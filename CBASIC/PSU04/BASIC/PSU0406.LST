   1: 0000: \***********************************************************************
   2: 0000: \***********************************************************************
   3: 0000: \***
   4: 0000: \***    PROGRAM         :       PSU04
   5: 0000: \***    DESCRIPTION     :       Event log viewer utility
   6: 0000: \***    AUTHOR          :       Mark Walker
   7: 0000: \***    DATE            :       26th September 2017
   8: 0000: \***
   9: 0000: \***********************************************************************
  10: 0000: \***********************************************************************
  11: 0000: \***
  12: 0000: \***    Module 6 contains the display handling for the details screen.
  13: 0000: \***
  14: 0000: \***********************************************************************
  15: 0000: \***********************************************************************
  16: 0000: \***
  17: 0000: \***    MODIFICATIONS
  18: 0000: \***
  19: 0000: \***    Version A.          Mark Walker                 26th Sep 2017
  20: 0000: \***    Initial version.
  21: 0000: \***
  22: 0000: \***    Version B.          Mark Walker                  6th Nov 2017
  23: 0000: \***    - Updated handling of bucket and source text descriptions.
  24: 0000: \***    - Use fast byte matching routine instead of MATCH statement
  25: 0000: \***      for performance reasons.
  26: 0000: \***
  27: 0000: \***    Version C.          Mark Walker                  6th Dec 2017
  28: 0000: \***    Relocated functions to this module and made public due to
  29: 0000: \***    the code module size limit being reached in the main display
  30: 0000: \***    manager screen handling module.
  31: 0000: \***
  32: 0000: \***    Version D.          Mark Walker                  6th Dec 2017
  33: 0000: \***    Relocated further functions to this module and made public
  34: 0000: \***    due to the code module size limit being reached again!
  35: 0000: \***
  36: 0000: \***    Version E.          Mark Walker                  6th Dec 2017
  37: 0000: \***    Corrected an array subscript out of bounds error when
  38: 0000: \***    attempting to search for a matching start/end program event
  39: 0000: \***    if either the selected start program event is the first entry
  40: 0000: \***    or the selected end program event is the last entry on the
  41: 0000: \***    summary screen.
  42: 0000: \***
  43: 0000: \***    Version F.          Mark Walker                 19th Mar 2018
  44: 0000: \***    - Added support for reporting application events logged by
  45: 0000: \***      all text file editors.
  46: 0000: \***    - Relocated further functions to this module and made public
  47: 0000: \***      due to the code module size limit being reached again!!
  48: 0000: \***
  49: 0000: \***********************************************************************
  50: 0000: \***********************************************************************
  51: 0000: 
  52: 0000: \***********************************************************************
  53: 0000: \***
  54: 0000: \***    Global variable declarations
  55: 0000: \***
  56: 0000: \***********************************************************************
  57: 0000: 
  58: 0000: %INCLUDE PSU04G.J86
  59: 0000: \***********************************************************************
  60: 0000: \***********************************************************************
  61: 0000: \***
  62: 0000: \***    GLOBAL VARIABLE DEFINITIONS FOR PSU04
  63: 0000: \***
  64: 0000: \***********************************************************************
  65: 0000: \***********************************************************************
  66: 0000: \***
  67: 0000: \***    MODIFICATIONS
  68: 0000: \***
  69: 0000: \***    Version A.          Mark Walker                 26th Sep 2017
  70: 0000: \***    Initial version.
  71: 0000: \***
  72: 0000: \***    Version B.          Mark Walker                  2nd Nov 2017
  73: 0000: \***    Added support for the source selection list.
  74: 0000: \***
  75: 0000: \***    Version C.          Mark Walker                  6th Nov 2017
  76: 0000: \***    Updated handling of bucket and source text descriptions.
  77: 0000: \***
  78: 0000: \***    Version D.          Mark Walker                 21st Nov 2017
  79: 0000: \***    Added support for the UTILS session screen.
  80: 0000: \***
  81: 0000: \***    Version E.          Mark Walker                  6th Dec 2017
  82: 0000: \***    Moved some local variables to globals to support moving
  83: 0000: \***    some functions from the main screen handling module to
  84: 0000: \***    an external subprogram.
  85: 0000: \***
  86: 0000: \***    Version F.          Mark Walker                 19th Mar 2017
  87: 0000: \***    Added support for reporting application events logged by
  88: 0000: \***    text file editor applications.
  89: 0000: \***
  90: 0000: \***********************************************************************
  91: 0000: \***********************************************************************
  92: 0000: 
  93: 0000:     INTEGER*1 GLOBAL CURRENT.FIELD%                                     !EMW
  94: 0000:     INTEGER*1 GLOBAL FALSE
  95: 0000:     INTEGER*1 GLOBAL OPEN.EVAPP
  96: 0000:     INTEGER*1 GLOBAL TRUE
  97: 0000:     INTEGER*1 GLOBAL U0401.APPLICATION%
  98: 0000:     INTEGER*1 GLOBAL U0401.APPLICATION.STATUS%
  99: 0000:     INTEGER*1 GLOBAL U0401.BUCKET%
 100: 0000:     INTEGER*1 GLOBAL U0401.BUCKET.STATUS%
 101: 0000:     INTEGER*1 GLOBAL U0401.CONTROLLER.ID%
 102: 0000:     INTEGER*1 GLOBAL U0401.CONTROLLER.ID.STATUS%
 103: 0000:     INTEGER*1 GLOBAL U0401.EVENT%
 104: 0000:     INTEGER*1 GLOBAL U0401.EVENT.STATUS%
 105: 0000:     INTEGER*1 GLOBAL U0401.LOG.DESC%
 106: 0000:     INTEGER*1 GLOBAL U0401.LOG.NUMBER%
 107: 0000:     INTEGER*1 GLOBAL U0401.MESSAGE.GROUP%
 108: 0000:     INTEGER*1 GLOBAL U0401.MESSAGE.GROUP.STATUS%
 109: 0000:     INTEGER*1 GLOBAL U0401.MESSAGE.NUMBER%
 110: 0000:     INTEGER*1 GLOBAL U0401.MESSAGE.NUMBER.STATUS%
 111: 0000:     INTEGER*1 GLOBAL U0401.SEVERITY%
 112: 0000:     INTEGER*1 GLOBAL U0401.SEVERITY.STATUS%
 113: 0000:     INTEGER*1 GLOBAL U0401.SOURCE%
 114: 0000:     INTEGER*1 GLOBAL U0401.SOURCE.STATUS%
 115: 0000:     INTEGER*1 GLOBAL U0401.TERMINAL%
 116: 0000:     INTEGER*1 GLOBAL U0401.TERMINAL.STATUS%
 117: 0000:     INTEGER*1 GLOBAL U0402.PAGE%
 118: 0000:     INTEGER*1 GLOBAL U0405.PAGE%
 119: 0000:     INTEGER*1 GLOBAL U0406.PAGE%
 120: 0000:     INTEGER*1 GLOBAL U0411.PAGE%                                        !BMW
 121: 0000:     INTEGER*1 GLOBAL U0412.PAGE%                                        !DMW
 122: 0000:     INTEGER*1 GLOBAL VALID.INPUT
 123: 0000:     INTEGER*1 GLOBAL VALID.KEY
 124: 0000: 
 125: 0000:     INTEGER*2 GLOBAL APPLICATIONS.PER.PAGE%
 126: 0000:     INTEGER*2 GLOBAL COMMAND.TIME.RANGE%
 127: 0000:     INTEGER*2 GLOBAL COMMANDS.PER.PAGE%
 128: 0000:     INTEGER*2 GLOBAL CURRENT.INDEX%                                     !EMW
 129: 0000:     INTEGER*2 GLOBAL CURRENT.REPORT.NUM%
 130: 0000:     INTEGER*2 GLOBAL EVENT.BUCKET%
 131: 0000:     INTEGER*2 GLOBAL EVENT.COUNT%
 132: 0000:     INTEGER*2 GLOBAL EVENT.DAY%
 133: 0000:     INTEGER*2 GLOBAL EVENT.FORMAT%
 134: 0000:     INTEGER*2 GLOBAL EVENT.HOUR%
 135: 0000:     INTEGER*2 GLOBAL EVENT.MESSAGE.NUMBER%
 136: 0000:     INTEGER*2 GLOBAL EVENT.MIN%
 137: 0000:     INTEGER*2 GLOBAL EVENT.MONTH%
 138: 0000:     INTEGER*2 GLOBAL EVENT.NODE.ID%
 139: 0000:     INTEGER*2 GLOBAL EVENT.NUMBER%
 140: 0000:     INTEGER*2 GLOBAL EVENT.SEVERITY%
 141: 0000:     INTEGER*2 GLOBAL EVENT.SOURCE%
 142: 0000:     INTEGER*2 GLOBAL EVENT.TERMINAL%
 143: 0000:     INTEGER*2 GLOBAL EVENT.YEAR%
 144: 0000:     INTEGER*2 GLOBAL FILES.PER.PAGE%
 145: 0000:     INTEGER*2 GLOBAL LINE.LENGTH%
 146: 0000:     INTEGER*2 GLOBAL MAX.FILE.RECORDS%
 147: 0000:     INTEGER*2 GLOBAL MAX.SOURCE.RECORDS%                                !BMW
 148: 0000:     INTEGER*2 GLOBAL NULL.MAPPING%                                      !BMW
 149: 0000:     INTEGER*2 GLOBAL RESULTS.COUNT%                                     !EMW
 150: 0000:     INTEGER*2 GLOBAL RESULTS.INDEX%                                     !EMW
 151: 0000:     INTEGER*2 GLOBAL RESULTS.LAST.PAGE%                                 !EMW
 152: 0000:     INTEGER*2 GLOBAL RESULTS.PAGE%                                      !EMW
 153: 0000:     INTEGER*2 GLOBAL RESULTS.PER.PAGE%
 154: 0000:     INTEGER*2 GLOBAL RESULTS.THIS.PAGE%                                 !EMW
 155: 0000:     INTEGER*2 GLOBAL RESULTS.TOTAL.PAGES%                               !EMW
 156: 0000:     INTEGER*2 GLOBAL SOURCES.PER.PAGE%                                  !BMW
 157: 0000:     INTEGER*2 GLOBAL ULOG.REPORT.NUM%                                   !DMW
 158: 0000:     INTEGER*2 GLOBAL ULOG.SESS.NUM%                                     !DMW
 159: 0000: 
 160: 0000:     INTEGER*4 GLOBAL EVENT.DATE%
 161: 0000:     INTEGER*4 GLOBAL EVENT.TIME%
 162: 0000: 
 163: 0000:     STRING GLOBAL ALL.APPLICATIONS.TEXT$
 164: 0000:     STRING GLOBAL ALL.BUCKETS.TEXT$
 165: 0000:     STRING GLOBAL ALL.CONTROLLERS.TEXT$
 166: 0000:     STRING GLOBAL ALL.EVENTS.TEXT$
 167: 0000:     STRING GLOBAL ALL.MESSAGE.GROUPS.TEXT$
 168: 0000:     STRING GLOBAL ALL.MESSAGE.NUMBERS.TEXT$
 169: 0000:     STRING GLOBAL ALL.SEVERITYS.TEXT$
 170: 0000:     STRING GLOBAL ALL.SOURCES.TEXT$
 171: 0000:     STRING GLOBAL ALL.TERMINALS.TEXT$
 172: 0000:     STRING GLOBAL BATCH.SCREEN.FLAG$
 173: 0000:     STRING GLOBAL BUCKET.TEXT$(1)
 174: 0000:     STRING GLOBAL CHAIN.TO.PROG$
 175: 0000:     STRING GLOBAL COMMENT$
 176: 0000:     STRING GLOBAL CONTROLLER.ID$
 177: 0000:     STRING GLOBAL CURRENT.CODE$
 178: 0000:     STRING GLOBAL DOW$(1)
 179: 0000:     STRING GLOBAL EDITOR.NAME$                                          !FMW
 180: 0000:     STRING GLOBAL EDITOR.PATHNAME$                                      !FMW
 181: 0000:     STRING GLOBAL EDITOR.PROGRAM$                                       !FMW
 182: 0000:     STRING GLOBAL EDITOR.TYPE$                                          !FMW
 183: 0000:     STRING GLOBAL EE$(1)
 184: 0000:     STRING GLOBAL EVENT.DOW$
 185: 0000:     STRING GLOBAL EVENT.MESSAGE.GROUP$
 186: 0000:     STRING GLOBAL EVENT.UNIQUE.DATA$
 187: 0000:     STRING GLOBAL FILE.OPERATION$
 188: 0000:     STRING GLOBAL HIGHWORD.DESCRIPTION$(1)
 189: 0000:     STRING GLOBAL HIGHWORD.ERRORCODE$(1)
 190: 0000:     STRING GLOBAL LA$(1)
 191: 0000:     STRING GLOBAL LE$(1)
 192: 0000:     STRING GLOBAL LJ$(1)
 193: 0000:     STRING GLOBAL LOG.DESC$
 194: 0000:     STRING GLOBAL LOG.NUMBER$
 195: 0000:     STRING GLOBAL LOWWORD.DESCRIPTION$(1)
 196: 0000:     STRING GLOBAL LOWWORD.ERRORCODE$(1)
 197: 0000:     STRING GLOBAL LW$(1)
 198: 0000:     STRING GLOBAL MESSAGE.TEXT$
 199: 0000:     STRING GLOBAL MODULE.NUMBER$
 200: 0000:     STRING GLOBAL NO.APPLICATIONS.TEXT$
 201: 0000:     STRING GLOBAL NO.BUCKETS.TEXT$
 202: 0000:     STRING GLOBAL NO.SEVERITYS.TEXT$
 203: 0000:     STRING GLOBAL NO.SOURCES.TEXT$                                      !BMW
 204: 0000:     STRING GLOBAL NONPRINTABLE.CHARS$
 205: 0000:     STRING GLOBAL NONPRINTABLE.MAP$
 206: 0000:     STRING GLOBAL NULL.FILENAME$
 207: 0000:     STRING GLOBAL NULL.PROGRAM$
 208: 0000:     STRING GLOBAL PID$
 209: 0000:     STRING GLOBAL PRINTABLE.CHARS$
 210: 0000:     STRING GLOBAL PROGRAM$
 211: 0000:     STRING GLOBAL R$(1)
 212: 0000:     STRING GLOBAL RETURN.CODE$
 213: 0000:     STRING GLOBAL RETURN.ERR$
 214: 0000:     STRING GLOBAL SE$(1)
 215: 0000:     STRING GLOBAL SELECTED.APPLICATIONS.TEXT$
 216: 0000:     STRING GLOBAL SELECTED.BUCKETS.TEXT$
 217: 0000:     STRING GLOBAL SELECTED.SEVERITYS.TEXT$
 218: 0000:     STRING GLOBAL SELECTED.SOURCES.TEXT$                                !BMW
 219: 0000:     STRING GLOBAL SEVERITY.TEXT$(1)
 220: 0000:     STRING GLOBAL SINGLE.APPLICATION.TEXT$
 221: 0000:     STRING GLOBAL SINGLE.BUCKET.TEXT$
 222: 0000:     STRING GLOBAL SINGLE.CONTROLLER.TEXT$
 223: 0000:     STRING GLOBAL SINGLE.EVENT.TEXT$
 224: 0000:     STRING GLOBAL SINGLE.MESSAGE.GROUP.TEXT$
 225: 0000:     STRING GLOBAL SINGLE.MESSAGE.NUMBER.TEXT$
 226: 0000:     STRING GLOBAL SINGLE.SEVERITY.TEXT$
 227: 0000:     STRING GLOBAL SINGLE.SOURCE.TEXT$
 228: 0000:     STRING GLOBAL SINGLE.TERMINAL.TEXT$
 229: 0000:     STRING GLOBAL SUMMARY.RECORD$(1)                                    !EMW
 230: 0000:     STRING GLOBAL SOURCE.TEXT$(1)                                       !CMW
 231: 0000:     STRING GLOBAL SS$(1)
 232: 0000:     STRING GLOBAL SW$(1)
 233: 0000:     STRING GLOBAL TILL.NUMBER$
 234: 0000:     STRING GLOBAL TS$(1)
 235: 0000:     STRING GLOBAL ULOG.FILE.NAME$                                       !DMW
 236: 0000:     STRING GLOBAL ULOG.RECORD$(1)                                       !EMW
 237: 0000: 
 238: 0000: %INCLUDE EVAPPDEC.J86                                                   !DMW
 239: 0000: \***********************************************************************
 240: 0000: \***********************************************************************
 241: 0000: \***
 242: 0000: \***    GLOBAL VARIABLE DEFINITIONS FOR EVENT APPLICATION FILE (EVAPP)
 243: 0000: \***
 244: 0000: \***********************************************************************
 245: 0000: \***********************************************************************
 246: 0000: \***
 247: 0000: \***    MODIFICATIONS
 248: 0000: \***
 249: 0000: \***    Version A.          Mark Walker                 18th Oct 2017
 250: 0000: \***    Initial version.
 251: 0000: \***
 252: 0000: \***********************************************************************
 253: 0000: \***********************************************************************
 254: 0000: 
 255: 0000:     INTEGER*2 GLOBAL EVAPP.RECL%
 256: 0000:     INTEGER*2 GLOBAL EVAPP.SESS.NUM%
 257: 0000:     INTEGER*2 GLOBAL EVAPP.REPORT.NUM%
 258: 0000: 
 259: 0000:     STRING GLOBAL EVAPP.FILE.NAME$
 260: 0000:     STRING GLOBAL EVAPP.PROGRAM$
 261: 0000:     STRING GLOBAL EVAPP.DESC$
 262: 0000:     STRING GLOBAL EVAPP.FILLER$
 263: 0000: 
 264: 0000: 
 265: 0000: \***********************************************************************
 266: 0000: \***
 267: 0000: \***    Function definitions
 268: 0000: \***
 269: 0000: \***********************************************************************
 270: 0000: 
 271: 0000: %INCLUDE BASROUT.J86                                                    !CMW
 272: 0000: \*LIB   BVEJ BASROUT  J86      03/11/97 08:16:26 PIDBLD3  *    FIX
 273: 0000: \*PROM  BVEJ BASROUT  J86      03/10/97 17:18:40 PIDBLD3  MVEJ IR34352
 274: 0000: \*RTIME BVEJ BASROUT  J86      03/10/97 17:18:41 PIDBLD3  MVEJ IR34352
 275: 0000: \*LIB   MVEJ BASROUT  J86      03/05/97 10:48:46 EDJRAL   *    IR34352
 276: 0000: \*LIB   MVEJ BASROUT  J86      02/17/97 11:19:56 EDJRAL   *    REASONAR
 277: 0000: \*LIB   MVEJ BASROUT  J86      02/14/97 15:59:11 EDJRAL   *    REASONAR
 278: 0000: ! BASROUT.J86 - this file is to be included in any BASIC code which utilizes
 279: 0000: !   the BASROUT.OBJ routines.  These routines were written
 280: 0000: !  using Metaware C and are intended to provide functions which
 281: 0000: !         are either not available in 4680 CBASIC or which can be more
 282: 0000: !               efficiently handled by the C language.  Their usage is
 283: 0000: !  offered on an "AT YOUR OWN RISK" basis.
 284: 0000: !
 285: 0000: !               The insert/extract routines usefulness may not be immediately
 286: 0000: !               apparent.  Their intention is that they be used in conjunction
 287: 0000: !               with a read/write form command.  They can more efficiently
 288: 0000: !               parse a string into many different variables than can the
 289: 0000: !               read form statement.  So instead of a long list of data var's
 290: 0000: !               it may be more efficient to just read/write one long string
 291: 0000: !               and then use the insert/extract routines to parse out the
 292: 0000: !   data.
 293: 0000: 
 294: 0000: ! ******************* SUB PROCESS FUNCTIONS *********************************
 295: 0000: 
 296: 0000: function osshell(cmd.line$) external   ! routine to start
 297: 0000:        ! another program.
 298: 0000:            integer*4    osshell    ! Upon completion of
 299: 0000:            string       cmd.line$   ! program, control is
 300: 0000:        ! returned to calling
 301: 0000: end function      ! program.
 302: 0000: !
 303: 0000: ! NOTES:  Program must be a 286 type file.  This does not exclude
 304: 0000: !         the capability to execute a batch file however.  Simply pass the
 305: 0000: !         following:
 306: 0000: !              c:\adx_spgm\command.286 batfile
 307: 0000: !         where batfile is the name of the batch file to be executed.
 308: 0000: !
 309: 0000: ! IMPORTANT: When using osshell to execute a batch file as described above,
 310: 0000: !            the final command in the batch file must be "exit".  If not,
 311: 0000: !       control is never given back to the calling program.
 312: 0000: 
 313: 0000: ! ************************ MEMORY RELATED FUNCTIONS ************************
 314: 0000: 
 315: 0000: function memfree(choice) external   ! routine to que the
 316: 0000:        ! status of the
 317: 0000:  integer*4 memfree    ! machine's memory:
 318: 0000:  integer*2 choice    ! Options:
 319: 0000:        !    1 - free
 320: 0000: end function      !    2 - total
 321: 0000:        !    3 - system
 322: 0000: 
 323: 0000: ! ********************** TIMEDATE RELATED FUNCTIONS ************************
 324: 0000: 
 325: 0000: function timedate(choice) external   ! routine to que the
 326: 0000:        ! OS's timedate table
 327: 0000:  integer*4 timedate   ! Choices:
 328: 0000:  integer*2 choice    !    1 - millisec's
 329: 0000:        !        since midnight
 330: 0000: end function      !    2 - minutes from
 331: 0000:        !  UCT (timezone)
 332: 0000:        !    3 - day of week
 333: 0000:        !   0-Sunday
 334: 0000:        !  6-Saturday
 335: 0000: 
 336: 0000: function settime(msecs) external   ! routine to set the
 337: 0000:        ! time on the controller
 338: 0000:  integer*4  settime    ! msecs is the desired
 339: 0000:  integer*4 msecs    ! number of milliseconds
 340: 0000:        ! since midnight
 341: 0000: end function      ! Returns negative on
 342: 0000:        ! error
 343: 0000: ! NOTE:  This routine sets the time only on the controller.  The terminals'
 344: 0000: ! time will not be updated until 1 AM or unless a terminal is STC'd.
 345: 0000: ! At 1 AM the controller broadcasts the new time to all terminals.
 346: 0000: ! Insure this is taken into consideration when using this routine.
 347: 0000: 
 348: 0000: !******************** DISK FILE RELATED FUNCTIONS *************************
 349: 0000: 
 350: 0000: function truncate(name,length) external   ! routine to truncate
 351: 0000:        ! the specified file
 352: 0000:  integer*4 truncate   ! to a given length.
 353: 0000:  string  name
 354: 0000:  integer*4 length
 355: 0000: 
 356: 0000: end function
 357: 0000: 
 358: 0000: !******************** STRING VALUE RELATED FUNCTIONS **********************
 359: 0000: 
 360: 0000: function isalpha(bstrn) external   ! routine to identify
 361: 0000:        ! if the specified
 362: 0000:  integer*1 isalpha    ! string contains all
 363: 0000:  string  bstrn    ! alphabetic char's
 364: 0000:        ! Returns:
 365: 0000: end function      !     0 - all alpha
 366: 0000:        !     X - byte of 1st
 367: 0000:        !         non-alpha
 368: 0000:        !   char
 369: 0000: 
 370: 0000: function isdigit(bstrn) external   ! routine to identify
 371: 0000:        ! if the specified
 372: 0000:  integer*1 isdigit    ! string contains all
 373: 0000:  string  bstrn    ! numeric char's
 374: 0000:        ! Returns:
 375: 0000: end function      !     0 - all numeric
 376: 0000:        !     X - byte of 1st
 377: 0000:        !         non-numeric
 378: 0000:        !   char
 379: 0000: 
 380: 0000: function islower(bstrn) external   ! routine to identify
 381: 0000:        ! if the specified
 382: 0000:  integer*1 islower    ! string contains all
 383: 0000:  string  bstrn    ! lower case char's
 384: 0000:        ! Returns:
 385: 0000: end function      !     0 - all lowercase
 386: 0000:        !     X - byte of 1st
 387: 0000:        !         non-lowercase
 388: 0000:        !   char
 389: 0000: 
 390: 0000: function isupper(bstrn) external   ! routine to identify
 391: 0000:        ! if the specified
 392: 0000:  integer*1 isupper    ! string contains all
 393: 0000:  string  bstrn    ! upper case char's
 394: 0000:        ! Returns:
 395: 0000: end function      !     0 - all uppercase
 396: 0000:        !     X - byte of 1st
 397: 0000:        !         non-uppercase
 398: 0000:        !   char
 399: 0000: 
 400: 0000: function toalpha(bstrn) external   ! routine to convert
 401: 0000:        ! non-alpha or non-num
 402: 0000:    integer*2 toalpha    ! char's to spaces
 403: 0000:  string  bstrn    ! Returns:
 404: 0000: end function      !   x - no. of char's
 405: 0000:        !       changed
 406: 0000: 
 407: 0000: ! ********************* USER/GROUP ZERO LEVEL FUNCTIONS *********************
 408: 0000: 
 409: 0000: function idlecount(choice) external   ! routine to either
 410: 0000:        ! set to zero or queue
 411: 0000:  integer*4 idlecount   ! the value of the
 412: 0000:  integer*1 choice    ! processor's idlecount
 413: 0000:        ! Choice:
 414: 0000: end function      !     0 - set to zero
 415: 0000: !       !     1 - get value
 416: 0000: ! NEEDS USER/GROUP 0 LEVEL OF AUTHORIZATION  ! Returns:
 417: 0000: ! TO WORK - This level is not available unless  !     X - idlecount
 418: 0000: ! the file ADXCSOUF.DAT file is "patched".  This !    -X - error code
 419: 0000: ! is highly unrecommended.
 420: 0000: 
 421: 0000: function logical(actname,logname,choice) external ! routine to set a
 422: 0000:        ! a logical name.
 423: 0000:  integer*4 logical    ! parms are self
 424: 0000:         string  logname    ! explanatory except
 425: 0000:  string  actname    ! for choice:
 426: 0000:  integer*1 choice    !   0 - set process
 427: 0000:        !   1 - set system
 428: 0000: end function      !   2 - get process
 429: 0000:        !   3 - get system
 430: 0000: 
 431: 0000: ! NOTE:  Only the setting of a system level of logical name requires
 432: 0000: ! user/group zero level of authorization.  Any application may query any
 433: 0000: ! logical name.  Setting of a system logical name is only applicable until
 434: 0000: ! the system is IPL'd.  A process logical name is only active when that
 435: 0000: ! process is active.
 436: 0000: 
 437: 0000: !******************** STRING PARSING FUNCTIONS *****************************
 438: 0000: 
 439: 0000: function inserts(whole,part,offset) external  ! routine to insert a
 440: 0000:        ! string (part) into
 441: 0000:  integer*2 INSERTS    ! another string (whole)
 442: 0000:  string  whole    ! starting at specified
 443: 0000:  string  part    ! character (offset)
 444: 0000:  integer*2 offset
 445: 0000: 
 446: 0000: end function
 447: 0000: 
 448: 0000: function cinsert4(integer4,bstring,offset) external   ! routine to insert
 449: 0000:        ! a 4-byte integer into
 450: 0000:  integer*1 cinsert4   ! a string starting at
 451: 0000:  integer*4 integer4   ! byte specified by
 452: 0000:  string  bstring    ! offset (1-based)
 453: 0000:  integer*2 offset    ! Returns:
 454: 0000:        !     0 - Success
 455: 0000: end function      !    -1 - String overrun
 456: 0000: 
 457: 0000: function cinsert2(integer2,bstring,offset) external  ! routine to insert
 458: 0000:        ! a 2-byte integer into
 459: 0000:  integer*1 cinsert2   ! a string starting at
 460: 0000:  integer*2 integer2   ! byte specified by
 461: 0000:  string  bstring    ! offset (1-based)
 462: 0000:  integer*2 offset    ! Returns:
 463: 0000:        !     0 - Success
 464: 0000: end function      !    -1 - String overrun
 465: 0000: 
 466: 0000: function cinsert1(bstring,integer1,offset) external  ! routine to insert
 467: 0000:        ! a 1-byte integer into
 468: 0000:  integer*1 cinsert1   ! a string starting at
 469: 0000:  integer*1 integer1   ! byte specified by
 470: 0000:  string  bstring    ! offset (1-based)
 471: 0000:  integer*2 offset    ! Returns:
 472: 0000:        !     0 - Success
 473: 0000: end function      !    -1 - String overrun
 474: 0000: 
 475: 0000: function extracts(whole,part,offset) external  ! routine to extract a
 476: 0000:        ! string (part) from
 477: 0000:  integer*2 EXTRACTS   ! another string (whole)
 478: 0000:  string  whole    ! starting at specified
 479: 0000:  string  part    ! character (offset)
 480: 0000:  integer*2 offset
 481: 0000: 
 482: 0000: end function
 483: 0000: 
 484: 0000: function cextract4(bstring,offset) external  ! routine to extract
 485: 0000:        ! a 4-byte integer from
 486: 0000:  integer*4 cextract4   ! a string starting at
 487: 0000:                        ! byte specified by
 488: 0000:  string  bstring    ! offset (1-based)
 489: 0000:  integer*2 offset    ! Returns:
 490: 0000:        !     X - 4 byte integer
 491: 0000: end function      !    -1 - String overrun
 492: 0000: 
 493: 0000: function cextract2(bstring,offset) external  ! routine to extract
 494: 0000:        ! a 2-byte integer from
 495: 0000:  integer*2 cextract2   ! a string starting at
 496: 0000:                        ! byte specified by
 497: 0000:  string  bstring    ! offset (1-based)
 498: 0000:  integer*2 offset    ! Returns:
 499: 0000:        !     X - 2 byte integer
 500: 0000: end function      !    -1 - String overrun
 501: 0000: 
 502: 0000: function cextract1(bstring,offset) external  ! routine to extract
 503: 0000:        ! a 1-byte integer from
 504: 0000:  integer*1 cextract1   ! a string starting at
 505: 0000:                        ! byte specified by
 506: 0000:  string  bstring    ! offset (1-based)
 507: 0000:  integer*2 offset    ! Returns:
 508: 0000:        !     X - 1 byte integer
 509: 0000: end function      !    -1 - String overrun
 510: 0000: 
 511: 0000: 
 512: 0000: function srchdir (file.name$,dtbl.buffer$) external ! routine to return
 513: 0000:        ! file names and sizes
 514: 0000:        ! Return values:
 515: 0000:        !    -1  no matches
 516: 0000:        !        found on first
 517: 0000:        !        call
 518: 0000:        !    0   no matches
 519: 0000:        !        found on sub-
 520: 0000:        !        sequent calls
 521: 0000:        !    Pos Success
 522: 0000:        !    Neg OS Rtn Code
 523: 0000: ! Usage Note:  If searching for all occurences of a particular file name,
 524: 0000: ! first initialize dtbl.buffer$ to 48 Nulls (pack$("00")) and issue a call
 525: 0000: ! to srchdir.  If any matches are found, a positive value will be returned.
 526: 0000: ! To see if any more matches exist, just issue another call to srchdir without
 527: 0000: ! resetting the values of dtbl.buffer$.  If any are found, a positive value
 528: 0000: ! will be returned.  This can be repeated until a Zero is returned.  All data
 529: 0000: ! describing file will be returned in the dtbl.buffer$ after each call.  Format
 530: 0000: ! of this data is defined below.
 531: 0000: 
 532: 0000:  integer*4 srchdir
 533: 0000: 
 534: 0000:  string  file.name$   ! file name to start
 535: 0000:        ! search (18 bytes max)
 536: 0000:        ! Wild cards and logical
 537: 0000:        ! names supported.
 538: 0000: 
 539: 0000:  string  dtbl.buffer$   ! must be initialized
 540: 0000:        ! to 48 bytes.  Contains
 541: 0000:        ! all of directory info
 542: 0000:        ! Initialize to nulls
 543: 0000:        ! each time a new file
 544: 0000:        ! name is used.
 545: 0000: 
 546: 0000: ! NOTE:  Format of dtbl.buffer$ string is as follows:
 547: 0000: !
 548: 0000: ! Offs  Type                    Description Notes
 549: 0000: !  0 integer*4  key  use extract4 to access
 550: 0000: !  4  string (18 bytes) file name
 551: 0000: ! 22 integer*2  attributes use extract2 to access
 552: 0000: !      0x01 - Read Only
 553: 0000: !      0x02 - Hidden
 554: 0000: !      0x04 - System
 555: 0000: !      0x08 - Volume Label
 556: 0000: !      0x10 - Subdirectory
 557: 0000: !      0x20 - Archive (Files)
 558: 0000: !      0x40 - Security enabled
 559: 0000: !      0x80 - Reserved
 560: 0000: !      0x0000 - Local
 561: 0000: !      0x4000 - Mirrored/Update
 562: 0000: !      0xC000 - Mirrored/Close
 563: 0000: !
 564: 0000: !      0x6000 - Compound/Update
 565: 0000: !      0xE000 - Compound/Close
 566: 0000: ! 24 integer*2  record size use extract2 to access
 567: 0000: ! 26 integer*1  User ID of Owner
 568: 0000: ! 27 integer*1  Group ID of Owner
 569: 0000: ! 28 integer*2  File Security
 570: 0000: ! 30 string (6 bytes) Reserved
 571: 0000: ! 36 integer*4  File Size use extract4 to access
 572: 0000: ! 40 integer*2  Year  use extract2 to access
 573: 0000: ! 42 integer*1  Month
 574: 0000: ! 43 integer*1  Day
 575: 0000: ! 44 integer*1  Hour
 576: 0000: ! 45 integer*1  Minute
 577: 0000: ! 46 integer*1  Second
 578: 0000: ! 47 integer*1  Reserved
 579: 0000: 
 580: 0000: end function
 581: 0000: 
 582: 0000: function srchproc (proc.name$,ptbl.buffer$) external ! routine to return
 583: 0000:        ! process names and
 584: 0000:        ! status.  Handy to
 585: 0000:        ! determine if a
 586: 0000:        ! program is currently
 587: 0000:        ! running.
 588: 0000:        ! Return values:
 589: 0000:        !    -1  no matches
 590: 0000:        !        found on first
 591: 0000:        !        call
 592: 0000:        !    0   no matches
 593: 0000:        !        found on sub-
 594: 0000:        !        sequent calls
 595: 0000:        !    Pos Success
 596: 0000:        !    Neg Failure
 597: 0000:        !        OS Rtn Code
 598: 0000:        ! 80000001h - Insuff
 599: 0000:         !        ptbl buffer
 600: 0000:        !        Length
 601: 0000: ! Usage Note:  If searching for all occurences of a particular process name,
 602: 0000: ! first initialize ptbl.buffer$ to 60 Nulls (pack$("00")) and issue a call
 603: 0000: ! to srchproc.  If any matches are found, a positive value will be returned.
 604: 0000: ! To see if any more matches exist, just issue another call to srchproc without
 605: 0000: ! resetting the values of ptbl.buffer$.  If any are found, a positive value
 606: 0000: ! will be returned.  This can be repeated until a Zero is returned.  All data
 607: 0000: ! describing file will be returned in the ptbl.buffer$ after each call.  Format
 608: 0000: ! of this data is defined as follows:
 609: 0000: !
 610: 0000: !       --------------------------------------------------------
 611: 0000: !   0   |                         PID                          |
 612: 0000: !       --------------------------------------------------------
 613: 0000: !   4   |           FID             |   CID        |   VCID    |
 614: 0000: !       --------------------------------------------------------
 615: 0000: !   8   |                         NAME                         |
 616: 0000: !       --------------------------------------------------------
 617: 0000: !  12   |                         NAME cont'd                  |
 618: 0000: !       --------------------------------------------------------
 619: 0000: !  16   |       NAME cont'd         |   STATE      |  PRIOR    |
 620: 0000: !       --------------------------------------------------------
 621: 0000: !  20   |                         MAXMEM                       |
 622: 0000: !       --------------------------------------------------------
 623: 0000: !  24   |       FLAGS               |   USER        |  GROUP   |
 624: 0000: !       --------------------------------------------------------
 625: 0000: !  28   |                         PARENT                       |
 626: 0000: !       --------------------------------------------------------
 627: 0000: !  32   |                         EVENTS                       |
 628: 0000: !       --------------------------------------------------------
 629: 0000: !  36   |                         CODE                         |
 630: 0000: !       --------------------------------------------------------
 631: 0000: !  40   |                         CSIZE                        |
 632: 0000: !       --------------------------------------------------------
 633: 0000: !  44   |                         DATA                         |
 634: 0000: !       --------------------------------------------------------
 635: 0000: !  48   |                         DSIZE                        |
 636: 0000: !       --------------------------------------------------------
 637: 0000: !  52   |                         HEAP                         |
 638: 0000: !       --------------------------------------------------------
 639: 0000: !  56   |                         HSIZE                        |
 640: 0000: !       --------------------------------------------------------
 641: 0000: !
 642: 0000: !       PID   Process ID
 643: 0000: !       FID  Process's Family ID
 644: 0000: !       CID   Physical Console Device Number
 645: 0000: !       VCID  Process's Virtual Console Number
 646: 0000: !       NAME  Process Name (Application Running)
 647: 0000: ! STATE    Process State (0-Run, 1-Waiting, 2-Terminating)
 648: 0000: ! PRIOR    Priority
 649: 0000: !       MAXMEM  Maximum Memory Allowed
 650: 0000: !       FLAGS  Bit 0 (1-System Process, 0-User Process)
 651: 0000: !   Bit 1 (1-Locked in Memory, 0-Swappable)
 652: 0000: !   Bit 2 (1-Running in SWI context, 0-Running in main context)
 653: 0000: !   Bit 3 (1-Superuser Process,0-Not a Superuser Process)
 654: 0000: ! USER  User Number
 655: 0000: ! GROUP  Group Number
 656: 0000: !       PARENT   Parent Process ID
 657: 0000: !       EVENTS   Bit Map of events that have completed but not retrieved
 658: 0000: !       CODE  Start of code area in user space
 659: 0000: ! CSIZE  Size in bytes of code area
 660: 0000: !       DATA  Start of data area in user space
 661: 0000: ! DSIZE  Size in bytes of data area
 662: 0000: !       HEAP  Start of heap area in user space
 663: 0000: ! HSIZE  Size in bytes of heap area
 664: 0000: !
 665: 0000:  integer*4 srchproc
 666: 0000: 
 667: 0000:  string  proc.name$   ! process name to start
 668: 0000:        ! search (10 bytes max)
 669: 0000:        ! Wild cards and logical
 670: 0000:        ! names supported.
 671: 0000: 
 672: 0000:  string  ptbl.buffer$   ! must be initialized
 673: 0000:        ! to 60 bytes.  Contains
 674: 0000:        ! all of process info
 675: 0000:        ! Initialize to nulls
 676: 0000:        ! each time a new
 677: 0000:        ! process name is used.
 678: 0000: 
 679: 0000: end function
 680: 0000: 
 681: 0000: function cconstat(timeout) external       ! function similar
 682: 0000:                                               ! to BASIC constat%
 683: 0000:  integer*2 cconstat   ! waits for either a
 684: 0000:  integer*4 timeout    ! key being hit or
 685: 0000:        ! the timer expiring
 686: 0000:        ! before returning
 687: 0000:        ! returns:
 688: 0000:        !   -1 error
 689: 0000:        !    0 timer expired
 690: 0000:        !    x scan code of
 691: 0000:        !      key hit
 692: 0000: end function
 693: 0000: 
 694: 0000: function disksize(disk.name$) external   ! function to find
 695: 0000:        ! the total size of
 696: 0000:  integer*4 disksize   ! the specified disk
 697: 0000:  string  disk.name$   ! name (e.g. "h0:")
 698: 0000:        ! if return value is
 699: 0000:        ! negative, error
 700: 0000: end function      ! was received
 701: 0000: 
 702: 0000: 
 703: 0000: %INCLUDE BTCMEM.J86                                                     !CMW
 704: 0000: !********************************************************************
 705: 0000: !***
 706: 0000: !***    INCLUDED CODE:  BTCMEM.J86
 707: 0000: !***    AUTHOR:         Stuart William McConnachie
 708: 0000: !***    DATE:           26th February 2006
 709: 0000: !***
 710: 0000: !********************************************************************
 711: 0000: !***
 712: 0000: !***    Controller CBASIC Memory Functions
 713: 0000: !***
 714: 0000: !********************************************************************
 715: 0000: 
 716: 0000: !Get a single byte integer from a string offset
 717: 0000: FUNCTION GETN1 (S$, P%) EXTERNAL
 718: 0000:     STRING S$
 719: 0000:     INTEGER*2 P%
 720: 0000:     INTEGER*2 GETN1
 721: 0000: END FUNCTION
 722: 0000: 
 723: 0000: !Get a two byte integer from a string offset
 724: 0000: FUNCTION GETN2 (S$, P%) EXTERNAL
 725: 0000:     STRING S$
 726: 0000:     INTEGER*2 P%
 727: 0000:     INTEGER*2 GETN2
 728: 0000: END FUNCTION
 729: 0000: 
 730: 0000: !Get a four byte integer from a string offset
 731: 0000: FUNCTION GETN4 (S$, P%) EXTERNAL
 732: 0000:     STRING S$
 733: 0000:     INTEGER*2 P%
 734: 0000:     INTEGER*4 GETN4
 735: 0000: END FUNCTION
 736: 0000: 
 737: 0000: !Get a 10 byte CBASIC real from a string offset
 738: 0000: FUNCTION GETR10 (S$, P%) EXTERNAL
 739: 0000:     STRING S$
 740: 0000:     INTEGER*2 P%
 741: 0000:     REAL GETR10
 742: 0000: END FUNCTION
 743: 0000: 
 744: 0000: !Put a single byte integer into a string at offset
 745: 0000: FUNCTION PUTN1 (S$, P%, N%) EXTERNAL
 746: 0000:     STRING S$
 747: 0000:     INTEGER*2 P%
 748: 0000:     INTEGER*1 N%
 749: 0000:     INTEGER*1 PUTN1
 750: 0000: END FUNCTION
 751: 0000: 
 752: 0000: !Put a two byte integer into a string at offset
 753: 0000: FUNCTION PUTN2 (S$, P%, N%) EXTERNAL
 754: 0000:     STRING S$
 755: 0000:     INTEGER*2 P%
 756: 0000:     INTEGER*2 N%
 757: 0000:     INTEGER*1 PUTN2
 758: 0000: END FUNCTION
 759: 0000: 
 760: 0000: !Put a four byte integer into a string at offset
 761: 0000: FUNCTION PUTN4 (S$, P%, N%) EXTERNAL
 762: 0000:     STRING S$
 763: 0000:     INTEGER*2 P%
 764: 0000:     INTEGER*4 N%
 765: 0000:     INTEGER*1 PUTN4
 766: 0000: END FUNCTION
 767: 0000: 
 768: 0000: !Put a 10 byte CBASIC real into a string at offset
 769: 0000: FUNCTION PUTR10 (S$, P%, R) EXTERNAL
 770: 0000:     STRING S$
 771: 0000:     INTEGER*2 P%
 772: 0000:     REAL R
 773: 0000:     INTEGER*1 PUTR10
 774: 0000: END FUNCTION
 775: 0000: 
 776: 0000: !Peek a two byte integer from a memory address
 777: 0000: FUNCTION PEEKN2 (A%) EXTERNAL
 778: 0000:     INTEGER*4 A%
 779: 0000:     INTEGER*2 PEEKN2
 780: 0000: END FUNCTION
 781: 0000: 
 782: 0000: !Peek a four byte integer from a memory address
 783: 0000: FUNCTION PEEKN4 (A%) EXTERNAL
 784: 0000:     INTEGER*4 A%
 785: 0000:     INTEGER*4 PEEKN4
 786: 0000: END FUNCTION
 787: 0000: 
 788: 0000: !Peek a 10 byte CBASIC real from a memory address
 789: 0000: FUNCTION PEEKR10 (A%) EXTERNAL
 790: 0000:     INTEGER*4 A%
 791: 0000:     REAL PEEKR10
 792: 0000: END FUNCTION
 793: 0000: 
 794: 0000: !Poke a two byte integer to a memory address
 795: 0000: FUNCTION POKEN2 (A%, N%) EXTERNAL
 796: 0000:     INTEGER*4 A%
 797: 0000:     INTEGER*2 N%
 798: 0000:     INTEGER*1 POKEN2
 799: 0000: END FUNCTION
 800: 0000: 
 801: 0000: !Poke a four byte integer to a memory address
 802: 0000: FUNCTION POKEN4 (A%, N%) EXTERNAL
 803: 0000:     INTEGER*4 A%
 804: 0000:     INTEGER*4 N%
 805: 0000:     INTEGER*1 POKEN4
 806: 0000: END FUNCTION
 807: 0000: 
 808: 0000: !Poke a 10 byte CBASIC real to a memory address
 809: 0000: FUNCTION POKER10 (A%, R) EXTERNAL
 810: 0000:     INTEGER*4 A%
 811: 0000:     REAL R
 812: 0000:     INTEGER*1 POKER10
 813: 0000: END FUNCTION
 814: 0000: 
 815: 0000: %INCLUDE STREXT.J86                                                     !CMW
 816: 0000: \*******************************************************************************
 817: 0000: \*******************************************************************************
 818: 0000: \***
 819: 0000: \***    REFERENCE   :   STREXT
 820: 0000: \***
 821: 0000: \*******************************************************************************
 822: 0000: \***
 823: 0000: \***    OVERVIEW:
 824: 0000: \***
 825: 0000: \***    This module contains common external function and subprogram
 826: 0000: \***    definitions used for string processing.
 827: 0000: \***
 828: 0000: \***    CONTENTS:
 829: 0000: \***
 830: 0000: \***    RTRIM$ - Removes the specified trailing character from a string
 831: 0000: \***    LTRIM$ - Removes the specified leading character from a string
 832: 0000: \***    TRIM$  - Removes the specified leading and trailing character
 833: 0000: \***             from a string
 834: 0000: \***
 835: 0000: \*******************************************************************************
 836: 0000: \***
 837: 0000: \***    MODIFICATIONS:
 838: 0000: \***
 839: 0000: \***    Version A.              Mark Walker                     24th Jul 2015
 840: 0000: \***    Initial version.
 841: 0000: \***
 842: 0000: \***    Version B.              Mark Walker                     24th Nov 2016
 843: 0000: \***    Added TRIM$ function.
 844: 0000: \***
 845: 0000: \*******************************************************************************
 846: 0000: \*******************************************************************************
 847: 0000: 
 848: 0000: FUNCTION RTRIM$(SOURCE$,TRIM.CHAR$) EXTERNAL
 849: 0000:     STRING    TRIM.CHAR$
 850: 0000:     STRING    SOURCE$
 851: 0000:     STRING    RTRIM$
 852: 0000: END FUNCTION
 853: 0000: 
 854: 0000: FUNCTION LTRIM$(SOURCE$,TRIM.CHAR$) EXTERNAL
 855: 0000:     STRING    TRIM.CHAR$
 856: 0000:     STRING    SOURCE$
 857: 0000:     STRING    LTRIM$
 858: 0000: END FUNCTION
 859: 0000: 
 860: 0000: FUNCTION TRIM$(SOURCE$,TRIM.CHAR$) EXTERNAL                             !BMW
 861: 0000:     STRING    TRIM.CHAR$                                                !BMW
 862: 0000:     STRING    SOURCE$                                                   !BMW
 863: 0000:     STRING    TRIM$                                                     !BMW
 864: 0000: END FUNCTION                                                            !BMW
 865: 0000: 
 866: 0000: 
 867: 0000: %INCLUDE EVAPPEXT.J86   ! Event application file                        !DMW
 868: 0000: \***********************************************************************
 869: 0000: \***********************************************************************
 870: 0000: \***
 871: 0000: \***    EXTERNAL FUNCTION DEFINITIONS FOR EVENT APPLICATION FILE (EVAPP)
 872: 0000: \***
 873: 0000: \***********************************************************************
 874: 0000: \***********************************************************************
 875: 0000: \***
 876: 0000: \***    MODIFICATIONS
 877: 0000: \***
 878: 0000: \***    Version A.          Mark Walker                 18th Oct 2017
 879: 0000: \***    Initial version.
 880: 0000: \***
 881: 0000: \***********************************************************************
 882: 0000: \***********************************************************************
 883: 0000: 
 884: 0000: FUNCTION EVAPP.SET EXTERNAL
 885: 0000: END FUNCTION
 886: 0000: 
 887: 0000: FUNCTION READ.EVAPP EXTERNAL
 888: 0000: INTEGER*1 READ.EVAPP
 889: 0000: END FUNCTION
 890: 0000: 
 891: 0000: FUNCTION WRITE.EVAPP EXTERNAL
 892: 0000: INTEGER*1 WRITE.EVAPP
 893: 0000: END FUNCTION
 894: 0000: 
 895: 0000: 
 896: 0000: FUNCTION MATCHB(P1$,P2$,P3) EXTERNAL                                    !BMW
 897: 0000:     INTEGER*2 MATCHB                                                    !BMW
 898: 0000:     STRING P1$                                                          !BMW
 899: 0000:     STRING P2$                                                          !BMW
 900: 0000:     INTEGER*2 P3                                                        !BMW
 901: 0000: END FUNCTION                                                            !BMW
 902: 0000: 
 903: 0000: \***********************************************************************!CMW
 904: 0000: \***                                                                    !CMW
 905: 0000: \***    ?VAL                                                            !CMW
 906: 0000: \***                                                                    !CMW
 907: 0000: \***********************************************************************!CMW
 908: 0000: \***                                                                    !CMW
 909: 0000: \***    Performs VAL function with an error trap for IH errors          !CMW
 910: 0000: \***                                                                    !CMW
 911: 0000: \***********************************************************************!CMW
 912: 0000: FUNCTION ?VAL(S$) PUBLIC                                                !CMW
 913: 0029:     INTEGER*4 ?VAL                                                      !CMW
 914: 0029:     STRING S$                                                           !CMW
 915: 0029:                                                                         !CMW
 916: 0029:     ON ERROR GOTO VAL.ERROR                                             !CMW
 917: 003e:                                                                         !CMW
 918: 003e:     ?VAL = VAL(S$)                                                      !CMW
 919: 005f:                                                                         !CMW
 920: 005f:     EXIT FUNCTION                                                       !CMW
 921: 0069:                                                                         !CMW
 922: 0069: EXIT.VAL:                                                               !CMW
 923: 0079:                                                                         !CMW
 924: 0079:     ?VAL = 0                                                            !CMW
 925: 008f:                                                                         !CMW
 926: 008f:     EXIT FUNCTION                                                       !CMW
 927: 0099:                                                                         !CMW
 928: 0099: VAL.ERROR:                                                              !CMW
 929: 00a9:                                                                         !CMW
 930: 00a9:     ! Trap IH errors                                                    !CMW
 931: 00a9:     RESUME EXIT.VAL                                                     !CMW
 932: 00c0:                                                                         !CMW
 933: 00c0: END FUNCTION                                                            !CMW
 934: 00df:                                                                         !CMW
 935: 00df: \********************************************************************** !CMW
 936: 00df: \***                                                                    !CMW
 937: 00df: \***    READ.ULOG                                                       !CMW
 938: 00df: \***                                                                    !CMW
 939: 00df: \********************************************************************** !CMW
 940: 00df: \***                                                                    !CMW
 941: 00df: \***    Read record from UTILS log file                                 !CMW
 942: 00df: \***                                                                    !CMW
 943: 00df: \********************************************************************** !CMW
 944: 00df: FUNCTION READ.ULOG PUBLIC                                               !CMW
 945: 0103:     INTEGER*1 READ.ULOG                                                 !CMW
 946: 0103:                                                                         !CMW
 947: 0103:     ON ERROR GOTO ULOG.READ.ERROR                                       !CMW
 948: 0118:                                                                         !CMW
 949: 0118:     READ.ULOG = 1                                                       !CMW
 950: 0124:                                                                         !CMW
 951: 0124:     ! Read next UTILS log record                                        !CMW
 952: 0124:     READ MATRIX #ULOG.SESS.NUM%; ULOG.RECORD$(1),4                      !CMW
 953: 014c:                                                                         !CMW
 954: 014c:     READ.ULOG = 0                                                       !CMW
 955: 0158:                                                                         !CMW
 956: 0158: EXIT.READ.ULOG:                                                         !CMW
 957: 0168:                                                                         !CMW
 958: 0168:     EXIT FUNCTION                                                       !CMW
 959: 0172:                                                                         !CMW
 960: 0172: ULOG.READ.ERROR:                                                        !CMW
 961: 0182:                                                                         !CMW
 962: 0182:     RESUME EXIT.READ.ULOG                                               !CMW
 963: 0199:                                                                         !CMW
 964: 0199: END FUNCTION                                                            !CMW
 965: 01b0:                                                                         !CMW
 966: 01b0: \***********************************************************************!CMW
 967: 01b0: \***                                                                    !CMW
 968: 01b0: \***    PAD$                                                            !CMW
 969: 01b0: \***                                                                    !CMW
 970: 01b0: \***********************************************************************!CMW
 971: 01b0: \***                                                                    !CMW
 972: 01b0: \***    Pads a numeric string with leading zeros                        !CMW
 973: 01b0: \***                                                                    !CMW
 974: 01b0: \***********************************************************************!CMW
 975: 01b0: FUNCTION PAD$(S$,N%) PUBLIC                                             !CMW
 976: 01d9:                                                                         !CMW
 977: 01d9:     STRING PAD$,S$                                                      !CMW
 978: 01d9:     INTEGER*2 N%                                                        !CMW
 979: 01d9:                                                                         !CMW
 980: 01d9:     PAD$ = RIGHT$(STRING$(N%,"0") + S$,N%)                              !CMW
 981: 0222:                                                                         !CMW
 982: 0222: END FUNCTION                                                            !CMW
 983: 0240:                                                                         !CMW
 984: 0240: \***********************************************************************!CMW
 985: 0240: \***                                                                    !CMW
 986: 0240: \***    ASC.TEXT$                                                       !CMW
 987: 0240: \***                                                                    !CMW
 988: 0240: \***********************************************************************!CMW
 989: 0240: \***                                                                    !CMW
 990: 0240: \***    Remove non-printable characters from a string                   !CMW
 991: 0240: \***                                                                    !CMW
 992: 0240: \***********************************************************************!CMW
 993: 0240: FUNCTION ASC.TEXT$(A$) PUBLIC                                           !CMW
 994: 0269:                                                                         !CMW
 995: 0269:     STRING ASC.TEXT$,A$                                                 !CMW
 996: 0269:                                                                         !CMW
 997: 0269:     ASC.TEXT$ = TRANSLATE$(A$,                                      \   !CMW
 998: 029c:                     NONPRINTABLE.CHARS$,                            \   !CMW
 999: 029c:                     NONPRINTABLE.MAP$)                                  !CMW
1000: 029c:                                                                         !CMW
1001: 029c: END FUNCTION                                                            !CMW
1002: 02ba:                                                                         !CMW
1003: 02ba: \***********************************************************************!CMW
1004: 02ba: \***                                                                    !CMW
1005: 02ba: \***    HEX.TEXT$                                                       !CMW
1006: 02ba: \***                                                                    !CMW
1007: 02ba: \***********************************************************************!CMW
1008: 02ba: \***                                                                    !CMW
1009: 02ba: \***    Display hex string                                              !CMW
1010: 02ba: \***                                                                    !CMW
1011: 02ba: \***********************************************************************!CMW
1012: 02ba: FUNCTION HEX.TEXT$(H$) PUBLIC                                           !CMW
1013: 02e3:                                                                         !CMW
1014: 02e3:     STRING HEX.TEXT$,H$                                                 !CMW
1015: 02e3:                                                                         !CMW
1016: 02e3:     HEX.TEXT$ = TRANSLATE$(H$,":;<=>?","ABCDEF")                        !CMW
1017: 0308:                                                                         !CMW
1018: 0308: END FUNCTION                                                            !CMW
1019: 0326:                                                                         !CMW
1020: 0326: \********************************************************************** !CMW
1021: 0326: \***                                                                    !CMW
1022: 0326: \***    INV.TEXT$                                                       !CMW
1023: 0326: \***                                                                    !CMW
1024: 0326: \********************************************************************** !CMW
1025: 0326: \***                                                                    !CMW
1026: 0326: \***    Print inverse video text                                        !CMW
1027: 0326: \***                                                                    !CMW
1028: 0326: \********************************************************************** !CMW
1029: 0326: FUNCTION INV.TEXT$(S$) PUBLIC                                           !CMW
1030: 034f:                                                                         !CMW
1031: 034f:     STRING INV.TEXT$,S$                                                 !CMW
1032: 034f:                                                                         !CMW
1033: 034f:     INV.TEXT$ = CHR$(27) + "p" +                                    \   !CMW
1034: 0396:                 S$ +                                                \   !CMW
1035: 0396:                 CHR$(27) + "q"                                          !CMW
1036: 0396:                                                                         !CMW
1037: 0396: END FUNCTION                                                            !CMW
1038: 03b4:                                                                         !CMW
1039: 03b4: \***********************************************************************!CMW
1040: 03b4: \***                                                                    !CMW
1041: 03b4: \***    BOLD.TEXT$                                                      !CMW
1042: 03b4: \***                                                                    !CMW
1043: 03b4: \***********************************************************************!CMW
1044: 03b4: \***                                                                    !CMW
1045: 03b4: \***    Print bold text                                                 !CMW
1046: 03b4: \***                                                                    !CMW
1047: 03b4: \***********************************************************************!CMW
1048: 03b4: FUNCTION BOLD.TEXT$(S$) PUBLIC                                          !CMW
1049: 03dd:                                                                         !CMW
1050: 03dd:     STRING BOLD.TEXT$,S$                                                !CMW
1051: 03dd:                                                                         !CMW
1052: 03dd:     BOLD.TEXT$ = CHR$(27) + "r" + S$ + CHR$(27) + "u"                   !CMW
1053: 0424:                                                                         !CMW
1054: 0424: END FUNCTION                                                            !CMW
1055: 0442:                                                                         !CMW
1056: 0442: \***********************************************************************!CMW
1057: 0442: \***                                                                    !CMW
1058: 0442: \***    IS.DIGITS                                                       !CMW
1059: 0442: \***                                                                    !CMW
1060: 0442: \***********************************************************************!CMW
1061: 0442: \***                                                                    !CMW
1062: 0442: \***    Returns TRUE if passed parameter string is numeric digits only. !CMW
1063: 0442: \***                                                                    !CMW
1064: 0442: \***********************************************************************!CMW
1065: 0442: FUNCTION IS.DIGITS(DATA$) PUBLIC                                        !CMW
1066: 046b:                                                                         !CMW
1067: 046b:     INTEGER*1   IS.DIGITS                                               !CMW
1068: 046b:     STRING      DATA$                                                   !CMW
1069: 046b:     STRING      TEST$                                                   !CMW
1070: 046b:                                                                         !CMW
1071: 046b:     DATA$ = TRANSLATE$(DATA$,"0123456789#","##########_")               !CMW
1072: 0490:     TEST$ = STRING$(LEN(DATA$),"#")                                     !CMW
1073: 04b7:                                                                         !CMW
1074: 04b7:     IS.DIGITS = (DATA$ = TEST$)                                         !CMW
1075: 04e1:                                                                         !CMW
1076: 04e1: END FUNCTION                                                            !CMW
1077: 04fd:                                                                         !CMW
1078: 04fd: \***********************************************************************!CMW
1079: 04fd: \***                                                                    !CMW
1080: 04fd: \***    LAST.TIME                                                       !CMW
1081: 04fd: \***                                                                    !CMW
1082: 04fd: \***********************************************************************!CMW
1083: 04fd: \***                                                                    !CMW
1084: 04fd: \***    Returns time one minute ago                                     !CMW
1085: 04fd: \***                                                                    !CMW
1086: 04fd: \***********************************************************************!CMW
1087: 04fd: SUB LAST.TIME(H%,M%) PUBLIC                                             !CMW
1088: 0521:                                                                         !CMW
1089: 0521:     INTEGER*2 H%,M%                                                     !CMW
1090: 0521:                                                                         !CMW
1091: 0521:     ! Decrement minutes                                                 !CMW
1092: 0521:     M% = M% - 1                                                         !CMW
1093: 052f:     ! IF minutes wrapped                                                !CMW
1094: 052f:     IF M% = -1 THEN BEGIN                                               !CMW
1095: 0540:         M% = 59                                                         !CMW
1096: 0550:         ! Decrement hours                                               !CMW
1097: 0550:         H% = H% - 1                                                     !CMW
1098: 055e:         ! IF hours wrapped                                              !CMW
1099: 055e:         IF H% = -1 THEN BEGIN                                           !CMW
1100: 056f:             ! Reset hours                                               !CMW
1101: 056f:             H% = 23                                                     !CMW
1102: 057f:         ENDIF                                                           !CMW
1103: 0587:     ENDIF                                                               !CMW
1104: 058f:                                                                         !CMW
1105: 058f: END SUB                                                                 !CMW
1106: 05a3:                                                                         !CMW
1107: 05a3: \***********************************************************************!CMW
1108: 05a3: \***                                                                    !CMW
1109: 05a3: \***    NEXT.TIME                                                       !CMW
1110: 05a3: \***                                                                    !CMW
1111: 05a3: \***********************************************************************!CMW
1112: 05a3: \***                                                                    !CMW
1113: 05a3: \***    Returns time in one minute                                      !CMW
1114: 05a3: \***                                                                    !CMW
1115: 05a3: \***********************************************************************!CMW
1116: 05a3: SUB NEXT.TIME(H%,M%) PUBLIC                                             !CMW
1117: 05c7:                                                                         !CMW
1118: 05c7:     INTEGER*2 H%,M%                                                     !CMW
1119: 05c7:                                                                         !CMW
1120: 05c7:     ! Increment minutes                                                 !CMW
1121: 05c7:     M% = M% + 1                                                         !CMW
1122: 05d5:     ! IF minutes wrapped                                                !CMW
1123: 05d5:     IF M% = 60 THEN BEGIN                                               !CMW
1124: 05e6:         M% = 0                                                          !CMW
1125: 05f6:         ! Increment hours                                               !CMW
1126: 05f6:         H% = H% + 1                                                     !CMW
1127: 0604:         ! IF hours wrapped                                              !CMW
1128: 0604:         IF H% = 24 THEN BEGIN                                           !CMW
1129: 0615:             ! Reset hours                                               !CMW
1130: 0615:             H% = 0                                                      !CMW
1131: 0625:         ENDIF                                                           !CMW
1132: 062d:     ENDIF                                                               !CMW
1133: 0635:                                                                         !CMW
1134: 0635: END SUB                                                                 !CMW
1135: 0649:                                                                         !CMW
1136: 0649: \***********************************************************************!CMW
1137: 0649: \***                                                                    !CMW
1138: 0649: \***    GET.FILENAME$                                                   !CMW
1139: 0649: \***                                                                    !CMW
1140: 0649: \***********************************************************************!CMW
1141: 0649: \***                                                                    !CMW
1142: 0649: \***    Extract maximum 12-byte ASC filename from specified index       !CMW
1143: 0649: \***    within the event unique data string.                            !CMW
1144: 0649: \***                                                                    !CMW
1145: 0649: \***********************************************************************!CMW
1146: 0649: FUNCTION GET.FILENAME$(INDEX%,L%) PUBLIC                                !CMW
1147: 066d:     STRING GET.FILENAME$,WORK$                                          !CMW
1148: 066d:     INTEGER*2 INDEX%,L%,M%                                              !CMW
1149: 066d:                                                                         !CMW
1150: 066d:     WORK$ = EVENT.UNIQUE.DATA$                                          !CMW
1151: 0689:                                                                         !CMW
1152: 0689:     ! Strip off characters after the string terminator (null)           !CMW
1153: 0689:     M% = MATCHB(CHR$(0),EVENT.UNIQUE.DATA$,INDEX%)                      !CMW
1154: 06bf:     IF M% > 0 THEN BEGIN                                                !CMW
1155: 06ce:         WORK$ = LEFT$(EVENT.UNIQUE.DATA$,M% - 1)                        !CMW
1156: 06f6:     ENDIF                                                               !CMW
1157: 06fe:                                                                         !CMW
1158: 06fe:     GET.FILENAME$ =                                                 \   !CMW
1159: 0756:         RTRIM$(UCASE$(ASC.TEXT$(MID$(WORK$,INDEX%,L%))),".")            !CMW
1160: 0756:                                                                         !CMW
1161: 0756: END FUNCTION                                                            !CMW
1162: 076f:                                                                         !CMW
1163: 076f: \***********************************************************************!CMW
1164: 076f: \***                                                                    !CMW
1165: 076f: \***    FIND.PROGRAM.PAIR                                               !CMW
1166: 076f: \***                                                                    !CMW
1167: 076f: \***********************************************************************!CMW
1168: 076f: \***                                                                    !CMW
1169: 076f: \***    Search for the matching end/start program event for the         !CMW
1170: 076f: \***    currently selected start/end program event.                     !CMW
1171: 076f: \***                                                                    !CMW
1172: 076f: \***********************************************************************!CMW
1173: 076f: FUNCTION FIND.PROGRAM.PAIR PUBLIC                                       !CMW
1174: 0793:                                                                         !CMW
1175: 0793:     INTEGER*1 END.OF.FIND                                               !CMW
1176: 0793:     INTEGER*1 FIND.PROGRAM.PAIR                                         !EMW
1177: 0793:     INTEGER*1 PROGRAM.FOUND                                             !CMW
1178: 0793:                                                                         !CMW
1179: 0793:     INTEGER*2 NEXT.MESSAGE.NUMBER%                                      !CMW
1180: 0793:     INTEGER*2 PAIR.MESSAGE.NUMBER%                                      !CMW
1181: 0793:                                                                         !CMW
1182: 0793:     STRING NEXT.MESSAGE.GROUP$                                          !CMW
1183: 0793:     STRING NEXT.PID$                                                    !CMW
1184: 0793:     STRING THIS.PID$                                                    !CMW
1185: 0793:                                                                         !CMW
1186: 0793:     FIND.PROGRAM.PAIR = FALSE                                           !EMW
1187: 07a5:                                                                         !CMW
1188: 07a5:     ! Get process ID for the currently selected event                   !CMW
1189: 07a5:     THIS.PID$ = MID$(SUMMARY.RECORD$(CURRENT.INDEX%),81,8)              !CMW
1190: 07db:                                                                         !CMW
1191: 07db:     ! IF start program event                                            !CMW
1192: 07db:     IF EVENT.MESSAGE.NUMBER% = 619 THEN BEGIN                           !CMW
1193: 07ee:         ! Search for the end program event                              !CMW
1194: 07ee:         PAIR.MESSAGE.NUMBER% = 620                                      !CMW
1195: 07fe:     ! IF end program event                                              !CMW
1196: 07fe:     ENDIF ELSE IF EVENT.MESSAGE.NUMBER% = 620 THEN BEGIN                !CMW
1197: 0811:         ! Search for the start program event                            !CMW
1198: 0811:         PAIR.MESSAGE.NUMBER% = 619                                      !CMW
1199: 081f:     ENDIF                                                               !CMW
1200: 0827:                                                                         !CMW
1201: 0827:     END.OF.FIND = FALSE                                                 !CMW
1202: 0839:     PROGRAM.FOUND = FALSE                                               !CMW
1203: 084b:                                                                         !CMW
1204: 084b:     ! While start/end program event pair NOT found                      !CMW
1205: 084b:     WHILE NOT END.OF.FIND                                               !CMW
1206: 0856:                                                                         !CMW
1207: 0856:         ! IF start program event                                        !CMW
1208: 0856:         IF EVENT.MESSAGE.NUMBER% = 619 THEN BEGIN                       !CMW
1209: 0869:             ! IF no more next events available                          !CMW
1210: 0869:             IF CURRENT.INDEX% = RESULTS.COUNT% THEN BEGIN               !CMW
1211: 0881:                 END.OF.FIND = TRUE                                      !CMW
1212: 0895:             ENDIF ELSE BEGIN                                            !EMW
1213: 089d:                 ! Move to the next event                                !EMW
1214: 089d:                 CURRENT.INDEX% = CURRENT.INDEX% + 1                     !EMW
1215: 08ac:             ENDIF                                                       !CMW
1216: 08b6:         ! IF end program event                                          !CMW
1217: 08b6:         ENDIF ELSE BEGIN                                                !CMW
1218: 08be:             ! IF no more previous events available                      !CMW
1219: 08be:             IF CURRENT.INDEX% = 0 THEN BEGIN                            !CMW
1220: 08d0:                 END.OF.FIND = TRUE                                      !CMW
1221: 08e4:             ENDIF ELSE BEGIN                                            !EMW
1222: 08ec:                 ! Move to the previous event                            !EMW
1223: 08ec:                 CURRENT.INDEX% = CURRENT.INDEX% - 1                     !EMW
1224: 08fb:             ENDIF                                                       !CMW
1225: 0903:         ENDIF                                                           !CMW
1226: 090b:                                                                         !CMW
1227: 090b:         ! Get next process ID                                           !CMW
1228: 090b:         NEXT.PID$ = MID$(SUMMARY.RECORD$(CURRENT.INDEX%),81,8)          !CMW
1229: 0941:         ! Get next message group                                        !CMW
1230: 0941:         NEXT.MESSAGE.GROUP$ =                                       \   !CMW
1231: 0977:             MID$(SUMMARY.RECORD$(CURRENT.INDEX%),42,1)                  !CMW
1232: 0977:         ! Get next message number                                       !CMW
1233: 0977:         NEXT.MESSAGE.NUMBER% =                                      \   !CMW
1234: 09b1:             VAL(MID$(SUMMARY.RECORD$(CURRENT.INDEX%),43,3))             !CMW
1235: 09b1:                                                                         !CMW
1236: 09b1:         ! IF matching program event pair found                          !CMW
1237: 09b1:         IF (THIS.PID$ = NEXT.PID$) AND                              \   !CMW
1238: 0a11:            (NEXT.MESSAGE.GROUP$ = "W") AND                          \   !CMW
1239: 0a11:            (NEXT.MESSAGE.NUMBER% = PAIR.MESSAGE.NUMBER%) THEN BEGIN     !CMW
1240: 0a11:             PROGRAM.FOUND = TRUE                                        !CMW
1241: 0a23:             END.OF.FIND = TRUE                                          !CMW
1242: 0a35:         ENDIF                                                           !CMW
1243: 0a3d:                                                                         !CMW
1244: 0a3d:     WEND                                                                !CMW
1245: 0a4f:                                                                         !CMW
1246: 0a4f:     ! IF matching program event pair found                              !CMW
1247: 0a4f:     IF PROGRAM.FOUND THEN BEGIN                                         !CMW
1248: 0a61:                                                                         !CMW
1249: 0a61:         ! Calculate page of the event pair                              !CMW
1250: 0a61:         RESULTS.PAGE% =                                             \   !CMW
1251: 0aba:             INT((RESULTS.COUNT% - CURRENT.INDEX%) /                 \   !CMW
1252: 0aba:             RESULTS.PER.PAGE%) + 1                                      !CMW
1253: 0aba:                                                                         !CMW
1254: 0aba:         ! Calculate row of the event pair                               !CMW
1255: 0aba:         CURRENT.FIELD% = RESULTS.COUNT% -                           \   !CMW
1256: 0af1:                          ((RESULTS.PAGE% - 1) *                     \   !CMW
1257: 0af1:                          RESULTS.PER.PAGE%) -                       \   !CMW
1258: 0af1:                          CURRENT.INDEX% + 3                             !CMW
1259: 0af1:                                                                         !CMW
1260: 0af1:     ENDIF                                                               !CMW
1261: 0af9:                                                                         !CMW
1262: 0af9:     ! Set function return code                                          !CMW
1263: 0af9:     FIND.PROGRAM.PAIR = PROGRAM.FOUND                                   !EMW
1264: 0b07:                                                                         !CMW
1265: 0b07: END FUNCTION                                                            !CMW
1266: 0b1e:                                                                         !CMW
1267: 0b1e: \***********************************************************************!CMW
1268: 0b1e: \***                                                                    !CMW
1269: 0b1e: \***    GET.APPLICATION$                                                !CMW
1270: 0b1e: \***                                                                    !CMW
1271: 0b1e: \***********************************************************************!CMW
1272: 0b1e: \***                                                                    !CMW
1273: 0b1e: \***    Get application name from an event record                       !CMW
1274: 0b1e: \***                                                                    !CMW
1275: 0b1e: \***********************************************************************!CMW
1276: 0b1e: FUNCTION GET.APPLICATION$(R$) PUBLIC                                    !CMW
1277: 0b47:                                                                         !CMW
1278: 0b47:     STRING GET.APPLICATION$,R$,P$,F$,W$                                 !CMW
1279: 0b47:     INTEGER*1 SOURCE%,FORMAT%                                           !CMW
1280: 0b47:     INTEGER*2 DATE%,M%,NUMBER%                                          !CMW
1281: 0b47:     INTEGER*2 MESSAGE%                                                  !FMW
1282: 0b47:                                                                         !CMW
1283: 0b47:     DATE% = GETN2(R$,0)                                                 !CMW
1284: 0b62:                                                                         !CMW
1285: 0b62:     P$ = NULL.PROGRAM$                                                  !CMW
1286: 0b7e:                                                                         !CMW
1287: 0b7e:     ! If events are found                                               !CMW
1288: 0b7e:     IF DATE% <> 0 THEN BEGIN                                            !CMW
1289: 0b90:                                                                         !CMW
1290: 0b90:         SOURCE% = GETN1(R$,8)                                           !CMW
1291: 0bab:         FORMAT% = GETN1(R$,33)                                          !CMW
1292: 0bc6:                                                                         !CMW
1293: 0bc6:         IF SOURCE% = 1 OR \          ! Controller application           !CMW
1294: 0be8:            SOURCE% = 60 THEN BEGIN   ! Terminal application             !CMW
1295: 0be8:                                                                         !CMW
1296: 0be8:             CALL EXTRACTS(R$,P$,15)                                     !CMW
1297: 0c08:             P$ = UCASE$(ASC.TEXT$(P$))                                  !CMW
1298: 0c2a:                                                                         !CMW
1299: 0c2a:             IF P$ = EDITOR.PROGRAM$ THEN BEGIN                          !FMW
1300: 0c4f:                 MESSAGE% = GETN2(R$,10)                                 !FMW
1301: 0c6a:                 IF MESSAGE% = 800 OR                                \   !FMW
1302: 0c96:                    MESSAGE% = 801 OR                                \   !FMW
1303: 0c96:                    MESSAGE% = 802 THEN BEGIN                            !FMW
1304: 0c96:                     P$ = "DREDIX  "                                     !FMW
1305: 0cad:                 ENDIF ELSE \                                            !FMW
1306: 0cb5:                 IF MESSAGE% = 803 OR                                \   !FMW
1307: 0ce1:                    MESSAGE% = 804 OR                                \   !FMW
1308: 0ce1:                    MESSAGE% = 805 THEN BEGIN                            !FMW
1309: 0ce1:                     P$ = "VEDIT   "                                     !FMW
1310: 0cf6:                 ENDIF                                                   !FMW
1311: 0cfe:                 IF MESSAGE% = 806 OR                                \   !FMW
1312: 0d2a:                    MESSAGE% = 807 OR                                \   !FMW
1313: 0d2a:                    MESSAGE% = 808 THEN BEGIN                            !FMW
1314: 0d2a:                     P$ = "XE      "                                     !FMW
1315: 0d3f:                 ENDIF                                                   !FMW
1316: 0d47:             ENDIF                                                       !FMW
1317: 0d4f:                                                                         !FMW
1318: 0d4f:             M% = MATCHB(".",P$,1)                                       !CMW
1319: 0d70:                                                                         !CMW
1320: 0d70:             ! IF program name contains full stops                       !CMW
1321: 0d70:             IF M% > 1 THEN BEGIN                                        !CMW
1322: 0d7f:                 ! Strip all full stop characters                        !CMW
1323: 0d7f:                 P$ = LEFT$(LEFT$(P$,M% - 1) + NULL.PROGRAM$,8)          !CMW
1324: 0dd5:             ENDIF                                                       !CMW
1325: 0de0:                                                                         !CMW
1326: 0de0:         ENDIF ELSE IF FORMAT% = 45 OR                               \   !CMW
1327: 0e02:                       FORMAT% = 103 THEN BEGIN                          !CMW
1328: 0e02:                                                                         !CMW
1329: 0e02:             F$ = NULL.FILENAME$                                         !CMW
1330: 0e1e:             CALL EXTRACTS(R$,F$,15)                                     !CMW
1331: 0e3e:             F$ = UCASE$(ASC.TEXT$(F$))                                  !CMW
1332: 0e60:                                                                         !CMW
1333: 0e60:             M% = MATCHB(".",F$,1)                                       !CMW
1334: 0e81:                                                                         !CMW
1335: 0e81:             ! IF filename contains a full stop                          !CMW
1336: 0e81:             IF M% > 1 THEN BEGIN                                        !CMW
1337: 0e90:                 ! Strip all characters after the first full stop        !CMW
1338: 0e90:                 P$ = LEFT$(LEFT$(F$,M% - 1) + NULL.PROGRAM$,8)          !CMW
1339: 0ee8:             ENDIF ELSE BEGIN                                            !CMW
1340: 0ef0:                 P$ = LEFT$(F$ + NULL.PROGRAM$,8)                        !CMW
1341: 0f2f:             ENDIF                                                       !CMW
1342: 0f3a:                                                                         !CMW
1343: 0f3a:         ENDIF ELSE IF FORMAT% = 28 OR                               \   !CMW
1344: 0f59:                       FORMAT% = 29 THEN BEGIN                           !CMW
1345: 0f59:                                                                         !CMW
1346: 0f59:             CALL EXTRACTS(R$,P$,25)                                     !CMW
1347: 0f79:             P$ = UCASE$(ASC.TEXT$(P$))                                  !CMW
1348: 0f9e:                                                                         !CMW
1349: 0f9e:         ENDIF ELSE IF FORMAT% = 47 THEN BEGIN                           !CMW
1350: 0fb0:                                                                         !CMW
1351: 0fb0:             NUMBER% = GETN1(R$,13)                                      !CMW
1352: 0fcb:                                                                         !CMW
1353: 0fcb:             IF NUMBER% = 7 OR NUMBER% = 8 THEN BEGIN                    !CMW
1354: 0fec:                 CALL EXTRACTS(R$,P$,25)                                 !CMW
1355: 100c:                 P$ = UCASE$(ASC.TEXT$(P$))                              !CMW
1356: 1030:             ENDIF ELSE IF NUMBER% = 177 THEN BEGIN                      !CMW
1357: 1040:                 P$ = "ADXCSJ0L"                                         !CMW
1358: 1055:             ENDIF                                                       !CMW
1359: 105d:                                                                         !CMW
1360: 105d:         ENDIF                                                           !CMW
1361: 1065:                                                                         !CMW
1362: 1065:     ENDIF                                                               !CMW
1363: 106d:                                                                         !CMW
1364: 106d:     GET.APPLICATION$ = P$                                               !CMW
1365: 1087:                                                                         !CMW
1366: 1087: END FUNCTION                                                            !CMW
1367: 10a5:                                                                         !CMW
1368: 10a5: \***********************************************************************!DMW
1369: 10a5: \***                                                                    !DMW
1370: 10a5: \***    GET.APPLICATION.DESCRIPTION$                                    !DMW
1371: 10a5: \***                                                                    !DMW
1372: 10a5: \***********************************************************************!DMW
1373: 10a5: \***                                                                    !DMW
1374: 10a5: \***    Get application description for the specified application name. !DMW
1375: 10a5: \***                                                                    !DMW
1376: 10a5: \***********************************************************************!DMW
1377: 10a5: FUNCTION GET.APPLICATION.DESCRIPTION$(P$) PUBLIC                        !DMW
1378: 10ce:     INTEGER*1 EVAPP.RC%                                                 !DMW
1379: 10ce:     STRING GET.APPLICATION.DESCRIPTION$                                 !DMW
1380: 10ce:     STRING P$                                                           !DMW
1381: 10ce:     STRING NAME$                                                        !DMW
1382: 10ce:                                                                         !DMW
1383: 10ce:     EVAPP.PROGRAM$ = P$                                                 !DMW
1384: 10e7:     EVAPP.RC% = READ.EVAPP                                              !DMW
1385: 10f7:                                                                         !DMW
1386: 10f7:     ! IF application name found                                         !DMW
1387: 10f7:     IF EVAPP.RC% = 0 THEN BEGIN                                         !DMW
1388: 1106:         NAME$ = EVAPP.DESC$                                             !DMW
1389: 1125:     ENDIF ELSE BEGIN                                                    !DMW
1390: 112d:         IF LEFT$(P$,3) = "ADX" THEN BEGIN                               !DMW
1391: 115d:             NAME$ = "Toshiba 4690 OS Application"                       !DMW
1392: 1174:         ENDIF ELSE BEGIN                                                !DMW
1393: 117c:             NAME$ = "Unknown Application"                               !DMW
1394: 1191:         ENDIF                                                           !DMW
1395: 1199:     ENDIF                                                               !DMW
1396: 11a1:                                                                         !DMW
1397: 11a1:     GET.APPLICATION.DESCRIPTION$ = NAME$                                !DMW
1398: 11bb:                                                                         !DMW
1399: 11bb: END FUNCTION                                                            !DMW
1400: 11d9:                                                                         !DMW
1401: 11d9: \***********************************************************************
1402: 11d9: \***
1403: 11d9: \***   WORD.WRAP$
1404: 11d9: \***
1405: 11d9: \***********************************************************************
1406: 11d9: \***
1407: 11d9: \***   Perform word wrap on string
1408: 11d9: \***
1409: 11d9: \***********************************************************************
1410: 11d9: FUNCTION WORD.WRAP$(TXT$,LINE.LEN%) !LOCAL
1411: 1202: 
1412: 1202:     STRING WRK$, TXT$, WORD.WRAP$, WORD$
1413: 1202:     INTEGER*2 LINE.LEN%, LEFT%, I%
1414: 1202: 
1415: 1202:     WRK$ = ""
1416: 1217:     LEFT% = 0
1417: 1225: 
1418: 1225:     GOSUB GET.NEXT.WORD
1419: 1237:     WHILE WORD$ <> ""
1420: 1242:         IF LEN(WORD$) > LEFT% THEN BEGIN
1421: 125e:             WRK$ = WRK$ + STRING$(LEFT%, " ") + WORD$ + " "
1422: 129e:             LEFT% = LINE.LEN% - LEN(WORD$) - 1
1423: 12c3:         ENDIF ELSE IF LEN(WORD$) = LEFT% THEN BEGIN
1424: 12df:             WRK$ = WRK$ + WORD$
1425: 1303:             LEFT% = LINE.LEN%
1426: 1313:         ENDIF ELSE BEGIN
1427: 131b:             WRK$ = WRK$ + WORD$ + " "
1428: 1343:             LEFT% = LEFT% - LEN(WORD$) - 1
1429: 1365:         ENDIF
1430: 136d:         GOSUB GET.NEXT.WORD
1431: 137f:     WEND
1432: 139d:     WORD.WRAP$ = WRK$
1433: 13b7:     WRK$ = ""
1434: 13cc:     TXT$ = ""
1435: 13e2:     WORD$ = ""
1436: 13f7:     EXIT FUNCTION
1437: 1402: 
1438: 1402: GET.NEXT.WORD:
1439: 1412: 
1440: 1412:     I% = MATCHB(" ", TXT$, 1)                                           !BMW
1441: 1431:     IF I% = 0 THEN BEGIN
1442: 1440:         WORD$ = TXT$
1443: 1457:         TXT$ = ""
1444: 1470:     ENDIF ELSE BEGIN
1445: 1478:         WORD$ = LEFT$(TXT$, I% - 1)
1446: 149b:         I% = I% + 1
1447: 14a7:         WHILE ASC(MID$(TXT$, I%, 1) + "?") = 20H
1448: 14b1:             I% = I% + 1
1449: 14bd:         WEND
1450: 14fa:         TXT$ = MID$(TXT$, I%, 32767)
1451: 151e:     ENDIF
1452: 1526: 
1453: 1526:     RETURN
1454: 1536: 
1455: 1536: END FUNCTION
1456: 1554: 
1457: 1554: \***********************************************************************!FMW
1458: 1554: \***                                                                    !FMW
1459: 1554: \***   UNCOMPRESS$                                                      !FMW
1460: 1554: \***                                                                    !FMW
1461: 1554: \***********************************************************************!FMW
1462: 1554: \***                                                                    !FMW
1463: 1554: \***   Uncompress a 10-byte compressed string into 13 bytes.            !FMW
1464: 1554: \***                                                                    !FMW
1465: 1554: \***   It works by converting blocks of 6-bits in a string to numbers   !FMW
1466: 1554: \***   and then mapping this back to the original ASCII codes.          !FMW
1467: 1554: \***                                                                    !FMW
1468: 1554: \***********************************************************************!FMW
1469: 1554: FUNCTION UNCOMPRESS$(S$) PUBLIC                                         !FMW
1470: 157d:                                                                         !FMW
1471: 157d:     STRING UNCOMPRESS$,S$,SOURCE$,DEST$                                 !FMW
1472: 157d:     INTEGER*2 CHAR%                                                     !FMW
1473: 157d:     INTEGER*2 BIT.POS%,BYTE.POS%                                        !FMW
1474: 157d:     INTEGER*2 RESULT%(1)                                                !FMW
1475: 157d:     INTEGER*2 I%,J%                                                     !FMW
1476: 157d:                                                                         !FMW
1477: 157d:     SOURCE$ = LEFT$(S$,10)                                              !FMW
1478: 159d:                                                                         !FMW
1479: 159d:     DIM RESULT%(13)                                                     !FMW
1480: 15c6:                                                                         !FMW
1481: 15c6:     BYTE.POS% = 1                                                       !FMW
1482: 15d4:     BIT.POS% = 20H                                                      !FMW
1483: 15e2:                                                                         !FMW
1484: 15e2:     ! For each source byte                                              !FMW
1485: 15e2:     FOR I% = 1 TO LEN(SOURCE$)                                          !FMW
1486: 15f3:                                                                         !FMW
1487: 15f3:         CHAR% = ASC(MID$(SOURCE$,I%,1))                                 !FMW
1488: 1619:                                                                         !FMW
1489: 1619:         ! Initialise source bit pattern to start at bit 8               !FMW
1490: 1619:         J% = 80H                                                        !FMW
1491: 1627:                                                                         !FMW
1492: 1627:         ! For each source string bit                                    !FMW
1493: 1627:         WHILE J% > 0                                                    !FMW
1494: 1632:                                                                         !FMW
1495: 1632:             ! IF bit is set                                             !FMW
1496: 1632:             IF CHAR% AND J% THEN BEGIN                                  !FMW
1497: 1643:                 ! Set bit in results array                              !FMW
1498: 1643:                 RESULT%(BYTE.POS%) = RESULT%(BYTE.POS%) OR BIT.POS%     !FMW
1499: 1679:             ENDIF                                                       !FMW
1500: 1681:                                                                         !FMW
1501: 1681:             ! Shift source bit pattern right by 1 bit                   !FMW
1502: 1681:             J% = J% / 2                                                 !FMW
1503: 1695:                                                                         !FMW
1504: 1695:             ! Shift result bit pattern right by 1 bit                   !FMW
1505: 1695:             BIT.POS% = BIT.POS% / 2                                     !FMW
1506: 16a9:                                                                         !FMW
1507: 16a9:             ! IF end of current result byte                             !FMW
1508: 16a9:             IF BIT.POS% = 0 THEN BEGIN                                  !FMW
1509: 16b8:                                                                         !FMW
1510: 16b8:                 ! Initialise result bit pattern to start at bit 6       !FMW
1511: 16b8:                 BIT.POS% = 20H                                          !FMW
1512: 16c6:                                                                         !FMW
1513: 16c6:                 ! Move to next result byte                              !FMW
1514: 16c6:                 BYTE.POS% = BYTE.POS% + 1                               !FMW
1515: 16d2:                                                                         !FMW
1516: 16d2:             ENDIF                                                       !FMW
1517: 16da:                                                                         !FMW
1518: 16da:         WEND                                                            !FMW
1519: 16ec:                                                                         !FMW
1520: 16ec:     NEXT I%                                                             !FMW
1521: 1712:                                                                         !FMW
1522: 1712:     DEST$ = ""                                                          !FMW
1523: 1727:                                                                         !FMW
1524: 1727:     ! FOR each destination byte                                         !FMW
1525: 1727:     FOR I% = 1 TO 13                                                    !FMW
1526: 1738:                                                                         !FMW
1527: 1738:         CHAR% = RESULT%(I%)                                             !FMW
1528: 1755:                                                                         !FMW
1529: 1755:         ! ---------------------------------------                       !FMW
1530: 1755:         ! Decode 6-bit blocks to ASCII characters                       !FMW
1531: 1755:         ! ---------------------------------------                       !FMW
1532: 1755:                                                                         !FMW
1533: 1755:         ! IF sqiggly bracket                                            !FMW
1534: 1755:         IF CHAR% = 39H OR CHAR% = 3BH THEN BEGIN                        !FMW
1535: 1776:             CHAR% = CHAR% + 42H                                         !FMW
1536: 1785:         ENDIF ELSE BEGIN                                                !FMW
1537: 178d:             CHAR% = CHAR% + 22H                                         !FMW
1538: 179a:         ENDIF                                                           !FMW
1539: 17a2:                                                                         !FMW
1540: 17a2:         ! IF NOT a null character                                       !FMW
1541: 17a2:         IF NOT CHAR% = 22H THEN BEGIN                                   !FMW
1542: 17b1:             DEST$ = DEST$ + CHR$(CHAR%)                                 !FMW
1543: 17d6:         ENDIF                                                           !FMW
1544: 17de:                                                                         !FMW
1545: 17de:     NEXT I%                                                             !FMW
1546: 17f7:                                                                         !FMW
1547: 17f7:     UNCOMPRESS$ = DEST$                                                 !FMW
1548: 1811:                                                                         !FMW
1549: 1811: END FUNCTION                                                            !FMW
1550: 182f:                                                                         !FMW
1551: 182f: \***********************************************************************!FMW
1552: 182f: \***                                                                    !FMW
1553: 182f: \***   DISPLAY.SECTOR                                                   !FMW
1554: 182f: \***                                                                    !FMW
1555: 182f: \***********************************************************************!FMW
1556: 182f: \***                                                                    !FMW
1557: 182f: \***   Display the comparison of the specified half of the sector       !FMW
1558: 182f: \***                                                                    !FMW
1559: 182f: \***********************************************************************!FMW
1560: 182f: SUB DISPLAY.SECTOR(H%) PUBLIC                                           !FMW
1561: 1853:     INTEGER*1 H%                                                        !FMW
1562: 1853:     INTEGER*2 I%,J%,K%,O%                                               !FMW
1563: 1853:     STRING ROW$,BEFORE.ROW$,AFTER.ROW$,BEFORE.BYTE$,AFTER.BYTE$         !FMW
1564: 1853:                                                                         !FMW
1565: 1853:     O% = ((H% - 1) * 512) + 1                                           !FMW
1566: 186b:                                                                         !FMW
1567: 186b:     LOCATE 3,3,OFF                                                      !FMW
1568: 1880:     PRINT "File name : ";MID$(ULOG.RECORD$(2),9,127)                    !FMW
1569: 18b9:     LOCATE 4,3,OFF                                                      !FMW
1570: 18ce:     PRINT "Sector    : ";LEFT$(ULOG.RECORD$(2),8)                       !FMW
1571: 1907:                                                                         !FMW
1572: 1907:     LOCATE 6,4,OFF                                                      !FMW
1573: 191c:     PRINT STRING$(14,"_");"BEFORE";STRING$(15,"_");                 \   !FMW
1574: 1995:           STRING$(3," ");                                           \   !FMW
1575: 1995:           STRING$(15,"_");"AFTER";STRING$(15,"_")                       !FMW
1576: 1995:                                                                         !FMW
1577: 1995:     ! IF partial sector found                                           !FMW
1578: 1995:     IF LEN(ULOG.RECORD$(3)) < 1024 THEN BEGIN                           !FMW
1579: 19c3:         ULOG.RECORD$(3) = LEFT$(ULOG.RECORD$(3) +                   \   !FMW
1580: 1a2c:                           STRING$(512,"FF"),1024)                       !FMW
1581: 1a2c:         ULOG.RECORD$(4) = LEFT$(ULOG.RECORD$(4) +                   \   !FMW
1582: 1a95:                           STRING$(512,"FF"),1024)                       !FMW
1583: 1a95:     ENDIF                                                               !FMW
1584: 1a9d:                                                                         !FMW
1585: 1a9d:     ! For each row                                                      !FMW
1586: 1a9d:     FOR I% = 1 TO 16                                                    !FMW
1587: 1aae:                                                                         !FMW
1588: 1aae:         BEFORE.ROW$ = ""                                                !FMW
1589: 1ac3:         AFTER.ROW$ = ""                                                 !FMW
1590: 1ad8:                                                                         !FMW
1591: 1ad8:         LOCATE I% + 6,4,OFF                                             !FMW
1592: 1af2:                                                                         !FMW
1593: 1af2:         FOR J% = 1 TO 4                                                 !FMW
1594: 1b03:             FOR K% = 1 TO 4                                             !FMW
1595: 1b14:                 BEFORE.BYTE$ = MID$(ULOG.RECORD$(3),                \   !FMW
1596: 1b59:                     O% + ((J% - 1) * 8) + ((K% - 1) * 2),2)             !FMW
1597: 1b59:                 AFTER.BYTE$  = MID$(ULOG.RECORD$(4),                \   !FMW
1598: 1b9e:                     O% + ((J% - 1) * 8) + ((K% - 1) * 2),2)             !FMW
1599: 1b9e:                                                                         !FMW
1600: 1b9e:                 BEFORE.ROW$ = BEFORE.ROW$ + BEFORE.BYTE$                !FMW
1601: 1bc2:                                                                         !FMW
1602: 1bc2:                 IF BEFORE.BYTE$ = AFTER.BYTE$ THEN BEGIN                !FMW
1603: 1be1:                                                                         !FMW
1604: 1be1:                     AFTER.ROW$ = AFTER.ROW$ + AFTER.BYTE$               !FMW
1605: 1c07:                                                                         !FMW
1606: 1c07:                 ENDIF ELSE BEGIN                                        !FMW
1607: 1c0f:                                                                         !FMW
1608: 1c0f:                     ! Highlight updated byte                            !FMW
1609: 1c0f:                     AFTER.ROW$ = AFTER.ROW$ + INV.TEXT$(AFTER.BYTE$)    !FMW
1610: 1c37:                                                                         !FMW
1611: 1c37:                 ENDIF                                                   !FMW
1612: 1c3f:                                                                         !FMW
1613: 1c3f:             NEXT K%                                                     !FMW
1614: 1c58:                                                                         !FMW
1615: 1c58:             BEFORE.ROW$ = BEFORE.ROW$ + " "                             !FMW
1616: 1c78:             AFTER.ROW$ = AFTER.ROW$ + " "                               !FMW
1617: 1c98:                                                                         !FMW
1618: 1c98:         NEXT J%                                                         !FMW
1619: 1cb1:                                                                         !FMW
1620: 1cb1:         O% = O% + 32                                                    !FMW
1621: 1cbe:                                                                         !FMW
1622: 1cbe:         ROW$ = BEFORE.ROW$ + "| " + AFTER.ROW$                          !FMW
1623: 1ce6:                                                                         !FMW
1624: 1ce6:         PRINT ROW$                                                      !FMW
1625: 1cfb:                                                                         !FMW
1626: 1cfb:     NEXT I%                                                             !FMW
1627: 1d14:                                                                         !FMW
1628: 1d14: END SUB                                                                 !FMW
1629: 1d28:                                                                         !FMW
1630: 1d28: \***********************************************************************
1631: 1d28: \***
1632: 1d28: \***    PSU0406
1633: 1d28: \***
1634: 1d28: \***********************************************************************
1635: 1d28: SUB PSU0406 PUBLIC
1636: 1d4c: 
1637: 1d4c:     INTEGER*1 CODE.FOUND
1638: 1d4c: 
1639: 1d4c:     INTEGER*2 I%
1640: 1d4c: 
1641: 1d4c:     STRING CODE.TEXT$
1642: 1d4c:     STRING DISPLAY.TEXT$
1643: 1d4c:     STRING ERROR.TEXT$
1644: 1d4c:     STRING PROGRAM.TEXT$
1645: 1d4c:     STRING TITLE.TEXT$
1646: 1d4c: 
1647: 1d4c:     GOSUB FORMAT.HEADER
1648: 1d5e: 
1649: 1d5e:     LOCATE 3,1,OFF : PRINT TITLE.TEXT$
1650: 1d80:     LOCATE 4,1,OFF : PRINT BOLD.TEXT$(DISPLAY.TEXT$)                    !CMW
1651: 1da9: 
1652: 1da9:     GOSUB FORMAT.EVENT.DESCRIPTION
1653: 1dbb: 
1654: 1dbb:     LOCATE 5,1,OFF : PRINT TITLE.TEXT$
1655: 1ddd:     LOCATE 6,1,OFF : PRINT BOLD.TEXT$(DISPLAY.TEXT$)                    !CMW
1656: 1e06: 
1657: 1e06:     GOSUB FORMAT.APPLICATION.DESCRIPTION
1658: 1e18: 
1659: 1e18:     LOCATE 8,1,OFF : PRINT TITLE.TEXT$
1660: 1e3a:     LOCATE 9,1,OFF : PRINT BOLD.TEXT$(DISPLAY.TEXT$)                    !CMW
1661: 1e63: 
1662: 1e63:     GOSUB FORMAT.COMMENT
1663: 1e75: 
1664: 1e75:     LOCATE 11,1,OFF : PRINT TITLE.TEXT$
1665: 1e97: 
1666: 1e97:     ! FOR each comment line (up to 4 lines)
1667: 1e97:     FOR I% = 0 TO 3
1668: 1ea7: 
1669: 1ea7:         DISPLAY.TEXT$ = MID$(COMMENT$,                              \
1670: 1edc:                         (I% * LINE.LENGTH%) + 1,                    \
1671: 1edc:                         LINE.LENGTH%)
1672: 1edc: 
1673: 1edc:         LOCATE 12 + I%,1,OFF : PRINT BOLD.TEXT$(DISPLAY.TEXT$)          !CMW
1674: 1f0b: 
1675: 1f0b:     NEXT I%
1676: 1f21: 
1677: 1f21:     GOSUB FORMAT.RETURN.CODE
1678: 1f33: 
1679: 1f33:     LOCATE 16,1,OFF : PRINT TITLE.TEXT$
1680: 1f55: 
1681: 1f55:     ! FOR each return code line (up to 4 lines)
1682: 1f55:     FOR I% = 0 TO 3
1683: 1f65: 
1684: 1f65:         DISPLAY.TEXT$ = MID$(ERROR.TEXT$,                           \
1685: 1f97:                         (I% * LINE.LENGTH%) + 1,                    \
1686: 1f97:                         LINE.LENGTH%)
1687: 1f97: 
1688: 1f97:         LOCATE 17 + I%,1,OFF : PRINT BOLD.TEXT$(DISPLAY.TEXT$)
1689: 1fc6: 
1690: 1fc6:     NEXT I%
1691: 1fdc: 
1692: 1fdc:     GOSUB FORMAT.UNIQUE.DATA
1693: 1fee: 
1694: 1fee:     LOCATE 21,1,OFF : PRINT TITLE.TEXT$
1695: 2010:     LOCATE 22,1,OFF : PRINT DISPLAY.TEXT$
1696: 2032: 
1697: 2032:     EXIT SUB
1698: 203d: 
1699: 203d: \***********************************************************************
1700: 203d: \***
1701: 203d: \***    FORMAT.HEADER
1702: 203d: \***
1703: 203d: \***********************************************************************
1704: 203d: \***
1705: 203d: \***    Formats the header title and details
1706: 203d: \***
1707: 203d: \***********************************************************************
1708: 203d: FORMAT.HEADER:
1709: 204d: 
1710: 204d:     ! IF controller ID is available
1711: 204d:     IF NOT CONTROLLER.ID$ = "" THEN BEGIN
1712: 206e: 
1713: 206e:         TITLE.TEXT$ = "Day"  + " " +                                \
1714: 20ae:                       "Time" + " " +                                \
1715: 20ae:                       "Till" + " " +                                \
1716: 20ae:                       "ID"   + " " +                                \
1717: 20ae:                       "S"    + " " +                                \
1718: 20ae:                       "Source"
1719: 20ae: 
1720: 20ae:         DISPLAY.TEXT$ =                                             \
1721: 21b0:             EVENT.DOW$                                  + " " +     \
1722: 21b0:             PAD$(STR$(EVENT.HOUR%),2)                   + ":" +     \
1723: 21b0:             PAD$(STR$(EVENT.MIN%),2)                    + " " +     \
1724: 21b0:             LEFT$(TILL.NUMBER$ + "   ",3)               + " " +     \
1725: 21b0:             LEFT$(CONTROLLER.ID$ + "  ",2)              + " " +     \
1726: 21b0:             STR$(EVENT.SEVERITY%)
1727: 21b0: 
1728: 21b0:         DISPLAY.TEXT$ =                                             \
1729: 2294:             DISPLAY.TEXT$ + " " +                                   \
1730: 2294:             "B" + STR$(EVENT.BUCKET%) + "/" +                       \
1731: 2294:             "S" + PAD$(STR$(EVENT.SOURCE%),3) + "/" +               \
1732: 2294:             "E" + PAD$(STR$(EVENT.NUMBER%),3) + " " +               \
1733: 2294:             BUCKET.TEXT$(EVENT.BUCKET%) + ", " +                    \   !BMW
1734: 2294:             SOURCE.TEXT$(EVENT.SOURCE%)                                 !BMW
1735: 2294: 
1736: 2294:         DISPLAY.TEXT$ =                                             \
1737: 22ea:             LEFT$(DISPLAY.TEXT$ +                                   \
1738: 22ea:             STRING$(LINE.LENGTH%," "),LINE.LENGTH%)
1739: 22ea: 
1740: 22ea:     ENDIF ELSE BEGIN
1741: 22f2: 
1742: 22f2:         ! Blank out title
1743: 22f2:         TITLE.TEXT$ = STRING$(LINE.LENGTH%," ")
1744: 2313: 
1745: 2313:         ! Blank out detail lines
1746: 2313:         DISPLAY.TEXT$ = STRING$(LINE.LENGTH%," ")
1747: 2334: 
1748: 2334:     ENDIF
1749: 233c: 
1750: 233c:     RETURN
1751: 234c: 
1752: 234c: \***********************************************************************
1753: 234c: \***
1754: 234c: \***    FORMAT.EVENT.DESCRIPTION
1755: 234c: \***
1756: 234c: \***********************************************************************
1757: 234c: \***
1758: 234c: \***    Formats the event description title and details
1759: 234c: \***
1760: 234c: \***********************************************************************
1761: 234c: FORMAT.EVENT.DESCRIPTION:
1762: 235c: 
1763: 235c:     TITLE.TEXT$ = LEFT$("Event Description " +                      \
1764: 23ac:                         STRING$(LINE.LENGTH%,"_"),                  \
1765: 23ac:                         LINE.LENGTH%)
1766: 23ac: 
1767: 23ac:     ! IF event message details available
1768: 23ac:     IF NOT (EVENT.MESSAGE.GROUP$ = " " AND                          \
1769: 23e8:             EVENT.MESSAGE.NUMBER% = 0) THEN BEGIN
1770: 23e8: 
1771: 23e8:         DISPLAY.TEXT$ =                                             \
1772: 2443:             EVENT.MESSAGE.GROUP$ +                                  \
1773: 2443:             PAD$(STR$(EVENT.MESSAGE.NUMBER%),3) + " " +             \
1774: 2443:             MESSAGE.TEXT$
1775: 2443: 
1776: 2443:     ENDIF ELSE BEGIN
1777: 244b:         DISPLAY.TEXT$ = MESSAGE.TEXT$
1778: 2467:     ENDIF
1779: 246f: 
1780: 246f:     ! IF process ID is available
1781: 246f:     IF NOT (PID$ = "") THEN BEGIN
1782: 248d:         DISPLAY.TEXT$ = DISPLAY.TEXT$ + " PID=" + PID$
1783: 24b8:     ENDIF
1784: 24c0: 
1785: 24c0:     DISPLAY.TEXT$ =                                                 \
1786: 2514:         LEFT$(DISPLAY.TEXT$ +                                       \
1787: 2514:         STRING$(LINE.LENGTH%," "),LINE.LENGTH%)
1788: 2514: 
1789: 2514:     RETURN
1790: 2524: 
1791: 2524: \***********************************************************************
1792: 2524: \***
1793: 2524: \***    FORMAT.APPLICATION.DESCRIPTION
1794: 2524: \***
1795: 2524: \***********************************************************************
1796: 2524: \***
1797: 2524: \***    Formats the event description title and details
1798: 2524: \***
1799: 2524: \***********************************************************************
1800: 2524: FORMAT.APPLICATION.DESCRIPTION:
1801: 2534: 
1802: 2534:     ! IF program is available
1803: 2534:     IF NOT PROGRAM$ = "" THEN BEGIN
1804: 2555: 
1805: 2555:         TITLE.TEXT$ = LEFT$("Application Description " +            \
1806: 25a5:                             STRING$(LINE.LENGTH%,"_"),              \
1807: 25a5:                             LINE.LENGTH%)
1808: 25a5: 
1809: 25a5:         PROGRAM.TEXT$ = LEFT$(PROGRAM$ + STRING$(8," "),8)
1810: 25f2: 
1811: 25f2:         DISPLAY.TEXT$ = PROGRAM.TEXT$ + " " +                       \
1812: 261e:                         GET.APPLICATION.DESCRIPTION$(PROGRAM.TEXT$)
1813: 261e: 
1814: 261e:         DISPLAY.TEXT$ =                                             \
1815: 2674:             LEFT$(DISPLAY.TEXT$ +                                   \
1816: 2674:             STRING$(LINE.LENGTH%," "),LINE.LENGTH%)
1817: 2674: 
1818: 2674:     ENDIF ELSE BEGIN
1819: 267c: 
1820: 267c:         ! Blank out title
1821: 267c:         TITLE.TEXT$ = STRING$(LINE.LENGTH%," ")
1822: 269d: 
1823: 269d:         ! Blank out detail lines
1824: 269d:         DISPLAY.TEXT$ = STRING$(LINE.LENGTH%," ")
1825: 26be: 
1826: 26be:     ENDIF
1827: 26c6: 
1828: 26c6:     RETURN
1829: 26d6: 
1830: 26d6: \***********************************************************************
1831: 26d6: \***
1832: 26d6: \***    FORMAT.COMMENT
1833: 26d6: \***
1834: 26d6: \***********************************************************************
1835: 26d6: \***
1836: 26d6: \***    Formats the event comment title and details
1837: 26d6: \***
1838: 26d6: \***********************************************************************
1839: 26d6: FORMAT.COMMENT:
1840: 26e6: 
1841: 26e6:     TITLE.TEXT$ = LEFT$("Event Comment " +                          \
1842: 2736:                         STRING$(LINE.LENGTH%,"_"),                  \
1843: 2736:                         LINE.LENGTH%)
1844: 2736: 
1845: 2736:     COMMENT$ = WORD.WRAP$(COMMENT$,LINE.LENGTH%)
1846: 275f: 
1847: 275f:     COMMENT$ = LEFT$(COMMENT$ +                                     \
1848: 27c0:                STRING$(LINE.LENGTH% * 4," "),LINE.LENGTH% * 4)
1849: 27c0: 
1850: 27c0:     RETURN
1851: 27d0: 
1852: 27d0: \***********************************************************************
1853: 27d0: \***
1854: 27d0: \***    FORMAT.RETURN.CODE
1855: 27d0: \***
1856: 27d0: \***********************************************************************
1857: 27d0: \***
1858: 27d0: \***    Formats the event return code title and details (if present)
1859: 27d0: \***
1860: 27d0: \***********************************************************************
1861: 27d0: FORMAT.RETURN.CODE:
1862: 27e0: 
1863: 27e0:     ERROR.TEXT$   = ""
1864: 27f5: 
1865: 27f5:     ! IF full 4-byte return code is available
1866: 27f5:     IF NOT (LEN(RETURN.CODE$) = 0 OR                                \
1867: 2883:             RETURN.CODE$ = "00000000" OR                            \
1868: 2883:             LEFT$(RETURN.CODE$,7) = "FFFFFFF") THEN BEGIN
1869: 2883: 
1870: 2883:         TITLE.TEXT$ =                                               \
1871: 28d3:             LEFT$("Return Code Description " +                      \
1872: 28d3:             STRING$(LINE.LENGTH%,"_"),LINE.LENGTH%)
1873: 28d3: 
1874: 28d3:         CODE.FOUND = FALSE
1875: 28e5: 
1876: 28e5:         I% = 1
1877: 28f3: 
1878: 28f3:         ! WHILE return code NOT found
1879: 28f3:         WHILE (NOT CODE.FOUND) AND LEN(EE$(I%)) > 0
1880: 28fe: 
1881: 28fe:             ! IF return code found
1882: 28fe:             IF RETURN.CODE$ = EE$(I%) THEN BEGIN
1883: 2931: 
1884: 2931:                 CODE.FOUND = TRUE
1885: 2943: 
1886: 2943:                 CODE.TEXT$  = "[" + SE$(I%) + "]"
1887: 2978:                 ERROR.TEXT$ = LE$(I%)
1888: 29a4: 
1889: 29a4:             ENDIF ELSE BEGIN
1890: 29ac:                 I% = I% + 1
1891: 29b8:             ENDIF
1892: 29c0: 
1893: 29c0:         WEND
1894: 29fd: 
1895: 29fd:         ! IF return code NOT found
1896: 29fd:         IF NOT CODE.FOUND THEN BEGIN
1897: 2a0f: 
1898: 2a0f:             IF LEN(RETURN.ERR$) = 0 THEN BEGIN
1899: 2a2d:                 RETURN.ERR$ = "xx"
1900: 2a44:             ENDIF
1901: 2a4c: 
1902: 2a4c:             CODE.TEXT$ = "[" + RETURN.ERR$ + "]"
1903: 2a73:             ERROR.TEXT$ = ""
1904: 2a88: 
1905: 2a88:             I% = 1
1906: 2a96: 
1907: 2a96:             ! WHILE return code NOT already found AND
1908: 2a96:             !       high word of return code NOT found
1909: 2a96:             WHILE (NOT CODE.FOUND) AND                              \
1910: 2aa1:                   LEN(HIGHWORD.ERRORCODE$(I%)) > 0
1911: 2aa1: 
1912: 2aa1:                 IF MID$(RETURN.CODE$,3,2) =                         \
1913: 2aeb:                     HIGHWORD.ERRORCODE$(I%) THEN BEGIN
1914: 2aeb: 
1915: 2aeb:                     CODE.FOUND = TRUE
1916: 2afd: 
1917: 2afd:                     ERROR.TEXT$ =                                   \
1918: 2b30:                         HIGHWORD.DESCRIPTION$(I%) + " error. "
1919: 2b30: 
1920: 2b30:                 ENDIF ELSE BEGIN
1921: 2b38:                     I% = I% + 1
1922: 2b44:                 ENDIF
1923: 2b4c: 
1924: 2b4c:             WEND
1925: 2b89: 
1926: 2b89:             CODE.FOUND = FALSE
1927: 2b9b: 
1928: 2b9b:             I% = 1
1929: 2ba9: 
1930: 2ba9:             ! WHILE return code NOT already found AND
1931: 2ba9:             !       low word of return code NOT found
1932: 2ba9:             WHILE (NOT CODE.FOUND) AND                              \
1933: 2bb4:                   LEN(LOWWORD.ERRORCODE$(I%)) > 0
1934: 2bb4: 
1935: 2bb4:                 IF RIGHT$(RETURN.CODE$,4) =                         \
1936: 2bfc:                     LOWWORD.ERRORCODE$(I%) THEN BEGIN
1937: 2bfc: 
1938: 2bfc:                     CODE.FOUND = TRUE
1939: 2c0e: 
1940: 2c0e:                     ERROR.TEXT$ =                                   \
1941: 2c45:                         ERROR.TEXT$ + LOWWORD.DESCRIPTION$(I%)
1942: 2c45: 
1943: 2c45:                 ENDIF ELSE BEGIN
1944: 2c4d:                     I% = I% + 1
1945: 2c59:                 ENDIF
1946: 2c61: 
1947: 2c61:             WEND
1948: 2c9e: 
1949: 2c9e:         ENDIF
1950: 2ca6: 
1951: 2ca6:         ! Build error details including return code and description
1952: 2ca6:         ERROR.TEXT$ = RETURN.CODE$ + " " +                          \
1953: 2cdd:                       CODE.TEXT$ + " " +                            \
1954: 2cdd:                       ERROR.TEXT$
1955: 2cdd: 
1956: 2cdd:         ! Break detail line into multiple lines with word wrapping
1957: 2cdd:         ERROR.TEXT$ = WORD.WRAP$(ERROR.TEXT$,LINE.LENGTH%)
1958: 2d01: 
1959: 2d01:         ERROR.TEXT$ = LEFT$(ERROR.TEXT$ +                           \
1960: 2d5f:                       STRING$(LINE.LENGTH% * 4," "),                \
1961: 2d5f:                       LINE.LENGTH% * 4)
1962: 2d5f: 
1963: 2d5f:     ENDIF ELSE BEGIN
1964: 2d67: 
1965: 2d67:         ! Blank out title
1966: 2d67:         TITLE.TEXT$ = STRING$(LINE.LENGTH%," ")
1967: 2d88: 
1968: 2d88:         ! Blank out detail lines
1969: 2d88:         ERROR.TEXT$ = STRING$(LINE.LENGTH% * 4," ")
1970: 2dad: 
1971: 2dad:     ENDIF
1972: 2db5: 
1973: 2db5:     RETURN
1974: 2dc5: 
1975: 2dc5: \***********************************************************************
1976: 2dc5: \***
1977: 2dc5: \***    FORMAT.UNIQUE.DATA
1978: 2dc5: \***
1979: 2dc5: \***********************************************************************
1980: 2dc5: \***
1981: 2dc5: \***    Formats the event unique data title and details
1982: 2dc5: \***
1983: 2dc5: \***********************************************************************
1984: 2dc5: FORMAT.UNIQUE.DATA:
1985: 2dd5: 
1986: 2dd5:     TITLE.TEXT$ = LEFT$("Event Unique Data " +                      \
1987: 2e25:                         STRING$(LINE.LENGTH%,"_"),                  \
1988: 2e25:                         LINE.LENGTH%)
1989: 2e25: 
1990: 2e25:     DISPLAY.TEXT$ =                                                 \
1991: 2e6a:         "*" + BOLD.TEXT$(ASC.TEXT$(EVENT.UNIQUE.DATA$)) + "*"           !CMW
1992: 2e6a: 
1993: 2e6a:     DISPLAY.TEXT$ =                                                 \
1994: 2ecb:         DISPLAY.TEXT$ + " " +                                       \
1995: 2ecb:         "[" + BOLD.TEXT$(HEX.TEXT$(UNPACK$(EVENT.UNIQUE.DATA$))) + "]"  !CMW
1996: 2ecb: 
1997: 2ecb:     DISPLAY.TEXT$ =                                                 \
1998: 2efe:         DISPLAY.TEXT$ + " " +                                       \
1999: 2efe:         "Format = " + STR$(EVENT.FORMAT%)
2000: 2efe: 
2001: 2efe:     DISPLAY.TEXT$ =                                                 \
2002: 2f52:         LEFT$(DISPLAY.TEXT$ +                                       \
2003: 2f52:         STRING$(LINE.LENGTH%," "),LINE.LENGTH%)
2004: 2f52: 
2005: 2f52:     RETURN
2006: 2f62: 
2007: 2f62: END SUB
2008: 2f76: 
2009: 2f76: End of Compilation
