   1: 0000: \***********************************************************************
   2: 0000: \***********************************************************************
   3: 0000: \***
   4: 0000: \***    PROGRAM         :       PSU04
   5: 0000: \***    DESCRIPTION     :       Event log viewer utility
   6: 0000: \***    AUTHOR          :       Mark Walker
   7: 0000: \***    DATE            :       26th September 2017
   8: 0000: \***
   9: 0000: \***********************************************************************
  10: 0000: \***********************************************************************
  11: 0000: \***
  12: 0000: \***    Module 1 contains formatting of the contents of the detail
  13: 0000: \***    screen for all 4690 operating system related events. This
  14: 0000: \***    includes controller hardware errors, terminal hardware
  15: 0000: \***    errors, terminal events, controller events and system events.
  16: 0000: \***
  17: 0000: \***********************************************************************
  18: 0000: \***********************************************************************
  19: 0000: \***
  20: 0000: \***    MODIFICATIONS
  21: 0000: \***
  22: 0000: \***    Version A.          Mark Walker                 26th Sep 2017
  23: 0000: \***    Initial version.
  24: 0000: \***
  25: 0000: \***    Version B.          Mark Walker                  2nd Nov 2017
  26: 0000: \***    - Updated comment for start and end of command mode sessions.
  27: 0000: \***    - Removed leading and trailing spaces from application names
  28: 0000: \***      in long W message descriptions.
  29: 0000: \***
  30: 0000: \***    Version C.          Mark Walker                  6th Nov 2017
  31: 0000: \***    - Use fast byte matching routine instead of MATCH statement
  32: 0000: \***      for performance reasons.
  33: 0000: \***
  34: 0000: \***    Version D.          Mark Walker                 15th Nov 2017
  35: 0000: \***    Added support for reporting application events logged by
  36: 0000: \***    the UTILS application.
  37: 0000: \***
  38: 0000: \***    Version E.          Mark Walker                 21st Nov 2017
  39: 0000: \***    - Display full 4-byte integer process ID.
  40: 0000: \***    - Updated comment for missing event logs.
  41: 0000: \***
  42: 0000: \***    Version F.          Mark Walker                 24th Nov 2017
  43: 0000: \***    - Reduced size of the comment for missing event logs to
  44: 0000: \***      prevent it being truncated.
  45: 0000: \***
  46: 0000: \***    Version G.          Mark Walker                  6th Dec 2017
  47: 0000: \***    Relocated public functions to a common module.
  48: 0000: \***
  49: 0000: \***********************************************************************
  50: 0000: \***********************************************************************
  51: 0000: 
  52: 0000: \***********************************************************************
  53: 0000: \***
  54: 0000: \***    Global variable declarations
  55: 0000: \***
  56: 0000: \***********************************************************************
  57: 0000: 
  58: 0000: %INCLUDE PSU04G.J86
  59: 0000: \***********************************************************************
  60: 0000: \***********************************************************************
  61: 0000: \***
  62: 0000: \***    GLOBAL VARIABLE DEFINITIONS FOR PSU04
  63: 0000: \***
  64: 0000: \***********************************************************************
  65: 0000: \***********************************************************************
  66: 0000: \***
  67: 0000: \***    MODIFICATIONS
  68: 0000: \***
  69: 0000: \***    Version A.          Mark Walker                 26th Sep 2017
  70: 0000: \***    Initial version.
  71: 0000: \***
  72: 0000: \***    Version B.          Mark Walker                  2nd Nov 2017
  73: 0000: \***    Added support for the source selection list.
  74: 0000: \***
  75: 0000: \***    Version C.          Mark Walker                  6th Nov 2017
  76: 0000: \***    Updated handling of bucket and source text descriptions.
  77: 0000: \***
  78: 0000: \***    Version D.          Mark Walker                 21st Nov 2017
  79: 0000: \***    Added support for the UTILS session screen.
  80: 0000: \***
  81: 0000: \***    Version E.          Mark Walker                  6th Dec 2017
  82: 0000: \***    Moved some local variables to globals to support moving
  83: 0000: \***    some functions from the main screen handling module to
  84: 0000: \***    an external subprogram.
  85: 0000: \***
  86: 0000: \***    Version F.          Mark Walker                 19th Mar 2017
  87: 0000: \***    Added support for reporting application events logged by
  88: 0000: \***    text file editor applications.
  89: 0000: \***
  90: 0000: \***********************************************************************
  91: 0000: \***********************************************************************
  92: 0000: 
  93: 0000:     INTEGER*1 GLOBAL CURRENT.FIELD%                                     !EMW
  94: 0000:     INTEGER*1 GLOBAL FALSE
  95: 0000:     INTEGER*1 GLOBAL OPEN.EVAPP
  96: 0000:     INTEGER*1 GLOBAL TRUE
  97: 0000:     INTEGER*1 GLOBAL U0401.APPLICATION%
  98: 0000:     INTEGER*1 GLOBAL U0401.APPLICATION.STATUS%
  99: 0000:     INTEGER*1 GLOBAL U0401.BUCKET%
 100: 0000:     INTEGER*1 GLOBAL U0401.BUCKET.STATUS%
 101: 0000:     INTEGER*1 GLOBAL U0401.CONTROLLER.ID%
 102: 0000:     INTEGER*1 GLOBAL U0401.CONTROLLER.ID.STATUS%
 103: 0000:     INTEGER*1 GLOBAL U0401.EVENT%
 104: 0000:     INTEGER*1 GLOBAL U0401.EVENT.STATUS%
 105: 0000:     INTEGER*1 GLOBAL U0401.LOG.DESC%
 106: 0000:     INTEGER*1 GLOBAL U0401.LOG.NUMBER%
 107: 0000:     INTEGER*1 GLOBAL U0401.MESSAGE.GROUP%
 108: 0000:     INTEGER*1 GLOBAL U0401.MESSAGE.GROUP.STATUS%
 109: 0000:     INTEGER*1 GLOBAL U0401.MESSAGE.NUMBER%
 110: 0000:     INTEGER*1 GLOBAL U0401.MESSAGE.NUMBER.STATUS%
 111: 0000:     INTEGER*1 GLOBAL U0401.SEVERITY%
 112: 0000:     INTEGER*1 GLOBAL U0401.SEVERITY.STATUS%
 113: 0000:     INTEGER*1 GLOBAL U0401.SOURCE%
 114: 0000:     INTEGER*1 GLOBAL U0401.SOURCE.STATUS%
 115: 0000:     INTEGER*1 GLOBAL U0401.TERMINAL%
 116: 0000:     INTEGER*1 GLOBAL U0401.TERMINAL.STATUS%
 117: 0000:     INTEGER*1 GLOBAL U0402.PAGE%
 118: 0000:     INTEGER*1 GLOBAL U0405.PAGE%
 119: 0000:     INTEGER*1 GLOBAL U0406.PAGE%
 120: 0000:     INTEGER*1 GLOBAL U0411.PAGE%                                        !BMW
 121: 0000:     INTEGER*1 GLOBAL U0412.PAGE%                                        !DMW
 122: 0000:     INTEGER*1 GLOBAL VALID.INPUT
 123: 0000:     INTEGER*1 GLOBAL VALID.KEY
 124: 0000: 
 125: 0000:     INTEGER*2 GLOBAL APPLICATIONS.PER.PAGE%
 126: 0000:     INTEGER*2 GLOBAL COMMAND.TIME.RANGE%
 127: 0000:     INTEGER*2 GLOBAL COMMANDS.PER.PAGE%
 128: 0000:     INTEGER*2 GLOBAL CURRENT.INDEX%                                     !EMW
 129: 0000:     INTEGER*2 GLOBAL CURRENT.REPORT.NUM%
 130: 0000:     INTEGER*2 GLOBAL EVENT.BUCKET%
 131: 0000:     INTEGER*2 GLOBAL EVENT.COUNT%
 132: 0000:     INTEGER*2 GLOBAL EVENT.DAY%
 133: 0000:     INTEGER*2 GLOBAL EVENT.FORMAT%
 134: 0000:     INTEGER*2 GLOBAL EVENT.HOUR%
 135: 0000:     INTEGER*2 GLOBAL EVENT.MESSAGE.NUMBER%
 136: 0000:     INTEGER*2 GLOBAL EVENT.MIN%
 137: 0000:     INTEGER*2 GLOBAL EVENT.MONTH%
 138: 0000:     INTEGER*2 GLOBAL EVENT.NODE.ID%
 139: 0000:     INTEGER*2 GLOBAL EVENT.NUMBER%
 140: 0000:     INTEGER*2 GLOBAL EVENT.SEVERITY%
 141: 0000:     INTEGER*2 GLOBAL EVENT.SOURCE%
 142: 0000:     INTEGER*2 GLOBAL EVENT.TERMINAL%
 143: 0000:     INTEGER*2 GLOBAL EVENT.YEAR%
 144: 0000:     INTEGER*2 GLOBAL FILES.PER.PAGE%
 145: 0000:     INTEGER*2 GLOBAL LINE.LENGTH%
 146: 0000:     INTEGER*2 GLOBAL MAX.FILE.RECORDS%
 147: 0000:     INTEGER*2 GLOBAL MAX.SOURCE.RECORDS%                                !BMW
 148: 0000:     INTEGER*2 GLOBAL NULL.MAPPING%                                      !BMW
 149: 0000:     INTEGER*2 GLOBAL RESULTS.COUNT%                                     !EMW
 150: 0000:     INTEGER*2 GLOBAL RESULTS.INDEX%                                     !EMW
 151: 0000:     INTEGER*2 GLOBAL RESULTS.LAST.PAGE%                                 !EMW
 152: 0000:     INTEGER*2 GLOBAL RESULTS.PAGE%                                      !EMW
 153: 0000:     INTEGER*2 GLOBAL RESULTS.PER.PAGE%
 154: 0000:     INTEGER*2 GLOBAL RESULTS.THIS.PAGE%                                 !EMW
 155: 0000:     INTEGER*2 GLOBAL RESULTS.TOTAL.PAGES%                               !EMW
 156: 0000:     INTEGER*2 GLOBAL SOURCES.PER.PAGE%                                  !BMW
 157: 0000:     INTEGER*2 GLOBAL ULOG.REPORT.NUM%                                   !DMW
 158: 0000:     INTEGER*2 GLOBAL ULOG.SESS.NUM%                                     !DMW
 159: 0000: 
 160: 0000:     INTEGER*4 GLOBAL EVENT.DATE%
 161: 0000:     INTEGER*4 GLOBAL EVENT.TIME%
 162: 0000: 
 163: 0000:     STRING GLOBAL ALL.APPLICATIONS.TEXT$
 164: 0000:     STRING GLOBAL ALL.BUCKETS.TEXT$
 165: 0000:     STRING GLOBAL ALL.CONTROLLERS.TEXT$
 166: 0000:     STRING GLOBAL ALL.EVENTS.TEXT$
 167: 0000:     STRING GLOBAL ALL.MESSAGE.GROUPS.TEXT$
 168: 0000:     STRING GLOBAL ALL.MESSAGE.NUMBERS.TEXT$
 169: 0000:     STRING GLOBAL ALL.SEVERITYS.TEXT$
 170: 0000:     STRING GLOBAL ALL.SOURCES.TEXT$
 171: 0000:     STRING GLOBAL ALL.TERMINALS.TEXT$
 172: 0000:     STRING GLOBAL BATCH.SCREEN.FLAG$
 173: 0000:     STRING GLOBAL BUCKET.TEXT$(1)
 174: 0000:     STRING GLOBAL CHAIN.TO.PROG$
 175: 0000:     STRING GLOBAL COMMENT$
 176: 0000:     STRING GLOBAL CONTROLLER.ID$
 177: 0000:     STRING GLOBAL CURRENT.CODE$
 178: 0000:     STRING GLOBAL DOW$(1)
 179: 0000:     STRING GLOBAL EDITOR.NAME$                                          !FMW
 180: 0000:     STRING GLOBAL EDITOR.PATHNAME$                                      !FMW
 181: 0000:     STRING GLOBAL EDITOR.PROGRAM$                                       !FMW
 182: 0000:     STRING GLOBAL EDITOR.TYPE$                                          !FMW
 183: 0000:     STRING GLOBAL EE$(1)
 184: 0000:     STRING GLOBAL EVENT.DOW$
 185: 0000:     STRING GLOBAL EVENT.MESSAGE.GROUP$
 186: 0000:     STRING GLOBAL EVENT.UNIQUE.DATA$
 187: 0000:     STRING GLOBAL FILE.OPERATION$
 188: 0000:     STRING GLOBAL HIGHWORD.DESCRIPTION$(1)
 189: 0000:     STRING GLOBAL HIGHWORD.ERRORCODE$(1)
 190: 0000:     STRING GLOBAL LA$(1)
 191: 0000:     STRING GLOBAL LE$(1)
 192: 0000:     STRING GLOBAL LJ$(1)
 193: 0000:     STRING GLOBAL LOG.DESC$
 194: 0000:     STRING GLOBAL LOG.NUMBER$
 195: 0000:     STRING GLOBAL LOWWORD.DESCRIPTION$(1)
 196: 0000:     STRING GLOBAL LOWWORD.ERRORCODE$(1)
 197: 0000:     STRING GLOBAL LW$(1)
 198: 0000:     STRING GLOBAL MESSAGE.TEXT$
 199: 0000:     STRING GLOBAL MODULE.NUMBER$
 200: 0000:     STRING GLOBAL NO.APPLICATIONS.TEXT$
 201: 0000:     STRING GLOBAL NO.BUCKETS.TEXT$
 202: 0000:     STRING GLOBAL NO.SEVERITYS.TEXT$
 203: 0000:     STRING GLOBAL NO.SOURCES.TEXT$                                      !BMW
 204: 0000:     STRING GLOBAL NONPRINTABLE.CHARS$
 205: 0000:     STRING GLOBAL NONPRINTABLE.MAP$
 206: 0000:     STRING GLOBAL NULL.FILENAME$
 207: 0000:     STRING GLOBAL NULL.PROGRAM$
 208: 0000:     STRING GLOBAL PID$
 209: 0000:     STRING GLOBAL PRINTABLE.CHARS$
 210: 0000:     STRING GLOBAL PROGRAM$
 211: 0000:     STRING GLOBAL R$(1)
 212: 0000:     STRING GLOBAL RETURN.CODE$
 213: 0000:     STRING GLOBAL RETURN.ERR$
 214: 0000:     STRING GLOBAL SE$(1)
 215: 0000:     STRING GLOBAL SELECTED.APPLICATIONS.TEXT$
 216: 0000:     STRING GLOBAL SELECTED.BUCKETS.TEXT$
 217: 0000:     STRING GLOBAL SELECTED.SEVERITYS.TEXT$
 218: 0000:     STRING GLOBAL SELECTED.SOURCES.TEXT$                                !BMW
 219: 0000:     STRING GLOBAL SEVERITY.TEXT$(1)
 220: 0000:     STRING GLOBAL SINGLE.APPLICATION.TEXT$
 221: 0000:     STRING GLOBAL SINGLE.BUCKET.TEXT$
 222: 0000:     STRING GLOBAL SINGLE.CONTROLLER.TEXT$
 223: 0000:     STRING GLOBAL SINGLE.EVENT.TEXT$
 224: 0000:     STRING GLOBAL SINGLE.MESSAGE.GROUP.TEXT$
 225: 0000:     STRING GLOBAL SINGLE.MESSAGE.NUMBER.TEXT$
 226: 0000:     STRING GLOBAL SINGLE.SEVERITY.TEXT$
 227: 0000:     STRING GLOBAL SINGLE.SOURCE.TEXT$
 228: 0000:     STRING GLOBAL SINGLE.TERMINAL.TEXT$
 229: 0000:     STRING GLOBAL SUMMARY.RECORD$(1)                                    !EMW
 230: 0000:     STRING GLOBAL SOURCE.TEXT$(1)                                       !CMW
 231: 0000:     STRING GLOBAL SS$(1)
 232: 0000:     STRING GLOBAL SW$(1)
 233: 0000:     STRING GLOBAL TILL.NUMBER$
 234: 0000:     STRING GLOBAL TS$(1)
 235: 0000:     STRING GLOBAL ULOG.FILE.NAME$                                       !DMW
 236: 0000:     STRING GLOBAL ULOG.RECORD$(1)                                       !EMW
 237: 0000: 
 238: 0000: 
 239: 0000: \***********************************************************************
 240: 0000: \***
 241: 0000: \***    Local variable declarations
 242: 0000: \***
 243: 0000: \***********************************************************************
 244: 0000: 
 245: 0000:     INTEGER*2 I%
 246: 0000:     INTEGER*2 INDEX%
 247: 0000:     INTEGER*2 M%
 248: 0000: 
 249: 0000:     STRING ACTION$
 250: 0000:     STRING ACTION.TEXT$
 251: 0000:     STRING CMD$
 252: 0000:     STRING COLORS$
 253: 0000:     STRING DEVICE.ID$
 254: 0000:     STRING DRIVE$
 255: 0000:     STRING FILENAME$
 256: 0000:     STRING ID$
 257: 0000:     STRING IP.ADDRESS$
 258: 0000:     STRING LIBRARY$
 259: 0000:     STRING LINK.ID$
 260: 0000:     STRING NAME$
 261: 0000:     STRING NODE$
 262: 0000:     STRING NODE2$
 263: 0000:     STRING OFFSET$
 264: 0000:     STRING OPERATOR$
 265: 0000:     STRING ORIGIN$
 266: 0000:     STRING REASON$
 267: 0000:     STRING REASON.TEXT$
 268: 0000:     STRING RESX$
 269: 0000:     STRING RESY$
 270: 0000:     STRING TERMINAL$
 271: 0000:     STRING TYPE$
 272: 0000:     STRING TYPE.TEXT$
 273: 0000:     STRING USER.ID$
 274: 0000:     STRING VBE$
 275: 0000: 
 276: 0000: \***********************************************************************
 277: 0000: \***
 278: 0000: \***    External function definitions
 279: 0000: \***
 280: 0000: \***********************************************************************
 281: 0000: 
 282: 0000: %INCLUDE BTCMEM.J86
 283: 0000: !********************************************************************
 284: 0000: !***
 285: 0000: !***    INCLUDED CODE:  BTCMEM.J86
 286: 0000: !***    AUTHOR:         Stuart William McConnachie
 287: 0000: !***    DATE:           26th February 2006
 288: 0000: !***
 289: 0000: !********************************************************************
 290: 0000: !***
 291: 0000: !***    Controller CBASIC Memory Functions
 292: 0000: !***
 293: 0000: !********************************************************************
 294: 0000: 
 295: 0000: !Get a single byte integer from a string offset
 296: 0000: FUNCTION GETN1 (S$, P%) EXTERNAL
 297: 0000:     STRING S$
 298: 0000:     INTEGER*2 P%
 299: 0000:     INTEGER*2 GETN1
 300: 0000: END FUNCTION
 301: 0000: 
 302: 0000: !Get a two byte integer from a string offset
 303: 0000: FUNCTION GETN2 (S$, P%) EXTERNAL
 304: 0000:     STRING S$
 305: 0000:     INTEGER*2 P%
 306: 0000:     INTEGER*2 GETN2
 307: 0000: END FUNCTION
 308: 0000: 
 309: 0000: !Get a four byte integer from a string offset
 310: 0000: FUNCTION GETN4 (S$, P%) EXTERNAL
 311: 0000:     STRING S$
 312: 0000:     INTEGER*2 P%
 313: 0000:     INTEGER*4 GETN4
 314: 0000: END FUNCTION
 315: 0000: 
 316: 0000: !Get a 10 byte CBASIC real from a string offset
 317: 0000: FUNCTION GETR10 (S$, P%) EXTERNAL
 318: 0000:     STRING S$
 319: 0000:     INTEGER*2 P%
 320: 0000:     REAL GETR10
 321: 0000: END FUNCTION
 322: 0000: 
 323: 0000: !Put a single byte integer into a string at offset
 324: 0000: FUNCTION PUTN1 (S$, P%, N%) EXTERNAL
 325: 0000:     STRING S$
 326: 0000:     INTEGER*2 P%
 327: 0000:     INTEGER*1 N%
 328: 0000:     INTEGER*1 PUTN1
 329: 0000: END FUNCTION
 330: 0000: 
 331: 0000: !Put a two byte integer into a string at offset
 332: 0000: FUNCTION PUTN2 (S$, P%, N%) EXTERNAL
 333: 0000:     STRING S$
 334: 0000:     INTEGER*2 P%
 335: 0000:     INTEGER*2 N%
 336: 0000:     INTEGER*1 PUTN2
 337: 0000: END FUNCTION
 338: 0000: 
 339: 0000: !Put a four byte integer into a string at offset
 340: 0000: FUNCTION PUTN4 (S$, P%, N%) EXTERNAL
 341: 0000:     STRING S$
 342: 0000:     INTEGER*2 P%
 343: 0000:     INTEGER*4 N%
 344: 0000:     INTEGER*1 PUTN4
 345: 0000: END FUNCTION
 346: 0000: 
 347: 0000: !Put a 10 byte CBASIC real into a string at offset
 348: 0000: FUNCTION PUTR10 (S$, P%, R) EXTERNAL
 349: 0000:     STRING S$
 350: 0000:     INTEGER*2 P%
 351: 0000:     REAL R
 352: 0000:     INTEGER*1 PUTR10
 353: 0000: END FUNCTION
 354: 0000: 
 355: 0000: !Peek a two byte integer from a memory address
 356: 0000: FUNCTION PEEKN2 (A%) EXTERNAL
 357: 0000:     INTEGER*4 A%
 358: 0000:     INTEGER*2 PEEKN2
 359: 0000: END FUNCTION
 360: 0000: 
 361: 0000: !Peek a four byte integer from a memory address
 362: 0000: FUNCTION PEEKN4 (A%) EXTERNAL
 363: 0000:     INTEGER*4 A%
 364: 0000:     INTEGER*4 PEEKN4
 365: 0000: END FUNCTION
 366: 0000: 
 367: 0000: !Peek a 10 byte CBASIC real from a memory address
 368: 0000: FUNCTION PEEKR10 (A%) EXTERNAL
 369: 0000:     INTEGER*4 A%
 370: 0000:     REAL PEEKR10
 371: 0000: END FUNCTION
 372: 0000: 
 373: 0000: !Poke a two byte integer to a memory address
 374: 0000: FUNCTION POKEN2 (A%, N%) EXTERNAL
 375: 0000:     INTEGER*4 A%
 376: 0000:     INTEGER*2 N%
 377: 0000:     INTEGER*1 POKEN2
 378: 0000: END FUNCTION
 379: 0000: 
 380: 0000: !Poke a four byte integer to a memory address
 381: 0000: FUNCTION POKEN4 (A%, N%) EXTERNAL
 382: 0000:     INTEGER*4 A%
 383: 0000:     INTEGER*4 N%
 384: 0000:     INTEGER*1 POKEN4
 385: 0000: END FUNCTION
 386: 0000: 
 387: 0000: !Poke a 10 byte CBASIC real to a memory address
 388: 0000: FUNCTION POKER10 (A%, R) EXTERNAL
 389: 0000:     INTEGER*4 A%
 390: 0000:     REAL R
 391: 0000:     INTEGER*1 POKER10
 392: 0000: END FUNCTION
 393: 0000: 
 394: 0000: %INCLUDE STREXT.J86
 395: 0000: \*******************************************************************************
 396: 0000: \*******************************************************************************
 397: 0000: \***
 398: 0000: \***    REFERENCE   :   STREXT
 399: 0000: \***
 400: 0000: \*******************************************************************************
 401: 0000: \***
 402: 0000: \***    OVERVIEW:
 403: 0000: \***
 404: 0000: \***    This module contains common external function and subprogram
 405: 0000: \***    definitions used for string processing.
 406: 0000: \***
 407: 0000: \***    CONTENTS:
 408: 0000: \***
 409: 0000: \***    RTRIM$ - Removes the specified trailing character from a string
 410: 0000: \***    LTRIM$ - Removes the specified leading character from a string
 411: 0000: \***    TRIM$  - Removes the specified leading and trailing character
 412: 0000: \***             from a string
 413: 0000: \***
 414: 0000: \*******************************************************************************
 415: 0000: \***
 416: 0000: \***    MODIFICATIONS:
 417: 0000: \***
 418: 0000: \***    Version A.              Mark Walker                     24th Jul 2015
 419: 0000: \***    Initial version.
 420: 0000: \***
 421: 0000: \***    Version B.              Mark Walker                     24th Nov 2016
 422: 0000: \***    Added TRIM$ function.
 423: 0000: \***
 424: 0000: \*******************************************************************************
 425: 0000: \*******************************************************************************
 426: 0000: 
 427: 0000: FUNCTION RTRIM$(SOURCE$,TRIM.CHAR$) EXTERNAL
 428: 0000:     STRING    TRIM.CHAR$
 429: 0000:     STRING    SOURCE$
 430: 0000:     STRING    RTRIM$
 431: 0000: END FUNCTION
 432: 0000: 
 433: 0000: FUNCTION LTRIM$(SOURCE$,TRIM.CHAR$) EXTERNAL
 434: 0000:     STRING    TRIM.CHAR$
 435: 0000:     STRING    SOURCE$
 436: 0000:     STRING    LTRIM$
 437: 0000: END FUNCTION
 438: 0000: 
 439: 0000: FUNCTION TRIM$(SOURCE$,TRIM.CHAR$) EXTERNAL                             !BMW
 440: 0000:     STRING    TRIM.CHAR$                                                !BMW
 441: 0000:     STRING    SOURCE$                                                   !BMW
 442: 0000:     STRING    TRIM$                                                     !BMW
 443: 0000: END FUNCTION                                                            !BMW
 444: 0000: 
 445: 0000: %INCLUDE BASROUT.J86    ! OSSHELL function
 446: 0000: \*LIB   BVEJ BASROUT  J86      03/11/97 08:16:26 PIDBLD3  *    FIX
 447: 0000: \*PROM  BVEJ BASROUT  J86      03/10/97 17:18:40 PIDBLD3  MVEJ IR34352
 448: 0000: \*RTIME BVEJ BASROUT  J86      03/10/97 17:18:41 PIDBLD3  MVEJ IR34352
 449: 0000: \*LIB   MVEJ BASROUT  J86      03/05/97 10:48:46 EDJRAL   *    IR34352
 450: 0000: \*LIB   MVEJ BASROUT  J86      02/17/97 11:19:56 EDJRAL   *    REASONAR
 451: 0000: \*LIB   MVEJ BASROUT  J86      02/14/97 15:59:11 EDJRAL   *    REASONAR
 452: 0000: ! BASROUT.J86 - this file is to be included in any BASIC code which utilizes
 453: 0000: !   the BASROUT.OBJ routines.  These routines were written
 454: 0000: !  using Metaware C and are intended to provide functions which
 455: 0000: !         are either not available in 4680 CBASIC or which can be more
 456: 0000: !               efficiently handled by the C language.  Their usage is
 457: 0000: !  offered on an "AT YOUR OWN RISK" basis.
 458: 0000: !
 459: 0000: !               The insert/extract routines usefulness may not be immediately
 460: 0000: !               apparent.  Their intention is that they be used in conjunction
 461: 0000: !               with a read/write form command.  They can more efficiently
 462: 0000: !               parse a string into many different variables than can the
 463: 0000: !               read form statement.  So instead of a long list of data var's
 464: 0000: !               it may be more efficient to just read/write one long string
 465: 0000: !               and then use the insert/extract routines to parse out the
 466: 0000: !   data.
 467: 0000: 
 468: 0000: ! ******************* SUB PROCESS FUNCTIONS *********************************
 469: 0000: 
 470: 0000: function osshell(cmd.line$) external   ! routine to start
 471: 0000:        ! another program.
 472: 0000:            integer*4    osshell    ! Upon completion of
 473: 0000:            string       cmd.line$   ! program, control is
 474: 0000:        ! returned to calling
 475: 0000: end function      ! program.
 476: 0000: !
 477: 0000: ! NOTES:  Program must be a 286 type file.  This does not exclude
 478: 0000: !         the capability to execute a batch file however.  Simply pass the
 479: 0000: !         following:
 480: 0000: !              c:\adx_spgm\command.286 batfile
 481: 0000: !         where batfile is the name of the batch file to be executed.
 482: 0000: !
 483: 0000: ! IMPORTANT: When using osshell to execute a batch file as described above,
 484: 0000: !            the final command in the batch file must be "exit".  If not,
 485: 0000: !       control is never given back to the calling program.
 486: 0000: 
 487: 0000: ! ************************ MEMORY RELATED FUNCTIONS ************************
 488: 0000: 
 489: 0000: function memfree(choice) external   ! routine to que the
 490: 0000:        ! status of the
 491: 0000:  integer*4 memfree    ! machine's memory:
 492: 0000:  integer*2 choice    ! Options:
 493: 0000:        !    1 - free
 494: 0000: end function      !    2 - total
 495: 0000:        !    3 - system
 496: 0000: 
 497: 0000: ! ********************** TIMEDATE RELATED FUNCTIONS ************************
 498: 0000: 
 499: 0000: function timedate(choice) external   ! routine to que the
 500: 0000:        ! OS's timedate table
 501: 0000:  integer*4 timedate   ! Choices:
 502: 0000:  integer*2 choice    !    1 - millisec's
 503: 0000:        !        since midnight
 504: 0000: end function      !    2 - minutes from
 505: 0000:        !  UCT (timezone)
 506: 0000:        !    3 - day of week
 507: 0000:        !   0-Sunday
 508: 0000:        !  6-Saturday
 509: 0000: 
 510: 0000: function settime(msecs) external   ! routine to set the
 511: 0000:        ! time on the controller
 512: 0000:  integer*4  settime    ! msecs is the desired
 513: 0000:  integer*4 msecs    ! number of milliseconds
 514: 0000:        ! since midnight
 515: 0000: end function      ! Returns negative on
 516: 0000:        ! error
 517: 0000: ! NOTE:  This routine sets the time only on the controller.  The terminals'
 518: 0000: ! time will not be updated until 1 AM or unless a terminal is STC'd.
 519: 0000: ! At 1 AM the controller broadcasts the new time to all terminals.
 520: 0000: ! Insure this is taken into consideration when using this routine.
 521: 0000: 
 522: 0000: !******************** DISK FILE RELATED FUNCTIONS *************************
 523: 0000: 
 524: 0000: function truncate(name,length) external   ! routine to truncate
 525: 0000:        ! the specified file
 526: 0000:  integer*4 truncate   ! to a given length.
 527: 0000:  string  name
 528: 0000:  integer*4 length
 529: 0000: 
 530: 0000: end function
 531: 0000: 
 532: 0000: !******************** STRING VALUE RELATED FUNCTIONS **********************
 533: 0000: 
 534: 0000: function isalpha(bstrn) external   ! routine to identify
 535: 0000:        ! if the specified
 536: 0000:  integer*1 isalpha    ! string contains all
 537: 0000:  string  bstrn    ! alphabetic char's
 538: 0000:        ! Returns:
 539: 0000: end function      !     0 - all alpha
 540: 0000:        !     X - byte of 1st
 541: 0000:        !         non-alpha
 542: 0000:        !   char
 543: 0000: 
 544: 0000: function isdigit(bstrn) external   ! routine to identify
 545: 0000:        ! if the specified
 546: 0000:  integer*1 isdigit    ! string contains all
 547: 0000:  string  bstrn    ! numeric char's
 548: 0000:        ! Returns:
 549: 0000: end function      !     0 - all numeric
 550: 0000:        !     X - byte of 1st
 551: 0000:        !         non-numeric
 552: 0000:        !   char
 553: 0000: 
 554: 0000: function islower(bstrn) external   ! routine to identify
 555: 0000:        ! if the specified
 556: 0000:  integer*1 islower    ! string contains all
 557: 0000:  string  bstrn    ! lower case char's
 558: 0000:        ! Returns:
 559: 0000: end function      !     0 - all lowercase
 560: 0000:        !     X - byte of 1st
 561: 0000:        !         non-lowercase
 562: 0000:        !   char
 563: 0000: 
 564: 0000: function isupper(bstrn) external   ! routine to identify
 565: 0000:        ! if the specified
 566: 0000:  integer*1 isupper    ! string contains all
 567: 0000:  string  bstrn    ! upper case char's
 568: 0000:        ! Returns:
 569: 0000: end function      !     0 - all uppercase
 570: 0000:        !     X - byte of 1st
 571: 0000:        !         non-uppercase
 572: 0000:        !   char
 573: 0000: 
 574: 0000: function toalpha(bstrn) external   ! routine to convert
 575: 0000:        ! non-alpha or non-num
 576: 0000:    integer*2 toalpha    ! char's to spaces
 577: 0000:  string  bstrn    ! Returns:
 578: 0000: end function      !   x - no. of char's
 579: 0000:        !       changed
 580: 0000: 
 581: 0000: ! ********************* USER/GROUP ZERO LEVEL FUNCTIONS *********************
 582: 0000: 
 583: 0000: function idlecount(choice) external   ! routine to either
 584: 0000:        ! set to zero or queue
 585: 0000:  integer*4 idlecount   ! the value of the
 586: 0000:  integer*1 choice    ! processor's idlecount
 587: 0000:        ! Choice:
 588: 0000: end function      !     0 - set to zero
 589: 0000: !       !     1 - get value
 590: 0000: ! NEEDS USER/GROUP 0 LEVEL OF AUTHORIZATION  ! Returns:
 591: 0000: ! TO WORK - This level is not available unless  !     X - idlecount
 592: 0000: ! the file ADXCSOUF.DAT file is "patched".  This !    -X - error code
 593: 0000: ! is highly unrecommended.
 594: 0000: 
 595: 0000: function logical(actname,logname,choice) external ! routine to set a
 596: 0000:        ! a logical name.
 597: 0000:  integer*4 logical    ! parms are self
 598: 0000:         string  logname    ! explanatory except
 599: 0000:  string  actname    ! for choice:
 600: 0000:  integer*1 choice    !   0 - set process
 601: 0000:        !   1 - set system
 602: 0000: end function      !   2 - get process
 603: 0000:        !   3 - get system
 604: 0000: 
 605: 0000: ! NOTE:  Only the setting of a system level of logical name requires
 606: 0000: ! user/group zero level of authorization.  Any application may query any
 607: 0000: ! logical name.  Setting of a system logical name is only applicable until
 608: 0000: ! the system is IPL'd.  A process logical name is only active when that
 609: 0000: ! process is active.
 610: 0000: 
 611: 0000: !******************** STRING PARSING FUNCTIONS *****************************
 612: 0000: 
 613: 0000: function inserts(whole,part,offset) external  ! routine to insert a
 614: 0000:        ! string (part) into
 615: 0000:  integer*2 INSERTS    ! another string (whole)
 616: 0000:  string  whole    ! starting at specified
 617: 0000:  string  part    ! character (offset)
 618: 0000:  integer*2 offset
 619: 0000: 
 620: 0000: end function
 621: 0000: 
 622: 0000: function cinsert4(integer4,bstring,offset) external   ! routine to insert
 623: 0000:        ! a 4-byte integer into
 624: 0000:  integer*1 cinsert4   ! a string starting at
 625: 0000:  integer*4 integer4   ! byte specified by
 626: 0000:  string  bstring    ! offset (1-based)
 627: 0000:  integer*2 offset    ! Returns:
 628: 0000:        !     0 - Success
 629: 0000: end function      !    -1 - String overrun
 630: 0000: 
 631: 0000: function cinsert2(integer2,bstring,offset) external  ! routine to insert
 632: 0000:        ! a 2-byte integer into
 633: 0000:  integer*1 cinsert2   ! a string starting at
 634: 0000:  integer*2 integer2   ! byte specified by
 635: 0000:  string  bstring    ! offset (1-based)
 636: 0000:  integer*2 offset    ! Returns:
 637: 0000:        !     0 - Success
 638: 0000: end function      !    -1 - String overrun
 639: 0000: 
 640: 0000: function cinsert1(bstring,integer1,offset) external  ! routine to insert
 641: 0000:        ! a 1-byte integer into
 642: 0000:  integer*1 cinsert1   ! a string starting at
 643: 0000:  integer*1 integer1   ! byte specified by
 644: 0000:  string  bstring    ! offset (1-based)
 645: 0000:  integer*2 offset    ! Returns:
 646: 0000:        !     0 - Success
 647: 0000: end function      !    -1 - String overrun
 648: 0000: 
 649: 0000: function extracts(whole,part,offset) external  ! routine to extract a
 650: 0000:        ! string (part) from
 651: 0000:  integer*2 EXTRACTS   ! another string (whole)
 652: 0000:  string  whole    ! starting at specified
 653: 0000:  string  part    ! character (offset)
 654: 0000:  integer*2 offset
 655: 0000: 
 656: 0000: end function
 657: 0000: 
 658: 0000: function cextract4(bstring,offset) external  ! routine to extract
 659: 0000:        ! a 4-byte integer from
 660: 0000:  integer*4 cextract4   ! a string starting at
 661: 0000:                        ! byte specified by
 662: 0000:  string  bstring    ! offset (1-based)
 663: 0000:  integer*2 offset    ! Returns:
 664: 0000:        !     X - 4 byte integer
 665: 0000: end function      !    -1 - String overrun
 666: 0000: 
 667: 0000: function cextract2(bstring,offset) external  ! routine to extract
 668: 0000:        ! a 2-byte integer from
 669: 0000:  integer*2 cextract2   ! a string starting at
 670: 0000:                        ! byte specified by
 671: 0000:  string  bstring    ! offset (1-based)
 672: 0000:  integer*2 offset    ! Returns:
 673: 0000:        !     X - 2 byte integer
 674: 0000: end function      !    -1 - String overrun
 675: 0000: 
 676: 0000: function cextract1(bstring,offset) external  ! routine to extract
 677: 0000:        ! a 1-byte integer from
 678: 0000:  integer*1 cextract1   ! a string starting at
 679: 0000:                        ! byte specified by
 680: 0000:  string  bstring    ! offset (1-based)
 681: 0000:  integer*2 offset    ! Returns:
 682: 0000:        !     X - 1 byte integer
 683: 0000: end function      !    -1 - String overrun
 684: 0000: 
 685: 0000: 
 686: 0000: function srchdir (file.name$,dtbl.buffer$) external ! routine to return
 687: 0000:        ! file names and sizes
 688: 0000:        ! Return values:
 689: 0000:        !    -1  no matches
 690: 0000:        !        found on first
 691: 0000:        !        call
 692: 0000:        !    0   no matches
 693: 0000:        !        found on sub-
 694: 0000:        !        sequent calls
 695: 0000:        !    Pos Success
 696: 0000:        !    Neg OS Rtn Code
 697: 0000: ! Usage Note:  If searching for all occurences of a particular file name,
 698: 0000: ! first initialize dtbl.buffer$ to 48 Nulls (pack$("00")) and issue a call
 699: 0000: ! to srchdir.  If any matches are found, a positive value will be returned.
 700: 0000: ! To see if any more matches exist, just issue another call to srchdir without
 701: 0000: ! resetting the values of dtbl.buffer$.  If any are found, a positive value
 702: 0000: ! will be returned.  This can be repeated until a Zero is returned.  All data
 703: 0000: ! describing file will be returned in the dtbl.buffer$ after each call.  Format
 704: 0000: ! of this data is defined below.
 705: 0000: 
 706: 0000:  integer*4 srchdir
 707: 0000: 
 708: 0000:  string  file.name$   ! file name to start
 709: 0000:        ! search (18 bytes max)
 710: 0000:        ! Wild cards and logical
 711: 0000:        ! names supported.
 712: 0000: 
 713: 0000:  string  dtbl.buffer$   ! must be initialized
 714: 0000:        ! to 48 bytes.  Contains
 715: 0000:        ! all of directory info
 716: 0000:        ! Initialize to nulls
 717: 0000:        ! each time a new file
 718: 0000:        ! name is used.
 719: 0000: 
 720: 0000: ! NOTE:  Format of dtbl.buffer$ string is as follows:
 721: 0000: !
 722: 0000: ! Offs  Type                    Description Notes
 723: 0000: !  0 integer*4  key  use extract4 to access
 724: 0000: !  4  string (18 bytes) file name
 725: 0000: ! 22 integer*2  attributes use extract2 to access
 726: 0000: !      0x01 - Read Only
 727: 0000: !      0x02 - Hidden
 728: 0000: !      0x04 - System
 729: 0000: !      0x08 - Volume Label
 730: 0000: !      0x10 - Subdirectory
 731: 0000: !      0x20 - Archive (Files)
 732: 0000: !      0x40 - Security enabled
 733: 0000: !      0x80 - Reserved
 734: 0000: !      0x0000 - Local
 735: 0000: !      0x4000 - Mirrored/Update
 736: 0000: !      0xC000 - Mirrored/Close
 737: 0000: !
 738: 0000: !      0x6000 - Compound/Update
 739: 0000: !      0xE000 - Compound/Close
 740: 0000: ! 24 integer*2  record size use extract2 to access
 741: 0000: ! 26 integer*1  User ID of Owner
 742: 0000: ! 27 integer*1  Group ID of Owner
 743: 0000: ! 28 integer*2  File Security
 744: 0000: ! 30 string (6 bytes) Reserved
 745: 0000: ! 36 integer*4  File Size use extract4 to access
 746: 0000: ! 40 integer*2  Year  use extract2 to access
 747: 0000: ! 42 integer*1  Month
 748: 0000: ! 43 integer*1  Day
 749: 0000: ! 44 integer*1  Hour
 750: 0000: ! 45 integer*1  Minute
 751: 0000: ! 46 integer*1  Second
 752: 0000: ! 47 integer*1  Reserved
 753: 0000: 
 754: 0000: end function
 755: 0000: 
 756: 0000: function srchproc (proc.name$,ptbl.buffer$) external ! routine to return
 757: 0000:        ! process names and
 758: 0000:        ! status.  Handy to
 759: 0000:        ! determine if a
 760: 0000:        ! program is currently
 761: 0000:        ! running.
 762: 0000:        ! Return values:
 763: 0000:        !    -1  no matches
 764: 0000:        !        found on first
 765: 0000:        !        call
 766: 0000:        !    0   no matches
 767: 0000:        !        found on sub-
 768: 0000:        !        sequent calls
 769: 0000:        !    Pos Success
 770: 0000:        !    Neg Failure
 771: 0000:        !        OS Rtn Code
 772: 0000:        ! 80000001h - Insuff
 773: 0000:         !        ptbl buffer
 774: 0000:        !        Length
 775: 0000: ! Usage Note:  If searching for all occurences of a particular process name,
 776: 0000: ! first initialize ptbl.buffer$ to 60 Nulls (pack$("00")) and issue a call
 777: 0000: ! to srchproc.  If any matches are found, a positive value will be returned.
 778: 0000: ! To see if any more matches exist, just issue another call to srchproc without
 779: 0000: ! resetting the values of ptbl.buffer$.  If any are found, a positive value
 780: 0000: ! will be returned.  This can be repeated until a Zero is returned.  All data
 781: 0000: ! describing file will be returned in the ptbl.buffer$ after each call.  Format
 782: 0000: ! of this data is defined as follows:
 783: 0000: !
 784: 0000: !       --------------------------------------------------------
 785: 0000: !   0   |                         PID                          |
 786: 0000: !       --------------------------------------------------------
 787: 0000: !   4   |           FID             |   CID        |   VCID    |
 788: 0000: !       --------------------------------------------------------
 789: 0000: !   8   |                         NAME                         |
 790: 0000: !       --------------------------------------------------------
 791: 0000: !  12   |                         NAME cont'd                  |
 792: 0000: !       --------------------------------------------------------
 793: 0000: !  16   |       NAME cont'd         |   STATE      |  PRIOR    |
 794: 0000: !       --------------------------------------------------------
 795: 0000: !  20   |                         MAXMEM                       |
 796: 0000: !       --------------------------------------------------------
 797: 0000: !  24   |       FLAGS               |   USER        |  GROUP   |
 798: 0000: !       --------------------------------------------------------
 799: 0000: !  28   |                         PARENT                       |
 800: 0000: !       --------------------------------------------------------
 801: 0000: !  32   |                         EVENTS                       |
 802: 0000: !       --------------------------------------------------------
 803: 0000: !  36   |                         CODE                         |
 804: 0000: !       --------------------------------------------------------
 805: 0000: !  40   |                         CSIZE                        |
 806: 0000: !       --------------------------------------------------------
 807: 0000: !  44   |                         DATA                         |
 808: 0000: !       --------------------------------------------------------
 809: 0000: !  48   |                         DSIZE                        |
 810: 0000: !       --------------------------------------------------------
 811: 0000: !  52   |                         HEAP                         |
 812: 0000: !       --------------------------------------------------------
 813: 0000: !  56   |                         HSIZE                        |
 814: 0000: !       --------------------------------------------------------
 815: 0000: !
 816: 0000: !       PID   Process ID
 817: 0000: !       FID  Process's Family ID
 818: 0000: !       CID   Physical Console Device Number
 819: 0000: !       VCID  Process's Virtual Console Number
 820: 0000: !       NAME  Process Name (Application Running)
 821: 0000: ! STATE    Process State (0-Run, 1-Waiting, 2-Terminating)
 822: 0000: ! PRIOR    Priority
 823: 0000: !       MAXMEM  Maximum Memory Allowed
 824: 0000: !       FLAGS  Bit 0 (1-System Process, 0-User Process)
 825: 0000: !   Bit 1 (1-Locked in Memory, 0-Swappable)
 826: 0000: !   Bit 2 (1-Running in SWI context, 0-Running in main context)
 827: 0000: !   Bit 3 (1-Superuser Process,0-Not a Superuser Process)
 828: 0000: ! USER  User Number
 829: 0000: ! GROUP  Group Number
 830: 0000: !       PARENT   Parent Process ID
 831: 0000: !       EVENTS   Bit Map of events that have completed but not retrieved
 832: 0000: !       CODE  Start of code area in user space
 833: 0000: ! CSIZE  Size in bytes of code area
 834: 0000: !       DATA  Start of data area in user space
 835: 0000: ! DSIZE  Size in bytes of data area
 836: 0000: !       HEAP  Start of heap area in user space
 837: 0000: ! HSIZE  Size in bytes of heap area
 838: 0000: !
 839: 0000:  integer*4 srchproc
 840: 0000: 
 841: 0000:  string  proc.name$   ! process name to start
 842: 0000:        ! search (10 bytes max)
 843: 0000:        ! Wild cards and logical
 844: 0000:        ! names supported.
 845: 0000: 
 846: 0000:  string  ptbl.buffer$   ! must be initialized
 847: 0000:        ! to 60 bytes.  Contains
 848: 0000:        ! all of process info
 849: 0000:        ! Initialize to nulls
 850: 0000:        ! each time a new
 851: 0000:        ! process name is used.
 852: 0000: 
 853: 0000: end function
 854: 0000: 
 855: 0000: function cconstat(timeout) external       ! function similar
 856: 0000:                                               ! to BASIC constat%
 857: 0000:  integer*2 cconstat   ! waits for either a
 858: 0000:  integer*4 timeout    ! key being hit or
 859: 0000:        ! the timer expiring
 860: 0000:        ! before returning
 861: 0000:        ! returns:
 862: 0000:        !   -1 error
 863: 0000:        !    0 timer expired
 864: 0000:        !    x scan code of
 865: 0000:        !      key hit
 866: 0000: end function
 867: 0000: 
 868: 0000: function disksize(disk.name$) external   ! function to find
 869: 0000:        ! the total size of
 870: 0000:  integer*4 disksize   ! the specified disk
 871: 0000:  string  disk.name$   ! name (e.g. "h0:")
 872: 0000:        ! if return value is
 873: 0000:        ! negative, error
 874: 0000: end function      ! was received
 875: 0000: 
 876: 0000: 
 877: 0000: %INCLUDE BTCSTR.J86     ! String functions
 878: 0000: !********************************************************************
 879: 0000: !***
 880: 0000: !***    INCLUDED CODE:  BTCSTR.J86
 881: 0000: !***    AUTHOR:         Stuart William McConnachie
 882: 0000: !***    DATE:           26th February 2006
 883: 0000: !***
 884: 0000: !********************************************************************
 885: 0000: !***
 886: 0000: !***    Controller CBASIC String Functions
 887: 0000: !***
 888: 0000: !********************************************************************
 889: 0000: 
 890: 0000: !Swaps to CBASIC strings
 891: 0000: SUB SWAPSTR (S1$, S2$) EXTERNAL
 892: 0000:     STRING S1$, S2$
 893: 0000: END SUB
 894: 0000: 
 895: 0000: !Left trim a string of spaces
 896: 0000: SUB LTRIM (S$) EXTERNAL
 897: 0000:     STRING S$
 898: 0000: END SUB
 899: 0000: 
 900: 0000: !Right trim a string of spaces
 901: 0000: SUB RTRIM (S$) EXTERNAL
 902: 0000:     STRING S$
 903: 0000: END SUB
 904: 0000: 
 905: 0000: !Left and right trim a string of spaces
 906: 0000: SUB TRIM (S$) EXTERNAL
 907: 0000:     STRING S$
 908: 0000: END SUB
 909: 0000: 
 910: 0000: !Left trim a string of a given ASCII character
 911: 0000: SUB LTRIMC (S$, C%) EXTERNAL
 912: 0000:     STRING S$
 913: 0000:     INTEGER*1 C%
 914: 0000: END SUB
 915: 0000: 
 916: 0000: !Right trim a string of a given ASCII character
 917: 0000: SUB RTRIMC (S$, C%) EXTERNAL
 918: 0000:     STRING S$
 919: 0000:     INTEGER*1 C%
 920: 0000: END SUB
 921: 0000: 
 922: 0000: !Left and right trim a string of a given ASCII character
 923: 0000: SUB TRIMC (S$, C%) EXTERNAL
 924: 0000:     STRING S$
 925: 0000:     INTEGER*1 C%
 926: 0000: END SUB
 927: 0000: 
 928: 0000: !Insert one string into another
 929: 0000: FUNCTION SUBSTR(S1$, O1%, S2$, O2%, L2%) EXTERNAL
 930: 0000:     STRING    S1$, S2$
 931: 0000:     INTEGER*2 O1%, O2%, L2%
 932: 0000:     INTEGER*1 SUBSTR
 933: 0000: END FUNCTION
 934: 0000:     
 935: 0000: 
 936: 0000: FUNCTION MATCHB(P1$,P2$,P3) EXTERNAL                                    !CMW
 937: 0000:     INTEGER*2 MATCHB                                                    !CMW
 938: 0000:     STRING P1$                                                          !CMW
 939: 0000:     STRING P2$                                                          !CMW
 940: 0000:     INTEGER*2 P3                                                        !CMW
 941: 0000: END FUNCTION                                                            !CMW
 942: 0000: 
 943: 0000: FUNCTION ASC.TEXT$(A$) EXTERNAL
 944: 0000:     STRING ASC.TEXT$,A$
 945: 0000: END FUNCTION
 946: 0000: 
 947: 0000: FUNCTION HEX.TEXT$(H$) EXTERNAL
 948: 0000: STRING HEX.TEXT$,H$
 949: 0000: END FUNCTION
 950: 0000: 
 951: 0000: FUNCTION ?VAL(S$) EXTERNAL                                              !GMW
 952: 0000:     INTEGER*4 ?VAL                                                      !GMW
 953: 0000:     STRING S$                                                           !GMW
 954: 0000: END FUNCTION                                                            !GMW
 955: 0000: 
 956: 0000: FUNCTION SUBSTITUTE$(T$,P$,R$) EXTERNAL
 957: 0000:     STRING SUBSTITUTE$,T$,P$,R$
 958: 0000: END FUNCTION
 959: 0000: 
 960: 0000: FUNCTION GET.FILENAME$(INDEX%,L%) EXTERNAL                              !GMW
 961: 0000:     STRING GET.FILENAME$                                                !GMW
 962: 0000:     INTEGER*2 INDEX%,L%                                                 !GMW
 963: 0000: END FUNCTION                                                            !GMW
 964: 0000: 
 965: 0000: SUB PSU0406 EXTERNAL
 966: 0000: END SUB
 967: 0000: 
 968: 0000: !\**********************************************************************!GMW
 969: 0000: !\***                                                                   !GMW
 970: 0000: !\***    ?VAL                                                           !GMW
 971: 0000: !\***                                                                   !GMW
 972: 0000: !\***    Performs VAL function with an error trap for IH errors         !GMW
 973: 0000: !\***                                                                   !GMW
 974: 0000: !\**********************************************************************!GMW
 975: 0000: !                                                                       !GMW
 976: 0000: !FUNCTION ?VAL(S$) PUBLIC                                               !GMW
 977: 0000: !!!!INTEGER*4 ?VAL                                                      !GMW
 978: 0000: !!!!STRING S$                                                           !GMW
 979: 0000: !                                                                       !GMW
 980: 0000: !!!!ON ERROR GOTO VAL.ERROR                                             !GMW
 981: 0000: !                                                                       !GMW
 982: 0000: !!!!?VAL = VAL(S$)                                                      !GMW
 983: 0000: !                                                                       !GMW
 984: 0000: !!!!EXIT FUNCTION                                                       !GMW
 985: 0000: !                                                                       !GMW
 986: 0000: !EXIT.VAL:                                                              !GMW
 987: 0000: !                                                                       !GMW
 988: 0000: !!!!?VAL = 0                                                            !GMW
 989: 0000: !                                                                       !GMW
 990: 0000: !!!!EXIT FUNCTION                                                       !GMW
 991: 0000: !                                                                       !GMW
 992: 0000: !VAL.ERROR:                                                             !GMW
 993: 0000: !                                                                       !GMW
 994: 0000: !!!!! Trap IH errors                                                    !GMW
 995: 0000: !!!!RESUME EXIT.VAL                                                     !GMW
 996: 0000: !                                                                       !GMW
 997: 0000: !END FUNCTION                                                           !GMW
 998: 0000: !                                                                       !GMW
 999: 0000: \***********************************************************************
1000: 0000: \***
1001: 0000: \***    Local function definitions
1002: 0000: \***
1003: 0000: \***********************************************************************
1004: 0000: 
1005: 0000: \***********************************************************************
1006: 0000: \***
1007: 0000: \***    GET.DEVICE.ID$
1008: 0000: \***
1009: 0000: \***    Extract 1-byte integer device ID and convert to string
1010: 0000: \***    format from specified index within the event unique data string.
1011: 0000: \***
1012: 0000: \***********************************************************************
1013: 0000: FUNCTION GET.DEVICE.ID$(INDEX%)
1014: 0024:     STRING GET.DEVICE.ID$
1015: 0024:     INTEGER*2 INDEX%
1016: 0024: 
1017: 0024:     GET.DEVICE.ID$ =                                                \
1018: 0074:         HEX.TEXT$(LTRIM$(UNPACK$(LEFT$(                             \
1019: 0074:             EVENT.UNIQUE.DATA$,INDEX%)),"0"))
1020: 0074: 
1021: 0074: END FUNCTION
1022: 008d: 
1023: 008d: !\**********************************************************************!GMW
1024: 008d: !\***                                                                   !GMW
1025: 008d: !\***    GET.FILENAME$                                                  !GMW
1026: 008d: !\***                                                                   !GMW
1027: 008d: !\***    Extract maximum 12-byte ASC filename from specified index      !GMW
1028: 008d: !\***    within the event unique data string.                           !GMW
1029: 008d: !\***                                                                   !GMW
1030: 008d: !\**********************************************************************!GMW
1031: 008d: !FUNCTION GET.FILENAME$(INDEX%,L%) PUBLIC                               !GMW
1032: 008d: !!!!STRING GET.FILENAME$,WORK$                                          !GMW
1033: 008d: !!!!INTEGER*2 INDEX%,L%,M%                                              !GMW
1034: 008d: !                                                                       !GMW
1035: 008d: !!!!WORK$ = EVENT.UNIQUE.DATA$                                          !GMW
1036: 008d: !                                                                       !GMW
1037: 008d: !!!!! Strip off characters after the string terminator (null)           !GMW
1038: 008d: !!!!M% = MATCHB(CHR$(0),EVENT.UNIQUE.DATA$,INDEX%)                      !GMW
1039: 008d: !!!!IF M% > 0 THEN BEGIN                                                !GMW
1040: 008d: !!!!!!!!WORK$ = LEFT$(EVENT.UNIQUE.DATA$,M% - 1)                        !GMW
1041: 008d: !!!!ENDIF                                                               !GMW
1042: 008d: !                                                                       !GMW
1043: 008d: !!!!GET.FILENAME$ =                                                 \   !GMW
1044: 008d: !!!!!!!!RTRIM$(UCASE$(ASC.TEXT$(MID$(WORK$,INDEX%,L%))),".")            !GMW
1045: 008d: !                                                                       !GMW
1046: 008d: !END FUNCTION                                                           !GMW
1047: 008d: !                                                                       !GMW
1048: 008d: \***********************************************************************
1049: 008d: \***
1050: 008d: \***    GET.RETURN.CODE$
1051: 008d: \***
1052: 008d: \***    Extract 4-byte integer return code and convert to string
1053: 008d: \***    format from specified index within the event unique data string.
1054: 008d: \***
1055: 008d: \***********************************************************************
1056: 008d: FUNCTION GET.RETURN.CODE$(INDEX%)
1057: 00b1:     STRING GET.RETURN.CODE$
1058: 00b1:     INTEGER*2 INDEX%
1059: 00b1: 
1060: 00b1:     GET.RETURN.CODE$ =                                              \
1061: 018a:         RIGHT$(HEX.TEXT$(UNPACK$("0" +                              \
1062: 018a:                MID$(EVENT.UNIQUE.DATA$,INDEX% + 3,1) +              \
1063: 018a:                MID$(EVENT.UNIQUE.DATA$,INDEX% + 2,1) +              \
1064: 018a:                MID$(EVENT.UNIQUE.DATA$,INDEX% + 1,1) +              \
1065: 018a:                MID$(EVENT.UNIQUE.DATA$,INDEX%,1))),8)
1066: 018a: 
1067: 018a: END FUNCTION
1068: 01a3: 
1069: 01a3: \***********************************************************************
1070: 01a3: \***
1071: 01a3: \***    GET.PID$
1072: 01a3: \***
1073: 01a3: \***    Extract 4-byte integer process ID and convert to string
1074: 01a3: \***    format from specified index within the event unique data string.
1075: 01a3: \***
1076: 01a3: \***********************************************************************
1077: 01a3: FUNCTION GET.PID$(INDEX%)
1078: 01c7:     STRING GET.PID$
1079: 01c7:     INTEGER*2 INDEX%
1080: 01c7: 
1081: 01c7:     GET.PID$ = LTRIM$(HEX.TEXT$(UNPACK$(                            \   !EMW
1082: 029e:                    MID$(EVENT.UNIQUE.DATA$,INDEX% + 3,1) +          \   !EMW
1083: 029e:                    MID$(EVENT.UNIQUE.DATA$,INDEX% + 2,1) +          \   !EMW
1084: 029e:                    MID$(EVENT.UNIQUE.DATA$,INDEX% + 1,1) +          \   !EMW
1085: 029e:                    MID$(EVENT.UNIQUE.DATA$,INDEX%,1))),"0")             !EMW
1086: 029e: 
1087: 029e: END FUNCTION
1088: 02b7: 
1089: 02b7: \***********************************************************************
1090: 02b7: \***********************************************************************
1091: 02b7: \***
1092: 02b7: \***    MAIN SUBPROGRAM PSU0401
1093: 02b7: \***
1094: 02b7: \***********************************************************************
1095: 02b7: \***********************************************************************
1096: 02b7: SUB PSU0401 PUBLIC
1097: 02db: 
1098: 02db:     COMMENT$ = "No additional comment available."
1099: 02f2: 
1100: 02f2:     ! Set parameter default values
1101: 02f2:     PROGRAM$     = "QQQQQQQQ"
1102: 0309:     PID$         = "QQQQQQQQ"                                           !EMW
1103: 0320:     FILENAME$    = "QQQQQQQQ.QQQ"
1104: 0335:     OPERATOR$    = "QQQQQQQQ"
1105: 034a:     DRIVE$       = "Q"
1106: 035f:     IP.ADDRESS$  = "QQQ.QQQ.QQQ.QQQ"
1107: 0374:     USER.ID$     = "QQQQQQQQQQQQ"
1108: 0389:     TERMINAL$    = "QQQ"
1109: 039e:     RETURN.CODE$ = "QQQQQQQQ"
1110: 03b5:     REASON$      = "QQ"
1111: 03ca:     TYPE$        = "QQ"
1112: 03df:     ACTION$      = "QQ"
1113: 03f4:     CMD$         = "QQ"
1114: 0409:     NAME$        = "QQQQQQQQ"
1115: 041e:     NODE$        = "QQ"
1116: 0433:     NODE2$       = "QQ"
1117: 0448:     ORIGIN$      = "QQ"
1118: 045d:     LIBRARY$     = "Q"
1119: 0472:     DEVICE.ID$   = "QQ"
1120: 0487:     VBE$         = "QQQQQ"
1121: 049c:     RESX$        = "QQQQQ"
1122: 04b1:     RESY$        = "QQQQQ"
1123: 04c6:     COLORS$      = "QQQQQQQQQQ"
1124: 04db:     ID$          = "QQQQQQQQQQ"
1125: 04f0: 
1126: 04f0:     RETURN.ERR$ = ""
1127: 0507: 
1128: 0507:     ! Get long description for event message
1129: 0507:     MESSAGE.TEXT$ = LW$(EVENT.MESSAGE.NUMBER%)
1130: 0536: 
1131: 0536:     ! IF no dedicated format
1132: 0536:     IF EVENT.FORMAT% = 0 THEN BEGIN
1133: 0548: 
1134: 0548:         ! IF print spooler error
1135: 0548:         IF EVENT.SOURCE% = 54 AND                                   \
1136: 0574:            EVENT.MESSAGE.NUMBER% = 790 THEN BEGIN
1137: 0574:             RETURN.CODE$ = GET.RETURN.CODE$(1)
1138: 058d:         ENDIF
1139: 0598: 
1140: 0598:     ENDIF ELSE IF EVENT.FORMAT% = 1 THEN BEGIN
1141: 05aa: 
1142: 05aa: !DEVICE ID: xx COMMAND SENT: xxxxxxxxxx STATUS RECEIVED: xxxx
1143: 05aa: 
1144: 05aa:         DEVICE.ID$ = GET.DEVICE.ID$(1)
1145: 05c4: 
1146: 05c4:     ENDIF ELSE IF EVENT.FORMAT% = 2 THEN BEGIN
1147: 05d6: 
1148: 05d6: !DEVICE ID: xx COMMAND: xxxx STATUS: xx LAST ERROR STATUS: xx
1149: 05d6: 
1150: 05d6:         DEVICE.ID$ = GET.DEVICE.ID$(1)
1151: 05f0: 
1152: 05f0:     ENDIF ELSE IF EVENT.FORMAT% = 3 THEN BEGIN
1153: 0602: 
1154: 0602: !DEVICE ID: xx DATA: xxxxxxxxxxxxxxxxxxxxxxxx *aaaaaaaaaaaa*
1155: 0602: 
1156: 0602:         DEVICE.ID$ = GET.DEVICE.ID$(1)
1157: 061c: 
1158: 061c:     ENDIF ELSE IF EVENT.FORMAT% = 4 THEN BEGIN
1159: 062e: 
1160: 062e: !DEVICE ID: xx COMMAND: xxxxxx
1161: 062e: !STATUS: xxxx LAST ERROR STATUS: xxxx
1162: 062e: 
1163: 062e:         DEVICE.ID$ = GET.DEVICE.ID$(1)
1164: 0648: 
1165: 0648:     ENDIF ELSE IF EVENT.FORMAT% = 5 THEN BEGIN
1166: 065a: 
1167: 065a: !DEVICE ID: xx COMMAND: xxxx
1168: 065a: !STATUS: xxxx ADAPTER ERROR: xx
1169: 065a: 
1170: 065a:         DEVICE.ID$ = GET.DEVICE.ID$(1)
1171: 0674: 
1172: 0674:     ENDIF ELSE IF EVENT.FORMAT% = 6 THEN BEGIN
1173: 0689: 
1174: 0689: !DIRECTORY: {ADX_?PGM current}
1175: 0689: !           {ADX_?MNT maintenance}
1176: 0689: !           {ADX_?BUL backup}
1177: 0689: !           {c}
1178: 0689: !OPERATION: {Open (Keyed/Display)}
1179: 0689: !           {Close}
1180: 0689: !           {Read}
1181: 0689: !           {Write (Keyed)}
1182: 0689: !           {Delete (Keyed)}
1183: 0689: !           {Copy (Keyed/Sequential)}
1184: 0689: !           {Create (Keyed)}
1185: 0689: !           {Rename}
1186: 0689: !           {File Data}
1187: 0689: !           {c}
1188: 0689: !RC: {A description of the return code}
1189: 0689: 
1190: 0689: 
1191: 0689: !---------------------------------
1192: 0689: ! FORMAT 6
1193: 0689: !---------------------------------
1194: 0689: !   Filename           12 byte ASC
1195: 0689: !   Lib name            1 byte ASC
1196: 0689: !   Type                1 byte INT
1197: 0689: !   Return code         4 byte INT
1198: 0689: !---------------------------------
1199: 0689: 
1200: 0689:         ! ADX_xPGM or ADX_xMNT or ADX_xBUL
1201: 0689:         LIBRARY$  = MID$(EVENT.UNIQUE.DATA$,13,1)
1202: 06ae: 
1203: 06ae:         FILENAME$ = GET.FILENAME$(1,12)
1204: 06c8: 
1205: 06c8:         RETURN.CODE$ = GET.RETURN.CODE$(15)
1206: 06e1: 
1207: 06e1:         TYPE$ = STR$(ASC(MID$(EVENT.UNIQUE.DATA$,14,1) + "?"))
1208: 072d: 
1209: 072d:     ENDIF ELSE IF EVENT.FORMAT% = 7 THEN BEGIN
1210: 0742: 
1211: 0742: !{Bad return code from Application Services/Program interface error}
1212: 0742: !RC: {A description of the return code}
1213: 0742: 
1214: 0742:     ENDIF ELSE IF EVENT.FORMAT% = 8 THEN BEGIN
1215: 0757: 
1216: 0757: !INITIALIZATION STRING LENGTH: xxxx
1217: 0757: !FIRST EIGHT BYTES: xxxxxxxxxxxxxxxx *aaaaaaaa*
1218: 0757: !DISPLAY RETURN CODE: xxxx
1219: 0757: 
1220: 0757:     ENDIF ELSE IF EVENT.FORMAT% = 9 THEN BEGIN
1221: 0769: 
1222: 0769: !PROGRAM: cccccccccccc RETURN CODE: xxxxxxxx
1223: 0769: !RC: {A description of the return code}
1224: 0769: 
1225: 0769: !---------------------------------
1226: 0769: ! FORMAT 9
1227: 0769: !---------------------------------
1228: 0769: !   Program            12 byte ASC
1229: 0769: !   Return code         4 byte INT
1230: 0769: !   Unused              2 byte ASC
1231: 0769: !---------------------------------
1232: 0769: 
1233: 0769:         PROGRAM$ =                                                  \
1234: 07c4:             RTRIM$(UCASE$(ASC.TEXT$(LEFT$(                          \
1235: 07c4:                 EVENT.UNIQUE.DATA$,12))),".")
1236: 07c4: 
1237: 07c4:         RETURN.CODE$ = GET.RETURN.CODE$(13)
1238: 07df: 
1239: 07df:     ENDIF ELSE IF EVENT.FORMAT% = 10 THEN BEGIN
1240: 07f1: 
1241: 07f1: !TABLE: cccccccccccc RETURN CODE: xxxxxxxx
1242: 07f1: !RC: {A description of the return code}
1243: 07f1: 
1244: 07f1:         RETURN.CODE$ = GET.RETURN.CODE$(13)
1245: 080a: 
1246: 080a:     ENDIF
1247: 0812: 
1248: 0812:     IF EVENT.FORMAT% = 11 THEN BEGIN
1249: 0824: 
1250: 0824: !DEVICE ID: xx UNIT: xx LAST DEVICE CHANNEL MESSAGE: xxxx
1251: 0824: !COMMAND: xx SYSTEM STATUS: xx DEVICE STATUS: xx
1252: 0824: !Note: In addition, the following information is given for the scanner.
1253: 0824: !OPEN FLAGS: xx STATUS FLAGS: xx
1254: 0824: !INCOMING DATA - LABEL TYPE: xxxx CONTINUATION FLAG: xx
1255: 0824: !PREVIOUS DATA - LABEL TYPE: xxxx CONTINUATION FLAG: xx
1256: 0824: !ACCUMULATION LABEL DATA LENGTH: xx LABEL DATA CHECK FLAGS: xx
1257: 0824: 
1258: 0824:         DEVICE.ID$ = GET.DEVICE.ID$(1)
1259: 083e: 
1260: 083e:     ENDIF ELSE IF EVENT.FORMAT% = 12 THEN BEGIN
1261: 0853: 
1262: 0853: !OPERATION: {DISPD}
1263: 0853: !           {POSF}
1264: 0853: !           {No reference for screen interface}
1265: 0853: !           {No visible fields}
1266: 0853: !           {c}
1267: 0853: 
1268: 0853:     ENDIF ELSE IF EVENT.FORMAT% = 13 THEN BEGIN
1269: 0868: 
1270: 0868: !OPERATION: {INITDM}
1271: 0868: !           {OPNDIS}
1272: 0868: !           {DISPD}
1273: 0868: !           {POSF}
1274: 0868: !           {NXTF}
1275: 0868: !           {PUTF}
1276: 0868: !           {CURS}
1277: 0868: !           {CLSDIS}
1278: 0868: !           {c}
1279: 0868: 
1280: 0868:     ENDIF ELSE IF EVENT.FORMAT% = 14 THEN BEGIN
1281: 087d: 
1282: 087d: !FUNCTION FLAGS: xxxx :bbbbbbbbbbbbbbbb: (BINARY)
1283: 087d: 
1284: 087d:     ENDIF ELSE IF EVENT.FORMAT% = 15 THEN BEGIN
1285: 088f: 
1286: 088f: !ERROR DETECTED BY {PROGRAM/SYSTEM}
1287: 088f: !RC: {A description of the return code}
1288: 088f: 
1289: 088f: !---------------------------------
1290: 088f: ! FORMAT 15
1291: 088f: !---------------------------------
1292: 088f: !   Return code         4 byte INT
1293: 088f: !   Unused             14 byte ASC
1294: 088f: !---------------------------------
1295: 088f: 
1296: 088f:         RETURN.CODE$ = GET.RETURN.CODE$(1)
1297: 08ab: 
1298: 08ab:     ENDIF ELSE IF EVENT.FORMAT% = 16 THEN BEGIN
1299: 08c0: 
1300: 08c0: !TABLE: {Process}             OPERATION: {Get}
1301: 08c0: !       {Environment}                    {Set}
1302: 08c0: !       {Time & Date}                    {Lookup}
1303: 08c0: !       {Storage}                        {c}
1304: 08c0: !       {Pipe}
1305: 08c0: !       {Disk File}
1306: 08c0: !       {Disk}
1307: 08c0: !       {Screen}
1308: 08c0: !       {Physical Console}
1309: 08c0: !       {Virtual Console}
1310: 08c0: !       {Mouse}
1311: 08c0: !       {Top Border}
1312: 08c0: !       {Bottom Border}
1313: 08c0: !       {Left Border}
1314: 08c0: !       {Right Border}
1315: 08c0: !       {System}
1316: 08c0: !       {File Number}
1317: 08c0: !       {System Defines}
1318: 08c0: !       {Process Defines}
1319: 08c0: !       {Command Environment}
1320: 08c0: !       {Device}
1321: 08c0: !       {Pathname}
1322: 08c0: !       {Printer}
1323: 08c0: !       {Serial}
1324: 08c0: !       {DOS Clock Driver}
1325: 08c0: !       {Null Device}
1326: 08c0: !       {Port}
1327: 08c0: !
1328: 08c0: !RC: {A description of the return code}
1329: 08c0: 
1330: 08c0:     ENDIF ELSE IF EVENT.FORMAT% = 17 THEN BEGIN
1331: 08d5: 
1332: 08d5: !OPERATION: {Bad screen interface return code}
1333: 08d5: !{Reference number is not valid}
1334: 08d5: !{Zero pointer}
1335: 08d5: !{Zero data length}
1336: 08d5: !{c}
1337: 08d5: 
1338: 08d5:     ENDIF ELSE IF EVENT.FORMAT% = 18 THEN BEGIN
1339: 08ea: 
1340: 08ea: !RETURN CODE: xxxxxxxx {FILE: ADXCSCTF.DAT TERMINAL NUMBER: iii}
1341: 08ea: !{FILE: ADXCSCDF.DAT DEVICE GROUP NAME: cccccccc}
1342: 08ea: !RC: {A description of the return code}
1343: 08ea: 
1344: 08ea:     ENDIF ELSE IF EVENT.FORMAT% = 19 THEN BEGIN
1345: 08ff: 
1346: 08ff: !FUNCTION: {INIT} RETURN CODE: xxxxxxxx
1347: 08ff: !          {PCREATE}
1348: 08ff: !          {PABORT}
1349: 08ff: !          {GET}
1350: 08ff: !          {SET}
1351: 08ff: !          {LOOKUP}
1352: 08ff: !          {OPEN}
1353: 08ff: !          {CLOSE}
1354: 08ff: !          {READ}
1355: 08ff: !          {WRITE}
1356: 08ff: !          {SEEK}
1357: 08ff: !          {CREATE}
1358: 08ff: !          {DELETE}
1359: 08ff: !          {SPECIAL}
1360: 08ff: !          {INSTALL}
1361: 08ff: !          {DVRLOCK}
1362: 08ff: !          {RENAME}
1363: 08ff: !          {LOCK}
1364: 08ff: !          {xx}
1365: 08ff: !COMMAND TO I/O ADAPTER: xxxxxxxxxxxxxxxxxx *aaaaaaaaa*
1366: 08ff: !RC: {A description of the return code}
1367: 08ff: 
1368: 08ff:     ENDIF ELSE IF EVENT.FORMAT% = 20 THEN BEGIN
1369: 0914: 
1370: 0914: !FUNCTION: {INIT} FILE NAME: ssssssssssss RETURN CODE: xxxxxxxx
1371: 0914: !{PCREATE}
1372: 0914: !{PABORT}
1373: 0914: !{GET}
1374: 0914: !{SET}
1375: 0914: !{LOOKUP}
1376: 0914: !{OPEN}
1377: 0914: !{CLOSE}
1378: 0914: !{READ}
1379: 0914: !{WRITE}
1380: 0914: !{SEEK}
1381: 0914: !{CREATE}
1382: 0914: !{DELETE}
1383: 0914: !{SPECIAL}
1384: 0914: !{INSTALL}
1385: 0914: !{DVRLOCK}
1386: 0914: !{RENAME}
1387: 0914: !{LOCK}
1388: 0914: !{xx}
1389: 0914: !RC: {A description of the return code}
1390: 0914: 
1391: 0914:         DRIVE$ = LEFT$(EVENT.UNIQUE.DATA$,1)
1392: 0939: 
1393: 0939:         TYPE$ = STR$(ASC(MID$(EVENT.UNIQUE.DATA$,2,1) + "?"))
1394: 0982: 
1395: 0982:         FILENAME$ = GET.FILENAME$(7,12)
1396: 099c: 
1397: 099c:         RETURN.CODE$ = GET.RETURN.CODE$(3)
1398: 09b5: 
1399: 09b5:         IF TYPE$ = "1" THEN BEGIN
1400: 09d0:             TYPE.TEXT$ = "PCREATE"
1401: 09e8:         ENDIF ELSE IF TYPE$ = "2" THEN BEGIN
1402: 0a03:             TYPE.TEXT$ = "PABORT"
1403: 0a1b:         ENDIF ELSE IF TYPE$ = "3" THEN BEGIN
1404: 0a36:             TYPE.TEXT$ = "GET"
1405: 0a4e:         ENDIF ELSE IF TYPE$ = "4" THEN BEGIN
1406: 0a69:             TYPE.TEXT$ = "SET"
1407: 0a81:         ENDIF ELSE IF TYPE$ = "5" THEN BEGIN
1408: 0a9c:             TYPE.TEXT$ = "LOOKUP"
1409: 0ab4:         ENDIF ELSE IF TYPE$ = "6" THEN BEGIN
1410: 0acf:             TYPE.TEXT$ = "OPEN"
1411: 0ae7:         ENDIF ELSE IF TYPE$ = "7" THEN BEGIN
1412: 0b02:             TYPE.TEXT$ = "CLOSE"
1413: 0b1a:         ENDIF ELSE IF TYPE$ = "8" THEN BEGIN
1414: 0b35:             TYPE.TEXT$ = "READ"
1415: 0b4d:         ENDIF ELSE IF TYPE$ = "9" THEN BEGIN
1416: 0b68:             TYPE.TEXT$ = "WRITE"
1417: 0b80:         ENDIF ELSE IF TYPE$ = "10" THEN BEGIN
1418: 0b9b:             TYPE.TEXT$ = "SEEK"
1419: 0bb3:         ENDIF ELSE IF TYPE$ = "11" THEN BEGIN
1420: 0bce:             TYPE.TEXT$ = "CREATE"
1421: 0be6:         ENDIF ELSE IF TYPE$ = "12" THEN BEGIN
1422: 0c01:             TYPE.TEXT$ = "DELETE"
1423: 0c19:         ENDIF ELSE IF TYPE$ = "13" THEN BEGIN
1424: 0c34:             TYPE.TEXT$ = "SPECIAL"
1425: 0c4c:         ENDIF ELSE IF TYPE$ = "14" THEN BEGIN
1426: 0c67:             TYPE.TEXT$ = "INSTALL"
1427: 0c7f:         ENDIF ELSE IF TYPE$ = "15" THEN BEGIN
1428: 0c9a:             TYPE.TEXT$ = "DVRLOCK"
1429: 0cb2:         ENDIF ELSE IF TYPE$ = "16" THEN BEGIN
1430: 0ccd:             TYPE.TEXT$ = "RENAME"
1431: 0ce4:         ENDIF ELSE IF TYPE$ = "17" THEN BEGIN
1432: 0cff:             TYPE.TEXT$ = "LOCK"
1433: 0d16:         ENDIF ELSE BEGIN
1434: 0d1e:             TYPE.TEXT$ = "UNKNOWN"
1435: 0d33:         ENDIF
1436: 0d3b: 
1437: 0d3b:         COMMENT$ = "A problem occurred during a " +                 \
1438: 0d61:                    TYPE.TEXT$ + " function."
1439: 0d61: 
1440: 0d61:     ENDIF
1441: 0d69: 
1442: 0d69:     IF EVENT.FORMAT% = 21 THEN BEGIN
1443: 0d7e: 
1444: 0d7e: !FUNCTION: {GET}
1445: 0d7e: !          {SET}
1446: 0d7e: !          {LOOKUP}
1447: 0d7e: !          {CREATE}
1448: 0d7e: !          {DELETE}
1449: 0d7e: !          {OPEN}
1450: 0d7e: !          {CLOSE}
1451: 0d7e: !          {READ}
1452: 0d7e: !          {WRITE}
1453: 0d7e: !          {SPECIAL}
1454: 0d7e: !          {RENAME}
1455: 0d7e: !          {DEFINE}
1456: 0d7e: !          {xx}
1457: 0d7e: !RC: {A description of the return code}
1458: 0d7e: 
1459: 0d7e:     ENDIF ELSE IF EVENT.FORMAT% = 22 THEN BEGIN
1460: 0d93: 
1461: 0d93: !ERROR: {Not a keyed file/file not found}
1462: 0d93: 
1463: 0d93:     ENDIF ELSE IF EVENT.FORMAT% = 23 THEN BEGIN
1464: 0da8: 
1465: 0da8: !Note: The following top line information is repeated for each type of trace.
1466: 0da8: !Terminal number is given only for a device channel trace.
1467: 0da8: !TRACE TYPE: {Device channel} {TERMINAL NUMBER: iii}
1468: 0da8: !            {Host} {CONTROLLER: cc}
1469: 0da8: !            {Disk} {CONTROLLER: cc}
1470: 0da8: !            {Loop} {CONTROLLER: cc}
1471: 0da8: !            {xx}
1472: 0da8: !WRAP ALLOWED: {Yes/No}
1473: 0da8: 
1474: 0da8:     ENDIF ELSE IF EVENT.FORMAT% = 24 THEN BEGIN
1475: 0dbd: 
1476: 0dbd: !CAUSE: {Operator request}
1477: 0dbd: !       {Trace file full}
1478: 0dbd: !       {Error}
1479: 0dbd: !       {xxxx}
1480: 0dbd: !RC: {A description of the return code}
1481: 0dbd: 
1482: 0dbd:     ENDIF ELSE IF EVENT.FORMAT% = 25 THEN BEGIN
1483: 0dcf: 
1484: 0dcf: !TERMINAL NUMBER: {iii} CONTROLLER ID: cc
1485: 0dcf: !INTERVAL BETWEEN SAMPLES: iiiiiiiiii MILLISECONDS
1486: 0dcf: 
1487: 0dcf:         COMMENT$ = "Performance Monitor."
1488: 0de9: 
1489: 0de9:     ENDIF ELSE IF EVENT.FORMAT% = 26 THEN BEGIN
1490: 0dfe: 
1491: 0dfe: !---------------------------------
1492: 0dfe: ! FORMAT 26
1493: 0dfe: !---------------------------------
1494: 0dfe: !   Reason              2 byte INT
1495: 0dfe: !   Type                2 byte INT
1496: 0dfe: !   Return Code         4 byte INT
1497: 0dfe: !   Not used (00)      10 byte ASC
1498: 0dfe: !---------------------------------
1499: 0dfe: 
1500: 0dfe:         ! ? Operator Request
1501: 0dfe:         ! ? 60 Samples
1502: 0dfe:         ! ? Error
1503: 0dfe:         REASON$ = STR$(GETN2(EVENT.UNIQUE.DATA$,0))
1504: 0e2c: 
1505: 0e2c:         ! ? Controller
1506: 0e2c:         ! ? Terminal
1507: 0e2c:         ! ? Controller and Terminal
1508: 0e2c:         TYPE$ = STR$(GETN2(EVENT.UNIQUE.DATA$,2))
1509: 0e5a: 
1510: 0e5a:         RETURN.CODE$ = GET.RETURN.CODE$(5)
1511: 0e76: 
1512: 0e76:     ENDIF ELSE IF EVENT.FORMAT% = 27 THEN BEGIN
1513: 0e8b: 
1514: 0e8b: !TYPE: {File ADXCSONF.DAT was not found in ADX_SDT1}
1515: 0e8b: !      {Creation of minimum size copy of ADXCSONF.DAT failed}
1516: 0e8b: !RC: {A description of the return code}
1517: 0e8b: 
1518: 0e8b:     ENDIF ELSE IF EVENT.FORMAT% = 28 THEN BEGIN
1519: 0ea0: 
1520: 0ea0: !---------------------------------
1521: 0ea0: ! FORMAT 28
1522: 0ea0: !---------------------------------
1523: 0ea0: !   Not used (00)       1 byte ASC
1524: 0ea0: !   Type                1 byte INT
1525: 0ea0: !   Process ID          4 byte INT
1526: 0ea0: !   Not used (00)       4 byte ASC
1527: 0ea0: !   Application         8 byte ASC
1528: 0ea0: !---------------------------------
1529: 0ea0: 
1530: 0ea0:         ! 0 = Normal
1531: 0ea0:         ! 1 = Background
1532: 0ea0:         TYPE$ = STR$(?VAL(UNPACK$(MID$(EVENT.UNIQUE.DATA$,2,1))))
1533: 0edb: 
1534: 0edb:         PID$ = GET.PID$(3)
1535: 0ef4: 
1536: 0ef4:         PROGRAM$ =                                                  \
1537: 0f4d:             RTRIM$(UCASE$(ASC.TEXT$(RIGHT$(                         \
1538: 0f4d:                 EVENT.UNIQUE.DATA$,8))),".")
1539: 0f4d: 
1540: 0f4d:         IF TYPE$ = "0" THEN BEGIN
1541: 0f68:             TYPE.TEXT$ = "foreground"
1542: 0f7f:         ENDIF ELSE IF TYPE$ = "1" THEN BEGIN
1543: 0f9a:             TYPE.TEXT$ = "background"
1544: 0faf:         ENDIF
1545: 0fb7: 
1546: 0fb7:         ! IF command mode session started                               !BMW
1547: 0fb7:         IF TYPE$ = "0" AND PROGRAM$ = "COMMAND" THEN BEGIN              !BMW
1548: 1004:             COMMENT$ = "A command mode session was started."            !BMW
1549: 101d:         ENDIF ELSE BEGIN                                                !BMW
1550: 1025:         
1551: 1025:             COMMENT$ = "A " + TYPE.TEXT$ + " application " +        \
1552: 105a:                        PROGRAM$ + " was started."
1553: 105a:                    
1554: 105a:         ENDIF                                                           !BMW
1555: 1065: 
1556: 1065:     ENDIF ELSE IF EVENT.FORMAT% = 29 THEN BEGIN
1557: 107a: 
1558: 107a: !---------------------------------
1559: 107a: ! FORMAT 29
1560: 107a: !---------------------------------
1561: 107a: !   Reason              1 byte INT
1562: 107a: !   Type                1 byte INT
1563: 107a: !   Process ID          4 byte INT
1564: 107a: !   Return Code         4 byte INT
1565: 107a: !   Application         8 byte ASC
1566: 107a: !---------------------------------
1567: 107a: 
1568: 107a:         ! 0 = Application ended
1569: 107a:         ! 1 = Application request
1570: 107a:         ! 2 = Operator request
1571: 107a:         REASON$ = STR$(?VAL(UNPACK$(LEFT$(EVENT.UNIQUE.DATA$,1))))
1572: 10b5: 
1573: 10b5:         ! 0 = Normal
1574: 10b5:         ! 1 = Background
1575: 10b5:         TYPE$ = STR$(?VAL(UNPACK$(MID$(EVENT.UNIQUE.DATA$,2,1))))
1576: 10f0: 
1577: 10f0:         PID$ = GET.PID$(3)
1578: 1109: 
1579: 1109:         RETURN.CODE$ = GET.RETURN.CODE$(7)
1580: 1122: 
1581: 1122:         PROGRAM$ =                                                  \
1582: 117b:             RTRIM$(UCASE$(ASC.TEXT$(RIGHT$(                         \
1583: 117b:                 EVENT.UNIQUE.DATA$,8))),".")
1584: 117b: 
1585: 117b:         IF TYPE$ = "0" THEN BEGIN
1586: 1196:             TYPE.TEXT$ = "foreground"
1587: 11ad:         ENDIF ELSE IF TYPE$ = "1" THEN BEGIN
1588: 11c8:             TYPE.TEXT$ = "background"
1589: 11dd:         ENDIF
1590: 11e5: 
1591: 11e5:         IF REASON$ = "0" THEN BEGIN
1592: 1200:             REASON.TEXT$ = "completed"
1593: 1217:         ENDIF ELSE IF REASON$ = "1" THEN BEGIN
1594: 1232:             REASON.TEXT$ = "completed"
1595: 1249:         ENDIF ELSE IF REASON$ = "2" THEN BEGIN
1596: 1264:             REASON.TEXT$ = "been cancelled by operator request"
1597: 1279:         ENDIF
1598: 1281: 
1599: 1281:         IF RETURN.CODE$ = "00000000" THEN BEGIN
1600: 129f:             REASON.TEXT$ = REASON.TEXT$ + " with no errors"
1601: 12c1:         ENDIF ELSE BEGIN
1602: 12c9:             REASON.TEXT$ = REASON.TEXT$ +                           \
1603: 12f4:                            " with errors. Return code is " +        \
1604: 12f4:                            RETURN.CODE$
1605: 12f4:         ENDIF
1606: 12fc: 
1607: 12fc:         ! IF command mode session ended                                 !BMW
1608: 12fc:         IF TYPE$ = "0" AND PROGRAM$ = "COMMAND" THEN BEGIN              !BMW
1609: 1349:             COMMENT$ = "A command mode session was ended."              !BMW
1610: 1362:         ENDIF ELSE BEGIN                                                !BMW
1611: 136a:         
1612: 136a:             COMMENT$ = "A " + TYPE.TEXT$ + " application " +        \
1613: 13bf:                        RTRIM$(PROGRAM$," ") + " has " +             \
1614: 13bf:                        REASON.TEXT$ + "."
1615: 13bf:                    
1616: 13bf:         ENDIF                                                           !BMW
1617: 13ca: 
1618: 13ca:     ENDIF ELSE IF EVENT.FORMAT% = 30 THEN BEGIN
1619: 13df: 
1620: 13df: !---------------------------------
1621: 13df: ! FORMAT 30
1622: 13df: !---------------------------------
1623: 13df: !   Action              1 byte INT
1624: 13df: !   Command             1 byte INT
1625: 13df: !   Name                8 byte ASC
1626: 13df: !   Source Node         2 byte ASC
1627: 13df: !   Destination Node    2 byte ASC
1628: 13df: !---------------------------------
1629: 13df: 
1630: 13df: !ACTION: {Request} COMMAND: {Dump terminal storage}
1631: 13df: !        {Response}         {Load terminal storage}
1632: 13df: !        {Timeout}          {Set terminal date/time}
1633: 13df: !        {Send All}         {Load application}
1634: 13df: !        {xx}               {Load application with DEBUG}
1635: 13df: !        {Local}            {Cancel application}
1636: 13df: !                           {Enable storage retention}
1637: 13df: !                           {Disable storage retention}
1638: 13df: !                           {Display terminal status}
1639: 13df: !                           {Set controller date/time}
1640: 13df: !                           {Controller IPL}
1641: 13df: !                           {Deactivate Master}
1642: 13df: !                           {Activate Master}
1643: 13df: !                           {Allow store loop backup}
1644: 13df: !                           {Prevent store loop backup}
1645: 13df: !                           {Resume store loop control}
1646: 13df: !                           {Deactivate File Server}
1647: 13df: !                           {Activate File Server}
1648: 13df: !                           {Send Master updates}
1649: 13df: !                           {Receive Master updates}
1650: 13df: !                           {Enable link}
1651: 13df: !                           {Disable link}
1652: 13df: !                           {Disable link with force}
1653: 13df: !                           {Enable Token Ring}
1654: 13df: !                           {Disable Token Ring}
1655: 13df: !                           {Display Link Status}
1656: 13df: !                           {Display Token Ring Status}
1657: 13df: !                           {xx}
1658: 13df: !                           {Disable Controller RAM disks}
1659: 13df: !                           {Enable Controller RAM disks}
1660: 13df: !NAME: {cccccccc}
1661: 13df: !ORIGIN: {LAN} SOURCE CONTROLLER: cc DESTINATION CONTROLLER: cc
1662: 13df: !        {Operator}
1663: 13df: !        {Application}
1664: 13df: 
1665: 13df:         ! 00 = Request
1666: 13df:         ! 01 = Response
1667: 13df:         ! 02 = Timeout
1668: 13df:         ! 03 = Send All
1669: 13df:         ACTION$  = HEX.TEXT$(UNPACK$(LEFT$(EVENT.UNIQUE.DATA$,1)))
1670: 140e: 
1671: 140e:         IF ACTION$ = "00" THEN BEGIN
1672: 1429:             ACTION.TEXT$ = "The action was requested. "
1673: 1441:         ENDIF ELSE IF ACTION$ = "01" THEN BEGIN
1674: 145c:             ACTION.TEXT$ = "The action was acknowledged. "
1675: 1474:         ENDIF ELSE IF ACTION$ = "02" THEN BEGIN
1676: 148f:             ACTION.TEXT$ = "The action timed out. "
1677: 14a6:         ENDIF ELSE IF ACTION$ = "03" THEN BEGIN
1678: 14c1:             ACTION.TEXT$ = "The action was sent to all. "
1679: 14d8:         ENDIF ELSE BEGIN
1680: 14e0:             ACTION.TEXT$ = "The action was unknown. "
1681: 14f5:         ENDIF
1682: 14fd: 
1683: 14fd:         ! ?? = Set terminal date/time
1684: 14fd:         ! ?? = Load application with DEBUG
1685: 14fd:         ! ?? = Deactivate Master
1686: 14fd:         ! ?? = Activate Master
1687: 14fd:         ! ?? = Allow store loop backup
1688: 14fd:         ! ?? = Prevent store loop backup
1689: 14fd:         ! ?? = Resume store loop control
1690: 14fd:         ! ?? = Deactivate File Server
1691: 14fd:         ! ?? = Activate File Server
1692: 14fd:         ! ?? = Send Master updates
1693: 14fd:         ! ?? = Receive Master updates
1694: 14fd:         ! ?? = Enable Token Ring
1695: 14fd:         ! ?? = Disable Token Ring
1696: 14fd:         ! ?? = Display Token Ring Status
1697: 14fd: 
1698: 14fd:         ! TERMINAL FUNCTIONS
1699: 14fd:         ! 16 = 1. Display Terminal Status
1700: 14fd:         ! 31 = 2. Enable storage retention
1701: 14fd:         ! 32 = 3. Disable storage retention
1702: 14fd:         ! 04 = 4. Start Terminal Application
1703: 14fd:         ! 06 = 5. Stop Terminal Application
1704: 14fd:         ! ?? = 6. Java Application Functions
1705: 14fd:         ! 02 = 7. Load terminal storage
1706: 14fd:         ! ?? = 8. Dump terminal storage
1707: 14fd: 
1708: 14fd:         ! CONTROLLER FUNCTIONS
1709: 14fd:         ! ?? = 1. Display Controller Status
1710: 14fd:         ! ?? = 2. Enable Controller RAM disk
1711: 14fd:         ! ?? = 3. Disable Controller RAM disk
1712: 14fd:         ! 60 = 4. Load controller storage
1713: 14fd:         ! ?? = 5. Dump controller storage
1714: 14fd: 
1715: 14fd:         ! TCC FUNCTIONS
1716: 14fd: 
1717: 14fd:         ! MULTIPLE CONTROLLER FUNCTIONS
1718: 14fd: 
1719: 14fd:         ! SYSTEM FUNCTIONS
1720: 14fd:         ! 40 = 1. Set system date/time
1721: 14fd:         ! ?? = 2. Set system message level
1722: 14fd: 
1723: 14fd:         ! COMMUNICATIONS FUNCTIONS
1724: 14fd:         ! ?? = 1. Enable link
1725: 14fd:         ! ?? = 2. Disable link (no force)
1726: 14fd:         ! ?? = 3. Disable link (force)
1727: 14fd:         ! 22 = 4. Display link
1728: 14fd:         ! ?? = 5. Enable LAN for LU 6.2 Communications
1729: 14fd:         ! ?? = 6. Disable LAN for LU 6.2 Communications
1730: 14fd:         ! ?? = 7. Display LAN status for LU 6.2 Communications
1731: 14fd: 
1732: 14fd:         IF EVENT.NUMBER% = 9 THEN BEGIN
1733: 150f:             COMMENT$ = "The system has requested a " +              \
1734: 152f:                        "store control terminal function. "
1735: 152f:         ENDIF ELSE IF EVENT.NUMBER% = 16 THEN BEGIN
1736: 1541:             COMMENT$ = "The system has requested a " +              \
1737: 1561:                        "store control communications function. "
1738: 1561:         ENDIF ELSE IF EVENT.NUMBER% = 20 THEN BEGIN
1739: 1573:             COMMENT$ = "The system has requested a " +              \
1740: 1591:                        "store control controller function. "
1741: 1591:         ENDIF
1742: 1599: 
1743: 1599:         CMD$ = STR$(ASC(MID$(EVENT.UNIQUE.DATA$,2,1)))
1744: 15cb: 
1745: 15cb:         ! IF Load Terminal Storage
1746: 15cb:         IF CMD$ = "2" THEN BEGIN                ! X'02'
1747: 15e6: 
1748: 15e6:             TERMINAL$ =                                             \
1749: 163e:                 LEFT$("000" + STR$(GETN2(EVENT.UNIQUE.DATA$,10)),3)
1750: 163e: 
1751: 163e:             REASON.TEXT$ = "Load Terminal Storage"
1752: 1656: 
1753: 1656:         ! IF Load Application
1754: 1656:         ENDIF ELSE IF CMD$ = "4" THEN BEGIN     ! X'04'
1755: 1674: 
1756: 1674:             NAME$ =                                                 \
1757: 16a3:                 UCASE$(ASC.TEXT$(MID$(EVENT.UNIQUE.DATA$,3,8)))
1758: 16a3: 
1759: 16a3:             TERMINAL$ =                                             \
1760: 16fb:                 LEFT$("000" + STR$(GETN2(EVENT.UNIQUE.DATA$,10)),3)
1761: 16fb: 
1762: 16fb:             REASON.TEXT$ = "Start Terminal Application"
1763: 1713: 
1764: 1713:         ! IF display terminal status
1765: 1713:         ENDIF ELSE IF CMD$ = "16" THEN BEGIN    ! X'10'
1766: 172e: 
1767: 172e:             TERMINAL$ =                                             \
1768: 1786:                 LEFT$("000" + STR$(GETN2(EVENT.UNIQUE.DATA$,10)),3)
1769: 1786: 
1770: 1786:             REASON.TEXT$ = "Display Terminal Status"
1771: 179e: 
1772: 179e:         ! IF set controller date/time
1773: 179e:         ENDIF ELSE IF CMD$ = "40" THEN BEGIN    ! X'28'
1774: 17b9: 
1775: 17b9:             NODE$  = ASC.TEXT$(MID$(EVENT.UNIQUE.DATA$,11,2))
1776: 17e3:             NODE2$ = ASC.TEXT$(MID$(EVENT.UNIQUE.DATA$,13,2))
1777: 180d: 
1778: 180d:             REASON.TEXT$ = "Set System Date and Time"
1779: 1825: 
1780: 1825:         ! IF display link status
1781: 1825:         ENDIF ELSE IF CMD$ = "22" THEN BEGIN    ! X'16'
1782: 1840: 
1783: 1840:             LINK.ID$ = STR$(GETN2(EVENT.UNIQUE.DATA$,10))
1784: 186e:             NAME$    = UCASE$(ASC.TEXT$(MID$(EVENT.UNIQUE.DATA$,3,8)))
1785: 189d: 
1786: 189d:             REASON.TEXT$ = "Display Link"
1787: 18b5: 
1788: 18b5:         ! IF enable storage retention
1789: 18b5:         ENDIF ELSE IF CMD$ = "31" THEN BEGIN    ! X'1F'
1790: 18d0: 
1791: 18d0:             REASON.TEXT$ = "Enable Storage Retention"
1792: 18e8: 
1793: 18e8:         ! IF enable storage retention
1794: 18e8:         ENDIF ELSE IF CMD$ = "32" THEN BEGIN    ! X'20'
1795: 1903: 
1796: 1903:             REASON.TEXT$ = "Disable Storage Retention"
1797: 191b: 
1798: 191b:         ! IF load controller storage
1799: 191b:         ENDIF ELSE IF CMD$ = "60" THEN BEGIN    ! X'3C'
1800: 1936: 
1801: 1936:             REASON.TEXT$ = "Load Controller Storage"
1802: 194d: 
1803: 194d:         ! IF stop terminal application
1804: 194d:         ENDIF ELSE IF CMD$ = "6" THEN BEGIN    ! X'06'
1805: 1968: 
1806: 1968:             REASON.TEXT$ = "Stop Terminal Application"
1807: 197f: 
1808: 197f:         ENDIF ELSE BEGIN
1809: 1987: 
1810: 1987:             REASON.TEXT$ = "unknown"
1811: 199c: 
1812: 199c:         ENDIF
1813: 19a4: 
1814: 19a4:         ORIGIN$ = UNPACK$(MID$(EVENT.UNIQUE.DATA$,15,1))
1815: 19ce: 
1816: 19ce:         COMMENT$ = COMMENT$ +                                       \
1817: 1a07:                    ACTION.TEXT$ +                                   \
1818: 1a07:                    "The function was " +                            \
1819: 1a07:                    REASON.TEXT$ + "."
1820: 1a07: 
1821: 1a07:     ENDIF
1822: 1a0f: 
1823: 1a0f:     IF EVENT.FORMAT% = 31 THEN BEGIN
1824: 1a24: 
1825: 1a24: !IPL CAUSE: {System dump occurred}
1826: 1a24: !           {Operator requested from Application/Terminal Services}
1827: 1a24: !           {Program requested from Application/Terminal Services}
1828: 1a24: !           {Hardware fault detected}
1829: 1a24: !           {Program requested from store controller}
1830: 1a24: !           {IPL because of software activation}
1831: 1a24: !           {Normal}
1832: 1a24: !           {xx Undefined}
1833: 1a24: !DUMP CAUSE: {Operator requested from dump switch}
1834: 1a24: !            {Operator requested from Application/Terminal Services}
1835: 1a24: !            {System program check}
1836: 1a24: !            {Requested from store controller}
1837: 1a24: !            {Requested from Application/Terminal Services}
1838: 1a24: !            {Application program check}
1839: 1a24: !            {xx Undefined}
1840: 1a24: !DIAGNOSTIC RESULT: xxxx (DUMP CAUSED BY MCPC)
1841: 1a24: !MCPC VECTOR: {Device error exception}
1842: 1a24: !             {Single step interrupt}
1843: 1a24: !             {NMI interrupt}
1844: 1a24: !             {Breakpoint interrupt}
1845: 1a24: !             {INTO detected overflow exception}
1846: 1a24: !             {BOUND range exceeded exception}
1847: 1a24: !             {Opcode that is not valid exception}
1848: 1a24: !             {Processor extension not available exception}
1849: 1a24: !             {Double exception detected}
1850: 1a24: !             {Processor extension segment overrun interrupt}
1851: 1a24: !             {Task state that is not valid segment}
1852: 1a24: !             {Segment not present}
1853: 1a24: !             {Stack segment overrun or not present}
1854: 1a24: !             {General protection}
1855: 1a24: !             {xx Undefined}
1856: 1a24: !Note: If COMMAND indicates "Enable Controller RAM disks" or
1857: 1a24: !"Disable Controller RAM disks" the OPERATOR ID is listed.
1858: 1a24: !Otherwise, the file NAME is listed.
1859: 1a24: 
1860: 1a24:     ENDIF ELSE IF EVENT.FORMAT% = 32 THEN BEGIN
1861: 1a39: 
1862: 1a39: !Note: Up to 16 bytes of data is listed.
1863: 1a39: !DATA LENGTH: xxxx
1864: 1a39: !DATA: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx *aaaaaaaaaaaaaaaa*
1865: 1a39: 
1866: 1a39:     ENDIF ELSE IF EVENT.FORMAT% = 33 THEN BEGIN
1867: 1a4e: 
1868: 1a4e: !Note: Either IPL CAUSE or DUMP CAUSE is listed.
1869: 1a4e: !IPL CAUSE: {Controller was powered Off and On or a
1870: 1a4e: !            power line disturbance occurred}
1871: 1a4e: !           {System dump occurred}
1872: 1a4e: !           {Operator requested from Application/Terminal Services}
1873: 1a4e: !           {Program requested from Application/Terminal Services}
1874: 1a4e: !           {Hardware fault detected}
1875: 1a4e: !           {Operator or program requested controller storage load
1876: 1a4e: !            from System Menu Initialization}
1877: 1a4e: !           {Program requested from store controller}
1878: 1a4e: !           {IPL because of software activation}
1879: 1a4e: !           {Block move error}
1880: 1a4e: !           {Normal}
1881: 1a4e: !           {Operator pressed CTRL, ALT and DEL}
1882: 1a4e: !           {xx Undefined}
1883: 1a4e: !DUMP CAUSE: {Operator requested from dump switch}
1884: 1a4e: !            {Operator requested from Application/Terminal Services}
1885: 1a4e: !            {System program check}
1886: 1a4e: !            {Requested from store controller}
1887: 1a4e: !            {Requested from Application/Terminal Services}
1888: 1a4e: !            {Application program check}
1889: 1a4e: !            {File system hang}
1890: 1a4e: !            {Program error on IBM Realtime Interface Co-Processor
1891: 1a4e: !             Multiport adapter card 0}
1892: 1a4e: !            {Program error on IBM Realtime Interface Co-Processor
1893: 1a4e: !             Multiport adapter card 1}
1894: 1a4e: !            {Program error on IBM X.25 Interface Co-Processor/2
1895: 1a4e: !             adapter card 2}
1896: 1a4e: !            {Program error on IBM X.25 Interface Co-Processor/2
1897: 1a4e: !             adapter card 3}
1898: 1a4e: !            {Operator requested controller dump}
1899: 1a4e: !            {Operator pressed CTRL, ALT and MINUS SIGN (numeric keypad)}
1900: 1a4e: !            {Application program requested controller dump}
1901: 1a4e: !            {xx}
1902: 1a4e: !Note: If IPL CAUSE is listed and it indicates hardware fault detected,
1903: 1a4e: !the FAULT DESCRIPTION is listed. Otherwise, the DUMP COMPLETION CODE is
1904: 1a4e: !listed.
1905: 1a4e: !When a channel check occurs on the store controller, the identity of the
1906: 1a4e: !slot where the parity error occurred is not available.
1907: 1a4e: !DUMP COMPLETION CODE: {Unable to read boot record}
1908: 1a4e: !                      {Unable to read directory}
1909: 1a4e: !                      {No dump file in directory}
1910: 1a4e: !                      {Unable to read FAT}
1911: 1a4e: !                      {Not enough room in directory}
1912: 1a4e: !                      {Disk error while writing to dump file}
1913: 1a4e: !                      {Cannot find partition table}
1914: 1a4e: !                      {Normal}
1915: 1a4e: !                      {xx Undefined}
1916: 1a4e: !FAULT DESCRIPTION: {Memory parity error}
1917: 1a4e: !                   {Disk adapter failure}
1918: 1a4e: !                   {Channel check - slot number xx}
1919: 1a4e: !                   {Channel check}
1920: 1a4e: !                   {DMA bus timeout - arbitration xx}
1921: 1a4e: !                   {Watchdog timeout}
1922: 1a4e: !                   {Unknown}
1923: 1a4e: !DIAGNOSTIC CODE: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
1924: 1a4e: !Note: B5/S024/E027 may show UNIQUE DATA instead of DIAGNOSTIC CODE
1925: 1a4e: 
1926: 1a4e:         REASON$ = STR$(EVENT.NUMBER%)
1927: 1a6e: 
1928: 1a6e:         REASON.TEXT$ = "Unknown reason."
1929: 1a83: 
1930: 1a83:         ! Dump
1931: 1a83:         IF EVENT.MESSAGE.NUMBER% = 598 THEN BEGIN
1932: 1a99: 
1933: 1a99:             IF EVENT.NUMBER% = 1 THEN BEGIN
1934: 1aab:                 REASON.TEXT$ = "A system dump occurred."
1935: 1ac3:             ENDIF ELSE IF EVENT.NUMBER% = 31 THEN BEGIN
1936: 1ad5:                 REASON.TEXT$ = "Someone has pressed the store " +   \
1937: 1afc:                                "controller dump switch, causing " + \
1938: 1afc:                                "a store controller dump and an " +  \
1939: 1afc:                                "IPL to occur."
1940: 1afc:             ENDIF ELSE IF EVENT.NUMBER% = 33 THEN BEGIN
1941: 1b0e:                 REASON.TEXT$ = "A store controller dump and an " +  \
1942: 1b31:                                "IPL has occurred because of an " +  \
1943: 1b31:                                "operating system program check."
1944: 1b31:             ENDIF ELSE IF EVENT.NUMBER% = 36 THEN BEGIN
1945: 1b43:                 REASON.TEXT$ = "A store controller application " +  \
1946: 1b66:                                "program check caused a store " +    \
1947: 1b66:                                "controller dump."
1948: 1b66:             ENDIF ELSE IF EVENT.NUMBER% = 37 THEN BEGIN
1949: 1b78:                 REASON.TEXT$ = "A store controller storage dump " + \
1950: 1b9f:                                "and IPL have occurred because " +   \
1951: 1b9f:                                "multiple terminal application " +   \
1952: 1b9f:                                "timeouts have occurred."
1953: 1b9f:             ENDIF ELSE IF EVENT.NUMBER% = 38 THEN BEGIN
1954: 1bb1:                 REASON.TEXT$ = "A store controller storage dump " + \
1955: 1be0:                                "and IPL have occurred because a " + \
1956: 1be0:                                "program check occurred on a " +     \
1957: 1be0:                                "program running on Realtime " +     \
1958: 1be0:                                "Interface Co-Processor " +          \
1959: 1be0:                                "Multiport adapter card number 0."
1960: 1be0:             ENDIF ELSE IF EVENT.NUMBER% = 39 THEN BEGIN
1961: 1bf2:                 REASON.TEXT$ = "A store controller storage dump " + \
1962: 1c21:                                "and IPL have occurred because a " + \
1963: 1c21:                                "program check occurred on a " +     \
1964: 1c21:                                "program running on Realtime " +     \
1965: 1c21:                                "Interface Co-Processor " +          \
1966: 1c21:                                "Multiport adapter card number 1."
1967: 1c21:             ENDIF ELSE IF EVENT.NUMBER% = 40 THEN BEGIN
1968: 1c33:                 REASON.TEXT$ = "A store controller storage dump " + \
1969: 1c62:                                "and IPL have occurred because a " + \
1970: 1c62:                                "program check occurred on a " +     \
1971: 1c62:                                "program running on Realtime " +     \
1972: 1c62:                                "Interface Co-Processor " +          \
1973: 1c62:                                "Multiport adapter card number 2."
1974: 1c62:             ENDIF ELSE IF EVENT.NUMBER% = 41 THEN BEGIN
1975: 1c74:                 REASON.TEXT$ = "A store controller storage dump " + \
1976: 1ca3:                                "and IPL have occurred because a " + \
1977: 1ca3:                                "program check occurred on a " +     \
1978: 1ca3:                                "program running on Realtime " +     \
1979: 1ca3:                                "Interface Co-Processor " +          \
1980: 1ca3:                                "Multiport adapter card number 3."
1981: 1ca3:             ENDIF ELSE IF EVENT.NUMBER% = 42 THEN BEGIN
1982: 1cb5:                 REASON.TEXT$ = "An operator requested a store " +   \
1983: 1cdc:                                "controller dump and IPL. This " +   \
1984: 1cdc:                                "is the result of a controller " +   \
1985: 1cdc:                                "dump menu selection."
1986: 1cdc:             ENDIF ELSE IF EVENT.NUMBER% = 43 THEN BEGIN
1987: 1cee:                 REASON.TEXT$ = "An application requested a " +      \
1988: 1d19:                                "store controller dump and IPL. " +  \
1989: 1d19:                                "This is the result of an " +        \
1990: 1d19:                                "ADXSERVE call to dump the " +       \
1991: 1d19:                                "controller memory."
1992: 1d19:             ENDIF ELSE IF EVENT.NUMBER% = 44 THEN BEGIN
1993: 1d2b:                 REASON.TEXT$ = "An operator requested a dump " +    \
1994: 1d5a:                                "from the controller. This " +       \
1995: 1d5a:                                "reason code is used when the " +    \
1996: 1d5a:                                "operator requests a controller " +  \
1997: 1d5a:                                "dump by pressing CTRL+ALT+- " +     \
1998: 1d5a:                                "(minus on the numeric keypad)."
1999: 1d5a:             ENDIF ELSE IF EVENT.NUMBER% = 45 THEN BEGIN
2000: 1d6c:                 REASON.TEXT$ = "The store controller dump " +       \
2001: 1d8f:                                "occurred in response to a " +       \
2002: 1d8f:                                "SYSWBUG call."
2003: 1d8f:             ENDIF ELSE IF EVENT.NUMBER% = 46 THEN BEGIN
2004: 1da1:                 REASON.TEXT$ = "The store controller dump " +       \
2005: 1dc4:                                "occurred in response to a " +       \
2006: 1dc4:                                "panic call."
2007: 1dc4:             ENDIF ELSE IF EVENT.NUMBER% = 47 THEN BEGIN
2008: 1dd6:                 REASON.TEXT$ = "A controller dump and IPL " +       \
2009: 1e05:                                "occurred due to the pipe system " + \
2010: 1e05:                                "hang (requested by terminal " +     \
2011: 1e05:                                "loop or controller loop in an " +   \
2012: 1e05:                                "attempt to recover the local " +    \
2013: 1e05:                                "pipe system)."
2014: 1e05:             ENDIF ELSE IF EVENT.NUMBER% = 50 THEN BEGIN
2015: 1e17:                 REASON.TEXT$ = "The system dump occurred due " +    \
2016: 1e39:                                "to an underlying Operating " +      \
2017: 1e39:                                "System trap."
2018: 1e39:             ENDIF ELSE IF EVENT.NUMBER% = 51 THEN BEGIN
2019: 1e4b:                 REASON.TEXT$ = "The system dump occurred due " +    \
2020: 1e6d:                                "to an underlying Operating " +      \
2021: 1e6d:                                "System trap."
2022: 1e6d:             ENDIF ELSE IF EVENT.NUMBER% = 52 THEN BEGIN
2023: 1e7f:                 REASON.TEXT$ = "The system dump occurred due " +    \
2024: 1e9f:                                "to an Enhanced Mode application " + \
2025: 1e9f:                                "program check."
2026: 1e9f:             ENDIF
2027: 1eaa: 
2028: 1eaa:         ! IPL
2029: 1eaa:         ENDIF ELSE IF EVENT.MESSAGE.NUMBER% = 599 THEN BEGIN
2030: 1ec0: 
2031: 1ec0:             IF EVENT.NUMBER% = 0 THEN BEGIN
2032: 1ed2:                 REASON.TEXT$ = "The store controller was " +        \
2033: 1ef9:                                "powered Off, then powered On " +    \
2034: 1ef9:                                "or a power line disturbance " +     \
2035: 1ef9:                                "occurred forcing an IPL."
2036: 1ef9:             ENDIF ELSE IF EVENT.NUMBER% = 1 THEN BEGIN
2037: 1f0b:                 REASON.TEXT$ = "A system dump occurred."
2038: 1f23:             ENDIF ELSE IF EVENT.NUMBER% = 2 THEN BEGIN
2039: 1f35:                 REASON.TEXT$ = "The operator requested an IPL " +   \
2040: 1f54:                                "from system services."
2041: 1f54:             ENDIF ELSE IF EVENT.NUMBER% = 3 THEN BEGIN
2042: 1f66:                 REASON.TEXT$ = "The program requested an IPL " +    \
2043: 1f85:                                "from terminal services."
2044: 1f85:             ENDIF ELSE IF EVENT.NUMBER% = 4 THEN BEGIN
2045: 1f97:                 REASON.TEXT$ = "A hardware fault occurred."
2046: 1faf:             ENDIF ELSE IF EVENT.NUMBER% = 5 THEN BEGIN
2047: 1fc1:                 REASON.TEXT$ = "The program or operator " +         \
2048: 1fe0:                                "requested an IPL from OCF."
2049: 1fe0:             ENDIF ELSE IF EVENT.NUMBER% = 6 THEN BEGIN
2050: 1ff2:                 REASON.TEXT$ = "An IPL occurred because of " +      \
2051: 2019:                                "software activation. This is a " +  \
2052: 2019:                                "normal occurrence when you " +      \
2053: 2019:                                "apply software maintenance."
2054: 2019:             ENDIF ELSE IF EVENT.NUMBER% = 7 THEN BEGIN
2055: 202b:                 REASON.TEXT$ = "An IPL occurred because an " +      \
2056: 204d:                                "operator pressed Ctrl, Alt " +      \
2057: 204d:                                "and Del."
2058: 204d:             ENDIF ELSE IF EVENT.NUMBER% = 8 THEN BEGIN
2059: 205f:                 REASON.TEXT$ = "An IPL occurred because an " +      \
2060: 2081:                                "operator pressed Ctrl, Alt " +      \
2061: 2081:                                "and Esc."
2062: 2081:             ENDIF ELSE IF EVENT.NUMBER% = 9 THEN BEGIN
2063: 2093:                 REASON.TEXT$ = "An IPL occurred because a new " +   \
2064: 20b3:                                "loader has been successfully " +    \
2065: 20b3:                                "installed on the system."
2066: 20b3:             ENDIF
2067: 20bb: 
2068: 20bb:         ENDIF
2069: 20c3: 
2070: 20c3:         COMMENT$ = REASON.TEXT$
2071: 20e1: 
2072: 20e1:     ENDIF ELSE IF EVENT.FORMAT% = 34 THEN BEGIN
2073: 20f6: 
2074: 20f6: !---------------------------------
2075: 20f6: ! FORMAT 34
2076: 20f6: !---------------------------------
2077: 20f6: !   Type                1 byte INT
2078: 20f6: !   Operator            8 byte ASC
2079: 20f6: !   Unused (20)         1 byte ASC
2080: 20f6: !   Unused (00)         9 byte ASC
2081: 20f6: !---------------------------------
2082: 20f6: 
2083: 20f6:         ! ? Signon
2084: 20f6:         ! ? Signoff
2085: 20f6:         ! ? Disconnect
2086: 20f6:         TYPE$ = STR$(?VAL(UNPACK$(MID$(EVENT.UNIQUE.DATA$,1,1))))
2087: 2131: 
2088: 2131:         OPERATOR$ =                                                 \
2089: 217a:             RTRIM$(ASC.TEXT$(MID$(EVENT.UNIQUE.DATA$,2,8)),".")
2090: 217a: 
2091: 217a:         IF TYPE$ = "0" THEN BEGIN
2092: 2195:             TYPE.TEXT$ = "signed on"
2093: 21ac:         ENDIF ELSE IF TYPE$ = "1" THEN BEGIN
2094: 21c7:             TYPE.TEXT$ = "signed off"
2095: 21de:         ENDIF ELSE IF TYPE$ = "2" THEN BEGIN
2096: 21f9:             TYPE.TEXT$ = "disconnected"
2097: 220e:         ENDIF
2098: 2216: 
2099: 2216:         COMMENT$ = "Operator " + OPERATOR$ +                        \
2100: 224b:                    " has " + TYPE.TEXT$ + "."
2101: 224b: 
2102: 224b:     ENDIF ELSE IF EVENT.FORMAT% = 35 THEN BEGIN
2103: 2260: 
2104: 2260: !OPERATION: {Bad data returned from screen interface}
2105: 2260: !           {No null from screen interface}
2106: 2260: !           {Bad data in screen routine input file}
2107: 2260: !           {c}
2108: 2260: !DATA LENGTH: xxxx FIRST EIGHT BYTES: xxxxxxxxxxxxxxxx *aaaaaaaa*
2109: 2260: 
2110: 2260:     ENDIF ELSE IF EVENT.FORMAT% = 36 THEN BEGIN
2111: 2275: 
2112: 2275: !---------------------------------
2113: 2275: ! FORMAT 36
2114: 2275: !---------------------------------
2115: 2275: !   Lib name            1 byte ASC
2116: 2275: !   Action              1 byte ASC
2117: 2275: !   Filename           12 byte ASC
2118: 2275: !   Return code         4 byte INT
2119: 2275: !---------------------------------
2120: 2275: 
2121: 2275:         ! ADX_xPGM or ADX_xMNT or ADX_xBUL
2122: 2275:         LIBRARY$  = LEFT$(EVENT.UNIQUE.DATA$,1)
2123: 229a: 
2124: 229a:         ! ? Accept
2125: 229a:         ! ? Test
2126: 229a:         ! ? Cancel
2127: 229a:         ACTION$ = MID$(EVENT.UNIQUE.DATA$,2,1)
2128: 22bf: 
2129: 22bf:         FILENAME$ = GET.FILENAME$(3,12)
2130: 22d9: 
2131: 22d9:         RETURN.CODE$ = GET.RETURN.CODE$(15)
2132: 22f4: 
2133: 22f4:     ENDIF ELSE IF EVENT.FORMAT% = 37 THEN BEGIN
2134: 2308: 
2135: 2308: !LINE NAME: cccccccc
2136: 2308: 
2137: 2308:     ENDIF ELSE IF EVENT.FORMAT% = 38 THEN BEGIN
2138: 231c: 
2139: 231c: !LAST STATUS RECEIVED: xxxx
2140: 231c: 
2141: 231c:     ENDIF ELSE IF EVENT.FORMAT% = 39 THEN BEGIN
2142: 232e: 
2143: 232e: !DEVICE ID: xx
2144: 232e: 
2145: 232e:         DEVICE.ID$ = GET.DEVICE.ID$(1)
2146: 2347: 
2147: 2347:     ENDIF ELSE IF EVENT.FORMAT% = 40 THEN BEGIN
2148: 2359: 
2149: 2359: !TERMINAL NUMBER: iii
2150: 2359: !Note: The terminal number may not be valid if this error was logged due to a
2151: 2359: !CRC error. In addition, the following special terminal numbers may be logged
2152: 2359: !wuth this error:
2153: 2359: !   12, 283 - An error occurred in a message from a terminal that was
2154: 2359: !             requesting backup.
2155: 2359: !   12, 285 - An error occurred in a message from a terminal that has not yet
2156: 2359: !             been given a terminal number.
2157: 2359: !   12, 286 - An error occurred in a message from the primary store
2158: 2359: !             controller instructing this store controller to exit backup.
2159: 2359: 
2160: 2359:     ENDIF
2161: 2361: 
2162: 2361:     IF EVENT.FORMAT% = 41 THEN BEGIN
2163: 2373: 
2164: 2373: !---------------------------------
2165: 2373: ! FORMAT 41
2166: 2373: !---------------------------------
2167: 2373: !   Return code         4 byte INT
2168: 2373: !   Not used (00)      14 byte ASC
2169: 2373: !---------------------------------
2170: 2373: 
2171: 2373:         RETURN.CODE$ = GET.RETURN.CODE$(1)
2172: 238f: 
2173: 238f:     ENDIF ELSE IF EVENT.FORMAT% = 42 THEN BEGIN
2174: 23a4: 
2175: 23a4: !RC: {Description of the Return Code}
2176: 23a4: 
2177: 23a4:     ENDIF ELSE IF EVENT.FORMAT% = 43 THEN BEGIN
2178: 23b9: 
2179: 23b9: !HOST DATA: xxxxxxxxxxxxxxxx *aaaaaaaa*
2180: 23b9: 
2181: 23b9:     ENDIF ELSE IF EVENT.FORMAT% = 44 THEN BEGIN
2182: 23cb: 
2183: 23cb: !---------------------------------
2184: 23cb: ! FORMAT 44
2185: 23cb: !---------------------------------
2186: 23cb: !   Filename           12 byte ASC
2187: 23cb: !   Not used (00)       6 byte ASC
2188: 23cb: !---------------------------------
2189: 23cb: 
2190: 23cb:         FILENAME$ = GET.FILENAME$(1,12)
2191: 23e8: 
2192: 23e8:     ENDIF ELSE IF EVENT.FORMAT% = 45 THEN BEGIN
2193: 23fd: 
2194: 23fd: !---------------------------------
2195: 23fd: ! FORMAT 45
2196: 23fd: !---------------------------------
2197: 23fd: !   Program            12 byte ASC
2198: 23fd: !   Not used (00)       6 byte ASC
2199: 23fd: !---------------------------------
2200: 23fd: 
2201: 23fd:         FILENAME$ = GET.FILENAME$(1,12)
2202: 2417: 
2203: 2417:         M% = MATCHB(".",FILENAME$,1)                                    !CMW
2204: 2438: 
2205: 2438:         ! IF filename contains a full stop
2206: 2438:         IF M% > 1 THEN BEGIN
2207: 2447:             ! Strip all characters after the first full stop
2208: 2447:             PROGRAM$ = LEFT$(LEFT$(FILENAME$,M% - 1) +              \
2209: 24a1:                              NULL.PROGRAM$,8)
2210: 24a1:         ENDIF ELSE BEGIN
2211: 24a9:             PROGRAM$ = LEFT$(FILENAME$ + NULL.PROGRAM$,8)
2212: 24ea:         ENDIF
2213: 24f5: 
2214: 24f5:     ENDIF ELSE IF EVENT.FORMAT% = 46 THEN BEGIN
2215: 250a: 
2216: 250a: !TERMINAL NUMBER ENTERED: cccc
2217: 250a: 
2218: 250a:     ENDIF ELSE IF EVENT.FORMAT% = 47 THEN BEGIN
2219: 251f: 
2220: 251f: !---------------------------------
2221: 251f: ! FORMAT 47
2222: 251f: !---------------------------------
2223: 251f: !   Type or Reason      1 byte INT
2224: 251f: !   Operator ID         8 byte ASC
2225: 251f: !   Unused (20)         1 byte ASC
2226: 251f: !   Application Name    8 byte ASC
2227: 251f: !---------------------------------
2228: 251f: 
2229: 251f:         ! IF display/alter file utility
2230: 251f:         IF EVENT.NUMBER% = 177 THEN BEGIN
2231: 2535: 
2232: 2535:             ! ---------------------------------------
2233: 2535:             ! Use format specific to this application
2234: 2535:             ! ---------------------------------------
2235: 2535: 
2236: 2535:             IF EVENT.MESSAGE.NUMBER% = 990 THEN BEGIN
2237: 2548:                 REASON.TEXT$ = "open"
2238: 255f:             ENDIF ELSE IF EVENT.MESSAGE.NUMBER% = 991 THEN BEGIN
2239: 2572:                 REASON.TEXT$ = "update"
2240: 2587:             ENDIF
2241: 258f: 
2242: 258f:             OPERATOR$ =                                             \
2243: 25d8:                 RTRIM$(ASC.TEXT$(MID$(EVENT.UNIQUE.DATA$,10,8)),".")
2244: 25d8: 
2245: 25d8:             FILENAME$ = GET.FILENAME$(1,8)
2246: 25f2: 
2247: 25f2:             COMMENT$ = "The ADXCSJ0L application has been used " +  \
2248: 2637:                        "by operator " + OPERATOR$ +                 \
2249: 2637:                        " to " + REASON.TEXT$ +                      \
2250: 2637:                        " file " + FILENAME$ + "."
2251: 2637: 
2252: 2637:         ! IF any other application
2253: 2637:         ENDIF ELSE BEGIN
2254: 263f: 
2255: 263f:             ! 0 = Application ended
2256: 263f:             ! 1 = Operator request
2257: 263f:             ! 2 = Application request
2258: 263f:             TYPE$ = STR$(?VAL(UNPACK$(LEFT$(EVENT.UNIQUE.DATA$,1))))
2259: 267a:             REASON$ = TYPE$
2260: 2693: 
2261: 2693:             PROGRAM$  =                                             \
2262: 26ec:                 RTRIM$(UCASE$(ASC.TEXT$(RIGHT$(                     \
2263: 26ec:                     EVENT.UNIQUE.DATA$,8))),".")
2264: 26ec: 
2265: 26ec:             OPERATOR$ =                                             \
2266: 2735:                 RTRIM$(ASC.TEXT$(MID$(EVENT.UNIQUE.DATA$,2,8)),".")
2267: 2735: 
2268: 2735:             IF EVENT.MESSAGE.NUMBER% = 989 THEN BEGIN
2269: 274b:                 IF REASON$ = "0" THEN BEGIN
2270: 2766:                     REASON.TEXT$ = "completed"
2271: 277e:                 ENDIF ELSE IF REASON$ = "1" THEN BEGIN
2272: 2799:                     REASON.TEXT$ = "been stopped by operator " +    \
2273: 27bb:                                    OPERATOR$
2274: 27bb:                 ENDIF ELSE IF REASON$ = "2" THEN BEGIN
2275: 27d6:                     REASON.TEXT$ = "been stopped by " +             \
2276: 27f2:                                    "application request"
2277: 27f2:                 ENDIF
2278: 27fa: 
2279: 27fa:                 COMMENT$ = "An application " +                      \
2280: 2846:                            RTRIM$(PROGRAM$," ") +                   \
2281: 2846:                            " has " + REASON.TEXT$ + "."
2282: 2846: 
2283: 2846:             ENDIF ELSE IF EVENT.MESSAGE.NUMBER% = 992 THEN BEGIN
2284: 285c:                 IF TYPE$ = "0" THEN BEGIN
2285: 2877:                     TYPE.TEXT$ = "foreground"
2286: 288e:                 ENDIF ELSE IF TYPE$ = "1" THEN BEGIN
2287: 28a9:                     TYPE.TEXT$ = "background"
2288: 28be:                 ENDIF
2289: 28c6: 
2290: 28c6:                 REASON.TEXT$ = "been started by operator " +        \
2291: 28e6:                                OPERATOR$
2292: 28e6: 
2293: 28e6:                 COMMENT$ = "A " + TYPE.TEXT$ + " application " +    \
2294: 293b:                            RTRIM$(PROGRAM$," ") +                   \
2295: 293b:                            " has " + REASON.TEXT$ + "."
2296: 293b: 
2297: 293b:             ENDIF
2298: 2943: 
2299: 2943:         ENDIF
2300: 294e: 
2301: 294e:     ENDIF ELSE IF EVENT.FORMAT% = 48 THEN BEGIN
2302: 2960: 
2303: 2960: !---------------------------------
2304: 2960: ! FORMAT 48
2305: 2960: !---------------------------------
2306: 2960: !   Node name          10 byte ASC
2307: 2960: !   Unused              8 byte ASC
2308: 2960: !---------------------------------
2309: 2960: 
2310: 2960:         NODE$ = ASC.TEXT$(MID$(EVENT.UNIQUE.DATA$,6,2))
2311: 298a:         ID$ = ASC.TEXT$(MID$(EVENT.UNIQUE.DATA$,1,10))
2312: 29b7: 
2313: 29b7:     ENDIF ELSE IF EVENT.FORMAT% = 49 THEN BEGIN
2314: 29c9: 
2315: 29c9: !---------------------------------
2316: 29c9: ! FORMAT 49
2317: 29c9: !---------------------------------
2318: 29c9: !   Node name          10 byte ASC
2319: 29c9: !   Unused              8 byte ASC
2320: 29c9: !---------------------------------
2321: 29c9: 
2322: 29c9:         NODE$ = ASC.TEXT$(MID$(EVENT.UNIQUE.DATA$,6,2))
2323: 29f3:         ID$ = ASC.TEXT$(MID$(EVENT.UNIQUE.DATA$,1,10))
2324: 2a1f: 
2325: 2a1f:     ENDIF ELSE IF EVENT.FORMAT% = 50 THEN BEGIN
2326: 2a31: 
2327: 2a31: !---------------------------------
2328: 2a31: ! FORMAT 50
2329: 2a31: !---------------------------------
2330: 2a31: !   Node name          10 byte ASC
2331: 2a31: !   Return Code         4 byte INT
2332: 2a31: !   Unused              4 byte ASC
2333: 2a31: !---------------------------------
2334: 2a31: 
2335: 2a31:         NODE$ = ASC.TEXT$(MID$(EVENT.UNIQUE.DATA$,6,2))
2336: 2a5b:         ID$ = ASC.TEXT$(MID$(EVENT.UNIQUE.DATA$,1,10))
2337: 2a85: 
2338: 2a85:     ENDIF
2339: 2a8d: 
2340: 2a8d:     IF EVENT.FORMAT% = 51 THEN BEGIN
2341: 2aa2: 
2342: 2aa2: !DATA ERRORS: iiiiiiii UNDERRUNS: iiiiiiii PARITY ERRORS: iiiiiiii
2343: 2aa2: !REASON: Statistics only. Not necessarily an error.
2344: 2aa2: 
2345: 2aa2:     ENDIF ELSE IF EVENT.FORMAT% = 52 THEN BEGIN
2346: 2ab7: 
2347: 2ab7: !DISK ID: C
2348: 2ab7: !RETURN CODE: xxxxxxxx
2349: 2ab7: !NUMBER of BYTES: iiiiiiii
2350: 2ab7: 
2351: 2ab7:     ENDIF ELSE IF EVENT.FORMAT% = 53 THEN BEGIN
2352: 2ac9: 
2353: 2ac9: !FILE NAME: cccccccccccc
2354: 2ac9: !RC: {Description of the Return Code}
2355: 2ac9: 
2356: 2ac9:         FILENAME$ = GET.FILENAME$(1,12)
2357: 2ae6: 
2358: 2ae6:     ENDIF ELSE IF EVENT.FORMAT% = 54 THEN BEGIN
2359: 2afb: 
2360: 2afb: !CARD NUMBER: {0, 1, 2 or 3}
2361: 2afb: 
2362: 2afb:     ENDIF ELSE IF EVENT.FORMAT% = 55 THEN BEGIN
2363: 2b10: 
2364: 2b10: !CARD NUMBER: {0, 1, 2 or 3}
2365: 2b10: !PAGE NUMBER: xx
2366: 2b10: !PARITY REGISTER CONTENTS: xxxx
2367: 2b10: 
2368: 2b10:     ENDIF ELSE IF EVENT.FORMAT% = 56 THEN BEGIN
2369: 2b24: 
2370: 2b24: !AMOUNT OF SPACE REQUESTED: xxxxxxxx
2371: 2b24: !RETURN CODE: xxxxxxxx
2372: 2b24: 
2373: 2b24:     ENDIF ELSE IF EVENT.FORMAT% = 57 THEN BEGIN
2374: 2b38: 
2375: 2b38: !SAVED FILE SIZE: xxxxxxxx
2376: 2b38: !ACTUAL FILE SIZE: xxxxxxxx
2377: 2b38: !FILE NAME: cccccccccccc
2378: 2b38: 
2379: 2b38:     ENDIF ELSE IF EVENT.FORMAT% = 58 THEN BEGIN
2380: 2b4c: 
2381: 2b4c: !LAST STATUS RECEIVED: xxxx COMMAND: XX
2382: 2b4c: !REASON: {Description of the Event Number}
2383: 2b4c: 
2384: 2b4c:     ENDIF ELSE IF EVENT.FORMAT% = 59 THEN BEGIN
2385: 2b5e: 
2386: 2b5e: !FILE NAME: cccccccccccc
2387: 2b5e: 
2388: 2b5e:         FILENAME$ = GET.FILENAME$(1,12)
2389: 2b7a: 
2390: 2b7a:     ENDIF ELSE IF EVENT.FORMAT% = 60 THEN BEGIN
2391: 2b8c: 
2392: 2b8c: !STATUS CODE: xxxxxxxx
2393: 2b8c: 
2394: 2b8c:     ENDIF
2395: 2b94: 
2396: 2b94:     IF EVENT.FORMAT% = 61 THEN BEGIN
2397: 2ba9: 
2398: 2ba9: !MESSAGE RECEIVED: xxxxxxxxxxxxxxxx
2399: 2ba9: 
2400: 2ba9:     ENDIF ELSE IF EVENT.FORMAT% = 62 THEN BEGIN
2401: 2bbb: 
2402: 2bbb: !---------------------------------
2403: 2bbb: ! FORMAT 62
2404: 2bbb: !---------------------------------
2405: 2bbb: !   Filename           12 byte ASC
2406: 2bbb: !   Return code         4 byte INT
2407: 2bbb: !   Unused (00)         2 byte ASC
2408: 2bbb: !---------------------------------
2409: 2bbb: 
2410: 2bbb:         FILENAME$ = GET.FILENAME$(1,12)
2411: 2bd5:         RETURN.CODE$ = GET.RETURN.CODE$(13)
2412: 2bf1: 
2413: 2bf1:     ENDIF ELSE IF EVENT.FORMAT% = 63 THEN BEGIN
2414: 2c06: 
2415: 2c06: !UNIQUE DATA: rrrrxxxxxxxxyyyyyyyyffffffffffffffff
2416: 2c06: !                rrrr = Return Code from the OPEN operation.
2417: 2c06: !            xxxxxxxx = Offset within the spool file of the START
2418: 2c06:         !               of the data that was skipped.
2419: 2c06: !            yyyyyyyy = Offset within the spool file of the END
2420: 2c06: !                       of the data that was skipped.
2421: 2c06: !    ffffffffffffffff = The first 8 characters of the file name
2422: 2c06: !                       in the record being processed.
2423: 2c06: 
2424: 2c06:     ENDIF ELSE IF EVENT.FORMAT% = 64 THEN BEGIN
2425: 2c1b: 
2426: 2c1b: !UNIQUE DATA: 4010xxxxxxxxyyyyyyyyffffffffffffffff
2427: 2c1b: !
2428: 2c1b: !             4010 = FILE NOT FOUND Return Code.
2429: 2c1b: !         xxxxxxxx = Offset within the spool file of the START
2430: 2c1b: !                    of the skipped record.
2431: 2c1b: !         yyyyyyyy = Offset within the spool file of the END
2432: 2c1b: !                    of the skipped record.
2433: 2c1b: ! ffffffffffffffff = The first 8 characters of the file name
2434: 2c1b: !                    in the record being processed.
2435: 2c1b: 
2436: 2c1b:     ENDIF ELSE IF EVENT.FORMAT% = 65 THEN BEGIN
2437: 2c30: 
2438: 2c30: !UNIQUE DATA: rrrr00000000000000000000000000000000
2439: 2c30: !             rrrr = Return Code from the attempt to create
2440: 2c30: !                    the despooling process.
2441: 2c30: 
2442: 2c30:     ENDIF ELSE IF EVENT.FORMAT% = 66 THEN BEGIN
2443: 2c45: 
2444: 2c45: !MOD ID: xxx {Module Identification: For Toshiba Internal Use}
2445: 2c45: !LOC ID: xxx {Location Identification: For Toshiba Internal Use}
2446: 2c45: !PROD ID: xxxx {Product Identification: For Toshiba Internal Use}
2447: 2c45: !RETURN CODE: xxxxxxxx
2448: 2c45: !RC: {Description of the Return Code}
2449: 2c45: !ERROR CODE: xxxx {For Toshiba Internal Use}
2450: 2c45: !ERROR QUALIFIER 1: xxxx ERROR QUALIFIER 2: xxxx
2451: 2c45: 
2452: 2c45:     ENDIF ELSE IF EVENT.FORMAT% = 67 THEN BEGIN
2453: 2c5a: 
2454: 2c5a: !RELATIVE SECTOR NUMBER: xxxx
2455: 2c5a: !RC: {Description of the Return Code}
2456: 2c5a: !UNIQUE DATA: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
2457: 2c5a: 
2458: 2c5a:     ENDIF ELSE IF EVENT.FORMAT% = 68 THEN BEGIN
2459: 2c6c: 
2460: 2c6c: !RETURN CODE: xxxxxxxx
2461: 2c6c: !FILE NAME: ssssssssssss
2462: 2c6c: !SOURCE:
2463: 2c6c: !TIME FRAME:
2464: 2c6c: 
2465: 2c6c:         RETURN.CODE$ = GET.RETURN.CODE$(1)
2466: 2c85: 
2467: 2c85:         FILENAME$ = GET.FILENAME$(5,12)
2468: 2ca1: 
2469: 2ca1:     ENDIF ELSE IF EVENT.FORMAT% = 69 THEN BEGIN
2470: 2cb5: 
2471: 2cb5: !Configuration Record Name: ccccccccccc
2472: 2cb5: !RC: {A description of the return code}
2473: 2cb5: !FLAGS: xx xx xx xx
2474: 2cb5: 
2475: 2cb5:     ENDIF ELSE IF EVENT.FORMAT% = 70 THEN BEGIN
2476: 2cc7: 
2477: 2cc7: !DEVICE ADDRESS: xx COMMAND: xxxx
2478: 2cc7: !PRINTER STATUS: xxxx FISCAL STATUS: xxxx
2479: 2cc7: !RETURN CODE: xxxxxxxx
2480: 2cc7: !RC: (A description of the return code)
2481: 2cc7: 
2482: 2cc7:     ENDIF
2483: 2ccf: 
2484: 2ccf:     IF EVENT.FORMAT% = 71 THEN BEGIN
2485: 2ce4: 
2486: 2ce4: !Excessive Line Errors, Card = xxxx Port = xxxx
2487: 2ce4: 
2488: 2ce4:     ENDIF ELSE IF EVENT.FORMAT% = 72 THEN BEGIN
2489: 2cf9: 
2490: 2cf9: !CAUSE: (Open failure)
2491: 2cf9: !       (Read failure)
2492: 2cf9: !       (Special failure)
2493: 2cf9: !       (Terminal Mismatch)
2494: 2cf9: !RC:    (A description of the return code)
2495: 2cf9: 
2496: 2cf9:     ENDIF ELSE IF EVENT.FORMAT% = 73 THEN BEGIN
2497: 2d0e: 
2498: 2d0e: !DEVICE ADDRESS: xx COMMAND: xxxxxx
2499: 2d0e: !PRINTER DATA: xxxx STATUS: xxxxxxxxxxxx
2500: 2d0e: 
2501: 2d0e:     ENDIF ELSE IF EVENT.FORMAT% = 74 THEN BEGIN
2502: 2d23: 
2503: 2d23: !DEVICE ADDRESS: xx          COMMAND SENT : xxxxxxxx
2504: 2d23: !STATUS RECEIVED: xxxxxxxx   DATA RECEIVED: xxxxxxxxxxxx
2505: 2d23: !For message W356 DATA RECEIVED contains the device information
2506: 2d23: !response from the attached keyboard in the following format:
2507: 2d23: !
2508: 2d23: !10ddff03ee
2509: 2d23: !
2510: 2d23: !  dd = Device ID X'01' = Retail Point-of-Sale Keyboard, or
2511: 2d23: !                         Retail Point-of-Sale Keyboard with
2512: 2d23: !                         Card Reader
2513: 2d23: !                 X'02' = Retail Point-of-Sale Keyboard with Card
2514: 2d23: !                         Reader and Display
2515: 2d23: !                 X'03' = Modifiable Layout Keyboard with Card Reader
2516: 2d23: !                 X'04' = Retail Point-of-Sale Alphanumeric Keyboard
2517: 2d23: !                         with Card Reader
2518: 2d23: !                 X'05' = ANPOS (DBCS)
2519: 2d23: !  ff = Features
2520: 2d23: !                 X'01' = Retail Point-of-Sale Keyboard,
2521: 2d23: !                         Retail Point-of-Sale Keyboard with Card Reader, or
2522: 2d23: !                         Retail Point-of-Sale Keyboard with Card Reader
2523: 2d23: !                         and Display
2524: 2d23: !                 X'02' = Modifiable Layout Keyboard with Card Reader
2525: 2d23: !                 X'03' = Retail Point-of-Sale Alphanumeric Keyboard
2526: 2d23: !                         with Card Reader
2527: 2d23: !                 X'04' = ANPOS (DBCS)
2528: 2d23: !  ee = EC level
2529: 2d23: !For messages W357 and W404 DEVICE ADDRESS contains the device address
2530: 2d23: !response from the attached touch keyboard in the following format:
2531: 2d23: !xx
2532: 2d23: !xx = 5C or 5D The device address 5C indicates that the
2533: 2d23: !touch screen is plugged into socket 4A.
2534: 2d23: !When the touch screen is plugged into 4B,
2535: 2d23: !9A, 9B, or 9C, the touch screen device
2536: 2d23: !address is 5D.
2537: 2d23: !For messages W357 and W404 COMMAND SENT contains the 4-byte command
2538: 2d23: !last sent to the touch screen.
2539: 2d23: !For messages W357 and W404 STATUS RECEIVED contains the 4 bytes of status
2540: 2d23: !last received from the touch screen.
2541: 2d23: !For messages W357 and W404 DATA RECEIVED contains the 6 bytes of data
2542: 2d23: !last received from the touch screen.
2543: 2d23: !For message W885 E009 Unique Data Format rrrrrrrrriiiissssssssnn :
2544: 2d23: !  rrrrrrrr = POS data registers for the adapter.
2545: 2d23: !      iiii = POS ID for the adapter.
2546: 2d23: !  ssssssss = SLOT
2547: 2d23: !        nn = PC adapter slot number.
2548: 2d23: 
2549: 2d23:     ENDIF ELSE IF EVENT.FORMAT% = 75 THEN BEGIN
2550: 2d38: 
2551: 2d38: !FN: {File name of initialization file that cannot be executed}
2552: 2d38: !RC: {Description of return code}
2553: 2d38: 
2554: 2d38:     ENDIF ELSE IF EVENT.FORMAT% = 76 THEN BEGIN
2555: 2d4d: 
2556: 2d4d: !FN: {Network operation in progress when error occurred}
2557: 2d4d: !RC: {Description of return code}
2558: 2d4d: 
2559: 2d4d:     ENDIF ELSE IF EVENT.FORMAT% = 77 THEN BEGIN
2560: 2d5f: 
2561: 2d5f: !---------------------------------
2562: 2d5f: ! FORMAT 77
2563: 2d5f: !---------------------------------
2564: 2d5f: !   IP address         15 byte ASC
2565: 2d5f: !   Unused              3 byte ASC
2566: 2d5f: !---------------------------------
2567: 2d5f: 
2568: 2d5f:         IP.ADDRESS$ =                                               \
2569: 2dab:             RTRIM$(ASC.TEXT$(LEFT$(EVENT.UNIQUE.DATA$,15)),".")
2570: 2dab: 
2571: 2dab:     ENDIF ELSE IF EVENT.FORMAT% = 78 THEN BEGIN
2572: 2dc0: 
2573: 2dc0: !RC: {Description of return code}
2574: 2dc0: !CALL: xxxx
2575: 2dc0: !INFO: xxxxxxxxxxxx
2576: 2dc0: 
2577: 2dc0:     ENDIF ELSE IF EVENT.FORMAT% = 79 THEN BEGIN
2578: 2dd5: 
2579: 2dd5: !RC: {Description of return code}
2580: 2dd5: !MOD ID: xxx
2581: 2dd5: !LOC ID: xxxxxxx
2582: 2dd5: 
2583: 2dd5:     ENDIF ELSE IF EVENT.FORMAT% = 80 THEN BEGIN
2584: 2dea: 
2585: 2dea: !----------------------------------
2586: 2dea: ! FORMAT 80
2587: 2dea: !----------------------------------
2588: 2dea: !   Video BIOS Extension 2 byte INT
2589: 2dea: !   X Resolution         2 byte INT
2590: 2dea: !   X Resolution         2 byte INT
2591: 2dea: !   Colours              4 byte INT
2592: 2dea: !   Unused (00)          8 byte ASC
2593: 2dea: !----------------------------------
2594: 2dea: 
2595: 2dea:         VBE$    = RIGHT$("0000" + STR$(GETN2(EVENT.UNIQUE.DATA$,0)),4)
2596: 2e40:         RESX$   = STR$(GETN2(EVENT.UNIQUE.DATA$,2))
2597: 2e6e:         RESY$   = STR$(GETN2(EVENT.UNIQUE.DATA$,4))
2598: 2e9c:         COLORS$ = STR$(GETN4(EVENT.UNIQUE.DATA$,6))
2599: 2ecb: 
2600: 2ecb:     ENDIF
2601: 2ed3: 
2602: 2ed3:     IF EVENT.FORMAT% = 81 THEN BEGIN
2603: 2ee5: 
2604: 2ee5: !---------------------------------
2605: 2ee5: ! FORMAT 81
2606: 2ee5: !---------------------------------
2607: 2ee5: !   Node ID             2 byte ASC
2608: 2ee5: !   Filename           12 byte ASC
2609: 2ee5: !   Unused              4 byte ASC
2610: 2ee5: !---------------------------------
2611: 2ee5: 
2612: 2ee5:         NODE$ = ASC.TEXT$(MID$(EVENT.UNIQUE.DATA$,1,2))
2613: 2f0f:         FILENAME$ = GET.FILENAME$(3,12)
2614: 2f2c: 
2615: 2f2c:     ENDIF ELSE IF EVENT.FORMAT% = 82 THEN BEGIN
2616: 2f41: 
2617: 2f41: !---------------------------------
2618: 2f41: ! FORMAT 82
2619: 2f41: !---------------------------------
2620: 2f41: !   Return code         4 byte INT
2621: 2f41: !   Operator ID         8 byte ASC
2622: 2f41: !   Unused (20)         1 byte ASC
2623: 2f41: !   Unused (00)         5 byte ASC
2624: 2f41: !---------------------------------
2625: 2f41: 
2626: 2f41:         RETURN.CODE$ =                                              \
2627: 301b:             RIGHT$(HEX.TEXT$(UNPACK$(CHR$(0) +                      \
2628: 301b:             MID$(EVENT.UNIQUE.DATA$,4,1) +                          \
2629: 301b:             MID$(EVENT.UNIQUE.DATA$,3,1) +                          \
2630: 301b:             MID$(EVENT.UNIQUE.DATA$,2,1) +                          \
2631: 301b:             MID$(EVENT.UNIQUE.DATA$,1,1))),8)
2632: 301b: 
2633: 301b:         OPERATOR$ =                                                 \
2634: 3064:             RTRIM$(ASC.TEXT$(MID$(EVENT.UNIQUE.DATA$,5,8)),".")
2635: 3064: 
2636: 3064:         IF RETURN.CODE$ = "00000000" THEN BEGIN
2637: 3085:             IF EVENT.NUMBER% = 1 THEN BEGIN
2638: 3097:                 COMMENT$ = "Command line log concatenation " +      \
2639: 30b7:                            "completed successfully during IPL."
2640: 30b7:             ENDIF ELSE IF EVENT.NUMBER% = 2 THEN BEGIN
2641: 30c9:                 COMMENT$ = "Command line log concatenation " +      \
2642: 30f3:                            "completed successfully by operator " +  \
2643: 30f3:                            OPERATOR$ + "."
2644: 30f3:             ENDIF
2645: 30fe:         ENDIF ELSE IF RETURN.CODE$ = "FFFFFFFA" THEN BEGIN
2646: 311c:             COMMENT$ = "No files of the specified type were found."
2647: 3136:         ENDIF ELSE IF RETURN.CODE$ = "FFFFFFFB" THEN BEGIN
2648: 3154:             COMMENT$ = "Output file is compressed (zipped)."
2649: 316e:         ENDIF ELSE IF RETURN.CODE$ = "FFFFFFFC" THEN BEGIN
2650: 318c:             COMMENT$ = "Can not open/create output file."
2651: 31a6:         ENDIF ELSE IF RETURN.CODE$ = "FFFFFFFD" THEN BEGIN
2652: 31c4:             COMMENT$ = "Directory ADX_CLOG does not exist."
2653: 31dd:         ENDIF ELSE IF RETURN.CODE$ = "FFFFFFFE" THEN BEGIN
2654: 31fb:             COMMENT$ = "No valid options found in list file."
2655: 3214:         ENDIF ELSE BEGIN
2656: 321c:             COMMENT$ = "Command line log concatenation " +          \
2657: 3245:                        "failed with return code " +                 \
2658: 3245:                        RETURN.CODE$
2659: 3245:         ENDIF
2660: 3250: 
2661: 3250:     ENDIF ELSE IF EVENT.FORMAT% = 83 THEN BEGIN
2662: 3264: 
2663: 3264: !Directory Services could not be started. The return code indicates the reason:
2664: 3264: !00000033 - C:\ADX_IDT1\ADXLDIFF.DAT is missing, or could not be accessed
2665: 3264: !00000034 - C:\ADX_IDT1\ADXLDIFF.DAT does not contain the "version" property
2666: 3264: !00000035 - C:\ADX_IDT1\ADXLDIFF.DAT does not contain the "root" property
2667: 3264: !00000036 - C:\ADX_IDT1\ADXLDIFF.DAT does not contain the "admin" property
2668: 3264: !00000037 - C:\ADX_IDT1\ADXLDIFF.DAT does not contain the "defaultpp" property
2669: 3264: !00000038 - C:\ADX_IDT1\ADXLDIFF.DAT does not contain the "security" property
2670: 3264: !00000039 - C:\ADX_IDT1\ADXLDIFF.DAT does not contain a security level
2671: 3264: !0000003A - C:\ADX_IDT1\ADXLDIFF.DAT contains an invalid security level
2672: 3264: !0000003B - C:\ADX_IDT1\ADXLDIFF.DAT does not contain a security strength
2673: 3264: !0000003C - C:\ADX_IDT1\ADXLDIFF.DAT contains an invalid security strength
2674: 3264: !0000003D - There was a failure running slapadd.
2675: 3264: !Usually this is the result of an invalid entry in C:\ADX_IDT1\ADXLDIFF.DAT.
2676: 3264: !See F:adxetc/logs/slapadd.log for additional information.
2677: 3264: !0000003E - C:\ADX_IDT1\ADXLDIFF.DAT does not contain the
2678: 3264: !end of configuration header indicator.
2679: 3264: !See C:\ADX_IDT1\ADXLDIFF.SMP for information on where to place this indicator.
2680: 3264: !00000064 through 00000096 - There was an internal error
2681: 3264: !805C4012 - C:\ADX_IDT1\ADXLDIFF.DAT length is zero, or greater than the
2682: 3264: !           maximum of 65536
2683: 3264: !805CXXXX - Internal error starting Directory Services
2684: 3264: 
2685: 3264:     ENDIF ELSE IF EVENT.FORMAT% = 84 THEN BEGIN
2686: 3276: 
2687: 3276: !---------------------------------
2688: 3276: ! FORMAT 84
2689: 3276: !---------------------------------
2690: 3276: !   Lib name            1 byte ASC
2691: 3276: !   Filename           12 byte ASC
2692: 3276: !   Unused (00)         1 byte ASC
2693: 3276: !   Return code         4 byte INT
2694: 3276: !---------------------------------
2695: 3276: 
2696: 3276:         ! ADX_xPGM or ADX_xMNT or ADX_xBUL
2697: 3276:         LIBRARY$  = LEFT$(EVENT.UNIQUE.DATA$,1)
2698: 329b: 
2699: 329b:         FILENAME$ = GET.FILENAME$(2,12)
2700: 32b5: 
2701: 32b5:         RETURN.CODE$ = GET.RETURN.CODE$(15)
2702: 32ce: 
2703: 32ce:     ENDIF
2704: 32d6: 
2705: 32d6: !-------------------
2706: 32d6: ! User added formats
2707: 32d6: !-------------------
2708: 32d6: 
2709: 32d6:     IF EVENT.FORMAT% = 100 THEN BEGIN
2710: 32e8: 
2711: 32e8: ! Used by FTP and telnet connections
2712: 32e8: 
2713: 32e8: !---------------------------------
2714: 32e8: ! FORMAT 100
2715: 32e8: !---------------------------------
2716: 32e8: !   IP address         15 byte ASC
2717: 32e8: !   Unused (00)         3 byte ASC
2718: 32e8: !---------------------------------
2719: 32e8: 
2720: 32e8:         IP.ADDRESS$ =                                               \
2721: 3334:             RTRIM$(ASC.TEXT$(LEFT$(EVENT.UNIQUE.DATA$,15)),".")
2722: 3334: 
2723: 3334:     ENDIF ELSE IF EVENT.FORMAT% = 101 THEN BEGIN
2724: 3346: 
2725: 3346: ! Used by FTP login
2726: 3346: 
2727: 3346: !---------------------------------
2728: 3346: ! FORMAT 101
2729: 3346: !---------------------------------
2730: 3346: !   User ID            12 byte ASC
2731: 3346: !   Unused (00)         6 byte ASC
2732: 3346: !---------------------------------
2733: 3346: 
2734: 3346:         USER.ID$ =                                                  \
2735: 3392:             RTRIM$(ASC.TEXT$(LEFT$(EVENT.UNIQUE.DATA$,12)),".")
2736: 3392: 
2737: 3392:     ENDIF ELSE IF EVENT.FORMAT% = 102 THEN BEGIN
2738: 33a7: 
2739: 33a7: ! Used by W759 RECORD LOCKED FOR AN EXTENDED PERIOD OF TIME
2740: 33a7: 
2741: 33a7: !---------------------------------
2742: 33a7: ! FORMAT 102
2743: 33a7: !---------------------------------
2744: 33a7: !   Filename           12 byte ASC
2745: 33a7: !   Terminal            2 byte INT
2746: 33a7: !   Record Offset       4 byte INT
2747: 33a7: !---------------------------------
2748: 33a7: 
2749: 33a7:         FILENAME$ = GET.FILENAME$(1,12)
2750: 33c1: 
2751: 33c1:         TERMINAL$ =                                                 \
2752: 3419:             LEFT$("000" + STR$(GETN2(EVENT.UNIQUE.DATA$,12)),3)
2753: 3419: 
2754: 3419:         OFFSET$ = STR$(GETN4(EVENT.UNIQUE.DATA$,14))
2755: 3448: 
2756: 3448:         IF TERMINAL$ <> "000" THEN BEGIN
2757: 3463:             COMMENT$ = "Terminal " +                                \
2758: 34a3:                        TERMINAL$ +                                  \
2759: 34a3:                        " is locking a record in file " +            \
2760: 34a3:                        FILENAME$ +                                  \
2761: 34a3:                        " at offset " +                              \
2762: 34a3:                        OFFSET$ + "."
2763: 34a3:         ENDIF ELSE BEGIN
2764: 34ab:             COMMENT$ = "A controller application is locking " +     \
2765: 34e1:                        "a record in file " +                        \
2766: 34e1:                        FILENAME$ +                                  \
2767: 34e1:                        " at offset " +                              \
2768: 34e1:                        OFFSET$ + "."
2769: 34e1:         ENDIF
2770: 34ec: 
2771: 34ec:     ENDIF ELSE IF EVENT.FORMAT% = 103 THEN BEGIN
2772: 3501: 
2773: 3501: ! Used by W594 xxxxxxxx SERVICE STARTED  ID=uuuuuuuu
2774: 3501: 
2775: 3501: !---------------------------------
2776: 3501: ! FORMAT 103
2777: 3501: !---------------------------------
2778: 3501: !   Program             8 byte ASC
2779: 3501: !   Operator            8 byte ASC
2780: 3501: !   Unused (00)         2 byte ASC
2781: 3501: !---------------------------------
2782: 3501: 
2783: 3501:         PROGRAM$  =                                                 \
2784: 355c:             RTRIM$(UCASE$(ASC.TEXT$(                                \
2785: 355c:                 LEFT$(EVENT.UNIQUE.DATA$,8))),".")
2786: 355c: 
2787: 355c:         OPERATOR$ =                                                 \
2788: 35a5:             RTRIM$(ASC.TEXT$(MID$(EVENT.UNIQUE.DATA$,9,8)),".")
2789: 35a5: 
2790: 35a5:         IF OPERATOR$ = "*IPL*" THEN BEGIN
2791: 35c0:             COMMENT$ = "The " + PROGRAM$ +                          \
2792: 35eb:                        " application was started during IPL."
2793: 35eb:         ENDIF ELSE BEGIN
2794: 35f3:             COMMENT$ = "The " + PROGRAM$ + \
2795: 3628:                        " application was started by operator " +    \
2796: 3628:                        OPERATOR$ + "."
2797: 3628:         ENDIF
2798: 3633: 
2799: 3633:     ENDIF ELSE IF EVENT.FORMAT% = 104 THEN BEGIN
2800: 3645: 
2801: 3645: ! Used by W895 INETD STATUS HAS CHANGED  TYPE=xx
2802: 3645: 
2803: 3645: !---------------------------------
2804: 3645: ! FORMAT 104
2805: 3645: !---------------------------------
2806: 3645: !   Type                1 byte INT
2807: 3645: !   Unused (00)        17 byte ASC
2808: 3645: !---------------------------------
2809: 3645: 
2810: 3645:         TYPE$ = STR$(?VAL(UNPACK$(MID$(EVENT.UNIQUE.DATA$,1,1))))
2811: 3683: 
2812: 3683:     ENDIF ELSE IF EVENT.FORMAT% = 105 THEN BEGIN
2813: 3698: 
2814: 3698: !---------------------------------
2815: 3698: ! FORMAT 105
2816: 3698: !---------------------------------
2817: 3698: !   Unused (20)         2 byte ASC
2818: 3698: !   Unused (00)        16 byte ASC
2819: 3698: !---------------------------------
2820: 3698: 
2821: 3698:         IF EVENT.NUMBER% = 102 THEN BEGIN
2822: 36aa:             COMMENT$ = "Activated Master Controller."
2823: 36c4:         ENDIF ELSE IF EVENT.NUMBER% = 103 THEN BEGIN
2824: 36d6:             COMMENT$ = "Deactivated Master Controller."
2825: 36ef:         ENDIF ELSE IF EVENT.NUMBER% = 104 THEN BEGIN
2826: 3701:             COMMENT$ = "Activated File Server Controller."
2827: 371a:         ENDIF ELSE IF EVENT.NUMBER% = 105 THEN BEGIN
2828: 372c:             COMMENT$ = "Deactivated File Server Controller."
2829: 3743:         ENDIF
2830: 374b: 
2831: 374b:     ENDIF
2832: 3753: 
2833: 3753:     ! Program name
2834: 3753:     MESSAGE.TEXT$ =                                                 \   !BMW
2835: 378e:         SUBSTITUTE$(MESSAGE.TEXT$,"^PROGRAM",TRIM$(PROGRAM$," "))       !BMW
2836: 378e: 
2837: 378e:     ! Process ID
2838: 378e:     MESSAGE.TEXT$ = SUBSTITUTE$(MESSAGE.TEXT$,"^PID",PID$)
2839: 37c0: 
2840: 37c0:     ! Operator
2841: 37c0:     MESSAGE.TEXT$ = SUBSTITUTE$(MESSAGE.TEXT$,"^OPERATOR",OPERATOR$)
2842: 37ef: 
2843: 37ef:     ! Filename
2844: 37ef:     MESSAGE.TEXT$ = SUBSTITUTE$(MESSAGE.TEXT$,"^FILENAME",FILENAME$)
2845: 381e: 
2846: 381e:     ! Drive
2847: 381e:     MESSAGE.TEXT$ = SUBSTITUTE$(MESSAGE.TEXT$,"^DRIVE",DRIVE$)
2848: 384d: 
2849: 384d:     ! IP address
2850: 384d:     MESSAGE.TEXT$ = SUBSTITUTE$(MESSAGE.TEXT$,"^IPADDR",IP.ADDRESS$)
2851: 387c: 
2852: 387c:     ! User ID
2853: 387c:     MESSAGE.TEXT$ = SUBSTITUTE$(MESSAGE.TEXT$,"^USER",USER.ID$)
2854: 38ab: 
2855: 38ab:     ! Type
2856: 38ab:     MESSAGE.TEXT$ = SUBSTITUTE$(MESSAGE.TEXT$,"^TYPE",TYPE$)
2857: 38da: 
2858: 38da:     ! Reason
2859: 38da:     MESSAGE.TEXT$ = SUBSTITUTE$(MESSAGE.TEXT$,"^REASON",REASON$)
2860: 3909: 
2861: 3909:     ! Terminal
2862: 3909:     MESSAGE.TEXT$ = SUBSTITUTE$(MESSAGE.TEXT$,"^TERMINAL",TERMINAL$)
2863: 3938: 
2864: 3938:     ! Return code
2865: 3938:     MESSAGE.TEXT$ = SUBSTITUTE$(MESSAGE.TEXT$,"^RC",RETURN.CODE$)
2866: 396a: 
2867: 396a:     ! Library
2868: 396a:     MESSAGE.TEXT$ = SUBSTITUTE$(MESSAGE.TEXT$,"^LIB",LIBRARY$)
2869: 3999: 
2870: 3999:     ! Device ID
2871: 3999:     MESSAGE.TEXT$ = SUBSTITUTE$(MESSAGE.TEXT$,"^DEVICE",DEVICE.ID$)
2872: 39c8: 
2873: 39c8:     ! VBE Version
2874: 39c8:     MESSAGE.TEXT$ = SUBSTITUTE$(MESSAGE.TEXT$,"^VBE",VBE$)
2875: 39f7: 
2876: 39f7:     ! X Resolution
2877: 39f7:     MESSAGE.TEXT$ = SUBSTITUTE$(MESSAGE.TEXT$,"^RESX",RESX$)
2878: 3a26: 
2879: 3a26:     ! Y Resolution
2880: 3a26:     MESSAGE.TEXT$ = SUBSTITUTE$(MESSAGE.TEXT$,"^RESY",RESY$)
2881: 3a55: 
2882: 3a55:     ! Colors
2883: 3a55:     MESSAGE.TEXT$ = SUBSTITUTE$(MESSAGE.TEXT$,"^COLORS",COLORS$)
2884: 3a84: 
2885: 3a84:     ! Node ID
2886: 3a84:     MESSAGE.TEXT$ = SUBSTITUTE$(MESSAGE.TEXT$,"^NODE",NODE$)
2887: 3ab3: 
2888: 3ab3:     ! Other Node ID
2889: 3ab3:     MESSAGE.TEXT$ = SUBSTITUTE$(MESSAGE.TEXT$,"^NODE2",NODE2$)
2890: 3ae2: 
2891: 3ae2:     ! ID
2892: 3ae2:     MESSAGE.TEXT$ = SUBSTITUTE$(MESSAGE.TEXT$,"^ID",ID$)
2893: 3b11: 
2894: 3b11:     ! IF no return code
2895: 3b11:     IF RETURN.CODE$ = "QQQQQQQQ" THEN BEGIN
2896: 3b2f:         RETURN.CODE$ = ""
2897: 3b46:     ENDIF
2898: 3b4e: 
2899: 3b4e:     ! IF no PID
2900: 3b4e:     IF PID$ = "QQQQQQQQ" THEN BEGIN                                     !EMW
2901: 3b6c:         PID$ = ""
2902: 3b83:     ENDIF
2903: 3b8b: 
2904: 3b8b:     ! IF no program
2905: 3b8b:     IF PROGRAM$ = "QQQQQQQQ" THEN BEGIN
2906: 3ba9:         PROGRAM$ = ""
2907: 3bc0:     ENDIF
2908: 3bc8: 
2909: 3bc8:     ! IF missing records
2910: 3bc8:     IF EVENT.DATE% = 0 THEN BEGIN
2911: 3be7:         MESSAGE.TEXT$ = "There are missing event logs"
2912: 3bfe:         COMMENT$ = "Missing event logs can occur if " +             \   !FMW
2913: 3c28:                    "the event log pipe is too small, an " +         \   !FMW
2914: 3c28:                    "application is flooding the event logs or " +   \   !FMW
2915: 3c28:                    "the EVENTMON application has been stopped " +   \   !FMW
2916: 3c28:                    "for an extended period."                            !FMW
2917: 3c28: 
2918: 3c28:     ENDIF
2919: 3c30: 
2920: 3c30:     ! IF multiple repeated event log entries
2921: 3c30:     IF EVENT.COUNT% > 1 THEN BEGIN
2922: 3c42: 
2923: 3c42:         COMMENT$ = COMMENT$ +                                       \
2924: 3c85:                    " This event is repeated " +                     \
2925: 3c85:                    STR$(EVENT.COUNT%) + " times."
2926: 3c85: 
2927: 3c85:     ENDIF
2928: 3c8d: 
2929: 3c8d:     ! Display event log details
2930: 3c8d:     CALL PSU0406
2931: 3c9a: 
2932: 3c9a: END SUB
2933: 3cae: 
2934: 3cae: End of Compilation
