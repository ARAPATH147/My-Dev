   1: 0000: \***********************************************************************
   2: 0000: \***********************************************************************
   3: 0000: \***
   4: 0000: \***    PROGRAM         :       PSU04
   5: 0000: \***    DESCRIPTION     :       Event log viewer utility
   6: 0000: \***    AUTHOR          :       Mark Walker
   7: 0000: \***    DATE            :       26th September 2017
   8: 0000: \***
   9: 0000: \***********************************************************************
  10: 0000: \***********************************************************************
  11: 0000: \***
  12: 0000: \***    Module 3 contains formatting of the contents of the detail
  13: 0000: \***    screen for GSA application events.
  14: 0000: \***
  15: 0000: \***********************************************************************
  16: 0000: \***********************************************************************
  17: 0000: \***
  18: 0000: \***    MODIFICATIONS
  19: 0000: \***
  20: 0000: \***    Version A.          Mark Walker                 26th Sep 2017
  21: 0000: \***    Initial version.
  22: 0000: \***
  23: 0000: \***    Version B.          Mark Walker                  6th Dec 2017
  24: 0000: \***    Removed redundant ERRNH module reference.
  25: 0000: \***
  26: 0000: \***********************************************************************
  27: 0000: \***********************************************************************
  28: 0000: 
  29: 0000: \***********************************************************************
  30: 0000: \***
  31: 0000: \***    Global variable declarations
  32: 0000: \***
  33: 0000: \***********************************************************************
  34: 0000: 
  35: 0000: %INCLUDE PSU04G.J86
  36: 0000: \***********************************************************************
  37: 0000: \***********************************************************************
  38: 0000: \***
  39: 0000: \***    GLOBAL VARIABLE DEFINITIONS FOR PSU04
  40: 0000: \***
  41: 0000: \***********************************************************************
  42: 0000: \***********************************************************************
  43: 0000: \***
  44: 0000: \***    MODIFICATIONS
  45: 0000: \***
  46: 0000: \***    Version A.          Mark Walker                 26th Sep 2017
  47: 0000: \***    Initial version.
  48: 0000: \***
  49: 0000: \***    Version B.          Mark Walker                  2nd Nov 2017
  50: 0000: \***    Added support for the source selection list.
  51: 0000: \***
  52: 0000: \***    Version C.          Mark Walker                  6th Nov 2017
  53: 0000: \***    Updated handling of bucket and source text descriptions.
  54: 0000: \***
  55: 0000: \***    Version D.          Mark Walker                 21st Nov 2017
  56: 0000: \***    Added support for the UTILS session screen.
  57: 0000: \***
  58: 0000: \***    Version E.          Mark Walker                  6th Dec 2017
  59: 0000: \***    Moved some local variables to globals to support moving
  60: 0000: \***    some functions from the main screen handling module to
  61: 0000: \***    an external subprogram.
  62: 0000: \***
  63: 0000: \***    Version F.          Mark Walker                 19th Mar 2017
  64: 0000: \***    Added support for reporting application events logged by
  65: 0000: \***    text file editor applications.
  66: 0000: \***
  67: 0000: \***********************************************************************
  68: 0000: \***********************************************************************
  69: 0000: 
  70: 0000:     INTEGER*1 GLOBAL CURRENT.FIELD%                                     !EMW
  71: 0000:     INTEGER*1 GLOBAL FALSE
  72: 0000:     INTEGER*1 GLOBAL OPEN.EVAPP
  73: 0000:     INTEGER*1 GLOBAL TRUE
  74: 0000:     INTEGER*1 GLOBAL U0401.APPLICATION%
  75: 0000:     INTEGER*1 GLOBAL U0401.APPLICATION.STATUS%
  76: 0000:     INTEGER*1 GLOBAL U0401.BUCKET%
  77: 0000:     INTEGER*1 GLOBAL U0401.BUCKET.STATUS%
  78: 0000:     INTEGER*1 GLOBAL U0401.CONTROLLER.ID%
  79: 0000:     INTEGER*1 GLOBAL U0401.CONTROLLER.ID.STATUS%
  80: 0000:     INTEGER*1 GLOBAL U0401.EVENT%
  81: 0000:     INTEGER*1 GLOBAL U0401.EVENT.STATUS%
  82: 0000:     INTEGER*1 GLOBAL U0401.LOG.DESC%
  83: 0000:     INTEGER*1 GLOBAL U0401.LOG.NUMBER%
  84: 0000:     INTEGER*1 GLOBAL U0401.MESSAGE.GROUP%
  85: 0000:     INTEGER*1 GLOBAL U0401.MESSAGE.GROUP.STATUS%
  86: 0000:     INTEGER*1 GLOBAL U0401.MESSAGE.NUMBER%
  87: 0000:     INTEGER*1 GLOBAL U0401.MESSAGE.NUMBER.STATUS%
  88: 0000:     INTEGER*1 GLOBAL U0401.SEVERITY%
  89: 0000:     INTEGER*1 GLOBAL U0401.SEVERITY.STATUS%
  90: 0000:     INTEGER*1 GLOBAL U0401.SOURCE%
  91: 0000:     INTEGER*1 GLOBAL U0401.SOURCE.STATUS%
  92: 0000:     INTEGER*1 GLOBAL U0401.TERMINAL%
  93: 0000:     INTEGER*1 GLOBAL U0401.TERMINAL.STATUS%
  94: 0000:     INTEGER*1 GLOBAL U0402.PAGE%
  95: 0000:     INTEGER*1 GLOBAL U0405.PAGE%
  96: 0000:     INTEGER*1 GLOBAL U0406.PAGE%
  97: 0000:     INTEGER*1 GLOBAL U0411.PAGE%                                        !BMW
  98: 0000:     INTEGER*1 GLOBAL U0412.PAGE%                                        !DMW
  99: 0000:     INTEGER*1 GLOBAL VALID.INPUT
 100: 0000:     INTEGER*1 GLOBAL VALID.KEY
 101: 0000: 
 102: 0000:     INTEGER*2 GLOBAL APPLICATIONS.PER.PAGE%
 103: 0000:     INTEGER*2 GLOBAL COMMAND.TIME.RANGE%
 104: 0000:     INTEGER*2 GLOBAL COMMANDS.PER.PAGE%
 105: 0000:     INTEGER*2 GLOBAL CURRENT.INDEX%                                     !EMW
 106: 0000:     INTEGER*2 GLOBAL CURRENT.REPORT.NUM%
 107: 0000:     INTEGER*2 GLOBAL EVENT.BUCKET%
 108: 0000:     INTEGER*2 GLOBAL EVENT.COUNT%
 109: 0000:     INTEGER*2 GLOBAL EVENT.DAY%
 110: 0000:     INTEGER*2 GLOBAL EVENT.FORMAT%
 111: 0000:     INTEGER*2 GLOBAL EVENT.HOUR%
 112: 0000:     INTEGER*2 GLOBAL EVENT.MESSAGE.NUMBER%
 113: 0000:     INTEGER*2 GLOBAL EVENT.MIN%
 114: 0000:     INTEGER*2 GLOBAL EVENT.MONTH%
 115: 0000:     INTEGER*2 GLOBAL EVENT.NODE.ID%
 116: 0000:     INTEGER*2 GLOBAL EVENT.NUMBER%
 117: 0000:     INTEGER*2 GLOBAL EVENT.SEVERITY%
 118: 0000:     INTEGER*2 GLOBAL EVENT.SOURCE%
 119: 0000:     INTEGER*2 GLOBAL EVENT.TERMINAL%
 120: 0000:     INTEGER*2 GLOBAL EVENT.YEAR%
 121: 0000:     INTEGER*2 GLOBAL FILES.PER.PAGE%
 122: 0000:     INTEGER*2 GLOBAL LINE.LENGTH%
 123: 0000:     INTEGER*2 GLOBAL MAX.FILE.RECORDS%
 124: 0000:     INTEGER*2 GLOBAL MAX.SOURCE.RECORDS%                                !BMW
 125: 0000:     INTEGER*2 GLOBAL NULL.MAPPING%                                      !BMW
 126: 0000:     INTEGER*2 GLOBAL RESULTS.COUNT%                                     !EMW
 127: 0000:     INTEGER*2 GLOBAL RESULTS.INDEX%                                     !EMW
 128: 0000:     INTEGER*2 GLOBAL RESULTS.LAST.PAGE%                                 !EMW
 129: 0000:     INTEGER*2 GLOBAL RESULTS.PAGE%                                      !EMW
 130: 0000:     INTEGER*2 GLOBAL RESULTS.PER.PAGE%
 131: 0000:     INTEGER*2 GLOBAL RESULTS.THIS.PAGE%                                 !EMW
 132: 0000:     INTEGER*2 GLOBAL RESULTS.TOTAL.PAGES%                               !EMW
 133: 0000:     INTEGER*2 GLOBAL SOURCES.PER.PAGE%                                  !BMW
 134: 0000:     INTEGER*2 GLOBAL ULOG.REPORT.NUM%                                   !DMW
 135: 0000:     INTEGER*2 GLOBAL ULOG.SESS.NUM%                                     !DMW
 136: 0000: 
 137: 0000:     INTEGER*4 GLOBAL EVENT.DATE%
 138: 0000:     INTEGER*4 GLOBAL EVENT.TIME%
 139: 0000: 
 140: 0000:     STRING GLOBAL ALL.APPLICATIONS.TEXT$
 141: 0000:     STRING GLOBAL ALL.BUCKETS.TEXT$
 142: 0000:     STRING GLOBAL ALL.CONTROLLERS.TEXT$
 143: 0000:     STRING GLOBAL ALL.EVENTS.TEXT$
 144: 0000:     STRING GLOBAL ALL.MESSAGE.GROUPS.TEXT$
 145: 0000:     STRING GLOBAL ALL.MESSAGE.NUMBERS.TEXT$
 146: 0000:     STRING GLOBAL ALL.SEVERITYS.TEXT$
 147: 0000:     STRING GLOBAL ALL.SOURCES.TEXT$
 148: 0000:     STRING GLOBAL ALL.TERMINALS.TEXT$
 149: 0000:     STRING GLOBAL BATCH.SCREEN.FLAG$
 150: 0000:     STRING GLOBAL BUCKET.TEXT$(1)
 151: 0000:     STRING GLOBAL CHAIN.TO.PROG$
 152: 0000:     STRING GLOBAL COMMENT$
 153: 0000:     STRING GLOBAL CONTROLLER.ID$
 154: 0000:     STRING GLOBAL CURRENT.CODE$
 155: 0000:     STRING GLOBAL DOW$(1)
 156: 0000:     STRING GLOBAL EDITOR.NAME$                                          !FMW
 157: 0000:     STRING GLOBAL EDITOR.PATHNAME$                                      !FMW
 158: 0000:     STRING GLOBAL EDITOR.PROGRAM$                                       !FMW
 159: 0000:     STRING GLOBAL EDITOR.TYPE$                                          !FMW
 160: 0000:     STRING GLOBAL EE$(1)
 161: 0000:     STRING GLOBAL EVENT.DOW$
 162: 0000:     STRING GLOBAL EVENT.MESSAGE.GROUP$
 163: 0000:     STRING GLOBAL EVENT.UNIQUE.DATA$
 164: 0000:     STRING GLOBAL FILE.OPERATION$
 165: 0000:     STRING GLOBAL HIGHWORD.DESCRIPTION$(1)
 166: 0000:     STRING GLOBAL HIGHWORD.ERRORCODE$(1)
 167: 0000:     STRING GLOBAL LA$(1)
 168: 0000:     STRING GLOBAL LE$(1)
 169: 0000:     STRING GLOBAL LJ$(1)
 170: 0000:     STRING GLOBAL LOG.DESC$
 171: 0000:     STRING GLOBAL LOG.NUMBER$
 172: 0000:     STRING GLOBAL LOWWORD.DESCRIPTION$(1)
 173: 0000:     STRING GLOBAL LOWWORD.ERRORCODE$(1)
 174: 0000:     STRING GLOBAL LW$(1)
 175: 0000:     STRING GLOBAL MESSAGE.TEXT$
 176: 0000:     STRING GLOBAL MODULE.NUMBER$
 177: 0000:     STRING GLOBAL NO.APPLICATIONS.TEXT$
 178: 0000:     STRING GLOBAL NO.BUCKETS.TEXT$
 179: 0000:     STRING GLOBAL NO.SEVERITYS.TEXT$
 180: 0000:     STRING GLOBAL NO.SOURCES.TEXT$                                      !BMW
 181: 0000:     STRING GLOBAL NONPRINTABLE.CHARS$
 182: 0000:     STRING GLOBAL NONPRINTABLE.MAP$
 183: 0000:     STRING GLOBAL NULL.FILENAME$
 184: 0000:     STRING GLOBAL NULL.PROGRAM$
 185: 0000:     STRING GLOBAL PID$
 186: 0000:     STRING GLOBAL PRINTABLE.CHARS$
 187: 0000:     STRING GLOBAL PROGRAM$
 188: 0000:     STRING GLOBAL R$(1)
 189: 0000:     STRING GLOBAL RETURN.CODE$
 190: 0000:     STRING GLOBAL RETURN.ERR$
 191: 0000:     STRING GLOBAL SE$(1)
 192: 0000:     STRING GLOBAL SELECTED.APPLICATIONS.TEXT$
 193: 0000:     STRING GLOBAL SELECTED.BUCKETS.TEXT$
 194: 0000:     STRING GLOBAL SELECTED.SEVERITYS.TEXT$
 195: 0000:     STRING GLOBAL SELECTED.SOURCES.TEXT$                                !BMW
 196: 0000:     STRING GLOBAL SEVERITY.TEXT$(1)
 197: 0000:     STRING GLOBAL SINGLE.APPLICATION.TEXT$
 198: 0000:     STRING GLOBAL SINGLE.BUCKET.TEXT$
 199: 0000:     STRING GLOBAL SINGLE.CONTROLLER.TEXT$
 200: 0000:     STRING GLOBAL SINGLE.EVENT.TEXT$
 201: 0000:     STRING GLOBAL SINGLE.MESSAGE.GROUP.TEXT$
 202: 0000:     STRING GLOBAL SINGLE.MESSAGE.NUMBER.TEXT$
 203: 0000:     STRING GLOBAL SINGLE.SEVERITY.TEXT$
 204: 0000:     STRING GLOBAL SINGLE.SOURCE.TEXT$
 205: 0000:     STRING GLOBAL SINGLE.TERMINAL.TEXT$
 206: 0000:     STRING GLOBAL SUMMARY.RECORD$(1)                                    !EMW
 207: 0000:     STRING GLOBAL SOURCE.TEXT$(1)                                       !CMW
 208: 0000:     STRING GLOBAL SS$(1)
 209: 0000:     STRING GLOBAL SW$(1)
 210: 0000:     STRING GLOBAL TILL.NUMBER$
 211: 0000:     STRING GLOBAL TS$(1)
 212: 0000:     STRING GLOBAL ULOG.FILE.NAME$                                       !DMW
 213: 0000:     STRING GLOBAL ULOG.RECORD$(1)                                       !EMW
 214: 0000: 
 215: 0000: 
 216: 0000: \***********************************************************************
 217: 0000: \***
 218: 0000: \***    Local variable declarations
 219: 0000: \***
 220: 0000: \***********************************************************************
 221: 0000: 
 222: 0000:     INTEGER*2 I%
 223: 0000:     INTEGER*2 INDEX%
 224: 0000:     INTEGER*2 M%
 225: 0000:     INTEGER*2 SESS.NUM%
 226: 0000: 
 227: 0000:     STRING ACTUAL$
 228: 0000:     STRING CODE$
 229: 0000:     STRING CODE.TEXT$
 230: 0000:     STRING COUNT$
 231: 0000:     STRING EXPECTED$
 232: 0000:     STRING FIELD$
 233: 0000:     STRING FILE$
 234: 0000:     STRING FILENAME$
 235: 0000:     STRING FLAG$
 236: 0000:     STRING FLAG.TEXT$
 237: 0000:     STRING FUNCTION$
 238: 0000:     STRING IMFOK.FLAG$
 239: 0000:     STRING ITEM.CODE$
 240: 0000:     STRING KEY$
 241: 0000:     STRING KEY.TEXT$
 242: 0000:     STRING LINE.NUMBER$
 243: 0000:     STRING LINE.TEXT$
 244: 0000:     STRING MODULE$
 245: 0000:     STRING PROGRAM.CHILD$
 246: 0000:     STRING PROGRAM.DATE$
 247: 0000:     STRING PROGRAM.NUMBER$
 248: 0000:     STRING PROGRAM.TIME$
 249: 0000:     STRING SCREEN$
 250: 0000:     STRING SESS.TEXT$
 251: 0000: 
 252: 0000: \***********************************************************************
 253: 0000: \***
 254: 0000: \***    Function definitions
 255: 0000: \***
 256: 0000: \***********************************************************************
 257: 0000: 
 258: 0000: %INCLUDE BTCMEM.J86
 259: 0000: !********************************************************************
 260: 0000: !***
 261: 0000: !***    INCLUDED CODE:  BTCMEM.J86
 262: 0000: !***    AUTHOR:         Stuart William McConnachie
 263: 0000: !***    DATE:           26th February 2006
 264: 0000: !***
 265: 0000: !********************************************************************
 266: 0000: !***
 267: 0000: !***    Controller CBASIC Memory Functions
 268: 0000: !***
 269: 0000: !********************************************************************
 270: 0000: 
 271: 0000: !Get a single byte integer from a string offset
 272: 0000: FUNCTION GETN1 (S$, P%) EXTERNAL
 273: 0000:     STRING S$
 274: 0000:     INTEGER*2 P%
 275: 0000:     INTEGER*2 GETN1
 276: 0000: END FUNCTION
 277: 0000: 
 278: 0000: !Get a two byte integer from a string offset
 279: 0000: FUNCTION GETN2 (S$, P%) EXTERNAL
 280: 0000:     STRING S$
 281: 0000:     INTEGER*2 P%
 282: 0000:     INTEGER*2 GETN2
 283: 0000: END FUNCTION
 284: 0000: 
 285: 0000: !Get a four byte integer from a string offset
 286: 0000: FUNCTION GETN4 (S$, P%) EXTERNAL
 287: 0000:     STRING S$
 288: 0000:     INTEGER*2 P%
 289: 0000:     INTEGER*4 GETN4
 290: 0000: END FUNCTION
 291: 0000: 
 292: 0000: !Get a 10 byte CBASIC real from a string offset
 293: 0000: FUNCTION GETR10 (S$, P%) EXTERNAL
 294: 0000:     STRING S$
 295: 0000:     INTEGER*2 P%
 296: 0000:     REAL GETR10
 297: 0000: END FUNCTION
 298: 0000: 
 299: 0000: !Put a single byte integer into a string at offset
 300: 0000: FUNCTION PUTN1 (S$, P%, N%) EXTERNAL
 301: 0000:     STRING S$
 302: 0000:     INTEGER*2 P%
 303: 0000:     INTEGER*1 N%
 304: 0000:     INTEGER*1 PUTN1
 305: 0000: END FUNCTION
 306: 0000: 
 307: 0000: !Put a two byte integer into a string at offset
 308: 0000: FUNCTION PUTN2 (S$, P%, N%) EXTERNAL
 309: 0000:     STRING S$
 310: 0000:     INTEGER*2 P%
 311: 0000:     INTEGER*2 N%
 312: 0000:     INTEGER*1 PUTN2
 313: 0000: END FUNCTION
 314: 0000: 
 315: 0000: !Put a four byte integer into a string at offset
 316: 0000: FUNCTION PUTN4 (S$, P%, N%) EXTERNAL
 317: 0000:     STRING S$
 318: 0000:     INTEGER*2 P%
 319: 0000:     INTEGER*4 N%
 320: 0000:     INTEGER*1 PUTN4
 321: 0000: END FUNCTION
 322: 0000: 
 323: 0000: !Put a 10 byte CBASIC real into a string at offset
 324: 0000: FUNCTION PUTR10 (S$, P%, R) EXTERNAL
 325: 0000:     STRING S$
 326: 0000:     INTEGER*2 P%
 327: 0000:     REAL R
 328: 0000:     INTEGER*1 PUTR10
 329: 0000: END FUNCTION
 330: 0000: 
 331: 0000: !Peek a two byte integer from a memory address
 332: 0000: FUNCTION PEEKN2 (A%) EXTERNAL
 333: 0000:     INTEGER*4 A%
 334: 0000:     INTEGER*2 PEEKN2
 335: 0000: END FUNCTION
 336: 0000: 
 337: 0000: !Peek a four byte integer from a memory address
 338: 0000: FUNCTION PEEKN4 (A%) EXTERNAL
 339: 0000:     INTEGER*4 A%
 340: 0000:     INTEGER*4 PEEKN4
 341: 0000: END FUNCTION
 342: 0000: 
 343: 0000: !Peek a 10 byte CBASIC real from a memory address
 344: 0000: FUNCTION PEEKR10 (A%) EXTERNAL
 345: 0000:     INTEGER*4 A%
 346: 0000:     REAL PEEKR10
 347: 0000: END FUNCTION
 348: 0000: 
 349: 0000: !Poke a two byte integer to a memory address
 350: 0000: FUNCTION POKEN2 (A%, N%) EXTERNAL
 351: 0000:     INTEGER*4 A%
 352: 0000:     INTEGER*2 N%
 353: 0000:     INTEGER*1 POKEN2
 354: 0000: END FUNCTION
 355: 0000: 
 356: 0000: !Poke a four byte integer to a memory address
 357: 0000: FUNCTION POKEN4 (A%, N%) EXTERNAL
 358: 0000:     INTEGER*4 A%
 359: 0000:     INTEGER*4 N%
 360: 0000:     INTEGER*1 POKEN4
 361: 0000: END FUNCTION
 362: 0000: 
 363: 0000: !Poke a 10 byte CBASIC real to a memory address
 364: 0000: FUNCTION POKER10 (A%, R) EXTERNAL
 365: 0000:     INTEGER*4 A%
 366: 0000:     REAL R
 367: 0000:     INTEGER*1 POKER10
 368: 0000: END FUNCTION
 369: 0000: 
 370: 0000: %INCLUDE STREXT.J86
 371: 0000: \*******************************************************************************
 372: 0000: \*******************************************************************************
 373: 0000: \***
 374: 0000: \***    REFERENCE   :   STREXT
 375: 0000: \***
 376: 0000: \*******************************************************************************
 377: 0000: \***
 378: 0000: \***    OVERVIEW:
 379: 0000: \***
 380: 0000: \***    This module contains common external function and subprogram
 381: 0000: \***    definitions used for string processing.
 382: 0000: \***
 383: 0000: \***    CONTENTS:
 384: 0000: \***
 385: 0000: \***    RTRIM$ - Removes the specified trailing character from a string
 386: 0000: \***    LTRIM$ - Removes the specified leading character from a string
 387: 0000: \***    TRIM$  - Removes the specified leading and trailing character
 388: 0000: \***             from a string
 389: 0000: \***
 390: 0000: \*******************************************************************************
 391: 0000: \***
 392: 0000: \***    MODIFICATIONS:
 393: 0000: \***
 394: 0000: \***    Version A.              Mark Walker                     24th Jul 2015
 395: 0000: \***    Initial version.
 396: 0000: \***
 397: 0000: \***    Version B.              Mark Walker                     24th Nov 2016
 398: 0000: \***    Added TRIM$ function.
 399: 0000: \***
 400: 0000: \*******************************************************************************
 401: 0000: \*******************************************************************************
 402: 0000: 
 403: 0000: FUNCTION RTRIM$(SOURCE$,TRIM.CHAR$) EXTERNAL
 404: 0000:     STRING    TRIM.CHAR$
 405: 0000:     STRING    SOURCE$
 406: 0000:     STRING    RTRIM$
 407: 0000: END FUNCTION
 408: 0000: 
 409: 0000: FUNCTION LTRIM$(SOURCE$,TRIM.CHAR$) EXTERNAL
 410: 0000:     STRING    TRIM.CHAR$
 411: 0000:     STRING    SOURCE$
 412: 0000:     STRING    LTRIM$
 413: 0000: END FUNCTION
 414: 0000: 
 415: 0000: FUNCTION TRIM$(SOURCE$,TRIM.CHAR$) EXTERNAL                             !BMW
 416: 0000:     STRING    TRIM.CHAR$                                                !BMW
 417: 0000:     STRING    SOURCE$                                                   !BMW
 418: 0000:     STRING    TRIM$                                                     !BMW
 419: 0000: END FUNCTION                                                            !BMW
 420: 0000: 
 421: 0000: %INCLUDE BASROUT.J86    ! OSSHELL function
 422: 0000: \*LIB   BVEJ BASROUT  J86      03/11/97 08:16:26 PIDBLD3  *    FIX
 423: 0000: \*PROM  BVEJ BASROUT  J86      03/10/97 17:18:40 PIDBLD3  MVEJ IR34352
 424: 0000: \*RTIME BVEJ BASROUT  J86      03/10/97 17:18:41 PIDBLD3  MVEJ IR34352
 425: 0000: \*LIB   MVEJ BASROUT  J86      03/05/97 10:48:46 EDJRAL   *    IR34352
 426: 0000: \*LIB   MVEJ BASROUT  J86      02/17/97 11:19:56 EDJRAL   *    REASONAR
 427: 0000: \*LIB   MVEJ BASROUT  J86      02/14/97 15:59:11 EDJRAL   *    REASONAR
 428: 0000: ! BASROUT.J86 - this file is to be included in any BASIC code which utilizes
 429: 0000: !   the BASROUT.OBJ routines.  These routines were written
 430: 0000: !  using Metaware C and are intended to provide functions which
 431: 0000: !         are either not available in 4680 CBASIC or which can be more
 432: 0000: !               efficiently handled by the C language.  Their usage is
 433: 0000: !  offered on an "AT YOUR OWN RISK" basis.
 434: 0000: !
 435: 0000: !               The insert/extract routines usefulness may not be immediately
 436: 0000: !               apparent.  Their intention is that they be used in conjunction
 437: 0000: !               with a read/write form command.  They can more efficiently
 438: 0000: !               parse a string into many different variables than can the
 439: 0000: !               read form statement.  So instead of a long list of data var's
 440: 0000: !               it may be more efficient to just read/write one long string
 441: 0000: !               and then use the insert/extract routines to parse out the
 442: 0000: !   data.
 443: 0000: 
 444: 0000: ! ******************* SUB PROCESS FUNCTIONS *********************************
 445: 0000: 
 446: 0000: function osshell(cmd.line$) external   ! routine to start
 447: 0000:        ! another program.
 448: 0000:            integer*4    osshell    ! Upon completion of
 449: 0000:            string       cmd.line$   ! program, control is
 450: 0000:        ! returned to calling
 451: 0000: end function      ! program.
 452: 0000: !
 453: 0000: ! NOTES:  Program must be a 286 type file.  This does not exclude
 454: 0000: !         the capability to execute a batch file however.  Simply pass the
 455: 0000: !         following:
 456: 0000: !              c:\adx_spgm\command.286 batfile
 457: 0000: !         where batfile is the name of the batch file to be executed.
 458: 0000: !
 459: 0000: ! IMPORTANT: When using osshell to execute a batch file as described above,
 460: 0000: !            the final command in the batch file must be "exit".  If not,
 461: 0000: !       control is never given back to the calling program.
 462: 0000: 
 463: 0000: ! ************************ MEMORY RELATED FUNCTIONS ************************
 464: 0000: 
 465: 0000: function memfree(choice) external   ! routine to que the
 466: 0000:        ! status of the
 467: 0000:  integer*4 memfree    ! machine's memory:
 468: 0000:  integer*2 choice    ! Options:
 469: 0000:        !    1 - free
 470: 0000: end function      !    2 - total
 471: 0000:        !    3 - system
 472: 0000: 
 473: 0000: ! ********************** TIMEDATE RELATED FUNCTIONS ************************
 474: 0000: 
 475: 0000: function timedate(choice) external   ! routine to que the
 476: 0000:        ! OS's timedate table
 477: 0000:  integer*4 timedate   ! Choices:
 478: 0000:  integer*2 choice    !    1 - millisec's
 479: 0000:        !        since midnight
 480: 0000: end function      !    2 - minutes from
 481: 0000:        !  UCT (timezone)
 482: 0000:        !    3 - day of week
 483: 0000:        !   0-Sunday
 484: 0000:        !  6-Saturday
 485: 0000: 
 486: 0000: function settime(msecs) external   ! routine to set the
 487: 0000:        ! time on the controller
 488: 0000:  integer*4  settime    ! msecs is the desired
 489: 0000:  integer*4 msecs    ! number of milliseconds
 490: 0000:        ! since midnight
 491: 0000: end function      ! Returns negative on
 492: 0000:        ! error
 493: 0000: ! NOTE:  This routine sets the time only on the controller.  The terminals'
 494: 0000: ! time will not be updated until 1 AM or unless a terminal is STC'd.
 495: 0000: ! At 1 AM the controller broadcasts the new time to all terminals.
 496: 0000: ! Insure this is taken into consideration when using this routine.
 497: 0000: 
 498: 0000: !******************** DISK FILE RELATED FUNCTIONS *************************
 499: 0000: 
 500: 0000: function truncate(name,length) external   ! routine to truncate
 501: 0000:        ! the specified file
 502: 0000:  integer*4 truncate   ! to a given length.
 503: 0000:  string  name
 504: 0000:  integer*4 length
 505: 0000: 
 506: 0000: end function
 507: 0000: 
 508: 0000: !******************** STRING VALUE RELATED FUNCTIONS **********************
 509: 0000: 
 510: 0000: function isalpha(bstrn) external   ! routine to identify
 511: 0000:        ! if the specified
 512: 0000:  integer*1 isalpha    ! string contains all
 513: 0000:  string  bstrn    ! alphabetic char's
 514: 0000:        ! Returns:
 515: 0000: end function      !     0 - all alpha
 516: 0000:        !     X - byte of 1st
 517: 0000:        !         non-alpha
 518: 0000:        !   char
 519: 0000: 
 520: 0000: function isdigit(bstrn) external   ! routine to identify
 521: 0000:        ! if the specified
 522: 0000:  integer*1 isdigit    ! string contains all
 523: 0000:  string  bstrn    ! numeric char's
 524: 0000:        ! Returns:
 525: 0000: end function      !     0 - all numeric
 526: 0000:        !     X - byte of 1st
 527: 0000:        !         non-numeric
 528: 0000:        !   char
 529: 0000: 
 530: 0000: function islower(bstrn) external   ! routine to identify
 531: 0000:        ! if the specified
 532: 0000:  integer*1 islower    ! string contains all
 533: 0000:  string  bstrn    ! lower case char's
 534: 0000:        ! Returns:
 535: 0000: end function      !     0 - all lowercase
 536: 0000:        !     X - byte of 1st
 537: 0000:        !         non-lowercase
 538: 0000:        !   char
 539: 0000: 
 540: 0000: function isupper(bstrn) external   ! routine to identify
 541: 0000:        ! if the specified
 542: 0000:  integer*1 isupper    ! string contains all
 543: 0000:  string  bstrn    ! upper case char's
 544: 0000:        ! Returns:
 545: 0000: end function      !     0 - all uppercase
 546: 0000:        !     X - byte of 1st
 547: 0000:        !         non-uppercase
 548: 0000:        !   char
 549: 0000: 
 550: 0000: function toalpha(bstrn) external   ! routine to convert
 551: 0000:        ! non-alpha or non-num
 552: 0000:    integer*2 toalpha    ! char's to spaces
 553: 0000:  string  bstrn    ! Returns:
 554: 0000: end function      !   x - no. of char's
 555: 0000:        !       changed
 556: 0000: 
 557: 0000: ! ********************* USER/GROUP ZERO LEVEL FUNCTIONS *********************
 558: 0000: 
 559: 0000: function idlecount(choice) external   ! routine to either
 560: 0000:        ! set to zero or queue
 561: 0000:  integer*4 idlecount   ! the value of the
 562: 0000:  integer*1 choice    ! processor's idlecount
 563: 0000:        ! Choice:
 564: 0000: end function      !     0 - set to zero
 565: 0000: !       !     1 - get value
 566: 0000: ! NEEDS USER/GROUP 0 LEVEL OF AUTHORIZATION  ! Returns:
 567: 0000: ! TO WORK - This level is not available unless  !     X - idlecount
 568: 0000: ! the file ADXCSOUF.DAT file is "patched".  This !    -X - error code
 569: 0000: ! is highly unrecommended.
 570: 0000: 
 571: 0000: function logical(actname,logname,choice) external ! routine to set a
 572: 0000:        ! a logical name.
 573: 0000:  integer*4 logical    ! parms are self
 574: 0000:         string  logname    ! explanatory except
 575: 0000:  string  actname    ! for choice:
 576: 0000:  integer*1 choice    !   0 - set process
 577: 0000:        !   1 - set system
 578: 0000: end function      !   2 - get process
 579: 0000:        !   3 - get system
 580: 0000: 
 581: 0000: ! NOTE:  Only the setting of a system level of logical name requires
 582: 0000: ! user/group zero level of authorization.  Any application may query any
 583: 0000: ! logical name.  Setting of a system logical name is only applicable until
 584: 0000: ! the system is IPL'd.  A process logical name is only active when that
 585: 0000: ! process is active.
 586: 0000: 
 587: 0000: !******************** STRING PARSING FUNCTIONS *****************************
 588: 0000: 
 589: 0000: function inserts(whole,part,offset) external  ! routine to insert a
 590: 0000:        ! string (part) into
 591: 0000:  integer*2 INSERTS    ! another string (whole)
 592: 0000:  string  whole    ! starting at specified
 593: 0000:  string  part    ! character (offset)
 594: 0000:  integer*2 offset
 595: 0000: 
 596: 0000: end function
 597: 0000: 
 598: 0000: function cinsert4(integer4,bstring,offset) external   ! routine to insert
 599: 0000:        ! a 4-byte integer into
 600: 0000:  integer*1 cinsert4   ! a string starting at
 601: 0000:  integer*4 integer4   ! byte specified by
 602: 0000:  string  bstring    ! offset (1-based)
 603: 0000:  integer*2 offset    ! Returns:
 604: 0000:        !     0 - Success
 605: 0000: end function      !    -1 - String overrun
 606: 0000: 
 607: 0000: function cinsert2(integer2,bstring,offset) external  ! routine to insert
 608: 0000:        ! a 2-byte integer into
 609: 0000:  integer*1 cinsert2   ! a string starting at
 610: 0000:  integer*2 integer2   ! byte specified by
 611: 0000:  string  bstring    ! offset (1-based)
 612: 0000:  integer*2 offset    ! Returns:
 613: 0000:        !     0 - Success
 614: 0000: end function      !    -1 - String overrun
 615: 0000: 
 616: 0000: function cinsert1(bstring,integer1,offset) external  ! routine to insert
 617: 0000:        ! a 1-byte integer into
 618: 0000:  integer*1 cinsert1   ! a string starting at
 619: 0000:  integer*1 integer1   ! byte specified by
 620: 0000:  string  bstring    ! offset (1-based)
 621: 0000:  integer*2 offset    ! Returns:
 622: 0000:        !     0 - Success
 623: 0000: end function      !    -1 - String overrun
 624: 0000: 
 625: 0000: function extracts(whole,part,offset) external  ! routine to extract a
 626: 0000:        ! string (part) from
 627: 0000:  integer*2 EXTRACTS   ! another string (whole)
 628: 0000:  string  whole    ! starting at specified
 629: 0000:  string  part    ! character (offset)
 630: 0000:  integer*2 offset
 631: 0000: 
 632: 0000: end function
 633: 0000: 
 634: 0000: function cextract4(bstring,offset) external  ! routine to extract
 635: 0000:        ! a 4-byte integer from
 636: 0000:  integer*4 cextract4   ! a string starting at
 637: 0000:                        ! byte specified by
 638: 0000:  string  bstring    ! offset (1-based)
 639: 0000:  integer*2 offset    ! Returns:
 640: 0000:        !     X - 4 byte integer
 641: 0000: end function      !    -1 - String overrun
 642: 0000: 
 643: 0000: function cextract2(bstring,offset) external  ! routine to extract
 644: 0000:        ! a 2-byte integer from
 645: 0000:  integer*2 cextract2   ! a string starting at
 646: 0000:                        ! byte specified by
 647: 0000:  string  bstring    ! offset (1-based)
 648: 0000:  integer*2 offset    ! Returns:
 649: 0000:        !     X - 2 byte integer
 650: 0000: end function      !    -1 - String overrun
 651: 0000: 
 652: 0000: function cextract1(bstring,offset) external  ! routine to extract
 653: 0000:        ! a 1-byte integer from
 654: 0000:  integer*1 cextract1   ! a string starting at
 655: 0000:                        ! byte specified by
 656: 0000:  string  bstring    ! offset (1-based)
 657: 0000:  integer*2 offset    ! Returns:
 658: 0000:        !     X - 1 byte integer
 659: 0000: end function      !    -1 - String overrun
 660: 0000: 
 661: 0000: 
 662: 0000: function srchdir (file.name$,dtbl.buffer$) external ! routine to return
 663: 0000:        ! file names and sizes
 664: 0000:        ! Return values:
 665: 0000:        !    -1  no matches
 666: 0000:        !        found on first
 667: 0000:        !        call
 668: 0000:        !    0   no matches
 669: 0000:        !        found on sub-
 670: 0000:        !        sequent calls
 671: 0000:        !    Pos Success
 672: 0000:        !    Neg OS Rtn Code
 673: 0000: ! Usage Note:  If searching for all occurences of a particular file name,
 674: 0000: ! first initialize dtbl.buffer$ to 48 Nulls (pack$("00")) and issue a call
 675: 0000: ! to srchdir.  If any matches are found, a positive value will be returned.
 676: 0000: ! To see if any more matches exist, just issue another call to srchdir without
 677: 0000: ! resetting the values of dtbl.buffer$.  If any are found, a positive value
 678: 0000: ! will be returned.  This can be repeated until a Zero is returned.  All data
 679: 0000: ! describing file will be returned in the dtbl.buffer$ after each call.  Format
 680: 0000: ! of this data is defined below.
 681: 0000: 
 682: 0000:  integer*4 srchdir
 683: 0000: 
 684: 0000:  string  file.name$   ! file name to start
 685: 0000:        ! search (18 bytes max)
 686: 0000:        ! Wild cards and logical
 687: 0000:        ! names supported.
 688: 0000: 
 689: 0000:  string  dtbl.buffer$   ! must be initialized
 690: 0000:        ! to 48 bytes.  Contains
 691: 0000:        ! all of directory info
 692: 0000:        ! Initialize to nulls
 693: 0000:        ! each time a new file
 694: 0000:        ! name is used.
 695: 0000: 
 696: 0000: ! NOTE:  Format of dtbl.buffer$ string is as follows:
 697: 0000: !
 698: 0000: ! Offs  Type                    Description Notes
 699: 0000: !  0 integer*4  key  use extract4 to access
 700: 0000: !  4  string (18 bytes) file name
 701: 0000: ! 22 integer*2  attributes use extract2 to access
 702: 0000: !      0x01 - Read Only
 703: 0000: !      0x02 - Hidden
 704: 0000: !      0x04 - System
 705: 0000: !      0x08 - Volume Label
 706: 0000: !      0x10 - Subdirectory
 707: 0000: !      0x20 - Archive (Files)
 708: 0000: !      0x40 - Security enabled
 709: 0000: !      0x80 - Reserved
 710: 0000: !      0x0000 - Local
 711: 0000: !      0x4000 - Mirrored/Update
 712: 0000: !      0xC000 - Mirrored/Close
 713: 0000: !
 714: 0000: !      0x6000 - Compound/Update
 715: 0000: !      0xE000 - Compound/Close
 716: 0000: ! 24 integer*2  record size use extract2 to access
 717: 0000: ! 26 integer*1  User ID of Owner
 718: 0000: ! 27 integer*1  Group ID of Owner
 719: 0000: ! 28 integer*2  File Security
 720: 0000: ! 30 string (6 bytes) Reserved
 721: 0000: ! 36 integer*4  File Size use extract4 to access
 722: 0000: ! 40 integer*2  Year  use extract2 to access
 723: 0000: ! 42 integer*1  Month
 724: 0000: ! 43 integer*1  Day
 725: 0000: ! 44 integer*1  Hour
 726: 0000: ! 45 integer*1  Minute
 727: 0000: ! 46 integer*1  Second
 728: 0000: ! 47 integer*1  Reserved
 729: 0000: 
 730: 0000: end function
 731: 0000: 
 732: 0000: function srchproc (proc.name$,ptbl.buffer$) external ! routine to return
 733: 0000:        ! process names and
 734: 0000:        ! status.  Handy to
 735: 0000:        ! determine if a
 736: 0000:        ! program is currently
 737: 0000:        ! running.
 738: 0000:        ! Return values:
 739: 0000:        !    -1  no matches
 740: 0000:        !        found on first
 741: 0000:        !        call
 742: 0000:        !    0   no matches
 743: 0000:        !        found on sub-
 744: 0000:        !        sequent calls
 745: 0000:        !    Pos Success
 746: 0000:        !    Neg Failure
 747: 0000:        !        OS Rtn Code
 748: 0000:        ! 80000001h - Insuff
 749: 0000:         !        ptbl buffer
 750: 0000:        !        Length
 751: 0000: ! Usage Note:  If searching for all occurences of a particular process name,
 752: 0000: ! first initialize ptbl.buffer$ to 60 Nulls (pack$("00")) and issue a call
 753: 0000: ! to srchproc.  If any matches are found, a positive value will be returned.
 754: 0000: ! To see if any more matches exist, just issue another call to srchproc without
 755: 0000: ! resetting the values of ptbl.buffer$.  If any are found, a positive value
 756: 0000: ! will be returned.  This can be repeated until a Zero is returned.  All data
 757: 0000: ! describing file will be returned in the ptbl.buffer$ after each call.  Format
 758: 0000: ! of this data is defined as follows:
 759: 0000: !
 760: 0000: !       --------------------------------------------------------
 761: 0000: !   0   |                         PID                          |
 762: 0000: !       --------------------------------------------------------
 763: 0000: !   4   |           FID             |   CID        |   VCID    |
 764: 0000: !       --------------------------------------------------------
 765: 0000: !   8   |                         NAME                         |
 766: 0000: !       --------------------------------------------------------
 767: 0000: !  12   |                         NAME cont'd                  |
 768: 0000: !       --------------------------------------------------------
 769: 0000: !  16   |       NAME cont'd         |   STATE      |  PRIOR    |
 770: 0000: !       --------------------------------------------------------
 771: 0000: !  20   |                         MAXMEM                       |
 772: 0000: !       --------------------------------------------------------
 773: 0000: !  24   |       FLAGS               |   USER        |  GROUP   |
 774: 0000: !       --------------------------------------------------------
 775: 0000: !  28   |                         PARENT                       |
 776: 0000: !       --------------------------------------------------------
 777: 0000: !  32   |                         EVENTS                       |
 778: 0000: !       --------------------------------------------------------
 779: 0000: !  36   |                         CODE                         |
 780: 0000: !       --------------------------------------------------------
 781: 0000: !  40   |                         CSIZE                        |
 782: 0000: !       --------------------------------------------------------
 783: 0000: !  44   |                         DATA                         |
 784: 0000: !       --------------------------------------------------------
 785: 0000: !  48   |                         DSIZE                        |
 786: 0000: !       --------------------------------------------------------
 787: 0000: !  52   |                         HEAP                         |
 788: 0000: !       --------------------------------------------------------
 789: 0000: !  56   |                         HSIZE                        |
 790: 0000: !       --------------------------------------------------------
 791: 0000: !
 792: 0000: !       PID   Process ID
 793: 0000: !       FID  Process's Family ID
 794: 0000: !       CID   Physical Console Device Number
 795: 0000: !       VCID  Process's Virtual Console Number
 796: 0000: !       NAME  Process Name (Application Running)
 797: 0000: ! STATE    Process State (0-Run, 1-Waiting, 2-Terminating)
 798: 0000: ! PRIOR    Priority
 799: 0000: !       MAXMEM  Maximum Memory Allowed
 800: 0000: !       FLAGS  Bit 0 (1-System Process, 0-User Process)
 801: 0000: !   Bit 1 (1-Locked in Memory, 0-Swappable)
 802: 0000: !   Bit 2 (1-Running in SWI context, 0-Running in main context)
 803: 0000: !   Bit 3 (1-Superuser Process,0-Not a Superuser Process)
 804: 0000: ! USER  User Number
 805: 0000: ! GROUP  Group Number
 806: 0000: !       PARENT   Parent Process ID
 807: 0000: !       EVENTS   Bit Map of events that have completed but not retrieved
 808: 0000: !       CODE  Start of code area in user space
 809: 0000: ! CSIZE  Size in bytes of code area
 810: 0000: !       DATA  Start of data area in user space
 811: 0000: ! DSIZE  Size in bytes of data area
 812: 0000: !       HEAP  Start of heap area in user space
 813: 0000: ! HSIZE  Size in bytes of heap area
 814: 0000: !
 815: 0000:  integer*4 srchproc
 816: 0000: 
 817: 0000:  string  proc.name$   ! process name to start
 818: 0000:        ! search (10 bytes max)
 819: 0000:        ! Wild cards and logical
 820: 0000:        ! names supported.
 821: 0000: 
 822: 0000:  string  ptbl.buffer$   ! must be initialized
 823: 0000:        ! to 60 bytes.  Contains
 824: 0000:        ! all of process info
 825: 0000:        ! Initialize to nulls
 826: 0000:        ! each time a new
 827: 0000:        ! process name is used.
 828: 0000: 
 829: 0000: end function
 830: 0000: 
 831: 0000: function cconstat(timeout) external       ! function similar
 832: 0000:                                               ! to BASIC constat%
 833: 0000:  integer*2 cconstat   ! waits for either a
 834: 0000:  integer*4 timeout    ! key being hit or
 835: 0000:        ! the timer expiring
 836: 0000:        ! before returning
 837: 0000:        ! returns:
 838: 0000:        !   -1 error
 839: 0000:        !    0 timer expired
 840: 0000:        !    x scan code of
 841: 0000:        !      key hit
 842: 0000: end function
 843: 0000: 
 844: 0000: function disksize(disk.name$) external   ! function to find
 845: 0000:        ! the total size of
 846: 0000:  integer*4 disksize   ! the specified disk
 847: 0000:  string  disk.name$   ! name (e.g. "h0:")
 848: 0000:        ! if return value is
 849: 0000:        ! negative, error
 850: 0000: end function      ! was received
 851: 0000: 
 852: 0000: 
 853: 0000: %INCLUDE BTCSTR.J86     ! String functions
 854: 0000: !********************************************************************
 855: 0000: !***
 856: 0000: !***    INCLUDED CODE:  BTCSTR.J86
 857: 0000: !***    AUTHOR:         Stuart William McConnachie
 858: 0000: !***    DATE:           26th February 2006
 859: 0000: !***
 860: 0000: !********************************************************************
 861: 0000: !***
 862: 0000: !***    Controller CBASIC String Functions
 863: 0000: !***
 864: 0000: !********************************************************************
 865: 0000: 
 866: 0000: !Swaps to CBASIC strings
 867: 0000: SUB SWAPSTR (S1$, S2$) EXTERNAL
 868: 0000:     STRING S1$, S2$
 869: 0000: END SUB
 870: 0000: 
 871: 0000: !Left trim a string of spaces
 872: 0000: SUB LTRIM (S$) EXTERNAL
 873: 0000:     STRING S$
 874: 0000: END SUB
 875: 0000: 
 876: 0000: !Right trim a string of spaces
 877: 0000: SUB RTRIM (S$) EXTERNAL
 878: 0000:     STRING S$
 879: 0000: END SUB
 880: 0000: 
 881: 0000: !Left and right trim a string of spaces
 882: 0000: SUB TRIM (S$) EXTERNAL
 883: 0000:     STRING S$
 884: 0000: END SUB
 885: 0000: 
 886: 0000: !Left trim a string of a given ASCII character
 887: 0000: SUB LTRIMC (S$, C%) EXTERNAL
 888: 0000:     STRING S$
 889: 0000:     INTEGER*1 C%
 890: 0000: END SUB
 891: 0000: 
 892: 0000: !Right trim a string of a given ASCII character
 893: 0000: SUB RTRIMC (S$, C%) EXTERNAL
 894: 0000:     STRING S$
 895: 0000:     INTEGER*1 C%
 896: 0000: END SUB
 897: 0000: 
 898: 0000: !Left and right trim a string of a given ASCII character
 899: 0000: SUB TRIMC (S$, C%) EXTERNAL
 900: 0000:     STRING S$
 901: 0000:     INTEGER*1 C%
 902: 0000: END SUB
 903: 0000: 
 904: 0000: !Insert one string into another
 905: 0000: FUNCTION SUBSTR(S1$, O1%, S2$, O2%, L2%) EXTERNAL
 906: 0000:     STRING    S1$, S2$
 907: 0000:     INTEGER*2 O1%, O2%, L2%
 908: 0000:     INTEGER*1 SUBSTR
 909: 0000: END FUNCTION
 910: 0000:     
 911: 0000: !%INCLUDE ERRNH.J86     ! ERRN function                                 !BMW
 912: 0000: 
 913: 0000: FUNCTION ASC.TEXT$(A$) EXTERNAL
 914: 0000: STRING ASC.TEXT$,A$
 915: 0000: END FUNCTION
 916: 0000: 
 917: 0000: FUNCTION HEX.TEXT$(H$) EXTERNAL
 918: 0000: STRING HEX.TEXT$,H$
 919: 0000: END FUNCTION
 920: 0000: 
 921: 0000: FUNCTION SUBSTITUTE$(T$,P$,R$) EXTERNAL
 922: 0000: STRING SUBSTITUTE$,T$,P$,R$
 923: 0000: END FUNCTION
 924: 0000: 
 925: 0000: SUB PSU0406 EXTERNAL
 926: 0000: END SUB
 927: 0000: 
 928: 0000: \***********************************************************************
 929: 0000: \***********************************************************************
 930: 0000: \***
 931: 0000: \***    MAIN SUBPROGRAM PSU0403
 932: 0000: \***
 933: 0000: \***********************************************************************
 934: 0000: \***********************************************************************
 935: 0000: SUB PSU0403 PUBLIC
 936: 0024: 
 937: 0024:     COMMENT$ = "No additional comment available."
 938: 003b: 
 939: 003b:     PROGRAM$ = RTRIM$(PROGRAM$," ")
 940: 0062: 
 941: 0062:     RETURN.CODE$ = ""
 942: 0079:     RETURN.ERR$ = ""
 943: 0090: 
 944: 0090:     IF EVENT.MESSAGE.NUMBER% = 0 THEN BEGIN
 945: 00a2:         MESSAGE.TEXT$ = "No message text found"
 946: 00bc:     ENDIF ELSE IF EVENT.MESSAGE.GROUP$ = "A" THEN BEGIN
 947: 00da:         MESSAGE.TEXT$ = LA$(EVENT.MESSAGE.NUMBER%)
 948: 010b:     ENDIF ELSE IF EVENT.MESSAGE.GROUP$ = "J" THEN BEGIN
 949: 0129:         MESSAGE.TEXT$ = LJ$(EVENT.MESSAGE.NUMBER%)
 950: 0158:     ENDIF
 951: 0160: 
 952: 0160:     IF EVENT.NUMBER% = 1 THEN BEGIN
 953: 0175: !-------------------------------------------------------------------------------
 954: 0175: !  1          EALDMMLL TIF build            File name         X(3)  ASCII
 955: 0175: !                                           Equals symbol     X     ASCII
 956: 0175: !                                           Record Count      X(6)  ASCII
 957: 0175: !-------------------------------------------------------------------------------
 958: 0175:         IF PROGRAM$ = "EALDMMLL" THEN BEGIN
 959: 0196: 
 960: 0196:             IF LEFT$(EVENT.UNIQUE.DATA$,3) = "TIF" THEN BEGIN
 961: 01cb: 
 962: 01cb:                 COUNT$ = RTRIM$(MID$(EVENT.UNIQUE.DATA$,5,6)," ")
 963: 0204: 
 964: 0204:                 COMMENT$ = "TIF rebuild completed successfully. " + \
 965: 022a:                            COUNT$ + " records added."
 966: 022a:             ENDIF
 967: 0232: 
 968: 0232:         ENDIF
 969: 023d: 
 970: 023d:     ENDIF ELSE IF EVENT.NUMBER% = 2 THEN BEGIN
 971: 0252: !-------------------------------------------------------------------------------
 972: 0252: !  2          General Error                 Module Number     XX    ASCII
 973: 0252: !                                           Session Number    XX    UPD
 974: 0252: !                                           ERR               XX    ASCII
 975: 0252: !                                           ERRN              X(4)  HEX
 976: 0252: !             OR 
 977: 0252: !             Store Close status            Close message     X(10) ASCII!
 978: 0252: !             OR 
 979: 0252: !             Cut-off status                Cut-off message   X(10) ASCII!
 980: 0252: !             OR 
 981: 0252: !             Critical error message        Stop message      X(10) ASCII
 982: 0252: !
 983: 0252: !-------------------------------------------------------------------------------
 984: 0252:         IF EVENT.UNIQUE.DATA$ = "STORECLOSE" THEN BEGIN
 985: 0270: 
 986: 0270:             COMMENT$ = "Sales Support has started " +               \
 987: 0291:                        "store close processing."
 988: 0291: 
 989: 0291:         ENDIF ELSE IF EVENT.UNIQUE.DATA$ = "EOD START " THEN BEGIN
 990: 02af: 
 991: 02af:             COMMENT$ = "Sales Support has started " +               \
 992: 02d0:                        "end-of-day cutoff processing."
 993: 02d0: 
 994: 02d0:         ENDIF ELSE IF EVENT.UNIQUE.DATA$ = "EOD END   " THEN BEGIN
 995: 02ee: 
 996: 02ee:             COMMENT$ = "Sales Support has completed " +             \
 997: 030f:                        "end-of-day cutoff processing."
 998: 030f: 
 999: 030f:         ENDIF ELSE IF EVENT.UNIQUE.DATA$ = "STOP--STOP" THEN BEGIN
1000: 032d: 
1001: 032d:             COMMENT$ = "Sales Support has encountered an " +        \
1002: 034e:                        "unrecoverable error."
1003: 034e: 
1004: 034e:         ENDIF ELSE BEGIN
1005: 0356: 
1006: 0356:             MODULE$ = LEFT$(EVENT.UNIQUE.DATA$,2)
1007: 037b: 
1008: 037b:             RETURN.CODE$ =                                          \
1009: 03aa:                 HEX.TEXT$(UNPACK$(RIGHT$(EVENT.UNIQUE.DATA$,4)))
1010: 03aa: 
1011: 03aa:             SESS.NUM% = VAL(MID$(EVENT.UNIQUE.DATA$,3,2))
1012: 03d3: 
1013: 03d3:             RETURN.ERR$ = MID$(EVENT.UNIQUE.DATA$,5,2)
1014: 03fa: 
1015: 03fa:             CODE.TEXT$ = "Error code is " + RETURN.ERR$ + ". " +    \
1016: 0434:                          "Error number is " + RETURN.CODE$ + ". "
1017: 0434: 
1018: 0434:             IF SESS.NUM% <> 0 THEN BEGIN
1019: 0446:                 SESS.TEXT$ = "File session number is " +            \
1020: 0469:                     STR$(SESS.NUM%)
1021: 0469: 
1022: 0469:                 IF LEN(SS$(SESS.NUM%)) > 0 THEN BEGIN
1023: 0495:                     SESS.TEXT$ = SESS.TEXT$ +                       \
1024: 04d4:                         " (" + SS$(SESS.NUM%) + "). "
1025: 04d4:                 ENDIF ELSE BEGIN
1026: 04dc:                     SESS.TEXT$ = SESS.TEXT$ + "."
1027: 04fc:                 ENDIF
1028: 0506: 
1029: 0506:             ENDIF ELSE BEGIN
1030: 050e:                 SESS.TEXT$ = "No file session number was logged. "
1031: 0523:             ENDIF
1032: 052b: 
1033: 052b:             COMMENT$ = "A general error has occurred. " +           \
1034: 0555:                        CODE.TEXT$ + SESS.TEXT$
1035: 0555: 
1036: 0555:         ENDIF
1037: 0560: 
1038: 0560:     ENDIF ELSE IF EVENT.NUMBER% = 101 THEN BEGIN
1039: 0575: !-------------------------------------------------------------------------------
1040: 0575: !101          DEC Error                     Module Number     XX    ASCII
1041: 0575: !                                           Session Number    XX    UPD
1042: 0575: !                                           ERR               XX    ASCII
1043: 0575: !                                           ERRN              X(4)  HEX
1044: 0575: !-------------------------------------------------------------------------------
1045: 0575:             MODULE$ = LEFT$(EVENT.UNIQUE.DATA$,2)                       !BMW
1046: 059a:                                                                         !BMW
1047: 059a:             RETURN.CODE$ =                                          \   !BMW
1048: 05c9:                 HEX.TEXT$(UNPACK$(RIGHT$(EVENT.UNIQUE.DATA$,4)))        !BMW
1049: 05c9:                                                                         !BMW
1050: 05c9:             SESS.NUM% = VAL(MID$(EVENT.UNIQUE.DATA$,3,2))               !BMW
1051: 05f2:                                                                         !BMW
1052: 05f2:             RETURN.ERR$ = MID$(EVENT.UNIQUE.DATA$,5,2)                  !BMW
1053: 0619:                                                                         !BMW
1054: 0619:             CODE.TEXT$ = "Error code is " + RETURN.ERR$ + ". " +    \   !BMW
1055: 0653:                          "Error number is " + RETURN.CODE$ + ". "       !BMW
1056: 0653:                                                                         !BMW
1057: 0653:             IF SESS.NUM% <> 0 THEN BEGIN                                !BMW
1058: 0665:                 SESS.TEXT$ = "File session number is " +            \   !BMW
1059: 0688:                     STR$(SESS.NUM%)                                     !BMW
1060: 0688:                                                                         !BMW
1061: 0688:                 IF LEN(SS$(SESS.NUM%)) > 0 THEN BEGIN                   !BMW
1062: 06b4:                     SESS.TEXT$ = SESS.TEXT$ +                       \   !BMW
1063: 06f3:                         " (" + SS$(SESS.NUM%) + "). "                   !BMW
1064: 06f3:                 ENDIF ELSE BEGIN                                        !BMW
1065: 06fb:                     SESS.TEXT$ = SESS.TEXT$ + "."                       !BMW
1066: 071b:                 ENDIF                                                   !BMW
1067: 0725:                                                                         !BMW
1068: 0725:             ENDIF ELSE BEGIN                                            !BMW
1069: 072d:                 SESS.TEXT$ = "No file session number was logged. "      !BMW
1070: 0742:             ENDIF                                                       !BMW
1071: 074a:                                                                         !BMW
1072: 074a:             COMMENT$ = "A DEC error has occurred. " +               \   !BMW
1073: 0776:                        CODE.TEXT$ + SESS.TEXT$                          !BMW
1074: 0776:                                                                         !BMW
1075: 0776:     ENDIF ELSE IF EVENT.NUMBER% = 102 THEN BEGIN                        !BMW
1076: 0788: !-------------------------------------------------------------------------------
1077: 0788: !  2          Critical error message        Stop message      X(10) ASCII
1078: 0788: !
1079: 0788: !-------------------------------------------------------------------------------
1080: 0788:         COMMENT$ = "Sales Support has encountered an " +            \   !BMW
1081: 07a6:                    "unrecoverable DEC error."                           !BMW
1082: 07a6:     
1083: 07a6:     ENDIF
1084: 07ae: 
1085: 07ae:     ! IF multiple repeated event log entries
1086: 07ae:     IF EVENT.COUNT% > 1 THEN BEGIN
1087: 07c0: 
1088: 07c0:         COMMENT$ = COMMENT$ +                                       \
1089: 0803:                    " This event is repeated " +                     \
1090: 0803:                    STR$(EVENT.COUNT%) + " times."
1091: 0803: 
1092: 0803:     ENDIF
1093: 080b: 
1094: 080b:     ! Display event log details
1095: 080b:     CALL PSU0406
1096: 0818: 
1097: 0818: END SUB
1098: 082c: 
1099: 082c: End of Compilation
