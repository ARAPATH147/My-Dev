   1: 0000: \***********************************************************************
   2: 0000: \***********************************************************************
   3: 0000: \***
   4: 0000: \***    PROGRAM         :       PSU04
   5: 0000: \***    DESCRIPTION     :       Event log viewer utility
   6: 0000: \***    AUTHOR          :       Mark Walker
   7: 0000: \***    DATE            :       26th September 2017
   8: 0000: \***
   9: 0000: \***********************************************************************
  10: 0000: \***********************************************************************
  11: 0000: \***
  12: 0000: \***    Module 4 contains formatting of the contents of the detail
  13: 0000: \***    screen for till application events.
  14: 0000: \***
  15: 0000: \***********************************************************************
  16: 0000: \***********************************************************************
  17: 0000: \***
  18: 0000: \***    MODIFICATIONS
  19: 0000: \***
  20: 0000: \***    Version A.          Mark Walker                 26th Sep 2017
  21: 0000: \***    Initial version.
  22: 0000: \***
  23: 0000: \***    Version B.          Mark Walker                  1st Dec 2017
  24: 0000: \***    Added new terminal application event format for variable
  25: 0000: \***    denomination GCM cards.
  26: 0000: \***
  27: 0000: \***    Version C.          Mark Walker                  6th Dec 2017
  28: 0000: \***    Removed redundant ERRNH module reference.
  29: 0000: \***
  30: 0000: \***    Version D.          Mark Walker                 26th Feb 2018
  31: 0000: \***    Corrected display of TOF errors logged using event 212.
  32: 0000: \***
  33: 0000: \***********************************************************************
  34: 0000: \***********************************************************************
  35: 0000: 
  36: 0000: \***********************************************************************
  37: 0000: \***
  38: 0000: \***    Global variable declarations
  39: 0000: \***
  40: 0000: \***********************************************************************
  41: 0000: 
  42: 0000: %INCLUDE PSU04G.J86
  43: 0000: \***********************************************************************
  44: 0000: \***********************************************************************
  45: 0000: \***
  46: 0000: \***    GLOBAL VARIABLE DEFINITIONS FOR PSU04
  47: 0000: \***
  48: 0000: \***********************************************************************
  49: 0000: \***********************************************************************
  50: 0000: \***
  51: 0000: \***    MODIFICATIONS
  52: 0000: \***
  53: 0000: \***    Version A.          Mark Walker                 26th Sep 2017
  54: 0000: \***    Initial version.
  55: 0000: \***
  56: 0000: \***    Version B.          Mark Walker                  2nd Nov 2017
  57: 0000: \***    Added support for the source selection list.
  58: 0000: \***
  59: 0000: \***    Version C.          Mark Walker                  6th Nov 2017
  60: 0000: \***    Updated handling of bucket and source text descriptions.
  61: 0000: \***
  62: 0000: \***    Version D.          Mark Walker                 21st Nov 2017
  63: 0000: \***    Added support for the UTILS session screen.
  64: 0000: \***
  65: 0000: \***    Version E.          Mark Walker                  6th Dec 2017
  66: 0000: \***    Moved some local variables to globals to support moving
  67: 0000: \***    some functions from the main screen handling module to
  68: 0000: \***    an external subprogram.
  69: 0000: \***
  70: 0000: \***    Version F.          Mark Walker                 19th Mar 2017
  71: 0000: \***    Added support for reporting application events logged by
  72: 0000: \***    text file editor applications.
  73: 0000: \***
  74: 0000: \***********************************************************************
  75: 0000: \***********************************************************************
  76: 0000: 
  77: 0000:     INTEGER*1 GLOBAL CURRENT.FIELD%                                     !EMW
  78: 0000:     INTEGER*1 GLOBAL FALSE
  79: 0000:     INTEGER*1 GLOBAL OPEN.EVAPP
  80: 0000:     INTEGER*1 GLOBAL TRUE
  81: 0000:     INTEGER*1 GLOBAL U0401.APPLICATION%
  82: 0000:     INTEGER*1 GLOBAL U0401.APPLICATION.STATUS%
  83: 0000:     INTEGER*1 GLOBAL U0401.BUCKET%
  84: 0000:     INTEGER*1 GLOBAL U0401.BUCKET.STATUS%
  85: 0000:     INTEGER*1 GLOBAL U0401.CONTROLLER.ID%
  86: 0000:     INTEGER*1 GLOBAL U0401.CONTROLLER.ID.STATUS%
  87: 0000:     INTEGER*1 GLOBAL U0401.EVENT%
  88: 0000:     INTEGER*1 GLOBAL U0401.EVENT.STATUS%
  89: 0000:     INTEGER*1 GLOBAL U0401.LOG.DESC%
  90: 0000:     INTEGER*1 GLOBAL U0401.LOG.NUMBER%
  91: 0000:     INTEGER*1 GLOBAL U0401.MESSAGE.GROUP%
  92: 0000:     INTEGER*1 GLOBAL U0401.MESSAGE.GROUP.STATUS%
  93: 0000:     INTEGER*1 GLOBAL U0401.MESSAGE.NUMBER%
  94: 0000:     INTEGER*1 GLOBAL U0401.MESSAGE.NUMBER.STATUS%
  95: 0000:     INTEGER*1 GLOBAL U0401.SEVERITY%
  96: 0000:     INTEGER*1 GLOBAL U0401.SEVERITY.STATUS%
  97: 0000:     INTEGER*1 GLOBAL U0401.SOURCE%
  98: 0000:     INTEGER*1 GLOBAL U0401.SOURCE.STATUS%
  99: 0000:     INTEGER*1 GLOBAL U0401.TERMINAL%
 100: 0000:     INTEGER*1 GLOBAL U0401.TERMINAL.STATUS%
 101: 0000:     INTEGER*1 GLOBAL U0402.PAGE%
 102: 0000:     INTEGER*1 GLOBAL U0405.PAGE%
 103: 0000:     INTEGER*1 GLOBAL U0406.PAGE%
 104: 0000:     INTEGER*1 GLOBAL U0411.PAGE%                                        !BMW
 105: 0000:     INTEGER*1 GLOBAL U0412.PAGE%                                        !DMW
 106: 0000:     INTEGER*1 GLOBAL VALID.INPUT
 107: 0000:     INTEGER*1 GLOBAL VALID.KEY
 108: 0000: 
 109: 0000:     INTEGER*2 GLOBAL APPLICATIONS.PER.PAGE%
 110: 0000:     INTEGER*2 GLOBAL COMMAND.TIME.RANGE%
 111: 0000:     INTEGER*2 GLOBAL COMMANDS.PER.PAGE%
 112: 0000:     INTEGER*2 GLOBAL CURRENT.INDEX%                                     !EMW
 113: 0000:     INTEGER*2 GLOBAL CURRENT.REPORT.NUM%
 114: 0000:     INTEGER*2 GLOBAL EVENT.BUCKET%
 115: 0000:     INTEGER*2 GLOBAL EVENT.COUNT%
 116: 0000:     INTEGER*2 GLOBAL EVENT.DAY%
 117: 0000:     INTEGER*2 GLOBAL EVENT.FORMAT%
 118: 0000:     INTEGER*2 GLOBAL EVENT.HOUR%
 119: 0000:     INTEGER*2 GLOBAL EVENT.MESSAGE.NUMBER%
 120: 0000:     INTEGER*2 GLOBAL EVENT.MIN%
 121: 0000:     INTEGER*2 GLOBAL EVENT.MONTH%
 122: 0000:     INTEGER*2 GLOBAL EVENT.NODE.ID%
 123: 0000:     INTEGER*2 GLOBAL EVENT.NUMBER%
 124: 0000:     INTEGER*2 GLOBAL EVENT.SEVERITY%
 125: 0000:     INTEGER*2 GLOBAL EVENT.SOURCE%
 126: 0000:     INTEGER*2 GLOBAL EVENT.TERMINAL%
 127: 0000:     INTEGER*2 GLOBAL EVENT.YEAR%
 128: 0000:     INTEGER*2 GLOBAL FILES.PER.PAGE%
 129: 0000:     INTEGER*2 GLOBAL LINE.LENGTH%
 130: 0000:     INTEGER*2 GLOBAL MAX.FILE.RECORDS%
 131: 0000:     INTEGER*2 GLOBAL MAX.SOURCE.RECORDS%                                !BMW
 132: 0000:     INTEGER*2 GLOBAL NULL.MAPPING%                                      !BMW
 133: 0000:     INTEGER*2 GLOBAL RESULTS.COUNT%                                     !EMW
 134: 0000:     INTEGER*2 GLOBAL RESULTS.INDEX%                                     !EMW
 135: 0000:     INTEGER*2 GLOBAL RESULTS.LAST.PAGE%                                 !EMW
 136: 0000:     INTEGER*2 GLOBAL RESULTS.PAGE%                                      !EMW
 137: 0000:     INTEGER*2 GLOBAL RESULTS.PER.PAGE%
 138: 0000:     INTEGER*2 GLOBAL RESULTS.THIS.PAGE%                                 !EMW
 139: 0000:     INTEGER*2 GLOBAL RESULTS.TOTAL.PAGES%                               !EMW
 140: 0000:     INTEGER*2 GLOBAL SOURCES.PER.PAGE%                                  !BMW
 141: 0000:     INTEGER*2 GLOBAL ULOG.REPORT.NUM%                                   !DMW
 142: 0000:     INTEGER*2 GLOBAL ULOG.SESS.NUM%                                     !DMW
 143: 0000: 
 144: 0000:     INTEGER*4 GLOBAL EVENT.DATE%
 145: 0000:     INTEGER*4 GLOBAL EVENT.TIME%
 146: 0000: 
 147: 0000:     STRING GLOBAL ALL.APPLICATIONS.TEXT$
 148: 0000:     STRING GLOBAL ALL.BUCKETS.TEXT$
 149: 0000:     STRING GLOBAL ALL.CONTROLLERS.TEXT$
 150: 0000:     STRING GLOBAL ALL.EVENTS.TEXT$
 151: 0000:     STRING GLOBAL ALL.MESSAGE.GROUPS.TEXT$
 152: 0000:     STRING GLOBAL ALL.MESSAGE.NUMBERS.TEXT$
 153: 0000:     STRING GLOBAL ALL.SEVERITYS.TEXT$
 154: 0000:     STRING GLOBAL ALL.SOURCES.TEXT$
 155: 0000:     STRING GLOBAL ALL.TERMINALS.TEXT$
 156: 0000:     STRING GLOBAL BATCH.SCREEN.FLAG$
 157: 0000:     STRING GLOBAL BUCKET.TEXT$(1)
 158: 0000:     STRING GLOBAL CHAIN.TO.PROG$
 159: 0000:     STRING GLOBAL COMMENT$
 160: 0000:     STRING GLOBAL CONTROLLER.ID$
 161: 0000:     STRING GLOBAL CURRENT.CODE$
 162: 0000:     STRING GLOBAL DOW$(1)
 163: 0000:     STRING GLOBAL EDITOR.NAME$                                          !FMW
 164: 0000:     STRING GLOBAL EDITOR.PATHNAME$                                      !FMW
 165: 0000:     STRING GLOBAL EDITOR.PROGRAM$                                       !FMW
 166: 0000:     STRING GLOBAL EDITOR.TYPE$                                          !FMW
 167: 0000:     STRING GLOBAL EE$(1)
 168: 0000:     STRING GLOBAL EVENT.DOW$
 169: 0000:     STRING GLOBAL EVENT.MESSAGE.GROUP$
 170: 0000:     STRING GLOBAL EVENT.UNIQUE.DATA$
 171: 0000:     STRING GLOBAL FILE.OPERATION$
 172: 0000:     STRING GLOBAL HIGHWORD.DESCRIPTION$(1)
 173: 0000:     STRING GLOBAL HIGHWORD.ERRORCODE$(1)
 174: 0000:     STRING GLOBAL LA$(1)
 175: 0000:     STRING GLOBAL LE$(1)
 176: 0000:     STRING GLOBAL LJ$(1)
 177: 0000:     STRING GLOBAL LOG.DESC$
 178: 0000:     STRING GLOBAL LOG.NUMBER$
 179: 0000:     STRING GLOBAL LOWWORD.DESCRIPTION$(1)
 180: 0000:     STRING GLOBAL LOWWORD.ERRORCODE$(1)
 181: 0000:     STRING GLOBAL LW$(1)
 182: 0000:     STRING GLOBAL MESSAGE.TEXT$
 183: 0000:     STRING GLOBAL MODULE.NUMBER$
 184: 0000:     STRING GLOBAL NO.APPLICATIONS.TEXT$
 185: 0000:     STRING GLOBAL NO.BUCKETS.TEXT$
 186: 0000:     STRING GLOBAL NO.SEVERITYS.TEXT$
 187: 0000:     STRING GLOBAL NO.SOURCES.TEXT$                                      !BMW
 188: 0000:     STRING GLOBAL NONPRINTABLE.CHARS$
 189: 0000:     STRING GLOBAL NONPRINTABLE.MAP$
 190: 0000:     STRING GLOBAL NULL.FILENAME$
 191: 0000:     STRING GLOBAL NULL.PROGRAM$
 192: 0000:     STRING GLOBAL PID$
 193: 0000:     STRING GLOBAL PRINTABLE.CHARS$
 194: 0000:     STRING GLOBAL PROGRAM$
 195: 0000:     STRING GLOBAL R$(1)
 196: 0000:     STRING GLOBAL RETURN.CODE$
 197: 0000:     STRING GLOBAL RETURN.ERR$
 198: 0000:     STRING GLOBAL SE$(1)
 199: 0000:     STRING GLOBAL SELECTED.APPLICATIONS.TEXT$
 200: 0000:     STRING GLOBAL SELECTED.BUCKETS.TEXT$
 201: 0000:     STRING GLOBAL SELECTED.SEVERITYS.TEXT$
 202: 0000:     STRING GLOBAL SELECTED.SOURCES.TEXT$                                !BMW
 203: 0000:     STRING GLOBAL SEVERITY.TEXT$(1)
 204: 0000:     STRING GLOBAL SINGLE.APPLICATION.TEXT$
 205: 0000:     STRING GLOBAL SINGLE.BUCKET.TEXT$
 206: 0000:     STRING GLOBAL SINGLE.CONTROLLER.TEXT$
 207: 0000:     STRING GLOBAL SINGLE.EVENT.TEXT$
 208: 0000:     STRING GLOBAL SINGLE.MESSAGE.GROUP.TEXT$
 209: 0000:     STRING GLOBAL SINGLE.MESSAGE.NUMBER.TEXT$
 210: 0000:     STRING GLOBAL SINGLE.SEVERITY.TEXT$
 211: 0000:     STRING GLOBAL SINGLE.SOURCE.TEXT$
 212: 0000:     STRING GLOBAL SINGLE.TERMINAL.TEXT$
 213: 0000:     STRING GLOBAL SUMMARY.RECORD$(1)                                    !EMW
 214: 0000:     STRING GLOBAL SOURCE.TEXT$(1)                                       !CMW
 215: 0000:     STRING GLOBAL SS$(1)
 216: 0000:     STRING GLOBAL SW$(1)
 217: 0000:     STRING GLOBAL TILL.NUMBER$
 218: 0000:     STRING GLOBAL TS$(1)
 219: 0000:     STRING GLOBAL ULOG.FILE.NAME$                                       !DMW
 220: 0000:     STRING GLOBAL ULOG.RECORD$(1)                                       !EMW
 221: 0000: 
 222: 0000: 
 223: 0000: \***********************************************************************
 224: 0000: \***
 225: 0000: \***    Local variable declarations
 226: 0000: \***
 227: 0000: \***********************************************************************
 228: 0000: 
 229: 0000:     INTEGER*2 I%
 230: 0000:     INTEGER*2 INDEX%
 231: 0000:     INTEGER*2 M%
 232: 0000:     INTEGER*2 SESS.NUM%
 233: 0000: 
 234: 0000:     STRING ACTUAL$
 235: 0000:     STRING BAR.CODE$                                                    !BMW
 236: 0000:     STRING BIN.RANGE$                                                   !BMW
 237: 0000:     STRING CODE$
 238: 0000:     STRING CODE.TEXT$
 239: 0000:     STRING EXPECTED$
 240: 0000:     STRING FIELD$
 241: 0000:     STRING FILE$
 242: 0000:     STRING FILENAME$
 243: 0000:     STRING FLAG$
 244: 0000:     STRING FLAG.TEXT$
 245: 0000:     STRING FUNCTION$
 246: 0000:     STRING IMFOK.FLAG$
 247: 0000:     STRING ITEM.CODE$
 248: 0000:     STRING KEY$
 249: 0000:     STRING KEY.TEXT$
 250: 0000:     STRING LINE.NUMBER$
 251: 0000:     STRING LINE.TEXT$
 252: 0000:     STRING MODULE$
 253: 0000:     STRING MODULE.TEXT$
 254: 0000:     STRING PROGRAM.CHILD$
 255: 0000:     STRING PROGRAM.DATE$
 256: 0000:     STRING PROGRAM.NUMBER$
 257: 0000:     STRING PROGRAM.TIME$
 258: 0000:     STRING SCREEN$
 259: 0000:     STRING SESS.TEXT$
 260: 0000:     STRING T$
 261: 0000:     STRING VERSION$
 262: 0000: 
 263: 0000: \***********************************************************************
 264: 0000: \***
 265: 0000: \***    External function definitions
 266: 0000: \***
 267: 0000: \***********************************************************************
 268: 0000: 
 269: 0000: %INCLUDE BTCMEM.J86
 270: 0000: !********************************************************************
 271: 0000: !***
 272: 0000: !***    INCLUDED CODE:  BTCMEM.J86
 273: 0000: !***    AUTHOR:         Stuart William McConnachie
 274: 0000: !***    DATE:           26th February 2006
 275: 0000: !***
 276: 0000: !********************************************************************
 277: 0000: !***
 278: 0000: !***    Controller CBASIC Memory Functions
 279: 0000: !***
 280: 0000: !********************************************************************
 281: 0000: 
 282: 0000: !Get a single byte integer from a string offset
 283: 0000: FUNCTION GETN1 (S$, P%) EXTERNAL
 284: 0000:     STRING S$
 285: 0000:     INTEGER*2 P%
 286: 0000:     INTEGER*2 GETN1
 287: 0000: END FUNCTION
 288: 0000: 
 289: 0000: !Get a two byte integer from a string offset
 290: 0000: FUNCTION GETN2 (S$, P%) EXTERNAL
 291: 0000:     STRING S$
 292: 0000:     INTEGER*2 P%
 293: 0000:     INTEGER*2 GETN2
 294: 0000: END FUNCTION
 295: 0000: 
 296: 0000: !Get a four byte integer from a string offset
 297: 0000: FUNCTION GETN4 (S$, P%) EXTERNAL
 298: 0000:     STRING S$
 299: 0000:     INTEGER*2 P%
 300: 0000:     INTEGER*4 GETN4
 301: 0000: END FUNCTION
 302: 0000: 
 303: 0000: !Get a 10 byte CBASIC real from a string offset
 304: 0000: FUNCTION GETR10 (S$, P%) EXTERNAL
 305: 0000:     STRING S$
 306: 0000:     INTEGER*2 P%
 307: 0000:     REAL GETR10
 308: 0000: END FUNCTION
 309: 0000: 
 310: 0000: !Put a single byte integer into a string at offset
 311: 0000: FUNCTION PUTN1 (S$, P%, N%) EXTERNAL
 312: 0000:     STRING S$
 313: 0000:     INTEGER*2 P%
 314: 0000:     INTEGER*1 N%
 315: 0000:     INTEGER*1 PUTN1
 316: 0000: END FUNCTION
 317: 0000: 
 318: 0000: !Put a two byte integer into a string at offset
 319: 0000: FUNCTION PUTN2 (S$, P%, N%) EXTERNAL
 320: 0000:     STRING S$
 321: 0000:     INTEGER*2 P%
 322: 0000:     INTEGER*2 N%
 323: 0000:     INTEGER*1 PUTN2
 324: 0000: END FUNCTION
 325: 0000: 
 326: 0000: !Put a four byte integer into a string at offset
 327: 0000: FUNCTION PUTN4 (S$, P%, N%) EXTERNAL
 328: 0000:     STRING S$
 329: 0000:     INTEGER*2 P%
 330: 0000:     INTEGER*4 N%
 331: 0000:     INTEGER*1 PUTN4
 332: 0000: END FUNCTION
 333: 0000: 
 334: 0000: !Put a 10 byte CBASIC real into a string at offset
 335: 0000: FUNCTION PUTR10 (S$, P%, R) EXTERNAL
 336: 0000:     STRING S$
 337: 0000:     INTEGER*2 P%
 338: 0000:     REAL R
 339: 0000:     INTEGER*1 PUTR10
 340: 0000: END FUNCTION
 341: 0000: 
 342: 0000: !Peek a two byte integer from a memory address
 343: 0000: FUNCTION PEEKN2 (A%) EXTERNAL
 344: 0000:     INTEGER*4 A%
 345: 0000:     INTEGER*2 PEEKN2
 346: 0000: END FUNCTION
 347: 0000: 
 348: 0000: !Peek a four byte integer from a memory address
 349: 0000: FUNCTION PEEKN4 (A%) EXTERNAL
 350: 0000:     INTEGER*4 A%
 351: 0000:     INTEGER*4 PEEKN4
 352: 0000: END FUNCTION
 353: 0000: 
 354: 0000: !Peek a 10 byte CBASIC real from a memory address
 355: 0000: FUNCTION PEEKR10 (A%) EXTERNAL
 356: 0000:     INTEGER*4 A%
 357: 0000:     REAL PEEKR10
 358: 0000: END FUNCTION
 359: 0000: 
 360: 0000: !Poke a two byte integer to a memory address
 361: 0000: FUNCTION POKEN2 (A%, N%) EXTERNAL
 362: 0000:     INTEGER*4 A%
 363: 0000:     INTEGER*2 N%
 364: 0000:     INTEGER*1 POKEN2
 365: 0000: END FUNCTION
 366: 0000: 
 367: 0000: !Poke a four byte integer to a memory address
 368: 0000: FUNCTION POKEN4 (A%, N%) EXTERNAL
 369: 0000:     INTEGER*4 A%
 370: 0000:     INTEGER*4 N%
 371: 0000:     INTEGER*1 POKEN4
 372: 0000: END FUNCTION
 373: 0000: 
 374: 0000: !Poke a 10 byte CBASIC real to a memory address
 375: 0000: FUNCTION POKER10 (A%, R) EXTERNAL
 376: 0000:     INTEGER*4 A%
 377: 0000:     REAL R
 378: 0000:     INTEGER*1 POKER10
 379: 0000: END FUNCTION
 380: 0000: 
 381: 0000: %INCLUDE STREXT.J86
 382: 0000: \*******************************************************************************
 383: 0000: \*******************************************************************************
 384: 0000: \***
 385: 0000: \***    REFERENCE   :   STREXT
 386: 0000: \***
 387: 0000: \*******************************************************************************
 388: 0000: \***
 389: 0000: \***    OVERVIEW:
 390: 0000: \***
 391: 0000: \***    This module contains common external function and subprogram
 392: 0000: \***    definitions used for string processing.
 393: 0000: \***
 394: 0000: \***    CONTENTS:
 395: 0000: \***
 396: 0000: \***    RTRIM$ - Removes the specified trailing character from a string
 397: 0000: \***    LTRIM$ - Removes the specified leading character from a string
 398: 0000: \***    TRIM$  - Removes the specified leading and trailing character
 399: 0000: \***             from a string
 400: 0000: \***
 401: 0000: \*******************************************************************************
 402: 0000: \***
 403: 0000: \***    MODIFICATIONS:
 404: 0000: \***
 405: 0000: \***    Version A.              Mark Walker                     24th Jul 2015
 406: 0000: \***    Initial version.
 407: 0000: \***
 408: 0000: \***    Version B.              Mark Walker                     24th Nov 2016
 409: 0000: \***    Added TRIM$ function.
 410: 0000: \***
 411: 0000: \*******************************************************************************
 412: 0000: \*******************************************************************************
 413: 0000: 
 414: 0000: FUNCTION RTRIM$(SOURCE$,TRIM.CHAR$) EXTERNAL
 415: 0000:     STRING    TRIM.CHAR$
 416: 0000:     STRING    SOURCE$
 417: 0000:     STRING    RTRIM$
 418: 0000: END FUNCTION
 419: 0000: 
 420: 0000: FUNCTION LTRIM$(SOURCE$,TRIM.CHAR$) EXTERNAL
 421: 0000:     STRING    TRIM.CHAR$
 422: 0000:     STRING    SOURCE$
 423: 0000:     STRING    LTRIM$
 424: 0000: END FUNCTION
 425: 0000: 
 426: 0000: FUNCTION TRIM$(SOURCE$,TRIM.CHAR$) EXTERNAL                             !BMW
 427: 0000:     STRING    TRIM.CHAR$                                                !BMW
 428: 0000:     STRING    SOURCE$                                                   !BMW
 429: 0000:     STRING    TRIM$                                                     !BMW
 430: 0000: END FUNCTION                                                            !BMW
 431: 0000: 
 432: 0000: %INCLUDE BASROUT.J86    ! OSSHELL function
 433: 0000: \*LIB   BVEJ BASROUT  J86      03/11/97 08:16:26 PIDBLD3  *    FIX
 434: 0000: \*PROM  BVEJ BASROUT  J86      03/10/97 17:18:40 PIDBLD3  MVEJ IR34352
 435: 0000: \*RTIME BVEJ BASROUT  J86      03/10/97 17:18:41 PIDBLD3  MVEJ IR34352
 436: 0000: \*LIB   MVEJ BASROUT  J86      03/05/97 10:48:46 EDJRAL   *    IR34352
 437: 0000: \*LIB   MVEJ BASROUT  J86      02/17/97 11:19:56 EDJRAL   *    REASONAR
 438: 0000: \*LIB   MVEJ BASROUT  J86      02/14/97 15:59:11 EDJRAL   *    REASONAR
 439: 0000: ! BASROUT.J86 - this file is to be included in any BASIC code which utilizes
 440: 0000: !   the BASROUT.OBJ routines.  These routines were written
 441: 0000: !  using Metaware C and are intended to provide functions which
 442: 0000: !         are either not available in 4680 CBASIC or which can be more
 443: 0000: !               efficiently handled by the C language.  Their usage is
 444: 0000: !  offered on an "AT YOUR OWN RISK" basis.
 445: 0000: !
 446: 0000: !               The insert/extract routines usefulness may not be immediately
 447: 0000: !               apparent.  Their intention is that they be used in conjunction
 448: 0000: !               with a read/write form command.  They can more efficiently
 449: 0000: !               parse a string into many different variables than can the
 450: 0000: !               read form statement.  So instead of a long list of data var's
 451: 0000: !               it may be more efficient to just read/write one long string
 452: 0000: !               and then use the insert/extract routines to parse out the
 453: 0000: !   data.
 454: 0000: 
 455: 0000: ! ******************* SUB PROCESS FUNCTIONS *********************************
 456: 0000: 
 457: 0000: function osshell(cmd.line$) external   ! routine to start
 458: 0000:        ! another program.
 459: 0000:            integer*4    osshell    ! Upon completion of
 460: 0000:            string       cmd.line$   ! program, control is
 461: 0000:        ! returned to calling
 462: 0000: end function      ! program.
 463: 0000: !
 464: 0000: ! NOTES:  Program must be a 286 type file.  This does not exclude
 465: 0000: !         the capability to execute a batch file however.  Simply pass the
 466: 0000: !         following:
 467: 0000: !              c:\adx_spgm\command.286 batfile
 468: 0000: !         where batfile is the name of the batch file to be executed.
 469: 0000: !
 470: 0000: ! IMPORTANT: When using osshell to execute a batch file as described above,
 471: 0000: !            the final command in the batch file must be "exit".  If not,
 472: 0000: !       control is never given back to the calling program.
 473: 0000: 
 474: 0000: ! ************************ MEMORY RELATED FUNCTIONS ************************
 475: 0000: 
 476: 0000: function memfree(choice) external   ! routine to que the
 477: 0000:        ! status of the
 478: 0000:  integer*4 memfree    ! machine's memory:
 479: 0000:  integer*2 choice    ! Options:
 480: 0000:        !    1 - free
 481: 0000: end function      !    2 - total
 482: 0000:        !    3 - system
 483: 0000: 
 484: 0000: ! ********************** TIMEDATE RELATED FUNCTIONS ************************
 485: 0000: 
 486: 0000: function timedate(choice) external   ! routine to que the
 487: 0000:        ! OS's timedate table
 488: 0000:  integer*4 timedate   ! Choices:
 489: 0000:  integer*2 choice    !    1 - millisec's
 490: 0000:        !        since midnight
 491: 0000: end function      !    2 - minutes from
 492: 0000:        !  UCT (timezone)
 493: 0000:        !    3 - day of week
 494: 0000:        !   0-Sunday
 495: 0000:        !  6-Saturday
 496: 0000: 
 497: 0000: function settime(msecs) external   ! routine to set the
 498: 0000:        ! time on the controller
 499: 0000:  integer*4  settime    ! msecs is the desired
 500: 0000:  integer*4 msecs    ! number of milliseconds
 501: 0000:        ! since midnight
 502: 0000: end function      ! Returns negative on
 503: 0000:        ! error
 504: 0000: ! NOTE:  This routine sets the time only on the controller.  The terminals'
 505: 0000: ! time will not be updated until 1 AM or unless a terminal is STC'd.
 506: 0000: ! At 1 AM the controller broadcasts the new time to all terminals.
 507: 0000: ! Insure this is taken into consideration when using this routine.
 508: 0000: 
 509: 0000: !******************** DISK FILE RELATED FUNCTIONS *************************
 510: 0000: 
 511: 0000: function truncate(name,length) external   ! routine to truncate
 512: 0000:        ! the specified file
 513: 0000:  integer*4 truncate   ! to a given length.
 514: 0000:  string  name
 515: 0000:  integer*4 length
 516: 0000: 
 517: 0000: end function
 518: 0000: 
 519: 0000: !******************** STRING VALUE RELATED FUNCTIONS **********************
 520: 0000: 
 521: 0000: function isalpha(bstrn) external   ! routine to identify
 522: 0000:        ! if the specified
 523: 0000:  integer*1 isalpha    ! string contains all
 524: 0000:  string  bstrn    ! alphabetic char's
 525: 0000:        ! Returns:
 526: 0000: end function      !     0 - all alpha
 527: 0000:        !     X - byte of 1st
 528: 0000:        !         non-alpha
 529: 0000:        !   char
 530: 0000: 
 531: 0000: function isdigit(bstrn) external   ! routine to identify
 532: 0000:        ! if the specified
 533: 0000:  integer*1 isdigit    ! string contains all
 534: 0000:  string  bstrn    ! numeric char's
 535: 0000:        ! Returns:
 536: 0000: end function      !     0 - all numeric
 537: 0000:        !     X - byte of 1st
 538: 0000:        !         non-numeric
 539: 0000:        !   char
 540: 0000: 
 541: 0000: function islower(bstrn) external   ! routine to identify
 542: 0000:        ! if the specified
 543: 0000:  integer*1 islower    ! string contains all
 544: 0000:  string  bstrn    ! lower case char's
 545: 0000:        ! Returns:
 546: 0000: end function      !     0 - all lowercase
 547: 0000:        !     X - byte of 1st
 548: 0000:        !         non-lowercase
 549: 0000:        !   char
 550: 0000: 
 551: 0000: function isupper(bstrn) external   ! routine to identify
 552: 0000:        ! if the specified
 553: 0000:  integer*1 isupper    ! string contains all
 554: 0000:  string  bstrn    ! upper case char's
 555: 0000:        ! Returns:
 556: 0000: end function      !     0 - all uppercase
 557: 0000:        !     X - byte of 1st
 558: 0000:        !         non-uppercase
 559: 0000:        !   char
 560: 0000: 
 561: 0000: function toalpha(bstrn) external   ! routine to convert
 562: 0000:        ! non-alpha or non-num
 563: 0000:    integer*2 toalpha    ! char's to spaces
 564: 0000:  string  bstrn    ! Returns:
 565: 0000: end function      !   x - no. of char's
 566: 0000:        !       changed
 567: 0000: 
 568: 0000: ! ********************* USER/GROUP ZERO LEVEL FUNCTIONS *********************
 569: 0000: 
 570: 0000: function idlecount(choice) external   ! routine to either
 571: 0000:        ! set to zero or queue
 572: 0000:  integer*4 idlecount   ! the value of the
 573: 0000:  integer*1 choice    ! processor's idlecount
 574: 0000:        ! Choice:
 575: 0000: end function      !     0 - set to zero
 576: 0000: !       !     1 - get value
 577: 0000: ! NEEDS USER/GROUP 0 LEVEL OF AUTHORIZATION  ! Returns:
 578: 0000: ! TO WORK - This level is not available unless  !     X - idlecount
 579: 0000: ! the file ADXCSOUF.DAT file is "patched".  This !    -X - error code
 580: 0000: ! is highly unrecommended.
 581: 0000: 
 582: 0000: function logical(actname,logname,choice) external ! routine to set a
 583: 0000:        ! a logical name.
 584: 0000:  integer*4 logical    ! parms are self
 585: 0000:         string  logname    ! explanatory except
 586: 0000:  string  actname    ! for choice:
 587: 0000:  integer*1 choice    !   0 - set process
 588: 0000:        !   1 - set system
 589: 0000: end function      !   2 - get process
 590: 0000:        !   3 - get system
 591: 0000: 
 592: 0000: ! NOTE:  Only the setting of a system level of logical name requires
 593: 0000: ! user/group zero level of authorization.  Any application may query any
 594: 0000: ! logical name.  Setting of a system logical name is only applicable until
 595: 0000: ! the system is IPL'd.  A process logical name is only active when that
 596: 0000: ! process is active.
 597: 0000: 
 598: 0000: !******************** STRING PARSING FUNCTIONS *****************************
 599: 0000: 
 600: 0000: function inserts(whole,part,offset) external  ! routine to insert a
 601: 0000:        ! string (part) into
 602: 0000:  integer*2 INSERTS    ! another string (whole)
 603: 0000:  string  whole    ! starting at specified
 604: 0000:  string  part    ! character (offset)
 605: 0000:  integer*2 offset
 606: 0000: 
 607: 0000: end function
 608: 0000: 
 609: 0000: function cinsert4(integer4,bstring,offset) external   ! routine to insert
 610: 0000:        ! a 4-byte integer into
 611: 0000:  integer*1 cinsert4   ! a string starting at
 612: 0000:  integer*4 integer4   ! byte specified by
 613: 0000:  string  bstring    ! offset (1-based)
 614: 0000:  integer*2 offset    ! Returns:
 615: 0000:        !     0 - Success
 616: 0000: end function      !    -1 - String overrun
 617: 0000: 
 618: 0000: function cinsert2(integer2,bstring,offset) external  ! routine to insert
 619: 0000:        ! a 2-byte integer into
 620: 0000:  integer*1 cinsert2   ! a string starting at
 621: 0000:  integer*2 integer2   ! byte specified by
 622: 0000:  string  bstring    ! offset (1-based)
 623: 0000:  integer*2 offset    ! Returns:
 624: 0000:        !     0 - Success
 625: 0000: end function      !    -1 - String overrun
 626: 0000: 
 627: 0000: function cinsert1(bstring,integer1,offset) external  ! routine to insert
 628: 0000:        ! a 1-byte integer into
 629: 0000:  integer*1 cinsert1   ! a string starting at
 630: 0000:  integer*1 integer1   ! byte specified by
 631: 0000:  string  bstring    ! offset (1-based)
 632: 0000:  integer*2 offset    ! Returns:
 633: 0000:        !     0 - Success
 634: 0000: end function      !    -1 - String overrun
 635: 0000: 
 636: 0000: function extracts(whole,part,offset) external  ! routine to extract a
 637: 0000:        ! string (part) from
 638: 0000:  integer*2 EXTRACTS   ! another string (whole)
 639: 0000:  string  whole    ! starting at specified
 640: 0000:  string  part    ! character (offset)
 641: 0000:  integer*2 offset
 642: 0000: 
 643: 0000: end function
 644: 0000: 
 645: 0000: function cextract4(bstring,offset) external  ! routine to extract
 646: 0000:        ! a 4-byte integer from
 647: 0000:  integer*4 cextract4   ! a string starting at
 648: 0000:                        ! byte specified by
 649: 0000:  string  bstring    ! offset (1-based)
 650: 0000:  integer*2 offset    ! Returns:
 651: 0000:        !     X - 4 byte integer
 652: 0000: end function      !    -1 - String overrun
 653: 0000: 
 654: 0000: function cextract2(bstring,offset) external  ! routine to extract
 655: 0000:        ! a 2-byte integer from
 656: 0000:  integer*2 cextract2   ! a string starting at
 657: 0000:                        ! byte specified by
 658: 0000:  string  bstring    ! offset (1-based)
 659: 0000:  integer*2 offset    ! Returns:
 660: 0000:        !     X - 2 byte integer
 661: 0000: end function      !    -1 - String overrun
 662: 0000: 
 663: 0000: function cextract1(bstring,offset) external  ! routine to extract
 664: 0000:        ! a 1-byte integer from
 665: 0000:  integer*1 cextract1   ! a string starting at
 666: 0000:                        ! byte specified by
 667: 0000:  string  bstring    ! offset (1-based)
 668: 0000:  integer*2 offset    ! Returns:
 669: 0000:        !     X - 1 byte integer
 670: 0000: end function      !    -1 - String overrun
 671: 0000: 
 672: 0000: 
 673: 0000: function srchdir (file.name$,dtbl.buffer$) external ! routine to return
 674: 0000:        ! file names and sizes
 675: 0000:        ! Return values:
 676: 0000:        !    -1  no matches
 677: 0000:        !        found on first
 678: 0000:        !        call
 679: 0000:        !    0   no matches
 680: 0000:        !        found on sub-
 681: 0000:        !        sequent calls
 682: 0000:        !    Pos Success
 683: 0000:        !    Neg OS Rtn Code
 684: 0000: ! Usage Note:  If searching for all occurences of a particular file name,
 685: 0000: ! first initialize dtbl.buffer$ to 48 Nulls (pack$("00")) and issue a call
 686: 0000: ! to srchdir.  If any matches are found, a positive value will be returned.
 687: 0000: ! To see if any more matches exist, just issue another call to srchdir without
 688: 0000: ! resetting the values of dtbl.buffer$.  If any are found, a positive value
 689: 0000: ! will be returned.  This can be repeated until a Zero is returned.  All data
 690: 0000: ! describing file will be returned in the dtbl.buffer$ after each call.  Format
 691: 0000: ! of this data is defined below.
 692: 0000: 
 693: 0000:  integer*4 srchdir
 694: 0000: 
 695: 0000:  string  file.name$   ! file name to start
 696: 0000:        ! search (18 bytes max)
 697: 0000:        ! Wild cards and logical
 698: 0000:        ! names supported.
 699: 0000: 
 700: 0000:  string  dtbl.buffer$   ! must be initialized
 701: 0000:        ! to 48 bytes.  Contains
 702: 0000:        ! all of directory info
 703: 0000:        ! Initialize to nulls
 704: 0000:        ! each time a new file
 705: 0000:        ! name is used.
 706: 0000: 
 707: 0000: ! NOTE:  Format of dtbl.buffer$ string is as follows:
 708: 0000: !
 709: 0000: ! Offs  Type                    Description Notes
 710: 0000: !  0 integer*4  key  use extract4 to access
 711: 0000: !  4  string (18 bytes) file name
 712: 0000: ! 22 integer*2  attributes use extract2 to access
 713: 0000: !      0x01 - Read Only
 714: 0000: !      0x02 - Hidden
 715: 0000: !      0x04 - System
 716: 0000: !      0x08 - Volume Label
 717: 0000: !      0x10 - Subdirectory
 718: 0000: !      0x20 - Archive (Files)
 719: 0000: !      0x40 - Security enabled
 720: 0000: !      0x80 - Reserved
 721: 0000: !      0x0000 - Local
 722: 0000: !      0x4000 - Mirrored/Update
 723: 0000: !      0xC000 - Mirrored/Close
 724: 0000: !
 725: 0000: !      0x6000 - Compound/Update
 726: 0000: !      0xE000 - Compound/Close
 727: 0000: ! 24 integer*2  record size use extract2 to access
 728: 0000: ! 26 integer*1  User ID of Owner
 729: 0000: ! 27 integer*1  Group ID of Owner
 730: 0000: ! 28 integer*2  File Security
 731: 0000: ! 30 string (6 bytes) Reserved
 732: 0000: ! 36 integer*4  File Size use extract4 to access
 733: 0000: ! 40 integer*2  Year  use extract2 to access
 734: 0000: ! 42 integer*1  Month
 735: 0000: ! 43 integer*1  Day
 736: 0000: ! 44 integer*1  Hour
 737: 0000: ! 45 integer*1  Minute
 738: 0000: ! 46 integer*1  Second
 739: 0000: ! 47 integer*1  Reserved
 740: 0000: 
 741: 0000: end function
 742: 0000: 
 743: 0000: function srchproc (proc.name$,ptbl.buffer$) external ! routine to return
 744: 0000:        ! process names and
 745: 0000:        ! status.  Handy to
 746: 0000:        ! determine if a
 747: 0000:        ! program is currently
 748: 0000:        ! running.
 749: 0000:        ! Return values:
 750: 0000:        !    -1  no matches
 751: 0000:        !        found on first
 752: 0000:        !        call
 753: 0000:        !    0   no matches
 754: 0000:        !        found on sub-
 755: 0000:        !        sequent calls
 756: 0000:        !    Pos Success
 757: 0000:        !    Neg Failure
 758: 0000:        !        OS Rtn Code
 759: 0000:        ! 80000001h - Insuff
 760: 0000:         !        ptbl buffer
 761: 0000:        !        Length
 762: 0000: ! Usage Note:  If searching for all occurences of a particular process name,
 763: 0000: ! first initialize ptbl.buffer$ to 60 Nulls (pack$("00")) and issue a call
 764: 0000: ! to srchproc.  If any matches are found, a positive value will be returned.
 765: 0000: ! To see if any more matches exist, just issue another call to srchproc without
 766: 0000: ! resetting the values of ptbl.buffer$.  If any are found, a positive value
 767: 0000: ! will be returned.  This can be repeated until a Zero is returned.  All data
 768: 0000: ! describing file will be returned in the ptbl.buffer$ after each call.  Format
 769: 0000: ! of this data is defined as follows:
 770: 0000: !
 771: 0000: !       --------------------------------------------------------
 772: 0000: !   0   |                         PID                          |
 773: 0000: !       --------------------------------------------------------
 774: 0000: !   4   |           FID             |   CID        |   VCID    |
 775: 0000: !       --------------------------------------------------------
 776: 0000: !   8   |                         NAME                         |
 777: 0000: !       --------------------------------------------------------
 778: 0000: !  12   |                         NAME cont'd                  |
 779: 0000: !       --------------------------------------------------------
 780: 0000: !  16   |       NAME cont'd         |   STATE      |  PRIOR    |
 781: 0000: !       --------------------------------------------------------
 782: 0000: !  20   |                         MAXMEM                       |
 783: 0000: !       --------------------------------------------------------
 784: 0000: !  24   |       FLAGS               |   USER        |  GROUP   |
 785: 0000: !       --------------------------------------------------------
 786: 0000: !  28   |                         PARENT                       |
 787: 0000: !       --------------------------------------------------------
 788: 0000: !  32   |                         EVENTS                       |
 789: 0000: !       --------------------------------------------------------
 790: 0000: !  36   |                         CODE                         |
 791: 0000: !       --------------------------------------------------------
 792: 0000: !  40   |                         CSIZE                        |
 793: 0000: !       --------------------------------------------------------
 794: 0000: !  44   |                         DATA                         |
 795: 0000: !       --------------------------------------------------------
 796: 0000: !  48   |                         DSIZE                        |
 797: 0000: !       --------------------------------------------------------
 798: 0000: !  52   |                         HEAP                         |
 799: 0000: !       --------------------------------------------------------
 800: 0000: !  56   |                         HSIZE                        |
 801: 0000: !       --------------------------------------------------------
 802: 0000: !
 803: 0000: !       PID   Process ID
 804: 0000: !       FID  Process's Family ID
 805: 0000: !       CID   Physical Console Device Number
 806: 0000: !       VCID  Process's Virtual Console Number
 807: 0000: !       NAME  Process Name (Application Running)
 808: 0000: ! STATE    Process State (0-Run, 1-Waiting, 2-Terminating)
 809: 0000: ! PRIOR    Priority
 810: 0000: !       MAXMEM  Maximum Memory Allowed
 811: 0000: !       FLAGS  Bit 0 (1-System Process, 0-User Process)
 812: 0000: !   Bit 1 (1-Locked in Memory, 0-Swappable)
 813: 0000: !   Bit 2 (1-Running in SWI context, 0-Running in main context)
 814: 0000: !   Bit 3 (1-Superuser Process,0-Not a Superuser Process)
 815: 0000: ! USER  User Number
 816: 0000: ! GROUP  Group Number
 817: 0000: !       PARENT   Parent Process ID
 818: 0000: !       EVENTS   Bit Map of events that have completed but not retrieved
 819: 0000: !       CODE  Start of code area in user space
 820: 0000: ! CSIZE  Size in bytes of code area
 821: 0000: !       DATA  Start of data area in user space
 822: 0000: ! DSIZE  Size in bytes of data area
 823: 0000: !       HEAP  Start of heap area in user space
 824: 0000: ! HSIZE  Size in bytes of heap area
 825: 0000: !
 826: 0000:  integer*4 srchproc
 827: 0000: 
 828: 0000:  string  proc.name$   ! process name to start
 829: 0000:        ! search (10 bytes max)
 830: 0000:        ! Wild cards and logical
 831: 0000:        ! names supported.
 832: 0000: 
 833: 0000:  string  ptbl.buffer$   ! must be initialized
 834: 0000:        ! to 60 bytes.  Contains
 835: 0000:        ! all of process info
 836: 0000:        ! Initialize to nulls
 837: 0000:        ! each time a new
 838: 0000:        ! process name is used.
 839: 0000: 
 840: 0000: end function
 841: 0000: 
 842: 0000: function cconstat(timeout) external       ! function similar
 843: 0000:                                               ! to BASIC constat%
 844: 0000:  integer*2 cconstat   ! waits for either a
 845: 0000:  integer*4 timeout    ! key being hit or
 846: 0000:        ! the timer expiring
 847: 0000:        ! before returning
 848: 0000:        ! returns:
 849: 0000:        !   -1 error
 850: 0000:        !    0 timer expired
 851: 0000:        !    x scan code of
 852: 0000:        !      key hit
 853: 0000: end function
 854: 0000: 
 855: 0000: function disksize(disk.name$) external   ! function to find
 856: 0000:        ! the total size of
 857: 0000:  integer*4 disksize   ! the specified disk
 858: 0000:  string  disk.name$   ! name (e.g. "h0:")
 859: 0000:        ! if return value is
 860: 0000:        ! negative, error
 861: 0000: end function      ! was received
 862: 0000: 
 863: 0000: 
 864: 0000: %INCLUDE BTCSTR.J86     ! String functions
 865: 0000: !********************************************************************
 866: 0000: !***
 867: 0000: !***    INCLUDED CODE:  BTCSTR.J86
 868: 0000: !***    AUTHOR:         Stuart William McConnachie
 869: 0000: !***    DATE:           26th February 2006
 870: 0000: !***
 871: 0000: !********************************************************************
 872: 0000: !***
 873: 0000: !***    Controller CBASIC String Functions
 874: 0000: !***
 875: 0000: !********************************************************************
 876: 0000: 
 877: 0000: !Swaps to CBASIC strings
 878: 0000: SUB SWAPSTR (S1$, S2$) EXTERNAL
 879: 0000:     STRING S1$, S2$
 880: 0000: END SUB
 881: 0000: 
 882: 0000: !Left trim a string of spaces
 883: 0000: SUB LTRIM (S$) EXTERNAL
 884: 0000:     STRING S$
 885: 0000: END SUB
 886: 0000: 
 887: 0000: !Right trim a string of spaces
 888: 0000: SUB RTRIM (S$) EXTERNAL
 889: 0000:     STRING S$
 890: 0000: END SUB
 891: 0000: 
 892: 0000: !Left and right trim a string of spaces
 893: 0000: SUB TRIM (S$) EXTERNAL
 894: 0000:     STRING S$
 895: 0000: END SUB
 896: 0000: 
 897: 0000: !Left trim a string of a given ASCII character
 898: 0000: SUB LTRIMC (S$, C%) EXTERNAL
 899: 0000:     STRING S$
 900: 0000:     INTEGER*1 C%
 901: 0000: END SUB
 902: 0000: 
 903: 0000: !Right trim a string of a given ASCII character
 904: 0000: SUB RTRIMC (S$, C%) EXTERNAL
 905: 0000:     STRING S$
 906: 0000:     INTEGER*1 C%
 907: 0000: END SUB
 908: 0000: 
 909: 0000: !Left and right trim a string of a given ASCII character
 910: 0000: SUB TRIMC (S$, C%) EXTERNAL
 911: 0000:     STRING S$
 912: 0000:     INTEGER*1 C%
 913: 0000: END SUB
 914: 0000: 
 915: 0000: !Insert one string into another
 916: 0000: FUNCTION SUBSTR(S1$, O1%, S2$, O2%, L2%) EXTERNAL
 917: 0000:     STRING    S1$, S2$
 918: 0000:     INTEGER*2 O1%, O2%, L2%
 919: 0000:     INTEGER*1 SUBSTR
 920: 0000: END FUNCTION
 921: 0000:     
 922: 0000: 
 923: 0000: FUNCTION ASC.TEXT$(A$) EXTERNAL
 924: 0000: STRING ASC.TEXT$,A$
 925: 0000: END FUNCTION
 926: 0000: 
 927: 0000: FUNCTION HEX.TEXT$(H$) EXTERNAL
 928: 0000: STRING HEX.TEXT$,H$
 929: 0000: END FUNCTION
 930: 0000: 
 931: 0000: FUNCTION SUBSTITUTE$(T$,P$,R$) EXTERNAL
 932: 0000: STRING SUBSTITUTE$,T$,P$,R$
 933: 0000: END FUNCTION
 934: 0000: 
 935: 0000: SUB PSU0406 EXTERNAL
 936: 0000: END SUB
 937: 0000: 
 938: 0000: \***********************************************************************
 939: 0000: \***********************************************************************
 940: 0000: \***
 941: 0000: \***    MAIN SUBPROGRAM PSU0404
 942: 0000: \***
 943: 0000: \***********************************************************************
 944: 0000: \***********************************************************************
 945: 0000: SUB PSU0404 PUBLIC
 946: 0024: 
 947: 0024:     COMMENT$ = "No additional comment available."
 948: 003b: 
 949: 003b:     PROGRAM$ = RTRIM$(PROGRAM$," ")
 950: 0062: 
 951: 0062:     RETURN.CODE$ = ""
 952: 0079:     RETURN.ERR$ = ""
 953: 0090: 
 954: 0090:     IF EVENT.MESSAGE.NUMBER% = 0 THEN BEGIN
 955: 00a2:         MESSAGE.TEXT$ = "No message text found"
 956: 00bc:     ENDIF ELSE IF EVENT.MESSAGE.GROUP$ = "A" THEN BEGIN
 957: 00da:         MESSAGE.TEXT$ = LA$(EVENT.MESSAGE.NUMBER%)
 958: 010b:     ENDIF ELSE IF EVENT.MESSAGE.GROUP$ = "J" THEN BEGIN
 959: 0129:         MESSAGE.TEXT$ = LJ$(EVENT.MESSAGE.NUMBER%)
 960: 0158:     ENDIF
 961: 0160: 
 962: 0160:     IF EVENT.NUMBER% = 1 THEN BEGIN
 963: 0175: !-------------------------------------------------------------------------------
 964: 0175: !1            General error                 Module            X(2)  ASC
 965: 0175: !                                           Session number    X(2)  UPD
 966: 0175: !                                           ERR               X(2)  ASC
 967: 0175: !                                           ERRN              X(4)  INT
 968: 0175: !-------------------------------------------------------------------------------
 969: 0175: 
 970: 0175:         MODULE$ = LEFT$(EVENT.UNIQUE.DATA$,2)
 971: 019a: 
 972: 019a:         ! IF user exit module
 973: 019a:         IF LEFT$(MODULE$,1) = "U" THEN BEGIN
 974: 01cc:             MODULE$ = LEFT$(MODULE$,1) +                            \
 975: 0210:                       UNPACK$(RIGHT$(MODULE$,1))
 976: 0210:         ENDIF
 977: 0218: 
 978: 0218:         MODULE.TEXT$ = " in module " + MODULE$ + ". "
 979: 023c: 
 980: 023c:         RETURN.CODE$ =                                              \
 981: 026b:             HEX.TEXT$(UNPACK$(RIGHT$(EVENT.UNIQUE.DATA$,4)))
 982: 026b: 
 983: 026b:         SESS.NUM% = VAL(MID$(EVENT.UNIQUE.DATA$,3,2))
 984: 0294: 
 985: 0294:         RETURN.ERR$ = MID$(EVENT.UNIQUE.DATA$,5,2)
 986: 02bb: 
 987: 02bb:         CODE.TEXT$ = "Error code is " + RETURN.ERR$ + ". " +        \
 988: 02f5:                      "Error number is " + RETURN.CODE$ + ". "
 989: 02f5: 
 990: 02f5:         GOSUB GET.SESS.TEXT
 991: 0307: 
 992: 0307:         COMMENT$ = "A general till program error " +                \
 993: 035a:                    "has occurred for till " +                       \
 994: 035a:                    STR$(EVENT.TERMINAL%) +                          \
 995: 035a:                    MODULE.TEXT$ +                                   \
 996: 035a:                    CODE.TEXT$ +                                     \
 997: 035a:                    SESS.TEXT$
 998: 035a: 
 999: 035a:     ENDIF ELSE IF EVENT.NUMBER% = 2 THEN BEGIN
1000: 036f: 
1001: 036f:     ENDIF ELSE IF EVENT.NUMBER% = 7 THEN BEGIN
1002: 0384: 
1003: 0384:     ENDIF ELSE IF EVENT.NUMBER% = 10 THEN BEGIN
1004: 0399: 
1005: 0399:     ENDIF ELSE IF EVENT.NUMBER% = 63 THEN BEGIN
1006: 03ae: !-------------------------------------------------------------------------------
1007: 03ae: !63           Asynchronous error            Module            X(2)  ASC
1008: 03ae: !                                           Session number    X(2)  UPD
1009: 03ae: !                                           ERR               X(2)  ASC
1010: 03ae: !                                           ERRN              X(4)  INT
1011: 03ae: !-------------------------------------------------------------------------------
1012: 03ae: 
1013: 03ae:         MODULE$ = LEFT$(EVENT.UNIQUE.DATA$,2)
1014: 03d3: 
1015: 03d3:         ! IF user exit module
1016: 03d3:         IF LEFT$(MODULE$,1) = "U" THEN BEGIN
1017: 0405:             MODULE$ = LEFT$(MODULE$,1) +                            \
1018: 0449:                       UNPACK$(RIGHT$(MODULE$,1))
1019: 0449:         ENDIF
1020: 0451: 
1021: 0451:         MODULE.TEXT$ = " in module " + MODULE$ + ". "
1022: 0475: 
1023: 0475:         RETURN.CODE$ =                                              \
1024: 04a4:             HEX.TEXT$(UNPACK$(RIGHT$(EVENT.UNIQUE.DATA$,4)))
1025: 04a4: 
1026: 04a4:         SESS.NUM% = VAL(MID$(EVENT.UNIQUE.DATA$,3,2))
1027: 04cd: 
1028: 04cd:         RETURN.ERR$ = MID$(EVENT.UNIQUE.DATA$,5,2)
1029: 04f4: 
1030: 04f4:         CODE.TEXT$ = "Error code is " +                             \
1031: 052e:                      RETURN.ERR$ + ". " +                           \
1032: 052e:                      "Error number is " +                           \
1033: 052e:                      RETURN.CODE$ + ". "
1034: 052e: 
1035: 052e:         GOSUB GET.SESS.TEXT
1036: 0540: 
1037: 0540:         COMMENT$ = "An asynchronous till program error " +          \
1038: 0593:                    "has occurred for till " +                       \
1039: 0593:                    STR$(EVENT.TERMINAL%) +                          \
1040: 0593:                    MODULE.TEXT$ +                                   \
1041: 0593:                    CODE.TEXT$ +                                     \
1042: 0593:                    SESS.TEXT$
1043: 0593: 
1044: 0593:     ENDIF ELSE IF EVENT.NUMBER% = 150 THEN BEGIN
1045: 05a6: !-------------------------------------------------------------------------------
1046: 05a6: !150          CCM Invites printed           Seq No            X(4)  ASC
1047: 05a6: !                                           Till No           X(3)  ASC
1048: 05a6: !                                           Batch Size        X(3)  ASC
1049: 05a6: !-------------------------------------------------------------------------------
1050: 05a6:         COMMENT$ = "CCM invites printed."
1051: 05c0: 
1052: 05c0:     ENDIF ELSE IF EVENT.NUMBER% = 200 THEN BEGIN
1053: 05d3: !-------------------------------------------------------------------------------
1054: 05d3: !200          Till only: Discount motor     Motor key value   X(1)  INT
1055: 05d3: !             keys were used.
1056: 05d3: !-------------------------------------------------------------------------------
1057: 05d3:         COMMENT$ = "Discount motor keys were used."
1058: 05ed: 
1059: 05ed:     ENDIF ELSE IF EVENT.NUMBER% = 202 THEN BEGIN
1060: 0600: !-------------------------------------------------------------------------------
1061: 0600: !202          Till only: Keyboard locked    State number      X(?)  ASC
1062: 0600: !             in main wait loop.  Unlocked. Colon delimiter
1063: 0600: !                                           Txn flag          X(?)  ASC
1064: 0600: !-------------------------------------------------------------------------------
1065: 0600:         COMMENT$ = "Keyboard locked in main wait loop. Unlocked."
1066: 061a: 
1067: 061a:     ENDIF ELSE IF EVENT.NUMBER% = 203 THEN BEGIN
1068: 062d: !-------------------------------------------------------------------------------
1069: 062d: !203          Till has detected CHECK       Filler            X(10) ASC
1070: 062d: !             SIGNATURE problem and has
1071: 062d: !             attempted to recover.
1072: 062d: !-------------------------------------------------------------------------------
1073: 062d:         COMMENT$ = "Till has detected CHECK SIGNATURE " +           \
1074: 064e:                    "problem and has attempted to recover."
1075: 064e: 
1076: 064e:     ENDIF ELSE IF EVENT.NUMBER% = 204 THEN BEGIN
1077: 0661: !-------------------------------------------------------------------------------
1078: 0661: !204          Till: Invalid checksum in     TMP message       X(10) ASC
1079: 0661: !             TMP message received.
1080: 0661: !-------------------------------------------------------------------------------
1081: 0661:         COMMENT$ = "Invalid checksum in TMP message received."
1082: 067b: 
1083: 067b:     ENDIF ELSE IF EVENT.NUMBER% = 205 THEN BEGIN
1084: 068e: !-------------------------------------------------------------------------------
1085: 068e: !205          Till: Timeout waiting for     TMP message       X(10) ASC
1086: 068e: !             TMP message.
1087: 068e: !-------------------------------------------------------------------------------
1088: 068e:         COMMENT$ = "Timeout waiting for TMP message."
1089: 06a8: 
1090: 06a8:     ENDIF ELSE IF EVENT.NUMBER% = 206 THEN BEGIN
1091: 06bb: !-------------------------------------------------------------------------------
1092: 06bb: !206          Till: Invalid sequence number TMP message       X(10) ASC
1093: 06bb: !             in  TMP message.
1094: 06bb: !-------------------------------------------------------------------------------
1095: 06bb:         COMMENT$ = "Invalid sequence number in TMP message."
1096: 06d5: 
1097: 06d5:     ENDIF ELSE IF EVENT.NUMBER% = 208 THEN BEGIN
1098: 06e8: !-------------------------------------------------------------------------------
1099: 06e8: !208          Till: Invalid TMP command     TMP message       X(10) ASC
1100: 06e8: !-------------------------------------------------------------------------------
1101: 06e8:         COMMENT$ = "Invalid TMP command."
1102: 0702: 
1103: 0702:     ENDIF ELSE IF EVENT.NUMBER% = 212 THEN BEGIN
1104: 0718: !-------------------------------------------------------------------------------
1105: 0718: !212          TOF module error              Module            X(2)  ASC
1106: 0718: !                                           Session number    X(2)  UPD
1107: 0718: !                                           ERR               X(2)  ASC
1108: 0718: !                                           ERRN              X(4)  INT
1109: 0718: !             OR
1110: 0718: !             Till software version         Version           X(10) ASC
1111: 0718: !-------------------------------------------------------------------------------
1112: 0718: 
1113: 0718:         MODULE$ = LEFT$(EVENT.UNIQUE.DATA$,2)
1114: 073d:         SESS.TEXT$ = MID$(EVENT.UNIQUE.DATA$,3,2)                       !DMW
1115: 0762: 
1116: 0762: !!!!!!!!! IF error in TOF module EALGAT1C                               !DMW
1117: 0762: !!!!!!!!IF MODULE$ = "T1" THEN BEGIN                                    !DMW
1118: 0762:         ! IF TOF error                                                  !DMW
1119: 0762:         IF SESS.TEXT$ = "02" AND                                    \   !DMW
1120: 07d4:            (MODULE$ = "T1" OR MODULE$ = "S2") THEN BEGIN                !DMW
1121: 07d4: 
1122: 07d4:             MODULE.TEXT$ = " in module " + MODULE$ + ". "
1123: 07f8: 
1124: 07f8:             RETURN.CODE$ =                                          \
1125: 0827:                 HEX.TEXT$(UNPACK$(RIGHT$(EVENT.UNIQUE.DATA$,4)))
1126: 0827: 
1127: 0827:             SESS.NUM% = VAL(MID$(EVENT.UNIQUE.DATA$,3,2))
1128: 0850: 
1129: 0850:             RETURN.ERR$ = MID$(EVENT.UNIQUE.DATA$,5,2)
1130: 0877: 
1131: 0877:             CODE.TEXT$ = "Error code is " +                         \
1132: 08b1:                          RETURN.ERR$ + ". " +                       \
1133: 08b1:                          "Error number is " +                       \
1134: 08b1:                          RETURN.CODE$ + ". "
1135: 08b1: 
1136: 08b1:             GOSUB GET.SESS.TEXT
1137: 08c3: 
1138: 08c3:             COMMENT$ = "A TOF till program error " +                \
1139: 0916:                        "has occurred for till " +                   \
1140: 0916:                        STR$(EVENT.TERMINAL%) +                      \
1141: 0916:                        MODULE.TEXT$ +                               \
1142: 0916:                        CODE.TEXT$ +                                 \
1143: 0916:                        SESS.TEXT$
1144: 0916: 
1145: 0916:         ENDIF ELSE BEGIN
1146: 091e: 
1147: 091e:             VERSION$ = EVENT.UNIQUE.DATA$
1148: 093a:             CALL RTRIMC(VERSION$,0)
1149: 0963: 
1150: 0963:             COMMENT$ = "Till program has started " +                \
1151: 0991:                        "following a reload. " +                     \
1152: 0991:                        "Software version is " +                     \
1153: 0991:                        VERSION$ + "."
1154: 0991: 
1155: 0991:         ENDIF
1156: 099c: 
1157: 099c:     ENDIF ELSE IF EVENT.NUMBER% = 219 THEN BEGIN
1158: 09af: !-------------------------------------------------------------------------------
1159: 09af: !219          Till. Number of BOOTS.COM     BOOTS.COM prices  X(2)  UPD
1160: 09af: !             prices does not match num of  BOOTS.COM items   X(2)  UPD
1161: 09af: !             BOOTS.COM items.              Filler            X(6)
1162: 09af: !-------------------------------------------------------------------------------
1163: 09af:         COMMENT$ = "Number of Boots.com prices does " +             \
1164: 09d0:                    "not match number of Boots.com items."
1165: 09d0:     
1166: 09d0:     ENDIF ELSE IF EVENT.NUMBER% = 225 THEN BEGIN                        !BMW
1167: 09e6: !-----------------------------------------------------------------------!BMW
1168: 09e6: !225          GCMPRICE file error           BIN range         X(3)  UPD !BMW
1169: 09e6: !                                           Bar code          X(6)  UPD !BMW
1170: 09e6: !                                           Filler            X(1)      !BMW
1171: 09e6: !-----------------------------------------------------------------------!BMW
1172: 09e6:         BIN.RANGE$ = UNPACK$(LEFT$(EVENT.UNIQUE.DATA$,3))               !BMW
1173: 0a10:         BAR.CODE$  = UNPACK$(MID$(EVENT.UNIQUE.DATA$,4,6))              !BMW
1174: 0a3a:                                                                         !BMW
1175: 0a3a:         CODE.TEXT$ = ""                                                 !BMW
1176: 0a4f:                                                                         !BMW
1177: 0a4f:         ! IF BIN range is specified                                     !BMW
1178: 0a4f:         IF NOT BIN.RANGE$ = STRING$(6,"0") THEN BEGIN                   !BMW
1179: 0a74:             CODE.TEXT$ = CODE.TEXT$ +                               \   !BMW
1180: 0aa0:                          "The BIN range is " + BIN.RANGE$ + ". "        !BMW
1181: 0aa0:         ENDIF                                                           !BMW
1182: 0aa8:                                                                         !BMW
1183: 0aa8:         ! IF bar code is specified                                      !BMW
1184: 0aa8:         IF NOT BAR.CODE$ = STRING$(12,"0") THEN BEGIN                   !BMW
1185: 0acd:             CODE.TEXT$ = CODE.TEXT$ +                               \   !BMW
1186: 0af9:                          "The barcode is " + BAR.CODE$ + ". "           !BMW
1187: 0af9:         ENDIF                                                           !BMW
1188: 0b01:                                                                         !BMW
1189: 0b01:         COMMENT$ = "An error occurred reading a record from " +     \   !BMW
1190: 0b27:                    "the GCMPRICE file. " + CODE.TEXT$                   !BMW
1191: 0b27:                                                                         !BMW
1192: 0b27:     ENDIF
1193: 0b2f: 
1194: 0b2f:     ! IF multiple repeated event log entries
1195: 0b2f:     IF EVENT.COUNT% > 1 THEN BEGIN
1196: 0b41: 
1197: 0b41:         COMMENT$ = COMMENT$ + \
1198: 0b84:                    " This event is repeated " + \
1199: 0b84:                    STR$(EVENT.COUNT%) + " times."
1200: 0b84: 
1201: 0b84:     ENDIF
1202: 0b8c: 
1203: 0b8c:     ! Display event log details
1204: 0b8c:     CALL PSU0406
1205: 0b99: 
1206: 0b99:     EXIT SUB
1207: 0ba4: 
1208: 0ba4: \***********************************************************************
1209: 0ba4: \***
1210: 0ba4: \***    GET.SESS.TEXT
1211: 0ba4: \***
1212: 0ba4: \***********************************************************************
1213: 0ba4: GET.SESS.TEXT:
1214: 0bb4: 
1215: 0bb4:     IF SESS.NUM% <> 0 THEN BEGIN
1216: 0bc3:         SESS.TEXT$ = "File session number is " + \
1217: 0c14:                      STR$(SESS.NUM%) + \
1218: 0c14:                      " (" + TS$(SESS.NUM%) + "). "
1219: 0c14:     ENDIF ELSE BEGIN
1220: 0c1c:         SESS.TEXT$ = "No file session number was logged. "
1221: 0c31:     ENDIF
1222: 0c39: 
1223: 0c39:     RETURN
1224: 0c49: 
1225: 0c49: END SUB
1226: 0c5d: 
1227: 0c5d: End of Compilation
