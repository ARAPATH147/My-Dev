   1: 0000: \***********************************************************************
   2: 0000: \***********************************************************************
   3: 0000: \***
   4: 0000: \***    PROGRAM         :       PSU04
   5: 0000: \***    DESCRIPTION     :       Event log viewer utility
   6: 0000: \***    AUTHOR          :       Mark Walker
   7: 0000: \***    DATE            :       26th September 2017
   8: 0000: \***
   9: 0000: \***********************************************************************
  10: 0000: \***********************************************************************
  11: 0000: \***
  12: 0000: \***    Module 5 contains handling for all display manager screen flow,
  13: 0000: \***    including the initial search parameter selection screen,
  14: 0000: \***    summary screen, event log file lists and selection lists.
  15: 0000: \***
  16: 0000: \***********************************************************************
  17: 0000: \***********************************************************************
  18: 0000: \***
  19: 0000: \***    MODIFICATIONS
  20: 0000: \***
  21: 0000: \***    Version A.          Mark Walker                 26th Sep 2017
  22: 0000: \***    Initial version.
  23: 0000: \***
  24: 0000: \***    Version B.          Mark Walker                  2nd Nov 2017
  25: 0000: \***    - Correctly re-initialised the 'session found' flag. This was
  26: 0000: \***      causing a command mode session search to be incorrectly
  27: 0000: \***      matched for a previous search on a different 'start of 
  28: 0000: \***      command session' event.
  29: 0000: \***    - Renamed flie list variables for consistency reasons.
  30: 0000: \***    - Added support for the source selection list.
  31: 0000: \***
  32: 0000: \***    Version C.          Mark Walker                  6th Nov 2017
  33: 0000: \***    - Updated handling of bucket and source text descriptions.
  34: 0000: \***    - Use fast byte matching routine instead of MATCH statement
  35: 0000: \***      for performance reasons.
  36: 0000: \***
  37: 0000: \***    Version D.          Mark Walker                  7th Nov 2017
  38: 0000: \***    Corrected display of terminal selection text being corrupted
  39: 0000: \***    when a single controller ID is selected.
  40: 0000: \***
  41: 0000: \***    Version E.          Mark Walker                 14th Nov 2017
  42: 0000: \***    Added support for local command line log files.
  43: 0000: \***
  44: 0000: \***    Version F.          Mark Walker                 21st Nov 2017
  45: 0000: \***    - Added support for the UTILS session screen to display
  46: 0000: \***      manual file sector updates.
  47: 0000: \***    - Renamed command session variables for consistency reasons.
  48: 0000: \***
  49: 0000: \***    Version G.          Mark Walker                 21st Nov 2017
  50: 0000: \***    - When searching for a matching command mode session, only
  51: 0000: \***      use the last 4 hex digits of the process ID.
  52: 0000: \***
  53: 0000: \***    Version H.          Mark Walker                  4th Dec 2017
  54: 0000: \***    - Added a refresh option on the summary screen to allow new
  55: 0000: \***      events to be displayed for the active event log without
  56: 0000: \***      having to keep returning to the selection screen.
  57: 0000: \***
  58: 0000: \***    Version I.          Mark Walker                  6th Dec 2017
  59: 0000: \***    - Added a pairing toggle option on the summary screen to
  60: 0000: \***      identify a matching start/end program event.
  61: 0000: \***    - Added a message when no new events are available using the
  62: 0000: \***      refresh option on the summary screen.
  63: 0000: \***    - Relocated functions to an external subprogram due to code
  64: 0000: \***      module size limit being reached.
  65: 0000: \***    - Relocated local functions to another module and made
  66: 0000: \***      public due to the code module size limit being reached.
  67: 0000: \***
  68: 0000: \***    Version J.          Mark Walker                  6th Dec 2017
  69: 0000: \***    - Open non-active event log files as locked with a buffer
  70: 0000: \***      size specified for optimal performance reasons.
  71: 0000: \***    - Relocated further local functions to another module and
  72: 0000: \***      made public due to the code module size limit being reached
  73: 0000: \***      again!
  74: 0000: \***
  75: 0000: \***    Version K.          Mark Walker                 19th Mar 2018
  76: 0000: \***    - Added support for reporting application events logged by
  77: 0000: \***      text file editor applications.
  78: 0000: \***    - Fixed issue with command sessions not being displayed
  79: 0000: \***      correctly if multiple occurrences of the same PID are
  80: 0000: \***      found for a command mode session.
  81: 0000: \***    - Relocated further local functions to another module and
  82: 0000: \***      made public due to the code module size limit being reached
  83: 0000: \***      again!!
  84: 0000: \***
  85: 0000: \***********************************************************************
  86: 0000: \***********************************************************************
  87: 0000: 
  88: 0000: \***********************************************************************
  89: 0000: \***
  90: 0000: \***    Global variable declarations
  91: 0000: \***
  92: 0000: \***********************************************************************
  93: 0000: 
  94: 0000: %INCLUDE PSBF39G.J86    ! Display Manager
  95: 0000: !******************************************************************************
  96: 0000: !******************************************************************************
  97: 0000: !***
  98: 0000: !***            PROGRAM         :       PSBF39G.J86
  99: 0000: !***
 100: 0000: !***            DESCRIPTION     :       DISPLAY MANAGER INTERFACE
 101: 0000: !***
 102: 0000: !***            AUTHOR          :       Stuart William McConnachie
 103: 0000: !***            DATE WRITTEN    :       September 2000
 104: 0000: !***
 105: 0000: !***        Provides a much needed and easier to use interface to
 106: 0000: !***        IBM Display Manager.
 107: 0000: !***
 108: 0000: !***        Saves the user having to set up, highlight, tab between and
 109: 0000: !***        validate fields.  Also handles the help screens and conversion
 110: 0000: !***        of date fields to external/internal format.
 111: 0000: !***
 112: 0000: !***    VERSION A           Mark Walker                         17 OCT 2017
 113: 0000: !***    - Added support for optionally moving to the top of the first page
 114: 0000: !***      or the bottom of the last page using the HOME and END buttons
 115: 0000: !***      respectively.
 116: 0000: !***
 117: 0000: !******************************************************************************
 118: 0000: !******************************************************************************
 119: 0000: 
 120: 0000:     STRING GLOBAL       MESSAGE$(1)
 121: 0000:     STRING GLOBAL       VALID$(1)
 122: 0000:     STRING GLOBAL       VISIBLE$(1)
 123: 0000:     STRING GLOBAL       FIELD$(1)
 124: 0000:     STRING GLOBAL       TITLE$
 125: 0000: 
 126: 0000:     INTEGER*2 GLOBAL    DM.SCREEN%
 127: 0000:     INTEGER*2 GLOBAL    DM.FIELD%
 128: 0000: 
 129: 0000:     INTEGER*2 GLOBAL    HOME.KEY%
 130: 0000:     INTEGER*2 GLOBAL    END.KEY%
 131: 0000:     INTEGER*2 GLOBAL    PGUP.KEY%
 132: 0000:     INTEGER*2 GLOBAL    PGDN.KEY%
 133: 0000:     INTEGER*2 GLOBAL    TAB.KEY%
 134: 0000:     INTEGER*2 GLOBAL    BTAB.KEY%
 135: 0000:     INTEGER*2 GLOBAL    UP.KEY%
 136: 0000:     INTEGER*2 GLOBAL    DOWN.KEY%
 137: 0000:     INTEGER*2 GLOBAL    ESC.KEY%
 138: 0000:     INTEGER*2 GLOBAL    ENTER.KEY%
 139: 0000:     INTEGER*2 GLOBAL    INS.KEY%
 140: 0000:     INTEGER*2 GLOBAL    PREV.KEY%
 141: 0000:     INTEGER*2 GLOBAL    NEXT.KEY%
 142: 0000: 
 143: 0000:     INTEGER*2 GLOBAL    F1.KEY%
 144: 0000:     INTEGER*2 GLOBAL    F2.KEY%
 145: 0000:     INTEGER*2 GLOBAL    F3.KEY%
 146: 0000:     INTEGER*2 GLOBAL    F4.KEY%
 147: 0000:     INTEGER*2 GLOBAL    F5.KEY%
 148: 0000:     INTEGER*2 GLOBAL    F6.KEY%
 149: 0000:     INTEGER*2 GLOBAL    F7.KEY%
 150: 0000:     INTEGER*2 GLOBAL    F8.KEY%
 151: 0000:     INTEGER*2 GLOBAL    F9.KEY%
 152: 0000:     INTEGER*2 GLOBAL    F10.KEY%
 153: 0000: 
 154: 0000:     INTEGER*2 GLOBAL    TOP.KEY%                                        !AMW
 155: 0000:     INTEGER*2 GLOBAL    BOTTOM.KEY%                                     !AMW
 156: 0000:     INTEGER*2 GLOBAL    INVALID.KEY%                                    !AMW
 157: 0000: 
 158: 0000: !******************************************************************************
 159: 0000: 
 160: 0000: %INCLUDE PSBF49G.J86    ! File check
 161: 0000: \******************************************************************************
 162: 0000: \******************************************************************************
 163: 0000: \***
 164: 0000: \***            PROGRAM         :       PSBF49
 165: 0000: \***            MODULE          :       PSBF49G (Global declarations)
 166: 0000: \***            AUTHOR          :       Tittoo Thomas
 167: 0000: \***            DATE WRITTEN    :       October 2013
 168: 0000: \***
 169: 0000: \******************************************************************************
 170: 0000: \***
 171: 0000: \***   Global definitions if any for the re-usable functions included in
 172: 0000: \***   PSBF49
 173: 0000: \***
 174: 0000: \******************************************************************************
 175: 0000: \******************************************************************************
 176: 0000: \***
 177: 0000: \***   VERSION A                    Tittoo Thomas                    7 Oct 2013
 178: 0000: \***   Initial version.
 179: 0000: \***
 180: 0000: \******************************************************************************
 181: 0000: \******************************************************************************
 182: 0000: 
 183: 0000: INTEGER*1 GLOBAL  ADDITIONAL.ELEMENTS%   ! Overflow of elements in delimited
 184: 0000:                                          ! string
 185: 0000: STRING    GLOBAL  DELIM.STR.ELEMENTS$(1) ! Holds data from parsed delim strngs
 186: 0000: 
 187: 0000: 
 188: 0000: %INCLUDE PSU04G.J86
 189: 0000: \***********************************************************************
 190: 0000: \***********************************************************************
 191: 0000: \***
 192: 0000: \***    GLOBAL VARIABLE DEFINITIONS FOR PSU04
 193: 0000: \***
 194: 0000: \***********************************************************************
 195: 0000: \***********************************************************************
 196: 0000: \***
 197: 0000: \***    MODIFICATIONS
 198: 0000: \***
 199: 0000: \***    Version A.          Mark Walker                 26th Sep 2017
 200: 0000: \***    Initial version.
 201: 0000: \***
 202: 0000: \***    Version B.          Mark Walker                  2nd Nov 2017
 203: 0000: \***    Added support for the source selection list.
 204: 0000: \***
 205: 0000: \***    Version C.          Mark Walker                  6th Nov 2017
 206: 0000: \***    Updated handling of bucket and source text descriptions.
 207: 0000: \***
 208: 0000: \***    Version D.          Mark Walker                 21st Nov 2017
 209: 0000: \***    Added support for the UTILS session screen.
 210: 0000: \***
 211: 0000: \***    Version E.          Mark Walker                  6th Dec 2017
 212: 0000: \***    Moved some local variables to globals to support moving
 213: 0000: \***    some functions from the main screen handling module to
 214: 0000: \***    an external subprogram.
 215: 0000: \***
 216: 0000: \***    Version F.          Mark Walker                 19th Mar 2017
 217: 0000: \***    Added support for reporting application events logged by
 218: 0000: \***    text file editor applications.
 219: 0000: \***
 220: 0000: \***********************************************************************
 221: 0000: \***********************************************************************
 222: 0000: 
 223: 0000:     INTEGER*1 GLOBAL CURRENT.FIELD%                                     !EMW
 224: 0000:     INTEGER*1 GLOBAL FALSE
 225: 0000:     INTEGER*1 GLOBAL OPEN.EVAPP
 226: 0000:     INTEGER*1 GLOBAL TRUE
 227: 0000:     INTEGER*1 GLOBAL U0401.APPLICATION%
 228: 0000:     INTEGER*1 GLOBAL U0401.APPLICATION.STATUS%
 229: 0000:     INTEGER*1 GLOBAL U0401.BUCKET%
 230: 0000:     INTEGER*1 GLOBAL U0401.BUCKET.STATUS%
 231: 0000:     INTEGER*1 GLOBAL U0401.CONTROLLER.ID%
 232: 0000:     INTEGER*1 GLOBAL U0401.CONTROLLER.ID.STATUS%
 233: 0000:     INTEGER*1 GLOBAL U0401.EVENT%
 234: 0000:     INTEGER*1 GLOBAL U0401.EVENT.STATUS%
 235: 0000:     INTEGER*1 GLOBAL U0401.LOG.DESC%
 236: 0000:     INTEGER*1 GLOBAL U0401.LOG.NUMBER%
 237: 0000:     INTEGER*1 GLOBAL U0401.MESSAGE.GROUP%
 238: 0000:     INTEGER*1 GLOBAL U0401.MESSAGE.GROUP.STATUS%
 239: 0000:     INTEGER*1 GLOBAL U0401.MESSAGE.NUMBER%
 240: 0000:     INTEGER*1 GLOBAL U0401.MESSAGE.NUMBER.STATUS%
 241: 0000:     INTEGER*1 GLOBAL U0401.SEVERITY%
 242: 0000:     INTEGER*1 GLOBAL U0401.SEVERITY.STATUS%
 243: 0000:     INTEGER*1 GLOBAL U0401.SOURCE%
 244: 0000:     INTEGER*1 GLOBAL U0401.SOURCE.STATUS%
 245: 0000:     INTEGER*1 GLOBAL U0401.TERMINAL%
 246: 0000:     INTEGER*1 GLOBAL U0401.TERMINAL.STATUS%
 247: 0000:     INTEGER*1 GLOBAL U0402.PAGE%
 248: 0000:     INTEGER*1 GLOBAL U0405.PAGE%
 249: 0000:     INTEGER*1 GLOBAL U0406.PAGE%
 250: 0000:     INTEGER*1 GLOBAL U0411.PAGE%                                        !BMW
 251: 0000:     INTEGER*1 GLOBAL U0412.PAGE%                                        !DMW
 252: 0000:     INTEGER*1 GLOBAL VALID.INPUT
 253: 0000:     INTEGER*1 GLOBAL VALID.KEY
 254: 0000: 
 255: 0000:     INTEGER*2 GLOBAL APPLICATIONS.PER.PAGE%
 256: 0000:     INTEGER*2 GLOBAL COMMAND.TIME.RANGE%
 257: 0000:     INTEGER*2 GLOBAL COMMANDS.PER.PAGE%
 258: 0000:     INTEGER*2 GLOBAL CURRENT.INDEX%                                     !EMW
 259: 0000:     INTEGER*2 GLOBAL CURRENT.REPORT.NUM%
 260: 0000:     INTEGER*2 GLOBAL EVENT.BUCKET%
 261: 0000:     INTEGER*2 GLOBAL EVENT.COUNT%
 262: 0000:     INTEGER*2 GLOBAL EVENT.DAY%
 263: 0000:     INTEGER*2 GLOBAL EVENT.FORMAT%
 264: 0000:     INTEGER*2 GLOBAL EVENT.HOUR%
 265: 0000:     INTEGER*2 GLOBAL EVENT.MESSAGE.NUMBER%
 266: 0000:     INTEGER*2 GLOBAL EVENT.MIN%
 267: 0000:     INTEGER*2 GLOBAL EVENT.MONTH%
 268: 0000:     INTEGER*2 GLOBAL EVENT.NODE.ID%
 269: 0000:     INTEGER*2 GLOBAL EVENT.NUMBER%
 270: 0000:     INTEGER*2 GLOBAL EVENT.SEVERITY%
 271: 0000:     INTEGER*2 GLOBAL EVENT.SOURCE%
 272: 0000:     INTEGER*2 GLOBAL EVENT.TERMINAL%
 273: 0000:     INTEGER*2 GLOBAL EVENT.YEAR%
 274: 0000:     INTEGER*2 GLOBAL FILES.PER.PAGE%
 275: 0000:     INTEGER*2 GLOBAL LINE.LENGTH%
 276: 0000:     INTEGER*2 GLOBAL MAX.FILE.RECORDS%
 277: 0000:     INTEGER*2 GLOBAL MAX.SOURCE.RECORDS%                                !BMW
 278: 0000:     INTEGER*2 GLOBAL NULL.MAPPING%                                      !BMW
 279: 0000:     INTEGER*2 GLOBAL RESULTS.COUNT%                                     !EMW
 280: 0000:     INTEGER*2 GLOBAL RESULTS.INDEX%                                     !EMW
 281: 0000:     INTEGER*2 GLOBAL RESULTS.LAST.PAGE%                                 !EMW
 282: 0000:     INTEGER*2 GLOBAL RESULTS.PAGE%                                      !EMW
 283: 0000:     INTEGER*2 GLOBAL RESULTS.PER.PAGE%
 284: 0000:     INTEGER*2 GLOBAL RESULTS.THIS.PAGE%                                 !EMW
 285: 0000:     INTEGER*2 GLOBAL RESULTS.TOTAL.PAGES%                               !EMW
 286: 0000:     INTEGER*2 GLOBAL SOURCES.PER.PAGE%                                  !BMW
 287: 0000:     INTEGER*2 GLOBAL ULOG.REPORT.NUM%                                   !DMW
 288: 0000:     INTEGER*2 GLOBAL ULOG.SESS.NUM%                                     !DMW
 289: 0000: 
 290: 0000:     INTEGER*4 GLOBAL EVENT.DATE%
 291: 0000:     INTEGER*4 GLOBAL EVENT.TIME%
 292: 0000: 
 293: 0000:     STRING GLOBAL ALL.APPLICATIONS.TEXT$
 294: 0000:     STRING GLOBAL ALL.BUCKETS.TEXT$
 295: 0000:     STRING GLOBAL ALL.CONTROLLERS.TEXT$
 296: 0000:     STRING GLOBAL ALL.EVENTS.TEXT$
 297: 0000:     STRING GLOBAL ALL.MESSAGE.GROUPS.TEXT$
 298: 0000:     STRING GLOBAL ALL.MESSAGE.NUMBERS.TEXT$
 299: 0000:     STRING GLOBAL ALL.SEVERITYS.TEXT$
 300: 0000:     STRING GLOBAL ALL.SOURCES.TEXT$
 301: 0000:     STRING GLOBAL ALL.TERMINALS.TEXT$
 302: 0000:     STRING GLOBAL BATCH.SCREEN.FLAG$
 303: 0000:     STRING GLOBAL BUCKET.TEXT$(1)
 304: 0000:     STRING GLOBAL CHAIN.TO.PROG$
 305: 0000:     STRING GLOBAL COMMENT$
 306: 0000:     STRING GLOBAL CONTROLLER.ID$
 307: 0000:     STRING GLOBAL CURRENT.CODE$
 308: 0000:     STRING GLOBAL DOW$(1)
 309: 0000:     STRING GLOBAL EDITOR.NAME$                                          !FMW
 310: 0000:     STRING GLOBAL EDITOR.PATHNAME$                                      !FMW
 311: 0000:     STRING GLOBAL EDITOR.PROGRAM$                                       !FMW
 312: 0000:     STRING GLOBAL EDITOR.TYPE$                                          !FMW
 313: 0000:     STRING GLOBAL EE$(1)
 314: 0000:     STRING GLOBAL EVENT.DOW$
 315: 0000:     STRING GLOBAL EVENT.MESSAGE.GROUP$
 316: 0000:     STRING GLOBAL EVENT.UNIQUE.DATA$
 317: 0000:     STRING GLOBAL FILE.OPERATION$
 318: 0000:     STRING GLOBAL HIGHWORD.DESCRIPTION$(1)
 319: 0000:     STRING GLOBAL HIGHWORD.ERRORCODE$(1)
 320: 0000:     STRING GLOBAL LA$(1)
 321: 0000:     STRING GLOBAL LE$(1)
 322: 0000:     STRING GLOBAL LJ$(1)
 323: 0000:     STRING GLOBAL LOG.DESC$
 324: 0000:     STRING GLOBAL LOG.NUMBER$
 325: 0000:     STRING GLOBAL LOWWORD.DESCRIPTION$(1)
 326: 0000:     STRING GLOBAL LOWWORD.ERRORCODE$(1)
 327: 0000:     STRING GLOBAL LW$(1)
 328: 0000:     STRING GLOBAL MESSAGE.TEXT$
 329: 0000:     STRING GLOBAL MODULE.NUMBER$
 330: 0000:     STRING GLOBAL NO.APPLICATIONS.TEXT$
 331: 0000:     STRING GLOBAL NO.BUCKETS.TEXT$
 332: 0000:     STRING GLOBAL NO.SEVERITYS.TEXT$
 333: 0000:     STRING GLOBAL NO.SOURCES.TEXT$                                      !BMW
 334: 0000:     STRING GLOBAL NONPRINTABLE.CHARS$
 335: 0000:     STRING GLOBAL NONPRINTABLE.MAP$
 336: 0000:     STRING GLOBAL NULL.FILENAME$
 337: 0000:     STRING GLOBAL NULL.PROGRAM$
 338: 0000:     STRING GLOBAL PID$
 339: 0000:     STRING GLOBAL PRINTABLE.CHARS$
 340: 0000:     STRING GLOBAL PROGRAM$
 341: 0000:     STRING GLOBAL R$(1)
 342: 0000:     STRING GLOBAL RETURN.CODE$
 343: 0000:     STRING GLOBAL RETURN.ERR$
 344: 0000:     STRING GLOBAL SE$(1)
 345: 0000:     STRING GLOBAL SELECTED.APPLICATIONS.TEXT$
 346: 0000:     STRING GLOBAL SELECTED.BUCKETS.TEXT$
 347: 0000:     STRING GLOBAL SELECTED.SEVERITYS.TEXT$
 348: 0000:     STRING GLOBAL SELECTED.SOURCES.TEXT$                                !BMW
 349: 0000:     STRING GLOBAL SEVERITY.TEXT$(1)
 350: 0000:     STRING GLOBAL SINGLE.APPLICATION.TEXT$
 351: 0000:     STRING GLOBAL SINGLE.BUCKET.TEXT$
 352: 0000:     STRING GLOBAL SINGLE.CONTROLLER.TEXT$
 353: 0000:     STRING GLOBAL SINGLE.EVENT.TEXT$
 354: 0000:     STRING GLOBAL SINGLE.MESSAGE.GROUP.TEXT$
 355: 0000:     STRING GLOBAL SINGLE.MESSAGE.NUMBER.TEXT$
 356: 0000:     STRING GLOBAL SINGLE.SEVERITY.TEXT$
 357: 0000:     STRING GLOBAL SINGLE.SOURCE.TEXT$
 358: 0000:     STRING GLOBAL SINGLE.TERMINAL.TEXT$
 359: 0000:     STRING GLOBAL SUMMARY.RECORD$(1)                                    !EMW
 360: 0000:     STRING GLOBAL SOURCE.TEXT$(1)                                       !CMW
 361: 0000:     STRING GLOBAL SS$(1)
 362: 0000:     STRING GLOBAL SW$(1)
 363: 0000:     STRING GLOBAL TILL.NUMBER$
 364: 0000:     STRING GLOBAL TS$(1)
 365: 0000:     STRING GLOBAL ULOG.FILE.NAME$                                       !DMW
 366: 0000:     STRING GLOBAL ULOG.RECORD$(1)                                       !EMW
 367: 0000: 
 368: 0000: %INCLUDE EVLOGDEC.J86
 369: 0000: \***********************************************************************
 370: 0000: \***********************************************************************
 371: 0000: \***
 372: 0000: \***    GLOBAL VARIABLE DEFINITIONS FOR EVENT LOG FILE (EVLOG)
 373: 0000: \***
 374: 0000: \***********************************************************************
 375: 0000: \***********************************************************************
 376: 0000: \***
 377: 0000: \***    MODIFICATIONS
 378: 0000: \***
 379: 0000: \***    Version A.          Mark Walker                 26th Sep 2017
 380: 0000: \***    Initial version.
 381: 0000: \***
 382: 0000: \***********************************************************************
 383: 0000: \***********************************************************************
 384: 0000: 
 385: 0000:     INTEGER*1 GLOBAL EVLOG.BUCKET%
 386: 0000:     INTEGER*1 GLOBAL EVLOG.FORMAT%
 387: 0000: 
 388: 0000:     INTEGER*2 GLOBAL EVLOG.COUNT%
 389: 0000:     INTEGER*2 GLOBAL EVLOG.MAX.FILES%
 390: 0000:     INTEGER*2 GLOBAL EVLOG.MAX.RECORDS%
 391: 0000:     INTEGER*2 GLOBAL EVLOG.RECL%
 392: 0000:     INTEGER*2 GLOBAL EVLOG.SESS.NUM%
 393: 0000:     INTEGER*2 GLOBAL EVLOG.REPORT.NUM%
 394: 0000: 
 395: 0000:     INTEGER*4 GLOBAL EVLOG.RECORD.NUMBER%
 396: 0000:     INTEGER*4 GLOBAL EVLOG.FILE.SIZE%
 397: 0000:     INTEGER*4 GLOBAL EVLOG.WAIT%
 398: 0000: 
 399: 0000:     STRING GLOBAL EVLOG.FILE.NAME$
 400: 0000:     STRING GLOBAL EVLOG.RECORD$
 401: 0000: 
 402: 0000: %INCLUDE CLLOGDEC.J86
 403: 0000: \***********************************************************************
 404: 0000: \***********************************************************************
 405: 0000: \***
 406: 0000: \***    GLOBAL VARIABLE DEFINITIONS FOR COMMAND LINE LOG FILE (ADXCLLOG)
 407: 0000: \***
 408: 0000: \***********************************************************************
 409: 0000: \***********************************************************************
 410: 0000: \***
 411: 0000: \***    MODIFICATIONS
 412: 0000: \***
 413: 0000: \***    Version A.          Mark Walker                 26th Sep 2017
 414: 0000: \***    Initial version.
 415: 0000: \***
 416: 0000: \***    Version B.          Mark Walker                 14th Nov 2017
 417: 0000: \***    Added support for local command line log files.
 418: 0000: \***
 419: 0000: \***********************************************************************
 420: 0000: \***********************************************************************
 421: 0000: 
 422: 0000:     INTEGER*2 GLOBAL CLLOG.SESS.NUM%
 423: 0000:     INTEGER*2 GLOBAL CLLOG.REPORT.NUM%
 424: 0000:     INTEGER*2 GLOBAL CLLOG.MAX.RECORDS%
 425: 0000: 
 426: 0000:     STRING GLOBAL CLLOG.FILE.NAME$
 427: 0000:     STRING GLOBAL CLLOG.NODE.ID$                                        !BMW
 428: 0000:     STRING GLOBAL CLLOG.RECORD$
 429: 0000: 
 430: 0000: 
 431: 0000:     INTEGER*2 GLOBAL KEY%
 432: 0000: 
 433: 0000: \***********************************************************************
 434: 0000: \***
 435: 0000: \***    Local variable declarations
 436: 0000: \***
 437: 0000: \***********************************************************************
 438: 0000: 
 439: 0000:     INTEGER*1 ALL.CONTROLLER.ID
 440: 0000:     INTEGER*1 ALL.EVENT.MESSAGE.GROUP
 441: 0000:     INTEGER*1 ALL.EVENT.MESSAGE.NUMBER
 442: 0000:     INTEGER*1 ALL.EVENT.NUMBER
 443: 0000:     INTEGER*1 ALL.EVENT.TERMINAL
 444: 0000:     INTEGER*1 APPLICATION.EVENT
 445: 0000:     INTEGER*1 APPLICATION.EXIT.PRESSED
 446: 0000:     INTEGER*1 APPLICATION.FOUND
 447: 0000:     INTEGER*1 BUCKET.EXIT.PRESSED
 448: 0000:     INTEGER*1 BUCKET.FOUND
 449: 0000:     INTEGER*1 CLLOG.RC%
 450: 0000:     INTEGER*1 COMMAND.EXIT.PRESSED                                      !FMW
 451: 0000:     INTEGER*1 COMMAND.SESSION
 452: 0000:     INTEGER*1 DETAIL.EXIT.PRESSED
 453: 0000:     INTEGER*1 END.OF.DATA
 454: 0000:     INTEGER*1 END.OF.FILE
 455: 0000:     INTEGER*1 END.OF.SESSION
 456: 0000:     INTEGER*1 ERROR.COUNT%
 457: 0000:     INTEGER*1 EVLOG.RC%
 458: 0000:     INTEGER*1 FILE.FOUND
 459: 0000:     INTEGER*1 FILE.EXIT.PRESSED                                         !BMW
 460: 0000:     INTEGER*1 REBUILD.INDEX
 461: 0000:     INTEGER*1 SECTOR.FOUND                                              !FMW
 462: 0000:     INTEGER*1 SELECTION.APPLICATION(1)
 463: 0000:     INTEGER*1 SELECTION.BUCKET(1)
 464: 0000:     INTEGER*1 SELECTION.SEVERITY(1)
 465: 0000:     INTEGER*1 SELECTION.SOURCE(1)                                       !BMW
 466: 0000:     INTEGER*1 SELECTION.CURRENT.FIELD%
 467: 0000:     INTEGER*1 SELECTION.EXIT.PRESSED
 468: 0000:     INTEGER*1 SELECTION.QUIT.CONFIRM
 469: 0000:     INTEGER*1 SELECTION.TERMINAL(1)
 470: 0000:     INTEGER*1 SESSION.FOUND
 471: 0000:     INTEGER*1 SEVERITY.EXIT.PRESSED
 472: 0000:     INTEGER*1 SEVERITY.FOUND
 473: 0000:     INTEGER*1 SOURCE.EXIT.PRESSED                                       !BMW
 474: 0000:     INTEGER*1 SOURCE.FOUND                                              !BMW
 475: 0000:     INTEGER*1 SUMMARY.EXIT.PRESSED
 476: 0000:     INTEGER*1 ULOG.RC%                                                  !FMW
 477: 0000:     INTEGER*1 UTILS.EXIT.PRESSED                                        !FMW
 478: 0000:     INTEGER*1 UTILS.SESSION                                             !FMW
 479: 0000: 
 480: 0000:     INTEGER*2 APPLICATION.COUNT%
 481: 0000:     INTEGER*2 APPLICATION.END.FIELD%
 482: 0000:     INTEGER*2 APPLICATION.INDEX%
 483: 0000:     INTEGER*2 APPLICATION.LAST.FIELD%
 484: 0000:     INTEGER*2 APPLICATION.LAST.PAGE%
 485: 0000:     INTEGER*2 APPLICATION.PAGE%
 486: 0000:     INTEGER*2 APPLICATION.SELECTED.COUNT%
 487: 0000:     INTEGER*2 APPLICATION.START.FIELD%
 488: 0000:     INTEGER*2 APPLICATION.THIS.PAGE%
 489: 0000:     INTEGER*2 APPLICATION.TOTAL.PAGES%
 490: 0000:     INTEGER*2 BUCKET.COUNT%
 491: 0000:     INTEGER*2 BUCKET.END.FIELD%
 492: 0000:     INTEGER*2 BUCKET.INDEX%
 493: 0000:     INTEGER*2 BUCKET.SELECTED.COUNT%
 494: 0000:     INTEGER*2 BUCKET.START.FIELD%
 495: 0000:     INTEGER*2 COMMAND.COUNT%
 496: 0000:     INTEGER*2 COMMAND.END.FIELD%                                        !FMW
 497: 0000:     INTEGER*2 COMMAND.INDEX%
 498: 0000:     INTEGER*2 COMMAND.LAST.FIELD%                                       !FMW
 499: 0000:     INTEGER*2 COMMAND.LAST.PAGE%
 500: 0000:     INTEGER*2 COMMAND.PAGE%
 501: 0000:     INTEGER*2 COMMAND.START.FIELD%                                      !FMW
 502: 0000:     INTEGER*2 COMMAND.THIS.PAGE%
 503: 0000:     INTEGER*2 COMMAND.TOTAL.PAGES%
 504: 0000:     INTEGER*2 DETAIL.END.FIELD%
 505: 0000:     INTEGER*2 DETAIL.START.FIELD%
 506: 0000:     INTEGER*2 FIELD.INDEX%
 507: 0000:     INTEGER*2 FILE.COUNT%                                               !BMW
 508: 0000:     INTEGER*2 FILE.END.FIELD%                                           !BMW
 509: 0000:     INTEGER*2 FILE.INDEX%                                               !BMW
 510: 0000:     INTEGER*2 FILE.LAST.FIELD%                                          !BMW
 511: 0000:     INTEGER*2 FILE.LAST.PAGE%                                           !BMW
 512: 0000:     INTEGER*2 FILE.MAP%(1)                                              !CMW
 513: 0000:     INTEGER*2 FILE.PAGE%                                                !BMW
 514: 0000:     INTEGER*2 FILE.START.FIELD%                                         !BMW
 515: 0000:     INTEGER*2 FILE.THIS.PAGE%                                           !BMW
 516: 0000:     INTEGER*2 FILE.TOTAL.PAGES%                                         !BMW
 517: 0000:     INTEGER*2 FIRST.LOG%
 518: 0000:     INTEGER*2 HEADER.COUNT%
 519: 0000:     INTEGER*2 I%
 520: 0000:     INTEGER*2 J%
 521: 0000:     INTEGER*2 LAST.RECORD.NUMBER%
 522: 0000:     INTEGER*2 M%
 523: 0000:     INTEGER*2 MAX.RECORDS%
 524: 0000:     INTEGER*2 RECORD.NUMBER%
 525: 0000:     INTEGER*2 SALESESS.NUM%
 526: 0000:     INTEGER*2 SAVED.FIELD%
 527: 0000:     INTEGER*2 SELECTION.END.FIELD%
 528: 0000:     INTEGER*2 SELECTION.EVENT.MESSAGE.NUMBER%
 529: 0000:     INTEGER*2 SELECTION.EVENT.NUMBER%
 530: 0000:     INTEGER*2 SELECTION.EVENT.TERMINAL%
 531: 0000:     INTEGER*2 SELECTION.START.FIELD%
 532: 0000:     INTEGER*2 SEQ.NUM%                                                  !FMW
 533: 0000:     INTEGER*2 SESS.NUM%
 534: 0000:     INTEGER*2 SESSION.HOUR%
 535: 0000:     INTEGER*2 SESSION.MIN%
 536: 0000:     INTEGER*2 SEVERITY.COUNT%
 537: 0000:     INTEGER*2 SEVERITY.END.FIELD%
 538: 0000:     INTEGER*2 SEVERITY.INDEX%
 539: 0000:     INTEGER*2 SEVERITY.SELECTED.COUNT%
 540: 0000:     INTEGER*2 SEVERITY.START.FIELD%
 541: 0000:     INTEGER*2 SOURCE.COUNT%                                             !BMW
 542: 0000:     INTEGER*2 SOURCE.END.FIELD%                                         !BMW
 543: 0000:     INTEGER*2 SOURCE.INDEX%                                             !BMW
 544: 0000:     INTEGER*2 SOURCE.LAST.FIELD%                                        !BMW
 545: 0000:     INTEGER*2 SOURCE.LAST.PAGE%                                         !BMW
 546: 0000:     INTEGER*2 SOURCE.MAP%(1)                                            !BMW
 547: 0000:     INTEGER*2 SOURCE.PAGE%                                              !BMW
 548: 0000:     INTEGER*2 SOURCE.SELECTED.COUNT%                                    !BMW
 549: 0000:     INTEGER*2 SOURCE.START.FIELD%                                       !BMW
 550: 0000:     INTEGER*2 SOURCE.THIS.PAGE%                                         !BMW
 551: 0000:     INTEGER*2 SOURCE.TOTAL.PAGES%                                       !BMW
 552: 0000:     INTEGER*2 SUMMARY.END.FIELD%
 553: 0000:     INTEGER*2 SUMMARY.LAST.FIELD%
 554: 0000:     INTEGER*2 SUMMARY.START.FIELD%
 555: 0000:     INTEGER*2 TILLSESS.NUM%
 556: 0000:     INTEGER*2 UTILS.PAGE%                                               !FMW
 557: 0000:     INTEGER*2 UTILS.END.FIELD%                                          !FMW
 558: 0000:     INTEGER*2 UTILS.START.FIELD%                                        !FMW
 559: 0000:     INTEGER*2 UTILS.TOTAL.PAGES%                                        !FMW
 560: 0000: 
 561: 0000:     INTEGER*4 ADXSTART.RC%
 562: 0000:     INTEGER*4 LOG.FILE.SIZE%
 563: 0000:     INTEGER*4 LOG.RECORD.COUNT%
 564: 0000: 
 565: 0000:     STRING ACTUAL$
 566: 0000:     STRING APPLICATION.DESC$(1)
 567: 0000:     STRING APPLICATION.RECORD$(1)
 568: 0000:     STRING BUCKET.RECORD$(1)
 569: 0000:     STRING CLLOG.PATH.NAME$                                             !EMW
 570: 0000:     STRING CODE$
 571: 0000:     STRING COMMAND.DATE$
 572: 0000:     STRING COMMAND.RECORD$(1)
 573: 0000:     STRING COMMAND.TIME$
 574: 0000:     STRING DETAIL.RECORD$(1)
 575: 0000:     STRING DTBL.BUFFER$
 576: 0000:     STRING EVENT.DATE$
 577: 0000:     STRING EVENT.END.TIME$
 578: 0000:     STRING EVENT.RECORD$
 579: 0000:     STRING EVENT.START.TIME$
 580: 0000:     STRING EXPECTED$
 581: 0000:     STRING FILE$
 582: 0000:     STRING FILE.INDEX$(1)
 583: 0000:     STRING FILE.RECORD$(1)
 584: 0000:     STRING FIRST.LOG.NUMBER$
 585: 0000:     STRING FLAG$
 586: 0000:     STRING FLAG.TEXT$
 587: 0000:     STRING FUNCTION$
 588: 0000:     STRING IMFOK.FLAG$
 589: 0000:     STRING ITEM.CODE$
 590: 0000:     STRING KEY$
 591: 0000:     STRING KEY.TEXT$
 592: 0000:     STRING LAST.APPLICATION$
 593: 0000:     STRING LAST.BUCKET$
 594: 0000:     STRING LAST.SEVERITY$
 595: 0000:     STRING LAST.SOURCE$                                                 !BMW
 596: 0000:     STRING LINE.NUMBER$
 597: 0000:     STRING LINE.TEXT$
 598: 0000:     STRING LOG.FILE.DATE$
 599: 0000:     STRING LOG.FILE.DAY$
 600: 0000:     STRING LOG.FILE.DOW$
 601: 0000:     STRING LOG.FILE.MONTH$
 602: 0000:     STRING LOG.FILE.NAME$
 603: 0000:     STRING LOG.FILE.TIME$
 604: 0000:     STRING LOG.FILE.YEAR$
 605: 0000:     STRING LOG.RECORD$(1)
 606: 0000:     STRING MATCH.STRING$
 607: 0000:     STRING MESSAGE1$
 608: 0000:     STRING MESSAGE2$
 609: 0000:     STRING MESSAGE3$
 610: 0000:     STRING MODULE$
 611: 0000:     STRING PROGRAM.CHILD$
 612: 0000:     STRING PROGRAM.DATE$
 613: 0000:     STRING PROGRAM.NUMBER$
 614: 0000:     STRING PROGRAM.TIME$
 615: 0000:     STRING REPORT.NAME$
 616: 0000:     STRING REPORT.RECORD$
 617: 0000:     STRING SALESESS.NAME$
 618: 0000:     STRING SALESESS.RECORD$
 619: 0000:     STRING SCREEN$
 620: 0000:     STRING SELECTION.CONTROLLER.ID$
 621: 0000:     STRING SELECTION.EVENT.MESSAGE.GROUP$
 622: 0000:     STRING SELECTION.FIELD$(1)
 623: 0000:     STRING SESS.TEXT$
 624: 0000:     STRING SEVERITY.RECORD$(1)
 625: 0000:     STRING SOURCE.LIST$(1)                                              !BMW
 626: 0000:     STRING SOURCE.RECORD$(1)                                            !BMW
 627: 0000:     STRING T$
 628: 0000:     STRING TILLSESS.NAME$
 629: 0000:     STRING TILLSESS.RECORD$
 630: 0000:     STRING TYPE$
 631: 0000:     STRING U0402.PAGE$
 632: 0000: 
 633: 0000: \***********************************************************************
 634: 0000: \***
 635: 0000: \***    Function definitions
 636: 0000: \***
 637: 0000: \***********************************************************************
 638: 0000: 
 639: 0000: %INCLUDE PSBF24E.J86    ! Standard error detected
 640: 0000: REM \
 641: 0000: \*******************************************************************************
 642: 0000: \*******************************************************************************
 643: 0000: \***
 644: 0000: \***    %INCLUDE FOR EXTERNAL DEFINITION OF STANDARD.ERROR.DETECTED FUNCTION
 645: 0000: \***
 646: 0000: \***                      REFERENCE     : PSBF24E.J86
 647: 0000: \***
 648: 0000: \***    Version A                 Janet Smith                  13th May 1992
 649: 0000: \***
 650: 0000: \*******************************************************************************
 651: 0000: \*******************************************************************************
 652: 0000: 
 653: 0000:    FUNCTION STANDARD.ERROR.DETECTED(ERRN%,                 \
 654: 0000: 				    ERRFILE%,              \
 655: 0000: 				    ERRL%,                 \
 656: 0000: 				    ERR$)        EXTERNAL
 657: 0000: 				    
 658: 0000:           STRING    ERR$
 659: 0000: 
 660: 0000:           INTEGER*2 ERRFILE%,              \
 661: 0000: 	            ERRL%,                 \
 662: 0000: 		    STANDARD.ERROR.DETECTED
 663: 0000: 		    
 664: 0000:           INTEGER*4 ERRN%
 665: 0000: 	  		    
 666: 0000:    END FUNCTION
 667: 0000: 
 668: 0000: 
 669: 0000: %INCLUDE PSBF39E.J86    ! Display Manager
 670: 0000: !******************************************************************************
 671: 0000: !******************************************************************************
 672: 0000: !***
 673: 0000: !***            PROGRAM         :       PSBF39E.J86
 674: 0000: !***
 675: 0000: !***            DESCRIPTION     :       DISPLAY MANAGER INTERFACE
 676: 0000: !***
 677: 0000: !***            AUTHOR          :       Stuart William McConnachie
 678: 0000: !***            DATE WRITTEN    :       September 2000
 679: 0000: !***
 680: 0000: !***        Provides a much needed and easier to use interface to
 681: 0000: !***        IBM Display Manager.
 682: 0000: !***
 683: 0000: !***        Saves the user having to set up, highlight, tab between and
 684: 0000: !***        validate fields.  Also handles the help screens and conversion
 685: 0000: !***        of date fields to external/internal format.
 686: 0000: !***
 687: 0000: !******************************************************************************
 688: 0000: !******************************************************************************
 689: 0000: 
 690: 0000: !******************************************************************************
 691: 0000: !   Initialises the display manager functions.
 692: 0000: !   You should call this from your program initialisation for screen programs.
 693: 0000: !   Note that the name of the display manager file is determined from the
 694: 0000: !   global variable MODULE.NUMBER$.  For example PSB1200 uses PSBD12.dat
 695: 0000: !   where the PSB and 12 have been derived from MODULE.NUMBER$.
 696: 0000: 
 697: 0000:     FUNCTION DM.INIT EXTERNAL
 698: 0000:         INTEGER*1   DM.INIT
 699: 0000:     END FUNCTION
 700: 0000: 
 701: 0000: !******************************************************************************
 702: 0000: !   Quits the display manager program and frees resources.
 703: 0000: !   You should call this from your program termination.
 704: 0000: 
 705: 0000:     FUNCTION DM.QUIT EXTERNAL
 706: 0000:         INTEGER*1   DM.QUIT
 707: 0000:     END FUNCTION
 708: 0000: 
 709: 0000: !******************************************************************************
 710: 0000: !   Initialises a particular screen from the current display manager file
 711: 0000: !   for display.  You supply the screen number, optional title message and
 712: 0000: !   the first and last help screens associated with the display.
 713: 0000: !   Once you have SHOWN a screen, you can use the remaining functions in
 714: 0000: !   this library to set field values, and actually retrieve input from the
 715: 0000: !   screen.  Note that showing a screen just displays it on the screen,
 716: 0000: !   you need to call PROCESS.SCREEN to actually get any user input.
 717: 0000: 
 718: 0000:     FUNCTION DM.SHOW.SCREEN (SCREEN%, TITLE$, FIRST.HELP%, LAST.HELP%) EXTERNAL
 719: 0000:         INTEGER*1   DM.SHOW.SCREEN
 720: 0000:         INTEGER*2   SCREEN%
 721: 0000:         STRING      TITLE$
 722: 0000:         INTEGER*2   FIRST.HELP%
 723: 0000:         INTEGER*2   LAST.HELP%
 724: 0000:     END FUNCTION
 725: 0000: 
 726: 0000: !******************************************************************************
 727: 0000: !   Sets a function key message to visible.  Optionally sets the text on that
 728: 0000: !   key to the message string passed, if it is not null.
 729: 0000: !   Note you must have shown a screen first, and that the function key fields
 730: 0000: !   need to be defined in your display file with field IDs 241-250.
 731: 0000: 
 732: 0000:     FUNCTION DM.SHOW.FN.KEY (KEY.NUM%, MESSAGE$) EXTERNAL
 733: 0000:         INTEGER*1   DM.SHOW.FN.KEY
 734: 0000:         INTEGER*2   KEY.NUM%
 735: 0000:         STRING      MESSAGE$
 736: 0000:     END FUNCTION
 737: 0000: 
 738: 0000: !******************************************************************************
 739: 0000: !   Sets a function key message to invisible.
 740: 0000: !   Note you must have shown a screen first, and that the function key fields
 741: 0000: !   need to be defined in your display file with field IDs 241-250.
 742: 0000: 
 743: 0000:     FUNCTION DM.HIDE.FN.KEY (KEY.NUM%) EXTERNAL
 744: 0000:         INTEGER*1   DM.HIDE.FN.KEY
 745: 0000:         INTEGER*2   KEY.NUM%
 746: 0000:     END FUNCTION
 747: 0000: 
 748: 0000: !******************************************************************************
 749: 0000: !   LEGACY: Do not use in new programs, use DM.FN.VISIBLE instead which takes
 750: 0000: !   an infix notation expression, as opposed to reverse polish
 751: 0000: !   This definition has been commented out accordingly.  If you are
 752: 0000: !   recompiling an application, change to useing the new function.
 753: 0000: !
 754: 0000: !   FUNCTION DM.FN.KEY.VISIBLE (KEY.NUM%, EXPR$) EXTERNAL
 755: 0000: !       INTEGER*1   DM.FN.KEY.VISIBILITY
 756: 0000: !       INTEGER*2   KEY.NUM%
 757: 0000: !       STRING      EXPR$
 758: 0000: !   END FUNCTION
 759: 0000: 
 760: 0000: !******************************************************************************
 761: 0000: !   Sets a runtine expression to determine if a function key is visible.
 762: 0000: !   This is the new version of the above which takes an infix notation EXPR$.
 763: 0000: !   Note you must have shown a screen first, and that the function key fields
 764: 0000: !   need to be defined in your display file with field IDs 241-250.
 765: 0000: 
 766: 0000:     FUNCTION DM.FN.VISIBLE (KEY.NUM%, EXPR$) EXTERNAL
 767: 0000:         INTEGER*1   DM.FN.VISIBILITY
 768: 0000:         INTEGER*2   KEY.NUM%
 769: 0000:         STRING      EXPR$
 770: 0000:     END FUNCTION
 771: 0000: 
 772: 0000: !******************************************************************************
 773: 0000: !   Specifies that a given field contains a date.
 774: 0000: !   This means that the date will be displayed on screen in the system date
 775: 0000: !   format (e.g. DD/MM/YY or MM/DD/YY, but will be returned and set by your
 776: 0000: !   application in YYMMDD format.
 777: 0000: !   It does NOT mean that the field will be validated as a date, you must do
 778: 0000: !   that explicitly using the VALID$ string.
 779: 0000: 
 780: 0000:     FUNCTION DM.DATE.FIELD (FIELD%) EXTERNAL
 781: 0000:         INTEGER*1   DM.DATE.FIELD
 782: 0000:         INTEGER*2   FIELD%
 783: 0000:     END FUNCTION
 784: 0000: 
 785: 0000: !******************************************************************************
 786: 0000: !   Specifies that a given field will contain a time.
 787: 0000: !   This means that the time will be displayed on screen using the system time
 788: 0000: !   format.  e.g. HH:MM
 789: 0000: 
 790: 0000:     FUNCTION DM.TIME.FIELD (FIELD%) EXTERNAL                                !CSWM
 791: 0000:         INTEGER*1   DM.TIME.FIELD                                           !CSWM
 792: 0000:         INTEGER*2   FIELD%                                                  !CSWM
 793: 0000:     END FUNCTION                                                            !CSWM
 794: 0000: 
 795: 0000: !******************************************************************************
 796: 0000: !   Specifies that a given input field will be read only.
 797: 0000: !   This allows you to select an item from a list by highlighting it.
 798: 0000: 
 799: 0000:     FUNCTION DM.RO.FIELD (FIELD%) EXTERNAL                                  !ESWM
 800: 0000:         INTEGER*1   DM.RO.FIELD                                             !ESWM
 801: 0000:         INTEGER*2   FIELD%                                                  !ESWM
 802: 0000:     END FUNCTION                                                            !ESWM
 803: 0000: 
 804: 0000: !******************************************************************************
 805: 0000: !   Specifies that a given input field will be read write.
 806: 0000: !   Undoes the effect of DM.RO.FIELD.
 807: 0000: 
 808: 0000:     FUNCTION DM.RW.FIELD (FIELD%) EXTERNAL                                  !ESWM
 809: 0000:         INTEGER*1   DM.RW.FIELD                                             !ESWM
 810: 0000:         INTEGER*2   FIELD%                                                  !ESWM
 811: 0000:     END FUNCTION                                                            !ESWM
 812: 0000: 
 813: 0000: !******************************************************************************
 814: 0000: !   LEGACY: Do not use in new programs, use DM.STATUS instead which takes
 815: 0000: !   an infix notation expression, as opposed to reverse polish.
 816: 0000: !   This definition has been commented out accordingly.  If you are
 817: 0000: !   recompiling an application, change to useing the new function.
 818: 0000: !
 819: 0000: !   FUNCTION DM.DISPLAY.MESSAGE (MESSAGE$) EXTERNAL                         !DSWM
 820: 0000: !       INTEGER*1   DM.DISPLAY.MESSAGE                                      !DSWM
 821: 0000: !       STRING      MESSAGE$                                                !DSWM
 822: 0000: !   END FUNCTION                                                            !DSWM
 823: 0000: 
 824: 0000: !******************************************************************************
 825: 0000: !   Displays a message in the status line of the display.  Does not wait for
 826: 0000: !   input.  Use this function for display messages such as B251 Processing...
 827: 0000: !   You must have field 1 defined in your display manager file.
 828: 0000: !   This is the new version of the above which takes an infix notation MESSAGE$.
 829: 0000: 
 830: 0000:     FUNCTION DM.STATUS (MESSAGE$) EXTERNAL                                  !DSWM
 831: 0000:         INTEGER*1   DM.STATUS                                               !DSWM
 832: 0000:         STRING      MESSAGE$                                                !DSWM
 833: 0000:     END FUNCTION                                                            !DSWM
 834: 0000: 
 835: 0000: !******************************************************************************
 836: 0000: !   Waits for input in the invisible input field of the display.  Additionally
 837: 0000: !   displays a message prompting the user on the status line.
 838: 0000: !   You must have fields 1 and 240 defined in your display manager file.
 839: 0000: !   The message supplied should be in Reverse Polish form.
 840: 0000: !   The function returns the key value that ended the input.
 841: 0000: 
 842: 0000:     FUNCTION DM.INVISIBLE.INPUT (MESSAGE$) EXTERNAL
 843: 0000:         STRING      MESSAGE$
 844: 0000:         INTEGER*2   DM.INVISIBLE.INPUT
 845: 0000:     END FUNCTION
 846: 0000: 
 847: 0000: !******************************************************************************
 848: 0000: !   Gets the contents of the invisible field from the display.  This will
 849: 0000: !   allow you to get the Y or N answer that the user typed, for example.
 850: 0000: 
 851: 0000:     FUNCTION DM.INVISIBLE.FIELD EXTERNAL
 852: 0000:         STRING      DM.INVISIBLE.FIELD
 853: 0000:     END FUNCTION
 854: 0000: 
 855: 0000: !******************************************************************************
 856: 0000: !   Returns or sets the current field used for input on the current display.
 857: 0000: !   If NEW.FIELD% is zero, the function simply returns the current field.
 858: 0000: !   If NEW.FIELD% is non zero, the function sets the current field.
 859: 0000: 
 860: 0000:     FUNCTION DM.CURRENT.FIELD (NEW.FIELD%) EXTERNAL
 861: 0000:         INTEGER*2   DM.CURRENT.FIELD
 862: 0000:         INTEGER*2   NEW.FIELD%
 863: 0000:     END FUNCTION
 864: 0000: 
 865: 0000: !******************************************************************************
 866: 0000: !   Sets a key number as being a validation key.  When this key is used the
 867: 0000: !   function will handle the key in the same way as the ENTER key.  i.e. all
 868: 0000: !   the visible fields on in input form are check for validity, and the key
 869: 0000: !   press is only returned to the user if the form entries are valid.
 870: 0000: !   Use this function to add the PGUP.KEY% and PGDN.KEY% keys, for example.
 871: 0000: 
 872: 0000:     FUNCTION DM.VALIDATE.KEY (KEY%) EXTERNAL                                !BSWM
 873: 0000:         INTEGER*1   DM.VALIDATE.KEY                                         !BSWM
 874: 0000:         INTEGER*2   KEY%                                                    !BSWM
 875: 0000:     END FUNCTION                                                            !BSWM
 876: 0000: 
 877: 0000: !******************************************************************************
 878: 0000: !   Returns or sets the flag which says if the screen contents have been
 879: 0000: !   changed or not.  Use this function when you have multiple pages to a
 880: 0000: !   form, but want the user to be prompted to save any changes on exit.
 881: 0000: !   When called with FLAG% set 0 or -1, the function updates the current
 882: 0000: !   displays setting.  When called with any other value, the function simply
 883: 0000: !   returns the current setting and does not update it.
 884: 0000: 
 885: 0000:     FUNCTION DM.CHANGED.FLAG (FLAG%) EXTERNAL                               !BSWM
 886: 0000:         INTEGER*1   FLAG%                                                   !BSWM
 887: 0000:         INTEGER*1   DM.CHANGED.FLAG                                         !BSWM
 888: 0000:     END FUNCTION                                                            !BSWM
 889: 0000: 
 890: 0000: !******************************************************************************
 891: 0000: !   Sets the field tab order.  The tab order can be either:
 892: 0000: !   0 - The TAB order is defined by the fields position on the display,
 893: 0000: !       left to right then top to bottom of the display.
 894: 0000: !   1 - The TAB order is defined by the number order of the fields.  This is
 895: 0000: !       a new option which allows greater control over the field TAB order.
 896: 0000: !   -1  Returns the current setting without changing it.
 897: 0000: !   The default tab order is 0.  Once set, the TAB order is a global setting
 898: 0000: !   for the current and all future screens.
 899: 0000: 
 900: 0000:     FUNCTION DM.TAB.ORDER (ORDER%) EXTERNAL                                 !DSWM
 901: 0000:         INTEGER*1   ORDER%                                                  !DSWM
 902: 0000:         INTEGER*1   DM.TAB.ORDER                                            !DSWM
 903: 0000:     END FUNCTION                                                            !DSWM
 904: 0000: 
 905: 0000: !******************************************************************************
 906: 0000: !   This function actually processes user input on the currently shown form.
 907: 0000: !   The function returns when any unrecognised key terminates input in a
 908: 0000: !   field.  The keys which will do this are determined by the properties of
 909: 0000: !   the Display Manager fields on your form.  The function internally handles
 910: 0000: !   most of the form navigation keys (e.g. Tab, Back Tab, Home End) the
 911: 0000: !   rest are up to the user application.
 912: 0000: 
 913: 0000:     FUNCTION DM.PROCESS.SCREEN (FIRST.FIELD%, LAST.FIELD%, CONFIRM) EXTERNAL
 914: 0000:         INTEGER*2   DM.PROCESS.SCREEN
 915: 0000:         INTEGER*2   FIRST.FIELD%
 916: 0000:         INTEGER*2   LAST.FIELD%
 917: 0000:         INTEGER*1   CONFIRM
 918: 0000:     END FUNCTION
 919: 0000: 
 920: 0000: !******************************************************************************
 921: 0000: !   Associates a field on the current display with a given compile time
 922: 0000: !   variable.  This allows the varibale to be used in your program code
 923: 0000: !   AND be updated by the display manager fields in PROCESS.SCREEN.
 924: 0000: !
 925: 0000: !   NOTE: PLEASE BE VERY CAREFUL WITH THE THIRD PARAMETER TO THIS SUB
 926: 0000: !   Always use an absolute variable for VARIABLE$:
 927: 0000: !       CALL DM.NAME (2, "MY.VAR$", MY.VAR$)
 928: 0000: !   NEVER use a calcualted value. These forms are all ILLEGAL:
 929: 0000: !       CALL DM.NAME (2, "MY.VAR$", "1234")
 930: 0000: !       CALL DM.NAME (2, "MY.VAR$", STR$(MY.VAR%))
 931: 0000: !   Also, if you MUST pass in an array element, for example:
 932: 0000: !       CALL DM.NAME (2, "MY.VAR$", ARRAY.ELEMENT$(I%))
 933: 0000: !   then you must make sure you do not reDIM the array until you have finished
 934: 0000: !   displaying and processing the screen.
 935: 0000: 
 936: 0000:     SUB DM.NAME (FIELD%, NAME$, VARIABLE$) EXTERNAL                         !DSWM
 937: 0000:         INTEGER*2 FIELD%                                                    !DSWM
 938: 0000:         STRING NAME$                                                        !DSWM
 939: 0000:         STRING VARIABLE$                                                    !DSWM
 940: 0000:     END SUB                                                                 !DSWM
 941: 0000: 
 942: 0000: !******************************************************************************
 943: 0000: !   Returns the index of a field on the current screen, given its name.
 944: 0000: 
 945: 0000:     FUNCTION DM.INDEX (FIELD$) EXTERNAL                                     !DSWM
 946: 0000:         STRING FIELD$                                                       !DSWM
 947: 0000:         INTEGER*2 DM.INDEX                                                  !DSWM
 948: 0000:     END FUNCTION                                                            !DSWM
 949: 0000: 
 950: 0000: !******************************************************************************
 951: 0000: !   Sets the validation expression for a field on the display.  Exactly the
 952: 0000: !   same as setting the global VALID$ array yourself, except it is done
 953: 0000: !   via the fields name as assoicated via DM.NAME.FIELD and the expression
 954: 0000: !   is in standard infix notation.
 955: 0000: 
 956: 0000:     FUNCTION DM.VALID (FIELD$, VALID$) EXTERNAL                             !DSWM
 957: 0000:         STRING FIELD$                                                       !DSWM
 958: 0000:         STRING VALID$                                                       !DSWM
 959: 0000:         INTEGER*2 DM.VALID                                                  !DSWM
 960: 0000:     END FUNCTION                                                            !DSWM
 961: 0000: 
 962: 0000: !******************************************************************************
 963: 0000: !   Sets the message expression for a field on the display.  Exactly the
 964: 0000: !   same as setting the global MESSAGE$ array yourself, except it is done
 965: 0000: !   via the fields name as assoicated via DM.NAME.FIELD and the expression
 966: 0000: !   is in standard infix notation.
 967: 0000: 
 968: 0000:     FUNCTION DM.MESSAGE (FIELD$, MESSAGE$) EXTERNAL                         !DSWM
 969: 0000:         STRING FIELD$                                                       !DSWM
 970: 0000:         STRING MESSAGE$                                                     !DSWM
 971: 0000:         INTEGER*2 DM.MESSAGE                                                !DSWM
 972: 0000:     END FUNCTION                                                            !DSWM
 973: 0000: 
 974: 0000: !******************************************************************************
 975: 0000: !   Sets the field attributes for a field on the display. Exactly the
 976: 0000: !   same as using the SETF command yourself except that it is done by
 977: 0000: !   using the fields name as associated via the DM.NAME.FIELD.
 978: 0000: 
 979: 0000: SUB DM.FLD.ATT (FIELD$, VALUE$) EXTERNAL                                    !FNWB
 980: 0000:     STRING      FIELD$                                                      !FNWB
 981: 0000:     STRING      VALUE$                                                      !FNWB
 982: 0000: END SUB                                                                     !FNWB
 983: 0000: 
 984: 0000: !******************************************************************************
 985: 0000: !   Sets an input field to act as an output only field on the display. This
 986: 0000: !   allows setting input fields that contain headings etc. to be skipped by
 987: 0000: !   the cursor movement keys.
 988: 0000: 
 989: 0000: FUNCTION DM.OO.FIELD (FIELD$) EXTERNAL                                      !FNWB
 990: 0000:     INTEGER*2   DM.OO.FIELD                                                 !FNWB
 991: 0000:     STRING      FIELD$                                                      !FNWB
 992: 0000: END FUNCTION                                                                !FNWB
 993: 0000: 
 994: 0000: !******************************************************************************
 995: 0000: !   Sets an input field back to an i/o field
 996: 0000: 
 997: 0000: FUNCTION DM.IO.FIELD (FIELD$) EXTERNAL                                      !FNWB
 998: 0000:     INTEGER*2   DM.IO.FIELD                                                 !FNWB
 999: 0000:     STRING      FIELD$                                                      !FNWB
1000: 0000: END FUNCTION                                                                !FNWB
1001: 0000: 
1002: 0000: !******************************************************************************
1003: 0000: !   Sets the visibility expression for a field on the display.  Exactly the
1004: 0000: !   same as setting the global VISIBLE$ array yourself, except it is done
1005: 0000: !   via the fields name as assoicated via DM.NAME.FIELD and the expression
1006: 0000: !   is in standard infix notation.
1007: 0000: 
1008: 0000:     FUNCTION DM.VISIBLE (FIELD$, VISIBLE$) EXTERNAL                         !DSWM
1009: 0000:         STRING FIELD$                                                       !DSWM
1010: 0000:         STRING VISIBLE$                                                     !DSWM
1011: 0000:         INTEGER*2 DM.VISIBLE                                                !DSWM
1012: 0000:     END FUNCTION                                                            !DSWM
1013: 0000: 
1014: 0000: !******************************************************************************
1015: 0000: !   Sets an error message in field 1 of the display and moves the input
1016: 0000: !   focus to the offending line of the display.  Should be called from user
1017: 0000: !   validation code.  Equivalent of the following separate calls:
1018: 0000: !       CALL DM.CURRENT.FIELD%(DM.INDEX(FIELD$))
1019: 0000: !       FIELD$(1) = POLISH$(MESSAGE$)
1020: 0000: !   Can also be called with a null field name, in which case the cursor
1021: 0000: !   remains in the current input field, but the error is displayed.
1022: 0000: 
1023: 0000:     FUNCTION DM.FOCUS (FIELD$, MESSAGE$) EXTERNAL                           !DSWM
1024: 0000:         STRING FIELD$                                                       !DSWM
1025: 0000:         STRING MESSAGE$                                                     !DSWM
1026: 0000:         INTEGER*2 DM.FOCUS                                                  !DSWM
1027: 0000:     END FUNCTION                                                            !DSWM
1028: 0000: 
1029: 0000: !******************************************************************************
1030: 0000: 
1031: 0000: %INCLUDE PSBF49E.J86    ! File check
1032: 0000: \******************************************************************************
1033: 0000: \******************************************************************************
1034: 0000: \***
1035: 0000: \***            PROGRAM         :       PSBF49
1036: 0000: \***            MODULE          :       PSBF49E (External declarations)
1037: 0000: \***            AUTHOR          :       Tittoo Thomas
1038: 0000: \***            DATE WRITTEN    :       October 2013
1039: 0000: \***
1040: 0000: \******************************************************************************
1041: 0000: \***
1042: 0000: \***   External function declarations for the re-usable functions included
1043: 0000: \***   in PSBF49
1044: 0000: \***
1045: 0000: \******************************************************************************
1046: 0000: \******************************************************************************
1047: 0000: \***
1048: 0000: \***   VERSION A                    Tittoo Thomas                    7 Oct 2013
1049: 0000: \***   Initial version.
1050: 0000: \***
1051: 0000: \******************************************************************************
1052: 0000: \******************************************************************************
1053: 0000: 
1054: 0000: 
1055: 0000: \******************************************************************************
1056: 0000: \***
1057: 0000: \***    FUNC.PROC.DELIM.STR%
1058: 0000: \***    Process an input string (INPUT$) delimited by an ASCII string (DELIM$).
1059: 0000: \***    Each chanracter sequence between the delimiter string is broken down to
1060: 0000: \***    tokens and stored as a global array (DELIM.STR.ELEMENTS$) elements.
1061: 0000: \***
1062: 0000: \***    The arguments RANGE.START% and ELEMENT.LIMIT% determine a range of
1063: 0000: \***    positions in the global array to hold the processed tokens. The first
1064: 0000: \***    position in the defined range will have the count of delimited tokens
1065: 0000: \***    successfully processed. The tokens themselves will be stored in the
1066: 0000: \***    following positions.
1067: 0000: \***
1068: 0000: \***    If there exists more elements in the string than what could be stored
1069: 0000: \***    in the range (i.e. postn [RANGE.START%+1] to postn ELEMENT.LIMIT%),
1070: 0000: \***    the ADDITIONAL.ELEMENTS% flag will be set to -1, and the remaining
1071: 0000: \***    elements discarded.
1072: 0000: \***
1073: 0000: \***    If the STRIP.SPACES% variable is set to -1, the spaces any leading
1074: 0000: \***    or trailing spaces are stripped off before storing into the array.
1075: 0000: \***
1076: 0000: \***    The DELIM.STR.ELEMENTS$ array should be dimensioned to hold a minimum
1077: 0000: \***    of ELEMENT.LIMIT% elements.
1078: 0000: \***
1079: 0000: \***    In case of an error the function will return a non-zero value
1080: 0000: \***
1081: 0000: \******************************************************************************
1082: 0000: 
1083: 0000: FUNCTION FUNC.PROC.DELIM.STR%( INPUT$, DELIM$, RANGE.START%,            \
1084: 0000:                                ELEMENT.LIMIT%, STRIP.SPACES%) EXTERNAL
1085: 0000:     STRING    INPUT$,                                                   \
1086: 0000:               DELIM$
1087: 0000: 
1088: 0000:     INTEGER*1 STRIP.SPACES%
1089: 0000: 
1090: 0000:     INTEGER*2 ELEMENT.LIMIT%,                                           \
1091: 0000:               FUNC.PROC.DELIM.STR%,                                     \
1092: 0000:               RANGE.START%
1093: 0000: 
1094: 0000: END FUNCTION
1095: 0000: 
1096: 0000: 
1097: 0000: \******************************************************************************
1098: 0000: \***
1099: 0000: \***    FUNC.CHECK.FILE.SIZE%
1100: 0000: \***    Check if the filename specified exists
1101: 0000: \***    If the file exists it returns the file size, else a negative value
1102: 0000: \***
1103: 0000: \******************************************************************************
1104: 0000: 
1105: 0000: FUNCTION FUNC.CHECK.FILE.SIZE%(CHECK.FILEPATH$) EXTERNAL
1106: 0000: 
1107: 0000:     INTEGER*4 FUNC.CHECK.FILE.SIZE%
1108: 0000:     STRING    CHECK.FILEPATH$
1109: 0000: 
1110: 0000: END FUNCTION
1111: 0000: 
1112: 0000: %INCLUDE BASROUT.J86
1113: 0000: \*LIB   BVEJ BASROUT  J86      03/11/97 08:16:26 PIDBLD3  *    FIX
1114: 0000: \*PROM  BVEJ BASROUT  J86      03/10/97 17:18:40 PIDBLD3  MVEJ IR34352
1115: 0000: \*RTIME BVEJ BASROUT  J86      03/10/97 17:18:41 PIDBLD3  MVEJ IR34352
1116: 0000: \*LIB   MVEJ BASROUT  J86      03/05/97 10:48:46 EDJRAL   *    IR34352
1117: 0000: \*LIB   MVEJ BASROUT  J86      02/17/97 11:19:56 EDJRAL   *    REASONAR
1118: 0000: \*LIB   MVEJ BASROUT  J86      02/14/97 15:59:11 EDJRAL   *    REASONAR
1119: 0000: ! BASROUT.J86 - this file is to be included in any BASIC code which utilizes
1120: 0000: !   the BASROUT.OBJ routines.  These routines were written
1121: 0000: !  using Metaware C and are intended to provide functions which
1122: 0000: !         are either not available in 4680 CBASIC or which can be more
1123: 0000: !               efficiently handled by the C language.  Their usage is
1124: 0000: !  offered on an "AT YOUR OWN RISK" basis.
1125: 0000: !
1126: 0000: !               The insert/extract routines usefulness may not be immediately
1127: 0000: !               apparent.  Their intention is that they be used in conjunction
1128: 0000: !               with a read/write form command.  They can more efficiently
1129: 0000: !               parse a string into many different variables than can the
1130: 0000: !               read form statement.  So instead of a long list of data var's
1131: 0000: !               it may be more efficient to just read/write one long string
1132: 0000: !               and then use the insert/extract routines to parse out the
1133: 0000: !   data.
1134: 0000: 
1135: 0000: ! ******************* SUB PROCESS FUNCTIONS *********************************
1136: 0000: 
1137: 0000: function osshell(cmd.line$) external   ! routine to start
1138: 0000:        ! another program.
1139: 0000:            integer*4    osshell    ! Upon completion of
1140: 0000:            string       cmd.line$   ! program, control is
1141: 0000:        ! returned to calling
1142: 0000: end function      ! program.
1143: 0000: !
1144: 0000: ! NOTES:  Program must be a 286 type file.  This does not exclude
1145: 0000: !         the capability to execute a batch file however.  Simply pass the
1146: 0000: !         following:
1147: 0000: !              c:\adx_spgm\command.286 batfile
1148: 0000: !         where batfile is the name of the batch file to be executed.
1149: 0000: !
1150: 0000: ! IMPORTANT: When using osshell to execute a batch file as described above,
1151: 0000: !            the final command in the batch file must be "exit".  If not,
1152: 0000: !       control is never given back to the calling program.
1153: 0000: 
1154: 0000: ! ************************ MEMORY RELATED FUNCTIONS ************************
1155: 0000: 
1156: 0000: function memfree(choice) external   ! routine to que the
1157: 0000:        ! status of the
1158: 0000:  integer*4 memfree    ! machine's memory:
1159: 0000:  integer*2 choice    ! Options:
1160: 0000:        !    1 - free
1161: 0000: end function      !    2 - total
1162: 0000:        !    3 - system
1163: 0000: 
1164: 0000: ! ********************** TIMEDATE RELATED FUNCTIONS ************************
1165: 0000: 
1166: 0000: function timedate(choice) external   ! routine to que the
1167: 0000:        ! OS's timedate table
1168: 0000:  integer*4 timedate   ! Choices:
1169: 0000:  integer*2 choice    !    1 - millisec's
1170: 0000:        !        since midnight
1171: 0000: end function      !    2 - minutes from
1172: 0000:        !  UCT (timezone)
1173: 0000:        !    3 - day of week
1174: 0000:        !   0-Sunday
1175: 0000:        !  6-Saturday
1176: 0000: 
1177: 0000: function settime(msecs) external   ! routine to set the
1178: 0000:        ! time on the controller
1179: 0000:  integer*4  settime    ! msecs is the desired
1180: 0000:  integer*4 msecs    ! number of milliseconds
1181: 0000:        ! since midnight
1182: 0000: end function      ! Returns negative on
1183: 0000:        ! error
1184: 0000: ! NOTE:  This routine sets the time only on the controller.  The terminals'
1185: 0000: ! time will not be updated until 1 AM or unless a terminal is STC'd.
1186: 0000: ! At 1 AM the controller broadcasts the new time to all terminals.
1187: 0000: ! Insure this is taken into consideration when using this routine.
1188: 0000: 
1189: 0000: !******************** DISK FILE RELATED FUNCTIONS *************************
1190: 0000: 
1191: 0000: function truncate(name,length) external   ! routine to truncate
1192: 0000:        ! the specified file
1193: 0000:  integer*4 truncate   ! to a given length.
1194: 0000:  string  name
1195: 0000:  integer*4 length
1196: 0000: 
1197: 0000: end function
1198: 0000: 
1199: 0000: !******************** STRING VALUE RELATED FUNCTIONS **********************
1200: 0000: 
1201: 0000: function isalpha(bstrn) external   ! routine to identify
1202: 0000:        ! if the specified
1203: 0000:  integer*1 isalpha    ! string contains all
1204: 0000:  string  bstrn    ! alphabetic char's
1205: 0000:        ! Returns:
1206: 0000: end function      !     0 - all alpha
1207: 0000:        !     X - byte of 1st
1208: 0000:        !         non-alpha
1209: 0000:        !   char
1210: 0000: 
1211: 0000: function isdigit(bstrn) external   ! routine to identify
1212: 0000:        ! if the specified
1213: 0000:  integer*1 isdigit    ! string contains all
1214: 0000:  string  bstrn    ! numeric char's
1215: 0000:        ! Returns:
1216: 0000: end function      !     0 - all numeric
1217: 0000:        !     X - byte of 1st
1218: 0000:        !         non-numeric
1219: 0000:        !   char
1220: 0000: 
1221: 0000: function islower(bstrn) external   ! routine to identify
1222: 0000:        ! if the specified
1223: 0000:  integer*1 islower    ! string contains all
1224: 0000:  string  bstrn    ! lower case char's
1225: 0000:        ! Returns:
1226: 0000: end function      !     0 - all lowercase
1227: 0000:        !     X - byte of 1st
1228: 0000:        !         non-lowercase
1229: 0000:        !   char
1230: 0000: 
1231: 0000: function isupper(bstrn) external   ! routine to identify
1232: 0000:        ! if the specified
1233: 0000:  integer*1 isupper    ! string contains all
1234: 0000:  string  bstrn    ! upper case char's
1235: 0000:        ! Returns:
1236: 0000: end function      !     0 - all uppercase
1237: 0000:        !     X - byte of 1st
1238: 0000:        !         non-uppercase
1239: 0000:        !   char
1240: 0000: 
1241: 0000: function toalpha(bstrn) external   ! routine to convert
1242: 0000:        ! non-alpha or non-num
1243: 0000:    integer*2 toalpha    ! char's to spaces
1244: 0000:  string  bstrn    ! Returns:
1245: 0000: end function      !   x - no. of char's
1246: 0000:        !       changed
1247: 0000: 
1248: 0000: ! ********************* USER/GROUP ZERO LEVEL FUNCTIONS *********************
1249: 0000: 
1250: 0000: function idlecount(choice) external   ! routine to either
1251: 0000:        ! set to zero or queue
1252: 0000:  integer*4 idlecount   ! the value of the
1253: 0000:  integer*1 choice    ! processor's idlecount
1254: 0000:        ! Choice:
1255: 0000: end function      !     0 - set to zero
1256: 0000: !       !     1 - get value
1257: 0000: ! NEEDS USER/GROUP 0 LEVEL OF AUTHORIZATION  ! Returns:
1258: 0000: ! TO WORK - This level is not available unless  !     X - idlecount
1259: 0000: ! the file ADXCSOUF.DAT file is "patched".  This !    -X - error code
1260: 0000: ! is highly unrecommended.
1261: 0000: 
1262: 0000: function logical(actname,logname,choice) external ! routine to set a
1263: 0000:        ! a logical name.
1264: 0000:  integer*4 logical    ! parms are self
1265: 0000:         string  logname    ! explanatory except
1266: 0000:  string  actname    ! for choice:
1267: 0000:  integer*1 choice    !   0 - set process
1268: 0000:        !   1 - set system
1269: 0000: end function      !   2 - get process
1270: 0000:        !   3 - get system
1271: 0000: 
1272: 0000: ! NOTE:  Only the setting of a system level of logical name requires
1273: 0000: ! user/group zero level of authorization.  Any application may query any
1274: 0000: ! logical name.  Setting of a system logical name is only applicable until
1275: 0000: ! the system is IPL'd.  A process logical name is only active when that
1276: 0000: ! process is active.
1277: 0000: 
1278: 0000: !******************** STRING PARSING FUNCTIONS *****************************
1279: 0000: 
1280: 0000: function inserts(whole,part,offset) external  ! routine to insert a
1281: 0000:        ! string (part) into
1282: 0000:  integer*2 INSERTS    ! another string (whole)
1283: 0000:  string  whole    ! starting at specified
1284: 0000:  string  part    ! character (offset)
1285: 0000:  integer*2 offset
1286: 0000: 
1287: 0000: end function
1288: 0000: 
1289: 0000: function cinsert4(integer4,bstring,offset) external   ! routine to insert
1290: 0000:        ! a 4-byte integer into
1291: 0000:  integer*1 cinsert4   ! a string starting at
1292: 0000:  integer*4 integer4   ! byte specified by
1293: 0000:  string  bstring    ! offset (1-based)
1294: 0000:  integer*2 offset    ! Returns:
1295: 0000:        !     0 - Success
1296: 0000: end function      !    -1 - String overrun
1297: 0000: 
1298: 0000: function cinsert2(integer2,bstring,offset) external  ! routine to insert
1299: 0000:        ! a 2-byte integer into
1300: 0000:  integer*1 cinsert2   ! a string starting at
1301: 0000:  integer*2 integer2   ! byte specified by
1302: 0000:  string  bstring    ! offset (1-based)
1303: 0000:  integer*2 offset    ! Returns:
1304: 0000:        !     0 - Success
1305: 0000: end function      !    -1 - String overrun
1306: 0000: 
1307: 0000: function cinsert1(bstring,integer1,offset) external  ! routine to insert
1308: 0000:        ! a 1-byte integer into
1309: 0000:  integer*1 cinsert1   ! a string starting at
1310: 0000:  integer*1 integer1   ! byte specified by
1311: 0000:  string  bstring    ! offset (1-based)
1312: 0000:  integer*2 offset    ! Returns:
1313: 0000:        !     0 - Success
1314: 0000: end function      !    -1 - String overrun
1315: 0000: 
1316: 0000: function extracts(whole,part,offset) external  ! routine to extract a
1317: 0000:        ! string (part) from
1318: 0000:  integer*2 EXTRACTS   ! another string (whole)
1319: 0000:  string  whole    ! starting at specified
1320: 0000:  string  part    ! character (offset)
1321: 0000:  integer*2 offset
1322: 0000: 
1323: 0000: end function
1324: 0000: 
1325: 0000: function cextract4(bstring,offset) external  ! routine to extract
1326: 0000:        ! a 4-byte integer from
1327: 0000:  integer*4 cextract4   ! a string starting at
1328: 0000:                        ! byte specified by
1329: 0000:  string  bstring    ! offset (1-based)
1330: 0000:  integer*2 offset    ! Returns:
1331: 0000:        !     X - 4 byte integer
1332: 0000: end function      !    -1 - String overrun
1333: 0000: 
1334: 0000: function cextract2(bstring,offset) external  ! routine to extract
1335: 0000:        ! a 2-byte integer from
1336: 0000:  integer*2 cextract2   ! a string starting at
1337: 0000:                        ! byte specified by
1338: 0000:  string  bstring    ! offset (1-based)
1339: 0000:  integer*2 offset    ! Returns:
1340: 0000:        !     X - 2 byte integer
1341: 0000: end function      !    -1 - String overrun
1342: 0000: 
1343: 0000: function cextract1(bstring,offset) external  ! routine to extract
1344: 0000:        ! a 1-byte integer from
1345: 0000:  integer*1 cextract1   ! a string starting at
1346: 0000:                        ! byte specified by
1347: 0000:  string  bstring    ! offset (1-based)
1348: 0000:  integer*2 offset    ! Returns:
1349: 0000:        !     X - 1 byte integer
1350: 0000: end function      !    -1 - String overrun
1351: 0000: 
1352: 0000: 
1353: 0000: function srchdir (file.name$,dtbl.buffer$) external ! routine to return
1354: 0000:        ! file names and sizes
1355: 0000:        ! Return values:
1356: 0000:        !    -1  no matches
1357: 0000:        !        found on first
1358: 0000:        !        call
1359: 0000:        !    0   no matches
1360: 0000:        !        found on sub-
1361: 0000:        !        sequent calls
1362: 0000:        !    Pos Success
1363: 0000:        !    Neg OS Rtn Code
1364: 0000: ! Usage Note:  If searching for all occurences of a particular file name,
1365: 0000: ! first initialize dtbl.buffer$ to 48 Nulls (pack$("00")) and issue a call
1366: 0000: ! to srchdir.  If any matches are found, a positive value will be returned.
1367: 0000: ! To see if any more matches exist, just issue another call to srchdir without
1368: 0000: ! resetting the values of dtbl.buffer$.  If any are found, a positive value
1369: 0000: ! will be returned.  This can be repeated until a Zero is returned.  All data
1370: 0000: ! describing file will be returned in the dtbl.buffer$ after each call.  Format
1371: 0000: ! of this data is defined below.
1372: 0000: 
1373: 0000:  integer*4 srchdir
1374: 0000: 
1375: 0000:  string  file.name$   ! file name to start
1376: 0000:        ! search (18 bytes max)
1377: 0000:        ! Wild cards and logical
1378: 0000:        ! names supported.
1379: 0000: 
1380: 0000:  string  dtbl.buffer$   ! must be initialized
1381: 0000:        ! to 48 bytes.  Contains
1382: 0000:        ! all of directory info
1383: 0000:        ! Initialize to nulls
1384: 0000:        ! each time a new file
1385: 0000:        ! name is used.
1386: 0000: 
1387: 0000: ! NOTE:  Format of dtbl.buffer$ string is as follows:
1388: 0000: !
1389: 0000: ! Offs  Type                    Description Notes
1390: 0000: !  0 integer*4  key  use extract4 to access
1391: 0000: !  4  string (18 bytes) file name
1392: 0000: ! 22 integer*2  attributes use extract2 to access
1393: 0000: !      0x01 - Read Only
1394: 0000: !      0x02 - Hidden
1395: 0000: !      0x04 - System
1396: 0000: !      0x08 - Volume Label
1397: 0000: !      0x10 - Subdirectory
1398: 0000: !      0x20 - Archive (Files)
1399: 0000: !      0x40 - Security enabled
1400: 0000: !      0x80 - Reserved
1401: 0000: !      0x0000 - Local
1402: 0000: !      0x4000 - Mirrored/Update
1403: 0000: !      0xC000 - Mirrored/Close
1404: 0000: !
1405: 0000: !      0x6000 - Compound/Update
1406: 0000: !      0xE000 - Compound/Close
1407: 0000: ! 24 integer*2  record size use extract2 to access
1408: 0000: ! 26 integer*1  User ID of Owner
1409: 0000: ! 27 integer*1  Group ID of Owner
1410: 0000: ! 28 integer*2  File Security
1411: 0000: ! 30 string (6 bytes) Reserved
1412: 0000: ! 36 integer*4  File Size use extract4 to access
1413: 0000: ! 40 integer*2  Year  use extract2 to access
1414: 0000: ! 42 integer*1  Month
1415: 0000: ! 43 integer*1  Day
1416: 0000: ! 44 integer*1  Hour
1417: 0000: ! 45 integer*1  Minute
1418: 0000: ! 46 integer*1  Second
1419: 0000: ! 47 integer*1  Reserved
1420: 0000: 
1421: 0000: end function
1422: 0000: 
1423: 0000: function srchproc (proc.name$,ptbl.buffer$) external ! routine to return
1424: 0000:        ! process names and
1425: 0000:        ! status.  Handy to
1426: 0000:        ! determine if a
1427: 0000:        ! program is currently
1428: 0000:        ! running.
1429: 0000:        ! Return values:
1430: 0000:        !    -1  no matches
1431: 0000:        !        found on first
1432: 0000:        !        call
1433: 0000:        !    0   no matches
1434: 0000:        !        found on sub-
1435: 0000:        !        sequent calls
1436: 0000:        !    Pos Success
1437: 0000:        !    Neg Failure
1438: 0000:        !        OS Rtn Code
1439: 0000:        ! 80000001h - Insuff
1440: 0000:         !        ptbl buffer
1441: 0000:        !        Length
1442: 0000: ! Usage Note:  If searching for all occurences of a particular process name,
1443: 0000: ! first initialize ptbl.buffer$ to 60 Nulls (pack$("00")) and issue a call
1444: 0000: ! to srchproc.  If any matches are found, a positive value will be returned.
1445: 0000: ! To see if any more matches exist, just issue another call to srchproc without
1446: 0000: ! resetting the values of ptbl.buffer$.  If any are found, a positive value
1447: 0000: ! will be returned.  This can be repeated until a Zero is returned.  All data
1448: 0000: ! describing file will be returned in the ptbl.buffer$ after each call.  Format
1449: 0000: ! of this data is defined as follows:
1450: 0000: !
1451: 0000: !       --------------------------------------------------------
1452: 0000: !   0   |                         PID                          |
1453: 0000: !       --------------------------------------------------------
1454: 0000: !   4   |           FID             |   CID        |   VCID    |
1455: 0000: !       --------------------------------------------------------
1456: 0000: !   8   |                         NAME                         |
1457: 0000: !       --------------------------------------------------------
1458: 0000: !  12   |                         NAME cont'd                  |
1459: 0000: !       --------------------------------------------------------
1460: 0000: !  16   |       NAME cont'd         |   STATE      |  PRIOR    |
1461: 0000: !       --------------------------------------------------------
1462: 0000: !  20   |                         MAXMEM                       |
1463: 0000: !       --------------------------------------------------------
1464: 0000: !  24   |       FLAGS               |   USER        |  GROUP   |
1465: 0000: !       --------------------------------------------------------
1466: 0000: !  28   |                         PARENT                       |
1467: 0000: !       --------------------------------------------------------
1468: 0000: !  32   |                         EVENTS                       |
1469: 0000: !       --------------------------------------------------------
1470: 0000: !  36   |                         CODE                         |
1471: 0000: !       --------------------------------------------------------
1472: 0000: !  40   |                         CSIZE                        |
1473: 0000: !       --------------------------------------------------------
1474: 0000: !  44   |                         DATA                         |
1475: 0000: !       --------------------------------------------------------
1476: 0000: !  48   |                         DSIZE                        |
1477: 0000: !       --------------------------------------------------------
1478: 0000: !  52   |                         HEAP                         |
1479: 0000: !       --------------------------------------------------------
1480: 0000: !  56   |                         HSIZE                        |
1481: 0000: !       --------------------------------------------------------
1482: 0000: !
1483: 0000: !       PID   Process ID
1484: 0000: !       FID  Process's Family ID
1485: 0000: !       CID   Physical Console Device Number
1486: 0000: !       VCID  Process's Virtual Console Number
1487: 0000: !       NAME  Process Name (Application Running)
1488: 0000: ! STATE    Process State (0-Run, 1-Waiting, 2-Terminating)
1489: 0000: ! PRIOR    Priority
1490: 0000: !       MAXMEM  Maximum Memory Allowed
1491: 0000: !       FLAGS  Bit 0 (1-System Process, 0-User Process)
1492: 0000: !   Bit 1 (1-Locked in Memory, 0-Swappable)
1493: 0000: !   Bit 2 (1-Running in SWI context, 0-Running in main context)
1494: 0000: !   Bit 3 (1-Superuser Process,0-Not a Superuser Process)
1495: 0000: ! USER  User Number
1496: 0000: ! GROUP  Group Number
1497: 0000: !       PARENT   Parent Process ID
1498: 0000: !       EVENTS   Bit Map of events that have completed but not retrieved
1499: 0000: !       CODE  Start of code area in user space
1500: 0000: ! CSIZE  Size in bytes of code area
1501: 0000: !       DATA  Start of data area in user space
1502: 0000: ! DSIZE  Size in bytes of data area
1503: 0000: !       HEAP  Start of heap area in user space
1504: 0000: ! HSIZE  Size in bytes of heap area
1505: 0000: !
1506: 0000:  integer*4 srchproc
1507: 0000: 
1508: 0000:  string  proc.name$   ! process name to start
1509: 0000:        ! search (10 bytes max)
1510: 0000:        ! Wild cards and logical
1511: 0000:        ! names supported.
1512: 0000: 
1513: 0000:  string  ptbl.buffer$   ! must be initialized
1514: 0000:        ! to 60 bytes.  Contains
1515: 0000:        ! all of process info
1516: 0000:        ! Initialize to nulls
1517: 0000:        ! each time a new
1518: 0000:        ! process name is used.
1519: 0000: 
1520: 0000: end function
1521: 0000: 
1522: 0000: function cconstat(timeout) external       ! function similar
1523: 0000:                                               ! to BASIC constat%
1524: 0000:  integer*2 cconstat   ! waits for either a
1525: 0000:  integer*4 timeout    ! key being hit or
1526: 0000:        ! the timer expiring
1527: 0000:        ! before returning
1528: 0000:        ! returns:
1529: 0000:        !   -1 error
1530: 0000:        !    0 timer expired
1531: 0000:        !    x scan code of
1532: 0000:        !      key hit
1533: 0000: end function
1534: 0000: 
1535: 0000: function disksize(disk.name$) external   ! function to find
1536: 0000:        ! the total size of
1537: 0000:  integer*4 disksize   ! the specified disk
1538: 0000:  string  disk.name$   ! name (e.g. "h0:")
1539: 0000:        ! if return value is
1540: 0000:        ! negative, error
1541: 0000: end function      ! was received
1542: 0000: 
1543: 0000: 
1544: 0000: %INCLUDE BTCMEM.J86
1545: 0000: !********************************************************************
1546: 0000: !***
1547: 0000: !***    INCLUDED CODE:  BTCMEM.J86
1548: 0000: !***    AUTHOR:         Stuart William McConnachie
1549: 0000: !***    DATE:           26th February 2006
1550: 0000: !***
1551: 0000: !********************************************************************
1552: 0000: !***
1553: 0000: !***    Controller CBASIC Memory Functions
1554: 0000: !***
1555: 0000: !********************************************************************
1556: 0000: 
1557: 0000: !Get a single byte integer from a string offset
1558: 0000: FUNCTION GETN1 (S$, P%) EXTERNAL
1559: 0000:     STRING S$
1560: 0000:     INTEGER*2 P%
1561: 0000:     INTEGER*2 GETN1
1562: 0000: END FUNCTION
1563: 0000: 
1564: 0000: !Get a two byte integer from a string offset
1565: 0000: FUNCTION GETN2 (S$, P%) EXTERNAL
1566: 0000:     STRING S$
1567: 0000:     INTEGER*2 P%
1568: 0000:     INTEGER*2 GETN2
1569: 0000: END FUNCTION
1570: 0000: 
1571: 0000: !Get a four byte integer from a string offset
1572: 0000: FUNCTION GETN4 (S$, P%) EXTERNAL
1573: 0000:     STRING S$
1574: 0000:     INTEGER*2 P%
1575: 0000:     INTEGER*4 GETN4
1576: 0000: END FUNCTION
1577: 0000: 
1578: 0000: !Get a 10 byte CBASIC real from a string offset
1579: 0000: FUNCTION GETR10 (S$, P%) EXTERNAL
1580: 0000:     STRING S$
1581: 0000:     INTEGER*2 P%
1582: 0000:     REAL GETR10
1583: 0000: END FUNCTION
1584: 0000: 
1585: 0000: !Put a single byte integer into a string at offset
1586: 0000: FUNCTION PUTN1 (S$, P%, N%) EXTERNAL
1587: 0000:     STRING S$
1588: 0000:     INTEGER*2 P%
1589: 0000:     INTEGER*1 N%
1590: 0000:     INTEGER*1 PUTN1
1591: 0000: END FUNCTION
1592: 0000: 
1593: 0000: !Put a two byte integer into a string at offset
1594: 0000: FUNCTION PUTN2 (S$, P%, N%) EXTERNAL
1595: 0000:     STRING S$
1596: 0000:     INTEGER*2 P%
1597: 0000:     INTEGER*2 N%
1598: 0000:     INTEGER*1 PUTN2
1599: 0000: END FUNCTION
1600: 0000: 
1601: 0000: !Put a four byte integer into a string at offset
1602: 0000: FUNCTION PUTN4 (S$, P%, N%) EXTERNAL
1603: 0000:     STRING S$
1604: 0000:     INTEGER*2 P%
1605: 0000:     INTEGER*4 N%
1606: 0000:     INTEGER*1 PUTN4
1607: 0000: END FUNCTION
1608: 0000: 
1609: 0000: !Put a 10 byte CBASIC real into a string at offset
1610: 0000: FUNCTION PUTR10 (S$, P%, R) EXTERNAL
1611: 0000:     STRING S$
1612: 0000:     INTEGER*2 P%
1613: 0000:     REAL R
1614: 0000:     INTEGER*1 PUTR10
1615: 0000: END FUNCTION
1616: 0000: 
1617: 0000: !Peek a two byte integer from a memory address
1618: 0000: FUNCTION PEEKN2 (A%) EXTERNAL
1619: 0000:     INTEGER*4 A%
1620: 0000:     INTEGER*2 PEEKN2
1621: 0000: END FUNCTION
1622: 0000: 
1623: 0000: !Peek a four byte integer from a memory address
1624: 0000: FUNCTION PEEKN4 (A%) EXTERNAL
1625: 0000:     INTEGER*4 A%
1626: 0000:     INTEGER*4 PEEKN4
1627: 0000: END FUNCTION
1628: 0000: 
1629: 0000: !Peek a 10 byte CBASIC real from a memory address
1630: 0000: FUNCTION PEEKR10 (A%) EXTERNAL
1631: 0000:     INTEGER*4 A%
1632: 0000:     REAL PEEKR10
1633: 0000: END FUNCTION
1634: 0000: 
1635: 0000: !Poke a two byte integer to a memory address
1636: 0000: FUNCTION POKEN2 (A%, N%) EXTERNAL
1637: 0000:     INTEGER*4 A%
1638: 0000:     INTEGER*2 N%
1639: 0000:     INTEGER*1 POKEN2
1640: 0000: END FUNCTION
1641: 0000: 
1642: 0000: !Poke a four byte integer to a memory address
1643: 0000: FUNCTION POKEN4 (A%, N%) EXTERNAL
1644: 0000:     INTEGER*4 A%
1645: 0000:     INTEGER*4 N%
1646: 0000:     INTEGER*1 POKEN4
1647: 0000: END FUNCTION
1648: 0000: 
1649: 0000: !Poke a 10 byte CBASIC real to a memory address
1650: 0000: FUNCTION POKER10 (A%, R) EXTERNAL
1651: 0000:     INTEGER*4 A%
1652: 0000:     REAL R
1653: 0000:     INTEGER*1 POKER10
1654: 0000: END FUNCTION
1655: 0000: 
1656: 0000: %INCLUDE DATEEXT.J86
1657: 0000: \*******************************************************************************
1658: 0000: \*******************************************************************************
1659: 0000: \***
1660: 0000: \***    REFERENCE   :   DATEEXT
1661: 0000: \***
1662: 0000: \*******************************************************************************
1663: 0000: \***
1664: 0000: \***    OVERVIEW:
1665: 0000: \***
1666: 0000: \***    This module contains common external function and subprogram
1667: 0000: \***    definitions used for date processing.
1668: 0000: \***
1669: 0000: \***    CONTENTS:
1670: 0000: \***
1671: 0000: \***    CENTURY$ - Get the current century from the current system date
1672: 0000: \***    DAY.OF.WEEK - Get day of week value (0=Sun-6=Sat) for specified date
1673: 0000: \***
1674: 0000: \*******************************************************************************
1675: 0000: \***
1676: 0000: \***    MODIFICATIONS:
1677: 0000: \***
1678: 0000: \***    Version A.              Mark Walker                     13th Mar 2015
1679: 0000: \***    Initial version.
1680: 0000: \***
1681: 0000: \***    Version B.              Mark Walker                     25th Jun 2015
1682: 0000: \***    Added DAY.OF.WEEK function.
1683: 0000: \***
1684: 0000: \*******************************************************************************
1685: 0000: \*******************************************************************************
1686: 0000: 
1687: 0000: FUNCTION CENTURY$ EXTERNAL
1688: 0000:     STRING CENTURY$
1689: 0000: END FUNCTION
1690: 0000: 
1691: 0000: FUNCTION DAY.OF.WEEK(IN.DATE$) EXTERNAL
1692: 0000:     INTEGER*1 DAY.OF.WEEK
1693: 0000:     STRING IN.DATE$
1694: 0000: END FUNCTION
1695: 0000: 
1696: 0000: %INCLUDE FILEEXT.J86
1697: 0000: \*******************************************************************************
1698: 0000: \*******************************************************************************
1699: 0000: \***
1700: 0000: \***    REFERENCE   :   FILEEXT
1701: 0000: \***
1702: 0000: \*******************************************************************************
1703: 0000: \***
1704: 0000: \***    OVERVIEW:
1705: 0000: \***
1706: 0000: \***    This module contains common external function and subprogram
1707: 0000: \***    definitions used for file processing.
1708: 0000: \***
1709: 0000: \***    CONTENTS:
1710: 0000: \***
1711: 0000: \***    FILE.EXISTS - Checks whether a file exists.
1712: 0000: \***
1713: 0000: \*******************************************************************************
1714: 0000: \***
1715: 0000: \***    MODIFICATIONS:
1716: 0000: \***
1717: 0000: \***    Version A.              Mark Walker                     13th Mar 2015
1718: 0000: \***    Initial version.
1719: 0000: \***
1720: 0000: \*******************************************************************************
1721: 0000: \*******************************************************************************
1722: 0000: 
1723: 0000: FUNCTION FILE.EXISTS(FILE.NAME$) EXTERNAL
1724: 0000:     INTEGER*1 FILE.EXISTS
1725: 0000:     STRING    FILE.NAME$
1726: 0000: END FUNCTION
1727: 0000: 
1728: 0000: %INCLUDE STREXT.J86
1729: 0000: \*******************************************************************************
1730: 0000: \*******************************************************************************
1731: 0000: \***
1732: 0000: \***    REFERENCE   :   STREXT
1733: 0000: \***
1734: 0000: \*******************************************************************************
1735: 0000: \***
1736: 0000: \***    OVERVIEW:
1737: 0000: \***
1738: 0000: \***    This module contains common external function and subprogram
1739: 0000: \***    definitions used for string processing.
1740: 0000: \***
1741: 0000: \***    CONTENTS:
1742: 0000: \***
1743: 0000: \***    RTRIM$ - Removes the specified trailing character from a string
1744: 0000: \***    LTRIM$ - Removes the specified leading character from a string
1745: 0000: \***    TRIM$  - Removes the specified leading and trailing character
1746: 0000: \***             from a string
1747: 0000: \***
1748: 0000: \*******************************************************************************
1749: 0000: \***
1750: 0000: \***    MODIFICATIONS:
1751: 0000: \***
1752: 0000: \***    Version A.              Mark Walker                     24th Jul 2015
1753: 0000: \***    Initial version.
1754: 0000: \***
1755: 0000: \***    Version B.              Mark Walker                     24th Nov 2016
1756: 0000: \***    Added TRIM$ function.
1757: 0000: \***
1758: 0000: \*******************************************************************************
1759: 0000: \*******************************************************************************
1760: 0000: 
1761: 0000: FUNCTION RTRIM$(SOURCE$,TRIM.CHAR$) EXTERNAL
1762: 0000:     STRING    TRIM.CHAR$
1763: 0000:     STRING    SOURCE$
1764: 0000:     STRING    RTRIM$
1765: 0000: END FUNCTION
1766: 0000: 
1767: 0000: FUNCTION LTRIM$(SOURCE$,TRIM.CHAR$) EXTERNAL
1768: 0000:     STRING    TRIM.CHAR$
1769: 0000:     STRING    SOURCE$
1770: 0000:     STRING    LTRIM$
1771: 0000: END FUNCTION
1772: 0000: 
1773: 0000: FUNCTION TRIM$(SOURCE$,TRIM.CHAR$) EXTERNAL                             !BMW
1774: 0000:     STRING    TRIM.CHAR$                                                !BMW
1775: 0000:     STRING    SOURCE$                                                   !BMW
1776: 0000:     STRING    TRIM$                                                     !BMW
1777: 0000: END FUNCTION                                                            !BMW
1778: 0000: 
1779: 0000: %INCLUDE BTCSTR.J86     ! String functions
1780: 0000: !********************************************************************
1781: 0000: !***
1782: 0000: !***    INCLUDED CODE:  BTCSTR.J86
1783: 0000: !***    AUTHOR:         Stuart William McConnachie
1784: 0000: !***    DATE:           26th February 2006
1785: 0000: !***
1786: 0000: !********************************************************************
1787: 0000: !***
1788: 0000: !***    Controller CBASIC String Functions
1789: 0000: !***
1790: 0000: !********************************************************************
1791: 0000: 
1792: 0000: !Swaps to CBASIC strings
1793: 0000: SUB SWAPSTR (S1$, S2$) EXTERNAL
1794: 0000:     STRING S1$, S2$
1795: 0000: END SUB
1796: 0000: 
1797: 0000: !Left trim a string of spaces
1798: 0000: SUB LTRIM (S$) EXTERNAL
1799: 0000:     STRING S$
1800: 0000: END SUB
1801: 0000: 
1802: 0000: !Right trim a string of spaces
1803: 0000: SUB RTRIM (S$) EXTERNAL
1804: 0000:     STRING S$
1805: 0000: END SUB
1806: 0000: 
1807: 0000: !Left and right trim a string of spaces
1808: 0000: SUB TRIM (S$) EXTERNAL
1809: 0000:     STRING S$
1810: 0000: END SUB
1811: 0000: 
1812: 0000: !Left trim a string of a given ASCII character
1813: 0000: SUB LTRIMC (S$, C%) EXTERNAL
1814: 0000:     STRING S$
1815: 0000:     INTEGER*1 C%
1816: 0000: END SUB
1817: 0000: 
1818: 0000: !Right trim a string of a given ASCII character
1819: 0000: SUB RTRIMC (S$, C%) EXTERNAL
1820: 0000:     STRING S$
1821: 0000:     INTEGER*1 C%
1822: 0000: END SUB
1823: 0000: 
1824: 0000: !Left and right trim a string of a given ASCII character
1825: 0000: SUB TRIMC (S$, C%) EXTERNAL
1826: 0000:     STRING S$
1827: 0000:     INTEGER*1 C%
1828: 0000: END SUB
1829: 0000: 
1830: 0000: !Insert one string into another
1831: 0000: FUNCTION SUBSTR(S1$, O1%, S2$, O2%, L2%) EXTERNAL
1832: 0000:     STRING    S1$, S2$
1833: 0000:     INTEGER*2 O1%, O2%, L2%
1834: 0000:     INTEGER*1 SUBSTR
1835: 0000: END FUNCTION
1836: 0000:     
1837: 0000: %INCLUDE CSORTDEF.J86   ! CSORT
1838: 0000: FUNCTION CSORT(ARPTR%, ELEMENTS%) EXTERNAL
1839: 0000:     INTEGER*4 ARPTR%, ELEMENTS%, CSORT
1840: 0000: END FUNCTION
1841: 0000: 
1842: 0000: 
1843: 0000: !%INCLUDE EVAPPEXT.J86  ! Event application file                        !JMW
1844: 0000: %INCLUDE EVLOGEXT.J86   ! Event log file
1845: 0000: \***********************************************************************
1846: 0000: \***********************************************************************
1847: 0000: \***
1848: 0000: \***    EXTERNAL FUNCTION DEFINITIONS FOR EVENT LOG FILE (EVLOG)
1849: 0000: \***
1850: 0000: \***********************************************************************
1851: 0000: \***********************************************************************
1852: 0000: \***
1853: 0000: \***    MODIFICATIONS
1854: 0000: \***
1855: 0000: \***    Version A.          Mark Walker                 26th Sep 2017
1856: 0000: \***    Initial version.
1857: 0000: \***
1858: 0000: \***********************************************************************
1859: 0000: \***********************************************************************
1860: 0000: 
1861: 0000: FUNCTION EVLOG.SET EXTERNAL
1862: 0000: END FUNCTION
1863: 0000: 
1864: 0000: FUNCTION READ.EVLOG EXTERNAL
1865: 0000: INTEGER*1 READ.EVLOG
1866: 0000: END FUNCTION
1867: 0000: 
1868: 0000: FUNCTION WRITE.EVLOG EXTERNAL
1869: 0000: INTEGER*1 WRITE.EVLOG
1870: 0000: END FUNCTION
1871: 0000: 
1872: 0000: %INCLUDE CLLOGEXT.J86   ! Command line log file
1873: 0000: \***********************************************************************
1874: 0000: \***********************************************************************
1875: 0000: \***
1876: 0000: \***    EXTERNAL FUNCTION DEFINITIONS FOR COMMAND LINE LOG FILE
1877: 0000: \***                       (ADXCLLOG.DAT)
1878: 0000: \***
1879: 0000: \***********************************************************************
1880: 0000: \***********************************************************************
1881: 0000: \***
1882: 0000: \***    MODIFICATIONS
1883: 0000: \***
1884: 0000: \***    Version A.          Mark Walker                 29th Sep 2017
1885: 0000: \***    Initial version.
1886: 0000: \***
1887: 0000: \***********************************************************************
1888: 0000: \***********************************************************************
1889: 0000: 
1890: 0000: FUNCTION CLLOG.SET EXTERNAL
1891: 0000: END FUNCTION
1892: 0000: 
1893: 0000: FUNCTION READ.CLLOG EXTERNAL
1894: 0000: INTEGER*1 READ.CLLOG
1895: 0000: END FUNCTION
1896: 0000: 
1897: 0000: 
1898: 0000: FUNCTION MATCHB(P1$,P2$,P3) EXTERNAL                                    !CMW
1899: 0000:     INTEGER*2 MATCHB                                                    !CMW
1900: 0000:     STRING P1$                                                          !CMW
1901: 0000:     STRING P2$                                                          !CMW
1902: 0000:     INTEGER*2 P3                                                        !CMW
1903: 0000: END FUNCTION                                                            !CMW
1904: 0000: 
1905: 0000: FUNCTION ?VAL(S$) EXTERNAL                                              !IMW
1906: 0000:     INTEGER*4 ?VAL                                                      !IMW
1907: 0000:     STRING S$                                                           !IMW
1908: 0000: END FUNCTION                                                            !IMW
1909: 0000:                                                                         !IMW
1910: 0000: FUNCTION PAD$(S$,N%) EXTERNAL                                           !IMW
1911: 0000:     STRING PAD$,S$                                                      !IMW
1912: 0000:     INTEGER*2 N%                                                        !IMW
1913: 0000: END FUNCTION                                                            !IMW
1914: 0000: 
1915: 0000: FUNCTION ASC.TEXT$(A$) EXTERNAL                                         !IMW
1916: 0000:     STRING ASC.TEXT$,A$                                                 !IMW
1917: 0000: END FUNCTION                                                            !IMW
1918: 0000: 
1919: 0000: FUNCTION HEX.TEXT$(H$) EXTERNAL                                         !IMW
1920: 0000:     STRING HEX.TEXT$,H$                                                 !IMW
1921: 0000: END FUNCTION                                                            !IMW
1922: 0000: 
1923: 0000: FUNCTION INV.TEXT$(S$) EXTERNAL                                         !IMW
1924: 0000:     STRING INV.TEXT$,S$                                                 !IMW
1925: 0000: END FUNCTION                                                            !IMW
1926: 0000: 
1927: 0000: FUNCTION IS.DIGITS(DATA$) EXTERNAL                                      !IMW
1928: 0000:     INTEGER*1 IS.DIGITS                                                 !IMW
1929: 0000:     STRING DATA$                                                        !IMW
1930: 0000: END FUNCTION                                                            !IMW
1931: 0000: 
1932: 0000: SUB LAST.TIME(H%,M%) EXTERNAL                                           !IMW
1933: 0000:     INTEGER*2 H%,M%                                                     !IMW
1934: 0000: END SUB                                                                 !IMW
1935: 0000: 
1936: 0000: SUB NEXT.TIME(H%,M%) EXTERNAL                                           !IMW
1937: 0000:     INTEGER*2 H%,M%                                                     !IMW
1938: 0000: END SUB                                                                 !IMW
1939: 0000: 
1940: 0000: FUNCTION READ.ULOG EXTERNAL                                             !IMW
1941: 0000:     INTEGER*1 READ.ULOG                                                 !IMW
1942: 0000: END FUNCTION                                                            !IMW
1943: 0000: 
1944: 0000: FUNCTION FIND.PROGRAM.PAIR EXTERNAL                                     !IMW
1945: 0000:     INTEGER*1 FIND.PROGRAM.PAIR                                         !IMW
1946: 0000: END FUNCTION                                                            !IMW
1947: 0000: 
1948: 0000: FUNCTION GET.APPLICATION$(R$) EXTERNAL                                  !IMW
1949: 0000:     STRING GET.APPLICATION$,R$                                          !IMW
1950: 0000: END FUNCTION                                                            !IMW
1951: 0000: 
1952: 0000: FUNCTION GET.APPLICATION.DESCRIPTION$(P$) EXTERNAL                      !JMW
1953: 0000:     STRING GET.APPLICATION.DESCRIPTION$                                 !JMW
1954: 0000:     STRING P$                                                           !JMW
1955: 0000: END FUNCTION                                                            !JMW
1956: 0000: 
1957: 0000: FUNCTION UNCOMPRESS$(S$) EXTERNAL                                       !KMW
1958: 0000:     STRING UNCOMPRESS$,S$                                               !KMW
1959: 0000: END FUNCTION                                                            !KMW
1960: 0000:                                                                         !KMW
1961: 0000: SUB DISPLAY.SECTOR(H%) EXTERNAL                                         !KMW
1962: 0000:     INTEGER*1 H%                                                        !KMW
1963: 0000: END SUB                                                                 !KMW
1964: 0000: 
1965: 0000: SUB PSU0401 EXTERNAL
1966: 0000: END SUB
1967: 0000: 
1968: 0000: SUB PSU0402 EXTERNAL
1969: 0000: END SUB
1970: 0000: 
1971: 0000: SUB PSU0403 EXTERNAL
1972: 0000: END SUB
1973: 0000: 
1974: 0000: SUB PSU0404 EXTERNAL
1975: 0000: END SUB
1976: 0000: 
1977: 0000: SUB PSU0406 EXTERNAL
1978: 0000: END SUB
1979: 0000: 
1980: 0000: \***********************************************************************
1981: 0000: \***                                                                    
1982: 0000: \***    SET.APPLICATION.FLAGS                                           
1983: 0000: \***                                                                    
1984: 0000: \***********************************************************************
1985: 0000: \***                                                                    
1986: 0000: \***    Sets or clears specified application flags                      
1987: 0000: \***                                                                    
1988: 0000: \***********************************************************************
1989: 0000: SUB SET.APPLICATION.FLAGS(I%,FLAG%)
1990: 0024: 
1991: 0024:     INTEGER*1 FLAG%
1992: 0024:     INTEGER*2 FLAG.INDEX%,SELECTION.INDEX%,I%
1993: 0024: 
1994: 0024:     ! Set all individual application selection flags
1995: 0024:     FOR FLAG.INDEX% = 11 TO LEN(APPLICATION.RECORD$(I%)) STEP 2
1996: 0034: 
1997: 0034:         SELECTION.INDEX% =                                          \
1998: 0064:             GETN2(APPLICATION.RECORD$(I%),FLAG.INDEX% - 1)
1999: 0064: 
2000: 0064:         ! Set application flag according to the selection
2001: 0064:         SELECTION.APPLICATION(SELECTION.INDEX%) = (FLAG% = 58H)
2002: 0092: 
2003: 0092:     NEXT FLAG.INDEX%
2004: 00ca: 
2005: 00ca: END SUB
2006: 00de: 
2007: 00de: \***********************************************************************!BMW
2008: 00de: \***                                                                    !BMW
2009: 00de: \***    SET.SOURCE.FLAGS                                                !BMW
2010: 00de: \***                                                                    !BMW
2011: 00de: \***********************************************************************!BMW
2012: 00de: \***                                                                    !BMW
2013: 00de: \***    Sets or clears specified source flags                           !BMW
2014: 00de: \***                                                                    !BMW
2015: 00de: \***********************************************************************!BMW
2016: 00de: SUB SET.SOURCE.FLAGS(I%,FLAG%)                                          !BMW
2017: 0102:                                                                         !BMW
2018: 0102:     INTEGER*1 FLAG%                                                     !BMW
2019: 0102:     INTEGER*2 FLAG.INDEX%,SELECTION.INDEX%,I%                           !BMW
2020: 0102:                                                                         !BMW
2021: 0102:     ! Set all individual source selection flags                         !BMW
2022: 0102:     FOR FLAG.INDEX% = 1 TO LEN(SOURCE.LIST$(I%)) STEP 2                 !BMW
2023: 0112:                                                                         !BMW
2024: 0112:         SELECTION.INDEX% =                                          \   !BMW
2025: 0142:             GETN2(SOURCE.LIST$(I%),FLAG.INDEX% - 1)                     !BMW
2026: 0142:                                                                         !BMW
2027: 0142:         ! Set source flag according to the selection                    !BMW
2028: 0142:         SELECTION.SOURCE(SELECTION.INDEX%) = (FLAG% = 58H)              !BMW
2029: 0170:                                                                         !BMW
2030: 0170:     NEXT FLAG.INDEX%                                                    !BMW
2031: 01a8:                                                                         !BMW
2032: 01a8: END SUB                                                                 !BMW
2033: 01bc:                                                                         !BMW
2034: 01bc: \***********************************************************************
2035: 01bc: \***
2036: 01bc: \***    SET.SELECTION.APPLICATION
2037: 01bc: \***
2038: 01bc: \***********************************************************************
2039: 01bc: \***
2040: 01bc: \***    Sets or clears all application flags and application selection
2041: 01bc: \***
2042: 01bc: \***********************************************************************
2043: 01bc: SUB SET.SELECTION.APPLICATION(SOURCE.POS%,DEST.POS%)
2044: 01e0: 
2045: 01e0:     INTEGER*1 FLAG%
2046: 01e0:     INTEGER*2 SOURCE.POS%,DEST.POS%
2047: 01e0: 
2048: 01e0:     APPLICATION.SELECTED.COUNT% = 0
2049: 01ee: 
2050: 01ee:     ! FOR each application
2051: 01ee:     FOR APPLICATION.INDEX% = 1 TO APPLICATION.COUNT%
2052: 01ff: 
2053: 01ff:         ! Move previous selection to current selection
2054: 01ff:         FLAG% = GETN1(APPLICATION.RECORD$(APPLICATION.INDEX%),      \
2055: 0230:                       SOURCE.POS% - 1)
2056: 0230:         CALL PUTN1(APPLICATION.RECORD$(APPLICATION.INDEX%),         \
2057: 0263:                    DEST.POS% - 1,                                   \
2058: 0263:                    FLAG%)
2059: 0263: 
2060: 0263:         CALL SET.APPLICATION.FLAGS(APPLICATION.INDEX%,FLAG%)
2061: 027a: 
2062: 027a:         ! IF application selected
2063: 027a:         IF FLAG% = 58H THEN BEGIN
2064: 0289:             APPLICATION.SELECTED.COUNT% =                           \
2065: 0295:                 APPLICATION.SELECTED.COUNT% + 1
2066: 0295:         ENDIF
2067: 029d: 
2068: 029d:     NEXT APPLICATION.INDEX%
2069: 02b8: 
2070: 02b8:     ! IF select none
2071: 02b8:     IF APPLICATION.SELECTED.COUNT% = 0 THEN BEGIN
2072: 02c7: 
2073: 02c7:         ! ---------------------------------------------
2074: 02c7:         ! Fake a multiple exclusion here to prevent the
2075: 02c7:         ! system considering the null application name
2076: 02c7:         ! to mean that 'all' applications should be
2077: 02c7:         ! selected.
2078: 02c7:         ! ---------------------------------------------
2079: 02c7:         SELECTION.FIELD$(U0401.APPLICATION%) = "-"
2080: 02f1: 
2081: 02f1:     ! IF select single
2082: 02f1:     ENDIF ELSE IF APPLICATION.SELECTED.COUNT% = 1 THEN BEGIN
2083: 0303: 
2084: 0303:         APPLICATION.INDEX% = 0
2085: 0311: 
2086: 0311:         APPLICATION.FOUND = FALSE
2087: 0323: 
2088: 0323:         WHILE (NOT APPLICATION.FOUND) AND \
2089: 032e:               (APPLICATION.INDEX% < APPLICATION.COUNT%)
2090: 032e: 
2091: 032e:             APPLICATION.INDEX% = APPLICATION.INDEX% + 1
2092: 033a: 
2093: 033a:             FLAG% = 58H ! "X"
2094: 0347: 
2095: 0347:             ! IF single selected application found
2096: 0347:             IF GETN1(APPLICATION.RECORD$(APPLICATION.INDEX%),       \
2097: 0384:                      DEST.POS% - 1) = FLAG% THEN BEGIN
2098: 0384: 
2099: 0384:                 ! IF 'null' application name selected
2100: 0384:                 IF LEFT$(APPLICATION.RECORD$(                       \
2101: 03c4:                              APPLICATION.INDEX%),8) = "" THEN BEGIN
2102: 03c4: 
2103: 03c4:                     ! ---------------------------------------------
2104: 03c4:                     ! Fake a multiple selection here to prevent the
2105: 03c4:                     ! system considering the null application name
2106: 03c4:                     ! to mean that 'all' applications should be
2107: 03c4:                     ! selected.
2108: 03c4:                     ! ---------------------------------------------
2109: 03c4:                     SELECTION.FIELD$(U0401.APPLICATION%) = "+"
2110: 03ed: 
2111: 03ed:                 ENDIF ELSE BEGIN
2112: 03f5: 
2113: 03f5:                     ! Set selection field to application name
2114: 03f5:                     SELECTION.FIELD$(U0401.APPLICATION%) =          \
2115: 0437:                         LEFT$(APPLICATION.RECORD$(                  \
2116: 0437:                                   APPLICATION.INDEX%),8)
2117: 0437: 
2118: 0437:                 ENDIF
2119: 043f:                 APPLICATION.FOUND = TRUE
2120: 0451:             ENDIF
2121: 0459: 
2122: 0459:         WEND
2123: 047e: 
2124: 047e:     ! IF select all
2125: 047e:     ENDIF ELSE IF APPLICATION.SELECTED.COUNT% =                     \
2126: 048f:                       APPLICATION.COUNT% THEN BEGIN
2127: 048f:         SELECTION.FIELD$(U0401.APPLICATION%) = "*"
2128: 04b9:     ! IF exclude some
2129: 04b9:     ENDIF ELSE IF APPLICATION.SELECTED.COUNT% >                     \
2130: 04f2:                       INT(APPLICATION.COUNT% / 2) THEN BEGIN
2131: 04f2:         SELECTION.FIELD$(U0401.APPLICATION%) = "-"
2132: 051b:     ! IF select some
2133: 051b:     ENDIF ELSE BEGIN
2134: 0523:         SELECTION.FIELD$(U0401.APPLICATION%) = "+"
2135: 054a:     ENDIF
2136: 0552: 
2137: 0552:     LAST.APPLICATION$ = SELECTION.FIELD$(U0401.APPLICATION%)
2138: 057e: 
2139: 057e: END SUB
2140: 0592: 
2141: 0592: \***********************************************************************
2142: 0592: \***
2143: 0592: \***    SET.SELECTION.SEVERITY
2144: 0592: \***
2145: 0592: \***********************************************************************
2146: 0592: \***
2147: 0592: \***    Sets or clears all severity flags and severity selection
2148: 0592: \***
2149: 0592: \***********************************************************************
2150: 0592: SUB SET.SELECTION.SEVERITY(SOURCE.POS%,DEST.POS%)
2151: 05b6: 
2152: 05b6:     INTEGER*1 FLAG%
2153: 05b6:     INTEGER*2 SOURCE.POS%,DEST.POS%
2154: 05b6: 
2155: 05b6:     SEVERITY.SELECTED.COUNT% = 0
2156: 05c4: 
2157: 05c4:     ! FOR each application
2158: 05c4:     FOR SEVERITY.INDEX% = 0 TO (SEVERITY.COUNT% - 1)
2159: 05d5: 
2160: 05d5:         ! Move previous selection to current selection
2161: 05d5:         FLAG% = GETN1(SEVERITY.RECORD$(SEVERITY.INDEX%),            \
2162: 0606:                       SOURCE.POS% - 1)
2163: 0606:         CALL PUTN1(SEVERITY.RECORD$(SEVERITY.INDEX%),               \
2164: 0639:                    DEST.POS% - 1,                                   \
2165: 0639:                    FLAG%)
2166: 0639: 
2167: 0639:         ! Set severity flag according to the selection
2168: 0639:         SELECTION.SEVERITY(SEVERITY.INDEX%) = (FLAG% = 58H)
2169: 0664: 
2170: 0664:         ! IF severity selected
2171: 0664:         IF FLAG% = 58H THEN BEGIN
2172: 0673:             SEVERITY.SELECTED.COUNT% = SEVERITY.SELECTED.COUNT% + 1
2173: 067f:         ENDIF
2174: 0687: 
2175: 0687:     NEXT SEVERITY.INDEX%
2176: 06a3: 
2177: 06a3:     ! IF select single
2178: 06a3:     IF SEVERITY.SELECTED.COUNT% = 1 THEN BEGIN
2179: 06b5: 
2180: 06b5:         SEVERITY.INDEX% = 0
2181: 06c3: 
2182: 06c3:         SEVERITY.FOUND = FALSE
2183: 06d5: 
2184: 06d5:         WHILE (NOT SEVERITY.FOUND) AND \
2185: 06e0:               (SEVERITY.INDEX% < SEVERITY.COUNT%)
2186: 06e0: 
2187: 06e0:             SEVERITY.INDEX% = SEVERITY.INDEX% + 1
2188: 06ec: 
2189: 06ec:             FLAG% = 58H ! "X"
2190: 06f9: 
2191: 06f9:             ! IF single selected severity found
2192: 06f9:             IF GETN1(SEVERITY.RECORD$(SEVERITY.INDEX% - 1),         \
2193: 0734:                      DEST.POS% - 1) = FLAG% THEN BEGIN
2194: 0734:                 SELECTION.FIELD$(U0401.SEVERITY%) =                 \
2195: 0763:                     STR$(SEVERITY.INDEX% - 1)
2196: 0763:                 SEVERITY.FOUND = TRUE
2197: 0775:             ENDIF
2198: 077d: 
2199: 077d:         WEND
2200: 07a2: 
2201: 07a2:     ! IF select all
2202: 07a2:     ENDIF ELSE IF SEVERITY.SELECTED.COUNT% =                        \
2203: 07b3:                       SEVERITY.COUNT% THEN BEGIN
2204: 07b3:         SELECTION.FIELD$(U0401.SEVERITY%) = "*"
2205: 07dd:     ! IF exclude some
2206: 07dd:     ENDIF ELSE IF SEVERITY.SELECTED.COUNT% >                        \
2207: 0816:                       INT(SEVERITY.COUNT% / 2) THEN BEGIN
2208: 0816:         SELECTION.FIELD$(U0401.SEVERITY%) = "-"
2209: 083f:     ! IF select some
2210: 083f:     ENDIF ELSE BEGIN
2211: 0847:         SELECTION.FIELD$(U0401.SEVERITY%) = "+"
2212: 086e:     ENDIF
2213: 0876: 
2214: 0876:     LAST.SEVERITY$ = SELECTION.FIELD$(U0401.SEVERITY%)
2215: 08a2: 
2216: 08a2: END SUB
2217: 08b6: 
2218: 08b6: \***********************************************************************
2219: 08b6: \***
2220: 08b6: \***    SET.SELECTION.BUCKET
2221: 08b6: \***
2222: 08b6: \***********************************************************************
2223: 08b6: \***
2224: 08b6: \***    Sets or clears all bucket flags and bucket selection
2225: 08b6: \***
2226: 08b6: \***********************************************************************
2227: 08b6: SUB SET.SELECTION.BUCKET(SOURCE.POS%,DEST.POS%)
2228: 08da: 
2229: 08da:     INTEGER*1 FLAG%
2230: 08da:     INTEGER*2 SOURCE.POS%,DEST.POS%
2231: 08da: 
2232: 08da:     BUCKET.SELECTED.COUNT% = 0
2233: 08e8: 
2234: 08e8:     ! FOR each application
2235: 08e8:     FOR BUCKET.INDEX% = 0 TO (BUCKET.COUNT% - 1)
2236: 08f9: 
2237: 08f9:         ! Move previous selection to current selection
2238: 08f9:         FLAG% = GETN1(BUCKET.RECORD$(BUCKET.INDEX%),                \
2239: 092a:                       SOURCE.POS% - 1)
2240: 092a:         CALL PUTN1(BUCKET.RECORD$(BUCKET.INDEX%),                   \
2241: 095d:                    DEST.POS% - 1,                                   \
2242: 095d:                    FLAG%)
2243: 095d: 
2244: 095d:         ! Set severity flag according to the selection
2245: 095d:         SELECTION.BUCKET(BUCKET.INDEX%) = (FLAG% = 58H)
2246: 0988: 
2247: 0988:         ! IF bucket selected
2248: 0988:         IF FLAG% = 58H THEN BEGIN
2249: 0997:             BUCKET.SELECTED.COUNT% = BUCKET.SELECTED.COUNT% + 1
2250: 09a3:         ENDIF
2251: 09ab: 
2252: 09ab:     NEXT BUCKET.INDEX%
2253: 09c7: 
2254: 09c7:     ! IF select single
2255: 09c7:     IF BUCKET.SELECTED.COUNT% = 1 THEN BEGIN
2256: 09d9: 
2257: 09d9:         BUCKET.INDEX% = 0
2258: 09e7: 
2259: 09e7:         BUCKET.FOUND = FALSE
2260: 09f9: 
2261: 09f9:         WHILE (NOT BUCKET.FOUND) AND \
2262: 0a04:               (BUCKET.INDEX% < BUCKET.COUNT%)
2263: 0a04: 
2264: 0a04:             BUCKET.INDEX% = BUCKET.INDEX% + 1
2265: 0a10: 
2266: 0a10:             FLAG% = 58H ! "X"
2267: 0a1d: 
2268: 0a1d:             ! IF single selected bucket found
2269: 0a1d:             IF GETN1(BUCKET.RECORD$(BUCKET.INDEX% - 1),             \
2270: 0a58:                      DEST.POS% - 1) = FLAG% THEN BEGIN
2271: 0a58:                 SELECTION.FIELD$(U0401.BUCKET%) =                   \
2272: 0a87:                     STR$(BUCKET.INDEX% - 1)
2273: 0a87:                 BUCKET.FOUND = TRUE
2274: 0a99:             ENDIF
2275: 0aa1: 
2276: 0aa1:         WEND
2277: 0ac6: 
2278: 0ac6:     ! IF select all
2279: 0ac6:     ENDIF ELSE IF BUCKET.SELECTED.COUNT% = BUCKET.COUNT% THEN BEGIN
2280: 0ad7:         SELECTION.FIELD$(U0401.BUCKET%) = "*"
2281: 0b01:     ! IF exclude some
2282: 0b01:     ENDIF ELSE IF BUCKET.SELECTED.COUNT% >                          \
2283: 0b3a:                       INT(BUCKET.COUNT% / 2) THEN BEGIN
2284: 0b3a:         SELECTION.FIELD$(U0401.BUCKET%) = "-"
2285: 0b63:     ! IF select some
2286: 0b63:     ENDIF ELSE BEGIN
2287: 0b6b:         SELECTION.FIELD$(U0401.BUCKET%) = "+"
2288: 0b92:     ENDIF
2289: 0b9a: 
2290: 0b9a:     LAST.BUCKET$ = SELECTION.FIELD$(U0401.BUCKET%)
2291: 0bc6: 
2292: 0bc6: END SUB
2293: 0bda: 
2294: 0bda: \***********************************************************************!BMW
2295: 0bda: \***                                                                    !BMW
2296: 0bda: \***    SET.SELECTION.SOURCE                                            !BMW
2297: 0bda: \***                                                                    !BMW
2298: 0bda: \***********************************************************************!BMW
2299: 0bda: \***                                                                    !BMW
2300: 0bda: \***    Sets or clears all source flags and source selection            !BMW
2301: 0bda: \***                                                                    !BMW
2302: 0bda: \***********************************************************************!BMW
2303: 0bda: SUB SET.SELECTION.SOURCE(SOURCE.POS%,DEST.POS%)                         !BMW
2304: 0bfe:                                                                         !BMW
2305: 0bfe:     INTEGER*1 FLAG%                                                     !BMW
2306: 0bfe:     INTEGER*2 SOURCE.POS%,DEST.POS%                                     !BMW
2307: 0bfe:                                                                         !BMW
2308: 0bfe:     SOURCE.SELECTED.COUNT% = 0                                          !BMW
2309: 0c0c:                                                                         !BMW
2310: 0c0c:     ! FOR each application                                              !BMW
2311: 0c0c:     FOR SOURCE.INDEX% = 1 TO SOURCE.COUNT%                              !BMW
2312: 0c1d:                                                                         !BMW
2313: 0c1d:         ! Move previous selection to current selection                  !BMW
2314: 0c1d:         FLAG% = GETN1(SOURCE.RECORD$(SOURCE.INDEX%),            \       !BMW
2315: 0c4e:                       SOURCE.POS% - 1)                                  !BMW
2316: 0c4e:         CALL PUTN1(SOURCE.RECORD$(SOURCE.INDEX%),               \       !BMW
2317: 0c81:                    DEST.POS% - 1,FLAG%)                                 !BMW
2318: 0c81:                                                                         !BMW
2319: 0c81:         CALL SET.SOURCE.FLAGS(SOURCE.INDEX%,FLAG%)                      !BMW
2320: 0c98:                                                                         !BMW
2321: 0c98:         ! IF source selected                                            !BMW
2322: 0c98:         IF FLAG% = 58H THEN BEGIN                                       !BMW
2323: 0ca7:             SOURCE.SELECTED.COUNT% = SOURCE.SELECTED.COUNT% + 1         !BMW
2324: 0cb3:         ENDIF                                                           !BMW
2325: 0cbb:                                                                         !BMW
2326: 0cbb:     NEXT SOURCE.INDEX%                                                  !BMW
2327: 0cd6:                                                                         !BMW
2328: 0cd6:     ! IF select single                                                  !BMW
2329: 0cd6:     IF SOURCE.SELECTED.COUNT% = 1 THEN BEGIN                            !BMW
2330: 0ce8:                                                                         !BMW
2331: 0ce8:         SOURCE.INDEX% = 0                                               !BMW
2332: 0cf6:                                                                         !BMW
2333: 0cf6:         SOURCE.FOUND = FALSE                                            !BMW
2334: 0d08:                                                                         !BMW
2335: 0d08:         WHILE (NOT SOURCE.FOUND) AND \                                  !BMW
2336: 0d13:               (SOURCE.INDEX% < SOURCE.COUNT%)                           !BMW
2337: 0d13:                                                                         !BMW
2338: 0d13:             SOURCE.INDEX% = SOURCE.INDEX% + 1                           !BMW
2339: 0d1f:                                                                         !BMW
2340: 0d1f:             FLAG% = 58H ! "X"                                           !BMW
2341: 0d2c:                                                                         !BMW
2342: 0d2c:             ! IF single selected source found                           !BMW
2343: 0d2c:             IF GETN1(SOURCE.RECORD$(SOURCE.INDEX%),                 \   !BMW
2344: 0d66:                      DEST.POS% - 1) = FLAG% THEN BEGIN                  !BMW
2345: 0d66:                 SELECTION.FIELD$(U0401.SOURCE%) =                   \   !BMW
2346: 0da8:                     LEFT$(SOURCE.RECORD$(SOURCE.INDEX%),3)              !BMW
2347: 0da8:                 SOURCE.FOUND = TRUE                                     !BMW
2348: 0dba:             ENDIF                                                       !BMW
2349: 0dc2:                                                                         !BMW
2350: 0dc2:         WEND                                                            !BMW
2351: 0de7:                                                                         !BMW
2352: 0de7:     ! IF select all                                                     !BMW
2353: 0de7:     ENDIF ELSE IF SOURCE.SELECTED.COUNT% =                          \   !BMW
2354: 0df8:                       SOURCE.COUNT% THEN BEGIN                          !BMW
2355: 0df8:         SELECTION.FIELD$(U0401.SOURCE%) = "*"                           !BMW
2356: 0e22:     ! IF exclude some                                                   !BMW
2357: 0e22:     ENDIF ELSE IF SOURCE.SELECTED.COUNT% >                          \   !BMW
2358: 0e5b:                       INT(SOURCE.COUNT% / 2) THEN BEGIN                 !BMW
2359: 0e5b:         SELECTION.FIELD$(U0401.SOURCE%) = "-"                           !BMW
2360: 0e84:     ! IF select some                                                    !BMW
2361: 0e84:     ENDIF ELSE BEGIN                                                    !BMW
2362: 0e8c:         SELECTION.FIELD$(U0401.SOURCE%) = "+"                           !BMW
2363: 0eb3:     ENDIF                                                               !BMW
2364: 0ebb:                                                                         !BMW
2365: 0ebb:     LAST.SOURCE$ = SELECTION.FIELD$(U0401.SOURCE%)                      !BMW
2366: 0ee7:                                                                         !BMW
2367: 0ee7: END SUB                                                                 !BMW
2368: 0efb:                                                                         !BMW
2369: 0efb: \***********************************************************************
2370: 0efb: \***
2371: 0efb: \***    CREATE.APPLICATION.LIST
2372: 0efb: \***
2373: 0efb: \***********************************************************************
2374: 0efb: \***
2375: 0efb: \***    Create sorted list of all available applications
2376: 0efb: \***
2377: 0efb: \***********************************************************************
2378: 0efb: SUB CREATE.APPLICATION.LIST(FULL.REBUILD,L$) PUBLIC
2379: 0f1f: 
2380: 0f1f:     INTEGER*1 FULL.REBUILD
2381: 0f1f:     INTEGER*1 SELECTION.DEFAULT
2382: 0f1f:     INTEGER*1 THIS.SELECTION%
2383: 0f1f:     INTEGER*1 LAST.SELECTION%
2384: 0f1f: 
2385: 0f1f:     INTEGER*2 CURRENT.LOG%
2386: 0f1f:     INTEGER*2 I%
2387: 0f1f:     INTEGER*2 LAST.RECORD.COUNT%
2388: 0f1f:     INTEGER*2 TEMP.APPLICATION.COUNT%
2389: 0f1f:     INTEGER*2 UNMERGED.APPLICATION.COUNT%
2390: 0f1f:     INTEGER*2 THIS.SOURCE%                                              !BMW
2391: 0f1f: 
2392: 0f1f:     STRING L$
2393: 0f1f:     STRING LAST.PROGRAM$
2394: 0f1f:     STRING TEMP.APPLICATION$(1)
2395: 0f1f:     STRING TEMP.STR$
2396: 0f1f:     STRING THIS.PROGRAM$
2397: 0f1f: 
2398: 0f1f:     ! IF full application index rebuild required
2399: 0f1f:     IF FULL.REBUILD THEN BEGIN
2400: 0f30:         LAST.RECORD.COUNT% = 0
2401: 0f40:     ! IF a partial application index rebuild required
2402: 0f40:     ENDIF ELSE BEGIN
2403: 0f48:         LAST.RECORD.COUNT% = LOG.RECORD.COUNT%
2404: 0f5a:     ENDIF
2405: 0f62: 
2406: 0f62:     ! Get current event log number
2407: 0f62:     CURRENT.LOG% = VAL(L$)
2408: 0f7e: 
2409: 0f7e:     ! Get event log file name
2410: 0f7e:     LOG.FILE.NAME$ = EVLOG.FILE.NAME$ + PAD$(L$,2)
2411: 0fae: 
2412: 0fae:     ! Get event log file size
2413: 0fae:     LOG.FILE.SIZE% = SIZE(LOG.FILE.NAME$)
2414: 0fd0: 
2415: 0fd0:     ! IF event log file is not empty
2416: 0fd0:     IF LOG.FILE.SIZE% > 0 THEN BEGIN
2417: 0fec: 
2418: 0fec:         ! IF currently active event log file                            !JMW
2419: 0fec:         IF CURRENT.LOG% = 0 THEN BEGIN                                  !JMW
2420: 0ffb:                                                                         !JMW
2421: 0ffb:             ! Open event log file for reading
2422: 0ffb:             OPEN LOG.FILE.NAME$ DIRECT RECL EVLOG.RECL%             \
2423: 1027:                 AS EVLOG.SESS.NUM% NOWRITE NODEL
2424: 1027:                                                                         !JMW
2425: 1027:         ENDIF ELSE BEGIN                                                !JMW
2426: 102f:                                                                         !JMW
2427: 102f:             ! Open event log file for exclusive reading                 !JMW
2428: 102f:             OPEN LOG.FILE.NAME$ DIRECT RECL EVLOG.RECL%             \   !JMW
2429: 105a:                 AS EVLOG.SESS.NUM%                                  \   !JMW
2430: 105a:                 BUFFSIZE 32256 LOCKED NOWRITE NODEL                     !JMW
2431: 105a:                                                                         !JMW
2432: 105a:         ENDIF                                                           !JMW
2433: 1062:                                                                         !JMW
2434: 1062:         ! Calculate record position of the last record
2435: 1062:         LOG.RECORD.COUNT% =                                         \
2436: 10a1:             INT(LOG.FILE.SIZE% / EVLOG.RECL%)
2437: 10a1: 
2438: 10a1:         ! Calculate maximum possible number of merged applications
2439: 10a1:         TEMP.APPLICATION.COUNT% = APPLICATION.COUNT% +              \
2440: 10c8:                                   LOG.RECORD.COUNT% -               \
2441: 10c8:                                   LAST.RECORD.COUNT%
2442: 10c8: 
2443: 10c8:         DIM TEMP.APPLICATION$(TEMP.APPLICATION.COUNT%)
2444: 10f3: 
2445: 10f3:         ! IF new event log file specified
2446: 10f3:         IF LAST.RECORD.COUNT% = 0 THEN BEGIN
2447: 1102:             
2448: 1102:             ! Reset event log records                                   !BMW
2449: 1102:             DIM LOG.RECORD$(EVLOG.MAX.RECORDS%)
2450: 1130:         
2451: 1130:             ! Reset source list (but NOT source records)                !BMW
2452: 1130:             DIM SOURCE.LIST$(SOURCE.COUNT%)                             !BMW
2453: 115b:         
2454: 115b:         ENDIF
2455: 1163: 
2456: 1163:         DIM SELECTION.APPLICATION(LOG.RECORD.COUNT%)
2457: 1192:         DIM SELECTION.SOURCE(LOG.RECORD.COUNT%)                         !BMW
2458: 11c1: 
2459: 11c1:         ! IF applications already available
2460: 11c1:         IF APPLICATION.COUNT% > 0 THEN BEGIN
2461: 11d3: 
2462: 11d3:             ! Set to true if more than half of
2463: 11d3:             ! applications previously selected
2464: 11d3:             SELECTION.DEFAULT =                                     \
2465: 11f2:                 (APPLICATION.SELECTED.COUNT% >                      \
2466: 11f2:                     (APPLICATION.COUNT% / 2))
2467: 11f2: 
2468: 11f2:             ! FOR each existing event log
2469: 11f2:             FOR I% = 1 TO APPLICATION.COUNT%
2470: 1203: 
2471: 1203:                 ! IF current event log file specified AND
2472: 1203:                 !    this is an update to the event logs
2473: 1203:                 IF CURRENT.LOG% = 0 AND                             \
2474: 1228:                    LAST.RECORD.COUNT% > 0 THEN BEGIN
2475: 1228:                     ! Keep application selections and all
2476: 1228:                     ! previous application selection flags
2477: 1228:                     TEMP.APPLICATION$(I%) = APPLICATION.RECORD$(I%)
2478: 125e:                 ENDIF ELSE BEGIN
2479: 1266:                     ! Keep application selections only
2480: 1266:                     TEMP.APPLICATION$(I%) =                         \
2481: 12a3:                         LEFT$(APPLICATION.RECORD$(I%),10)
2482: 12a3:                 ENDIF
2483: 12ab: 
2484: 12ab:             NEXT I%
2485: 12c8: 
2486: 12c8:         ENDIF ELSE BEGIN
2487: 12d0:             SELECTION.DEFAULT = TRUE
2488: 12e2:         ENDIF
2489: 12ea: 
2490: 12ea:         UNMERGED.APPLICATION.COUNT% = APPLICATION.COUNT%
2491: 12f8: 
2492: 12f8:         LAST.PROGRAM$ = "QQQQQQQQ" ! Dummy last program name
2493: 130d: 
2494: 130d:         ! For each event log
2495: 130d:         FOR EVLOG.RECORD.NUMBER% =                                  \
2496: 132a:             (LAST.RECORD.COUNT% + 1) TO LOG.RECORD.COUNT%
2497: 132a: 
2498: 132a:             ! Read next record from event log file
2499: 132a:             EVLOG.RC% = READ.EVLOG
2500: 133a: 
2501: 133a:             ! Store event log record
2502: 133a:             LOG.RECORD$(EVLOG.RECORD.NUMBER%) = EVLOG.RECORD$
2503: 136b: 
2504: 136b:             ! Get application name from current event log record        !BMW
2505: 136b:             THIS.PROGRAM$ = GET.APPLICATION$(EVLOG.RECORD$)
2506: 138c:             
2507: 138c:             ! Put record index integer into a temporary string          !BMW
2508: 138c:             TEMP.STR$ = STRING$(2,CHR$(0))
2509: 13ab:             CALL PUTN2(TEMP.STR$,0,EVLOG.RECORD.NUMBER%)
2510: 13d1: 
2511: 13d1:             ! Get source from current event log record                  !BMW
2512: 13d1:             THIS.SOURCE% = GETN1(EVLOG.RECORD$,8)                       !BMW
2513: 13f1:                                                                         !BMW
2514: 13f1:             ! Add record index to source list index                     !BMW
2515: 13f1:             SOURCE.LIST$(SOURCE.MAP%(THIS.SOURCE%)) =               \   !BMW
2516: 144c:                 SOURCE.LIST$(SOURCE.MAP%(THIS.SOURCE%)) +           \   !BMW
2517: 144c:                 TEMP.STR$                                               !BMW
2518: 144c: 
2519: 144c:             ! IF program is different from the last
2520: 144c:             IF NOT LAST.PROGRAM$ = THIS.PROGRAM$ THEN BEGIN
2521: 146b: 
2522: 146b:                 UNMERGED.APPLICATION.COUNT% =                       \
2523: 1477:                     UNMERGED.APPLICATION.COUNT% + 1
2524: 1477: 
2525: 1477:                 ! Create new application list index entry               !BMW
2526: 1477:                 TEMP.APPLICATION$(UNMERGED.APPLICATION.COUNT%) =    \
2527: 14b0:                     THIS.PROGRAM$ +                                 \
2528: 14b0:                     "Z" +                                           \
2529: 14b0:                     " " +                                           \
2530: 14b0:                     TEMP.STR$
2531: 14b0: 
2532: 14b0:                 LAST.PROGRAM$ = THIS.PROGRAM$
2533: 14cb: 
2534: 14cb:             ENDIF ELSE BEGIN
2535: 14d3:                 ! Add record index to application list index            !BMW
2536: 14d3:                 TEMP.APPLICATION$(UNMERGED.APPLICATION.COUNT%) =    \
2537: 1512:                    TEMP.APPLICATION$(UNMERGED.APPLICATION.COUNT%) + \
2538: 1512:                    TEMP.STR$
2539: 1512:             ENDIF
2540: 151a: 
2541: 151a:         NEXT EVLOG.RECORD.NUMBER%
2542: 154e: 
2543: 154e:         CLOSE EVLOG.SESS.NUM%
2544: 1562: 
2545: 1562:         ! Sort applications into alphabetical order
2546: 1562:         CALL CSORT(VARPTR(TEMP.APPLICATION$(0)),                    \
2547: 158b:                           UNMERGED.APPLICATION.COUNT%)
2548: 158b: 
2549: 158b:         LAST.PROGRAM$   = "QQQQQQQQ" ! Dummy last program name
2550: 15a0:         LAST.SELECTION% = 0          ! Dummy last selection
2551: 15ad: 
2552: 15ad:         DIM APPLICATION.RECORD$(UNMERGED.APPLICATION.COUNT%)
2553: 15d8:         DIM APPLICATION.DESC$(UNMERGED.APPLICATION.COUNT%)
2554: 1603: 
2555: 1603:         APPLICATION.COUNT% = 0
2556: 1611: 
2557: 1611:         ! For each unmerged application entry
2558: 1611:         FOR I% = 1 TO UNMERGED.APPLICATION.COUNT%
2559: 1622: 
2560: 1622:             ! Get application name
2561: 1622:             CALL EXTRACTS(TEMP.APPLICATION$(I%),THIS.PROGRAM$,1)
2562: 1652:             THIS.SELECTION% = GETN1(TEMP.APPLICATION$(I%),8)
2563: 167d: 
2564: 167d:             ! IF application is different from the last
2565: 167d:             IF (NOT LAST.PROGRAM$ = THIS.PROGRAM$) THEN BEGIN
2566: 169f: 
2567: 169f:                 ! IF new application
2568: 169f:                 IF THIS.SELECTION% = 5AH THEN BEGIN ! "Z"
2569: 16ae:                     ! IF selection by default
2570: 16ae:                     IF SELECTION.DEFAULT THEN BEGIN
2571: 16bd:                         THIS.SELECTION% = 58H ! "X"
2572: 16cc:                     ENDIF ELSE BEGIN
2573: 16d4:                         THIS.SELECTION% = 20H ! " "
2574: 16e1:                     ENDIF
2575: 16e9:                 ENDIF
2576: 16f1: 
2577: 16f1:                 APPLICATION.COUNT% = APPLICATION.COUNT% + 1
2578: 16fd: 
2579: 16fd:                 ! Create new application list index entry               !BMW
2580: 16fd:                 APPLICATION.RECORD$(APPLICATION.COUNT%) =           \
2581: 174a:                     THIS.PROGRAM$ + "  " +                          \
2582: 174a:                     MID$(TEMP.APPLICATION$(I%),11,32767)
2583: 174a: 
2584: 174a:                 LAST.PROGRAM$ = THIS.PROGRAM$
2585: 1766: 
2586: 1766:             ! IF application is the same as the last
2587: 1766:             ENDIF ELSE BEGIN
2588: 176e: 
2589: 176e:                 ! IF new application selection
2590: 176e:                 IF THIS.SELECTION% = 5AH THEN BEGIN
2591: 177d:                     ! Keep selection the same as before
2592: 177d:                     THIS.SELECTION% = LAST.SELECTION%
2593: 178b:                 ENDIF
2594: 1793: 
2595: 1793:                 ! Add record index to application list index            !BMW
2596: 1793:                 APPLICATION.RECORD$(APPLICATION.COUNT%) =           \
2597: 17ea:                     APPLICATION.RECORD$(APPLICATION.COUNT%) +       \
2598: 17ea:                     MID$(TEMP.APPLICATION$(I%),11,32767)
2599: 17ea: 
2600: 17ea:             ENDIF
2601: 17f2: 
2602: 17f2:             ! Set application selection
2603: 17f2:             CALL PUTN1(APPLICATION.RECORD$(                         \
2604: 181f:                 APPLICATION.COUNT%),8,THIS.SELECTION%)
2605: 181f: 
2606: 181f:             LAST.SELECTION% = THIS.SELECTION%
2607: 182d: 
2608: 182d:         NEXT I%
2609: 1848: 
2610: 1848:         ! Re-initialise source selected cout                            !BMW
2611: 1848:         SOURCE.SELECTED.COUNT% = 0                                      !BMW
2612: 1856:                                                                         !BMW
2613: 1856:         ! For each source entry                                         !BMW
2614: 1856:         FOR I% = 1 TO SOURCE.COUNT%                                     !BMW
2615: 1866:                                                                         !BMW
2616: 1866:             ! Get source selection                                      !BMW
2617: 1866:             THIS.SELECTION% = GETN1(SOURCE.RECORD$(I%),3)               !BMW
2618: 1891:                                                                         !BMW
2619: 1891:             ! Set all source selection flags                            !BMW
2620: 1891:             CALL SET.SOURCE.FLAGS(I%,THIS.SELECTION%)                   !BMW
2621: 18a8:                                                                         !BMW
2622: 18a8:             ! IF source selected                                        !BMW
2623: 18a8:             IF THIS.SELECTION% = 58H THEN BEGIN ! "X"                   !BMW
2624: 18b7:                 SOURCE.SELECTED.COUNT% =                            \   !BMW
2625: 18c3:                     SOURCE.SELECTED.COUNT% + 1                          !BMW
2626: 18c3:             ENDIF                                                       !BMW
2627: 18cb:                                                                         !BMW
2628: 18cb:         NEXT I%                                                         !BMW
2629: 18e3:                                                                         !BMW
2630: 18e3:         ! Re-initialise application selected cout                       !BMW
2631: 18e3:         APPLICATION.SELECTED.COUNT% = 0                                 !BMW
2632: 18f1:         
2633: 18f1:         ! For each merged application entry
2634: 18f1:         FOR I% = 1 TO APPLICATION.COUNT%
2635: 1901: 
2636: 1901:             ! Get application selection
2637: 1901:             THIS.SELECTION% = GETN1(APPLICATION.RECORD$(I%),8)
2638: 192c: 
2639: 192c:             ! Set all application selection flags
2640: 192c:             CALL SET.APPLICATION.FLAGS(I%,THIS.SELECTION%)
2641: 1943: 
2642: 1943:             ! IF application selected
2643: 1943:             IF THIS.SELECTION% = 58H THEN BEGIN ! "X"
2644: 1952:                 APPLICATION.SELECTED.COUNT% =                       \
2645: 195e:                     APPLICATION.SELECTED.COUNT% + 1
2646: 195e:             ENDIF
2647: 1966: 
2648: 1966:         NEXT I%
2649: 197e: 
2650: 197e:         ! Calculate total number of applications pages
2651: 197e:         APPLICATION.TOTAL.PAGES% =                                  \
2652: 19c9:             INT((APPLICATION.COUNT% - 1) /                          \
2653: 19c9:             APPLICATIONS.PER.PAGE%) + 1
2654: 19c9: 
2655: 19c9:         ! Calculate applications on the last page
2656: 19c9:         APPLICATION.LAST.PAGE% = APPLICATION.COUNT% -               \
2657: 19e9:             ((APPLICATION.TOTAL.PAGES% - 1) *                       \
2658: 19e9:             APPLICATIONS.PER.PAGE%)
2659: 19e9: 
2660: 19e9:         ! Clear temporary application work array
2661: 19e9:         DIM TEMP.APPLICATION$(0)
2662: 1a12: 
2663: 1a12:     ENDIF
2664: 1a1a: 
2665: 1a1a: END SUB
2666: 1a2e: 
2667: 1a2e: !\**********************************************************************!KMW
2668: 1a2e: !\***                                                                   !KMW
2669: 1a2e: !\***   DISPLAY.SECTOR                                                  !KMW
2670: 1a2e: !\***                                                                   !KMW
2671: 1a2e: !\**********************************************************************!KMW
2672: 1a2e: !\***                                                                   !KMW
2673: 1a2e: !\***   Display the comparison of the specified half of the sector      !KMW
2674: 1a2e: !\***                                                                   !KMW
2675: 1a2e: !\**********************************************************************!KMW
2676: 1a2e: !SUB DISPLAY.SECTOR(H%)                                                 !KMW
2677: 1a2e: !   INTEGER*1 H%                                                        !KMW
2678: 1a2e: !   INTEGER*2 I%,J%,K%,O%                                               !KMW
2679: 1a2e: !   STRING ROW$,BEFORE.ROW$,AFTER.ROW$,BEFORE.BYTE$,AFTER.BYTE$         !KMW
2680: 1a2e: !                                                                       !KMW
2681: 1a2e: !   O% = ((H% - 1) * 512) + 1                                           !KMW
2682: 1a2e: !                                                                       !KMW
2683: 1a2e: !   LOCATE 3,3,OFF                                                      !KMW
2684: 1a2e: !   PRINT "File name : ";MID$(ULOG.RECORD$(2),9,127)                    !KMW
2685: 1a2e: !   LOCATE 4,3,OFF                                                      !KMW
2686: 1a2e: !   PRINT "Sector    : ";LEFT$(ULOG.RECORD$(2),8)                       !KMW
2687: 1a2e: !                                                                       !KMW
2688: 1a2e: !   LOCATE 6,4,OFF                                                      !KMW
2689: 1a2e: !   PRINT STRING$(14,"_");"BEFORE";STRING$(15,"_");                 \   !KMW
2690: 1a2e: !         STRING$(3," ");                                           \   !KMW
2691: 1a2e: !         STRING$(15,"_");"AFTER";STRING$(15,"_")                       !KMW
2692: 1a2e: !                                                                       !KMW
2693: 1a2e: !   ! IF partial sector found                                           !KMW
2694: 1a2e: !   IF LEN(ULOG.RECORD$(3)) < 1024 THEN BEGIN                           !KMW
2695: 1a2e: !       ULOG.RECORD$(3) = LEFT$(ULOG.RECORD$(3) +                   \   !KMW
2696: 1a2e: !                         STRING$(512,"FF"),1024)                       !KMW
2697: 1a2e: !       ULOG.RECORD$(4) = LEFT$(ULOG.RECORD$(4) +                   \   !KMW
2698: 1a2e: !                         STRING$(512,"FF"),1024)                       !KMW
2699: 1a2e: !   ENDIF                                                               !KMW
2700: 1a2e: !                                                                       !KMW
2701: 1a2e: !   ! For each row                                                      !KMW
2702: 1a2e: !   FOR I% = 1 TO 16                                                    !KMW
2703: 1a2e: !                                                                       !KMW
2704: 1a2e: !       BEFORE.ROW$ = ""                                                !KMW
2705: 1a2e: !       AFTER.ROW$ = ""                                                 !KMW
2706: 1a2e: !                                                                       !KMW
2707: 1a2e: !       LOCATE I% + 6,4,OFF                                             !KMW
2708: 1a2e: !                                                                       !KMW
2709: 1a2e: !       FOR J% = 1 TO 4                                                 !KMW
2710: 1a2e: !           FOR K% = 1 TO 4                                             !KMW
2711: 1a2e: !               BEFORE.BYTE$ = MID$(ULOG.RECORD$(3),                \   !KMW
2712: 1a2e: !                   O% + ((J% - 1) * 8) + ((K% - 1) * 2),2)             !KMW
2713: 1a2e: !               AFTER.BYTE$  = MID$(ULOG.RECORD$(4),                \   !KMW
2714: 1a2e: !                   O% + ((J% - 1) * 8) + ((K% - 1) * 2),2)             !KMW
2715: 1a2e: !                                                                       !KMW
2716: 1a2e: !               BEFORE.ROW$ = BEFORE.ROW$ + BEFORE.BYTE$                !KMW
2717: 1a2e: !                                                                       !KMW
2718: 1a2e: !               IF BEFORE.BYTE$ = AFTER.BYTE$ THEN BEGIN                !KMW
2719: 1a2e: !                                                                       !KMW
2720: 1a2e: !                   AFTER.ROW$ = AFTER.ROW$ + AFTER.BYTE$               !KMW
2721: 1a2e: !                                                                       !KMW
2722: 1a2e: !               ENDIF ELSE BEGIN                                        !KMW
2723: 1a2e: !                                                                       !KMW
2724: 1a2e: !                   ! Highlight updated byte                            !KMW
2725: 1a2e: !                   AFTER.ROW$ = AFTER.ROW$ + INV.TEXT$(AFTER.BYTE$)    !KMW
2726: 1a2e: !                                                                       !KMW
2727: 1a2e: !               ENDIF                                                   !KMW
2728: 1a2e: !                                                                       !KMW
2729: 1a2e: !           NEXT K%                                                     !KMW
2730: 1a2e: !                                                                       !KMW
2731: 1a2e: !           BEFORE.ROW$ = BEFORE.ROW$ + " "                             !KMW
2732: 1a2e: !           AFTER.ROW$ = AFTER.ROW$ + " "                               !KMW
2733: 1a2e: !                                                                       !KMW
2734: 1a2e: !       NEXT J%                                                         !KMW
2735: 1a2e: !                                                                       !KMW
2736: 1a2e: !       O% = O% + 32                                                    !KMW
2737: 1a2e: !                                                                       !KMW
2738: 1a2e: !       ROW$ = BEFORE.ROW$ + "| " + AFTER.ROW$                          !KMW
2739: 1a2e: !                                                                       !KMW
2740: 1a2e: !       PRINT ROW$                                                      !KMW
2741: 1a2e: !                                                                       !KMW
2742: 1a2e: !   NEXT I%                                                             !KMW
2743: 1a2e: !                                                                       !KMW
2744: 1a2e: !END SUB                                                                !KMW
2745: 1a2e: !                                                                       !KMW
2746: 1a2e: \***********************************************************************
2747: 1a2e: \***
2748: 1a2e: \***    DM.FIELD.CHANGED
2749: 1a2e: \***
2750: 1a2e: \***********************************************************************
2751: 1a2e: \***
2752: 1a2e: \***    Display manager data field user exit
2753: 1a2e: \***
2754: 1a2e: \***********************************************************************
2755: 1a2e: SUB DM.FIELD.CHANGED(SCREEN%,FIELD%,VALUE$,VALID,UPDATE) PUBLIC
2756: 1a52: 
2757: 1a52:     INTEGER*2   SCREEN%     ! Current screen number
2758: 1a52:     INTEGER*2   FIELD%      ! Field modified
2759: 1a52:     STRING      VALUE$      ! New value for field (can be modified)
2760: 1a52:     INTEGER*1   VALID       ! Return false if field invalid
2761: 1a52:     INTEGER*1   UPDATE      ! Return true if updated output fields
2762: 1a52:     INTEGER*2   INDEX%
2763: 1a52:     STRING      FILE.NAME$
2764: 1a52:     INTEGER*1   FLAG.VALUE%
2765: 1a52: 
2766: 1a52:     ! IF selection screen
2767: 1a52:     IF SCREEN% = 1 THEN BEGIN
2768: 1a66: 
2769: 1a66:         ! IF Log number field
2770: 1a66:         IF FIELD% = U0401.LOG.NUMBER% THEN BEGIN
2771: 1a81: 
2772: 1a81:             VALUE$ = PAD$(TRIM$(VALUE$," "),2)
2773: 1ab8:             FIELD$(FIELD%) = VALUE$
2774: 1ae5:             UPDATE = TRUE
2775: 1afa: 
2776: 1afa:             ! IF log number has changed
2777: 1afa:             IF NOT (LOG.NUMBER$ = VALUE$) THEN BEGIN
2778: 1b21: 
2779: 1b21:                 ! IF event log file exists
2780: 1b21:                 IF NOT FILE.MAP%(VAL(VALUE$)) =                     \   !BMW
2781: 1b55:                            NULL.MAPPING% THEN BEGIN                     !BMW
2782: 1b55: 
2783: 1b55:                     FILE.INDEX% = FILE.MAP%(VAL(VALUE$))                !BMW
2784: 1b80: 
2785: 1b80:                     FIELD$(U0401.LOG.DESC%) =                       \
2786: 1bc5:                         MID$(FILE.RECORD$(FILE.INDEX%),10,45)           !BMW
2787: 1bc5: 
2788: 1bc5:                     ! Set flag for full application index rebuild
2789: 1bc5:                     REBUILD.INDEX = TRUE
2790: 1bd7: 
2791: 1bd7:                     VALID.KEY = TRUE ! Motor key is valid
2792: 1bef: 
2793: 1bef:                 ENDIF ELSE BEGIN
2794: 1bf7: 
2795: 1bf7:                     VALID.KEY = FALSE ! Motor key is invalid
2796: 1c0d:                     FIELD$(U0401.LOG.DESC%) = " "
2797: 1c37: 
2798: 1c37:                 ENDIF
2799: 1c3f: 
2800: 1c3f:                 LOG.NUMBER$ = VALUE$
2801: 1c5c: 
2802: 1c5c:             ENDIF
2803: 1c67: 
2804: 1c67:         ! IF application field
2805: 1c67:         ENDIF ELSE IF FIELD% = U0401.APPLICATION% THEN BEGIN
2806: 1c82: 
2807: 1c82:             ! IF select all
2808: 1c82:             IF TRIM$(VALUE$," ") = "*" OR VALUE$ = "" THEN BEGIN
2809: 1cec: 
2810: 1cec:                 ! IF blanked out an invalid entry OR
2811: 1cec:                 !    a single application was previously selected OR
2812: 1cec:                 !    some applications selected
2813: 1cec:                 IF (NOT VALID.KEY) OR                               \
2814: 1dc6:                    ((NOT (LAST.APPLICATION$ = "*" OR                \
2815: 1dc6:                           LAST.APPLICATION$ = "+" OR                \
2816: 1dc6:                           LAST.APPLICATION$ = "-")) AND             \
2817: 1dc6:                           (APPLICATION.SELECTED.COUNT% = 1)) OR     \
2818: 1dc6:                    LAST.APPLICATION$ = "+" OR                       \
2819: 1dc6:                    LAST.APPLICATION$ = "-" THEN BEGIN
2820: 1dc6: 
2821: 1dc6:                     ! FOR each application
2822: 1dc6:                     FOR APPLICATION.INDEX% = 1 TO APPLICATION.COUNT%
2823: 1dd6:                         ! Set current application selected flag
2824: 1dd6:                         CALL PUTN1(APPLICATION.RECORD$(             \
2825: 1e02:                             APPLICATION.INDEX%),8,58H)
2826: 1e02:                         CALL SET.APPLICATION.FLAGS(                 \
2827: 1e2a:                             APPLICATION.INDEX%,58H)
2828: 1e2a:                     NEXT APPLICATION.INDEX%
2829: 1e42: 
2830: 1e42:                     ! All applications selected
2831: 1e42:                     APPLICATION.SELECTED.COUNT% = APPLICATION.COUNT%
2832: 1e50: 
2833: 1e50:                     LAST.APPLICATION$ = "*"
2834: 1e65: 
2835: 1e65:                 ENDIF
2836: 1e6d: 
2837: 1e6d:                 FIELD$(FIELD%) = "*"
2838: 1e94:                 FIELD$(U0401.APPLICATION.STATUS%) =                 \
2839: 1ec5:                     ALL.APPLICATIONS.TEXT$
2840: 1ec5:                 UPDATE = TRUE
2841: 1eda: 
2842: 1eda:                 VALID.KEY = TRUE ! Motor key is valid
2843: 1ef3: 
2844: 1ef3:             ! IF select some
2845: 1ef3:             ENDIF ELSE IF TRIM$(VALUE$," ") = "+" OR                \
2846: 1f71:                           TRIM$(VALUE$," ") = "-" THEN BEGIN
2847: 1f71: 
2848: 1f71:                 ! IF manually entered a '+' or '-'
2849: 1f71:                 IF ((LAST.APPLICATION$ = "+" OR                     \
2850: 207c:                      LAST.APPLICATION$ = "*") AND                   \
2851: 207c:                     TRIM$(VALUE$," ") = "-") OR                     \
2852: 207c:                    ((LAST.APPLICATION$ = "-" OR                     \
2853: 207c:                      LAST.APPLICATION$ = "*") AND                   \
2854: 207c:                     TRIM$(VALUE$," ") = "+") THEN BEGIN
2855: 207c:                     ! Error - cannot manually enter a '+' or '-'
2856: 207c:                     VALID = FALSE
2857: 2091:                 ENDIF
2858: 209c: 
2859: 209c:             ! IF select single
2860: 209c:             ENDIF ELSE BEGIN
2861: 20a4: 
2862: 20a4:                 VALUE$ = UCASE$(VALUE$)
2863: 20c5: 
2864: 20c5:                 APPLICATION.INDEX% = 0
2865: 20d3: 
2866: 20d3:                 APPLICATION.FOUND = FALSE
2867: 20e5: 
2868: 20e5:                 WHILE (APPLICATION.INDEX% < APPLICATION.COUNT%)
2869: 20f0: 
2870: 20f0:                     APPLICATION.INDEX% = APPLICATION.INDEX% + 1
2871: 20fc: 
2872: 20fc:                     ! IF application match found
2873: 20fc:                     IF LEFT$(APPLICATION.RECORD$(                   \
2874: 2142:                         APPLICATION.INDEX%),8) = VALUE$ THEN BEGIN
2875: 2142:                         CALL PUTN1(APPLICATION.RECORD$(             \
2876: 216e:                                    APPLICATION.INDEX%),8,58H)
2877: 216e:                         CALL SET.APPLICATION.FLAGS(                 \
2878: 2196:                             APPLICATION.INDEX%,58H)
2879: 2196:                         APPLICATION.FOUND = TRUE
2880: 21aa:                     ENDIF ELSE BEGIN
2881: 21b2:                         CALL PUTN1(APPLICATION.RECORD$(             \
2882: 21de:                                    APPLICATION.INDEX%),8,20H)
2883: 21de:                         CALL SET.APPLICATION.FLAGS(                 \
2884: 2206:                             APPLICATION.INDEX%,20H)
2885: 2206:                     ENDIF
2886: 220e: 
2887: 220e:                 WEND
2888: 2222: 
2889: 2222:                 IF APPLICATION.FOUND THEN BEGIN
2890: 2234: 
2891: 2234:                     ! There can be only one...
2892: 2234:                     APPLICATION.SELECTED.COUNT% = 1
2893: 2242: 
2894: 2242:                     FIELD$(U0401.APPLICATION%) = VALUE$
2895: 2272:                     FIELD$(U0401.APPLICATION.STATUS%) =             \
2896: 22a3:                         SINGLE.APPLICATION.TEXT$
2897: 22a3: 
2898: 22a3:                     LAST.APPLICATION$ = VALUE$
2899: 22be: 
2900: 22be:                     VALID.KEY = TRUE ! Motor key is valid
2901: 22d7: 
2902: 22d7:                 ENDIF ELSE BEGIN
2903: 22df: 
2904: 22df:                     FIELD$(U0401.APPLICATION%) = VALUE$
2905: 230f:                     FIELD$(U0401.APPLICATION.STATUS%) = " "
2906: 2339: 
2907: 2339:                     LAST.APPLICATION$ = ""
2908: 234e: 
2909: 234e:                     VALID.KEY = FALSE ! Motor key is invalid
2910: 2364: 
2911: 2364:                 ENDIF
2912: 236c: 
2913: 236c:                 UPDATE = TRUE
2914: 2381: 
2915: 2381:             ENDIF
2916: 238c: 
2917: 238c:         ! IF Terminal field
2918: 238c:         ENDIF ELSE IF FIELD% = U0401.TERMINAL% THEN BEGIN
2919: 23a7: 
2920: 23a7:             ! IF select all
2921: 23a7:             IF TRIM$(VALUE$," ") = "*" OR VALUE$ = "" THEN BEGIN
2922: 240e:                 FIELD$(FIELD%) = "*"
2923: 2435:                 FIELD$(U0401.TERMINAL.STATUS%) =                    \
2924: 2466:                     ALL.TERMINALS.TEXT$
2925: 2466:                 UPDATE = TRUE
2926: 247e:             ENDIF ELSE IF NOT IS.DIGITS(TRIM$(VALUE$," ")) THEN BEGIN
2927: 24a8:                 VALID = FALSE
2928: 24c0:             ENDIF ELSE BEGIN
2929: 24c8:                 FIELD$(FIELD%) = PAD$(TRIM$(VALUE$," "),3)
2930: 2510:                 FIELD$(U0401.TERMINAL.STATUS%) =                    \
2931: 2541:                     SINGLE.TERMINAL.TEXT$
2932: 2541:                 UPDATE = TRUE
2933: 2556:             ENDIF
2934: 2561: 
2935: 2561:         ! IF Controller ID field
2936: 2561:         ENDIF ELSE IF FIELD% = U0401.CONTROLLER.ID% THEN BEGIN
2937: 257c: 
2938: 257c:             ! IF select all
2939: 257c:             IF TRIM$(VALUE$," ") = "*" OR VALUE$ = "" THEN BEGIN
2940: 25e3:                 FIELD$(FIELD%) = "*"
2941: 260a:                 FIELD$(U0401.CONTROLLER.ID.STATUS%) =               \
2942: 263b:                     ALL.CONTROLLERS.TEXT$
2943: 263b:                 UPDATE = TRUE
2944: 2653:             ENDIF ELSE IF IS.DIGITS(TRIM$(VALUE$," ")) THEN BEGIN
2945: 267d:                 VALID = FALSE
2946: 2695:             ENDIF ELSE BEGIN
2947: 269d:                 FIELD$(FIELD%) = UCASE$(TRIM$(VALUE$," "))
2948: 26d8:                 FIELD$(U0401.CONTROLLER.ID.STATUS%) =               \   !DMW
2949: 2709:                     SINGLE.CONTROLLER.TEXT$
2950: 2709:                 UPDATE = TRUE
2951: 271e:             ENDIF
2952: 2729: 
2953: 2729:         ! IF severity field
2954: 2729:         ENDIF ELSE IF FIELD% = U0401.SEVERITY% THEN BEGIN
2955: 2744: 
2956: 2744:             ! IF select all
2957: 2744:             IF TRIM$(VALUE$," ") = "*" OR VALUE$ = "" THEN BEGIN
2958: 27ae: 
2959: 27ae:                 ! IF a single severity was previously selected OR
2960: 27ae:                 !    some severitys selected
2961: 27ae:                 IF ((NOT (LAST.SEVERITY$ = "*" OR                   \
2962: 287d:                           LAST.SEVERITY$ = "+" OR                   \
2963: 287d:                           LAST.SEVERITY$ = "-")) AND                \
2964: 287d:                           (SEVERITY.SELECTED.COUNT% = 1)) OR        \
2965: 287d:                    LAST.SEVERITY$ = "+" OR                          \
2966: 287d:                    LAST.SEVERITY$ = "-" THEN BEGIN
2967: 287d: 
2968: 287d:                     FOR SEVERITY.INDEX% = 0 TO (SEVERITY.COUNT% - 1)
2969: 288d:                         CALL PUTN1(SEVERITY.RECORD$(                \
2970: 28b9:                                    SEVERITY.INDEX%),2,58H)
2971: 28b9:                     NEXT SEVERITY.INDEX%
2972: 28d2: 
2973: 28d2:                     ! Update all severity selection changes
2974: 28d2:                     CALL SET.SELECTION.SEVERITY(3,2)
2975: 2901: 
2976: 2901:                     ! All severitys selected
2977: 2901:                     SEVERITY.SELECTED.COUNT% = SEVERITY.COUNT%
2978: 290f: 
2979: 290f:                     LAST.SEVERITY$ = "*"
2980: 2924: 
2981: 2924:                 ENDIF
2982: 292c: 
2983: 292c:                 FIELD$(FIELD%) = "*"
2984: 2953:                 FIELD$(U0401.SEVERITY.STATUS%) = ALL.SEVERITYS.TEXT$
2985: 2984:                 UPDATE = TRUE
2986: 299c: 
2987: 299c:             ! IF select some
2988: 299c:             ENDIF ELSE IF TRIM$(VALUE$," ") = "+" OR                \
2989: 2a1a:                           TRIM$(VALUE$," ") = "-" THEN BEGIN
2990: 2a1a: 
2991: 2a1a:                 ! IF manually entered a '+' or '-'
2992: 2a1a:                 IF ((LAST.SEVERITY$ = "+" OR                        \
2993: 2b25:                      LAST.SEVERITY$ = "*") AND                      \
2994: 2b25:                     TRIM$(VALUE$," ") = "-") OR                     \
2995: 2b25:                    ((LAST.SEVERITY$ = "-" OR                        \
2996: 2b25:                      LAST.SEVERITY$ = "*") AND                      \
2997: 2b25:                     TRIM$(VALUE$," ") = "+") THEN BEGIN
2998: 2b25:                     ! Error - cannot manually enter a '+' or '-'
2999: 2b25:                     VALID = FALSE
3000: 2b3a:                 ENDIF
3001: 2b45: 
3002: 2b45:             ! IF not numeric
3003: 2b45:             ENDIF ELSE IF NOT IS.DIGITS(TRIM$(VALUE$," ")) THEN BEGIN
3004: 2b6f: 
3005: 2b6f:                 ! Error - value must be numeric
3006: 2b6f:                 VALID = FALSE
3007: 2b87: 
3008: 2b87:             ! IF select single
3009: 2b87:             ENDIF ELSE BEGIN
3010: 2b8f: 
3011: 2b8f:                 ! FOR each severity
3012: 2b8f:                 FOR SEVERITY.INDEX% = 0 TO (SEVERITY.COUNT% - 1)
3013: 2ba0: 
3014: 2ba0:                     IF SEVERITY.INDEX% = VAL(VALUE$) THEN BEGIN
3015: 2bd0:                         CALL PUTN1(SEVERITY.RECORD$(                \
3016: 2bfe:                                    SEVERITY.INDEX%),2,58H)
3017: 2bfe:                     ENDIF ELSE BEGIN
3018: 2c06:                         CALL PUTN1(SEVERITY.RECORD$(                \
3019: 2c32:                                    SEVERITY.INDEX%),2,20H)
3020: 2c32:                     ENDIF
3021: 2c3a: 
3022: 2c3a:                 NEXT SEVERITY.INDEX%
3023: 2c56: 
3024: 2c56:                 ! Update all severity selection changes
3025: 2c56:                 CALL SET.SELECTION.SEVERITY(3,2)
3026: 2c85: 
3027: 2c85:                 ! There can be only one...
3028: 2c85:                 SEVERITY.SELECTED.COUNT% = 1
3029: 2c93: 
3030: 2c93:                 FIELD$(U0401.SEVERITY%) = VALUE$
3031: 2cc3:                 FIELD$(U0401.SEVERITY.STATUS%) = SINGLE.SEVERITY.TEXT$
3032: 2cf4:                 UPDATE = TRUE
3033: 2d09: 
3034: 2d09:                 LAST.SEVERITY$ = VALUE$
3035: 2d24: 
3036: 2d24:             ENDIF
3037: 2d2f: 
3038: 2d2f:         ! IF bucket field
3039: 2d2f:         ENDIF ELSE IF FIELD% = U0401.BUCKET% THEN BEGIN
3040: 2d4a: 
3041: 2d4a:             ! IF select all
3042: 2d4a:             IF TRIM$(VALUE$," ") = "*" OR VALUE$ = "" THEN BEGIN
3043: 2db4: 
3044: 2db4:                 ! IF a single bucket was previously selected OR
3045: 2db4:                 !    some buckets selected
3046: 2db4:                 IF ((NOT (LAST.BUCKET$ = "*" OR                     \
3047: 2e83:                           LAST.BUCKET$ = "+" OR                     \
3048: 2e83:                           LAST.BUCKET$ = "-")) AND                  \
3049: 2e83:                           (BUCKET.SELECTED.COUNT% = 1)) OR          \
3050: 2e83:                    LAST.BUCKET$ = "+" OR                            \
3051: 2e83:                    LAST.BUCKET$ = "-" THEN BEGIN
3052: 2e83: 
3053: 2e83:                     FOR BUCKET.INDEX% = 0 TO (BUCKET.COUNT% - 1)
3054: 2e93:                         CALL PUTN1(BUCKET.RECORD$(BUCKET.INDEX%),2,58H)
3055: 2ebf:                     NEXT BUCKET.INDEX%
3056: 2ed8: 
3057: 2ed8:                     ! Update all bucket selection changes
3058: 2ed8:                     CALL SET.SELECTION.BUCKET(3,2)
3059: 2f07: 
3060: 2f07:                     ! All buckets selected
3061: 2f07:                     BUCKET.SELECTED.COUNT% = BUCKET.COUNT%
3062: 2f15: 
3063: 2f15:                     LAST.BUCKET$ = "*"
3064: 2f2a: 
3065: 2f2a:                 ENDIF
3066: 2f32: 
3067: 2f32:                 FIELD$(FIELD%) = "*"
3068: 2f59:                 FIELD$(U0401.BUCKET.STATUS%) = ALL.BUCKETS.TEXT$
3069: 2f8a:                 UPDATE = TRUE
3070: 2fa2: 
3071: 2fa2:             ! IF select some
3072: 2fa2:             ENDIF ELSE IF TRIM$(VALUE$," ") = "+" OR                \
3073: 3020:                           TRIM$(VALUE$," ") = "-" THEN BEGIN
3074: 3020: 
3075: 3020:                 ! IF manually entered a '+' or '-'
3076: 3020:                 IF ((LAST.BUCKET$ = "+" OR                          \
3077: 312b:                      LAST.BUCKET$ = "*") AND                        \
3078: 312b:                     TRIM$(VALUE$," ") = "-") OR                     \
3079: 312b:                    ((LAST.BUCKET$ = "-" OR                          \
3080: 312b:                      LAST.BUCKET$ = "*") AND                        \
3081: 312b:                     TRIM$(VALUE$," ") = "+") THEN BEGIN
3082: 312b:                     ! Error - cannot manually enter a '+' or '-'
3083: 312b:                     VALID = FALSE
3084: 3140:                 ENDIF
3085: 314b: 
3086: 314b:             ! IF not numeric
3087: 314b:             ENDIF ELSE IF NOT IS.DIGITS(TRIM$(VALUE$," ")) THEN BEGIN
3088: 3175: 
3089: 3175:                 ! Error - value must be numeric
3090: 3175:                 VALID = FALSE
3091: 318d: 
3092: 318d:             ! IF select single
3093: 318d:             ENDIF ELSE BEGIN
3094: 3195: 
3095: 3195:                 ! FOR each bucket
3096: 3195:                 FOR BUCKET.INDEX% = 0 TO (BUCKET.COUNT% - 1)
3097: 31a6: 
3098: 31a6:                     IF BUCKET.INDEX% = VAL(VALUE$) THEN BEGIN
3099: 31d6:                         CALL PUTN1(BUCKET.RECORD$(BUCKET.INDEX%),2,58H)
3100: 3204:                     ENDIF ELSE BEGIN
3101: 320c:                         CALL PUTN1(BUCKET.RECORD$(BUCKET.INDEX%),2,20H)
3102: 3238:                     ENDIF
3103: 3240: 
3104: 3240:                 NEXT BUCKET.INDEX%
3105: 325c: 
3106: 325c:                 ! Update all bucket selection changes
3107: 325c:                 CALL SET.SELECTION.BUCKET(3,2)
3108: 328b: 
3109: 328b:                 ! There can be only one...
3110: 328b:                 BUCKET.SELECTED.COUNT% = 1
3111: 3299: 
3112: 3299:                 FIELD$(U0401.BUCKET%) = VALUE$
3113: 32c9:                 FIELD$(U0401.BUCKET.STATUS%) = SINGLE.BUCKET.TEXT$
3114: 32fa:                 UPDATE = TRUE
3115: 330f: 
3116: 330f:                 LAST.BUCKET$ = VALUE$
3117: 332a: 
3118: 332a:             ENDIF
3119: 3335: 
3120: 3335:         ! IF source field
3121: 3335:         ENDIF ELSE IF FIELD% = U0401.SOURCE% THEN BEGIN
3122: 3350: 
3123: 3350:             ! IF select all                                             !BMW
3124: 3350:             IF TRIM$(VALUE$," ") = "*" OR VALUE$ = "" THEN BEGIN        !BMW
3125: 33ba:                                                                         !BMW
3126: 33ba:                 ! IF a single source was previously selected OR         !BMW
3127: 33ba:                 !    some sources selected                              !BMW
3128: 33ba:                 IF ((NOT (LAST.SOURCE$ = "*" OR                     \   !BMW
3129: 3489:                           LAST.SOURCE$ = "+" OR                     \   !BMW
3130: 3489:                           LAST.SOURCE$ = "-")) AND                  \   !BMW
3131: 3489:                           (SOURCE.SELECTED.COUNT% = 1)) OR          \   !BMW
3132: 3489:                    LAST.SOURCE$ = "+" OR                            \   !BMW
3133: 3489:                    LAST.SOURCE$ = "-" THEN BEGIN                        !BMW
3134: 3489:                                                                         !BMW
3135: 3489:                     FOR SOURCE.INDEX% = 1 TO SOURCE.COUNT%              !BMW
3136: 3499:                         CALL PUTN1(SOURCE.RECORD$(                  \   !BMW
3137: 34c5:                                    SOURCE.INDEX%),4,58H)                !BMW
3138: 34c5:                         CALL SET.SOURCE.FLAGS(SOURCE.INDEX%,58H)        !BMW
3139: 34ed:                     NEXT SOURCE.INDEX%                                  !BMW
3140: 3505:                                                                         !BMW
3141: 3505:                     ! Update all source selection changes               !BMW
3142: 3505:                     CALL SET.SELECTION.SOURCE(5,4)                      !BMW
3143: 3534:                                                                         !BMW
3144: 3534:                     ! All buckets selected                              !BMW
3145: 3534:                     SOURCE.SELECTED.COUNT% = SOURCE.COUNT%              !BMW
3146: 3542:                                                                         !BMW
3147: 3542:                     LAST.SOURCE$ = "*"                                  !BMW
3148: 3557:                                                                         !BMW
3149: 3557:                 ENDIF                                                   !BMW
3150: 355f:                                                                         !BMW
3151: 355f:                 FIELD$(FIELD%) = "*"                                    !BMW
3152: 3586:                 FIELD$(U0401.SOURCE.STATUS%) = ALL.SOURCES.TEXT$        !BMW
3153: 35b7:                 UPDATE = TRUE                                           !BMW
3154: 35cf:                                                                         !BMW
3155: 35cf:             ! IF select some                                            !BMW
3156: 35cf:             ENDIF ELSE IF TRIM$(VALUE$," ") = "+" OR                \   !BMW
3157: 364d:                           TRIM$(VALUE$," ") = "-" THEN BEGIN            !BMW
3158: 364d:                                                                         !BMW
3159: 364d:                 ! IF manually entered a '+' or '-'                      !BMW
3160: 364d:                 IF ((LAST.SOURCE$ = "+" OR                          \   !BMW
3161: 3758:                      LAST.SOURCE$ = "*") AND                        \   !BMW
3162: 3758:                     TRIM$(VALUE$," ") = "-") OR                     \   !BMW
3163: 3758:                    ((LAST.SOURCE$ = "-" OR                          \   !BMW
3164: 3758:                      LAST.SOURCE$ = "*") AND                        \   !BMW
3165: 3758:                     TRIM$(VALUE$," ") = "+") THEN BEGIN                 !BMW
3166: 3758:                     ! Error - cannot manually enter a '+' or '-'        !BMW
3167: 3758:                     VALID = FALSE                                       !BMW
3168: 376d:                 ENDIF                                                   !BMW
3169: 3778:                                                                         !BMW
3170: 3778:             ! IF not numeric                                            !BMW
3171: 3778:             ENDIF ELSE IF NOT IS.DIGITS(TRIM$(VALUE$," ")) THEN BEGIN   !BMW
3172: 37a2:                                                                         !BMW
3173: 37a2:                 ! Error - value must be numeric                         !BMW
3174: 37a2:                 VALID = FALSE                                           !BMW
3175: 37ba:                                                                         !BMW
3176: 37ba:             ! IF select single                                          !BMW
3177: 37ba:             ENDIF ELSE BEGIN                                            !BMW
3178: 37c2:                                                                         !BMW
3179: 37c2:                 ! FOR each source                                       !BMW
3180: 37c2:                 FOR SOURCE.INDEX% = 1 TO SOURCE.COUNT%                  !BMW
3181: 37d3:                                                                         !BMW
3182: 37d3:                     IF LEFT$(SOURCE.RECORD$(                        \   !BMW
3183: 3819:                              SOURCE.INDEX%),3) = VALUE$ THEN BEGIN      !BMW
3184: 3819:                         CALL PUTN1(SOURCE.RECORD$(SOURCE.INDEX%),4,58H) !BMW
3185: 3845:                         CALL SET.SOURCE.FLAGS(SOURCE.INDEX%,58H)        !BMW
3186: 386f:                     ENDIF ELSE BEGIN                                    !BMW
3187: 3877:                         CALL PUTN1(SOURCE.RECORD$(SOURCE.INDEX%),4,20H) !BMW
3188: 38a3:                         CALL SET.SOURCE.FLAGS(SOURCE.INDEX%,20H)        !BMW
3189: 38cb:                     ENDIF                                               !BMW
3190: 38d3:                                                                         !BMW
3191: 38d3:                 NEXT SOURCE.INDEX%                                      !BMW
3192: 38ee:                                                                         !BMW
3193: 38ee:                 ! Update all source selection changes                   !BMW
3194: 38ee:                 CALL SET.SELECTION.SOURCE(5,4)                          !BMW
3195: 391d:                                                                         !BMW
3196: 391d:                 ! There can be only one...                              !BMW
3197: 391d:                 SOURCE.SELECTED.COUNT% = 1                              !BMW
3198: 392b:                                                                         !BMW
3199: 392b:                 FIELD$(U0401.SOURCE%) = VALUE$                          !BMW
3200: 395b:                 FIELD$(U0401.SOURCE.STATUS%) = SINGLE.SOURCE.TEXT$      !BMW
3201: 398c:                 UPDATE = TRUE                                           !BMW
3202: 39a1:                                                                         !BMW
3203: 39a1:                 LAST.SOURCE$ = VALUE$                                   !BMW
3204: 39bc:                                                                         !BMW
3205: 39bc:             ENDIF                                                       !BMW
3206: 39c7:                                                                         !BMW
3207: 39c7:         ! IF event number field
3208: 39c7:         ENDIF ELSE IF FIELD% = U0401.EVENT% THEN BEGIN
3209: 39e2: 
3210: 39e2:             ! IF select all
3211: 39e2:             IF TRIM$(VALUE$," ") = "*" OR VALUE$ = "" THEN BEGIN
3212: 3a49:                 FIELD$(FIELD%) = "*"
3213: 3a70:                 FIELD$(U0401.EVENT.STATUS%) = ALL.EVENTS.TEXT$
3214: 3aa1:                 UPDATE = TRUE
3215: 3ab9:             ENDIF ELSE IF NOT IS.DIGITS(TRIM$(VALUE$," ")) THEN BEGIN
3216: 3ae3:                 VALID = FALSE
3217: 3afb:             ENDIF ELSE BEGIN
3218: 3b03:                 FIELD$(FIELD%) = PAD$(TRIM$(VALUE$," "),3)
3219: 3b4b:                 FIELD$(U0401.EVENT.STATUS%) = SINGLE.EVENT.TEXT$
3220: 3b7c:                 UPDATE = TRUE
3221: 3b91:             ENDIF
3222: 3b9c: 
3223: 3b9c:         ! IF message group field
3224: 3b9c:         ENDIF ELSE IF FIELD% = U0401.MESSAGE.GROUP% THEN BEGIN
3225: 3bb7: 
3226: 3bb7:             ! IF select all
3227: 3bb7:             IF TRIM$(VALUE$," ") = "*" OR VALUE$ = "" THEN BEGIN
3228: 3c1e:                 FIELD$(FIELD%) = "*"
3229: 3c45:                 FIELD$(U0401.MESSAGE.GROUP.STATUS%) = \
3230: 3c76:                     ALL.MESSAGE.GROUPS.TEXT$
3231: 3c76:                 UPDATE = TRUE
3232: 3c8e:             ENDIF ELSE IF IS.DIGITS(TRIM$(VALUE$," ")) THEN BEGIN
3233: 3cb8:                 VALID = FALSE
3234: 3cd0:             ENDIF ELSE BEGIN
3235: 3cd8:                 FIELD$(FIELD%) = UCASE$(TRIM$(VALUE$," "))
3236: 3d13:                 FIELD$(U0401.MESSAGE.GROUP.STATUS%) = \
3237: 3d44:                     SINGLE.MESSAGE.GROUP.TEXT$
3238: 3d44:                 UPDATE = TRUE
3239: 3d59:             ENDIF
3240: 3d64: 
3241: 3d64:         ! IF message number field
3242: 3d64:         ENDIF ELSE IF FIELD% = U0401.MESSAGE.NUMBER% THEN BEGIN
3243: 3d7f: 
3244: 3d7f:             ! IF select all
3245: 3d7f:             IF TRIM$(VALUE$," ") = "*" OR VALUE$ = "" THEN BEGIN
3246: 3de6:                 FIELD$(FIELD%) = "*"
3247: 3e0d:                 FIELD$(U0401.MESSAGE.NUMBER.STATUS%) = \
3248: 3e3e:                     ALL.MESSAGE.NUMBERS.TEXT$
3249: 3e3e:                 UPDATE = TRUE
3250: 3e56:             ENDIF ELSE IF NOT IS.DIGITS(TRIM$(VALUE$," ")) THEN BEGIN
3251: 3e80:                 VALID = FALSE
3252: 3e98:             ENDIF ELSE BEGIN
3253: 3ea0:                 FIELD$(FIELD%) = PAD$(TRIM$(VALUE$," "),3)
3254: 3ee8:                 FIELD$(U0401.MESSAGE.NUMBER.STATUS%) = \
3255: 3f19:                     SINGLE.MESSAGE.NUMBER.TEXT$
3256: 3f19:                 UPDATE = TRUE
3257: 3f2e:             ENDIF
3258: 3f36: 
3259: 3f36:         ENDIF
3260: 3f41: 
3261: 3f41:     ! IF application selection screen
3262: 3f41:     ENDIF ELSE IF SCREEN% = 6 THEN BEGIN
3263: 3f55: 
3264: 3f55:         ! Convert any selection other than space to an 'X'
3265: 3f55:         IF NOT VALUE$ = "" THEN BEGIN
3266: 3f72:             VALUE$ = "X"
3267: 3f88:             FIELD$(FIELD%) = VALUE$
3268: 3fb5:         ENDIF
3269: 3fbd:         UPDATE = TRUE
3270: 3fd2: 
3271: 3fd2:         APPLICATION.INDEX% = ((APPLICATION.PAGE% - 1) *             \
3272: 3ff3:             APPLICATIONS.PER.PAGE%) + (FIELD% - 2)
3273: 3ff3: 
3274: 3ff3:         FLAG.VALUE% = ASC(VALUE$)
3275: 400d: 
3276: 400d:         ! IF application selection has changed
3277: 400d:         IF NOT GETN1(APPLICATION.RECORD$(                           \
3278: 4041:                      APPLICATION.INDEX%),9) = FLAG.VALUE% THEN BEGIN
3279: 4041:             CALL PUTN1(APPLICATION.RECORD$(                         \
3280: 406e:                        APPLICATION.INDEX%),9,FLAG.VALUE%)
3281: 406e:         ENDIF
3282: 4079: 
3283: 4079:     ! IF severity selection screen
3284: 4079:     ENDIF ELSE IF SCREEN% = 9 THEN BEGIN
3285: 408d: 
3286: 408d:         ! Convert any selection other than space to an 'X'
3287: 408d:         IF NOT VALUE$ = "" THEN BEGIN
3288: 40aa:             VALUE$ = "X"
3289: 40c0:             FIELD$(FIELD%) = VALUE$
3290: 40ed:         ENDIF
3291: 40f5:         UPDATE = TRUE
3292: 410a: 
3293: 410a:         SEVERITY.INDEX% = FIELD% - 3
3294: 411e: 
3295: 411e:         FLAG.VALUE% = ASC(VALUE$)
3296: 4138: 
3297: 4138:         ! IF severity selection has changed
3298: 4138:         IF NOT GETN1(SEVERITY.RECORD$(                              \
3299: 416c:                      SEVERITY.INDEX%),2) = FLAG.VALUE% THEN BEGIN
3300: 416c:             CALL PUTN1(SEVERITY.RECORD$(                            \
3301: 4199:                        SEVERITY.INDEX%),2,FLAG.VALUE%)
3302: 4199:         ENDIF
3303: 41a4: 
3304: 41a4:     ! IF bucket selection screen
3305: 41a4:     ENDIF ELSE IF SCREEN% = 10 THEN BEGIN
3306: 41b8: 
3307: 41b8:         ! Convert any selection other than space to an 'X'
3308: 41b8:         IF NOT VALUE$ = "" THEN BEGIN
3309: 41d5:             VALUE$ = "X"
3310: 41eb:             FIELD$(FIELD%) = VALUE$
3311: 4218:         ENDIF
3312: 4220:         UPDATE = TRUE
3313: 4235: 
3314: 4235:         BUCKET.INDEX% = FIELD% - 3
3315: 4249: 
3316: 4249:         FLAG.VALUE% = ASC(VALUE$)
3317: 4263: 
3318: 4263:         ! IF bucket selection has changed
3319: 4263:         IF NOT GETN1(BUCKET.RECORD$(                                \
3320: 4297:                      BUCKET.INDEX%),2) = FLAG.VALUE% THEN BEGIN
3321: 4297:             CALL PUTN1(BUCKET.RECORD$(                              \
3322: 42c4:                        BUCKET.INDEX%),2,FLAG.VALUE%)
3323: 42c4:         ENDIF
3324: 42cf: 
3325: 42cf:     ! IF source selection screen                                        !BMW
3326: 42cf:     ENDIF ELSE IF SCREEN% = 11 THEN BEGIN                               !BMW
3327: 42e3:                                                                         !BMW
3328: 42e3:         ! Convert any selection other than space to an 'X'              !BMW
3329: 42e3:         IF NOT VALUE$ = "" THEN BEGIN                                   !BMW
3330: 4300:             VALUE$ = "X"                                                !BMW
3331: 4316:             FIELD$(FIELD%) = VALUE$                                     !BMW
3332: 4343:         ENDIF                                                           !BMW
3333: 434b:         UPDATE = TRUE                                                   !BMW
3334: 4360:                                                                         !BMW
3335: 4360:         SOURCE.INDEX% = ((SOURCE.PAGE% - 1) *                       \   !BMW
3336: 4381:             SOURCES.PER.PAGE%) + (FIELD% - 2)                           !BMW
3337: 4381:                                                                         !BMW
3338: 4381:         FLAG.VALUE% = ASC(VALUE$)                                       !BMW
3339: 439b:                                                                         !BMW
3340: 439b:         ! IF source selection has changed                               !BMW
3341: 439b:         IF NOT GETN1(SOURCE.RECORD$(SOURCE.INDEX%),4) =             \   !BMW
3342: 43cf:                          FLAG.VALUE% THEN BEGIN                         !BMW
3343: 43cf:             CALL PUTN1(SOURCE.RECORD$(SOURCE.INDEX%),4,FLAG.VALUE%)     !BMW
3344: 43fc:         ENDIF                                                           !BMW
3345: 4404:                                                                         !BMW
3346: 4404:     ENDIF
3347: 440c: 
3348: 440c: END SUB
3349: 4420: 
3350: 4420: \***********************************************************************!IMW
3351: 4420: \***                                                                    !IMW
3352: 4420: \***    GET.CURRENT.INDEX                                               !IMW
3353: 4420: \***                                                                    !IMW
3354: 4420: \***********************************************************************!IMW
3355: 4420: \***                                                                    !IMW
3356: 4420: \***    Calculate the summary index for the currently selected row      !IMW
3357: 4420: \***                                                                    !IMW
3358: 4420: \***********************************************************************!IMW
3359: 4420: FUNCTION GET.CURRENT.INDEX(PAGE%,FIELD%)                                !IMW
3360: 4444:                                                                         !IMW
3361: 4444:     INTEGER*2 GET.CURRENT.INDEX                                         !IMW
3362: 4444:     INTEGER*2 PAGE%                                                     !IMW
3363: 4444:     INTEGER*2 FIELD%                                                    !IMW
3364: 4444:                                                                         !IMW
3365: 4444:     ! Calculate selected event log index                                !IMW
3366: 4444:     GET.CURRENT.INDEX = RESULTS.COUNT% -                            \   !IMW
3367: 4471:                         (((PAGE% - 1) *                             \   !IMW
3368: 4471:                         RESULTS.PER.PAGE%) +                        \   !IMW
3369: 4471:                         (FIELD% - 3))                                   !IMW
3370: 4471:                                                                         !IMW
3371: 4471: END FUNCTION                                                            !IMW
3372: 4488:                                                                         !IMW
3373: 4488: \***********************************************************************!IMW
3374: 4488: \***                                                                    !IMW
3375: 4488: \***    SHOW.PAIR.OPTION                                                !IMW
3376: 4488: \***                                                                    !IMW
3377: 4488: \***********************************************************************!IMW
3378: 4488: \***                                                                    !IMW
3379: 4488: \***    Show or hide the pair option on the summary screen              !IMW
3380: 4488: \***                                                                    !IMW
3381: 4488: \***********************************************************************!IMW
3382: 4488: SUB SHOW.PAIR.OPTION(ROW%)                                              !IMW
3383: 44ac:                                                                         !IMW
3384: 44ac:     INTEGER*2 ROW%                                                      !IMW
3385: 44ac:                                                                         !IMW
3386: 44ac:     EVENT.MESSAGE.GROUP$  = MID$(SUMMARY.RECORD$(ROW%),42,1)            !IMW
3387: 44e3:     EVENT.MESSAGE.NUMBER% = ?VAL(MID$(SUMMARY.RECORD$(ROW%),43,3))      !IMW
3388: 4523:                                                                         !IMW
3389: 4523:     ! IF start/end program system event                                 !IMW
3390: 4523:     IF EVENT.MESSAGE.GROUP$ = "W" AND                               \   !IMW
3391: 4575:        (EVENT.MESSAGE.NUMBER% = 619 OR                              \   !IMW
3392: 4575:         EVENT.MESSAGE.NUMBER% = 620) THEN BEGIN                         !IMW
3393: 4575:                                                                         !IMW
3394: 4575:         ! Display pair function key                                     !IMW
3395: 4575:         CALL DM.SHOW.FN.KEY(2,"PAIR")                                   !IMW
3396: 458d:                                                                         !IMW
3397: 458d:     ENDIF ELSE BEGIN                                                    !IMW
3398: 4595:                                                                         !IMW
3399: 4595:         ! Hide pair function key                                        !IMW
3400: 4595:         CALL DM.HIDE.FN.KEY(2)                                          !IMW
3401: 45a6:                                                                         !IMW
3402: 45a6:     ENDIF                                                               !IMW
3403: 45ae:                                                                         !IMW
3404: 45ae: END SUB                                                                 !IMW
3405: 45c2:                                                                         !IMW
3406: 45c2: \***********************************************************************
3407: 45c2: \***
3408: 45c2: \***    DM.KEY.CHANGED
3409: 45c2: \***
3410: 45c2: \***********************************************************************
3411: 45c2: \***
3412: 45c2: \***    Display manager motor key field user exit
3413: 45c2: \***
3414: 45c2: \***********************************************************************
3415: 45c2: SUB DM.KEY.CHANGED(SCREEN%,FIELD%,MOTOR.KEY%) PUBLIC
3416: 45e6: 
3417: 45e6:     INTEGER*2   SCREEN%     ! Current screen number
3418: 45e6:     INTEGER*2   FIELD%      ! Current field
3419: 45e6:     INTEGER*2   MOTOR.KEY%  ! Motor key
3420: 45e6: 
3421: 45e6:     INTEGER*2   THIS.PAGE%                                              !IMW
3422: 45e6: 
3423: 45e6:     ! IF selection screen
3424: 45e6:     IF SCREEN% = 1 THEN BEGIN
3425: 45fa: 
3426: 45fa:         IF MOTOR.KEY% = F3.KEY% OR MOTOR.KEY% = ESC.KEY% THEN BEGIN
3427: 462c: 
3428: 462c:             SELECTION.QUIT.CONFIRM = TRUE
3429: 4641: 
3430: 4641:         ENDIF ELSE IF NOT VALID.KEY THEN BEGIN
3431: 4653: 
3432: 4653:             MOTOR.KEY% = INVALID.KEY%
3433: 466b: 
3434: 466b:         ENDIF ELSE IF FIELD% = U0401.LOG.NUMBER% THEN BEGIN
3435: 4686: 
3436: 4686:             IF MOTOR.KEY% = ENTER.KEY% OR                           \
3437: 46e2:                MOTOR.KEY% = TAB.KEY% OR                             \
3438: 46e2:                MOTOR.KEY% = DOWN.KEY% OR                            \
3439: 46e2:                MOTOR.KEY% = END.KEY% THEN BEGIN
3440: 46e2: 
3441: 46e2:                 ! IF an application index rebuild is required
3442: 46e2:                 IF REBUILD.INDEX THEN BEGIN
3443: 46f1: 
3444: 46f1:                     ! Display 'Please Wait' message
3445: 46f1:                     CALL DM.STATUS(                                 \
3446: 4705:                         "'B221 Rebuilding Index - Please Wait...")
3447: 4705: 
3448: 4705:                     ! Perform full application index rebuild
3449: 4705:                     CALL CREATE.APPLICATION.LIST(TRUE,LOG.NUMBER$)
3450: 4720: 
3451: 4720:                     ! Clear 'Please Wait' message
3452: 4720:                     CALL DM.STATUS("'")
3453: 4734: 
3454: 4734:                     REBUILD.INDEX = FALSE
3455: 4746:                 ENDIF
3456: 474e: 
3457: 474e:             ENDIF
3458: 4756: 
3459: 4756:             ! IF returning to the log number field
3460: 4756:             IF MOTOR.KEY% = END.KEY% THEN BEGIN
3461: 476d: 
3462: 476d:                 ! Hide list function key
3463: 476d:                 CALL DM.HIDE.FN.KEY(9)
3464: 4780: 
3465: 4780:             ENDIF ELSE BEGIN
3466: 4788: 
3467: 4788:                 ! Display list function key
3468: 4788:                 CALL DM.SHOW.FN.KEY(9,"LIST")
3469: 479e: 
3470: 479e:             ENDIF
3471: 47a9: 
3472: 47a9:         ENDIF ELSE IF FIELD% = U0401.APPLICATION% THEN BEGIN
3473: 47c4: 
3474: 47c4:             IF MOTOR.KEY% = ENTER.KEY% OR                           \
3475: 4820:                MOTOR.KEY% = BTAB.KEY% OR                            \
3476: 4820:                MOTOR.KEY% = HOME.KEY% OR                            \
3477: 4820:                MOTOR.KEY% = UP.KEY% THEN BEGIN
3478: 4820: 
3479: 4820:                 ! Display list function key
3480: 4820:                 CALL DM.SHOW.FN.KEY(9,"LIST")
3481: 4838: 
3482: 4838:             ENDIF ELSE BEGIN
3483: 4840: 
3484: 4840:                 ! Hide list function key
3485: 4840:                 CALL DM.HIDE.FN.KEY(9)
3486: 4851: 
3487: 4851:             ENDIF
3488: 485c: 
3489: 485c:         ENDIF ELSE IF FIELD% = U0401.TERMINAL% THEN BEGIN
3490: 4877: 
3491: 4877:             ! IF returning to the log number or application field
3492: 4877:             IF MOTOR.KEY% = BTAB.KEY% OR                            \
3493: 48be:                MOTOR.KEY% = HOME.KEY% OR                            \
3494: 48be:                MOTOR.KEY% = UP.KEY% THEN BEGIN
3495: 48be: 
3496: 48be:                 ! Display list function key
3497: 48be:                 CALL DM.SHOW.FN.KEY(9,"LIST")
3498: 48d6: 
3499: 48d6:             ENDIF ELSE BEGIN
3500: 48de: 
3501: 48de:                 ! Hide list function key
3502: 48de:                 CALL DM.HIDE.FN.KEY(9)
3503: 48ef: 
3504: 48ef:             ENDIF
3505: 48fa: 
3506: 48fa:         ENDIF ELSE IF FIELD% = U0401.CONTROLLER.ID% THEN BEGIN
3507: 4915: 
3508: 4915:             ! IF returning to the log number field OR
3509: 4915:             !    moving forward to the severity field
3510: 4915:             IF MOTOR.KEY% = HOME.KEY% OR                            \
3511: 495c:                MOTOR.KEY% = TAB.KEY% OR                             \
3512: 495c:                MOTOR.KEY% = DOWN.KEY% THEN BEGIN
3513: 495c: 
3514: 495c:                 ! Display list function key
3515: 495c:                 CALL DM.SHOW.FN.KEY(9,"LIST")
3516: 4974: 
3517: 4974:             ENDIF ELSE BEGIN
3518: 497c: 
3519: 497c:                 ! Hide list function key
3520: 497c:                 CALL DM.HIDE.FN.KEY(9)
3521: 498d: 
3522: 498d:             ENDIF
3523: 4998: 
3524: 4998:         ENDIF ELSE IF FIELD% = U0401.SEVERITY% THEN BEGIN
3525: 49b3: 
3526: 49b3:             ! IF returning to the log number field OR
3527: 49b3:             !    moving forward to the bucket field
3528: 49b3:             IF MOTOR.KEY% = ENTER.KEY% OR                           \
3529: 4a0f:                MOTOR.KEY% = HOME.KEY% OR                            \
3530: 4a0f:                MOTOR.KEY% = TAB.KEY% OR                             \
3531: 4a0f:                MOTOR.KEY% = DOWN.KEY% THEN BEGIN
3532: 4a0f: 
3533: 4a0f:                 ! Display list function key
3534: 4a0f:                 CALL DM.SHOW.FN.KEY(9,"LIST")
3535: 4a27: 
3536: 4a27:             ENDIF ELSE BEGIN
3537: 4a2f: 
3538: 4a2f:                 ! Hide list function key
3539: 4a2f:                 CALL DM.HIDE.FN.KEY(9)
3540: 4a40: 
3541: 4a40:             ENDIF
3542: 4a4b: 
3543: 4a4b:         ENDIF ELSE IF FIELD% = U0401.BUCKET% THEN BEGIN
3544: 4a66: 
3545: 4a66:             ! IF returning to the log number field OR
3546: 4a66:             !    moving forward to the source field OR                  !BMW
3547: 4a66:             !    moving back to the severity field
3548: 4a66:             IF MOTOR.KEY% = ENTER.KEY% OR                           \
3549: 4aec:                MOTOR.KEY% = HOME.KEY% OR                            \
3550: 4aec:                MOTOR.KEY% = TAB.KEY% OR                             \   !BMW
3551: 4aec:                MOTOR.KEY% = DOWN.KEY% OR                            \   !BMW
3552: 4aec:                MOTOR.KEY% = BTAB.KEY% OR                            \
3553: 4aec:                MOTOR.KEY% = UP.KEY% THEN BEGIN
3554: 4aec: 
3555: 4aec:                 ! Display list function key
3556: 4aec:                 CALL DM.SHOW.FN.KEY(9,"LIST")
3557: 4b04: 
3558: 4b04:             ENDIF ELSE BEGIN
3559: 4b0c: 
3560: 4b0c:                 ! Hide list function key
3561: 4b0c:                 CALL DM.HIDE.FN.KEY(9)
3562: 4b1d: 
3563: 4b1d:             ENDIF
3564: 4b28: 
3565: 4b28:         ENDIF ELSE IF FIELD% = U0401.SOURCE% THEN BEGIN
3566: 4b43: 
3567: 4b43:             ! IF returning to the log number field OR
3568: 4b43:             !    moving back to the bucket field
3569: 4b43:             IF MOTOR.KEY% = HOME.KEY% OR                            \
3570: 4b8a:                MOTOR.KEY% = BTAB.KEY% OR                            \
3571: 4b8a:                MOTOR.KEY% = UP.KEY% THEN BEGIN
3572: 4b8a: 
3573: 4b8a:                 ! Display list function key
3574: 4b8a:                 CALL DM.SHOW.FN.KEY(9,"LIST")
3575: 4ba2: 
3576: 4ba2:             ENDIF ELSE BEGIN
3577: 4baa: 
3578: 4baa:                 ! Hide list function key
3579: 4baa:                 CALL DM.HIDE.FN.KEY(9)
3580: 4bbb: 
3581: 4bbb:             ENDIF
3582: 4bc6: 
3583: 4bc6:         ENDIF ELSE IF FIELD% = U0401.EVENT% THEN BEGIN                  !BMW
3584: 4be1:                                                                         !BMW
3585: 4be1:             ! IF returning to the log number field OR                   !BMW
3586: 4be1:             !    moving back to the source field                        !BMW
3587: 4be1:             IF MOTOR.KEY% = HOME.KEY% OR                            \   !BMW
3588: 4c28:                MOTOR.KEY% = BTAB.KEY% OR                            \   !BMW
3589: 4c28:                MOTOR.KEY% = UP.KEY% THEN BEGIN                          !BMW
3590: 4c28:                                                                         !BMW
3591: 4c28:                 ! Display list function key                             !BMW
3592: 4c28:                 CALL DM.SHOW.FN.KEY(9,"LIST")                           !BMW
3593: 4c40:                                                                         !BMW
3594: 4c40:             ENDIF ELSE BEGIN                                            !BMW
3595: 4c48:                                                                         !BMW
3596: 4c48:                 ! Hide list function key                                !BMW
3597: 4c48:                 CALL DM.HIDE.FN.KEY(9)                                  !BMW
3598: 4c59:                                                                         !BMW
3599: 4c59:             ENDIF                                                       !BMW
3600: 4c64:                                                                         !BMW
3601: 4c64:         ENDIF ELSE IF FIELD% = U0401.MESSAGE.GROUP% OR              \   !BMW
3602: 4c98:                       FIELD% = U0401.MESSAGE.NUMBER% THEN BEGIN
3603: 4c98: 
3604: 4c98:             ! IF returning to the log number field
3605: 4c98:             IF MOTOR.KEY% = HOME.KEY% THEN BEGIN
3606: 4caf: 
3607: 4caf:                 ! Display list function key
3608: 4caf:                 CALL DM.SHOW.FN.KEY(9,"LIST")
3609: 4cc7: 
3610: 4cc7:             ENDIF ELSE IF NOT MOTOR.KEY% = INVALID.KEY% THEN BEGIN
3611: 4cde: 
3612: 4cde:                 ! Hide list function key
3613: 4cde:                 CALL DM.HIDE.FN.KEY(9)
3614: 4cef: 
3615: 4cef:             ENDIF
3616: 4cf7: 
3617: 4cf7:         ENDIF
3618: 4d02: 
3619: 4d02:     ! IF summary screen
3620: 4d02:     ENDIF ELSE IF SCREEN% = 2 THEN BEGIN
3621: 4d16: 
3622: 4d16:         ! IF home key                                                   !HMW
3623: 4d16:         IF MOTOR.KEY% = HOME.KEY% THEN BEGIN
3624: 4d2d:             ! Remap HOME key to move to top of first page
3625: 4d2d:             MOTOR.KEY% = TOP.KEY%
3626: 4d44:         ! IF end key                                                    !HMW
3627: 4d44:         ENDIF ELSE IF MOTOR.KEY% = END.KEY% THEN BEGIN
3628: 4d5b:             ! Remap END key to move to bottom of last page
3629: 4d5b:             MOTOR.KEY% = BOTTOM.KEY%
3630: 4d70:         ENDIF
3631: 4d78: 
3632: 4d78:         ! Default to current page                                       !IMW
3633: 4d78:         THIS.PAGE% = RESULTS.PAGE%                                      !IMW
3634: 4d8a:                                                                         !IMW
3635: 4d8a:         IF MOTOR.KEY% = TOP.KEY% THEN BEGIN                             !IMW
3636: 4da1:                                                                         !IMW
3637: 4da1:             CURRENT.FIELD% = SUMMARY.START.FIELD% ! First row           !IMW
3638: 4db3:             THIS.PAGE% = 1 ! First page                                 !IMW
3639: 4dc4:                                                                         !IMW
3640: 4dc4:         ENDIF ELSE IF MOTOR.KEY% = BOTTOM.KEY% THEN BEGIN               !IMW
3641: 4ddb:                                                                         !IMW
3642: 4ddb:             CURRENT.FIELD% = RESULTS.LAST.PAGE% + 2 ! Last row          !IMW
3643: 4df4:             THIS.PAGE% = RESULTS.TOTAL.PAGES% ! Last page               !IMW
3644: 4e09:                                                                         !IMW
3645: 4e09:         ENDIF ELSE IF MOTOR.KEY% = PREV.KEY% OR                     \   !IMW
3646: 4e53:                       MOTOR.KEY% = UP.KEY% OR                       \   !IMW
3647: 4e53:                       MOTOR.KEY% = BTAB.KEY% THEN BEGIN                 !IMW
3648: 4e53:                                                                         !IMW
3649: 4e53:             IF CURRENT.FIELD% > SUMMARY.START.FIELD% THEN BEGIN         !IMW
3650: 4e69:                 CURRENT.FIELD% = CURRENT.FIELD% - 1 ! Previous row      !IMW
3651: 4e7a:             ENDIF ELSE BEGIN                                            !IMW
3652: 4e82:                 IF RESULTS.PAGE% > 1 THEN BEGIN                         !IMW
3653: 4e94:                     CURRENT.FIELD% = SUMMARY.END.FIELD% ! Last row      !IMW
3654: 4ea6:                     THIS.PAGE% = RESULTS.PAGE% - 1 ! Previous page      !IMW
3655: 4eb9:                 ENDIF                                                   !IMW
3656: 4ec1:             ENDIF                                                       !IMW
3657: 4ecc:                                                                         !IMW
3658: 4ecc:         ENDIF ELSE IF MOTOR.KEY% = NEXT.KEY% OR                     \   !IMW
3659: 4f16:                       MOTOR.KEY% = DOWN.KEY% OR                     \   !IMW
3660: 4f16:                       MOTOR.KEY% = TAB.KEY% THEN BEGIN                  !IMW
3661: 4f16:                                                                         !IMW
3662: 4f16:             IF CURRENT.FIELD% < SUMMARY.LAST.FIELD% THEN BEGIN          !IMW
3663: 4f2c:                 CURRENT.FIELD% = CURRENT.FIELD% + 1 ! Next row          !IMW
3664: 4f3d:             ENDIF ELSE BEGIN                                            !IMW
3665: 4f45:                 IF RESULTS.PAGE% < RESULTS.TOTAL.PAGES% THEN BEGIN      !IMW
3666: 4f5d:                     CURRENT.FIELD% = SUMMARY.START.FIELD% ! First row   !IMW
3667: 4f6f:                     THIS.PAGE% = RESULTS.PAGE% + 1 ! Next page          !IMW
3668: 4f82:                 ENDIF                                                   !IMW
3669: 4f8a:             ENDIF                                                       !IMW
3670: 4f95:                                                                         !IMW
3671: 4f95:         ENDIF ELSE IF MOTOR.KEY% = PGUP.KEY% OR                     \   !IMW
3672: 4fc7:                       MOTOR.KEY% = F7.KEY% THEN BEGIN                   !IMW
3673: 4fc7:                                                                         !IMW
3674: 4fc7:             CURRENT.FIELD% = SUMMARY.START.FIELD% ! First row           !IMW
3675: 4fd9:                                                                         !IMW
3676: 4fd9:             IF RESULTS.PAGE% > 1 THEN BEGIN                             !IMW
3677: 4feb:                 THIS.PAGE% = RESULTS.PAGE% - 1 ! Previous page          !IMW
3678: 4ffe:             ENDIF                                                       !IMW
3679: 5009:                                                                         !IMW
3680: 5009:         ENDIF ELSE IF MOTOR.KEY% = PGDN.KEY% OR                     \   !IMW
3681: 503b:                       MOTOR.KEY% = F8.KEY% THEN BEGIN                   !IMW
3682: 503b:                                                                         !IMW
3683: 503b:             CURRENT.FIELD% = SUMMARY.START.FIELD% ! First row           !IMW
3684: 504d:                                                                         !IMW
3685: 504d:             IF RESULTS.PAGE% < RESULTS.TOTAL.PAGES% THEN BEGIN          !IMW
3686: 5065:                 THIS.PAGE% = RESULTS.PAGE% + 1 ! Next page              !IMW
3687: 5078:             ENDIF                                                       !IMW
3688: 5080:                                                                         !IMW
3689: 5080:         ENDIF                                                           !IMW
3690: 5088:                                                                         !IMW
3691: 5088:         ! Calculate summary index for the current row                   !IMW
3692: 5088:         CURRENT.INDEX% =                                            \   !IMW
3693: 50ab:             GET.CURRENT.INDEX(THIS.PAGE%,CURRENT.FIELD%)                !IMW
3694: 50ab:                                                                         !IMW
3695: 50ab:         ! Show or hide the pair option                                  !IMW
3696: 50ab:         CALL SHOW.PAIR.OPTION(CURRENT.INDEX%)                           !IMW
3697: 50c3:                                                                         !IMW
3698: 50c3:     ! IF detail screen
3699: 50c3:     ENDIF ELSE IF SCREEN% = 3 THEN BEGIN
3700: 50d4: 
3701: 50d4:         ! IF returning from the help screen
3702: 50d4:         IF MOTOR.KEY% = F1.KEY% THEN BEGIN
3703: 50eb:             ! Restore the detail screen contents
3704: 50eb:             CALL PSU0406
3705: 50f8:         ENDIF
3706: 5103: 
3707: 5103:     ! IF application selection screen
3708: 5103:     ENDIF ELSE IF SCREEN% = 6 THEN BEGIN
3709: 5114: 
3710: 5114:         ! IF home key                                                   !HMW
3711: 5114:         IF MOTOR.KEY% = HOME.KEY% THEN BEGIN
3712: 512b:             ! Remap HOME key to move to top of first page
3713: 512b:             MOTOR.KEY% = TOP.KEY%
3714: 5142:         ! IF end key                                                    !HMW
3715: 5142:         ENDIF ELSE IF MOTOR.KEY% = END.KEY% THEN BEGIN
3716: 5159:             ! Remap END key to move to bottom of last page
3717: 5159:             MOTOR.KEY% = BOTTOM.KEY%
3718: 516e:         ENDIF
3719: 5179: 
3720: 5179:     ! IF source selection screen                                        !BMW
3721: 5179:     ENDIF ELSE IF SCREEN% = 11 THEN BEGIN                               !BMW
3722: 518a:                                                                         !BMW
3723: 518a:         ! IF home key                                                   !HMW
3724: 518a:         IF MOTOR.KEY% = HOME.KEY% THEN BEGIN                            !BMW
3725: 51a1:             ! Remap HOME key to move to top of first page               !BMW
3726: 51a1:             MOTOR.KEY% = TOP.KEY%                                       !BMW
3727: 51b8:         ! IF end key                                                    !HMW
3728: 51b8:         ENDIF ELSE IF MOTOR.KEY% = END.KEY% THEN BEGIN                  !BMW
3729: 51cf:             ! Remap END key to move to bottom of last page              !BMW
3730: 51cf:             MOTOR.KEY% = BOTTOM.KEY%                                    !BMW
3731: 51e4:         ENDIF                                                           !BMW
3732: 51ee:                                                                         !BMW
3733: 51ee:     ! IF utils screen                                                   !FMW
3734: 51ee:     ENDIF ELSE IF SCREEN% = 12 THEN BEGIN                               !FMW
3735: 51ff:                                                                         !FMW
3736: 51ff:         ! IF returning from the help screen                             !FMW
3737: 51ff:         IF MOTOR.KEY% = F1.KEY% THEN BEGIN                              !FMW
3738: 5216:                                                                         !FMW
3739: 5216:             ! Restore the UTILS sector update screen                    !FMW
3740: 5216:             CALL DISPLAY.SECTOR(UTILS.PAGE%)                            !FMW
3741: 523d:                                                                         !FMW
3742: 523d:         ENDIF                                                           !FMW
3743: 5245:                                                                         !FMW
3744: 5245:     ENDIF
3745: 524d: 
3746: 524d: END SUB
3747: 5261: 
3748: 5261: \***********************************************************************
3749: 5261: \***
3750: 5261: \***    SELECT.ALL.APPLICATIONS
3751: 5261: \***
3752: 5261: \***********************************************************************
3753: 5261: \***
3754: 5261: \***    Sets or clears all current application selections
3755: 5261: \***
3756: 5261: \***********************************************************************
3757: 5261: SUB SELECT.ALL.APPLICATIONS(SELECTION)
3758: 5285:     INTEGER*1 SELECTION
3759: 5285:     INTEGER*1 FLAG.VALUE%
3760: 5285: 
3761: 5285:     ! FOR each application
3762: 5285:     FOR APPLICATION.INDEX% = 1 TO APPLICATION.COUNT%
3763: 5295: 
3764: 5295:         ! IF all applications selected
3765: 5295:         IF SELECTION THEN BEGIN
3766: 52a6:             ! Set selection
3767: 52a6:             FLAG.VALUE% = 58H ! "X"
3768: 52b5:         ENDIF ELSE BEGIN
3769: 52bd:             ! Clear selection
3770: 52bd:             FLAG.VALUE% = 20H ! " "
3771: 52ca:         ENDIF
3772: 52d2: 
3773: 52d2:         ! Update current application selection
3774: 52d2:         CALL PUTN1(APPLICATION.RECORD$(                             \
3775: 52ff:             APPLICATION.INDEX%),9,FLAG.VALUE%)
3776: 52ff: 
3777: 52ff:     NEXT APPLICATION.INDEX%
3778: 531a: 
3779: 531a:     ! IF all applications selected
3780: 531a:     IF SELECTION THEN BEGIN
3781: 532b:         ! Set applications selected count
3782: 532b:         APPLICATION.SELECTED.COUNT% = APPLICATION.COUNT%
3783: 533b:     ENDIF ELSE BEGIN
3784: 5343:         ! Clear applications selected count
3785: 5343:         APPLICATION.SELECTED.COUNT% = 0
3786: 5351:     ENDIF
3787: 5359: 
3788: 5359: END SUB
3789: 536d: 
3790: 536d: \***********************************************************************
3791: 536d: \***
3792: 536d: \***    SELECT.ALL.SEVERITYS
3793: 536d: \***
3794: 536d: \***********************************************************************
3795: 536d: \***
3796: 536d: \***    Sets or clears all current severity selections
3797: 536d: \***
3798: 536d: \***********************************************************************
3799: 536d: SUB SELECT.ALL.SEVERITYS(SELECTION)
3800: 5391:     INTEGER*1 SELECTION
3801: 5391:     INTEGER*1 FLAG.VALUE%
3802: 5391: 
3803: 5391:     ! FOR each severity
3804: 5391:     FOR SEVERITY.INDEX% = 0 TO (SEVERITY.COUNT% - 1)
3805: 53a1: 
3806: 53a1:         ! IF all severitys selected
3807: 53a1:         IF SELECTION THEN BEGIN
3808: 53b2:             ! Set selection
3809: 53b2:             FLAG.VALUE% = 58H ! "X"
3810: 53c1:         ENDIF ELSE BEGIN
3811: 53c9:             ! Clear selection
3812: 53c9:             FLAG.VALUE% = 20H ! " "
3813: 53d6:         ENDIF
3814: 53de: 
3815: 53de:         ! Update current severity selection
3816: 53de:         CALL PUTN1(SEVERITY.RECORD$(SEVERITY.INDEX%),2,FLAG.VALUE%)
3817: 540b: 
3818: 540b:     NEXT SEVERITY.INDEX%
3819: 5427: 
3820: 5427:     ! IF all severitys selected
3821: 5427:     IF SELECTION THEN BEGIN
3822: 5438:         ! Set severitys selected count
3823: 5438:         SEVERITY.SELECTED.COUNT% = SEVERITY.COUNT%
3824: 5448:     ENDIF ELSE BEGIN
3825: 5450:         ! Clear severitys selected count
3826: 5450:         SEVERITY.SELECTED.COUNT% = 0
3827: 545e:     ENDIF
3828: 5466: 
3829: 5466: END SUB
3830: 547a: 
3831: 547a: \***********************************************************************
3832: 547a: \***
3833: 547a: \***    SELECT.ALL.BUCKETS
3834: 547a: \***
3835: 547a: \***********************************************************************
3836: 547a: \***
3837: 547a: \***    Sets or clears all current bucket selections
3838: 547a: \***
3839: 547a: \***********************************************************************
3840: 547a: SUB SELECT.ALL.BUCKETS(SELECTION)
3841: 549e:     INTEGER*1 SELECTION
3842: 549e:     INTEGER*1 FLAG.VALUE%
3843: 549e: 
3844: 549e:     ! FOR each bucket
3845: 549e:     FOR BUCKET.INDEX% = 0 TO (BUCKET.COUNT% - 1)
3846: 54ae: 
3847: 54ae:         ! IF all buckets selected
3848: 54ae:         IF SELECTION THEN BEGIN
3849: 54bf:             ! Set selection
3850: 54bf:             FLAG.VALUE% = 58H ! "X"
3851: 54ce:         ENDIF ELSE BEGIN
3852: 54d6:             ! Clear selection
3853: 54d6:             FLAG.VALUE% = 20H ! " "
3854: 54e3:         ENDIF
3855: 54eb: 
3856: 54eb:         ! Update current bucket selection
3857: 54eb:         CALL PUTN1(BUCKET.RECORD$(BUCKET.INDEX%),2,FLAG.VALUE%)
3858: 5518: 
3859: 5518:     NEXT BUCKET.INDEX%
3860: 5534: 
3861: 5534:     ! IF all buckets selected
3862: 5534:     IF SELECTION THEN BEGIN
3863: 5545:         ! Set buckets selected count
3864: 5545:         BUCKET.SELECTED.COUNT% = BUCKET.COUNT%
3865: 5555:     ENDIF ELSE BEGIN
3866: 555d:         ! Clear buckets selected count
3867: 555d:         BUCKET.SELECTED.COUNT% = 0
3868: 556b:     ENDIF
3869: 5573: 
3870: 5573: END SUB
3871: 5587: 
3872: 5587: \***********************************************************************!BMW
3873: 5587: \***                                                                    !BMW
3874: 5587: \***    SELECT.ALL.SOURCES                                              !BMW
3875: 5587: \***                                                                    !BMW
3876: 5587: \***********************************************************************!BMW
3877: 5587: \***                                                                    !BMW
3878: 5587: \***    Sets or clears all current source selections                    !BMW
3879: 5587: \***                                                                    !BMW
3880: 5587: \***********************************************************************!BMW
3881: 5587: SUB SELECT.ALL.SOURCES(SELECTION)                                       !BMW
3882: 55ab:     INTEGER*1 SELECTION                                                 !BMW
3883: 55ab:     INTEGER*1 FLAG.VALUE%                                               !BMW
3884: 55ab:                                                                         !BMW
3885: 55ab:     ! FOR each source                                                   !BMW
3886: 55ab:     FOR SOURCE.INDEX% = 1 TO SOURCE.COUNT%                              !BMW
3887: 55bb:                                                                         !BMW
3888: 55bb:         ! IF all sources selected                                       !BMW
3889: 55bb:         IF SELECTION THEN BEGIN                                         !BMW
3890: 55cc:             ! Set selection                                             !BMW
3891: 55cc:             FLAG.VALUE% = 58H ! "X"                                     !BMW
3892: 55db:         ENDIF ELSE BEGIN                                                !BMW
3893: 55e3:             ! Clear selection                                           !BMW
3894: 55e3:             FLAG.VALUE% = 20H ! " "                                     !BMW
3895: 55f0:         ENDIF                                                           !BMW
3896: 55f8:                                                                         !BMW
3897: 55f8:         ! Update current source selection                               !BMW
3898: 55f8:         CALL PUTN1(SOURCE.RECORD$(SOURCE.INDEX%),4,FLAG.VALUE%)         !BMW
3899: 5625:                                                                         !BMW
3900: 5625:     NEXT SOURCE.INDEX%                                                  !BMW
3901: 5640:                                                                         !BMW
3902: 5640:     ! IF all sources selected                                           !BMW
3903: 5640:     IF SELECTION THEN BEGIN                                             !BMW
3904: 5651:         ! Set sources selected count                                    !BMW
3905: 5651:         SOURCE.SELECTED.COUNT% = SOURCE.COUNT%                          !BMW
3906: 5661:     ENDIF ELSE BEGIN                                                    !BMW
3907: 5669:         ! Clear sources selected count                                  !BMW
3908: 5669:         SOURCE.SELECTED.COUNT% = 0                                      !BMW
3909: 5677:     ENDIF                                                               !BMW
3910: 567f:                                                                         !BMW
3911: 567f: END SUB                                                                 !BMW
3912: 5693:                                                                         !BMW
3913: 5693: \***********************************************************************
3914: 5693: \***
3915: 5693: \***   SUBSTITUTE$
3916: 5693: \***
3917: 5693: \***********************************************************************
3918: 5693: \***
3919: 5693: \***   Replace sub-string with another sub-string in a string
3920: 5693: \***
3921: 5693: \***********************************************************************
3922: 5693: FUNCTION SUBSTITUTE$(T$,P$,R$) PUBLIC
3923: 56c6: 
3924: 56c6:     STRING SUBSTITUTE$,T$,P$,R$
3925: 56c6:     INTEGER*2 INDEX%
3926: 56c6: 
3927: 56c6:     ! Search for replacement symbol in string
3928: 56c6:     INDEX% = MATCH(P$,T$,1)
3929: 56e4: 
3930: 56e4:     ! IF found
3931: 56e4:     IF INDEX% > 0 THEN BEGIN
3932: 56f3: 
3933: 56f3:         ! Substitute replacement symbol with parameter string
3934: 56f3:         SUBSTITUTE$ = LEFT$(T$,INDEX% - 1) + \
3935: 5757:                       R$ + \
3936: 5757:                       MID$(T$,INDEX% + LEN(P$),LEN(T$))
3937: 5757:     ENDIF ELSE BEGIN
3938: 575f:         SUBSTITUTE$ = T$
3939: 5777:     ENDIF
3940: 577f: 
3941: 577f: END FUNCTION
3942: 57a7: 
3943: 57a7: \***********************************************************************
3944: 57a7: \***********************************************************************
3945: 57a7: \***
3946: 57a7: \***    MAIN SUBPROGRAM PSU0405
3947: 57a7: \***
3948: 57a7: \***********************************************************************
3949: 57a7: \***********************************************************************
3950: 57a7: SUB PSU0405 PUBLIC
3951: 57cb: 
3952: 57cb:     ON ERROR GOTO ERROR.DETECTED
3953: 57e0: 
3954: 57e0:     ! Display Manager Initialisation
3955: 57e0:     CALL DM.INIT
3956: 57ed: 
3957: 57ed:     ! Get list of available event log files
3958: 57ed:     GOSUB GET.FILE.RESULTS
3959: 57ff: 
3960: 57ff:     GOSUB INITIALISE.SEVERITY.LIST
3961: 5811:     GOSUB INITIALISE.BUCKET.LIST
3962: 5823:     GOSUB INITIALISE.SOURCE.LIST                                        !BMW
3963: 5835:     
3964: 5835:     ! Perform full application index rebuild                            !BMW
3965: 5835:     CALL CREATE.APPLICATION.LIST(TRUE,LOG.NUMBER$)                      !BMW
3966: 5850:     
3967: 5850:     GOSUB INITIALISE.SELECTION.FIELDS
3968: 5862: 
3969: 5862:     GOSUB PROCESS.SELECTION.SCREEN
3970: 5874: 
3971: 5874:     EXIT SUB
3972: 587f: 
3973: 587f: \***********************************************************************
3974: 587f: \***
3975: 587f: \***    INITIALISE.SELECTION.FIELDS
3976: 587f: \***
3977: 587f: \***********************************************************************
3978: 587f: INITIALISE.SELECTION.FIELDS:
3979: 588f: 
3980: 588f:     ! Dimension to size of last used field
3981: 588f:     DIM SELECTION.FIELD$(U0401.MESSAGE.NUMBER.STATUS%)
3982: 58bf: 
3983: 58bf:     SELECTION.FIELD$(U0401.APPLICATION%)    = "*"
3984: 58e6:     SELECTION.FIELD$(U0401.TERMINAL%)       = "*"
3985: 590d:     SELECTION.FIELD$(U0401.CONTROLLER.ID%)  = "*"
3986: 5934:     SELECTION.FIELD$(U0401.SEVERITY%)       = "*"
3987: 595b:     SELECTION.FIELD$(U0401.BUCKET%)         = "*"
3988: 5982:     SELECTION.FIELD$(U0401.SOURCE%)         = "*"
3989: 59a9:     SELECTION.FIELD$(U0401.EVENT%)          = "*"
3990: 59d0:     SELECTION.FIELD$(U0401.MESSAGE.GROUP%)  = "*"
3991: 59f7:     SELECTION.FIELD$(U0401.MESSAGE.NUMBER%) = "*"
3992: 5a1e: 
3993: 5a1e:     LAST.APPLICATION$ = SELECTION.FIELD$(U0401.APPLICATION%)
3994: 5a4a:     LAST.SEVERITY$    = SELECTION.FIELD$(U0401.SEVERITY%)
3995: 5a76:     LAST.BUCKET$      = SELECTION.FIELD$(U0401.BUCKET%)
3996: 5aa2:     LAST.SOURCE$      = SELECTION.FIELD$(U0401.SOURCE%)                 !BMW
3997: 5ace: 
3998: 5ace:     RETURN
3999: 5ade: 
4000: 5ade: \***********************************************************************
4001: 5ade: \***
4002: 5ade: \***    INITIALISE.SEVERITY.LIST
4003: 5ade: \***
4004: 5ade: \***********************************************************************
4005: 5ade: INITIALISE.SEVERITY.LIST:
4006: 5aee: 
4007: 5aee:     SEVERITY.COUNT% = 6
4008: 5afc: 
4009: 5afc:     DIM SEVERITY.RECORD$(SEVERITY.COUNT% - 1)
4010: 5b28:     DIM SELECTION.SEVERITY(SEVERITY.COUNT% - 1)
4011: 5b54: 
4012: 5b54:     FOR I% = 0 TO (SEVERITY.COUNT% - 1)
4013: 5b64:         SEVERITY.RECORD$(I%) = STR$(I%) +                           \
4014: 5ba3:                                "X" + \ Current                      \
4015: 5ba3:                                "X"   ! New
4016: 5ba3:         SELECTION.SEVERITY(I%) = TRUE
4017: 5bca:     NEXT I%
4018: 5be3: 
4019: 5be3:     SEVERITY.SELECTED.COUNT% = SEVERITY.COUNT%
4020: 5bf1: 
4021: 5bf1:     RETURN
4022: 5c01: 
4023: 5c01: \***********************************************************************
4024: 5c01: \***
4025: 5c01: \***    INITIALISE.BUCKET.LIST
4026: 5c01: \***
4027: 5c01: \***********************************************************************
4028: 5c01: INITIALISE.BUCKET.LIST:
4029: 5c11: 
4030: 5c11:     BUCKET.COUNT% = 7
4031: 5c1f: 
4032: 5c1f:     DIM BUCKET.RECORD$(BUCKET.COUNT% - 1)
4033: 5c4b:     DIM SELECTION.BUCKET(BUCKET.COUNT% - 1)
4034: 5c77: 
4035: 5c77:     FOR I% = 0 TO (BUCKET.COUNT% - 1)
4036: 5c87:         BUCKET.RECORD$(I%) = STR$(I%) +                             \
4037: 5cc6:                              "X" +  \ Current                       \
4038: 5cc6:                              "X"    ! New
4039: 5cc6:         SELECTION.BUCKET(I%) = TRUE
4040: 5ced:     NEXT I%
4041: 5d06: 
4042: 5d06:     BUCKET.SELECTED.COUNT% = BUCKET.COUNT%
4043: 5d14: 
4044: 5d14:     RETURN
4045: 5d24: 
4046: 5d24: \***********************************************************************!BMW
4047: 5d24: \***                                                                    !BMW
4048: 5d24: \***    INITIALISE.SOURCE.LIST                                          !BMW
4049: 5d24: \***                                                                    !BMW
4050: 5d24: \***********************************************************************!BMW
4051: 5d24: INITIALISE.SOURCE.LIST:                                                 !BMW
4052: 5d34:                                                                         !BMW
4053: 5d34:     DIM SOURCE.RECORD$(MAX.SOURCE.RECORDS%)                             !BMW
4054: 5d62:     DIM SOURCE.LIST$(MAX.SOURCE.RECORDS%)                               !BMW
4055: 5d90:     DIM SOURCE.MAP%(MAX.SOURCE.RECORDS%)                                !BMW
4056: 5dbe:                                                                         !BMW
4057: 5dbe:     J% = 0                                                              !BMW
4058: 5dcc:                                                                         !BMW
4059: 5dcc:     FOR I% = 0 TO (MAX.SOURCE.RECORDS% - 1)                             !BMW
4060: 5ddd:                                                                         !BMW
4061: 5ddd:         IF LEN(SOURCE.TEXT$(I%)) > 0 THEN BEGIN                         !CMW
4062: 5e0c:                                                                         !BMW
4063: 5e0c:             J% = J% + 1                                                 !BMW
4064: 5e18:                                                                         !BMW
4065: 5e18:             SOURCE.MAP%(I%) = J%                                        !BMW
4066: 5e35:                                                                         !BMW
4067: 5e35:             SOURCE.RECORD$(J%) = PAD$(STR$(I%),3) +                 \   !BMW
4068: 5e88:                                  "X" +  \ Current                   \   !BMW
4069: 5e88:                                  "X"    ! New                           !BMW
4070: 5e88:                                                                         !BMW
4071: 5e88:         ENDIF ELSE BEGIN                                                !BMW
4072: 5e90:             SOURCE.MAP%(I%) = NULL.MAPPING% ! High values               !BMW
4073: 5eb7:         ENDIF                                                           !BMW
4074: 5ebf:                                                                         !BMW
4075: 5ebf:     NEXT I%                                                             !BMW
4076: 5edf:                                                                         !BMW
4077: 5edf:     SOURCE.COUNT% = J%                                                  !BMW
4078: 5eed:                                                                         !BMW
4079: 5eed:     SOURCE.SELECTED.COUNT% = SOURCE.COUNT%                              !BMW
4080: 5efb:                                                                         !BMW
4081: 5efb:     ! Calculate total number of sources pages                           !BMW
4082: 5efb:     SOURCE.TOTAL.PAGES% = \                                             !BMW
4083: 5f46:         INT((SOURCE.COUNT% - 1) / SOURCES.PER.PAGE%) + 1                !BMW
4084: 5f46:                                                                         !BMW
4085: 5f46:     ! Calculate sources on the last page                                !BMW
4086: 5f46:     SOURCE.LAST.PAGE% =                                             \   !BMW
4087: 5f66:         SOURCE.COUNT% - ((SOURCE.TOTAL.PAGES% - 1) *                \   !BMW
4088: 5f66:         SOURCES.PER.PAGE%)                                              !BMW
4089: 5f66:                                                                         !BMW
4090: 5f66:     RETURN                                                              !BMW
4091: 5f76:                                                                         !BMW
4092: 5f76: \***********************************************************************
4093: 5f76: \***
4094: 5f76: \***    PROCESS.SELECTION.SCREEN
4095: 5f76: \***
4096: 5f76: \***********************************************************************
4097: 5f76: PROCESS.SELECTION.SCREEN:
4098: 5f86: 
4099: 5f86:     GOSUB INITIALISE.SELECTION.SCREEN
4100: 5f98: 
4101: 5f98:     CURRENT.FIELD% = SELECTION.START.FIELD%
4102: 5faa: 
4103: 5faa:     WHILE NOT SELECTION.EXIT.PRESSED
4104: 5fb5: 
4105: 5fb5:         CALL DM.CURRENT.FIELD(CURRENT.FIELD%)
4106: 5fcd: 
4107: 5fcd:         GOSUB DISPLAY.SELECTION.PAGE
4108: 5fdf: 
4109: 5fdf:         KEY% = DM.PROCESS.SCREEN(SELECTION.START.FIELD%,            \
4110: 6007:                                  SELECTION.END.FIELD%,              \
4111: 6007:                                  TRUE) ! Quit confirm
4112: 6007: 
4113: 6007:         ! IF quit NOT confirmed yet
4114: 6007:         IF SELECTION.QUIT.CONFIRM THEN BEGIN
4115: 6019: 
4116: 6019:             ! IF quit confirmed now
4117: 6019:             IF KEY% = F3.KEY% OR KEY% = ESC.KEY% THEN BEGIN
4118: 604d: 
4119: 604d:                 SELECTION.EXIT.PRESSED = TRUE
4120: 6061: 
4121: 6061:             ENDIF ELSE BEGIN
4122: 6069: 
4123: 6069:                 ! Restore previous field position
4124: 6069:                 CURRENT.FIELD% = SELECTION.CURRENT.FIELD%
4125: 607b: 
4126: 607b:                 ! Reset quit confirm flag
4127: 607b:                 SELECTION.QUIT.CONFIRM = FALSE
4128: 608d: 
4129: 608d:             ENDIF
4130: 6098: 
4131: 6098:         ! IF quit key OR escape key
4132: 6098:         ENDIF ELSE IF KEY% = F3.KEY% OR KEY% = ESC.KEY% THEN BEGIN
4133: 60cc: 
4134: 60cc:             SELECTION.EXIT.PRESSED = TRUE
4135: 60e1: 
4136: 60e1:         ! IF selection list key
4137: 60e1:         ENDIF ELSE IF KEY% = F9.KEY% THEN BEGIN
4138: 60fc: 
4139: 60fc:             CURRENT.FIELD% = DM.CURRENT.FIELD(0)
4140: 6114: 
4141: 6114:             ! Save all input fields to allow them to be restored
4142: 6114:             ! when returning back to the selection screen
4143: 6114:             FOR I% = SELECTION.START.FIELD% TO SELECTION.END.FIELD%
4144: 6124:                 SELECTION.FIELD$(I%) = FIELD$(I%)
4145: 615b:                 CALL TRIM(SELECTION.FIELD$(I%))
4146: 617c:             NEXT I%
4147: 6194: 
4148: 6194:             ! Save current field position
4149: 6194:             SELECTION.CURRENT.FIELD% = CURRENT.FIELD%
4150: 61a6: 
4151: 61a6:             ! IF log number field
4152: 61a6:             IF CURRENT.FIELD% = U0401.LOG.NUMBER% THEN BEGIN
4153: 61be: 
4154: 61be:                 ! Display 'Processing - Please Wait...' message
4155: 61be:                 CALL DM.STATUS("MESSAGE(251,'')")
4156: 61d2: 
4157: 61d2:                 GOSUB PROCESS.FILES.SCREEN
4158: 61e7: 
4159: 61e7:             ENDIF ELSE IF CURRENT.FIELD% = U0401.APPLICATION% THEN BEGIN
4160: 61ff: 
4161: 61ff:                 ! Display 'Processing - Please Wait...' message
4162: 61ff:                 CALL DM.STATUS("MESSAGE(251,'')")
4163: 6213: 
4164: 6213:                 GOSUB PROCESS.APPLICATION.SCREEN
4165: 6228: 
4166: 6228:             ENDIF ELSE IF CURRENT.FIELD% = U0401.SEVERITY% THEN BEGIN
4167: 6240: 
4168: 6240:                 ! Display 'Processing - Please Wait...' message
4169: 6240:                 CALL DM.STATUS("MESSAGE(251,'')")
4170: 6254: 
4171: 6254:                 GOSUB PROCESS.SEVERITY.SCREEN
4172: 6269: 
4173: 6269:             ENDIF ELSE IF CURRENT.FIELD% = U0401.BUCKET% THEN BEGIN
4174: 6281: 
4175: 6281:                 ! Display 'Processing - Please Wait...' message
4176: 6281:                 CALL DM.STATUS("MESSAGE(251,'')")
4177: 6295: 
4178: 6295:                 GOSUB PROCESS.BUCKET.SCREEN
4179: 62a9: 
4180: 62a9:             ENDIF ELSE IF CURRENT.FIELD% = U0401.SOURCE% THEN BEGIN     !BMW
4181: 62c1:                                                                         !BMW
4182: 62c1:                 ! Display 'Processing - Please Wait...' message         !BMW
4183: 62c1:                 CALL DM.STATUS("MESSAGE(251,'')")                       !BMW
4184: 62d5:                                                                         !BMW
4185: 62d5:                 GOSUB PROCESS.SOURCE.SCREEN                             !BMW
4186: 62e9:                                                                         !BMW
4187: 62e9:             ENDIF ELSE BEGIN
4188: 62f1: 
4189: 62f1:                 ! No records found
4190: 62f1:                 CALL DM.FOCUS("",                                   \
4191: 6309:                 "MESSAGE(221,'NO SELECTION LIST AVAILABLE')")
4192: 6309: 
4193: 6309:             ENDIF
4194: 6311: 
4195: 6311:             ! Restore previous field position
4196: 6311:             CURRENT.FIELD% = SELECTION.CURRENT.FIELD%
4197: 6326: 
4198: 6326:         ! IF enter key
4199: 6326:         ENDIF ELSE IF KEY% = ENTER.KEY% THEN BEGIN
4200: 6341: 
4201: 6341:             CURRENT.FIELD% = DM.CURRENT.FIELD(0)
4202: 6359: 
4203: 6359:             ! Save current field position
4204: 6359:             SELECTION.CURRENT.FIELD% = CURRENT.FIELD%
4205: 636b: 
4206: 636b:             ! Ensure each field contains a valid value
4207: 636b:             GOSUB VALIDATE.SELECTION.FIELDS
4208: 637d: 
4209: 637d:             IF VALID.INPUT THEN BEGIN
4210: 6392: 
4211: 6392:                 ! Save all input fields to allow them to be restored
4212: 6392:                 ! when returning back to the selection screen
4213: 6392:                 FOR I% = SELECTION.START.FIELD% TO SELECTION.END.FIELD%
4214: 63a2:                     SELECTION.FIELD$(I%) = UCASE$(FIELD$(I%))
4215: 63de:                     CALL TRIM(SELECTION.FIELD$(I%))
4216: 63ff:                 NEXT I%
4217: 6417: 
4218: 6417:                 ! Display 'Processing - Please Wait...' message
4219: 6417:                 CALL DM.STATUS("MESSAGE(251,'')")
4220: 642b: 
4221: 642b:                 ! IF currently active event log                         !HMW
4222: 642b:                 IF VAL(LOG.NUMBER$) = 0 THEN BEGIN                      !HMW
4223: 6460:                     ! IF new events are available                       !HMW
4224: 6460:                     IF SIZE(LOG.FILE.NAME$) > LOG.FILE.SIZE% THEN BEGIN !HMW
4225: 648c:                         ! Perform partial application index rebuild     !HMW
4226: 648c:                         CALL CREATE.APPLICATION.LIST(FALSE,LOG.NUMBER$) !HMW
4227: 64a7:                     ENDIF                                               !HMW
4228: 64af:                 ENDIF                                                   !HMW
4229: 64b7:                 
4230: 64b7:                 GOSUB GET.SEARCH.RESULTS
4231: 64c9: 
4232: 64c9:                 IF RESULTS.COUNT% = 0 THEN BEGIN
4233: 64db: 
4234: 64db:                     ! No records found
4235: 64db:                    CALL DM.FOCUS("",                                \
4236: 64f5:                    "MESSAGE(221,'NO RECORDS FOUND FOR THIS SELECTION')")
4237: 64f5: 
4238: 64f5:                 ENDIF ELSE BEGIN
4239: 64fd: 
4240: 64fd:                     GOSUB PROCESS.SUMMARY.SCREEN
4241: 650f: 
4242: 650f:                     ! Reset quit confirm flag
4243: 650f:                     CALL DM.CHANGED.FLAG(FALSE)
4244: 6527: 
4245: 6527:                 ENDIF
4246: 652f: 
4247: 652f:                 ! Restore previous field position
4248: 652f:                 CURRENT.FIELD% = SELECTION.CURRENT.FIELD%
4249: 6544: 
4250: 6544:             ENDIF ELSE BEGIN
4251: 654c: 
4252: 654c:                 ! Restore previous field position
4253: 654c:                 CURRENT.FIELD% = SELECTION.CURRENT.FIELD%
4254: 655e: 
4255: 655e:                 ! IF returning to a selection list field
4256: 655e:                 IF CURRENT.FIELD% = U0401.LOG.NUMBER% OR            \
4257: 65d4:                    CURRENT.FIELD% = U0401.APPLICATION% OR           \
4258: 65d4:                    CURRENT.FIELD% = U0401.SEVERITY% OR              \
4259: 65d4:                    CURRENT.FIELD% = U0401.BUCKET% OR                \   !BMW
4260: 65d4:                    CURRENT.FIELD% = U0401.SOURCE% THEN BEGIN            !BMW
4261: 65d4: 
4262: 65d4:                     ! Display list function key
4263: 65d4:                     CALL DM.SHOW.FN.KEY(9,"LIST")
4264: 65ec: 
4265: 65ec:                 ENDIF ELSE BEGIN
4266: 65f4: 
4267: 65f4:                     ! Hide list function key
4268: 65f4:                     CALL DM.HIDE.FN.KEY(9)
4269: 6605: 
4270: 6605:                 ENDIF
4271: 660d: 
4272: 660d:             ENDIF
4273: 6618: 
4274: 6618:         ! IF invalid data entered in a selection field
4275: 6618:         ENDIF ELSE IF KEY% = INVALID.KEY% THEN BEGIN
4276: 6633: 
4277: 6633:             CURRENT.FIELD% = DM.CURRENT.FIELD(0)
4278: 664b: 
4279: 664b:             ! IF log number field
4280: 664b:             IF CURRENT.FIELD% = U0401.LOG.NUMBER% THEN BEGIN
4281: 6663: 
4282: 6663:                 ! B221 Invalid Log Number
4283: 6663:                 CALL DM.FOCUS("",                                   \
4284: 667e:                 "MESSAGE(221,'Log Number file does not exist')")
4285: 667e: 
4286: 667e:             ENDIF ELSE IF CURRENT.FIELD% = U0401.APPLICATION% THEN BEGIN
4287: 6696: 
4288: 6696:                 ! B221 Application not present in logs                  !IMW
4289: 6696:                 CALL DM.FOCUS("",                                   \
4290: 66c0:                 "MESSAGE(221,'Application not present " +           \   !IMW
4291: 66c0:                 "in the selected log')")                                !IMW
4292: 66c0: 
4293: 66c0:             ENDIF ELSE IF CURRENT.FIELD% = U0401.TERMINAL% THEN BEGIN
4294: 66d8: 
4295: 66d8:                 ! B221 Invalid Terminal
4296: 66d8:                 CALL DM.FOCUS("",                                   \
4297: 66f3:                 "MESSAGE(221,'Terminal must be in the range 1-999')")   !BMW
4298: 66f3: 
4299: 66f3:             ENDIF ELSE IF CURRENT.FIELD% = U0401.CONTROLLER.ID% THEN BEGIN
4300: 670b: 
4301: 670b:                 ! B221 Invalid Controller ID
4302: 670b:                 CALL DM.FOCUS("",                                   \
4303: 6726:                 "MESSAGE(221,'Controller ID must be CE or CF')")
4304: 6726: 
4305: 6726:             ENDIF ELSE IF CURRENT.FIELD% = U0401.SEVERITY% THEN BEGIN
4306: 673e: 
4307: 673e:                 ! B221 Invalid Severity
4308: 673e:                 CALL DM.FOCUS("",                                   \
4309: 6758:                 "MESSAGE(221,'Severity must be in the range 1-5 or 0')")
4310: 6758: 
4311: 6758:             ENDIF ELSE IF CURRENT.FIELD% = U0401.BUCKET% THEN BEGIN
4312: 6770: 
4313: 6770:                 ! B221 Invalid Bucket
4314: 6770:                 CALL DM.FOCUS("",                                   \
4315: 678a:                 "MESSAGE(221,'Bucket must be in the range 1-6 or 0')")
4316: 678a: 
4317: 678a:             ENDIF ELSE IF CURRENT.FIELD% = U0401.SOURCE% THEN BEGIN     !BMW
4318: 67a2:                                                                         !BMW
4319: 67a2:                 ! B221 Invalid Source                                   !BMW
4320: 67a2:                 CALL DM.FOCUS("",                                   \   !BMW
4321: 67ba:                 "MESSAGE(221,'Source must be in the range 1-255 or 0')")!BMW
4322: 67ba: 
4323: 67ba:             ENDIF
4324: 67c4: 
4325: 67c4:         ! IF any other motor key
4326: 67c4:         ENDIF ELSE BEGIN
4327: 67cc: 
4328: 67cc:             CURRENT.FIELD% = DM.CURRENT.FIELD(0)
4329: 67e4: 
4330: 67e4:             ! B001 Invalid key pressed
4331: 67e4:             CALL DM.FOCUS("","MESSAGE(1,'')")
4332: 67fc: 
4333: 67fc:         ENDIF
4334: 6804: 
4335: 6804:     WEND
4336: 6816: 
4337: 6816:     RETURN
4338: 6826: 
4339: 6826: \***********************************************************************
4340: 6826: \***
4341: 6826: \***    DISPLAY.SELECTION.PAGE
4342: 6826: \***
4343: 6826: \***********************************************************************
4344: 6826: DISPLAY.SELECTION.PAGE:
4345: 6836: 
4346: 6836:     FIELD$(U0401.LOG.NUMBER%) = PAD$(LOG.NUMBER$,2)
4347: 686e: 
4348: 686e:     IF APPLICATION.SELECTED.COUNT% = 0 THEN BEGIN
4349: 687d:         FIELD$(U0401.APPLICATION.STATUS%) = NO.APPLICATIONS.TEXT$
4350: 68b1:     ENDIF ELSE IF APPLICATION.SELECTED.COUNT% = 1 THEN BEGIN
4351: 68c0:         FIELD$(U0401.APPLICATION.STATUS%) = SINGLE.APPLICATION.TEXT$
4352: 68f4:     ENDIF ELSE IF \
4353: 68fc:         APPLICATION.SELECTED.COUNT% = APPLICATION.COUNT% THEN BEGIN
4354: 690d:         FIELD$(U0401.APPLICATION.STATUS%) = ALL.APPLICATIONS.TEXT$
4355: 6940:     ENDIF ELSE BEGIN
4356: 6948:         FIELD$(U0401.APPLICATION.STATUS%) = SELECTED.APPLICATIONS.TEXT$
4357: 6979:     ENDIF
4358: 6981: 
4359: 6981:     IF NOT FIELD$(U0401.TERMINAL%) = "*" THEN BEGIN
4360: 69b2:         FIELD$(U0401.TERMINAL.STATUS%) = SINGLE.TERMINAL.TEXT$
4361: 69e5:     ENDIF ELSE BEGIN
4362: 69ed:         FIELD$(U0401.TERMINAL.STATUS%) = ALL.TERMINALS.TEXT$
4363: 6a1e:     ENDIF
4364: 6a26: 
4365: 6a26:     IF NOT FIELD$(U0401.CONTROLLER.ID%) = "*" THEN BEGIN
4366: 6a57:         FIELD$(U0401.CONTROLLER.ID.STATUS%) = SINGLE.CONTROLLER.TEXT$
4367: 6a8a:     ENDIF ELSE BEGIN
4368: 6a92:         FIELD$(U0401.CONTROLLER.ID.STATUS%) = ALL.CONTROLLERS.TEXT$
4369: 6ac3:     ENDIF
4370: 6acb: 
4371: 6acb:     IF SEVERITY.SELECTED.COUNT% = 0 THEN BEGIN
4372: 6ada:         FIELD$(U0401.SEVERITY.STATUS%) = NO.SEVERITYS.TEXT$
4373: 6b0e:     ENDIF ELSE IF SEVERITY.SELECTED.COUNT% = 1 THEN BEGIN
4374: 6b1d:         FIELD$(U0401.SEVERITY.STATUS%) = SINGLE.SEVERITY.TEXT$
4375: 6b51:     ENDIF ELSE IF \
4376: 6b59:         SEVERITY.SELECTED.COUNT% = SEVERITY.COUNT% THEN BEGIN
4377: 6b6a:         FIELD$(U0401.SEVERITY.STATUS%) = ALL.SEVERITYS.TEXT$
4378: 6b9d:     ENDIF ELSE BEGIN
4379: 6ba5:         FIELD$(U0401.SEVERITY.STATUS%) = SELECTED.SEVERITYS.TEXT$
4380: 6bd6:     ENDIF
4381: 6bde: 
4382: 6bde:     IF BUCKET.SELECTED.COUNT% = 0 THEN BEGIN
4383: 6bed:         FIELD$(U0401.BUCKET.STATUS%) = NO.BUCKETS.TEXT$
4384: 6c21:     ENDIF ELSE IF BUCKET.SELECTED.COUNT% = 1 THEN BEGIN
4385: 6c30:         FIELD$(U0401.BUCKET.STATUS%) = SINGLE.BUCKET.TEXT$
4386: 6c64:     ENDIF ELSE IF \
4387: 6c6c:         BUCKET.SELECTED.COUNT% = BUCKET.COUNT% THEN BEGIN
4388: 6c7d:         FIELD$(U0401.BUCKET.STATUS%) = ALL.BUCKETS.TEXT$
4389: 6cb0:     ENDIF ELSE BEGIN
4390: 6cb8:         FIELD$(U0401.BUCKET.STATUS%) = SELECTED.BUCKETS.TEXT$
4391: 6ce9:     ENDIF
4392: 6cf1: 
4393: 6cf1:     IF SOURCE.SELECTED.COUNT% = 0 THEN BEGIN                            !BMW
4394: 6d00:         FIELD$(U0401.SOURCE.STATUS%) = NO.SOURCES.TEXT$                 !BMW
4395: 6d34:     ENDIF ELSE IF SOURCE.SELECTED.COUNT% = 1 THEN BEGIN                 !BMW
4396: 6d43:         FIELD$(U0401.SOURCE.STATUS%) = SINGLE.SOURCE.TEXT$              !BMW
4397: 6d77:     ENDIF ELSE IF \                                                     !BMW
4398: 6d7f:         SOURCE.SELECTED.COUNT% = SOURCE.COUNT% THEN BEGIN               !BMW
4399: 6d90:         FIELD$(U0401.SOURCE.STATUS%) = ALL.SOURCES.TEXT$                !BMW
4400: 6dc3:     ENDIF ELSE BEGIN                                                    !BMW
4401: 6dcb:         FIELD$(U0401.SOURCE.STATUS%) = SELECTED.SOURCES.TEXT$           !BMW
4402: 6dfc:     ENDIF                                                               !BMW
4403: 6e04:                                                                         !BMW
4404: 6e04:     IF NOT FIELD$(U0401.EVENT%) = "*" THEN BEGIN
4405: 6e35:         FIELD$(U0401.EVENT.STATUS%) = SINGLE.EVENT.TEXT$
4406: 6e68:     ENDIF ELSE BEGIN
4407: 6e70:         FIELD$(U0401.EVENT.STATUS%) = ALL.EVENTS.TEXT$
4408: 6ea1:     ENDIF
4409: 6ea9: 
4410: 6ea9:     IF NOT FIELD$(U0401.MESSAGE.GROUP%) = "*" THEN BEGIN
4411: 6eda:         FIELD$(U0401.MESSAGE.GROUP.STATUS%) =                       \
4412: 6f0d:             SINGLE.MESSAGE.GROUP.TEXT$
4413: 6f0d:     ENDIF ELSE BEGIN
4414: 6f15:         FIELD$(U0401.MESSAGE.GROUP.STATUS%) =                       \
4415: 6f46:             ALL.MESSAGE.GROUPS.TEXT$
4416: 6f46:     ENDIF
4417: 6f4e: 
4418: 6f4e:      IF NOT FIELD$(U0401.MESSAGE.NUMBER%) = "*" THEN BEGIN
4419: 6f7f:         FIELD$(U0401.MESSAGE.NUMBER.STATUS%) =                      \
4420: 6fb2:             SINGLE.MESSAGE.NUMBER.TEXT$
4421: 6fb2:     ENDIF ELSE BEGIN
4422: 6fba:         FIELD$(U0401.MESSAGE.NUMBER.STATUS%) =                      \
4423: 6feb:             ALL.MESSAGE.NUMBERS.TEXT$
4424: 6feb:     ENDIF
4425: 6ff3: 
4426: 6ff3:     RETURN
4427: 7003: 
4428: 7003: \***********************************************************************
4429: 7003: \***
4430: 7003: \***    VALIDATE.SELECTION.FIELDS
4431: 7003: \***
4432: 7003: \***********************************************************************
4433: 7003: VALIDATE.SELECTION.FIELDS:
4434: 7013: 
4435: 7013:     VALID.INPUT = FALSE
4436: 7029: 
4437: 7029:     ! IF log number is valid
4438: 7029:     IF IS.DIGITS(FIELD$(U0401.LOG.NUMBER%)) THEN BEGIN
4439: 705e: 
4440: 705e:         LOG.NUMBER$ = PAD$(STR$(VAL(FIELD$(U0401.LOG.NUMBER%))),2)
4441: 70b0:         LOG.FILE.NAME$ = EVLOG.FILE.NAME$ + LOG.NUMBER$
4442: 70da: 
4443: 70da:         IF NOT FILE.EXISTS(LOG.FILE.NAME$) THEN BEGIN
4444: 70f6: 
4445: 70f6:             ! B221 Invalid Log Number
4446: 70f6:             CALL DM.FOCUS("",                                       \
4447: 710e:             "MESSAGE(221,'Log Number file does not exist')")
4448: 710e: 
4449: 710e:             ! Move cursor to log number field
4450: 710e:             SELECTION.CURRENT.FIELD% = U0401.LOG.NUMBER%
4451: 7120: 
4452: 7120:             RETURN
4453: 7130: 
4454: 7130:         ENDIF
4455: 7138: 
4456: 7138:     ENDIF
4457: 7140: 
4458: 7140:     ! IF terminal number is NOT select all
4459: 7140:     IF NOT (FIELD$(U0401.TERMINAL%) = "*") THEN BEGIN
4460: 7174: 
4461: 7174:         ! IF terminal number is NOT numeric or null
4462: 7174:         IF NOT (IS.DIGITS(FIELD$(U0401.TERMINAL%)) OR               \
4463: 71dd:                (FIELD$(U0401.TERMINAL%) = "")) THEN BEGIN
4464: 71dd: 
4465: 71dd:             ! B221 Invalid Terminal
4466: 71dd:             CALL DM.FOCUS("",                                       \
4467: 71f5:             "MESSAGE(221,'Terminal must be numeric')")
4468: 71f5: 
4469: 71f5:             ! Move cursor to Terminal field
4470: 71f5:             SELECTION.CURRENT.FIELD% = U0401.TERMINAL%
4471: 7207: 
4472: 7207:             RETURN
4473: 7217: 
4474: 7217:         ENDIF
4475: 721f: 
4476: 721f:         ! IF terminal number not in range
4477: 721f:         IF NOT ((FIELD$(U0401.TERMINAL%) = "") OR                   \
4478: 7302:                (VAL(FIELD$(U0401.TERMINAL%)) >= 1 AND               \
4479: 7302:                 VAL(FIELD$(U0401.TERMINAL%)) <= 999)) THEN BEGIN
4480: 7302: 
4481: 7302:             ! B221 Invalid Terminal
4482: 7302:             CALL DM.FOCUS("",                                       \
4483: 731a:             "MESSAGE(221,'Terminal must be in the range 1-999')")       !BMW
4484: 731a: 
4485: 731a:             ! Move cursor to Terminal field
4486: 731a:             SELECTION.CURRENT.FIELD% = U0401.TERMINAL%
4487: 732c: 
4488: 732c:             RETURN
4489: 733c: 
4490: 733c:         ENDIF
4491: 7344: 
4492: 7344:     ENDIF
4493: 734c: 
4494: 734c:     ! IF controller ID is NOT select all
4495: 734c:     IF NOT (FIELD$(U0401.CONTROLLER.ID%) = "*") THEN BEGIN
4496: 7380: 
4497: 7380:         ! IF controller ID is numeric
4498: 7380:         IF IS.DIGITS(FIELD$(U0401.CONTROLLER.ID%)) THEN BEGIN
4499: 73b2: 
4500: 73b2:             ! B221 Invalid Controller
4501: 73b2:             CALL DM.FOCUS("",                                       \
4502: 73ca:             "MESSAGE(221,'Controller ID cannot be numeric')")
4503: 73ca: 
4504: 73ca:             ! Move cursor to Controller ID field
4505: 73ca:             SELECTION.CURRENT.FIELD% = U0401.CONTROLLER.ID%
4506: 73dc: 
4507: 73dc:             RETURN
4508: 73ec: 
4509: 73ec:         ENDIF
4510: 73f4: 
4511: 73f4:         IF NOT (((FIELD$(U0401.CONTROLLER.ID%) = "") OR             \
4512: 74a5:                  (FIELD$(U0401.CONTROLLER.ID%) >= "CE" AND          \   !BMW
4513: 74a5:                   FIELD$(U0401.CONTROLLER.ID%) <= "CF"))) THEN BEGIN    !BMW
4514: 74a5: 
4515: 74a5:             ! B221 Invalid Controller ID
4516: 74a5:             CALL DM.FOCUS("",                                       \
4517: 74bd:             "MESSAGE(221,'Controller ID must be CE or CF')")            !BMW
4518: 74bd: 
4519: 74bd:             ! Move cursor to Controller ID field
4520: 74bd:             SELECTION.CURRENT.FIELD% = U0401.CONTROLLER.ID%
4521: 74cf: 
4522: 74cf:             RETURN
4523: 74df: 
4524: 74df:         ENDIF
4525: 74e7: 
4526: 74e7:     ENDIF
4527: 74ef: 
4528: 74ef:     ! IF severity is NOT select all OR
4529: 74ef:     !                    selected severitys OR
4530: 74ef:     !                    excluded severitys
4531: 74ef:     IF NOT (FIELD$(U0401.SEVERITY%) = "*" OR                        \
4532: 75a5:             FIELD$(U0401.SEVERITY%) = "+" OR                        \
4533: 75a5:             FIELD$(U0401.SEVERITY%) = "-") THEN BEGIN
4534: 75a5: 
4535: 75a5:         ! IF severity is NOT numeric or null
4536: 75a5:         IF NOT (IS.DIGITS(FIELD$(U0401.SEVERITY%)) OR               \
4537: 760e:                (FIELD$(U0401.SEVERITY%) = "")) THEN BEGIN
4538: 760e: 
4539: 760e:             ! B221 Invalid Severity
4540: 760e:             CALL DM.FOCUS("",                                       \
4541: 7626:             "MESSAGE(221,'Severity must be numeric')")
4542: 7626: 
4543: 7626:             ! Move cursor to Severity field
4544: 7626:             SELECTION.CURRENT.FIELD% = U0401.SEVERITY%
4545: 7638: 
4546: 7638:             RETURN
4547: 7648: 
4548: 7648:         ENDIF
4549: 7650: 
4550: 7650:         IF NOT ((FIELD$(U0401.SEVERITY%) = "") OR                   \
4551: 7733:             (VAL(FIELD$(U0401.SEVERITY%)) >= 0 AND                  \
4552: 7733:             VAL(FIELD$(U0401.SEVERITY%)) <= 5)) THEN BEGIN
4553: 7733: 
4554: 7733:             ! B221 Invalid Severity
4555: 7733:             CALL DM.FOCUS("",                                       \
4556: 774b:             "MESSAGE(221,'Severity must be in the range 1-5 or 0')")
4557: 774b: 
4558: 774b:             ! Move cursor to Severity field
4559: 774b:             SELECTION.CURRENT.FIELD% = U0401.SEVERITY%
4560: 775d: 
4561: 775d:             RETURN
4562: 776d: 
4563: 776d:         ENDIF
4564: 7775: 
4565: 7775:     ENDIF
4566: 777d: 
4567: 777d:     ! IF bucket is NOT select all
4568: 777d:     !                  selected buckets OR
4569: 777d:     !                  excluded buckets
4570: 777d:     IF NOT (FIELD$(U0401.BUCKET%) = "*" OR                          \
4571: 7833:             FIELD$(U0401.BUCKET%) = "+" OR                          \
4572: 7833:             FIELD$(U0401.BUCKET%) = "-") THEN BEGIN
4573: 7833: 
4574: 7833:         ! IF bucket is NOT numeric or null
4575: 7833:         IF NOT (IS.DIGITS(FIELD$(U0401.BUCKET%)) OR                 \
4576: 789c:                (FIELD$(U0401.BUCKET%) = "")) THEN BEGIN
4577: 789c: 
4578: 789c:             ! B221 Invalid Bucket
4579: 789c:             CALL DM.FOCUS("",                                       \
4580: 78b4:             "MESSAGE(221,'Bucket must be numeric')")
4581: 78b4: 
4582: 78b4:             ! Move cursor to Bucket field
4583: 78b4:             SELECTION.CURRENT.FIELD% = U0401.BUCKET%
4584: 78c6: 
4585: 78c6:             RETURN
4586: 78d6: 
4587: 78d6:         ENDIF
4588: 78de: 
4589: 78de:         IF NOT ((FIELD$(U0401.BUCKET%) = "") OR                     \
4590: 79c1:             (VAL(FIELD$(U0401.BUCKET%)) >= 0 AND                    \
4591: 79c1:              VAL(FIELD$(U0401.BUCKET%)) <= 6)) THEN BEGIN
4592: 79c1: 
4593: 79c1:             ! B221 Invalid Bucket
4594: 79c1:             CALL DM.FOCUS("",                                       \
4595: 79d9:             "MESSAGE(221,'Bucket must be in the range 1-6 or 0')")
4596: 79d9: 
4597: 79d9:             ! Move cursor to Bucket field
4598: 79d9:             SELECTION.CURRENT.FIELD% = U0401.BUCKET%
4599: 79eb: 
4600: 79eb:             RETURN
4601: 79fb: 
4602: 79fb:         ENDIF
4603: 7a03: 
4604: 7a03:     ENDIF
4605: 7a0b: 
4606: 7a0b:     ! IF source is NOT select all                                       !BMW
4607: 7a0b:     !                  selected sources OR                              !BMW
4608: 7a0b:     !                  excluded sources                                 !BMW
4609: 7a0b:     IF NOT (FIELD$(U0401.SOURCE%) = "*" OR                          \   !BMW
4610: 7ac1:             FIELD$(U0401.SOURCE%) = "+" OR                          \   !BMW
4611: 7ac1:             FIELD$(U0401.SOURCE%) = "-") THEN BEGIN                     !BMW
4612: 7ac1: 
4613: 7ac1:         ! IF source is NOT numeric or null
4614: 7ac1:         IF NOT (IS.DIGITS(FIELD$(U0401.SOURCE%)) OR                 \
4615: 7b2a:                (FIELD$(U0401.SOURCE%) = "")) THEN BEGIN
4616: 7b2a: 
4617: 7b2a:             ! B221 Invalid Source
4618: 7b2a:             CALL DM.FOCUS("",                                       \
4619: 7b42:             "MESSAGE(221,'Source must be numeric')")
4620: 7b42: 
4621: 7b42:             ! Move cursor to Source field
4622: 7b42:             SELECTION.CURRENT.FIELD% = U0401.SOURCE%
4623: 7b54: 
4624: 7b54:             RETURN
4625: 7b64: 
4626: 7b64:         ENDIF
4627: 7b6c: 
4628: 7b6c:         ! IF source not in range
4629: 7b6c:         IF NOT ((FIELD$(U0401.SOURCE%) = "") OR                     \
4630: 7c4f:                (VAL(FIELD$(U0401.SOURCE%)) >= 0 AND                 \   !BMW
4631: 7c4f:                 VAL(FIELD$(U0401.SOURCE%)) <= 255)) THEN BEGIN
4632: 7c4f: 
4633: 7c4f:             ! B221 Invalid Source
4634: 7c4f:             CALL DM.FOCUS("",                                       \
4635: 7c67:             "MESSAGE(221,'Source must be in the range 1-255 or 0')")    !BMW
4636: 7c67: 
4637: 7c67:             ! Move cursor to Source field
4638: 7c67:             SELECTION.CURRENT.FIELD% = U0401.SOURCE%
4639: 7c79: 
4640: 7c79:             RETURN
4641: 7c89: 
4642: 7c89:         ENDIF
4643: 7c91: 
4644: 7c91:     ENDIF
4645: 7c99: 
4646: 7c99:     ! IF event number is NOT select all
4647: 7c99:     IF NOT (FIELD$(U0401.EVENT%) = "*") THEN BEGIN
4648: 7ccd: 
4649: 7ccd:         ! IF event number is NOT numeric or null
4650: 7ccd:         IF NOT (IS.DIGITS(FIELD$(U0401.EVENT%)) OR                  \
4651: 7d36:                (FIELD$(U0401.EVENT%) = "")) THEN BEGIN
4652: 7d36: 
4653: 7d36:             ! B221 Invalid Event Number
4654: 7d36:             CALL DM.FOCUS("",                                       \
4655: 7d4e:             "MESSAGE(221,'Event Number must be numeric')")
4656: 7d4e: 
4657: 7d4e:             ! Move cursor to event number field
4658: 7d4e:             SELECTION.CURRENT.FIELD% = U0401.EVENT%
4659: 7d60: 
4660: 7d60:             RETURN
4661: 7d70: 
4662: 7d70:         ENDIF
4663: 7d78: 
4664: 7d78:         ! IF event number not in range
4665: 7d78:         IF NOT ((FIELD$(U0401.EVENT%) = "") OR                      \
4666: 7e5b:                (VAL(FIELD$(U0401.EVENT%)) >= 1 AND                  \
4667: 7e5b:                 VAL(FIELD$(U0401.EVENT%)) <= 999)) THEN BEGIN
4668: 7e5b: 
4669: 7e5b:             ! B221 Invalid Event Number
4670: 7e5b:             CALL DM.FOCUS("",                                       \
4671: 7e73:             "MESSAGE(221,'Event Number must be in the range 1-999')")   !BMW
4672: 7e73: 
4673: 7e73:             ! Move cursor to event number field
4674: 7e73:             SELECTION.CURRENT.FIELD% = U0401.EVENT%
4675: 7e85: 
4676: 7e85:             RETURN
4677: 7e95: 
4678: 7e95:         ENDIF
4679: 7e9d: 
4680: 7e9d:     ENDIF
4681: 7ea5: 
4682: 7ea5:     ! IF message group is NOT select all
4683: 7ea5:     IF NOT (FIELD$(U0401.MESSAGE.GROUP%) = "*") THEN BEGIN
4684: 7ed9: 
4685: 7ed9:         ! IF message group is numeric
4686: 7ed9:         IF IS.DIGITS(FIELD$(U0401.MESSAGE.GROUP%)) THEN BEGIN
4687: 7f0b: 
4688: 7f0b:             ! B221 Invalid Message Group
4689: 7f0b:             CALL DM.FOCUS("",                                       \
4690: 7f23:             "MESSAGE(221,'Message Group cannot be numeric')")
4691: 7f23: 
4692: 7f23:             ! Move cursor to Message Group field
4693: 7f23:             SELECTION.CURRENT.FIELD% = U0401.MESSAGE.GROUP%
4694: 7f35: 
4695: 7f35:             RETURN
4696: 7f45: 
4697: 7f45:         ENDIF
4698: 7f4d: 
4699: 7f4d:         IF NOT (((FIELD$(U0401.MESSAGE.GROUP%) = "") OR             \
4700: 7ffe:                  (FIELD$(U0401.MESSAGE.GROUP%) >= "A" AND           \
4701: 7ffe:                   FIELD$(U0401.MESSAGE.GROUP%) <= "Z"))) THEN BEGIN
4702: 7ffe: 
4703: 7ffe:             ! B221 Invalid Message Group
4704: 7ffe:             CALL DM.FOCUS("",                                       \
4705: 8016:             "MESSAGE(221,'Message Group must be in the range A-Z')")    !BMW
4706: 8016: 
4707: 8016:             ! Move cursor to Message Group field
4708: 8016:             SELECTION.CURRENT.FIELD% = U0401.MESSAGE.GROUP%
4709: 8028: 
4710: 8028:             RETURN
4711: 8038: 
4712: 8038:         ENDIF
4713: 8040: 
4714: 8040:     ENDIF
4715: 8048: 
4716: 8048:     ! IF message number is NOT select all
4717: 8048:     IF NOT (FIELD$(U0401.MESSAGE.NUMBER%) = "*") THEN BEGIN
4718: 807c: 
4719: 807c:         ! IF message number is NOT numeric or null
4720: 807c:         IF NOT (IS.DIGITS(FIELD$(U0401.MESSAGE.NUMBER%)) OR         \
4721: 80e5:                (FIELD$(U0401.MESSAGE.NUMBER%) = "")) THEN BEGIN
4722: 80e5: 
4723: 80e5:             ! B221 Invalid Message Number
4724: 80e5:             CALL DM.FOCUS("",                                       \
4725: 80fd:             "MESSAGE(221,'Message Number must be numeric')")
4726: 80fd: 
4727: 80fd:             ! Move cursor to message number field
4728: 80fd:             SELECTION.CURRENT.FIELD% = U0401.MESSAGE.NUMBER%
4729: 810f: 
4730: 810f:             RETURN
4731: 811f: 
4732: 811f:         ENDIF
4733: 8127: 
4734: 8127:         ! IF message number not in range
4735: 8127:         IF NOT ((FIELD$(U0401.MESSAGE.NUMBER%) = "") OR             \
4736: 820a:                (VAL(FIELD$(U0401.MESSAGE.NUMBER%)) >= 1 AND         \
4737: 820a:                 VAL(FIELD$(U0401.MESSAGE.NUMBER%)) <= 999)) THEN BEGIN
4738: 820a: 
4739: 820a:             ! B221 Invalid Message Number
4740: 820a:             CALL DM.FOCUS("",                                       \
4741: 8222:             "MESSAGE(221,'Message Number must be in the range 1-999')") !BMW
4742: 8222: 
4743: 8222:             ! Move cursor to message number field
4744: 8222:             SELECTION.CURRENT.FIELD% = U0401.MESSAGE.NUMBER%
4745: 8234: 
4746: 8234:             RETURN
4747: 8244: 
4748: 8244:         ENDIF
4749: 824c: 
4750: 824c:     ENDIF
4751: 8254: 
4752: 8254:     VALID.INPUT = TRUE
4753: 826a: 
4754: 826a:     RETURN
4755: 827a: 
4756: 827a: \***********************************************************************
4757: 827a: \***
4758: 827a: \***    INITIALISE.SELECTION.SCREEN
4759: 827a: \***
4760: 827a: \***********************************************************************
4761: 827a: INITIALISE.SELECTION.SCREEN:
4762: 828a: 
4763: 828a:     ! Display selection DM screen
4764: 828a:     CALL DM.SHOW.SCREEN(1,"",1,1)
4765: 82a4: 
4766: 82a4:     SELECTION.START.FIELD% = U0401.LOG.NUMBER%
4767: 82b7:     SELECTION.END.FIELD%   = U0401.MESSAGE.NUMBER.STATUS%
4768: 82ca: 
4769: 82ca:     FOR I% = SELECTION.START.FIELD% TO SELECTION.END.FIELD%
4770: 82da:         FIELD$(I%) = SELECTION.FIELD$(I%)
4771: 8311:     NEXT I%
4772: 8329: 
4773: 8329:     ! Log description field (output only)
4774: 8329:     FIELD$(U0401.LOG.DESC%) = MID$(FILE.RECORD$(FILE.INDEX%),10,45)     !BMW
4775: 836e: 
4776: 836e:     SELECTION.EXIT.PRESSED = FALSE
4777: 8380: 
4778: 8380:     RETURN
4779: 8390: 
4780: 8390: \***********************************************************************
4781: 8390: \***
4782: 8390: \***    PROCESS.FILES.SCREEN
4783: 8390: \***
4784: 8390: \***********************************************************************
4785: 8390: PROCESS.FILES.SCREEN:
4786: 83a0: 
4787: 83a0:     FILE.PAGE% = 1                                                      !BMW
4788: 83ae: 
4789: 83ae:     GOSUB INITIALISE.FILE.SCREEN
4790: 83c0: 
4791: 83c0:     CURRENT.FIELD% = FILE.START.FIELD%                                  !BMW
4792: 83d2: 
4793: 83d2:     WHILE NOT FILE.EXIT.PRESSED                                         !BMW
4794: 83dd: 
4795: 83dd:         CALL DM.CURRENT.FIELD(CURRENT.FIELD%)
4796: 83f5: 
4797: 83f5:         GOSUB DISPLAY.FILE.PAGE
4798: 8407: 
4799: 8407:         KEY% = DM.PROCESS.SCREEN(FILE.START.FIELD%,                 \   !BMW
4800: 842f:                                  FILE.LAST.FIELD%,                  \   !BMW
4801: 842f:                                  TRUE) ! Quit confirm
4802: 842f: 
4803: 842f:         ! IF quit key                                                   !HMW
4804: 842f:         IF KEY% = F3.KEY% THEN BEGIN
4805: 8447: 
4806: 8447:             FILE.EXIT.PRESSED = TRUE                                    !BMW
4807: 8459: 
4808: 8459:             GOSUB INITIALISE.SELECTION.SCREEN
4809: 846e: 
4810: 846e:         ! IF escape key                                                 !HMW
4811: 846e:         ENDIF ELSE IF KEY% = ESC.KEY% THEN BEGIN
4812: 8486: 
4813: 8486:             FILE.EXIT.PRESSED = TRUE                                    !BMW
4814: 8498: 
4815: 8498:             GOSUB INITIALISE.SELECTION.SCREEN
4816: 84ad: 
4817: 84ad:         ! IF cursor up                                                  !HMW
4818: 84ad:         ENDIF ELSE IF KEY% = PREV.KEY% THEN BEGIN
4819: 84c5: 
4820: 84c5:             IF FILE.PAGE% > 1 THEN BEGIN                                !BMW
4821: 84d4:                 ! Move to the last row on the previous page
4822: 84d4:                 CURRENT.FIELD% = FILES.PER.PAGE% + 2
4823: 84ed:                 FILE.PAGE% = FILE.PAGE% - 1                             !BMW
4824: 84fb:             ENDIF ELSE BEGIN
4825: 8503:                 ! No previous page exists
4826: 8503:                 CALL DM.FOCUS("","MESSAGE(74,'')")
4827: 851b:                 CURRENT.FIELD% = FILE.START.FIELD%                      !BMW
4828: 852d:             ENDIF
4829: 8538: 
4830: 8538:         ! IF cursor down                                                !HMW
4831: 8538:         ENDIF ELSE IF KEY% = NEXT.KEY% THEN BEGIN
4832: 8550: 
4833: 8550:             ! IF this is not the last page
4834: 8550:             IF FILE.PAGE% < FILE.TOTAL.PAGES% THEN BEGIN                !BMW
4835: 8561:                 ! Move to the first row on the next page
4836: 8561:                 CURRENT.FIELD% = 3 ! First input field
4837: 8571:                 FILE.PAGE% = FILE.PAGE% + 1                             !BMW
4838: 857f:             ENDIF ELSE BEGIN
4839: 8587:                 ! No next page exists
4840: 8587:                 CALL DM.FOCUS("","MESSAGE(75,'')")
4841: 859f:                 CURRENT.FIELD% = FILE.LAST.FIELD%                       !BMW
4842: 85b1:             ENDIF
4843: 85bc: 
4844: 85bc:         ! IF page up                                                    !HMW
4845: 85bc:         ENDIF ELSE IF KEY% = F7.KEY% OR                             \
4846: 85f0:                       KEY% = PGUP.KEY% THEN BEGIN
4847: 85f0: 
4848: 85f0:             IF FILE.PAGE% = 1 THEN BEGIN                                !BMW
4849: 85ff: 
4850: 85ff:                 ! No previous page exists
4851: 85ff:                 CALL DM.FOCUS("","MESSAGE(74,'')")
4852: 8619: 
4853: 8619:             ENDIF ELSE BEGIN
4854: 8621:                 FILE.PAGE% = FILE.PAGE% - 1                             !BMW
4855: 862d:                 CURRENT.FIELD% = FILE.START.FIELD%                      !BMW
4856: 863f:             ENDIF
4857: 864a: 
4858: 864a:         ! IF page down                                                  !HMW
4859: 864a:         ENDIF ELSE IF KEY% = F8.KEY% OR                             \
4860: 867e:                       KEY% = PGDN.KEY% THEN BEGIN
4861: 867e: 
4862: 867e:             IF FILE.PAGE% = FILE.TOTAL.PAGES% THEN BEGIN                !BMW
4863: 868f: 
4864: 868f:                 ! No next page exists
4865: 868f:                 CALL DM.FOCUS("","MESSAGE(75,'')")
4866: 86a9: 
4867: 86a9:             ENDIF ELSE BEGIN
4868: 86b1:                 FILE.PAGE% = FILE.PAGE% + 1                             !BMW
4869: 86bd:                 CURRENT.FIELD% = FILE.START.FIELD%                      !BMW
4870: 86cf:             ENDIF
4871: 86da: 
4872: 86da:         ! IF enter key                                                  !HMW
4873: 86da:         ENDIF ELSE IF KEY% = ENTER.KEY% THEN BEGIN
4874: 86f5: 
4875: 86f5:             ! Save position of selected file record
4876: 86f5:             CURRENT.FIELD% = DM.CURRENT.FIELD(0)
4877: 870d: 
4878: 870d:             ! Get log file number
4879: 870d:             FILE.INDEX% = ((FILE.PAGE% - 1) * FILES.PER.PAGE%) +    \   !BMW
4880: 8734:                           (CURRENT.FIELD% - 3) + 1                      !BMW
4881: 8734: 
4882: 8734:             LOG.NUMBER$ =                                           \
4883: 8780:                 STR$(VAL(MID$(FILE.RECORD$(FILE.INDEX%),7,2)))          !BMW
4884: 8780: 
4885: 8780:             SELECTION.FIELD$(U0401.LOG.NUMBER%) = LOG.NUMBER$
4886: 87ae: 
4887: 87ae:             FILE.EXIT.PRESSED = TRUE                                    !BMW
4888: 87c0: 
4889: 87c0:             GOSUB INITIALISE.SELECTION.SCREEN
4890: 87d2: 
4891: 87d2:             CALL DM.CHANGED.FLAG(TRUE)
4892: 87ec: 
4893: 87ec:         ENDIF ELSE BEGIN
4894: 87f4: 
4895: 87f4:             ! B001 Invalid key pressed
4896: 87f4:             CALL DM.FOCUS("", "MESSAGE(1,'')")
4897: 880c: 
4898: 880c:         ENDIF
4899: 8814: 
4900: 8814:     WEND
4901: 8826: 
4902: 8826:     RETURN
4903: 8836: 
4904: 8836: \***********************************************************************
4905: 8836: \***
4906: 8836: \***    INITIALISE.FILE.SCREEN
4907: 8836: \***
4908: 8836: \***********************************************************************
4909: 8836: INITIALISE.FILE.SCREEN:
4910: 8846: 
4911: 8846:     ! Display file DM screen
4912: 8846:     CALL DM.SHOW.SCREEN(4,"",4,4)
4913: 8860: 
4914: 8860:     FILE.START.FIELD% = 3                                               !BMW
4915: 886e:     FILE.END.FIELD%   = 20                                              !BMW
4916: 887c: 
4917: 887c:     FILE.EXIT.PRESSED = FALSE                                           !BMW
4918: 888e: 
4919: 888e:     RETURN
4920: 889e: 
4921: 889e: \***********************************************************************
4922: 889e: \***
4923: 889e: \***    DISPLAY.FILE.PAGE
4924: 889e: \***
4925: 889e: \***********************************************************************
4926: 889e: DISPLAY.FILE.PAGE:
4927: 88ae: 
4928: 88ae:     ! IF first page
4929: 88ae:     IF FILE.PAGE% = 1 THEN BEGIN                                        !BMW
4930: 88bd:         ! Hide page up function key
4931: 88bd:         CALL DM.HIDE.FN.KEY(7)
4932: 88d0:     ENDIF ELSE BEGIN
4933: 88d8:         ! Display page up function key
4934: 88d8:         CALL DM.SHOW.FN.KEY(7,"PGUP")
4935: 88ee:     ENDIF
4936: 88f6: 
4937: 88f6:     ! IF last page
4938: 88f6:     IF FILE.PAGE% = FILE.TOTAL.PAGES% THEN BEGIN                        !BMW
4939: 8907: 
4940: 8907:         ! Hide page down function key
4941: 8907:         CALL DM.HIDE.FN.KEY(8)
4942: 8918: 
4943: 8918:         FILE.LAST.FIELD% = FILE.LAST.PAGE% + 2                          !BMW
4944: 8929: 
4945: 8929:         ! For the last page, set results per page to the remainder
4946: 8929:         FILE.THIS.PAGE% = FILE.LAST.PAGE%                               !BMW
4947: 8939: 
4948: 8939:     ENDIF ELSE BEGIN
4949: 8941: 
4950: 8941:         ! Display page down function key
4951: 8941:         CALL DM.SHOW.FN.KEY(8,"PGDN")
4952: 8957: 
4953: 8957:         FILE.LAST.FIELD% = FILE.END.FIELD%                              !BMW
4954: 8965: 
4955: 8965:         ! Set files per page to
4956: 8965:         ! the maximum files allowed per page
4957: 8965:         FILE.THIS.PAGE% = FILES.PER.PAGE%                               !BMW
4958: 8977: 
4959: 8977:     ENDIF
4960: 897f: 
4961: 897f:     FOR I% = 1 TO FILE.THIS.PAGE%                                       !BMW
4962: 8990: 
4963: 8990:         FIELD.INDEX% = I% + 2
4964: 89a1: 
4965: 89a1:         FILE.INDEX% = ((FILE.PAGE% - 1) * FILES.PER.PAGE%) + I%         !BMW
4966: 89bb: 
4967: 89bb:         FIELD$(FIELD.INDEX%) =                                      \
4968: 89fb:             MID$(FILE.RECORD$(FILE.INDEX%),10,45)                       !BMW
4969: 89fb: 
4970: 89fb:         CALL DM.VISIBLE(STR$(FIELD.INDEX%),"TRUE")
4971: 8a28: 
4972: 8a28:         CALL DM.RO.FIELD(FIELD.INDEX%)
4973: 8a3b: 
4974: 8a3b:     NEXT I%
4975: 8a56: 
4976: 8a56:     FIELD$(U0402.PAGE%) =                                           \
4977: 8adf:         RIGHT$((STRING$(7," ") +                                    \
4978: 8adf:         "Page " + STR$(FILE.PAGE%) +                                \   !BMW
4979: 8adf:         " of "  + STR$(FILE.TOTAL.PAGES%)),18)                          !BMW
4980: 8adf: 
4981: 8adf:     ! IF files per page is not a full page
4982: 8adf:     IF FILE.THIS.PAGE% < FILES.PER.PAGE% THEN BEGIN                     !BMW
4983: 8af7: 
4984: 8af7:         ! For each remaining row
4985: 8af7:         FOR I% = (FILE.THIS.PAGE% + 1) TO FILES.PER.PAGE%               !BMW
4986: 8b08: 
4987: 8b08:             FIELD.INDEX% = I% + 2
4988: 8b19: 
4989: 8b19:             ! Clear the row
4990: 8b19:             FIELD$(FIELD.INDEX%) = STRING$(80," ")
4991: 8b45: 
4992: 8b45:             ! Hide the field
4993: 8b45:             CALL DM.VISIBLE(STR$(FIELD.INDEX%),"FALSE")
4994: 8b72: 
4995: 8b72:         NEXT I%
4996: 8b91: 
4997: 8b91:     ENDIF
4998: 8b99: 
4999: 8b99:     RETURN
5000: 8ba9: 
5001: 8ba9: \***********************************************************************
5002: 8ba9: \***
5003: 8ba9: \***    GET.FILE.RESULTS
5004: 8ba9: \***
5005: 8ba9: \***********************************************************************
5006: 8ba9: \***
5007: 8ba9: \***    Search for event log files and build a table of available
5008: 8ba9: \***    event log files for displaying on the file selection screen.
5009: 8ba9: \***
5010: 8ba9: \***********************************************************************
5011: 8ba9: GET.FILE.RESULTS:
5012: 8bb9: 
5013: 8bb9:     FILE.INDEX% = 1 ! Default to current event log                      !BMW
5014: 8bc7: 
5015: 8bc7:     DIM FILE.RECORD$(MAX.FILE.RECORDS%)
5016: 8bf5:     DIM FILE.MAP%(MAX.FILE.RECORDS%)                                    !BMW
5017: 8c23: 
5018: 8c23:     J% = 0
5019: 8c31: 
5020: 8c31:     FOR I% = 0 TO (MAX.FILE.RECORDS% - 1)                               !BMW
5021: 8c42: 
5022: 8c42:         LOG.FILE.NAME$ = EVLOG.FILE.NAME$ + PAD$(STR$(I%),2)
5023: 8c7e: 
5024: 8c7e:         ! Initialise index to high values                               !BMW
5025: 8c7e:         FILE.MAP%(I%) = NULL.MAPPING%                                   !BMW
5026: 8ca5:         
5027: 8ca5:         IF FILE.EXISTS(LOG.FILE.NAME$) THEN BEGIN
5028: 8cc4: 
5029: 8cc4:             ! Get event log file size
5030: 8cc4:             LOG.FILE.SIZE% = SIZE(LOG.FILE.NAME$)
5031: 8ce6: 
5032: 8ce6:             ! Calculate record position of the last record
5033: 8ce6:             LAST.RECORD.NUMBER% =                                   \
5034: 8d1d:                 INT(LOG.FILE.SIZE% / EVLOG.RECL%)
5035: 8d1d: 
5036: 8d1d:             EVENT.RECORD$ = ""
5037: 8d32: 
5038: 8d32:             ! IF event log file is not empty
5039: 8d32:             IF LAST.RECORD.NUMBER% > 0 THEN BEGIN
5040: 8d44: 
5041: 8d44:                 ! IF first event log file
5042: 8d44:                 IF NOT FILE.FOUND THEN BEGIN
5043: 8d53:                     FIRST.LOG% = I%
5044: 8d61:                     FILE.FOUND = TRUE
5045: 8d73:                 ENDIF
5046: 8d7b: 
5047: 8d7b:                 J% = J% + 1
5048: 8d87: 
5049: 8d87:                 FILE.RECORD$(J%) = LOG.FILE.NAME$
5050: 8dad:                 FILE.MAP%(I%) = J%                                      !BMW
5051: 8dca: 
5052: 8dca:                 OPEN LOG.FILE.NAME$ DIRECT RECL EVLOG.RECL% \
5053: 8df4:                     AS EVLOG.SESS.NUM% NOWRITE NODEL
5054: 8df4: 
5055: 8df4:                 EVLOG.RECORD.NUMBER% = 1
5056: 8e0b: 
5057: 8e0b:                 ! Read first event from event log file
5058: 8e0b:                 EVLOG.RC% = READ.EVLOG
5059: 8e1b: 
5060: 8e1b:                 EVENT.DATE% = GETN2(EVLOG.RECORD$,0)
5061: 8e46:                 EVENT.TIME% = GETN2(EVLOG.RECORD$,2)
5062: 8e71: 
5063: 8e71:                 EVENT.DAY%   = EVENT.DATE% AND 0001FH
5064: 8e9a:                 EVENT.MONTH% = SHIFT(EVENT.DATE% AND 001E0H,5)
5065: 8ecc:                 EVENT.YEAR%  =                                      \
5066: 8f09:                     SHIFT(EVENT.DATE% AND 0FE00H,9) + 1980
5067: 8f09: 
5068: 8f09:                 EVENT.HOUR% = SHIFT(EVENT.TIME% AND 0F800H,11)
5069: 8f3b:                 EVENT.MIN%  = SHIFT(EVENT.TIME% AND 007E0H,5)
5070: 8f6d: 
5071: 8f6d:                 LOG.FILE.DAY$   = PAD$(STR$(EVENT.DAY%),2)
5072: 8f9f:                 LOG.FILE.MONTH$ = PAD$(STR$(EVENT.MONTH%),2)
5073: 8fd1:                 LOG.FILE.YEAR$  = RIGHT$(STR$(EVENT.YEAR%),2)
5074: 9003:                 LOG.FILE.DATE$  = LOG.FILE.YEAR$ +                  \
5075: 902f:                                   LOG.FILE.MONTH$ +                 \
5076: 902f:                                   LOG.FILE.DAY$
5077: 902f: 
5078: 902f:                 LOG.FILE.DOW$ = DOW$(DAY.OF.WEEK(LOG.FILE.DATE$))
5079: 9067: 
5080: 9067:                 LOG.FILE.TIME$ =                                    \
5081: 90cc:                     PAD$(STR$(EVENT.HOUR%),2) + ":" +               \
5082: 90cc:                     PAD$(STR$(EVENT.MIN%),2)
5083: 90cc: 
5084: 90cc:                 FILE.RECORD$(J%) = FILE.RECORD$(J%) + " " +         \
5085: 913f:                                    LOG.FILE.DOW$ + " " +            \
5086: 913f:                                    LOG.FILE.DAY$ + "/" +            \
5087: 913f:                                    LOG.FILE.MONTH$ + "/" +          \
5088: 913f:                                    LOG.FILE.YEAR$ + " " +           \
5089: 913f:                                    LOG.FILE.TIME$
5090: 913f: 
5091: 913f:                 IF I% = 0 THEN BEGIN
5092: 914e: 
5093: 914e:                     FILE.RECORD$(J%) = FILE.RECORD$(J%) +           \
5094: 918c:                                        " to Current"
5095: 918c: 
5096: 918c:                 ENDIF ELSE BEGIN
5097: 9194: 
5098: 9194:                     EVLOG.RECORD.NUMBER% = LAST.RECORD.NUMBER%
5099: 91ad: 
5100: 91ad:                     ! Read last event from event log file
5101: 91ad:                     EVLOG.RC% = READ.EVLOG
5102: 91bd: 
5103: 91bd:                     EVENT.DATE% = GETN2(EVLOG.RECORD$,0)
5104: 91e8:                     EVENT.TIME% = GETN2(EVLOG.RECORD$,2)
5105: 9213: 
5106: 9213:                     EVENT.DAY%   = EVENT.DATE% AND 0001FH
5107: 923c:                     EVENT.MONTH% = SHIFT(EVENT.DATE% AND 001E0H,5)
5108: 926e:                     EVENT.YEAR%  =                                  \
5109: 92ab:                         SHIFT(EVENT.DATE% AND 0FE00H,9) + 1980
5110: 92ab: 
5111: 92ab:                     EVENT.HOUR% = SHIFT(EVENT.TIME% AND 0F800H,11)
5112: 92dd:                     EVENT.MIN%  = SHIFT(EVENT.TIME% AND 007E0H,5)
5113: 930f: 
5114: 930f:                     LOG.FILE.DAY$   = PAD$(STR$(EVENT.DAY%),2)
5115: 9341:                     LOG.FILE.MONTH$ = PAD$(STR$(EVENT.MONTH%),2)
5116: 9373:                     LOG.FILE.YEAR$  = RIGHT$(STR$(EVENT.YEAR%),2)
5117: 93a5:                     LOG.FILE.DATE$  = LOG.FILE.YEAR$ +              \
5118: 93d1:                                       LOG.FILE.MONTH$ +             \
5119: 93d1:                                       LOG.FILE.DAY$
5120: 93d1: 
5121: 93d1:                     LOG.FILE.DOW$ =                                 \
5122: 9409:                         DOW$(DAY.OF.WEEK(LOG.FILE.DATE$))
5123: 9409: 
5124: 9409:                     LOG.FILE.TIME$ =                                \
5125: 946e:                         PAD$(STR$(EVENT.HOUR%),2) + ":" +           \
5126: 946e:                         PAD$(STR$(EVENT.MIN%),2)
5127: 946e: 
5128: 946e:                     FILE.RECORD$(J%) = FILE.RECORD$(J%) +           \
5129: 94e1:                                        " to " +                     \
5130: 94e1:                                        LOG.FILE.DOW$ + " " +        \
5131: 94e1:                                        LOG.FILE.DAY$ + "/" +        \
5132: 94e1:                                        LOG.FILE.MONTH$ + "/" +      \
5133: 94e1:                                        LOG.FILE.YEAR$ + " " +       \
5134: 94e1:                                        LOG.FILE.TIME$
5135: 94e1: 
5136: 94e1:                 ENDIF
5137: 94e9: 
5138: 94e9:                 CLOSE EVLOG.SESS.NUM%
5139: 94fd: 
5140: 94fd:             ENDIF
5141: 9505: 
5142: 9505:         ENDIF
5143: 950d: 
5144: 950d:     NEXT I%
5145: 952d: 
5146: 952d:     FILE.COUNT% = J%                                                    !BMW
5147: 953b: 
5148: 953b:     ! Calculate total number of files pages
5149: 953b:     FILE.TOTAL.PAGES% =                                             \   !BMW
5150: 9586:         INT((FILE.COUNT% - 1) / FILES.PER.PAGE%) + 1                    !BMW
5151: 9586: 
5152: 9586:     ! Calculate files on the last page
5153: 9586:     FILE.LAST.PAGE% =                                               \   !BMW
5154: 95a6:         FILE.COUNT% - ((FILE.TOTAL.PAGES% - 1) * FILES.PER.PAGE%)       !BMW
5155: 95a6: 
5156: 95a6:     LOG.NUMBER$ = PAD$(STR$(FIRST.LOG%),2)
5157: 95d6: 
5158: 95d6:     RETURN
5159: 95e6: 
5160: 95e6: \***********************************************************************
5161: 95e6: \***
5162: 95e6: \***    GET.SEARCH.RESULTS
5163: 95e6: \***
5164: 95e6: \***********************************************************************
5165: 95e6: \***
5166: 95e6: \***    Search selected event log file for event log records that
5167: 95e6: \***    match the specified search criteria.
5168: 95e6: \***
5169: 95e6: \***********************************************************************
5170: 95e6: GET.SEARCH.RESULTS:
5171: 95f6: 
5172: 95f6:     MAX.RECORDS% = LOG.RECORD.COUNT%
5173: 9608: 
5174: 9608:     DIM SUMMARY.RECORD$(MAX.RECORDS%)
5175: 9639:     DIM DETAIL.RECORD$(MAX.RECORDS%)
5176: 9664: 
5177: 9664:     ! IF all terminals selected
5178: 9664:     IF SELECTION.FIELD$(4) = "*" THEN BEGIN
5179: 968b:         ALL.EVENT.TERMINAL = TRUE
5180: 969f:     ENDIF ELSE BEGIN
5181: 96a7:         ALL.EVENT.TERMINAL = FALSE
5182: 96b9:         SELECTION.EVENT.TERMINAL% = VAL(SELECTION.FIELD$(4))
5183: 96df:     ENDIF
5184: 96e7: 
5185: 96e7:     ! IF all controller IDs selected
5186: 96e7:     IF SELECTION.FIELD$(5) = "*" THEN BEGIN
5187: 970e:         ALL.CONTROLLER.ID = TRUE
5188: 9722:     ENDIF ELSE BEGIN
5189: 972a:         ALL.CONTROLLER.ID = FALSE
5190: 973c:         SELECTION.CONTROLLER.ID$ = SELECTION.FIELD$(5)
5191: 9761:     ENDIF
5192: 9769: 
5193: 9769:     ! IF all event numbers selected
5194: 9769:     IF SELECTION.FIELD$(9) = "*" THEN BEGIN
5195: 9790:         ALL.EVENT.NUMBER = TRUE
5196: 97a4:     ENDIF ELSE BEGIN
5197: 97ac:         ALL.EVENT.NUMBER = FALSE
5198: 97be:         SELECTION.EVENT.NUMBER% = VAL(SELECTION.FIELD$(9))
5199: 97e4:     ENDIF
5200: 97ec: 
5201: 97ec:     ! IF all message groups selected
5202: 97ec:     IF SELECTION.FIELD$(10) = "*" THEN BEGIN
5203: 9813:         ALL.EVENT.MESSAGE.GROUP = TRUE
5204: 9827:     ENDIF ELSE BEGIN
5205: 982f:         ALL.EVENT.MESSAGE.GROUP = FALSE
5206: 9841:         SELECTION.EVENT.MESSAGE.GROUP$ = SELECTION.FIELD$(10)
5207: 9866:     ENDIF
5208: 986e: 
5209: 986e:     ! IF all message numbers selected
5210: 986e:     IF SELECTION.FIELD$(11) = "*" THEN BEGIN
5211: 9895:         ALL.EVENT.MESSAGE.NUMBER = TRUE
5212: 98a9:     ENDIF ELSE BEGIN
5213: 98b1:         ALL.EVENT.MESSAGE.NUMBER = FALSE
5214: 98c3:         SELECTION.EVENT.MESSAGE.NUMBER% = VAL(SELECTION.FIELD$(11))
5215: 98e9:     ENDIF
5216: 98f1: 
5217: 98f1:     RESULTS.COUNT% = 0
5218: 9902: 
5219: 9902:     END.OF.FILE = FALSE
5220: 9914: 
5221: 9914:     ! FOR each event log
5222: 9914:     FOR I% = 1 TO LOG.RECORD.COUNT%
5223: 9925: 
5224: 9925:         EVENT.RECORD$ = LOG.RECORD$(I%)
5225: 994c: 
5226: 994c:         ! Extract event details from the event record
5227: 994c:         GOSUB GET.EVENT.DETAILS
5228: 995e: 
5229: 995e:         ! IF event log record matches selections
5230: 995e:         ! ------------------------------------------
5231: 995e:         ! NOTE: IF statement intentionally sequenced
5232: 995e:         !          like this for performance reasons
5233: 995e:         ! ------------------------------------------
5234: 995e:         IF SELECTION.APPLICATION(I%) THEN IF                        \
5235: 997e:                                                                     \
5236: 997e:            SELECTION.SOURCE(I%) THEN IF                             \   !BMW
5237: 999e:                                                                     \   !BMW
5238: 999e:            ((EVENT.BUCKET% = 0) AND                                 \
5239: 9ae5:              SELECTION.BUCKET(0) OR                                 \
5240: 9ae5:             (EVENT.BUCKET% = 1) AND                                 \
5241: 9ae5:              SELECTION.BUCKET(1) OR                                 \
5242: 9ae5:             (EVENT.BUCKET% = 2) AND                                 \
5243: 9ae5:             SELECTION.BUCKET(2) OR                                  \
5244: 9ae5:             (EVENT.BUCKET% = 3) AND                                 \
5245: 9ae5:             SELECTION.BUCKET(3) OR                                  \
5246: 9ae5:             (EVENT.BUCKET% = 4) AND                                 \
5247: 9ae5:             SELECTION.BUCKET(4) OR                                  \
5248: 9ae5:             (EVENT.BUCKET% = 5) AND                                 \
5249: 9ae5:             SELECTION.BUCKET(5) OR                                  \
5250: 9ae5:             (EVENT.BUCKET% = 6) AND                                 \
5251: 9ae5:             SELECTION.BUCKET(6)) THEN IF                            \
5252: 9ae5:                                                                     \
5253: 9ae5:            ((EVENT.SEVERITY% = 0) AND                               \
5254: 9bfe:              SELECTION.SEVERITY(0) OR                               \
5255: 9bfe:             (EVENT.SEVERITY% = 1) AND                               \
5256: 9bfe:              SELECTION.SEVERITY(1) OR                               \
5257: 9bfe:             (EVENT.SEVERITY% = 2) AND                               \
5258: 9bfe:              SELECTION.SEVERITY(2) OR                               \
5259: 9bfe:             (EVENT.SEVERITY% = 3) AND                               \
5260: 9bfe:              SELECTION.SEVERITY(3) OR                               \
5261: 9bfe:             (EVENT.SEVERITY% = 4) AND                               \
5262: 9bfe:              SELECTION.SEVERITY(4) OR                               \
5263: 9bfe:             (EVENT.SEVERITY% = 5) AND                               \
5264: 9bfe:              SELECTION.SEVERITY(5)) THEN IF                         \
5265: 9bfe:                                                                     \
5266: 9bfe:            (ALL.EVENT.TERMINAL OR                                   \
5267: 9c21:            (SELECTION.EVENT.TERMINAL% = EVENT.TERMINAL%)) THEN IF   \
5268: 9c21:                                                                     \
5269: 9c21:            (ALL.CONTROLLER.ID OR                                    \
5270: 9c58:            (SELECTION.CONTROLLER.ID$ = CONTROLLER.ID$)) THEN IF     \
5271: 9c58:                                                                     \
5272: 9c58:            (ALL.EVENT.NUMBER OR                                     \
5273: 9c7b:            (SELECTION.EVENT.NUMBER% = EVENT.NUMBER%)) THEN IF       \
5274: 9c7b:                                                                     \
5275: 9c7b:            (ALL.EVENT.MESSAGE.GROUP OR                              \
5276: 9caf:            (SELECTION.EVENT.MESSAGE.GROUP$ =                        \
5277: 9caf:                EVENT.MESSAGE.GROUP$)) THEN IF                       \
5278: 9caf:                                                                     \
5279: 9caf:            (ALL.EVENT.MESSAGE.NUMBER OR                             \
5280: 9ccf:            (SELECTION.EVENT.MESSAGE.NUMBER% =                       \
5281: 9ccf:                EVENT.MESSAGE.NUMBER%)) THEN BEGIN
5282: 9ccf: 
5283: 9ccf:             GOSUB USE.EVENT.DETAILS
5284: 9ce3: 
5285: 9ce3:         ENDIF ELSE BEGIN
5286: 9ceb:             ! Not selected
5287: 9ceb:             EVENT.RECORD$ = ""
5288: 9d00:         ENDIF
5289: 9d08: 
5290: 9d08: END.RESULT.REACHED:
5291: 9d18: 
5292: 9d18:     NEXT I%
5293: 9d37: 
5294: 9d37:     ! Calculate total number of results pages
5295: 9d37:     RESULTS.TOTAL.PAGES% =                                          \
5296: 9d8a:         INT((RESULTS.COUNT% - 1) / RESULTS.PER.PAGE%) + 1
5297: 9d8a: 
5298: 9d8a:     ! Calculate results on the last page
5299: 9d8a:     RESULTS.LAST.PAGE% =                                            \
5300: 9db7:         RESULTS.COUNT% - ((RESULTS.TOTAL.PAGES% - 1) *              \
5301: 9db7:         RESULTS.PER.PAGE%)
5302: 9db7: 
5303: 9db7:     RETURN
5304: 9dc7: 
5305: 9dc7: \***********************************************************************
5306: 9dc7: \***
5307: 9dc7: \***    GET.EVENT.DETAILS
5308: 9dc7: \***
5309: 9dc7: \***********************************************************************
5310: 9dc7: \***
5311: 9dc7: \***    Extract all fields from the event log record
5312: 9dc7: \***
5313: 9dc7: \***********************************************************************
5314: 9dc7: GET.EVENT.DETAILS:
5315: 9dd7: 
5316: 9dd7:     APPLICATION.EVENT = FALSE
5317: 9de9: 
5318: 9de9:     EVENT.DATE%           = GETN2(EVENT.RECORD$,0)
5319: 9e11:     EVENT.TIME%           = GETN2(EVENT.RECORD$,2)
5320: 9e39:     EVENT.NODE.ID%        = GETN2(EVENT.RECORD$,4)
5321: 9e5a:     EVENT.TERMINAL%       = GETN2(EVENT.RECORD$,6)
5322: 9e7b:     EVENT.SOURCE%         = GETN1(EVENT.RECORD$,8)
5323: 9e9c:     EVENT.MESSAGE.GROUP$  = MID$(EVENT.RECORD$,10,1)
5324: 9ec0:     EVENT.MESSAGE.NUMBER% = GETN2(EVENT.RECORD$,10)
5325: 9ee1:     EVENT.SEVERITY%       = GETN1(EVENT.RECORD$,12)
5326: 9f02:     EVENT.NUMBER%         = GETN1(EVENT.RECORD$,13)
5327: 9f23:     EVENT.UNIQUE.DATA$    = MID$(EVENT.RECORD$,15,18)
5328: 9f47:     EVENT.BUCKET%         = GETN1(EVENT.RECORD$,32)
5329: 9f68:     EVENT.FORMAT%         = GETN1(EVENT.RECORD$,33)
5330: 9f89:     EVENT.COUNT%          = GETN2(EVENT.RECORD$,34)
5331: 9faa: 
5332: 9faa:     ! If missing events are found
5333: 9faa:     IF EVENT.DATE% = 0 THEN BEGIN
5334: 9fcc: 
5335: 9fcc:         CONTROLLER.ID$ = ""
5336: 9fe3:         TILL.NUMBER$   = ""
5337: 9ffa: 
5338: 9ffa:         PROGRAM$ = NULL.PROGRAM$
5339: a018:         PID$     = ""                                                   !IMW
5340: a02f: 
5341: a02f:         EVENT.MESSAGE.GROUP$  = ""
5342: a046:         EVENT.MESSAGE.NUMBER% = 0
5343: a057: 
5344: a057:         EVENT.DAY%   = 0
5345: a068:         EVENT.MONTH% = 0
5346: a079:         EVENT.YEAR%  = 0
5347: a08a:         EVENT.DOW$   = ""
5348: a0a1:         EVENT.HOUR%  = 0
5349: a0b2:         EVENT.MIN%   = 0
5350: a0c6: 
5351: a0c6:     ENDIF ELSE BEGIN
5352: a0ce: 
5353: a0ce:         EVENT.DAY%   = EVENT.DATE% AND 0001FH
5354: a0f7:         EVENT.MONTH% = SHIFT(EVENT.DATE% AND 001E0H,5)
5355: a129:         EVENT.YEAR%  = SHIFT(EVENT.DATE% AND 0FE00H,9) + 1980
5356: a166:         EVENT.DATE$  = RIGHT$(STR$(EVENT.YEAR%),2) +                \
5357: a1f3:                        PAD$(STR$(EVENT.MONTH%),2) +                 \
5358: a1f3:                        PAD$(STR$(EVENT.DAY%),2)
5359: a1f3:         EVENT.DOW$   = DOW$(DAY.OF.WEEK(EVENT.DATE$))
5360: a22d: 
5361: a22d:         EVENT.HOUR% = SHIFT(EVENT.TIME% AND 0F800H,11)
5362: a25f:         EVENT.MIN%  = SHIFT(EVENT.TIME% AND 007E0H,5)
5363: a291: 
5364: a291:         CONTROLLER.ID$ = CHR$(SHIFT(EVENT.NODE.ID% AND 0FF00H,8)) + \
5365: a2de:                          CHR$(EVENT.NODE.ID% AND 000FFH)
5366: a2de: 
5367: a2de:         ! IF terminal number is available
5368: a2de:         IF EVENT.TERMINAL% > 0 THEN BEGIN
5369: a2f0:             TILL.NUMBER$ = PAD$(STR$(EVENT.TERMINAL%),3)
5370: a326:         ENDIF ELSE BEGIN
5371: a32e:             TILL.NUMBER$ = ""
5372: a345:         ENDIF
5373: a34d: 
5374: a34d:         ! IF message group is out of range
5375: a34d:         IF NOT (EVENT.MESSAGE.GROUP$ >= "A" AND                     \
5376: a39f:                 EVENT.MESSAGE.GROUP$ <= "Z") THEN BEGIN
5377: a39f:             EVENT.MESSAGE.GROUP$ = " "
5378: a3b6:         ENDIF
5379: a3be: 
5380: a3be:         ! Get application name
5381: a3be:         PROGRAM$ = GET.APPLICATION$(EVENT.RECORD$)
5382: a3de: 
5383: a3de:         ! IF terminal or controller application event
5384: a3de:         IF EVENT.SOURCE% = 1 OR \          ! Controller application
5385: a40a:            EVENT.SOURCE% = 60 THEN BEGIN   ! Terminal application
5386: a40a: 
5387: a40a:             APPLICATION.EVENT = TRUE
5388: a41c:             EVENT.UNIQUE.DATA$ = RIGHT$(EVENT.UNIQUE.DATA$,10)
5389: a441:             PID$ = ""
5390: a45b: 
5391: a45b:         ! IF process ID is available in this event format
5392: a45b:         ENDIF ELSE IF EVENT.FORMAT% = 28 OR                         \
5393: a49c:                       EVENT.FORMAT% = 29 OR                         \
5394: a49c:                       EVENT.FORMAT% = 47 THEN BEGIN
5395: a49c: 
5396: a49c:             ! Process ID
5397: a49c:             PID$ =                                                  \   !GMW
5398: a566:                 LTRIM$(HEX.TEXT$(UNPACK$(                           \   !GMW
5399: a566:                 MID$(EVENT.UNIQUE.DATA$,6,1) +                      \   !GMW
5400: a566:                 MID$(EVENT.UNIQUE.DATA$,5,1) +                      \   !GMW
5401: a566:                 MID$(EVENT.UNIQUE.DATA$,4,1) +                      \   !GMW
5402: a566:                 MID$(EVENT.UNIQUE.DATA$,3,1))),"0")                     !GMW
5403: a566: 
5404: a566:         ENDIF
5405: a56e: 
5406: a56e:     ENDIF
5407: a576: 
5408: a576:     RETURN
5409: a586: 
5410: a586: \***********************************************************************
5411: a586: \***
5412: a586: \***    USE.EVENT.DETAILS
5413: a586: \***
5414: a586: \***********************************************************************
5415: a586: \***
5416: a586: \***    Add event log details to the summary and detail tables
5417: a586: \***
5418: a586: \***********************************************************************
5419: a586: USE.EVENT.DETAILS:
5420: a596: 
5421: a596:     ! IF missing event status record                                    !IMW
5422: a596:     IF EVENT.DATE% = 0 THEN BEGIN
5423: a5b5: 
5424: a5b5:         T$ = STRING$(41,"-") + " "
5425: a5e3:         MESSAGE.TEXT$ = "There are " +                              \
5426: a61e:                         STR$(EVENT.COUNT%) +                        \
5427: a61e:                         " missing records"
5428: a61e: 
5429: a61e:     ENDIF ELSE BEGIN
5430: a626: 
5431: a626:         ! IF system event                                               !IMW
5432: a626:         IF EVENT.MESSAGE.GROUP$ = "W" AND                           \
5433: a681:             LEN(SW$(EVENT.MESSAGE.NUMBER%)) > 0 THEN BEGIN
5434: a681:             ! Get short message description                             !IMW
5435: a681:             MESSAGE.TEXT$ = SW$(EVENT.MESSAGE.NUMBER%)
5436: a6b3:         ! IF text editor event                                          !KMW
5437: a6b3:         ENDIF ELSE IF EVENT.MESSAGE.GROUP$ = "A" AND                \   !KMW
5438: a706:                       EVENT.NUMBER% = 177 AND                       \   !KMW
5439: a706:                       EVENT.MESSAGE.NUMBER% < 900 THEN BEGIN            !KMW
5440: a706:             IF EVENT.MESSAGE.NUMBER% = 800 OR           \ DREDIX        !KMW
5441: a744:                EVENT.MESSAGE.NUMBER% = 803 OR           \ VEDIT         !KMW
5442: a744:                EVENT.MESSAGE.NUMBER% = 806 THEN BEGIN   ! XE            !KMW
5443: a744:                 MESSAGE.TEXT$ = "Opened"                                !KMW
5444: a75e:                ENDIF ELSE \                                             !KMW
5445: a766:             IF EVENT.MESSAGE.NUMBER% = 801 OR           \ DREDIX        !KMW
5446: a7a4:                EVENT.MESSAGE.NUMBER% = 804 OR           \ VEDIT         !KMW
5447: a7a4:                EVENT.MESSAGE.NUMBER% = 807 THEN BEGIN   ! XE            !KMW
5448: a7a4:                 MESSAGE.TEXT$ = "Updated"                               !KMW
5449: a7bd:             ENDIF ELSE \                                                !KMW
5450: a7c5:             IF EVENT.MESSAGE.NUMBER% = 802 OR           \ DREDIX        !KMW
5451: a803:                EVENT.MESSAGE.NUMBER% = 805 OR           \ VEDIT         !KMW
5452: a803:                EVENT.MESSAGE.NUMBER% = 808 THEN BEGIN   ! XE            !KMW
5453: a803:                 MESSAGE.TEXT$ = "Created"                               !KMW
5454: a81a:             ENDIF                                                       !KMW
5455: a822:             MESSAGE.TEXT$ = MESSAGE.TEXT$ + " file " +              \   !KMW
5456: a859:                 UNCOMPRESS$(EVENT.UNIQUE.DATA$)                         !KMW
5457: a859:         ENDIF ELSE BEGIN
5458: a861:             ! Get application event unique data                         !IMW
5459: a861:             MESSAGE.TEXT$ = \
5460: a8cd:                 "*" + ASC.TEXT$(EVENT.UNIQUE.DATA$) + "*" +         \
5461: a8cd:                 "[" + HEX.TEXT$(UNPACK$(EVENT.UNIQUE.DATA$)) + "]"
5462: a8cd: 
5463: a8cd:         ENDIF
5464: a8d5: 
5465: a8d5:         ! Build event log details for summary record                    !IMW
5466: a8d5:         T$ = EVENT.DOW$                                  + " " +    \
5467: aaad:              PAD$(STR$(EVENT.HOUR%),2)                   + ":" +    \
5468: aaad:              PAD$(STR$(EVENT.MIN%),2)                    + " " +    \
5469: aaad:              LEFT$(TILL.NUMBER$ + "   ",3)               + " " +    \
5470: aaad:              LEFT$(CONTROLLER.ID$ + "  ",2)              + " " +    \
5471: aaad:              STR$(EVENT.SEVERITY%)                       + " " +    \
5472: aaad:              "B" + STR$(EVENT.BUCKET%)                   + "/" +    \
5473: aaad:              "S" + PAD$(STR$(EVENT.SOURCE%),3)           + "/" +    \
5474: aaad:              "E" + PAD$(STR$(EVENT.NUMBER%),3)           + " " +    \
5475: aaad:              PROGRAM$                                    + " " +    \
5476: aaad:              EVENT.MESSAGE.GROUP$                        +          \
5477: aaad:              PAD$(STR$(EVENT.MESSAGE.NUMBER%),3)
5478: aaad: 
5479: aaad:         ! IF multiple repeated event log entries
5480: aaad:         IF EVENT.COUNT% > 1 THEN BEGIN
5481: aabf:             T$ = T$ + "+"
5482: aae1:         ENDIF ELSE BEGIN
5483: aae9:             T$ = T$ + " "
5484: ab09:         ENDIF
5485: ab11: 
5486: ab11:     ENDIF
5487: ab19: 
5488: ab19:     ! Build completed summary record                                    !IMW
5489: ab19:     T$ = LEFT$(T$ + MESSAGE.TEXT$ + STRING$(80," "),80) +           \   !IMW
5490: abb6:          RIGHT$(STRING$(8,"0") + PID$,8)                                !IMW
5491: abb6: 
5492: abb6:     RESULTS.COUNT% = RESULTS.COUNT% + 1
5493: abc5:     SUMMARY.RECORD$(RESULTS.COUNT%) = T$                                !IMW
5494: abf1:     DETAIL.RECORD$(RESULTS.COUNT%) = EVENT.RECORD$
5495: ac1a: 
5496: ac1a:     RETURN
5497: ac2a: 
5498: ac2a: \***********************************************************************
5499: ac2a: \***
5500: ac2a: \***    PROCESS.SUMMARY.SCREEN
5501: ac2a: \***
5502: ac2a: \***********************************************************************
5503: ac2a: PROCESS.SUMMARY.SCREEN:
5504: ac3a: 
5505: ac3a:     RESULTS.PAGE% = 1
5506: ac4b: 
5507: ac4b:     GOSUB INITIALISE.SUMMARY.SCREEN
5508: ac5d: 
5509: ac5d:     CURRENT.FIELD% = SUMMARY.START.FIELD%
5510: ac6f:     
5511: ac6f:     ! Set default current index to first summary record                 !IMW
5512: ac6f:     CURRENT.INDEX% = RESULTS.COUNT%                                     !IMW
5513: ac85: 
5514: ac85:     WHILE NOT SUMMARY.EXIT.PRESSED
5515: ac90: 
5516: ac90:         CALL DM.CURRENT.FIELD(CURRENT.FIELD%)
5517: aca8: 
5518: aca8:         GOSUB DISPLAY.SUMMARY.PAGE
5519: acba: 
5520: acba:         KEY% = DM.PROCESS.SCREEN(SUMMARY.START.FIELD%,              \
5521: ace2:                                  SUMMARY.LAST.FIELD%,               \
5522: ace2:                                  FALSE)
5523: ace2: 
5524: ace2:         ! IF quit key                                                   !HMW
5525: ace2:         IF KEY% = F3.KEY% THEN BEGIN
5526: acfa: 
5527: acfa:             SUMMARY.EXIT.PRESSED = TRUE
5528: ad0c: 
5529: ad0c:             GOSUB INITIALISE.SELECTION.SCREEN
5530: ad21: 
5531: ad21:         ! IF escape key                                                 !HMW
5532: ad21:         ENDIF ELSE IF KEY% = ESC.KEY% THEN BEGIN
5533: ad39: 
5534: ad39:             SUMMARY.EXIT.PRESSED = TRUE
5535: ad4b: 
5536: ad4b:             GOSUB INITIALISE.SELECTION.SCREEN
5537: ad60: 
5538: ad60:         ! IF refresh results                                            !HMW
5539: ad60:         ENDIF ELSE IF KEY% = F4.KEY% THEN BEGIN                         !HMW
5540: ad7b:                                                                         !HMW
5541: ad7b:             ! Save position of selected summary record                  !HMW
5542: ad7b:             CURRENT.FIELD% = DM.CURRENT.FIELD(0)                        !HMW
5543: ad93:                                                                         !HMW
5544: ad93:             ! IF currently active event log                             !HMW
5545: ad93:             IF VAL(LOG.NUMBER$) = 0 THEN BEGIN                          !HMW
5546: adcb:                                                                         !HMW
5547: adcb:                 ! IF new events are available                           !HMW
5548: adcb:                 IF SIZE(LOG.FILE.NAME$) > LOG.FILE.SIZE% THEN BEGIN     !HMW
5549: adfa:                                                                         !HMW
5550: adfa:                     ! Display 'Processing - Please Wait...' message     !HMW
5551: adfa:                     CALL DM.STATUS("MESSAGE(251,'')")                   !HMW
5552: ae0e:                                                                         !HMW
5553: ae0e:                     ! Perform partial application index rebuild         !HMW
5554: ae0e:                     CALL CREATE.APPLICATION.LIST(FALSE,LOG.NUMBER$)     !HMW
5555: ae29:                                                                         !HMW
5556: ae29:                     GOSUB GET.SEARCH.RESULTS                            !HMW
5557: ae3b:                                                                         !HMW
5558: ae3b:                     CALL DM.FOCUS("",                               \   !HMW
5559: ae62:                         "MESSAGE(221,'Events have " +               \   !HMW
5560: ae62:                         "been updated')")                               !HMW
5561: ae62:                                                                         !HMW
5562: ae62:                     RESULTS.PAGE% = 1                                   !HMW
5563: ae73:                                                                         !HMW
5564: ae73:                     CURRENT.FIELD% = SUMMARY.START.FIELD%               !HMW
5565: ae87:                                                                         !HMW
5566: ae87:                 ENDIF ELSE BEGIN                                        !IMW
5567: ae8f:                                                                         !IMW
5568: ae8f:                     CALL DM.FOCUS("",                               \   !IMW
5569: aeb6:                         "MESSAGE(221,'No new events " +             \   !IMW
5570: aeb6:                         "available')")                                  !IMW
5571: aeb6:                                                                         !IMW
5572: aeb6:                 ENDIF                                                   !HMW
5573: aec0:                                                                         !HMW
5574: aec0:             ENDIF ELSE BEGIN                                            !HMW
5575: aec8:                                                                         !HMW
5576: aec8:                 ! B001 Invalid key pressed                              !HMW
5577: aec8:                 CALL DM.FOCUS("", "MESSAGE(1,'')")                      !HMW
5578: aee0:                                                                         !HMW
5579: aee0:             ENDIF                                                       !HMW
5580: aeeb:                                                                         !HMW
5581: aeeb:         ! IF search for start/end program toggle                        !IMW
5582: aeeb:         ENDIF ELSE IF KEY% = F2.KEY% THEN BEGIN                         !IMW
5583: af06:                                                                         !IMW
5584: af06:             ! Get position of selected summary record                   !IMW
5585: af06:             CURRENT.FIELD% = DM.CURRENT.FIELD(0)                        !IMW
5586: af1e:                                                                         !IMW
5587: af1e:             ! Calculate selected event log index                        !IMW
5588: af1e:             CURRENT.INDEX% = RESULTS.COUNT% -                       \   !IMW
5589: af5d:                              (((RESULTS.PAGE% - 1) *                \   !IMW
5590: af5d:                              RESULTS.PER.PAGE%) +                   \   !IMW
5591: af5d:                              (CURRENT.FIELD% - 3))                      !IMW
5592: af5d:                                                                         !IMW
5593: af5d:             EVENT.MESSAGE.GROUP$  =                                 \   !IMW
5594: af95:                 MID$(SUMMARY.RECORD$(CURRENT.INDEX%),42,1)              !IMW
5595: af95:             EVENT.MESSAGE.NUMBER% =                                 \   !IMW
5596: afd6:                 ?VAL(MID$(SUMMARY.RECORD$(CURRENT.INDEX%),43,3))        !IMW
5597: afd6:                                                                         !IMW
5598: afd6:             ! IF start/end program system event                         !IMW
5599: afd6:             IF EVENT.MESSAGE.GROUP$ = "W" AND                       \   !IMW
5600: b028:                (EVENT.MESSAGE.NUMBER% = 619 OR                      \   !IMW
5601: b028:                 EVENT.MESSAGE.NUMBER% = 620) THEN BEGIN                 !IMW
5602: b028:                                                                         !IMW
5603: b028:                 ! Find matching start/end program event                 !IMW
5604: b028:                 IF NOT FIND.PROGRAM.PAIR THEN BEGIN                     !IMW
5605: b039:                     CALL DM.FOCUS("",                               \   !IMW
5606: b060:                         "MESSAGE(221,'No matching event " +         \   !IMW
5607: b060:                         "pair found')")                                 !IMW
5608: b060:                 ENDIF                                                   !IMW
5609: b06a:                                                                         !IMW
5610: b06a:             ENDIF ELSE BEGIN                                            !IMW
5611: b072:                                                                         !IMW
5612: b072:                 ! B001 Invalid key pressed                              !IMW
5613: b072:                 CALL DM.FOCUS("", "MESSAGE(1,'')")                      !IMW
5614: b08a:                                                                         !IMW
5615: b08a:             ENDIF                                                       !IMW
5616: b095:                                                                         !IMW
5617: b095:         ! IF cursor up                                                  !HMW
5618: b095:         ENDIF ELSE IF KEY% = PREV.KEY% THEN BEGIN
5619: b0ad: 
5620: b0ad:             IF RESULTS.PAGE% > 1 THEN BEGIN
5621: b0bf:                 ! Move to the last row on the previous page
5622: b0bf:                 CURRENT.FIELD% = 20 ! Will always be 20
5623: b0cf:                 RESULTS.PAGE% = RESULTS.PAGE% - 1
5624: b0e0:             ENDIF ELSE BEGIN
5625: b0e8:                 ! No previous page exists
5626: b0e8:                 CALL DM.FOCUS("","MESSAGE(74,'')")
5627: b100:                 CURRENT.FIELD% = SUMMARY.START.FIELD%
5628: b112:             ENDIF
5629: b11d: 
5630: b11d:         ! IF cursor down                                                !HMW
5631: b11d:         ENDIF ELSE IF KEY% = NEXT.KEY% THEN BEGIN
5632: b138: 
5633: b138:             ! IF this is not the last page
5634: b138:             IF RESULTS.PAGE% < RESULTS.TOTAL.PAGES% THEN BEGIN
5635: b150:                 ! Move to the first row on the next page
5636: b150:                 CURRENT.FIELD% = 3 ! Will always be 3
5637: b160:                 RESULTS.PAGE% = RESULTS.PAGE% + 1
5638: b171:             ENDIF ELSE BEGIN
5639: b179:                 ! No next page exists
5640: b179:                 CALL DM.FOCUS("","MESSAGE(75,'')")
5641: b191:                 CURRENT.FIELD% = SUMMARY.LAST.FIELD%
5642: b1a3:             ENDIF
5643: b1ae: 
5644: b1ae:         ! IF first page                                                 !HMW
5645: b1ae:         ENDIF ELSE IF KEY% = TOP.KEY% THEN BEGIN
5646: b1c9: 
5647: b1c9:             IF RESULTS.PAGE% = 1 THEN BEGIN
5648: b1db: 
5649: b1db:                 IF CURRENT.FIELD% = SUMMARY.START.FIELD% THEN BEGIN
5650: b1f1: 
5651: b1f1:                     ! No previous page exists
5652: b1f1:                     CALL DM.FOCUS("","MESSAGE(74,'')")
5653: b20b: 
5654: b20b:                 ENDIF ELSE BEGIN
5655: b213: 
5656: b213:                     CURRENT.FIELD% = SUMMARY.START.FIELD%
5657: b225: 
5658: b225:                 ENDIF
5659: b22f: 
5660: b22f:             ENDIF ELSE BEGIN
5661: b237: 
5662: b237:                 RESULTS.PAGE% = 1
5663: b248:                 CURRENT.FIELD% = SUMMARY.START.FIELD%
5664: b25a: 
5665: b25a:             ENDIF
5666: b265: 
5667: b265:         ! IF last page                                                  !HMW
5668: b265:         ENDIF ELSE IF KEY% = BOTTOM.KEY% THEN BEGIN
5669: b280: 
5670: b280:             IF RESULTS.PAGE% = RESULTS.TOTAL.PAGES% THEN BEGIN
5671: b298: 
5672: b298:                 IF CURRENT.FIELD% = SUMMARY.LAST.FIELD% THEN BEGIN
5673: b2ae: 
5674: b2ae:                     ! No next page exists
5675: b2ae:                     CALL DM.FOCUS("","MESSAGE(75,'')")
5676: b2c8: 
5677: b2c8:                 ENDIF ELSE BEGIN
5678: b2d0: 
5679: b2d0:                     CURRENT.FIELD% = RESULTS.LAST.PAGE% + 2
5680: b2e9: 
5681: b2e9:                 ENDIF
5682: b2f3: 
5683: b2f3:             ENDIF ELSE BEGIN
5684: b2fb: 
5685: b2fb:                 RESULTS.PAGE% = RESULTS.TOTAL.PAGES%
5686: b311:                 CURRENT.FIELD% = RESULTS.LAST.PAGE% + 2
5687: b32a: 
5688: b32a:             ENDIF
5689: b335: 
5690: b335:         ! IF page up                                                    !HMW
5691: b335:         ENDIF ELSE IF KEY% = F7.KEY% OR                             \
5692: b369:                       KEY% = PGUP.KEY% THEN BEGIN
5693: b369: 
5694: b369:             IF RESULTS.PAGE% = 1 THEN BEGIN
5695: b37b: 
5696: b37b:                 ! No previous page exists
5697: b37b:                 CALL DM.FOCUS("","MESSAGE(74,'')")
5698: b395: 
5699: b395:             ENDIF ELSE BEGIN
5700: b39d:                 RESULTS.PAGE% = RESULTS.PAGE% - 1
5701: b3ac:                 CURRENT.FIELD% = SUMMARY.START.FIELD%
5702: b3be:             ENDIF
5703: b3c9: 
5704: b3c9:         ! IF page down                                                  !HMW
5705: b3c9:         ENDIF ELSE IF KEY% = F8.KEY% OR                             \
5706: b3fd:                       KEY% = PGDN.KEY% THEN BEGIN
5707: b3fd: 
5708: b3fd:             IF RESULTS.PAGE% = RESULTS.TOTAL.PAGES% THEN BEGIN
5709: b415: 
5710: b415:                 ! No next page exists
5711: b415:                 CALL DM.FOCUS("","MESSAGE(75,'')")
5712: b42f: 
5713: b42f:             ENDIF ELSE BEGIN
5714: b437:                 RESULTS.PAGE% = RESULTS.PAGE% + 1
5715: b446:                 CURRENT.FIELD% = SUMMARY.START.FIELD%
5716: b458:             ENDIF
5717: b463: 
5718: b463:         ! IF enter key                                                  !HMW
5719: b463:         ENDIF ELSE IF KEY% = ENTER.KEY% THEN BEGIN
5720: b47b: 
5721: b47b:             ! Display 'Processing - Please Wait...' message
5722: b47b:             CALL DM.STATUS("MESSAGE(251,'')")
5723: b48f: 
5724: b48f:             ! Save position of selected summary record
5725: b48f:             CURRENT.FIELD% = DM.CURRENT.FIELD(0)
5726: b4a7: 
5727: b4a7:             GOSUB PROCESS.DETAIL.SCREEN
5728: b4bb: 
5729: b4bb:         ENDIF ELSE BEGIN
5730: b4c3:             
5731: b4c3:             ! Save position of selected summary record                  !HMW
5732: b4c3:             CURRENT.FIELD% = DM.CURRENT.FIELD(0)                        !HMW
5733: b4db:                                                                         !HMW
5734: b4db:             ! B001 Invalid key pressed
5735: b4db:             CALL DM.FOCUS("", "MESSAGE(1,'')")
5736: b4f3: 
5737: b4f3:         ENDIF
5738: b4fb: 
5739: b4fb:     WEND
5740: b50d: 
5741: b50d:     RETURN
5742: b51d: 
5743: b51d: \***********************************************************************
5744: b51d: \***
5745: b51d: \***    INITIALISE.SUMMARY.SCREEN
5746: b51d: \***
5747: b51d: \***********************************************************************
5748: b51d: INITIALISE.SUMMARY.SCREEN:
5749: b52d: 
5750: b52d:     CALL DM.SHOW.SCREEN(2,"",2,2)
5751: b547: 
5752: b547:     SUMMARY.START.FIELD% = 3
5753: b555:     SUMMARY.END.FIELD%   = 20
5754: b563: 
5755: b563:     SUMMARY.EXIT.PRESSED = FALSE
5756: b575: 
5757: b575:     RETURN
5758: b585: 
5759: b585: \***********************************************************************
5760: b585: \***
5761: b585: \***    DISPLAY.SUMMARY.PAGE
5762: b585: \***
5763: b585: \***********************************************************************
5764: b585: DISPLAY.SUMMARY.PAGE:
5765: b595: 
5766: b595:     ! IF first page
5767: b595:     IF RESULTS.PAGE% = 1 THEN BEGIN
5768: b5a7:         ! Hide page up function key
5769: b5a7:         CALL DM.HIDE.FN.KEY(7)
5770: b5ba:     ENDIF ELSE BEGIN
5771: b5c2:         ! Display page up function key
5772: b5c2:         CALL DM.SHOW.FN.KEY(7,"PGUP")
5773: b5d8:     ENDIF
5774: b5e0: 
5775: b5e0:     ! IF last page
5776: b5e0:     IF RESULTS.PAGE% = RESULTS.TOTAL.PAGES% THEN BEGIN
5777: b5f8: 
5778: b5f8:         ! Hide page down function key
5779: b5f8:         CALL DM.HIDE.FN.KEY(8)
5780: b609: 
5781: b609:         SUMMARY.LAST.FIELD% = RESULTS.LAST.PAGE% + 2
5782: b61e: 
5783: b61e:         ! For the last page, set results per page to the remainder
5784: b61e:         RESULTS.THIS.PAGE% = RESULTS.LAST.PAGE%
5785: b636: 
5786: b636:     ENDIF ELSE BEGIN
5787: b63e: 
5788: b63e:         ! Display page down function key
5789: b63e:         CALL DM.SHOW.FN.KEY(8,"PGDN")
5790: b654: 
5791: b654:         SUMMARY.LAST.FIELD% = SUMMARY.END.FIELD%
5792: b662: 
5793: b662:         ! Set results per page to
5794: b662:         ! the maximum results allowed per page
5795: b662:         RESULTS.THIS.PAGE% = RESULTS.PER.PAGE%
5796: b678: 
5797: b678:     ENDIF
5798: b680: 
5799: b680:     FOR I% = 1 TO RESULTS.THIS.PAGE%
5800: b691: 
5801: b691:         FIELD.INDEX% = I% + 2
5802: b6a2: 
5803: b6a2:         RESULTS.INDEX% = RESULTS.COUNT% -                           \
5804: b6d6:                         (((RESULTS.PAGE% - 1) *                     \
5805: b6d6:                         RESULTS.PER.PAGE%) + (I% - 1))
5806: b6d6: 
5807: b6d6:         FIELD$(FIELD.INDEX%) =                                      \   !IMW
5808: b71c:             LEFT$(SUMMARY.RECORD$(RESULTS.INDEX%),80)                   !IMW
5809: b71c: 
5810: b71c:         CALL DM.VISIBLE(STR$(FIELD.INDEX%),"TRUE")
5811: b749: 
5812: b749:         CALL DM.RO.FIELD(FIELD.INDEX%)
5813: b75c: 
5814: b75c:     NEXT I%
5815: b77b: 
5816: b77b:     FIELD$(U0402.PAGE%) =                                           \
5817: b80c:         RIGHT$((STRING$(7," ") +                                    \
5818: b80c:         "Page " + STR$(RESULTS.PAGE%) +                             \
5819: b80c:         " of "  + STR$(RESULTS.TOTAL.PAGES%)),18)
5820: b80c: 
5821: b80c:     ! IF results per page is not a full page
5822: b80c:     IF RESULTS.THIS.PAGE% < RESULTS.PER.PAGE% THEN BEGIN
5823: b827: 
5824: b827:         ! For each remaining row
5825: b827:         FOR I% = (RESULTS.THIS.PAGE% + 1) TO RESULTS.PER.PAGE%
5826: b83c: 
5827: b83c:             FIELD.INDEX% = I% + 2
5828: b84d: 
5829: b84d:             ! Clear the row
5830: b84d:             FIELD$(FIELD.INDEX%) = STRING$(80," ")
5831: b879: 
5832: b879:             ! Hide the field
5833: b879:             CALL DM.VISIBLE(STR$(FIELD.INDEX%),"FALSE")
5834: b8a6: 
5835: b8a6:         NEXT I%
5836: b8c5: 
5837: b8c5:     ENDIF
5838: b8cd: 
5839: b8cd:     ! IF active event log file                                          !HMW
5840: b8cd:     IF VAL(LOG.NUMBER$) = 0 THEN BEGIN                                  !HMW
5841: b902:         ! Display refresh function key                                  !HMW
5842: b902:         CALL DM.SHOW.FN.KEY(4,"RFSH")                                   !HMW
5843: b91a:     ENDIF ELSE BEGIN                                                    !HMW
5844: b922:         ! Hide refresh function key                                     !HMW
5845: b922:         CALL DM.HIDE.FN.KEY(4)                                          !HMW
5846: b933:     ENDIF                                                               !HMW
5847: b93b:                                                                         !HMW
5848: b93b:     ! Calculate summary index for the current row                       !IMW
5849: b93b:     CURRENT.INDEX% =                                                \   !IMW
5850: b961:         GET.CURRENT.INDEX(RESULTS.PAGE%,CURRENT.FIELD%)                 !IMW
5851: b961:                                                                         !IMW
5852: b961:     ! Show or hide the pair option                                      !IMW
5853: b961:     CALL SHOW.PAIR.OPTION(CURRENT.INDEX%)                               !IMW
5854: b976:     
5855: b976:     RETURN
5856: b986: 
5857: b986: \***********************************************************************
5858: b986: \***
5859: b986: \***    PROCESS.DETAIL.SCREEN
5860: b986: \***
5861: b986: \***********************************************************************
5862: b986: PROCESS.DETAIL.SCREEN:
5863: b996: 
5864: b996:     GOSUB INITIALISE.DETAIL.SCREEN
5865: b9a8: 
5866: b9a8:     WHILE NOT DETAIL.EXIT.PRESSED
5867: b9b3: 
5868: b9b3:         GOSUB DISPLAY.DETAIL.PAGE
5869: b9c5: 
5870: b9c5:         KEY% = DM.PROCESS.SCREEN(DETAIL.START.FIELD%,               \
5871: b9ed:                                  DETAIL.END.FIELD%,                 \
5872: b9ed:                                  FALSE)
5873: b9ed: 
5874: b9ed:         ! IF quit key                                                   !HMW
5875: b9ed:         IF KEY% = F3.KEY% THEN BEGIN
5876: ba05: 
5877: ba05:             DETAIL.EXIT.PRESSED = TRUE
5878: ba17: 
5879: ba17:             GOSUB INITIALISE.SUMMARY.SCREEN
5880: ba2c: 
5881: ba2c:         ! IF view command mode session
5882: ba2c:         ENDIF ELSE IF KEY% = F4.KEY% THEN BEGIN
5883: ba47: 
5884: ba47:             ! IF command mode start or end of session event             !FMW
5885: ba47:             IF COMMAND.SESSION THEN BEGIN
5886: ba59: 
5887: ba59:                 ! Save current detail record position
5888: ba59:                 SAVED.FIELD% = CURRENT.FIELD%
5889: ba6c: 
5890: ba6c:                 ! Display 'Processing - Please Wait...' message
5891: ba6c:                 CALL DM.STATUS("MESSAGE(251,'')")
5892: ba80: 
5893: ba80:                 GOSUB GET.COMMAND.SESSION
5894: ba92: 
5895: ba92:                 ! IF no definite session match found
5896: ba92:                 IF NOT SESSION.FOUND THEN BEGIN
5897: baa1:                     ! No records found
5898: baa1:                     CALL DM.FOCUS("",                               \
5899: baca:                         "MESSAGE(221,'NO INACTIVE COMMAND " +       \
5900: baca:                         "SESSION FOUND FOR THIS SELECTION')")
5901: baca:                 ENDIF ELSE BEGIN
5902: bad2:                     GOSUB PROCESS.COMMAND.SCREEN                        !FMW
5903: bae4:                 ENDIF
5904: baec: 
5905: baec:                 ! Restore current detail record position
5906: baec:                 CURRENT.FIELD% = SAVED.FIELD%
5907: bb01: 
5908: bb01:             ! IF UTILS file update event                                !FMW
5909: bb01:             ENDIF ELSE IF UTILS.SESSION THEN BEGIN                      !FMW
5910: bb13:                                                                         !FMW
5911: bb13:                 ! Save current detail record position                   !FMW
5912: bb13:                 SAVED.FIELD% = CURRENT.FIELD%                           !FMW
5913: bb26:                                                                         !FMW
5914: bb26:                 ! Display 'Processing - Please Wait...' message         !FMW
5915: bb26:                 CALL DM.STATUS("MESSAGE(251,'')")                       !FMW
5916: bb3a:                                                                         !FMW
5917: bb3a:                 GOSUB GET.UTILS.SESSION                                 !FMW
5918: bb4c:                                                                         !FMW
5919: bb4c:                 ! IF no definite UTILS sector match found               !FMW
5920: bb4c:                 IF NOT SECTOR.FOUND THEN BEGIN                          !FMW
5921: bb5b:                     ! No records found                                  !FMW
5922: bb5b:                     CALL DM.FOCUS("",                               \   !FMW
5923: bb84:                         "MESSAGE(221,'NO UPDATED SECTOR " +         \   !FMW
5924: bb84:                         "AVAILABLE FOR THIS SELECTION')")               !FMW
5925: bb84:                 ENDIF ELSE BEGIN                                        !FMW
5926: bb8c:                     GOSUB PROCESS.UTILS.SCREEN                          !FMW
5927: bb9e:                 ENDIF                                                   !FMW
5928: bba6:                                                                         !FMW
5929: bba6:                 ! Restore current detail record position                !FMW
5930: bba6:                 CURRENT.FIELD% = SAVED.FIELD%                           !FMW
5931: bbba:                                                                         !FMW
5932: bbba:             ENDIF ELSE BEGIN
5933: bbc2:                 ! B001 Invalid key pressed
5934: bbc2:                 CALL DM.FOCUS("", "MESSAGE(1,'')")
5935: bbda:             ENDIF
5936: bbe5: 
5937: bbe5:         ! IF escape key                                                 !HMW
5938: bbe5:         ENDIF ELSE IF KEY% = ESC.KEY% THEN BEGIN
5939: bbfd: 
5940: bbfd:             DETAIL.EXIT.PRESSED = TRUE
5941: bc0f:             SUMMARY.EXIT.PRESSED = TRUE
5942: bc21: 
5943: bc21:             GOSUB INITIALISE.SELECTION.SCREEN
5944: bc36: 
5945: bc36:         ! IF cursor up OR page up                                       !IMW
5946: bc36:         ENDIF ELSE IF KEY% = PREV.KEY% OR                           \
5947: bc83:                       KEY% = F7.KEY% OR                             \
5948: bc83:                       KEY% = PGUP.KEY% THEN BEGIN
5949: bc83: 
5950: bc83:             IF CURRENT.FIELD% > SUMMARY.START.FIELD% THEN BEGIN
5951: bc99:                 ! Move to the previous row
5952: bc99:                 CURRENT.FIELD% = CURRENT.FIELD% - 1
5953: bcaa:             ENDIF ELSE BEGIN
5954: bcb2:                 IF RESULTS.PAGE% > 1 THEN BEGIN
5955: bcc4:                     ! Move to the last row on the previous page
5956: bcc4:                     CURRENT.FIELD% = 20 ! Will always be 20
5957: bcd4:                     RESULTS.PAGE% = RESULTS.PAGE% - 1
5958: bce5:                 ENDIF ELSE BEGIN
5959: bced:                     ! No previous page exists
5960: bced:                     CALL DM.FOCUS("","MESSAGE(74,'')")
5961: bd05:                 ENDIF
5962: bd0d:             ENDIF
5963: bd18: 
5964: bd18:         ! IF cursor down OR page down                                   !IMW
5965: bd18:         ENDIF ELSE IF KEY% = NEXT.KEY% OR                           \
5966: bd65:                       KEY% = F8.KEY% OR                             \
5967: bd65:                       KEY% = PGDN.KEY% THEN BEGIN
5968: bd65: 
5969: bd65:             ! IF this is not the last row on the page
5970: bd65:             IF CURRENT.FIELD% < SUMMARY.LAST.FIELD% THEN BEGIN
5971: bd7b:                 ! Move to the next row
5972: bd7b:                 CURRENT.FIELD% = CURRENT.FIELD% + 1
5973: bd8c:             ENDIF ELSE BEGIN
5974: bd94:                 ! IF this is not the last page
5975: bd94:                 IF RESULTS.PAGE% < RESULTS.TOTAL.PAGES% THEN BEGIN
5976: bdac:                     ! Move to the first row on the next page
5977: bdac:                     CURRENT.FIELD% = 3 ! Will always be 3
5978: bdbc:                     RESULTS.PAGE% = RESULTS.PAGE% + 1
5979: bdcd:                 ENDIF ELSE BEGIN
5980: bdd5:                     ! No next page exists
5981: bdd5:                     CALL DM.FOCUS("","MESSAGE(75,'')")
5982: bded:                 ENDIF
5983: bdf5:             ENDIF
5984: bdff: 
5985: bdff:         ENDIF ELSE BEGIN
5986: be07: 
5987: be07:             ! B001 Invalid key pressed
5988: be07:             CALL DM.FOCUS("", "MESSAGE(1,'')")
5989: be1f: 
5990: be1f:         ENDIF
5991: be27: 
5992: be27:     WEND
5993: be39: 
5994: be39:     RETURN
5995: be49: 
5996: be49: \***********************************************************************
5997: be49: \***
5998: be49: \***    GET.COMMAND.SESSION
5999: be49: \***
6000: be49: \***********************************************************************
6001: be49: \***
6002: be49: \***    Search the command history file for a command mode session
6003: be49: \***    for the specified process ID.
6004: be49: \***
6005: be49: \***********************************************************************
6006: be49: GET.COMMAND.SESSION:
6007: be59: 
6008: be59:     SESSION.FOUND = FALSE                                               !BMW
6009: be6b:     
6010: be6b:     ! Build full pathname of the command line log                       !EMW
6011: be6b:     CLLOG.NODE.ID$   = "ADXLX" + CONTROLLER.ID$ + "N"                   !EMW
6012: be94:     CLLOG.PATH.NAME$ = CLLOG.NODE.ID$ + "::" + CLLOG.FILE.NAME$         !EMW
6013: bec2:     
6014: bec2:     ! Open command line log file
6015: bec2:     OPEN CLLOG.PATH.NAME$ AS CLLOG.SESS.NUM% NOWRITE NODEL              !EMW
6016: bee7: 
6017: bee7:     ! Build match string for a command mode session header
6018: bee7:     MATCH.STRING$ = "OpID=######## PID=" +                          \
6019: bf3d:                     PAD$(RIGHT$(PID$,4),4) +                        \   !GMW
6020: bf3d:                     " NodeID=" + CONTROLLER.ID$
6021: bf3d: 
6022: bf3d:     END.OF.FILE = FALSE
6023: bf4f: 
6024: bf4f: !!!!HEADER.COUNT% = 0                                                   !KMW
6025: bf4f: 
6026: bf4f:     WHILE NOT END.OF.FILE
6027: bf5a: 
6028: bf5a:         ! Read next command line
6029: bf5a:         CLLOG.RC% = READ.CLLOG
6030: bf6a: 
6031: bf6a:         ! IF end of CLLOG file reached
6032: bf6a:         IF NOT CLLOG.RC% = 0 THEN BEGIN
6033: bf79:             END.OF.FILE = TRUE
6034: bf8d:         ENDIF ELSE BEGIN
6035: bf95: 
6036: bf95:             ! IF command line is for this event
6037: bf95:             IF MATCH(MATCH.STRING$,CLLOG.RECORD$,1) THEN BEGIN
6038: bfbb:                 ! Get all command lines
6039: bfbb:                 GOSUB GET.COMMAND.DETAILS
6040: bfcd:             ENDIF
6041: bfd5: 
6042: bfd5:         ENDIF
6043: bfdd: 
6044: bfdd:     WEND
6045: bfef: 
6046: bfef:     ! IF a definite match on process ID and time was found
6047: bfef:     IF SESSION.FOUND THEN BEGIN
6048: bffe: 
6049: bffe:         ! Calculate total number of results pages
6050: bffe:         COMMAND.TOTAL.PAGES% =                                      \
6051: c049:             INT((COMMAND.COUNT% - 1) / COMMANDS.PER.PAGE%) + 1
6052: c049: 
6053: c049:         ! Calculate results on the last page
6054: c049:         COMMAND.LAST.PAGE% =                                        \
6055: c069:             COMMAND.COUNT% - ((COMMAND.TOTAL.PAGES% - 1) *          \
6056: c069:             COMMANDS.PER.PAGE%)
6057: c069: 
6058: c069:     ENDIF
6059: c071: 
6060: c071:     CLOSE CLLOG.SESS.NUM%
6061: c085: 
6062: c085:     RETURN
6063: c095: 
6064: c095: \***********************************************************************
6065: c095: \***
6066: c095: \***    GET.COMMAND.DETAILS
6067: c095: \***
6068: c095: \***********************************************************************
6069: c095: GET.COMMAND.DETAILS:
6070: c0a5: 
6071: c0a5:     END.OF.SESSION = FALSE
6072: c0b7: 
6073: c0b7:     DIM COMMAND.RECORD$(CLLOG.MAX.RECORDS%)
6074: c0e5: 
6075: c0e5:     HEADER.COUNT%  = 0                                                  !KMW
6076: c0f3:     COMMAND.COUNT% = 0
6077: c101: 
6078: c101:     WHILE NOT END.OF.SESSION
6079: c10b: 
6080: c10b:         CLLOG.RC% = READ.CLLOG
6081: c11b: 
6082: c11b:         ! IF end of CLLOG file reached
6083: c11b:         IF NOT CLLOG.RC% = 0 THEN BEGIN
6084: c12a:             END.OF.FILE = TRUE
6085: c13c:             END.OF.SESSION = TRUE
6086: c150:         ENDIF ELSE BEGIN
6087: c158:             GOSUB PROCESS.COMMAND.RECORD
6088: c16a:         ENDIF
6089: c172: 
6090: c172:     WEND
6091: c181: 
6092: c181:     ! End of session event
6093: c181:     IF EVENT.FORMAT% = 29 THEN BEGIN
6094: c196: 
6095: c196:         M% = COMMAND.TIME.RANGE%
6096: c1a8: 
6097: c1a8:         ! Get specified time range (minutes)
6098: c1a8:         WHILE M% > 0
6099: c1b2:             CALL LAST.TIME(SESSION.HOUR%,SESSION.MIN%)
6100: c1ca:             M% = M% - 1
6101: c1d6:         WEND
6102: c1e5: 
6103: c1e5:         ! Check a range of +/- specified time range
6104: c1e5:         M% = (COMMAND.TIME.RANGE% * 2) + 1
6105: c1fa: 
6106: c1fa:         WHILE M% > 0
6107: c204: 
6108: c204:             IF (EVENT.HOUR% = SESSION.HOUR%) AND                    \
6109: c232:                (EVENT.MIN% = SESSION.MIN%) THEN BEGIN
6110: c232:                 M% = -1 ! Definite match found
6111: c242:             ENDIF ELSE BEGIN
6112: c24a:                 M% = M% - 1
6113: c256:                 ! Get time in one minute
6114: c256:                 CALL NEXT.TIME(SESSION.HOUR%,SESSION.MIN%)
6115: c26e:             ENDIF
6116: c276: 
6117: c276:         WEND
6118: c288: 
6119: c288:         ! IF NOT a definite match
6120: c288:         IF M% = 0 THEN BEGIN
6121: c297:             ! Go back and try again
6122: c297:             END.OF.SESSION = TRUE
6123: c2a9:             END.OF.FILE = FALSE
6124: c2bb:             SESSION.FOUND = FALSE
6125: c2cf:         ENDIF ELSE BEGIN
6126: c2d7:             END.OF.FILE = TRUE                                          !EMW
6127: c2e9:             SESSION.FOUND = TRUE
6128: c2fb:         ENDIF
6129: c303: 
6130: c303:     ENDIF
6131: c30b: 
6132: c30b:     RETURN
6133: c31b: 
6134: c31b: \***********************************************************************
6135: c31b: \***
6136: c31b: \***    PROCESS.COMMAND.RECORD
6137: c31b: \***
6138: c31b: \***********************************************************************
6139: c31b: PROCESS.COMMAND.RECORD:
6140: c32b: 
6141: c32b:     IF LEFT$(CLLOG.RECORD$,1) = CHR$(0AH) THEN BEGIN
6142: c363: 
6143: c363:         END.OF.SESSION = TRUE
6144: c375:         END.OF.FILE = TRUE
6145: c38a: 
6146: c38a:     ENDIF ELSE BEGIN
6147: c392: 
6148: c392:         ! IF the command lines are from AUTOEXEC.BAT
6149: c392:         IF (NOT (HEADER.COUNT% = 2)) AND                            \
6150: c3e4:            (MATCH("ADX_UPGM:AUTOEXEC.BAT",                          \
6151: c3e4:                   CLLOG.RECORD$,1) OR                               \
6152: c3e4:             MATCH("ADX_UPGM:########.BAT",                          \
6153: c3e4:                   CLLOG.RECORD$,1)) THEN BEGIN
6154: c3e4: 
6155: c3e4:             HEADER.COUNT% = HEADER.COUNT% + 1
6156: c3f0: 
6157: c3f0:             IF HEADER.COUNT% = 1 THEN BEGIN
6158: c402: 
6159: c402:                 COMMAND.COUNT% = COMMAND.COUNT% + 1
6160: c40e: 
6161: c40e:                 COMMAND.DATE$ =                                     \
6162: c47c:                     MID$(CLLOG.RECORD$,20,2) + "/" +                \
6163: c47c:                     MID$(CLLOG.RECORD$,17,2) + "/" +                \
6164: c47c:                     MID$(CLLOG.RECORD$,23,4)
6165: c47c: 
6166: c47c:                 COMMAND.TIME$ =                                     \
6167: c4c7:                     MID$(CLLOG.RECORD$,1,2) + ":" +                 \
6168: c4c7:                     MID$(CLLOG.RECORD$,4,2)
6169: c4c7: 
6170: c4c7:                 COMMAND.RECORD$(COMMAND.COUNT%) =                   \
6171: c504:                     COMMAND.DATE$ + " " +                           \
6172: c504:                     COMMAND.TIME$ + " " +                           \
6173: c504:                     "*** Command session started ***"
6174: c504: 
6175: c504:                 ! IF start of session event
6176: c504:                 IF EVENT.FORMAT% = 28 THEN BEGIN
6177: c519: 
6178: c519:                     SESSION.HOUR% = VAL(MID$(CLLOG.RECORD$,1,2))
6179: c542:                     SESSION.MIN% =  VAL(MID$(CLLOG.RECORD$,4,2))
6180: c56b: 
6181: c56b:                     M% = COMMAND.TIME.RANGE%
6182: c57d: 
6183: c57d:                     ! Get specified time range (minutes)
6184: c57d:                     WHILE M% > 0
6185: c587:                         CALL LAST.TIME(SESSION.HOUR%,SESSION.MIN%)
6186: c59f:                         M% = M% - 1
6187: c5ab:                     WEND
6188: c5ba: 
6189: c5ba:                     ! Check a range of +/- specified time range
6190: c5ba:                     M% = (COMMAND.TIME.RANGE% * 2) + 1
6191: c5cf: 
6192: c5cf:                     WHILE M% > 0
6193: c5d9: 
6194: c5d9:                         IF (EVENT.HOUR% = SESSION.HOUR%) AND        \
6195: c607:                            (EVENT.MIN% = SESSION.MIN%) THEN BEGIN
6196: c607:                             M% = -1 ! Definite match found
6197: c617:                         ENDIF ELSE BEGIN
6198: c61f:                             M% = M% - 1
6199: c62b:                             ! Get time in one minute
6200: c62b:                             CALL NEXT.TIME(SESSION.HOUR%,           \
6201: c643:                                            SESSION.MIN%)
6202: c643:                         ENDIF
6203: c64b: 
6204: c64b:                     WEND
6205: c65d: 
6206: c65d:                     ! IF NOT a definite match
6207: c65d:                     IF M% = 0 THEN BEGIN
6208: c66c:                         ! Go back and try again
6209: c66c:                         END.OF.SESSION = TRUE
6210: c67e:                         END.OF.FILE = FALSE
6211: c690:                         SESSION.FOUND = FALSE
6212: c6a4:                     ENDIF ELSE BEGIN
6213: c6ac:                         END.OF.FILE = TRUE                              !EMW
6214: c6be:                         SESSION.FOUND = TRUE
6215: c6d0:                     ENDIF
6216: c6d8: 
6217: c6d8:                 ENDIF
6218: c6e0: 
6219: c6e0:             ENDIF
6220: c6eb: 
6221: c6eb:         ! IF command lines found
6222: c6eb:         ENDIF ELSE IF HEADER.COUNT% = 2 THEN BEGIN
6223: c6fd: 
6224: c6fd:             COMMAND.COUNT% = COMMAND.COUNT% + 1
6225: c709: 
6226: c709:             COMMAND.DATE$ =                                         \
6227: c777:                 MID$(CLLOG.RECORD$,20,2) + "/" +                    \
6228: c777:                 MID$(CLLOG.RECORD$,17,2) + "/" +                    \
6229: c777:                 MID$(CLLOG.RECORD$,23,4)
6230: c777: 
6231: c777:             COMMAND.TIME$ =                                         \
6232: c7c2:                 MID$(CLLOG.RECORD$,1,2) + ":" +                     \
6233: c7c2:                 MID$(CLLOG.RECORD$,4,2)
6234: c7c2: 
6235: c7c2:             ! IF editor control application                             !KMW
6236: c7c2:             IF MATCH(EDITOR.PATHNAME$,CLLOG.RECORD$,1) THEN BEGIN       !KMW
6237: c7ee:                                                                         !KMW
6238: c7ee:                 ! Get editor type                                       !KMW
6239: c7ee:                 EDITOR.TYPE$ = MID$(CLLOG.RECORD$,53,1)                 !KMW
6240: c815:                                                                         !KMW
6241: c815:                 IF EDITOR.TYPE$ = "D" THEN BEGIN                        !KMW
6242: c833:                     EDITOR.NAME$ = "DREDIX"                             !KMW
6243: c84c:                 ENDIF ELSE IF EDITOR.TYPE$ = "V" THEN BEGIN             !KMW
6244: c86a:                     EDITOR.NAME$ = "VEDIT"                              !KMW
6245: c883:                 ENDIF ELSE IF EDITOR.TYPE$ = "X" THEN BEGIN             !KMW
6246: c8a1:                     EDITOR.NAME$ = "XE"                                 !KMW
6247: c8b8:                 ENDIF                                                   !KMW
6248: c8c0:                                                                         !KMW
6249: c8c0:                 ! Substitute text editor name                           !KMW
6250: c8c0:                 CLLOG.RECORD$ =                                     \   !KMW
6251: c919:                     SUBSTITUTE$(CLLOG.RECORD$,                      \   !KMW
6252: c919:                                 EDITOR.PATHNAME$ + "," +            \   !KMW
6253: c919:                                 EDITOR.TYPE$,                       \   !KMW
6254: c919:                                 EDITOR.NAME$)                           !KMW
6255: c919:                                                                         !KMW
6256: c919:             ENDIF                                                       !KMW
6257: c921:                                                                         !KMW
6258: c921:             COMMAND.RECORD$(COMMAND.COUNT%) =                       \
6259: c96e:                 COMMAND.DATE$ + " " +                               \
6260: c96e:                 COMMAND.TIME$ + " " +                               \
6261: c96e:                 MID$(CLLOG.RECORD$,31,80)
6262: c96e: 
6263: c96e:             SESSION.HOUR% = VAL(MID$(CLLOG.RECORD$,1,2))
6264: c997:             SESSION.MIN% =  VAL(MID$(CLLOG.RECORD$,4,2))
6265: c9c0: 
6266: c9c0:         ENDIF
6267: c9c8: 
6268: c9c8:     ENDIF
6269: c9d0: 
6270: c9d0:     RETURN
6271: c9e0: 
6272: c9e0: \***********************************************************************
6273: c9e0: \***
6274: c9e0: \***    PROCESS.COMMAND.SCREEN                                          !FMW
6275: c9e0: \***
6276: c9e0: \***********************************************************************
6277: c9e0: PROCESS.COMMAND.SCREEN:                                                 !FMW
6278: c9f0: 
6279: c9f0:     GOSUB INITIALISE.COMMAND.SCREEN                                     !FMW
6280: ca02: 
6281: ca02:     ! IF 'command started' event log
6282: ca02:     IF EVENT.FORMAT% = 28 THEN BEGIN
6283: ca14: 
6284: ca14:         ! First page
6285: ca14:         COMMAND.PAGE% = 1
6286: ca22:         ! First field on first page
6287: ca22:         CURRENT.FIELD% = COMMAND.START.FIELD%                           !FMW
6288: ca36: 
6289: ca36:     ! IF 'command ended' event log
6290: ca36:     ENDIF ELSE BEGIN
6291: ca3e: 
6292: ca3e:         ! Calculate last field on last page
6293: ca3e:         COMMAND.LAST.FIELD% = COMMAND.LAST.PAGE% + 2                    !FMW
6294: ca4f: 
6295: ca4f:         ! Last page
6296: ca4f:         COMMAND.PAGE% = COMMAND.TOTAL.PAGES%
6297: ca5d:         ! Last field on last page
6298: ca5d:         CURRENT.FIELD% = COMMAND.LAST.FIELD%                            !FMW
6299: ca6f:     ENDIF
6300: ca77: 
6301: ca77:     WHILE NOT COMMAND.EXIT.PRESSED                                      !FMW
6302: ca82: 
6303: ca82:         CALL DM.CURRENT.FIELD(CURRENT.FIELD%)
6304: ca9a: 
6305: ca9a:         GOSUB DISPLAY.COMMAND.PAGE                                      !FMW
6306: caac: 
6307: caac:         KEY% = DM.PROCESS.SCREEN(COMMAND.START.FIELD%,              \   !FMW
6308: cad4:                                  COMMAND.LAST.FIELD%,               \   !FMW
6309: cad4:                                  FALSE)
6310: cad4: 
6311: cad4:         ! IF quit key                                                   !HMW
6312: cad4:         IF KEY% = F3.KEY% THEN BEGIN
6313: caec: 
6314: caec:             COMMAND.EXIT.PRESSED = TRUE                                 !FMW
6315: cafe: 
6316: cafe:             GOSUB INITIALISE.DETAIL.SCREEN
6317: cb13: 
6318: cb13:         ! IF escape key                                                 !HMW
6319: cb13:         ENDIF ELSE IF KEY% = ESC.KEY% THEN BEGIN
6320: cb2b: 
6321: cb2b:             COMMAND.EXIT.PRESSED = TRUE                                 !FMW
6322: cb3d:             DETAIL.EXIT.PRESSED = TRUE
6323: cb4f:             SUMMARY.EXIT.PRESSED = TRUE
6324: cb61: 
6325: cb61:             GOSUB INITIALISE.SELECTION.SCREEN
6326: cb76: 
6327: cb76:         ! IF cursor up                                                  !HMW
6328: cb76:         ENDIF ELSE IF KEY% = PREV.KEY% THEN BEGIN
6329: cb8e: 
6330: cb8e:             IF COMMAND.PAGE% > 1 THEN BEGIN
6331: cb9d:                 ! Move to the last row on the previous page
6332: cb9d:                 CURRENT.FIELD% = 20 ! Will always be 20
6333: cbad:                 COMMAND.PAGE% = COMMAND.PAGE% - 1
6334: cbbb:             ENDIF ELSE BEGIN
6335: cbc3:                 ! No previous page exists
6336: cbc3:                 CALL DM.FOCUS("","MESSAGE(74,'')")
6337: cbdb:                 CURRENT.FIELD% = COMMAND.START.FIELD%                   !FMW
6338: cbed:             ENDIF
6339: cbf8: 
6340: cbf8:         ! IF cursor down                                                !HMW
6341: cbf8:         ENDIF ELSE IF KEY% = NEXT.KEY% THEN BEGIN
6342: cc10: 
6343: cc10:             ! IF this is not the last page
6344: cc10:             IF COMMAND.PAGE% < COMMAND.TOTAL.PAGES% THEN BEGIN
6345: cc21:                 ! Move to the first row on the next page
6346: cc21:                 CURRENT.FIELD% = 3 ! Will always be 3
6347: cc31:                 COMMAND.PAGE% = COMMAND.PAGE% + 1
6348: cc3f:             ENDIF ELSE BEGIN
6349: cc47:                 ! No next page exists
6350: cc47:                 CALL DM.FOCUS("","MESSAGE(75,'')")
6351: cc5f:                 CURRENT.FIELD% = COMMAND.LAST.FIELD%                    !FMW
6352: cc71:             ENDIF
6353: cc7c: 
6354: cc7c:         ! IF page up                                                    !HMW
6355: cc7c:         ENDIF ELSE IF KEY% = F7.KEY% OR                             \
6356: ccb0:                       KEY% = PGUP.KEY% THEN BEGIN
6357: ccb0: 
6358: ccb0:             IF COMMAND.PAGE% = 1 THEN BEGIN
6359: ccbf: 
6360: ccbf:                 CURRENT.FIELD% = DM.CURRENT.FIELD(0)
6361: ccd7: 
6362: ccd7:                 ! No previous page exists
6363: ccd7:                 CALL DM.FOCUS("","MESSAGE(74,'')")
6364: ccf1: 
6365: ccf1:             ENDIF ELSE BEGIN
6366: ccf9:                 COMMAND.PAGE% = COMMAND.PAGE% - 1
6367: cd05:                 CURRENT.FIELD% = COMMAND.START.FIELD%                   !FMW
6368: cd17:             ENDIF
6369: cd22: 
6370: cd22:         ! IF page down                                                  !HMW
6371: cd22:         ENDIF ELSE IF KEY% = F8.KEY% OR                             \
6372: cd59:                       KEY% = PGDN.KEY% THEN BEGIN
6373: cd59: 
6374: cd59:             IF COMMAND.PAGE% = COMMAND.TOTAL.PAGES% THEN BEGIN
6375: cd6a: 
6376: cd6a:                 CURRENT.FIELD% = DM.CURRENT.FIELD(0)
6377: cd82: 
6378: cd82:                 ! No next page exists
6379: cd82:                 CALL DM.FOCUS("","MESSAGE(75,'')")
6380: cd9c: 
6381: cd9c:             ENDIF ELSE BEGIN
6382: cda4:                 COMMAND.PAGE% = COMMAND.PAGE% + 1
6383: cdb0:                 CURRENT.FIELD% = COMMAND.START.FIELD%                   !FMW
6384: cdc2:             ENDIF
6385: cdcc: 
6386: cdcc:         ENDIF ELSE BEGIN
6387: cdd4:             CURRENT.FIELD% = DM.CURRENT.FIELD(0)
6388: cdec:         ENDIF
6389: cdf4: 
6390: cdf4:     WEND
6391: ce06: 
6392: ce06:     RETURN
6393: ce16: 
6394: ce16: \***********************************************************************
6395: ce16: \***
6396: ce16: \***    DISPLAY.COMMAND.PAGE                                            !FMW
6397: ce16: \***
6398: ce16: \***********************************************************************
6399: ce16: DISPLAY.COMMAND.PAGE:                                                   !FMW
6400: ce26: 
6401: ce26:     ! IF first page
6402: ce26:     IF COMMAND.PAGE% = 1 THEN BEGIN
6403: ce35:         ! Hide page up function key
6404: ce35:         CALL DM.HIDE.FN.KEY(7)
6405: ce48:     ENDIF ELSE BEGIN
6406: ce50:         ! Display page up function key
6407: ce50:         CALL DM.SHOW.FN.KEY(7,"PGUP")
6408: ce66:     ENDIF
6409: ce6e: 
6410: ce6e:     ! IF last page
6411: ce6e:     IF COMMAND.PAGE% = COMMAND.TOTAL.PAGES% THEN BEGIN
6412: ce7f: 
6413: ce7f:         ! Hide page down function key
6414: ce7f:         CALL DM.HIDE.FN.KEY(8)
6415: ce90: 
6416: ce90:         COMMAND.LAST.FIELD% = COMMAND.LAST.PAGE% + 2
6417: cea1: 
6418: cea1:         ! For the last page, set results per page to the remainder
6419: cea1:         COMMAND.THIS.PAGE% = COMMAND.LAST.PAGE%
6420: ceb1: 
6421: ceb1:     ENDIF ELSE BEGIN
6422: ceb9: 
6423: ceb9:         ! Display page down function key
6424: ceb9:         CALL DM.SHOW.FN.KEY(8,"PGDN")
6425: cecf: 
6426: cecf:         COMMAND.LAST.FIELD% = COMMAND.END.FIELD%                        !FMW
6427: cedd: 
6428: cedd:         ! Set results per page to
6429: cedd:         ! the maximum results allowed per page
6430: cedd:         COMMAND.THIS.PAGE% = COMMANDS.PER.PAGE%
6431: ceef: 
6432: ceef:     ENDIF
6433: cef7: 
6434: cef7:     FOR I% = 1 TO COMMAND.THIS.PAGE%
6435: cf08: 
6436: cf08:         FIELD.INDEX% = I% + 2
6437: cf19: 
6438: cf19:         COMMAND.INDEX% =                                            \
6439: cf33:             ((COMMAND.PAGE% - 1) * COMMANDS.PER.PAGE%) + I%
6440: cf33: 
6441: cf33:         FIELD$(FIELD.INDEX%) = COMMAND.RECORD$(COMMAND.INDEX%)
6442: cf6a: 
6443: cf6a:         CALL DM.VISIBLE(STR$(FIELD.INDEX%),"TRUE")
6444: cf97: 
6445: cf97:         CALL DM.RO.FIELD(FIELD.INDEX%)
6446: cfaa: 
6447: cfaa:     NEXT I%
6448: cfc5: 
6449: cfc5:     FIELD$(U0405.PAGE%) =                                           \
6450: d04e:         RIGHT$((STRING$(7," ") +                                    \
6451: d04e:         "Page " + STR$(COMMAND.PAGE%) +                             \
6452: d04e:         " of "  + STR$(COMMAND.TOTAL.PAGES%)),18)
6453: d04e: 
6454: d04e:     ! IF results per page is not a full page
6455: d04e:     IF COMMAND.THIS.PAGE% < COMMANDS.PER.PAGE% THEN BEGIN
6456: d066: 
6457: d066:         ! For each remaining row
6458: d066:         FOR I% = (COMMAND.THIS.PAGE% + 1) TO COMMANDS.PER.PAGE%
6459: d077: 
6460: d077:             FIELD.INDEX% = I% + 2
6461: d088: 
6462: d088:             ! Clear the row
6463: d088:             FIELD$(FIELD.INDEX%) = STRING$(80," ")
6464: d0b4: 
6465: d0b4:             ! Hide the field
6466: d0b4:             CALL DM.VISIBLE(STR$(FIELD.INDEX%),"FALSE")
6467: d0e1: 
6468: d0e1:         NEXT I%
6469: d100: 
6470: d100:     ENDIF
6471: d108: 
6472: d108:     RETURN
6473: d118: 
6474: d118: \***********************************************************************
6475: d118: \***
6476: d118: \***    INITIALISE.COMMAND.SCREEN                                       !FMW
6477: d118: \***
6478: d118: \***********************************************************************
6479: d118: INITIALISE.COMMAND.SCREEN:                                              !FMW
6480: d128: 
6481: d128:     CALL DM.SHOW.SCREEN(5,"",5,5)
6482: d142: 
6483: d142:     COMMAND.START.FIELD% = 3                                            !FMW
6484: d150:     COMMAND.END.FIELD%   = 20                                           !FMW
6485: d15e: 
6486: d15e:     COMMAND.EXIT.PRESSED = FALSE                                        !FMW
6487: d170: 
6488: d170:     RETURN
6489: d180: 
6490: d180: \***********************************************************************!FMW
6491: d180: \***                                                                    !FMW
6492: d180: \***    GET.UTILS.SESSION                                               !FMW
6493: d180: \***                                                                    !FMW
6494: d180: \***********************************************************************!FMW
6495: d180: GET.UTILS.SESSION:                                                      !FMW
6496: d190:                                                                         !FMW
6497: d190:     UTILS.TOTAL.PAGES% = 2                                              !FMW
6498: d19e:                                                                         !FMW
6499: d19e:     SECTOR.FOUND = FALSE                                                !FMW
6500: d1b0:                                                                         !FMW
6501: d1b0:     DIM ULOG.RECORD$(4)                                                 !FMW
6502: d1df:                                                                         !FMW
6503: d1df:     OPEN ULOG.FILE.NAME$ AS ULOG.SESS.NUM%                              !FMW
6504: d206:                                                                         !FMW
6505: d206:     END.OF.FILE = FALSE                                                 !FMW
6506: d218:                                                                         !FMW
6507: d218:     WHILE NOT END.OF.FILE AND NOT SECTOR.FOUND                          !FMW
6508: d223:                                                                         !FMW
6509: d223:         ! Read next UTILS log record                                    !FMW
6510: d223:         ULOG.RC% = READ.ULOG                                            !FMW
6511: d233:                                                                         !FMW
6512: d233:         ! IF end of UTILS log file reached                              !FMW
6513: d233:         IF NOT ULOG.RC% = 0 THEN BEGIN                                  !FMW
6514: d242:             END.OF.FILE = TRUE                                          !FMW
6515: d257:         ENDIF ELSE BEGIN                                                !FMW
6516: d25f:                                                                         !FMW
6517: d25f:             ! IF date match found                                       !FMW
6518: d25f:             IF LEFT$(ULOG.RECORD$(1),6) = EVENT.DATE$ THEN BEGIN        !FMW
6519: d2a7:                                                                         !FMW
6520: d2a7:                 ! Get sequence number from event log                    !FMW
6521: d2a7:                 SEQ.NUM% = GETN2(EVENT.UNIQUE.DATA$,8)                  !FMW
6522: d2c7:                                                                         !FMW
6523: d2c7:                 ! IF UTILS log file sequence number match found         !FMW
6524: d2c7:                 IF SEQ.NUM% = VAL(RIGHT$(ULOG.RECORD$(1),5)) THEN BEGIN !FMW
6525: d319:                     SECTOR.FOUND = TRUE                                 !FMW
6526: d32b:                 ENDIF                                                   !FMW
6527: d333:                                                                         !FMW
6528: d333:             ENDIF                                                       !FMW
6529: d33b:                                                                         !FMW
6530: d33b:         ENDIF                                                           !FMW
6531: d343:                                                                         !FMW
6532: d343:     WEND                                                                !FMW
6533: d35d:                                                                         !FMW
6534: d35d:     CLOSE ULOG.SESS.NUM%                                                !FMW
6535: d371:                                                                         !FMW
6536: d371: RETURN                                                                  !FMW
6537: d381:                                                                         !FMW
6538: d381: \***********************************************************************!FMW
6539: d381: \***                                                                    !FMW
6540: d381: \***    PROCESS.UTILS.SCREEN                                            !FMW
6541: d381: \***                                                                    !FMW
6542: d381: \***********************************************************************!FMW
6543: d381: PROCESS.UTILS.SCREEN:                                                   !FMW
6544: d391:                                                                         !FMW
6545: d391:     GOSUB INITIALISE.UTILS.SCREEN                                       !FMW
6546: d3a3:                                                                         !FMW
6547: d3a3:     ! First page                                                        !FMW
6548: d3a3:     UTILS.PAGE% = 1                                                     !FMW
6549: d3b1:                                                                         !FMW
6550: d3b1:     WHILE NOT UTILS.EXIT.PRESSED                                        !FMW
6551: d3bc:                                                                         !FMW
6552: d3bc:         GOSUB DISPLAY.UTILS.PAGE                                        !FMW
6553: d3ce:                                                                         !FMW
6554: d3ce:         KEY% = DM.PROCESS.SCREEN(UTILS.START.FIELD%,                \   !FMW
6555: d3f6:                                  UTILS.END.FIELD%,                  \   !FMW
6556: d3f6:                                  FALSE)                                 !FMW
6557: d3f6:                                                                         !FMW
6558: d3f6:         ! IF quit key                                                   !HMW
6559: d3f6:         IF KEY% = F3.KEY% THEN BEGIN                                    !FMW
6560: d40e:                                                                         !FMW
6561: d40e:             UTILS.EXIT.PRESSED = TRUE                                   !FMW
6562: d420:                                                                         !FMW
6563: d420:             GOSUB INITIALISE.DETAIL.SCREEN                              !FMW
6564: d435:                                                                         !FMW
6565: d435:         ! IF escape key                                                 !HMW
6566: d435:         ENDIF ELSE IF KEY% = ESC.KEY% THEN BEGIN                        !FMW
6567: d44d:                                                                         !FMW
6568: d44d:             UTILS.EXIT.PRESSED = TRUE                                   !FMW
6569: d45f:             DETAIL.EXIT.PRESSED = TRUE                                  !FMW
6570: d471:             SUMMARY.EXIT.PRESSED = TRUE                                 !FMW
6571: d483:                                                                         !FMW
6572: d483:             GOSUB INITIALISE.SELECTION.SCREEN                           !FMW
6573: d498:                                                                         !FMW
6574: d498:         ! IF cursor up OR page up                                       !HMW
6575: d498:         ENDIF ELSE IF KEY% = PREV.KEY% OR                           \   !FMW
6576: d4e2:                       KEY% = F7.KEY% OR                             \   !FMW
6577: d4e2:                       KEY% = PGUP.KEY% THEN BEGIN                       !FMW
6578: d4e2:                                                                         !FMW
6579: d4e2:             IF UTILS.PAGE% = 2 THEN BEGIN                               !FMW
6580: d4f1:                 UTILS.PAGE% = 1                                         !FMW
6581: d501:             ENDIF ELSE BEGIN                                            !FMW
6582: d509:                 ! No previous page exists                               !FMW
6583: d509:                 CALL DM.FOCUS("","MESSAGE(74,'')")                      !FMW
6584: d521:             ENDIF                                                       !FMW
6585: d52c:                                                                         !FMW
6586: d52c:         ! if Cursor down OR page down                                   !HMW
6587: d52c:         ENDIF ELSE IF KEY% = NEXT.KEY% OR                           \   !FMW
6588: d576:                       KEY% = F8.KEY% OR                             \   !FMW
6589: d576:                       KEY% = PGDN.KEY% THEN BEGIN                       !FMW
6590: d576:                                                                         !FMW
6591: d576:             IF UTILS.PAGE% = 1 THEN BEGIN                               !FMW
6592: d585:                 UTILS.PAGE% = 2                                         !FMW
6593: d595:             ENDIF ELSE BEGIN                                            !FMW
6594: d59d:                 ! No next page exists                                   !FMW
6595: d59d:                 CALL DM.FOCUS("","MESSAGE(75,'')")                      !FMW
6596: d5b5:             ENDIF                                                       !FMW
6597: d5bd:                                                                         !FMW
6598: d5bd:         ENDIF                                                           !FMW
6599: d5c5:                                                                         !FMW
6600: d5c5:     WEND                                                                !FMW
6601: d5d7:                                                                         !FMW
6602: d5d7:     RETURN                                                              !FMW
6603: d5e7:                                                                         !FMW
6604: d5e7: \***********************************************************************!FMW
6605: d5e7: \***                                                                    !FMW
6606: d5e7: \***    INITIALISE.UTILS.SCREEN                                         !FMW
6607: d5e7: \***                                                                    !FMW
6608: d5e7: \***********************************************************************!FMW
6609: d5e7: INITIALISE.UTILS.SCREEN:                                                !FMW
6610: d5f7:                                                                         !FMW
6611: d5f7:     CALL DM.SHOW.SCREEN(12,"",12,12)                                    !FMW
6612: d611:                                                                         !FMW
6613: d611:     UTILS.START.FIELD% = 1                                              !FMW
6614: d61f:     UTILS.END.FIELD%   = 1                                              !FMW
6615: d62d:                                                                         !FMW
6616: d62d:     UTILS.EXIT.PRESSED = FALSE                                          !FMW
6617: d63f:                                                                         !FMW
6618: d63f:     RETURN                                                              !FMW
6619: d64f:                                                                         !FMW
6620: d64f: \***********************************************************************!FMW
6621: d64f: \***                                                                    !FMW
6622: d64f: \***    DISPLAY.UTILS.PAGE                                              !FMW
6623: d64f: \***                                                                    !FMW
6624: d64f: \***********************************************************************!FMW
6625: d64f: DISPLAY.UTILS.PAGE:                                                     !FMW
6626: d65f:                                                                         !FMW
6627: d65f:     FIELD$(U0412.PAGE%) =                                           \   !FMW
6628: d6e8:         RIGHT$((STRING$(7," ") +                                    \   !FMW
6629: d6e8:         "Page " + STR$(UTILS.PAGE%) +                               \   !FMW
6630: d6e8:         " of "  + STR$(UTILS.TOTAL.PAGES%)),18)                         !FMW
6631: d6e8:                                                                         !FMW
6632: d6e8:     CALL DISPLAY.SECTOR(UTILS.PAGE%)                                    !FMW
6633: d70f:                                                                         !FMW
6634: d70f:     RETURN                                                              !FMW
6635: d71f:                                                                         !FMW
6636: d71f: \***********************************************************************
6637: d71f: \***
6638: d71f: \***    INITIALISE.DETAIL.SCREEN
6639: d71f: \***
6640: d71f: \***********************************************************************
6641: d71f: INITIALISE.DETAIL.SCREEN:
6642: d72f: 
6643: d72f:     CALL DM.SHOW.SCREEN(3,"",3,3)
6644: d749: 
6645: d749:     DETAIL.START.FIELD% = 1
6646: d757:     DETAIL.END.FIELD%   = 1
6647: d765: 
6648: d765:     DETAIL.EXIT.PRESSED = FALSE
6649: d777: 
6650: d777:     RETURN
6651: d787: 
6652: d787: \***********************************************************************
6653: d787: \***
6654: d787: \***    DISPLAY.DETAIL.PAGE
6655: d787: \***
6656: d787: \***********************************************************************
6657: d787: DISPLAY.DETAIL.PAGE:
6658: d797: 
6659: d797:     ! IF last page
6660: d797:     IF RESULTS.PAGE% = RESULTS.TOTAL.PAGES% THEN BEGIN
6661: d7af: 
6662: d7af:         SUMMARY.LAST.FIELD% = RESULTS.LAST.PAGE% + 2
6663: d7c4: 
6664: d7c4:         ! For the last page, set results per page to the remainder
6665: d7c4:         RESULTS.THIS.PAGE% = RESULTS.LAST.PAGE%
6666: d7dc: 
6667: d7dc:     ENDIF ELSE BEGIN
6668: d7e4: 
6669: d7e4:         SUMMARY.LAST.FIELD% = SUMMARY.END.FIELD%
6670: d7f2: 
6671: d7f2:         ! Set results per page to
6672: d7f2:         ! the maximum results allowed per page
6673: d7f2:         RESULTS.THIS.PAGE% = RESULTS.PER.PAGE%
6674: d808: 
6675: d808:     ENDIF
6676: d810: 
6677: d810:     I% = CURRENT.FIELD% - 2
6678: d825: 
6679: d825:     RESULTS.INDEX% = RESULTS.COUNT% -                               \
6680: d859:                     (((RESULTS.PAGE% - 1) *                         \
6681: d859:                     RESULTS.PER.PAGE%) + (I% - 1))
6682: d859: 
6683: d859:     EVENT.RECORD$ = DETAIL.RECORD$(RESULTS.INDEX%)
6684: d883:     GOSUB GET.EVENT.DETAILS
6685: d895: 
6686: d895:     ! IF start or stop program system event
6687: d895:     IF EVENT.FORMAT% = 28 OR EVENT.FORMAT% = 29 THEN BEGIN
6688: d8c1:         ! Get type - foreground or background
6689: d8c1:         TYPE$ = STR$(VAL(UNPACK$(MID$(EVENT.UNIQUE.DATA$,2,1))))
6690: d910:     ENDIF
6691: d918: 
6692: d918:     COMMAND.SESSION = FALSE                                             !FMW
6693: d92a:     UTILS.SESSION   = FALSE                                             !FMW
6694: d93c:     
6695: d93c:     ! IF foreground command window start or stopped
6696: d93c:     IF PROGRAM$ = "COMMAND" AND                                     \
6697: d9b1:        TYPE$ = "0" AND                                              \
6698: d9b1:        (EVENT.MESSAGE.NUMBER% = 619 OR                              \
6699: d9b1:        EVENT.MESSAGE.NUMBER% = 620) THEN BEGIN
6700: d9b1:         COMMAND.SESSION = TRUE
6701: d9c3:         ! Display CLOG function key
6702: d9c3:         CALL DM.SHOW.FN.KEY(4,"CLOG")
6703: d9d9:     ENDIF
6704: d9e1: 
6705: d9e1:     ! IF UTILS update application event                                 !FMW
6706: d9e1:     IF EVENT.MESSAGE.GROUP$ = "A" AND                               \   !FMW
6707: da1e:        EVENT.MESSAGE.NUMBER% = 991 THEN BEGIN                           !FMW
6708: da1e:         UTILS.SESSION = TRUE                                            !FMW
6709: da30:         ! Display VIEW function key                                     !FMW
6710: da30:         CALL DM.SHOW.FN.KEY(4,"VIEW")                                   !FMW
6711: da46:     ENDIF                                                               !FMW
6712: da4e: 
6713: da4e:     ! IF we don't need the F4 key highlighting                          !FMW
6714: da4e:     IF NOT COMMAND.SESSION AND NOT UTILS.SESSION THEN BEGIN             !FMW
6715: da65:         ! Hide F4 function key                                          !FMW
6716: da65:         CALL DM.HIDE.FN.KEY(4)                                          !FMW
6717: da76:     ENDIF                                                               !FMW
6718: da7e: 
6719: da7e:     IF APPLICATION.EVENT THEN BEGIN
6720: da90:         ! IF terminal application
6721: da90:         IF PROGRAM$ = "EALTSTTL" THEN BEGIN
6722: daae:             CALL PSU0404
6723: dabe:         ! IF GSA controller application
6724: dabe:         ENDIF ELSE IF LEFT$(PROGRAM$,3) = "EAL" OR                  \
6725: db3b:                       LEFT$(PROGRAM$,3) = "QXL" THEN BEGIN
6726: db3b:             CALL PSU0403
6727: db4a:         ! IF other controller application
6728: db4a:         ENDIF ELSE BEGIN
6729: db52:             CALL PSU0402
6730: db5f:         ENDIF
6731: db69:     ENDIF ELSE BEGIN
6732: db71:         CALL PSU0401
6733: db7e:     ENDIF
6734: db86: 
6735: db86:     RETURN
6736: db96: 
6737: db96: \***********************************************************************
6738: db96: \***
6739: db96: \***    PROCESS.APPLICATION.SCREEN
6740: db96: \***
6741: db96: \***********************************************************************
6742: db96: PROCESS.APPLICATION.SCREEN:
6743: dba6: 
6744: dba6:     APPLICATION.PAGE% = 1
6745: dbb4: 
6746: dbb4:     GOSUB INITIALISE.APPLICATION.SCREEN
6747: dbc6: 
6748: dbc6:     CURRENT.FIELD% = APPLICATION.START.FIELD%
6749: dbd8: 
6750: dbd8:     WHILE NOT APPLICATION.EXIT.PRESSED
6751: dbe3: 
6752: dbe3:         CALL DM.CURRENT.FIELD(CURRENT.FIELD%)
6753: dbfb: 
6754: dbfb:         GOSUB DISPLAY.APPLICATION.PAGE
6755: dc0d: 
6756: dc0d:         KEY% = DM.PROCESS.SCREEN(APPLICATION.START.FIELD%,          \
6757: dc35:                                  APPLICATION.LAST.FIELD%,           \
6758: dc35:                                  TRUE)
6759: dc35: 
6760: dc35:         ! IF quit key                                                   !HMW
6761: dc35:         IF KEY% = F3.KEY% THEN BEGIN
6762: dc4d: 
6763: dc4d:             APPLICATION.EXIT.PRESSED = TRUE
6764: dc5f: 
6765: dc5f:             GOSUB INITIALISE.SELECTION.SCREEN
6766: dc74: 
6767: dc74:         ! IF escape key                                                 !HMW
6768: dc74:         ENDIF ELSE IF KEY% = ESC.KEY% THEN BEGIN
6769: dc8c: 
6770: dc8c:             APPLICATION.EXIT.PRESSED = TRUE
6771: dc9e: 
6772: dc9e:             GOSUB INITIALISE.SELECTION.SCREEN
6773: dcb3: 
6774: dcb3:         ! IF cursor up                                                  !HMW
6775: dcb3:         ENDIF ELSE IF KEY% = PREV.KEY% THEN BEGIN
6776: dccb: 
6777: dccb:             IF APPLICATION.PAGE% > 1 THEN BEGIN
6778: dcda:                 ! Move to the last row on the previous page
6779: dcda:                 CURRENT.FIELD% = 20 ! Will always be 20
6780: dcea:                 APPLICATION.PAGE% = APPLICATION.PAGE% - 1
6781: dcf8:             ENDIF ELSE BEGIN
6782: dd00:                 ! No previous page exists
6783: dd00:                 CALL DM.FOCUS("","MESSAGE(74,'')")
6784: dd18:                 CURRENT.FIELD% = APPLICATION.START.FIELD%
6785: dd2a:             ENDIF
6786: dd35: 
6787: dd35:         ! IF cursor down                                                !HMW
6788: dd35:         ENDIF ELSE IF KEY% = NEXT.KEY% THEN BEGIN
6789: dd4d: 
6790: dd4d:             ! IF this is not the last page
6791: dd4d:             IF APPLICATION.PAGE% <                                  \
6792: dd5e:                    APPLICATION.TOTAL.PAGES% THEN BEGIN
6793: dd5e:                 ! Move to the first row on the next page
6794: dd5e:                 CURRENT.FIELD% = 3 ! Will always be 3
6795: dd6e:                 APPLICATION.PAGE% = APPLICATION.PAGE% + 1
6796: dd7c:             ENDIF ELSE BEGIN
6797: dd84:                 ! No next page exists
6798: dd84:                 CALL DM.FOCUS("","MESSAGE(75,'')")
6799: dd9c:                 CURRENT.FIELD% = APPLICATION.LAST.FIELD%
6800: ddae:             ENDIF
6801: ddb9: 
6802: ddb9:         ! IF first page                                                 !HMW
6803: ddb9:         ENDIF ELSE IF KEY% = TOP.KEY% THEN BEGIN
6804: ddd4: 
6805: ddd4:             IF APPLICATION.PAGE% = 1 THEN BEGIN
6806: dde3: 
6807: dde3:                 IF CURRENT.FIELD% =                                 \
6808: ddf9:                        APPLICATION.START.FIELD% THEN BEGIN
6809: ddf9: 
6810: ddf9:                     ! No previous page exists
6811: ddf9:                     CALL DM.FOCUS("","MESSAGE(74,'')")
6812: de13: 
6813: de13:                 ENDIF ELSE BEGIN
6814: de1b: 
6815: de1b:                     CURRENT.FIELD% = APPLICATION.START.FIELD%
6816: de2d: 
6817: de2d:                 ENDIF
6818: de37: 
6819: de37:             ENDIF ELSE BEGIN
6820: de3f: 
6821: de3f:                 APPLICATION.PAGE% = 1
6822: de4d:                 CURRENT.FIELD% = APPLICATION.START.FIELD%
6823: de5f: 
6824: de5f:             ENDIF
6825: de6a: 
6826: de6a:         ! IF last page                                                  !HMW
6827: de6a:         ENDIF ELSE IF KEY% = BOTTOM.KEY% THEN BEGIN
6828: de85: 
6829: de85:             IF APPLICATION.PAGE% =                                  \
6830: de96:                    APPLICATION.TOTAL.PAGES% THEN BEGIN
6831: de96: 
6832: de96:                 IF CURRENT.FIELD% =                                 \
6833: deac:                        APPLICATION.LAST.FIELD% THEN BEGIN
6834: deac: 
6835: deac:                     ! No next page exists
6836: deac:                     CALL DM.FOCUS("","MESSAGE(75,'')")
6837: dec6: 
6838: dec6:                 ENDIF ELSE BEGIN
6839: dece: 
6840: dece:                     CURRENT.FIELD% = APPLICATION.LAST.PAGE% + 2
6841: dee3: 
6842: dee3:                 ENDIF
6843: deed: 
6844: deed:             ENDIF ELSE BEGIN
6845: def5: 
6846: def5:                 APPLICATION.PAGE% = APPLICATION.TOTAL.PAGES%
6847: df03:                 CURRENT.FIELD% = APPLICATION.LAST.PAGE% + 2
6848: df18: 
6849: df18:             ENDIF
6850: df23: 
6851: df23:         ! IF page up                                                    !HMW
6852: df23:         ENDIF ELSE IF KEY% = F7.KEY% OR                             \
6853: df57:                       KEY% = PGUP.KEY% THEN BEGIN
6854: df57: 
6855: df57:             IF APPLICATION.PAGE% = 1 THEN BEGIN
6856: df66: 
6857: df66:                 ! No previous page exists
6858: df66:                 CALL DM.FOCUS("","MESSAGE(74,'')")
6859: df80: 
6860: df80:             ENDIF ELSE BEGIN
6861: df88:                 APPLICATION.PAGE% = APPLICATION.PAGE% - 1
6862: df94:                 CURRENT.FIELD% = APPLICATION.START.FIELD%
6863: dfa6:             ENDIF
6864: dfb1: 
6865: dfb1:         ! IF page down                                                  !HMW
6866: dfb1:         ENDIF ELSE IF KEY% = F8.KEY% OR                             \
6867: dfe5:                       KEY% = PGDN.KEY% THEN BEGIN
6868: dfe5: 
6869: dfe5:             IF APPLICATION.PAGE% =                                  \
6870: dff6:                    APPLICATION.TOTAL.PAGES% THEN BEGIN
6871: dff6: 
6872: dff6:                 ! No next page exists
6873: dff6:                 CALL DM.FOCUS("","MESSAGE(75,'')")
6874: e010: 
6875: e010:             ENDIF ELSE BEGIN
6876: e018:                 APPLICATION.PAGE% = APPLICATION.PAGE% + 1
6877: e024:                 CURRENT.FIELD% = APPLICATION.START.FIELD%
6878: e036:             ENDIF
6879: e041: 
6880: e041:         ! IF select all                                                 !HMW
6881: e041:         ENDIF ELSE IF KEY% = F9.KEY% THEN BEGIN
6882: e059: 
6883: e059:             ! Save position of selected application record
6884: e059:             CURRENT.FIELD% = DM.CURRENT.FIELD(0)
6885: e071: 
6886: e071:             ! Set all application selections
6887: e071:             CALL SELECT.ALL.APPLICATIONS(TRUE)
6888: e089: 
6889: e089:         ! IF clear all                                                  !HMW
6890: e089:         ENDIF ELSE IF KEY% = F10.KEY% THEN BEGIN
6891: e0a1: 
6892: e0a1:             ! Save position of selected application record
6893: e0a1:             CURRENT.FIELD% = DM.CURRENT.FIELD(0)
6894: e0b9: 
6895: e0b9:             ! Clear all application selections
6896: e0b9:             CALL SELECT.ALL.APPLICATIONS(FALSE)
6897: e0d1: 
6898: e0d1:         ! IF enter key                                                  !HMW
6899: e0d1:         ENDIF ELSE IF KEY% = ENTER.KEY% THEN BEGIN
6900: e0ec: 
6901: e0ec:             ! Save position of selected application record
6902: e0ec:             CURRENT.FIELD% = DM.CURRENT.FIELD(0)
6903: e104: 
6904: e104:             APPLICATION.EXIT.PRESSED = TRUE
6905: e116: 
6906: e116:             ! Update all application selection changes
6907: e116:             CALL SET.SELECTION.APPLICATION(10,9)
6908: e145: 
6909: e145:             GOSUB INITIALISE.SELECTION.SCREEN
6910: e157: 
6911: e157:             ! Set quit confirm flag
6912: e157:             CALL DM.CHANGED.FLAG(TRUE)
6913: e171: 
6914: e171:         ENDIF ELSE BEGIN
6915: e179: 
6916: e179:             ! B001 Invalid key pressed
6917: e179:             CALL DM.FOCUS("", "MESSAGE(1,'')")
6918: e191: 
6919: e191:         ENDIF
6920: e199: 
6921: e199:     WEND
6922: e1ab: 
6923: e1ab:     RETURN
6924: e1bb: 
6925: e1bb: \***********************************************************************
6926: e1bb: \***
6927: e1bb: \***    INITIALISE.APPLICATION.SCREEN
6928: e1bb: \***
6929: e1bb: \***********************************************************************
6930: e1bb: INITIALISE.APPLICATION.SCREEN:
6931: e1cb: 
6932: e1cb:     ! Display application list DM screen
6933: e1cb:     CALL DM.SHOW.SCREEN(6,"",6,6)
6934: e1e5: 
6935: e1e5:     APPLICATION.START.FIELD% = 3
6936: e1f3:     APPLICATION.END.FIELD%   = 20
6937: e201: 
6938: e201:     APPLICATION.EXIT.PRESSED = FALSE
6939: e213: 
6940: e213:     ! Save all application selection changes
6941: e213:     CALL SET.SELECTION.APPLICATION(9,10)
6942: e242: 
6943: e242:     ! FOR each application
6944: e242:     FOR I% = 1 TO APPLICATION.COUNT%
6945: e252: 
6946: e252:         ! Get application description
6947: e252:         APPLICATION.DESC$(I%) =                                     \
6948: e294:             GET.APPLICATION.DESCRIPTION$(                           \
6949: e294:                 LEFT$(APPLICATION.RECORD$(I%),8))
6950: e294: 
6951: e294:     NEXT I%
6952: e2ac: 
6953: e2ac:     RETURN
6954: e2bc: 
6955: e2bc: \***********************************************************************
6956: e2bc: \***
6957: e2bc: \***    DISPLAY.APPLICATION.PAGE
6958: e2bc: \***
6959: e2bc: \***********************************************************************
6960: e2bc: DISPLAY.APPLICATION.PAGE:
6961: e2cc: 
6962: e2cc:     ! IF first page
6963: e2cc:     IF APPLICATION.PAGE% = 1 THEN BEGIN
6964: e2db:         ! Hide page up function key
6965: e2db:         CALL DM.HIDE.FN.KEY(7)
6966: e2ee:     ENDIF ELSE BEGIN
6967: e2f6:         ! Display page up function key
6968: e2f6:         CALL DM.SHOW.FN.KEY(7,"PGUP")
6969: e30c:     ENDIF
6970: e314: 
6971: e314:     ! IF last page
6972: e314:     IF APPLICATION.PAGE% = APPLICATION.TOTAL.PAGES% THEN BEGIN
6973: e325: 
6974: e325:         ! Hide page down function key
6975: e325:         CALL DM.HIDE.FN.KEY(8)
6976: e336: 
6977: e336:         APPLICATION.LAST.FIELD% = APPLICATION.LAST.PAGE% + 2
6978: e347: 
6979: e347:         ! For the last page, set results per page to the remainder
6980: e347:         APPLICATION.THIS.PAGE% = APPLICATION.LAST.PAGE%
6981: e357: 
6982: e357:     ENDIF ELSE BEGIN
6983: e35f: 
6984: e35f:         ! Display page down function key
6985: e35f:         CALL DM.SHOW.FN.KEY(8,"PGDN")
6986: e375: 
6987: e375:         APPLICATION.LAST.FIELD% = APPLICATION.END.FIELD%
6988: e383: 
6989: e383:         ! Set applications per page to
6990: e383:         ! the maximum applications allowed per page
6991: e383:         APPLICATION.THIS.PAGE% = APPLICATIONS.PER.PAGE%
6992: e395: 
6993: e395:     ENDIF
6994: e39d: 
6995: e39d:     FOR I% = 1 TO APPLICATION.THIS.PAGE%
6996: e3ae: 
6997: e3ae:         APPLICATION.INDEX% =                                        \
6998: e3c8:             ((APPLICATION.PAGE% - 1) *                              \
6999: e3c8:             APPLICATIONS.PER.PAGE%) + I%
7000: e3c8: 
7001: e3c8:         FIELD.INDEX% = I% + 2
7002: e3d9:         FIELD$(FIELD.INDEX%) = \
7003: e441:             RIGHT$(" " + \
7004: e441:             MID$(APPLICATION.RECORD$(APPLICATION.INDEX%),10,1),1)
7005: e441: 
7006: e441:         FIELD.INDEX% = I% + 20
7007: e452:         FIELD$(FIELD.INDEX%) =                                      \
7008: e492:             LEFT$(APPLICATION.RECORD$(APPLICATION.INDEX%),8)
7009: e492: 
7010: e492:         FIELD.INDEX% = I% + 38
7011: e4a3:         FIELD$(FIELD.INDEX%) = APPLICATION.DESC$(APPLICATION.INDEX%)
7012: e4da: 
7013: e4da:         CALL DM.VISIBLE(STR$(FIELD.INDEX%),"TRUE")
7014: e507:         CALL DM.RO.FIELD(FIELD.INDEX%)
7015: e51a: 
7016: e51a:     NEXT I%
7017: e535: 
7018: e535:     FIELD$(U0406.PAGE%) =                                           \
7019: e5be:         RIGHT$((STRING$(7," ") +                                    \
7020: e5be:         "Page " + STR$(APPLICATION.PAGE%) +                         \
7021: e5be:         " of "  + STR$(APPLICATION.TOTAL.PAGES%)),18)
7022: e5be: 
7023: e5be:     ! IF results per page is not a full page
7024: e5be:     IF APPLICATION.THIS.PAGE% < APPLICATIONS.PER.PAGE% THEN BEGIN
7025: e5d6: 
7026: e5d6:         ! For each remaining row
7027: e5d6:         FOR I% = (APPLICATION.THIS.PAGE% + 1) TO                    \
7028: e5e8:                  APPLICATIONS.PER.PAGE%
7029: e5e8: 
7030: e5e8:             FIELD.INDEX% = I% + 2
7031: e5f9:             FIELD$(FIELD.INDEX%) = " " ! Clear
7032: e61e: 
7033: e61e:             FIELD.INDEX% = I% + 20
7034: e62f:             FIELD$(FIELD.INDEX%) = NULL.PROGRAM$ ! Clear
7035: e65b: 
7036: e65b:             FIELD.INDEX% = I% + 38
7037: e66c:             FIELD$(FIELD.INDEX%) = STRING$(56," ") ! Clear
7038: e698: 
7039: e698:             ! Hide the field
7040: e698:             CALL DM.VISIBLE(STR$(FIELD.INDEX%),"FALSE")
7041: e6c5: 
7042: e6c5:         NEXT I%
7043: e6e4: 
7044: e6e4:     ENDIF
7045: e6ec: 
7046: e6ec:     RETURN
7047: e6fc: 
7048: e6fc: \***********************************************************************
7049: e6fc: \***
7050: e6fc: \***    PROCESS.SEVERITY.SCREEN
7051: e6fc: \***
7052: e6fc: \***********************************************************************
7053: e6fc: PROCESS.SEVERITY.SCREEN:
7054: e70c: 
7055: e70c:     GOSUB INITIALISE.SEVERITY.SCREEN
7056: e71e: 
7057: e71e:     CURRENT.FIELD% = SEVERITY.START.FIELD%
7058: e730: 
7059: e730:     WHILE NOT SEVERITY.EXIT.PRESSED
7060: e73b: 
7061: e73b:         CALL DM.CURRENT.FIELD(CURRENT.FIELD%)
7062: e753: 
7063: e753:         GOSUB DISPLAY.SEVERITY.PAGE
7064: e765: 
7065: e765:         KEY% = DM.PROCESS.SCREEN(SEVERITY.START.FIELD%,             \
7066: e78d:                                  SEVERITY.END.FIELD%,               \
7067: e78d:                                  TRUE)
7068: e78d: 
7069: e78d:         ! IF quit key OR escape key                                     !HMW
7070: e78d:         IF KEY% = F3.KEY% OR KEY% = ESC.KEY% THEN BEGIN
7071: e7c1: 
7072: e7c1:             SEVERITY.EXIT.PRESSED = TRUE
7073: e7d3: 
7074: e7d3:             GOSUB INITIALISE.SELECTION.SCREEN
7075: e7e8: 
7076: e7e8:         ! IF cursor up                                                  !HMW
7077: e7e8:         ENDIF ELSE IF KEY% = PREV.KEY% THEN BEGIN
7078: e800: 
7079: e800:             IF CURRENT.FIELD% = SEVERITY.START.FIELD% THEN BEGIN
7080: e816:                 CURRENT.FIELD% = SEVERITY.START.FIELD%
7081: e828:             ENDIF
7082: e833: 
7083: e833:         ! IF cursor down                                                !HMW
7084: e833:         ENDIF ELSE IF KEY% = NEXT.KEY% THEN BEGIN
7085: e84b: 
7086: e84b:             IF CURRENT.FIELD% = SEVERITY.END.FIELD% THEN BEGIN
7087: e861:                 CURRENT.FIELD% = SEVERITY.END.FIELD%
7088: e873:             ENDIF
7089: e87e: 
7090: e87e:         ! IF select all                                                 !HMW
7091: e87e:         ENDIF ELSE IF KEY% = F9.KEY% THEN BEGIN
7092: e896: 
7093: e896:             ! Save position of selected severity record
7094: e896:             CURRENT.FIELD% = DM.CURRENT.FIELD(0)
7095: e8ae: 
7096: e8ae:             ! Set all severity selections
7097: e8ae:             CALL SELECT.ALL.SEVERITYS(TRUE)
7098: e8c6: 
7099: e8c6:         ! IF clear all                                                  !HMW
7100: e8c6:         ENDIF ELSE IF KEY% = F10.KEY% THEN BEGIN
7101: e8de: 
7102: e8de:             ! Save position of selected severity record
7103: e8de:             CURRENT.FIELD% = DM.CURRENT.FIELD(0)
7104: e8f6: 
7105: e8f6:             ! Clear all severity selections
7106: e8f6:             CALL SELECT.ALL.SEVERITYS(FALSE)
7107: e90e: 
7108: e90e:         ! IF enter key                                                  !HMW
7109: e90e:         ENDIF ELSE IF KEY% = ENTER.KEY% THEN BEGIN
7110: e929: 
7111: e929:             ! Save position of selected severity record
7112: e929:             CURRENT.FIELD% = DM.CURRENT.FIELD(0)
7113: e941: 
7114: e941:             SEVERITY.EXIT.PRESSED = TRUE
7115: e953: 
7116: e953:             ! Update all severity selection changes
7117: e953:             CALL SET.SELECTION.SEVERITY(3,2)
7118: e982: 
7119: e982:             GOSUB INITIALISE.SELECTION.SCREEN
7120: e994: 
7121: e994:             ! Set quit confirm flag
7122: e994:             CALL DM.CHANGED.FLAG(TRUE)
7123: e9ae: 
7124: e9ae:         ENDIF ELSE BEGIN
7125: e9b6: 
7126: e9b6:             ! B001 Invalid key pressed
7127: e9b6:             CALL DM.FOCUS("", "MESSAGE(1,'')")
7128: e9ce: 
7129: e9ce:         ENDIF
7130: e9d6: 
7131: e9d6:     WEND
7132: e9e8: 
7133: e9e8:     RETURN
7134: e9f8: 
7135: e9f8: \***********************************************************************
7136: e9f8: \***
7137: e9f8: \***    INITIALISE.SEVERITY.SCREEN
7138: e9f8: \***
7139: e9f8: \***********************************************************************
7140: e9f8: INITIALISE.SEVERITY.SCREEN:
7141: ea08: 
7142: ea08:     ! Display severity DM screen
7143: ea08:     CALL DM.SHOW.SCREEN(9,"",9,9)
7144: ea22: 
7145: ea22:     SEVERITY.START.FIELD% = 3
7146: ea30:     SEVERITY.END.FIELD%   = 8
7147: ea3e: 
7148: ea3e:     SEVERITY.EXIT.PRESSED = FALSE
7149: ea50: 
7150: ea50:     ! Restore all severity selection changes
7151: ea50:     CALL SET.SELECTION.SEVERITY(2,3)
7152: ea7f: 
7153: ea7f:     RETURN
7154: ea8f: 
7155: ea8f: \***********************************************************************
7156: ea8f: \***
7157: ea8f: \***    DISPLAY.SEVERITY.PAGE
7158: ea8f: \***
7159: ea8f: \***********************************************************************
7160: ea8f: DISPLAY.SEVERITY.PAGE:
7161: ea9f: 
7162: ea9f:     ! For each severity
7163: ea9f:     FOR I% = 0 TO 5
7164: eab0: 
7165: eab0:         SEVERITY.INDEX% = I%
7166: eabe: 
7167: eabe:         FIELD.INDEX% = I% + 3
7168: eacf:         FIELD$(FIELD.INDEX%) =                                      \
7169: eb37:             RIGHT$(" " +                                            \
7170: eb37:             MID$(SEVERITY.RECORD$(SEVERITY.INDEX%),3,1),1)
7171: eb37: 
7172: eb37:         FIELD.INDEX% = I% + 21
7173: eb48:         FIELD$(FIELD.INDEX%) =                                      \
7174: eb88:             LEFT$(SEVERITY.RECORD$(SEVERITY.INDEX%),1)
7175: eb88: 
7176: eb88:         FIELD.INDEX% = I% + 39
7177: eb99:         FIELD$(FIELD.INDEX%) = SEVERITY.TEXT$(I%)
7178: ebd3: 
7179: ebd3:         CALL DM.VISIBLE(STR$(FIELD.INDEX%),"TRUE")
7180: ec00:         CALL DM.RO.FIELD(FIELD.INDEX%)
7181: ec13: 
7182: ec13:     NEXT I%
7183: ec2c: 
7184: ec2c:     RETURN
7185: ec3c: 
7186: ec3c: \***********************************************************************
7187: ec3c: \***
7188: ec3c: \***    PROCESS.BUCKET.SCREEN
7189: ec3c: \***
7190: ec3c: \***********************************************************************
7191: ec3c: PROCESS.BUCKET.SCREEN:
7192: ec4c: 
7193: ec4c:     GOSUB INITIALISE.BUCKET.SCREEN
7194: ec5e: 
7195: ec5e:     CURRENT.FIELD% = BUCKET.START.FIELD%
7196: ec70: 
7197: ec70:     WHILE NOT BUCKET.EXIT.PRESSED
7198: ec7b: 
7199: ec7b:         CALL DM.CURRENT.FIELD(CURRENT.FIELD%)
7200: ec93: 
7201: ec93:         GOSUB DISPLAY.BUCKET.PAGE
7202: eca5: 
7203: eca5:         KEY% = DM.PROCESS.SCREEN(BUCKET.START.FIELD%,               \
7204: eccd:                                  BUCKET.END.FIELD%,                 \
7205: eccd:                                  TRUE)
7206: eccd: 
7207: eccd:         ! IF quit key OR escape key                                     !HMW
7208: eccd:         IF KEY% = F3.KEY% OR KEY% = ESC.KEY% THEN BEGIN
7209: ed01: 
7210: ed01:             BUCKET.EXIT.PRESSED = TRUE
7211: ed13: 
7212: ed13:             GOSUB INITIALISE.SELECTION.SCREEN
7213: ed28: 
7214: ed28:         ! IF cursor up                                                  !HMW
7215: ed28:         ENDIF ELSE IF KEY% = PREV.KEY% THEN BEGIN
7216: ed40: 
7217: ed40:             IF CURRENT.FIELD% = BUCKET.START.FIELD% THEN BEGIN          !BMW
7218: ed56:                 CURRENT.FIELD% = BUCKET.START.FIELD%                    !BMW
7219: ed68:             ENDIF                                                       !BMW
7220: ed73: 
7221: ed73:         ! IF cursor down                                                !HMW
7222: ed73:         ENDIF ELSE IF KEY% = NEXT.KEY% THEN BEGIN
7223: ed8b: 
7224: ed8b:             IF CURRENT.FIELD% = BUCKET.END.FIELD% THEN BEGIN            !BMW
7225: eda1:                 CURRENT.FIELD% = BUCKET.END.FIELD%                      !BMW
7226: edb3:             ENDIF                                                       !BMW
7227: edbe: 
7228: edbe:         ! IF select all                                                 !HMW
7229: edbe:         ENDIF ELSE IF KEY% = F9.KEY% THEN BEGIN
7230: edd6: 
7231: edd6:             ! Save position of selected bucket record
7232: edd6:             CURRENT.FIELD% = DM.CURRENT.FIELD(0)
7233: edee: 
7234: edee:             ! Set all severity buckets
7235: edee:             CALL SELECT.ALL.BUCKETS(TRUE)
7236: ee06: 
7237: ee06:         ! IF clear all                                                  !HMW
7238: ee06:         ENDIF ELSE IF KEY% = F10.KEY% THEN BEGIN
7239: ee1e: 
7240: ee1e:             ! Save position of selected bucket record
7241: ee1e:             CURRENT.FIELD% = DM.CURRENT.FIELD(0)
7242: ee36: 
7243: ee36:             ! Clear all bucket selections
7244: ee36:             CALL SELECT.ALL.BUCKETS(FALSE)
7245: ee4e: 
7246: ee4e:         ! IF enter key                                                  !HMW
7247: ee4e:         ENDIF ELSE IF KEY% = ENTER.KEY% THEN BEGIN
7248: ee69: 
7249: ee69:             ! Save position of selected bucket record
7250: ee69:             CURRENT.FIELD% = DM.CURRENT.FIELD(0)
7251: ee81: 
7252: ee81:             BUCKET.EXIT.PRESSED = TRUE
7253: ee93: 
7254: ee93:             ! Update all bucket selection changes
7255: ee93:             CALL SET.SELECTION.BUCKET(3,2)
7256: eec2: 
7257: eec2:             GOSUB INITIALISE.SELECTION.SCREEN
7258: eed4: 
7259: eed4:             ! Set quit confirm flag
7260: eed4:             CALL DM.CHANGED.FLAG(TRUE)
7261: eeee: 
7262: eeee:         ENDIF ELSE BEGIN
7263: eef6: 
7264: eef6:             ! B001 Invalid key pressed
7265: eef6:             CALL DM.FOCUS("", "MESSAGE(1,'')")
7266: ef0e: 
7267: ef0e:         ENDIF
7268: ef16: 
7269: ef16:     WEND
7270: ef28: 
7271: ef28:     RETURN
7272: ef38: 
7273: ef38: \***********************************************************************
7274: ef38: \***
7275: ef38: \***    INITIALISE.BUCKET.SCREEN
7276: ef38: \***
7277: ef38: \***********************************************************************
7278: ef38: INITIALISE.BUCKET.SCREEN:
7279: ef48: 
7280: ef48:     ! Display bucket DM screen
7281: ef48:     CALL DM.SHOW.SCREEN(10,"",10,10)
7282: ef62: 
7283: ef62:     BUCKET.START.FIELD% = 3
7284: ef70:     BUCKET.END.FIELD%   = 9
7285: ef7e: 
7286: ef7e:     BUCKET.EXIT.PRESSED = FALSE
7287: ef90: 
7288: ef90:     ! Save all bucket selection changes
7289: ef90:     CALL SET.SELECTION.BUCKET(2,3)
7290: efbf: 
7291: efbf:     RETURN
7292: efcf: 
7293: efcf: \***********************************************************************
7294: efcf: \***
7295: efcf: \***    DISPLAY.BUCKET.PAGE
7296: efcf: \***
7297: efcf: \***********************************************************************
7298: efcf: DISPLAY.BUCKET.PAGE:
7299: efdf: 
7300: efdf:     ! For each bucket
7301: efdf:     FOR I% = 0 TO 6
7302: eff0: 
7303: eff0:         BUCKET.INDEX% = I%
7304: effe: 
7305: effe:         FIELD.INDEX% = I% + 3
7306: f00f:         FIELD$(FIELD.INDEX%) =                                      \
7307: f077:             RIGHT$(" " +                                            \
7308: f077:             MID$(BUCKET.RECORD$(BUCKET.INDEX%),3,1),1)
7309: f077: 
7310: f077:         FIELD.INDEX% = I% + 21
7311: f088:         FIELD$(FIELD.INDEX%) =                                      \
7312: f0c8:             LEFT$(BUCKET.RECORD$(BUCKET.INDEX%),1)
7313: f0c8: 
7314: f0c8:         FIELD.INDEX% = I% + 39
7315: f0d9:         FIELD$(FIELD.INDEX%) = BUCKET.TEXT$(I%)
7316: f113: 
7317: f113:         CALL DM.VISIBLE(STR$(FIELD.INDEX%),"TRUE")
7318: f140:         CALL DM.RO.FIELD(FIELD.INDEX%)
7319: f153: 
7320: f153:     NEXT I%
7321: f16c: 
7322: f16c:     RETURN
7323: f17c: 
7324: f17c: \***********************************************************************!BMW
7325: f17c: \***                                                                    !BMW
7326: f17c: \***    PROCESS.SOURCE.SCREEN                                           !BMW
7327: f17c: \***                                                                    !BMW
7328: f17c: \***********************************************************************!BMW
7329: f17c: PROCESS.SOURCE.SCREEN:                                                  !BMW
7330: f18c:                                                                         !BMW
7331: f18c:     SOURCE.PAGE% = 1                                                    !BMW
7332: f19a:                                                                         !BMW
7333: f19a:     GOSUB INITIALISE.SOURCE.SCREEN                                      !BMW
7334: f1ac:                                                                         !BMW
7335: f1ac:     CURRENT.FIELD% = SOURCE.START.FIELD%                                !BMW
7336: f1be:                                                                         !BMW
7337: f1be:     WHILE NOT SOURCE.EXIT.PRESSED                                       !BMW
7338: f1c9:                                                                         !BMW
7339: f1c9:         CALL DM.CURRENT.FIELD(CURRENT.FIELD%)                           !BMW
7340: f1e1:                                                                         !BMW
7341: f1e1:         GOSUB DISPLAY.SOURCE.PAGE                                       !BMW
7342: f1f3:                                                                         !BMW
7343: f1f3:         KEY% = DM.PROCESS.SCREEN(SOURCE.START.FIELD%,               \   !BMW
7344: f21b:                                  SOURCE.LAST.FIELD%,                \   !BMW
7345: f21b:                                  TRUE)                                  !BMW
7346: f21b:                                                                         !BMW
7347: f21b:         ! IF quit key OR escape key                                     !HMW
7348: f21b:         IF KEY% = F3.KEY% OR KEY% = ESC.KEY% THEN BEGIN                 !BMW
7349: f24f:                                                                         !BMW
7350: f24f:             SOURCE.EXIT.PRESSED = TRUE                                  !BMW
7351: f261:                                                                         !BMW
7352: f261:             GOSUB INITIALISE.SELECTION.SCREEN                           !BMW
7353: f276:                                                                         !BMW
7354: f276:         ! IF cursor up                                                  !HMW
7355: f276:         ENDIF ELSE IF KEY% = PREV.KEY% THEN BEGIN                       !BMW
7356: f28e:                                                                         !BMW
7357: f28e:             IF SOURCE.PAGE% > 1 THEN BEGIN                              !BMW
7358: f29d:                 ! Move to the last row on the previous page             !BMW
7359: f29d:                 CURRENT.FIELD% = 20 ! Will always be 20                 !BMW
7360: f2ad:                 SOURCE.PAGE% = SOURCE.PAGE% - 1                         !BMW
7361: f2bb:             ENDIF ELSE BEGIN                                            !BMW
7362: f2c3:                 ! No previous page exists                               !BMW
7363: f2c3:                 CALL DM.FOCUS("","MESSAGE(74,'')")                      !BMW
7364: f2db:                 CURRENT.FIELD% = SOURCE.START.FIELD%                    !BMW
7365: f2ed:             ENDIF                                                       !BMW
7366: f2f8:                                                                         !BMW
7367: f2f8:         ! IF cursor down                                                !HMW
7368: f2f8:         ENDIF ELSE IF KEY% = NEXT.KEY% THEN BEGIN                       !BMW
7369: f310:                                                                         !BMW
7370: f310:             ! IF this is not the last page                              !BMW
7371: f310:             IF SOURCE.PAGE% < SOURCE.TOTAL.PAGES% THEN BEGIN            !BMW
7372: f321:                 ! Move to the first row on the next page                !BMW
7373: f321:                 CURRENT.FIELD% = 3 ! Will always be 3                   !BMW
7374: f331:                 SOURCE.PAGE% = SOURCE.PAGE% + 1                         !BMW
7375: f33f:             ENDIF ELSE BEGIN                                            !BMW
7376: f347:                 ! No next page exists                                   !BMW
7377: f347:                 CALL DM.FOCUS("","MESSAGE(75,'')")                      !BMW
7378: f35f:                 CURRENT.FIELD% = SOURCE.LAST.FIELD%                     !BMW
7379: f371:             ENDIF                                                       !BMW
7380: f37c:                                                                         !BMW
7381: f37c:         ! IF first page                                                 !HMW
7382: f37c:         ENDIF ELSE IF KEY% = TOP.KEY% THEN BEGIN                        !BMW
7383: f397:                                                                         !BMW
7384: f397:             IF SOURCE.PAGE% = 1 THEN BEGIN                              !BMW
7385: f3a6:                                                                         !BMW
7386: f3a6:                 IF CURRENT.FIELD% = SOURCE.START.FIELD% THEN BEGIN      !BMW
7387: f3bc:                                                                         !BMW
7388: f3bc:                     ! No previous page exists                           !BMW
7389: f3bc:                     CALL DM.FOCUS("","MESSAGE(74,'')")                  !BMW
7390: f3d6:                                                                         !BMW
7391: f3d6:                 ENDIF ELSE BEGIN                                        !BMW
7392: f3de:                                                                         !BMW
7393: f3de:                     CURRENT.FIELD% = SOURCE.START.FIELD%                !BMW
7394: f3f0:                                                                         !BMW
7395: f3f0:                 ENDIF                                                   !BMW
7396: f3fa:                                                                         !BMW
7397: f3fa:             ENDIF ELSE BEGIN                                            !BMW
7398: f402:                                                                         !BMW
7399: f402:                 SOURCE.PAGE% = 1                                        !BMW
7400: f410:                 CURRENT.FIELD% = SOURCE.START.FIELD%                    !BMW
7401: f422:                                                                         !BMW
7402: f422:             ENDIF                                                       !BMW
7403: f42d:                                                                         !BMW
7404: f42d:         ! IF last page                                                  !HMW
7405: f42d:         ENDIF ELSE IF KEY% = BOTTOM.KEY% THEN BEGIN                     !BMW
7406: f448:                                                                         !BMW
7407: f448:             IF SOURCE.PAGE% = SOURCE.TOTAL.PAGES% THEN BEGIN            !BMW
7408: f459:                                                                         !BMW
7409: f459:                 IF CURRENT.FIELD% = SOURCE.LAST.FIELD% THEN BEGIN       !BMW
7410: f46f:                                                                         !BMW
7411: f46f:                     ! No next page exists                               !BMW
7412: f46f:                     CALL DM.FOCUS("","MESSAGE(75,'')")                  !BMW
7413: f489:                                                                         !BMW
7414: f489:                 ENDIF ELSE BEGIN                                        !BMW
7415: f491:                                                                         !BMW
7416: f491:                     CURRENT.FIELD% = SOURCE.LAST.PAGE% + 2              !BMW
7417: f4a6:                                                                         !BMW
7418: f4a6:                 ENDIF                                                   !BMW
7419: f4b0:                                                                         !BMW
7420: f4b0:             ENDIF ELSE BEGIN                                            !BMW
7421: f4b8:                                                                         !BMW
7422: f4b8:                 SOURCE.PAGE% = SOURCE.TOTAL.PAGES%                      !BMW
7423: f4c6:                 CURRENT.FIELD% = SOURCE.LAST.PAGE% + 2                  !BMW
7424: f4db:                                                                         !BMW
7425: f4db:             ENDIF                                                       !BMW
7426: f4e6:                                                                         !BMW
7427: f4e6:         ! IF page up                                                    !HMW
7428: f4e6:         ENDIF ELSE IF KEY% = F7.KEY% OR                             \   !BMW
7429: f51a:                       KEY% = PGUP.KEY% THEN BEGIN                       !BMW
7430: f51a:                                                                         !BMW
7431: f51a:             IF SOURCE.PAGE% = 1 THEN BEGIN                              !BMW
7432: f529:                                                                         !BMW
7433: f529:                 ! No previous page exists                               !BMW
7434: f529:                 CALL DM.FOCUS("","MESSAGE(74,'')")                      !BMW
7435: f543:                                                                         !BMW
7436: f543:             ENDIF ELSE BEGIN                                            !BMW
7437: f54b:                 SOURCE.PAGE% = SOURCE.PAGE% - 1                         !BMW
7438: f557:                 CURRENT.FIELD% = SOURCE.START.FIELD%                    !BMW
7439: f569:             ENDIF                                                       !BMW
7440: f574:                                                                         !BMW
7441: f574:         ! IF page down                                                  !HMW
7442: f574:         ENDIF ELSE IF KEY% = F8.KEY% OR                             \   !BMW
7443: f5a8:                       KEY% = PGDN.KEY% THEN BEGIN                       !BMW
7444: f5a8:                                                                         !BMW
7445: f5a8:             IF SOURCE.PAGE% = SOURCE.TOTAL.PAGES% THEN BEGIN            !BMW
7446: f5b9:                                                                         !BMW
7447: f5b9:                 ! No next page exists                                   !BMW
7448: f5b9:                 CALL DM.FOCUS("","MESSAGE(75,'')")                      !BMW
7449: f5d3:                                                                         !BMW
7450: f5d3:             ENDIF ELSE BEGIN                                            !BMW
7451: f5db:                 SOURCE.PAGE% = SOURCE.PAGE% + 1                         !BMW
7452: f5e7:                 CURRENT.FIELD% = SOURCE.START.FIELD%                    !BMW
7453: f5f9:             ENDIF                                                       !BMW
7454: f604:                                                                         !BMW
7455: f604:         ! IF select all                                                 !HMW
7456: f604:         ENDIF ELSE IF KEY% = F9.KEY% THEN BEGIN                         !BMW
7457: f61c:                                                                         !BMW
7458: f61c:             ! Save position of selected bucket record                   !BMW
7459: f61c:             CURRENT.FIELD% = DM.CURRENT.FIELD(0)                        !BMW
7460: f634:                                                                         !BMW
7461: f634:             ! Set all severity buckets                                  !BMW
7462: f634:             CALL SELECT.ALL.SOURCES(TRUE)                               !BMW
7463: f64c:                                                                         !BMW
7464: f64c:         ! IF clear all                                                  !HMW
7465: f64c:         ENDIF ELSE IF KEY% = F10.KEY% THEN BEGIN                        !BMW
7466: f664:                                                                         !BMW
7467: f664:             ! Save position of selected bucket record                   !BMW
7468: f664:             CURRENT.FIELD% = DM.CURRENT.FIELD(0)                        !BMW
7469: f67c:                                                                         !BMW
7470: f67c:             ! Clear all bucket selections                               !BMW
7471: f67c:             CALL SELECT.ALL.SOURCES(FALSE)                              !BMW
7472: f694:                                                                         !BMW
7473: f694:         ! IF enter key                                                  !HMW
7474: f694:         ENDIF ELSE IF KEY% = ENTER.KEY% THEN BEGIN                      !BMW
7475: f6af:                                                                         !BMW
7476: f6af:             ! Save position of selected bucket record                   !BMW
7477: f6af:             CURRENT.FIELD% = DM.CURRENT.FIELD(0)                        !BMW
7478: f6c7:                                                                         !BMW
7479: f6c7:             SOURCE.EXIT.PRESSED = TRUE                                  !BMW
7480: f6d9:                                                                         !BMW
7481: f6d9:             ! Update all bucket selection changes                       !BMW
7482: f6d9:             CALL SET.SELECTION.SOURCE(5,4)                              !BMW
7483: f708:                                                                         !BMW
7484: f708:             GOSUB INITIALISE.SELECTION.SCREEN                           !BMW
7485: f71a:                                                                         !BMW
7486: f71a:             ! Set quit confirm flag                                     !BMW
7487: f71a:             CALL DM.CHANGED.FLAG(TRUE)                                  !BMW
7488: f734:                                                                         !BMW
7489: f734:         ENDIF ELSE BEGIN                                                !BMW
7490: f73c:                                                                         !BMW
7491: f73c:             ! B001 Invalid key pressed                                  !BMW
7492: f73c:             CALL DM.FOCUS("", "MESSAGE(1,'')")                          !BMW
7493: f754:                                                                         !BMW
7494: f754:         ENDIF                                                           !BMW
7495: f75c:                                                                         !BMW
7496: f75c:     WEND                                                                !BMW
7497: f76e:                                                                         !BMW
7498: f76e:     RETURN                                                              !BMW
7499: f77e:                                                                         !BMW
7500: f77e: \***********************************************************************!BMW
7501: f77e: \***                                                                    !BMW
7502: f77e: \***    INITIALISE.SOURCE.SCREEN                                        !BMW
7503: f77e: \***                                                                    !BMW
7504: f77e: \***********************************************************************!BMW
7505: f77e: INITIALISE.SOURCE.SCREEN:                                               !BMW
7506: f78e:                                                                         !BMW
7507: f78e:     ! Display source DM screen                                          !BMW
7508: f78e:     CALL DM.SHOW.SCREEN(11,"",11,11)                                    !BMW
7509: f7a8:                                                                         !BMW
7510: f7a8:     SOURCE.START.FIELD% = 3                                             !BMW
7511: f7b6:     SOURCE.END.FIELD%   = 20                                            !BMW
7512: f7c4:                                                                         !BMW
7513: f7c4:     SOURCE.EXIT.PRESSED = FALSE                                         !BMW
7514: f7d6:                                                                         !BMW
7515: f7d6:     ! Save all source selection changes                                 !BMW
7516: f7d6:     CALL SET.SELECTION.SOURCE(4,5)                                      !BMW
7517: f805:                                                                         !BMW
7518: f805:     RETURN                                                              !BMW
7519: f815:                                                                         !BMW
7520: f815: \***********************************************************************!BMW
7521: f815: \***                                                                    !BMW
7522: f815: \***    DISPLAY.SOURCE.PAGE                                             !BMW
7523: f815: \***                                                                    !BMW
7524: f815: \***********************************************************************!BMW
7525: f815: DISPLAY.SOURCE.PAGE:                                                    !BMW
7526: f825:                                                                         !BMW
7527: f825:     ! IF first page                                                     !BMW
7528: f825:     IF SOURCE.PAGE% = 1 THEN BEGIN                                      !BMW
7529: f834:         ! Hide page up function key                                     !BMW
7530: f834:         CALL DM.HIDE.FN.KEY(7)                                          !BMW
7531: f847:     ENDIF ELSE BEGIN                                                    !BMW
7532: f84f:         ! Display page up function key                                  !BMW
7533: f84f:         CALL DM.SHOW.FN.KEY(7,"PGUP")                                   !BMW
7534: f865:     ENDIF                                                               !BMW
7535: f86d:                                                                         !BMW
7536: f86d:     ! IF last page                                                      !BMW
7537: f86d:     IF SOURCE.PAGE% = SOURCE.TOTAL.PAGES% THEN BEGIN                    !BMW
7538: f87e:                                                                         !BMW
7539: f87e:         ! Hide page down function key                                   !BMW
7540: f87e:         CALL DM.HIDE.FN.KEY(8)                                          !BMW
7541: f88f:                                                                         !BMW
7542: f88f:         SOURCE.LAST.FIELD% = SOURCE.LAST.PAGE% + 2                      !BMW
7543: f8a0:                                                                         !BMW
7544: f8a0:         ! For the last page, set results per page to the remainder      !BMW
7545: f8a0:         SOURCE.THIS.PAGE% = SOURCE.LAST.PAGE%                           !BMW
7546: f8b0:                                                                         !BMW
7547: f8b0:     ENDIF ELSE BEGIN                                                    !BMW
7548: f8b8:                                                                         !BMW
7549: f8b8:         ! Display page down function key                                !BMW
7550: f8b8:         CALL DM.SHOW.FN.KEY(8,"PGDN")                                   !BMW
7551: f8ce:                                                                         !BMW
7552: f8ce:         SOURCE.LAST.FIELD% = SOURCE.END.FIELD%                          !BMW
7553: f8dc:                                                                         !BMW
7554: f8dc:         ! Set sources per page to                                       !BMW
7555: f8dc:         ! the maximum sources allowed per page                          !BMW
7556: f8dc:         SOURCE.THIS.PAGE% = SOURCES.PER.PAGE%                           !BMW
7557: f8ee:                                                                         !BMW
7558: f8ee:     ENDIF                                                               !BMW
7559: f8f6:                                                                         !BMW
7560: f8f6:     FOR I% = 1 TO SOURCE.THIS.PAGE%                                     !BMW
7561: f907:                                                                         !BMW
7562: f907:         SOURCE.INDEX% =                                             \   !BMW
7563: f921:             ((SOURCE.PAGE% - 1) *                                   \   !BMW
7564: f921:             SOURCES.PER.PAGE%) + I%                                     !BMW
7565: f921:                                                                         !BMW
7566: f921:         FIELD.INDEX% = I% + 2                                           !BMW
7567: f932:         FIELD$(FIELD.INDEX%) = \                                        !BMW
7568: f99a:             RIGHT$(" " + \                                              !BMW
7569: f99a:             MID$(SOURCE.RECORD$(SOURCE.INDEX%),5,1),1)                  !BMW
7570: f99a:                                                                         !BMW
7571: f99a:         FIELD.INDEX% = I% + 20                                          !BMW
7572: f9ab:         FIELD$(FIELD.INDEX%) =                                      \   !BMW
7573: f9eb:             LEFT$(SOURCE.RECORD$(SOURCE.INDEX%),3)                      !BMW
7574: f9eb:                                                                         !BMW
7575: f9eb:         FIELD.INDEX% = I% + 38                                          !BMW
7576: f9fc:         FIELD$(FIELD.INDEX%) =                                      \   !BMW
7577: fa59:             SOURCE.TEXT$(VAL(LEFT$(SOURCE.RECORD$(SOURCE.INDEX%),3)))   !BMW
7578: fa59:                                                                         !BMW
7579: fa59:         CALL DM.VISIBLE(STR$(FIELD.INDEX%),"TRUE")                      !BMW
7580: fa86:         CALL DM.RO.FIELD(FIELD.INDEX%)                                  !BMW
7581: fa99:                                                                         !BMW
7582: fa99:     NEXT I%                                                             !BMW
7583: fab4:                                                                         !BMW
7584: fab4:     FIELD$(U0411.PAGE%) =                                           \   !BMW
7585: fb3d:         RIGHT$((STRING$(7," ") +                                    \   !BMW
7586: fb3d:         "Page " + STR$(SOURCE.PAGE%) +                              \   !BMW
7587: fb3d:         " of "  + STR$(SOURCE.TOTAL.PAGES%)),18)                        !BMW
7588: fb3d:                                                                         !BMW
7589: fb3d:     ! IF results per page is not a full page                            !BMW
7590: fb3d:     IF SOURCE.THIS.PAGE% < SOURCES.PER.PAGE% THEN BEGIN                 !BMW
7591: fb55:                                                                         !BMW
7592: fb55:         ! For each remaining row                                        !BMW
7593: fb55:         FOR I% = (SOURCE.THIS.PAGE% + 1) TO                    \        !BMW
7594: fb67:                  SOURCES.PER.PAGE%                                      !BMW
7595: fb67:                                                                         !BMW
7596: fb67:             FIELD.INDEX% = I% + 2                                       !BMW
7597: fb78:             FIELD$(FIELD.INDEX%) = " " ! Clear                          !BMW
7598: fb9d:                                                                         !BMW
7599: fb9d:             FIELD.INDEX% = I% + 20                                      !BMW
7600: fbae:             FIELD$(FIELD.INDEX%) = "   " ! Clear                        !BMW
7601: fbd3:                                                                         !BMW
7602: fbd3:             FIELD.INDEX% = I% + 38                                      !BMW
7603: fbe4:             FIELD$(FIELD.INDEX%) = STRING$(34," ") ! Clear              !BMW
7604: fc10:                                                                         !BMW
7605: fc10:             ! Hide the field                                            !BMW
7606: fc10:             CALL DM.VISIBLE(STR$(FIELD.INDEX%),"FALSE")                 !BMW
7607: fc3d:                                                                         !BMW
7608: fc3d:         NEXT I%                                                         !BMW
7609: fc5c:                                                                         !BMW
7610: fc5c:     ENDIF                                                               !BMW
7611: fc64:                                                                         !BMW
7612: fc64:     RETURN                                                              !BMW
7613: fc74:                                                                         !BMW
7614: fc74: \***********************************************************************
7615: fc74: \***
7616: fc74: \***    ERROR.DETECTED
7617: fc74: \***
7618: fc74: \***********************************************************************
7619: fc74: ERROR.DETECTED:
7620: fc84: 
7621: fc84:     ERROR.COUNT% = ERROR.COUNT% + 1
7622: fc90: 
7623: fc90:     ! IF potential infinite loop
7624: fc90:     IF ERROR.COUNT% > 1 THEN BEGIN
7625: fc9f:         STOP
7626: fcac:     ENDIF
7627: fcb4: 
7628: fcb4:     CALL STANDARD.ERROR.DETECTED(ERRN, ERRF%, ERRL, ERR)
7629: fce1: 
7630: fce1: END SUB
7631: fcf5: 
7632: fcf5: End of Compilation
