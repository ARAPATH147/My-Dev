   1: 0003: \***********************************************************************
   2: 0003: \*
   3: 0003: \* Program: XBACKUP          Jaya Kumar Inbaraj              27/01/2014
   4: 0003: \*
   5: 0003: \* FOD260 - Enhanced Backup and Recovery
   6: 0003: \*
   7: 0003: \* This program will compress files in directories and the 3 digit
   8: 0003: \* extension will be constructed using the hex value of the
   9: 0003: \* month as the 1st digit and the date of the month as the last 2 digits
  10: 0003: \* of the extension e.g. a file created on the 1st of December would
  11: 0003: \* have the extension C01. There will be some changes made to the cross
  12: 0003: \* disk backup configuration file BKPSCRPT. A new directory will be
  13: 0003: \* created on both controller hard drives named XDISKALT. This directory
  14: 0003: \* will be used to backup directories when the secondary controller is
  15: 0003: \* configured to run the store.
  16: 0003: \*
  17: 0003: \* The application is scheduled to start by SLEEPER every day with a
  18: 0003: \* passed flag to indicate a Full or Incremental backup. The
  19: 0003: \* application reads in the defined backup script, which has a list of
  20: 0003: \* files and directories to archive as well as the location of the
  21: 0003: \* archive.  Each archive will have the date and month in hex
  22: 0003: \* (i.e. 1st December = C01) as an extension. Archives are kept for a
  23: 0003: \* configurable amount of time, currently 14 days' worth of backups
  24: 0003: \* will be available.
  25: 0003: \*
  26: 0003: \* SCRIPT FILE
  27: 0003: \* ===========
  28: 0003: \* BKPSCRPT file would be in following record format:
  29: 0003: \*
  30: 0003: \*      COMMAND          REQUIRED VALUES FOLLOWING
  31: 0003: \*      -------          -------------------------
  32: 0003: \*      TIME RANGE       START TIME     END TIME
  33: 0003: \*      DAYS TO KEEP     NO. OF DAYS
  34: 0003: \*      BACKUP           DIRECTORY      PRIMARY     SECONDARY
  35: 0003: \*                                      ARCHIVE     ARCHIVE
  36: 0003: \*                                      DIRECTORY   DIRECTORY
  37: 0003: \*      EXCLUDE          FILE NAME
  38: 0003: \*
  39: 0003: \* PASSED PARAMTERS
  40: 0003: \* ================
  41: 0003: \* Parameters  : SLEEPER OR "" (If SUPPORT run)
  42: 0003: \* plus either   F             for Full Backup
  43: 0003: \*      or       I             for an Incremental Backup
  44: 0003: \*
  45: 0003: \* INPUT AND OUTPUT FILES
  46: 0003: \* ======================
  47: 0003: \* Input files : BKPSCRPT.TXT  (Backup Script File)
  48: 0003: \*               BKPEXCL.DAT   (Backup Exclude File)
  49: 0003: \*               BKPLIST.MDD   (Backup List File)
  50: 0003: \*
  51: 0003: \* Output files: XBACKUP.LOG   (XBACKUP Log File)
  52: 0003: \*               BKPLIST.MDD   (Backup List File)
  53: 0003: \*               BKPFAILC.MDD  (Backup Fail File for C drive)
  54: 0003: \*               BKPFAILD.MDD  (Backup Fail File for D drive)
  55: 0003: \*               BKPEXCL.DAT   (Backup Exclude File)
  56: 0003: \*
  57: 0003: \*======================================================================
  58: 0003: \*                   V E R S I O N   C O N T R O L
  59: 0003: \* PLEASE UPDATE RUN VERSION NUMBER STATUS.TEXT.MSG$(0)
  60: 0003: \*======================================================================
  61: 0003: \*
  62: 0003: \* Version B               Jaya kumar Inbaraj                 04/04/2014
  63: 0003: \* FOD260 - Enhanced Backup and Recovery
  64: 0003: \* Updated the code with respect to the changes in XBKOK file format.
  65: 0003: \* Added ONS Re-run option. Also updated the coding standards with
  66: 0003: \* respect to internal review comments.
  67: 0003: \*
  68: 0003: \* Version C               Jaya kumar Inbaraj                 10/04/2014
  69: 0003: \* FOD260 - Enhanced Backup and Recovery
  70: 0003: \* Worked on Internal review comments and coding standards
  71: 0003: \* Commented out the Minor error flag usage in XBKOK.
  72: 0003: \*
  73: 0003: \* Version D               Jaya kumar Inbaraj                 24/04/2014
  74: 0003: \* FOD260 - Enhanced Backup and Recovery
  75: 0003: \* Updated the code with respect to the CR2 changes.
  76: 0003: \*
  77: 0003: \* Version E               Jaya kumar Inbaraj                 29/04/2014
  78: 0003: \* FOD260 - Enhanced Backup and Recovery
  79: 0003: \* Renamed few function names based on Internal review comments
  80: 0003: \*
  81: 0003: \* Version F               Jaya kumar Inbaraj                 08/05/2014
  82: 0003: \* FOD260 - Enhanced Backup and Recovery
  83: 0003: \* Worked on Application Management Team review comments
  84: 0003: \*
  85: 0003: \* Version G               Jaya kumar Inbaraj                 14/05/2014
  86: 0003: \* FOD260 - Enhanced Backup and Recovery
  87: 0003: \* Worked on Application Management Team review comments
  88: 0003: \*
  89: 0003: \* Version H               Dave Constable                     16/05/2014
  90: 0003: \* FOD260 - Enhanced Backup and Recovery
  91: 0003: \* Application Management Team review comments
  92: 0003: \*
  93: 0003: \* Version I     Jaya kumar Inbaraj / Dave Constable          21/05/2014
  94: 0003: \* FOD260 - Enhanced Backup and Recovery
  95: 0003: \* Internal and Application Management Team review comments
  96: 0003: \* QC659 - corrected for files with no extension
  97: 0003: \* QC650 - added create for missing XBKOK file
  98: 0003: \*
  99: 0003: \* Version J               Jaya kumar Inbaraj                 03/06/2014
 100: 0003: \* FOD260 - Enhanced Backup and Recovery
 101: 0003: \* QC677 - Corrected the BKPSCRPT start time validation
 102: 0003: \* Corrected the parameter validation in Command mode.
 103: 0003: \* Updated the code for older files purging.
 104: 0003: \*
 105: 0003: \* Version K                  Dave Constable                  03/06/2014
 106: 0003: \* FOD260 - Enhanced Backup and Recovery changes to enable CR for
 107: 0003: \* configurable Full backup day and code review changes
 108: 0003: \* QC 717 - force BKPFAIL on locked files at backup also
 109: 0003: \*
 110: 0003: \* Version L                  Dave Constable                  25/06/2014
 111: 0003: \* FOD260 - Enhanced Backup and Recovery
 112: 0003: \* Code review changes; alignment of file open status,
 113: 0003: \* QC 719 - opened the BKPLIST file as locked to avoid being unable to
 114: 0003: \* write later
 115: 0003: \* QC 808 - correctly ignore forcing next day if null set in script
 116: 0003: \*
 117: 0003: \* Version M                  Dave Constable                  14/07/2014
 118: 0003: \* FOD260 - Enhanced Backup and Recovery
 119: 0003: \* QC809 - corrected case to match on exclusions
 120: 0003: \*
 121: 0003: \* Version N               Jaya kumar Inbaraj                 01/08/2014
 122: 0003: \* FOD260 - Enhanced Backup and Recovery
 123: 0003: \* QC 717 - Variable issues in storing distribution type is corrected.
 124: 0003: \* QC 719 - Locked the BKPLIST file throughout the program.
 125: 0003: \* QC 724 - Current BKPLIST file is excluded from BACKUP
 126: 0003: \* QC 947 - Adjusted the logic to correct the BACKUP flow.
 127: 0003: \*
 128: 0003: \* Version O               Jaya kumar Inbaraj                 22/08/2014
 129: 0003: \* FOD260 - Enhanced Backup and Recovery
 130: 0003: \* CR5 changes to have configuration files in both C and D drives. Also
 131: 0003: \* BKPFAIL.MDD file has been replaced with BKPFAILC.MDD and BKPFAILD.MDD
 132: 0003: \* to have separate BKPFAIL file for C and D drive.
 133: 0003: \* Also incorporated APPS management review comments and Internal
 134: 0003: \* review comments.
 135: 0003: \*
 136: 0003: \* Version P               Jaya kumar Inbaraj                 01/09/2014
 137: 0003: \* FOD260 - Enhanced Backup and Recovery
 138: 0003: \* QC1124 - BKPSCRPT end time processing issue is fixed.
 139: 0003: \*
 140: 0003: \* Version Q              Dave Constable                      08/09/2014
 141: 0003: \* FOD260 - Enhanced Backup and Recovery
 142: 0003: \* Corrected version marker (should have been P, was O, now Q)
 143: 0003: \* Array overflow seen in store 499 pilot. Added formatting to LOG to
 144: 0003: \* show total in each array count and the total.
 145: 0003: \* Reset of ARRAY.INDEX to the limit if second array in use.
 146: 0003: \*
 147: 0003: \* Version R               Jaya kumar Inbaraj                 09/09/2014
 148: 0003: \* FOD260 - Enhanced Backup and Recovery
 149: 0003: \* Allowed the background program to pass F/I also as parameter.
 150: 0003: \*
 151: 0003: \* Version S               Marc Hudson                        30/12/2014
 152: 0003: \* To get this in support of the Service Desk i've fixed an issue that
 153: 0003: \* would causes backup to error and stop. The error is when it tries to
 154: 0003: \* open a file that doesn't exist..
 155: 0003: \*
 156: 0003: \* Version T              Sreemol Mini                        10/03/2017
 157: 0003: \* Its noted that, XBACKUP hangs during lot of situations and doesn't 
 158: 0003: \* complete in scheduled time and goes upto 10.00am in some cases.
 159: 0003: \* As a result many JOBOK,POGOK failures reported. Issue is due to 
 160: 0003: \* millions of open and close happens on BKPEXCL.DAT, the number of
 161: 0003: \* open and close will increase based on total files available in 
 162: 0003: \* in the directory plus the predefined exclusion list.Updated the   
 163: 0003: \* code to use an array instead to avoide open and close also moved   
 164: 0003: \* the BKPEXCL.DAT file location to W: drive for faster performance. 
 165: 0003: \*
 166: 0003: \* Version U               Ranjith Gopalankutty              30/06/2017
 167: 0003: \* Further enhancement has been made so that full backup is executed   
 168: 0003: \* every day rather than incremental backup, as there are hard coded   
 169: 0003: \* variables in the code which decides the execution day. code loop    
 170: 0003: \* will go in to incremental backup even if opted for full backup if   
 171: 0003: \* the run day is not sunday. Made the changes so that, full backup    
 172: 0003: \* is executed on the configured  days in sleeper. Also removed hard   
 173: 0003: \* coding so that, we can decide the number of days of execution using 
 174: 0003: \* sleeper rather than changing the code.                              
 175: 0003: \* Access to BKPLIST files has been taken off, as no more incremental  
 176: 0003: \* backups needs to be performed. We don't need to maintain the file   
 177: 0003: \* going forward
 178: 0003: \*
 179: 0003: \***********************************************************************
 180: 0003: 
 181: 0003: \***********************************************************************
 182: 0003: \*
 183: 0003: \*    Included code defining file related global variables
 184: 0003: \*
 185: 0003: \***********************************************************************
 186: 0003:     %INCLUDE BKPLIDEC.J86    ! BKPLIST function declaration
 187: 0003: \***********************************************************************
 188: 0003: \***********************************************************************
 189: 0003: \*
 190: 0003: \*    BKPLIST - Backup List File
 191: 0003: \*
 192: 0003: \*    %INCLUDE FOR VARIABLE DECLARATIONS
 193: 0003: \*
 194: 0003: \*        REFERENCE   :   BKPLIDEC.J86
 195: 0003: \*
 196: 0003: \*        FILE TYPE   :   Sequential
 197: 0003: \*
 198: 0003: \* Version A              Jaya Kumar Inbaraj              04/02/2014
 199: 0003: \* Original version.
 200: 0003: \*
 201: 0003: \* Version B              Jaya Kumar Inbaraj              09/04/2014
 202: 0003: \* FOD260 - Enhanced Backup and Recovery
 203: 0003: \* Changed all the file function variables from BKPLIST prefix to
 204: 0003: \* BKPLI prefix.
 205: 0003: \*
 206: 0003: \* Version C              Jaya Kumar Inbaraj              29/04/2014
 207: 0003: \* FOD260 - Enhanced Backup and Recovery
 208: 0003: \* Commented out the unused variables
 209: 0003: \*
 210: 0003: \* Version D              Dave Constable                  05/06/2014
 211: 0003: \* changes for generic full and incremental backups rather than forced 
 212: 0003: \* Sunday
 213: 0003: \*
 214: 0003: \***********************************************************************
 215: 0003: \***********************************************************************
 216: 0003: 
 217: 0003:     ! Changed the File related variables from BKPLIST to BKPLI prefix   !BJK
 218: 0003:     STRING GLOBAL                     \
 219: 0003: \        BKPLIST.CRLF$,                \                                !CJK
 220: 0003:         BKPLI.FILE.NAME$,             \ BKPLIST file name
 221: 0003:         BKPLI.FILENAME$,              \ File present in BKPLIST
 222: 0003:         BKPLI.FULL.EXIST$,            \                                 !DDC
 223: 0003:         BKPLI.FULL.FILE.CHNG$,        \                                 !DDC
 224: 0003:         BKPLI.INCREMENTAL.EXIST$(1),  \                                 !DDC
 225: 0003:         BKPLI.INCREMENTAL.FILE.CHNG$(1), \                              !DDC
 226: 0003:         BKPLI.VALUE$                                                    !DDC        
 227: 0003: 
 228: 0003:     ! Changed the File related variables from BKPLIST to BKPLI prefix   !BJK
 229: 0003:     INTEGER*2 GLOBAL                  \
 230: 0003: \        BKPLI.RECL%,                  \                                !CJK
 231: 0003:         BKPLI.RECORD.NUM%,            \
 232: 0003:         BKPLI.REPORT.NUM%,            \
 233: 0003:         BKPLI.SESS.NUM%
 234: 0003: 
 235: 0003:     INTEGER*1 GLOBAL                  \
 236: 0003:         BKPLIST.NO.OF.FIELDS%
 237: 0003: 
 238: 0003: 
 239: 0003:     %INCLUDE HSIUFDEC.J86    ! OS FTP function declaration              !KDC
 240: 0003: !*****************************************************************************
 241: 0003: !*****************************************************************************
 242: 0003: !***
 243: 0003: !***    %INCLUDE FOR ADXHSIUF FTP TRUSERS FILE - FIELD DECLARATIONS
 244: 0003: !***                                             FILE REFERENCE PARAMETERS
 245: 0003: !***
 246: 0003: !***                      FILE TYPE    : SEQUENTIAL
 247: 0003: !***
 248: 0003: !***                      REFERENCE    : ADXHSIUF
 249: 0003: !***
 250: 0003: !***           VERSION A : DAVE CONSTABLE   26/05/2014
 251: 0003: !***
 252: 0003: !***
 253: 0003: !*****************************************************************************
 254: 0003: !*****************************************************************************
 255: 0003: 
 256: 0003:     STRING      GLOBAL  HSIUF.FILE.NAME$    !* file name used in open
 257: 0003:     INTEGER*1   GLOBAL  HSIUF.OPEN          !* open (TRUE) or closed (FALSE)
 258: 0003:     STRING      GLOBAL  HSIUF.RECORD$       !* read/write record 
 259: 0003:     INTEGER*2   GLOBAL  HSIUF.REPORT.NUM%   !* for error logging
 260: 0003:     INTEGER*2   GLOBAL  HSIUF.SESS.NUM%     !* session number allocation
 261: 0003:     
 262: 0003:     
 263: 0003:     %INCLUDE SLPCFDEC.J86    ! Sleeper control                          !KDC
 264: 0003: \*****************************************************************************
 265: 0003: \*****************************************************************************
 266: 0003: \***
 267: 0003: \***             %INCLUDE FOR SLEEPER CHECK FILE - FIELD DECLARATIONS
 268: 0003: \***                                          FILE REFERENCE PARAMETERS
 269: 0003: \***
 270: 0003: \***                      FILE TYPE    :
 271: 0003: \***
 272: 0003: \***                      REFERENCE    : slpcfdeb.J86
 273: 0003: \***
 274: 0003: \***      Version A             Steve Windsor          8.2.93
 275: 0003: \***
 276: 0003: \***      Version B             Richard Foster         28.6.93
 277: 0003: \***
 278: 0003: \***      Version C             Mark Goode             6.03.00
 279: 0003: \***
 280: 0003: \***      Version D         Jaya Kumar Inbaraj               28/04/2014
 281: 0003: \***      FOD260 - Enhanced Backup and Recovery
 282: 0003: \***      Updated Filler variable usage has been explained. Added two
 283: 0003: \***      variables related to SLPCF Filler variable.
 284: 0003: \***
 285: 0003: \*****************************************************************************
 286: 0003: \*****************************************************************************
 287: 0003: 
 288: 0003: 
 289: 0003:   STRING GLOBAL          \
 290: 0003:     SLPCF.FILE.NAME$
 291: 0003: 
 292: 0003:   INTEGER*2 GLOBAL        \
 293: 0003:     SLPCF.REPORT.NUM%,    \
 294: 0003:     SLPCF.SESS.NUM%
 295: 0003: 
 296: 0003:   STRING GLOBAL              \
 297: 0003:     SLPCF.APP.NAME$,         \ 21 bytes - Application to be started
 298: 0003:     SLPCF.RUN.FREQUENCY$,    \ 1 byte   - d=daily, m=monthly              !BRCF
 299: 0003:     SLPCF.DAY.NUM$,          \ 6 bytes  - blank = evry day                !BRCF
 300: 0003:                              \            1 = sun  2 = mon                !BRCF
 301: 0003:               \            3 = tue  4 = wed                !BRCF
 302: 0003:               \            5 = thu  6 = fri                !BRCF
 303: 0003:               \            7 = sat                         !BRCF
 304: 0003:               \         OR nn = date (monthly run) up to   !BRCF
 305: 0003:               \                 3 2-digit numbers          !BRCF
 306: 0003:     SLPCF.RUN.TIME$,         \ 6 bytes  - time due to be started (HHMMSS) !BRCF
 307: 0003:     SLPCF.LAST.RUN.DATE$,    \ 6 bytes  - Date last run (YYMMDD)          !BRCF
 308: 0003:     SLPCF.FILE.PRESENT$,     \ 3 bytes  - Report number of file which must!BRCRF
 309: 0003:                              \            be present                      !BRCF
 310: 0003:     SLPCF.FILE.PRESENT.NAME$,\ 8 bytes  - Name of above file              !BRCF
 311: 0003:     SLPCF.FILE.ABSENT$,      \ 3 bytes  - Report number of file which must!BRCF
 312: 0003:                              \            not be present                  !BRCF
 313: 0003:     SLPCF.FILE.ABSENT.NAME$, \ 8 bytes  - Name of above file              !BRCF
 314: 0003:     SLPCF.NODE.ID$,          \ 2 bytes  - Node on which to run application!BRCF
 315: 0003:                              \            CE = Master only                !BRCF
 316: 0003:               \            CF = File Server only           !BRCF
 317: 0003:               \            DE = Single only                !BRCF
 318: 0003:               \            SM = Single and Master          !BRCF
 319: 0003:               \            SF = Single and File Server     !BRCF
 320: 0003:     SLPCF.SOFTS.REC$,        \ 4 bytes  - The record number on the SOFTS file !LMG
 321: 0003:     SLPCF.FILLER$,           \ 12 bytes - Format can be xYYYYYYYYY      !DJK LMG
 322: 0003:               \ where; If x is 1-9 then the first x characters of Y are !DJK
 323: 0003:               \ passed to the starting application as a start parameter !DJK
 324: 0003:               \ and a CrLf                                              !DJK
 325: 0003:     SLPCF.PARM$              ! Value Y from SLPCF.FILLER                !DJK
 326: 0003: 
 327: 0003:   INTEGER*2 GLOBAL        \
 328: 0003:     SLPCF.RECL%           ! Length of record
 329: 0003: 
 330: 0003:   INTEGER*1 GLOBAL        \                                             !DJK
 331: 0003:     SLPCF.PARM.LEN%       ! Value X from SLPCF.FILLER                   !DJK
 332: 0003: 
 333: 0003:   INTEGER*4 GLOBAL        \
 334: 0003:     SLPCF.REC.NO%         ! Record Number
 335: 0003: 
 336: 0003:     %INCLUDE XBKOKDEC.J86    ! XBKOK function declaration
 337: 0003: \**********************************************************************
 338: 0003: \*
 339: 0003: \*                        XBKOK FILE VARIABLES
 340: 0003: \*
 341: 0003: \*  Version A                David Artiss          1st September 2009
 342: 0003: \*
 343: 0003: \*  Version B                Sandhya Pillai        26th March 2014
 344: 0003: \*  FOD260 - Enhanced Backup and Recovery
 345: 0003: \*
 346: 0003: \*  Version C             Jaya Kumar Inbaraj              24/04/2014
 347: 0003: \*  FOD260 - Enhanced Backup and Recovery
 348: 0003: \*  Updated the code with respect to the CR2 changes
 349: 0003: \*
 350: 0003: \**********************************************************************
 351: 0003: 
 352: 0003:   STRING GLOBAL           \
 353: 0003: \    XBKOK.END.DATE$,      \ 6 byte                                     !CJK !BSP
 354: 0003: \    XBKOK.END.TIME$,      \ 4 byte                                     !CJK !BSP
 355: 0003:     XBKOK.FILE.NAME$,     \
 356: 0003:     XBKOK.RECORD$,        \ 22 bytes
 357: 0003:     XBKOK.START.DATE$,    \ 6 byte                                      !BSP
 358: 0003:     XBKOK.START.TIME$,    \ 4 byte                                      !BSP
 359: 0003:     XBKOK.STATUS$,        \ 1 byte                                      !BSP
 360: 0003:     XBKOK.TYPE$           ! 1 byte                                      !BSP
 361: 0003: 
 362: 0003:   INTEGER*2 GLOBAL        \
 363: 0003:     XBKOK.RECL%,          \
 364: 0003:     XBKOK.SESS.NUM%,      \
 365: 0003:     XBKOK.REPORT.NUM%
 366: 0003: 
 367: 0003: 
 368: 0003: \***********************************************************************
 369: 0003: \*
 370: 0003: \*    Included code defining function related global variables
 371: 0003: \*
 372: 0003: \***********************************************************************
 373: 0003:     %INCLUDE PSBF01G.J86     ! Application log
 374: 0003: REM \
 375: 0003: \*******************************************************************************
 376: 0003: \*******************************************************************************
 377: 0003: \***
 378: 0003: \***       %INCLUDE FOR GLOBAL DEFINITIONS FOR FUNCTION APPLICATION.LOG
 379: 0003: \***
 380: 0003: \***                FUNCTION NUMBER    : PSBF01
 381: 0003: \***
 382: 0003: \***                REFERENCE          : PSBF01G.J86
 383: 0003: \***
 384: 0003: \***                DATE OF LAST AMENDMENT  - 27/2/86
 385: 0003: \***
 386: 0003: \***
 387: 0003: \*******************************************************************************
 388: 0003: 
 389: 0003:       INTEGER GLOBAL  F01.RETURN.CODE%
 390: 0003: 
 391: 0003: 
 392: 0003:     %INCLUDE PSBF02G.J86     ! Update Date
 393: 0003: REM\
 394: 0003: \*******************************************************************************
 395: 0003: \*******************************************************************************
 396: 0003: \***
 397: 0003: \***        INCLUDE       : UPDATE.DATE globals
 398: 0003: \***
 399: 0003: \***        REFERENCE     : PSBF02G.J86
 400: 0003: \***
 401: 0003: \***        Version A     Bruce Scriver      4th March 1986
 402: 0003: \*** 
 403: 0003: \***        Version B     Andrew Wedgeworth   6th July 1992
 404: 0003: \***        Removal of return code field which no longer required.
 405: 0003: \***
 406: 0003: \*******************************************************************************
 407: 0003: \*******************************************************************************
 408: 0003: 
 409: 0003:       STRING   GLOBAL F02.DATE$
 410: 0003: 
 411: 0003:       ! 1 line deleted from here                                       ! BAW
 412: 0003: 
 413: 0003:     %INCLUDE PSBF13G.J86     ! PSDATE function
 414: 0003: REM\
 415: 0003: \*******************************************************************************
 416: 0003: \*******************************************************************************
 417: 0003: \***
 418: 0003: \***        INCLUDE       : PSDATE globals
 419: 0003: \***
 420: 0003: \***        REFERENCE     : PSBF13G.J86
 421: 0003: \***
 422: 0003: \***     VERSION A                                  Bruce Scriver  6th Mar 86             
 423: 0003: \***            
 424: 0003: \***     VERSION B                                  Janet Lawrence 17 Aug 90
 425: 0003: \***     Add global to be used to indicate whether or not the function should
 426: 0003: \***     log an event when an invalid date is passed to it.
 427: 0003: \***
 428: 0003: \***     VERSION C                               Andrew Wedgeworth 17 July 92
 429: 0003: \***     Return code removed as no longer required.
 430: 0003: \***
 431: 0003: \*******************************************************************************
 432: 0003: \*******************************************************************************
 433: 0003: 
 434: 0003:       STRING    GLOBAL F13.DAY$,			\
 435: 0003:                        F13.DISPLAY.MESSAGE$		! BJAL
 436: 0003: 
 437: 0003: 
 438: 0003:     %INCLUDE PSBF20G.J86     ! Session number Utility
 439: 0003: REM\
 440: 0003: \*******************************************************************************
 441: 0003: \*******************************************************************************
 442: 0003: \***
 443: 0003: \***     %INCLUDE GLOBAL VARIABLE DEFINITIONS FOR SESS.NUM.UTILITY FUNCTION
 444: 0003: \***
 445: 0003: \***                       REFERENCE     : PSBF20G.J86
 446: 0003: \*** 
 447: 0003: \***     Version A              Bruce Scrive                   5th May 1988   
 448: 0003: \*** 
 449: 0003: \***     Version B              Robert Cowey                   7th May 1991
 450: 0003: \***     Global variable F20.INTEGER.FILE.NO% changed from one byte integer
 451: 0003: \***     to two byte integer.
 452: 0003: \***
 453: 0003: \***     Version D              Andrew Wedgeworth             1st July 1992
 454: 0003: \***     F20.RETURN.CODE% removed as it is no longer required.
 455: 0003: \***
 456: 0003: \*******************************************************************************
 457: 0003: \*******************************************************************************
 458: 0003: 
 459: 0003:       STRING    GLOBAL F20.FILE.NAME$,                                 \
 460: 0003:                        F20.STRING.FILE.NO$,                            \
 461: 0003:                        F20.TABLE.DIMENSIONED.FLAG$,                    \
 462: 0003:                        SESS.NUM.TABLE$(1)
 463: 0003: 
 464: 0003:       INTEGER*2 GLOBAL F20.INTEGER.FILE.NO%
 465: 0003: 
 466: 0003:       ! 1 line deleted from here                                       ! DAW 
 467: 0003: 
 468: 0003: \***********************************************************************
 469: 0003: \*
 470: 0003: \*    Global variable definitions
 471: 0003: \*
 472: 0003: \***********************************************************************
 473: 0003:     STRING GLOBAL                   \
 474: 0003:         FILE.OPERATION$
 475: 0003: 
 476: 0003:     INTEGER*2 GLOBAL                \
 477: 0003:         CURRENT.REPORT.NUM%,        \
 478: 0003:         FILE.RC2%,                  \
 479: 0003:         RETURN.VALUE.CHECK%         !                                   !KDC
 480: 0003: 
 481: 0003: \***********************************************************************
 482: 0003: \*
 483: 0003: \*    Local Variables
 484: 0003: \*
 485: 0003: \***********************************************************************
 486: 0003:     STRING                          \
 487: 0003:         ADX.PARM.2$,                \
 488: 0003:         BACKUP.DAYS$,               \                                   !KDC
 489: 0003:         BKPEXCL.FILE.NAME$,         \
 490: 0003:         BKPEXCL.FORM$,              \
 491: 0003:         BKPEXCL.VALUE$,             \
 492: 0003:         BKPFAIL.FILE$,              \
 493: 0003:         BKPFAILC.FILE.NAME$,        \                                   !OJK
 494: 0003:         BKPFAILD.FILE.NAME$,        \                                   !OJK
 495: 0003:         BKPFAIL.FORM$,              \
 496: 0003:         BKPLIST.COMP.FILENAME$,     \
 497: 0003:         BKPLIST.FILE.NAME.C$,       \                                   !OJK
 498: 0003:         BKPLIST.FORM$,              \
 499: 0003:         BKPLIST.RECD$,              \                                   !KDC
 500: 0003:         BKPSCRPT.COMMAND$,          \
 501: 0003:         BKPSCRPT.DAYS.TO.KEEP$,     \
 502: 0003:         BKPSCRPT.DIRECTORY$,        \
 503: 0003:         BKPSCRPT.END.TIME$,         \                                   !PJK
 504: 0003:         BKPSCRPT.FILE.EXCLUSION$,   \
 505: 0003:         BKPSCRPT.FILE.NAME$,        \
 506: 0003:         BKPSCRPT.OUT.FILE.NAME$,    \
 507: 0003:         BKPSCRPT.START.TIME$,       \
 508: 0003:         BKPSCRPT.VALUE$,            \
 509: 0003:         C.DRIVE.ALTERNATE.DIRECTORY$,   \                               !KDC
 510: 0003:         C.DRIVE.IMAGE.DIRECTORY$,   \                                   !KDC
 511: 0003:         CE.CNTR$,                   \  ! CE value                       !CJK
 512: 0003:         CE.C.XDISKALT$,             \  ! Renamed the variable           !FJK
 513: 0003:         CE.C.XDISKIMG$,             \  ! Renamed the variable           !FJK
 514: 0003:         CE.D.XDISKALT$,             \  ! Renamed the variable           !FJK
 515: 0003:         CE.D.XDISKIMG$,             \  ! Renamed the variable           !FJK
 516: 0003:         CE.NODE.NAME$,              \                                   !KDC
 517: 0003:         CF.CNTR$,                   \  ! CF value                       !CJK
 518: 0003:         CF.C.XDISKALT$,             \  ! Renamed the variable           !FJK
 519: 0003:         CF.C.XDISKIMG$,             \  ! Renamed the variable           !FJK
 520: 0003:         CF.D.XDISKALT$,             \  ! Renamed the variable           !FJK
 521: 0003:         CF.D.XDISKIMG$,             \  ! Renamed the variable           !FJK
 522: 0003:         CF.NODE.NAME$,              \                                   !KDC
 523: 0003:         CNTR.DIR$,                  \                                   !IDK
 524: 0003:         CNTLR.ID$,                  \  ! Current Controller node        !CJK
 525: 0003:         COMMA.VALUE$,               \
 526: 0003:         COMMAND.STRING$,            \
 527: 0003:         CONFIGURED.NODES$,          \
 528: 0003:         CONSTANT.DAYS$(1),          \                                   !LDC
 529: 0003:         CRLF$,                      \
 530: 0003:         CURR.DATE$,                 \
 531: 0003:         CURR.TIME$,                 \
 532: 0003:         D.DRIVE.IMAGE.DIRECTORY$,   \                                   !KDC
 533: 0003:         D.DRIVE.ALTERNATE.DIRECTORY$,   \                               !KDC
 534: 0003:         DATE.VALUE$,                \  ! Renamed the variable           !FJK
 535: 0003:         DIR.FILE.NAME$,             \  ! File name from DIR command     !CJK
 536: 0003:         DIR.OUT$,                   \  ! DIR command output file        !CJK
 537: 0003:         DIR.SEC.OUT$,               \  ! Renamed the variable           !BJK
 538: 0003:         DIREC.TO.SEARCH$,           \  ! Renamed the variable           !FJK
 539: 0003:         DIR.VALUE$,                 \  ! DIR command line value         !CJK
 540: 0003:         DIR.SEC.VALUE$,             \  ! DIR command line value         !BJK
 541: 0003:         DIRECTORY.SEARCH$,          \  ! Directory value                !CJK
 542: 0003:         DIRECTORY.SEARCH.VALUE$,    \  ! Search inside Directory        !CJK
 543: 0003:         DIST.TYPE$,                 \  ! Distribution type              !CJK
 544: 0003:         DRIVE$,                     \
 545: 0003:         EXT.MDD$,                   \  ! Extension MDD                  !CJK
 546: 0003:         EXTENSION$,                 \                                   !KDC
 547: 0003:         FIELDS$(1),                 \                                   !KDC
 548: 0003:         FILE.EXT.VALUE$,            \  ! Renamed the variable           !FJK
 549: 0003:         FILE.HAS.CHANGED$,          \
 550: 0003:         FILE.IS.PRESENT$,           \
 551: 0003:         FILE.NAME.VALUE$,           \  ! Renamed the variable           !FJK
 552: 0003:         FTP.FILE.NAME$,             \
 553: 0003:         FTP.PASSWORD$,              \  ! Extracted password from OS file!KDC
 554: 0003:         FTP.USER$,                  \                                   !KDC
 555: 0003:         FTPOUT.FILE.NAME$,          \
 556: 0003:         FULL.DATE$,                 \                                   !KDC
 557: 0003:         FULL.DAY$,                  \                                   !KDC
 558: 0003:         FULL.DEL.EXT.MDD$,          \  ! Full Extension to delete       !KDC
 559: 0003:         FULL.EXT.MDD$,              \  ! Full Extension MDD             !KDC
 560: 0003:         FUNC.FLAG$,                 \
 561: 0003:         HHMM.STATUS.MSG$,           \
 562: 0003:         IP.ADDRESS$,                \
 563: 0003:         MASTER$,                    \  ! Current Master controller      !CJK
 564: 0003:         MONTH$,                     \
 565: 0003:         PARM.BACKGRND$,             \                                   !RJK
 566: 0003:         PARM.BACKGRND.FULL$,        \                                   !RJK
 567: 0003:         PARM.BACKGRND.INC$,         \                                   !RJK
 568: 0003:         PARM.FULL$,                 \                                   !KDC
 569: 0003:         PARM.INCREMENTAL$,          \                                   !KDC
 570: 0003:         PARM.ONS$,                  \                                   !KDC
 571: 0003:         PARM.RERUN.FULL$,           \                                   !DJK
 572: 0003:         PARM.RERUN.INC$,            \                                   !DJK
 573: 0003:         PARM.SLEEPER$,              \                                   !KDC
 574: 0003:         PARM.SLEEPER.FULL$,         \                                   !DJK
 575: 0003:         PARM.SLEEPER.INC$,          \                                   !DJK
 576: 0003:         PASSED.STRING$,             \
 577: 0003:         PREFIX.HHMMSS.PROG$,        \  ! Included new variable          !FJK
 578: 0003:         PROGRAM$,                   \
 579: 0003:         PSDATE.DATE$,               \                                   !KDC
 580: 0003:         REMAINING.VALUE$,           \
 581: 0003:         RUN.ALLOWED$,               \                                   !URG
 582: 0003:         RUN.TYPE$,                  \  ! To capture Backup run type     !DJK
 583: 0003:         STATUS.END$,                \
 584: 0003:         STATUS.MAJOR.ERROR$,        \
 585: 0003:         STATUS.MSG$,                \
 586: 0003:         STATUS.TEXT.MSG$(1),        \                                   !KDC
 587: 0003:         STATUS.TEXT.ERROR$(1),      \                                   !KDC
 588: 0003:         STATUS.START$,              \
 589: 0003:         TEMP.DIRECTORY.NAME$,       \                                   !KDC
 590: 0003:         TEMP.FILE.NAME$,            \
 591: 0003:         TODAY.BKPLIST.REC$,         \                                   !KDC
 592: 0003:         TODAY.BKPLIST.REC.ERR$,     \                                   !KDC
 593: 0003:         TODAY.DATE$,                \
 594: 0003:         VAR.STRING.1$,              \
 595: 0003:         VAR.STRING.2$,              \
 596: 0003:         VERSION$,                   \                                   !OJK
 597: 0003:         XBACK.LOG.FILE.NAME$,       \
 598: 0003:         XBACK.LOG.FORM$,            \
 599: 0003:         XBACK.LOG.LIVE.PATH$,       \
 600: 0003:         XBACK.LOG.REC$,             \
 601: 0003:         XBACK.NULL$,                \
 602: 0003:         XBACK.PIPE.NAME$,           \
 603: 0003:         XBACK.YES$,                 \
 604: 0003:         XBKLOG.VALUE$,              \
 605: 0003:         XBKOK.INTERIM.STATUS$,      \  ! Renamed the variable           !BJK
 606: 0003:         XBKPFTP.FORM$,              \  ! FTP form                       !CJK
 607: 0003:         XBKPFTP.LINE$,              \  ! FTP line                       !CJK
 608: 0003:         XBKTEMP.LOG$                   ! Renamed the variable           !FJK
 609: 0003: 
 610: 0003:     ! Grouping Arrays                                                   !CJK
 611: 0003:     STRING                          \
 612: 0003:         BKPEXCL.ARRAY$(1),          \ Array holding exclude files       !TSM
 613: 0003:         BKPEXCL.COMP.ARRAY$(1),     \ Array holding entire exclude files!TSM
 614: 0003:         BKPLIST.ARRAY$(1),          \
 615: 0003:         BKPLIST.SECOND.ARRAY$(1)       ! Renamed the variable           !BJK
 616: 0003: 
 617: 0003:     ! local integer 1 variables
 618: 0003:     INTEGER*1                       \
 619: 0003:         ADX.FUNCTION%,              \
 620: 0003:         ADX.INTEGER%,               \
 621: 0003:         BKPSCRPT.HH%,               \                                   !KDC
 622: 0003:         BKPSCRPT.MM%,               \                                   !KDC
 623: 0003:         BKPSCRPT.END.HH%,           \                                   !PJK
 624: 0003:         BKPSCRPT.END.MM%,           \                                   !PJK
 625: 0003:         CNTLR.CONFIG%,              \
 626: 0003:         COMMA.POSITION%,            \
 627: 0003:         CURR.HH%,                   \                                   !KDC
 628: 0003:         CURR.MM%,                   \                                   !KDC
 629: 0003:         DAYS.AFTER.FULL.BAKUP%,     \                                   !KDC
 630: 0003:         ERROR.COUNT%,               \
 631: 0003:         FILE.CHECK.1%,              \                                   !KDC
 632: 0003:         FILE.CHECK.2%,              \                                   !KDC
 633: 0003:         FILE.CHECK.3%,              \                                   !KDC
 634: 0003:         FILE.CHECK.4%,              \                                   !KDC
 635: 0003:         FULL.BACKUP.NOT.FOUND%,     \                                   !KDC
 636: 0003:         MASTER.AND.FILE.SERVER%,    \
 637: 0003:         NODE.POSITION%,             \
 638: 0003:         NUM.OF.ARRAYS%,             \  ! Included new variable          !FJK
 639: 0003:         RUN.ALLOWED%,               \                                   !URG
 640: 0003:         SLASH.POSITION%,            \
 641: 0003:         SLEEPER.DAY%,               \                                   !KDC
 642: 0003:         TODAY.BKPLIST.REC%,         \                                   !LDC
 643: 0003:         XBACK.ZERO%
 644: 0003:         
 645: 0003:     ! Grouping Boolean variables
 646: 0003:     INTEGER*1                       \
 647: 0003:         ALT.EXISTS,                 \  ! XDISKALT directory exist       !CJK
 648: 0003:         ALT.MASTER.ON,              \  ! CF present                     !CJK
 649: 0003:         BACKGROUND.RUN,             \
 650: 0003:         BACKUP.DIR.EXIST,           \                                   !KDC
 651: 0003:         BACKUP.OFF,                 \
 652: 0003:         BKPEXCL.OPEN,               \
 653: 0003:         BKPEXCL.RUN,                \
 654: 0003:         BKPFAILC.OPEN,              \                                   !OJK
 655: 0003:         BKPFAILD.OPEN,              \                                   !OJK
 656: 0003:         BKPLI.OPEN,                 \  ! Renamed the variable           !FJK
 657: 0003:         BKPSCRPT.ERROR,             \
 658: 0003:         BKPSCRPT.OPEN,              \
 659: 0003:         COMMA.PRESENT,              \                                   !KDC
 660: 0003:         DAY.SINCE.FULL%,            \                                   !KDC
 661: 0003:         EXCLUDE.PRESENT,            \
 662: 0003:         FALSE,                      \
 663: 0003:         FILE.MISSING,               \                                   !SMH
 664: 0003:         FILE.PRESENT,               \
 665: 0003:         FIRST.ARRAY.FOUND,          \
 666: 0003:         FSET.ON,                    \  ! FSET command allowed           !CJK
 667: 0003:         FTP.SUCCESS,                \                                   !KDC
 668: 0003:         IMG.EXISTS,                 \  ! XDISKIMG directory exist       !CJK
 669: 0003:         INCLUDE.RUN,                \  ! Backup process                 !CJK
 670: 0003:         IS.ARCHIVE.ON,              \                                   !HDC
 671: 0003:         OPEN.BKPFAILFILE,           \                                   !SMH
 672: 0003:         SECOND.ARRAY.FOUND,         \
 673: 0003:         SECOND.ARRAY.ON,            \
 674: 0003:         SLPCF.OPEN,                 \                                   !KDC
 675: 0003:         TEMP.2.OPEN,                \  ! Temp variable 2                !FJK
 676: 0003:         TEMP.OPEN,                  \
 677: 0003:         TMP.EXISTS,                 \  ! C:\TEMP directory exist        !CJK
 678: 0003:         TRUE,                       \
 679: 0003:         VALUE.PRESENT,              \  ! Value present                  !CJK
 680: 0003:         VALUE.EXISTS,               \
 681: 0003:         VALUE.EXISTS.2,             \                                   !HDC
 682: 0003:         XBACK.LOG.OPEN,             \
 683: 0003:         XBACK.OPEN,                 \
 684: 0003:         XBKOK.OPEN,                 \                                   !KDC
 685: 0003:         ZIP.FILE.EXISTS             !                                   !KDC
 686: 0003:                         
 687: 0003:     ! local integer 2 variables
 688: 0003:     INTEGER*2                       \
 689: 0003:         ARRAY.INDEX%,               \
 690: 0003:         ARRAY.LIMIT%,               \
 691: 0003:         ARRAY.SECOND.INDEX%,        \  ! Renamed the variable           !BJK
 692: 0003:         BEGIN.POS%,                 \                                   !KDC
 693: 0003:         BKPEXCL.ARRAY.INDEX%,       \ Exclude array's index             !TSM
 694: 0003:         BKPEXCL.ARRAY.LIMIT%,       \ Exclude array's limit             !TSM
 695: 0003:         BKPEXCL.COMP.INDEX%,        \ Complete exclude array's index    !TSM
 696: 0003:         BKPEXCL.COMP.LIMIT%,        \ Complete exclude array's limit    !TSM
 697: 0003:         BKPEXCL.COMP.POS%,          \ For holding current index number  !TSM
 698: 0003:                                     \ of complete exclude array         !TSM
 699: 0003:         BKPEXCL.INDEX%,             \ For holding current index number  !TSM
 700: 0003:                                     \ of exclude array                  !TSM
 701: 0003:         BKPEXCL.REPORT.NUM%,        \
 702: 0003:         BKPEXCL.SESS.NUM%,          \
 703: 0003:         BKPFAILC.REPORT.NUM%,       \                                   !OJK
 704: 0003:         BKPFAILD.REPORT.NUM%,       \                                   !OJK
 705: 0003:         BKPFAILC.SESS.NUM%,         \                                   !OJK
 706: 0003:         BKPFAILD.SESS.NUM%,         \                                   !OJK
 707: 0003:         BKPSCRPT.REPORT.NUM%,       \
 708: 0003:         BKPSCRPT.SESS.NUM%,         \
 709: 0003:         COMMA.POSITION.2%,          \  ! Renamed the variable           !BJK
 710: 0003:         EVENT.NUMBER%,              \
 711: 0003:         FILE.POSITION%,             \
 712: 0003:         INDEX%,                     \
 713: 0003:         MATCH.POS%,                 \                                   !KDC
 714: 0003:         MESSAGE.NUMBER%,            \
 715: 0003:         PASSED.INTEGER%,            \
 716: 0003:         SECOND.INDEX%,              \  ! Renamed the variable           !BJK
 717: 0003:         TEMP.REPORT.NUM%,           \
 718: 0003:         TEMP.REPORT.NUM.2%,         \  ! Renamed the variable           !BJK
 719: 0003:         TEMP.SESS.NUM%,             \
 720: 0003:         TEMP.SESS.NUM.2%,           \  ! Renamed the variable           !BJK
 721: 0003:         XBACK.LOG.REPORT.NUM%,      \
 722: 0003:         XBACK.LOG.SESS.NUM%,        \
 723: 0003:         XBACK.PIPE.REPORT.NUM%,     \
 724: 0003:         XBACK.PIPE.SESS.NUM%
 725: 0003: 
 726: 0003:     ! local integer 4 variables
 727: 0003:     INTEGER*4 ADXSERVE.RC%
 728: 0003: 
 729: 0003: \***********************************************************************
 730: 0003: \*
 731: 0003: \*    EXT included code defining file related external functions
 732: 0003: \*
 733: 0003: \***********************************************************************
 734: 0003:     %INCLUDE BKPLIEXT.J86    ! BKPLIST function definition
 735: 0003: \***********************************************************************
 736: 0003: \***********************************************************************
 737: 0003: \*
 738: 0003: \*    BKPLIST - Backup List File
 739: 0003: \*
 740: 0003: \*    %INCLUDE FOR EXTERNAL FUNCTIONS
 741: 0003: \*
 742: 0003: \*        REFERENCE   :   BKPLIEXT.J86
 743: 0003: \*
 744: 0003: \*        FILE TYPE   :   Sequential
 745: 0003: \*
 746: 0003: \* Version A              Jaya Kumar Inbaraj              04/02/2014
 747: 0003: \* Original version.
 748: 0003: \*
 749: 0003: \* Version B              Jaya Kumar Inbaraj              09/04/2014
 750: 0003: \* FOD260 - Enhanced Backup and Recovery
 751: 0003: \*
 752: 0003: \* Changed all the file function variables and Function names from
 753: 0003: \* BKPLIST prefix to BKPLI prefix.
 754: 0003: \*
 755: 0003: \***********************************************************************
 756: 0003: \***********************************************************************
 757: 0003: 
 758: 0003:     ! Function for setting File Name and Report Number
 759: 0003:     FUNCTION BKPLI.SET EXTERNAL                                   !BJK
 760: 0003:         INTEGER*1 BKPLI.SET                                       !BJK
 761: 0003:     END FUNCTION
 762: 0003: 
 763: 0003:     ! Function for reading BKPLIST records
 764: 0003:     FUNCTION READ.BKPLI EXTERNAL                                  !BJK
 765: 0003:         INTEGER*1 READ.BKPLI                                      !BJK
 766: 0003:     END FUNCTION
 767: 0003: 
 768: 0003:     ! Function for writing BKPLIST records
 769: 0003:     FUNCTION WRITE.BKPLI EXTERNAL                                 !BJK
 770: 0003:         INTEGER*1 WRITE.BKPLI                                     !BJK
 771: 0003:     END FUNCTION
 772: 0003:     %INCLUDE XBKOKEXT.J86    ! XBKOK function definition
 773: 0003: \**********************************************************************
 774: 0003: \*
 775: 0003: \*                 FUNCTION DEFINITIONS FOR THE XBKOK
 776: 0003: \*
 777: 0003: \*  Version A                David Artiss          1st September 2009
 778: 0003: \*
 779: 0003: \**********************************************************************
 780: 0003: 
 781: 0003:    FUNCTION XBKOK.SET EXTERNAL
 782: 0003:    END FUNCTION
 783: 0003: 
 784: 0003:   FUNCTION READ.XBKOK EXTERNAL
 785: 0003:    INTEGER*2 READ.XBKOK
 786: 0003:   END FUNCTION
 787: 0003: 
 788: 0003:   FUNCTION WRITE.XBKOK EXTERNAL
 789: 0003:    INTEGER*2 WRITE.XBKOK
 790: 0003:   END FUNCTION
 791: 0003: 
 792: 0003:   FUNCTION WRITE.XBKOK.HOLD EXTERNAL
 793: 0003:    INTEGER*2 WRITE.XBKOK.HOLD
 794: 0003:   END FUNCTION
 795: 0003: 
 796: 0003: 
 797: 0003: \***********************************************************************
 798: 0003: \*
 799: 0003: \*    Included code defining external Boots functions
 800: 0003: \*
 801: 0003: \***********************************************************************
 802: 0003:     %INCLUDE ADXCOPY.J86     ! To copy files
 803: 0003: \******************************************************************************
 804: 0003: \******************************************************************************
 805: 0003: \***                                                                        ***
 806: 0003: \***    %INCLUDE FOR SUBROUTINE ADXCOPYF (an I.B.M. system subroutine)      ***
 807: 0003: \***                                                                        ***
 808: 0003: \***         DATE WRITTEN  :  13th May 1988                                 ***
 809: 0003: \***                                                                        ***
 810: 0003: \******************************************************************************
 811: 0003: \******************************************************************************
 812: 0003: 
 813: 0003:    SUB  ADXCOPYF (RETC, INFILE, OUTFILE, OPT0, OPT1, OPT2) EXTERNAL
 814: 0003: 
 815: 0003:       INTEGER*4   RETC
 816: 0003:       STRING      INFILE, OUTFILE
 817: 0003:       INTEGER*2   OPT0, OPT1, OPT2
 818: 0003: 
 819: 0003:    END  SUB
 820: 0003: 
 821: 0003:     %INCLUDE ADXSERVE.J86    ! ADXSERVE function
 822: 0003: \******************************************************************************
 823: 0003: \******************************************************************************
 824: 0003: \***                                                                        ***
 825: 0003: \***    %INCLUDE FOR FUNCTION ADXSERVE (an I.B.M. system function)          ***
 826: 0003: \***                                                                        ***
 827: 0003: \***         AUTHOR        :  Bruce Scriver                                 ***
 828: 0003: \***                                                                        ***
 829: 0003: \***         DATE WRITTEN  :  14th March 1986                               ***
 830: 0003: \***                                                                        ***
 831: 0003: \***         DATE OF LAST REVISION  - 14th March 1986                       ***
 832: 0003: \***                                                                        ***
 833: 0003: \***                                                                        ***
 834: 0003: \******************************************************************************
 835: 0003: \******************************************************************************
 836: 0003: 
 837: 0003:    SUB ADXSERVE (RETURN.CODE%,                                                \
 838: 0003:                  ADX.FUNCTION%,                                               \
 839: 0003:                  ADX.PARM.1%,                                                 \
 840: 0003:                  ADX.PARM.2$)                                                 \
 841: 0003:    EXTERNAL
 842: 0003:   
 843: 0003:       STRING     ADX.PARM.2$
 844: 0003: 
 845: 0003:       INTEGER*2  ADX.FUNCTION%,                                               \
 846: 0003:                  ADX.PARM.1%
 847: 0003: 
 848: 0003:       INTEGER*4  RETURN.CODE%                                                 \
 849: 0003: 
 850: 0003:    END SUB     
 851: 0003: 
 852: 0003:     %INCLUDE BASROUT.J86     ! OSShell function
 853: 0003: \*LIB   BVEJ BASROUT  J86      03/11/97 08:16:26 PIDBLD3  *    FIX
 854: 0003: \*PROM  BVEJ BASROUT  J86      03/10/97 17:18:40 PIDBLD3  MVEJ IR34352
 855: 0003: \*RTIME BVEJ BASROUT  J86      03/10/97 17:18:41 PIDBLD3  MVEJ IR34352
 856: 0003: \*LIB   MVEJ BASROUT  J86      03/05/97 10:48:46 EDJRAL   *    IR34352
 857: 0003: \*LIB   MVEJ BASROUT  J86      02/17/97 11:19:56 EDJRAL   *    REASONAR
 858: 0003: \*LIB   MVEJ BASROUT  J86      02/14/97 15:59:11 EDJRAL   *    REASONAR
 859: 0003: ! BASROUT.J86 - this file is to be included in any BASIC code which utilizes
 860: 0003: !   the BASROUT.OBJ routines.  These routines were written
 861: 0003: !  using Metaware C and are intended to provide functions which
 862: 0003: !         are either not available in 4680 CBASIC or which can be more
 863: 0003: !               efficiently handled by the C language.  Their usage is
 864: 0003: !  offered on an "AT YOUR OWN RISK" basis.
 865: 0003: !
 866: 0003: !               The insert/extract routines usefulness may not be immediately
 867: 0003: !               apparent.  Their intention is that they be used in conjunction
 868: 0003: !               with a read/write form command.  They can more efficiently
 869: 0003: !               parse a string into many different variables than can the
 870: 0003: !               read form statement.  So instead of a long list of data var's
 871: 0003: !               it may be more efficient to just read/write one long string
 872: 0003: !               and then use the insert/extract routines to parse out the
 873: 0003: !   data.
 874: 0003: 
 875: 0003: ! ******************* SUB PROCESS FUNCTIONS *********************************
 876: 0003: 
 877: 0003: function osshell(cmd.line$) external   ! routine to start
 878: 0003:        ! another program.
 879: 0003:            integer*4    osshell    ! Upon completion of
 880: 0003:            string       cmd.line$   ! program, control is
 881: 0003:        ! returned to calling
 882: 0003: end function      ! program.
 883: 0003: !
 884: 0003: ! NOTES:  Program must be a 286 type file.  This does not exclude
 885: 0003: !         the capability to execute a batch file however.  Simply pass the
 886: 0003: !         following:
 887: 0003: !              c:\adx_spgm\command.286 batfile
 888: 0003: !         where batfile is the name of the batch file to be executed.
 889: 0003: !
 890: 0003: ! IMPORTANT: When using osshell to execute a batch file as described above,
 891: 0003: !            the final command in the batch file must be "exit".  If not,
 892: 0003: !       control is never given back to the calling program.
 893: 0003: 
 894: 0003: ! ************************ MEMORY RELATED FUNCTIONS ************************
 895: 0003: 
 896: 0003: function memfree(choice) external   ! routine to que the
 897: 0003:        ! status of the
 898: 0003:  integer*4 memfree    ! machine's memory:
 899: 0003:  integer*2 choice    ! Options:
 900: 0003:        !    1 - free
 901: 0003: end function      !    2 - total
 902: 0003:        !    3 - system
 903: 0003: 
 904: 0003: ! ********************** TIMEDATE RELATED FUNCTIONS ************************
 905: 0003: 
 906: 0003: function timedate(choice) external   ! routine to que the
 907: 0003:        ! OS's timedate table
 908: 0003:  integer*4 timedate   ! Choices:
 909: 0003:  integer*2 choice    !    1 - millisec's
 910: 0003:        !        since midnight
 911: 0003: end function      !    2 - minutes from
 912: 0003:        !  UCT (timezone)
 913: 0003:        !    3 - day of week
 914: 0003:        !   0-Sunday
 915: 0003:        !  6-Saturday
 916: 0003: 
 917: 0003: function settime(msecs) external   ! routine to set the
 918: 0003:        ! time on the controller
 919: 0003:  integer*4  settime    ! msecs is the desired
 920: 0003:  integer*4 msecs    ! number of milliseconds
 921: 0003:        ! since midnight
 922: 0003: end function      ! Returns negative on
 923: 0003:        ! error
 924: 0003: ! NOTE:  This routine sets the time only on the controller.  The terminals'
 925: 0003: ! time will not be updated until 1 AM or unless a terminal is STC'd.
 926: 0003: ! At 1 AM the controller broadcasts the new time to all terminals.
 927: 0003: ! Insure this is taken into consideration when using this routine.
 928: 0003: 
 929: 0003: !******************** DISK FILE RELATED FUNCTIONS *************************
 930: 0003: 
 931: 0003: function truncate(name,length) external   ! routine to truncate
 932: 0003:        ! the specified file
 933: 0003:  integer*4 truncate   ! to a given length.
 934: 0003:  string  name
 935: 0003:  integer*4 length
 936: 0003: 
 937: 0003: end function
 938: 0003: 
 939: 0003: !******************** STRING VALUE RELATED FUNCTIONS **********************
 940: 0003: 
 941: 0003: function isalpha(bstrn) external   ! routine to identify
 942: 0003:        ! if the specified
 943: 0003:  integer*1 isalpha    ! string contains all
 944: 0003:  string  bstrn    ! alphabetic char's
 945: 0003:        ! Returns:
 946: 0003: end function      !     0 - all alpha
 947: 0003:        !     X - byte of 1st
 948: 0003:        !         non-alpha
 949: 0003:        !   char
 950: 0003: 
 951: 0003: function isdigit(bstrn) external   ! routine to identify
 952: 0003:        ! if the specified
 953: 0003:  integer*1 isdigit    ! string contains all
 954: 0003:  string  bstrn    ! numeric char's
 955: 0003:        ! Returns:
 956: 0003: end function      !     0 - all numeric
 957: 0003:        !     X - byte of 1st
 958: 0003:        !         non-numeric
 959: 0003:        !   char
 960: 0003: 
 961: 0003: function islower(bstrn) external   ! routine to identify
 962: 0003:        ! if the specified
 963: 0003:  integer*1 islower    ! string contains all
 964: 0003:  string  bstrn    ! lower case char's
 965: 0003:        ! Returns:
 966: 0003: end function      !     0 - all lowercase
 967: 0003:        !     X - byte of 1st
 968: 0003:        !         non-lowercase
 969: 0003:        !   char
 970: 0003: 
 971: 0003: function isupper(bstrn) external   ! routine to identify
 972: 0003:        ! if the specified
 973: 0003:  integer*1 isupper    ! string contains all
 974: 0003:  string  bstrn    ! upper case char's
 975: 0003:        ! Returns:
 976: 0003: end function      !     0 - all uppercase
 977: 0003:        !     X - byte of 1st
 978: 0003:        !         non-uppercase
 979: 0003:        !   char
 980: 0003: 
 981: 0003: function toalpha(bstrn) external   ! routine to convert
 982: 0003:        ! non-alpha or non-num
 983: 0003:    integer*2 toalpha    ! char's to spaces
 984: 0003:  string  bstrn    ! Returns:
 985: 0003: end function      !   x - no. of char's
 986: 0003:        !       changed
 987: 0003: 
 988: 0003: ! ********************* USER/GROUP ZERO LEVEL FUNCTIONS *********************
 989: 0003: 
 990: 0003: function idlecount(choice) external   ! routine to either
 991: 0003:        ! set to zero or queue
 992: 0003:  integer*4 idlecount   ! the value of the
 993: 0003:  integer*1 choice    ! processor's idlecount
 994: 0003:        ! Choice:
 995: 0003: end function      !     0 - set to zero
 996: 0003: !       !     1 - get value
 997: 0003: ! NEEDS USER/GROUP 0 LEVEL OF AUTHORIZATION  ! Returns:
 998: 0003: ! TO WORK - This level is not available unless  !     X - idlecount
 999: 0003: ! the file ADXCSOUF.DAT file is "patched".  This !    -X - error code
1000: 0003: ! is highly unrecommended.
1001: 0003: 
1002: 0003: function logical(actname,logname,choice) external ! routine to set a
1003: 0003:        ! a logical name.
1004: 0003:  integer*4 logical    ! parms are self
1005: 0003:         string  logname    ! explanatory except
1006: 0003:  string  actname    ! for choice:
1007: 0003:  integer*1 choice    !   0 - set process
1008: 0003:        !   1 - set system
1009: 0003: end function      !   2 - get process
1010: 0003:        !   3 - get system
1011: 0003: 
1012: 0003: ! NOTE:  Only the setting of a system level of logical name requires
1013: 0003: ! user/group zero level of authorization.  Any application may query any
1014: 0003: ! logical name.  Setting of a system logical name is only applicable until
1015: 0003: ! the system is IPL'd.  A process logical name is only active when that
1016: 0003: ! process is active.
1017: 0003: 
1018: 0003: !******************** STRING PARSING FUNCTIONS *****************************
1019: 0003: 
1020: 0003: function inserts(whole,part,offset) external  ! routine to insert a
1021: 0003:        ! string (part) into
1022: 0003:  integer*2 INSERTS    ! another string (whole)
1023: 0003:  string  whole    ! starting at specified
1024: 0003:  string  part    ! character (offset)
1025: 0003:  integer*2 offset
1026: 0003: 
1027: 0003: end function
1028: 0003: 
1029: 0003: function cinsert4(integer4,bstring,offset) external   ! routine to insert
1030: 0003:        ! a 4-byte integer into
1031: 0003:  integer*1 cinsert4   ! a string starting at
1032: 0003:  integer*4 integer4   ! byte specified by
1033: 0003:  string  bstring    ! offset (1-based)
1034: 0003:  integer*2 offset    ! Returns:
1035: 0003:        !     0 - Success
1036: 0003: end function      !    -1 - String overrun
1037: 0003: 
1038: 0003: function cinsert2(integer2,bstring,offset) external  ! routine to insert
1039: 0003:        ! a 2-byte integer into
1040: 0003:  integer*1 cinsert2   ! a string starting at
1041: 0003:  integer*2 integer2   ! byte specified by
1042: 0003:  string  bstring    ! offset (1-based)
1043: 0003:  integer*2 offset    ! Returns:
1044: 0003:        !     0 - Success
1045: 0003: end function      !    -1 - String overrun
1046: 0003: 
1047: 0003: function cinsert1(bstring,integer1,offset) external  ! routine to insert
1048: 0003:        ! a 1-byte integer into
1049: 0003:  integer*1 cinsert1   ! a string starting at
1050: 0003:  integer*1 integer1   ! byte specified by
1051: 0003:  string  bstring    ! offset (1-based)
1052: 0003:  integer*2 offset    ! Returns:
1053: 0003:        !     0 - Success
1054: 0003: end function      !    -1 - String overrun
1055: 0003: 
1056: 0003: function extracts(whole,part,offset) external  ! routine to extract a
1057: 0003:        ! string (part) from
1058: 0003:  integer*2 EXTRACTS   ! another string (whole)
1059: 0003:  string  whole    ! starting at specified
1060: 0003:  string  part    ! character (offset)
1061: 0003:  integer*2 offset
1062: 0003: 
1063: 0003: end function
1064: 0003: 
1065: 0003: function cextract4(bstring,offset) external  ! routine to extract
1066: 0003:        ! a 4-byte integer from
1067: 0003:  integer*4 cextract4   ! a string starting at
1068: 0003:                        ! byte specified by
1069: 0003:  string  bstring    ! offset (1-based)
1070: 0003:  integer*2 offset    ! Returns:
1071: 0003:        !     X - 4 byte integer
1072: 0003: end function      !    -1 - String overrun
1073: 0003: 
1074: 0003: function cextract2(bstring,offset) external  ! routine to extract
1075: 0003:        ! a 2-byte integer from
1076: 0003:  integer*2 cextract2   ! a string starting at
1077: 0003:                        ! byte specified by
1078: 0003:  string  bstring    ! offset (1-based)
1079: 0003:  integer*2 offset    ! Returns:
1080: 0003:        !     X - 2 byte integer
1081: 0003: end function      !    -1 - String overrun
1082: 0003: 
1083: 0003: function cextract1(bstring,offset) external  ! routine to extract
1084: 0003:        ! a 1-byte integer from
1085: 0003:  integer*1 cextract1   ! a string starting at
1086: 0003:                        ! byte specified by
1087: 0003:  string  bstring    ! offset (1-based)
1088: 0003:  integer*2 offset    ! Returns:
1089: 0003:        !     X - 1 byte integer
1090: 0003: end function      !    -1 - String overrun
1091: 0003: 
1092: 0003: 
1093: 0003: function srchdir (file.name$,dtbl.buffer$) external ! routine to return
1094: 0003:        ! file names and sizes
1095: 0003:        ! Return values:
1096: 0003:        !    -1  no matches
1097: 0003:        !        found on first
1098: 0003:        !        call
1099: 0003:        !    0   no matches
1100: 0003:        !        found on sub-
1101: 0003:        !        sequent calls
1102: 0003:        !    Pos Success
1103: 0003:        !    Neg OS Rtn Code
1104: 0003: ! Usage Note:  If searching for all occurences of a particular file name,
1105: 0003: ! first initialize dtbl.buffer$ to 48 Nulls (pack$("00")) and issue a call
1106: 0003: ! to srchdir.  If any matches are found, a positive value will be returned.
1107: 0003: ! To see if any more matches exist, just issue another call to srchdir without
1108: 0003: ! resetting the values of dtbl.buffer$.  If any are found, a positive value
1109: 0003: ! will be returned.  This can be repeated until a Zero is returned.  All data
1110: 0003: ! describing file will be returned in the dtbl.buffer$ after each call.  Format
1111: 0003: ! of this data is defined below.
1112: 0003: 
1113: 0003:  integer*4 srchdir
1114: 0003: 
1115: 0003:  string  file.name$   ! file name to start
1116: 0003:        ! search (18 bytes max)
1117: 0003:        ! Wild cards and logical
1118: 0003:        ! names supported.
1119: 0003: 
1120: 0003:  string  dtbl.buffer$   ! must be initialized
1121: 0003:        ! to 48 bytes.  Contains
1122: 0003:        ! all of directory info
1123: 0003:        ! Initialize to nulls
1124: 0003:        ! each time a new file
1125: 0003:        ! name is used.
1126: 0003: 
1127: 0003: ! NOTE:  Format of dtbl.buffer$ string is as follows:
1128: 0003: !
1129: 0003: ! Offs  Type                    Description Notes
1130: 0003: !  0 integer*4  key  use extract4 to access
1131: 0003: !  4  string (18 bytes) file name
1132: 0003: ! 22 integer*2  attributes use extract2 to access
1133: 0003: !      0x01 - Read Only
1134: 0003: !      0x02 - Hidden
1135: 0003: !      0x04 - System
1136: 0003: !      0x08 - Volume Label
1137: 0003: !      0x10 - Subdirectory
1138: 0003: !      0x20 - Archive (Files)
1139: 0003: !      0x40 - Security enabled
1140: 0003: !      0x80 - Reserved
1141: 0003: !      0x0000 - Local
1142: 0003: !      0x4000 - Mirrored/Update
1143: 0003: !      0xC000 - Mirrored/Close
1144: 0003: !
1145: 0003: !      0x6000 - Compound/Update
1146: 0003: !      0xE000 - Compound/Close
1147: 0003: ! 24 integer*2  record size use extract2 to access
1148: 0003: ! 26 integer*1  User ID of Owner
1149: 0003: ! 27 integer*1  Group ID of Owner
1150: 0003: ! 28 integer*2  File Security
1151: 0003: ! 30 string (6 bytes) Reserved
1152: 0003: ! 36 integer*4  File Size use extract4 to access
1153: 0003: ! 40 integer*2  Year  use extract2 to access
1154: 0003: ! 42 integer*1  Month
1155: 0003: ! 43 integer*1  Day
1156: 0003: ! 44 integer*1  Hour
1157: 0003: ! 45 integer*1  Minute
1158: 0003: ! 46 integer*1  Second
1159: 0003: ! 47 integer*1  Reserved
1160: 0003: 
1161: 0003: end function
1162: 0003: 
1163: 0003: function srchproc (proc.name$,ptbl.buffer$) external ! routine to return
1164: 0003:        ! process names and
1165: 0003:        ! status.  Handy to
1166: 0003:        ! determine if a
1167: 0003:        ! program is currently
1168: 0003:        ! running.
1169: 0003:        ! Return values:
1170: 0003:        !    -1  no matches
1171: 0003:        !        found on first
1172: 0003:        !        call
1173: 0003:        !    0   no matches
1174: 0003:        !        found on sub-
1175: 0003:        !        sequent calls
1176: 0003:        !    Pos Success
1177: 0003:        !    Neg Failure
1178: 0003:        !        OS Rtn Code
1179: 0003:        ! 80000001h - Insuff
1180: 0003:         !        ptbl buffer
1181: 0003:        !        Length
1182: 0003: ! Usage Note:  If searching for all occurences of a particular process name,
1183: 0003: ! first initialize ptbl.buffer$ to 60 Nulls (pack$("00")) and issue a call
1184: 0003: ! to srchproc.  If any matches are found, a positive value will be returned.
1185: 0003: ! To see if any more matches exist, just issue another call to srchproc without
1186: 0003: ! resetting the values of ptbl.buffer$.  If any are found, a positive value
1187: 0003: ! will be returned.  This can be repeated until a Zero is returned.  All data
1188: 0003: ! describing file will be returned in the ptbl.buffer$ after each call.  Format
1189: 0003: ! of this data is defined as follows:
1190: 0003: !
1191: 0003: !       --------------------------------------------------------
1192: 0003: !   0   |                         PID                          |
1193: 0003: !       --------------------------------------------------------
1194: 0003: !   4   |           FID             |   CID        |   VCID    |
1195: 0003: !       --------------------------------------------------------
1196: 0003: !   8   |                         NAME                         |
1197: 0003: !       --------------------------------------------------------
1198: 0003: !  12   |                         NAME cont'd                  |
1199: 0003: !       --------------------------------------------------------
1200: 0003: !  16   |       NAME cont'd         |   STATE      |  PRIOR    |
1201: 0003: !       --------------------------------------------------------
1202: 0003: !  20   |                         MAXMEM                       |
1203: 0003: !       --------------------------------------------------------
1204: 0003: !  24   |       FLAGS               |   USER        |  GROUP   |
1205: 0003: !       --------------------------------------------------------
1206: 0003: !  28   |                         PARENT                       |
1207: 0003: !       --------------------------------------------------------
1208: 0003: !  32   |                         EVENTS                       |
1209: 0003: !       --------------------------------------------------------
1210: 0003: !  36   |                         CODE                         |
1211: 0003: !       --------------------------------------------------------
1212: 0003: !  40   |                         CSIZE                        |
1213: 0003: !       --------------------------------------------------------
1214: 0003: !  44   |                         DATA                         |
1215: 0003: !       --------------------------------------------------------
1216: 0003: !  48   |                         DSIZE                        |
1217: 0003: !       --------------------------------------------------------
1218: 0003: !  52   |                         HEAP                         |
1219: 0003: !       --------------------------------------------------------
1220: 0003: !  56   |                         HSIZE                        |
1221: 0003: !       --------------------------------------------------------
1222: 0003: !
1223: 0003: !       PID   Process ID
1224: 0003: !       FID  Process's Family ID
1225: 0003: !       CID   Physical Console Device Number
1226: 0003: !       VCID  Process's Virtual Console Number
1227: 0003: !       NAME  Process Name (Application Running)
1228: 0003: ! STATE    Process State (0-Run, 1-Waiting, 2-Terminating)
1229: 0003: ! PRIOR    Priority
1230: 0003: !       MAXMEM  Maximum Memory Allowed
1231: 0003: !       FLAGS  Bit 0 (1-System Process, 0-User Process)
1232: 0003: !   Bit 1 (1-Locked in Memory, 0-Swappable)
1233: 0003: !   Bit 2 (1-Running in SWI context, 0-Running in main context)
1234: 0003: !   Bit 3 (1-Superuser Process,0-Not a Superuser Process)
1235: 0003: ! USER  User Number
1236: 0003: ! GROUP  Group Number
1237: 0003: !       PARENT   Parent Process ID
1238: 0003: !       EVENTS   Bit Map of events that have completed but not retrieved
1239: 0003: !       CODE  Start of code area in user space
1240: 0003: ! CSIZE  Size in bytes of code area
1241: 0003: !       DATA  Start of data area in user space
1242: 0003: ! DSIZE  Size in bytes of data area
1243: 0003: !       HEAP  Start of heap area in user space
1244: 0003: ! HSIZE  Size in bytes of heap area
1245: 0003: !
1246: 0003:  integer*4 srchproc
1247: 0003: 
1248: 0003:  string  proc.name$   ! process name to start
1249: 0003:        ! search (10 bytes max)
1250: 0003:        ! Wild cards and logical
1251: 0003:        ! names supported.
1252: 0003: 
1253: 0003:  string  ptbl.buffer$   ! must be initialized
1254: 0003:        ! to 60 bytes.  Contains
1255: 0003:        ! all of process info
1256: 0003:        ! Initialize to nulls
1257: 0003:        ! each time a new
1258: 0003:        ! process name is used.
1259: 0003: 
1260: 0003: end function
1261: 0003: 
1262: 0003: function cconstat(timeout) external       ! function similar
1263: 0003:                                               ! to BASIC constat%
1264: 0003:  integer*2 cconstat   ! waits for either a
1265: 0003:  integer*4 timeout    ! key being hit or
1266: 0003:        ! the timer expiring
1267: 0003:        ! before returning
1268: 0003:        ! returns:
1269: 0003:        !   -1 error
1270: 0003:        !    0 timer expired
1271: 0003:        !    x scan code of
1272: 0003:        !      key hit
1273: 0003: end function
1274: 0003: 
1275: 0003: function disksize(disk.name$) external   ! function to find
1276: 0003:        ! the total size of
1277: 0003:  integer*4 disksize   ! the specified disk
1278: 0003:  string  disk.name$   ! name (e.g. "h0:")
1279: 0003:        ! if return value is
1280: 0003:        ! negative, error
1281: 0003: end function      ! was received
1282: 0003: 
1283: 0003: 
1284: 0003:     %INCLUDE BTCSTR.J86      ! String functions
1285: 0003: !********************************************************************
1286: 0003: !***
1287: 0003: !***    INCLUDED CODE:  BTCSTR.J86
1288: 0003: !***    AUTHOR:         Stuart William McConnachie
1289: 0003: !***    DATE:           26th February 2006
1290: 0003: !***
1291: 0003: !********************************************************************
1292: 0003: !***
1293: 0003: !***    Controller CBASIC String Functions
1294: 0003: !***
1295: 0003: !********************************************************************
1296: 0003: 
1297: 0003: !Swaps to CBASIC strings
1298: 0003: SUB SWAPSTR (S1$, S2$) EXTERNAL
1299: 0003:     STRING S1$, S2$
1300: 0003: END SUB
1301: 0003: 
1302: 0003: !Left trim a string of spaces
1303: 0003: SUB LTRIM (S$) EXTERNAL
1304: 0003:     STRING S$
1305: 0003: END SUB
1306: 0003: 
1307: 0003: !Right trim a string of spaces
1308: 0003: SUB RTRIM (S$) EXTERNAL
1309: 0003:     STRING S$
1310: 0003: END SUB
1311: 0003: 
1312: 0003: !Left and right trim a string of spaces
1313: 0003: SUB TRIM (S$) EXTERNAL
1314: 0003:     STRING S$
1315: 0003: END SUB
1316: 0003: 
1317: 0003: !Left trim a string of a given ASCII character
1318: 0003: SUB LTRIMC (S$, C%) EXTERNAL
1319: 0003:     STRING S$
1320: 0003:     INTEGER*1 C%
1321: 0003: END SUB
1322: 0003: 
1323: 0003: !Right trim a string of a given ASCII character
1324: 0003: SUB RTRIMC (S$, C%) EXTERNAL
1325: 0003:     STRING S$
1326: 0003:     INTEGER*1 C%
1327: 0003: END SUB
1328: 0003: 
1329: 0003: !Left and right trim a string of a given ASCII character
1330: 0003: SUB TRIMC (S$, C%) EXTERNAL
1331: 0003:     STRING S$
1332: 0003:     INTEGER*1 C%
1333: 0003: END SUB
1334: 0003: 
1335: 0003: !Insert one string into another
1336: 0003: FUNCTION SUBSTR(S1$, O1%, S2$, O2%, L2%) EXTERNAL
1337: 0003:     STRING    S1$, S2$
1338: 0003:     INTEGER*2 O1%, O2%, L2%
1339: 0003:     INTEGER*1 SUBSTR
1340: 0003: END FUNCTION
1341: 0003:     
1342: 0003:     %INCLUDE CMPDATE.J86     ! Compare date utility
1343: 0003: !********************************************************************
1344: 0003: !***
1345: 0003: !***    INCLUDED CODE:  CMPDATE.J86
1346: 0003: !***    AUTHOR:         Stuart William McConnachie
1347: 0003: !***    DATE:           27th January 1997
1348: 0003: !***
1349: 0003: !********************************************************************
1350: 0003: !***   
1351: 0003: !***    Version B            Nik Sen                 30th March 1998
1352: 0003: !***    Changes to cope with a date of '000000' by replacing it with
1353: 0003: !***    '850101' before comparison. An all zero's date is valid in 
1354: 0003: !***    certain date fields and CMPDATE was returning the wrong result
1355: 0003: !***    when comparing with an actual date. Also change to cope with
1356: 0003: !***    dates of '999999' as some date fields are initialised to this
1357: 0003: !***    as a high value.
1358: 0003: !***
1359: 0003: !***    Version C    Stuart William McConnachie   20th December 1999
1360: 0003: !***    Improved function efficiency by changing tests for high and
1361: 0003: !***    low values, added above, to integers (rather than strings).
1362: 0003: !***    Also, using 850101 as a replacement for 000000, will not give
1363: 0003: !***    valid results after 350101 because of the 50 year wrap, so
1364: 0003: !***    corrected this.
1365: 0003: !***
1366: 0003: !***    Version D.  Stuart William McConnachie    26th February 2006
1367: 0003: !***    Place this code in it's own module in FUNLIB.  Make all
1368: 0003: !***    the functions herein EXTERNAL accordingly.
1369: 0003: !***
1370: 0003: !********************************************************************
1371: 0003: !***    
1372: 0003: !***    The following functions compare dates, checking for
1373: 0003: !***    century boundries.  Dates in the 50 years prior to the
1374: 0003: !***    compared date are less than the compared date, dates in
1375: 0003: !***    50 years after the compared date are greater than the
1376: 0003: !***    compared date.
1377: 0003: !***    Can handle dates in both packed and unpacked formats, or
1378: 0003: !***    a mixture of both.
1379: 0003: !***    In the case of a error, for example IH after detecting
1380: 0003: !***    illegal characters in VAL, the functions default to
1381: 0003: !***    comparing strings without testing for a change of century.
1382: 0003: !***
1383: 0003: !***    DATE.GT(DATE1$, DATE2$)  same as  DATE1$ >  DATE2$
1384: 0003: !***    DATE.GE(DATE1$, DATE2$)  same as  DATE1$ >= DATE2$
1385: 0003: !***    DATE.LT(DATE1$, DATE2$)  same as  DATE1$ <  DATE2$
1386: 0003: !***    DATE.LE(DATE1$, DATE2$)  same as  DATE1$ <= DATE2$
1387: 0003: !***
1388: 0003: !********************************************************************
1389: 0003: 
1390: 0003: FUNCTION DATE.GT(DATE1$, DATE2$) EXTERNAL                               !DSWM
1391: 0003:     STRING    DATE1$, DATE2$
1392: 0003:     INTEGER*1 DATE.GT
1393: 0003: END FUNCTION
1394: 0003: 
1395: 0003: 
1396: 0003: FUNCTION DATE.GE(DATE1$, DATE2$) EXTERNAL                               !DSWM
1397: 0003:     STRING    DATE1$, DATE2$
1398: 0003:     INTEGER*1 DATE.GE
1399: 0003: END FUNCTION
1400: 0003: 
1401: 0003: 
1402: 0003: FUNCTION DATE.LT(DATE1$, DATE2$) EXTERNAL                               !DSWM
1403: 0003:     STRING    DATE1$, DATE2$
1404: 0003:     INTEGER*1 DATE.LT
1405: 0003: END FUNCTION
1406: 0003: 
1407: 0003: 
1408: 0003: FUNCTION DATE.LE(DATE1$, DATE2$) EXTERNAL                               !DSWM
1409: 0003:     STRING    DATE1$, DATE2$
1410: 0003:     INTEGER*1 DATE.LE
1411: 0003: END FUNCTION
1412: 0003: 
1413: 0003:     %INCLUDE ERRNH.J86       ! Converts ERRN to 8-byte ASCII string
1414: 0003: \******************************************************************************
1415: 0003: \***
1416: 0003: \***	FUNCTION ERRNH
1417: 0003: \***
1418: 0003: \***	Convert the 4-byte error number to an 8-byte ASCII string
1419: 0003: \***
1420: 0003: \******************************************************************************
1421: 0003: 
1422: 0003: 	FUNCTION ERRNH PUBLIC
1423: 0027: 
1424: 0027: 	STRING			ERRNH,					\
1425: 0027: 				E$
1426: 0027: 
1427: 0027: 	INTEGER*2		I%
1428: 0027: 	INTEGER*4		H%
1429: 0027: 
1430: 0027: 	E$ = ""
1431: 003c: 	H% = ERRN
1432: 0056: 
1433: 0056: 	FOR I% = 28 TO 0 STEP -4
1434: 0066: 	    E$ = E$ + CHR$((SHIFT(H%,I%) AND 000FH) + 48)
1435: 00c2: 	NEXT I%
1436: 00da: 
1437: 00da: 	ERRNH = TRANSLATE$(E$,":;<=>?","ABCDEF")
1438: 0101: 
1439: 0101: 	END FUNCTION
1440: 011a:     %INCLUDE PSBF01E.J86     ! Application log
1441: 011a: REM \
1442: 011a: \*******************************************************************************
1443: 011a: \*******************************************************************************
1444: 011a: \***
1445: 011a: \***      %INCLUDE FOR EXTERNAL DEFINITION OF FUNCTION APPLICATION.LOG
1446: 011a: \***
1447: 011a: \***                      FUNCTION NUMBER   : PSBF01
1448: 011a: \***
1449: 011a: \***                    INCLUDE REFERENCE : PSBF01E.J86
1450: 011a: \*** 
1451: 011a: \***      Version B           Andrew Wedgeworth          1st July 1992
1452: 011a: \***      Three parameters which passed to the function have been removed.
1453: 011a: \***      APPLICATION.LOG has been added as a variable name (this holds the
1454: 011a: \***      return code).
1455: 011a: \***
1456: 011a: \*******************************************************************************
1457: 011a: 
1458: 011a: 
1459: 011a:    FUNCTION APPLICATION.LOG (MESSAGE.NO%,                                     \
1460: 011a:                              VAR.STRING.1$,                                   \
1461: 011a:                              VAR.STRING.2$,                                   \
1462: 011a:                              EVENT.NO%)  EXTERNAL
1463: 011a: 
1464: 011a:       INTEGER*1 EVENT.NO%
1465: 011a: 
1466: 011a:       INTEGER*2 APPLICATION.LOG,                                       \ GAW
1467: 011a:                 MESSAGE.NO%
1468: 011a: 
1469: 011a:       STRING VAR.STRING.1$,                                            \
1470: 011a:              VAR.STRING.2$
1471: 011a: 
1472: 011a:    END FUNCTION
1473: 011a: 
1474: 011a: \*******************************************************************************
1475: 011a:     %INCLUDE PSBF02E.J86     ! Update Date
1476: 011a: REM\
1477: 011a: \*******************************************************************************
1478: 011a: \*******************************************************************************
1479: 011a: \***
1480: 011a: \***        INCLUDE       : UPDATE.DATE external definition
1481: 011a: \***        AUTHOR        : Bruce Scriver (Basic Code)
1482: 011a: \***        DATE WRITTEN  : 4th March 1986 (Basic Code)
1483: 011a: \***
1484: 011a: \***        REFERENCE     : PSBF02E.J86
1485: 011a: \***
1486: 011a: \***        Version A     Bruce Scriver          4th March 1986
1487: 011a: \***
1488: 011a: \***        Version B     Andrew Wedgeworth       6th July 1992
1489: 011a: \***        Removal of redundant parameters, and inclusion of UPDATE.DATE as
1490: 011a: \***        a variable to hold the return code.
1491: 011a: \***
1492: 011a: \*******************************************************************************
1493: 011a: \*******************************************************************************
1494: 011a: 
1495: 011a:    FUNCTION UPDATE.DATE (INCREMENT%)                                   \
1496: 011a:    EXTERNAL
1497: 011a:    ! 3 parameters removed from here                                    ! BAW
1498: 011a: 
1499: 011a:    ! 3 lines deleted from here                                         ! BAW
1500: 011a:    
1501: 011a:       INTEGER*2 UPDATE.DATE                                            ! BAW
1502: 011a: 
1503: 011a:       INTEGER*4 INCREMENT%
1504: 011a: 
1505: 011a:    END FUNCTION
1506: 011a: 
1507: 011a:     %INCLUDE PSBF13E.J86     ! PSDATE function
1508: 011a: REM\
1509: 011a: \*******************************************************************************
1510: 011a: \*******************************************************************************
1511: 011a: \***
1512: 011a: \***        INCLUDE       : PSDATE external definition
1513: 011a: \***
1514: 011a: \***        REFERENCE     : PSBF13E.J86
1515: 011a: \***
1516: 011a: \***        Version A     Bruce Scriver                6th March 1986
1517: 011a: \*** 
1518: 011a: \***        Version B     Andrew Wedgeworth            17th July 1992  
1519: 011a: \***        Redundant parameters removed and PSDATE defined as a variable
1520: 011a: \***        to hold the return code. 
1521: 011a: \***
1522: 011a: \*******************************************************************************
1523: 011a: \*******************************************************************************
1524: 011a: 
1525: 011a:    FUNCTION PSDATE (INPUT.DATE$)                                               \
1526: 011a:    EXTERNAL
1527: 011a: 
1528: 011a:      STRING    INPUT.DATE$                                                   
1529: 011a:    
1530: 011a:      INTEGER*2 PSDATE 
1531: 011a: 
1532: 011a:    END FUNCTION
1533: 011a: 
1534: 011a:     %INCLUDE PSBF20E.J86     ! Session number utility
1535: 011a: REM\
1536: 011a: \*******************************************************************************
1537: 011a: \*******************************************************************************
1538: 011a: \***
1539: 011a: \***       %INCLUDE FOR EXTERNAL DEFINITION OF SESS.NUM.UTILITY
1540: 011a: \***
1541: 011a: \***                  REFERENCE     : PSBF20E.J86
1542: 011a: \***
1543: 011a: \***     VERSION C            Janet Smith                13th May 1992
1544: 011a: \***     Increased PASSED.INTEGER to 2 bytes to cater for more than
1545: 011a: \***     128 files.
1546: 011a: \***
1547: 011a: \***     VERSION D.           Andrew Wedgeworth          1st July 1992
1548: 011a: \***     Removal of redundant parameters and addition of SESS.NUM.UTILITY
1549: 011a: \***     as a variable.  This new variable contains the function's return
1550: 011a: \***     code.
1551: 011a: \***
1552: 011a: \*******************************************************************************
1553: 011a: \*******************************************************************************
1554: 011a: 
1555: 011a:    FUNCTION SESS.NUM.UTILITY (FUNCTION.FLAG$,                          \
1556: 011a:                               PASSED.INTEGER%,                         \
1557: 011a:                               PASSED.STRING$)                          \
1558: 011a:    EXTERNAL
1559: 011a: 
1560: 011a:    STRING    FUNCTION.FLAG$,                                           \
1561: 011a:              PASSED.STRING$
1562: 011a:    ! 3 variables removed from here                                     ! CAW
1563: 011a: 
1564: 011a: 
1565: 011a:    INTEGER*2 SESS.NUM.UTILITY,                                         \ CAW
1566: 011a:              PASSED.INTEGER%				               ! CJAS
1567: 011a: 
1568: 011a:    END FUNCTION
1569: 011a: 
1570: 011a:     %INCLUDE PSBF24E.J86     ! Standard error detected
1571: 011a: REM \
1572: 011a: \*******************************************************************************
1573: 011a: \*******************************************************************************
1574: 011a: \***
1575: 011a: \***    %INCLUDE FOR EXTERNAL DEFINITION OF STANDARD.ERROR.DETECTED FUNCTION
1576: 011a: \***
1577: 011a: \***                      REFERENCE     : PSBF24E.J86
1578: 011a: \***
1579: 011a: \***    Version A                 Janet Smith                  13th May 1992
1580: 011a: \***
1581: 011a: \*******************************************************************************
1582: 011a: \*******************************************************************************
1583: 011a: 
1584: 011a:    FUNCTION STANDARD.ERROR.DETECTED(ERRN%,                 \
1585: 011a: 				    ERRFILE%,              \
1586: 011a: 				    ERRL%,                 \
1587: 011a: 				    ERR$)        EXTERNAL
1588: 011a: 				    
1589: 011a:           STRING    ERR$
1590: 011a: 
1591: 011a:           INTEGER*2 ERRFILE%,              \
1592: 011a: 	            ERRL%,                 \
1593: 011a: 		    STANDARD.ERROR.DETECTED
1594: 011a: 		    
1595: 011a:           INTEGER*4 ERRN%
1596: 011a: 	  		    
1597: 011a:    END FUNCTION
1598: 011a: 
1599: 011a: 
1600: 011a:     %INCLUDE HSIUFEXT.J86    ! OS FTP function declaration              !KDC
1601: 011a: !*****************************************************************************
1602: 011a: !*****************************************************************************
1603: 011a: !***
1604: 011a: !***         FUNCTION DEFINITIONS FOR ADXHSIUF FTP TRUSERS FILE FUNCTIONS 
1605: 011a: !***
1606: 011a: !***                      REFERENCE    : HSIUFEXT
1607: 011a: !***
1608: 011a: !***           VERSION A : DAVE CONSTABLE   26/05/2014
1609: 011a: !***
1610: 011a: !*****************************************************************************
1611: 011a: !*****************************************************************************
1612: 011a: !-----------------------------------------------------------------------------
1613: 011a: 
1614: 011a: FUNCTION HSIUF.SET EXTERNAL
1615: 011a:     INTEGER*1   HSIUF.SET
1616: 011a: END FUNCTION
1617: 011a: 
1618: 011a: 
1619: 011a: FUNCTION READ.HSIUF EXTERNAL
1620: 011a:     INTEGER*1   READ.HSIUF
1621: 011a: END FUNCTION
1622: 011a: 
1623: 011a: 
1624: 011a: FUNCTION WRITE.HSIUF EXTERNAL
1625: 011a:     INTEGER*1   WRITE.HSIUF
1626: 011a: END FUNCTION
1627: 011a: 
1628: 011a: FUNCTION FUNC.GET.FTP.PASSWORD.FOR$(F.PASSED.USER$) EXTERNAL
1629: 011a:     STRING  FUNC.GET.FTP.PASSWORD$          !* function return value
1630: 011a:     STRING  F.PASSED.USER$                  !* passed user id in ASCII
1631: 011a:     STRING  F.USER.ID$                      !* working user variable
1632: 011a:     INTEGER*1   F.OPEN                      !* file open status
1633: 011a:     INTEGER*1   F.NO.MORE.RECORDS           !* end of file reached
1634: 011a:     INTEGER*2   F.READ.CHECK%               !* return from the read
1635: 011a:     STRING      F.FTP.TRUSER.MATCH$         !* full string for user name
1636: 011a:     STRING      F.FTP.PASSWORD$             !* extracted password
1637: 011a:     INTEGER*2   F.MATCH.OFFSET%             !* match offset of user name
1638: 011a:     INTEGER*2   F.NEXT.OFFSET%              !* next offset after user
1639: 011a: END FUNCTION
1640: 011a: 
1641: 011a: 
1642: 011a:     %INCLUDE SLPCFEXT.J86    ! sleeper control                          !KDC
1643: 011a: \*****************************************************************************
1644: 011a: \*****************************************************************************
1645: 011a: \***
1646: 011a: \***         FUNCTION DEFINITIONS FOR SLEEPER CHECK FILE
1647: 011a: \***
1648: 011a: \***                    REFERENCE : slpcfexa.J86
1649: 011a: \***
1650: 011a: \***    Version A           Steve Windsor          8.2.93
1651: 011a: \***
1652: 011a: \***    Version B           Richard Foster         8.7.93
1653: 011a: \***  
1654: 011a: \*****************************************************************************
1655: 011a: \*****************************************************************************
1656: 011a: 
1657: 011a:    FUNCTION SLPCF.SET EXTERNAL
1658: 011a:    END FUNCTION
1659: 011a: 
1660: 011a:   FUNCTION READ.SLPCF EXTERNAL
1661: 011a:    INTEGER*2 READ.SLPCF
1662: 011a:   END FUNCTION
1663: 011a: 
1664: 011a:   FUNCTION WRITE.SLPCF EXTERNAL
1665: 011a:    INTEGER*2 WRITE.SLPCF
1666: 011a:   END FUNCTION
1667: 011a: 
1668: 011a: 
1669: 011a: \***********************************************************************
1670: 011a: \*
1671: 011a: \*    ADXDATE  : This Sub-program is directly referenced from
1672: 011a: \*               "Programming Guide" (Version 6 Release 3). It
1673: 011a: \*               uses the ADXDATE and returns the System date
1674: 011a: \*               in YYYYMMDD format.
1675: 011a: \*
1676: 011a: \***********************************************************************
1677: 011a: SUB ADXDATE(RC, BUFFER) EXTERNAL
1678: 011a:     INTEGER*4 RC
1679: 011a:     STRING BUFFER
1680: 011a: END SUB
1681: 011a: 
1682: 011a: \***********************************************************************
1683: 011a: \*
1684: 011a: \*    FUNC.IS.VALID.TIME(FIELD$):This Function is passed a string and
1685: 011a: \*                               returns true (non zero) if it is a
1686: 011a: \*                               valid time in the format of HHMM
1687: 011a: \*
1688: 011a: \***********************************************************************
1689: 011a: FUNCTION FUNC.IS.VALID.TIME(FIELD$)                                     !KDC
1690: 0143:     INTEGER*2       FUNC.IS.VALID.TIME                                  !KDC
1691: 0143:     INTEGER*2       VALUE%                                              !KDC
1692: 0143:     STRING          FIELD$                                              !KDC
1693: 0143:                                                                         !KDC
1694: 0143: ON ERROR GOTO ERROR.TRAP
1695: 0158:     ! default as valid
1696: 0158:     FUNC.IS.VALID.TIME = -1
1697: 0165: 
1698: 0165:     VALUE% = VAL(FIELD$)
1699: 017d: 
1700: 017d:     !------------------------------------------------------------!      !OJK
1701: 017d:     ! Making sure that it's numeric value between 0 and 2359 and !      !OJK
1702: 017d:     ! length of the field is equal to 4 else it's invalid time   !      !OJK
1703: 017d:     !------------------------------------------------------------!      !OJK
1704: 017d:     IF VALUE% < 0 OR VALUE% > 2359 OR LEN(FIELD$) <> 4 THEN BEGIN       !OJK
1705: 01bb:         FUNC.IS.VALID.TIME = 0
1706: 01cb:     ENDIF ELSE BEGIN
1707: 01d3: 
1708: 01d3:         IF VAL(LEFT$(FIELD$,2))  > 23 OR VAL(RIGHT$(FIELD$,2)) > 59 \   !OJK
1709: 0276:         THEN BEGIN                                                      !OJK
1710: 0276:             FUNC.IS.VALID.TIME = 0
1711: 0283:         ENDIF
1712: 028b: 
1713: 028b:     ENDIF
1714: 0293: 
1715: 0293: !    FIELD$ = ""                                                        !OJK
1716: 0293: 
1717: 0293: FUNC.EXIT:
1718: 02a3: 
1719: 02a3: EXIT FUNCTION
1720: 02ad: 
1721: 02ad: ERROR.TRAP:
1722: 02bd: 
1723: 02bd: ! Any error in the function is assumed as INVALID time and hence        !OJK
1724: 02bd: ! commenting out the ERR check                                          !OJK
1725: 02bd: !    IF ERR = "IH" THEN BEGIN                                           !OJK
1726: 02bd:     FUNC.IS.VALID.TIME = 0
1727: 02ca:     RESUME FUNC.EXIT
1728: 02e1: !    ENDIF                                                              !OJK
1729: 02e1: 
1730: 02e1: END FUNCTION                                                            !KDC
1731: 02fd: 
1732: 02fd: 
1733: 02fd: \***********************************************************************
1734: 02fd: \***********************************************************************
1735: 02fd: \***********************************************************************
1736: 02fd: \*                                                                     *
1737: 02fd: \*          S T A R T   O F   M A I N L I N E   C O D E                *
1738: 02fd: \*                                                                     *
1739: 02fd: \***********************************************************************
1740: 02fd: \***********************************************************************
1741: 02fd: \***********************************************************************
1742: 02fd: 
1743: 02fd: ON ERROR GOTO ERROR.DETECTED
1744: 032c: 
1745: 032c:     GOSUB INITIALISATION
1746: 033e:     GOSUB MAIN.PROCESSING
1747: 0350:     GOSUB TERMINATION
1748: 0362: 
1749: 0362: ! Called during abnormal run
1750: 0362: STOP.PROGRAM:
1751: 0372:     STOP
1752: 037f: 
1753: 037f: \***********************************************************************
1754: 037f: \*
1755: 037f: \*    INITIALISATION : This Sub-routine does all the initial processing
1756: 037f: \*                     before starting the main process
1757: 037f: \*
1758: 037f: \***********************************************************************
1759: 037f: INITIALISATION:
1760: 038f: 
1761: 038f:     GOSUB INITIALISE.VARIABLES
1762: 03a1:     GOSUB CHECK.PARAM
1763: 03b3:     GOSUB CONTROLLER.CONFIG.CHECK
1764: 03c5:     GOSUB ALLOCATE.SESSION.NUMBERS
1765: 03d7:     GOSUB CREATE.RUN.PIPE
1766: 03e9:     GOSUB CHECK.BKP.DIRECTORIES
1767: 03fb:     GOSUB CREATE.XBACKUP.LOG
1768: 040d:     GOSUB PROG.RUN.MODE
1769: 041f:     GOSUB GET.SLEEPER.CONFIGURATION                                     !KDC
1770: 0431:     GOSUB CREATE.FILES
1771: 0443:     GOSUB OPEN.AND.READ.XBKOK
1772: 0455:     GOSUB UPDATE.XBKOK
1773: 0467: 
1774: 0467: RETURN
1775: 0477: 
1776: 0477: \***********************************************************************
1777: 0477: \*
1778: 0477: \*    MAIN.PROCESSING : This Sub-routine does the main processing for
1779: 0477: \*                      creating the Backup.
1780: 0477: \*
1781: 0477: \***********************************************************************
1782: 0477: MAIN.PROCESSING:
1783: 0487: 
1784: 0487:   ! GOSUB BKPLIST.FULL.CHECK                                            !URG KDC
1785: 0487:     GOSUB PROCESS.BKPSCRPT
1786: 0499:   ! GOSUB CREATE.UPDATED.BKPLIST                                        !URG
1787: 0499:     GOSUB BACKUP.COMPLETION
1788: 04ab:   ! GOSUB BACKUP.CONFIG.FILES                                           !URG OJK
1789: 04ab:     GOSUB OLD.ARCHIVE.PURGE
1790: 04bd:     GOSUB FINAL.UPDATE.XBKOK        ! Changed the order of XBKOK update !OJK
1791: 04cf: 
1792: 04cf: RETURN
1793: 04df: 
1794: 04df: \***********************************************************************
1795: 04df: \*
1796: 04df: \*    TERMINATION: Termination Sub-routine will be called before
1797: 04df: \*                 program closure.
1798: 04df: \*
1799: 04df: \***********************************************************************
1800: 04df: TERMINATION:
1801: 04ef: 
1802: 04ef:     GOSUB CLOSE.AND.DEALLOC.SESSIONS
1803: 0501: 
1804: 0501: RETURN
1805: 0511: 
1806: 0511: \**********************************************************************\
1807: 0511: \**********************************************************************\
1808: 0511: \*                                                                    *\
1809: 0511: \*                 INITIALISATION SPECIFIC ROUTINES                   *\
1810: 0511: \*                                                                    *\
1811: 0511: \**********************************************************************\
1812: 0511: \**********************************************************************\
1813: 0511: 
1814: 0511: \***********************************************************************
1815: 0511: \*
1816: 0511: \*    INITIALISE.VARIABLES : This Sub-routine Initialize all the
1817: 0511: \*                           necessary variables which will be used
1818: 0511: \*                           in this program.
1819: 0511: \*
1820: 0511: \***********************************************************************
1821: 0511: INITIALISE.VARIABLES:
1822: 0521: 
1823: 0521:     ! messages for update and errors                                    !KDC
1824: 0521:     GOSUB INITALISE.MESSAGES                                            !KDC
1825: 0533: 
1826: 0533:     STATUS.MSG$ = STATUS.TEXT.MSG$(2)                                   !KDC
1827: 0558:     GOSUB DISPLAY.STATUS.MSG
1828: 056a: 
1829: 056a:     ! Program name
1830: 056a:     PROGRAM$        = "XBACKUP"
1831: 057f: 
1832: 057f:     ! Zero variable
1833: 057f:     XBACK.ZERO%     = 0                      ! Setting '0' variable
1834: 058c: 
1835: 058c:     ! ADXSERVE function variables
1836: 058c:     ADX.FUNCTION%   = 26                     ! Default Function value
1837: 0599:     ADX.INTEGER%    = XBACK.ZERO%
1838: 05a7:     ADXSERVE.RC%    = XBACK.ZERO%
1839: 05bf: 
1840: 05bf:     ! Boolean assignments
1841: 05bf:     FALSE           = XBACK.ZERO%            !  0 = False
1842: 05cd:     TRUE            = -1                     ! -1 = True
1843: 05da: 
1844: 05da:     ! Command line assignment
1845: 05da:     COMMAND.STRING$ = COMMAND$   
1846: 05f0: 
1847: 05f0:     ! Parameter value
1848: 05f0:     PARM.BACKGRND$      = "BACKGRND"                                    !RJK
1849: 0605:     PARM.FULL$          = "F"                                           !KDC
1850: 061a:     PARM.INCREMENTAL$   = "I"                                           !KDC
1851: 062f:     PARM.ONS$           = "RE-RUN"                                      !KDC
1852: 0644:     PARM.SLEEPER$       = "SLEEPER"                                     !KDC
1853: 0659:     ! built command string expected at start up                         !KDC
1854: 0659:     PARM.BACKGRND.INC$ = PARM.BACKGRND$ + " " + PARM.INCREMENTAL$       !RJK
1855: 0681:     PARM.BACKGRND.FULL$= PARM.BACKGRND$ + " " + PARM.FULL$              !RJK
1856: 06a9:     PARM.RERUN.FULL$   = PARM.ONS$ + " " +  PARM.FULL$                  !KDC
1857: 06d1:     PARM.SLEEPER.FULL$ = PARM.SLEEPER$ + " " +  PARM.FULL$              !KDC
1858: 06f9:     PARM.RERUN.INC$    = PARM.ONS$ + " " +  PARM.INCREMENTAL$           !KDC
1859: 0721:     PARM.SLEEPER.INC$  = PARM.SLEEPER$ + " " +  PARM.INCREMENTAL$       !KDC
1860: 0749: 
1861: 0749:     ! Backup directory names must be hard coded to match the XRESTORE   !KDC
1862: 0749:     ! logic which cannot use user logical names because it needs to run !KDC
1863: 0749:     ! under supplemental where these are not available.                 !KDC
1864: 0749:     ! They are constructed here to make any future change more          !KDC
1865: 0749:     ! manageable and shown here in logical order for clarity            !KDC
1866: 0749:     CE.NODE.NAME$                   = "ADXLXCEN::"                      !KDC
1867: 075e:     CF.NODE.NAME$                   = "ADXLXCFN::"                      !KDC
1868: 0773:     C.DRIVE.IMAGE.DIRECTORY$        = "C:\XDISKIMG\"                    !KDC
1869: 0788:     C.DRIVE.ALTERNATE.DIRECTORY$    = "C:\XDISKALT\"                    !KDC
1870: 079d:     D.DRIVE.IMAGE.DIRECTORY$        = "D:\XDISKIMG\"                    !KDC
1871: 07b2:     D.DRIVE.ALTERNATE.DIRECTORY$    = "D:\XDISKALT\"                    !KDC
1872: 07c7:     
1873: 07c7: 
1874: 07c7:     ! To ensure faster processing is achieved using W drive rather than !TSM
1875: 07c7:     ! C drive to avoide repeated open and close on harddisk             !TSM
1876: 07c7: 
1877: 07c7:     TEMP.DIRECTORY.NAME$           = "W:\"                              !TSM
1878: 07dc:     ! the full path can then be constructed                             !KDC
1879: 07dc:     ! for CE                                                            !KDC
1880: 07dc:     CE.C.XDISKALT$  = CE.NODE.NAME$ + C.DRIVE.ALTERNATE.DIRECTORY$      !KDC
1881: 0800:     CE.C.XDISKIMG$  = CE.NODE.NAME$ + C.DRIVE.IMAGE.DIRECTORY$          !KDC
1882: 0824:     CE.D.XDISKALT$  = CE.NODE.NAME$ + D.DRIVE.ALTERNATE.DIRECTORY$      !KDC
1883: 0848:     CE.D.XDISKIMG$  = CE.NODE.NAME$ + D.DRIVE.IMAGE.DIRECTORY$          !KDC
1884: 086c:     ! for CF                                                            !KDC
1885: 086c:     CF.C.XDISKALT$  = CF.NODE.NAME$ + C.DRIVE.ALTERNATE.DIRECTORY$      !KDC
1886: 0890:     CF.C.XDISKIMG$  = CF.NODE.NAME$ + C.DRIVE.IMAGE.DIRECTORY$          !KDC
1887: 08b4:     CF.D.XDISKALT$  = CF.NODE.NAME$ + D.DRIVE.ALTERNATE.DIRECTORY$      !KDC
1888: 08d8:     CF.D.XDISKIMG$  = CF.NODE.NAME$ + D.DRIVE.IMAGE.DIRECTORY$          !KDC
1889: 08fc:                                                                         !KDC
1890: 08fc:     ! files located in the temporary directory                          !KDC
1891: 08fc:                             ! Excluded list                             !KDC
1892: 08fc:     BKPEXCL.FILE.NAME$      = TEMP.DIRECTORY.NAME$ + "BKPEXCL.DAT"      !KDC
1893: 091c:                             ! BKPLIST C drive file                      !OJK
1894: 091c: 
1895: 091c:     !Removing the access to BKPLIST file as we dont need to maintain it !URG
1896: 091c:     ! BKPLIST.FILE.NAME.C$    = "C:\ADX_UDT1\BKPLIST."                  !URG OJK
1897: 091c:                             ! FTP file                                  !KDC
1898: 091c:     FTP.FILE.NAME$          = TEMP.DIRECTORY.NAME$ + "XBKPFTP.FTP"      !KDC
1899: 093c:                             ! FTP output                                !KDC
1900: 093c:     FTPOUT.FILE.NAME$       = TEMP.DIRECTORY.NAME$ + "XBKPFTP.OUT"      !KDC
1901: 095c:                             ! Log file                                  !KDC
1902: 095c:     XBACK.LOG.LIVE.PATH$    = TEMP.DIRECTORY.NAME$ + "XBACKUP.LOG"      !KDC
1903: 097c:                             ! Temporary log                             !KDC
1904: 097c:     XBKTEMP.LOG$            = TEMP.DIRECTORY.NAME$ + "XBKTEMP.LOG"      !KDC
1905: 099c:     ! Other File names                                                  !KDC
1906: 099c:     BKPFAILC.FILE.NAME$     = "D:\XDISKIMG\BKPFAILC."    ! failed C list!OJK
1907: 09b1:     BKPFAILD.FILE.NAME$     = "C:\XDISKIMG\BKPFAILD."    ! failed D list!OJK
1908: 09c6:     BKPSCRPT.FILE.NAME$     = "D:\ADX_UDT1\BKPSCRPT.TXT" ! Backup script
1909: 09db:     TEMP.FILE.NAME$         = "TEMP"                     ! Temporary
1910: 09f0:     XBACK.LOG.FILE.NAME$    = "D:\ADX_UDT1\XBACKUP.LOG"  ! Log file
1911: 0a05:     XBACK.PIPE.NAME$        = "pi:XBACKUP"               ! Pipe name
1912: 0a1a: 
1913: 0a1a:     ! Updated File and Pipe variables                                   !CJK
1914: 0a1a:     BKPEXCL.REPORT.NUM%     = 205                   !                   !OJK
1915: 0a28:     BKPFAILC.REPORT.NUM%    = 418                   ! Temporary         !OJK
1916: 0a36:     BKPFAILD.REPORT.NUM%    = 419                   ! report            !OJK
1917: 0a44:     BKPSCRPT.REPORT.NUM%    = 420                   ! numbers
1918: 0a52:     TEMP.REPORT.NUM%        = 426                   !
1919: 0a60:     TEMP.REPORT.NUM.2%      = 531                   !
1920: 0a6e:     XBACK.LOG.REPORT.NUM%   = 668                   !
1921: 0a7c:     XBACK.PIPE.REPORT.NUM%  = 827                   !
1922: 0a8a: 
1923: 0a8a:     ! Directory listing output files
1924: 0a8a:     DIR.OUT$                = "C:\DIR.OUT"          ! Directory listing
1925: 0a9f:     DIR.SEC.OUT$            = "C:\DIR.OU1"          ! Directory listing
1926: 0ab4: 
1927: 0ab4:     ! Controller related variables
1928: 0ab4:     ALT.MASTER.ON           = FALSE                 ! CF presence
1929: 0ac2:     CE.CNTR$                = "CE"                  ! CE Controller     !CJK
1930: 0ad7:     CF.CNTR$                = "CF"                  ! CF Controller     !CJK
1931: 0aec:     MASTER$                 = "CE"                  ! Default Controller
1932: 0b01:     ! ADXSERVE file function variable value for MASTER/FILE server      !OJK
1933: 0b01:     MASTER.AND.FILE.SERVER% = 21                    ! Master/File server
1934: 0b0e: 
1935: 0b0e:     ! Boolean variables
1936: 0b0e:     ALT.EXISTS              = FALSE                 ! ALT and IMG
1937: 0b1c:     IMG.EXISTS              = FALSE                 ! directory exist
1938: 0b2a:     VALUE.EXISTS            = TRUE                  ! Boolean check
1939: 0b38: 
1940: 0b38:     ! File not opened yet, hence defaulting to FALSE                    !OJK
1941: 0b38:     BKPEXCL.OPEN   = FALSE                                              !OJK
1942: 0b46:     BKPFAILC.OPEN  = FALSE                                              !OJK
1943: 0b54:     BKPFAILD.OPEN  = FALSE                                              !OJK
1944: 0b62:     BKPLI.OPEN     = FALSE                                              !OJK
1945: 0b70:     BKPSCRPT.OPEN  = FALSE                                              !OJK
1946: 0b7e:     SLPCF.OPEN     = FALSE                                              !OJK
1947: 0b8c:     TEMP.2.OPEN    = FALSE                                              !OJK
1948: 0b9a:     TEMP.OPEN      = FALSE                                              !OJK
1949: 0ba8:     XBACK.LOG.OPEN = FALSE                                              !OJK
1950: 0bb6:     XBACK.OPEN     = FALSE                                              !OJK
1951: 0bc4:     XBKOK.OPEN     = FALSE                                              !OJK
1952: 0bd2: 
1953: 0bd2:     ! Repeated variables
1954: 0bd2:     COMMA.VALUE$            = ","                   ! Comma value
1955: 0be7:     XBACK.NULL$             = ""                    ! Null value
1956: 0bfc:     XBACK.YES$              = "Y"                   ! 'Y' value
1957: 0c11: 
1958: 0c11:     ! Status variables
1959: 0c11:     RUN.TYPE$               = XBACK.NULL$           ! Null              !DJK
1960: 0c2a:     STATUS.END$             = "E"                   ! Successful End
1961: 0c3f:     STATUS.MAJOR.ERROR$     = "X"                   ! Major error
1962: 0c54:     STATUS.START$           = "S"                   ! Program started
1963: 0c69: 
1964: 0c69:     ! Array variables
1965: 0c69:     ARRAY.INDEX%            = XBACK.ZERO%
1966: 0c78:     ARRAY.LIMIT%            = 10000                 ! Array limit
1967: 0c86:     ARRAY.SECOND.INDEX%     = XBACK.ZERO%
1968: 0c95:     
1969: 0c95:     BKPEXCL.ARRAY.INDEX% = 1               !Exclude array index         !TSM
1970: 0ca3:     BKPEXCL.ARRAY.LIMIT% = 1000            !Exclude array limit         !TSM
1971: 0cb1:     BKPEXCL.COMP.INDEX%  = 1               !Complete exclude array index!TSM
1972: 0cbf:     BKPEXCL.COMP.LIMIT%  = 10000           !Complete exclude array limit!TSM
1973: 0ccd:     
1974: 0ccd:     INDEX%                  = XBACK.ZERO%
1975: 0cdc:     NUM.OF.ARRAYS%          = 2                     ! Number of arrays  !FJK
1976: 0ce9:     SECOND.INDEX%           = XBACK.ZERO%           ! used
1977: 0cf8:     SECOND.ARRAY.ON         = FALSE
1978: 0d06: 
1979: 0d06:     CRLF$                   = CHR$(13) + CHR$(10)   ! Assigning CR/LF   !OJK
1980: 0d33: 
1981: 0d33:     ! It holds BKPLIST line values and 10,000 is the maximum allowed    !OJK
1982: 0d33:     ! BKPLIST line value in this array                                  !OJK
1983: 0d33:     ! DIM BKPLIST.ARRAY$(ARRAY.LIMIT%)                                  !URG
1984: 0d33:     
1985: 0d33:     !Defines array dimension                                            !TSM
1986: 0d33:     DIM BKPEXCL.ARRAY$(BKPEXCL.ARRAY.LIMIT%)                            !TSM
1987: 0d5e:     DIM BKPEXCL.COMP.ARRAY$(BKPEXCL.COMP.LIMIT%)                        !TSM
1988: 0d89: 
1989: 0d89:     ! Incremental file flag for existing and changed                    !KDC
1990: 0d89:     ! Other than one FULL backup day in a week, rest of the 6 days      !OJK
1991: 0d89:     ! details will be stored and used using in following arrays         !OJK
1992: 0d89:     DIM BKPLI.INCREMENTAL.EXIST$(6)                                     !KDC
1993: 0db8:     DIM BKPLI.INCREMENTAL.FILE.CHNG$(6)                                 !KDC
1994: 0de7: 
1995: 0de7: !    CRLF$                   = CHR$(13) + CHR$(10)   ! Assigning CR/LF  !OJK
1996: 0de7: 
1997: 0de7:     ! set the file function variables                                   !KDC
1998: 0de7:     CALL BKPLI.SET
1999: 0df4:     CALL XBKOK.SET
2000: 0e0f:     CALL HSIUF.SET                                                      !KDC
2001: 0e1c:     CALL SLPCF.SET                                                      !KDC
2002: 0e37: 
2003: 0e37:     GOSUB SET.PROCESS.DATE
2004: 0e49: 
2005: 0e49: RETURN
2006: 0e59: 
2007: 0e59: ! KDC START BLOCK
2008: 0e59: \***********************************************************************
2009: 0e59: \*
2010: 0e59: \*    INITALISE.MESSAGES:This Sub-routine Initialize all the messages
2011: 0e59: \*                       used for status update and errors
2012: 0e59: \*
2013: 0e59: \***********************************************************************
2014: 0e59: INITALISE.MESSAGES:
2015: 0e69: 
2016: 0e69:     VERSION$ = "### XBACKUP.286 - Version R - 09/09/2014 ###"           !RJK
2017: 0e7e: 
2018: 0e7e:     DIM STATUS.TEXT.MSG$(60)
2019: 0ea7:     DIM STATUS.TEXT.ERROR$(60)
2020: 0ed0: 
2021: 0ed0:     !******************************************************************
2022: 0ed0:     ! Status update messages
2023: 0ed0:     !******************************************************************
2024: 0ed0:     STATUS.TEXT.MSG$(0)  = "Version ""R"" "                             !RJK
2025: 0ef0:     STATUS.TEXT.MSG$(1)  = "Ended: ZIP files already present"
2026: 0f10:     STATUS.TEXT.MSG$(2)  = STATUS.TEXT.MSG$(0) + \
2027: 0f47:                            " Initialising variables"
2028: 0f47:     STATUS.TEXT.MSG$(3)  = "Defining Process date"
2029: 0f67:     STATUS.TEXT.MSG$(4)  = "Processing on "
2030: 0f87:     STATUS.TEXT.MSG$(5)  = " at "
2031: 0fa7:     STATUS.TEXT.MSG$(6)  = "Checking Controller configuration"
2032: 0fc7:     STATUS.TEXT.MSG$(7)  = "Ending the program"
2033: 0fe7:     STATUS.TEXT.MSG$(8)  = "Controller is not Master/File server"
2034: 1007:     STATUS.TEXT.MSG$(9)  = "SLPCF Full backup day is "
2035: 1027:     STATUS.TEXT.MSG$(10) = "Allocating Session numbers"
2036: 1047:     STATUS.TEXT.MSG$(11) = "Creating run pipe"
2037: 1067:     STATUS.TEXT.MSG$(12) = "Checking backup directories"
2038: 1087:     STATUS.TEXT.MSG$(13) = " directory created"
2039: 10a7:     STATUS.TEXT.MSG$(14) = ""
2040: 10c7:     STATUS.TEXT.MSG$(15) = "Run is not scheduled for today"
2041: 10e7:     STATUS.TEXT.MSG$(16) = "Backup Configured for all Days"
2042: 1107:     STATUS.TEXT.MSG$(17) = ""
2043: 1127:     STATUS.TEXT.MSG$(18) = ""
2044: 1147:     STATUS.TEXT.MSG$(19) = ""
2045: 1167:     STATUS.TEXT.MSG$(20) = ""
2046: 1187:     STATUS.TEXT.MSG$(21) = ""
2047: 11a7:     STATUS.TEXT.MSG$(22) = ""
2048: 11c7: 
2049: 11c7:     STATUS.TEXT.MSG$(23) = "Existing XBACKUP log deleted"
2050: 11e7:     STATUS.TEXT.MSG$(24) = STATUS.TEXT.MSG$(0) + \
2051: 121e:                            " Backup Application started"
2052: 121e:     STATUS.TEXT.MSG$(25) = "New XBACKUP log file created"
2053: 123e:     STATUS.TEXT.MSG$(26) = "Master Controller is CE"
2054: 125e:     STATUS.TEXT.MSG$(27) = "Master Controller is CF"
2055: 127e:     STATUS.TEXT.MSG$(28) = "Program running in Sleeper mode"
2056: 129e:     STATUS.TEXT.MSG$(29) = "Existing BKPEXCL file deleted"
2057: 12be:     STATUS.TEXT.MSG$(30) = "New BKPFAIL files created"                  !OJK
2058: 12de:     STATUS.TEXT.MSG$(31) = "Created new XBKOK"
2059: 12fe:     STATUS.TEXT.MSG$(32) = "XBKOK opened and read"
2060: 131e:     STATUS.TEXT.MSG$(33) = ""                   ! removed as duplicated
2061: 133e:     STATUS.TEXT.MSG$(34) = "Started: ""S"" XBACKUP started"
2062: 135e:     STATUS.TEXT.MSG$(35) = "Ended: ""E"" XBACKUP ended"
2063: 137e: 
2064: 137e:     ! As BKPLIST file is not required anymore, no need of below statuses!URG
2065: 137e:     ! STATUS.TEXT.MSG$(36) = " files present in BKPLIST"                !URG
2066: 137e:     ! STATUS.TEXT.MSG$(37) = "BKPLIST file opened"                      !URG
2067: 137e:     ! STATUS.TEXT.MSG$(38) = "New BKPLIST file created"                 !URG
2068: 137e: 
2069: 137e:     STATUS.TEXT.MSG$(39) = "FULL backup in progress..."
2070: 139e:     STATUS.TEXT.MSG$(40) = "INCREMENTAL backup in progress..."
2071: 13be:     ! backup script processing wait message
2072: 13be:     STATUS.TEXT.MSG$(41) = "Please note that directory archiving"
2073: 13de:     STATUS.TEXT.MSG$(42) = "would take more time depending on the"
2074: 13fe:     STATUS.TEXT.MSG$(43) = "number of files in a directory"
2075: 141e:     STATUS.TEXT.MSG$(44) = "Hence please be patient when"
2076: 143e:     STATUS.TEXT.MSG$(45) = "the program is running..."
2077: 145e:     STATUS.TEXT.MSG$(46) = "**************************************"
2078: 147e: 
2079: 147e:     STATUS.TEXT.MSG$(47) = " directory archiving...  "
2080: 149e:     STATUS.TEXT.MSG$(48) = "Success: Directory Backup completed"
2081: 14be:     STATUS.TEXT.MSG$(49) = " directory back up starts..."
2082: 14de:     ! Removing the status of BKPLIST file                               !URG
2083: 14de:     ! STATUS.TEXT.MSG$(50) = "Creating Updated BKPLIST file"            !URG
2084: 14de:     ! STATUS.TEXT.MSG$(51) = "Updated BKPLIST file created"             !URG
2085: 14de:     ! STATUS.TEXT.MSG$(52) = "Ended: BKPLIST file write error"          !URG
2086: 14de:     STATUS.TEXT.MSG$(53) = "Started FTPing the archived files"
2087: 14fe:     STATUS.TEXT.MSG$(54) = "Archived file FTP transfer completed"
2088: 151e:     STATUS.TEXT.MSG$(55) = "Older archive files purged"
2089: 153e:     STATUS.TEXT.MSG$(56) = "XBACKUP log file backed up successfully"
2090: 155e:     ! STATUS.TEXT.MSG$(57) = "Deleting older BKPLIST file if present"   !URG
2091: 155e:     STATUS.TEXT.MSG$(58) = ""
2092: 157e:     STATUS.TEXT.MSG$(59) = ""
2093: 159e:     STATUS.TEXT.MSG$(60) = ""
2094: 15be: 
2095: 15be:     !******************************************************************
2096: 15be:     ! Error messages
2097: 15be:     !******************************************************************
2098: 15be:     STATUS.TEXT.ERROR$(1)  = "Error: Open/read failed in DIR list file"
2099: 15de:     STATUS.TEXT.ERROR$(2)  = "Error: Open/Read failed in DIR MDD file"
2100: 15fe:     STATUS.TEXT.ERROR$(3)  = "ADXDATE sub-program error"
2101: 161e:     STATUS.TEXT.ERROR$(4)  = "Parameter is missing or incorrect... "
2102: 163e:     STATUS.TEXT.ERROR$(5)  = "Controller status not obtainable"
2103: 165e:     STATUS.TEXT.ERROR$(6)  = "Error: Controller Node ID invalid"
2104: 167e:     STATUS.TEXT.ERROR$(7)  = "SLPCF Full backup configuration not found"
2105: 169e:     STATUS.TEXT.ERROR$(8)  = "Ended: Directory listing error"
2106: 16be:     STATUS.TEXT.ERROR$(9)  = "Error: Variable error in BKPSCRPT file"
2107: 16de:     STATUS.TEXT.ERROR$(10) = "Ended: Open error in BKPSCRPT file"
2108: 16fe:     STATUS.TEXT.ERROR$(11) = "Ended: Read error in BKPSCRPT file"
2109: 171e:     STATUS.TEXT.ERROR$(12) = "Ended: XBKOK read error"
2110: 173e:     STATUS.TEXT.ERROR$(13) = "Ended: XBKOK truncated"
2111: 175e:     STATUS.TEXT.ERROR$(14) = "ERROR: XBKOK missing"
2112: 177e:     STATUS.TEXT.ERROR$(15) = "Ended: XBKOK write error"
2113: 179e:     STATUS.TEXT.ERROR$(16) = "Ended: ""X"" Critical Error, refer log"
2114: 17be:     ! STATUS.TEXT.ERROR$(17) = "Full run, New BKPLIST file created"     ! URG
2115: 17be:     ! Array limit reached message
2116: 17be:     STATUS.TEXT.ERROR$(18) = "More than "
2117: 17de:     STATUS.TEXT.ERROR$(19) = " files has been found"
2118: 17fe:     STATUS.TEXT.ERROR$(20) = "Check for any abnormality in file system"
2119: 181e: 
2120: 181e:     ! STATUS.TEXT.ERROR$(21) = "Current week BKPLIST file not present"  ! URG
2121: 181e:     STATUS.TEXT.ERROR$(22) = " directory does not exist"
2122: 183e:     STATUS.TEXT.ERROR$(23) = "Error: BKPEXCL write failed"
2123: 185e:     STATUS.TEXT.ERROR$(24) = "Ended: Open/Read failure in DIR.NOT file"
2124: 187e:     STATUS.TEXT.ERROR$(25) = "Error: Open/Read failed in DIR list file"
2125: 189e:     STATUS.TEXT.ERROR$(26) = "Error: Read failed in DIR list file"
2126: 18be:     STATUS.TEXT.ERROR$(27) = "Ended: Open failed in BKPEXCL file"
2127: 18de:     STATUS.TEXT.ERROR$(28) = " backup rename fails"
2128: 18fe:     STATUS.TEXT.ERROR$(29) = " file COPY error"
2129: 191e:     STATUS.TEXT.ERROR$(30) = " directory is not archived"
2130: 193e:     STATUS.TEXT.ERROR$(31) = "Because it has no files in it..."
2131: 195e:     STATUS.TEXT.ERROR$(32) = "Error: BKPFAIL write failed"
2132: 197e:     STATUS.TEXT.ERROR$(33) = "Error: FTP communication issue occurred"
2133: 199e:     STATUS.TEXT.ERROR$(34) = "Error in opening FTP output file"
2134: 19be:     STATUS.TEXT.ERROR$(35) = "Error: XBKPFTP write failed"
2135: 19de:     STATUS.TEXT.ERROR$(36) = "Error: XBACKUP write failed"
2136: 19fe:     STATUS.TEXT.ERROR$(37) = "UPDATE date function error"
2137: 1a1e:     STATUS.TEXT.ERROR$(38) = "PSDATE function error"
2138: 1a3e:     STATUS.TEXT.ERROR$(39) = "Ended: Error while opening "
2139: 1a5e:     STATUS.TEXT.ERROR$(40) = "Ended: Error in application log"
2140: 1a7e:     ! Invalid parameter message
2141: 1a7e:     STATUS.TEXT.ERROR$(41) = "!**************************************!"
2142: 1a9e:     STATUS.TEXT.ERROR$(42) = "! Please check the parameter..."
2143: 1abe:     STATUS.TEXT.ERROR$(43) = "! Invalid parameter passed"
2144: 1ade: 
2145: 1ade:     STATUS.TEXT.ERROR$(44) = "Logging 106 event File Op = "
2146: 1afe:     STATUS.TEXT.ERROR$(45) = "Error while processing "
2147: 1b1e:     ! Program already running message
2148: 1b1e:     STATUS.TEXT.ERROR$(46) = "***! "
2149: 1b3e:     STATUS.TEXT.ERROR$(47) = ".286 is already active         !***"
2150: 1b5e: 
2151: 1b5e:     STATUS.TEXT.ERROR$(48) = "Ended: Variable error in BKPSCRPT file"
2152: 1b7e:     STATUS.TEXT.ERROR$(49) = "Ended: Unable to access XBACKUP.LOG file"
2153: 1b9e:     STATUS.TEXT.ERROR$(50) = "Ended: Unable to access BKPSCRPT file"
2154: 1bbe:     STATUS.TEXT.ERROR$(51) = "Ended: Unable to access BKPEXCL file"
2155: 1bde:     STATUS.TEXT.ERROR$(52) = "Ended: Unable to access XBKOK file"
2156: 1bfe:     STATUS.TEXT.ERROR$(53) = "Ended: XBACKUP log create failed"
2157: 1c1e:     STATUS.TEXT.ERROR$(54) = "Ended: BKPEXCL file create failed"
2158: 1c3e:     STATUS.TEXT.ERROR$(55) = "Ended: BKPFAILC file create failed"       !OJK
2159: 1c5e:     ! STATUS.TEXT.ERROR$(56) = "Ended: BKPLIST file create failed"      !URG
2160: 1c5e:     STATUS.TEXT.ERROR$(57) = "Ended: Temporary file create failed"
2161: 1c7e:     STATUS.TEXT.ERROR$(58) = "Ended: DAYS TO KEEP is 0 in BKPSCRPT"     !PJK
2162: 1c9e:     ! STATUS.TEXT.ERROR$(59) = "Ended: Unable to access BKPLIST file"   !URG
2163: 1c9e:     STATUS.TEXT.ERROR$(60) = "Ended: BKPFAILD file create failed"       !OJK
2164: 1cbe: RETURN
2165: 1cce: ! KDC END BLOCK
2166: 1cce: 
2167: 1cce: \***********************************************************************
2168: 1cce: \*
2169: 1cce: \*    SET.PROCESS.DATE : This Sub-routine Initialize all the
2170: 1cce: \*                       date and time variables which will
2171: 1cce: \*                       be used in this program.
2172: 1cce: \*
2173: 1cce: \***********************************************************************
2174: 1cce: SET.PROCESS.DATE:
2175: 1cde: 
2176: 1cde:     STATUS.MSG$ = STATUS.TEXT.MSG$(3)                                   !KDC
2177: 1d03:     GOSUB DISPLAY.STATUS.MSG
2178: 1d15: 
2179: 1d15:     !------------------------------------!
2180: 1d15:     ! The below variable holds the first !
2181: 1d15:     ! three letters of all the months    !
2182: 1d15:     !------------------------------------!
2183: 1d15:     MONTH$ = "   JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC"
2184: 1d2a: 
2185: 1d2a:     CURR.DATE$ = DATE$
2186: 1d40:     CURR.TIME$ = TIME$
2187: 1d56: 
2188: 1d56:     !---------------------------------------!
2189: 1d56:     ! To get the date in YYYYMMDD format    !                           !OJK
2190: 1d56:     !---------------------------------------!
2191: 1d56:     CALL ADXDATE (RETURN.VALUE.CHECK%, TODAY.DATE$)                     !OJK
2192: 1d8f: 
2193: 1d8f:     ! Checking the return value
2194: 1d8f:     IF RETURN.VALUE.CHECK% <> XBACK.ZERO% THEN BEGIN                    !KDC
2195: 1daa:         STATUS.MSG$ = STATUS.TEXT.ERROR$(3)                             !KDC
2196: 1dcf:         GOSUB DISPLAY.STATUS.MSG                                        !FJK
2197: 1de1:         GOSUB STOP.PROGRAM                                              !FJK
2198: 1df3:     ENDIF                                                               !FJK
2199: 1dfb: 
2200: 1dfb: ! Commenting out as it has become redundant                             !OJK
2201: 1dfb: !    TODAY.DATE$ = LEFT$(DATE.YYYY$, 2) + CURR.DATE$ ! Year in YYYYMMDD !OJK
2202: 1dfb: 
2203: 1dfb:     ! Today's date in DD MMM YYYY
2204: 1dfb:     TODAY.DATE$ = RIGHT$(TODAY.DATE$, 2) + " "                + \ ! DD
2205: 1ebe:                   MID$(MONTH$,VAL(MID$(TODAY.DATE$,5,2)) * 3  + \ ! MMM
2206: 1ebe:                   1 , 3) + " " + LEFT$(TODAY.DATE$, 4)            ! YYYY
2207: 1ebe: 
2208: 1ebe:     !-------------------------------------------------------!
2209: 1ebe:     ! Defining the Extension name from date and month value !
2210: 1ebe:     !-------------------------------------------------------!
2211: 1ebe:     EXTENSION$ = RIGHT$(CURR.DATE$,4)       ! Extracting Month value    !KDC
2212: 1ede:     GOSUB GET.FILE.EXTENSION                                            !KDC
2213: 1ef0:     EXT.MDD$ = EXTENSION$                                               !KDC
2214: 1f09: 
2215: 1f09: RETURN
2216: 1f19: 
2217: 1f19: \***********************************************************************
2218: 1f19: \*
2219: 1f19: \*    CHECK.PARAM : This Sub-routine uses the ADXSERVE function to
2220: 1f19: \*                  check whether it's a background run. Also
2221: 1f19: \*                  it validates the command parameter.
2222: 1f19: \*
2223: 1f19: \***********************************************************************
2224: 1f19: CHECK.PARAM:
2225: 1f29: 
2226: 1f29:     ! Processing message to display
2227: 1f29:     STATUS.MSG$ = STATUS.TEXT.MSG$(4) + TODAY.DATE$ + \                 !KDC
2228: 1fd6:                   STATUS.TEXT.MSG$(5) + \                               !KDC
2229: 1fd6:                   MID$(TIME$,1,2) + ":" + MID$(TIME$,3,2) + ":" + \     !KDC
2230: 1fd6:                   MID$(TIME$,5,2)                                       !KDC
2231: 1fd6: 
2232: 1fd6: 
2233: 1fd6:     CALL ADXSERVE (ADXSERVE.RC%,ADX.FUNCTION%,ADX.INTEGER%,STATUS.MSG$)
2234: 2012:     CALL TRIM(COMMAND.STRING$)
2235: 2026: 
2236: 2026:     IF ADXSERVE.RC% = -1101 THEN BEGIN  ! Not running as background
2237: 2044:         BACKGROUND.RUN = FALSE
2238: 2052:         GOSUB DISPLAY.STATUS.MSG
2239: 2064: 
2240: 2064:         IF LEN(COMMAND.STRING$) = 1 THEN BEGIN                          !KDC
2241: 2082: 
2242: 2082:             IF COMMAND.STRING$ = "F" THEN BEGIN  ! Full backup
2243: 209d:                 ! Setting the Backup type
2244: 209d:                 RUN.TYPE$ = "F"
2245: 20b5:             ENDIF ELSE IF COMMAND.STRING$ = "I" THEN BEGIN ! Incremental
2246: 20d0:                 ! Setting the Backup type
2247: 20d0:                ! RUN.TYPE$ = "I"                                        !URG
2248: 20d0:                  RUN.TYPE$ = "F"                                        !URG   
2249: 20e8:             ENDIF ELSE BEGIN
2250: 20f0: 
2251: 20f0:                 IF LEN(COMMAND.STRING$) = XBACK.ZERO% THEN BEGIN
2252: 210e:                     !-----------------------------------------------!
2253: 210e:                     ! As command parameters not passed, determining !
2254: 210e:                     ! the backup type using current day             !
2255: 210e:                     !-----------------------------------------------!
2256: 210e: 
2257: 210e:                     ! Getting the day using PSDATE function
2258: 210e:                     PSDATE.DATE$ = CURR.DATE$                           !KDC
2259: 2127:                     GOSUB GET.DAY.AND.CHECK.ERROR                       !KDC
2260: 2139: 
2261: 2139:                  !   IF F13.DAY$ = FULL.DAY$ THEN BEGIN       ! If Full !URG KDC
2262: 2139:                  !       ! Setting the Backup type                      !URG
2263: 2139: 
2264: 2139:                          RUN.TYPE$ = "F"
2265: 2150: 
2266: 2150:                  !   ENDIF ELSE BEGIN                                   !URG
2267: 2150:                  !      ! Setting the Backup type                       !URG
2268: 2150:                  !       RUN.TYPE$ = "I"                                !URG
2269: 2150:                  !   ENDIF                                              !URG
2270: 2150: 
2271: 2150:                 ENDIF ELSE BEGIN
2272: 2158:                     GOSUB INVALID.PARAM.EXIT                            !DJK
2273: 216a:                 ENDIF
2274: 2172:             ENDIF
2275: 217c: 
2276: 217c:         ENDIF ELSE BEGIN
2277: 2184:             GOSUB INVALID.PARAM.EXIT                                    !DJK
2278: 2196:         ENDIF
2279: 21a1: 
2280: 21a1:     ENDIF ELSE BEGIN
2281: 21a9:         GOSUB CHECK.ADXSERVE.RC ! Stops program if non zero
2282: 21bb:         BACKGROUND.RUN = TRUE
2283: 21c9: 
2284: 21c9:         !-----------------------------------------------------!         !DJK
2285: 21c9:         ! Implemented changes in Background parameter check   !         !DJK
2286: 21c9:         ! with respect to the changes in SLEEPER program      !         !DJK
2287: 21c9:         !-----------------------------------------------------!         !DJK
2288: 21c9: 
2289: 21c9:         ! If parameter is SLEEPER or RERUN Incremental
2290: 21c9:         IF RIGHT$(COMMAND.STRING$,9) = PARM.SLEEPER.INC$ OR \           !RJK
2291: 226d:            RIGHT$(COMMAND.STRING$,8) = PARM.RERUN.INC$   OR \           !RJK
2292: 226d:            COMMAND.STRING$ = PARM.BACKGRND.INC$   THEN BEGIN            !RJK
2293: 226d:             ! Setting the Backup type
2294: 226d:            ! RUN.TYPE$ = "I"                                            !URG
2295: 226d:              RUN.TYPE$ = "F"                                            !URG
2296: 2285:         ! If parameter is SLEEPER or RERUN Full
2297: 2285:         ENDIF ELSE IF RIGHT$(COMMAND.STRING$,9)= PARM.SLEEPER.FULL$ OR \!RJK
2298: 2329:                       RIGHT$(COMMAND.STRING$,8) = PARM.RERUN.FULL$  OR \!RJK
2299: 2329:                       COMMAND.STRING$ = PARM.BACKGRND.FULL$ THEN BEGIN  !RJK
2300: 2329:             ! Setting the Backup type
2301: 2329:             RUN.TYPE$ = "F"
2302: 2340: 
2303: 2340:         ! Invalid parameter
2304: 2340:         ENDIF ELSE BEGIN
2305: 2348:             STATUS.MSG$ = STATUS.TEXT.ERROR$(4)
2306: 236d:             GOSUB DISPLAY.STATUS.MSG
2307: 237f:             GOSUB STOP.PROGRAM
2308: 2391:         ENDIF
2309: 2399: 
2310: 2399:     ENDIF
2311: 23a1: 
2312: 23a1: RETURN
2313: 23b1: 
2314: 23b1: \***********************************************************************
2315: 23b1: \*
2316: 23b1: \*    CONTROLLER.CONFIG.CHECK: This Sub-routine uses ADXSERVE function
2317: 23b1: \*                             and check whether the controller is
2318: 23b1: \*                             Master and File server.If not, program
2319: 23b1: \*                             should end, logging an appropriate error.
2320: 23b1: \*
2321: 23b1: \***********************************************************************
2322: 23b1: CONTROLLER.CONFIG.CHECK:
2323: 23c1: 
2324: 23c1:     STATUS.MSG$ = STATUS.TEXT.MSG$(6)                                   !KDC
2325: 23e6:     GOSUB DISPLAY.STATUS.MSG
2326: 23f8: 
2327: 23f8:     ADX.FUNCTION% = 4      ! Function 4 to get the controller details
2328: 2405:     CALL ADXSERVE (ADXSERVE.RC%,ADX.FUNCTION%,ADX.INTEGER%,ADX.PARM.2$)
2329: 2441: 
2330: 2441:     ! If return code non zero state error and end                       !KDC
2331: 2441:     IF ADXSERVE.RC% <> XBACK.ZERO% THEN BEGIN
2332: 2468:         STATUS.MSG$ = STATUS.TEXT.ERROR$(5)                             !KDC
2333: 248d:         GOSUB DISPLAY.STATUS.MSG
2334: 249f:         STATUS.MSG$ = STATUS.TEXT.MSG$(7)                               !KDC
2335: 24c4:         GOSUB DISPLAY.STATUS.MSG
2336: 24d6:         GOSUB STOP.PROGRAM
2337: 24e8:     ENDIF
2338: 24f0: 
2339: 24f0:     ! Controller configuration
2340: 24f0:     CNTLR.CONFIG% = VAL(MID$(ADX.PARM.2$, 25, 2))
2341: 2516:     ! Master Controller ID
2342: 2516:     CNTLR.ID$     = MID$(ADX.PARM.2$, 14, 2)
2343: 2538: 
2344: 2538:     !-------------------------------------------!
2345: 2538:     ! If controller is not a Master/File server !
2346: 2538:     !-------------------------------------------!
2347: 2538:     IF CNTLR.CONFIG% <> MASTER.AND.FILE.SERVER% THEN BEGIN
2348: 254c:         STATUS.MSG$ = STATUS.TEXT.MSG$(8)                               !KDC
2349: 2571:         GOSUB DISPLAY.STATUS.MSG
2350: 2583:         STATUS.MSG$ = STATUS.TEXT.MSG$(7)                               !KDC
2351: 25a8:         GOSUB DISPLAY.STATUS.MSG
2352: 25ba:         GOSUB STOP.PROGRAM
2353: 25cc:     ENDIF
2354: 25d4: 
2355: 25d4:     ADX.FUNCTION% = 36     ! Function 36 to get the configured nodes
2356: 25e1:     CALL ADXSERVE (ADXSERVE.RC%,ADX.FUNCTION%,ADX.INTEGER%,ADX.PARM.2$)
2357: 261d:     GOSUB CHECK.ADXSERVE.RC ! Stops program if non zero
2358: 262f: 
2359: 262f:     ! To identify Controllers in LAN
2360: 262f:     NODE.POSITION%    = MATCH("00", ADX.PARM.2$, 1)
2361: 264d:     CONFIGURED.NODES$ = LEFT$(ADX.PARM.2$, NODE.POSITION% - 1) ! Node ID
2362: 2674: 
2363: 2674:     !---------------------------------------!
2364: 2674:     ! Identifying Master controller Node ID !
2365: 2674:     !---------------------------------------!
2366: 2674:     IF CNTLR.ID$ = CE.CNTR$ THEN BEGIN
2367: 2693:         MASTER$ = CE.CNTR$                                              !OJK
2368: 26ac:         ! If CF controller available
2369: 26ac:         IF MATCH("CF", CONFIGURED.NODES$, 1) <> XBACK.ZERO% THEN BEGIN
2370: 26d3:             ALT.MASTER.ON = TRUE
2371: 26e1:         ENDIF
2372: 26ec:     ENDIF ELSE BEGIN
2373: 26f4:         IF CNTLR.ID$ = CF.CNTR$ THEN BEGIN
2374: 2713:             MASTER$       = CF.CNTR$
2375: 272c:             ALT.MASTER.ON = TRUE
2376: 273c:         ENDIF ELSE BEGIN
2377: 2744:             STATUS.MSG$ = STATUS.TEXT.ERROR$(6)                         !KDC
2378: 2769:             GOSUB DISPLAY.STATUS.MSG
2379: 277b:             GOSUB STOP.PROGRAM
2380: 278d:         ENDIF
2381: 2795:     ENDIF
2382: 279d: 
2383: 279d: RETURN
2384: 27ad: 
2385: 27ad: 
2386: 27ad: \***********************************************************************!KDC
2387: 27ad: \*                                                                      !KDC
2388: 27ad: \*    GET.SLEEPER.CONFIGURATION:This Sub-routine looks through the      !KDC
2389: 27ad: \*                              Sleeper control file in order to see    !KDC
2390: 27ad: \*                              what the current setting for the Full   !KDC
2391: 27ad: \*                              backup is. It then assumes all          !KDC
2392: 27ad: \*                              Incremental based upon this day         !KDC
2393: 27ad: \*                                                                      !KDC
2394: 27ad: \***********************************************************************!KDC
2395: 27ad: GET.SLEEPER.CONFIGURATION:                                              !KDC
2396: 27bd: 
2397: 27bd:     !*******************************************************************!KDC
2398: 27bd:     ! first find the full backup day configured in sleeper              !KDC
2399: 27bd:     !*******************************************************************!KDC
2400: 27bd:     IF END #SLPCF.SESS.NUM% THEN SLPCF.NOT.FOUND
2401: 27d9: 
2402: 27d9:     OPEN SLPCF.FILE.NAME$ DIRECT RECL SLPCF.RECL% \                     !OJK
2403: 2806:          AS SLPCF.SESS.NUM% NOWRITE NODEL
2404: 2806: 
2405: 2806:     SLPCF.OPEN             = TRUE
2406: 2814:     SLPCF.REC.NO%          = 0
2407: 282b:     FULL.BACKUP.NOT.FOUND% = 0
2408: 2838: 
2409: 2838:     WHILE FULL.BACKUP.NOT.FOUND% = 0
2410: 2843:         SLPCF.REC.NO% = SLPCF.REC.NO% + 1
2411: 285c:         IF READ.SLPCF = 0 THEN BEGIN
2412: 2871:             IF SLPCF.APP.NAME$ = "ADX_UPGM:XBACKUP.286" THEN BEGIN
2413: 2892: 
2414: 2892:                 IF SLPCF.PARM$ = PARM.FULL$ THEN BEGIN
2415: 28b7:                     FULL.BACKUP.NOT.FOUND% = 1          !found
2416: 28c4:                     !extract single day for full build
2417: 28c4:                     !SLEEPER.DAY% = VAL(SLPCF.DAY.NUM$)                 !URG
2418: 28c4:                     !STATUS.MSG$ = STATUS.TEXT.MSG$(9) + SLPCF.DAY.NUM$ !URG OJK
2419: 28c4:                     RUN.ALLOWED% = 0                                    !URG
2420: 28d1:                     RUN.ALLOWED$ = "NO"                                 !URG
2421: 28e6: 
2422: 28e6:                !Below code change is to read sleeper properly rather    !URG
2423: 28e6:                !than reading it once a week and count the incremental   !URG
2424: 28e6:                !days. Below approach gives the flexibility to configure !URG
2425: 28e6:                !XBACKUP days based on need                              !URG
2426: 28e6: 
2427: 28e6:                     IF SLPCF.DAY.NUM$ = " " THEN BEGIN                  !URG
2428: 2904:                        STATUS.MSG$ = STATUS.TEXT.MSG$(16)               !URG
2429: 2929:                        GOSUB DISPLAY.STATUS.MSG                         !URG
2430: 293b:                        GOSUB LOG.STATUS.MSG                             !URG
2431: 294d:                        RUN.ALLOWED$ = "YES"                             !URG
2432: 2965:                     ENDIF ELSE BEGIN                                    !URG
2433: 296d:                        CALL PSDATE(DATE$)                               !URG
2434: 2985:                        IF F13.DAY$ = "SUN" THEN BEGIN                   !URG
2435: 29a3:                           RUN.ALLOWED% = MATCH("1",SLPCF.DAY.NUM$,1)    !URG
2436: 29c7:                        ENDIF ELSE IF F13.DAY$ = "MON" THEN BEGIN        !URG
2437: 29e5:                           RUN.ALLOWED% = MATCH("2",SLPCF.DAY.NUM$,1)    !URG
2438: 2a09:                        ENDIF ELSE IF F13.DAY$ = "TUE" THEN BEGIN        !URG
2439: 2a27:                           RUN.ALLOWED% = MATCH("3",SLPCF.DAY.NUM$,1)    !URG
2440: 2a4b:                        ENDIF ELSE IF F13.DAY$ = "WED" THEN BEGIN        !URG
2441: 2a69:                           RUN.ALLOWED% = MATCH("4",SLPCF.DAY.NUM$,1)    !URG
2442: 2a8d:                        ENDIF ELSE IF F13.DAY$ = "THU" THEN BEGIN        !URG
2443: 2aab:                           RUN.ALLOWED% = MATCH("5",SLPCF.DAY.NUM$,1)    !URG
2444: 2acf:                        ENDIF ELSE IF F13.DAY$ = "FRI" THEN BEGIN        !URG
2445: 2aed:                           RUN.ALLOWED% = MATCH("6",SLPCF.DAY.NUM$,1)    !URG
2446: 2b10:                        ENDIF ELSE IF F13.DAY$ = "SAT" THEN BEGIN        !URG
2447: 2b2e:                           RUN.ALLOWED% = MATCH("7",SLPCF.DAY.NUM$,1)    !URG
2448: 2b4f:                        ENDIF                                            !URG
2449: 2b57: 
2450: 2b57:                        IF RUN.ALLOWED% > 0 THEN BEGIN                   !URG
2451: 2b66:                           RUN.ALLOWED$  = "YES"                         !URG
2452: 2b7b:                        ENDIF                                            !URG
2453: 2b83: 
2454: 2b83:                     ENDIF                                               !URG
2455: 2b8b: 
2456: 2b8b: 
2457: 2b8b:                 ENDIF
2458: 2b93:             ENDIF
2459: 2b9d:         ENDIF ELSE BEGIN                                !end of file
2460: 2ba5:             STATUS.MSG$ = STATUS.TEXT.ERROR$(7)                         !KDC
2461: 2bca:             GOSUB DISPLAY.STATUS.MSG
2462: 2bdc:             GOSUB STOP.PROGRAM
2463: 2bee:         ENDIF
2464: 2bf6:     WEND
2465: 2c08: 
2466: 2c08:     GOSUB DISPLAY.STATUS.MSG
2467: 2c1a: 
2468: 2c1a:     IF SLPCF.OPEN THEN BEGIN                                            !KDC
2469: 2c29:         CLOSE SLPCF.SESS.NUM%                                           !KDC
2470: 2c3d:         CALL SESS.NUM.UTILITY ("C",SLPCF.SESS.NUM%,XBACK.NULL$)         !OJK
2471: 2c60:         SLPCF.OPEN = FALSE                                              !KDC
2472: 2c6e:     ENDIF                                                               !KDC
2473: 2c76: 
2474: 2c76:     IF RUN.ALLOWED$ = "NO" THEN  BEGIN                                  !URG
2475: 2c91:        STATUS.MSG$ = STATUS.TEXT.MSG$(15)                               !URG
2476: 2cb6:        GOSUB DISPLAY.STATUS.MSG                                         !URG
2477: 2cc8:        GOSUB LOG.STATUS.MSG                                             !URG
2478: 2cda:        GOSUB STOP.PROGRAM                                               !URG
2479: 2cec:     ENDIF                                                               !URG
2480: 2cf4: 
2481: 2cf4: 
2482: 2cf4:     !*******************************************************************!KDC
2483: 2cf4:     !then set the data we will build from - note that the array elements!KDC
2484: 2cf4:     !must match the sleeper settings (ie 1=Sunday) to work correctly    !KDC
2485: 2cf4:     !*******************************************************************!KDC
2486: 2cf4:  ! No need of below set of codes as we are not doing incrementals        !URG
2487: 2cf4:  ! anymore
2488: 2cf4: 
2489: 2cf4:  !   DIM CONSTANT.DAYS$(7)                                               !URG LDC
2490: 2cf4:  !    CONSTANT.COLON$ = ":"                                              !URG OJK
2491: 2cf4:  !   CONSTANT.DAYS$(1) = ":SUN"                                          !URG OJK
2492: 2cf4:  !   CONSTANT.DAYS$(2) = ":MON"                                          !URG OJK
2493: 2cf4:  !   CONSTANT.DAYS$(3) = ":TUE"                                          !URG OJK
2494: 2cf4:  !   CONSTANT.DAYS$(4) = ":WED"                                          !URG OJK
2495: 2cf4:  !   CONSTANT.DAYS$(5) = ":THU"                                          !URG OJK
2496: 2cf4:  !   CONSTANT.DAYS$(6) = ":FRI"                                          !URG OJK
2497: 2cf4:  !   CONSTANT.DAYS$(7) = ":SAT"                                          !URG OJK
2498: 2cf4: 
2499: 2cf4:     !*******************************************************************!KDC
2500: 2cf4:     !Build up the string with all the days, starting with the full      !KDC
2501: 2cf4:     !backup day so it can be matched to any-time to find the Full and   !KDC
2502: 2cf4:     !Incremental days adding the : prevents mismatching characters that !KDC
2503: 2cf4:     !might overlap. for example if Sunday is the full configured day the!KDC
2504: 2cf4:     ! string would be; ":SUN:MON:TUE:WED:THU:FRI:SAT"                   !KDC
2505: 2cf4:     !*******************************************************************!KDC
2506: 2cf4:  !   BACKUP.DAYS$ = CONSTANT.DAYS$(SLEEPER.DAY%)                         !URG LDC
2507: 2cf4: 
2508: 2cf4:  !   FULL.DAY$    = RIGHT$(CONSTANT.DAYS$(SLEEPER.DAY%),3)               !URG LDC
2509: 2cf4:                                                                          !URG KDC
2510: 2cf4:  !   FOR DAY.SINCE.FULL% = 2 TO 7                                        !URG KDC
2511: 2cf4:                                                                          !URG KDC
2512: 2cf4:  !       IF SLEEPER.DAY% = 7 THEN BEGIN              !if Saturday        !URG KDC
2513: 2cf4:  !           SLEEPER.DAY% = 1                        !set to Sunday      !URG KDC
2514: 2cf4:  !       ENDIF ELSE BEGIN                                                !URG KDC
2515: 2cf4:  !           SLEEPER.DAY% = SLEEPER.DAY% + 1         !next day           !URG KDC
2516: 2cf4:  !       ENDIF                                                           !URG KDC
2517: 2cf4:                                                                          !URG KDC
2518: 2cf4:  !       BACKUP.DAYS$ = BACKUP.DAYS$ + CONSTANT.DAYS$(SLEEPER.DAY%)      !URG LDC
2519: 2cf4:                                                                          !URG KDC
2520: 2cf4:  !   NEXT DAY.SINCE.FULL%                                                !URG KDC
2521: 2cf4:                                                                          !URG KDC
2522: 2cf4:  !   DIM CONSTANT.DAYS$(0)                                               !URG LDC
2523: 2cf4:                                                                          !URG KDC
2524: 2cf4: SLPCF.NOT.FOUND:
2525: 2d04:     SLPCF.OPEN = FALSE
2526: 2d12: 
2527: 2d12: RETURN                                                                  !KDC
2528: 2d22: 
2529: 2d22: \***********************************************************************
2530: 2d22: \*
2531: 2d22: \*    ALLOCATE.SESSION.NUMBERS: This Sub-routine uses variables of FILE
2532: 2d22: \*                              functions and calls SESS.NUM.UTILITY to
2533: 2d22: \*                              allocate session numbers.
2534: 2d22: \*
2535: 2d22: \***********************************************************************
2536: 2d22: ALLOCATE.SESSION.NUMBERS:
2537: 2d32: 
2538: 2d32:     STATUS.MSG$ = STATUS.TEXT.MSG$(10)                                  !KDC
2539: 2d57:     GOSUB DISPLAY.STATUS.MSG
2540: 2d69: 
2541: 2d69:     FUNC.FLAG$ = "O"   ! Setting the file operation to Open
2542: 2d7e: 
2543: 2d7e:     ! ADXHSIUF FTP file                                                 !KDC
2544: 2d7e:     PASSED.INTEGER% = HSIUF.REPORT.NUM%                                 !KDC
2545: 2d90:     PASSED.STRING$  = HSIUF.FILE.NAME$                                  !KDC
2546: 2dac:     GOSUB GET.SESSION.NUMBER                                            !KDC
2547: 2dbe:     HSIUF.SESS.NUM% = F20.INTEGER.FILE.NO%                              !KDC
2548: 2dd4: 
2549: 2dd4:     ! BKPEXCL
2550: 2dd4:     PASSED.INTEGER% = BKPEXCL.REPORT.NUM%
2551: 2de2:     PASSED.STRING$  = BKPEXCL.FILE.NAME$
2552: 2dfb:     GOSUB GET.SESSION.NUMBER                                            !KDC
2553: 2e0d:     BKPEXCL.SESS.NUM%  = F20.INTEGER.FILE.NO%
2554: 2e1f: 
2555: 2e1f:     ! BKPFAILC                                                          !OJK
2556: 2e1f:     PASSED.INTEGER% = BKPFAILC.REPORT.NUM%                              !OJK
2557: 2e2d:     PASSED.STRING$  = BKPFAILC.FILE.NAME$                               !OJK
2558: 2e46:     GOSUB GET.SESSION.NUMBER                                            !KDC
2559: 2e58:     BKPFAILC.SESS.NUM% = F20.INTEGER.FILE.NO%                           !OJK
2560: 2e6a: 
2561: 2e6a:     ! BKPFAILD                                                          !OJK
2562: 2e6a:     PASSED.INTEGER% = BKPFAILD.REPORT.NUM%                              !OJK
2563: 2e78:     PASSED.STRING$  = BKPFAILD.FILE.NAME$                               !OJK
2564: 2e91:     GOSUB GET.SESSION.NUMBER                                            !OJK
2565: 2ea3:     BKPFAILD.SESS.NUM% = F20.INTEGER.FILE.NO%                           !OJK
2566: 2eb5: 
2567: 2eb5:     ! BKPLIST session allocation
2568: 2eb5:     PASSED.INTEGER% = BKPLI.REPORT.NUM%
2569: 2ec7:     PASSED.STRING$  = BKPLI.FILE.NAME$
2570: 2ee3:     GOSUB GET.SESSION.NUMBER                                            !KDC
2571: 2ef5:     BKPLI.SESS.NUM% = F20.INTEGER.FILE.NO%
2572: 2f0b: 
2573: 2f0b:     ! BKPSCRPT session allocation
2574: 2f0b:     PASSED.INTEGER% = BKPSCRPT.REPORT.NUM%
2575: 2f19:     PASSED.STRING$  = BKPSCRPT.FILE.NAME$
2576: 2f32:     GOSUB GET.SESSION.NUMBER                                            !KDC
2577: 2f44:     BKPSCRPT.SESS.NUM% = F20.INTEGER.FILE.NO%
2578: 2f56: 
2579: 2f56:     ! Sleeper Control file                                              !KDC
2580: 2f56:     PASSED.INTEGER% = SLPCF.REPORT.NUM%                                 !KDC
2581: 2f68:     PASSED.STRING$  = SLPCF.FILE.NAME$                                  !OJK
2582: 2f84:     GOSUB GET.SESSION.NUMBER                                            !KDC
2583: 2f96:     SLPCF.SESS.NUM% = F20.INTEGER.FILE.NO%                              !KDC
2584: 2fac: 
2585: 2fac:     ! Temporary file
2586: 2fac:     PASSED.INTEGER% = TEMP.REPORT.NUM%
2587: 2fba:     PASSED.STRING$  = TEMP.FILE.NAME$
2588: 2fd3:     GOSUB GET.SESSION.NUMBER                                            !KDC
2589: 2fe5:     TEMP.SESS.NUM%  = F20.INTEGER.FILE.NO%
2590: 2ff7: 
2591: 2ff7:     ! Temporary file
2592: 2ff7:     PASSED.INTEGER% = TEMP.REPORT.NUM.2%
2593: 3005:     PASSED.STRING$  = TEMP.FILE.NAME$
2594: 301e:     GOSUB GET.SESSION.NUMBER                                            !KDC
2595: 3030:     TEMP.SESS.NUM.2% = F20.INTEGER.FILE.NO%
2596: 3042: 
2597: 3042:     ! XBACKUP log
2598: 3042:     PASSED.INTEGER% = XBACK.LOG.REPORT.NUM%
2599: 3050:     PASSED.STRING$  = XBACK.LOG.LIVE.PATH$
2600: 3069:     GOSUB GET.SESSION.NUMBER                                            !KDC
2601: 307b:     XBACK.LOG.SESS.NUM%  = F20.INTEGER.FILE.NO%
2602: 308d: 
2603: 308d:     ! XBACKUP pipe
2604: 308d:     PASSED.INTEGER% = XBACK.PIPE.REPORT.NUM%
2605: 309b:     PASSED.STRING$  = XBACK.PIPE.NAME$
2606: 30b4:     GOSUB GET.SESSION.NUMBER                                            !KDC
2607: 30c6:     XBACK.PIPE.SESS.NUM% = F20.INTEGER.FILE.NO%
2608: 30d8: 
2609: 30d8:     ! XBKOK session allocation
2610: 30d8:     PASSED.INTEGER% = XBKOK.REPORT.NUM%
2611: 30ea:     PASSED.STRING$  = XBKOK.FILE.NAME$
2612: 3106:     GOSUB GET.SESSION.NUMBER                                            !KDC
2613: 3118:     XBKOK.SESS.NUM% = F20.INTEGER.FILE.NO%
2614: 312e: 
2615: 312e: RETURN
2616: 313e: 
2617: 313e: \***********************************************************************
2618: 313e: \*
2619: 313e: \*    GET.SESSION.NUMBER: This Sub-routine calls SESS.NUM.UTILITY to
2620: 313e: \*                        allocate session numbers.
2621: 313e: \*
2622: 313e: \***********************************************************************
2623: 313e: GET.SESSION.NUMBER:
2624: 314e: 
2625: 314e:     RETURN.VALUE.CHECK% = SESS.NUM.UTILITY (FUNC.FLAG$,  \              !KDC
2626: 3179:                                         PASSED.INTEGER%, \              !KDC
2627: 3179:                                         PASSED.STRING$)                 !KDC
2628: 3179:     GOSUB RETURN.VALUE.CHECK                                            !KDC
2629: 318b: 
2630: 318b: RETURN
2631: 319b: 
2632: 319b: \***********************************************************************
2633: 319b: \*
2634: 319b: \*      GET.DAY.AND.CHECK.ERROR:This Sub-routine calls PSDATE to get
2635: 319b: \*                              a day of the week.
2636: 319b: \*
2637: 319b: \***********************************************************************
2638: 319b: GET.DAY.AND.CHECK.ERROR:
2639: 31ab: 
2640: 31ab:     RETURN.VALUE.CHECK% = PSDATE(PSDATE.DATE$)
2641: 31ca: 
2642: 31ca:     ! Checking the return value
2643: 31ca:     GOSUB CHECK.PSDATE.RC
2644: 31dc: 
2645: 31dc: RETURN
2646: 31ec: 
2647: 31ec: \***********************************************************************
2648: 31ec: \*
2649: 31ec: \*    CREATE.RUN.PIPE: This Sub-routine creates pipe for current module
2650: 31ec: \*                     to avoid any duplicate run.
2651: 31ec: \*
2652: 31ec: \***********************************************************************
2653: 31ec: CREATE.RUN.PIPE:
2654: 31fc: 
2655: 31fc:     STATUS.MSG$ = STATUS.TEXT.MSG$(11)                                  !KDC
2656: 3221:     GOSUB DISPLAY.STATUS.MSG
2657: 3233: 
2658: 3233:     CREATE XBACK.PIPE.NAME$ AS XBACK.PIPE.SESS.NUM% BUFFSIZE XBACK.ZERO%
2659: 3257:     WAIT ; 1000     ! Allow a second for pipe to be created
2660: 326e: 
2661: 326e:     XBACK.OPEN = TRUE
2662: 327c: 
2663: 327c: RETURN
2664: 328c: 
2665: 328c: \***********************************************************************
2666: 328c: \*
2667: 328c: \*    CHECK.BKP.DIRECTORIES: This Subroutine verifies the existence of
2668: 328c: \*                           backup directories. If any of the
2669: 328c: \*                           directory is missing, then respective
2670: 328c: \*                           directories will be created.
2671: 328c: \*
2672: 328c: \***********************************************************************
2673: 328c: CHECK.BKP.DIRECTORIES:
2674: 329c: 
2675: 329c:     STATUS.MSG$ = STATUS.TEXT.MSG$(12)                                  !KDC
2676: 32c1:     GOSUB DISPLAY.STATUS.MSG
2677: 32d3: 
2678: 32d3:     !----------------------------!
2679: 32d3:     ! If Master controller is CE !
2680: 32d3:     !----------------------------!
2681: 32d3:     IF MASTER$ = CE.CNTR$ THEN BEGIN
2682: 32f5: 
2683: 32f5:         ! first check drives are available before doing any more
2684: 32f5: 
2685: 32f5:         ! Checking directory presence and verifying listing error
2686: 32f5:         DRIVE$ = "ADXLXCEN::C:/"
2687: 330a:         GOSUB DOES.BACKUP.DIR.EXIST
2688: 331c:         IF NOT BACKUP.DIR.EXIST THEN BEGIN
2689: 332b:             BACKUP.DIR.EXIST = 1
2690: 3338:             STATUS.MSG$ = STATUS.TEXT.ERROR$(8)
2691: 335d:             GOSUB PROGRAM.EXIT
2692: 336f:         ENDIF
2693: 3377: 
2694: 3377:         ! now build each directory as needed
2695: 3377:         IF NOT IMG.EXISTS THEN BEGIN                                    !CJK
2696: 3386:             ! Create directory If not present
2697: 3386:             CALL OSSHELL("MKDIR ADXLXCEN::C:\XDISKIMG")                 !KDC
2698: 339a:             STATUS.MSG$ = CE.C.XDISKIMG$+ STATUS.TEXT.MSG$(13)          !KDC
2699: 33ca:             GOSUB DISPLAY.STATUS.MSG
2700: 33dc:         ENDIF
2701: 33e4: 
2702: 33e4:         IF NOT ALT.EXISTS THEN BEGIN                                    !CJK
2703: 33f3:             ! Create directory If not present
2704: 33f3:             CALL OSSHELL("MKDIR ADXLXCEN::C:\XDISKALT")                 !KDC
2705: 3407:             STATUS.MSG$ =  CE.C.XDISKALT$ + STATUS.TEXT.MSG$(13)        !KDC
2706: 3437:             GOSUB DISPLAY.STATUS.MSG
2707: 3449:         ENDIF
2708: 3451: 
2709: 3451:         IF NOT TMP.EXISTS THEN BEGIN                                    !CJK
2710: 3460:             ! Create directory If not present
2711: 3460:             CALL OSSHELL("MKDIR ADXLXCEN::C:\TEMP")
2712: 3474:             STATUS.MSG$ = CE.NODE.NAME$ + TEMP.DIRECTORY.NAME$ + \      !KDC
2713: 34ac:                           STATUS.TEXT.MSG$(13)                          !KDC
2714: 34ac:             GOSUB DISPLAY.STATUS.MSG
2715: 34be:         ENDIF
2716: 34c6: 
2717: 34c6:         ! Checking directory presence and verifying listing error
2718: 34c6:         DRIVE$ = "ADXLXCEN::D:/"
2719: 34db:         GOSUB DOES.BACKUP.DIR.EXIST
2720: 34ed:         IF NOT BACKUP.DIR.EXIST THEN BEGIN
2721: 34fc:             BACKUP.DIR.EXIST = 1
2722: 3509:             STATUS.MSG$ = STATUS.TEXT.ERROR$(8)
2723: 352e:             GOSUB PROGRAM.EXIT
2724: 3540:         ENDIF
2725: 3548: 
2726: 3548:         IF NOT IMG.EXISTS THEN BEGIN                                    !CJK
2727: 3557:             ! Create directory If not present
2728: 3557:             CALL OSSHELL("MKDIR ADXLXCEN::D:\XDISKIMG")
2729: 356b:             STATUS.MSG$ = CE.D.XDISKIMG$ + STATUS.TEXT.MSG$(13)         !KDC
2730: 359b:             GOSUB DISPLAY.STATUS.MSG
2731: 35ad:         ENDIF
2732: 35b5: 
2733: 35b5:         IF NOT ALT.EXISTS THEN BEGIN                                    !CJK
2734: 35c4:             ! Create directory If not present
2735: 35c4:             CALL OSSHELL("MKDIR ADXLXCEN::D:\XDISKALT")
2736: 35d8:             STATUS.MSG$ = CE.D.XDISKALT$ + STATUS.TEXT.MSG$(13)         !KDC
2737: 3608:             GOSUB DISPLAY.STATUS.MSG
2738: 361a:         ENDIF
2739: 3622: 
2740: 3622:         !---------------------------------------------!
2741: 3622:         ! If Alternate controller is available in LAN !
2742: 3622:         !---------------------------------------------!
2743: 3622:         IF ALT.MASTER.ON THEN BEGIN
2744: 3634: 
2745: 3634:             ! first check drives are available before doing any more
2746: 3634: 
2747: 3634:             ! Checking directory presence and verifying listing error
2748: 3634:             DRIVE$ = "ADXLXCFN::C:/"
2749: 3649:             GOSUB DOES.BACKUP.DIR.EXIST
2750: 365b:             IF NOT BACKUP.DIR.EXIST THEN BEGIN
2751: 366a:                 BACKUP.DIR.EXIST = 1
2752: 3677:                 STATUS.MSG$ = STATUS.TEXT.ERROR$(8)
2753: 369c:                 GOSUB PROGRAM.EXIT
2754: 36ae:             ENDIF
2755: 36b6: 
2756: 36b6:             ! now build each directory as needed
2757: 36b6: 
2758: 36b6:             IF NOT IMG.EXISTS THEN BEGIN                                !CJK
2759: 36c5:                 ! Create directory If not present
2760: 36c5:                 CALL OSSHELL("MKDIR ADXLXCFN::C:\XDISKIMG")
2761: 36d9:                 STATUS.MSG$ = CF.C.XDISKIMG$ + STATUS.TEXT.MSG$(13)     !KDC
2762: 3709:                 GOSUB DISPLAY.STATUS.MSG
2763: 371b:             ENDIF
2764: 3723: 
2765: 3723:             IF NOT ALT.EXISTS THEN BEGIN                                !CJK
2766: 3732:                 ! Create directory If not present
2767: 3732:                 CALL OSSHELL("MKDIR ADXLXCFN::C:\XDISKALT")
2768: 3746:                 STATUS.MSG$ = CF.C.XDISKALT$ + STATUS.TEXT.MSG$(13)     !KDC
2769: 3776:                 GOSUB DISPLAY.STATUS.MSG
2770: 3788:             ENDIF
2771: 3790: 
2772: 3790:             ! Checking directory presence and verifying listing error
2773: 3790:             DRIVE$ = "ADXLXCFN::D:/"
2774: 37a5:             GOSUB DOES.BACKUP.DIR.EXIST
2775: 37b7:             IF NOT BACKUP.DIR.EXIST THEN BEGIN
2776: 37c6:                 BACKUP.DIR.EXIST = 1
2777: 37d3:                 STATUS.MSG$ = STATUS.TEXT.ERROR$(8)
2778: 37f8:                 GOSUB PROGRAM.EXIT
2779: 380a:             ENDIF
2780: 3812: 
2781: 3812:             IF NOT IMG.EXISTS THEN BEGIN                                !CJK
2782: 3821:                 ! Create directory If not present
2783: 3821:                 CALL OSSHELL("MKDIR ADXLXCFN::D:\XDISKIMG")
2784: 3835:                 STATUS.MSG$ = CF.D.XDISKIMG$ + STATUS.TEXT.MSG$(13)     !KDC
2785: 3865:                 GOSUB DISPLAY.STATUS.MSG
2786: 3877:             ENDIF
2787: 387f: 
2788: 387f:             IF NOT ALT.EXISTS THEN BEGIN                                !CJK
2789: 388e:                 ! Create directory If not present
2790: 388e:                 CALL OSSHELL("MKDIR ADXLXCFN::D:\XDISKALT")
2791: 38a2:                 STATUS.MSG$ = CF.D.XDISKALT$ + STATUS.TEXT.MSG$(13)     !KDC
2792: 38d2:                 GOSUB DISPLAY.STATUS.MSG
2793: 38e4:             ENDIF
2794: 38ec: 
2795: 38ec:         ENDIF
2796: 38f7:     ENDIF ELSE BEGIN
2797: 38ff: 
2798: 38ff:     !----------------------------!
2799: 38ff:     ! If Master controller is CF !
2800: 38ff:     !----------------------------!
2801: 38ff:         ! first check drives are available before doing any more
2802: 38ff: 
2803: 38ff:         ! Checking directory presence and verifying listing error
2804: 38ff:         DRIVE$ = "ADXLXCFN::C:/"
2805: 3914:         GOSUB DOES.BACKUP.DIR.EXIST
2806: 3926:         IF NOT BACKUP.DIR.EXIST THEN BEGIN
2807: 3935:             BACKUP.DIR.EXIST = 1
2808: 3942:             STATUS.MSG$ = STATUS.TEXT.ERROR$(8)
2809: 3967:             GOSUB PROGRAM.EXIT
2810: 3979:         ENDIF
2811: 3981: 
2812: 3981:         ! now build each directory as needed
2813: 3981: 
2814: 3981:         IF NOT IMG.EXISTS THEN BEGIN                                    !CJK
2815: 3990:             ! Create directory If not present
2816: 3990:             CALL OSSHELL("MKDIR ADXLXCFN::C:\XDISKIMG")
2817: 39a4:             STATUS.MSG$ = CF.C.XDISKIMG$ + STATUS.TEXT.MSG$(13)         !KDC
2818: 39d4:             GOSUB DISPLAY.STATUS.MSG
2819: 39e6:         ENDIF
2820: 39ee: 
2821: 39ee:         IF NOT ALT.EXISTS THEN BEGIN                                    !CJK
2822: 39fd:             ! Create directory If not present
2823: 39fd:             CALL OSSHELL("MKDIR ADXLXCFN::C:\XDISKALT")
2824: 3a11:             STATUS.MSG$ = CF.C.XDISKALT$ + STATUS.TEXT.MSG$(13)         !KDC
2825: 3a41:             GOSUB DISPLAY.STATUS.MSG
2826: 3a53:         ENDIF
2827: 3a5b: 
2828: 3a5b:         IF NOT TMP.EXISTS THEN BEGIN                                    !CJK
2829: 3a6a:             ! Create directory If not present
2830: 3a6a:             CALL OSSHELL("MKDIR ADXLXCFN::C:\TEMP")
2831: 3a7e:             STATUS.MSG$ = CF.NODE.NAME$ + TEMP.DIRECTORY.NAME$ + \      !KDC
2832: 3ab6:                           STATUS.TEXT.MSG$(13)                          !KDC
2833: 3ab6:             GOSUB DISPLAY.STATUS.MSG
2834: 3ac8:         ENDIF
2835: 3ad0: 
2836: 3ad0:         ! Checking directory presence and verifying listing error
2837: 3ad0:         DRIVE$ = "ADXLXCFN::D:/"
2838: 3ae5:         GOSUB DOES.BACKUP.DIR.EXIST
2839: 3af7:         IF NOT BACKUP.DIR.EXIST THEN BEGIN
2840: 3b06:             BACKUP.DIR.EXIST = 1
2841: 3b13:             STATUS.MSG$ = STATUS.TEXT.ERROR$(8)
2842: 3b38:             GOSUB PROGRAM.EXIT
2843: 3b4a:         ENDIF
2844: 3b52: 
2845: 3b52:         IF NOT IMG.EXISTS THEN BEGIN                                    !CJK
2846: 3b61:             ! Create directory If not present
2847: 3b61:             CALL OSSHELL("MKDIR ADXLXCFN::D:\XDISKIMG")
2848: 3b75:             STATUS.MSG$ = CF.D.XDISKIMG$ + STATUS.TEXT.MSG$(13)         !KDC
2849: 3ba5:             GOSUB DISPLAY.STATUS.MSG
2850: 3bb7:         ENDIF
2851: 3bbf: 
2852: 3bbf:         IF NOT ALT.EXISTS THEN BEGIN                                    !CJK
2853: 3bce:             CALL OSSHELL("MKDIR ADXLXCFN::D:\XDISKALT")
2854: 3be2:             STATUS.MSG$ = CF.D.XDISKALT$ + STATUS.TEXT.MSG$(13)         !KDC
2855: 3c12:             GOSUB DISPLAY.STATUS.MSG
2856: 3c24:         ENDIF
2857: 3c2c:     ENDIF
2858: 3c34: RETURN
2859: 3c44: 
2860: 3c44: \***********************************************************************
2861: 3c44: \*
2862: 3c44: \*    DOES.BACKUP.DIR.EXIST: This function verifies the existence of
2863: 3c44: \*                           backup directories.
2864: 3c44: \*
2865: 3c44: \***********************************************************************
2866: 3c44: DOES.BACKUP.DIR.EXIST:
2867: 3c54: 
2868: 3c54:     ! flag to capture error against this subroutine only
2869: 3c54:     BACKUP.DIR.EXIST = 2
2870: 3c61: 
2871: 3c61:     ! Directory list details
2872: 3c61:     CALL OSSHELL("DIR -T " + DRIVE$ + " > " + DIR.OUT$               + \
2873: 3ca0:                  " >>* " + DIR.OUT$  )
2874: 3ca0: 
2875: 3ca0:     IF END # TEMP.SESS.NUM% THEN ERROR.LISTING.DIRECTORY
2876: 3cb9:     OPEN DIR.OUT$ AS TEMP.SESS.NUM%
2877: 3cda: 
2878: 3cda:     ! Setting the temporary file open
2879: 3cda:     TEMP.OPEN = TRUE                                                    !FJK
2880: 3ce8: 
2881: 3ce8:     ! Ignoring the first 4 lines
2882: 3ce8:     READ # TEMP.SESS.NUM%; LINE DIR.VALUE$
2883: 3d04:     READ # TEMP.SESS.NUM%; LINE DIR.VALUE$
2884: 3d20:     READ # TEMP.SESS.NUM%; LINE DIR.VALUE$
2885: 3d3c:     READ # TEMP.SESS.NUM%; LINE DIR.VALUE$
2886: 3d58: 
2887: 3d58:     ALT.EXISTS   = FALSE
2888: 3d66:     IMG.EXISTS   = FALSE
2889: 3d74:     TMP.EXISTS   = FALSE
2890: 3d82:     VALUE.EXISTS = TRUE
2891: 3d90: 
2892: 3d90:     WHILE VALUE.EXISTS
2893: 3d9b:         READ # TEMP.SESS.NUM%; LINE DIR.VALUE$
2894: 3db7: 
2895: 3db7:         ! Match found
2896: 3db7:         IF MATCH("XDISKIMG     <DIR>", DIR.VALUE$, 1) <> XBACK.ZERO% \
2897: 3dde:         THEN BEGIN
2898: 3dde:             IMG.EXISTS = TRUE
2899: 3def:         ENDIF ELSE BEGIN
2900: 3df7:             ! Match found
2901: 3df7:             IF MATCH("XDISKALT     <DIR>", DIR.VALUE$, 1) \
2902: 3e1e:             <> XBACK.ZERO% THEN BEGIN
2903: 3e1e:                 ALT.EXISTS = TRUE
2904: 3e2e:             ENDIF ELSE BEGIN
2905: 3e36:                 ! Match found
2906: 3e36:                 IF MATCH("TEMP         <DIR>", DIR.VALUE$, 1) \
2907: 3e5d:                 <> XBACK.ZERO% THEN BEGIN
2908: 3e5d:                     TMP.EXISTS = TRUE
2909: 3e6b:                 ENDIF
2910: 3e73:             ENDIF
2911: 3e7b:         ENDIF
2912: 3e83: 
2913: 3e83:         ! EOF reached
2914: 3e83:         IF LEN(DIR.VALUE$) = XBACK.ZERO% THEN BEGIN
2915: 3ea1:             VALUE.EXISTS = FALSE
2916: 3eaf:         ENDIF
2917: 3eb7: 
2918: 3eb7:     WEND
2919: 3ec9: 
2920: 3ec9:     ! Deleting the file as no longer needed
2921: 3ec9:     DELETE TEMP.SESS.NUM%
2922: 3eda:     ! Setting the temporary file close
2923: 3eda:     TEMP.OPEN = FALSE                                                   !FJK
2924: 3ee8: 
2925: 3ee8:     BACKUP.DIR.EXIST = 1
2926: 3ef5: 
2927: 3ef5:  BACKUP.DIR.EXIST.EXIT:                                                 !OJK
2928: 3f05: 
2929: 3f05: RETURN
2930: 3f15: 
2931: 3f15: ! if end error handling
2932: 3f15: ERROR.LISTING.DIRECTORY:
2933: 3f25: 
2934: 3f25:     STATUS.MSG$ = STATUS.TEXT.ERROR$(1)                                 !KDC
2935: 3f4a:     BACKUP.DIR.EXIST = FALSE    ! Error occurred
2936: 3f58: 
2937: 3f58: RETURN
2938: 3f68: 
2939: 3f68: 
2940: 3f68: \***********************************************************************
2941: 3f68: \*
2942: 3f68: \*    CREATE.XBACKUP.LOG: This Subroutine verifies the existence of
2943: 3f68: \*                        LOG file. If present, delete the log file
2944: 3f68: \*                        and create a new one.
2945: 3f68: \*
2946: 3f68: \***********************************************************************
2947: 3f68: CREATE.XBACKUP.LOG:
2948: 3f78: 
2949: 3f78:     CURRENT.REPORT.NUM% = XBACK.LOG.REPORT.NUM%
2950: 3f8a: 
2951: 3f8a:     !---------------------------------------!
2952: 3f8a:     ! Checking the Existence of XBACKUP log !
2953: 3f8a:     !---------------------------------------!
2954: 3f8a: 
2955: 3f8a:     FILE.OPERATION$ = "O"                                               !CJK
2956: 3fa1: 
2957: 3fa1:     IF END # XBACK.LOG.SESS.NUM% THEN XBACK.LOG.NOT.PRESENT             !CJK
2958: 3fba:     OPEN XBACK.LOG.LIVE.PATH$ AS XBACK.LOG.SESS.NUM%
2959: 3fdb:     XBACK.LOG.OPEN = TRUE                                               !HDC
2960: 3fe9: 
2961: 3fe9:     DELETE XBACK.LOG.SESS.NUM%
2962: 3ffa:     XBACK.LOG.OPEN = FALSE                                              !HDC
2963: 4008:     STATUS.MSG$ = STATUS.TEXT.MSG$(23)                                  !HDC
2964: 402d:     GOSUB DISPLAY.STATUS.MSG
2965: 403f: 
2966: 403f: XBACK.LOG.NOT.PRESENT:                                                  !CJK
2967: 404f: 
2968: 404f:     FILE.OPERATION$ = "C"               ! File Create
2969: 4066: 
2970: 4066:     ! File error will be captured in ERROR.DETECTED                     !CJK
2971: 4066:     CREATE POSFILE XBACK.LOG.LIVE.PATH$ AS XBACK.LOG.SESS.NUM%         \
2972: 4086:                                                 UNLOCKED LOCAL
2973: 4086: 
2974: 4086:     XBACK.LOG.OPEN = TRUE
2975: 4094:     STATUS.MSG$ = STATUS.TEXT.MSG$(24)                                  !HDC
2976: 40b9:     GOSUB LOG.STATUS.MSG
2977: 40cb: 
2978: 40cb:     STATUS.MSG$ = STATUS.TEXT.MSG$(25)                                  !HDC
2979: 40f0:     GOSUB DISPLAY.STATUS.MSG
2980: 4102: 
2981: 4102: RETURN
2982: 4112: 
2983: 4112: \***********************************************************************
2984: 4112: \*
2985: 4112: \*    PROG.RUN.MODE: This Subroutine reads the BKPSCRPT file and stores
2986: 4112: \*                   the Start time and Days to keep in a variable. It
2987: 4112: \*                   also defines the backup file extension.
2988: 4112: \*                   Then it validates the parameter. If it's a
2989: 4112: \*                   SLEEPER run, respective Subroutine will be
2990: 4112: \*                   processed. Else "Command Mode" Subroutine will
2991: 4112: \*                   be processed.
2992: 4112: \*
2993: 4112: \***********************************************************************
2994: 4112: PROG.RUN.MODE:
2995: 4122: 
2996: 4122:     IF MASTER$ = CE.CNTR$ THEN BEGIN
2997: 4141:         STATUS.MSG$ = STATUS.TEXT.MSG$(26)                              !KDC
2998: 4168:     ENDIF ELSE BEGIN
2999: 4170:         STATUS.MSG$ = STATUS.TEXT.MSG$(27)                              !KDC
3000: 4195:     ENDIF
3001: 419d:     GOSUB LOG.STATUS.MSG
3002: 41af: 
3003: 41af:     CURRENT.REPORT.NUM% = BKPSCRPT.REPORT.NUM%
3004: 41c1:     FILE.OPERATION$ = "O"                                               !CJK
3005: 41d8: 
3006: 41d8:     !-------------------------!
3007: 41d8:     ! Open Backup script file !
3008: 41d8:     !-------------------------!
3009: 41d8:     IF END # BKPSCRPT.SESS.NUM% THEN BKPSCRPT.OPEN.ERROR
3010: 41f1:     OPEN BKPSCRPT.FILE.NAME$ AS BKPSCRPT.SESS.NUM%
3011: 4212:     BKPSCRPT.OPEN = TRUE
3012: 4220:     VALUE.EXISTS = TRUE
3013: 422e: 
3014: 422e:     IF END # BKPSCRPT.SESS.NUM% THEN BKPSCRPT.READ.ERROR
3015: 4247:     !----------------------------------------------!
3016: 4247:     ! Extracting Time range and Days to Keep value !
3017: 4247:     !----------------------------------------------!
3018: 4247:     WHILE VALUE.EXISTS
3019: 4252:         READ # BKPSCRPT.SESS.NUM%; LINE BKPSCRPT.VALUE$
3020: 426e:         ! Finding comma position
3021: 426e:         COMMA.POSITION% = MATCH(COMMA.VALUE$, BKPSCRPT.VALUE$, 1)
3022: 4290: 
3023: 4290:         !--------------------------------------!
3024: 4290:         ! If comma present in the string value !
3025: 4290:         !--------------------------------------!
3026: 4290:         IF COMMA.POSITION% <> XBACK.ZERO% THEN BEGIN
3027: 42a4:             ! Storing the comma separated value
3028: 42a4:             BKPSCRPT.COMMAND$ = LEFT$(BKPSCRPT.VALUE$,                 \
3029: 42cb:                                      (COMMA.POSITION% - 1) )
3030: 42cb:             CALL TRIM(BKPSCRPT.COMMAND$)
3031: 42df: 
3032: 42df:             ! Remaining comma separated value
3033: 42df:             BKPSCRPT.VALUE$ = MID$(BKPSCRPT.VALUE$,                    \
3034: 4313:                                    (COMMA.POSITION% + 1),              \
3035: 4313:                                    LEN(BKPSCRPT.VALUE$)   )
3036: 4313: 
3037: 4313:             !----------------------------!
3038: 4313:             ! If command is "Time Range" !
3039: 4313:             !----------------------------!
3040: 4313:             IF BKPSCRPT.COMMAND$ = "TIME RANGE" THEN BEGIN
3041: 4331:                 ! Comma Position
3042: 4331:                 COMMA.POSITION% = MATCH(COMMA.VALUE$,BKPSCRPT.VALUE$,1) !OJK
3043: 4353:                 ! Extract start time
3044: 4353:                 BKPSCRPT.START.TIME$ = LEFT$(BKPSCRPT.VALUE$,          \
3045: 437a:                                              (COMMA.POSITION% - 1))
3046: 437a:                 CALL TRIM(BKPSCRPT.START.TIME$)
3047: 438e: 
3048: 438e:                 ! Remaining Backup script value                         !PJK
3049: 438e:                 BKPSCRPT.VALUE$ = MID$(BKPSCRPT.VALUE$,                \!PJK
3050: 43c2:                                        (COMMA.POSITION% + 1),          \!PJK
3051: 43c2:                                        LEN(BKPSCRPT.VALUE$)   )         !PJK
3052: 43c2:                 !---------------------------!                           !PJK
3053: 43c2:                 ! Extracting end time value !                           !PJK
3054: 43c2:                 !---------------------------!                           !PJK
3055: 43c2:                                                                         !PJK
3056: 43c2:                 CALL TRIM   (BKPSCRPT.VALUE$)                           !PJK
3057: 43d6:                 CALL RTRIMC (BKPSCRPT.VALUE$, ASC(","))                 !PJK
3058: 4407:                 CALL TRIM   (BKPSCRPT.VALUE$)                           !PJK
3059: 441b:                 ! Storing END TIME                                      !PJK
3060: 441b:                 BKPSCRPT.END.TIME$ = BKPSCRPT.VALUE$                    !PJK
3061: 4437: 
3062: 4437:             ENDIF ELSE BEGIN
3063: 443f:                 !------------------------------!
3064: 443f:                 ! If command is "Days to Keep" !
3065: 443f:                 !------------------------------!
3066: 443f:                 IF BKPSCRPT.COMMAND$ = "DAYS TO KEEP" THEN BEGIN
3067: 445a:                     ! Finding comma position
3068: 445a:                     COMMA.POSITION%        = MATCH(COMMA.VALUE$,       \
3069: 447c:                                                    BKPSCRPT.VALUE$,    \
3070: 447c:                                                     1               )
3071: 447c:                     ! Extract Days to Keep
3072: 447c:                     BKPSCRPT.DAYS.TO.KEEP$ = LEFT$(BKPSCRPT.VALUE$,    \
3073: 44a3:                                                    (COMMA.POSITION%    \
3074: 44a3:                                                                - 1) )
3075: 44a3:                     CALL TRIM(BKPSCRPT.DAYS.TO.KEEP$)
3076: 44b7:                     VALUE.EXISTS = FALSE
3077: 44c5:                 ENDIF
3078: 44cd:             ENDIF
3079: 44d5:         ENDIF
3080: 44dd:     WEND
3081: 44ef: 
3082: 44ef:     BKPSCRPT.ERROR = TRUE
3083: 44fd:     ! Checking START time                                               !PJK
3084: 44fd:     IF LEN(BKPSCRPT.START.TIME$) > 0 THEN BEGIN                         !LDC
3085: 4518:         IF NOT FUNC.IS.VALID.TIME(BKPSCRPT.START.TIME$) THEN BEGIN      !LDC
3086: 4533:             STATUS.MSG$ = STATUS.TEXT.ERROR$(9)                         !LDC
3087: 4558:             GOSUB PROGRAM.EXIT                                          !LDC
3088: 456a:         ENDIF                                                           !LDC
3089: 4572:     ENDIF                                                               !LDC
3090: 457a:     ! Checking END time                                                 !PJK
3091: 457a:     IF LEN(BKPSCRPT.END.TIME$) > 0 THEN BEGIN                           !PJK
3092: 4595:         IF NOT FUNC.IS.VALID.TIME(BKPSCRPT.END.TIME$) THEN BEGIN        !PJK
3093: 45b0:             STATUS.MSG$ = STATUS.TEXT.ERROR$(9)                         !PJK
3094: 45d5:             GOSUB PROGRAM.EXIT                                          !PJK
3095: 45e7:         ENDIF                                                           !PJK
3096: 45ef:     ENDIF                                                               !PJK
3097: 45f7:     ! Checking Days to Keep                                             !PJK
3098: 45f7:     IF VAL(BKPSCRPT.DAYS.TO.KEEP$) < XBACK.ZERO% THEN BEGIN             !KDC
3099: 4625:         STATUS.MSG$ = STATUS.TEXT.ERROR$(9)                             !KDC
3100: 464a:         GOSUB PROGRAM.EXIT                                              !KDC
3101: 465e:     ENDIF ELSE \                                                        !KDC
3102: 4666:     IF VAL(BKPSCRPT.DAYS.TO.KEEP$) = XBACK.ZERO% THEN BEGIN             !KDC
3103: 4694:         STATUS.MSG$ = STATUS.TEXT.ERROR$(58)                            !KDC
3104: 46b9:         GOSUB PROGRAM.EXIT                                              !KDC
3105: 46cb:     ENDIF                                                               !KDC
3106: 46d3: 
3107: 46d3:     BKPSCRPT.ERROR = FALSE
3108: 46e1: 
3109: 46e1:     !-----------------------------------------------------------!
3110: 46e1:     ! Navigating the program according to the command parameter !
3111: 46e1:     !-----------------------------------------------------------!
3112: 46e1:     IF LEN(COMMAND.STRING$) = 1                   OR \ Command length 1 !RJK
3113: 4752:        MATCH(PARM.ONS$, COMMAND.STRING$,8)  <> 0  OR \ OR Re-run        !RJK
3114: 4752:        MATCH(PARM.BACKGRND$, COMMAND.STRING$,1) <> 0 THEN BEGIN         !RJK
3115: 4752:         GOSUB COMMAND.MODE.OR.ONS.RUN                                   !KDC
3116: 4766:     ENDIF ELSE BEGIN
3117: 476e:         GOSUB PROG.SLEEPER.RUN                                          !KDC
3118: 4780:     ENDIF
3119: 4788: 
3120: 4788: 
3121: 4788: RETURN
3122: 4798: 
3123: 4798: BKPSCRPT.OPEN.ERROR:
3124: 47a8:     STATUS.MSG$ = STATUS.TEXT.ERROR$(10)                                !KDC
3125: 47cd:     FILE.OPERATION$ = "O"                               ! File open
3126: 47e4:     GOSUB FILE.ERROR.EXIT
3127: 47f6: 
3128: 47f6: BKPSCRPT.READ.ERROR:
3129: 4806:     STATUS.MSG$ = STATUS.TEXT.ERROR$(11)                                !KDC
3130: 482b:     FILE.OPERATION$ = "R"                               ! File read
3131: 4842:     GOSUB FILE.ERROR.EXIT
3132: 4854: 
3133: 4854: RETURN
3134: 4864: 
3135: 4864: \***********************************************************************
3136: 4864: \*
3137: 4864: \*    PROG.SLEEPER.RUN:     This Subroutine checks for any current day
3138: 4864: \*                          zip files are present in XDISKIMG or
3139: 4864: \*                          XDISKALT. If files are available then
3140: 4864: \*                          program should end, logging an appropriate
3141: 4864: \*                          error.
3142: 4864: \*
3143: 4864: \***********************************************************************
3144: 4864: PROG.SLEEPER.RUN:
3145: 4874: 
3146: 4874:     STATUS.MSG$ = STATUS.TEXT.MSG$(28)                                  !KDC
3147: 4899:     GOSUB DISPLAY.STATUS.MSG                                            !KDC
3148: 48ab:     GOSUB LOG.STATUS.MSG                                                !KDC
3149: 48bd: 
3150: 48bd:     !----------------------------!
3151: 48bd:     ! If Master controller is CE !
3152: 48bd:     !----------------------------!
3153: 48bd:     IF MASTER$ = CE.CNTR$ THEN BEGIN
3154: 48df:         !------------------------------------!
3155: 48df:         ! Checking for current day ZIP files !
3156: 48df:         !------------------------------------!
3157: 48df:         CNTR.DIR$ = CE.C.XDISKIMG$
3158: 48f8:         GOSUB DOES.ZIP.FILE.EXISTS
3159: 490a:         FILE.CHECK.1% = ZIP.FILE.EXISTS
3160: 4918: 
3161: 4918:         CNTR.DIR$ = CE.D.XDISKIMG$
3162: 4931:         GOSUB DOES.ZIP.FILE.EXISTS
3163: 4943:         FILE.CHECK.2% = ZIP.FILE.EXISTS
3164: 4951: 
3165: 4951:         CNTR.DIR$ = CE.C.XDISKALT$
3166: 496a:         GOSUB DOES.ZIP.FILE.EXISTS
3167: 497c:         FILE.CHECK.3% = ZIP.FILE.EXISTS
3168: 498a: 
3169: 498a:         CNTR.DIR$ = CE.D.XDISKALT$
3170: 49a3:         GOSUB DOES.ZIP.FILE.EXISTS
3171: 49b5:         FILE.CHECK.4% = ZIP.FILE.EXISTS
3172: 49c3: 
3173: 49c3:         IF FILE.CHECK.1% OR FILE.CHECK.2% \
3174: 49dc:         OR FILE.CHECK.3% OR FILE.CHECK.4% \
3175: 49dc:         THEN BEGIN
3176: 49dc:             GOSUB PROGRAM.EXIT
3177: 49ee:         ENDIF
3178: 49f6: 
3179: 49f6:         !------------------------------------------!
3180: 49f6:         ! If Alternate controller available in LAN !
3181: 49f6:         !------------------------------------------!
3182: 49f6:         IF ALT.MASTER.ON THEN BEGIN
3183: 4a08:             !------------------------------------!
3184: 4a08:             ! Checking for current day ZIP files !
3185: 4a08:             !------------------------------------!
3186: 4a08:             CNTR.DIR$ = CF.C.XDISKIMG$
3187: 4a21:             GOSUB DOES.ZIP.FILE.EXISTS
3188: 4a33:             FILE.CHECK.1% = ZIP.FILE.EXISTS
3189: 4a41: 
3190: 4a41:             CNTR.DIR$ = CF.D.XDISKIMG$
3191: 4a5a:             GOSUB DOES.ZIP.FILE.EXISTS
3192: 4a6c:             FILE.CHECK.2% = ZIP.FILE.EXISTS
3193: 4a7a: 
3194: 4a7a:             CNTR.DIR$ = CF.C.XDISKALT$
3195: 4a93:             GOSUB DOES.ZIP.FILE.EXISTS
3196: 4aa5:             FILE.CHECK.3% = ZIP.FILE.EXISTS
3197: 4ab3: 
3198: 4ab3:             CNTR.DIR$ = CF.D.XDISKALT$
3199: 4acc:             GOSUB DOES.ZIP.FILE.EXISTS
3200: 4ade:             FILE.CHECK.4% = ZIP.FILE.EXISTS
3201: 4aec: 
3202: 4aec:             IF FILE.CHECK.1% OR FILE.CHECK.2% \
3203: 4b05:             OR FILE.CHECK.3% OR FILE.CHECK.4% \
3204: 4b05:             THEN BEGIN
3205: 4b05:                 GOSUB PROGRAM.EXIT
3206: 4b17:             ENDIF
3207: 4b1f:         ENDIF
3208: 4b2a:     ENDIF ELSE BEGIN
3209: 4b32: 
3210: 4b32:     !----------------------------!
3211: 4b32:     ! If Master controller is CF !
3212: 4b32:     !----------------------------!
3213: 4b32:         !------------------------------------!
3214: 4b32:         ! Checking for current day ZIP files !
3215: 4b32:         !------------------------------------!
3216: 4b32:         CNTR.DIR$ = CF.C.XDISKIMG$
3217: 4b4b:         GOSUB DOES.ZIP.FILE.EXISTS
3218: 4b5d:         FILE.CHECK.1% = ZIP.FILE.EXISTS
3219: 4b6b: 
3220: 4b6b:         CNTR.DIR$ = CF.D.XDISKIMG$
3221: 4b84:         GOSUB DOES.ZIP.FILE.EXISTS
3222: 4b96:         FILE.CHECK.2% = ZIP.FILE.EXISTS
3223: 4ba4: 
3224: 4ba4:         CNTR.DIR$ = CF.C.XDISKALT$
3225: 4bbd:         GOSUB DOES.ZIP.FILE.EXISTS
3226: 4bcf:         FILE.CHECK.3% = ZIP.FILE.EXISTS
3227: 4bdd: 
3228: 4bdd:         CNTR.DIR$ = CF.D.XDISKALT$
3229: 4bf6:         GOSUB DOES.ZIP.FILE.EXISTS
3230: 4c08:         FILE.CHECK.4% = ZIP.FILE.EXISTS
3231: 4c16: 
3232: 4c16:         IF FILE.CHECK.1% OR FILE.CHECK.2% \
3233: 4c2f:         OR FILE.CHECK.3% OR FILE.CHECK.4% \
3234: 4c2f:         THEN BEGIN
3235: 4c2f:             GOSUB PROGRAM.EXIT
3236: 4c41:         ENDIF
3237: 4c49: 
3238: 4c49:     ENDIF
3239: 4c51: 
3240: 4c51: RETURN
3241: 4c61: 
3242: 4c61: \***********************************************************************
3243: 4c61: \*
3244: 4c61: \*    COMMAND.MODE.OR.ONS.RUN: This Subroutine does the action for
3245: 4c61: \*                             Command mode run or ONS re-run. It reads
3246: 4c61: \*                             the START TIME and END TIME from BKPSCRPT
3247: 4c61: \*                             and also deletes the current day files if
3248: 4c61: \*                             present.
3249: 4c61: \*
3250: 4c61: \***********************************************************************
3251: 4c61: COMMAND.MODE.OR.ONS.RUN:
3252: 4c71: 
3253: 4c71:     !-------------------------------------------!
3254: 4c71:     ! Defining the Process date and backup file !
3255: 4c71:     ! extension, using the Start and End time   !                       !PJK
3256: 4c71:     !-------------------------------------------!
3257: 4c71:     IF LEN(BKPSCRPT.START.TIME$) > 0 AND LEN(BKPSCRPT.END.TIME$) > 0 \  !PJK
3258: 4cb4:     THEN BEGIN                                                          !PJK
3259: 4cb4:         !-------------------------------------------------------!
3260: 4cb4:         ! Checking the current time with BKPSCRPT Start time to !
3261: 4cb4:         ! determine the processing day                          !
3262: 4cb4:         !-------------------------------------------------------!
3263: 4cb4:         ! calculate current time once for easy comparison               !KDC
3264: 4cb4:         CURR.HH%     = VAL(LEFT$(CURR.TIME$,2))                         !KDC
3265: 4cda:         CURR.MM%     = VAL(MID$(CURR.TIME$,3,2))                        !KDC
3266: 4d00:         ! calculate script time once for easy comparison                !KDC
3267: 4d00:         BKPSCRPT.HH% = VAL(LEFT$(BKPSCRPT.START.TIME$,2))               !KDC
3268: 4d26:         BKPSCRPT.MM% = VAL(RIGHT$(BKPSCRPT.START.TIME$,2))              !KDC
3269: 4d4a:         ! calculate script end time                                     !PJK
3270: 4d4a:         BKPSCRPT.END.HH% = VAL(LEFT$(BKPSCRPT.END.TIME$,2))             !PJK
3271: 4d70:         BKPSCRPT.END.MM% = VAL(RIGHT$(BKPSCRPT.END.TIME$,2))            !PJK
3272: 4d94:                                                                         !KDC
3273: 4d94:         !-------------------------------------------------------!       !KDC
3274: 4d94:         ! if not zero and after script time or a later hour     !       !KDC
3275: 4d94:         ! and before end time then make the next day            !       !PJK
3276: 4d94:         !-------------------------------------------------------!       !KDC
3277: 4d94:         IF ((CURR.HH% = BKPSCRPT.HH% AND CURR.MM% > = BKPSCRPT.MM%) \   !PJK
3278: 4deb:             OR CURR.HH% > BKPSCRPT.HH%  )                       AND \   !PJK
3279: 4deb:            ((CURR.HH% = BKPSCRPT.END.HH%   AND                      \   !PJK
3280: 4deb:             CURR.MM% <= BKPSCRPT.END.MM%)  OR                       \   !PJK
3281: 4deb:              CURR.HH% < BKPSCRPT.END.HH%)                 THEN BEGIN    !PJK
3282: 4deb: 
3283: 4deb:             F02.DATE$ = CURR.DATE$
3284: 4e06:             RETURN.VALUE.CHECK% = UPDATE.DATE( 1 )  ! Add one day       !KDC
3285: 4e25: 
3286: 4e25:             GOSUB CHECK.UPDATE.DATE.RC                                  !FJK
3287: 4e37: 
3288: 4e37:             CURR.DATE$ = F02.DATE$
3289: 4e53:         ENDIF
3290: 4e5b:     ENDIF                                                               !LDC
3291: 4e63:     !-----------------------------------!
3292: 4e63:     ! Defining the Extension name from  !
3293: 4e63:     ! date and month value              !
3294: 4e63:     !-----------------------------------!
3295: 4e63:     EXTENSION$ = RIGHT$(CURR.DATE$,4)       ! Extracting Month value    !KDC
3296: 4e83:     GOSUB GET.FILE.EXTENSION                                            !KDC
3297: 4e95:     EXT.MDD$ = EXTENSION$                                               !KDC
3298: 4eae: 
3299: 4eae:     !------------------------------------!
3300: 4eae:     ! Deleting the current day zip files !
3301: 4eae:     !------------------------------------!
3302: 4eae:     IF MASTER$ = CE.CNTR$ THEN BEGIN               ! If Master is CE
3303: 4ed0: 
3304: 4ed0:         CNTR.DIR$ = CE.C.XDISKIMG$
3305: 4ee9:         GOSUB DOES.ZIP.FILE.EXISTS
3306: 4efb:         IF ZIP.FILE.EXISTS THEN BEGIN
3307: 4f0a:             ! Deleting the current day files
3308: 4f0a:             CALL OSSHELL("DEL " + CE.C.XDISKIMG$ + "*." + EXT.MDD$)
3309: 4f3d:         ENDIF
3310: 4f45: 
3311: 4f45:         CNTR.DIR$ = CE.D.XDISKIMG$
3312: 4f5e:         GOSUB DOES.ZIP.FILE.EXISTS
3313: 4f70:         IF ZIP.FILE.EXISTS THEN BEGIN
3314: 4f7f:             ! Deleting the current day files
3315: 4f7f:             CALL OSSHELL("DEL " + CE.D.XDISKIMG$ + "*." + EXT.MDD$)
3316: 4fb2:         ENDIF
3317: 4fba: 
3318: 4fba:         CNTR.DIR$ = CE.C.XDISKALT$
3319: 4fd3:         GOSUB DOES.ZIP.FILE.EXISTS
3320: 4fe5:         IF ZIP.FILE.EXISTS THEN BEGIN
3321: 4ff4:             ! Deleting the current day files
3322: 4ff4:             CALL OSSHELL("DEL " + CE.C.XDISKALT$ + "*." + EXT.MDD$)
3323: 5027:         ENDIF
3324: 502f: 
3325: 502f:         CNTR.DIR$ = CE.D.XDISKALT$
3326: 5048:         GOSUB DOES.ZIP.FILE.EXISTS
3327: 505a:         IF ZIP.FILE.EXISTS THEN BEGIN
3328: 5069:             ! Deleting the current day files
3329: 5069:             CALL OSSHELL("DEL " + CE.D.XDISKALT$ + "*." + EXT.MDD$)
3330: 509c:         ENDIF
3331: 50a4: 
3332: 50a4:     ENDIF
3333: 50ac: 
3334: 50ac:     ! If Master is CF or Alternate controller available                 !DJK
3335: 50ac:     IF ALT.MASTER.ON OR MASTER$ = CF.CNTR$ THEN BEGIN                   !DJK
3336: 50e0: 
3337: 50e0:         CNTR.DIR$ = CF.C.XDISKIMG$
3338: 50f9:         GOSUB DOES.ZIP.FILE.EXISTS
3339: 510b:         IF ZIP.FILE.EXISTS THEN BEGIN
3340: 511a:             ! Deleting the current day files
3341: 511a:             CALL OSSHELL("DEL " + CF.C.XDISKIMG$ + "*." + EXT.MDD$)
3342: 514d:         ENDIF
3343: 5155: 
3344: 5155:         CNTR.DIR$ = CF.D.XDISKIMG$
3345: 516e:         GOSUB DOES.ZIP.FILE.EXISTS
3346: 5180:         IF ZIP.FILE.EXISTS THEN BEGIN
3347: 518f:             ! Deleting the current day files
3348: 518f:             CALL OSSHELL("DEL " + CF.D.XDISKIMG$ + "*." + EXT.MDD$)
3349: 51c2:         ENDIF
3350: 51ca: 
3351: 51ca:         CNTR.DIR$ = CF.C.XDISKALT$
3352: 51e3:         GOSUB DOES.ZIP.FILE.EXISTS
3353: 51f5:         IF ZIP.FILE.EXISTS THEN BEGIN
3354: 5204:             ! Deleting the current day files
3355: 5204:             CALL OSSHELL("DEL " + CF.C.XDISKALT$ + "*." + EXT.MDD$)
3356: 5237:         ENDIF
3357: 523f: 
3358: 523f:         CNTR.DIR$ = CF.D.XDISKALT$
3359: 5258:         GOSUB DOES.ZIP.FILE.EXISTS
3360: 526a:         IF ZIP.FILE.EXISTS THEN BEGIN
3361: 5279:             ! Deleting the current day files
3362: 5279:             CALL OSSHELL("DEL " + CF.D.XDISKALT$  + "*." + EXT.MDD$)
3363: 52ac:         ENDIF
3364: 52b4:     ENDIF
3365: 52bc: 
3366: 52bc: RETURN
3367: 52cc: 
3368: 52cc: \***********************************************************************
3369: 52cc: \*
3370: 52cc: \*    DOES.ZIP.FILE.EXISTS: This function checks the existence of
3371: 52cc: \*                          current day ZIP file.
3372: 52cc: \*
3373: 52cc: \***********************************************************************
3374: 52cc: DOES.ZIP.FILE.EXISTS:
3375: 52dc: 
3376: 52dc:     ! flag to indicate where we are processing
3377: 52dc:     ZIP.FILE.EXISTS = 2
3378: 52e9: 
3379: 52e9:     ! Extracting today's zip file details
3380: 52e9:     CALL OSSHELL("DIR " + CNTR.DIR$  + "*." + EXT.MDD$  + " > " + \
3381: 5334:                   DIR.OUT$ + " >>* " + DIR.OUT$ )
3382: 5334: 
3383: 5334:     IF END # TEMP.SESS.NUM% THEN ZIP.FILE.EXISTS.EXIT
3384: 534d:     OPEN DIR.OUT$ AS TEMP.SESS.NUM%
3385: 536e: 
3386: 536e:     ! Setting the temporary file open
3387: 536e:     TEMP.OPEN = TRUE
3388: 537c: 
3389: 537c:     ! Ignoring the first 4 lines
3390: 537c:     READ # TEMP.SESS.NUM%; LINE DIR.VALUE$
3391: 5398:     READ # TEMP.SESS.NUM%; LINE DIR.VALUE$
3392: 53b4:     READ # TEMP.SESS.NUM%; LINE DIR.VALUE$
3393: 53d0:     READ # TEMP.SESS.NUM%; LINE DIR.VALUE$
3394: 53ec: 
3395: 53ec:     ! Checking the file presence                                        !CJK
3396: 53ec:     READ # TEMP.SESS.NUM%; LINE DIR.VALUE$
3397: 5408:     ! default to false
3398: 5408:     ZIP.FILE.EXISTS = 0                                                 !KDC
3399: 5415:     IF LEN(DIR.VALUE$) <> XBACK.ZERO% THEN BEGIN
3400: 5433:         ZIP.FILE.EXISTS = TRUE
3401: 5441:         STATUS.MSG$ = STATUS.TEXT.MSG$(1)                               !KDC
3402: 5466:     ENDIF
3403: 546e: 
3404: 546e:     ! Deleting the file as no longer needed
3405: 546e:     DELETE TEMP.SESS.NUM%
3406: 547f: 
3407: 547f:     ! Setting the temporary file close
3408: 547f:     TEMP.OPEN = FALSE                                                   !FJK
3409: 548d: 
3410: 548d: RETURN
3411: 549d: 
3412: 549d: ZIP.FILE.EXISTS.EXIT:
3413: 54ad: 
3414: 54ad:     STATUS.MSG$ = STATUS.TEXT.ERROR$(2)                                 !KDC
3415: 54d2: !    ZIP.FILE.EXISTS = TRUE                                             !OJK
3416: 54d2: 
3417: 54d2: RETURN
3418: 54e2: 
3419: 54e2: 
3420: 54e2: \***********************************************************************
3421: 54e2: \*
3422: 54e2: \*    CREATE.FILES: This Subroutine Checks the file existence of
3423: 54e2: \*                  BKPEXCL.DAT. If file is present already delete it.
3424: 54e2: \*                  Then create the same files as a new one. Also
3425: 54e2: \*                  create BKPFAIL files in respective directory.       !OJK
3426: 54e2: \*
3427: 54e2: \***********************************************************************
3428: 54e2: CREATE.FILES:
3429: 54f2: 
3430: 54f2:     CURRENT.REPORT.NUM% = BKPEXCL.REPORT.NUM%
3431: 5504:     FILE.OPERATION$ = "O"                                               !CJK
3432: 551b: 
3433: 551b:     !-------------------------------------!
3434: 551b:     ! If BKPEXCL file exists, deleting it !
3435: 551b:     !-------------------------------------!
3436: 551b:     IF END # BKPEXCL.SESS.NUM% THEN BKPEXCL.NOT.PRESENT                 !CJK
3437: 5534:     OPEN BKPEXCL.FILE.NAME$ AS BKPEXCL.SESS.NUM%
3438: 5555:     BKPEXCL.OPEN = TRUE                                                 !HDC
3439: 5563: 
3440: 5563:     FILE.OPERATION$ = "D"                                               !CJK
3441: 557a:     
3442: 557a:     DELETE BKPEXCL.SESS.NUM%
3443: 558b:     BKPEXCL.OPEN = FALSE                                                !LDC
3444: 5599: 
3445: 5599:     STATUS.MSG$ = STATUS.TEXT.MSG$(29)                                  !KDC
3446: 55be:     GOSUB DISPLAY.STATUS.MSG
3447: 55d0:     GOSUB LOG.STATUS.MSG
3448: 55e2: 
3449: 55e2: BKPEXCL.NOT.PRESENT:                                                    !CJK
3450: 55f2: !    ! Commented out this flag as it is redundant                       !OJK
3451: 55f2: !    BKPEXCL.OPEN = FALSE                                               !OJK
3452: 55f2: 
3453: 55f2:     FILE.OPERATION$ = "C"               ! File Create
3454: 5609: 
3455: 5609:     ! File error will be captured in ERROR.DETECTED
3456: 5609:     CREATE POSFILE BKPEXCL.FILE.NAME$ AS BKPEXCL.SESS.NUM% \
3457: 5629:                                             UNLOCKED LOCAL
3458: 5629: 
3459: 5629:     BKPEXCL.OPEN = TRUE
3460: 5637: 
3461: 5637:     ! Setting BKPFAILC values for creating BKPFAILC file                !OJK
3462: 5637:     CURRENT.REPORT.NUM% = BKPFAILC.REPORT.NUM%                          !OJK
3463: 5649:     BKPFAILC.FILE.NAME$ = BKPFAILC.FILE.NAME$ + EXT.MDD$                !OJK
3464: 566d: 
3465: 566d:     ! File error will be captured in ERROR.DETECTED                     !OJK
3466: 566d:     CREATE POSFILE BKPFAILC.FILE.NAME$ AS BKPFAILC.SESS.NUM% \          !OJK
3467: 568d:                                                 UNLOCKED LOCAL          !OJK
3468: 568d: 
3469: 568d:     BKPFAILC.OPEN = TRUE                                                !OJK
3470: 569b: 
3471: 569b:     ! Setting BKPFAILD values for creating BKPFAILD file                !OJK
3472: 569b:     CURRENT.REPORT.NUM% = BKPFAILD.REPORT.NUM%                          !OJK
3473: 56ad:     BKPFAILD.FILE.NAME$ = BKPFAILD.FILE.NAME$ + EXT.MDD$                !OJK
3474: 56d1: 
3475: 56d1:     ! File error will be captured in ERROR.DETECTED
3476: 56d1:     CREATE POSFILE BKPFAILD.FILE.NAME$ AS BKPFAILD.SESS.NUM% \          !OJK
3477: 56f1:                                                 UNLOCKED LOCAL          !OJK
3478: 56f1: 
3479: 56f1:     BKPFAILD.OPEN = TRUE                                                !OJK
3480: 56ff: 
3481: 56ff:     STATUS.MSG$ = STATUS.TEXT.MSG$(30)                                  !KDC
3482: 5724:     GOSUB DISPLAY.STATUS.MSG
3483: 5736:     GOSUB LOG.STATUS.MSG
3484: 5748: 
3485: 5748: RETURN
3486: 5758: 
3487: 5758: \***********************************************************************
3488: 5758: \*
3489: 5758: \*    OPEN.AND.READ.XBKOK: Opens the XBKOK status-and-configuration file.
3490: 5758: \*                         The XBKOK should always exist and be readable
3491: 5758: \*                         so if missing or cannot be read an event 106
3492: 5758: \*                         is logged via the FILE.ERROR.EXIT routine.
3493: 5758: \*
3494: 5758: \***********************************************************************
3495: 5758: OPEN.AND.READ.XBKOK:
3496: 5768: 
3497: 5768:     FILE.OPERATION$     = "O"                       ! Open
3498: 577f:     CURRENT.REPORT.NUM% = XBKOK.REPORT.NUM%
3499: 5795: 
3500: 5795:     !*******************************************************************!KDC
3501: 5795:     !* set local error to handle missing OK file only                   !KDC
3502: 5795:     !* other errors will handle in the main ON ERROR                    !KDC
3503: 5795:     !*******************************************************************!KDC
3504: 5795:     IF END # XBKOK.SESS.NUM% THEN XBKOK.FILE.NOT.FOUND                  !KDC
3505: 57b1:     OPEN XBKOK.FILE.NAME$ DIRECT RECL XBKOK.RECL% AS XBKOK.SESS.NUM%    !KDC
3506: 57dd:     XBKOK.OPEN = TRUE                                                   !OJK
3507: 57eb:                                                                         !KDC
3508: 57eb:  XBKOK.FILE.OPEN.ERROR:                                                 !OJK
3509: 57fb:     !*******************************************************************!KDC
3510: 57fb:     !* check if file not open must be a create error                    !KDC
3511: 57fb:     !*******************************************************************!KDC
3512: 57fb:     IF NOT XBKOK.OPEN THEN BEGIN                                        !OJK
3513: 580d:         !***************************************************************!KDC
3514: 580d:         !* set to normal IF END error handling for files in case of     !KDC
3515: 580d:         !* other issues then create the OK file and set the write with  !KDC
3516: 580d:         !* starting record details                                      !KDC
3517: 580d:         !***************************************************************!KDC
3518: 580d:         IF END # XBKOK.SESS.NUM% THEN FILE.ERROR.EXIT                   !KDC
3519: 5829:         CREATE POSFILE XBKOK.FILE.NAME$ DIRECT 1 RECL XBKOK.RECL% AS \  !KDC
3520: 585a:                        XBKOK.SESS.NUM% MIRRORED PERUPDATE               !OJK
3521: 585a:         XBKOK.OPEN = TRUE                                               !LDC
3522: 5868:         STATUS.MSG$ = STATUS.TEXT.MSG$(31)                              !KDC
3523: 588d:         GOSUB DISPLAY.STATUS.MSG                                        !KDC
3524: 589f:         ! Assigning defaults                                            !KDC
3525: 589f:         XBKOK.START.DATE$ = DATE$                                       !KDC
3526: 58b7:         XBKOK.START.TIME$ = LEFT$(TIME$,4)                              !KDC
3527: 58e3:         XBKOK.STATUS$     = STATUS.START$                               !KDC
3528: 58fe:         XBKOK.TYPE$       = RUN.TYPE$                                   !KDC
3529: 591c:     ENDIF ELSE BEGIN                                                    !KDC
3530: 5924:         FILE.RC2%   = READ.XBKOK                                        !KDC
3531: 5938:         STATUS.MSG$ = STATUS.TEXT.ERROR$(12)                            !KDC
3532: 595d:         GOSUB CHECK.FILE.RC2                                            !KDC
3533: 596f:                                                                         !KDC
3534: 596f:         IF SIZE(XBKOK.FILE.NAME$) <> XBKOK.RECL% THEN BEGIN             !KDC
3535: 59a1:             FILE.OPERATION$ = "R"                       ! Read          !KDC
3536: 59b8:             STATUS.MSG$     = STATUS.TEXT.ERROR$(13)                    !KDC
3537: 59dd:             GOSUB FILE.ERROR.EXIT                                       !KDC
3538: 59ef:         ENDIF                                                           !KDC
3539: 59f7:     ENDIF                                                               !KDC
3540: 59ff: 
3541: 59ff:     STATUS.MSG$ = STATUS.TEXT.MSG$(32)                                  !KDC
3542: 5a24:     GOSUB DISPLAY.STATUS.MSG
3543: 5a36:     GOSUB LOG.STATUS.MSG
3544: 5a48: 
3545: 5a48:     XBKOK.INTERIM.STATUS$ = STATUS.START$                               !BJK
3546: 5a61: 
3547: 5a61:     ! Assigning the Start date and time                                 !BJK
3548: 5a61:     XBKOK.START.DATE$ = DATE$                                           !BJK
3549: 5a79:     XBKOK.START.TIME$ = LEFT$(TIME$,4)                                  !BJK
3550: 5aa5: 
3551: 5aa5: RETURN
3552: 5ab5: 
3553: 5ab5: \***********************************************************************!KDC
3554: 5ab5: \*                                                                      !KDC
3555: 5ab5: \*    XBKOK.FILE.NOT.FOUND: Displays a message and updates LOG and      !KDC
3556: 5ab5: \*                          logs the error in the normal way            !KDC
3557: 5ab5: \*                                                                      !KDC
3558: 5ab5: \***********************************************************************!KDC
3559: 5ab5: XBKOK.FILE.NOT.FOUND:                                                   !KDC
3560: 5ac5:     XBKOK.OPEN = FALSE                                                  !KDC
3561: 5ad3:     STATUS.MSG$ = STATUS.TEXT.ERROR$(14)                                !KDC
3562: 5af8:     GOSUB DISPLAY.STATUS.MSG                                            !KDC
3563: 5b0a:                                                                         !KDC
3564: 5b0a:     ! Logging event 106 for File error                                  !KDC
3565: 5b0a:     STATUS.MSG$ = STATUS.TEXT.ERROR$(44) + FILE.OPERATION$              !KDC
3566: 5b3d:     GOSUB DISPLAY.STATUS.MSG                                            !KDC
3567: 5b4f:     GOSUB LOG.STATUS.MSG                                                !KDC
3568: 5b61:                                                                         !KDC
3569: 5b61:     EVENT.NUMBER% = 106     ! Event 106                                 !KDC
3570: 5b6f:                                                                         !KDC
3571: 5b6f:     ! Application event log data                                        !KDC
3572: 5b6f:     VAR.STRING.1$ = FILE.OPERATION$                                  + \!KDC
3573: 5bce:                     CHR$(SHIFT(CURRENT.REPORT.NUM%,8))               + \!KDC
3574: 5bce:                     CHR$(SHIFT(CURRENT.REPORT.NUM%,XBACK.ZERO%))        !KDC
3575: 5bce:                                                                         !KDC
3576: 5bce:     GOSUB CALL.F01.APPLICATION.LOG                                      !KDC
3577: 5be0:     GOTO XBKOK.FILE.OPEN.ERROR                                          !KDC
3578: 5beb: 
3579: 5beb: \***********************************************************************
3580: 5beb: \*
3581: 5beb: \*    UPDATE.XBKOK: Calls WRITE.XBKOK to update the XBKOK.
3582: 5beb: \*                  Displays a message and updates LOG
3583: 5beb: \*
3584: 5beb: \***********************************************************************
3585: 5beb: UPDATE.XBKOK:
3586: 5bfb: 
3587: 5bfb:     IF NOT XBKOK.OPEN THEN BEGIN    ! If XBKOK not open                 !CJK
3588: 5c0a:         RETURN
3589: 5c1a:     ENDIF
3590: 5c22: 
3591: 5c22:     ! Assigning the Interim status and Backup type before update
3592: 5c22:     XBKOK.STATUS$ = XBKOK.INTERIM.STATUS$
3593: 5c3d:     XBKOK.TYPE$   = RUN.TYPE$                                           !DJK
3594: 5c58: 
3595: 5c58:     STATUS.MSG$ = STATUS.TEXT.ERROR$(15)                                !KDC
3596: 5c7d:     FILE.RC2%   = WRITE.XBKOK
3597: 5c91:     GOSUB CHECK.FILE.RC2
3598: 5ca3: 
3599: 5ca3:     ! Re-aligned the IF statements                                      !BJK
3600: 5ca3:     IF XBKOK.INTERIM.STATUS$ = STATUS.START$ THEN BEGIN                 !KDC
3601: 5cc2:         ! Started status
3602: 5cc2:         STATUS.MSG$ = STATUS.TEXT.MSG$(34)                              !KDC
3603: 5ce9:     ENDIF ELSE IF XBKOK.INTERIM.STATUS$ = STATUS.END$ THEN BEGIN
3604: 5d08:         ! Success status
3605: 5d08:         STATUS.MSG$ = STATUS.TEXT.MSG$(35)                              !KDC
3606: 5d2f:     ENDIF ELSE BEGIN
3607: 5d37:         ! Major error
3608: 5d37:         STATUS.MSG$ = STATUS.TEXT.ERROR$(16)                            !KDC
3609: 5d5c:     ENDIF
3610: 5d64: 
3611: 5d64:     GOSUB DISPLAY.STATUS.MSG
3612: 5d76:     GOSUB LOG.STATUS.MSG
3613: 5d88: 
3614: 5d88: RETURN
3615: 5d98: 
3616: 5d98:                 !   INITIALISATION SPECIFIC ROUTINES ENDS   !
3617: 5d98:                 !...........................................!
3618: 5d98: 
3619: 5d98: \**********************************************************************\
3620: 5d98: \**********************************************************************\
3621: 5d98: \*                                                                    *\
3622: 5d98: \*                 MAIN.PROCESSING SPECIFIC ROUTINES                  *\
3623: 5d98: \*                                                                    *\
3624: 5d98: \**********************************************************************\
3625: 5d98: \**********************************************************************\
3626: 5d98: 
3627: 5d98: \***********************************************************************
3628: 5d98: \*
3629: 5d98: \*    BKPLIST.FULL.CHECK: This Subroutine checks the day of the week.   !KDC
3630: 5d98: \*                        If matching Full day from configuration using !KDC
3631: 5d98: \*                        (Sleeper), create a new BKPLIST.MDD file. For !KDC
3632: 5d98: \*                        Non Full (Incremental) run, it also stores the!KDC
3633: 5d98: \*                        BKPLIST Line details into an array            !KDC
3634: 5d98: \*
3635: 5d98: \***********************************************************************
3636: 5d98: ! Below subroutine checks on the execution day based on that it does    !URG
3637: 5d98: ! appropriate actions.We dont need to maintain the BKPLIST file if we   !URG
3638: 5d98: ! are not doing the incremental backup.                                 !URG
3639: 5d98: 
3640: 5d98: ! BKPLIST.FULL.CHECK:                                                   !URG KDC
3641: 5d98: 
3642: 5d98:  ! Setting the success status
3643: 5d98:  !     XBKOK.INTERIM.STATUS$ = STATUS.END$                              !URG
3644: 5d98: 
3645: 5d98:  ! Getting the day using PSDATE function
3646: 5d98:  !    PSDATE.DATE$ = CURR.DATE$                                         !URG KDC
3647: 5d98:  !    CALL PSDATE(CURR.DATE$)                                           !URG
3648: 5d98:  ! Below piece of code is to copy the BKPLIST file on sunday to         !URG
3649: 5d98:  ! sunday basis, so that xrestore functionality is not affected         !URG
3650: 5d98: 
3651: 5d98:  !   IF F13.DAY$ = "SUN" THEN BEGIN                                     !URG
3652: 5d98:  !       GOSUB GET.DAY.AND.CHECK.ERROR                                  !KDC
3653: 5d98:  !       GOSUB DETERMINE.BKPLIST.EXT                                    !OJK
3654: 5d98:  !       BKPLI.FILE.NAME$ = BKPLI.FILE.NAME$ + EXT.MDD$                 !URG
3655: 5d98:  !       BKPLI.FILE.NEW$ = LEFT$(BKPLI.FILE.NAME$,20) + ORG.EXT$        !URG
3656: 5d98:  !       CALL ADXCOPYF(ADXSERVE.RC%,BKPLI.FILE.NEW$,            \       !URG
3657: 5d98:  !                 BKPLI.FILE.NAME$,0,0,0)                              !URG
3658: 5d98: 
3659: 5d98:  !   ENDIF                                                              !URG
3660: 5d98:  ! Code follows are commented as no need to read through BKPLIST file   !URG
3661: 5d98:  ! and sort to array, instead the last run of BKPLIST file will be      !URG
3662: 5d98:  ! Continued for ever for XRESTORE.                                     !URG
3663: 5d98: 
3664: 5d98:  !   IF F13.DAY$ = FULL.DAY$ THEN BEGIN             ! If Full           !URG KDC
3665: 5d98: 
3666: 5d98:         ! Setting FULL backup as this is the first run of the week      !DJK
3667: 5d98:  !       RUN.TYPE$ = "F"                                                !URG DJK
3668: 5d98: 
3669: 5d98:  !       FILE.OPERATION$     = "C"              ! File Create           !URG
3670: 5d98:  !       CURRENT.REPORT.NUM% = BKPLI.REPORT.NUM%                        !URG
3671: 5d98: 
3672: 5d98:         ! Setting the BKPLIST file name
3673: 5d98:  !       BKPLI.FILE.NAME$ = BKPLI.FILE.NAME$ + EXT.MDD$                 !URG
3674: 5d98: 
3675: 5d98:  !       CREATE POSFILE BKPLI.FILE.NAME$ AS BKPLI.SESS.NUM%             \URG
3676: 5d98:  !                                       LOCKED \                       !URG LDC
3677: 5d98:  !                                       MIRRORED PERUPDATE             !URG
3678: 5d98:  !       BKPLI.OPEN   = TRUE                                            !URG
3679: 5d98:  !       STATUS.MSG$  = STATUS.TEXT.ERROR$(17)                          !URG KDC
3680: 5d98:  !       GOSUB DISPLAY.STATUS.MSG                                       !URG
3681: 5d98:  !       GOSUB LOG.STATUS.MSG                                           !URG
3682: 5d98: 
3683: 5d98:  !   ENDIF ELSE BEGIN                                                   !URG
3684: 5d98: 
3685: 5d98:  !       GOSUB DETERMINE.BKPLIST.EXT                                    !URG OJK
3686: 5d98: 
3687: 5d98:         ! Setting the BKPLIST file name
3688: 5d98:  !       BKPLI.FILE.NAME$ = BKPLI.FILE.NAME$ + FULL.EXT.MDD$            !URG KDC
3689: 5d98: 
3690: 5d98:  !       FILE.OPERATION$     = "O"                                      !URG CJK
3691: 5d98:  !       CURRENT.REPORT.NUM% = BKPLI.REPORT.NUM%                        !URG CJK
3692: 5d98: 
3693: 5d98:  !       GOSUB OPEN.BKPLIST.FILE                                        !URG GJK
3694: 5d98: 
3695: 5d98:  !       VALUE.PRESENT = TRUE                                           !URG
3696: 5d98:  !       ARRAY.INDEX%  = XBACK.ZERO%                                    !URG
3697: 5d98: 
3698: 5d98:  !       FILE.OPERATION$     = "R"                                      !URG CJK
3699: 5d98:  !       CURRENT.REPORT.NUM% = BKPLI.REPORT.NUM%                        !URG CJK
3700: 5d98: 
3701: 5d98:         !------------------------------------------------!
3702: 5d98:         ! Storing the BKPLIST file details into an array !
3703: 5d98:         !------------------------------------------------!
3704: 5d98:  !       WHILE VALUE.PRESENT                                            !URG 
3705: 5d98:  !           IF READ.BKPLI THEN BEGIN      ! force exit on fail         !URG KDC
3706: 5d98:  !               VALUE.PRESENT = FALSE                                  !URG
3707: 5d98:  !           ENDIF ELSE BEGIN                                           !URG
3708: 5d98:  !               ARRAY.INDEX% = ARRAY.INDEX% + 1   ! Increment the index!URG
3709: 5d98: 
3710: 5d98:                 !-----------------------------------------------------!
3711: 5d98:                 ! If Array limit reached, second array is initialized !
3712: 5d98:                 !-----------------------------------------------------!
3713: 5d98:  !               IF ARRAY.INDEX% = ARRAY.LIMIT% THEN BEGIN              !URG
3714: 5d98:  !                   DIM BKPLIST.SECOND.ARRAY$(ARRAY.LIMIT%)            !URG
3715: 5d98:  !                   BKPLIST.ARRAY$(ARRAY.INDEX%) = BKPLI.VALUE$        !URG KDC
3716: 5d98:  !               ENDIF ELSE BEGIN                                       !URG
3717: 5d98: 
3718: 5d98:                     !--------------------------------------------------!
3719: 5d98:                     ! Once Array limit crossed, second array has been  !!KDC
3720: 5d98:                     ! set ON and program starts using second array     !!KDC
3721: 5d98:                     !--------------------------------------------------!
3722: 5d98:  !                   IF ARRAY.INDEX% > ARRAY.LIMIT% THEN BEGIN          !URG
3723: 5d98:  !                       SECOND.ARRAY.ON     = TRUE                     !URG
3724: 5d98:  !                       ! Increment the index                       
3725: 5d98:  !                       ARRAY.SECOND.INDEX% = ARRAY.SECOND.INDEX% + 1  !URG
3726: 5d98: 
3727: 5d98:                         !--------------------------------------!
3728: 5d98:                         ! Checking the index of second array   !
3729: 5d98:                         ! before writing in array              !
3730: 5d98:                         !--------------------------------------!
3731: 5d98:  !                      IF ARRAY.SECOND.INDEX% > ARRAY.LIMIT% THEN BEGIN!URG
3732: 5d98:  !                          STATUS.MSG$ = STATUS.TEXT.ERROR$(18)     + \!URG KDC
3733: 5d98:  !                               STR$(ARRAY.LIMIT% * NUM.OF.ARRAYS%) + \!URG OJK
3734: 5d98:  !                               STATUS.TEXT.ERROR$(19)                 !URG OJK
3735: 5d98:  !                          GOSUB DISPLAY.STATUS.MSG                    !URG
3736: 5d98:  !                          GOSUB LOG.STATUS.MSG                        !URG
3737: 5d98:  !                          STATUS.MSG$ = STATUS.TEXT.ERROR$(20)        !URG KDC
3738: 5d98:  !                          XBKOK.INTERIM.STATUS$ = STATUS.MAJOR.ERROR$ !URG
3739: 5d98:  !                          GOSUB PROGRAM.EXIT                          !URG
3740: 5d98:  !                      ENDIF                                           !URG
3741: 5d98:  !                      BKPLIST.SECOND.ARRAY$(ARRAY.SECOND.INDEX%) = \  !URG
3742: 5d98:  !                                                          BKPLI.VALUE$!URG KDC
3743: 5d98:  !                   ENDIF ELSE BEGIN                                   !URG
3744: 5d98:  !                       BKPLIST.ARRAY$(ARRAY.INDEX%) = BKPLI.VALUE$    !URG KDC
3745: 5d98:  !                   ENDIF                                              !URG
3746: 5d98:  !               ENDIF                                                  !URG
3747: 5d98:  !           ENDIF                                                      !URG KDC
3748: 5d98:  !       WEND                                                           !URG
3749: 5d98:  !    BKPLST.COMPL:                                                     !OJK
3750: 5d98: 
3751: 5d98:         !-------------------------------------------!
3752: 5d98:         ! Not closing the BKPLIST file, as the file !
3753: 5d98:         ! should not be accessed by any other       !
3754: 5d98:         ! application throughout the program run    !
3755: 5d98:         !-------------------------------------------!
3756: 5d98:         !reset the first array counter to the max if the secondary one  !URG QDC
3757: 5d98:         ! is in use                                                     !URG QDC
3758: 5d98:  !       IF ARRAY.INDEX% > ARRAY.LIMIT% THEN ARRAY.INDEX% = ARRAY.LIMIT%!URG QDC
3759: 5d98: 
3760: 5d98:  !       STATUS.MSG$ = STR$(ARRAY.INDEX%)        + "+" + \              !URG RJK
3761: 5d98:  !                     STR$(ARRAY.SECOND.INDEX%) + " = " + \            !URG RJK
3762: 5d98:  !                     STR$(ARRAY.INDEX% + ARRAY.SECOND.INDEX%) + \     !URG QDC
3763: 5d98:  !                     STATUS.TEXT.MSG$(36)                             !URG KDC
3764: 5d98:  !       GOSUB DISPLAY.STATUS.MSG                                       !URG
3765: 5d98:  !       GOSUB LOG.STATUS.MSG                                           !URG
3766: 5d98: 
3767: 5d98:  !   ENDIF                                                              !URG
3768: 5d98: 
3769: 5d98: RETURN
3770: 5da8: 
3771: 5da8: \***********************************************************************!GJK
3772: 5da8: \*                                                                      !GJK
3773: 5da8: \*    OPEN.BKPLIST.FILE: This Subroutine opens the BKPLIST file if      !GJK
3774: 5da8: \*                       present. If not present, then creates a new    !GJK
3775: 5da8: \*                       file for the current week.                     !GJK
3776: 5da8: \*                                                                      !GJK
3777: 5da8: \***********************************************************************!GJK
3778: 5da8: ! Commenting out the subroutine as BKPLIST file will not be maintained  !URG
3779: 5da8: ! going forward.
3780: 5da8: !OPEN.BKPLIST.FILE:                                                     !URG
3781: 5da8: 
3782: 5da8:     ! Open the BKPLIST file if present
3783: 5da8: !    IF END # BKPLI.SESS.NUM% THEN BKPLI.NOT.PRESENT                    !URG
3784: 5da8: !    OPEN BKPLI.FILE.NAME$ AS BKPLI.SESS.NUM% LOCKED                    !URG
3785: 5da8: 
3786: 5da8: !    BKPLI.OPEN   = TRUE                                                !URG
3787: 5da8: !    STATUS.MSG$  = STATUS.TEXT.MSG$(37)                                !URG KDC
3788: 5da8: !    GOSUB DISPLAY.STATUS.MSG                                           !URG
3789: 5da8: !    GOSUB LOG.STATUS.MSG                                               !URG
3790: 5da8: 
3791: 5da8: !    RETURN                                                             !URG
3792: 5da8: 
3793: 5da8: !BKPLI.NOT.PRESENT:                                                     !URG 
3794: 5da8: 
3795: 5da8:   !  STATUS.MSG$ = STATUS.TEXT.ERROR$(21)                               !URG KDC
3796: 5da8:   !  GOSUB DISPLAY.STATUS.MSG                                           !URG
3797: 5da8:   !  GOSUB LOG.STATUS.MSG                                               !URG
3798: 5da8: 
3799: 5da8:     ! Create the BKPLIST file as it is not present
3800: 5da8:   !  CREATE POSFILE BKPLI.FILE.NAME$ AS BKPLI.SESS.NUM% LOCKED \        !URG OJK
3801: 5da8:   !                                         MIRRORED PERUPDATE          !URG OJK
3802: 5da8:   !  BKPLI.OPEN   = TRUE
3803: 5da8:   !  STATUS.MSG$  = STATUS.TEXT.MSG$(38)                                !URG KDC
3804: 5da8:   !  GOSUB DISPLAY.STATUS.MSG
3805: 5da8:   !  GOSUB LOG.STATUS.MSG
3806: 5da8: 
3807: 5da8:   ! Setting FULL backup as this is the first run of the week            !URG DJK
3808: 5da8:   ! RUN.TYPE$ = "F"                                                     !URG DJK
3809: 5da8: 
3810: 5da8: RETURN
3811: 5db8: 
3812: 5db8: \***********************************************************************
3813: 5db8: \*
3814: 5db8: \*    DETERMINE.BKPLIST.EXT: This Subroutine determines the BKPLIST file
3815: 5db8: \*                           name's extension and set the file name.
3816: 5db8: \*
3817: 5db8: \***********************************************************************
3818: 5db8: ! Below subroutine needs to be commented out as it decides the          !URG
3819: 5db8: ! extension type                                                        !URG
3820: 5db8: 
3821: 5db8: !DETERMINE.BKPLIST.EXT:                                                 !URG
3822: 5db8: 
3823: 5db8: !    F02.DATE$ = CURR.DATE$                                             !URG
3824: 5db8: !    GOSUB HOW.MANY.DAYS.SINCE.FULL                                     !URG KDC
3825: 5db8:    
3826: 5db8: !    RETURN.VALUE.CHECK% = UPDATE.DATE(-DAYS.AFTER.FULL.BAKUP%)         !URG
3827: 5db8: 
3828: 5db8: !    GOSUB CHECK.UPDATE.DATE.RC                                         !URG FJK
3829: 5db8: 
3830: 5db8:     ! Setting the Full date                                             !KDC
3831: 5db8: !    FULL.DATE$ = F02.DATE$                                             !URG KDC
3832: 5db8:     
3833: 5db8: !    RETURN.VALUE.CHECK% = UPDATE.DATE(-7)                              !URG
3834: 5db8: 
3835: 5db8: 
3836: 5db8: !    GOSUB CHECK.UPDATE.DATE.RC                                         !URG
3837: 5db8: 
3838: 5db8: !    ORG.DATE$ = F02.DATE$                                              !URG
3839: 5db8: 
3840: 5db8:     !--------------------------------------------------------!
3841: 5db8:     ! Defining the Extension name from date and month value  !
3842: 5db8:     !--------------------------------------------------------!
3843: 5db8: !    EXTENSION$ = RIGHT$(FULL.DATE$,4)      ! Extracting Month value    !URG KDC
3844: 5db8: !    GOSUB GET.FILE.EXTENSION                                           !URG KDC
3845: 5db8: !    FULL.EXT.MDD$ = EXTENSION$                                         !URG KDC
3846: 5db8: !    IF VAL(MID$(CURR.DATE$,3,2)) >  9 THEN BEGIN                       !URG
3847: 5db8: !        ORG.EXT$ = LEFT$(EXTENSION$,1) + RIGHT$(ORG.DATE$,2)           !URG
3848: 5db8: !    ENDIF ELSE BEGIN                                                   !URG
3849: 5db8: !       ORG.EXT$ = RIGHT$(ORG.DATE$,3)                                  !URG
3850: 5db8: !    ENDIF                                                              !URG
3851: 5db8: 
3852: 5db8: !    STATUS.MSG$ = STATUS.TEXT.MSG$(57)                                 !URG KDC
3853: 5db8: !    GOSUB LOG.STATUS.MSG                                               !URG JJK
3854: 5db8: !    GOSUB DISPLAY.STATUS.MSG                                           !URG JJK
3855: 5db8: 
3856: 5db8:     !----------------------------------!                                !JJK
3857: 5db8:     ! Deleting the older BKPLIST files !
3858: 5db8:     !----------------------------------!
3859: 5db8:     ! Determining 3 weeks prior BKPLIST file
3860: 5db8: !    RETURN.VALUE.CHECK% = UPDATE.DATE(-VAL(BKPSCRPT.DAYS.TO.KEEP$) - 7)!URG KDC
3861: 5db8: !    GOSUB CHECK.UPDATE.DATE.RC                                         !URG JJK
3862: 5db8: 
3863: 5db8: !    EXTENSION$ = RIGHT$(F02.DATE$,4)   ! Extracting Month value        !URG KDC
3864: 5db8: !    GOSUB GET.FILE.EXTENSION                                           !URG KDC
3865: 5db8: !    FULL.DEL.EXT.MDD$ = EXTENSION$                    !KDC
3866: 5db8: 
3867: 5db8:     ! Old BKPLIST file delete in D:/ADX_UDT1/                           !URG OJK
3868: 5db8: !    CALL OSSHELL("DEL D:\ADX_UDT1\BKPLIST." + FULL.DEL.EXT.MDD$ + \    !URG KDC
3869: 5db8: !                 " > " + DIR.OUT$ +  " >>* " + DIR.OUT$ )              !URG JJK
3870: 5db8:     ! Old BKPLIST file delete in C:/ADX_UDT1/                           !URG OJK
3871: 5db8: !    CALL OSSHELL("DEL C:\ADX_UDT1\BKPLIST." + FULL.DEL.EXT.MDD$ + \    !URG OJK
3872: 5db8: !                 " > " + DIR.OUT$ +  " >>* " + DIR.OUT$ )              !URG OJK
3873: 5db8: 
3874: 5db8: RETURN
3875: 5dc8: 
3876: 5dc8: \***********************************************************************
3877: 5dc8: \*
3878: 5dc8: \*    HOW.MANY.DAYS.SINCE.FULL: This Subroutine matches the day set
3879: 5dc8: \*                              in F13.DAY and sets the number of days
3880: 5dc8: \*                              since the Full backup was taken for
3881: 5dc8: \*                              this day
3882: 5dc8: \*
3883: 5dc8: \***********************************************************************
3884: 5dc8: HOW.MANY.DAYS.SINCE.FULL:
3885: 5dd0: 
3886: 5dd0:     ! match for the day and set using the offset as days before
3887: 5dd0:     DAYS.AFTER.FULL.BAKUP% = MATCH(":"+F13.DAY$, BACKUP.DAYS$,1)        !KDC
3888: 5e0e:     DAYS.AFTER.FULL.BAKUP% = (DAYS.AFTER.FULL.BAKUP%-1)/4               !KDC
3889: 5e23: 
3890: 5e23: RETURN
3891: 5e33: 
3892: 5e33: 
3893: 5e33: \***********************************************************************
3894: 5e33: \*
3895: 5e33: \*    PROCESS.BKPSCRPT: This Subroutine reads the BKPSCRPT and  stores
3896: 5e33: \*                      the EXCLUDE items in BKPEXCL.DAT and also
3897: 5e33: \*                      initiate all the processing required for the
3898: 5e33: \*                      Backup process.
3899: 5e33: \*
3900: 5e33: \***********************************************************************
3901: 5e33: PROCESS.BKPSCRPT:
3902: 5e43:     
3903: 5e43:     !--------------------------------------------------!                !DJK
3904: 5e43:     ! Logging/Displaying the backup type for reference !                !DJK
3905: 5e43:     !--------------------------------------------------!                !DJK
3906: 5e43:     IF RUN.TYPE$ = "F" THEN BEGIN
3907: 5e5e:         STATUS.MSG$ = STATUS.TEXT.MSG$(39)                              !KDC
3908: 5e85:     ENDIF ELSE BEGIN
3909: 5e8d:         STATUS.MSG$ = STATUS.TEXT.MSG$(40)                              !KDC
3910: 5eb2:     ENDIF
3911: 5eba: 
3912: 5eba:     GOSUB DISPLAY.STATUS.MSG
3913: 5ecc:     GOSUB LOG.STATUS.MSG
3914: 5ede: 
3915: 5ede:     VALUE.EXISTS = TRUE
3916: 5eec:     INCLUDE.RUN  = FALSE
3917: 5efa: 
3918: 5efa:     STATUS.MSG$ = STATUS.TEXT.MSG$(46)                                  !KDC
3919: 5f1f:     GOSUB DISPLAY.STATUS.MSG
3920: 5f31:     STATUS.MSG$ = STATUS.TEXT.MSG$(41)                                  !KDC
3921: 5f56:     GOSUB DISPLAY.STATUS.MSG
3922: 5f68:     STATUS.MSG$ = STATUS.TEXT.MSG$(42)                                  !KDC
3923: 5f8d:     GOSUB DISPLAY.STATUS.MSG
3924: 5f9f:     STATUS.MSG$ = STATUS.TEXT.MSG$(43)                                  !KDC
3925: 5fc4:     GOSUB DISPLAY.STATUS.MSG
3926: 5fd6:     STATUS.MSG$ = STATUS.TEXT.MSG$(44)                                  !KDC
3927: 5ffb:     GOSUB DISPLAY.STATUS.MSG
3928: 600d:     STATUS.MSG$ = STATUS.TEXT.MSG$(45)                                  !KDC
3929: 6032:     GOSUB DISPLAY.STATUS.MSG
3930: 6044:     STATUS.MSG$ = STATUS.TEXT.MSG$(46)                                  !KDC
3931: 6069:     GOSUB DISPLAY.STATUS.MSG
3932: 607b:     WAIT;2000   ! Allow two second for user
3933: 6092:                 ! to read the instructions
3934: 6092: 
3935: 6092:     IF END # BKPSCRPT.SESS.NUM% THEN BKPSCRPT.READ.ERR
3936: 60ab:     FILE.OPERATION$     = "R"                                           !CJK
3937: 60c2:     CURRENT.REPORT.NUM% = BKPSCRPT.REPORT.NUM%                          !CJK
3938: 60d4: 
3939: 60d4:     !-----------------------------------------------------------------!
3940: 60d4:     ! Extracting EXCLUDE and BACKUP and performing respective process !
3941: 60d4:     !-----------------------------------------------------------------!
3942: 60d4:     WHILE VALUE.EXISTS
3943: 60df:         READ # BKPSCRPT.SESS.NUM%; LINE BKPSCRPT.VALUE$
3944: 60fb:         ! Comma position
3945: 60fb:         COMMA.POSITION% = MATCH(COMMA.VALUE$,BKPSCRPT.VALUE$,1)
3946: 611d: 
3947: 611d:         IF COMMA.POSITION% <> XBACK.ZERO% THEN BEGIN
3948: 6131:             ! Extracting Backup script command
3949: 6131:             BKPSCRPT.COMMAND$ = LEFT$(BKPSCRPT.VALUE$,                 \
3950: 6158:                                      (COMMA.POSITION% - 1) )
3951: 6158:             CALL TRIM(BKPSCRPT.COMMAND$)
3952: 616c: 
3953: 616c:             ! Remaining Backup script value
3954: 616c:             BKPSCRPT.VALUE$ = MID$(BKPSCRPT.VALUE$,                    \
3955: 61a0:                                    (COMMA.POSITION% + 1),              \
3956: 61a0:                                    LEN(BKPSCRPT.VALUE$)   )
3957: 61a0:             !-----------------------!
3958: 61a0:             ! If command is Backup  !
3959: 61a0:             !-----------------------!
3960: 61a0:             IF BKPSCRPT.COMMAND$ = "BACKUP" THEN BEGIN
3961: 61be:                 ! To avoid first loop run
3962: 61be:                 IF INCLUDE.RUN THEN BEGIN
3963: 61d0: 
3964: 61d0:                     ! Check the directory existence
3965: 61d0:                     GOSUB DIRECTORY.EXISTENCE
3966: 61e2: 
3967: 61e2:                     !-------------------------------------!
3968: 61e2:                     ! BACKUP.OFF would be set TRUE if the !
3969: 61e2:                     ! directory is not present            !
3970: 61e2:                     !-------------------------------------!
3971: 61e2:                     IF BACKUP.OFF THEN BEGIN
3972: 61f1:                         ! Directory not exist
3973: 61f1:                         STATUS.MSG$ = BKPSCRPT.DIRECTORY$            + \
3974: 6221:                                       STATUS.TEXT.ERROR$(22)            !KDC
3975: 6221:                         GOSUB DISPLAY.STATUS.MSG
3976: 6233:                         GOSUB LOG.STATUS.MSG
3977: 6248:                     ENDIF ELSE BEGIN
3978: 6250:                         ! Directory Archiving
3979: 6250:                         STATUS.MSG$ = BKPSCRPT.DIRECTORY$            + \
3980: 6280:                                       STATUS.TEXT.MSG$(47)              !KDC
3981: 6280:                         GOSUB DISPLAY.STATUS.MSG
3982: 6292:                         GOSUB LOG.STATUS.MSG
3983: 62a4: 
3984: 62a4:                         ! Checking the files for Backing up
3985: 62a4:                         GOSUB BKPLIST.HOUSEKEEPING
3986: 62b6:                         
3987: 62b6:                         ! Write to BKPEXCL file and to make sure        !TSM
3988: 62b6:                         ! Write routine is not called if there are no   !TSM
3989: 62b6:                         ! Exclusion files present for the subdirecories !TSM
3990: 62b6:                         
3991: 62b6:                         IF BKPEXCL.COMP.INDEX% > 1 THEN BEGIN           !TSM
3992: 62c5:                             GOSUB WRITE.BKPEXCL                         !TSM
3993: 62d7:                         ENDIF                                           !TSM
3994: 62df:                         ! Backup process
3995: 62df:                         GOSUB BACKUP.PROCESS
3996: 62f1: 
3997: 62f1:                     ENDIF
3998: 62f9: 
3999: 62f9:                     ! Reset the flag
4000: 62f9:                     EXCLUDE.PRESENT = FALSE
4001: 6307: 
4002: 6307:                 ENDIF
4003: 630f:                 !-----------------------------------!
4004: 630f:                 ! To start the Backup process after !
4005: 630f:                 ! skipping the first loop           !
4006: 630f:                 !-----------------------------------!
4007: 630f:                 INCLUDE.RUN = TRUE                                      !NJK
4008: 631d: 
4009: 631d:                 !------------------------------------------!
4010: 631d:                 ! Extracting Backup script directory value !
4011: 631d:                 !------------------------------------------!
4012: 631d: 
4013: 631d:                 ! Comma position
4014: 631d:                 COMMA.POSITION% = MATCH(COMMA.VALUE$,BKPSCRPT.VALUE$,1) !OJK
4015: 633f:                 ! Backup directory
4016: 633f:                 BKPSCRPT.DIRECTORY$  = LEFT$(BKPSCRPT.VALUE$,          \
4017: 6366:                                              (COMMA.POSITION% - 1))
4018: 6366: 
4019: 6366:                 CALL TRIM(BKPSCRPT.DIRECTORY$)
4020: 637a: 
4021: 637a:                 ! Remaining Backup script value
4022: 637a:                 BKPSCRPT.VALUE$ = MID$(BKPSCRPT.VALUE$,                \
4023: 63ae:                                        (COMMA.POSITION% + 1),          \
4024: 63ae:                                        LEN(BKPSCRPT.VALUE$)   )
4025: 63ae: 
4026: 63ae:                 !-------------------------------------------------!
4027: 63ae:                 ! Extracting Backup script output directory value !
4028: 63ae:                 !-------------------------------------------------!
4029: 63ae: 
4030: 63ae:                 ! Comma position
4031: 63ae:                 COMMA.POSITION%         = MATCH(COMMA.VALUE$,          \
4032: 63d0:                                                 BKPSCRPT.VALUE$,       \
4033: 63d0:                                                 1)
4034: 63d0:                 ! Output directory
4035: 63d0:                 BKPSCRPT.OUT.FILE.NAME$ = LEFT$(BKPSCRPT.VALUE$,       \
4036: 63f7:                                                (COMMA.POSITION% - 1))
4037: 63f7:                 CALL TRIM(BKPSCRPT.OUT.FILE.NAME$)
4038: 640b: 
4039: 640b:                 ! Remaining Backup script value
4040: 640b:                 BKPSCRPT.VALUE$ = MID$(BKPSCRPT.VALUE$,                \
4041: 643f:                                        (COMMA.POSITION% + 1),          \
4042: 643f:                                        LEN(BKPSCRPT.VALUE$)   )
4043: 643f: 
4044: 643f:                 !-----------------------------------!
4045: 643f:                 ! Backup script output if CF master !
4046: 643f:                 !-----------------------------------!
4047: 643f:                 IF MASTER$ <> CE.CNTR$ THEN BEGIN
4048: 645e:                     ! Output directory
4049: 645e:                     BKPSCRPT.OUT.FILE.NAME$ = BKPSCRPT.VALUE$
4050: 6477:                     CALL TRIM(BKPSCRPT.OUT.FILE.NAME$)
4051: 648b:                 ENDIF
4052: 6496: 
4053: 6496:             ENDIF ELSE BEGIN
4054: 649e:             !-----------------------!
4055: 649e:             ! If command is Exclude !
4056: 649e:             !-----------------------!
4057: 649e:                 IF BKPSCRPT.COMMAND$ = "EXCLUDE" THEN BEGIN
4058: 64bc:                     ! Comma position
4059: 64bc:                     COMMA.POSITION%          = MATCH(COMMA.VALUE$,     \
4060: 64de:                                                      BKPSCRPT.VALUE$,  \
4061: 64de:                                                       1)
4062: 64de:                     ! File exclusion
4063: 64de:                     BKPSCRPT.FILE.EXCLUSION$ = LEFT$(BKPSCRPT.VALUE$,  \
4064: 6505:                                                      (COMMA.POSITION%  \
4065: 6505:                                                                  - 1) )
4066: 6505:                     CALL TRIM(BKPSCRPT.FILE.EXCLUSION$)
4067: 6519:                     !Add the files to be excluded in Exclude array      !TSM
4068: 6519:                     BKPEXCL.ARRAY$(BKPEXCL.ARRAY.INDEX%)=              \!TSM
4069: 653f:                                                BKPSCRPT.FILE.EXCLUSION$ !TSM
4070: 653f:                     ! Add the files to be excluded in Complete exclude  !TSM
4071: 653f:                     ! array                                             !TSM
4072: 653f:                     BKPEXCL.COMP.ARRAY$(BKPEXCL.COMP.INDEX%) =         \!TSM
4073: 6565:                                                BKPSCRPT.FILE.EXCLUSION$ !TSM
4074: 6565:                     !Increment the exclude array index                  !TSM
4075: 6565:                     BKPEXCL.ARRAY.INDEX% = BKPEXCL.ARRAY.INDEX% + 1     !TSM
4076: 6571:                     !Increment the complete array index                 !TSM
4077: 6571:                     BKPEXCL.COMP.INDEX%  = BKPEXCL.COMP.INDEX% + 1      !TSM
4078: 657d:                     
4079: 657d:                     ! Commented out the subroutine call as it is being  !TSM
4080: 657d:                     ! done above in the code                            !TSM
4081: 657d:                     !GOSUB WRITE.BKPEXCL                                !TSM
4082: 657d: 
4083: 657d:                     ! Set the Boolean ON
4084: 657d:                     EXCLUDE.PRESENT = TRUE
4085: 658b:                 ENDIF
4086: 6593:             ENDIF
4087: 659b:         ENDIF
4088: 65a3:     WEND
4089: 65b5: 
4090: 65b5: BKPSCRPT.READ.ERR:
4091: 65c5: 
4092: 65c5:     !-------------------------------------!
4093: 65c5:     ! Last directory backup from BKPSCRPT !
4094: 65c5:     !-------------------------------------!
4095: 65c5: 
4096: 65c5:     ! Check the directory existence
4097: 65c5:     GOSUB DIRECTORY.EXISTENCE
4098: 65d7: 
4099: 65d7:     !-------------------------------------!
4100: 65d7:     ! BACKUP.OFF would be set TRUE if the !
4101: 65d7:     ! directory is not present            !
4102: 65d7:     !-------------------------------------!
4103: 65d7:     IF BACKUP.OFF THEN BEGIN
4104: 65e6:         ! Directory not exist
4105: 65e6:         STATUS.MSG$ = BKPSCRPT.DIRECTORY$ + STATUS.TEXT.ERROR$(22)      !KDC
4106: 6616:         GOSUB DISPLAY.STATUS.MSG
4107: 6628:         GOSUB LOG.STATUS.MSG
4108: 663d:     ENDIF ELSE BEGIN
4109: 6645:         ! Directory Archiving
4110: 6645:         STATUS.MSG$ = BKPSCRPT.DIRECTORY$ + STATUS.TEXT.MSG$(47)        !KDC
4111: 6675:         GOSUB DISPLAY.STATUS.MSG
4112: 6687:         GOSUB LOG.STATUS.MSG
4113: 6699: 
4114: 6699:         GOSUB BKPLIST.HOUSEKEEPING
4115: 66ab:         IF BKPEXCL.COMP.INDEX% > 1 THEN BEGIN                           !TSM
4116: 66ba:             GOSUB WRITE.BKPEXCL                                         !TSM
4117: 66cc:         ENDIF                                                           !TSM
4118: 66d4:         GOSUB BACKUP.PROCESS
4119: 66e6: 
4120: 66e6:     ENDIF
4121: 66ee: 
4122: 66ee:     !-----------------------------------------------------------------!
4123: 66ee:     ! Closing the relevant sessions as BKPSCRPT file read is complete !
4124: 66ee:     !-----------------------------------------------------------------!
4125: 66ee:     CLOSE BKPEXCL.SESS.NUM%
4126: 66ff:     BKPEXCL.OPEN = FALSE                                                !LDC
4127: 670d:     ! Deallocate session
4128: 670d:     CALL SESS.NUM.UTILITY ("C",BKPEXCL.SESS.NUM%,XBACK.NULL$)
4129: 672d: 
4130: 672d:     ! Non Re-used sessions, hence closing the file directly             !OJK
4131: 672d:     CLOSE BKPFAILC.SESS.NUM%                                            !OJK
4132: 673e:     BKPFAILC.OPEN = FALSE                                               !OJK
4133: 674c:     ! Deallocate session                                                !OJK
4134: 674c:     CALL SESS.NUM.UTILITY ("C",BKPFAILC.SESS.NUM%,XBACK.NULL$)          !OJK
4135: 676c: 
4136: 676c:     ! Non Re-used sessions, hence closing the file directly             !OJK
4137: 676c:     CLOSE BKPFAILD.SESS.NUM%                                            !OJK
4138: 677d:     BKPFAILD.OPEN = FALSE                                               !OJK
4139: 678b:     ! Deallocate session                                                !OJK
4140: 678b:     CALL SESS.NUM.UTILITY ("C",BKPFAILD.SESS.NUM%,XBACK.NULL$)          !OJK
4141: 67ab: 
4142: 67ab:     ! Non Re-used sessions, hence closing the file directly
4143: 67ab:     CLOSE BKPSCRPT.SESS.NUM%
4144: 67bc:     BKPSCRPT.OPEN = FALSE                                               !LDC
4145: 67ca:     ! Deallocate session
4146: 67ca:     CALL SESS.NUM.UTILITY ("C",BKPSCRPT.SESS.NUM%,XBACK.NULL$)
4147: 67ea: 
4148: 67ea: ! HSIUF session will be handled in File function itself. De-allocation  !OJK
4149: 67ea: ! has been moved to more appropriate place. SLPCF session de-allocation !OJK
4150: 67ea: ! is redundant and hence commented out                                  !OJK
4151: 67ea: !    ! Deallocate session                                               !OJK
4152: 67ea: !    CALL SESS.NUM.UTILITY ("C",HSIUF.SESS.NUM%,XBACK.NULL$)            !OJK
4153: 67ea: !    HSIUF.OPEN = FALSE                                                 !OJK
4154: 67ea: 
4155: 67ea: !    ! Deallocate session                                               !OJK
4156: 67ea: !    CALL SESS.NUM.UTILITY ("C",SLPCF.SESS.NUM%,XBACK.NULL$)            !OJK
4157: 67ea: !    SLPCF.OPEN = FALSE                                                 !OJK
4158: 67ea: 
4159: 67ea:     STATUS.MSG$ = STATUS.TEXT.MSG$(48)                                  !KDC
4160: 680f:     GOSUB DISPLAY.STATUS.MSG
4161: 6821:     GOSUB LOG.STATUS.MSG
4162: 6833: RETURN
4163: 6843: 
4164: 6843: \***********************************************************************
4165: 6843: \*
4166: 6843: \*   WRITE.BKPEXCL: Writes exclusion details to BKPEXCL.DAT
4167: 6843: \*
4168: 6843: \***********************************************************************
4169: 6843: WRITE.BKPEXCL:    
4170: 6853: 
4171: 6853:     CURRENT.REPORT.NUM% = BKPEXCL.REPORT.NUM%
4172: 6865:     FILE.OPERATION$     = "W"                   ! File write
4173: 687c:     
4174: 687c:     !Correct the index value                                            !TSM
4175: 687c:     BKPEXCL.COMP.INDEX% = BKPEXCL.COMP.INDEX% - 1                       !TSM
4176: 6888:     !Copy the content of complete exclude array to BKPEXCL file         !TSM
4177: 6888:     FOR BKPEXCL.COMP.POS% = 1 TO BKPEXCL.COMP.INDEX%                    !TSM
4178: 6899: 
4179: 6899:         !BKPSCRPT.FILE.EXCLUSION$ = BKPSCRPT.FILE.EXCLUSION$ + CRLF$    !TSM
4180: 6899: 
4181: 6899:         BKPSCRPT.FILE.EXCLUSION$ = BKPEXCL.COMP.ARRAY$                 \!TSM
4182: 68cb:                                            (BKPEXCL.COMP.POS%) + CRLF$  !TSM
4183: 68cb:         ! Form String
4184: 68cb:         BKPEXCL.FORM$ = "C" + STR$(LEN(BKPSCRPT.FILE.EXCLUSION$))
4185: 68fe: 
4186: 68fe:         IF END # BKPEXCL.SESS.NUM% THEN WRITE.BKPEXCL.ERROR
4187: 6917:         WRITE FORM BKPEXCL.FORM$; # BKPEXCL.SESS.NUM%;                 \
4188: 693f:                              BKPSCRPT.FILE.EXCLUSION$
4189: 693f:     NEXT BKPEXCL.COMP.POS%                                              !TSM
4190: 695a: 
4191: 695a: 
4192: 695a: RETURN
4193: 696a: 
4194: 696a: WRITE.BKPEXCL.ERROR:
4195: 697a:     STATUS.MSG$ = STATUS.TEXT.ERROR$(23)                                !KDC
4196: 699f:     GOSUB FILE.ERROR.EXIT
4197: 69b1: RETURN
4198: 69c1: \***********************************************************************
4199: 69c1: \*
4200: 69c1: \*    DIRECTORY.EXISTENCE: This Subroutine checks the existence
4201: 69c1: \*                         of current directory.
4202: 69c1: \*
4203: 69c1: \***********************************************************************
4204: 69c1: DIRECTORY.EXISTENCE:
4205: 69d1: 
4206: 69d1:     ! Setting the variables
4207: 69d1:     REMAINING.VALUE$  = BKPSCRPT.DIRECTORY$
4208: 69ea:     DRIVE$            = LEFT$(REMAINING.VALUE$,2)   ! Current drive
4209: 6a0c:     DIRECTORY.SEARCH$ = XBACK.NULL$
4210: 6a25:     SLASH.POSITION%   = XBACK.ZERO%
4211: 6a33:     BACKUP.OFF        = FALSE
4212: 6a41: 
4213: 6a41:     !---------------------------------------------!
4214: 6a41:     ! To check the directory existence of given   !
4215: 6a41:     ! sequence of directories under current drive !
4216: 6a41:     !---------------------------------------------!
4217: 6a41:     WHILE (LEN(REMAINING.VALUE$) <> SLASH.POSITION%) AND \
4218: 6a4c:     BACKUP.OFF = FALSE
4219: 6a4c:         ! Backward slash position
4220: 6a4c:         SLASH.POSITION%  = MATCH("\\", REMAINING.VALUE$, 1)
4221: 6a6a: 
4222: 6a6a:         REMAINING.VALUE$ = RIGHT$(REMAINING.VALUE$,                    \
4223: 6a9d:                               (LEN(REMAINING.VALUE$) - SLASH.POSITION%))!OJK
4224: 6a9d:         ! Backward slash position
4225: 6a9d:         SLASH.POSITION%  = MATCH("\\", REMAINING.VALUE$, 1)
4226: 6abb: 
4227: 6abb:         !---------------------!
4228: 6abb:         ! Directory to search !
4229: 6abb:         !---------------------!
4230: 6abb: 
4231: 6abb:         ! Extracting the directory value
4232: 6abb:         DIREC.TO.SEARCH$ = LEFT$(REMAINING.VALUE$,(SLASH.POSITION% - 1))
4233: 6ae2: 
4234: 6ae2:         ! Appending the slash
4235: 6ae2:         DIRECTORY.SEARCH$ = DIRECTORY.SEARCH$ + "\"
4236: 6b02: 
4237: 6b02:         !--------------------------!
4238: 6b02:         ! Current Search directory !
4239: 6b02:         !--------------------------!
4240: 6b02:         DIRECTORY.SEARCH.VALUE$ = DRIVE$ + DIRECTORY.SEARCH$
4241: 6b26: 
4242: 6b26:         !----------------------------------!
4243: 6b26:         ! Verifying the directory presence !
4244: 6b26:         !----------------------------------!
4245: 6b26:         GOSUB CHECK.DIR.NOT.EXIST
4246: 6b38: 
4247: 6b38:         !----------------------------------!
4248: 6b38:         ! If last run and directory exists !
4249: 6b38:         !----------------------------------!
4250: 6b38:         IF LEN(REMAINING.VALUE$) = SLASH.POSITION% AND \                !OJK
4251: 6b6b:            BACKUP.OFF            = FALSE     THEN BEGIN                 !OJK
4252: 6b6b:             ! Getting file details from current directory
4253: 6b6b:             CALL OSSHELL("DIR " + BKPSCRPT.DIRECTORY$                + \
4254: 6ba2:                          "*.*" + " > " + DIR.SEC.OUT$ )
4255: 6ba2:         ENDIF
4256: 6baa:         DIRECTORY.SEARCH$ = DIRECTORY.SEARCH$ + DIREC.TO.SEARCH$
4257: 6bce: 
4258: 6bce:     WEND
4259: 6c04: 
4260: 6c04: RETURN
4261: 6c14: ! HDC START BLOCK                                                       ! HDC
4262: 6c14: \***********************************************************************
4263: 6c14: \*
4264: 6c14: \*    CHECK.DIR.NOT.EXIST: This checks the existence of a given
4265: 6c14: \*                          directory.
4266: 6c14: \*
4267: 6c14: \***********************************************************************
4268: 6c14: CHECK.DIR.NOT.EXIST:
4269: 6c24: 
4270: 6c24:     ! Directory list details
4271: 6c24:     CALL OSSHELL("DIR -T " + DIRECTORY.SEARCH.VALUE$ + " > " + \
4272: 6c63:                  DIR.OUT$ + " >>* " + DIR.OUT$)                         !KDC
4273: 6c63: 
4274: 6c63:     IF END # TEMP.SESS.NUM% THEN DIR.NOT.EXISTS.ERR
4275: 6c7c:     OPEN DIR.OUT$ AS TEMP.SESS.NUM%                                     !KDC
4276: 6c9d:     ! Setting the temporary file open
4277: 6c9d:     TEMP.OPEN = TRUE
4278: 6cab: 
4279: 6cab:     ! Ignoring the first 4 lines
4280: 6cab:     READ # TEMP.SESS.NUM%; LINE DIR.VALUE$
4281: 6cc7:     READ # TEMP.SESS.NUM%; LINE DIR.VALUE$
4282: 6ce3:     READ # TEMP.SESS.NUM%; LINE DIR.VALUE$
4283: 6cff:     READ # TEMP.SESS.NUM%; LINE DIR.VALUE$
4284: 6d1b: 
4285: 6d1b:     BACKUP.OFF     = TRUE
4286: 6d29:     VALUE.EXISTS.2 = TRUE
4287: 6d37: 
4288: 6d37:     WHILE VALUE.EXISTS.2
4289: 6d42:         READ # TEMP.SESS.NUM%; LINE DIR.VALUE$
4290: 6d5e: 
4291: 6d5e:         ! Match found
4292: 6d5e:         IF MATCH((LEFT$(DIREC.TO.SEARCH$+STRING$(13," "),13) + "<DIR>")\!KDC
4293: 6dde:         , DIR.VALUE$, 1) <> XBACK.ZERO% \                               !KDC
4294: 6dde:         THEN BEGIN
4295: 6dde:             BACKUP.OFF = FALSE
4296: 6dec:         ENDIF
4297: 6df4: 
4298: 6df4:         ! IF EOF reached
4299: 6df4:         IF LEN(DIR.VALUE$) = XBACK.ZERO% THEN BEGIN
4300: 6e12:             VALUE.EXISTS.2 = FALSE
4301: 6e20:         ENDIF
4302: 6e28: 
4303: 6e28:     WEND
4304: 6e3a: 
4305: 6e3a:     ! Deleting the file as no longer needed
4306: 6e3a:     DELETE TEMP.SESS.NUM%
4307: 6e4b:     TEMP.OPEN = FALSE                                                   !LDC
4308: 6e59: RETURN
4309: 6e69: 
4310: 6e69: DIR.NOT.EXISTS.ERR:
4311: 6e79: 
4312: 6e79:     BACKUP.OFF = TRUE
4313: 6e87:     STATUS.MSG$ = STATUS.TEXT.ERROR$(24)                                !KDC
4314: 6eac: 
4315: 6eac: RETURN
4316: 6ebc: ! HDC END BLOCK                                                         !HDC
4317: 6ebc: 
4318: 6ebc: \***********************************************************************
4319: 6ebc: \*
4320: 6ebc: \*    BKPLIST.HOUSEKEEPING: This Subroutine stores the file details of
4321: 6ebc: \*                          current directory and navigate the call
4322: 6ebc: \*                          based on the current day.
4323: 6ebc: \*
4324: 6ebc: \***********************************************************************
4325: 6ebc: BKPLIST.HOUSEKEEPING: 
4326: 6ecc:     ! As the status setting in BKPLIST.FULL.CHECK has been  commented   !URG
4327: 6ecc:     ! setting the status here                                           !URG
4328: 6ecc:     XBKOK.INTERIM.STATUS$ = STATUS.END$                                 !URG
4329: 6ee5:     IF END # TEMP.SESS.NUM.2% THEN ERROR.DIR.OPEN
4330: 6efe: 
4331: 6efe:     !--------------------------------------------!
4332: 6efe:     ! If directory exists, read the file details !
4333: 6efe:     ! under the directory                        !
4334: 6efe:     !--------------------------------------------!
4335: 6efe:     IF NOT BACKUP.OFF THEN BEGIN                                        !CJK
4336: 6f10: 
4337: 6f10:         FILE.OPERATION$     = "O"                                       !CJK
4338: 6f27:         CURRENT.REPORT.NUM% = TEMP.REPORT.NUM.2%                        !CJK
4339: 6f39: 
4340: 6f39:         OPEN DIR.SEC.OUT$ AS TEMP.SESS.NUM.2%
4341: 6f5a: 
4342: 6f5a:         ! Setting the temporary file open
4343: 6f5a:         TEMP.2.OPEN = TRUE                                              !FJK
4344: 6f68: 
4345: 6f68:         FILE.OPERATION$     = "R"                                       !CJK
4346: 6f7f: 
4347: 6f7f:         ! Ignoring the first 4 lines
4348: 6f7f:         READ # TEMP.SESS.NUM.2%; LINE DIR.SEC.VALUE$
4349: 6f9b:         READ # TEMP.SESS.NUM.2%; LINE DIR.SEC.VALUE$
4350: 6fb7:         READ # TEMP.SESS.NUM.2%; LINE DIR.SEC.VALUE$
4351: 6fd3:         READ # TEMP.SESS.NUM.2%; LINE DIR.SEC.VALUE$
4352: 6fef: 
4353: 6fef:         FILE.PRESENT = TRUE
4354: 6ffd: 
4355: 6ffd:         !-----------------------------------------------------!
4356: 6ffd:         ! Navigating the routine depending on the current day !
4357: 6ffd:         !-----------------------------------------------------!
4358: 6ffd:         ! if the day is the Full backup day                             !URG KDC
4359: 6ffd:        ! IF F13.DAY$ = FULL.DAY$ THEN BEGIN                             !URG KDC
4360: 6ffd:             GOSUB BKPLIST.FULL                                          !URG KDC
4361: 700f:        ! ENDIF ELSE BEGIN                                               !URG
4362: 700f:        !     GOSUB BKPLIST.NON.FULL                                     !URG KDC
4363: 700f:        ! ENDIF                                                          !URG
4364: 700f: 
4365: 700f:         ! Deleting the file as no longer needed
4366: 700f:         FILE.OPERATION$ = "D"                                           !CJK
4367: 7026:         DELETE TEMP.SESS.NUM.2%
4368: 7037:         ! Setting the temporary file close
4369: 7037:         TEMP.2.OPEN = FALSE                                             !FJK
4370: 7045: 
4371: 7045:     ENDIF
4372: 704d: 
4373: 704d:     RETURN
4374: 705d: 
4375: 705d: ERROR.DIR.OPEN:
4376: 706d:     STATUS.MSG$ = STATUS.TEXT.ERROR$(25)
4377: 7092:     FILE.OPERATION$ = "O"                       ! File open
4378: 70a9:     GOSUB FILE.ERROR.EXIT
4379: 70bb: 
4380: 70bb: RETURN
4381: 70cb: 
4382: 70cb: \***********************************************************************
4383: 70cb: \*
4384: 70cb: \*    BKPLIST.NON.FULL: This Subroutine performs the BACKUP process     !KDC
4385: 70cb: \*                      for NON SUNDAY run.                             !KDC
4386: 70cb: \*
4387: 70cb: \***********************************************************************
4388: 70cb: ! No need of below subroutine as we dont need to do incremental         !URG
4389: 70cb: ! backup                                                                !URG
4390: 70cb: !BKPLIST.NON.FULL:                                                      !URG KDC
4391: 70cb: 
4392: 70cb: !    FILE.OPERATION$     = "R"                                          !URG CJK
4393: 70cb: !    CURRENT.REPORT.NUM% = TEMP.REPORT.NUM.2%                           !URG CJK
4394: 70cb: 
4395: 70cb: !    IF END # TEMP.SESS.NUM.2% THEN ERROR.DIR.READ1                     !URG
4396: 70cb:     !--------------------------------------------------!
4397: 70cb:     ! Looping until file name present. Storing all the !
4398: 70cb:     ! file details from the current directory          !
4399: 70cb:     !--------------------------------------------------!
4400: 70cb: !    WHILE FILE.PRESENT                                                 !URG
4401: 70cb: !        BKPEXCL.RUN = TRUE                                             !URG
4402: 70cb: !        READ # TEMP.SESS.NUM.2%; LINE DIR.SEC.VALUE$                   !URG
4403: 70cb: 
4404: 70cb:         !------------------------------------!
4405: 70cb:         ! Making sure length value is non    !
4406: 70cb:         ! zero and it's not a directory      !
4407: 70cb:         !------------------------------------!
4408: 70cb: !        IF LEN(DIR.SEC.VALUE$)              <> XBACK.ZERO%         AND \URG
4409: 70cb: !           MATCH("<DIR>", DIR.SEC.VALUE$, 1) = XBACK.ZERO%             \URG
4410: 70cb: !           THEN BEGIN                                                  !URG
4411: 70cb: !           FILE.NAME.VALUE$ = LEFT$(DIR.SEC.VALUE$,8)   ! File name    !URG 
4412: 70cb: !           FILE.EXT.VALUE$  = MID$(DIR.SEC.VALUE$,10,3) ! and extension!URG
4413: 70cb: !           CALL TRIM(FILE.NAME.VALUE$)                                 !URG
4414: 70cb: !            CALL TRIM(FILE.EXT.VALUE$)                                 !URG
4415: 70cb: 
4416: 70cb:             ! Complete file name regardless of extension                !URG
4417: 70cb: !            IF FILE.EXT.VALUE$ <> STRING$(3," ") THEN BEGIN ! Extension!URG
4418: 70cb: !                DIR.FILE.NAME$ = FILE.NAME.VALUE$ + "." + \ ! Present  !URG
4419: 70cb: !                                 FILE.EXT.VALUE$                       !URG
4420: 70cb: !            ENDIF ELSE BEGIN                                           !URG
4421: 70cb: !                DIR.FILE.NAME$ = FILE.NAME.VALUE$                      !URG
4422: 70cb: !            ENDIF                                                      !URG
4423: 70cb: 
4424: 70cb: !            IF EXCLUDE.PRESENT THEN BEGIN                              !URG
4425: 70cb:             !-----------------------------------------------------!
4426: 70cb:             ! Closing the BKPEXCL session as the existing session !
4427: 70cb:             ! might be in APPEND mode                             !
4428: 70cb:             !-----------------------------------------------------!
4429: 70cb: !                CLOSE BKPEXCL.SESS.NUM%                                !URG
4430: 70cb: !                BKPEXCL.OPEN = FALSE                                   !URG
4431: 70cb: 
4432: 70cb: !                FILE.OPERATION$     = "O"                              !URG
4433: 70cb: !                CURRENT.REPORT.NUM% = BKPEXCL.REPORT.NUM%              !URG
4434: 70cb: 
4435: 70cb:                 !--------------------------------------------!
4436: 70cb:                 ! Opening and reading BKPEXCL to avoid       !
4437: 70cb:                 ! exclusion list file to be added in BKPLIST !
4438: 70cb:                 !--------------------------------------------!
4439: 70cb: !                IF END # BKPEXCL.SESS.NUM% THEN BKPEXCL.OPEN.COMP1     !URG
4440: 70cb: !                OPEN BKPEXCL.FILE.NAME$ AS BKPEXCL.SESS.NUM%           !URG
4441: 70cb: !                IF END # BKPEXCL.SESS.NUM% THEN BKPEXCL.READ.COMP1     !URG
4442: 70cb: 
4443: 70cb: !                BKPEXCL.OPEN        = TRUE                             !URG FJK
4444: 70cb: !                FILE.OPERATION$     = "R"                              !URG CJK
4445: 70cb: !                CURRENT.REPORT.NUM% = BKPEXCL.REPORT.NUM%              !URG CJK
4446: 70cb: 
4447: 70cb: !                WHILE BKPEXCL.RUN                                      !URG  
4448: 70cb: !                    READ # BKPEXCL.SESS.NUM%; LINE BKPEXCL.VALUE$      !URG 
4449: 70cb: !                    IF UCASE$(BKPEXCL.VALUE$) = UCASE$(DIR.FILE.NAME$) \URG
4450: 70cb: !                    THEN BEGIN                                         !URG
4451: 70cb: !                        ! Setting False if EXCLUDE file matches        !URG
4452: 70cb: !                        BKPEXCL.RUN = FALSE                            !URG
4453: 70cb: !                    ENDIF                                              !URG
4454: 70cb: !                WEND                                                   !URG
4455: 70cb: !                BKPEXCL.READ.COMP1:                                    !URG
4456: 70cb: 
4457: 70cb: !            ENDIF
4458: 70cb: 
4459: 70cb:             !-----------------------------------!
4460: 70cb:             ! If file is not present in BKPEXCL !
4461: 70cb:             !-----------------------------------!
4462: 70cb: !            IF BKPEXCL.RUN THEN BEGIN                                  !URG
4463: 70cb: 
4464: 70cb: !                FILE.POSITION%     = XBACK.ZERO%                       !URG
4465: 70cb: !                FILE.IS.PRESENT$   = XBACK.NULL$                       !URG
4466: 70cb: !                FILE.IS.PRESENT$   = XBACK.NULL$                       !URG
4467: 70cb: !                COMMA.POSITION.2%  = XBACK.ZERO%                       !URG
4468: 70cb: !                FIRST.ARRAY.FOUND  = FALSE                             !URG
4469: 70cb: !                SECOND.ARRAY.FOUND = FALSE                             !URG
4470: 70cb: 
4471: 70cb: !                BKPLIST.COMP.FILENAME$ = BKPSCRPT.DIRECTORY$         + \URG
4472: 70cb: !                                         DIR.FILE.NAME$
4473: 70cb: 
4474: 70cb:                 !-----------------------------------------------!
4475: 70cb:                 ! Checking the file existence in BKPLIST array. !
4476: 70cb:                 ! If present, the array index will be saved for !
4477: 70cb:                 ! updating it respectively                      !
4478: 70cb:                 !-----------------------------------------------!
4479: 70cb: !                FOR INDEX% = 1 TO ARRAY.INDEX%                         !URG
4480: 70cb:                                                                         !URG RJK
4481: 70cb: !                    IF INDEX% > 9999 THEN BEGIN                        !URG
4482: 70cb: !                    COMMA.POSITION.2% = 0                              !URG
4483: 70cb: !                    ENDIF                                              !URG RJK
4484: 70cb: !                    COMMA.POSITION.2% = MATCH(COMMA.VALUE$,            \URG
4485: 70cb: !                                             BKPLIST.ARRAY$(INDEX%),   \URG
4486: 70cb: !                                                                 1)    !URG
4487: 70cb: !                    IF COMMA.POSITION.2% THEN BEGIN                    !URG RJK
4488: 70cb: !                        IF LEFT$(BKPLIST.ARRAY$(INDEX%),               \URG
4489: 70cb: !                                 (COMMA.POSITION.2% - 1))          =   \URG
4490: 70cb: !                           BKPLIST.COMP.FILENAME$                      \URG
4491: 70cb: !                        THEN BEGIN                                     !URG
4492: 70cb: !                            FILE.POSITION%    = INDEX%                 !URG
4493: 70cb: !                            INDEX%            = ARRAY.INDEX%           !URG
4494: 70cb: !                            FIRST.ARRAY.FOUND = TRUE                   !URG
4495: 70cb: !                        ENDIF                                          !URG
4496: 70cb: !                    ENDIF                                              !URG RJK
4497: 70cb: !                NEXT INDEX%                                            !URG
4498: 70cb: 
4499: 70cb:                 !--------------------------------!
4500: 70cb:                 ! Checking the file existence in !
4501: 70cb:                 ! BKPLIST array 2 if present     !
4502: 70cb:                 !--------------------------------!
4503: 70cb: !                IF SECOND.ARRAY.ON AND FILE.POSITION% = XBACK.ZERO%    \URG
4504: 70cb: !                THEN BEGIN                                             !URG
4505: 70cb: !                    FOR SECOND.INDEX% = 1 TO ARRAY.SECOND.INDEX%       !URG
4506: 70cb: !                        COMMA.POSITION.2% =                            \URG
4507: 70cb: !                                 MATCH(COMMA.VALUE$,                   \URG
4508: 70cb: !                                 BKPLIST.SECOND.ARRAY$(SECOND.INDEX%), \URG
4509: 70cb: !                                 1)                                    !URG
4510: 70cb: !                        IF LEFT$(BKPLIST.SECOND.ARRAY$(SECOND.INDEX%), \URG
4511: 70cb: !                                 (COMMA.POSITION.2% - 1))           =  \URG
4512: 70cb: !                           BKPLIST.COMP.FILENAME$                      \URG
4513: 70cb: !                        THEN BEGIN                                     !URG
4514: 70cb: !                            FILE.POSITION%     = SECOND.INDEX%         !URG
4515: 70cb: !                            SECOND.INDEX%      = ARRAY.SECOND.INDEX%   !URG
4516: 70cb: !                            SECOND.ARRAY.FOUND = TRUE                  !URG
4517: 70cb: !                        ENDIF                                          !URG
4518: 70cb: !                    NEXT SECOND.INDEX%                                 !URG
4519: 70cb: !                ENDIF                                                  !URG
4520: 70cb: 
4521: 70cb:                 !--------------------------------------!
4522: 70cb:                 ! If file is found in BKPLIST array(s) !
4523: 70cb:                 !--------------------------------------!
4524: 70cb: !                IF FILE.POSITION% <> XBACK.ZERO% THEN BEGIN            !URG
4525: 70cb: !                    FILE.IS.PRESENT$ = XBACK.YES$                      !URG 
4526: 70cb: 
4527: 70cb:                     !-------------------------------------------------! !DJK
4528: 70cb:                     ! If backup run is FULL or Archive flag is ON     !
4529: 70cb:                     ! then FILE.HAS.CHANGED$ will be set to 'Y', else !
4530: 70cb:                     ! NULL value will be set and the file details     !
4531: 70cb:                     ! will be added to exclusion list.                !
4532: 70cb:                     !-------------------------------------------------!
4533: 70cb: !                    GOSUB IS.ARCHIVE.FLAG.ON                           !URG HDC
4534: 70cb: !                    IF RUN.TYPE$ = "F" OR IS.ARCHIVE.ON THEN BEGIN     !URG OJK
4535: 70cb: 
4536: 70cb: !                        FILE.HAS.CHANGED$ = XBACK.YES$                 !URG 
4537: 70cb: 
4538: 70cb:                         ! Set OFF Archive attribute
4539: 70cb: !                        CALL OSSHELL("FSET "                     + \   !URG
4540: 70cb: !                                      BKPLIST.COMP.FILENAME$     + \   !URG
4541: 70cb: !                                      " -A=OFF >> " + DIR.OUT$   + \   !URG
4542: 70cb: !                                      " >>* " + DIR.OUT$  )            !URG
4543: 70cb: !                    ENDIF ELSE BEGIN                                   !URG
4544: 70cb: !                        ! Setting Null for File changed flag
4545: 70cb: !                        FILE.HAS.CHANGED$ = XBACK.NULL$                !URG
4546: 70cb: 
4547: 70cb: !                        EXCLUDE.PRESENT = TRUE                         !URG
4548: 70cb: 
4549: 70cb: !                        FILE.OPERATION$     = "O"                      !URG CJK
4550: 70cb: !                        CURRENT.REPORT.NUM% = BKPEXCL.REPORT.NUM%      !URG CJK
4551: 70cb: 
4552: 70cb:                         !---------------------------------------!
4553: 70cb:                         ! Closing the session to open in APPEND !
4554: 70cb:                         ! mode to update the file               !
4555: 70cb:                         !---------------------------------------!
4556: 70cb: !                        CLOSE BKPEXCL.SESS.NUM%                        !URG  
4557: 70cb: !                        BKPEXCL.OPEN = FALSE                           !URG FJK
4558: 70cb: 
4559: 70cb: !                        IF END # BKPEXCL.SESS.NUM% THEN                \URG
4560: 70cb: !                                            BKPEXCL.OPEN.COMP1         !URG
4561: 70cb: !                        OPEN BKPEXCL.FILE.NAME$ AS BKPEXCL.SESS.NUM%   \URG
4562: 70cb: !                                                              APPEND   !URG
4563: 70cb: !                        BKPEXCL.OPEN = TRUE                            !URG FJK
4564: 70cb: 
4565: 70cb: !                        BKPSCRPT.FILE.EXCLUSION$ = DIR.FILE.NAME$      !URG
4566: 70cb: !                        GOSUB WRITE.BKPEXCL                            !URG
4567: 70cb: !                    ENDIF                                              !URG
4568: 70cb: 
4569: 70cb: 
4570: 70cb:                     !-----------------------------------!
4571: 70cb:                     ! To identify in which array the    !
4572: 70cb:                     ! file has been found and update    !
4573: 70cb:                     ! accordingly                       !
4574: 70cb:                     !-----------------------------------!
4575: 70cb: !                    IF FIRST.ARRAY.FOUND THEN BEGIN                    !URG KDC
4576: 70cb: !                        TODAY.BKPLIST.REC$ = \                         !URG KDC
4577: 70cb: !                            BKPLIST.ARRAY$(FILE.POSITION%)             !URG OJK
4578: 70cb: !                        GOSUB UPD.TODAY.BKPLIST.REC                    !URG KDC
4579: 70cb: !                        BKPLIST.ARRAY$(FILE.POSITION%) = \             !URG KDC
4580: 70cb: !                            TODAY.BKPLIST.REC$                         !URG OJK
4581: 70cb: !                    ENDIF ELSE BEGIN                                   !URG KDC
4582: 70cb: !                        TODAY.BKPLIST.REC$ = \                         !URG KDC
4583: 70cb: !                            BKPLIST.SECOND.ARRAY$(FILE.POSITION%)      !URG OJK
4584: 70cb: !                        GOSUB UPD.TODAY.BKPLIST.REC                    !URG KDC
4585: 70cb: !                        BKPLIST.SECOND.ARRAY$(FILE.POSITION%) = \      !URG KDC
4586: 70cb: !                            TODAY.BKPLIST.REC$                         !URG OJK
4587: 70cb: !                    ENDIF                                              !URG KDC
4588: 70cb: 
4589: 70cb:                     ! Reset the flag
4590: 70cb: !                    FIRST.ARRAY.FOUND  = FALSE                         !URG BJK
4591: 70cb: !                    SECOND.ARRAY.FOUND = FALSE                         !URG BJK
4592: 70cb: 
4593: 70cb:                 ! If file is not found in BKPLIST
4594: 70cb: !                ENDIF ELSE BEGIN                                       !URG 
4595: 70cb: 
4596: 70cb:                     !---------------------------------!
4597: 70cb:                     ! If file is not present in array !
4598: 70cb:                     ! prepare to add as a new record  !
4599: 70cb:                     !---------------------------------!
4600: 70cb: !                    FILE.IS.PRESENT$  = XBACK.YES$                     !URG
4601: 70cb: !                    FILE.HAS.CHANGED$ = XBACK.YES$                     !URG
4602: 70cb: 
4603: 70cb:                     !--------------------------------!
4604: 70cb:                     ! Checking which array to select !
4605: 70cb:                     !--------------------------------!
4606: 70cb: !                    IF NOT SECOND.ARRAY.ON THEN BEGIN                  !URG
4607: 70cb: 
4608: 70cb: !                        GOSUB CREATE.BKPLIST.RECD                      !URG
4609: 70cb: !                        BKPLIST.ARRAY$(INDEX%) = BKPLIST.RECD$         !URG KDC
4610: 70cb: 
4611: 70cb: !                        ARRAY.INDEX% = INDEX%                          !URG
4612: 70cb: 
4613: 70cb: !                    ENDIF ELSE BEGIN                                   !URG
4614: 70cb: 
4615: 70cb:                         !----------------------------------!
4616: 70cb:                         ! If second array limit is reached !
4617: 70cb:                         !----------------------------------!
4618: 70cb: !                       IF SECOND.INDEX% > ARRAY.LIMIT% THEN BEGIN      !URG
4619: 70cb: !                           STATUS.MSG$ = STATUS.TEXT.ERROR$(18)     + \!URG KDC
4620: 70cb: !                                STR$(ARRAY.LIMIT% * NUM.OF.ARRAYS%) + \!URG OJK
4621: 70cb: !                                STATUS.TEXT.ERROR$(19)                 !URG OJK
4622: 70cb: !                           GOSUB DISPLAY.STATUS.MSG                    !URG
4623: 70cb: !                           GOSUB LOG.STATUS.MSG                        !URG
4624: 70cb: !                           STATUS.MSG$ = STATUS.TEXT.ERROR$(20)        !URG KDC
4625: 70cb: !                           XBKOK.INTERIM.STATUS$ = STATUS.MAJOR.ERROR$ !URG
4626: 70cb: !                           GOSUB PROGRAM.EXIT                          !URG
4627: 70cb: !                       ENDIF                                           !URG
4628: 70cb: 
4629: 70cb: !                        GOSUB CREATE.BKPLIST.RECD                      !URG KDC
4630: 70cb: !                        BKPLIST.SECOND.ARRAY$(SECOND.INDEX%) = \       !URG KDC
4631: 70cb: !                                                 BKPLIST.RECD$         !URG KDC
4632: 70cb: 
4633: 70cb: !                        ARRAY.SECOND.INDEX% = SECOND.INDEX%            !URG
4634: 70cb: !                    ENDIF                                              !URG
4635: 70cb: 
4636: 70cb:                     !-------------------------------------------!
4637: 70cb:                     ! If array limit reached in the first array !
4638: 70cb:                     ! make the second array ON                  !
4639: 70cb:                     !-------------------------------------------!
4640: 70cb: !                    IF INDEX% = ARRAY.LIMIT%                       AND \URG
4641: 70cb: !                       SECOND.ARRAY.ON = FALSE THEN BEGIN              !URG
4642: 70cb: !                        DIM BKPLIST.SECOND.ARRAY$(ARRAY.LIMIT%)        !URG  
4643: 70cb: !                        SECOND.ARRAY.ON = TRUE                         !URG
4644: 70cb: !                    ENDIF                                              !URG 
4645: 70cb: 
4646: 70cb:                     ! Set OFF Archive attribute
4647: 70cb: !                    CALL OSSHELL("FSET "                     + \       !URG
4648: 70cb: !                                  BKPLIST.COMP.FILENAME$     + \       !URG
4649: 70cb: !                                  " -A=OFF >> " + DIR.OUT$   + \       !URG
4650: 70cb: !                                  " >>* " + DIR.OUT$  )                !URG
4651: 70cb: !                ENDIF                                                  !URG
4652: 70cb: !            ENDIF                                                      !URG
4653: 70cb: !        ENDIF ELSE BEGIN                                               !URG
4654: 70cb: !            ! If the file reached End of Line                           
4655: 70cb: !            IF LEN(DIR.SEC.VALUE$) = XBACK.ZERO% THEN BEGIN            !URG
4656: 70cb: !                FILE.PRESENT = FALSE                                   !URG
4657: 70cb: !            ENDIF                                                      !URG
4658: 70cb: !        ENDIF                                                          !URG
4659: 70cb: !    WEND                                                               !URG
4660: 70cb: 
4661: 70cb: ! RETURN                                                                !URG 
4662: 70cb: 
4663: 70cb: !KDC START CHANGE BLOCK
4664: 70cb: \***********************************************************************
4665: 70cb: \*
4666: 70cb: \*    UPD.TODAY.BKPLIST.REC:    This subroutine uses the line value
4667: 70cb: \*                              of BKPLIST, process it and return
4668: 70cb: \*                              with updated value based on current day
4669: 70cb: \***********************************************************************
4670: 70cb: ! Commenting the subroutine as it is used during incremental backup to  !URG
4671: 70cb: ! to update a record in BKPLIST file based on the change                !URG
4672: 70cb: !UPD.TODAY.BKPLIST.REC:                                                 !URG
4673: 70cb: !
4674: 70cb: !    TODAY.BKPLIST.REC% = 1                                             !URG LDC
4675: 70cb: !    ! set in case of error failure
4676: 70cb: !    TODAY.BKPLIST.REC.ERR$ = TODAY.BKPLIST.REC$                        !URG
4677: 70cb: !    BKPLI.VALUE$           = TODAY.BKPLIST.REC$                        !URG
4678: 70cb: !
4679: 70cb: !    BEGIN.POS%    = 1           ! Begin search position                !URG
4680: 70cb: !    INDEX%        = XBACK.ZERO% ! Index for Field Array                !URG
4681: 70cb: !    COMMA.PRESENT = TRUE        ! While Boolean                        !URG
4682: 70cb: !
4683: 70cb: !    DIM FIELDS$(0)                 ! Clear the array first             !URG
4684: 70cb: !    DIM FIELDS$(15)                ! To store BKPLIST values           !URG
4685: 70cb: !
4686: 70cb: !    !----------------------------------------------------------!
4687: 70cb: !    ! Extracting all the variables using comma separator value !
4688: 70cb: !    !----------------------------------------------------------!
4689: 70cb: !    WHILE COMMA.PRESENT                                                !URG
4690: 70cb: !        ! Get index of next field delimiter                            !URG 
4691: 70cb: !        MATCH.POS% = MATCH(COMMA.VALUE$,BKPLI.VALUE$,BEGIN.POS%)       !URG KDC
4692: 70cb: !
4693: 70cb: !        INDEX% = INDEX% + 1     ! Incrementing the index               !URG
4694: 70cb: !
4695: 70cb: !        IF MATCH.POS% > XBACK.ZERO% THEN BEGIN                         !URG
4696: 70cb: !            ! If we found a field delimiter                            !URG
4697: 70cb: !            ! Get contents of field
4698: 70cb: !            FIELDS$(INDEX%) = MID$(BKPLI.VALUE$, BEGIN.POS%, \         !URG KDC
4699: 70cb: !                                 (MATCH.POS% - BEGIN.POS%)  )          !URG
4700: 70cb: !
4701: 70cb: !            ! Move next start position past field delimiter
4702: 70cb: !            BEGIN.POS% = MATCH.POS% + 1                                !URG
4703: 70cb: !        ENDIF ELSE BEGIN                                               !URG
4704: 70cb: !            ! Else we're at the last field                             !URG
4705: 70cb: !            COMMA.PRESENT = FALSE                                      !URG
4706: 70cb: !        ENDIF                                                          !URG
4707: 70cb: !    WEND                                                               !URG
4708: 70cb: !
4709: 70cb: !    ! Storing the values                                               !URG BJK
4710: 70cb: !    BKPLI.FILENAME$                 = FIELDS$(1)                       !URG KDC
4711: 70cb: !    BKPLI.FULL.EXIST$               = FIELDS$(2)                       !URG KDC
4712: 70cb: !    BKPLI.FULL.FILE.CHNG$           = FIELDS$(3)                       !URG KDC
4713: 70cb: !    BKPLI.INCREMENTAL.EXIST$(1)     = FIELDS$(4)                       !URG KDC
4714: 70cb: !    BKPLI.INCREMENTAL.FILE.CHNG$(1) = FIELDS$(5)                       !URG KDC
4715: 70cb: !    BKPLI.INCREMENTAL.EXIST$(2)     = FIELDS$(6)                       !URG KDC
4716: 70cb: !    BKPLI.INCREMENTAL.FILE.CHNG$(2) = FIELDS$(7)                       !URG KDC
4717: 70cb: !    BKPLI.INCREMENTAL.EXIST$(3)     = FIELDS$(8)                       !URG KDC
4718: 70cb: !    BKPLI.INCREMENTAL.FILE.CHNG$(3) = FIELDS$(9)                       !URG KDC
4719: 70cb: !    BKPLI.INCREMENTAL.EXIST$(4)     = FIELDS$(10)                      !URG KDC
4720: 70cb: !    BKPLI.INCREMENTAL.FILE.CHNG$(4) = FIELDS$(11)                      !URG KDC
4721: 70cb: !    BKPLI.INCREMENTAL.EXIST$(5)     = FIELDS$(12)                      !URG KDC
4722: 70cb: !    BKPLI.INCREMENTAL.FILE.CHNG$(5) = FIELDS$(13)                      !URG KDC
4723: 70cb: !    BKPLI.INCREMENTAL.EXIST$(6)     = FIELDS$(14)                      !URG KDC
4724: 70cb: !    BKPLI.INCREMENTAL.FILE.CHNG$(6) = FIELDS$(15)                      !URG KDC
4725: 70cb: !
4726: 70cb: !    GOSUB HOW.MANY.DAYS.SINCE.FULL                                     !URG KDC
4727: 70cb: !
4728: 70cb: !    BKPLI.INCREMENTAL.EXIST$(DAYS.AFTER.FULL.BAKUP%) = \               !URG  
4729: 70cb: !        FILE.IS.PRESENT$                                               !URG 
4730: 70cb: !
4731: 70cb: !    BKPLI.INCREMENTAL.FILE.CHNG$(DAYS.AFTER.FULL.BAKUP%) = \           !URG  
4732: 70cb: !        FILE.HAS.CHANGED$                                              !URG
4733: 70cb: !
4734: 70cb: !    ! Storing the updated BKPLIST values
4735: 70cb: !    TODAY.BKPLIST.REC$ =  \                                            !URG KDC
4736: 70cb: !        BKPLI.FILENAME$                 + COMMA.VALUE$ + \             !URG KDC
4737: 70cb: !        BKPLI.FULL.EXIST$               + COMMA.VALUE$ + \             !URG KDC
4738: 70cb: !        BKPLI.FULL.FILE.CHNG$           + COMMA.VALUE$ + \             !URG KDC
4739: 70cb: !        BKPLI.INCREMENTAL.EXIST$(1)     + COMMA.VALUE$ + \             !URG KDC
4740: 70cb: !        BKPLI.INCREMENTAL.FILE.CHNG$(1) + COMMA.VALUE$ + \             !URG KDC
4741: 70cb: !        BKPLI.INCREMENTAL.EXIST$(2)     + COMMA.VALUE$ + \             !URG KDC
4742: 70cb: !        BKPLI.INCREMENTAL.FILE.CHNG$(2) + COMMA.VALUE$ + \             !URG KDC
4743: 70cb: !        BKPLI.INCREMENTAL.EXIST$(3)     + COMMA.VALUE$ + \             !URG KDC
4744: 70cb: !        BKPLI.INCREMENTAL.FILE.CHNG$(3) + COMMA.VALUE$ + \             !URG KDC
4745: 70cb: !        BKPLI.INCREMENTAL.EXIST$(4)     + COMMA.VALUE$ + \             !URG KDC
4746: 70cb: !        BKPLI.INCREMENTAL.FILE.CHNG$(4) + COMMA.VALUE$ + \             !URG KDC
4747: 70cb: !        BKPLI.INCREMENTAL.EXIST$(5)     + COMMA.VALUE$ + \             !URG KDC
4748: 70cb: !        BKPLI.INCREMENTAL.FILE.CHNG$(5) + COMMA.VALUE$ + \             !URG KDC
4749: 70cb: !        BKPLI.INCREMENTAL.EXIST$(6)     + COMMA.VALUE$ + \             !URG KDC
4750: 70cb: !        BKPLI.INCREMENTAL.FILE.CHNG$(6) + COMMA.VALUE$                 !URG KDC
4751: 70cb: !
4752: 70cb: !RETURN                                                                 !URG  
4753: 70cb: !
4754: 70cb: !UPD.TODAY.BKPLIST.REC.ERR:                                             !URG 
4755: 70cb: !    TODAY.BKPLIST.REC% = 0                                             !URG LDC
4756: 70cb: !    TODAY.BKPLIST.REC$ = TODAY.BKPLIST.REC.ERR$                        !URG 
4757: 70cb: !    GOSUB LOG.STATUS.MSG                                               !URG  
4758: 70cb: !    GOSUB DISPLAY.STATUS.MSG                                           !URG  
4759: 70cb: !RETURN                                                                 !URG
4760: 70cb: 
4761: 70cb: \***********************************************************************
4762: 70cb: \*
4763: 70cb: \*    CREATE.BKPLIST.RECD:  This subroutine creates an empty list
4764: 70cb: \*                          entry for the correct day and builds the
4765: 70cb: \*                          arrays accordingly
4766: 70cb: \*
4767: 70cb: \***********************************************************************
4768: 70cb: ! Commenting the subroutine as no need to create the backup list record !URG
4769: 70cb: ! as it is done to maintain the incremental backup                      !URG
4770: 70cb: !CREATE.BKPLIST.RECD:                                                   !URG
4771: 70cb: 
4772: 70cb:     ! Setting the BKPLIST file variables
4773: 70cb: !    BKPLI.FILENAME$       = BKPLIST.COMP.FILENAME$                     !URG OJK
4774: 70cb: !    BKPLI.FULL.EXIST$     = XBACK.NULL$                                !URG OJK
4775: 70cb: !    BKPLI.FULL.FILE.CHNG$ = XBACK.NULL$                                !URG OJK
4776: 70cb: !    DIM BKPLI.INCREMENTAL.EXIST$(0)                                    !URG KDC
4777: 70cb: !    DIM BKPLI.INCREMENTAL.FILE.CHNG$(0)                                !URG KDC
4778: 70cb: !    DIM BKPLI.INCREMENTAL.EXIST$(6)                                    !URG KDC
4779: 70cb: !    DIM BKPLI.INCREMENTAL.FILE.CHNG$(6)                                !URG KDC
4780: 70cb: 
4781: 70cb:     ! Setting the values based on the DAY
4782: 70cb: !    GOSUB HOW.MANY.DAYS.SINCE.FULL                                     !URG KDC
4783: 70cb:                                                                         !URG KDC
4784: 70cb: !    BKPLI.INCREMENTAL.EXIST$(DAYS.AFTER.FULL.BAKUP%) = \               !URG KDC
4785: 70cb: !        FILE.IS.PRESENT$                                               !URG KDC
4786: 70cb:                                                                         !URG KDC
4787: 70cb: !    BKPLI.INCREMENTAL.FILE.CHNG$(DAYS.AFTER.FULL.BAKUP%) = \           !URG KDC
4788: 70cb: !        FILE.HAS.CHANGED$                                              !URG KDC
4789: 70cb: 
4790: 70cb:     ! Storing the updated BKPLIST values
4791: 70cb: !    BKPLIST.RECD$ =  \                                                 !URG KDC
4792: 70cb: !        BKPLI.FILENAME$                 + COMMA.VALUE$ + \             !URG KDC
4793: 70cb: !        BKPLI.FULL.EXIST$               + COMMA.VALUE$ + \             !URG KDC
4794: 70cb: !        BKPLI.FULL.FILE.CHNG$           + COMMA.VALUE$ + \             !URG KDC
4795: 70cb: !        BKPLI.INCREMENTAL.EXIST$(1)     + COMMA.VALUE$ + \             !URG KDC
4796: 70cb: !        BKPLI.INCREMENTAL.FILE.CHNG$(1) + COMMA.VALUE$ + \             !URG KDC
4797: 70cb: !        BKPLI.INCREMENTAL.EXIST$(2)     + COMMA.VALUE$ + \             !URG KDC
4798: 70cb: !        BKPLI.INCREMENTAL.FILE.CHNG$(2) + COMMA.VALUE$ + \             !URG KDC
4799: 70cb: !        BKPLI.INCREMENTAL.EXIST$(3)     + COMMA.VALUE$ + \             !URG KDC
4800: 70cb: !        BKPLI.INCREMENTAL.FILE.CHNG$(3) + COMMA.VALUE$ + \             !URG KDC
4801: 70cb: !        BKPLI.INCREMENTAL.EXIST$(4)     + COMMA.VALUE$ + \             !URG KDC
4802: 70cb: !        BKPLI.INCREMENTAL.FILE.CHNG$(4) + COMMA.VALUE$ + \             !URG KDC
4803: 70cb: !        BKPLI.INCREMENTAL.EXIST$(5)     + COMMA.VALUE$ + \             !URG KDC
4804: 70cb: !        BKPLI.INCREMENTAL.FILE.CHNG$(5) + COMMA.VALUE$ + \             !URG KDC
4805: 70cb: !        BKPLI.INCREMENTAL.EXIST$(6)     + COMMA.VALUE$ + \             !URG KDC
4806: 70cb: !        BKPLI.INCREMENTAL.FILE.CHNG$(6) + COMMA.VALUE$                 !URG KDC
4807: 70cb: !
4808: 70cb: !RETURN                                                                 !URG  
4809: 70cb: !!KDC END CHANGE BLOCK                                                  !URG
4810: 70cb: !
4811: 70cb: !ERROR.DIR.READ1:                                                       !URG 
4812: 70cb: !    STATUS.MSG$ = STATUS.TEXT.ERROR$(26)                               !URG KDC
4813: 70cb: !    FILE.OPERATION$ = "R"               ! File read                    !URG  
4814: 70cb: !    GOSUB FILE.ERROR.EXIT                                              !URG
4815: 70cb: !
4816: 70cb: !BKPEXCL.OPEN.COMP1:                                                    !URG
4817: 70cb: !    STATUS.MSG$ = STATUS.TEXT.ERROR$(27)                               !URG KDC
4818: 70cb: !    FILE.OPERATION$ = "O"               ! File open                    !URG
4819: 70cb: !    GOSUB FILE.ERROR.EXIT                                              !URG 
4820: 70cb: !
4821: 70cb: !RETURN                                                                 !URG
4822: 70cb: !
4823: 70cb: !!HDC START BLOCK                                                       !URG 
4824: 70cb: \***********************************************************************
4825: 70cb: \*
4826: 70cb: \*    IS.ARCHIVE.FLAG.ON: This subroutine checks the ARCHIVE flag of the!OJK
4827: 70cb: \*                        file BKPLIST.COMP.FILENAME$
4828: 70cb: \*
4829: 70cb: \***********************************************************************
4830: 70cb: !Commenting the subroutine as its used for checking the file change     !URG
4831: 70cb: !status.                                                                !URG
4832: 70cb: !IS.ARCHIVE.FLAG.ON:                                                    !URG
4833: 70cb: !
4834: 70cb: !    IS.ARCHIVE.ON = FALSE                                              !URG 
4835: 70cb: !
4836: 70cb: !    ! Ignore if file contains '-'
4837: 70cb: !    IF MATCH("-",BKPLIST.COMP.FILENAME$,1) = XBACK.ZERO% THEN BEGIN    !URG
4838: 70cb: !        ! Storing the Archive values
4839: 70cb: !        CALL OSSHELL("FSET " + BKPLIST.COMP.FILENAME$ + " > " + \      !URG OJK
4840: 70cb: !                     DIR.OUT$ + " >>* " + DIR.OUT$)                    !URG OJK
4841: 70cb: !    ENDIF ELSE BEGIN                                                   !URG
4842: 70cb: !        RETURN                                                         !URG  
4843: 70cb: !    ENDIF                                                              !URG
4844: 70cb: !
4845: 70cb: !    IF END # TEMP.SESS.NUM% THEN ARCHIVE.ERROR                         !URG
4846: 70cb: !    OPEN DIR.OUT$ AS TEMP.SESS.NUM%                                    !URG 
4847: 70cb: !    ! Setting the temporary file open 
4848: 70cb: !    TEMP.OPEN = TRUE                                                   !URG
4849: 70cb: !
4850: 70cb: !    ! Ignoring the first line
4851: 70cb: !    READ # TEMP.SESS.NUM%; LINE DIR.VALUE$                             !URG
4852: 70cb: !    READ # TEMP.SESS.NUM%; LINE DIR.VALUE$                             !URG
4853: 70cb: !
4854: 70cb: !    ! Match found
4855: 70cb: !    IF MATCH("A=ON", DIR.VALUE$, 1) <> XBACK.ZERO% THEN BEGIN          !URG 
4856: 70cb: !        IS.ARCHIVE.ON = TRUE                                           !URG 
4857: 70cb: !    ENDIF                                                              !URG
4858: 70cb: !
4859: 70cb: !    !---------------------------------------!
4860: 70cb: !    ! Closing the session. No deallocation, !
4861: 70cb: !    ! as the session will be reused         !
4862: 70cb: !    !---------------------------------------!
4863: 70cb: !    CLOSE TEMP.SESS.NUM%                                               !URG
4864: 70cb: !    ! Setting the temporary file close                           
4865: 70cb: !    TEMP.OPEN = FALSE                                                  !URG 
4866: 70cb: !
4867: 70cb: !RETURN                                                                 !URG
4868: 70cb: !
4869: 70cb: !ARCHIVE.ERROR:                                                         !URG
4870: 70cb: !
4871: 70cb: !    IS.ARCHIVE.ON = TRUE                                               !URG  
4872: 70cb: !
4873: 70cb: !RETURN                                                                 !URG
4874: 70cb: !! HDC END BLOCK                                                        !URG
4875: 70cb: \***********************************************************************
4876: 70cb: \*
4877: 70cb: \*    BKPLIST.FULL: This Subroutine performs the BACKUP process for the !KDC
4878: 70cb: \*                  for Full day run.                                   !KDC
4879: 70cb: \*
4880: 70cb: \***********************************************************************
4881: 70cb: BKPLIST.FULL:                                                           !KDC
4882: 70db: 
4883: 70db:     IF END # TEMP.SESS.NUM.2% THEN ERROR.DIR.READ
4884: 70f4: 
4885: 70f4:     ! Setting the BKPLIST file variables
4886: 70f4: !    BKPLI.FULL.EXIST$     = XBACK.YES$                                 !URG OJK
4887: 70f4: !    BKPLI.FULL.FILE.CHNG$ = XBACK.YES$                                 !URG OJK
4888: 70f4: !    DIM BKPLI.INCREMENTAL.EXIST$(0)                                    !URG KDC
4889: 70f4: !    DIM BKPLI.INCREMENTAL.FILE.CHNG$(0)                                !URG KDC
4890: 70f4: !    DIM BKPLI.INCREMENTAL.EXIST$(6)                                    !URG KDC
4891: 70f4: !    DIM BKPLI.INCREMENTAL.FILE.CHNG$(6)                                !URG KDC
4892: 70f4: 
4893: 70f4:     FILE.OPERATION$     = "R"                                           !CJK
4894: 710b:     CURRENT.REPORT.NUM% = TEMP.REPORT.NUM.2%                            !CJK
4895: 711d: 
4896: 711d:     !---------------------------------!
4897: 711d:     ! Looping until file name present !
4898: 711d:     !---------------------------------!
4899: 711d:     WHILE FILE.PRESENT
4900: 7128:         BKPEXCL.RUN = TRUE
4901: 7136:         READ # TEMP.SESS.NUM.2%; LINE DIR.SEC.VALUE$
4902: 7152: 
4903: 7152:         !------------------------------------!
4904: 7152:         ! Making sure length value is non    !
4905: 7152:         ! zero and it's not a directory      !
4906: 7152:         !------------------------------------!
4907: 7152:         IF LEN(DIR.SEC.VALUE$)              <> XBACK.ZERO%         AND \
4908: 71a4:            MATCH("<DIR>", DIR.SEC.VALUE$, 1) = XBACK.ZERO%             \
4909: 71a4:            THEN BEGIN
4910: 71a4:             FILE.NAME.VALUE$ = LEFT$(DIR.SEC.VALUE$,8)   ! File name
4911: 71c6:             FILE.EXT.VALUE$  = MID$(DIR.SEC.VALUE$,10,3) ! and extension
4912: 71e8:             CALL TRIM(FILE.NAME.VALUE$)
4913: 71fc:             CALL TRIM(FILE.EXT.VALUE$)
4914: 7210: 
4915: 7210:             ! Complete file name regardless of extension                !KDC
4916: 7210:             IF FILE.EXT.VALUE$ <> STRING$(3," ") THEN BEGIN ! Extension !KDC
4917: 7235:                 DIR.FILE.NAME$ = FILE.NAME.VALUE$ + "." + \ ! Present   !KDC
4918: 725f:                                  FILE.EXT.VALUE$                        !KDC
4919: 725f:             ENDIF ELSE BEGIN                                            !KDC
4920: 7267:                 DIR.FILE.NAME$ = FILE.NAME.VALUE$                       !KDC
4921: 7280:             ENDIF                                                       !KDC
4922: 7288: 
4923: 7288:             ! If exclude file present
4924: 7288:             IF EXCLUDE.PRESENT THEN BEGIN
4925: 729a:                
4926: 729a:                 !Set the index value to 1                               !TSM
4927: 729a:                 BKPEXCL.INDEX% = 1                                      !TSM
4928: 72a8:                 
4929: 72a8:               !Commenting out the code as it is no longer used          !TSM
4930: 72a8:                !---------------------------------------------!
4931: 72a8:                ! Closing the existing session as it has been !
4932: 72a8:                ! opened in APPEND mode                       !
4933: 72a8:                !---------------------------------------------!
4934: 72a8:                !CLOSE BKPEXCL.SESS.NUM%                                 !TSM
4935: 72a8:                !BKPEXCL.OPEN = FALSE                                    !TSM
4936: 72a8:                 
4937: 72a8:                !FILE.OPERATION$     = "O"                               !TSM
4938: 72a8:                !CURRENT.REPORT.NUM% = BKPEXCL.REPORT.NUM%               !TSM
4939: 72a8:                !
4940: 72a8:                !!--------------------------------------------!
4941: 72a8:                !! Opening and reading BKPEXCL to avoid       !
4942: 72a8:                !! exclusion list file to be added in BKPLIST !
4943: 72a8:                !!--------------------------------------------!
4944: 72a8:                !IF END # BKPEXCL.SESS.NUM% THEN BKPEXCL.OPEN.COMP       !TSM
4945: 72a8:                !OPEN BKPEXCL.FILE.NAME$ AS BKPEXCL.SESS.NUM%            !TSM
4946: 72a8:                !IF END # BKPEXCL.SESS.NUM% THEN BKPEXCL.READ.COMP       !TSM
4947: 72a8:                !
4948: 72a8:                !BKPEXCL.OPEN        = TRUE                              !TSM
4949: 72a8:                !FILE.OPERATION$     = "R"                               !TSM
4950: 72a8:                !CURRENT.REPORT.NUM% = BKPEXCL.REPORT.NUM%               !TSM
4951: 72a8:                !
4952: 72a8:                !WHILE BKPEXCL.RUN                                       !TSM
4953: 72a8:                !    READ # BKPEXCL.SESS.NUM%; LINE BKPEXCL.VALUE$       !TSM
4954: 72a8:                !    IF UCASE$(BKPEXCL.VALUE$) = UCASE$(DIR.FILE.NAME$) \!TSM
4955: 72a8:                !    THEN BEGIN                                          !TSM
4956: 72a8:                !        BKPEXCL.RUN = FALSE                             !TSM
4957: 72a8:                !    ENDIF                                               !TSM
4958: 72a8:                !WEND                                                    !TSM
4959: 72a8:                !BKPEXCL.READ.COMP:                                      !TSM
4960: 72a8:                 
4961: 72a8:                !FILE.OPERATION$     = "O"                               !TSM
4962: 72a8:                !CURRENT.REPORT.NUM% = BKPEXCL.REPORT.NUM%               !TSM
4963: 72a8:                 
4964: 72a8:                 !Iterate until a match found or specifided exclude array!TSM
4965: 72a8:                 !index reached                                          !TSM
4966: 72a8: 
4967: 72a8:                 WHILE BKPEXCL.INDEX% < BKPEXCL.ARRAY.INDEX%             !TSM
4968: 72b3:                     BKPEXCL.VALUE$ = BKPEXCL.ARRAY$(BKPEXCL.INDEX%)     !TSM
4969: 72da:                     IF UCASE$(BKPEXCL.VALUE$) = UCASE$(DIR.FILE.NAME$) \!TSM
4970: 7311:                                                              THEN BEGIN !TSM
4971: 7311:                         BKPEXCL.RUN = FALSE                             !TSM
4972: 731f:                         BKPEXCL.INDEX% = BKPEXCL.ARRAY.INDEX%           !TSM
4973: 732d:                     ENDIF                                               !TSM
4974: 7335:                     !Increment array index                              !TSM
4975: 7335:                     BKPEXCL.INDEX% = BKPEXCL.INDEX% +1                  !TSM
4976: 7341:                 WEND                                                    !TSM
4977: 7355: 
4978: 7355:              !----------------------------------------------!
4979: 7355:              ! If exclude file is not matched  with current !
4980: 7355:              ! file name, add the file to BKPLIST           !
4981: 7355:              !----------------------------------------------!
4982: 7355:              !  No need to add the files in to BKPLIST now as a final   !URG
4983: 7355:              !  Processing of array in to the text file will happen     !URG
4984: 7355:              ! IF BKPEXCL.RUN THEN BEGIN                                !URG
4985: 7355:              !     BKPLI.FILENAME$ = BKPSCRPT.DIRECTORY$            +   !URG
4986: 7355:              !                       DIR.FILE.NAME$                     !URG
4987: 7355:              !     FILE.OPERATION$ = "W"                                !URG
4988: 7355:              !     FILE.RC2%       = WRITE.BKPLI                        !URG
4989: 7355:              !      GOSUB CHECK.FILE.RC2                                !URG 
4990: 7355: 
4991: 7355:              !     Set OFF Archive attribute
4992: 7355:              !      CALL OSSHELL("FSET " + BKPLI.FILENAME$ + \          !URG KDC
4993: 7355:              !               " -A=OFF >> " + DIR.OUT$   + \             !URG KDC
4994: 7355:              !               " >>* " + DIR.OUT$  )                      !URG KDC
4995: 7355: 
4996: 7355:               !  ENDIF                                                  !URG
4997: 7355: 
4998: 7355:                 !---------------------------------------!
4999: 7355:                 ! Directly add the files to the BKPLIST !
5000: 7355:                 ! as no exclude list present            !
5001: 7355:                 !---------------------------------------!
5002: 7355:              ! ENDIF ELSE BEGIN                                         !URG
5003: 7355:              !    BKPLI.FILENAME$ = BKPSCRPT.DIRECTORY$ + DIR.FILE.NAME$!URG
5004: 7355:              !    FILE.OPERATION$ = "W"                                 !URG
5005: 7355:              !    FILE.RC2%       = WRITE.BKPLI                         !URG
5006: 7355:              !    GOSUB CHECK.FILE.RC2                                  !URG
5007: 7355:              ! Set OFF Archive attribute                                !URG
5008: 7355: 
5009: 7355:              ! commenting out as we are not setting incremental any       
5010: 7355:              ! more                                                     !URG
5011: 7355: 
5012: 7355:              !    CALL OSSHELL("FSET " + BKPLI.FILENAME$ + \            !URG KDC
5013: 7355:              !                 " -A=OFF >> " + DIR.OUT$ + \             !URG KDC
5014: 7355:              !                 " >>* " + DIR.OUT$  )                    !URG KDC
5015: 7355: 
5016: 7355:             ENDIF
5017: 735f: 
5018: 735f:         ENDIF ELSE BEGIN
5019: 7367:             !----------------------------------!
5020: 7367:             ! When end of file listing reached !
5021: 7367:             !----------------------------------!
5022: 7367:             IF LEN(DIR.SEC.VALUE$) = XBACK.ZERO% THEN BEGIN
5023: 7385:                 FILE.PRESENT = FALSE
5024: 7393:             ENDIF
5025: 739b:         ENDIF
5026: 73a3:     WEND
5027: 73b5: 
5028: 73b5: RETURN
5029: 73c5: 
5030: 73c5: ERROR.DIR.READ:
5031: 73d5:     STATUS.MSG$ = STATUS.TEXT.ERROR$(26)                                !KDC
5032: 73fa:     FILE.OPERATION$ = "R"               ! File read
5033: 7411:     GOSUB FILE.ERROR.EXIT
5034: 7423: 
5035: 7423: BKPEXCL.OPEN.COMP:
5036: 742b:     STATUS.MSG$ = STATUS.TEXT.ERROR$(27)                                !KDC
5037: 7450:     FILE.OPERATION$ = "O"               ! File open
5038: 7467:     GOSUB FILE.ERROR.EXIT
5039: 7479: 
5040: 7479: RETURN
5041: 7489: 
5042: 7489: \***********************************************************************
5043: 7489: \*
5044: 7489: \*   BACKUP.PROCESS: This Subroutine does the backup archiving process
5045: 7489: \*                   using ADXZUDIR utility. If any files are missed to
5046: 7489: \*                   archive, then those files will be manually copied
5047: 7489: \*                   to backup directory and those details will be
5048: 7489: \*                   added to BKPFAIL.
5049: 7489: \*
5050: 7489: \***********************************************************************
5051: 7489: BACKUP.PROCESS:
5052: 7499: 
5053: 7499:     STATUS.MSG$ = BKPSCRPT.DIRECTORY$ + STATUS.TEXT.MSG$(49)            !KDC
5054: 74c9:     GOSUB DISPLAY.STATUS.MSG
5055: 74db:     GOSUB LOG.STATUS.MSG
5056: 74ed: 
5057: 74ed:     !--------------------------------------------------!
5058: 74ed:     ! Closing the session. No deallocation, as the     !
5059: 74ed:     ! session will be reused. De-allocation will       !
5060: 74ed:     ! happen once the complete backup process finishes !
5061: 74ed:     !--------------------------------------------------!
5062: 74ed:     CLOSE BKPEXCL.SESS.NUM%
5063: 74fe: 
5064: 74fe:     !---------------------------------------!
5065: 74fe:     ! Setting as FALSE to create a new file !
5066: 74fe:     ! for next directory backup             !
5067: 74fe:     !---------------------------------------!
5068: 74fe:     BKPEXCL.OPEN = FALSE
5069: 750c: 
5070: 750c:     ! Using BKPEXCL and archiving the files
5071: 750c:     CALL OSSHELL("ADXZUDIR -c -XL:" + BKPEXCL.FILE.NAME$ + " "   + \
5072: 755b:                  BKPSCRPT.OUT.FILE.NAME$ + ".ZIP" + " "          + \
5073: 755b:                  BKPSCRPT.DIRECTORY$ + " > " + XBKTEMP.LOG$ )
5074: 755b: 
5075: 755b:     ! Renaming the zip file after archiving
5076: 755b:     FILE.RC2% = RENAME ((BKPSCRPT.OUT.FILE.NAME$ + "." + EXT.MDD$),    \
5077: 75ac:                         (BKPSCRPT.OUT.FILE.NAME$ + ".ZIP"))
5078: 75ac: 
5079: 75ac:     ! If rename fails
5080: 75ac:     IF NOT FILE.RC2% THEN BEGIN
5081: 75bf:         STATUS.MSG$ = BKPSCRPT.OUT.FILE.NAME$ + STATUS.TEXT.ERROR$(28)  !OJK
5082: 75ef:         GOSUB DISPLAY.STATUS.MSG
5083: 7601:         GOSUB LOG.STATUS.MSG
5084: 7613:     ENDIF
5085: 761b: 
5086: 761b:     !---------------------------------------!
5087: 761b:     ! Closing the session. No deallocation, !
5088: 761b:     ! as the session will be reused         !
5089: 761b:     !---------------------------------------!
5090: 761b:     CLOSE TEMP.SESS.NUM.2%
5091: 762c:     ! Setting the temporary file close
5092: 762c:     TEMP.2.OPEN = FALSE                                                 !FJK
5093: 763a: 
5094: 763a:     IF END # TEMP.SESS.NUM.2% THEN XBKLOG.READ.COMP
5095: 7653:     OPEN XBKTEMP.LOG$ AS TEMP.SESS.NUM.2%
5096: 7674: 
5097: 7674:     ! Setting the temporary file open
5098: 7674:     TEMP.2.OPEN = TRUE                                                  !FJK
5099: 7682: 
5100: 7682:     VALUE.PRESENT = TRUE
5101: 7690: 
5102: 7690:     ! Identifying the directory to be copied
5103: 7690:     SLASH.POSITION% = MATCH("\\", BKPSCRPT.OUT.FILE.NAME$, 4)
5104: 76ae: 
5105: 76ae:     ! Extracting the directory to be copied
5106: 76ae:     BKPSCRPT.OUT.FILE.NAME$ = \
5107: 76d3:             LEFT$(BKPSCRPT.OUT.FILE.NAME$,SLASH.POSITION%)
5108: 76d3: 
5109: 76d3:     FILE.OPERATION$     = "R"                                           !CJK
5110: 76ea:     CURRENT.REPORT.NUM% = TEMP.REPORT.NUM.2%                            !CJK
5111: 76fc: 
5112: 76fc:     !---------------------------------!
5113: 76fc:     ! Checking for any archive errors !
5114: 76fc:     !---------------------------------!
5115: 76fc:     WHILE VALUE.PRESENT
5116: 7707:         FILE.MISSING = FALSE                                               !SMH
5117: 7715:         READ # TEMP.SESS.NUM.2%; LINE XBKLOG.VALUE$
5118: 7731: 
5119: 7731:         ! Checking for errors
5120: 7731:         FILE.POSITION% = MATCH("Error adding file",XBKLOG.VALUE$, 1)
5121: 774f: 
5122: 774f:         !----------------------!
5123: 774f:         ! If copy errors found !
5124: 774f:         !----------------------!
5125: 774f:         IF FILE.POSITION% <> XBACK.ZERO% THEN BEGIN
5126: 7764: 
5127: 7764:             FILE.NAME.VALUE$ = MID$(XBKLOG.VALUE$,(FILE.POSITION% +    \!FJK
5128: 779f:                                     18), (LEN(XBKLOG.VALUE$) -         \
5129: 779f:                                     FILE.POSITION% - 17))
5130: 779f:             FSET.ON = TRUE
5131: 77ad: 
5132: 77ad:             !-------------------------------------------!
5133: 77ad:             ! Checking the LOCK mode of the file before !
5134: 77ad:             ! using FSET command                        !
5135: 77ad:             !-------------------------------------------!
5136: 77ad:             BKPFAIL.FILE$ = BKPSCRPT.DIRECTORY$  + FILE.NAME.VALUE$
5137: 77d1:             
5138: 77d1:             !----------------------------------------------!                !SMH
5139: 77d1:             ! Sets variable open.bkpfailfile to true so    !                !SMH
5140: 77d1:             ! if the open fails its handled by a specific  !                !SMH
5141: 77d1:             ! error routine, then when it resumes/continue !                !SMH
5142: 77d1:             ! it sets it to false so that error routine    !                !SMH
5143: 77d1:             ! isnt used else where.                        !                !SMH
5144: 77d1:             !----------------------------------------------!                !SMH
5145: 77d1:             OPEN.BKPFAILFILE = TRUE                                         !SMH
5146: 77df:             OPEN BKPFAIL.FILE$ AS TEMP.SESS.NUM% LOCKED                     
5147: 7800:             
5148: 7800:             OPEN.BKPFAILFILE = FALSE                                        !SMH
5149: 780e:             
5150: 780e:             !------------------------------------!                          !SMH
5151: 780e:             ! File.Missing set to false in error !                          !SMH
5152: 780e:             ! routine to catch missing file      !                          !SMH
5153: 780e:             !------------------------------------!                          !SMH
5154: 780e:             
5155: 780e:             IF NOT FILE.MISSING = TRUE THEN BEGIN                           !SMH
5156: 7822:             
5157: 7822:                 TEMP.OPEN = TRUE                                            !HDC
5158: 7830:                                                    
5159: 7830:                 CLOSE TEMP.SESS.NUM%
5160: 7841:                 TEMP.OPEN = FALSE                                           !HDC
5161: 784f:                      
5162: 784f:                 IF FSET.ON THEN BEGIN
5163: 7861:                     ! Making sure that the failed file is not current
5164: 7861:                     ! BKPLIST file
5165: 7861:                     IF BKPFAIL.FILE$ <> BKPLI.FILE.NAME$ THEN BEGIN         !NJK
5166: 7886:                         ! C directory file will be backed up in D:/XDISKIMG/!OJK
5167: 7886:                         IF UCASE$(LEFT$(BKPSCRPT.DIRECTORY$,1)) = "C" \     !OJK
5168: 78cb:                         THEN BEGIN                                          !OJK
5169: 78cb:                             CALL ADXCOPYF(ADXSERVE.RC%,BKPFAIL.FILE$,     \ !OJK
5170: 7937:                                           "D:\XDISKIMG\" +                \ !OJK
5171: 7937:                                           FILE.NAME.VALUE$ + "." +        \ !OJK
5172: 7937:                                           EXT.MDD$,0,1,0)                   !OJK
5173: 7937:                             GOSUB WRITE.BKPFAILC                            !OJK
5174: 794c:                         ENDIF ELSE BEGIN                                    !OJK
5175: 7954:                         ! D directory file will be backed up in C:/XDISKIMG/!OJK
5176: 7954:                             CALL ADXCOPYF(ADXSERVE.RC%,BKPFAIL.FILE$,     \ !OJK
5177: 79c0:                                           "C:\XDISKIMG\" +                \ !OJK
5178: 79c0:                                           FILE.NAME.VALUE$ + "." +        \ !OJK
5179: 79c0:                                           EXT.MDD$,0,1,0)                   !OJK
5180: 79c0:                             GOSUB WRITE.BKPFAILD                            !OJK
5181: 79d2:                         ENDIF
5182: 79da:                     ENDIF                                                   !NJK
5183: 79e4:                 ENDIF ELSE BEGIN
5184: 79ec:                     STATUS.MSG$ = BKPFAIL.FILE$ + STATUS.TEXT.ERROR$(29)    !KDC
5185: 7a1c:                     GOSUB DISPLAY.STATUS.MSG
5186: 7a2e:                     GOSUB LOG.STATUS.MSG
5187: 7a40:                 ENDIF
5188: 7a48:             
5189: 7a48:                 !------------------------------------!
5190: 7a48:                 ! If empty directory archiving found !
5191: 7a48:                 !------------------------------------!
5192: 7a48:                 FILE.POSITION% = MATCH("0x80104010",XBKLOG.VALUE$,1)
5193: 7a66:         
5194: 7a66:                 ! If no files present
5195: 7a66:                 IF FILE.POSITION% <> XBACK.ZERO%                            OR \
5196: 7aac:                    MATCH("No matching files found", XBKLOG.VALUE$, 1)       <> \
5197: 7aac:                    XBACK.ZERO% THEN BEGIN
5198: 7aac:                     STATUS.MSG$ = BKPSCRPT.DIRECTORY$ + STATUS.TEXT.ERROR$(30)  !OJK
5199: 7adc:                     GOSUB DISPLAY.STATUS.MSG
5200: 7aee:                     GOSUB LOG.STATUS.MSG
5201: 7b00:         
5202: 7b00:                     STATUS.MSG$ = STATUS.TEXT.ERROR$(31)                        !KDC
5203: 7b25:                     GOSUB DISPLAY.STATUS.MSG
5204: 7b37:                     GOSUB LOG.STATUS.MSG
5205: 7b49:                     VALUE.PRESENT = FALSE
5206: 7b57:                 ENDIF
5207: 7b5f:             ENDIF                                                               !SMH
5208: 7b67:         ENDIF
5209: 7b6f:     
5210: 7b6f:     WEND
5211: 7b81: 
5212: 7b81: XBKLOG.READ.COMP:
5213: 7b91: 
5214: 7b91:     ! Deleting the file as no longer needed
5215: 7b91:     FILE.OPERATION$ = "D"                                               !CJK
5216: 7ba8:     
5217: 7ba8:     DELETE TEMP.SESS.NUM.2%
5218: 7bb9:     TEMP.2.OPEN = FALSE                                                 !FJK
5219: 7bc7: 
5220: 7bc7:     FILE.OPERATION$     = "C"                                           !CJK
5221: 7bde:     CURRENT.REPORT.NUM% = BKPEXCL.REPORT.NUM%                           !CJK
5222: 7bf0:     !--------------------------------------!                            !BJK
5223: 7bf0:     ! create the BKPEXCL file for next run !                            !BJK
5224: 7bf0:     !--------------------------------------!                            !BJK
5225: 7bf0:     CREATE POSFILE BKPEXCL.FILE.NAME$ AS BKPEXCL.SESS.NUM% LOCAL        !OJK
5226: 7c10:     BKPEXCL.OPEN = TRUE                                                 !FJK
5227: 7c1e: 
5228: 7c1e:     !Reset the exclude array index                                      !TSM
5229: 7c1e:     BKPEXCL.ARRAY.INDEX% = 1                                            !TSM
5230: 7c2c:     !Reset the complete exclude array index                             !TSM
5231: 7c2c:     BKPEXCL.COMP.INDEX%  = 1                                            !TSM 
5232: 7c3a: 
5233: 7c3a: RETURN
5234: 7c4a: 
5235: 7c4a: \***********************************************************************
5236: 7c4a: \*
5237: 7c4a: \*   WRITE.BKPFAILC: Writes failed file details to BKPFAILC.MDD         !OJK
5238: 7c4a: \*
5239: 7c4a: \***********************************************************************
5240: 7c4a: WRITE.BKPFAILC:                                                         !OJK
5241: 7c5a: 
5242: 7c5a:     CURRENT.REPORT.NUM% = BKPFAILC.REPORT.NUM%                          !OJK
5243: 7c6c:     GOSUB DETERMINE.DIST.TYPE
5244: 7c7e: 
5245: 7c7e:     BKPFAIL.FILE$ = BKPFAIL.FILE$ + COMMA.VALUE$ + DIST.TYPE$ + CRLF$
5246: 7cb2:     BKPFAIL.FORM$ = "C" + STR$(LEN(BKPFAIL.FILE$)) ! form string
5247: 7ce5: 
5248: 7ce5:     IF END # BKPFAILC.SESS.NUM% THEN WRITE.BKPFAILC.ERROR               !OJK
5249: 7cfe:     WRITE FORM BKPFAIL.FORM$; # BKPFAILC.SESS.NUM%; BKPFAIL.FILE$       !OJK
5250: 7d26: 
5251: 7d26: RETURN
5252: 7d36: 
5253: 7d36: WRITE.BKPFAILC.ERROR:                                                   !OJK
5254: 7d46:     STATUS.MSG$ = STATUS.TEXT.ERROR$(32)
5255: 7d6b:     FILE.OPERATION$ = "W"       ! File write
5256: 7d82:     GOSUB FILE.ERROR.EXIT
5257: 7d94: 
5258: 7d94: RETURN
5259: 7da4: 
5260: 7da4: \***********************************************************************!OJK
5261: 7da4: \*                                                                      !OJK
5262: 7da4: \*   WRITE.BKPFAILD: Writes failed file details to BKPFAILD.MDD         !OJK
5263: 7da4: \*                                                                      !OJK
5264: 7da4: \***********************************************************************!OJK
5265: 7da4: WRITE.BKPFAILD:                                                         !OJK
5266: 7db4:                                                                         !OJK
5267: 7db4:     CURRENT.REPORT.NUM% = BKPFAILD.REPORT.NUM%                          !OJK
5268: 7dc6:     GOSUB DETERMINE.DIST.TYPE                                           !OJK
5269: 7dd8:                                                                         !OJK
5270: 7dd8:     BKPFAIL.FILE$ = BKPFAIL.FILE$ + COMMA.VALUE$ + DIST.TYPE$ + CRLF$   !OJK
5271: 7e0c:     BKPFAIL.FORM$ = "C" + STR$(LEN(BKPFAIL.FILE$)) ! form string        !OJK
5272: 7e3f:                                                                         !OJK
5273: 7e3f:     IF END # BKPFAILD.SESS.NUM% THEN WRITE.BKPFAILD.ERROR               !OJK
5274: 7e58:     WRITE FORM BKPFAIL.FORM$; # BKPFAILD.SESS.NUM%; BKPFAIL.FILE$       !OJK
5275: 7e80:                                                                         !OJK
5276: 7e80: RETURN                                                                  !OJK
5277: 7e90:                                                                         !OJK
5278: 7e90: WRITE.BKPFAILD.ERROR:                                                   !OJK
5279: 7ea0:     STATUS.MSG$ = STATUS.TEXT.ERROR$(32)                                !OJK
5280: 7ec5:     FILE.OPERATION$ = "W"       ! File write                            !OJK
5281: 7edc:     GOSUB FILE.ERROR.EXIT                                               !OJK
5282: 7eee:                                                                         !OJK
5283: 7eee: RETURN                                                                  !OJK
5284: 7efe: 
5285: 7efe: \***********************************************************************
5286: 7efe: \*
5287: 7efe: \*   DETERMINE.DIST.TYPE: This Subroutine checks the distribution type
5288: 7efe: \*                        of the BKPFAIL file and stores it.
5289: 7efe: \*
5290: 7efe: \***********************************************************************
5291: 7efe: DETERMINE.DIST.TYPE:
5292: 7f0e: 
5293: 7f0e:     CALL OSSHELL("dir -d " + BKPFAIL.FILE$ + " > " + DIR.SEC.OUT$ )     !OJK
5294: 7f41: 
5295: 7f41:     FILE.OPERATION$     = "O"                                           !CJK
5296: 7f58:     CURRENT.REPORT.NUM% = TEMP.REPORT.NUM%                              !CJK
5297: 7f6a: 
5298: 7f6a:     IF END # TEMP.SESS.NUM% THEN DIST.ERROR
5299: 7f83:     OPEN DIR.SEC.OUT$ AS TEMP.SESS.NUM%
5300: 7fa4: 
5301: 7fa4:     ! Setting the temporary file open
5302: 7fa4:     TEMP.OPEN       = TRUE                                              !FJK
5303: 7fb2:     FILE.OPERATION$ = "R"                                               !CJK
5304: 7fc9: 
5305: 7fc9:     ! Ignoring the first 4 lines
5306: 7fc9:     READ # TEMP.SESS.NUM%; LINE DIR.VALUE$
5307: 7fe5:     READ # TEMP.SESS.NUM%; LINE DIR.VALUE$
5308: 8001:     READ # TEMP.SESS.NUM%; LINE DIR.VALUE$
5309: 801d:     READ # TEMP.SESS.NUM%; LINE DIR.VALUE$
5310: 8039: 
5311: 8039:     READ # TEMP.SESS.NUM%; LINE DIR.VALUE$
5312: 8055: 
5313: 8055:     ! Initiating to NULL
5314: 8055:     DIST.TYPE$ = XBACK.NULL$
5315: 806e: 
5316: 806e:     ! Storing the Distribution type
5317: 806e:     DIST.TYPE$ = MID$(DIR.VALUE$,26,1)                                  !NJK
5318: 8090: 
5319: 8090:     DELETE TEMP.SESS.NUM%                                               !FJK
5320: 80a1: 
5321: 80a1:     ! Setting the temporary file close
5322: 80a1:     TEMP.OPEN = FALSE                                                   !FJK
5323: 80af: 
5324: 80af: RETURN
5325: 80bf: 
5326: 80bf: DIST.ERROR:
5327: 80cf: 
5328: 80cf:     DIST.TYPE$ = "1"        ! Local by default
5329: 80e4: 
5330: 80e4: RETURN
5331: 80f4: 
5332: 80f4: \***********************************************************************
5333: 80f4: \*
5334: 80f4: \*   CREATE.UPDATED.BKPLIST: This Subroutine creates the updated
5335: 80f4: \*                           BKPLIST after deleting the existing
5336: 80f4: \*                           BKPLIST file.
5337: 80f4: \*
5338: 80f4: \***********************************************************************
5339: 80f4: 
5340: 80f4: !Commenting out the subroutine which creates updated backup list file    !URG
5341: 80f4: !CREATE.UPDATED.BKPLIST:                                                 !URG
5342: 80f4: 
5343: 80f4: !    ! Closing the BKPLIST session                                       !URG
5344: 80f4: !    CLOSE BKPLI.SESS.NUM%                                               !URG NJK
5345: 80f4: !    BKPLI.OPEN  = FALSE                                                 !URG NJK
5346: 80f4: 
5347: 80f4: !    ! if the day is the Full backup day                                 !URG KDC
5348: 80f4: !   ! IF F13.DAY$ <> FULL.DAY$ THEN BEGIN                                !URG KDC
5349: 80f4: 
5350: 80f4: !        STATUS.MSG$ = STATUS.TEXT.MSG$(50)                              !URG KDC
5351: 80f4: !        GOSUB DISPLAY.STATUS.MSG                                        !URG
5352: 80f4: !        GOSUB LOG.STATUS.MSG                                            !URG
5353: 80f4: 
5354: 80f4: !        FILE.OPERATION$     = "O"                                       !URG CJK
5355: 80f4: !        CURRENT.REPORT.NUM% = BKPLI.REPORT.NUM%                         !URG CJK
5356: 80f4: 
5357: 80f4: !        ! Deleting the existing BKPLIST file
5358: 80f4: !        IF END # BKPLI.SESS.NUM% THEN BKPLIST.NOT.PRESENT               !URG
5359: 80f4: !        OPEN BKPLI.FILE.NAME$ AS BKPLI.SESS.NUM% LOCKED                 !URG LDC
5360: 80f4: !        BKPLI.OPEN = TRUE                                               !URG GJK
5361: 80f4: 
5362: 80f4: !        FILE.OPERATION$ = "D"                                           !URG CJK
5363: 80f4: !        DELETE BKPLI.SESS.NUM%                                          !URG
5364: 80f4: 
5365: 80f4: !BKPLIST.NOT.PRESENT:                                                    !URG
5366: 80f4: !        ! At this point either the file is deleted or not present
5367: 80f4: !        BKPLI.OPEN = FALSE                                              !URG GJK
5368: 80f4: 
5369: 80f4: !        FILE.OPERATION$ = "C"                                           !URG CJK
5370: 80f4: 
5371: 80f4: !        ! Creating the new BKPLIST file
5372: 80f4: !        CREATE POSFILE BKPLI.FILE.NAME$ AS BKPLI.SESS.NUM%              \URG
5373: 80f4: !                                        LOCKED \                        !URG LDC
5374: 80f4: !                                        MIRRORED PERUPDATE              !URG
5375: 80f4: !        BKPLI.OPEN = TRUE                                               !URG FJK
5376: 80f4: 
5377: 80f4: !        IF END # BKPLI.SESS.NUM% THEN WRITE.BKPLIST.ERROR               !URG
5378: 80f4: 
5379: 80f4: !        !----------------------------------------------!
5380: 80f4: !        ! Extracting the file details from first array !
5381: 80f4: !        !----------------------------------------------!
5382: 80f4: !        FOR INDEX% = 1 TO ARRAY.INDEX%                                 !URG
5383: 80f4: 
5384: 80f4: !            BKPLIST.ARRAY$(INDEX%) = BKPLIST.ARRAY$(INDEX%) + CRLF$    !URG
5385: 80f4: 
5386: 80f4: !            ! Form string                                              !URG CJK
5387: 80f4: !            BKPLIST.FORM$ = "C" + STR$(LEN(BKPLIST.ARRAY$(INDEX%)))    !URG CJK
5388: 80f4: 
5389: 80f4: !            WRITE FORM BKPLIST.FORM$; # BKPLI.SESS.NUM%;               \URG
5390: 80f4: !                                    BKPLIST.ARRAY$(INDEX%)             !URG
5391: 80f4: 
5392: 80f4: !        NEXT INDEX%                                                    !URG
5393: 80f4: 
5394: 80f4: !        !----------------------------------!
5395: 80f4: !        ! Extracting the file details from !
5396: 80f4: !        ! second array if ON               !
5397: 80f4: !        !----------------------------------!
5398: 80f4: !        IF SECOND.ARRAY.ON THEN BEGIN                                  !URG
5399: 80f4: !            FOR SECOND.INDEX% = 1 TO ARRAY.SECOND.INDEX%               !URG
5400: 80f4: !
5401: 80f4: !                BKPLIST.SECOND.ARRAY$(SECOND.INDEX%) =                 \URG
5402: 80f4: !                        BKPLIST.SECOND.ARRAY$(SECOND.INDEX%)  + CRLF$  !URG
5403: 80f4: !
5404: 80f4: !                BKPLIST.FORM$ = "C" + \ ! Form                         !URG
5405: 80f4: !                                STR$(LEN(BKPLIST.SECOND.ARRAY$ \       !URG
5406: 80f4: !                                (SECOND.INDEX%)))                      !URG
5407: 80f4: 
5408: 80f4: !                WRITE FORM BKPLIST.FORM$; # BKPLI.SESS.NUM%;           \URG
5409: 80f4: !                                    BKPLIST.SECOND.ARRAY$(SECOND.INDEX%)
5410: 80f4: !            NEXT SECOND.INDEX%                                         !URG
5411: 80f4: !        ENDIF                                                          !URG
5412: 80f4: !        STATUS.MSG$ = STATUS.TEXT.MSG$(51)                             !URG KDC
5413: 80f4: !        GOSUB DISPLAY.STATUS.MSG                                       !URG
5414: 80f4: !        GOSUB LOG.STATUS.MSG                                           !URG
5415: 80f4: !
5416: 80f4: !   ! ENDIF                                                             !URG
5417: 80f4: 
5418: 80f4: !    !-------------------------------------------------------------!
5419: 80f4: !    ! Closing the BKPLIST session as processing has been complete !
5420: 80f4: !    !-------------------------------------------------------------!
5421: 80f4: !
5422: 80f4: !    CLOSE BKPLI.SESS.NUM%                                              !URG
5423: 80f4: !    CALL SESS.NUM.UTILITY ("C",BKPLI.SESS.NUM%,XBACK.NULL$)            !URG
5424: 80f4: !    BKPLI.OPEN = FALSE                                                 !URG
5425: 80f4: 
5426: 80f4: !RETURN                                                                 !URG
5427: 80f4: 
5428: 80f4: !WRITE.BKPLIST.ERROR:
5429: 80f4: !    STATUS.MSG$     = STATUS.TEXT.MSG$(52)                             !URG KDC
5430: 80f4: !    FILE.OPERATION$ = "W"               ! File write                   !URG
5431: 80f4: !    GOSUB FILE.ERROR.EXIT                                              !URG
5432: 80f4: !
5433: 80f4: !RETURN                                                                 !URG
5434: 80f4: 
5435: 80f4: \***********************************************************************
5436: 80f4: \*
5437: 80f4: \*   BACKUP.COMPLETION: This Subroutine uses IPCONFIG command to
5438: 80f4: \*                      determine the CF controller IP. And then FTP
5439: 80f4: \*                      all the current day archived files to CF
5440: 80f4: \*                      including BKPFAIL file.
5441: 80f4: \*
5442: 80f4: \***********************************************************************
5443: 80f4: BACKUP.COMPLETION:
5444: 8104: 
5445: 8104:     ! If controller is CE and CF is on LAN
5446: 8104:     IF MASTER$ = CE.CNTR$ AND ALT.MASTER.ON THEN BEGIN
5447: 8136: 
5448: 8136:         STATUS.MSG$ = STATUS.TEXT.MSG$(53)                              !KDC
5449: 815b:         GOSUB DISPLAY.STATUS.MSG
5450: 816d:         GOSUB LOG.STATUS.MSG
5451: 817f: 
5452: 817f:         CALL OSSHELL("IPCONFIG > " + DIR.OUT$)
5453: 81a6: 
5454: 81a6:         FILE.OPERATION$     = "O"                                       !CJK
5455: 81bd:         CURRENT.REPORT.NUM% = TEMP.REPORT.NUM%                          !CJK
5456: 81cf: 
5457: 81cf:         IF END # TEMP.SESS.NUM% THEN FTPOUT.ERR
5458: 81e8:         OPEN DIR.OUT$ AS TEMP.SESS.NUM%
5459: 8209: 
5460: 8209: 
5461: 8209:         ! Setting the temporary file open
5462: 8209:         TEMP.OPEN       = TRUE                                          !FJK
5463: 8217:         FILE.OPERATION$ = "R"                                           !CJK
5464: 822e: 
5465: 822e:         READ # TEMP.SESS.NUM%; LINE DIR.VALUE$
5466: 824a:         READ # TEMP.SESS.NUM%; LINE DIR.VALUE$
5467: 8266:         READ # TEMP.SESS.NUM%; LINE DIR.VALUE$
5468: 8282: 
5469: 8282:         ! IP configuration details
5470: 8282:         READ # TEMP.SESS.NUM%; LINE DIR.VALUE$
5471: 829e: 
5472: 829e:         !----------------------------------------------------------!
5473: 829e:         ! Deleting the session as temporary file is no more needed !
5474: 829e:         !----------------------------------------------------------!
5475: 829e:         FILE.OPERATION$ = "D"                                           !CJK
5476: 82b5:         DELETE TEMP.SESS.NUM%
5477: 82c6:         ! Setting the temporary file close
5478: 82c6:         TEMP.OPEN = FALSE                                               !FJK
5479: 82d4: 
5480: 82d4:         ! IP address of CE
5481: 82d4:         DIR.VALUE$ = MID$(DIR.VALUE$,5,20)
5482: 82f6:         CALL TRIM(DIR.VALUE$)
5483: 830a:         VALUE.PRESENT = TRUE
5484: 8318: 
5485: 8318:         INDEX% = XBACK.ZERO%
5486: 8327: 
5487: 8327:         !------------------------------------!
5488: 8327:         ! Extracting the IP address value    !
5489: 8327:         !------------------------------------!
5490: 8327:         IP.ADDRESS$ = XBACK.NULL$
5491: 8340: 
5492: 8340:         ! Extracting the IP address without last two digit
5493: 8340:         WHILE VALUE.PRESENT
5494: 834b:             INDEX% = LEN(DIR.VALUE$)
5495: 8365:             IF MID$(DIR.VALUE$,INDEX%,1) <> "." THEN BEGIN  ! Identify
5496: 8399:                 DIR.VALUE$ = LEFT$(DIR.VALUE$,(INDEX% - 1)) ! the DOT
5497: 83c0:             ENDIF ELSE BEGIN
5498: 83c8:                 VALUE.PRESENT = FALSE
5499: 83d6:             ENDIF
5500: 83de:         WEND
5501: 83f0: 
5502: 83f0:         ! Setting the CF IP address
5503: 83f0:         IP.ADDRESS$ = DIR.VALUE$ + "28"           ! Secondary controller
5504: 8410: 
5505: 8410:         FILE.OPERATION$ = "C"                                           !CJK
5506: 8427: 
5507: 8427:         CREATE FTP.FILE.NAME$ AS TEMP.SESS.NUM%
5508: 8448:         ! Setting the temporary file open
5509: 8448:         TEMP.OPEN   = TRUE                                              !OJK
5510: 8456: 
5511: 8456:         FTP.USER$   = "xbackup"                                         !OJK
5512: 846b:         FTP.SUCCESS = FALSE                                             !OJK
5513: 8479: 
5514: 8479:         !---------------------------------!
5515: 8479:         ! Sequence of FTP commands stored !
5516: 8479:         ! in FTP file for file transfer   !
5517: 8479:         !---------------------------------!
5518: 8479:         XBKPFTP.LINE$ = "open " + IP.ADDRESS$       ! Open command
5519: 8499:         GOSUB WRITE.XBKPFTP
5520: 84ab:         XBKPFTP.LINE$ = XBACK.NULL$
5521: 84c4:         GOSUB WRITE.XBKPFTP
5522: 84d6:         FTP.PASSWORD$ = FUNC.GET.FTP.PASSWORD.FOR$("xbackup")           !KDC
5523: 84f0:         XBKPFTP.LINE$ = "user " + FTP.USER$ + " " + FTP.PASSWORD$       !OJK
5524: 851c:         GOSUB WRITE.XBKPFTP
5525: 852e:         XBKPFTP.LINE$ = "bin"                       ! Binary command
5526: 8543:         GOSUB WRITE.XBKPFTP
5527: 8555:         XBKPFTP.LINE$ = "prompt"                    ! Prompt off command
5528: 856a:         GOSUB WRITE.XBKPFTP
5529: 857c:         XBKPFTP.LINE$ = "lcd C:\XDISKIMG"           ! Local directory
5530: 8591:         GOSUB WRITE.XBKPFTP
5531: 85a3:         XBKPFTP.LINE$ = "cd C:\XDISKIMG"            ! FTP directory
5532: 85b8:         GOSUB WRITE.XBKPFTP
5533: 85ca:         XBKPFTP.LINE$ = "mput *." + EXT.MDD$        ! PUT files
5534: 85ea:         GOSUB WRITE.XBKPFTP
5535: 85fc:         XBKPFTP.LINE$ = "lcd D:\XDISKIMG"           ! Local directory
5536: 8611:         GOSUB WRITE.XBKPFTP
5537: 8623:         XBKPFTP.LINE$ = "cd D:\XDISKIMG"            ! FTP directory
5538: 8638:         GOSUB WRITE.XBKPFTP
5539: 864a:         XBKPFTP.LINE$ = "mput *." + EXT.MDD$        ! PUT files
5540: 866a:         GOSUB WRITE.XBKPFTP
5541: 867c:         XBKPFTP.LINE$ = "close"                     ! Complete
5542: 8691:         GOSUB WRITE.XBKPFTP
5543: 86a3:         XBKPFTP.LINE$ = "quit"                      ! Quit
5544: 86b8:         GOSUB WRITE.XBKPFTP
5545: 86ca: 
5546: 86ca:         !-------------------------------------------------------!
5547: 86ca:         ! Closing the temporary session as processing completed !
5548: 86ca:         !-------------------------------------------------------!
5549: 86ca:         CLOSE TEMP.SESS.NUM%
5550: 86db:         ! Setting the temporary file close
5551: 86db:         TEMP.OPEN = FALSE                                               !FJK
5552: 86e9: 
5553: 86e9:         ! FTP the files
5554: 86e9:         CALL OSSHELL("TYPE " + FTP.FILE.NAME$ + " | FTP >> "         + \
5555: 8728:                      FTPOUT.FILE.NAME$  + " >>* " + FTPOUT.FILE.NAME$)
5556: 8728: 
5557: 8728:         FILE.OPERATION$     = "O"                                       !CJK
5558: 873f:         CURRENT.REPORT.NUM% = TEMP.REPORT.NUM%                          !CJK
5559: 8751: 
5560: 8751:         IF END # TEMP.SESS.NUM% THEN FTPOUT.ERR
5561: 876a:         OPEN FTPOUT.FILE.NAME$ AS TEMP.SESS.NUM%
5562: 878b: 
5563: 878b:         ! Setting the temporary file open
5564: 878b:         TEMP.OPEN       = TRUE                                          !FJK
5565: 8799:         FILE.OPERATION$ = "R"                                           !CJK
5566: 87b0:         VALUE.PRESENT   = TRUE                                          !KDC
5567: 87be: 
5568: 87be:         IF END # TEMP.SESS.NUM% THEN FTPOUT.READ.EOF                    !KDC
5569: 87d7:         WHILE VALUE.PRESENT
5570: 87e1:             READ # TEMP.SESS.NUM%; LINE DIR.VALUE$
5571: 87fd:             IF MATCH("226 Transfer complete", \                         !KDC
5572: 8824:                DIR.VALUE$,1) <> XBACK.ZERO% THEN BEGIN                  !KDC
5573: 8824:                 FTP.SUCCESS   = TRUE                                    !KDC
5574: 8832:                 VALUE.PRESENT = FALSE                                   !KDC
5575: 8840:             ENDIF
5576: 8848:         WEND
5577: 8857: FTPOUT.READ.EOF:                                                        !KDC
5578: 8867:         !-------------------------------------------------------!
5579: 8867:         ! Closing the temporary session as processing completed !
5580: 8867:         !-------------------------------------------------------!
5581: 8867:         FILE.OPERATION$ = "D"                                           !CJK
5582: 887e:         DELETE TEMP.SESS.NUM%
5583: 888f:         ! Setting the temporary file close
5584: 888f:         TEMP.OPEN = FALSE                                               !FJK
5585: 889d: 
5586: 889d:         IF FTP.SUCCESS THEN BEGIN                                       !KDC
5587: 88ac:             STATUS.MSG$ = STATUS.TEXT.MSG$(54)                          !KDC
5588: 88d3:         ENDIF ELSE BEGIN                                                !KDC
5589: 88db:             STATUS.MSG$ = STATUS.TEXT.ERROR$(33)                        !KDC
5590: 8900:             XBKOK.INTERIM.STATUS$ = STATUS.MAJOR.ERROR$                 !KDC
5591: 8919:         ENDIF                                                           !KDC
5592: 8921:         GOSUB DISPLAY.STATUS.MSG
5593: 8933:         GOSUB LOG.STATUS.MSG
5594: 8945:     ENDIF
5595: 894d: 
5596: 894d:     !-------------------------------------------------------------!
5597: 894d:     ! Deallocating the Temporary session only at the end of main  !
5598: 894d:     ! process as it has been used multiple times by the program   !
5599: 894d:     !-------------------------------------------------------------!
5600: 894d: 
5601: 894d:     CLOSE TEMP.SESS.NUM%
5602: 895e:     ! Setting the temporary file close                                  !HDC
5603: 895e:     TEMP.OPEN = FALSE                                                   !HDC
5604: 896c:     CALL SESS.NUM.UTILITY ("C",TEMP.SESS.NUM%,XBACK.NULL$)  ! Deallocate
5605: 898c: 
5606: 898c: 
5607: 898c:     CLOSE TEMP.SESS.NUM.2%
5608: 899d:     TEMP.2.OPEN = FALSE                                                 !LDC
5609: 89ab:     CALL SESS.NUM.UTILITY ("C",TEMP.SESS.NUM.2%,XBACK.NULL$)! Deallocate
5610: 89cb: 
5611: 89cb:     ! Deallocate session. Open and Close session will be handled by     !OJK
5612: 89cb:     ! the file function itself.                                         !OJK
5613: 89cb:     CALL SESS.NUM.UTILITY ("C",HSIUF.SESS.NUM%,XBACK.NULL$)             !OJK
5614: 89ee: 
5615: 89ee: RETURN
5616: 89fe: 
5617: 89fe: FTPOUT.ERR:
5618: 8a0e:     STATUS.MSG$ = STATUS.TEXT.ERROR$(34)                                !KDC
5619: 8a33:     GOSUB DISPLAY.STATUS.MSG
5620: 8a45:     GOSUB LOG.STATUS.MSG
5621: 8a57: 
5622: 8a57: RETURN
5623: 8a67: 
5624: 8a67: 
5625: 8a67: \***********************************************************************
5626: 8a67: \*
5627: 8a67: \*   FINAL.UPDATE.XBKOK: This Subroutine does the final update on the
5628: 8a67: \*                       XBKOK and closes the session
5629: 8a67: \*
5630: 8a67: \***********************************************************************
5631: 8a67: FINAL.UPDATE.XBKOK:
5632: 8a77: 
5633: 8a77:     GOSUB UPDATE.XBKOK
5634: 8a89: 
5635: 8a89:     !--------------------------------------------!
5636: 8a89:     ! As final XBKOK update is done, closing and !
5637: 8a89:     ! deallocating the session                   !
5638: 8a89:     !--------------------------------------------!
5639: 8a89:     CLOSE XBKOK.SESS.NUM%
5640: 8a9d:     CALL SESS.NUM.UTILITY ("C",XBKOK.SESS.NUM%,XBACK.NULL$) ! Deallocate
5641: 8ac0: 
5642: 8ac0:     XBKOK.OPEN = FALSE
5643: 8ace: 
5644: 8ace: RETURN
5645: 8ade: 
5646: 8ade: \***********************************************************************
5647: 8ade: \*
5648: 8ade: \*   WRITE.XBKPFTP: Writes FTP command details to XBKPFTP
5649: 8ade: \*
5650: 8ade: \***********************************************************************
5651: 8ade: WRITE.XBKPFTP:
5652: 8aee: 
5653: 8aee:     CURRENT.REPORT.NUM% = TEMP.REPORT.NUM%
5654: 8b00: 
5655: 8b00:     XBKPFTP.LINE$ = XBKPFTP.LINE$ + CRLF$
5656: 8b24:     XBKPFTP.FORM$ = "C" + STR$(LEN(XBKPFTP.LINE$)) ! form string
5657: 8b57: 
5658: 8b57:     IF END # TEMP.SESS.NUM% THEN WRITE.XBKPFTP.ERROR
5659: 8b70:     WRITE FORM XBKPFTP.FORM$; # TEMP.SESS.NUM%; XBKPFTP.LINE$
5660: 8b98: 
5661: 8b98: RETURN
5662: 8ba8: 
5663: 8ba8: WRITE.XBKPFTP.ERROR:
5664: 8bb8:     STATUS.MSG$     = STATUS.TEXT.ERROR$(35)                            !KDC
5665: 8bdd:     FILE.OPERATION$ = "W"       ! File write
5666: 8bf4:     GOSUB FILE.ERROR.EXIT
5667: 8c06: 
5668: 8c06: RETURN
5669: 8c16: 
5670: 8c16: \***********************************************************************
5671: 8c16: \*
5672: 8c16: \*   OLD.ARCHIVE.PURGE: This Subroutine purges the old archive file and
5673: 8c16: \*                      backup the XBACKUP log
5674: 8c16: \*
5675: 8c16: \***********************************************************************
5676: 8c16: OLD.ARCHIVE.PURGE:
5677: 8c26: 
5678: 8c26:     F02.DATE$           = CURR.DATE$                                    !KDC
5679: 8c41:     RETURN.VALUE.CHECK% = UPDATE.DATE(VAL("-" + BKPSCRPT.DAYS.TO.KEEP$))!KDC
5680: 8c78: 
5681: 8c78:     ! Checking the return value
5682: 8c78:     GOSUB CHECK.UPDATE.DATE.RC                                          !FJK
5683: 8c8a: 
5684: 8c8a:     !-----------------------------------!
5685: 8c8a:     ! Defining the Extension name for   !
5686: 8c8a:     ! older archive files               !
5687: 8c8a:     !-----------------------------------!
5688: 8c8a:     EXTENSION$ = RIGHT$(F02.DATE$,4)       ! Extracting Month value     !KDC
5689: 8cad:     GOSUB GET.FILE.EXTENSION                                            !KDC
5690: 8cbf:     EXT.MDD$ = EXTENSION$                                               !KDC
5691: 8cd8: 
5692: 8cd8:     IF MASTER$ = CE.CNTR$ THEN BEGIN
5693: 8cfa:         ! Deleting the old archive files
5694: 8cfa:         CALL OSSHELL("DEL " + CE.C.XDISKIMG$ + "*." + EXT.MDD$ + \      !JJK
5695: 8d45:                      " >> " + DIR.OUT$ +  " >>* " + DIR.OUT$ )
5696: 8d45: 
5697: 8d45:         CALL OSSHELL("DEL " + CE.D.XDISKIMG$ + "*." + EXT.MDD$ + \      !JJK
5698: 8d90:                      " >> " + DIR.OUT$ +  " >>* " + DIR.OUT$ )
5699: 8d90: 
5700: 8d90:         CALL OSSHELL("DEL " + CE.C.XDISKALT$ + "*." + EXT.MDD$ + \      !JJK
5701: 8ddb:                      " >> " + DIR.OUT$ +  " >>* " + DIR.OUT$ )
5702: 8ddb: 
5703: 8ddb:         CALL OSSHELL("DEL " + CE.D.XDISKALT$ + "*." + EXT.MDD$ + \      !JJK
5704: 8e26:                      " >> " + DIR.OUT$ +  " >>* " + DIR.OUT$ )
5705: 8e26: 
5706: 8e26:     ENDIF
5707: 8e2e: 
5708: 8e2e:     IF MASTER$ = CF.CNTR$ OR ALT.MASTER.ON THEN BEGIN
5709: 8e60:         ! Deleting the old archive files
5710: 8e60:         CALL OSSHELL("DEL " + CF.C.XDISKIMG$ + "*." + EXT.MDD$ + \      !JJK
5711: 8eab:                      " >> " + DIR.OUT$ +  " >>* " + DIR.OUT$ )
5712: 8eab: 
5713: 8eab:         CALL OSSHELL("DEL " + CF.D.XDISKIMG$ + "*." + EXT.MDD$ + \      !JJK
5714: 8ef6:                      " >> " + DIR.OUT$ +  " >>* " + DIR.OUT$ )
5715: 8ef6: 
5716: 8ef6:         CALL OSSHELL("DEL " + CF.C.XDISKALT$ + "*." + EXT.MDD$ + \      !JJK
5717: 8f41:                      " >> " + DIR.OUT$ +  " >>* " + DIR.OUT$ )
5718: 8f41: 
5719: 8f41:         CALL OSSHELL("DEL " + CF.D.XDISKALT$ + "*." + EXT.MDD$ + \      !JJK
5720: 8f8c:                      " >> " + DIR.OUT$ +  " >>* " + DIR.OUT$ )
5721: 8f8c:     ENDIF
5722: 8f94: 
5723: 8f94:     STATUS.MSG$ = STATUS.TEXT.MSG$(55)                                  !KDC
5724: 8fb9:     GOSUB DISPLAY.STATUS.MSG
5725: 8fcb:     GOSUB LOG.STATUS.MSG
5726: 8fdd: 
5727: 8fdd:     CALL ADXCOPYF(ADXSERVE.RC%,XBACK.LOG.LIVE.PATH$,                   \
5728: 9023:                          XBACK.LOG.FILE.NAME$,0,1,0)
5729: 9023: 
5730: 9023:     ! Moving XBACKUP.LOG from TEMP to D:/adx_udt1
5731: 9023:     IF ADXSERVE.RC% = XBACK.ZERO% THEN BEGIN
5732: 904a:         STATUS.MSG$ = STATUS.TEXT.MSG$(56)                              !KDC
5733: 906f:         GOSUB DISPLAY.STATUS.MSG
5734: 9081: 
5735: 9081:         !---------------------------!
5736: 9081:         ! Deleting the existing LOG !
5737: 9081:         ! file in TEMP directory    !
5738: 9081:         !---------------------------!
5739: 9081:         FILE.OPERATION$     = "D"                                       !CJK
5740: 9098:         CURRENT.REPORT.NUM% = XBACK.LOG.REPORT.NUM%                     !CJK
5741: 90aa:         DELETE XBACK.LOG.SESS.NUM%
5742: 90bb:         XBACK.LOG.OPEN = FALSE                                          !LDC
5743: 90c9:         !--------------------------!
5744: 90c9:         ! Deallocating the session !
5745: 90c9:         !--------------------------!
5746: 90c9:         CALL SESS.NUM.UTILITY ("C",XBACK.LOG.SESS.NUM%,XBACK.NULL$)
5747: 90e9: 
5748: 90e9:     ENDIF
5749: 90f1: 
5750: 90f1: RETURN
5751: 9101: 
5752: 9101: \***********************************************************************!OJK
5753: 9101: \*                                                                      !OJK
5754: 9101: \*   BACKUP.CONFIG.FILES: This Subroutine backs up configuration files  !OJK
5755: 9101: \*                        in C drive                                    !OJK
5756: 9101: \*                                                                      !OJK
5757: 9101: \***********************************************************************!OJK
5758: 9101: ! As there is nothing to backup commenting out the subroutine           !URG
5759: 9101: !BACKUP.CONFIG.FILES:                                                   !URG OJK
5760: 9101:                                                                         
5761: 9101: !    IF F13.DAY$ = "SUN" THEN BEGIN                                     !URG
5762: 9101: !        STATUS.MSG$ = "Backing up Configuration files"                 !URG OJK
5763: 9101: !        GOSUB LOG.STATUS.MSG                                           !URG OJK
5764: 9101: !        GOSUB DISPLAY.STATUS.MSG                                       !URG OJK
5765: 9101:                                                                          
5766: 9101:     ! Taking a copy of current BKPLIST file in C:/ADX_UDT1/             !URG OJK
5767: 9101: !        CALL ADXCOPYF(ADXSERVE.RC%,BKPLI.FILE.NAME$,            \      !URG OJK
5768: 9101: !                  BKPLIST.FILE.NAME.C$ + FULL.EXT.MDD$,0,0,0)          !URG OJK
5769: 9101:                                                                         
5770: 9101: !        IF ADXSERVE.RC% <> XBACK.ZERO% THEN BEGIN                      !URG OJK
5771: 9101: !            STATUS.MSG$ = "Error in BKPLIST file backing up"           !URG OJK
5772: 9101: !            XBKOK.INTERIM.STATUS$ = STATUS.MAJOR.ERROR$                !URG OJK
5773: 9101: !            GOSUB PROGRAM.EXIT                                         !URG OJK
5774: 9101: !        ENDIF                                                          !URG OJK
5775: 9101: !    ENDIF                                                              !URG
5776: 9101:                                                                        
5777: 9101: !RETURN                                                                 !URG OJK
5778: 9101: 
5779: 9101: \***********************************************************************!KDC
5780: 9101: \*                                                                      !KDC
5781: 9101: \*   GET.FILE.EXTENSION: Calculate the extension needed based on month  !KDC
5782: 9101: \*                       and day using month A/B/C for 10/11/12         !KDC
5783: 9101: \*                                                                      !KDC
5784: 9101: \***********************************************************************!KDC
5785: 9101: GET.FILE.EXTENSION:                                                     !KDC
5786: 9111:                                                                         !KDC
5787: 9111:     ! Storing the Month and Date in MDD format in new logic             !KDC
5788: 9111:     IF LEFT$(EXTENSION$,2) = "12" THEN BEGIN    ! If December (12)      !KDC
5789: 9143:         EXTENSION$ = "C" + RIGHT$(EXTENSION$, 2)                        !KDC
5790: 916d:     ENDIF ELSE \                                                        !KDC
5791: 9175:     IF LEFT$(EXTENSION$,2) = "11" THEN BEGIN    ! If November (11)      !KDC
5792: 91a7:         EXTENSION$ = "B" + RIGHT$(EXTENSION$, 2)                        !KDC
5793: 91d1:     ENDIF ELSE IF \                                                     !KDC
5794: 91d9:     LEFT$(EXTENSION$,2) = "10" THEN BEGIN       ! If October  (10)      !KDC
5795: 920b:         EXTENSION$ = "A" + RIGHT$(EXTENSION$, 2)                        !KDC
5796: 9234:     ENDIF ELSE BEGIN                            ! Rest of the Month     !KDC
5797: 923c:         EXTENSION$ = RIGHT$(EXTENSION$, 3)                              !KDC
5798: 925c:     ENDIF                                                               !KDC
5799: 9264:                                                                         !KDC
5800: 9264: RETURN                                                                  !KDC
5801: 9274:                 !   MAIN.PROCESSING SPECIFIC ROUTINES ENDS   !
5802: 9274:                 !............................................!
5803: 9274: 
5804: 9274: \**********************************************************************\
5805: 9274: \**********************************************************************\
5806: 9274: \*                                                                    *\
5807: 9274: \*                 TERMINATION SPECIFIC ROUTINES                      *\
5808: 9274: \*                                                                    *\
5809: 9274: \**********************************************************************\
5810: 9274: \**********************************************************************\
5811: 9274: 
5812: 9274: \***********************************************************************
5813: 9274: \*
5814: 9274: \*    CLOSE.AND.DEALLOC.SESSIONS: This Sub-routine closes the active
5815: 9274: \*                                sessions and De-allocates the session
5816: 9274: \*                                numbers.
5817: 9274: \*
5818: 9274: \***********************************************************************
5819: 9274: CLOSE.AND.DEALLOC.SESSIONS:
5820: 9284: 
5821: 9284:     ! Changed the variable FILE.OPERATION$ to FUNC.FLAG$                !BJK
5822: 9284:     FUNC.FLAG$     = "C"         ! File Close                           !BJK
5823: 9299:     PASSED.STRING$ = XBACK.NULL$ ! Setting Null
5824: 92b2: 
5825: 92b2:     IF XBACK.OPEN THEN BEGIN
5826: 92c1:         CLOSE XBACK.PIPE.SESS.NUM%
5827: 92d2:         XBACK.OPEN = FALSE                                              !LDC
5828: 92e0:         CALL SESS.NUM.UTILITY                                          \
5829: 9304:             (FUNC.FLAG$,XBACK.PIPE.SESS.NUM%,PASSED.STRING$)
5830: 9304: 
5831: 9304:     ENDIF
5832: 930c: 
5833: 930c:     IF BKPLI.OPEN THEN BEGIN
5834: 931b:         CLOSE BKPLI.SESS.NUM%
5835: 932f:         BKPLI.OPEN = FALSE                                              !LDC
5836: 933d:         CALL SESS.NUM.UTILITY                                          \
5837: 9364:             (FUNC.FLAG$,BKPLI.SESS.NUM%,PASSED.STRING$)
5838: 9364:     ENDIF
5839: 936c: 
5840: 936c:     IF BKPEXCL.OPEN THEN BEGIN
5841: 937b:         CLOSE BKPEXCL.SESS.NUM%
5842: 938c:         BKPEXCL.OPEN = FALSE                                            !LDC
5843: 939a:         CALL SESS.NUM.UTILITY                                          \
5844: 93be:             (FUNC.FLAG$,BKPEXCL.SESS.NUM%,PASSED.STRING$)
5845: 93be:     ENDIF
5846: 93c6: 
5847: 93c6:     IF BKPFAILC.OPEN THEN BEGIN                                         !OJK
5848: 93d5:         CLOSE BKPFAILC.SESS.NUM%                                        !OJK
5849: 93e6:         BKPFAILC.OPEN = FALSE                                           !OJK
5850: 93f4:         CALL SESS.NUM.UTILITY                                          \
5851: 9418:             (FUNC.FLAG$,BKPFAILC.SESS.NUM%,PASSED.STRING$)              !OJK
5852: 9418:     ENDIF
5853: 9420: 
5854: 9420:     IF BKPFAILD.OPEN THEN BEGIN                                         !OJK
5855: 942f:         CLOSE BKPFAILD.SESS.NUM%                                        !OJK
5856: 9440:         BKPFAILC.OPEN = FALSE                                           !OJK
5857: 944e:         CALL SESS.NUM.UTILITY                                          \!OJK
5858: 9472:             (FUNC.FLAG$,BKPFAILD.SESS.NUM%,PASSED.STRING$)              !OJK
5859: 9472:     ENDIF                                                               !OJK
5860: 947a: 
5861: 947a:     IF BKPSCRPT.OPEN THEN BEGIN
5862: 9489:         CLOSE BKPSCRPT.SESS.NUM%
5863: 949a:         BKPSCRPT.OPEN = FALSE                                           !LDC
5864: 94a8:         CALL SESS.NUM.UTILITY                                          \
5865: 94cc:             (FUNC.FLAG$,BKPSCRPT.SESS.NUM%,PASSED.STRING$)
5866: 94cc:     ENDIF
5867: 94d4: 
5868: 94d4:     IF TEMP.OPEN THEN BEGIN
5869: 94e3:         CLOSE TEMP.SESS.NUM%
5870: 94f4:         TEMP.OPEN = FALSE                                               !LDC
5871: 9502:         CALL SESS.NUM.UTILITY                                          \
5872: 9526:             (FUNC.FLAG$,TEMP.SESS.NUM%,PASSED.STRING$)
5873: 9526:     ENDIF
5874: 952e: 
5875: 952e:     IF TEMP.2.OPEN THEN BEGIN                                           !FJK
5876: 953d:         CLOSE TEMP.SESS.NUM.2%                                          !FJK
5877: 954e:         TEMP.2.OPEN = FALSE                                             !LDC
5878: 955c:         CALL SESS.NUM.UTILITY \                                         !FJK
5879: 9580:             (FUNC.FLAG$,TEMP.SESS.NUM.2%,PASSED.STRING$)                !FJK
5880: 9580:     ENDIF                                                               !FJK
5881: 9588: 
5882: 9588:     IF XBKOK.OPEN THEN BEGIN
5883: 9597:         CLOSE XBKOK.SESS.NUM%
5884: 95ab:         XBKOK.OPEN = FALSE                                              !LDC
5885: 95b9:         CALL SESS.NUM.UTILITY                                          \
5886: 95e0:             (FUNC.FLAG$,XBKOK.SESS.NUM%,PASSED.STRING$)
5887: 95e0:     ENDIF
5888: 95e8: 
5889: 95e8:     IF XBACK.LOG.OPEN THEN BEGIN
5890: 95f7:         CLOSE XBACK.LOG.SESS.NUM%
5891: 9608:         XBACK.LOG.OPEN = FALSE                                          !LDC
5892: 9616:         CALL SESS.NUM.UTILITY                                          \
5893: 963a:             (FUNC.FLAG$,XBACK.LOG.SESS.NUM%,PASSED.STRING$)
5894: 963a:     ENDIF
5895: 9642: 
5896: 9642:     IF HSIUF.OPEN THEN BEGIN                                            !KDC
5897: 9654:         CLOSE HSIUF.SESS.NUM%                                           !KDC
5898: 9668:         HSIUF.OPEN = FALSE                                              !LDC
5899: 967a:         CALL SESS.NUM.UTILITY                                          \!KDC
5900: 96a1:             (FUNC.FLAG$,HSIUF.SESS.NUM%,PASSED.STRING$)                 !KDC
5901: 96a1:     ENDIF                                                               !KDC
5902: 96a9: 
5903: 96a9:     IF SLPCF.OPEN THEN BEGIN                                            !KDC
5904: 96b8:         CLOSE SLPCF.SESS.NUM%                                           !KDC
5905: 96cc:         SLPCF.OPEN = FALSE                                              !LDC
5906: 96da:         CALL SESS.NUM.UTILITY                                          \!KDC
5907: 9701:             (FUNC.FLAG$,SLPCF.SESS.NUM%,PASSED.STRING$)                 !KDC
5908: 9701:     ENDIF                                                               !KDC
5909: 9709: 
5910: 9709: RETURN
5911: 9719: 
5912: 9719:                 !   TERMINATION SPECIFIC ROUTINES ENDS   !
5913: 9719:                 !........................................!
5914: 9719: 
5915: 9719: \**********************************************************************\
5916: 9719: \**********************************************************************\
5917: 9719: \*                                                                    *\
5918: 9719: \*                       GENERIC ROUTINES                             *\
5919: 9719: \*                                                                    *\
5920: 9719: \**********************************************************************\
5921: 9719: \**********************************************************************\
5922: 9719: 
5923: 9719: \***********************************************************************
5924: 9719: \*
5925: 9719: \*   LOG.STATUS.MSG: Writes status message to log file
5926: 9719: \*
5927: 9719: \***********************************************************************
5928: 9719: LOG.STATUS.MSG:
5929: 9729: 
5930: 9729:     CURRENT.REPORT.NUM% = XBACK.LOG.REPORT.NUM%
5931: 973b: 
5932: 973b:     IF NOT XBACK.LOG.OPEN THEN BEGIN ! If not open                      !CJK
5933: 974a:         RETURN
5934: 975a:     ENDIF
5935: 9762: 
5936: 9762:     DATE.VALUE$ = DATE$                                                 !FJK
5937: 9778: 
5938: 9778:     PREFIX.HHMMSS.PROG$ = RIGHT$(DATE.VALUE$,2) + "/" + \ DD            !KDC
5939: 986a:                           MID$(DATE.VALUE$,3,2) + "/" + \ MM            !KDC
5940: 986a:                           LEFT$(DATE.VALUE$,2)  + " " + \ YY            !KDC
5941: 986a:                           MID$(TIME$,1,2)       + ":" + \               !KDC
5942: 986a:                           MID$(TIME$,3,2)       + ":" + \               !KDC
5943: 986a:                           MID$(TIME$,5,2)       + " " + \ Time-stamp    !KDC
5944: 986a:                           STATUS.MSG$                   ! Text          !KDC
5945: 986a: 
5946: 986a:     XBACK.LOG.REC$  = PREFIX.HHMMSS.PROG$ + CRLF$                       !FJK
5947: 988e:     XBACK.LOG.FORM$ = "C" + STR$(LEN(XBACK.LOG.REC$))   ! Form string
5948: 98c1: 
5949: 98c1:     IF END # XBACK.LOG.SESS.NUM% THEN WRITE.XBACK.LOG.ERROR
5950: 98da:     WRITE FORM XBACK.LOG.FORM$; # XBACK.LOG.SESS.NUM%; XBACK.LOG.REC$
5951: 9902: 
5952: 9902: RETURN
5953: 9912: 
5954: 9912: WRITE.XBACK.LOG.ERROR:
5955: 9922:     STATUS.MSG$     = STATUS.TEXT.ERROR$(36)                            !KDC
5956: 9947:     FILE.OPERATION$ = "W"           ! File write
5957: 995e:     GOSUB FILE.ERROR.EXIT
5958: 9970: 
5959: 9970: RETURN
5960: 9980: 
5961: 9980: \***********************************************************************
5962: 9980: \*
5963: 9980: \*    DISPLAY.STATUS.MSG: If program running in Background, it display
5964: 9980: \*                        it as Background message, else it prints in
5965: 9980: \*                        the console.
5966: 9980: \*
5967: 9980: \***********************************************************************
5968: 9980: DISPLAY.STATUS.MSG:
5969: 9990: 
5970: 9990:     HHMM.STATUS.MSG$ = MID$(TIME$,1,2) + ":" + MID$(TIME$,3,2) + \      !KDC
5971: 99fc:                        " " + STATUS.MSG$               ! Text           !FJK
5972: 99fc: 
5973: 99fc:     IF BACKGROUND.RUN THEN BEGIN    ! Running in background
5974: 9a0b: 
5975: 9a0b:         ADX.INTEGER%  = XBACK.ZERO% ! Setting the parameter
5976: 9a19:         ADX.FUNCTION% = 26          ! Parameter for Background message
5977: 9a26: 
5978: 9a26:         ! Display STATUS.MSG$ to background screen
5979: 9a26:         !                Return code,   Function,
5980: 9a26:         CALL ADXSERVE (ADXSERVE.RC%, ADX.FUNCTION%,                    \
5981: 9a62:                        ADX.INTEGER%, HHMM.STATUS.MSG$)
5982: 9a62:         !                   Parm1,       Parm2
5983: 9a62: 
5984: 9a62:         GOSUB CHECK.ADXSERVE.RC ! Stops program if non zero
5985: 9a76: 
5986: 9a76:     ENDIF ELSE BEGIN
5987: 9a7e: 
5988: 9a7e:         ! Display message to command mode screen status box
5989: 9a7e:         PRINT LEFT$(HHMM.STATUS.MSG$ + STRING$(46, " "), 46) ! message
5990: 9ac7:     ENDIF
5991: 9acf: RETURN
5992: 9adf:                         !   GENERIC ROUTINES ENDS   !
5993: 9adf:                         !...........................!
5994: 9adf: 
5995: 9adf: \**********************************************************************\
5996: 9adf: \**********************************************************************\
5997: 9adf: \*                                                                    *\
5998: 9adf: \*                   PROGRAM-INDEPENDENT ROUTINES                     *\
5999: 9adf: \*                                                                    *\
6000: 9adf: \**********************************************************************\
6001: 9adf: \**********************************************************************\
6002: 9adf: 
6003: 9adf: \***********************************************************************!FJK
6004: 9adf: \*
6005: 9adf: \*    CHECK.UPDATE.DATE.RC: If RETURN.VALUE.CHECK% is not equal to zero !KDC
6006: 9adf: \*                          logs the error and end the program.         !KDC
6007: 9adf: \*
6008: 9adf: \***********************************************************************
6009: 9adf: CHECK.UPDATE.DATE.RC:
6010: 9aef: 
6011: 9aef:     ! Checking the return value
6012: 9aef:     IF RETURN.VALUE.CHECK% <> XBACK.ZERO% THEN BEGIN                    !KDC
6013: 9b0a:         STATUS.MSG$ = STATUS.TEXT.ERROR$(37)                            !KDC
6014: 9b2f:         GOSUB DISPLAY.STATUS.MSG
6015: 9b41:         GOSUB STOP.PROGRAM
6016: 9b53:     ENDIF
6017: 9b5b: 
6018: 9b5b: RETURN
6019: 9b6b: 
6020: 9b6b: \***********************************************************************!FJK
6021: 9b6b: \*
6022: 9b6b: \*    CHECK.PSDATE.RC: If FUNC.RC2% is not equal to zero ... logs
6023: 9b6b: \*                     the error and end the program.
6024: 9b6b: \*
6025: 9b6b: \***********************************************************************
6026: 9b6b: CHECK.PSDATE.RC:
6027: 9b7b: 
6028: 9b7b:     ! Checking the return value
6029: 9b7b:     IF RETURN.VALUE.CHECK% <> XBACK.ZERO% THEN BEGIN                    !KDC
6030: 9b96:         STATUS.MSG$ = STATUS.TEXT.ERROR$(38)                            !KDC
6031: 9bbb:         GOSUB DISPLAY.STATUS.MSG
6032: 9bcd:         GOSUB STOP.PROGRAM
6033: 9bdf:     ENDIF
6034: 9be7: 
6035: 9be7: RETURN
6036: 9bf7: 
6037: 9bf7: \***********************************************************************
6038: 9bf7: \*
6039: 9bf7: \*    CHECK.FILE.RC2: If FILE.RC2% is zero ... By-passes rest
6040: 9bf7: \*                    of procedure. Diverts program control to
6041: 9bf7: \*                    FILE.ERROR.EXIT (exiting program).
6042: 9bf7: \*
6043: 9bf7: \***********************************************************************
6044: 9bf7: CHECK.FILE.RC2:
6045: 9c07: 
6046: 9c07:     IF FILE.RC2% = 0 THEN RETURN ! No error
6047: 9c21: 
6048: 9c21:     GOSUB FILE.ERROR.EXIT
6049: 9c33: 
6050: 9c33: RETURN
6051: 9c43: 
6052: 9c43: \***********************************************************************
6053: 9c43: \*
6054: 9c43: \*    RETURN.VALUE.CHECK: If RETURN.VALUE.CHECK% is zero,               !KDC
6055: 9c43: \*                        By-passes rest of procedure and Stops         !KDC
6056: 9c43: \*                        program.                                      !KDC
6057: 9c43: \*
6058: 9c43: \***********************************************************************
6059: 9c43: RETURN.VALUE.CHECK:                                                     !KDC
6060: 9c53: 
6061: 9c53:     IF RETURN.VALUE.CHECK% = XBACK.ZERO% THEN RETURN  ! No error        !KDC
6062: 9c76: 
6063: 9c76:     STATUS.MSG$  = STATUS.TEXT.ERROR$(39) + PASSED.STRING$              !KDC
6064: 9ca6: 
6065: 9ca6:     GOSUB PROGRAM.EXIT
6066: 9cb8: 
6067: 9cb8: RETURN
6068: 9cc8: 
6069: 9cc8: \***********************************************************************
6070: 9cc8: \*
6071: 9cc8: \*    CHECK.ADXSERVE.RC: CALLs PSBF20 SESS.NUM.UTILITY to CLOSE entry
6072: 9cc8: \*                       on session number table and deallocate file
6073: 9cc8: \*                       session number for all files used by program.
6074: 9cc8: \*
6075: 9cc8: \***********************************************************************
6076: 9cc8: CHECK.ADXSERVE.RC:
6077: 9cd8: 
6078: 9cd8:     IF ADXSERVE.RC% <> XBACK.ZERO% THEN BEGIN  ! Error check
6079: 9cfc:         GOSUB LOG.AN.EVENT.23
6080: 9d0e:         GOSUB PROGRAM.EXIT
6081: 9d20:     ENDIF
6082: 9d28: 
6083: 9d28: RETURN
6084: 9d38: 
6085: 9d38: \**********************************************************************
6086: 9d38: \*
6087: 9d38: \*    LOG.AN.EVENT.23: Writes details of Event 23 to application
6088: 9d38: \*                     event log.
6089: 9d38: \*
6090: 9d38: \**********************************************************************
6091: 9d38: LOG.AN.EVENT.23:
6092: 9d48: 
6093: 9d48:     EVENT.NUMBER% = 23 ! ADXSERVE error
6094: 9d56: 
6095: 9d56:     ! Formatting the length
6096: 9d56:     VAR.STRING.1$ = RIGHT$("00000" + STR$(ADXSERVE.RC%),5)           + \
6097: 9db3:                     PACK$("0000000000")
6098: 9db3: 
6099: 9db3:     GOSUB CALL.F01.APPLICATION.LOG
6100: 9dc5: 
6101: 9dc5: RETURN
6102: 9dd5: 
6103: 9dd5: CALL.F01.APPLICATION.LOG:
6104: 9de5: 
6105: 9de5:     MESSAGE.NUMBER% = XBACK.ZERO%                                       !FJK
6106: 9df4:     VAR.STRING.2$   = XBACK.NULL$                                       !FJK
6107: 9e0d: 
6108: 9e0d:     RETURN.VALUE.CHECK% = APPLICATION.LOG (MESSAGE.NUMBER%, \           !KDC
6109: 9e3d:                           VAR.STRING.1$, VAR.STRING.2$, EVENT.NUMBER% ) !KDC
6110: 9e3d: 
6111: 9e3d:     IF RETURN.VALUE.CHECK% <> XBACK.ZERO% THEN BEGIN ! If error         !KDC
6112: 9e58:         STATUS.MSG$ = STATUS.TEXT.ERROR$(40)                            !KDC
6113: 9e7d:         GOSUB PROGRAM.EXIT
6114: 9e8f:     ENDIF
6115: 9e97: 
6116: 9e97: RETURN
6117: 9ea7:                     !   PROGRAM-INDEPENDENT ROUTINES ENDS   !
6118: 9ea7:                     !.......................................!
6119: 9ea7: 
6120: 9ea7: \**********************************************************************\
6121: 9ea7: \**********************************************************************\
6122: 9ea7: \*                                                                    *\
6123: 9ea7: \*             IF END # AND ERROR.DETECTED ROUTINES                   *\
6124: 9ea7: \*                                                                    *\
6125: 9ea7: \**********************************************************************\
6126: 9ea7: \**********************************************************************\
6127: 9ea7: 
6128: 9ea7: \***********************************************************************!DJK
6129: 9ea7: \*
6130: 9ea7: \*    INVALID.PARAM.EXIT: This subroutine will be called if invalid
6131: 9ea7: \*                        parameter is passed in XBACKUP run. It clears
6132: 9ea7: \*                        the screen and ends the program with a
6133: 9ea7: \*                        display message.
6134: 9ea7: \*
6135: 9ea7: \***********************************************************************
6136: 9ea7: INVALID.PARAM.EXIT:
6137: 9eb7: 
6138: 9eb7:     CLEARS
6139: 9ec6:     STATUS.MSG$ = STATUS.TEXT.ERROR$(41)                                !KDC
6140: 9eeb:     GOSUB DISPLAY.STATUS.MSG
6141: 9efd:     STATUS.MSG$ = STATUS.TEXT.ERROR$(42)                                !KDC
6142: 9f22:     GOSUB DISPLAY.STATUS.MSG
6143: 9f34:     STATUS.MSG$ = STATUS.TEXT.ERROR$(43)                                !KDC
6144: 9f59:     GOSUB DISPLAY.STATUS.MSG
6145: 9f6b:     STATUS.MSG$ = STATUS.TEXT.ERROR$(41)                                !KDC
6146: 9f90:     GOSUB DISPLAY.STATUS.MSG
6147: 9fa2:     GOSUB STOP.PROGRAM
6148: 9fb4: 
6149: 9fb4: RETURN
6150: 9fc4: 
6151: 9fc4: \***********************************************************************
6152: 9fc4: \*
6153: 9fc4: \*    FILE.ERROR.EXIT: Logs events for specific file errors.
6154: 9fc4: \*                     Formats error message and displays on background
6155: 9fc4: \*                     screen. Logs an event 106. Stops program.
6156: 9fc4: \*
6157: 9fc4: \***********************************************************************
6158: 9fc4: FILE.ERROR.EXIT:
6159: 9fd4: 
6160: 9fd4:     GOSUB DISPLAY.STATUS.MSG
6161: 9fe6:     IF CURRENT.REPORT.NUM% <> XBACK.LOG.REPORT.NUM% THEN BEGIN
6162: 9ffb:         GOSUB LOG.STATUS.MSG
6163: a00d:     ENDIF
6164: a015: 
6165: a015:     XBKOK.INTERIM.STATUS$ = STATUS.MAJOR.ERROR$ ! Critical errors
6166: a02e:     GOSUB FINAL.UPDATE.XBKOK                                            !BJK
6167: a040: 
6168: a040:     ! Logging event 106 for File error                                  !FJK
6169: a040:     STATUS.MSG$ = STATUS.TEXT.ERROR$(44) + FILE.OPERATION$              !KDC
6170: a073:     GOSUB DISPLAY.STATUS.MSG                                            !FJK
6171: a085:     GOSUB LOG.STATUS.MSG                                                !FJK
6172: a097: 
6173: a097:     EVENT.NUMBER% = 106     ! Event 106                                 !FJK
6174: a0a5: 
6175: a0a5:     ! Application event log data                                        !FJK
6176: a0a5:     VAR.STRING.1$ = FILE.OPERATION$                                  + \!FJK
6177: a104:                     CHR$(SHIFT(CURRENT.REPORT.NUM%,8))               + \!FJK
6178: a104:                     CHR$(SHIFT(CURRENT.REPORT.NUM%,XBACK.ZERO%))        !FJK
6179: a104: 
6180: a104:     GOSUB CALL.F01.APPLICATION.LOG                                      !FJK
6181: a116: 
6182: a116:     GOSUB TERMINATION
6183: a128:     GOSUB STOP.PROGRAM
6184: a13a: 
6185: a13a: RETURN
6186: a14a: 
6187: a14a: \***********************************************************************
6188: a14a: \*
6189: a14a: \*    PROGRAM.EXIT: Displays final status message and writes it to
6190: a14a: \*                  log file. Updates XBKOK to set XBKOK.STATUS$.
6191: a14a: \*
6192: a14a: \***********************************************************************
6193: a14a: PROGRAM.EXIT:
6194: a15a: 
6195: a15a:     GOSUB DISPLAY.STATUS.MSG
6196: a16c:     GOSUB LOG.STATUS.MSG
6197: a17e:     GOSUB FINAL.UPDATE.XBKOK                                            !BJK
6198: a190:     GOSUB TERMINATION
6199: a1a2:     GOSUB STOP.PROGRAM
6200: a1b4: 
6201: a1b4: RETURN
6202: a1c4: 
6203: a1c4: \***********************************************************************
6204: a1c4: \*
6205: a1c4: \*    ERROR.DETECTED: Main Error Handling Routine. Starts with the
6206: a1c4: \*                    resume error conditions following ERROR.COUNT%
6207: a1c4: \*                    check to avoid error loop. Also References
6208: a1c4: \*                    STANDARD.ERROR.DETECTED to log Event 101.
6209: a1c4: \*
6210: a1c4: \***********************************************************************
6211: a1c4: ERROR.DETECTED:
6212: a1d4:     
6213: a1d4:     IF ERR = "OE" AND OPEN.BKPFAILFILE = TRUE THEN BEGIN                !SMH
6214: a216:         FILE.MISSING = TRUE                                             !SMH
6215: a224:         RESUME                                                          !SMH
6216: a23b:     ENDIF                                                               !SMH
6217: a243: 
6218: a243:     IF ERR = "CU" OR ERR = "DU" THEN RESUME     ! Close and delete
6219: a2b1:                                                 ! session errors
6220: a2b1:     IF ERR = "*I" THEN BEGIN   ! Unexpected error on file
6221: a2d7:         IF FSET.ON THEN BEGIN
6222: a2e6:             FSET.ON = FALSE
6223: a2f4:             RESUME
6224: a30b:         ENDIF
6225: a313:     ENDIF
6226: a31b: 
6227: a31b:     ! check if this is coming from DOES.BACKUP.DIR.EXIST to handle error!KDC
6228: a31b:     IF BACKUP.DIR.EXIST = 2 THEN BEGIN                                  !KDC
6229: a32a:         STATUS.MSG$ = STATUS.TEXT.ERROR$(1)                             !KDC
6230: a34f:         BACKUP.DIR.EXIST = FALSE    ! Error occurred                    !KDC
6231: a35d:         RESUME BACKUP.DIR.EXIST.EXIT                                    !KDC
6232: a374:     ENDIF                                                               !KDC
6233: a37c: 
6234: a37c:     ! check if this is coming from DOES.ZIP.FILE.EXISTS to handle error !KDC
6235: a37c:     IF ZIP.FILE.EXISTS = 2 THEN BEGIN                                   !KDC
6236: a38b:         STATUS.MSG$ = STATUS.TEXT.ERROR$(1)                             !KDC
6237: a3b0:         ZIP.FILE.EXISTS = FALSE    ! Error occurred                     !KDC
6238: a3be:         RESUME ZIP.FILE.EXISTS.EXIT                                     !KDC
6239: a3d5:     ENDIF                                                               !KDC
6240: a3dd: 
6241: a3dd:     !*******************************************************************!KDC
6242: a3dd:     ! if an error found processing the list file then report and        !KDC
6243: a3dd:     ! continue                                                          !KDC
6244: a3dd:     ! this replicates the original error handling in the                !KDC
6245: a3dd:     ! FUNC.UPD.TODAY.BKPLIST.REC$ function when it converted to a       !KDC
6246: a3dd:     ! subroutine                                                        !KDC
6247: a3dd:     !*******************************************************************!KDC
6248: a3dd:     IF ERRF% <> 0 THEN BEGIN                                            !KDC
6249: a3ef:         !IF ERRF% = BKPLI.SESS.NUM% THEN BEGIN                           !KDC
6250: a3ef: 
6251: a3ef:         !    STATUS.MSG$ = STATUS.TEXT.ERROR$(45) + \                   !URG KDC
6252: a3ef:         !                  BKPLI.FILENAME$ + " file"                    !URG KDC
6253: a3ef:                                                                         !URG KDC
6254: a3ef:             ! resume depending on where the error was                   !URG LDC
6255: a3ef:         !    IF TODAY.BKPLIST.REC% = 1 THEN BEGIN                       !URG LDC
6256: a3ef:         !        RESUME UPD.TODAY.BKPLIST.REC.ERR                       !URG LDC
6257: a3ef:         !     ENDIF ELSE BEGIN                                          !URG OJK
6258: a3ef:                                                                         !URG LDC
6259: a3ef:         !    ENDIF                                                      !URG LDC
6260: a3ef:         !ENDIF                                                          !URG KDC
6261: a3ef:     ENDIF                                                               !KDC
6262: a3f7: 
6263: a3f7:     ERROR.COUNT% = ERROR.COUNT% + 1             ! Updates Error count
6264: a403:     !***************************************************************!   !KDC
6265: a403:     ! error handling below this point will add to the general error !   !KDC
6266: a403:     ! failure count                                                 !   !KDC
6267: a403:     !***************************************************************!   !KDC
6268: a403: 
6269: a403:     IF ERROR.COUNT% > 1 THEN BEGIN              ! Infinite Error
6270: a412:         GOSUB STOP.PROGRAM                      ! loop check            !BJK
6271: a424:     ENDIF
6272: a42c: 
6273: a42c:     !------------------------!
6274: a42c:     ! Fatal errors to follow !
6275: a42c:     !------------------------!
6276: a42c: 
6277: a42c:     ! Error creating run pipe, Program already running
6278: a42c:     IF ERR = "ME" AND ERRF% = XBACK.PIPE.SESS.NUM% THEN BEGIN
6279: a478:         CLEARS
6280: a487:         STATUS.MSG$ = STATUS.TEXT.ERROR$(46) + PROGRAM$ + \     !KDC
6281: a4cb:                       STATUS.TEXT.ERROR$(47)                    !KDC
6282: a4cb:         GOSUB DISPLAY.STATUS.MSG                               ! display
6283: a4dd:         GOSUB TERMINATION
6284: a4ef:         GOSUB STOP.PROGRAM
6285: a501:     ENDIF
6286: a509: 
6287: a509:     IF ERR = "IH" THEN BEGIN                ! Illegal characters
6288: a52f:         IF BKPSCRPT.ERROR THEN BEGIN
6289: a53e:             STATUS.MSG$ =  STATUS.TEXT.ERROR$(48)                       !KDC
6290: a563:             GOSUB PROGRAM.EXIT
6291: a575:         ENDIF
6292: a57d:     ENDIF
6293: a585: 
6294: a585:     ! File access error
6295: a585:     IF (ERRN AND 0000FFFFH) = 400CH OR ERR = "ND" THEN BEGIN
6296: a5f8: 
6297: a5f8:         FILE.OPERATION$ = "O"
6298: a60f: 
6299: a60f:         IF ERRF% = XBACK.LOG.SESS.NUM% THEN BEGIN
6300: a622:             STATUS.MSG$ = STATUS.TEXT.ERROR$(49)                        !KDC
6301: a647:             GOSUB FILE.ERROR.EXIT
6302: a659:         ENDIF
6303: a661:         IF ERRF% = BKPSCRPT.SESS.NUM% THEN BEGIN
6304: a674:             STATUS.MSG$ = STATUS.TEXT.ERROR$(50)                        !KDC
6305: a699:             GOSUB FILE.ERROR.EXIT
6306: a6ab:         ENDIF
6307: a6b3:         IF ERRF% = BKPEXCL.SESS.NUM% THEN BEGIN
6308: a6c6:             STATUS.MSG$ = STATUS.TEXT.ERROR$(51)                        !KDC
6309: a6eb:             GOSUB FILE.ERROR.EXIT
6310: a6fd:         ENDIF
6311: a705:         IF ERRF% = XBKOK.SESS.NUM% THEN BEGIN                           !DJK
6312: a721:             STATUS.MSG$ = STATUS.TEXT.ERROR$(52)                        !KDC
6313: a746:             GOSUB FILE.ERROR.EXIT                                       !DJK
6314: a758:         ENDIF                                                           !DJK
6315: a760:         IF ERRF% = BKPLI.SESS.NUM% THEN BEGIN                           !KDC
6316: a77c:             STATUS.MSG$ = STATUS.TEXT.ERROR$(59)                        !KDC
6317: a7a1:             GOSUB FILE.ERROR.EXIT                                       !KDC
6318: a7b3:         ENDIF                                                           !KDC
6319: a7bb: 
6320: a7bb:     ENDIF
6321: a7c3: 
6322: a7c3:     IF FILE.OPERATION$ = "C" THEN BEGIN              ! File Create
6323: a7e4:         IF ERRF% = XBACK.LOG.SESS.NUM% THEN BEGIN
6324: a7f7:             STATUS.MSG$ = STATUS.TEXT.ERROR$(53)                        !KDC
6325: a81c:             GOSUB FILE.ERROR.EXIT
6326: a82e:         ENDIF
6327: a836:         IF ERRF% = BKPEXCL.SESS.NUM% THEN BEGIN
6328: a849:             STATUS.MSG$ = STATUS.TEXT.ERROR$(54)                        !KDC
6329: a86e:             GOSUB FILE.ERROR.EXIT
6330: a880:         ENDIF
6331: a888:         IF ERRF% = BKPFAILC.SESS.NUM% THEN BEGIN                        !OJK
6332: a89b:             STATUS.MSG$ = STATUS.TEXT.ERROR$(55)                        !KDC
6333: a8c0:             GOSUB FILE.ERROR.EXIT
6334: a8d2:         ENDIF
6335: a8da:         IF ERRF% = BKPFAILD.SESS.NUM% THEN BEGIN                        !OJK
6336: a8ed:             STATUS.MSG$ = STATUS.TEXT.ERROR$(60)                        !OJK
6337: a912:             GOSUB FILE.ERROR.EXIT                                       !OJK
6338: a924:         ENDIF                                                           !OJK
6339: a92c:         IF ERRF% = BKPLI.SESS.NUM% THEN BEGIN
6340: a948:             STATUS.MSG$ = STATUS.TEXT.ERROR$(56)                        !KDC
6341: a96d:             GOSUB FILE.ERROR.EXIT
6342: a97f:         ENDIF
6343: a987:         IF ERRF% = TEMP.SESS.NUM% OR ERRF% = TEMP.SESS.NUM.2% THEN BEGIN!CJK
6344: a9b7:             STATUS.MSG$ = STATUS.TEXT.ERROR$(57)                        !KDC
6345: a9dc:             GOSUB FILE.ERROR.EXIT
6346: a9ee:         ENDIF
6347: a9f6:     ENDIF
6348: a9fe: 
6349: a9fe:     ! Log event 102
6350: a9fe:     CALL STANDARD.ERROR.DETECTED(ERRN, ERRF%, ERRL, ERR)                !FJK
6351: aa2b: 
6352: aa2b:     ! Status message to display
6353: aa2b:     STATUS.MSG$ = "Ended: " + ERR + " " + ERRNH + " ERRL "  + \
6354: aa93:                   STR$(ERRL) + " ERRF% " + STR$(ERRF%)
6355: aa93:     XBKOK.INTERIM.STATUS$ = STATUS.MAJOR.ERROR$ ! Failed
6356: aaac:     GOSUB PROGRAM.EXIT ! Displays status message, updates LOG and XBKOK
6357: aac3: 
6358: aac3: END
6359: aac3: 
6360: aac3: \***********************************************************************
6361: aac3: \***********************************************************************
6362: aac3: \*
6363: aac3: \*    End of program XBACKUP
6364: aac3: \*
6365: aac3: \***********************************************************************
6366: aac3: \***********************************************************************
6367: aac3: 
6368: aac3: 
6369: aac3: End of Compilation
