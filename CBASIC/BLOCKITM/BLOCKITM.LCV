\******************************************************************************
\******************************************************************************
\******************************************************************************
\******************************************************************************
\*******************************************************************************
\*******************************************************************************
\***                                                                         ***
\***                                                                         ***
\***            PROGRAM       : BLOCKITM.286                                 ***
\***                                                                         ***
\***            TITLE         : Block Item From Sale Fiddle Program          ***
\***                                                                         ***
\***            AUTHOR        : Charles Skadorwa                             ***
\***                                                                         ***
\***            DATE WRITTEN  : 13th Jun 2008                                ***
\***                                                                         ***
\***            MODULE        : BLOCKITM.BAS                                 ***
\***                                                                         ***
\***                                                                         ***
\***                                                                         ***
\*******************************************************************************
\***  Description
\***  ===========
\***  The purpose of this program is to read in a file containing a list of
\***  BOOTS item codes and set two BIT flags on the IRF for those items.
\***  
\***     IRF.INDICAT0% Bit 5 - Item not authorised for sale (recall active)
\***     IRF.INDICAT8% Bit 6 - Withdrawn Recall
\***  
\***  This action will prevent the sale of these items at the till   
\***               
\***
\***  Ver A     Charles Skadorwa                                    13 Jun 2008
\***            Initial Version.
\***
\***  Ver B     Charles Skadorwa                                    20 Jun 2008
\***            Defect: Program changed to update all associated barcodes
\***                    by reading the IDF to get no. of barcodes and IEF
\***                    in order to trawl down the chain of barcodes.
\***
\***  Ver C     Charles Skadorwa                                    6  Aug 2008
\***            Defect: Program changed to update first barcode if only 
\***                    one barcode exists eg. Insurance items
\***
\***  Ver D     Charles Skadorwa                                    17 Oct 2008
\***            Enhancement: Ensure that only real program failures will 
\***                         result in a .ERR file ie. we don't want to
\***                         report a failure for items not on file. Also,
\***                         a .WRN file is created which will list any items
\***                         not on file.
\***
\***  Ver E     Charles Skadorwa                                    10 Oct 2009
\***            This program assumed that the IDF, IRF and IDF files are
\***            synchronised with no corruptions. However, in some instances 
\***            an item can exist on the IRF and not the IDF. This change
\***            ensures that if a there is a read failure on the IDF, then the
\***            IRF is scanned for all occurrences of that item and the recall 
\***            bit flags set. This is to resolve the issue whereby Blockitm is 
\***            run but the PPC's still report items being on recall because 
\***            Transact reads the IRF directly and not the IDF.
\***
\*******************************************************************************
\*******************************************************************************
\*******************************************************************************
\***
\***   Define variables
\***
\***---------------------------------------------------------------------------

%INCLUDE IDFDEC.J86     ! IDF Variables                                      !BCS
REM \
\******************************************************************************
\******************************************************************************
\***
\***         %INCLUDE FOR ITEM DATA FILE - FIELD DECLARATIONS
\***                                       FILE REFERENCE PARAMETERS
\***
\***                  FILE TYPE    : Keyed
\***
\***                  REFERENCE    : IDFDEC.J86
\***
\***         VERSION A : Andrew Wedgeworth  29th June 1992    
\***
\***    VERSION C.              Robert Cowey.                       25 AUG 1993.
\***    Replaced un-used RANK$ with BSNS.CNTR$ and FILLER$.
\***
\***    VERSION D.              Andrew Wedgeworth               15th March 1995
\***    Comments updated to reflect the fact that some bits on the file are
\***    no longer used.
\***
\*******************************************************************************
\*******************************************************************************

  STRING GLOBAL           \
    IDF.FILE.NAME$,       \  
    IDF.BOOTS.CODE$,      \ 4 byte UPD with check digit (key)
    IDF.FIRST.BAR.CODE$,  \ 6 byte UPD without check digit
    IDF.SECOND.BAR.CODE$, \ 6 byte UPD without check digit
    IDF.NO.OF.BAR.CODES$, \ 2 byte UPD. Total number of bar codes for this item
    IDF.PRODUCT.GRP$,     \ 3 byte UPD. The first two digits are the concept
                          \ group and the last four the concept sequence
    IDF.STNDRD.DESC$,     \ 24 bytes
    IDF.STATUS.1$,        \ 1 byte, values B,C,D,P,X,Z and blank
    IDF.INTRO.DATE$,      \ 3 byte UPD YYMMDD. Date first added to this file
    IDF.BSNS.CNTR$,       \ 1 byte ASC. Business Centre ID letter      ! CRC
    IDF.FILLER$,          \ 1 byte un-used                             ! CRC
    IDF.PARENT.CODE$,     \ 4 byte UPD with check digit ; may be zero if no
                          \ flashpacks, current IDF.BOOTS.CODE$ if parent line
                          \ or Boots Code of parent line if a flashpack.
    IDF.DATE.OF.LAST.SALE$! 3 byte UPD. Date of last sale.

  INTEGER*1 GLOBAL        \
    IDF.BIT.FLAGS.1%,     \ 1 byte - bit values
                          \ X"80"  - Group code flag
                          \ X"40"  - Keylines flag
                          \ X"20"  - Markdown flag
                          \ X"10"  - Warehouse flag
                          \ X"08"  - CSR flag
                          \ X"04"  - Directs A flag
                          \ X"02"  - Directs B flag
                          \ X"01"  - Directs C flag
    IDF.BIT.FLAGS.2%      \ 1 byte - bit values
                          \ X"80"  - Own brand line flag
                          \ X"40"  - Exclusive line flag
                          \ X"20"  - Unused 
                          \ X"10"  - Unused
                          \ X"08"  - Stock system flag
                          \ X"04"  - Pending count flag
                          \ X"02"  - Reserved
                          ! X"01"  - Reserved

  INTEGER*2 GLOBAL        \
    IDF.RECL%,            \  
    IDF.REPORT.NUM%,      \ 
    IDF.SESS.NUM%
%INCLUDE IEFDEC.J86     ! IEF Variables                                      !BCS
REM \
\******************************************************************************
\******************************************************************************
\***
\***         %INCLUDE FOR ITEM EAN CODES FILE - FIELD DECLARATIONS
\***                                            FILE REFERENCE PARAMETERS
\***
\***               FILE TYPE    : Keyed
\***
\***               REFERENCE    : IEFDEC.J86
\***
\***    VERSION B.              ROBERT COWEY.                       21 OCT 1993.
\***    No changes to this file.
\***
\*******************************************************************************
\*******************************************************************************

  STRING GLOBAL                      \
    IEF.FILE.NAME$,		     \
    IEF.BOOTS.CODE.BAR.CODE$,        \ 9 byte UPD -                        BBAAS
                                     \ 3 bytes UPD boots code              BBAAS   
                                     \ + 6 UPD bar code,                   BBAAS
                                     \ no check digits. (key)              BBAAS
    IEF.NEXT.BAR.CODE$               ! 6 byte UPD without check digit

  INTEGER*2 GLOBAL        \
    IEF.REPORT.NUM%,	  \
    IEF.SESS.NUM%,	  \ 
    IEF.RECL%
%INCLUDE IRFDEC.J86     ! IRF Variables

\**********************************************************************************
\***
\***       %INCLUDE FOR ITEM RECORD FILE - FIELD DECLARATIONS
\***                                     - FILE REFERENCE PARAMETERS
\***
\***                      FILE TYPE    : Keyed
\***
\***                      REFERENCE    : IRFDEC.J86
\***
\***     Version A               Andrew Wedgeworth            29th June 1992
\***
\***     Version B               Andrew Wedgeworth        14th December 1992
\***     Version letter incremented to match other IRF code.
\***
\***     Version C             Steve Windsor          12.02.93
\***     Version letter incremented to match other IRF code.
\***
\***     Version D             Steve Windsor          12.05.93
\***     Version letter incremented to match other IRF code.
\***
\***     Version E           Steve Perkins       20th September 1993
\***     Deals project : Handling of Converted/Unconverted records
\***     ++   Anything with 'Delete' after initials should be   ++
\***     ++   deleted once the IRF has been converted in all    ++
\***     ++   stores.                                           ++
\***
\***     Version F           Mark Walker            5th January 1994
\***     Version letter incremented to match other IRF code.
\***
\***     Version 96A         Mark Walker               22nd May 1995
\***     Definition for IRF.POINTS% added.
\***
\***                     Stuart McConnachie           12th June 1995
\***     INDICAT3% comments added for discount/loyalty flags.
\***
\***     Version for 96C  Andrew Wedgeworth            22nd May 1996
\***     Removed IRF.FILLER$ field, as this is now redundant.
\***
\***     Version G     Stuart William McConnachie      11th February 2000
\***     Converted IRF.INDICAT2$ to integer flag byte.
\***
\***     REVISION 1.6.               ROBERT COWEY.               9 JUL 2002.
\***     Major changes for 2002 Deals Rewrite project.
\***     Incorporated up to date record layout to assist development work
\***     (placed in the IRFDEC.J86 to make it visible from ...LST files).
\***     Moved various comments against variables to record layout.
\***     Relisted variables in alphabetical order.
\***     Deleted redundant variables associated with the old deals system ...
\***     DEAL.NUM$, DEAL.SAVING$
\***     Retained variables that are otherwise redundant (to be set to null X'00'
\***     within file functions) ...
\***     INDICAT2%, INDICAT4%, SALEQUAN$, POINTS%
\***     Defined variables to hold interpreted deals data for new deals system ...
\***     DEAL.NUM$(n) and LIST.ID%(n) (where 'n' represents entry 0, 1 and 2).
\***     These two variables are interpretations of DEAL.DATA% which is defined
\***     locally within IRFFUN.BAS to keep underlying data invisible to programs.
\***
\***     REVISION 1.7                ROBERT COWEY.               5 AUG 2002.
\***     Further changes for 2002 Deals Rewrite project (PSBF19 related).
\***     Defined NEW.IRF.DATA$ as a global variable for use with new functions
\***     CONCAT.NEW.IRF.DATA$ and SPLIT.NEW.IRF.DATA$.
\***
\***     REVISION 1.8                ROBERT COWEY.              15 JUL 2003.
\***     Usage of INDICAT0% bit-3 X'08' changed to Item Contains Alcohol.
\***     No changes to this file other than description.
\***     No changes to IRF file functions.
\***
\***     REVISION 1.9.      STUART WILLIAM MCCONNACHIE           22 OCT 2003.
\***     Changes to remove limit of 3 deals per item.
\***     Declaration of new variables for IRF Deal Extension file (IRFDEX).
\***
\***     REVISION 2.0.            ALAN CARR                       9 FEB 2006.
\***     Add new IRF.INDICAT8% 1 byte, amend IRF.UNUSED$ from 3 to 2 bytes.
\***
\***     REVISION 2.1              TITTOO THOMAS                  01 July 2011
\***     The IRF.UNUSED field is disintegrated to 2 new indicator fields
\***                      IRF.INDICAT9%   1 INT
\***                      IRF.INDICAT10%  1 INT
\***...............................................................................


\**********************************************************************************
\***
\***    IRF RECORD LAYOUT - REVISION 1.7 - CORRECT FOR 2011 CORE Stores PROJECT
\***
\***     1 11  UPD  BAR.CODE$   Without check digit - File KEY
\***    12  1  INT  INDICAT0%
\***                    X"01" - Contains statins                           ! 2.2 TT
\***                    X"02" - Item not priced (giveaway)
\***                    X"04" - Item not returnable
\***                    X"08" - Item contains alcohol
\***                    X"10" - Blocked from sale                          ! 2.2 TT
\***                    X"20" - Enforced price entry
\***                    X"40" - Enforced quantity entry
\***                    X"80" - Movement kept
\***    13  1  INT  INDICAT1%
\***                    X"01" - Asprin
\***                    X"02" - Paracetamol
\***                    X"04" - TPLU inclusion flag
\***                    X"08" - Giftcard item                              ! 2.2 TT
\***                    X"10" - Withdrawn Block from sale                  ! 2.2 TT
\***                    X"20" - Non-solid dose painkiller                  ! 2.2 TT
\***                    X"40" - Insurance policy item                      ! 2.2 TT
\***                    X"80" - Ibuprofen
\***    14  2  INT  DEAL.DATA%(0)   Interpreted into sub-variables ...
\***                    X'3F' - into DEAL.NUM$(0) "0000" to "9999" (2 byte UPD)
\***                    X'C0' - into LIST.ID%(0) X'00' X
\***                                             X'01' A
\***                                             X'10' B
\***                                             X'11' C                   ! 1.9 RC
\***    16  1  INT  INDICAT8%                                              ! 2.0 AJC
\***                    X"01" - Chlamydia NHS test kit                     ! 2.2 TT
\***                    X"02" - Chlamydia open sell test kit               ! 2.2 TT
\***                    X"04" - Unrestricted group code                    ! 2.2 TT
\***                    X"08" - Nightingale Till prompt                    ! 2.2 TT
\***                    X"10" - Contains Ephedrine                         ! 2.2 TT
\***                    X"60" -  X'00' - If also Blocked From Sale Recall, ! 2.2 TT
\***                                        Emergency                      ! 2.2 TT
\***                             X'00' - If NOT Blocked From Sale Recall,  ! 2.2 TT
\***                                        No recall                      ! 2.2 TT
\***                             X'20' 100% returns                        ! 2.2 TT
\***                             X'40' Withdrawn recall                    ! 2.2 TT
\***                             X'60' Reverse Logistics                   ! 2.2 TT
\***                    X"80" - WEEE item flag                             ! 2.0 AJC
\***    17  1  INT  INDICAT9%
\***                    X'3F' - Disposal special instruction (0-63)
\***                    X"40" - Resaleable Indicator
\***                    X"80" - Boots.com Extended Indicator
\***    18  1  INT  INDICAT10%
\***                    X'07' - Age restrictions
\***                             X'00' - No Age restriction
\***                             X'01' - Age 12 or over
\***                             X'02' - Age 15 or over
\***                             X'03' - Age 16 or over
\***                             X'04' - Age 18 or over
\***                             X'05' - Age 21 or over
\***                             X'06' - Reserved
\***                             X'07' - Reserved
\***                    X'38' - Ethical classification
\***                             X'00' - No ethical classification
\***                             X'08' - Pharmacy medicine (P)
\***                             X'10' - General Sale License (GSL)
\***                             X'18' - Prescription Only Medicine (POM)
\***                             X'20' - Reserved
\***                             X'28' - Reserved
\***                             X'30' - Reserved
\***                             X'38' - Reserved
\***                    X'C0' - Returns route
\***                             X'00' - Not Returnable (Destroy)
\***                             X'40' - Returns & Recovery
\***                             X'80' - Direct
\***                             X'C0' - Semi-centralised
\***    19  5  UPD  SALEPRIC$   Current price in pence
\***    24  1  INT  INDICAT5%   Guarantee duration
\***                    X'3F' - Lowest 6 bits indicate duration (1-63)
\***                    X'40' - Contains Pseudoephedrine                   ! 2.2 TT
\***                    X'80' - Guarantee Duration Type                    ! 2.2 TT
\***                              (1 = Months, 0 = Years)                  ! 2.2 TT
\***    25 18  ASC  ITEMNAME$   Description used by till
\***    43  3  UPD  BOOTS.CODE$ Without check digit
\***    46  2  INT  DEAL.DATA%(1)   Similar structure to DEAL.DATA%(0)
\***    48  2  INT  DEAL.DATA%(2)   Similar structure to DEAL.DATA%(0)
\***    50  1  INT  INDICAT3%
\***                    X"01" - Discountexempt (item exempt from discount)
\***                    X"02" - Boots brand item
\***                    X"04" - Item redeemable for loyalty
\***                    X"08" - Loyalty exempt (item exempt from loyalty)
\***                    X"10" - **Redundant                                ! 2.2 TT
\***                    X"20" - Local Price active
\***                    X"40" - Stock system item
\***                    X"80" - **Redundant                                ! 2.2 TT
\***
\***    Record Length 50
\***
\***
\***    IRF DEAL EXTENSION RECORD LAYOUT ! 1.9 RC
\***
\***     1  3  UPD  BOOTS.CODE$
\***     4  2  INT  IRF.DEAL.DATA%(3)   Similar structure to DEAL.DATA%(0)
\***     6  2  INT  IRF.DEAL.DATA%(4)   Similar structure to DEAL.DATA%(0)
\***     8  2  INT  IRF.DEAL.DATA%(5)   Similar structure to DEAL.DATA%(0)
\***    10  2  INT  IRF.DEAL.DATA%(6)   Similar structure to DEAL.DATA%(0)
\***    12  2  INT  IRF.DEAL.DATA%(7)   Similar structure to DEAL.DATA%(0)
\***    14  2  INT  IRF.DEAL.DATA%(8)   Similar structure to DEAL.DATA%(0)
\***    16  2  INT  IRF.DEAL.DATA%(9)   Similar structure to DEAL.DATA%(0)
\***
\***    Record Length 17
\***
\**********************************************************************************


    STRING GLOBAL            \
        IRF.ALT.FILE.NAME$,  \
        IRF.BAR.CODE$,       \
        IRF.BOOTS.CODE$,     \
        IRF.DEAL.SAVING$,    \ 2 byte - deal saving amount (0 - œ99.99) ! ESP
        IRF.DEPARTME$,       \ 3 byte UPD. Department number          ! ESP Delete
        IRF.FILE.NAME$,      \
        IRF.HOLDING.PRICE$,  \ 4 byte UPD. Current H.O. price in pence if a local
                             \ price is in effect, zero otherwise.     ! ESP Delete
        IRF.ITEMNAME$,       \
\       IRF.MPGROUP$,        \ Removed SBH 31/1/96
        IRF.RECORD$,         \                                         ! ESP Delete
        IRF.SALEPRIC$,       \
        IRF.SALEQUAN$,       \ Redundant (set to null within functions)    ! 1.6 RC
        IRF.UNUSED$,         \                                                        ! 1.6 RC
        NEW.IRF.DATA$        !                                             ! 1.7 RC

    STRING GLOBAL            \                                             ! 1.6 RC
        IRF.DEAL.NUM$(1)                                                   ! 1.6 RC

    INTEGER*1 GLOBAL         \
        IRF.DD.SUB%,         \ IRF.DEAL.DATA% subscript                    ! 1.6 RC
        IRF.INDICAT0%,       \
        IRF.INDICAT1%,       \
        IRF.INDICAT2%,       \ Redundant (set to null within functions)    ! 1.6 RC
        IRF.INDICAT3%,       \
        IRF.INDICAT4%,       \ Redundant (set to null within functions)    ! 1.6 RC
        IRF.INDICAT5%,       \                                             ! 2.0 AJC
        IRF.INDICAT8%,       \                                             ! 2.0 AJC
        IRF.INDICAT9%,       \                                             ! 2.2 TT
        IRF.INDICAT10%                                                     ! 2.2 TT

    INTEGER*1 GLOBAL         \                                             ! 1.6 RC
        IRF.LIST.ID%(1)                                                    ! 1.6 RC

    INTEGER*2 GLOBAL         \
        IRF.ALT.REPORT.NUM%, \
        IRF.ALT.SESS.NUM%,   \
        IRF.POINTS%,         \ Redundant (set to null within functions)    ! 1.6 RC
        IRF.RECL%,           \
        IRF.REPORT.NUM%,     \
        IRF.SESS.NUM%,       \
        IRF.MAX.DEALS%       !                                             ! 1.9 SM

    STRING GLOBAL IRFDEX.FILE.NAME$                                        ! 1.9 SM

    INTEGER*2 GLOBAL IRFDEX.SESS.NUM%                                      ! 1.9 SM
    INTEGER*2 GLOBAL IRFDEX.REPORT.NUM%                                    ! 1.9 SM
    INTEGER*2 GLOBAL IRFDEX.RECL%                                          ! 1.9 SM


!   INTEGER*2 GLOBAL      \ IRF.DEAL.DATA%(n) variables are defined locally  1.6 RC
!       IRF.DEAL.DATA%(1) \ within IRFFUN.BAS to keep invisible to programs  1.6 RC

%INCLUDE PSBF01G.J86    ! APPLICATION.LOG
REM \
\*******************************************************************************
\*******************************************************************************
\***
\***       %INCLUDE FOR GLOBAL DEFINITIONS FOR FUNCTION APPLICATION.LOG
\***
\***                FUNCTION NUMBER    : PSBF01
\***
\***                REFERENCE          : PSBF01G.J86
\***
\***                DATE OF LAST AMENDMENT  - 27/2/86
\***
\***
\*******************************************************************************

      INTEGER GLOBAL  F01.RETURN.CODE%


%INCLUDE PSBF11G.J86    ! Gets next barcode in an IEF chain                  !BCS
REM \
\*******************************************************************************
\*******************************************************************************
\***
\***    %INCLUDE FOR GLOBALS DEFINITIONS FOR FUNCTION READ.NEXT.IEF
\***
\***            FUNCTION NUMBER    : PSBF11
\***
\***            REFERENCE          : PSBF11G.J86
\***
\***    Version B            Bruce Scriver             11th December 1986 
\***
\***    Version C            Andrew Wedgeworth             15th July 1992
\***    Redundant return code field removed.
\***
\*******************************************************************************
\*******************************************************************************

      STRING    GLOBAL  F11.ERROR.FLAG$,                               \ BBAAS
                        F11.NEXT.BAR.CODE$                             ! BBAAS

      INTEGER*2 GLOBAL  F11.CURRENT.COUNT%


%INCLUDE PSBF20G.J86    ! GLOBAL VARIABLE DEFINITIONS FOR SESS.NUM.UTILITY FUNCTION
REM\
\*******************************************************************************
\*******************************************************************************
\***
\***     %INCLUDE GLOBAL VARIABLE DEFINITIONS FOR SESS.NUM.UTILITY FUNCTION
\***
\***                       REFERENCE     : PSBF20G.J86
\*** 
\***     Version A              Bruce Scrive                   5th May 1988   
\*** 
\***     Version B              Robert Cowey                   7th May 1991
\***     Global variable F20.INTEGER.FILE.NO% changed from one byte integer
\***     to two byte integer.
\***
\***     Version D              Andrew Wedgeworth             1st July 1992
\***     F20.RETURN.CODE% removed as it is no longer required.
\***
\*******************************************************************************
\*******************************************************************************

      STRING    GLOBAL F20.FILE.NAME$,                                 \
                       F20.STRING.FILE.NO$,                            \
                       F20.TABLE.DIMENSIONED.FLAG$,                    \
                       SESS.NUM.TABLE$(1)

      INTEGER*2 GLOBAL F20.INTEGER.FILE.NO%

      ! 1 line deleted from here                                       ! DAW 


  
STRING GLOBAL                             \
     CURRENT.CODE$,                       \
     FILE.OPERATION$                      !

INTEGER*1 TRUE,                           \
          FALSE,                          \
          EVENT.NUM%                      !
          
INTEGER*2 I%,                             \
          J%,                             \
          CURRENT.REPORT.NUM%,            \
          DATE.FORMAT%,                   \
          ERROR.COUNT%,                   \
          ERR.REPORT.NUM%,                \
          ERR.SESS.NUM%,                  \
          EXPCTD.NO.CODES%,               \                                  !BCS
          INDEX%,                         \                                  !BCS
          MESSAGE.NUMBER%,                \
          BLOCKITM.SESS.NUM%,             \
          INPUT.RECL%,                    \
          INPUT.REPORT.NUM%,              \
          INPUT.SESS.NUM%,                \
          OK.REPORT.NUM%,                 \
          OK.SESS.NUM%,                   \
          LOG.REPORT.NUM%,                \
          LOG.SESS.NUM%,                  \
          WRN.REPORT.NUM%,                \                                  !DCS
          WRN.SESS.NUM%,                  \                                  !DCS
          SB.FILE.REP.NUM%,               \
          SB.FILE.SESS.NUM%,              \
          SB.INTEGER%                     !
                                 
                              
INTEGER*4 ADXSERVE.RET.CODE%,             \
          ADX.RC%,                        \
          INPUT.REC.NO%,                  \
          RC%                             !

STRING    ADXSERVE.DATA$,                 \
          ADX.DATA$,                      \
          BMESG$,                         \
          CMD.LINE$,                      \
          COMM.MODE.FLAG$,                \
          CURRENT.IEF.BAR.CODE$,          \                                  !BCS
          ERROR.OVERRIDE.FLAG$,           \
          GENUINE.ERROR.FLAG$,            \                                  !DCS
          BLOCKITM.COMPLETION.MSG$,       \
          BLOCKITM.ERR.PATH$,             \
          BLOCKITM.INPUT.PATH$,           \
          BLOCKITM.OK.PATH$,              \
          BLOCKITM.LOG.PATH$,             \
          BLOCKITM.WRN.PATH$,             \                                  !DCS
          BLOCKITM.PATH$,                 \
          INPUT.FILLER$,                  \
          INPUT.BOOTS.CODE$,              \
          MSG$,                           \                                  !DCS
          MODULE$,                        \       
          MODULE.NUMBER$,                 \
          NULL.BAR.CODE$,                 \                                  !BCS
          PARAM$,                         \
          PROGRAM$,                       \
          LOG.FILE.OPEN$,                 \      
          RUN.DATE$,                      \
          RUN.TIME$,                      \
          SB.ACTION$,                     \
          SB.STRING$,                     \
          SB.FILE.NAME$,                  \
          SKIP.PAST.ITEM.DUE.TO.ERROR$,   \                                  !BCS
          UPD.BAR.CODE$,                  \                                  !BCS
          VAR.STRING.1$,                  \
          VAR.STRING.2$,                  \
          VERSION$                        !                                  !DCS


%INCLUDE ADXSERVE.J86
\******************************************************************************
\******************************************************************************
\***                                                                        ***
\***    %INCLUDE FOR FUNCTION ADXSERVE (an I.B.M. system function)          ***
\***                                                                        ***
\***         AUTHOR        :  Bruce Scriver                                 ***
\***                                                                        ***
\***         DATE WRITTEN  :  14th March 1986                               ***
\***                                                                        ***
\***         DATE OF LAST REVISION  - 14th March 1986                       ***
\***                                                                        ***
\***                                                                        ***
\******************************************************************************
\******************************************************************************

   SUB ADXSERVE (RETURN.CODE%,                                                \
                 ADX.FUNCTION%,                                               \
                 ADX.PARM.1%,                                                 \
                 ADX.PARM.2$)                                                 \
   EXTERNAL
  
      STRING     ADX.PARM.2$

      INTEGER*2  ADX.FUNCTION%,                                               \
                 ADX.PARM.1%

      INTEGER*4  RETURN.CODE%                                                 \

   END SUB     

%INCLUDE ERRNH.J86      ! Hex Error Number
\******************************************************************************
\***
\***	FUNCTION ERRNH
\***
\***	Convert the 4-byte error number to an 8-byte ASCII string
\***
\******************************************************************************

	FUNCTION ERRNH PUBLIC

	STRING			ERRNH,					\
				E$

	INTEGER*2		I%
	INTEGER*4		H%

	E$ = ""
	H% = ERRN

	FOR I% = 28 TO 0 STEP -4
	    E$ = E$ + CHR$((SHIFT(H%,I%) AND 000FH) + 48)
	NEXT I%

	ERRNH = TRANSLATE$(E$,":;<=>?","ABCDEF")

	END FUNCTION
%INCLUDE IDFEXT.J86     ! IDF FILE FUNCTIONS                                 !BCS
\*******************************************************************************
\***                                                                         ***
\***      EXTERNAL FUNCTION DEFINITIONS FOR THE ITEM DESCRIPTION FILE        ***
\***                                                                         ***
\***                       REFERENCE : IDFEXT.J86                            ***
\***                                                                         ***
\***      Version A           Andrew Wedgeworth         9th July 1992        ***
\***
\***    VERSION C.              Robert Cowey.                       25 AUG 1993.
\***    No changes to this file.
\***
\***   VERSION D               Nik Sen                 22nd December 1994
\***   WRITE.IDF.HOLD added
\***
\*******************************************************************************

       FUNCTION IDF.SET EXTERNAL                                      
       END FUNCTION                                                   


       FUNCTION READ.IDF EXTERNAL                                     
          INTEGER*2 READ.IDF                                          
       END FUNCTION                                                   


       FUNCTION READ.IDF.LOCK EXTERNAL                                
          INTEGER*2 READ.IDF.LOCK                                     
       END FUNCTION                                                   

       FUNCTION WRITE.IDF EXTERNAL
          INTEGER*2 WRITE.IDF
       END FUNCTION	       

       FUNCTION WRITE.IDF.HOLD EXTERNAL
          INTEGER*2 WRITE.IDF.HOLD
       END FUNCTION

       FUNCTION WRITE.IDF.UNLOCK EXTERNAL                                  
          INTEGER*2 WRITE.IDF.UNLOCK                                      
       END FUNCTION                                                   
%INCLUDE IEFEXT.J86     ! IEF FILE FUNCTIONS                                 !BCS
\*****************************************************************************
\*****************************************************************************
\***
\***         EXTERNAL FUNCTION DEFINITIONS FOR IEF
\***
\***         REFERENCE: IEFEXT.J86
\***
\***    VERSION B.              ROBERT COWEY.                       21 OCT 1993.
\***    No changes to this file.
\***
\*******************************************************************************
\*******************************************************************************

   FUNCTION IEF.SET EXTERNAL
   END FUNCTION
   
   FUNCTION READ.IEF EXTERNAL
      INTEGER*2 READ.IEF
   END FUNCTION
   
   FUNCTION WRITE.IEF EXTERNAL
      INTEGER*2 WRITE.IEF
   END FUNCTION
   
   
%INCLUDE IRFEXT.J86     ! IRF FILE FUNCTIONS
\*********************************************************************************
\***
\***      EXTERNAL FUNCTION DEFINITIONS FOR THE ITEM REFERENCE FILE
\***
\***                    REFERENCE : IRFEXT.J86
\***
\***      Version A          Andrew Wedgeworth        9th July 1992
\***
\***      Version B          Andrew Wedgeworth        14th December 1992
\***      Version letter incremented to match other IRF code.
\***
\***      Version C           Steve Windsor        12.02.93
\***      Added external reference to read the alternate IRF.
\***
\***      Version D           Steve Windsor        12.05.93
\***      Added all external references that wre in the original FNS.
\***
\***      Version E           Steve Perkins        21.09.93
\***      Deals project: Fields changed for new deals project
\*** 
\***      Version F           Mark Walker          5th January 1994
\***      Version letter incremented to match other IRF code.           
\***                                                                    
\***      Version G     Stuart William McConnachie      11th February 2000
\***      Converted IRF.INDICAT2$ to integer flag byte.
\***
\***      REVISION 1.6.               ROBERT COWEY.               9 JUL 2002.
\***      Major changes to IRF layout for 2002 Deals Rewrite project.
\***      No changes to this particular file for this revision.
\***
\***      REVISION 1.7.               ROBERT COWEY.               5 AUG 2002.
\***      Further changes for 2002 Deals Rewrite project (PSBF19 related).
\***      Defined new functions CONCAT.NEW.IRF.DATA$ and SPLIT.NEW.IRF.DATA$.
\***
\***      REVISION 1.8                ROBERT COWEY.              15 JUL 2003.
\***      Usage of INDICAT0% bit-3 X'08' changed to Item Contains Alcohol.
\***      No changes to this file other than description.
\***      No changes to IRF file functions.
\***
\***      REVISION 1.9.      STUART WILLIAM MCCONNACHIE           22 OCT 2003.
\***      Changes to remove limit of 3 deals per item.
\***      No changes to this file.
\***
\***      REVISION 2.0.             ALAN CARR                      9 FEB 2006.
\***      Add new IRF.INDICAT8% 1 byte, amend IRF.UNUSED$ from 3 to 2 bytes.
\***      No changes to this file.
\***
\***..............................................................................
   
   FUNCTION IRF.SET EXTERNAL
   END FUNCTION

  FUNCTION CONCAT.NEW.IRF.DATA$ EXTERNAL                                  ! 1.7 RC
  END FUNCTION                                                            ! 1.7 RC

  FUNCTION SPLIT.NEW.IRF.DATA$ EXTERNAL                                   ! 1.7 RC
  END FUNCTION                                                            ! 1.7 RC
  
  FUNCTION READ.IRF EXTERNAL
   INTEGER*2 READ.IRF
  END FUNCTION

  FUNCTION READ.IRF.ALT EXTERNAL
   INTEGER*2 READ.IRF.ALT
  END FUNCTION

  FUNCTION READ.IRF.LOCK EXTERNAL
   INTEGER*2 READ.IRF.LOCK
  END FUNCTION

  FUNCTION WRITE.IRF EXTERNAL
   INTEGER*2 WRITE.IRF
  END FUNCTION

  FUNCTION WRITE.IRF.UNLOCK EXTERNAL
   INTEGER*2 WRITE.IRF.UNLOCK
  END FUNCTION

  FUNCTION WRITE.IRF.HOLD EXTERNAL
   INTEGER*2 WRITE.IRF.HOLD
  END FUNCTION

  FUNCTION WRITE.IRF.HOLD.UNLOCK EXTERNAL
   INTEGER*2 WRITE.IRF.HOLD.UNLOCK
  END FUNCTION

  
%INCLUDE PSBF01E.J86    ! APPLICATION.LOG
REM \
\*******************************************************************************
\*******************************************************************************
\***
\***      %INCLUDE FOR EXTERNAL DEFINITION OF FUNCTION APPLICATION.LOG
\***
\***                      FUNCTION NUMBER   : PSBF01
\***
\***                    INCLUDE REFERENCE : PSBF01E.J86
\*** 
\***      Version B           Andrew Wedgeworth          1st July 1992
\***      Three parameters which passed to the function have been removed.
\***      APPLICATION.LOG has been added as a variable name (this holds the
\***      return code).
\***
\*******************************************************************************


   FUNCTION APPLICATION.LOG (MESSAGE.NO%,                                     \
                             VAR.STRING.1$,                                   \
                             VAR.STRING.2$,                                   \
                             EVENT.NO%)  EXTERNAL

      INTEGER*1 EVENT.NO%

      INTEGER*2 APPLICATION.LOG,                                       \ GAW
                MESSAGE.NO%

      STRING VAR.STRING.1$,                                            \
             VAR.STRING.2$

   END FUNCTION

\*******************************************************************************
%INCLUDE PSBF11E.J86    ! Gets next barcode in an IEF chain                  !BCS
REM \
\*******************************************************************************
\*******************************************************************************
\***
\***    %INCLUDE FOR EXTERNAL DEFINITION OF FUNCTION READ.NEXT.IEF
\***
\***
\***            FUNCTION NUMBER       : PSBF11
\***
\***            INCLUDE REFERENCE     : PSBF11E.J86
\***
\***            DATE OF LAST AMENDMENT -  3rd March 1986
\***
\***     Version B             Andrew Wedgeworth          15th July 1992
\***     Removal of redundant function parameters.  READ.NEXT.IEF defined as
\***     a variable to hold the return code.
\***
\*******************************************************************************
\*******************************************************************************

REM \
\*******************************************************************************
\*******************************************************************************
\***
\***
\***            FUNCTION OVERVIEW
\***            -----------------
\***
\***   This function finds and retreives the next bar code in an IEF chain.
\***   If the code found is the last code in the chain, the function checks that
\***   the number of codes in the chain is equal to the expected number.  If it
\***   is not, a message is displayed and logged.  If an error occurs in reading
\***   the IEF, a message is displayed and logged, and the function returns to
\***   the calling program with a return code of 1.
\***
\***
\*******************************************************************************
\*******************************************************************************

   FUNCTION READ.NEXT.IEF (LAST.BAR.CODE$,                             \
                           TOTAL.COUNT%,                               \
                           BOOTS.CODE$)  EXTERNAL
   ! 3 parameters deleted from here                                    ! BAW			   

      STRING  BOOTS.CODE$,                                             \
              LAST.BAR.CODE$
      ! 3 variables removed from here                                  ! BAW

      INTEGER*2 READ.NEXT.IEF,                                         \ BAW
                TOTAL.COUNT%
             


   END FUNCTION

\*******************************************************************************
%INCLUDE PSBF20E.J86    ! GLOBAL VARIABLE DEFINITIONS FOR SESS.NUM.UTILITY FUNCTION
REM\
\*******************************************************************************
\*******************************************************************************
\***
\***       %INCLUDE FOR EXTERNAL DEFINITION OF SESS.NUM.UTILITY
\***
\***                  REFERENCE     : PSBF20E.J86
\***
\***     VERSION C            Janet Smith                13th May 1992
\***     Increased PASSED.INTEGER to 2 bytes to cater for more than
\***     128 files.
\***
\***     VERSION D.           Andrew Wedgeworth          1st July 1992
\***     Removal of redundant parameters and addition of SESS.NUM.UTILITY
\***     as a variable.  This new variable contains the function's return
\***     code.
\***
\*******************************************************************************
\*******************************************************************************

   FUNCTION SESS.NUM.UTILITY (FUNCTION.FLAG$,                          \
                              PASSED.INTEGER%,                         \
                              PASSED.STRING$)                          \
   EXTERNAL

   STRING    FUNCTION.FLAG$,                                           \
             PASSED.STRING$
   ! 3 variables removed from here                                     ! CAW


   INTEGER*2 SESS.NUM.UTILITY,                                         \ CAW
             PASSED.INTEGER%				               ! CJAS

   END FUNCTION

%INCLUDE PSBF24E.J86    ! STANDARD.ERROR.DETECTED
REM \
\*******************************************************************************
\*******************************************************************************
\***
\***    %INCLUDE FOR EXTERNAL DEFINITION OF STANDARD.ERROR.DETECTED FUNCTION
\***
\***                      REFERENCE     : PSBF24E.J86
\***
\***    Version A                 Janet Smith                  13th May 1992
\***
\*******************************************************************************
\*******************************************************************************

   FUNCTION STANDARD.ERROR.DETECTED(ERRN%,                 \
				    ERRFILE%,              \
				    ERRL%,                 \
				    ERR$)        EXTERNAL
				    
          STRING    ERR$

          INTEGER*2 ERRFILE%,              \
	            ERRL%,                 \
		    STANDARD.ERROR.DETECTED
		    
          INTEGER*4 ERRN%
	  		    
   END FUNCTION


%INCLUDE PSBF30E.J86    ! PROCESS KEYED FILE                                 !ECS
\*****************************************************************************
\*****************************************************************************
\***
\***                 EXTERNAL FUNCTION DEFINITION PSBF30
\***
\*****************************************************************************
\*****************************************************************************

\*****************************************************************************
\*****************************************************************************
\***
\***   Version 96A              Mark Walker                31st May 1995
\***   Original version.
\***
\***   Version B                Andrew Wedgeworth          17th March 1997
\***   Added READONLY$ variable.  This parameter may be used to specify 
\***   whether the file is to be opened with the READONLY option.
\***
\*****************************************************************************
\*****************************************************************************
 
       FUNCTION PROCESS.KEYED.FILE(FILE.NAME$,                         \ 
                                   REPORT.NUM%,                        \  
                                   READONLY$) EXTERNAL

       STRING FILE.NAME$,READONLY$
       INTEGER*2 PROCESS.KEYED.FILE,REPORT.NUM%

       END FUNCTION




    
\******************************************************************************
\***
\***    DO.MESSAGE 
\***
\******************************************************************************

SUB DO.MESSAGE(MESG$)

    INTEGER*2 STATUS%
    STRING MESG$
    
    IF STATUS% = 0 THEN BEGIN
        CALL ADXSERVE (ADXSERVE.RET.CODE%,26,0,MESG$)
        IF ADXSERVE.RET.CODE% <> 0 THEN BEGIN
            STATUS% = 1 !FOREGROUND
            PRINT MESG$
        ENDIF ELSE BEGIN
            STATUS% = 2 !BACKGROUND
        ENDIF
    ENDIF ELSE IF STATUS% = 1 THEN BEGIN
        PRINT MESG$
    ENDIF ELSE BEGIN
        CALL ADXSERVE (ADXSERVE.RET.CODE%,26,0,MESG$)
    ENDIF
    
    IF LOG.FILE.OPEN$ = "Y" THEN BEGIN
          PRINT # LOG.SESS.NUM%; MESG$
    ENDIF
    
END SUB
        
        
\******************************************************************************
\***
\***    GETN1
\***
\******************************************************************************

FUNCTION GETN1 (S$, OFFSET%)
    INTEGER*2 GETN1
    STRING S$
    INTEGER*2 OFFSET%
    GETN1 = ASC(MID$(S$, OFFSET%+1, 1))
END FUNCTION
    
    
\******************************************************************************
\***
\***    Format date    YYYYMMDD --> DD/MM/YYYY
\***
\******************************************************************************

FUNCTION FORMAT.DATE$ (FIELD$)

    STRING      FIELD$
    STRING      FORMAT.DATE$

    FORMAT.DATE$ = MID$(FIELD$, 5, 2) + "/" +                     \
                   MID$(FIELD$, 3, 2) + "/20" +                   \
                   MID$(FIELD$, 1, 2)

END FUNCTION


\******************************************************************************
\***
\***    Format Time      HHMMSS --> HH:MM                               
\***
\******************************************************************************

FUNCTION FORMAT.TIME$ (FIELD$)

    STRING      FIELD$
    STRING      FORMAT.TIME$


    FORMAT.TIME$ = MID$(FIELD$, 1, 2) +   \
                   ":"                +   \
                   MID$(FIELD$, 3, 2)

END FUNCTION


\******************************************************************************
\***                                                                          *
\***   FUNCTION : READ.INPUT                                                  *
\***                                                                          *
\******************************************************************************
\***                                                                          *
\***  Reads the Input file.                                                   *
\***                                                                          *
\******************************************************************************

FUNCTION READ.INPUT PUBLIC

      INTEGER*2 READ.INPUT

      READ.INPUT = 1

      IF END # INPUT.SESS.NUM% THEN READ.ERROR
      READ FORM "C7,C2"; #INPUT.SESS.NUM%, INPUT.REC.NO%;   \
               INPUT.BOOTS.CODE$, \
               INPUT.FILLER$

      READ.INPUT = 0
   EXIT FUNCTION


READ.ERROR:

      FILE.OPERATION$     = "R"
      CURRENT.REPORT.NUM% = INPUT.REPORT.NUM%
      CURRENT.CODE$       = ""

END FUNCTION


\********************************************************************************
\***                                                                     !ECS   *
\***      READ.AND.UPDATE.IRF                                                   *
\***                                                                            *
\***                                                                            *
\********************************************************************************

SUB READ.AND.UPDATE.IRF

    IRF.BAR.CODE$ = UPD.BAR.CODE$
    
    RC% = READ.IRF.LOCK
    
    IF RC% = 0 THEN BEGIN ! Item exists on IRF file
        IF CMD.LINE$ = "YES" THEN BEGIN
            ! Set Item Not Authorised for Sale Bit flag 5
            IRF.INDICAT0% = IRF.INDICAT0% OR 00010000B  
            ! Set Recall Reason Type Bit flags 6 & 7
            IRF.INDICAT8% = IRF.INDICAT8% OR 01100000B  
        ENDIF ELSE BEGIN ! "NO"
            ! Reset Item Not Authorised for Sale Bit flag 5
            IRF.INDICAT0% = IRF.INDICAT0% AND 11101111B  
            ! Reset Recall Reason Type Bit flags 6 & 7
            IRF.INDICAT8% = IRF.INDICAT8% AND 10011111B  
        ENDIF
        
        RC% = WRITE.IRF.UNLOCK

        IF RC% = 0 THEN BEGIN ! Item updated successfully on IRF file
            CALL DO.MESSAGE(STR$(INPUT.REC.NO%) + ":" + UNPACK$(UPD.BAR.CODE$) + " " + BMESG$)
        ENDIF ELSE BEGIN
            MSG$ = STR$(INPUT.REC.NO%) + ":" + UNPACK$(UPD.BAR.CODE$) + " ERROR - CANNOT UPDATE"  !DCS
            CALL DO.MESSAGE(MSG$)                                                                 !DCS
            PRINT # WRN.SESS.NUM%; MSG$                                                           !DCS
            ! Carry on processing but set error override flag so that error is captured
            ! ie. BLOCKITM.ERR file is produced
            ERROR.OVERRIDE.FLAG$ = "Y"
            SKIP.PAST.ITEM.DUE.TO.ERROR$ = "Y"                                                            
            GENUINE.ERROR.FLAG$  = "Y"                                                            !DCS
        ENDIF
        
    ENDIF ELSE BEGIN
        MSG$ = STR$(INPUT.REC.NO%) + ":" + UNPACK$(UPD.BAR.CODE$) + " ** NOT ON FILE **"      !DCS
        CALL DO.MESSAGE(MSG$)                                                                 !DCS
        PRINT # WRN.SESS.NUM%; MSG$                                                           !DCS
    ENDIF

END SUB



\********************************************************************************
\***                                                                     !ECS   *
\***      PROCESS.KEYED.RECORD$                                                 *
\***                                                                            *
\***      'User exit' for PROCESS.KEYED.FILE (PSBF30)                           *
\***                                                                            *
\********************************************************************************

FUNCTION PROCESS.KEYED.RECORD$(RECORD$) PUBLIC
            
    STRING PROCESS.KEYED.RECORD$,  \
           RECORD$    
    
    IF MID$(RECORD$,43, 3) = IRF.BOOTS.CODE$ THEN BEGIN
    
        CALL DO.MESSAGE("    Updating Barcode: " + UNPACK$(LEFT$(RECORD$,11)) )
        
        IRF.INDICAT0% = ASC(MID$(RECORD$,12, 1))
        IRF.INDICAT8% = ASC(MID$(RECORD$,16, 1)) 
        UPD.BAR.CODE$ = LEFT$(RECORD$,11)
        
        CALL READ.AND.UPDATE.IRF
    ENDIF
    
    PROCESS.KEYED.RECORD$ = RECORD$      

END FUNCTION


    
!****************************************************************************
!****************************************************************************
!****************************************************************************
!****************************************************************************
!****************************************************************************
!****                                                                    ****
!****             S T A R T   O F   M A I N   P R O G R A M              ****
!****                                                                    ****
!****************************************************************************
!****************************************************************************
!****************************************************************************
!****************************************************************************
!****************************************************************************

ON ERROR GOTO ERROR.DETECTED

    GOSUB INITIALISATION
    
    GOSUB MAIN.PROCESSING

    GOSUB TERMINATION
    
ABORT.PROGRAM:

    STOP


!**************************************************************************
!***
!***    INITIALISATION:
!***
!***    Set up global variables.
!***    Display initial message.
!***    Determine if running in background.
!***
!**************************************************************************

INITIALISATION:

      
      PROGRAM$           EQ "BLOCKITM"
      MODULE$            EQ ""
      MODULE.NUMBER$     EQ  PROGRAM$ + MODULE$

      VERSION$ = "5.0  14/10/09"                                             !DCS !ECS
      
      ERROR.OVERRIDE.FLAG$ = "N"
      GENUINE.ERROR.FLAG$  = "N"                                             !DCS
      LOG.FILE.OPEN$ = "N"
      TRUE  = -1
      FALSE = 0
      
      ERROR.COUNT% = 0
      INPUT.RECL%  = 9  ! 7-digit Boots Item code + CRLF
      
      NULL.BAR.CODE$ = PACK$(STRING$(12,"0"))                                !BCS
      
      !------------------------
      ! Check Parameters passed
      !------------------------
      CMD.LINE$ = COMMAND$
      CMD.LINE$ = UCASE$(CMD.LINE$)
      
      CLEARS
      
      IF CMD.LINE$ <> "" THEN BEGIN  ! Only display if parameter passed      !DCS
          CALL DO.MESSAGE("BLOCKITM.286 (ver: " + VERSION$ + ")")            !DCS
          CALL DO.MESSAGE("Initialisation")                                  !DCS
          CALL DO.MESSAGE("CMD.LINE$: " + CMD.LINE$)                         !DCS
      ENDIF                                                                  !DCS
      
      IF CMD.LINE$ <> "YES" AND CMD.LINE$ <> "NO" THEN BEGIN   
          CALL DO.MESSAGE("                              BLOCKITM.286 (ver: " + VERSION$ + ")")
          CALL DO.MESSAGE("                              ============")
          CALL DO.MESSAGE(" This program blocks or unblocks items for sale at the till.")
          CALL DO.MESSAGE("")
          CALL DO.MESSAGE("               USAGE: BLOCKITM YES")
          CALL DO.MESSAGE("                      BLOCKITM NO")
          CALL DO.MESSAGE("")
          CALL DO.MESSAGE(" This program reads an input text file:- ADXLXAAN::C:\BLOCKITM.DAT")
          CALL DO.MESSAGE(" which contains a list of 7-digit Boots item codes.")
          CALL DO.MESSAGE(" The following bit flags are set to 1 (YES) or 0 (NO) on the IRF for ")
          CALL DO.MESSAGE(" each item code within the input file & associated barcodes :")
          CALL DO.MESSAGE("")
          CALL DO.MESSAGE("     Item Not Authorised for Sale (INDICAT0%, Bit flag  5)")
          CALL DO.MESSAGE("     Recall Reason Type           (INDICAT8%, Bit flags 6 & 7)")
          CALL DO.MESSAGE("")
          CALL DO.MESSAGE(" C:\BLOCKITM.OK  is created if successful")
          CALL DO.MESSAGE(" C:\BLOCKITM.ERR is created if failed or could not update an item(s).")
          CALL DO.MESSAGE("                 In this case, run it again or apply update manually.")
          CALL DO.MESSAGE(" C:\BLOCKITM.LOG is created which logs all processing activity.")
          CALL DO.MESSAGE(" C:\BLOCKITM.WRN is created which logs any items not on file.")
          CALL DO.MESSAGE("")
          CALL DO.MESSAGE("     NB: NO files are created if the incorrect parameters are passed.")
          GOTO ABORT.PROGRAM
      ENDIF 
      
      BMESG$ = "Unblocked"
      IF CMD.LINE$ = "YES" THEN BEGIN
          BMESG$ = "Blocked"
      ENDIF
      !--------------------------
      ! Clear up OK and ERR files
      !--------------------------
      CALL IDF.SET                                                           !BCS
      CALL IEF.SET                                                           !BCS
      CALL IRF.SET
      
      GOSUB ALLOCATE.SESSION.NUMBERS
      
      BLOCKITM.OK.PATH$    = "ADXLXAAN::C:\BLOCKITM.OK"
      BLOCKITM.ERR.PATH$   = "ADXLXAAN::C:\BLOCKITM.ERR"
      BLOCKITM.PATH$ = BLOCKITM.ERR.PATH$
      BLOCKITM.SESS.NUM% = ERR.SESS.NUM%
      BLOCKITM.COMPLETION.MSG$ = "BLOCKITM has failed. Check C:\BLOCKITM.LOG and EVENT LOG"
      
      BLOCKITM.INPUT.PATH$ = "ADXLXAAN::C:\BLOCKITM.DAT"
      BLOCKITM.LOG.PATH$   = "ADXLXAAN::C:\BLOCKITM.LOG"
      BLOCKITM.WRN.PATH$   = "ADXLXAAN::C:\BLOCKITM.WRN"                      !DCS
         
      GOSUB DELETE.COMPLETION.FILES
      GOSUB CREATE.COMPLETION.FILE   ! Create .ERR at start
      
      RUN.DATE$   = FORMAT.DATE$(DATE$)                                             
      RUN.TIME$   = FORMAT.TIME$(TIME$)
                                                                             
      IF END # LOG.SESS.NUM% THEN FILE.ERROR
      
        CREATE POSFILE BLOCKITM.LOG.PATH$ AS LOG.SESS.NUM%    \
               BUFFSIZE 32768 LOCKED LOCAL
      
      LOG.FILE.OPEN$ = "Y"
      
      IF END # WRN.SESS.NUM% THEN FILE.ERROR                                  !DCS
                                                                              !DCS
        CREATE POSFILE BLOCKITM.WRN.PATH$ AS WRN.SESS.NUM%    \               !DCS
               BUFFSIZE 32768 LOCKED LOCAL                                    !DCS
               
      CALL DO.MESSAGE("BLOCKITM.286 (ver: " + VERSION$ + ")" + " started: " + RUN.DATE$ + " @ " + RUN.TIME$)
      
      GOSUB OPEN.FILES
      
RETURN
      

!**************************************************************************
!***
!***    MAIN.PROCESSING
!***
!**************************************************************************

MAIN.PROCESSING:

    CALL DO.MESSAGE("MAIN PROCESSING")
                                             
    IF END #INPUT.SESS.NUM% THEN FILE.ERROR  
    
    INPUT.REC.NO% = 1
    
    RC% = READ.INPUT
    
    WHILE RC% <> 1
    
        SKIP.PAST.ITEM.DUE.TO.ERROR$ = "N"  ! Reset flag                     !BCS
        
        GOSUB GET.NO.OF.BARCODES                                             !BCS
        
        IF SKIP.PAST.ITEM.DUE.TO.ERROR$ = "N" THEN BEGIN                     !BCS
            GOSUB TRAWL.THROUGH.ALL.ASSOCIATED.BARCODES.ON.IEF               !BCS
        ENDIF ELSE BEGIN                                                     !BCS!ECS
            CALL DO.MESSAGE("Scanning through IRF")                              !ECS
            IRF.BOOTS.CODE$ = PACK$(MID$(UNPACK$(IDF.BOOTS.CODE$),2, 6))         !ECS
                                                                                 
            RC% = PROCESS.KEYED.FILE(IRF.FILE.NAME$, \                           !ECS 
                                     IRF.REPORT.NUM%,\                           !ECS
                                     "N")  ! READONLY = N                        !ECS
                             
            IF RC% <> 0 THEN BEGIN                                               !ECS
                CALL DO.MESSAGE("PSBF30 ERROR - continuing")                     !ECS
                GOSUB PSBF30.ERROR         ! Log Non-zero return code from ext func   !ECS
            ENDIF                                                                !ECS
        ENDIF                                                                !ECS
         
        INPUT.REC.NO% = INPUT.REC.NO% + 1    ! Next input record
        
        RC% = READ.INPUT
        
    WEND
    
RETURN
    

!**************************************************************************
!***                                                                  !BCS
!***    GET.NO.OF.BARCODES
!***
!**************************************************************************

GET.NO.OF.BARCODES:

    EXPCTD.NO.CODES% = 0
    IDF.BOOTS.CODE$ = PACK$("0" + INPUT.BOOTS.CODE$) 
    RC% = READ.IDF                                                                            
                                                                                              
    IF RC% = 0 THEN BEGIN ! Item read successfully from IDF file                             
        EXPCTD.NO.CODES% = VAL(UNPACK$(IDF.NO.OF.BAR.CODES$))
        CALL DO.MESSAGE(STR$(INPUT.REC.NO%) + ":" + INPUT.BOOTS.CODE$ + \
                        " " + "Read IDF OK. No. of Barcodes: " + STR$(EXPCTD.NO.CODES%))   
    ENDIF ELSE BEGIN                                                                          
        MSG$ = STR$(INPUT.REC.NO%) + ":" + INPUT.BOOTS.CODE$ + " IDF read FAILED"     !DCS
        CALL DO.MESSAGE(MSG$)                                                         !DCS
        PRINT # WRN.SESS.NUM%; MSG$                                                   !DCS
        ! Carry on processing but set error override flag so that error is captured           
        ! Nb. BLOCKITM.ERR file only produced for catastrophic failures
        ERROR.OVERRIDE.FLAG$ = "Y"
        SKIP.PAST.ITEM.DUE.TO.ERROR$ = "Y"                                                            
    ENDIF
    
RETURN


!**************************************************************************
!***                                                                  !BCS
!***    TRAWL.THROUGH.ALL.ASSOCIATED.BARCODES.ON.IEF
!***
!**************************************************************************

TRAWL.THROUGH.ALL.ASSOCIATED.BARCODES.ON.IEF:

   IF IDF.FIRST.BAR.CODE$ = NULL.BAR.CODE$ THEN BEGIN
        MSG$ = STR$(INPUT.REC.NO%) + ":" + INPUT.BOOTS.CODE$ + " ERROR - NULL 1st Barcode on IDF"     !DCS
        CALL DO.MESSAGE(MSG$)                                                                         !DCS
        PRINT # WRN.SESS.NUM%; MSG$                                                                   !DCS
           ! Carry on processing but set error override flag so that error is captured
           ! ie. BLOCKITM.ERR file is produced
           ERROR.OVERRIDE.FLAG$ = "Y"
           SKIP.PAST.ITEM.DUE.TO.ERROR$ = "Y"                                                            
           GENUINE.ERROR.FLAG$  = "Y"                                                                 !DCS
       RETURN
   ENDIF
   
   UPD.BAR.CODE$ = PACK$("0000000000") + IDF.FIRST.BAR.CODE$ ! Convert 6-bytes packed to 11-bytes packed
   
                                                                                !CCS
   IF EXPCTD.NO.CODES% = 1 THEN BEGIN                                           !CCS
            !------------------------                                           !CCS
            ! Update 1st Barcode ONLY                                           !CCS
            !-----------------------                                            !CCS
            CALL READ.AND.UPDATE.IRF                                            !CCS !ECS
   ENDIF                                                                        !CCS
   
   
   IF EXPCTD.NO.CODES% > 1 THEN BEGIN
     
       IF IDF.SECOND.BAR.CODE$ = NULL.BAR.CODE$ THEN BEGIN  
           MSG$ = STR$(INPUT.REC.NO%) + ":" + INPUT.BOOTS.CODE$ + " ERROR - NULL 2nd Barcode on IDF"     !DCS
           CALL DO.MESSAGE(MSG$)                                                                         !DCS
           PRINT # WRN.SESS.NUM%; MSG$                                                                   !DCS
           ! Carry on processing but set error override flag so that error is captured
           ! ie. BLOCKITM.ERR file is produced
           ERROR.OVERRIDE.FLAG$ = "Y"
           SKIP.PAST.ITEM.DUE.TO.ERROR$ = "Y"                                                            
           GENUINE.ERROR.FLAG$  = "Y"                                                                 !DCS
           RETURN
       ENDIF ELSE BEGIN
            !-------------------
            ! Update 1st Barcode
            !-------------------                                                 
            CALL READ.AND.UPDATE.IRF                                            !ECS
            !-------------------
            ! Update 2nd Barcode
            !-------------------
            UPD.BAR.CODE$ = PACK$("0000000000") + IDF.SECOND.BAR.CODE$ ! Convert 6-bytes packed to 11-bytes packed
            CALL READ.AND.UPDATE.IRF                                            !ECS
       ENDIF
      

       IF EXPCTD.NO.CODES% > 2 THEN BEGIN 
             !-------------------------------------
             ! Update all other associated Barcodes
             !-------------------------------------
             RC% = READ.NEXT.IEF (IDF.SECOND.BAR.CODE$,   \
                                  EXPCTD.NO.CODES%,       \
                                  INPUT.BOOTS.CODE$)      
             IF RC% = 1 THEN BEGIN
                 MSG$ = STR$(INPUT.REC.NO%) + ":" + INPUT.BOOTS.CODE$ + " ERROR - reading 3rd Barcode on IDF"  !DCS
                 CALL DO.MESSAGE(MSG$)                                                                         !DCS
                 PRINT # WRN.SESS.NUM%; MSG$                                                                   !DCS
                 ! Carry on processing but set error override flag so that error is captured
                 ! ie. BLOCKITM.ERR file is produced
                 ERROR.OVERRIDE.FLAG$ = "Y"
                 SKIP.PAST.ITEM.DUE.TO.ERROR$ = "Y"                                                            
                 RETURN
             
             ENDIF
       
             F11.CURRENT.COUNT% = 1                                    
             INDEX% = 3
             
             WHILE VAL(UNPACK$(F11.NEXT.BAR.CODE$)) <> 0                       
                 
                 !--------------------------
                 ! Update associated Barcode
                 !--------------------------
                 UPD.BAR.CODE$ = PACK$("0000000000") + F11.NEXT.BAR.CODE$ ! Convert 6-bytes packed to 11-bytes packed
                 CALL READ.AND.UPDATE.IRF                                            !ECS
                 
                 CURRENT.IEF.BAR.CODE$ = F11.NEXT.BAR.CODE$                     
                 
                 RC% = READ.NEXT.IEF (CURRENT.IEF.BAR.CODE$,  \          
                                     EXPCTD.NO.CODES%,    \          
                                     INPUT.BOOTS.CODE$)                           
                 IF RC% = 1 THEN BEGIN           
                     MSG$ = STR$(INPUT.REC.NO%) + ":" + UNPACK$(F11.NEXT.BAR.CODE$) + " ERROR - Associated Barcode " + STR$(INDEX%) + " on IDF"  !DCS
                     CALL DO.MESSAGE(MSG$)                                                                                                       !DCS
                     PRINT # WRN.SESS.NUM%; MSG$                                                                                                 !DCS
                     ! Carry on processing but set error override flag so that error is captured
                     ! ie. BLOCKITM.ERR file is produced
                     ERROR.OVERRIDE.FLAG$ = "Y"
                     SKIP.PAST.ITEM.DUE.TO.ERROR$ = "Y"                                                            
                     GENUINE.ERROR.FLAG$  = "Y"                                                                                                  !DCS
                     RETURN
                 ENDIF
                     
                 INDEX% = INDEX% + 1                                                      
             WEND                                             
       ENDIF
   ENDIF
      
RETURN



!**************************************************************************
!***
!***    TERMINATION
!***
!**************************************************************************

TERMINATION:

    CALL DO.MESSAGE("Termination")

    GOSUB RENAME.COMPLETION.FILE      
    
    RUN.DATE$   = FORMAT.DATE$(DATE$)                                             
    RUN.TIME$   = FORMAT.TIME$(TIME$)
    
    CALL DO.MESSAGE("BLOCKITM ended: " + RUN.DATE$ + " @ " + RUN.TIME$)
    CALL DO.MESSAGE("Completed Successfully")
   
    GOSUB CLOSE.FILES
    
RETURN


!**************************************************************************
!***
!***    ALLOCATE.SESSION.NUMBERS
!***
!**************************************************************************
                                                        
ALLOCATE.SESSION.NUMBERS:                               
                                                        
      CALL DO.MESSAGE("Allocate Session Numbers")       
      SB.ACTION$ = "O"
                                                                              
      SB.INTEGER% = IDF.REPORT.NUM%                                           !BCS
      SB.STRING$ = IDF.FILE.NAME$                                             !BCS
      GOSUB SB.FILE.UTILS                                                     !BCS
      IDF.SESS.NUM% = SB.FILE.SESS.NUM%                                       !BCS
      
      SB.INTEGER% = IEF.REPORT.NUM%                                           !BCS
      SB.STRING$ = IEF.FILE.NAME$                                             !BCS
      GOSUB SB.FILE.UTILS                                                     !BCS
      IEF.SESS.NUM% = SB.FILE.SESS.NUM%                                       !BCS
                                                                              
      SB.INTEGER% = IRF.REPORT.NUM%
      SB.STRING$ = IRF.FILE.NAME$
      GOSUB SB.FILE.UTILS
      IRF.SESS.NUM% = SB.FILE.SESS.NUM%
      

      WRN.REPORT.NUM% = 995                                                   !DCS
      SB.INTEGER% = WRN.REPORT.NUM%                                           !DCS
      SB.STRING$  = BLOCKITM.WRN.PATH$                                        !DCS
      GOSUB SB.FILE.UTILS                                                     !DCS
      WRN.SESS.NUM% = SB.FILE.SESS.NUM%                                       !DCS
      
      INPUT.REPORT.NUM% = 996
      SB.INTEGER% = INPUT.REPORT.NUM%
      SB.STRING$  = BLOCKITM.INPUT.PATH$
      GOSUB SB.FILE.UTILS
      INPUT.SESS.NUM% = SB.FILE.SESS.NUM%
      
      OK.SESS.NUM% = SB.FILE.SESS.NUM%
      OK.REPORT.NUM% = 997
      SB.INTEGER% = OK.REPORT.NUM%
      SB.STRING$  = BLOCKITM.OK.PATH$
      GOSUB SB.FILE.UTILS
      OK.SESS.NUM% = SB.FILE.SESS.NUM%

      ERR.REPORT.NUM% = 998
      SB.INTEGER% = ERR.REPORT.NUM%
      SB.STRING$  = BLOCKITM.ERR.PATH$
      GOSUB SB.FILE.UTILS
      ERR.SESS.NUM% = SB.FILE.SESS.NUM%

      LOG.REPORT.NUM% = 999
      SB.INTEGER% = LOG.REPORT.NUM%
      SB.STRING$  = BLOCKITM.LOG.PATH$
      GOSUB SB.FILE.UTILS
      LOG.SESS.NUM% = SB.FILE.SESS.NUM%
      
RETURN

         
\*******************************************************************************
\***
\***    DELETE.COMPLETION.FILES:
\***
\***    Deletes BLOCKITM.OK  if it exists.
\***    Deletes BLOCKITM.ERR if it exists.
\***    Deletes BLOCKITM.LOG if it exists.
\***
\***............................................................................


DELETE.COMPLETION.FILES:

    IF END # OK.SESS.NUM% THEN BLOCKITM.OK.DELETED
    OPEN BLOCKITM.OK.PATH$ DIRECT RECL 40 AS OK.SESS.NUM%
    DELETE OK.SESS.NUM%

  BLOCKITM.OK.DELETED:

    IF END # ERR.SESS.NUM% THEN BLOCKITM.ERR.DELETED
    OPEN BLOCKITM.ERR.PATH$ DIRECT RECL 40 AS ERR.SESS.NUM%
    DELETE ERR.SESS.NUM%

  BLOCKITM.ERR.DELETED:

    IF END # LOG.SESS.NUM% THEN BLOCKITM.LOG.DELETED
    OPEN BLOCKITM.LOG.PATH$ DIRECT RECL 40 AS LOG.SESS.NUM%
    DELETE LOG.SESS.NUM%

  BLOCKITM.LOG.DELETED:
  
    IF END # WRN.SESS.NUM% THEN BLOCKITM.WRN.DELETED                           !DCS
    OPEN BLOCKITM.WRN.PATH$ DIRECT RECL 40 AS WRN.SESS.NUM%                    !DCS
    DELETE WRN.SESS.NUM%                                                       !DCS
                                                                               !DCS
  BLOCKITM.WRN.DELETED:                                                        !DCS

RETURN


\*****************************************************************************
\*** CREATE.COMPLETION.FILE
\*** Creates BLOCKITM.ERR completion file.
\***............................................................................
    
CREATE.COMPLETION.FILE:

   CURRENT.REPORT.NUM% = 999

   IF END # BLOCKITM.SESS.NUM% THEN FILE.ERROR

   CREATE POSFILE BLOCKITM.PATH$ DIRECT 1 RECL 60 \
          AS BLOCKITM.SESS.NUM% LOCAL
                                                                    
RETURN

            
\*****************************************************************************
\*** RENAME.COMPLETION.FILE
\*** Writes a message to completion file and renames the completion file from  
\*** .ERR to .OK
\***............................................................................
    
RENAME.COMPLETION.FILE:

    ! When set to "Y", the override flag indicates that some of the updates 
    ! to the IRF were NOT successful for some reason or other and needs
    ! investigating further.
    IF ERROR.OVERRIDE.FLAG$ = "N" THEN BEGIN
        BLOCKITM.COMPLETION.MSG$ = "BLOCKITM completed successfully!"                                      
    ENDIF ELSE BEGIN                                                                          !DCS
        BLOCKITM.COMPLETION.MSG$ = "BLOCKITM completed with WARNINGS - check C:\BLOCKITM.WRN" !DCS
    ENDIF                                                                                     !DCS
   
   CURRENT.REPORT.NUM% = 999

   IF END # BLOCKITM.SESS.NUM% THEN FILE.ERROR

   WRITE FORM "C60"; \
         # BLOCKITM.SESS.NUM%, 1;  \
           BLOCKITM.COMPLETION.MSG$ 

    !IF ERROR.OVERRIDE.FLAG$ = "N" THEN BEGIN  ! Only rename to .OK if no errors
    IF GENUINE.ERROR.FLAG$ = "N" THEN BEGIN  ! Only rename to .OK if no genuine errors     !DCS
        RC% = RENAME(BLOCKITM.OK.PATH$, BLOCKITM.PATH$)
        
        IF RC% THEN BEGIN
            CALL DO.MESSAGE("Renaming of BLOCKITM.ERR to BLOCKITM.OK ** SUCCESSFUL **")
        ENDIF ELSE BEGIN
            CALL DO.MESSAGE("Renaming of BLOCKITM.ERR to BLOCKITM.OK ** FAILED **")
        ENDIF
    ENDIF

   CLOSE BLOCKITM.SESS.NUM%
                                                                          
   
RETURN


\******************************************************************************
\***
\***   SB.FILE.UTILS:
\***
\***   Allocate/report/de-allocate a file session number
\***
\******************************************************************************

SB.FILE.UTILS:

       RC% = SESS.NUM.UTILITY(SB.ACTION$,                              \
                              SB.INTEGER%,                             \
                              SB.STRING$)

       IF SB.ACTION$ = "O" THEN BEGIN
          SB.FILE.SESS.NUM% = F20.INTEGER.FILE.NO%
       ENDIF ELSE BEGIN
          IF SB.ACTION$ = "R" THEN BEGIN
             SB.FILE.REP.NUM% = F20.INTEGER.FILE.NO%
             SB.FILE.NAME$ = F20.FILE.NAME$
          ENDIF
       ENDIF

RETURN

\******************************************************************************
\***
\***   OPEN.FILES:
\***
\******************************************************************************
OPEN.FILES:

    CALL DO.MESSAGE("Open Files")

!RESUME.PROCESSING:

    CURRENT.CODE$ = " "
    FILE.OPERATION$ = "O"
                                              !--------!
    CURRENT.REPORT.NUM% = INPUT.REPORT.NUM%   ! INPUT  !
    IF END #INPUT.SESS.NUM% THEN FILE.ERROR   !--------!
    OPEN BLOCKITM.INPUT.PATH$ DIRECT RECL INPUT.RECL% AS INPUT.SESS.NUM% BUFFSIZE 32767
    
                                              !--------!                     !BCS
    CURRENT.REPORT.NUM% = IDF.REPORT.NUM%     ! IDF    !                     !BCS
    IF END #IDF.SESS.NUM% THEN FILE.ERROR     !--------!                     !BCS
    OPEN IDF.FILE.NAME$ KEYED RECL IDF.RECL% AS IDF.SESS.NUM%  NOWRITE NODEL !BCS
    
                                              !--------!                     !BCS
    CURRENT.REPORT.NUM% = IEF.REPORT.NUM%     ! IEF    !                     !BCS
    IF END #IEF.SESS.NUM% THEN FILE.ERROR     !--------!                     !BCS
    OPEN IEF.FILE.NAME$ KEYED RECL IEF.RECL% AS IEF.SESS.NUM%  NOWRITE NODEL !BCS
        
                                              !--------!
    CURRENT.REPORT.NUM% = IRF.REPORT.NUM%     ! IRF    !
    IF END #IRF.SESS.NUM% THEN FILE.ERROR     !--------!
    OPEN IRF.FILE.NAME$ KEYED RECL IRF.RECL% AS IRF.SESS.NUM% NODEL
        

RETURN

\******************************************************************************
\***
\***   CLOSE.FILES:
\***
\******************************************************************************
CLOSE.FILES:
    
    CALL DO.MESSAGE("Closing Files")
    
    CURRENT.CODE$ = " "
    FILE.OPERATION$ = "C"
    
    CURRENT.REPORT.NUM% = INPUT.REPORT.NUM%
    CLOSE INPUT.SESS.NUM%
    
    CURRENT.REPORT.NUM% = IDF.REPORT.NUM%                                    !BCS
    CLOSE IDF.SESS.NUM%                                                      !BCS
    
    CURRENT.REPORT.NUM% = IEF.REPORT.NUM%                                    !BCS
    CLOSE IEF.SESS.NUM%                                                      !BCS
    
    CURRENT.REPORT.NUM% = IRF.REPORT.NUM%
    CLOSE IRF.SESS.NUM%
    
    CURRENT.REPORT.NUM% = LOG.REPORT.NUM%
    CLOSE LOG.SESS.NUM%
    
    CURRENT.REPORT.NUM% = WRN.REPORT.NUM%                                    !DCS
    CLOSE WRN.SESS.NUM%                                                      !DCS

RETURN

\*******************************************************************************
\***
\***   FILE.ERROR:
\***
\***   Open Read or Write File error
\***
\-------------------------------------------------------------------------------

FILE.ERROR:
        
    CALL DO.MESSAGE("File Error")

    GOSUB LOG.EVENT.106

GOTO PROGRAM.ABEND


!!!*************************************************************************
!!!*************************************************************************
!!!
!!!   PSBF30.ERROR
!!!
!!!   Process keyed file error
!!!
!!!*************************************************************************
!!!*************************************************************************

PSBF30.ERROR: 

    CALL DO.MESSAGE("Processed Keyed File Error")
    EVENT.NUM% = 89
    VAR.STRING.1$ = "PSBF30: " + STR$(RC%)
    VAR.STRING.2$ = " "
    RC% = APPLICATION.LOG (MESSAGE.NUMBER%,  \
                           VAR.STRING.1$,    \
                           VAR.STRING.2$,    \
                           EVENT.NUM%)
    CALL DO.MESSAGE("Update Failed - " + VAR.STRING.1$)

RETURN

                                  
\*******************************************************************************
\***
\***   LOG.EVENT.106 open,read,write error
\***
\-------------------------------------------------------------------------------

LOG.EVENT.106:

    EVENT.NUM% = 106

    VAR.STRING.1$ = FILE.OPERATION$                    +  \
                    CHR$(SHIFT(CURRENT.REPORT.NUM%,8)) +  \
                    CHR$(SHIFT(CURRENT.REPORT.NUM%,0)) +  \
                    CURRENT.CODE$

    VAR.STRING.2$ = ""
    GOSUB CALL.APPLICATION.LOG

RETURN    



\******************************************************************************
\***
\***   CALL.APPLICATION.LOG:
\***
\***
\------------------------------------------------------------------------------

CALL.APPLICATION.LOG:

          RC% = APPLICATION.LOG (MESSAGE.NUMBER%,  \
                                 VAR.STRING.1$,    \
                                 VAR.STRING.2$,    \
                                 EVENT.NUM%)

RETURN

\*****************************************************************************
\***                                                                         *
\***   ERROR ROUTINE  :  ERROR.DETECTED                                      *
\***                                                                         *
\***                                                                         *
\***   IF another error detected then EXIT PROGRAM                           *
\***                                                                         *
\***   call STANDARD.ERROR.DETECTED                                          *
\***   gosub DISPLAY.ERROR.MESSAGE                                           *
\***                                                                         *
\*****************************************************************************

ERROR.DETECTED:

    ERROR.COUNT% = ERROR.COUNT% + 1

    IF ERROR.COUNT% <= 3 THEN BEGIN
    
        IF (ERRN AND 0000FFFFH) = 0000400CH THEN BEGIN \   ! Trap all other file access conflicts
                
            IF CURRENT.REPORT.NUM% = IDF.REPORT.NUM% OR \                            !BCS
               CURRENT.REPORT.NUM% = IEF.REPORT.NUM% OR \                            !BCS
               CURRENT.REPORT.NUM% = IRF.REPORT.NUM% THEN BEGIN                      !BCS
                 CALL DO.MESSAGE("IDF/IEF/IRF File is locked - Retry " + STR$(ERROR.COUNT%) + " of 3") !BCS
            ENDIF ELSE BEGIN
                 CALL DO.MESSAGE("A File is locked - Retry " + STR$(ERROR.COUNT%) + " of 3")
            ENDIF
            
            WAIT ;20000    ! Wait for 20 seconds and then retry
            
        ENDIF   
        
        RESUME RETRY
        
    ENDIF   
                                                                       
    IF (ERRN AND 0000FFFFH) = 0000400CH THEN BEGIN \   ! Log Event 106 for file access conflicts
        GOSUB LOG.EVENT.106
    ENDIF 
    
    \*****************************************************************************
    \***                                                                         *
    \***   PROGRAM.ABEND                                                         *
    \***                                                                         *
    \*****************************************************************************
    
    PROGRAM.ABEND:

    PRINT "ERR:  "; ERR
    PRINT "ERRN: "; ERRNH
    PRINT "ERRF: "; ERRF%
    PRINT "ERRL: "; ERRL
    
    CALL DO.MESSAGE("Program BLOCKITM has abended. Check App. Log")

    ! Catch any uncaught events
    RC% = STANDARD.ERROR.DETECTED(ERRN,   \
                                  ERRF%,  \
                                  ERRL,   \
                                  ERR)
    
END
