   1: 0002: \******************************************************************************
   2: 0002: \******************************************************************************
   3: 0002: \***
   4: 0002: \***
   5: 0002: \***   PSD97                 26/10/2015                 Ranjith Gopalankutty
   6: 0002: \***
   7: 0002: \***   Original version
   8: 0002: \***
   9: 0002: \***
  10: 0002: \***   Usage
  11: 0002: \***   This utility will help to clear the serial number of DVCHR,DIDIR
  12: 0002: \***   and DEALDIR bin files in BCF.BIN. Which will be used during deal 
  13: 0002: \***   initial load process.
  14: 0002: \***   
  15: 0002: \***   Screen will have below standard options          
  16: 0002: \***       F3  = To return to main menu       
  17: 0002: \***       F1  = Help Key 
  18: 0002: \***       ESC = To escape out of the screen
  19: 0002: \***   
  20: 0002: \***   
  21: 0002: \******************************************************************************
  22: 0002: \******************************************************************************
  23: 0002: \***
  24: 0002: \***    Included code defining function related Global variables
  25: 0002: \***
  26: 0002: \******************************************************************************
  27: 0002: \******************************************************************************
  28: 0002: 
  29: 0002:     %INCLUDE BCFDEC.J86     !   BCF file function
  30: 0002: \*****************************************************************************
  31: 0002: \*****************************************************************************
  32: 0002: \***
  33: 0002: \***               %INCLUDE FOR BCF - FIELD DECLARATIONS
  34: 0002: \***                                  FILE REFERENCE PARAMETERS
  35: 0002: \***
  36: 0002: \***                      FILE TYPE    : SEQUENTIAL
  37: 0002: \***
  38: 0002: \***                      REFERENCE    : BCFDEC.J86
  39: 0002: \***
  40: 0002: \***      Version A             Steve Windsor          5th Jan 1993
  41: 0002: \***
  42: 0002: \***      Version B             Michael J. Kelsall    01st Dec 1993
  43: 0002: \***      Addition to file of CCMVT serial number as part of
  44: 0002: \***      RETURNS/AUTOMATIC CREDIT CLAIMING package.
  45: 0002: \***
  46: 0002: \***      Version C           Stuart William McConnachie 23rd Jan 1995
  47: 0002: \***      Addition of TXR serial number as part of the TRANSACTION RETRIEVAL
  48: 0002: \***      project.
  49: 0002: \***
  50: 0002: \***      Version D           Stuart William McConnachie  7th June 1995
  51: 0002: \***      Converted calls to enable more than 1 record on the BCF.
  52: 0002: \***      The second record is to be used for the No7 customer card trial.
  53: 0002: \***
  54: 0002: \***      Version E                 Stuart Highley        7th April 1999
  55: 0002: \***      Added new fields for cash accounting.
  56: 0002: \***
  57: 0002: \***      Version F                 Mark Goode            20th May 2000
  58: 0002: \***      Added new fields for Dentistry project.
  59: 0002: \***
  60: 0002: \***      Version G                 Mark Goode            18th July 2000
  61: 0002: \***      Added new fields for Well-Being project.
  62: 0002: \***
  63: 0002: \***      Version I                 Amy Hoggard           13th Oct 2000
  64: 0002: \***      Added new fields for ECO project.
  65: 0002: \***
  66: 0002: \***      Version K                 Brian Greenfield      1st May 2001
  67: 0002: \***      Added new field for Wellbeing Services record 13.
  68: 0002: \***
  69: 0002: \***      Version L                 Amy Hoggard           4th Jan 2002
  70: 0002: \***      Added new field for ETOPUP project.
  71: 0002: \***
  72: 0002: \***      Version M                 Julia Stones          22nd July 2002
  73: 0002: \***      Added new fields for Deals rewrite project record 14.
  74: 0002: \***
  75: 0002: \***    Revision 4.6            ROBERT COWEY.            19 MAY 2003.
  76: 0002: \***    Modifications for All Txn Data To CDAS project.
  77: 0002: \***    Removed redundant variables ...
  78: 0002: \***      BCF.CTSL1.SERIAL.NUM$, BCF.CTSL2,SERIAL.NUM$
  79: 0002: \***    Defined new variable ...
  80: 0002: \***      BCF.MTSLQ.DAYS$, BCF.FILLER67$
  81: 0002: \***
  82: 0002: \***    Revision 4.7           Julia Stones              9th July 2003.
  83: 0002: \***    Modifications for New Lines Report project.
  84: 0002: \***    Defined new variable
  85: 0002: \***    BCF.NEWLINES.WEEKS$
  86: 0002: \***
  87: 0002: \***    Revision 4.8           Julia Stones              3rd October 2003.
  88: 0002: \***    Modifications for New Lines Report project.
  89: 0002: \***    Defined new variable
  90: 0002: \***    BCF.NEWLINES.LINES$
  91: 0002: \***
  92: 0002: \***    Version N              Jamie Thorpe             27th June 2006
  93: 0002: \***    Added BCF.DVCHR.SERIAL.NUM$
  94: 0002: \***
  95: 0002: \***    Revision 4.10          Charles Skadorwa            4th July 2011
  96: 0002: \***    CORE Heritage Stores Release 2 (Outbound) Project.
  97: 0002: \***    New variables defined: BCF.ECC.DATETIMESTAMP$
  98: 0002: \***                           BCF.IUF.DATETIMESTAMP$
  99: 0002: \***
 100: 0002: \***    Revision 4.11          Arun Sudhakaran             10th April 2013
 101: 0002: \***    Added new variables for including Supplier Number lengths
 102: 0002: \***    as part of Automatic Booking In of Chilled Food ASNs project
 103: 0002: \***
 104: 0002: \***    Revision 4.12          Charles Skadorwa            5th Sept 2013
 105: 0002: \***    F261 Gift Card Mall IIN Range Extension Project - Commented !4.12 CSk
 106: 0002: \***    Defined new variables for GCM Product Group Number and Record 22
 107: 0002: \***    lengths.
 108: 0002: \***
 109: 0002: \***    Version O              Mark Walker                  3rd Feb 2014
 110: 0002: \***    F337 Centralised View of Stock
 111: 0002: \***    - Defined variables for record 23 (stock snapshot parameters).
 112: 0002: \***    - Minor formatting changes (uncommented).
 113: 0002: \***
 114: 0002: \***    Revision O             Charles Skadorwa             25th June 2014
 115: 0002: \***    F353 Deal Limits Increase Project.
 116: 0002: \***    Renamed 3 variables in function BCF.RECORD.14.W -
 117: 0002: \***        BCF.DINF.NUM.REC$ becomes BCF.ITMDL.NUM.REC$
 118: 0002: \***        BCF.DINF.KEY.LEN$ becomes BCF.ITMDL.KEY.LEN$
 119: 0002: \***        BCF.ECC.DATETIMESTAMP$ becomes BCF.FILLER.DATETIMESTAMP$
 120: 0002: \*****************************************************************************
 121: 0002: \*****************************************************************************
 122: 0002: 
 123: 0002:     STRING GLOBAL                                                       \
 124: 0002:         BCF.FILE.NAME$
 125: 0002: 
 126: 0002:     INTEGER*2 GLOBAL                                                    \
 127: 0002:         BCF.RECL%,                                                      \   !OMW
 128: 0002:         BCF.REPORT.NUM%,                                                \
 129: 0002:         BCF.SESS.NUM%
 130: 0002: 
 131: 0002:     STRING GLOBAL                                                       \
 132: 0002:     BCF.RECORD$,          \ 80 bytes
 133: 0002:     BCF.IUF.SERIAL.NO$,   \ 5 bytes, IUF serial number
 134: 0002:     BCF.OPEN.DATE$,       \ 6 bytes, Last store opening date (YYMMDD)
 135: 0002:     BCF.FILLER.DATE$,     \ 3 bytes, filler
 136: 0002:     BCF.LABEL.DATE$,      \ 6 bytes, label print date (YYMMDD)
 137: 0002:     BCF.SALES.SERIAL.NO$ ,\ 5 bytes, sales serial number
 138: 0002:     BCF.STMVB.SERIAL.NO$, \ 5 bytes, current serial number          \
 139: 0002:                               \     of Stock Movement Backup file       \
 140: 0002:     BCF.TOF.DAYS$,        \ 2 bytes, number of days' worth of sales to \
 141: 0002:                           \       be held on the TIF at re-build       \
 142: 0002:         BCF.EPS.BATCH$,       \ 2 bytes, highest batch number to have   \
 143: 0002:                               \     been reported upon by PSE31         \
 144: 0002:     BCF.NO.EPF.COPIES$,   \ 2 bytes, no. of copies of EPS payment file \
 145: 0002:     BCF.CCMVT.SERIAL.NUM$,\ 5 bytes ASC                                ! BMJK
 146: 0002:     BCF.TXR.SERIAL.NUM$,  \ 5 bytes transaction retrieval serial number!SWM
 147: 0002:     BCF.CUSTD.SERIAL.NUM$,\ 5 bytes customer data file serial number   !SWM
 148: 0002:     BCF.PSB58.DATE$,      \ 6 bytes date of last MTSL/CUSTW cut-off    !SWM
 149: 0002:     BCF.CTSL1.SERIAL.NUM$,\ 5 bytes serial number on first MTSLQ (and  ! 4.6 RC
 150: 0002:                           \         thereore CTSL1) batch header       ! 4.6 RC
 151: 0002:     BCF.MTSLQ.DAYS$,      \ 2 byte MTSLQ data retention period (PSB14) ! 4.6 RC
 152: 0002:     BCF.FILLER67$,        \ 8 bytes filler beginning at byte 67        ! 4.6 RC
 153: 0002:         BCF.NTIUF.SERIAL.NO$,                                           \   !FMG
 154: 0002:         BCF.DENTISTRY.PSAUDIT.SERIAL.NO$,                               \   !FMG
 155: 0002:         BCF.WELL.SERIAL.NO$,                                            \   !GMG
 156: 0002:         BCF.WELL.PSAUDIT.SERIAL.NO$,                                    \   !GMG
 157: 0002:     BCF.ACSAL.SERIAL.NUM$,\ 5 bytes serial number on ACSAL             !ESDH
 158: 0002:     BCF.DENTISTRY.PRODUCT.GROUP$,                                      \FMG
 159: 0002:     BCF.WELL.PRODUCT.GROUP$,                                           \GMG
 160: 0002:     BCF.FILLER$,         \! 1 byte, filler                             !BMJK
 161: 0002:     BCF.WELL.SERV.PRODUCT.GROUP$,                                      \KBG
 162: 0002:         BCF.ETOPUP.PROD.GRP$,                                           \   !LAH
 163: 0002:         BCF.END.FILLER$,                                                \   !LAH
 164: 0002:     BCF.TBAG.BATCH.NO$,                                                \IAH
 165: 0002:     BCF.TBAG.DAYS.KEPT$,                                               \IAH
 166: 0002:     BCF.NEWLINES.WEEKS$,                                               \4.7JAS
 167: 0002:     BCF.NEWLINES.LINES$,                                               \4.8JAS
 168: 0002:     BCF.TBAG.FILLER$,                                                  \ 79 Bytes filler !IAH 70 Bytes filler 4.7JAS ! 65 Bytes fille 4.8JAS
 169: 0002:     BCF.DEALDIR.SERIAL.NUM$, \ 4 bytes serial number                   !MJAS
 170: 0002:     BCF.DIDIR.SERIAL.NUM$,   \ 4 bytes serial number                   !MJAS
 171: 0002:     BCF.DEAL.NUM.REC$,       \ 6 bytes number of records in deal file  !MJAS
 172: 0002:     BCF.ITMDL.NUM.REC$,      \ 6 bytes number of records in ITMDL file !OCS
 173: 0002:     BCF.DEAL.KEY.LEN$,       \ 3 bytes key length of deal file         !MJAS
 174: 0002:     BCF.ITMDL.KEY.LEN$,      \ 3 bytes bytes ITMDL record key length   !OCS
 175: 0002:     BCF.DVCHR.SERIAL.NUM$,   \ 4 bytes serial numbr                    !NJT !4.10CSk
 176: 0002:     BCF.FILLER.DATETIMESTAMP$,\17 bytes filler for future use          !OCS
 177: 0002:     BCF.IUF.DATETIMESTAMP$, \ !17 bytes timestamp YYYYMMDDHHMMSSsss     !4.10CSk
 178: 0002:                             \ !   Last successfully processed IUF from SAP.
 179: 0002:         BCF.ITEM.STATUS$(1),     \1 byte array, item status             \   !OMW
 180: 0002:         BCF.NEGATIVE.STOCK.FLAG$(1), \1 byte array, Flag (Y/N) whether  \   !OMW
 181: 0002:                                  \   to include items with a negative   \   !OMW
 182: 0002:                                  \   stock figure in the initial stock  \   !OMW
 183: 0002:                                  \   snapshot messages.                 \   !OMW
 184: 0002:         BCF.POSITIVE.STOCK.FLAG$(1), \1 byte array, Flag (Y/N) whether  \   !OMW
 185: 0002:                                  \   to include items with a positive   \   !OMW
 186: 0002:                                  \   stock figure in the initial stock  \   !OMW
 187: 0002:                                  \   snapshot messages.                 \   !OMW
 188: 0002:         BCF.ZERO.STOCK.FLAG$(1)  !1 byte array, Flag (Y/N) whether to   \   !OMW
 189: 0002:                                  \   include items with a zero          \   !OMW
 190: 0002:                                  \   stock figure in the initial stock  \   !OMW
 191: 0002:                                  !   snapshot messages.                     !OMW
 192: 0002:                 
 193: 0002:     INTEGER*1                                                           \
 194: 0002:         BCF.NO.CPM.COPIES%
 195: 0002: 
 196: 0002:     INTEGER*2 GLOBAL                                                    \
 197: 0002:     BCF.CC.SERIAL.NO,        \ 1 byte UPD, CC serial number
 198: 0002:         BCF.MAX.STATUS.COUNT%,        \ Maximum number of item status   \   !OMW
 199: 0002:     BCF.REC21.REC.LEN%,      \ Total Supplier number length            !4.11 AS
 200: 0002:     BCF.REC21.SUPPLIER.LEN%, \ Length of the supplier number           !4.11 AS
 201: 0002:         BCF.MAX.STOCK.INIT.MESSAGES%, \ Maximum number of initial       \   !OMW
 202: 0002:                                       \ stock snapshot message to       \   !OMW
 203: 0002:                                       \ send per day.                   \   !OMW
 204: 0002:         BCF.MAX.STOCK.INIT.ITEMS%,    \ Maximum number of items to      \   !OMW
 205: 0002:                                       \ include in a single initial     \   !OMW
 206: 0002:                                       \ stock snapshot message.         \   !OMW
 207: 0002:         BCF.NEGATIVE.DAYS%(1),        \ Number of days' movements with  \   !OMW
 208: 0002:                                       \ a negative stock figure to      \   !OMW
 209: 0002:                                       \ include in the initial stock    \   !OMW
 210: 0002:                                       \ snapshot messages.              \   !OMW
 211: 0002:         BCF.POSITIVE.DAYS%(1),        \ Number of days' movements with  \   !OMW
 212: 0002:                                       \ a positive stock figure to      \   !OMW
 213: 0002:                                       \ include in the initial stock    \   !OMW
 214: 0002:                                       \ snapshot messages.              \   !OMW
 215: 0002:         BCF.REC22.REC.LEN%,           \                                 \   !4.12 CSk
 216: 0002:         BCF.REC22.PROD.GROUP.LEN%,    \ Length of GCM Product Group No  \   !4.12 CSk
 217: 0002:         BCF.ZERO.DAYS%(1)             \ Number of days' movements with  \   !OMW
 218: 0002:                                       \ a zero stock figure to include  \   !OMW
 219: 0002:                                       \ in the initial stock snapshot   \   !OMW
 220: 0002:                                       ! messages.                           !OMW
 221: 0002: 
 222: 0002: 
 223: 0002:     INTEGER*4 GLOBAL                                                    \
 224: 0002:         BCF.REC.NO%
 225: 0002: 
 226: 0002:     %INCLUDE BEMFDEC.J86    !   BEMF file function
 227: 0002: \******************************************************************************
 228: 0002: \***
 229: 0002: \***	   %INCLUDE FOR BOOTS ERROR MESSAGE FILE - FIELD DECLARATIONS
 230: 0002: \***                                             - FILE REFERENCE PARAMETERS
 231: 0002: \***
 232: 0002: \***                         FILE TYPE : Direct
 233: 0002: \***
 234: 0002: \***                         REFERENCE : BEMFDEC
 235: 0002: \***
 236: 0002: \***	Version A               Mark Walker                  1st November 1993
 237: 0002: \***
 238: 0002: \******************************************************************************
 239: 0002: 
 240: 0002: 	STRING GLOBAL			BEMF.MESSAGE$,			\
 241: 0002: 					BEMF.FILE.NAME$
 242: 0002: 
 243: 0002: 	INTEGER*2 GLOBAL		BEMF.RECL%,			\
 244: 0002: 					BEMF.REPORT.NUM%,		\
 245: 0002: 					BEMF.SESS.NUM%
 246: 0002: 
 247: 0002: 	INTEGER*4 GLOBAL		BEMF.REC.NO%
 248: 0002:     %INCLUDE PSBF01G.J86    !   APPLICATION.LOG
 249: 0002: REM \
 250: 0002: \*******************************************************************************
 251: 0002: \*******************************************************************************
 252: 0002: \***
 253: 0002: \***       %INCLUDE FOR GLOBAL DEFINITIONS FOR FUNCTION APPLICATION.LOG
 254: 0002: \***
 255: 0002: \***                FUNCTION NUMBER    : PSBF01
 256: 0002: \***
 257: 0002: \***                REFERENCE          : PSBF01G.J86
 258: 0002: \***
 259: 0002: \***                DATE OF LAST AMENDMENT  - 27/2/86
 260: 0002: \***
 261: 0002: \***
 262: 0002: \*******************************************************************************
 263: 0002: 
 264: 0002:       INTEGER GLOBAL  F01.RETURN.CODE%
 265: 0002: 
 266: 0002: 
 267: 0002:     %INCLUDE PSBF20G.J86    !   ALLOCATE.DEALLOCATE.SESS.NUM
 268: 0002: REM\
 269: 0002: \*******************************************************************************
 270: 0002: \*******************************************************************************
 271: 0002: \***
 272: 0002: \***     %INCLUDE GLOBAL VARIABLE DEFINITIONS FOR SESS.NUM.UTILITY FUNCTION
 273: 0002: \***
 274: 0002: \***                       REFERENCE     : PSBF20G.J86
 275: 0002: \*** 
 276: 0002: \***     Version A              Bruce Scrive                   5th May 1988   
 277: 0002: \*** 
 278: 0002: \***     Version B              Robert Cowey                   7th May 1991
 279: 0002: \***     Global variable F20.INTEGER.FILE.NO% changed from one byte integer
 280: 0002: \***     to two byte integer.
 281: 0002: \***
 282: 0002: \***     Version D              Andrew Wedgeworth             1st July 1992
 283: 0002: \***     F20.RETURN.CODE% removed as it is no longer required.
 284: 0002: \***
 285: 0002: \*******************************************************************************
 286: 0002: \*******************************************************************************
 287: 0002: 
 288: 0002:       STRING    GLOBAL F20.FILE.NAME$,                                 \
 289: 0002:                        F20.STRING.FILE.NO$,                            \
 290: 0002:                        F20.TABLE.DIMENSIONED.FLAG$,                    \
 291: 0002:                        SESS.NUM.TABLE$(1)
 292: 0002: 
 293: 0002:       INTEGER*2 GLOBAL F20.INTEGER.FILE.NO%
 294: 0002: 
 295: 0002:       ! 1 line deleted from here                                       ! DAW 
 296: 0002: 
 297: 0002:     %INCLUDE PSBF39G.J86    !   Display Manager
 298: 0002: !******************************************************************************
 299: 0002: !******************************************************************************
 300: 0002: !***
 301: 0002: !***            PROGRAM         :       PSBF39G.J86
 302: 0002: !***
 303: 0002: !***            DESCRIPTION     :       DISPLAY MANAGER INTERFACE
 304: 0002: !***
 305: 0002: !***            AUTHOR          :       Stuart William McConnachie
 306: 0002: !***            DATE WRITTEN    :       September 2000
 307: 0002: !***
 308: 0002: !***        Provides a much needed and easier to use interface to
 309: 0002: !***        IBM Display Manager.
 310: 0002: !***
 311: 0002: !***        Saves the user having to set up, highlight, tab between and
 312: 0002: !***        validate fields.  Also handles the help screens and conversion
 313: 0002: !***        of date fields to external/internal format.
 314: 0002: !***
 315: 0002: !******************************************************************************
 316: 0002: !******************************************************************************
 317: 0002:     
 318: 0002:     STRING GLOBAL       MESSAGE$(1)
 319: 0002:     STRING GLOBAL       VALID$(1)
 320: 0002:     STRING GLOBAL       VISIBLE$(1)
 321: 0002:     STRING GLOBAL       FIELD$(1)
 322: 0002:     STRING GLOBAL       TITLE$
 323: 0002: 
 324: 0002:     INTEGER*2 GLOBAL    DM.SCREEN%
 325: 0002:     INTEGER*2 GLOBAL    DM.FIELD%
 326: 0002:     
 327: 0002:     INTEGER*2 GLOBAL    HOME.KEY%
 328: 0002:     INTEGER*2 GLOBAL    END.KEY%
 329: 0002:     INTEGER*2 GLOBAL    PGUP.KEY%
 330: 0002:     INTEGER*2 GLOBAL    PGDN.KEY%
 331: 0002:     INTEGER*2 GLOBAL    TAB.KEY%
 332: 0002:     INTEGER*2 GLOBAL    BTAB.KEY%
 333: 0002:     INTEGER*2 GLOBAL    UP.KEY%
 334: 0002:     INTEGER*2 GLOBAL    DOWN.KEY%
 335: 0002:     INTEGER*2 GLOBAL    ESC.KEY%
 336: 0002:     INTEGER*2 GLOBAL    ENTER.KEY%
 337: 0002:     INTEGER*2 GLOBAL    INS.KEY%
 338: 0002:     INTEGER*2 GLOBAL    PREV.KEY%
 339: 0002:     INTEGER*2 GLOBAL    NEXT.KEY%
 340: 0002:         
 341: 0002:     INTEGER*2 GLOBAL    F1.KEY%
 342: 0002:     INTEGER*2 GLOBAL    F2.KEY%
 343: 0002:     INTEGER*2 GLOBAL    F3.KEY%
 344: 0002:     INTEGER*2 GLOBAL    F4.KEY%
 345: 0002:     INTEGER*2 GLOBAL    F5.KEY%
 346: 0002:     INTEGER*2 GLOBAL    F6.KEY%
 347: 0002:     INTEGER*2 GLOBAL    F7.KEY%
 348: 0002:     INTEGER*2 GLOBAL    F8.KEY%
 349: 0002:     INTEGER*2 GLOBAL    F9.KEY%
 350: 0002:     INTEGER*2 GLOBAL    F10.KEY%
 351: 0002:                 
 352: 0002: !******************************************************************************
 353: 0002: 
 354: 0002:     %INCLUDE PSBUSEG.J86    !   Chain Function
 355: 0002: \/*********************************************************************/ PSBUSEG
 356: 0002: \/*                                                                   */ PSBUSEG
 357: 0002: \/* PSBUSEG.J86  -  Definitions for Chain/Use with PSB Screen Program */ PSBUSEG
 358: 0002: \/* ----------------------------------------------------------------- */ PSBUSEG
 359: 0002: \/*                                                                   */ PSBUSEG
 360: 0002: \/*********************************************************************/ PSBUSEG
 361: 0002:                                                                        ! PSBUSEG
 362: 0002:         STRING GLOBAL  PSBCHN.PRG,      \ Program to chain to          ! PSBUSEG
 363: 0002:                        PSBCHN.OP,       \ Operator Id                  ! PSBUSEG
 364: 0002:                        PSBCHN.APP,      \ Program chained from         ! PSBUSEG
 365: 0002:                        PSBCHN.MENCON,   \ Menu Control                 ! PSBUSEG
 366: 0002:                        PSBCHN.U1,       \ User parameter               ! PSBUSEG
 367: 0002:                        PSBCHN.U2,       \ User parameter               ! PSBUSEG
 368: 0002:                        PSBCHN.U3        ! User parameter               ! PSBUSEG
 369: 0002:                                                                        ! PSBUSEG
 370: 0002: 
 371: 0002: \******************************************************************************
 372: 0002: \******************************************************************************
 373: 0002: \***
 374: 0002: \***    Global Variable definitions
 375: 0002: \***
 376: 0002: \******************************************************************************
 377: 0002: \******************************************************************************
 378: 0002: 
 379: 0002:     STRING GLOBAL                                                       \
 380: 0002:         BATCH.SCREEN.FLAG$,                                             \ Screen flags
 381: 0002:         CHAIN.TO.PROG$,                                                 \ Chain to programs
 382: 0002:         CURRENT.CODE$,                                                  \ Current code
 383: 0002:         CURRENT.CODE.LOGGED$,                                           \
 384: 0002:         FILE.NO$,                                                       \
 385: 0002:         FILE.OPERATION$,                                                \ File operations indicator
 386: 0002:         FUNCTION.FLAG$,                                                 \
 387: 0002:         MODULE$,                                                        \
 388: 0002:         MODULE.NUMBER$,                                                 \ Module number
 389: 0002:         PASSED.STRING$,                                                 \
 390: 0002:         PROGRAM$,                                                       \
 391: 0002:         VAR.STRING.1$,                                                  \
 392: 0002:         VAR.STRING.2$                                                   !
 393: 0002: 
 394: 0002:      INTEGER*1 GLOBAL                                                   \
 395: 0002:          COMMAND.MODE,                                                  \
 396: 0002:          ERROR.COUNT%,                                                  \
 397: 0002:          FALSE,                                                         \
 398: 0002:          TRUE                                                           !
 399: 0002: 
 400: 0002:      INTEGER*2 GLOBAL                                                   \
 401: 0002:          CURRENT.REPORT.NUM%,                                           \
 402: 0002:          EVENT.NO%,                                                     \
 403: 0002:          MESSAGE.NO%,                                                   \
 404: 0002:          PASSED.INTEGER%                                                !
 405: 0002: 
 406: 0002:     INTEGER*4 GLOBAL                                                    \
 407: 0002:          RET.KEY%                                                       \
 408: 0002: 
 409: 0002: \******************************************************************************
 410: 0002: \******************************************************************************
 411: 0002: \***
 412: 0002: \***   VARIABLE DECLARATIONS
 413: 0002: \***
 414: 0002: \******************************************************************************
 415: 0002: \******************************************************************************
 416: 0002: 
 417: 0002:     STRING                                                              \
 418: 0002:         BCF.OPEN.FLAG$,                                                 \
 419: 0002:         CURRENT.DATE$,                                                  \
 420: 0002:         OPERATOR.NUMBER$                                                !
 421: 0002: 
 422: 0002: 
 423: 0002:     INTEGER*1                                                           \
 424: 0002:         EXIT.NOW,                                                       \
 425: 0002:         INITIALIZED,                                                    \
 426: 0002:         PSD97.FIELD%,                                                   \
 427: 0002:         RESET                                                           !
 428: 0002: 
 429: 0002:     INTEGER*4                                                           \
 430: 0002:         RC%                                                             !
 431: 0002: 
 432: 0002: \******************************************************************************
 433: 0002: \******************************************************************************
 434: 0002: \***
 435: 0002: \***    FUNCTION DECLARATIONS
 436: 0002: \***
 437: 0002: \******************************************************************************
 438: 0002: \******************************************************************************
 439: 0002: 
 440: 0002:     %INCLUDE BASROUT.J86   ! OSShell function
 441: 0002: \*LIB   BVEJ BASROUT  J86      03/11/97 08:16:26 PIDBLD3  *    FIX
 442: 0002: \*PROM  BVEJ BASROUT  J86      03/10/97 17:18:40 PIDBLD3  MVEJ IR34352
 443: 0002: \*RTIME BVEJ BASROUT  J86      03/10/97 17:18:41 PIDBLD3  MVEJ IR34352
 444: 0002: \*LIB   MVEJ BASROUT  J86      03/05/97 10:48:46 EDJRAL   *    IR34352
 445: 0002: \*LIB   MVEJ BASROUT  J86      02/17/97 11:19:56 EDJRAL   *    REASONAR
 446: 0002: \*LIB   MVEJ BASROUT  J86      02/14/97 15:59:11 EDJRAL   *    REASONAR
 447: 0002: ! BASROUT.J86 - this file is to be included in any BASIC code which utilizes
 448: 0002: !   the BASROUT.OBJ routines.  These routines were written
 449: 0002: !  using Metaware C and are intended to provide functions which
 450: 0002: !         are either not available in 4680 CBASIC or which can be more
 451: 0002: !               efficiently handled by the C language.  Their usage is
 452: 0002: !  offered on an "AT YOUR OWN RISK" basis.
 453: 0002: !
 454: 0002: !               The insert/extract routines usefulness may not be immediately
 455: 0002: !               apparent.  Their intention is that they be used in conjunction
 456: 0002: !               with a read/write form command.  They can more efficiently
 457: 0002: !               parse a string into many different variables than can the
 458: 0002: !               read form statement.  So instead of a long list of data var's
 459: 0002: !               it may be more efficient to just read/write one long string
 460: 0002: !               and then use the insert/extract routines to parse out the
 461: 0002: !   data.
 462: 0002: 
 463: 0002: ! ******************* SUB PROCESS FUNCTIONS *********************************
 464: 0002: 
 465: 0002: function osshell(cmd.line$) external   ! routine to start
 466: 0002:        ! another program.
 467: 0002:            integer*4    osshell    ! Upon completion of
 468: 0002:            string       cmd.line$   ! program, control is
 469: 0002:        ! returned to calling
 470: 0002: end function      ! program.
 471: 0002: !
 472: 0002: ! NOTES:  Program must be a 286 type file.  This does not exclude
 473: 0002: !         the capability to execute a batch file however.  Simply pass the
 474: 0002: !         following:
 475: 0002: !              c:\adx_spgm\command.286 batfile
 476: 0002: !         where batfile is the name of the batch file to be executed.
 477: 0002: !
 478: 0002: ! IMPORTANT: When using osshell to execute a batch file as described above,
 479: 0002: !            the final command in the batch file must be "exit".  If not,
 480: 0002: !       control is never given back to the calling program.
 481: 0002: 
 482: 0002: ! ************************ MEMORY RELATED FUNCTIONS ************************
 483: 0002: 
 484: 0002: function memfree(choice) external   ! routine to que the
 485: 0002:        ! status of the
 486: 0002:  integer*4 memfree    ! machine's memory:
 487: 0002:  integer*2 choice    ! Options:
 488: 0002:        !    1 - free
 489: 0002: end function      !    2 - total
 490: 0002:        !    3 - system
 491: 0002: 
 492: 0002: ! ********************** TIMEDATE RELATED FUNCTIONS ************************
 493: 0002: 
 494: 0002: function timedate(choice) external   ! routine to que the
 495: 0002:        ! OS's timedate table
 496: 0002:  integer*4 timedate   ! Choices:
 497: 0002:  integer*2 choice    !    1 - millisec's
 498: 0002:        !        since midnight
 499: 0002: end function      !    2 - minutes from
 500: 0002:        !  UCT (timezone)
 501: 0002:        !    3 - day of week
 502: 0002:        !   0-Sunday
 503: 0002:        !  6-Saturday
 504: 0002: 
 505: 0002: function settime(msecs) external   ! routine to set the
 506: 0002:        ! time on the controller
 507: 0002:  integer*4  settime    ! msecs is the desired
 508: 0002:  integer*4 msecs    ! number of milliseconds
 509: 0002:        ! since midnight
 510: 0002: end function      ! Returns negative on
 511: 0002:        ! error
 512: 0002: ! NOTE:  This routine sets the time only on the controller.  The terminals'
 513: 0002: ! time will not be updated until 1 AM or unless a terminal is STC'd.
 514: 0002: ! At 1 AM the controller broadcasts the new time to all terminals.
 515: 0002: ! Insure this is taken into consideration when using this routine.
 516: 0002: 
 517: 0002: !******************** DISK FILE RELATED FUNCTIONS *************************
 518: 0002: 
 519: 0002: function truncate(name,length) external   ! routine to truncate
 520: 0002:        ! the specified file
 521: 0002:  integer*4 truncate   ! to a given length.
 522: 0002:  string  name
 523: 0002:  integer*4 length
 524: 0002: 
 525: 0002: end function
 526: 0002: 
 527: 0002: !******************** STRING VALUE RELATED FUNCTIONS **********************
 528: 0002: 
 529: 0002: function isalpha(bstrn) external   ! routine to identify
 530: 0002:        ! if the specified
 531: 0002:  integer*1 isalpha    ! string contains all
 532: 0002:  string  bstrn    ! alphabetic char's
 533: 0002:        ! Returns:
 534: 0002: end function      !     0 - all alpha
 535: 0002:        !     X - byte of 1st
 536: 0002:        !         non-alpha
 537: 0002:        !   char
 538: 0002: 
 539: 0002: function isdigit(bstrn) external   ! routine to identify
 540: 0002:        ! if the specified
 541: 0002:  integer*1 isdigit    ! string contains all
 542: 0002:  string  bstrn    ! numeric char's
 543: 0002:        ! Returns:
 544: 0002: end function      !     0 - all numeric
 545: 0002:        !     X - byte of 1st
 546: 0002:        !         non-numeric
 547: 0002:        !   char
 548: 0002: 
 549: 0002: function islower(bstrn) external   ! routine to identify
 550: 0002:        ! if the specified
 551: 0002:  integer*1 islower    ! string contains all
 552: 0002:  string  bstrn    ! lower case char's
 553: 0002:        ! Returns:
 554: 0002: end function      !     0 - all lowercase
 555: 0002:        !     X - byte of 1st
 556: 0002:        !         non-lowercase
 557: 0002:        !   char
 558: 0002: 
 559: 0002: function isupper(bstrn) external   ! routine to identify
 560: 0002:        ! if the specified
 561: 0002:  integer*1 isupper    ! string contains all
 562: 0002:  string  bstrn    ! upper case char's
 563: 0002:        ! Returns:
 564: 0002: end function      !     0 - all uppercase
 565: 0002:        !     X - byte of 1st
 566: 0002:        !         non-uppercase
 567: 0002:        !   char
 568: 0002: 
 569: 0002: function toalpha(bstrn) external   ! routine to convert
 570: 0002:        ! non-alpha or non-num
 571: 0002:    integer*2 toalpha    ! char's to spaces
 572: 0002:  string  bstrn    ! Returns:
 573: 0002: end function      !   x - no. of char's
 574: 0002:        !       changed
 575: 0002: 
 576: 0002: ! ********************* USER/GROUP ZERO LEVEL FUNCTIONS *********************
 577: 0002: 
 578: 0002: function idlecount(choice) external   ! routine to either
 579: 0002:        ! set to zero or queue
 580: 0002:  integer*4 idlecount   ! the value of the
 581: 0002:  integer*1 choice    ! processor's idlecount
 582: 0002:        ! Choice:
 583: 0002: end function      !     0 - set to zero
 584: 0002: !       !     1 - get value
 585: 0002: ! NEEDS USER/GROUP 0 LEVEL OF AUTHORIZATION  ! Returns:
 586: 0002: ! TO WORK - This level is not available unless  !     X - idlecount
 587: 0002: ! the file ADXCSOUF.DAT file is "patched".  This !    -X - error code
 588: 0002: ! is highly unrecommended.
 589: 0002: 
 590: 0002: function logical(actname,logname,choice) external ! routine to set a
 591: 0002:        ! a logical name.
 592: 0002:  integer*4 logical    ! parms are self
 593: 0002:         string  logname    ! explanatory except
 594: 0002:  string  actname    ! for choice:
 595: 0002:  integer*1 choice    !   0 - set process
 596: 0002:        !   1 - set system
 597: 0002: end function      !   2 - get process
 598: 0002:        !   3 - get system
 599: 0002: 
 600: 0002: ! NOTE:  Only the setting of a system level of logical name requires
 601: 0002: ! user/group zero level of authorization.  Any application may query any
 602: 0002: ! logical name.  Setting of a system logical name is only applicable until
 603: 0002: ! the system is IPL'd.  A process logical name is only active when that
 604: 0002: ! process is active.
 605: 0002: 
 606: 0002: !******************** STRING PARSING FUNCTIONS *****************************
 607: 0002: 
 608: 0002: function inserts(whole,part,offset) external  ! routine to insert a
 609: 0002:        ! string (part) into
 610: 0002:  integer*2 INSERTS    ! another string (whole)
 611: 0002:  string  whole    ! starting at specified
 612: 0002:  string  part    ! character (offset)
 613: 0002:  integer*2 offset
 614: 0002: 
 615: 0002: end function
 616: 0002: 
 617: 0002: function cinsert4(integer4,bstring,offset) external   ! routine to insert
 618: 0002:        ! a 4-byte integer into
 619: 0002:  integer*1 cinsert4   ! a string starting at
 620: 0002:  integer*4 integer4   ! byte specified by
 621: 0002:  string  bstring    ! offset (1-based)
 622: 0002:  integer*2 offset    ! Returns:
 623: 0002:        !     0 - Success
 624: 0002: end function      !    -1 - String overrun
 625: 0002: 
 626: 0002: function cinsert2(integer2,bstring,offset) external  ! routine to insert
 627: 0002:        ! a 2-byte integer into
 628: 0002:  integer*1 cinsert2   ! a string starting at
 629: 0002:  integer*2 integer2   ! byte specified by
 630: 0002:  string  bstring    ! offset (1-based)
 631: 0002:  integer*2 offset    ! Returns:
 632: 0002:        !     0 - Success
 633: 0002: end function      !    -1 - String overrun
 634: 0002: 
 635: 0002: function cinsert1(bstring,integer1,offset) external  ! routine to insert
 636: 0002:        ! a 1-byte integer into
 637: 0002:  integer*1 cinsert1   ! a string starting at
 638: 0002:  integer*1 integer1   ! byte specified by
 639: 0002:  string  bstring    ! offset (1-based)
 640: 0002:  integer*2 offset    ! Returns:
 641: 0002:        !     0 - Success
 642: 0002: end function      !    -1 - String overrun
 643: 0002: 
 644: 0002: function extracts(whole,part,offset) external  ! routine to extract a
 645: 0002:        ! string (part) from
 646: 0002:  integer*2 EXTRACTS   ! another string (whole)
 647: 0002:  string  whole    ! starting at specified
 648: 0002:  string  part    ! character (offset)
 649: 0002:  integer*2 offset
 650: 0002: 
 651: 0002: end function
 652: 0002: 
 653: 0002: function cextract4(bstring,offset) external  ! routine to extract
 654: 0002:        ! a 4-byte integer from
 655: 0002:  integer*4 cextract4   ! a string starting at
 656: 0002:                        ! byte specified by
 657: 0002:  string  bstring    ! offset (1-based)
 658: 0002:  integer*2 offset    ! Returns:
 659: 0002:        !     X - 4 byte integer
 660: 0002: end function      !    -1 - String overrun
 661: 0002: 
 662: 0002: function cextract2(bstring,offset) external  ! routine to extract
 663: 0002:        ! a 2-byte integer from
 664: 0002:  integer*2 cextract2   ! a string starting at
 665: 0002:                        ! byte specified by
 666: 0002:  string  bstring    ! offset (1-based)
 667: 0002:  integer*2 offset    ! Returns:
 668: 0002:        !     X - 2 byte integer
 669: 0002: end function      !    -1 - String overrun
 670: 0002: 
 671: 0002: function cextract1(bstring,offset) external  ! routine to extract
 672: 0002:        ! a 1-byte integer from
 673: 0002:  integer*1 cextract1   ! a string starting at
 674: 0002:                        ! byte specified by
 675: 0002:  string  bstring    ! offset (1-based)
 676: 0002:  integer*2 offset    ! Returns:
 677: 0002:        !     X - 1 byte integer
 678: 0002: end function      !    -1 - String overrun
 679: 0002: 
 680: 0002: 
 681: 0002: function srchdir (file.name$,dtbl.buffer$) external ! routine to return
 682: 0002:        ! file names and sizes
 683: 0002:        ! Return values:
 684: 0002:        !    -1  no matches
 685: 0002:        !        found on first
 686: 0002:        !        call
 687: 0002:        !    0   no matches
 688: 0002:        !        found on sub-
 689: 0002:        !        sequent calls
 690: 0002:        !    Pos Success
 691: 0002:        !    Neg OS Rtn Code
 692: 0002: ! Usage Note:  If searching for all occurences of a particular file name,
 693: 0002: ! first initialize dtbl.buffer$ to 48 Nulls (pack$("00")) and issue a call
 694: 0002: ! to srchdir.  If any matches are found, a positive value will be returned.
 695: 0002: ! To see if any more matches exist, just issue another call to srchdir without
 696: 0002: ! resetting the values of dtbl.buffer$.  If any are found, a positive value
 697: 0002: ! will be returned.  This can be repeated until a Zero is returned.  All data
 698: 0002: ! describing file will be returned in the dtbl.buffer$ after each call.  Format
 699: 0002: ! of this data is defined below.
 700: 0002: 
 701: 0002:  integer*4 srchdir
 702: 0002: 
 703: 0002:  string  file.name$   ! file name to start
 704: 0002:        ! search (18 bytes max)
 705: 0002:        ! Wild cards and logical
 706: 0002:        ! names supported.
 707: 0002: 
 708: 0002:  string  dtbl.buffer$   ! must be initialized
 709: 0002:        ! to 48 bytes.  Contains
 710: 0002:        ! all of directory info
 711: 0002:        ! Initialize to nulls
 712: 0002:        ! each time a new file
 713: 0002:        ! name is used.
 714: 0002: 
 715: 0002: ! NOTE:  Format of dtbl.buffer$ string is as follows:
 716: 0002: !
 717: 0002: ! Offs  Type                    Description Notes
 718: 0002: !  0 integer*4  key  use extract4 to access
 719: 0002: !  4  string (18 bytes) file name
 720: 0002: ! 22 integer*2  attributes use extract2 to access
 721: 0002: !      0x01 - Read Only
 722: 0002: !      0x02 - Hidden
 723: 0002: !      0x04 - System
 724: 0002: !      0x08 - Volume Label
 725: 0002: !      0x10 - Subdirectory
 726: 0002: !      0x20 - Archive (Files)
 727: 0002: !      0x40 - Security enabled
 728: 0002: !      0x80 - Reserved
 729: 0002: !      0x0000 - Local
 730: 0002: !      0x4000 - Mirrored/Update
 731: 0002: !      0xC000 - Mirrored/Close
 732: 0002: !
 733: 0002: !      0x6000 - Compound/Update
 734: 0002: !      0xE000 - Compound/Close
 735: 0002: ! 24 integer*2  record size use extract2 to access
 736: 0002: ! 26 integer*1  User ID of Owner
 737: 0002: ! 27 integer*1  Group ID of Owner
 738: 0002: ! 28 integer*2  File Security
 739: 0002: ! 30 string (6 bytes) Reserved
 740: 0002: ! 36 integer*4  File Size use extract4 to access
 741: 0002: ! 40 integer*2  Year  use extract2 to access
 742: 0002: ! 42 integer*1  Month
 743: 0002: ! 43 integer*1  Day
 744: 0002: ! 44 integer*1  Hour
 745: 0002: ! 45 integer*1  Minute
 746: 0002: ! 46 integer*1  Second
 747: 0002: ! 47 integer*1  Reserved
 748: 0002: 
 749: 0002: end function
 750: 0002: 
 751: 0002: function srchproc (proc.name$,ptbl.buffer$) external ! routine to return
 752: 0002:        ! process names and
 753: 0002:        ! status.  Handy to
 754: 0002:        ! determine if a
 755: 0002:        ! program is currently
 756: 0002:        ! running.
 757: 0002:        ! Return values:
 758: 0002:        !    -1  no matches
 759: 0002:        !        found on first
 760: 0002:        !        call
 761: 0002:        !    0   no matches
 762: 0002:        !        found on sub-
 763: 0002:        !        sequent calls
 764: 0002:        !    Pos Success
 765: 0002:        !    Neg Failure
 766: 0002:        !        OS Rtn Code
 767: 0002:        ! 80000001h - Insuff
 768: 0002:         !        ptbl buffer
 769: 0002:        !        Length
 770: 0002: ! Usage Note:  If searching for all occurences of a particular process name,
 771: 0002: ! first initialize ptbl.buffer$ to 60 Nulls (pack$("00")) and issue a call
 772: 0002: ! to srchproc.  If any matches are found, a positive value will be returned.
 773: 0002: ! To see if any more matches exist, just issue another call to srchproc without
 774: 0002: ! resetting the values of ptbl.buffer$.  If any are found, a positive value
 775: 0002: ! will be returned.  This can be repeated until a Zero is returned.  All data
 776: 0002: ! describing file will be returned in the ptbl.buffer$ after each call.  Format
 777: 0002: ! of this data is defined as follows:
 778: 0002: !
 779: 0002: !       --------------------------------------------------------
 780: 0002: !   0   |                         PID                          |
 781: 0002: !       --------------------------------------------------------
 782: 0002: !   4   |           FID             |   CID        |   VCID    |
 783: 0002: !       --------------------------------------------------------
 784: 0002: !   8   |                         NAME                         |
 785: 0002: !       --------------------------------------------------------
 786: 0002: !  12   |                         NAME cont'd                  |
 787: 0002: !       --------------------------------------------------------
 788: 0002: !  16   |       NAME cont'd         |   STATE      |  PRIOR    |
 789: 0002: !       --------------------------------------------------------
 790: 0002: !  20   |                         MAXMEM                       |
 791: 0002: !       --------------------------------------------------------
 792: 0002: !  24   |       FLAGS               |   USER        |  GROUP   |
 793: 0002: !       --------------------------------------------------------
 794: 0002: !  28   |                         PARENT                       |
 795: 0002: !       --------------------------------------------------------
 796: 0002: !  32   |                         EVENTS                       |
 797: 0002: !       --------------------------------------------------------
 798: 0002: !  36   |                         CODE                         |
 799: 0002: !       --------------------------------------------------------
 800: 0002: !  40   |                         CSIZE                        |
 801: 0002: !       --------------------------------------------------------
 802: 0002: !  44   |                         DATA                         |
 803: 0002: !       --------------------------------------------------------
 804: 0002: !  48   |                         DSIZE                        |
 805: 0002: !       --------------------------------------------------------
 806: 0002: !  52   |                         HEAP                         |
 807: 0002: !       --------------------------------------------------------
 808: 0002: !  56   |                         HSIZE                        |
 809: 0002: !       --------------------------------------------------------
 810: 0002: !
 811: 0002: !       PID   Process ID
 812: 0002: !       FID  Process's Family ID
 813: 0002: !       CID   Physical Console Device Number
 814: 0002: !       VCID  Process's Virtual Console Number
 815: 0002: !       NAME  Process Name (Application Running)
 816: 0002: ! STATE    Process State (0-Run, 1-Waiting, 2-Terminating)
 817: 0002: ! PRIOR    Priority
 818: 0002: !       MAXMEM  Maximum Memory Allowed
 819: 0002: !       FLAGS  Bit 0 (1-System Process, 0-User Process)
 820: 0002: !   Bit 1 (1-Locked in Memory, 0-Swappable)
 821: 0002: !   Bit 2 (1-Running in SWI context, 0-Running in main context)
 822: 0002: !   Bit 3 (1-Superuser Process,0-Not a Superuser Process)
 823: 0002: ! USER  User Number
 824: 0002: ! GROUP  Group Number
 825: 0002: !       PARENT   Parent Process ID
 826: 0002: !       EVENTS   Bit Map of events that have completed but not retrieved
 827: 0002: !       CODE  Start of code area in user space
 828: 0002: ! CSIZE  Size in bytes of code area
 829: 0002: !       DATA  Start of data area in user space
 830: 0002: ! DSIZE  Size in bytes of data area
 831: 0002: !       HEAP  Start of heap area in user space
 832: 0002: ! HSIZE  Size in bytes of heap area
 833: 0002: !
 834: 0002:  integer*4 srchproc
 835: 0002: 
 836: 0002:  string  proc.name$   ! process name to start
 837: 0002:        ! search (10 bytes max)
 838: 0002:        ! Wild cards and logical
 839: 0002:        ! names supported.
 840: 0002: 
 841: 0002:  string  ptbl.buffer$   ! must be initialized
 842: 0002:        ! to 60 bytes.  Contains
 843: 0002:        ! all of process info
 844: 0002:        ! Initialize to nulls
 845: 0002:        ! each time a new
 846: 0002:        ! process name is used.
 847: 0002: 
 848: 0002: end function
 849: 0002: 
 850: 0002: function cconstat(timeout) external       ! function similar
 851: 0002:                                               ! to BASIC constat%
 852: 0002:  integer*2 cconstat   ! waits for either a
 853: 0002:  integer*4 timeout    ! key being hit or
 854: 0002:        ! the timer expiring
 855: 0002:        ! before returning
 856: 0002:        ! returns:
 857: 0002:        !   -1 error
 858: 0002:        !    0 timer expired
 859: 0002:        !    x scan code of
 860: 0002:        !      key hit
 861: 0002: end function
 862: 0002: 
 863: 0002: function disksize(disk.name$) external   ! function to find
 864: 0002:        ! the total size of
 865: 0002:  integer*4 disksize   ! the specified disk
 866: 0002:  string  disk.name$   ! name (e.g. "h0:")
 867: 0002:        ! if return value is
 868: 0002:        ! negative, error
 869: 0002: end function      ! was received
 870: 0002: 
 871: 0002: 
 872: 0002:     %INCLUDE BCFEXT.J86    ! BCF File function
 873: 0002: \*****************************************************************************
 874: 0002: \*****************************************************************************
 875: 0002: \***
 876: 0002: \***         FUNCTION DEFINITIONS FOR BOOTS CONTROL FILE
 877: 0002: \***
 878: 0002: \***                    REFERENCE : BCFEXTA.J86
 879: 0002: \***
 880: 0002: \***    Version A           Steve Windsor          5th Jan 1993
 881: 0002: \***
 882: 0002: \***    Version B           Michael J. Kelsall    14th Sep 1993
 883: 0002: \***    Code incremented to maintain consistency with other included code
 884: 0002: \***    for RETURNS/AUTOMATIC CREDIT CLAIMING system.
 885: 0002: \***
 886: 0002: \***    Version C           Stuart William McConnachie 23rd Jan 1995
 887: 0002: \***    Addition of TXR serial number as part of the TRANSACTION RETRIEVAL
 888: 0002: \***    project.
 889: 0002: \***
 890: 0002: \***    Version D           Stuart William McConnachie  7th June 1995
 891: 0002: \***    Converted calls to enable more than 1 record on the BCF.
 892: 0002: \***    The second record is to be used for the No7 customer card trial.
 893: 0002: \***
 894: 0002: \***    Revision 4.6            ROBERT COWEY.            19 MAY 2003.
 895: 0002: \***    Modifications for All Txn Data To CDAS project.
 896: 0002: \***    No changes to this file.
 897: 0002: \***
 898: 0002: \***    Revision 4.7            Julia Stones              9th July 2003
 899: 0002: \***    Modifications for New Lines Report project.
 900: 0002: \***    No changes to this file.
 901: 0002: \***
 902: 0002: \*****************************************************************************
 903: 0002: \*****************************************************************************
 904: 0002: 
 905: 0002:    FUNCTION BCF.SET EXTERNAL
 906: 0002:    END FUNCTION
 907: 0002: 
 908: 0002:   FUNCTION READ.BCF EXTERNAL
 909: 0002:    INTEGER*2 READ.BCF
 910: 0002:   END FUNCTION
 911: 0002: 
 912: 0002:   FUNCTION READ.BCF.LOCK EXTERNAL
 913: 0002:    INTEGER*2 READ.BCF.LOCK
 914: 0002:   END FUNCTION
 915: 0002: 
 916: 0002:   FUNCTION WRITE.BCF EXTERNAL
 917: 0002:    INTEGER*2 WRITE.BCF
 918: 0002:   END FUNCTION
 919: 0002: 
 920: 0002:   FUNCTION WRITE.BCF.UNLOCK EXTERNAL
 921: 0002:    INTEGER*2 WRITE.BCF.UNLOCK
 922: 0002:   END FUNCTION
 923: 0002: 
 924: 0002:   FUNCTION WRITE.HOLD.BCF.UNLOCK EXTERNAL
 925: 0002:    INTEGER*2 WRITE.HOLD.BCF.UNLOCK
 926: 0002:   END FUNCTION
 927: 0002: 
 928: 0002: 
 929: 0002: \******************************************************************************
 930: 0002: \******************************************************************************
 931: 0002: \***
 932: 0002: \***    Included code defining external Boots functions
 933: 0002: \***
 934: 0002: \******************************************************************************
 935: 0002: \******************************************************************************
 936: 0002: 
 937: 0002:     %INCLUDE PSBF01E.J86   ! APPLICATION.LOG
 938: 0002: REM \
 939: 0002: \*******************************************************************************
 940: 0002: \*******************************************************************************
 941: 0002: \***
 942: 0002: \***      %INCLUDE FOR EXTERNAL DEFINITION OF FUNCTION APPLICATION.LOG
 943: 0002: \***
 944: 0002: \***                      FUNCTION NUMBER   : PSBF01
 945: 0002: \***
 946: 0002: \***                    INCLUDE REFERENCE : PSBF01E.J86
 947: 0002: \*** 
 948: 0002: \***      Version B           Andrew Wedgeworth          1st July 1992
 949: 0002: \***      Three parameters which passed to the function have been removed.
 950: 0002: \***      APPLICATION.LOG has been added as a variable name (this holds the
 951: 0002: \***      return code).
 952: 0002: \***
 953: 0002: \*******************************************************************************
 954: 0002: 
 955: 0002: 
 956: 0002:    FUNCTION APPLICATION.LOG (MESSAGE.NO%,                                     \
 957: 0002:                              VAR.STRING.1$,                                   \
 958: 0002:                              VAR.STRING.2$,                                   \
 959: 0002:                              EVENT.NO%)  EXTERNAL
 960: 0002: 
 961: 0002:       INTEGER*1 EVENT.NO%
 962: 0002: 
 963: 0002:       INTEGER*2 APPLICATION.LOG,                                       \ GAW
 964: 0002:                 MESSAGE.NO%
 965: 0002: 
 966: 0002:       STRING VAR.STRING.1$,                                            \
 967: 0002:              VAR.STRING.2$
 968: 0002: 
 969: 0002:    END FUNCTION
 970: 0002: 
 971: 0002: \*******************************************************************************
 972: 0002:     %INCLUDE PSBF20E.J86   ! ALLOCATE.DEALLOCATE.SESS.NUM
 973: 0002: REM\
 974: 0002: \*******************************************************************************
 975: 0002: \*******************************************************************************
 976: 0002: \***
 977: 0002: \***       %INCLUDE FOR EXTERNAL DEFINITION OF SESS.NUM.UTILITY
 978: 0002: \***
 979: 0002: \***                  REFERENCE     : PSBF20E.J86
 980: 0002: \***
 981: 0002: \***     VERSION C            Janet Smith                13th May 1992
 982: 0002: \***     Increased PASSED.INTEGER to 2 bytes to cater for more than
 983: 0002: \***     128 files.
 984: 0002: \***
 985: 0002: \***     VERSION D.           Andrew Wedgeworth          1st July 1992
 986: 0002: \***     Removal of redundant parameters and addition of SESS.NUM.UTILITY
 987: 0002: \***     as a variable.  This new variable contains the function's return
 988: 0002: \***     code.
 989: 0002: \***
 990: 0002: \*******************************************************************************
 991: 0002: \*******************************************************************************
 992: 0002: 
 993: 0002:    FUNCTION SESS.NUM.UTILITY (FUNCTION.FLAG$,                          \
 994: 0002:                               PASSED.INTEGER%,                         \
 995: 0002:                               PASSED.STRING$)                          \
 996: 0002:    EXTERNAL
 997: 0002: 
 998: 0002:    STRING    FUNCTION.FLAG$,                                           \
 999: 0002:              PASSED.STRING$
1000: 0002:    ! 3 variables removed from here                                     ! CAW
1001: 0002: 
1002: 0002: 
1003: 0002:    INTEGER*2 SESS.NUM.UTILITY,                                         \ CAW
1004: 0002:              PASSED.INTEGER%				               ! CJAS
1005: 0002: 
1006: 0002:    END FUNCTION
1007: 0002: 
1008: 0002:     %INCLUDE PSBF24E.J86   ! Error detected
1009: 0002: REM \
1010: 0002: \*******************************************************************************
1011: 0002: \*******************************************************************************
1012: 0002: \***
1013: 0002: \***    %INCLUDE FOR EXTERNAL DEFINITION OF STANDARD.ERROR.DETECTED FUNCTION
1014: 0002: \***
1015: 0002: \***                      REFERENCE     : PSBF24E.J86
1016: 0002: \***
1017: 0002: \***    Version A                 Janet Smith                  13th May 1992
1018: 0002: \***
1019: 0002: \*******************************************************************************
1020: 0002: \*******************************************************************************
1021: 0002: 
1022: 0002:    FUNCTION STANDARD.ERROR.DETECTED(ERRN%,                 \
1023: 0002: 				    ERRFILE%,              \
1024: 0002: 				    ERRL%,                 \
1025: 0002: 				    ERR$)        EXTERNAL
1026: 0002: 				    
1027: 0002:           STRING    ERR$
1028: 0002: 
1029: 0002:           INTEGER*2 ERRFILE%,              \
1030: 0002: 	            ERRL%,                 \
1031: 0002: 		    STANDARD.ERROR.DETECTED
1032: 0002: 		    
1033: 0002:           INTEGER*4 ERRN%
1034: 0002: 	  		    
1035: 0002:    END FUNCTION
1036: 0002: 
1037: 0002: 
1038: 0002:     %INCLUDE PSBF39E.J86   ! Display Manager
1039: 0002: !******************************************************************************
1040: 0002: !******************************************************************************
1041: 0002: !***
1042: 0002: !***            PROGRAM         :       PSBF39E.J86
1043: 0002: !***
1044: 0002: !***            DESCRIPTION     :       DISPLAY MANAGER INTERFACE
1045: 0002: !***
1046: 0002: !***            AUTHOR          :       Stuart William McConnachie
1047: 0002: !***            DATE WRITTEN    :       September 2000
1048: 0002: !***
1049: 0002: !***        Provides a much needed and easier to use interface to
1050: 0002: !***        IBM Display Manager.
1051: 0002: !***
1052: 0002: !***        Saves the user having to set up, highlight, tab between and
1053: 0002: !***        validate fields.  Also handles the help screens and conversion
1054: 0002: !***        of date fields to external/internal format.
1055: 0002: !***
1056: 0002: !******************************************************************************
1057: 0002: !******************************************************************************
1058: 0002: 
1059: 0002: !******************************************************************************
1060: 0002: !   Initialises the display manager functions.
1061: 0002: !   You should call this from your program initialisation for screen programs.
1062: 0002: !   Note that the name of the display manager file is determined from the
1063: 0002: !   global variable MODULE.NUMBER$.  For example PSB1200 uses PSBD12.dat
1064: 0002: !   where the PSB and 12 have been derived from MODULE.NUMBER$.
1065: 0002: 
1066: 0002:     FUNCTION DM.INIT EXTERNAL
1067: 0002:         INTEGER*1   DM.INIT
1068: 0002:     END FUNCTION
1069: 0002: 
1070: 0002: !******************************************************************************
1071: 0002: !   Quits the display manager program and frees resources.
1072: 0002: !   You should call this from your program termination.
1073: 0002: 
1074: 0002:     FUNCTION DM.QUIT EXTERNAL
1075: 0002:         INTEGER*1   DM.QUIT
1076: 0002:     END FUNCTION
1077: 0002: 
1078: 0002: !******************************************************************************
1079: 0002: !   Initialises a particular screen from the current display manager file
1080: 0002: !   for display.  You supply the screen number, optional title message and
1081: 0002: !   the first and last help screens associated with the display.
1082: 0002: !   Once you have SHOWN a screen, you can use the remaining functions in
1083: 0002: !   this library to set field values, and actually retrieve input from the
1084: 0002: !   screen.  Note that showing a screen just displays it on the screen,
1085: 0002: !   you need to call PROCESS.SCREEN to actually get any user input.
1086: 0002: 
1087: 0002:     FUNCTION DM.SHOW.SCREEN (SCREEN%, TITLE$, FIRST.HELP%, LAST.HELP%) EXTERNAL
1088: 0002:         INTEGER*1   DM.SHOW.SCREEN
1089: 0002:         INTEGER*2   SCREEN%
1090: 0002:         STRING      TITLE$
1091: 0002:         INTEGER*2   FIRST.HELP%
1092: 0002:         INTEGER*2   LAST.HELP%
1093: 0002:     END FUNCTION
1094: 0002: 
1095: 0002: !******************************************************************************
1096: 0002: !   Sets a function key message to visible.  Optionally sets the text on that
1097: 0002: !   key to the message string passed, if it is not null.
1098: 0002: !   Note you must have shown a screen first, and that the function key fields
1099: 0002: !   need to be defined in your display file with field IDs 241-250.
1100: 0002: 
1101: 0002:     FUNCTION DM.SHOW.FN.KEY (KEY.NUM%, MESSAGE$) EXTERNAL
1102: 0002:         INTEGER*1   DM.SHOW.FN.KEY
1103: 0002:         INTEGER*2   KEY.NUM%
1104: 0002:         STRING      MESSAGE$
1105: 0002:     END FUNCTION
1106: 0002: 
1107: 0002: !******************************************************************************
1108: 0002: !   Sets a function key message to invisible.
1109: 0002: !   Note you must have shown a screen first, and that the function key fields
1110: 0002: !   need to be defined in your display file with field IDs 241-250.
1111: 0002: 
1112: 0002:     FUNCTION DM.HIDE.FN.KEY (KEY.NUM%) EXTERNAL
1113: 0002:         INTEGER*1   DM.HIDE.FN.KEY
1114: 0002:         INTEGER*2   KEY.NUM%
1115: 0002:     END FUNCTION
1116: 0002: 
1117: 0002: !******************************************************************************
1118: 0002: !   LEGACY: Do not use in new programs, use DM.FN.VISIBLE instead which takes
1119: 0002: !   an infix notation expression, as opposed to reverse polish
1120: 0002: !   This definition has been commented out accordingly.  If you are
1121: 0002: !   recompiling an application, change to useing the new function.
1122: 0002: !
1123: 0002: !   FUNCTION DM.FN.KEY.VISIBLE (KEY.NUM%, EXPR$) EXTERNAL
1124: 0002: !       INTEGER*1   DM.FN.KEY.VISIBILITY
1125: 0002: !       INTEGER*2   KEY.NUM%
1126: 0002: !       STRING      EXPR$
1127: 0002: !   END FUNCTION
1128: 0002: 
1129: 0002: !******************************************************************************
1130: 0002: !   Sets a runtine expression to determine if a function key is visible.
1131: 0002: !   This is the new version of the above which takes an infix notation EXPR$.
1132: 0002: !   Note you must have shown a screen first, and that the function key fields
1133: 0002: !   need to be defined in your display file with field IDs 241-250.
1134: 0002: 
1135: 0002:     FUNCTION DM.FN.VISIBLE (KEY.NUM%, EXPR$) EXTERNAL
1136: 0002:         INTEGER*1   DM.FN.VISIBILITY
1137: 0002:         INTEGER*2   KEY.NUM%
1138: 0002:         STRING      EXPR$
1139: 0002:     END FUNCTION
1140: 0002: 
1141: 0002: !******************************************************************************
1142: 0002: !   Specifies that a given field contains a date.
1143: 0002: !   This means that the date will be displayed on screen in the system date
1144: 0002: !   format (e.g. DD/MM/YY or MM/DD/YY, but will be returned and set by your
1145: 0002: !   application in YYMMDD format.
1146: 0002: !   It does NOT mean that the field will be validated as a date, you must do
1147: 0002: !   that explicitly using the VALID$ string.
1148: 0002: 
1149: 0002:     FUNCTION DM.DATE.FIELD (FIELD%) EXTERNAL
1150: 0002:         INTEGER*1   DM.DATE.FIELD
1151: 0002:         INTEGER*2   FIELD%
1152: 0002:     END FUNCTION
1153: 0002: 
1154: 0002: !******************************************************************************
1155: 0002: !   Specifies that a given field will contain a time.
1156: 0002: !   This means that the time will be displayed on screen using the system time
1157: 0002: !   format.  e.g. HH:MM
1158: 0002: 
1159: 0002:     FUNCTION DM.TIME.FIELD (FIELD%) EXTERNAL                                !CSWM
1160: 0002:         INTEGER*1   DM.TIME.FIELD                                           !CSWM
1161: 0002:         INTEGER*2   FIELD%                                                  !CSWM
1162: 0002:     END FUNCTION                                                            !CSWM
1163: 0002: 
1164: 0002: !******************************************************************************
1165: 0002: !   Specifies that a given input field will be read only.
1166: 0002: !   This allows you to select an item from a list by highlighting it.
1167: 0002: 
1168: 0002:     FUNCTION DM.RO.FIELD (FIELD%) EXTERNAL                                  !ESWM
1169: 0002:         INTEGER*1   DM.RO.FIELD                                             !ESWM
1170: 0002:         INTEGER*2   FIELD%                                                  !ESWM
1171: 0002:     END FUNCTION                                                            !ESWM
1172: 0002: 
1173: 0002: !******************************************************************************
1174: 0002: !   Specifies that a given input field will be read write.
1175: 0002: !   Undoes the effect of DM.RO.FIELD.
1176: 0002: 
1177: 0002:     FUNCTION DM.RW.FIELD (FIELD%) EXTERNAL                                  !ESWM
1178: 0002:         INTEGER*1   DM.RW.FIELD                                             !ESWM
1179: 0002:         INTEGER*2   FIELD%                                                  !ESWM
1180: 0002:     END FUNCTION                                                            !ESWM
1181: 0002: 
1182: 0002: !******************************************************************************
1183: 0002: !   LEGACY: Do not use in new programs, use DM.STATUS instead which takes
1184: 0002: !   an infix notation expression, as opposed to reverse polish.
1185: 0002: !   This definition has been commented out accordingly.  If you are
1186: 0002: !   recompiling an application, change to useing the new function.
1187: 0002: !
1188: 0002: !   FUNCTION DM.DISPLAY.MESSAGE (MESSAGE$) EXTERNAL                         !DSWM
1189: 0002: !       INTEGER*1   DM.DISPLAY.MESSAGE                                      !DSWM
1190: 0002: !       STRING      MESSAGE$                                                !DSWM
1191: 0002: !   END FUNCTION                                                            !DSWM
1192: 0002: 
1193: 0002: !******************************************************************************
1194: 0002: !   Displays a message in the status line of the display.  Does not wait for
1195: 0002: !   input.  Use this function for display messages such as B251 Processing...
1196: 0002: !   You must have field 1 defined in your display manager file.
1197: 0002: !   This is the new version of the above which takes an infix notation MESSAGE$.
1198: 0002: 
1199: 0002:     FUNCTION DM.STATUS (MESSAGE$) EXTERNAL                                  !DSWM
1200: 0002:         INTEGER*1   DM.STATUS                                               !DSWM
1201: 0002:         STRING      MESSAGE$                                                !DSWM
1202: 0002:     END FUNCTION                                                            !DSWM
1203: 0002: 
1204: 0002: !******************************************************************************
1205: 0002: !   Waits for input in the invisible input field of the display.  Additionally
1206: 0002: !   displays a message prompting the user on the status line.
1207: 0002: !   You must have fields 1 and 240 defined in your display manager file.
1208: 0002: !   The message supplied should be in Reverse Polish form.
1209: 0002: !   The function returns the key value that ended the input.
1210: 0002: 
1211: 0002:     FUNCTION DM.INVISIBLE.INPUT (MESSAGE$) EXTERNAL
1212: 0002:         STRING      MESSAGE$
1213: 0002:         INTEGER*2   DM.INVISIBLE.INPUT
1214: 0002:     END FUNCTION
1215: 0002: 
1216: 0002: !******************************************************************************
1217: 0002: !   Gets the contents of the invisible field from the display.  This will
1218: 0002: !   allow you to get the Y or N answer that the user typed, for example.
1219: 0002: 
1220: 0002:     FUNCTION DM.INVISIBLE.FIELD EXTERNAL
1221: 0002:         STRING      DM.INVISIBLE.FIELD
1222: 0002:     END FUNCTION
1223: 0002: 
1224: 0002: !******************************************************************************
1225: 0002: !   Returns or sets the current field used for input on the current display.
1226: 0002: !   If NEW.FIELD% is zero, the function simply returns the current field.
1227: 0002: !   If NEW.FIELD% is non zero, the function sets the current field.
1228: 0002: 
1229: 0002:     FUNCTION DM.CURRENT.FIELD (NEW.FIELD%) EXTERNAL
1230: 0002:         INTEGER*2   DM.CURRENT.FIELD
1231: 0002:         INTEGER*2   NEW.FIELD%
1232: 0002:     END FUNCTION
1233: 0002: 
1234: 0002: !******************************************************************************
1235: 0002: !   Sets a key number as being a validation key.  When this key is used the
1236: 0002: !   function will handle the key in the same way as the ENTER key.  i.e. all
1237: 0002: !   the visible fields on in input form are check for validity, and the key
1238: 0002: !   press is only returned to the user if the form entries are valid.
1239: 0002: !   Use this function to add the PGUP.KEY% and PGDN.KEY% keys, for example.
1240: 0002: 
1241: 0002:     FUNCTION DM.VALIDATE.KEY (KEY%) EXTERNAL                                !BSWM
1242: 0002:         INTEGER*1   DM.VALIDATE.KEY                                         !BSWM
1243: 0002:         INTEGER*2   KEY%                                                    !BSWM
1244: 0002:     END FUNCTION                                                            !BSWM
1245: 0002: 
1246: 0002: !******************************************************************************
1247: 0002: !   Returns or sets the flag which says if the screen contents have been
1248: 0002: !   changed or not.  Use this function when you have multiple pages to a
1249: 0002: !   form, but want the user to be prompted to save any changes on exit.
1250: 0002: !   When called with FLAG% set 0 or -1, the function updates the current
1251: 0002: !   displays setting.  When called with any other value, the function simply
1252: 0002: !   returns the current setting and does not update it.
1253: 0002: 
1254: 0002:     FUNCTION DM.CHANGED.FLAG (FLAG%) EXTERNAL                               !BSWM
1255: 0002:         INTEGER*1   FLAG%                                                   !BSWM
1256: 0002:         INTEGER*1   DM.CHANGED.FLAG                                         !BSWM
1257: 0002:     END FUNCTION                                                            !BSWM
1258: 0002: 
1259: 0002: !******************************************************************************
1260: 0002: !   Sets the field tab order.  The tab order can be either:
1261: 0002: !   0 - The TAB order is defined by the fields position on the display,
1262: 0002: !       left to right then top to bottom of the display.
1263: 0002: !   1 - The TAB order is defined by the number order of the fields.  This is
1264: 0002: !       a new option which allows greater control over the field TAB order.
1265: 0002: !   -1  Returns the current setting without changing it.
1266: 0002: !   The default tab order is 0.  Once set, the TAB order is a global setting
1267: 0002: !   for the current and all future screens.
1268: 0002: 
1269: 0002:     FUNCTION DM.TAB.ORDER (ORDER%) EXTERNAL                                 !DSWM
1270: 0002:         INTEGER*1   ORDER%                                                  !DSWM
1271: 0002:         INTEGER*1   DM.TAB.ORDER                                            !DSWM
1272: 0002:     END FUNCTION                                                            !DSWM
1273: 0002: 
1274: 0002: !******************************************************************************
1275: 0002: !   This function actually processes user input on the currently shown form.
1276: 0002: !   The function returns when any unrecognised key terminates input in a
1277: 0002: !   field.  The keys which will do this are determined by the properties of
1278: 0002: !   the Display Manager fields on your form.  The function internally handles
1279: 0002: !   most of the form navigation keys (e.g. Tab, Back Tab, Home End) the
1280: 0002: !   rest are up to the user application.
1281: 0002: 
1282: 0002:     FUNCTION DM.PROCESS.SCREEN (FIRST.FIELD%, LAST.FIELD%, CONFIRM) EXTERNAL
1283: 0002:         INTEGER*2   DM.PROCESS.SCREEN
1284: 0002:         INTEGER*2   FIRST.FIELD%
1285: 0002:         INTEGER*2   LAST.FIELD%
1286: 0002:         INTEGER*1   CONFIRM
1287: 0002:     END FUNCTION
1288: 0002: 
1289: 0002: !******************************************************************************
1290: 0002: !   Associates a field on the current display with a given compile time
1291: 0002: !   variable.  This allows the varibale to be used in your program code
1292: 0002: !   AND be updated by the display manager fields in PROCESS.SCREEN.
1293: 0002: !
1294: 0002: !   NOTE: PLEASE BE VERY CAREFUL WITH THE THIRD PARAMETER TO THIS SUB
1295: 0002: !   Always use an absolute variable for VARIABLE$:
1296: 0002: !       CALL DM.NAME (2, "MY.VAR$", MY.VAR$)
1297: 0002: !   NEVER use a calcualted value. These forms are all ILLEGAL:
1298: 0002: !       CALL DM.NAME (2, "MY.VAR$", "1234")
1299: 0002: !       CALL DM.NAME (2, "MY.VAR$", STR$(MY.VAR%))
1300: 0002: !   Also, if you MUST pass in an array element, for example:
1301: 0002: !       CALL DM.NAME (2, "MY.VAR$", ARRAY.ELEMENT$(I%))
1302: 0002: !   then you must make sure you do not reDIM the array until you have finished
1303: 0002: !   displaying and processing the screen.
1304: 0002: 
1305: 0002:     SUB DM.NAME (FIELD%, NAME$, VARIABLE$) EXTERNAL                         !DSWM
1306: 0002:         INTEGER*2 FIELD%                                                    !DSWM
1307: 0002:         STRING NAME$                                                        !DSWM
1308: 0002:         STRING VARIABLE$                                                    !DSWM
1309: 0002:     END SUB                                                                 !DSWM
1310: 0002: 
1311: 0002: !******************************************************************************
1312: 0002: !   Returns the index of a field on the current screen, given its name.
1313: 0002: 
1314: 0002:     FUNCTION DM.INDEX (FIELD$) EXTERNAL                                     !DSWM
1315: 0002:         STRING FIELD$                                                       !DSWM
1316: 0002:         INTEGER*2 DM.INDEX                                                  !DSWM
1317: 0002:     END FUNCTION                                                            !DSWM
1318: 0002: 
1319: 0002: !******************************************************************************
1320: 0002: !   Sets the validation expression for a field on the display.  Exactly the
1321: 0002: !   same as setting the global VALID$ array yourself, except it is done
1322: 0002: !   via the fields name as assoicated via DM.NAME.FIELD and the expression
1323: 0002: !   is in standard infix notation.
1324: 0002: 
1325: 0002:     FUNCTION DM.VALID (FIELD$, VALID$) EXTERNAL                             !DSWM
1326: 0002:         STRING FIELD$                                                       !DSWM
1327: 0002:         STRING VALID$                                                       !DSWM
1328: 0002:         INTEGER*2 DM.VALID                                                  !DSWM
1329: 0002:     END FUNCTION                                                            !DSWM
1330: 0002: 
1331: 0002: !******************************************************************************
1332: 0002: !   Sets the message expression for a field on the display.  Exactly the
1333: 0002: !   same as setting the global MESSAGE$ array yourself, except it is done
1334: 0002: !   via the fields name as assoicated via DM.NAME.FIELD and the expression
1335: 0002: !   is in standard infix notation.
1336: 0002: 
1337: 0002:     FUNCTION DM.MESSAGE (FIELD$, MESSAGE$) EXTERNAL                         !DSWM
1338: 0002:         STRING FIELD$                                                       !DSWM
1339: 0002:         STRING MESSAGE$                                                     !DSWM
1340: 0002:         INTEGER*2 DM.MESSAGE                                                !DSWM
1341: 0002:     END FUNCTION                                                            !DSWM
1342: 0002: 
1343: 0002: !******************************************************************************
1344: 0002: !   Sets the field attributes for a field on the display. Exactly the
1345: 0002: !   same as using the SETF command yourself except that it is done by
1346: 0002: !   using the fields name as associated via the DM.NAME.FIELD.
1347: 0002: 
1348: 0002: SUB DM.FLD.ATT (FIELD$, VALUE$) EXTERNAL                                    !FNWB
1349: 0002:     STRING      FIELD$                                                      !FNWB
1350: 0002:     STRING      VALUE$                                                      !FNWB
1351: 0002: END SUB                                                                     !FNWB
1352: 0002: 
1353: 0002: !******************************************************************************
1354: 0002: !   Sets an input field to act as an output only field on the display. This
1355: 0002: !   allows setting input fields that contain headings etc. to be skipped by
1356: 0002: !   the cursor movement keys.
1357: 0002: 
1358: 0002: FUNCTION DM.OO.FIELD (FIELD$) EXTERNAL                                      !FNWB
1359: 0002:     INTEGER*2   DM.OO.FIELD                                                 !FNWB
1360: 0002:     STRING      FIELD$                                                      !FNWB
1361: 0002: END FUNCTION                                                                !FNWB
1362: 0002: 
1363: 0002: !******************************************************************************
1364: 0002: !   Sets an input field back to an i/o field
1365: 0002: 
1366: 0002: FUNCTION DM.IO.FIELD (FIELD$) EXTERNAL                                      !FNWB
1367: 0002:     INTEGER*2   DM.IO.FIELD                                                 !FNWB
1368: 0002:     STRING      FIELD$                                                      !FNWB
1369: 0002: END FUNCTION                                                                !FNWB
1370: 0002: 
1371: 0002: !******************************************************************************
1372: 0002: !   Sets the visibility expression for a field on the display.  Exactly the
1373: 0002: !   same as setting the global VISIBLE$ array yourself, except it is done
1374: 0002: !   via the fields name as assoicated via DM.NAME.FIELD and the expression
1375: 0002: !   is in standard infix notation.
1376: 0002: 
1377: 0002:     FUNCTION DM.VISIBLE (FIELD$, VISIBLE$) EXTERNAL                         !DSWM
1378: 0002:         STRING FIELD$                                                       !DSWM
1379: 0002:         STRING VISIBLE$                                                     !DSWM
1380: 0002:         INTEGER*2 DM.VISIBLE                                                !DSWM
1381: 0002:     END FUNCTION                                                            !DSWM
1382: 0002: 
1383: 0002: !******************************************************************************
1384: 0002: !   Sets an error message in field 1 of the display and moves the input
1385: 0002: !   focus to the offending line of the display.  Should be called from user
1386: 0002: !   validation code.  Equivalent of the following separate calls:
1387: 0002: !       CALL DM.CURRENT.FIELD%(DM.INDEX(FIELD$))
1388: 0002: !       FIELD$(1) = POLISH$(MESSAGE$)
1389: 0002: !   Can also be called with a null field name, in which case the cursor
1390: 0002: !   remains in the current input field, but the error is displayed.
1391: 0002: 
1392: 0002:     FUNCTION DM.FOCUS (FIELD$, MESSAGE$) EXTERNAL                           !DSWM
1393: 0002:         STRING FIELD$                                                       !DSWM
1394: 0002:         STRING MESSAGE$                                                     !DSWM
1395: 0002:         INTEGER*2 DM.FOCUS                                                  !DSWM
1396: 0002:     END FUNCTION                                                            !DSWM
1397: 0002: 
1398: 0002: !******************************************************************************
1399: 0002: 
1400: 0002: 
1401: 0002: \******************************************************************************
1402: 0002: \******************************************************************************
1403: 0002: \***
1404: 0002: \***    MAIN PROGRAM
1405: 0002: \***
1406: 0002: \******************************************************************************
1407: 0002: \******************************************************************************
1408: 0002: 
1409: 0002:     MAIN.PROGRAM:
1410: 0024: 
1411: 0024:         ON ERROR GOTO ERROR.DETECTED
1412: 0039:         %INCLUDE PSBUSEE.J86            ! Chaining Parameters
1413: 0039: \/*********************************************************************/ PSBUSEE
1414: 0039: \/*                                                                   */ PSBUSEE
1415: 0039: \/*      PSBUSEE.J86  -  USE in PSB Application Program               */ PSBUSEE
1416: 0039: \/*      ----------------------------------------------               */ PSBUSEE
1417: 0039: \/*                                                                   */ PSBUSEE
1418: 0039: \/*********************************************************************/ PSBUSEE
1419: 0039:                                                                        ! PSBUSEE
1420: 0039:         USE  PSBCHN.OP , PSBCHN.APP , PSBCHN.MENCON , PSBCHN.U1 ,      \ PSBUSEE
1421: 008d:              PSBCHN.U2 , PSBCHN.U3                                     ! PSBUSEE
1422: 008d:                                                                        ! PSBUSEE
1423: 008d: 
1424: 008d:     PROGRAM.CONTROL:
1425: 009d: 
1426: 009d:         GOSUB INITIALISATION
1427: 00af:         GOSUB MAIN.SCREEN
1428: 00c1:         GOSUB TERMINATION
1429: 00d3: 
1430: 00d3:     STOP
1431: 00e0: 
1432: 00e0: \******************************************************************************
1433: 00e0: \******************************************************************************
1434: 00e0: \***
1435: 00e0: \***    MAIN PROGRAM
1436: 00e0: \***
1437: 00e0: \******************************************************************************
1438: 00e0: \******************************************************************************
1439: 00e0: 
1440: 00e0:     INITIALISATION:
1441: 00f0: 
1442: 00f0: 
1443: 00f0:         BCF.OPEN.FLAG$ = "N"
1444: 0105: 
1445: 0105:         INITIALIZED = FALSE         
1446: 0117:         TRUE = -1
1447: 0127:         FALSE = 0  
1448: 0137:         BATCH.SCREEN.FLAG$ = "S"        ! Screen
1449: 014e:         CHAIN.TO.PROG$     = "PSB50"    ! PSB50 for chain
1450: 0165:         MODULE.NUMBER$     = "PSD97"    ! Current Module
1451: 017c:         RESET = FALSE
1452: 018e:         CALL DM.INIT                    ! Display Manager Initialization
1453: 019b:         EXIT.NOW = FALSE
1454: 01ad:         PSD97.FIELD% = 3                ! Default screen input field
1455: 01ba: 
1456: 01ba:         GOSUB ALLOCATE.SESSION.NUMBERS
1457: 01cc: 
1458: 01cc:         
1459: 01cc: 
1460: 01cc:     RETURN
1461: 01dc: 
1462: 01dc: \******************************************************************************
1463: 01dc: \******************************************************************************
1464: 01dc: \***
1465: 01dc: \***    ALLOCATE.SESSION.NUMBERS:
1466: 01dc: \***
1467: 01dc: \***    Use the session number utility to allocate file numbers for the
1468: 01dc: \***    files used by the program.
1469: 01dc: \***
1470: 01dc: \******************************************************************************
1471: 01dc: \******************************************************************************
1472: 01dc: 
1473: 01dc:     ALLOCATE.SESSION.NUMBERS:
1474: 01ec: 
1475: 01ec: 
1476: 01ec:         CALL BCF.SET 
1477: 0207:         FUNCTION.FLAG$ EQ "O"
1478: 021e: 
1479: 021e:         PASSED.INTEGER% EQ BCF.REPORT.NUM%
1480: 0234:         PASSED.STRING$ EQ BCF.FILE.NAME$
1481: 0252:         GOSUB CALL.F20.SESS.NUM.UTILITY
1482: 0264:         BCF.SESS.NUM% EQ F20.INTEGER.FILE.NO%
1483: 027a: 
1484: 027a:     RETURN
1485: 028a: 
1486: 028a: \******************************************************************************
1487: 028a: \******************************************************************************
1488: 028a: \***
1489: 028a: \***    CALL.F20.SESS.NUM.UTILITY:
1490: 028a: \***
1491: 028a: \******************************************************************************
1492: 028a: \******************************************************************************
1493: 028a: 
1494: 028a:     CALL.F20.SESS.NUM.UTILITY: 
1495: 029a:         
1496: 029a:         FILE.OPERATION$ = "O"
1497: 02b1:         CURRENT.REPORT.NUM% = PASSED.INTEGER%
1498: 02c7:         RC% = SESS.NUM.UTILITY (FUNCTION.FLAG$, PASSED.INTEGER%,       \
1499: 0300:                                  PASSED.STRING$)
1500: 0300:         IF RC% <> 0 THEN GOTO FILE.ERROR
1501: 031e: 
1502: 031e:     RETURN
1503: 032e: 
1504: 032e: \******************************************************************************
1505: 032e: \******************************************************************************
1506: 032e: \***
1507: 032e: \***    Screen Validation
1508: 032e: \***
1509: 032e: \******************************************************************************
1510: 032e: \******************************************************************************
1511: 032e: 
1512: 032e:     MAIN.SCREEN:
1513: 033e: 
1514: 033e:         WHILE NOT EXIT.NOW
1515: 0349: 
1516: 0349:             CALL DM.SHOW.SCREEN(1, "", 2, 2)
1517: 0363:      
1518: 0363: 
1519: 0363:             ! Reads BCF and get the current serial numbers of various deal 
1520: 0363:             ! related files and display on the screen. If the current 
1521: 0363:             ! values are already zero, user can refrain from running the
1522: 0363:             ! program
1523: 0363: 
1524: 0363:             GOSUB BCF.OPEN
1525: 0375:             GOSUB BCF.READ
1526: 0387:             GOSUB BCF.CURRENT.FIELD
1527: 0399: 
1528: 0399:             ! if the values are already zero reset flag will be set. if the user
1529: 0399:             ! tries to enter the key again B186 message will be shown on the
1530: 0399:             ! screen
1531: 0399: 
1532: 0399:             IF RESET = TRUE THEN BEGIN
1533: 03ae:                   CALL DM.STATUS                                        \
1534: 03c2:             ("MESSAGE(186,'as BCF serial numbers are already initialized')")
1535: 03c2: 
1536: 03c2:             ENDIF
1537: 03ca: 
1538: 03ca:             CALL DM.CURRENT.FIELD (PSD97.FIELD%) 
1539: 03de: 
1540: 03de:             INITIALIZED = FALSE
1541: 03f0: 
1542: 03f0:             WHILE INITIALIZED <> TRUE 
1543: 03fb: 
1544: 03fb:                 RET.KEY% = DM.PROCESS.SCREEN(PSD97.FIELD%               \
1545: 042c:                                      , PSD97.FIELD%,FALSE)
1546: 042c: 
1547: 042c:                 IF RET.KEY% = F3.KEY%   THEN BEGIN
1548: 0457: 
1549: 0457:                     INITIALIZED = TRUE
1550: 0469:                     EXIT.NOW    = TRUE
1551: 047b:                     GOSUB CHAIN.TO.CALLER
1552: 0490: 
1553: 0490:                 ENDIF ELSE IF RET.KEY% = ESC.KEY%    THEN BEGIN
1554: 04bb:                     GOTO ESCAPE.PRESSED	
1555: 04c9: 
1556: 04c9: 
1557: 04c9:                 ENDIF ELSE IF RET.KEY% = ENTER.KEY%  THEN BEGIN
1558: 04f7: 
1559: 04f7:                     ! Logic executes only if the 'Y' flag is been typed
1560: 04f7:                     ! and enter key is pressed, if so it will be display
1561: 04f7:                     ! processing message.
1562: 04f7: 
1563: 04f7:                     IF UCASE$(FIELD$(3)) = CHR$(89) THEN BEGIN
1564: 053a:                         CALL DM.STATUS ("MESSAGE(251,'')")
1565: 054e:                         WAIT ;500
1566: 0565: 
1567: 0565:                     ! Opens BCF file and reads 14th record, after getting
1568: 0565:                     ! the DIDIR,DVCHR AND DEALDIR serial number it sets
1569: 0565:                     ! the flag accordingly. If the values are already 
1570: 0565:                     ! zero then RESET and INITIALIZED flag will set and
1571: 0565:                     ! message B186 will be shown on the screen
1572: 0565: 
1573: 0565:                         GOSUB BCF.OPEN
1574: 0577:                         GOSUB BCF.READ
1575: 0589:                         GOSUB VALIDATE.BCF  
1576: 059b: 
1577: 059b:                         IF RESET = TRUE THEN BEGIN                   
1578: 05b0: 
1579: 05b0:                             INITIALIZED = TRUE
1580: 05c4: 
1581: 05c4:                         ENDIF ELSE BEGIN
1582: 05cc: 
1583: 05cc:                     ! If serial numbers are not set to zero then main processing
1584: 05cc:                     ! subroutine will be called and the values will be set to zero
1585: 05cc: 
1586: 05cc:                             GOSUB MAIN.PROCESSING
1587: 05de: 
1588: 05de:                             CALL DM.STATUS ("MESSAGE(299,'')")
1589: 05f2: 
1590: 05f2:                             GOSUB BCF.CURRENT.FIELD
1591: 0604: 
1592: 0604:                         ENDIF                 
1593: 060e: 
1594: 060e:                     ENDIF ELSE BEGIN
1595: 0616: 
1596: 0616:                     ! Displays the message if the input letter is not Y
1597: 0616: 
1598: 0616:                         CALL DM.STATUS ("MESSAGE(005,'')")              
1599: 062a: 
1600: 062a:                     ENDIF
1601: 0634: 
1602: 0634:                 ENDIF ELSE BEGIN
1603: 063c:                     !Displays if the key pressed is not ESCAPE,F3 or enter 
1604: 063c:                     CALL DM.STATUS ("MESSAGE(001,'')")                   
1605: 0650: 
1606: 0650:                 ENDIF
1607: 0658: 
1608: 0658:             WEND
1609: 0670: 
1610: 0670:         WEND 
1611: 0682: 
1612: 0682:     RETURN
1613: 0692: 
1614: 0692: \******************************************************************************
1615: 0692: \******************************************************************************
1616: 0692: \***
1617: 0692: \***    BCF OPEN
1618: 0692: \***
1619: 0692: \******************************************************************************
1620: 0692: \******************************************************************************
1621: 0692: 
1622: 0692:     BCF.OPEN:
1623: 06a2: 
1624: 06a2:         FILE.OPERATION$ = "O"
1625: 06b9:         IF BCF.OPEN.FLAG$ <> "Y" THEN BEGIN
1626: 06d4: 
1627: 06d4:             IF END #BCF.SESS.NUM% THEN FILE.ERROR
1628: 06f0:             OPEN BCF.FILE.NAME$ RECL BCF.RECL% AS BCF.SESS.NUM% LOCKED 
1629: 071c:             BCF.OPEN.FLAG$ = "Y"
1630: 0731: 
1631: 0731:         ENDIF
1632: 0739: 
1633: 0739:     RETURN
1634: 0749: 
1635: 0749: 
1636: 0749: \******************************************************************************
1637: 0749: \******************************************************************************
1638: 0749: \***
1639: 0749: \***    BCF READ
1640: 0749: \***
1641: 0749: \******************************************************************************
1642: 0749: \******************************************************************************
1643: 0749: 
1644: 0749:     BCF.READ:
1645: 0759: 
1646: 0759:         ! Record number in BCF , which holds deal related serial numbers
1647: 0759:         BCF.REC.NO% = 14                            
1648: 0770:         FILE.OPERATION$ = "R"
1649: 0787:         RC% = READ.BCF
1650: 07a0: 
1651: 07a0:         IF RC% <> 0 THEN BEGIN
1652: 07bb:             GOSUB FILE.ERROR
1653: 07cd:         ENDIF
1654: 07d5: 
1655: 07d5:     RETURN
1656: 07e5: 
1657: 07e5: \******************************************************************************
1658: 07e5: \******************************************************************************
1659: 07e5: \***
1660: 07e5: \***    VALIDATE BCF
1661: 07e5: \***
1662: 07e5: \******************************************************************************
1663: 07e5: \******************************************************************************
1664: 07e5: 
1665: 07e5:     VALIDATE.BCF:         
1666: 07f5: 
1667: 07f5:         IF  BCF.DEALDIR.SERIAL.NUM$ = "0000" AND          \          
1668: 086f:                           BCF.DIDIR.SERIAL.NUM$   = "0000" AND          \
1669: 086f:                           BCF.DVCHR.SERIAL.NUM$   = "0000" THEN BEGIN
1670: 086f: 
1671: 086f: 
1672: 086f:             RESET = TRUE
1673: 0881:         ENDIF
1674: 0889: 
1675: 0889:     RETURN
1676: 0899: 
1677: 0899: \******************************************************************************
1678: 0899: \******************************************************************************
1679: 0899: \***
1680: 0899: \***    BCF.CURRENT.FIELD
1681: 0899: \***
1682: 0899: \******************************************************************************
1683: 0899: \******************************************************************************
1684: 0899: 
1685: 0899:     BCF.CURRENT.FIELD:
1686: 08a9:         ! fields to display the current values from BCF
1687: 08a9: 
1688: 08a9:         FIELD$(6) = BCF.DEALDIR.SERIAL.NUM$
1689: 08d3:         FIELD$(7) = BCF.DIDIR.SERIAL.NUM$
1690: 08fd:         FIELD$(8) = BCF.DVCHR.SERIAL.NUM$
1691: 0927: 
1692: 0927:     RETURN
1693: 0937: 
1694: 0937: 
1695: 0937: \******************************************************************************
1696: 0937: \******************************************************************************
1697: 0937: \***
1698: 0937: \***    MAIN PROCESSING
1699: 0937: \***
1700: 0937: \******************************************************************************
1701: 0937: \******************************************************************************
1702: 0937: 
1703: 0937:     MAIN.PROCESSING:
1704: 0947: 
1705: 0947:         BCF.REC.NO% = 14
1706: 095e: 
1707: 095e:         FILE.OPERATION$ = "R"
1708: 0975: 
1709: 0975:         RC% = READ.BCF
1710: 098e: 
1711: 098e:         IF RC% <> 0 THEN BEGIN
1712: 09a9:             GOTO FILE.ERROR
1713: 09b6:         ENDIF ELSE BEGIN
1714: 09be:             GOSUB SET.SERIAL.ZERO
1715: 09d0:         ENDIF
1716: 09d8: 
1717: 09d8:     RETURN
1718: 09e8: 
1719: 09e8: \******************************************************************************
1720: 09e8: \******************************************************************************
1721: 09e8: \***
1722: 09e8: \***    SET.SERIAL.ZERO
1723: 09e8: \***
1724: 09e8: \******************************************************************************
1725: 09e8: \******************************************************************************
1726: 09e8: 
1727: 09e8:     SET.SERIAL.ZERO:
1728: 09f8: 
1729: 09f8:       ! Below hard coded variables will reset the serial numbers of DEALDIR
1730: 09f8:       ! DIDIR and DVCHR. Store can have an initial deal load then
1731: 09f8: 
1732: 09f8:         BCF.DEALDIR.SERIAL.NUM$ = "0000"
1733: 0a0f:         BCF.DIDIR.SERIAL.NUM$   = "0000"
1734: 0a26:         BCF.DVCHR.SERIAL.NUM$   = "0000"
1735: 0a3d: 
1736: 0a3d:         FILE.OPERATION$ = "W"
1737: 0a54: 
1738: 0a54:         RC% = WRITE.BCF
1739: 0a6d: 
1740: 0a6d:         IF RC% <> 0 THEN BEGIN
1741: 0a88:             GOTO FILE.ERROR
1742: 0a95:         ENDIF ELSE BEGIN  
1743: 0a9d:             RESET = TRUE
1744: 0aaf:         ENDIF 
1745: 0ab7: 
1746: 0ab7: 
1747: 0ab7:     RETURN
1748: 0ac7: 
1749: 0ac7: \******************************************************************************
1750: 0ac7: \******************************************************************************
1751: 0ac7: \***
1752: 0ac7: \***     CLOSE.PROCESSING
1753: 0ac7: \***
1754: 0ac7: \******************************************************************************
1755: 0ac7: \******************************************************************************
1756: 0ac7: 
1757: 0ac7:     CLOSE.PROCESSING:
1758: 0ad7: 
1759: 0ad7:         IF BCF.OPEN.FLAG$ <> "N" THEN BEGIN
1760: 0af2:             CLOSE BCF.SESS.NUM%   
1761: 0b06:             BCF.OPEN.FLAG$ = "N"
1762: 0b1b:         ENDIF
1763: 0b23: 
1764: 0b23:     RETURN 
1765: 0b33: 
1766: 0b33: \******************************************************************************
1767: 0b33: \******************************************************************************
1768: 0b33: \***
1769: 0b33: \***     DEALLOCATE.SESSION.NUMBERS
1770: 0b33: \***
1771: 0b33: \******************************************************************************
1772: 0b33: \******************************************************************************
1773: 0b33: 
1774: 0b33:     DEALLOCATE.SESSION.NUMBERS:
1775: 0b43: 
1776: 0b43:         FUNCTION.FLAG$   = "C"          
1777: 0b5a: 
1778: 0b5a:         PASSED.INTEGER% EQ BCF.REPORT.NUM%
1779: 0b70:         PASSED.STRING$ EQ BCF.FILE.NAME$
1780: 0b8e:         GOSUB CALL.F20.SESS.NUM.UTILITY
1781: 0ba0:         BCF.SESS.NUM% EQ F20.INTEGER.FILE.NO%
1782: 0bb6: 
1783: 0bb6:     RETURN
1784: 0bc6: 
1785: 0bc6: \******************************************************************************
1786: 0bc6: \******************************************************************************
1787: 0bc6: \***
1788: 0bc6: \***   SUBROUTINE :  ESCAPE.PRESSED
1789: 0bc6: \***
1790: 0bc6: \******************************************************************************
1791: 0bc6: \******************************************************************************
1792: 0bc6: 
1793: 0bc6:     ESCAPE.PRESSED:
1794: 0bd6: 
1795: 0bd6:         PSBCHN.MENCON = "000000"
1796: 0bed: 
1797: 0bed:     CHAIN.TO.CALLER: 
1798: 0bfd: 
1799: 0bfd:         IF COMMAND.MODE THEN BEGIN
1800: 0c0f:             CLEARS
1801: 0c1e:             GOSUB STOP.PROGRAM
1802: 0c30:         ENDIF
1803: 0c38: 
1804: 0c38:         ! Processing - Please wait
1805: 0c38:         CALL DM.STATUS ("MESSAGE(405,'')")
1806: 0c4c:         CALL DM.QUIT
1807: 0c59: 
1808: 0c59:         ! Current program and chaining program
1809: 0c59:         PSBCHN.APP = "C:/ADX_UPGM/PSE50.286"
1810: 0c70:         PSBCHN.PRG = "C:/ADX_UPGM/" + CHAIN.TO.PROG$ + ".286"
1811: 0c99: 
1812: 0c99:         %INCLUDE PSBCHNE.J86          ! Include CHAIN operation
1813: 0c99: \/*********************************************************************/ PSBCHNE
1814: 0c99: \/*                                                                   */ PSBCHNE
1815: 0c99: \/*      PSBCHNE.J86  -  Chain to PSB Application Program             */ PSBCHNE
1816: 0c99: \/*      ------------------------------------------------             */ PSBCHNE
1817: 0c99: \/*                                                                   */ PSBCHNE
1818: 0c99: \/*********************************************************************/ PSBCHNE
1819: 0c99:                                                                        ! PSBCHNE
1820: 0c99:         CHAIN  PSBCHN.PRG , PSBCHN.OP , PSBCHN.APP , PSBCHN.MENCON ,   \ PSBCHNE
1821: 0d19:                             PSBCHN.U1 , PSBCHN.U2  , PSBCHN.U3         ! PSBCHNE
1822: 0d19:                                                                        ! PSBCHNE
1823: 0d19: 
1824: 0d19:         GOSUB STOP.PROGRAM
1825: 0d2b: 
1826: 0d2b:     RETURN
1827: 0d3b: 
1828: 0d3b: 
1829: 0d3b: \******************************************************************************
1830: 0d3b: \******************************************************************************
1831: 0d3b: \***
1832: 0d3b: \***   SUBROUTINE : TERMINATION
1833: 0d3b: \***
1834: 0d3b: \******************************************************************************
1835: 0d3b: \******************************************************************************
1836: 0d3b: 
1837: 0d3b:      TERMINATION:
1838: 0d4b: 
1839: 0d4b:          GOSUB CLOSE.PROCESSING
1840: 0d5d:          GOSUB DEALLOCATE.SESSION.NUMBERS
1841: 0d6f: 
1842: 0d6f:      RETURN
1843: 0d7f: 
1844: 0d7f: \******************************************************************************
1845: 0d7f: \******************************************************************************
1846: 0d7f: \***                                                                           
1847: 0d7f: \***   ERROR ROUTINE  :  FILE.ERROR                                            
1848: 0d7f: \***                                                                           
1849: 0d7f: \***   Call APPLICATION.LOG to log an event 106 with                           
1850: 0d7f: \***   flag, current report number and current key                             
1851: 0d7f: \***                                                                           
1852: 0d7f: \***                                                                           
1853: 0d7f: \******************************************************************************
1854: 0d7f: \******************************************************************************
1855: 0d7f: 
1856: 0d7f:     FILE.ERROR:         
1857: 0d8f: 
1858: 0d8f:         EVENT.NO%     = 106
1859: 0da0: 
1860: 0da0:         FILE.NO$  = CHR$(SHIFT(BCF.REPORT.NUM%,8))            +         \
1861: 0df3:                   CHR$(SHIFT(BCF.REPORT.NUM%,0))
1862: 0df3: 
1863: 0df3:         IF FILE.OPERATION$ = "O" THEN BEGIN  ! Open error
1864: 0e11: 
1865: 0e11:             MESSAGE.NO%   = 501    ! Message No. for open error
1866: 0e24: 
1867: 0e24:         ENDIF ELSE IF FILE.OPERATION$ = "R" THEN BEGIN  ! Read error
1868: 0e42: 
1869: 0e42:             MESSAGE.NO%   = 508    ! Message No. for Read error
1870: 0e55: 
1871: 0e55:         ENDIF ELSE IF FILE.OPERATION$ = "W" THEN BEGIN  ! Read error
1872: 0e73: 
1873: 0e73:             MESSAGE.NO%   = 504    ! Message No. for Write error
1874: 0e84: 
1875: 0e84:         ENDIF
1876: 0e8c: 
1877: 0e8c:         VAR.STRING.1$ = FILE.OPERATION$                       +         \
1878: 0f16:                  CHR$(SHIFT(BCF.REPORT.NUM%, 8) AND 0FFH)     +         \
1879: 0f16:                  CHR$(BCF.REPORT.NUM% AND 0FFH)               +         \
1880: 0f16:                  CURRENT.CODE$
1881: 0f16:         VAR.STRING.2$ = RIGHT$("000" + STR$(BCF.REPORT.NUM%),3) +       \
1882: 0f7e:                  UNPACK$(CURRENT.CODE$)  
1883: 0f7e: 
1884: 0f7e:         RC% = APPLICATION.LOG(MESSAGE.NO%,VAR.STRING.1$,                \
1885: 0fc0:                       VAR.STRING.2$,EVENT.NO%)
1886: 0fc0: 
1887: 0fc0: 
1888: 0fc0:         GOTO ESCAPE.PRESSED
1889: 0fcb: 
1890: 0fcb: \******************************************************************************
1891: 0fcb: \******************************************************************************
1892: 0fcb: \***
1893: 0fcb: \***   SUBROUTINE : ERROR.DETECTED
1894: 0fcb: \***
1895: 0fcb: \******************************************************************************
1896: 0fcb: \******************************************************************************
1897: 0fcb: 
1898: 0fcb:     ERROR.DETECTED:
1899: 0fdb: 
1900: 0fdb:         IF ERR = "NP" THEN BEGIN    ! Command mode run
1901: 1001:             COMMAND.MODE = TRUE       ! Command mode is set to TRUE
1902: 1017:             RESUME PROGRAM.CONTROL
1903: 102e:         ENDIF
1904: 1036: 
1905: 1036:        ! CALL STANDARD.ERROR.DETECTED(ERRN, ERRF%, ERRL, ERR)
1906: 1036: 
1907: 1036:         GOSUB FILE.ERROR
1908: 1048: 
1909: 1048: \******************************************************************************
1910: 1048: \******************************************************************************
1911: 1048: \***
1912: 1048: \***   SUBROUTINE : STOP.PROGRAM
1913: 1048: \***
1914: 1048: \******************************************************************************
1915: 1048: \******************************************************************************
1916: 1048: 
1917: 1048:      STOP.PROGRAM:
1918: 105d: 
1919: 105d:      END
1920: 105d: 
1921: 105d: \******************************************************************************
1922: 105d: \******************************************************************************
1923: 105d: \***
1924: 105d: \***    End of program 
1925: 105d: \***
1926: 105d: \******************************************************************************
1927: 105d: \******************************************************************************
1928: 105d:  
1929: 105d: End of Compilation
