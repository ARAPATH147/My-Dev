   1: 0000: \********************************************************************
   2: 0000: \********************************************************************
   3: 0000: \***
   4: 0000: \***
   5: 0000: \***            PROGRAM         :       SRP10
   6: 0000: \***            AUTHOR          :       Neil Bennett
   7: 0000: \***            DATE WRITTEN    :       June 2006
   8: 0000: \***
   9: 0000: \***            MODULE          :       SRP10.BAS
  10: 0000: \***
  11: 0000: \***
  12: 0000: \***    VERSION A.          NEIL BENNETT.           02 JUN 2006.
  13: 0000: \***    Initial version.
  14: 0000: \***
  15: 0000: \***    VERSION B.          Charles Skadorwa.       11 DEC 2008.
  16: 0000: \***    No. of records on SRSXF increased from 30,000 to 60,000
  17: 0000: \***    due to increase in Intactix data volumes for large stores
  18: 0000: \***    which caused keyed file insertion errors.
  19: 0000: \***
  20: 0000: \***    Version C.          Ranjith Gopalankutty      15 March 2016  
  21: 0000: \***    INV10004135 - While housekeeping the planner files, current  
  22: 0000: \***    deletion subroutine(POG.DEL) deletes only SRPOG,SRMOD and    
  23: 0000: \***    SRPDF and leaving behind SRSXF. File builds up over time     
  24: 0000: \***    and fails POGOK suite. POG.DEL will be changed to include    
  25: 0000: \***    SRSXF deletion, also existing deletion logic of SRMOD file   
  26: 0000: \***    is outdated which will be changed too. Starting 2015,        
  27: 0000: \***    refresh of planner has increased, so need to increase the    
  28: 0000: \***    file capacity of SRPOG,SRMOD,SRPDF and SRSXF to double of    
  29: 0000: \***    its current size                                             
  30: 0000: \********************************************************************
  31: 0000: \********************************************************************
  32: 0000: 
  33: 0000: \********************************************************************
  34: 0000: \********************************************************************
  35: 0000: \***
  36: 0000: \***    Module Overview
  37: 0000: \***    ---------------
  38: 0000: \***
  39: 0000: \***    This ADCS initiated program takes the Intactix Space and
  40: 0000: \***    Range store data and applies it to the in store POG and
  41: 0000: \***    module keyed files.
  42: 0000: \***
  43: 0000: \********************************************************************
  44: 0000: \********************************************************************
  45: 0000: 
  46: 0000: \********************************************************************
  47: 0000: \***
  48: 0000: \***    Function globals
  49: 0000: \***
  50: 0000: \********************************************************************
  51: 0000: 
  52: 0000: %INCLUDE PSBF01G.J86    !APPLICATION LOG
  53: 0000: REM \
  54: 0000: \*******************************************************************************
  55: 0000: \*******************************************************************************
  56: 0000: \***
  57: 0000: \***       %INCLUDE FOR GLOBAL DEFINITIONS FOR FUNCTION APPLICATION.LOG
  58: 0000: \***
  59: 0000: \***                FUNCTION NUMBER    : PSBF01
  60: 0000: \***
  61: 0000: \***                REFERENCE          : PSBF01G.J86
  62: 0000: \***
  63: 0000: \***                DATE OF LAST AMENDMENT  - 27/2/86
  64: 0000: \***
  65: 0000: \***
  66: 0000: \*******************************************************************************
  67: 0000: 
  68: 0000:       INTEGER GLOBAL  F01.RETURN.CODE%
  69: 0000: 
  70: 0000: 
  71: 0000: %INCLUDE PSBF20G.J86    !SESSION NUMBER UTILITY
  72: 0000: REM\
  73: 0000: \*******************************************************************************
  74: 0000: \*******************************************************************************
  75: 0000: \***
  76: 0000: \***     %INCLUDE GLOBAL VARIABLE DEFINITIONS FOR SESS.NUM.UTILITY FUNCTION
  77: 0000: \***
  78: 0000: \***                       REFERENCE     : PSBF20G.J86
  79: 0000: \*** 
  80: 0000: \***     Version A              Bruce Scrive                   5th May 1988   
  81: 0000: \*** 
  82: 0000: \***     Version B              Robert Cowey                   7th May 1991
  83: 0000: \***     Global variable F20.INTEGER.FILE.NO% changed from one byte integer
  84: 0000: \***     to two byte integer.
  85: 0000: \***
  86: 0000: \***     Version D              Andrew Wedgeworth             1st July 1992
  87: 0000: \***     F20.RETURN.CODE% removed as it is no longer required.
  88: 0000: \***
  89: 0000: \*******************************************************************************
  90: 0000: \*******************************************************************************
  91: 0000: 
  92: 0000:       STRING    GLOBAL F20.FILE.NAME$,                                 \
  93: 0000:                        F20.STRING.FILE.NO$,                            \
  94: 0000:                        F20.TABLE.DIMENSIONED.FLAG$,                    \
  95: 0000:                        SESS.NUM.TABLE$(1)
  96: 0000: 
  97: 0000:       INTEGER*2 GLOBAL F20.INTEGER.FILE.NO%
  98: 0000: 
  99: 0000:       ! 1 line deleted from here                                       ! DAW 
 100: 0000: 
 101: 0000: %INCLUDE POGDEDEC.J86
 102: 0000: \********************************************************************
 103: 0000: \***      EXTERNAL FUNCTION DECLARATIONS FOR THE POGDE FILE
 104: 0000: \***      REFERENCE : POGOKDEC.J86
 105: 0000: \***      Version A           Neil Bennett            6th June 2006
 106: 0000: \***
 107: 0000: \********************************************************************
 108: 0000: 
 109: 0000:   INTEGER*2 GLOBAL                \
 110: 0000:     POGDE.SESS.NUM%,              \
 111: 0000:     POGDE.REPORT.NUM%             !
 112: 0000: 
 113: 0000:   STRING GLOBAL                   \
 114: 0000:     POGDE.COPY.NAME$,             \
 115: 0000:     POGDE.FILE.NAME$,             \
 116: 0000:     POGDE.RCD$                    !
 117: 0000: %INCLUDE POGOKDEC.J86
 118: 0000: \********************************************************************
 119: 0000: \***      EXTERNAL FUNCTION DECLARATIONS FOR THE POGOK FILE
 120: 0000: \***      REFERENCE : POGOKDEC.J86
 121: 0000: \***      Version A           Neil Bennett            6th June 2006
 122: 0000: \***
 123: 0000: \********************************************************************
 124: 0000: 
 125: 0000:   INTEGER*1 GLOBAL                \
 126: 0000:     POGOK.PE10.RETCODE%,          \
 127: 0000:     POGOK.PE5.RETCODE%,           \
 128: 0000:     POGOK.PE6.RETCODE%,           \
 129: 0000:     POGOK.PE7.RETCODE%,           \
 130: 0000:     POGOK.PE4.RETCODE%,           \
 131: 0000:     POGOK.PE19.RETCODE%           !
 132: 0000: 
 133: 0000:   INTEGER*2 GLOBAL                \
 134: 0000:     POGOK.DAYS.TO.RETAIN%,        \
 135: 0000:     POGOK.SESS.NUM%,              \
 136: 0000:     POGOK.REPORT.NUM%,            \
 137: 0000:     POGOK.RECL%                   !
 138: 0000: 
 139: 0000:   INTEGER*4 GLOBAL                \
 140: 0000:     POGOK.SRD.REC.COUNT%,         \
 141: 0000:     POGOK.SRM.REC.COUNT%
 142: 0000: 
 143: 0000:   STRING GLOBAL                   \
 144: 0000:     POGOK.FILE.NAME$,             \
 145: 0000:     POGOK.SRD.SER.NO$,            \
 146: 0000:     POGOK.SRM.SER.NO$,            \
 147: 0000:     POGOK.SRD.DATE$,              \
 148: 0000:     POGOK.SRM.DATE$,              \
 149: 0000:     POGOK.RELOAD$,                \
 150: 0000:     POGOK.PE10.RUNFLAG$,          \
 151: 0000:     POGOK.PE5.RUNFLAG$,           \
 152: 0000:     POGOK.PE6.RUNFLAG$,           \
 153: 0000:     POGOK.PE7.RUNFLAG$,           \
 154: 0000:     POGOK.PE4.RUNFLAG$,           \
 155: 0000:     POGOK.FAILED.SRD.SER.NO$,     \
 156: 0000:     POGOK.FAILED.SRD.DATE$,       \
 157: 0000:     POGOK.FAILED.SRM.SER.NO$,     \
 158: 0000:     POGOK.FAILED.SRM.DATE$,       \
 159: 0000:     POGOK.PE10.RUNDATE$,          \
 160: 0000:     POGOK.PE5.RUNDATE$,           \
 161: 0000:     POGOK.PE6.RUNDATE$,           \
 162: 0000:     POGOK.PE7.RUNDATE$,           \
 163: 0000:     POGOK.PE4.RUNDATE$,           \
 164: 0000:     POGOK.PE19.RUNFLAG$,          \
 165: 0000:     POGOK.PE19.RUNDATE$,          \
 166: 0000:     POGOK.FILLER$                 !
 167: 0000: %INCLUDE SRPDFDEC.J86
 168: 0000: \********************************************************************
 169: 0000: \***      EXTERNAL FUNCTION DECLARATIONS FOR THE SRPDF FILE
 170: 0000: \***      REFERENCE : SRPDFDEC.J86
 171: 0000: \***      Version A           Neil Bennett          7th August 2006
 172: 0000: \***
 173: 0000: \********************************************************************
 174: 0000: 
 175: 0000:   INTEGER*2 GLOBAL        \
 176: 0000:     SRPDF.SESS.NUM%,      \
 177: 0000:     SRPDF.REPORT.NUM%,    \
 178: 0000:     SRPDF.RECL%           !
 179: 0000: 
 180: 0000:   INTEGER*4 GLOBAL        \
 181: 0000:     SRPDF.POGDB%          ! Unique POG Database key
 182: 0000: 
 183: 0000:   STRING GLOBAL           \
 184: 0000:     SRPDF.FILE.NAME$,     \ File name
 185: 0000:     SRPDF.SHRT.DESC$,     \ Medium descriptor (50)
 186: 0000:     SRPDF.FULL.DESC$,     \ Full descriptor (100)
 187: 0000:     SRPDF.FILLER$         !
 188: 0000: 
 189: 0000: 
 190: 0000: %INCLUDE SRPOGDEC.J86
 191: 0000: \********************************************************************
 192: 0000: \***      EXTERNAL FUNCTION DECLARATIONS FOR THE SRPOG FILE
 193: 0000: \***      REFERENCE : SRPOGDEC.J86
 194: 0000: \***      Version A           Neil Bennett            5th June 2006
 195: 0000: \***
 196: 0000: \********************************************************************
 197: 0000: 
 198: 0000:   INTEGER*1 GLOBAL        \
 199: 0000:     SRPOG.MODULE.COUNT%,  \ Number of modules comprising POG
 200: 0000:     SRPOG.KEY.LEVEL%,     \ Family hierarchy key level
 201: 0000:     SRPOG.LIVE.RPT.CNT%,  \ Computed Live repeat count (Unset -1)
 202: 0000:     SRPOG.PEND.RPT.CNT%   ! Computed pending repeat count (Unset -1)
 203: 0000: 
 204: 0000:   INTEGER*2 GLOBAL        \
 205: 0000:     SRPOG.SESS.NUM%,      \
 206: 0000:     SRPOG.REPORT.NUM%,    \
 207: 0000:     SRPOG.RECL%           !
 208: 0000: 
 209: 0000:   INTEGER*4 GLOBAL        \
 210: 0000:     SRPOG.POGDB%,         \ Unique POG Database key
 211: 0000:     SRPOG.CAT.DBKEY%,     \ Family hierarchy key
 212: 0000:     SRPOG.CAT1.ID%,       \ hierarchy key
 213: 0000:     SRPOG.CAT2.ID%,       \ hierarchy key
 214: 0000:     SRPOG.CAT3.ID%,       \ hierarchy key
 215: 0000:     SRPOG.POGID%          ! POG Identifier
 216: 0000: 
 217: 0000:   STRING GLOBAL           \
 218: 0000:     SRPOG.FILE.NAME$,     \ File name
 219: 0000:     SRPOG.COPY.NAME$,     \ File name
 220: 0000:     SRPOG.ACT.DATE$,      \ Activation Date YYYY MM DD
 221: 0000:     SRPOG.DEACT.DATE$,    \ Deactivation Date YYYY MM DD
 222: 0000:     SRPOG.DESCRIPTION$,   \ Truncated POG description (30)
 223: 0000:     SRPOG.PLANNER.FAMILY$,\ Truncated Planner Family description (30)
 224: 0000:     SRPOG.DATE.RPT.CNT$,  \ Date repeat count is valid YYYY MM DD
 225: 0000:     SRPOG.FILLER$         !
 226: 0000: 
 227: 0000: 
 228: 0000: %INCLUDE SRMODDEC.J86
 229: 0000: \********************************************************************
 230: 0000: \***      EXTERNAL FUNCTION DECLARATIONS FOR THE SRMOD FILE
 231: 0000: \***      REFERENCE : SRMODDEC.J86
 232: 0000: \***      Version A           Neil Bennett            5th June 2006
 233: 0000: \***
 234: 0000: \********************************************************************
 235: 0000: 
 236: 0000:   INTEGER*1 GLOBAL             \
 237: 0000:     SRMOD.FACINGS%(1),         \
 238: 0000:     SRMOD.MODULE.SEQ%,         \
 239: 0000:     SRMOD.RECORD.CHAIN%,       \
 240: 0000:     SRMOD.SHELF.NUM%(1)
 241: 0000: 
 242: 0000:   INTEGER*2 GLOBAL             \
 243: 0000:     SRMOD.ITEM.COUNT%,         \
 244: 0000:     SRMOD.MAX.ITEMS%,          \
 245: 0000:     SRMOD.MDQ%(1),             \
 246: 0000:     SRMOD.PSC%(1),             \
 247: 0000:     SRMOD.RECL%,               \
 248: 0000:     SRMOD.REPORT.NUM%,         \
 249: 0000:     SRMOD.SHELF.COUNT%,        \
 250: 0000:     SRMOD.SESS.NUM%
 251: 0000: 
 252: 0000:   INTEGER*4 GLOBAL             \
 253: 0000:     SRMOD.POGDB%
 254: 0000: 
 255: 0000:   STRING GLOBAL                \
 256: 0000:     SRMOD.ARRAY$,              \
 257: 0000:     SRMOD.COPY.NAME$,          \
 258: 0000:     SRMOD.DESCRIPTOR$,         \
 259: 0000:     SRMOD.FILE.NAME$,          \
 260: 0000:     SRMOD.ITEM.CODE$(1),       \
 261: 0000:     SRMOD.FILLER$
 262: 0000: %INCLUDE SRSXFDEC.J86
 263: 0000: \********************************************************************
 264: 0000: \***      EXTERNAL FUNCTION DECLARATIONS FOR THE SRSXF FILE
 265: 0000: \***      REFERENCE : SRSXFDEC.J86
 266: 0000: \***      Version A           Neil Bennett          7th August 2006
 267: 0000: \***
 268: 0000: \********************************************************************
 269: 0000: 
 270: 0000:   INTEGER*1 GLOBAL        \
 271: 0000:     SRSXF.MODULE.SEQ%,    \
 272: 0000:     SRSXF.SHELF.NO%,      \
 273: 0000:     SRSXF.NOTCH.NO%       !
 274: 0000: 
 275: 0000:   INTEGER*2 GLOBAL        \
 276: 0000:     SRSXF.SESS.NUM%,      \
 277: 0000:     SRSXF.REPORT.NUM%,    \
 278: 0000:     SRSXF.RECL%           !
 279: 0000: 
 280: 0000:   INTEGER*4 GLOBAL        \
 281: 0000:     SRSXF.POGDB%,         \
 282: 0000:     SRSXF.SHELF.KEY%      !
 283: 0000: 
 284: 0000:   STRING GLOBAL           \
 285: 0000:     SRSXF.FILE.NAME$,     \ File name
 286: 0000:     SRSXF.SHELF.DESC$,    \
 287: 0000:     SRSXF.FILLER$         !
 288: 0000: 
 289: 0000: 
 290: 0000: 
 291: 0000: \********************************************************************
 292: 0000: \***
 293: 0000: \***    SRP10 variables
 294: 0000: \***
 295: 0000: \********************************************************************
 296: 0000: 
 297: 0000:    STRING    GLOBAL CURRENT.CODE$
 298: 0000:    INTEGER*2 GLOBAL CURRENT.REPORT.NUM%
 299: 0000:    STRING    GLOBAL FILE.OPERATION$
 300: 0000:    STRING    GLOBAL SB.ACTION$
 301: 0000:    STRING    GLOBAL SB.FILE.NAME$
 302: 0000:    INTEGER*2 GLOBAL SB.INTEGER%
 303: 0000:    INTEGER*2 GLOBAL SB.FILE.REP.NUM%
 304: 0000:    INTEGER*2 GLOBAL SB.FILE.SESS.NUM%
 305: 0000:    STRING    GLOBAL SB.STRING$
 306: 0000: 
 307: 0000:    INTEGER*2 ARRAY.COUNT%                                               ! CRG
 308: 0000:    INTEGER*1 bg%
 309: 0000:    INTEGER*1 CHAIN.COUNT%                                               ! CRG
 310: 0000:    STRING    comm.tail$
 311: 0000:    INTEGER*1 eof%
 312: 0000:    STRING    err.cd$
 313: 0000:    INTEGER*2 event.no%
 314: 0000:    STRING    file$
 315: 0000:    STRING    file.no$
 316: 0000:    INTEGER*1 run.suite%
 317: 0000:    INTEGER*1 init.fail%
 318: 0000:    INTEGER*1 init.load%
 319: 0000:    INTEGER*2 it.ptr%
 320: 0000:    INTEGER*2 item.cnt%
 321: 0000:    INTEGER*1 last.notch%
 322: 0000:    INTEGER*1 last.shelf%
 323: 0000:    STRING    mess$
 324: 0000:    INTEGER*2 message.no%
 325: 0000:    INTEGER*1 mod.cnt%
 326: 0000:    INTEGER*1 no.file%
 327: 0000:    INTEGER*1 no.inp.file%
 328: 0000:    INTEGER*1 no.mod.file%
 329: 0000:    INTEGER*1 no.pog.file%
 330: 0000:    INTEGER*1 no.read%
 331: 0000:    STRING    parm$
 332: 0000:    STRING    POGDE.DATE$
 333: 0000:    INTEGER*2 POGDE.DTR%
 334: 0000:    INTEGER*4 POGDE.SER.NO%
 335: 0000:    INTEGER*2 rc%
 336: 0000:    INTEGER*4 rc4%
 337: 0000:    INTEGER*4 rec.cnt%
 338: 0000:    STRING    rectyp$
 339: 0000:    STRING    rundate$
 340: 0000:    INTEGER*2 shelf.cnt%
 341: 0000:    INTEGER*1 srmod.chg%
 342: 0000:    INTEGER*2 shelf.item.seq%
 343: 0000:    INTEGER*2 sit.cnt%
 344: 0000:    INTEGER*1 SRMOD.COUNT.LIMIT%                                         ! CRG
 345: 0000:    INTEGER*1 srp10.error%
 346: 0000:    INTEGER*1 srp10.event%
 347: 0000:    INTEGER*1 tlr.read%
 348: 0000:    INTEGER*4 tlr.cnt%
 349: 0000:    STRING    text$
 350: 0000:    STRING    var.string.1$
 351: 0000:    STRING    var.string.2$
 352: 0000:    STRING    work$
 353: 0000: 
 354: 0000: \********************************************************************
 355: 0000: \***
 356: 0000: \***    External functions
 357: 0000: \***
 358: 0000: \********************************************************************
 359: 0000: 
 360: 0000: %INCLUDE ADXSERVE.J86   !Controller Services
 361: 0000: \******************************************************************************
 362: 0000: \******************************************************************************
 363: 0000: \***                                                                        ***
 364: 0000: \***    %INCLUDE FOR FUNCTION ADXSERVE (an I.B.M. system function)          ***
 365: 0000: \***                                                                        ***
 366: 0000: \***         AUTHOR        :  Bruce Scriver                                 ***
 367: 0000: \***                                                                        ***
 368: 0000: \***         DATE WRITTEN  :  14th March 1986                               ***
 369: 0000: \***                                                                        ***
 370: 0000: \***         DATE OF LAST REVISION  - 14th March 1986                       ***
 371: 0000: \***                                                                        ***
 372: 0000: \***                                                                        ***
 373: 0000: \******************************************************************************
 374: 0000: \******************************************************************************
 375: 0000: 
 376: 0000:    SUB ADXSERVE (RETURN.CODE%,                                                \
 377: 0000:                  ADX.FUNCTION%,                                               \
 378: 0000:                  ADX.PARM.1%,                                                 \
 379: 0000:                  ADX.PARM.2$)                                                 \
 380: 0000:    EXTERNAL
 381: 0000:   
 382: 0000:       STRING     ADX.PARM.2$
 383: 0000: 
 384: 0000:       INTEGER*2  ADX.FUNCTION%,                                               \
 385: 0000:                  ADX.PARM.1%
 386: 0000: 
 387: 0000:       INTEGER*4  RETURN.CODE%                                                 \
 388: 0000: 
 389: 0000:    END SUB     
 390: 0000: 
 391: 0000: %INCLUDE PSBF01E.J86    !APPLICATION LOG
 392: 0000: REM \
 393: 0000: \*******************************************************************************
 394: 0000: \*******************************************************************************
 395: 0000: \***
 396: 0000: \***      %INCLUDE FOR EXTERNAL DEFINITION OF FUNCTION APPLICATION.LOG
 397: 0000: \***
 398: 0000: \***                      FUNCTION NUMBER   : PSBF01
 399: 0000: \***
 400: 0000: \***                    INCLUDE REFERENCE : PSBF01E.J86
 401: 0000: \*** 
 402: 0000: \***      Version B           Andrew Wedgeworth          1st July 1992
 403: 0000: \***      Three parameters which passed to the function have been removed.
 404: 0000: \***      APPLICATION.LOG has been added as a variable name (this holds the
 405: 0000: \***      return code).
 406: 0000: \***
 407: 0000: \*******************************************************************************
 408: 0000: 
 409: 0000: 
 410: 0000:    FUNCTION APPLICATION.LOG (MESSAGE.NO%,                                     \
 411: 0000:                              VAR.STRING.1$,                                   \
 412: 0000:                              VAR.STRING.2$,                                   \
 413: 0000:                              EVENT.NO%)  EXTERNAL
 414: 0000: 
 415: 0000:       INTEGER*1 EVENT.NO%
 416: 0000: 
 417: 0000:       INTEGER*2 APPLICATION.LOG,                                       \ GAW
 418: 0000:                 MESSAGE.NO%
 419: 0000: 
 420: 0000:       STRING VAR.STRING.1$,                                            \
 421: 0000:              VAR.STRING.2$
 422: 0000: 
 423: 0000:    END FUNCTION
 424: 0000: 
 425: 0000: \*******************************************************************************
 426: 0000: %INCLUDE PSBF20E.J86    !SESSION NUMBER UTILITY
 427: 0000: REM\
 428: 0000: \*******************************************************************************
 429: 0000: \*******************************************************************************
 430: 0000: \***
 431: 0000: \***       %INCLUDE FOR EXTERNAL DEFINITION OF SESS.NUM.UTILITY
 432: 0000: \***
 433: 0000: \***                  REFERENCE     : PSBF20E.J86
 434: 0000: \***
 435: 0000: \***     VERSION C            Janet Smith                13th May 1992
 436: 0000: \***     Increased PASSED.INTEGER to 2 bytes to cater for more than
 437: 0000: \***     128 files.
 438: 0000: \***
 439: 0000: \***     VERSION D.           Andrew Wedgeworth          1st July 1992
 440: 0000: \***     Removal of redundant parameters and addition of SESS.NUM.UTILITY
 441: 0000: \***     as a variable.  This new variable contains the function's return
 442: 0000: \***     code.
 443: 0000: \***
 444: 0000: \*******************************************************************************
 445: 0000: \*******************************************************************************
 446: 0000: 
 447: 0000:    FUNCTION SESS.NUM.UTILITY (FUNCTION.FLAG$,                          \
 448: 0000:                               PASSED.INTEGER%,                         \
 449: 0000:                               PASSED.STRING$)                          \
 450: 0000:    EXTERNAL
 451: 0000: 
 452: 0000:    STRING    FUNCTION.FLAG$,                                           \
 453: 0000:              PASSED.STRING$
 454: 0000:    ! 3 variables removed from here                                     ! CAW
 455: 0000: 
 456: 0000: 
 457: 0000:    INTEGER*2 SESS.NUM.UTILITY,                                         \ CAW
 458: 0000:              PASSED.INTEGER%				               ! CJAS
 459: 0000: 
 460: 0000:    END FUNCTION
 461: 0000: 
 462: 0000: %INCLUDE PSBF24E.J86    !STANDARD ERROR DETECTED
 463: 0000: REM \
 464: 0000: \*******************************************************************************
 465: 0000: \*******************************************************************************
 466: 0000: \***
 467: 0000: \***    %INCLUDE FOR EXTERNAL DEFINITION OF STANDARD.ERROR.DETECTED FUNCTION
 468: 0000: \***
 469: 0000: \***                      REFERENCE     : PSBF24E.J86
 470: 0000: \***
 471: 0000: \***    Version A                 Janet Smith                  13th May 1992
 472: 0000: \***
 473: 0000: \*******************************************************************************
 474: 0000: \*******************************************************************************
 475: 0000: 
 476: 0000:    FUNCTION STANDARD.ERROR.DETECTED(ERRN%,                 \
 477: 0000: 				    ERRFILE%,              \
 478: 0000: 				    ERRL%,                 \
 479: 0000: 				    ERR$)        EXTERNAL
 480: 0000: 				    
 481: 0000:           STRING    ERR$
 482: 0000: 
 483: 0000:           INTEGER*2 ERRFILE%,              \
 484: 0000: 	            ERRL%,                 \
 485: 0000: 		    STANDARD.ERROR.DETECTED
 486: 0000: 		    
 487: 0000:           INTEGER*4 ERRN%
 488: 0000: 	  		    
 489: 0000:    END FUNCTION
 490: 0000: 
 491: 0000: 
 492: 0000: 
 493: 0000: %INCLUDE BTCMEM.J86
 494: 0000: !********************************************************************
 495: 0000: !***
 496: 0000: !***    INCLUDED CODE:  BTCMEM.J86
 497: 0000: !***    AUTHOR:         Stuart William McConnachie
 498: 0000: !***    DATE:           26th February 2006
 499: 0000: !***
 500: 0000: !********************************************************************
 501: 0000: !***
 502: 0000: !***    Controller CBASIC Memory Functions
 503: 0000: !***
 504: 0000: !********************************************************************
 505: 0000: 
 506: 0000: !Get a single byte integer from a string offset
 507: 0000: FUNCTION GETN1 (S$, P%) EXTERNAL
 508: 0000:     STRING S$
 509: 0000:     INTEGER*2 P%
 510: 0000:     INTEGER*2 GETN1
 511: 0000: END FUNCTION
 512: 0000: 
 513: 0000: !Get a two byte integer from a string offset
 514: 0000: FUNCTION GETN2 (S$, P%) EXTERNAL
 515: 0000:     STRING S$
 516: 0000:     INTEGER*2 P%
 517: 0000:     INTEGER*2 GETN2
 518: 0000: END FUNCTION
 519: 0000: 
 520: 0000: !Get a four byte integer from a string offset
 521: 0000: FUNCTION GETN4 (S$, P%) EXTERNAL
 522: 0000:     STRING S$
 523: 0000:     INTEGER*2 P%
 524: 0000:     INTEGER*4 GETN4
 525: 0000: END FUNCTION
 526: 0000: 
 527: 0000: !Get a 10 byte CBASIC real from a string offset
 528: 0000: FUNCTION GETR10 (S$, P%) EXTERNAL
 529: 0000:     STRING S$
 530: 0000:     INTEGER*2 P%
 531: 0000:     REAL GETR10
 532: 0000: END FUNCTION
 533: 0000: 
 534: 0000: !Put a single byte integer into a string at offset
 535: 0000: FUNCTION PUTN1 (S$, P%, N%) EXTERNAL
 536: 0000:     STRING S$
 537: 0000:     INTEGER*2 P%
 538: 0000:     INTEGER*1 N%
 539: 0000:     INTEGER*1 PUTN1
 540: 0000: END FUNCTION
 541: 0000: 
 542: 0000: !Put a two byte integer into a string at offset
 543: 0000: FUNCTION PUTN2 (S$, P%, N%) EXTERNAL
 544: 0000:     STRING S$
 545: 0000:     INTEGER*2 P%
 546: 0000:     INTEGER*2 N%
 547: 0000:     INTEGER*1 PUTN2
 548: 0000: END FUNCTION
 549: 0000: 
 550: 0000: !Put a four byte integer into a string at offset
 551: 0000: FUNCTION PUTN4 (S$, P%, N%) EXTERNAL
 552: 0000:     STRING S$
 553: 0000:     INTEGER*2 P%
 554: 0000:     INTEGER*4 N%
 555: 0000:     INTEGER*1 PUTN4
 556: 0000: END FUNCTION
 557: 0000: 
 558: 0000: !Put a 10 byte CBASIC real into a string at offset
 559: 0000: FUNCTION PUTR10 (S$, P%, R) EXTERNAL
 560: 0000:     STRING S$
 561: 0000:     INTEGER*2 P%
 562: 0000:     REAL R
 563: 0000:     INTEGER*1 PUTR10
 564: 0000: END FUNCTION
 565: 0000: 
 566: 0000: !Peek a two byte integer from a memory address
 567: 0000: FUNCTION PEEKN2 (A%) EXTERNAL
 568: 0000:     INTEGER*4 A%
 569: 0000:     INTEGER*2 PEEKN2
 570: 0000: END FUNCTION
 571: 0000: 
 572: 0000: !Peek a four byte integer from a memory address
 573: 0000: FUNCTION PEEKN4 (A%) EXTERNAL
 574: 0000:     INTEGER*4 A%
 575: 0000:     INTEGER*4 PEEKN4
 576: 0000: END FUNCTION
 577: 0000: 
 578: 0000: !Peek a 10 byte CBASIC real from a memory address
 579: 0000: FUNCTION PEEKR10 (A%) EXTERNAL
 580: 0000:     INTEGER*4 A%
 581: 0000:     REAL PEEKR10
 582: 0000: END FUNCTION
 583: 0000: 
 584: 0000: !Poke a two byte integer to a memory address
 585: 0000: FUNCTION POKEN2 (A%, N%) EXTERNAL
 586: 0000:     INTEGER*4 A%
 587: 0000:     INTEGER*2 N%
 588: 0000:     INTEGER*1 POKEN2
 589: 0000: END FUNCTION
 590: 0000: 
 591: 0000: !Poke a four byte integer to a memory address
 592: 0000: FUNCTION POKEN4 (A%, N%) EXTERNAL
 593: 0000:     INTEGER*4 A%
 594: 0000:     INTEGER*4 N%
 595: 0000:     INTEGER*1 POKEN4
 596: 0000: END FUNCTION
 597: 0000: 
 598: 0000: !Poke a 10 byte CBASIC real to a memory address
 599: 0000: FUNCTION POKER10 (A%, R) EXTERNAL
 600: 0000:     INTEGER*4 A%
 601: 0000:     REAL R
 602: 0000:     INTEGER*1 POKER10
 603: 0000: END FUNCTION
 604: 0000: 
 605: 0000: %INCLUDE SRPEXT.J86
 606: 0000: \********************************************************************
 607: 0000: \***      Space and Range Planner Common Functions  (SRPFUN)
 608: 0000: \***      Version A           Neil Bennett          24.08.2006
 609: 0000: \***
 610: 0000: \....................................................................
 611: 0000: \***
 612: 0000: \***    GET.CATID Construct a 4 byte integer Category ID from 3
 613: 0000: \***              hierarchical (I4) keys supplied.
 614: 0000: \***
 615: 0000: \********************************************************************
 616: 0000: 
 617: 0000:    FUNCTION GET.CATID%(lev1%,lev2%,lev3%) EXTERNAL
 618: 0000: 
 619: 0000:     INTEGER*4 GET.CATID%
 620: 0000:     INTEGER*4 lev1%, lev2%, lev3%
 621: 0000: 
 622: 0000:    END FUNCTION
 623: 0000: 
 624: 0000: \********************************************************************
 625: 0000: %INCLUDE POGDEEXT.J86
 626: 0000: \********************************************************************
 627: 0000: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE POGDE FILE
 628: 0000: \***      REFERENCE : POGDEEXT.J86
 629: 0000: \***      Version A           Neil Bennett            8th June 2006
 630: 0000: \***
 631: 0000: \********************************************************************
 632: 0000: 
 633: 0000:        FUNCTION POGDE.SET EXTERNAL
 634: 0000:        END FUNCTION
 635: 0000: 
 636: 0000:        FUNCTION READ.POGDE EXTERNAL
 637: 0000:           INTEGER*2 READ.POGDE
 638: 0000:        END FUNCTION
 639: 0000: %INCLUDE POGOKEXT.J86
 640: 0000: \********************************************************************
 641: 0000: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE POGOK FILE
 642: 0000: \***      REFERENCE : POGOKEXT.J86
 643: 0000: \***      Version A           Neil Bennett            6th June 2006
 644: 0000: \***
 645: 0000: \********************************************************************
 646: 0000: 
 647: 0000:        FUNCTION POGOK.SET EXTERNAL
 648: 0000:        END FUNCTION
 649: 0000: 
 650: 0000:        FUNCTION READ.POGOK EXTERNAL
 651: 0000:           INTEGER*2 READ.POGOK
 652: 0000:        END FUNCTION
 653: 0000: 
 654: 0000:        FUNCTION READ.POGOK.LOCK EXTERNAL
 655: 0000:           INTEGER*2 READ.POGOK.LOCK
 656: 0000:        END FUNCTION
 657: 0000: 
 658: 0000:        FUNCTION WRITE.POGOK EXTERNAL
 659: 0000:           INTEGER*2 WRITE.POGOK
 660: 0000:        END FUNCTION
 661: 0000: 
 662: 0000:        FUNCTION WRITE.POGOK.UNLOCK EXTERNAL
 663: 0000:           INTEGER*2 WRITE.POGOK.UNLOCK
 664: 0000:        END FUNCTION
 665: 0000: 
 666: 0000:        FUNCTION CREATE.POGOK EXTERNAL
 667: 0000:           INTEGER*2 CREATE.POGOK
 668: 0000:        END FUNCTION
 669: 0000: %INCLUDE SRPDFEXT.J86
 670: 0000: \********************************************************************
 671: 0000: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE SRPDF FILE
 672: 0000: \***      REFERENCE : SRPDFEXT.J86
 673: 0000: \***      Version A           Neil Bennett          7th August 2006
 674: 0000: \***
 675: 0000: \********************************************************************
 676: 0000: 
 677: 0000:        FUNCTION SRPDF.SET EXTERNAL
 678: 0000:        END FUNCTION
 679: 0000: 
 680: 0000:        FUNCTION READ.SRPDF EXTERNAL
 681: 0000:           INTEGER*2 READ.SRPDF
 682: 0000:        END FUNCTION
 683: 0000: 
 684: 0000:        FUNCTION WRITE.SRPDF EXTERNAL
 685: 0000:           INTEGER*2 WRITE.SRPDF
 686: 0000:        END FUNCTION
 687: 0000: 
 688: 0000:        FUNCTION DELREC.SRPDF EXTERNAL
 689: 0000:           INTEGER*2 DELREC.SRPDF
 690: 0000:        END FUNCTION
 691: 0000: %INCLUDE SRPOGEXT.J86
 692: 0000: \********************************************************************
 693: 0000: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE SRPOG FILE
 694: 0000: \***      REFERENCE : SRPOGEXT.J86
 695: 0000: \***      Version A           Neil Bennett            5th June 2006
 696: 0000: \***
 697: 0000: \********************************************************************
 698: 0000: 
 699: 0000:        FUNCTION SRPOG.SET EXTERNAL
 700: 0000:        END FUNCTION
 701: 0000: 
 702: 0000:        FUNCTION READ.SRPOG EXTERNAL
 703: 0000:           INTEGER*2 READ.SRPOG
 704: 0000:        END FUNCTION
 705: 0000: 
 706: 0000:        FUNCTION WRITE.SRPOG EXTERNAL
 707: 0000:           INTEGER*2 WRITE.SRPOG
 708: 0000:        END FUNCTION
 709: 0000: 
 710: 0000:        FUNCTION DELREC.SRPOG EXTERNAL
 711: 0000:           INTEGER*2 DELREC.SRPOG
 712: 0000:        END FUNCTION
 713: 0000: %INCLUDE SRMODEXT.J86
 714: 0000: \********************************************************************
 715: 0000: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE SRMOD FILE
 716: 0000: \***      REFERENCE : SRMODEXT.J86
 717: 0000: \***      Version A           Neil Bennett            5th June 2006
 718: 0000: \***
 719: 0000: \********************************************************************
 720: 0000: 
 721: 0000:        FUNCTION SRMOD.SET EXTERNAL
 722: 0000:        END FUNCTION
 723: 0000: 
 724: 0000:        FUNCTION READ.SRMOD EXTERNAL
 725: 0000:           INTEGER*2 READ.SRMOD
 726: 0000:        END FUNCTION
 727: 0000: 
 728: 0000:        FUNCTION WRITE.SRMOD EXTERNAL
 729: 0000:           INTEGER*2 WRITE.SRMOD
 730: 0000:        END FUNCTION
 731: 0000: 
 732: 0000:        FUNCTION DELREC.SRMOD EXTERNAL
 733: 0000:           INTEGER*2 DELREC.SRMOD
 734: 0000:        END FUNCTION
 735: 0000: 
 736: 0000:        SUB SRMOD.SPLIT.SHELF.ITEM EXTERNAL
 737: 0000:        END SUB
 738: 0000: %INCLUDE SRSXFEXT.J86
 739: 0000: \********************************************************************
 740: 0000: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE SRSXF FILE
 741: 0000: \***      REFERENCE : SRSXFEXT.J86
 742: 0000: \***      Version A           Neil Bennett          7th August 2006
 743: 0000: \***
 744: 0000: \********************************************************************
 745: 0000: 
 746: 0000:        FUNCTION SRSXF.SET EXTERNAL
 747: 0000:        END FUNCTION
 748: 0000: 
 749: 0000:        FUNCTION READ.SRSXF EXTERNAL
 750: 0000:           INTEGER*2 READ.SRSXF
 751: 0000:        END FUNCTION
 752: 0000: 
 753: 0000:        FUNCTION WRITE.SRSXF EXTERNAL
 754: 0000:           INTEGER*2 WRITE.SRSXF
 755: 0000:        END FUNCTION
 756: 0000: 
 757: 0000:        FUNCTION DELREC.SRSXF EXTERNAL
 758: 0000:           INTEGER*2 DELREC.SRSXF
 759: 0000:        END FUNCTION
 760: 0000: 
 761: 0000:    FUNCTION ADXSTART(NAME$, PARM$, MESS$) EXTERNAL
 762: 0000:       INTEGER*2 ADXSTART
 763: 0000:       STRING    NAME$, PARM$, MESS$
 764: 0000:    END FUNCTION
 765: 0000: 
 766: 0000: \********************************************************************
 767: 0000: \***
 768: 0000: \***    SRP10 functions
 769: 0000: \***
 770: 0000: \********************************************************************
 771: 0000: 
 772: 0000: \********************************************************************
 773: 0000: \********************************************************************
 774: 0000: \***
 775: 0000: \***    S T A R T  O F  M A I N L I N E  C O D E
 776: 0000: \***
 777: 0000: \********************************************************************
 778: 0000: \********************************************************************
 779: 0000: 
 780: 0000:     ON ERROR GOTO ERROR.DETECTED
 781: 002f: 
 782: 002f: START.PROGRAM:
 783: 0037: 
 784: 0037:     mess$ = "Program started - Initialising ....."
 785: 004c:     GOSUB DISPLAY.MSG
 786: 005e:     GOSUB INITIALISATION
 787: 0070: 
 788: 0070:     IF NOT init.fail% THEN BEGIN
 789: 007f:        mess$ = "Processing S&R Change Delta File ..."
 790: 0094:        GOSUB DISPLAY.MSG
 791: 00a6:        GOSUB MAIN.PROCESS
 792: 00b8:     ENDIF
 793: 00c0: 
 794: 00c0: TIDY.END.PROG:
 795: 00d0: 
 796: 00d0:     IF run.suite% THEN BEGIN
 797: 00e2:        mess$ = "Updating run File and Tidy up ......"
 798: 00f7:        GOSUB DISPLAY.MSG
 799: 0109:        GOSUB UPDATE.RUN.FILE
 800: 011b:        mess$ = "Program Ended - Flag " + POGOK.PE10.RUNFLAG$        \
 801: 0166:              + " Code " + STR$(POGOK.PE10.RETCODE%) + " ......"
 802: 0166:     ENDIF ELSE BEGIN
 803: 016e:        mess$ = "Suite already processed today - Ending."
 804: 0183:     ENDIF
 805: 018b: 
 806: 018b:     GOSUB DISPLAY.MSG
 807: 019d:     GOSUB TERMINATION
 808: 01af: 
 809: 01af: FATAL.END.PROG:
 810: 01bf: 
 811: 01bf:     IF err.cd$ <> "" THEN BEGIN
 812: 01da: 
 813: 01da:        mess$ = "Program Abended ERR >" + err.cd$ + "<"
 814: 01fe:        GOSUB DISPLAY.MSG
 815: 0210: 
 816: 0210:     ENDIF
 817: 0218: 
 818: 0218: STOP
 819: 0225: 
 820: 0225: \********************************************************************
 821: 0225: \********************************************************************
 822: 0225: \***
 823: 0225: \***    S T A R T  O F  S U B R O U T I N E S
 824: 0225: \***
 825: 0225: \********************************************************************
 826: 0225: \********************************************************************
 827: 0225: 
 828: 0225: \********************************************************************
 829: 0225: \***
 830: 0225: \***    SUBROUTINE      :       MAIN.PROCESS
 831: 0225: \***
 832: 0225: \********************************************************************
 833: 0225: \***
 834: 0225: \***    READ sequentially through the POG Delta file
 835: 0225: \***
 836: 0225: \***    Process each record type
 837: 0225: \***
 838: 0225: \***    RETURN
 839: 0225: \***
 840: 0225: \********************************************************************
 841: 0225: 
 842: 0225: MAIN.PROCESS:
 843: 0235: 
 844: 0235:    mod.cnt%  = 0
 845: 0242:    sit.cnt%  = 0
 846: 0250:    eof%      = 0
 847: 025d: 
 848: 025d:    WHILE eof% = 0                                                    \
 849: 0268:      AND tlr.read% = 0                              ! Set in Init
 850: 0268: 
 851: 0268:       rc% = READ.POGDE
 852: 0278:       IF rc% <> 0 THEN BEGIN
 853: 0287:          eof% = 1
 854: 0297:       ENDIF ELSE BEGIN
 855: 029f: 
 856: 029f:          rectyp$ = UNPACK$(MID$(POGDE.RCD$,1,1))
 857: 02c9: 
 858: 02c9:          IF mod.cnt% <> 0 THEN BEGIN
 859: 02db:             IF LEFT$(rectyp$,1) = "0"                               \
 860: 0352:             OR LEFT$(rectyp$,1) = "9" THEN BEGIN
 861: 0352:                IF mod.cnt% <> SRPOG.MODULE.COUNT% THEN BEGIN
 862: 0367:                   srp10.event% = 7
 863: 0374:                   GOSUB LOG.EVENT
 864: 0386:                   GOSUB WRITE.POG.FINAL
 865: 0398:                ENDIF
 866: 03a0:                mod.cnt% = 0
 867: 03ad:             ENDIF
 868: 03b5:          ENDIF
 869: 03bd: 
 870: 03bd:          IF srmod.chg% > 0 THEN BEGIN
 871: 03cf:             IF LEFT$(rectyp$,1) <> "2" THEN BEGIN
 872: 0401:                srmod.chg% = 0
 873: 040e:                GOSUB WRITE.MODULE.FINAL
 874: 0422:             ENDIF ELSE IF item.cnt% <> 0                            \
 875: 045f:                       AND MOD(item.cnt%,                            \
 876: 045f:                               (SRMOD.MAX.ITEMS%)) = 0 THEN BEGIN
 877: 045f:                GOSUB WRITE.MODULE
 878: 0471:             ENDIF
 879: 0479:          ENDIF
 880: 0481: 
 881: 0481:          IF rectyp$ = "01" THEN BEGIN              ! POG Add
 882: 049c:             rec.cnt% = rec.cnt% +1
 883: 04b5:             GOSUB POG.ADD
 884: 04ca:          ENDIF ELSE IF rectyp$ = "02" THEN BEGIN   ! POG Delete
 885: 04e5:             rec.cnt% = rec.cnt% +1
 886: 04fe:             GOSUB POG.DEL
 887: 0513:          ENDIF ELSE IF rectyp$ = "03" THEN BEGIN   ! POG Change
 888: 052e:             rec.cnt% = rec.cnt% +1
 889: 0547:             GOSUB POG.ADD
 890: 055c:          ENDIF ELSE IF rectyp$ = "10" THEN BEGIN   ! Module Add
 891: 0577:             rec.cnt% = rec.cnt% +1
 892: 0590:             mod.cnt% = mod.cnt% +1
 893: 059c:             GOSUB MOD.ADD
 894: 05b1:          ENDIF ELSE IF rectyp$ = "21" THEN BEGIN   ! Shelf/Item Add
 895: 05cc:             rec.cnt% = rec.cnt% +1
 896: 05e5:             GOSUB ITEM.ADD
 897: 05f9:          ENDIF ELSE IF rectyp$ = "99" THEN BEGIN   ! Trailer Record
 898: 0614:             rec.cnt% = rec.cnt% +1
 899: 062d:             tlr.read% = 1
 900: 063a:             tlr.cnt% = GETN4(POGDE.RCD$,1)
 901: 0664:          ENDIF
 902: 066c: 
 903: 066c:       ENDIF
 904: 0674: 
 905: 0674:    WEND
 906: 069b: 
 907: 069b: RETURN
 908: 06ab: 
 909: 06ab: \********************************************************************
 910: 06ab: \***
 911: 06ab: \***    SUBROUTINE      :       POG.ADD
 912: 06ab: \***
 913: 06ab: \********************************************************************
 914: 06ab: \***
 915: 06ab: \***    Set SRPOG values from POGDE record
 916: 06ab: \***
 917: 06ab: \***    Write to SRPOG file
 918: 06ab: \***
 919: 06ab: \***    RETURN
 920: 06ab: \***
 921: 06ab: \********************************************************************
 922: 06ab: 
 923: 06ab: POG.ADD:
 924: 06bb: 
 925: 06bb: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
 926: 06bb: \* Set POGDB from delta file                                       *\
 927: 06bb: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
 928: 06bb: 
 929: 06bb:    SRPOG.POGDB%          = GETN4(POGDE.RCD$,  9    )
 930: 06e7: 
 931: 06e7: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
 932: 06e7: \* For POG change, read existing record and keep module count      *\
 933: 06e7: \*    (this will never be changed - delete POG and add POG used)   *\
 934: 06e7: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
 935: 06e7: 
 936: 06e7:    IF rectyp$ = "03" THEN BEGIN
 937: 0702:       rc% = READ.SRPOG
 938: 0712:       IF rc% <> 0 THEN BEGIN
 939: 0721:          SRPOG.MODULE.COUNT%   = GETN1(POGDE.RCD$,118    )
 940: 0745:       ENDIF
 941: 074f:    ENDIF ELSE BEGIN
 942: 0757:       SRPOG.MODULE.COUNT%   = GETN1(POGDE.RCD$,118    )
 943: 077b:    ENDIF
 944: 0783: 
 945: 0783: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
 946: 0783: \* Set remaining variables supplied in Delta file                  *\
 947: 0783: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
 948: 0783: 
 949: 0783:    SRPOG.POGID%          = GETN4(POGDE.RCD$,  1    )
 950: 07af:    SRPOG.ACT.DATE$       =  MID$(POGDE.RCD$,  6,  4)
 951: 07d6:    SRPOG.PLANNER.FAMILY$ =  MID$(POGDE.RCD$, 64, 30)
 952: 07fd:       ! (Truncated from 50 bytes)
 953: 07fd:    SRPOG.DEACT.DATE$     =  MID$(POGDE.RCD$,114,  4)
 954: 0824:    SRPOG.CAT1.ID%        = GETN4(POGDE.RCD$,119    )
 955: 0850:    SRPOG.CAT2.ID%        = GETN4(POGDE.RCD$,123    )
 956: 087c:    SRPOG.CAT3.ID%        = GETN4(POGDE.RCD$,127    )
 957: 08a8: 
 958: 08a8:    SRPDF.POGDB%          = SRPOG.POGDB%
 959: 08c1:    SRPDF.SHRT.DESC$      =  MID$(POGDE.RCD$, 14, 50)
 960: 08e8:    SRPDF.FULL.DESC$      =  MID$(POGDE.RCD$,132,100)
 961: 0910: 
 962: 0910: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
 963: 0910: \* Extract SRPOG.DESCRIPTION$ (30 bytes) from short decriptor      *\
 964: 0910: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
 965: 0910: 
 966: 0910:    SRPOG.DESCRIPTION$    = LEFT$(SRPDF.SHRT.DESC$, 30)
 967: 0937: 
 968: 0937: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
 969: 0937: \* Build SRPOG.CAT.DBKEY from category keys in Delta file          *\
 970: 0937: \* Set key level                                                   *\
 971: 0937: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
 972: 0937: 
 973: 0937:    IF SRPOG.CAT3.ID% <> 0 THEN BEGIN
 974: 0956:       SRPOG.KEY.LEVEL% = 3
 975: 0968:    ENDIF ELSE IF SRPOG.CAT2.ID% <> 0 THEN BEGIN
 976: 0987:       SRPOG.KEY.LEVEL% = 2
 977: 0999:    ENDIF ELSE BEGIN
 978: 09a1:       SRPOG.KEY.LEVEL% = 1
 979: 09b1:    ENDIF
 980: 09b9: 
 981: 09b9:    SRPOG.CAT.DBKEY% = GET.CATID%(SRPOG.CAT1.ID%,                    \
 982: 09f9:                                  SRPOG.CAT2.ID%,                    \
 983: 09f9:                                  SRPOG.CAT3.ID%)
 984: 09f9: 
 985: 09f9: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
 986: 09f9: \* Set repeat count values to default unset                        *\
 987: 09f9: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
 988: 09f9: 
 989: 09f9:    SRPOG.LIVE.RPT.CNT% = -1
 990: 0a09:    SRPOG.DATE.RPT.CNT$ = PACK$("00000000")
 991: 0a25:    SRPOG.PEND.RPT.CNT% = -1
 992: 0a35: 
 993: 0a35: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
 994: 0a35: \* Set filler                                                      *\
 995: 0a35: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
 996: 0a35: 
 997: 0a35:    SRPOG.FILLER$ = " "
 998: 0a4c:    SRPDF.FILLER$ = STRING$(15," ")
 999: 0a6a: 
1000: 0a6a: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1001: 0a6a: \* Write SRPOG record to file                                      *\
1002: 0a6a: \* Write SRPDF record to file                                      *\
1003: 0a6a: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1004: 0a6a: 
1005: 0a6a:    rc% = WRITE.SRPOG
1006: 0a7a:    IF rc% <> 0 THEN BEGIN
1007: 0a89:       GOSUB FILE.ERROR
1008: 0a9b:    ENDIF
1009: 0aa3:    rc% = WRITE.SRPDF
1010: 0ab3:    IF rc% <> 0 THEN BEGIN
1011: 0ac2:       GOSUB FILE.ERROR
1012: 0ad4:    ENDIF
1013: 0adc: 
1014: 0adc: RETURN
1015: 0aec: 
1016: 0aec: \********************************************************************
1017: 0aec: \***
1018: 0aec: \***    SUBROUTINE      :       POG.DEL
1019: 0aec: \***
1020: 0aec: \********************************************************************
1021: 0aec: \***
1022: 0aec: \***    Build SRPOG key from POGDE record
1023: 0aec: \***
1024: 0aec: \***    Read record from SRPOG file
1025: 0aec: \***
1026: 0aec: \***    Delete record from SRPOG file (Ignore not found errors)
1027: 0aec: \***
1028: 0aec: \***    Delete child records from SRMOD using key + module count
1029: 0aec: \***
1030: 0aec: \***    Delete notch details from SRSXF for the modules                 ! CRG
1031: 0aec: \***
1032: 0aec: \***    RETURN
1033: 0aec: \***
1034: 0aec: \********************************************************************
1035: 0aec: 
1036: 0aec: POG.DEL:
1037: 0afc: 
1038: 0afc:    SRPOG.POGID%        = GETN4(POGDE.RCD$, 1)                           ! CRG
1039: 0b28:    SRPOG.POGDB%        = GETN4(POGDE.RCD$, 5)                           ! CRG
1040: 0b54:    SRPOG.ACT.DATE$     = MID$(POGDE.RCD$,10, 4)                         ! CRG
1041: 0b7b:    SRPDF.POGDB%        = SRPOG.POGDB%                                   ! CRG
1042: 0b94:    SRSXF.POGDB%        = SRPOG.POGDB%                                   ! CRG
1043: 0bad:    SRMOD.POGDB%        = SRPOG.POGDB%                                   ! CRG
1044: 0bc6:    SRMOD.MODULE.SEQ%   = 0                                              ! CRG
1045: 0bd6:    SRMOD.RECORD.CHAIN% = 0                                              ! CRG
1046: 0be6:    ARRAY.COUNT%        = 0                                              ! CRG
1047: 0bf4:    CHAIN.COUNT%        = 0                                              ! CRG
1048: 0c01:    
1049: 0c01:   ! Module count will be changing from planner to planner but           ! CRG
1050: 0c01:   ! Iteration has to happen 127 times. In the past, it is noticed that  ! CRG
1051: 0c01:   ! Module sequence number are not always incremented in order, it      ! CRG
1052: 0c01:   ! will be random (1,4,7 etc.) So below count will make sure that      ! CRG
1053: 0c01:   ! deletion covers the entire module range.                            ! CRG
1054: 0c01:   
1055: 0c01:    SRMOD.COUNT.LIMIT%  = 127                                            ! CRG
1056: 0c0e:    
1057: 0c0e:    RC% = DELREC.SRPOG                                                   ! CRG
1058: 0c1e:    RC% = DELREC.SRPDF                                                   ! CRG
1059: 0c2e: 
1060: 0c2e:   ! Delete all the Module records and its chain records for this POG    ! CRG
1061: 0c2e:   ! from SRMOD file and delete the corresponding shelf records from     ! CRG
1062: 0c2e:   ! SRSXF file                                                          ! CRG
1063: 0c2e: 
1064: 0c2e:    WHILE SRMOD.MODULE.SEQ% >= 0 AND                      \              ! CRG
1065: 0c39:          SRMOD.MODULE.SEQ% <= SRMOD.COUNT.LIMIT%                        ! CRG
1066: 0c39: 
1067: 0c39:       !Read SRMOD File                                                  ! CRG
1068: 0c39:       RC% = READ.SRMOD                                                  ! CRG
1069: 0c49: 
1070: 0c49:       IF RC% = 0 THEN BEGIN                                             ! CRG
1071: 0c5b: 
1072: 0c5b:          !If module record is read successfully then, get its chain     ! CRG
1073: 0c5b:          !records count                                                 ! CRG
1074: 0c5b: 
1075: 0c5b:          IF SRMOD.ITEM.COUNT% > SRMOD.MAX.ITEMS% THEN BEGIN             ! CRG
1076: 0c73:             CHAIN.COUNT% = SRMOD.ITEM.COUNT% / SRMOD.MAX.ITEMS%         ! CRG
1077: 0c8d:          ENDIF                                                          ! CRG
1078: 0c95: 
1079: 0c95:          !Assign the current SRMOD module sequence to SRSXF module      ! CRG
1080: 0c95:          !sequence                                                      ! CRG
1081: 0c95: 
1082: 0c95:          SRSXF.MODULE.SEQ% = SRMOD.MODULE.SEQ%                          ! CRG
1083: 0cab: 
1084: 0cab:          WHILE SRMOD.RECORD.CHAIN% <= CHAIN.COUNT%                      ! CRG
1085: 0cb6: 
1086: 0cb6:             !Get the shelf numbers from SRSXF file for all module       ! CRG
1087: 0cb6:             !records and its chain records and delete them from         ! CRG
1088: 0cb6:             !SRSXF file                                                 ! CRG
1089: 0cb6: 
1090: 0cb6:             FOR ARRAY.COUNT% = 0 TO SRMOD.MAX.ITEMS% - 1                ! CRG
1091: 0cc6:                SRSXF.SHELF.NO% = SRMOD.SHELF.NUM%(ARRAY.COUNT%)         ! CRG
1092: 0cea:                !Ignore delete errors                                    ! CRG
1093: 0cea:                RC% = DELREC.SRSXF                                       ! CRG
1094: 0cfa:             NEXT ARRAY.COUNT%                                           ! CRG
1095: 0d17: 
1096: 0d17:     ! Delete errors will be ignored as iteration happens for 127 times  ! CRG
1097: 0d17:     ! even if the module sequence numbers are less. This is done to     ! CRG
1098: 0d17:     ! avoid dumping of the event log with error message                 ! CRG
1099: 0d17: 
1100: 0d17:             RC% = DELREC.SRMOD                                          ! CRG
1101: 0d27: 
1102: 0d27:             !Increment the chain number to read the next chain record   ! CRG
1103: 0d27:             !or to exit from the while loop                             ! CRG
1104: 0d27:             SRMOD.RECORD.CHAIN% = SRMOD.RECORD.CHAIN% + 1               ! CRG
1105: 0d36: 
1106: 0d36:             !Read and delete the chain records if any                   ! CRG
1107: 0d36:             RC% = 1                                                     ! CRG
1108: 0d44: 
1109: 0d44:             WHILE (RC% = 1) AND (SRMOD.RECORD.CHAIN% <= CHAIN.COUNT%)   ! CRG
1110: 0d4e:                RC% = READ.SRMOD                                         ! CRG
1111: 0d5e:                IF RC% THEN BEGIN                                        ! CRG
1112: 0d6e:                   SRMOD.RECORD.CHAIN% = SRMOD.RECORD.CHAIN% + 1         ! CRG
1113: 0d7d:                ENDIF                                                    ! CRG
1114: 0d85:             WEND                                                        ! CRG
1115: 0dae: 
1116: 0dae:          WEND                                                           ! CRG
1117: 0dc6: 
1118: 0dc6:       ENDIF                                                             ! CRG
1119: 0dce: 
1120: 0dce:       !Increment SRMOD module sequence to check for the next available  ! CRG
1121: 0dce:       !module sequence in the SRMOD file                                ! CRG
1122: 0dce:       SRMOD.MODULE.SEQ% = SRMOD.MODULE.SEQ% + 1                         ! CRG
1123: 0ddd: 
1124: 0ddd:       !Reset the chain numbers and chain count for next module record   ! CRG
1125: 0ddd:       SRMOD.RECORD.CHAIN% = 0                                           ! CRG
1126: 0ded:       CHAIN.COUNT% = 0                                                  ! CRG
1127: 0dfa:    WEND                                                                 ! CRG
1128: 0e29: 
1129: 0e29:    ! Below original subroutine will be commented out as current logic   ! CRG
1130: 0e29:    ! does not delete records from SRSXF file. Deletion engine is        ! CRG
1131: 0e29:    ! outdated ,it leaves behind many records untouched, and over time   ! CRG
1132: 0e29:    ! it piles up in the file and POGOK suite fails                      ! CRG
1133: 0e29: 
1134: 0e29: 
1135: 0e29:     
1136: 0e29: 
1137: 0e29:    ! rc% = READ.SRPOG                                                   ! CRG
1138: 0e29:    ! IF rc% = 0 THEN BEGIN                                              ! CRG
1139: 0e29:    !   rc% = DELREC.SRPOG                                               ! CRG
1140: 0e29:    !   SRMOD.POGDB% = SRPOG.POGDB%                                      ! CRG
1141: 0e29:    !   SRMOD.MODULE.SEQ% = 0                                            ! CRG
1142: 0e29:    !   SRMOD.RECORD.CHAIN% = 0                                          ! CRG
1143: 0e29:    !   WHILE SRMOD.MODULE.SEQ% <= SRPOG.MODULE.COUNT%                   ! CRG
1144: 0e29:    !      rc% = READ.SRMOD                                              ! CRG
1145: 0e29:    !      rc% = DELREC.SRMOD                                            ! CRG
1146: 0e29:    !      WHILE SRMOD.ITEM.COUNT% > 50                                  ! CRG
1147: 0e29:    !         SRMOD.RECORD.CHAIN% = SRMOD.RECORD.CHAIN% +1               ! CRG
1148: 0e29:    !         SRMOD.ITEM.COUNT% = SRMOD.ITEM.COUNT% -50                  ! CRG
1149: 0e29:    !         rc% = DELREC.SRMOD                                         ! CRG
1150: 0e29:    !      WEND                                                          ! CRG
1151: 0e29:    !      SRMOD.MODULE.SEQ% = SRMOD.MODULE.SEQ% +1                      ! CRG
1152: 0e29:    !      SRMOD.RECORD.CHAIN% = 0                                       ! CRG
1153: 0e29:    !   WEND                                                             ! CRG
1154: 0e29:    ! ENDIF                                                              ! CRG
1155: 0e29:    ! rc% = READ.SRPDF                                                   ! CRG
1156: 0e29:    ! IF rc% = 0 THEN BEGIN                                              ! CRG
1157: 0e29:    !    rc% = DELREC.SRPDF                                              ! CRG
1158: 0e29:    ! ENDIF                                                              ! CRG
1159: 0e29: 
1160: 0e29: RETURN
1161: 0e39: 
1162: 0e39: \********************************************************************
1163: 0e39: \***
1164: 0e39: \***    SUBROUTINE      :       MOD.ADD
1165: 0e39: \***
1166: 0e39: \********************************************************************
1167: 0e39: \***
1168: 0e39: \***    Set SRMOD values from POGDE record
1169: 0e39: \***
1170: 0e39: \***    Write to SRMOD file
1171: 0e39: \***
1172: 0e39: \***    RETURN
1173: 0e39: \***
1174: 0e39: \********************************************************************
1175: 0e39: 
1176: 0e39: MOD.ADD:
1177: 0e49: 
1178: 0e49:    srmod.chg%  =  1
1179: 0e56:    item.cnt%   =  0
1180: 0e64:    shelf.cnt%  =  0
1181: 0e72:    last.shelf% = -1
1182: 0e7f: 
1183: 0e7f:    SRMOD.POGDB%           = GETN4(POGDE.RCD$, 5)
1184: 0eab:    SRMOD.MODULE.SEQ%      = GETN1(POGDE.RCD$,13)
1185: 0ecf:    SRMOD.RECORD.CHAIN%    = 0
1186: 0edf:    SRMOD.DESCRIPTOR$      = MID$ (POGDE.RCD$,15,30)
1187: 0f06:    FOR it.ptr% = 0 TO (SRMOD.MAX.ITEMS% -1)
1188: 0f17:       SRMOD.SHELF.NUM%(it.ptr%) = 0
1189: 0f35:       SRMOD.FACINGS%(it.ptr%)   = 0
1190: 0f53:       SRMOD.ITEM.CODE$(it.ptr%) = STRING$(3,CHR$(0))
1191: 0f82:       SRMOD.MDQ%(it.ptr%)       = 0
1192: 0fa1:       SRMOD.PSC%(it.ptr%)       = 0
1193: 0fc0:    NEXT it.ptr%
1194: 0fe0:    it.ptr% = 0
1195: 0fee:    SRMOD.SHELF.COUNT%     = GETN2(POGDE.RCD$,44)
1196: 1012:    SRMOD.ITEM.COUNT%      = 0
1197: 1023:    SRMOD.FILLER$          = STRING$(18," ")
1198: 1041: 
1199: 1041:    IF SRPOG.POGID% <> GETN4(POGDE.RCD$,1) THEN BEGIN
1200: 107b:       srp10.event% = 6
1201: 1088:       GOSUB LOG.EVENT
1202: 109a:    ENDIF
1203: 10a2: 
1204: 10a2: RETURN
1205: 10b2: 
1206: 10b2: \********************************************************************
1207: 10b2: \***
1208: 10b2: \***    SUBROUTINE      :       ITEM.ADD
1209: 10b2: \***
1210: 10b2: \********************************************************************
1211: 10b2: \***
1212: 10b2: \***    Set SRMOD values from POGDE record
1213: 10b2: \***
1214: 10b2: \***    Write to SRMOD file
1215: 10b2: \***
1216: 10b2: \***    RETURN
1217: 10b2: \***
1218: 10b2: \********************************************************************
1219: 10b2: 
1220: 10b2: ITEM.ADD:
1221: 10c2: 
1222: 10c2:    IF last.shelf% <> GETN1(POGDE.RCD$,12)                           \
1223: 1121:    OR last.notch% <> GETN1(POGDE.RCD$, 1) THEN BEGIN
1224: 1121:       shelf.cnt%        = shelf.cnt% +1
1225: 112d:       last.shelf%       = GETN1(POGDE.RCD$,12)
1226: 114d:       last.notch%       = GETN1(POGDE.RCD$, 1)
1227: 116d:       SRSXF.POGDB%      = SRMOD.POGDB%
1228: 1186:       SRSXF.MODULE.SEQ% = SRMOD.MODULE.SEQ%
1229: 119c:       SRSXF.SHELF.NO%   = GETN1(POGDE.RCD$,12)
1230: 11c0:       SRSXF.NOTCH.NO%   = GETN1(POGDE.RCD$, 1)
1231: 11e4:       SRSXF.SHELF.KEY%  = GETN4(POGDE.RCD$,13)
1232: 1210:       SRSXF.SHELF.DESC$ = STRING$(50,CHR$(0))
1233: 1231:       SRSXF.FILLER$     = "  "
1234: 1248:       rc% = WRITE.SRSXF
1235: 1258:       IF rc% <> 0 THEN BEGIN
1236: 1267:          GOSUB FILE.ERROR
1237: 1279:       ENDIF
1238: 1281:    ENDIF
1239: 1289: 
1240: 1289:    SRMOD.FACINGS%(it.ptr%)   = GETN1(POGDE.RCD$, 2)
1241: 12c1:    SRMOD.ITEM.CODE$(it.ptr%) = MID$ (POGDE.RCD$, 6, 3)
1242: 12f6:    SRMOD.MDQ%(it.ptr%)       = GETN2(POGDE.RCD$, 8)
1243: 132e:    SRMOD.PSC%(it.ptr%)       = GETN2(POGDE.RCD$,10)
1244: 1366:    SRMOD.SHELF.NUM%(it.ptr%) = GETN1(POGDE.RCD$,12)
1245: 139e:    it.ptr%  = it.ptr% +1
1246: 13aa: 
1247: 13aa: \  shelf.item.seq%   = GETN2(POGDE.RCD$, 3)      ! not used ?
1248: 13aa:    item.cnt%         = item.cnt% +1
1249: 13b6:    SRMOD.ITEM.COUNT% = item.cnt%
1250: 13c8: 
1251: 13c8: RETURN
1252: 13d8: 
1253: 13d8: \********************************************************************
1254: 13d8: \***
1255: 13d8: \***    SUBROUTINE      :       WRITE.MODULE
1256: 13d8: \***
1257: 13d8: \********************************************************************
1258: 13d8: \***
1259: 13d8: \***    Write to SRMOD file
1260: 13d8: \***
1261: 13d8: \***    Increment CHAIN sequence ready for possible next write
1262: 13d8: \***
1263: 13d8: \***    RETURN
1264: 13d8: \***
1265: 13d8: \********************************************************************
1266: 13d8: 
1267: 13d8: WRITE.MODULE:
1268: 13e8: 
1269: 13e8:    rc% = WRITE.SRMOD
1270: 13f8:    IF rc% <> 0 THEN BEGIN
1271: 1407:       GOSUB FILE.ERROR
1272: 1419:    ENDIF
1273: 1421: 
1274: 1421:    FOR it.ptr% = 0 TO (SRMOD.MAX.ITEMS% -1)
1275: 1432:       SRMOD.SHELF.NUM%(it.ptr%) = 0
1276: 1450:       SRMOD.FACINGS%(it.ptr%)   = 0
1277: 146e:       SRMOD.ITEM.CODE$(it.ptr%) = STRING$(3,CHR$(0))
1278: 149d:       SRMOD.MDQ%(it.ptr%)       = 0
1279: 14bc:       SRMOD.PSC%(it.ptr%)       = 0
1280: 14db:    NEXT it.ptr%
1281: 14fb:    it.ptr% = 0
1282: 1509: 
1283: 1509:    SRMOD.RECORD.CHAIN%    = SRMOD.RECORD.CHAIN% +1
1284: 1518: 
1285: 1518: RETURN
1286: 1528: 
1287: 1528: \********************************************************************
1288: 1528: \***
1289: 1528: \***    SUBROUTINE      :       WRITE.MODULE.FINAL
1290: 1528: \***
1291: 1528: \********************************************************************
1292: 1528: \***
1293: 1528: \***    Write to SRMOD file
1294: 1528: \***
1295: 1528: \***    Update previous records in chain with item count
1296: 1528: \***
1297: 1528: \***    RETURN
1298: 1528: \***
1299: 1528: \********************************************************************
1300: 1528: 
1301: 1528: WRITE.MODULE.FINAL:
1302: 1538: 
1303: 1538: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1304: 1538: \* Shelf count not set by host insert computed count               *\
1305: 1538: \* This is the count of shelves and/or notch changes within a shelf*\
1306: 1538: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1307: 1538: 
1308: 1538:    SRMOD.SHELF.COUNT% = shelf.cnt%
1309: 154a: 
1310: 154a: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1311: 154a: \* Write any outstanding items to file                             *\
1312: 154a: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1313: 154a: 
1314: 154a:    IF it.ptr% > 0 THEN BEGIN
1315: 1559:       GOSUB WRITE.MODULE
1316: 156b:    ENDIF
1317: 1573: 
1318: 1573: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1319: 1573: \* Decrement the chain pointer by 2 to point to last but 1 write   *\
1320: 1573: \*    as the last write would have had the correct item count      *\
1321: 1573: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1322: 1573: 
1323: 1573:    SRMOD.RECORD.CHAIN% = SRMOD.RECORD.CHAIN% -2
1324: 1583: 
1325: 1583: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1326: 1583: \* For each record back to the first, update the item count field  *\
1327: 1583: \* and the shelf count field.                                      *\
1328: 1583: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1329: 1583: 
1330: 1583:    WHILE SRMOD.RECORD.CHAIN% >= 0
1331: 158e:       rc% = READ.SRMOD
1332: 159e:       IF rc% <> 0 THEN BEGIN
1333: 15ad:          GOSUB FILE.ERROR
1334: 15bf:       ENDIF
1335: 15c7:       SRMOD.ITEM.COUNT% = item.cnt%
1336: 15d9:       SRMOD.SHELF.COUNT% = shelf.cnt%
1337: 15eb:       rc% = WRITE.SRMOD
1338: 15fb:       IF rc% <> 0 THEN BEGIN
1339: 160a:          GOSUB FILE.ERROR
1340: 161c:       ENDIF
1341: 1624:       SRMOD.RECORD.CHAIN% = SRMOD.RECORD.CHAIN% -1
1342: 1633:    WEND
1343: 1648: 
1344: 1648: RETURN
1345: 1658: 
1346: 1658: \********************************************************************
1347: 1658: \***
1348: 1658: \***    SUBROUTINE      :       WRITE.POG.FINAL
1349: 1658: \***
1350: 1658: \********************************************************************
1351: 1658: \***
1352: 1658: \***    Write to SRPOG file updating module count
1353: 1658: \***
1354: 1658: \***    RETURN
1355: 1658: \***
1356: 1658: \********************************************************************
1357: 1658: 
1358: 1658: WRITE.POG.FINAL:
1359: 1668: 
1360: 1668:    rc% = READ.SRPOG
1361: 1678:    IF rc% <> 0 THEN BEGIN
1362: 1687:       GOSUB FILE.ERROR
1363: 1699:    ENDIF
1364: 16a1:    SRPOG.MODULE.COUNT% = mod.cnt%
1365: 16b3:    rc% = WRITE.SRPOG
1366: 16c3:    IF rc% <> 0 THEN BEGIN
1367: 16d2:       GOSUB FILE.ERROR
1368: 16e4:    ENDIF
1369: 16ec: 
1370: 16ec: RETURN
1371: 16fc: 
1372: 16fc: \********************************************************************
1373: 16fc: \***
1374: 16fc: \***    SUBROUTINE      :       INITIALISATION
1375: 16fc: \***
1376: 16fc: \********************************************************************
1377: 16fc: \***
1378: 16fc: \***    Initialise main program variables
1379: 16fc: \***
1380: 16fc: \***    Allocate session numbers to files
1381: 16fc: \***
1382: 16fc: \***    OPEN required files
1383: 16fc: \***
1384: 16fc: \***    SET program started flag
1385: 16fc: \***
1386: 16fc: \***    Check run is valid
1387: 16fc: \***
1388: 16fc: \***    RETURN
1389: 16fc: \***
1390: 16fc: \********************************************************************
1391: 16fc: 
1392: 16fc: INITIALISATION:
1393: 170c: 
1394: 170c: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1395: 170c: \* Set program variables                                           *\
1396: 170c: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1397: 170c: 
1398: 170c:    bg%           = 0
1399: 1719:    init.fail%    = 0
1400: 1726:    rec.cnt%      = 0
1401: 173b:    srmod.chg%    = 0
1402: 1748:    srp10.error%  = 0
1403: 1755:    srp10.event%  = 0
1404: 1762:    tlr.cnt%      = 0
1405: 1777:    tlr.read%     = 0
1406: 1784:    comm.tail$    = COMMAND$
1407: 179a: 
1408: 179a:    IF LEFT$(comm.tail$, 8) = "BACKGRND" THEN BEGIN
1409: 17cc:       bg% = 1
1410: 17d9:       comm.tail$ = MID$(comm.tail$,10,LEN(comm.tail$) -9)
1411: 180b:    ENDIF
1412: 1813: 
1413: 1813: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1414: 1813: \* Set todays date YYYYMMDD                                        *\
1415: 1813: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1416: 1813: 
1417: 1813:    rundate$ = PACK$("20"+DATE$)
1418: 183a: 
1419: 183a: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1420: 183a: \* Allocate Session Numbers and Open Files                         *\
1421: 183a: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1422: 183a: 
1423: 183a:    GOSUB ALLOCATE.SESS.NUMS
1424: 184c: 
1425: 184c:    GOSUB OPEN.FILES
1426: 185e: 
1427: 185e: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1428: 185e: \* Set POGOK run flag                                              *\
1429: 185e: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1430: 185e: 
1431: 185e:    no.read% = 0
1432: 186b: retry1:
1433: 187b:    rc% = READ.POGOK.LOCK
1434: 188b:    IF rc% <> 0 THEN BEGIN
1435: 189a:       GOSUB FILE.ERROR
1436: 18ac:       IF no.read% > 0 THEN GOTO retry1
1437: 18bd:    ENDIF
1438: 18c5: 
1439: 18c5:    run.suite% = 2
1440: 18d2:    IF LEFT$(comm.tail$, 7) = "SLEEPER" THEN BEGIN
1441: 1907:       IF POGOK.PE10.RUNDATE$ = rundate$                             \
1442: 195d:      AND POGOK.PE10.RUNFLAG$ <> "X" THEN BEGIN
1443: 195d:          run.suite% = run.suite% -1
1444: 196b:       ENDIF ELSE BEGIN
1445: 1973:          POGOK.PE10.RUNFLAG$ = "S"
1446: 198a:       ENDIF
1447: 1992:       IF POGOK.PE5.RUNDATE$ = rundate$                              \
1448: 19e8:      AND POGOK.PE5.RUNFLAG$ <> "X" THEN BEGIN
1449: 19e8:          run.suite% = run.suite% -1
1450: 19f6:       ENDIF ELSE BEGIN
1451: 19fe:          GOSUB START.SRP5
1452: 1a10:       ENDIF
1453: 1a1a:    ENDIF ELSE BEGIN
1454: 1a22:       POGOK.PE10.RUNFLAG$ = "S"
1455: 1a39:       GOSUB START.SRP5
1456: 1a4b:    ENDIF
1457: 1a53: 
1458: 1a53:    rc% = WRITE.POGOK.UNLOCK
1459: 1a63:    IF rc% <> 0 THEN BEGIN
1460: 1a72:       GOSUB FILE.ERROR
1461: 1a84:    ENDIF
1462: 1a8c: 
1463: 1a8c:    IF NOT run.suite% THEN BEGIN
1464: 1a9b:       init.fail% = -1
1465: 1aa8:       RETURN
1466: 1ab8:    ENDIF
1467: 1ac0: 
1468: 1ac0: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1469: 1ac0: \* Read input file header record                                   *\
1470: 1ac0: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1471: 1ac0: 
1472: 1ac0:    IF NOT no.inp.file% THEN BEGIN
1473: 1acf:       rc% = READ.POGDE
1474: 1adf:       IF rc% <> 0 THEN BEGIN
1475: 1aee:          GOSUB FILE.ERROR
1476: 1b00:       ENDIF
1477: 1b08:    ENDIF
1478: 1b10: 
1479: 1b10: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1480: 1b10: \* Check for header record                                         *\
1481: 1b10: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1482: 1b10: 
1483: 1b10:    IF (NOT no.inp.file%)                                            \
1484: 1b6c:   AND (UNPACK$(MID$(POGDE.RCD$,1,1)) = "00") THEN BEGIN
1485: 1b6c:       rec.cnt% = rec.cnt% +1
1486: 1b85:       POGDE.SER.NO% = GETN4(POGDE.RCD$,1)
1487: 1baf:       POGDE.DATE$   = MID$(POGDE.RCD$,6,4)
1488: 1bd4:       POGDE.DTR%    = GETN2(POGDE.RCD$,9)
1489: 1bf4: 
1490: 1bf4: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1491: 1bf4: \* NOT rerun AND serial number and date are equal - Duplicate      *\
1492: 1bf4: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1493: 1bf4: 
1494: 1bf4:       IF LEFT$(comm.tail$, 5) <> "RERUN"                            \
1495: 1c6e:      AND LEFT$(comm.tail$, 7) <> "SLEEPER" THEN BEGIN               !
1496: 1c6e:          IF VAL(POGOK.SRD.SER.NO$) = POGDE.SER.NO%                  \
1497: 1cdd:         AND POGOK.SRD.DATE$ = POGDE.DATE$ THEN BEGIN
1498: 1cdd: 
1499: 1cdd:             ! Log event for duplicate
1500: 1cdd:             srp10.event% = 2
1501: 1cea:             GOSUB LOG.EVENT
1502: 1cfc: 
1503: 1cfc:             srp10.error% = srp10.error% OR 08H
1504: 1d0c: 
1505: 1d0c:             init.fail% = 1
1506: 1d19: 
1507: 1d19:             RETURN
1508: 1d29: 
1509: 1d29:          ENDIF
1510: 1d31:       ENDIF
1511: 1d39: 
1512: 1d39: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1513: 1d39: \* serial number or date < reset file - Old data                   *\
1514: 1d39: \*    (allow for serial number rollover @ 9999)                    *\
1515: 1d39: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1516: 1d39: 
1517: 1d39:       rc% = VAL(POGOK.SRD.SER.NO$)
1518: 1d56:       IF rc% = 9999 THEN rc% = 0
1519: 1d6c: 
1520: 1d6c:       IF rc% > GETN4(POGDE.RCD$,1)                                  \
1521: 1dde:       OR POGOK.SRD.DATE$ > MID$(POGDE.RCD$,6,4) THEN BEGIN
1522: 1dde: 
1523: 1dde:          srp10.event% = 3
1524: 1deb:          GOSUB LOG.EVENT
1525: 1dfd: 
1526: 1dfd:          srp10.error% = srp10.error% OR 04H
1527: 1e0d: 
1528: 1e0d:          init.fail% = 1
1529: 1e1a: 
1530: 1e1a:          RETURN
1531: 1e2a: 
1532: 1e2a:       ENDIF
1533: 1e32: 
1534: 1e32: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1535: 1e32: \* Initial load                                                    *\
1536: 1e32: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1537: 1e32: 
1538: 1e32:       IF MID$(POGDE.RCD$,12,1) = "I" THEN BEGIN
1539: 1e6a: 
1540: 1e6a:          init.load% = 1
1541: 1e77: 
1542: 1e77:          IF NOT no.pog.file% THEN BEGIN
1543: 1e89:             CLOSE SRPOG.SESS.NUM%
1544: 1e9d:             IF END #SRPOG.SESS.NUM% THEN NO.SRPOG.COPY
1545: 1eb9:             OPEN SRPOG.COPY.NAME$ AS SRPOG.SESS.NUM%
1546: 1ee0:             DELETE SRPOG.SESS.NUM%
1547: 1ef4: NO.SRPOG.COPY:
1548: 1f04:             rc% = RENAME(SRPOG.COPY.NAME$,SRPOG.FILE.NAME$)
1549: 1f2a:          ENDIF
1550: 1f32:          IF NOT no.mod.file% THEN BEGIN
1551: 1f44:             CLOSE SRMOD.SESS.NUM%
1552: 1f58:             IF END #SRMOD.SESS.NUM% THEN NO.SRMOD.COPY
1553: 1f74:             OPEN SRMOD.COPY.NAME$ AS SRMOD.SESS.NUM%
1554: 1f9b:             DELETE SRMOD.SESS.NUM%
1555: 1faf: NO.SRMOD.COPY:
1556: 1fbf:             rc% = RENAME(SRMOD.COPY.NAME$,SRMOD.FILE.NAME$)
1557: 1fe5:          ENDIF
1558: 1fed: 
1559: 1fed:          GOSUB CREATE.SRPOG
1560: 1fff:          GOSUB CREATE.SRMOD
1561: 2014: 
1562: 2014: 
1563: 2014:       ENDIF ELSE IF MID$(POGDE.RCD$,12,1) = "D" THEN BEGIN
1564: 204c: 
1565: 204c: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1566: 204c: \* delta file and no existing                                      *\
1567: 204c: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1568: 204c: 
1569: 204c:          IF no.pog.file% OR no.mod.file% THEN BEGIN
1570: 2060: 
1571: 2060:             srp10.event% = 5
1572: 206d:             GOSUB LOG.EVENT
1573: 207f: 
1574: 207f:             srp10.error% = srp10.error% OR 10H
1575: 208f: 
1576: 208f:             IF NOT no.pog.file% THEN BEGIN
1577: 209e:                DELETE SRPOG.SESS.NUM%
1578: 20b2:             ENDIF
1579: 20ba:             IF NOT no.mod.file% THEN BEGIN
1580: 20c9:                DELETE SRMOD.SESS.NUM%
1581: 20dd:             ENDIF
1582: 20e5: 
1583: 20e5:             GOSUB CREATE.SRPOG
1584: 20f7:             GOSUB CREATE.SRMOD
1585: 2109: 
1586: 2109:          ENDIF
1587: 2111: 
1588: 2111:       ENDIF
1589: 211c: 
1590: 211c:    ENDIF ELSE BEGIN
1591: 2124: 
1592: 2124: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1593: 2124: \* No header record or No input file                               *\
1594: 2124: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1595: 2124: 
1596: 2124:       srp10.event% = 1
1597: 2131:       GOSUB LOG.EVENT
1598: 2143: 
1599: 2143:       srp10.error% = srp10.error% OR 20H
1600: 2153:       init.fail% = 1
1601: 2160: 
1602: 2160:       IF no.pog.file% OR no.mod.file% THEN BEGIN
1603: 2174: 
1604: 2174:          IF NOT no.pog.file% THEN BEGIN
1605: 2183:             DELETE SRPOG.SESS.NUM%
1606: 2197:          ENDIF
1607: 219f:          IF NOT no.mod.file% THEN BEGIN
1608: 21ae:             DELETE SRMOD.SESS.NUM%
1609: 21c2:          ENDIF
1610: 21ca: 
1611: 21ca:          GOSUB CREATE.SRPOG
1612: 21dc:          GOSUB CREATE.SRMOD
1613: 21ee: 
1614: 21ee:       ENDIF
1615: 21f6: 
1616: 21f6:    ENDIF
1617: 21fe: 
1618: 21fe: RETURN
1619: 220e: 
1620: 220e: \********************************************************************
1621: 220e: \***
1622: 220e: \***    SUBROUTINE      :       ALLOCATE.SESS.NUMS
1623: 220e: \***
1624: 220e: \********************************************************************
1625: 220e: \***
1626: 220e: \***    Allocate all session numbers
1627: 220e: \***
1628: 220e: \********************************************************************
1629: 220e: 
1630: 220e: ALLOCATE.SESS.NUMS:
1631: 221e: 
1632: 221e:     SB.ACTION$ = "O"
1633: 2235: 
1634: 2235:     SB.INTEGER% = POGDE.REPORT.NUM%
1635: 224b:     SB.STRING$  = POGDE.FILE.NAME$
1636: 2269:     GOSUB SB.FILE.UTILS
1637: 227b:     POGDE.SESS.NUM% = SB.FILE.SESS.NUM%
1638: 2291: 
1639: 2291:     SB.INTEGER% = POGOK.REPORT.NUM%
1640: 22a7:     SB.STRING$  = POGOK.FILE.NAME$
1641: 22c5:     GOSUB SB.FILE.UTILS
1642: 22d7:     POGOK.SESS.NUM% = SB.FILE.SESS.NUM%
1643: 22ed: 
1644: 22ed:     SB.INTEGER% = SRPOG.REPORT.NUM%
1645: 2303:     SB.STRING$  = SRPOG.FILE.NAME$
1646: 2321:     GOSUB SB.FILE.UTILS
1647: 2333:     SRPOG.SESS.NUM% = SB.FILE.SESS.NUM%
1648: 2349: 
1649: 2349:     SB.INTEGER% = SRMOD.REPORT.NUM%
1650: 235f:     SB.STRING$  = SRMOD.FILE.NAME$
1651: 237d:     GOSUB SB.FILE.UTILS
1652: 238f:     SRMOD.SESS.NUM% = SB.FILE.SESS.NUM%
1653: 23a5: 
1654: 23a5:     SB.INTEGER% = SRPDF.REPORT.NUM%
1655: 23bb:     SB.STRING$  = SRPDF.FILE.NAME$
1656: 23d9:     GOSUB SB.FILE.UTILS
1657: 23eb:     SRPDF.SESS.NUM% = SB.FILE.SESS.NUM%
1658: 2401: 
1659: 2401:     SB.INTEGER% = SRSXF.REPORT.NUM%
1660: 2417:     SB.STRING$  = SRSXF.FILE.NAME$
1661: 2435:     GOSUB SB.FILE.UTILS
1662: 2447:     SRSXF.SESS.NUM% = SB.FILE.SESS.NUM%
1663: 245d: 
1664: 245d: RETURN
1665: 246d: 
1666: 246d: \********************************************************************
1667: 246d: \***
1668: 246d: \***    SUBROUTINE      :       OPEN.FILES
1669: 246d: \***
1670: 246d: \********************************************************************
1671: 246d: \***
1672: 246d: \***    Open required files
1673: 246d: \***
1674: 246d: \********************************************************************
1675: 246d: 
1676: 246d: OPEN.FILES:
1677: 247d: 
1678: 247d:    CALL POGDE.SET
1679: 2498:    CALL POGOK.SET
1680: 24b3:    CALL SRPDF.SET
1681: 24ce:    CALL SRPOG.SET
1682: 24e9:    CALL SRMOD.SET
1683: 2504:    CALL SRSXF.SET
1684: 251f: 
1685: 251f:    FILE.OPERATION$ = "O"
1686: 2536: 
1687: 2536:    no.inp.file% = 1
1688: 2543:    CURRENT.REPORT.NUM% = POGDE.REPORT.NUM%
1689: 2559:    IF END # POGDE.SESS.NUM% THEN pogde.open.err
1690: 2575:    rc4% = SIZE(POGDE.FILE.NAME$)
1691: 259a:    rc%  = MOD(rc4%, 1024)
1692: 25b2:    IF rc% <> 0 THEN BEGIN
1693: 25c4:       mess$ = STRING$(1024 -rc%, " ")
1694: 25e6:       work$ = "C" + STR$(LEN(mess$))
1695: 2619:       OPEN POGDE.FILE.NAME$ AS POGDE.SESS.NUM% APPEND
1696: 2640:       WRITE FORM work$; #POGDE.SESS.NUM%; mess$
1697: 266b:       CLOSE POGDE.SESS.NUM%
1698: 267f:    ENDIF
1699: 2687: 
1700: 2687:    OPEN POGDE.FILE.NAME$ DIRECT RECL 1024 AS POGDE.SESS.NUM%        \
1701: 26b0:         NOWRITE NODEL
1702: 26b0:    no.inp.file% = 0
1703: 26bd: pogde.open.err:
1704: 26cd: 
1705: 26cd:    no.file% = 1
1706: 26da:    CURRENT.REPORT.NUM% = POGOK.REPORT.NUM%
1707: 26f0:    IF END # POGOK.SESS.NUM% THEN pogok.open.err
1708: 270c:    OPEN POGOK.FILE.NAME$ DIRECT RECL POGOK.RECL% AS POGOK.SESS.NUM% \
1709: 2739:          NODEL
1710: 2739:    no.file% = 0
1711: 2746: pogok.open.err:
1712: 2756:    IF no.file% = 1 THEN BEGIN
1713: 2765:       rc% = CREATE.POGOK
1714: 2775:       IF rc% <> 0 THEN BEGIN
1715: 2784:          GOSUB CREATE.ERROR
1716: 2796:       ENDIF
1717: 279e:    ENDIF
1718: 27a6: 
1719: 27a6:    no.pog.file% = 1
1720: 27b3:    CURRENT.REPORT.NUM% = SRPOG.REPORT.NUM%
1721: 27c9:    IF END # SRPOG.SESS.NUM% THEN srpog.open.err
1722: 27e5:    OPEN SRPOG.FILE.NAME$ KEYED RECL SRPOG.RECL% AS SRPOG.SESS.NUM%
1723: 2811:    no.pog.file% = 0
1724: 281e: srpog.open.err:
1725: 282e: 
1726: 282e:    no.mod.file% = 1
1727: 283b:    CURRENT.REPORT.NUM% = SRMOD.REPORT.NUM%
1728: 2851:    IF END # SRMOD.SESS.NUM% THEN srmod.open.err
1729: 286d:    OPEN SRMOD.FILE.NAME$ KEYED RECL SRMOD.RECL% AS SRMOD.SESS.NUM%
1730: 2899:    no.mod.file% = 0
1731: 28a6: srmod.open.err:
1732: 28b6: 
1733: 28b6:    no.file% = 1
1734: 28c3:    CURRENT.REPORT.NUM% = SRPDF.REPORT.NUM%
1735: 28d9:    IF END # SRPDF.SESS.NUM% THEN srpdf.open.err
1736: 28f5:    OPEN SRPDF.FILE.NAME$ KEYED RECL SRPDF.RECL% AS SRPDF.SESS.NUM%
1737: 2921:    no.file% = 0
1738: 292e: srpdf.open.err:
1739: 293e:    IF no.file% = 1 THEN BEGIN
1740: 294d:       no.file% = 0
1741: 295a:       IF NOT no.inp.file% THEN BEGIN
1742: 2969:          FILE.OPERATION$ = "C"
1743: 2980:    ! Planner refresh from inctactix has been increased over time so     ! CRG 
1744: 2980:    ! doubling the file capacity to double of its current size           ! CRG
1745: 2980:    
1746: 2980:    !      CREATE POSFILE SRPDF.FILE.NAME$ KEYED 4,,,3000                \ CRG
1747: 2980:           CREATE POSFILE SRPDF.FILE.NAME$ KEYED 4,,,6000                \ CRG
1748: 2980:                 RECL SRPDF.RECL% AS SRPDF.SESS.NUM% MIRRORED ATCLOSE
1749: 2980:       ENDIF
1750: 2988:    ENDIF
1751: 2990: 
1752: 2990:    no.file% = 1
1753: 299d:    CURRENT.REPORT.NUM% = SRSXF.REPORT.NUM%
1754: 29b3:    IF END # SRSXF.SESS.NUM% THEN srsxf.open.err
1755: 29cf:    OPEN SRSXF.FILE.NAME$ KEYED RECL SRSXF.RECL% AS SRSXF.SESS.NUM%
1756: 29fb:    no.file% = 0
1757: 2a08: srsxf.open.err:
1758: 2a18:    IF no.file% = 1 THEN BEGIN
1759: 2a27:       no.file% = 0
1760: 2a34:       IF NOT no.inp.file% THEN BEGIN
1761: 2a43:          FILE.OPERATION$ = "C"
1762: 2a5a: 		 
1763: 2a5a:    ! Planner refresh from Inctactix has been increased over time so     ! CRG 
1764: 2a5a:    ! doubling the file capacity to 1.5 times of its current size        ! CRG 
1765: 2a5a:    
1766: 2a5a:    !      CREATE POSFILE SRSXF.FILE.NAME$ KEYED 6,,,60000               \ CRG
1767: 2a5a:           CREATE POSFILE SRSXF.FILE.NAME$ KEYED 6,,,90000               \ CRG
1768: 2a5a:                 RECL SRSXF.RECL% AS SRSXF.SESS.NUM% MIRRORED ATCLOSE
1769: 2a5a:       ENDIF
1770: 2a62:    ENDIF
1771: 2a6a: 
1772: 2a6a: RETURN
1773: 2a7a: 
1774: 2a7a: \********************************************************************
1775: 2a7a: \***
1776: 2a7a: \***    SUBROUTINE      :       UPDATE.RUN.FILE
1777: 2a7a: \***
1778: 2a7a: \********************************************************************
1779: 2a7a: \***
1780: 2a7a: \***    READ POGOK Locked
1781: 2a7a: \***
1782: 2a7a: \***    Set up variables according to run results
1783: 2a7a: \***
1784: 2a7a: \***    WRITE POGOK Unlock
1785: 2a7a: \***
1786: 2a7a: \***    RETURN
1787: 2a7a: \***
1788: 2a7a: \********************************************************************
1789: 2a7a: 
1790: 2a7a: UPDATE.RUN.FILE:
1791: 2a8a: 
1792: 2a8a: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1793: 2a8a: \* Set todays date YYYYMMDD (set again incase 24:00 passed)        *\
1794: 2a8a: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1795: 2a8a: 
1796: 2a8a:    rundate$ = PACK$("20"+DATE$)
1797: 2ab1: 
1798: 2ab1: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1799: 2ab1: \* Set error codes for incomplete Delta file                       *\
1800: 2ab1: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1801: 2ab1: 
1802: 2ab1:    IF (srp10.error% AND 80H) = 80H                                  \
1803: 2ad5:   AND init.fail% = 0 THEN BEGIN
1804: 2ad5:       IF tlr.read% = 0 THEN BEGIN
1805: 2ae4:          srp10.error% = srp10.error% OR 02H
1806: 2af6:       ENDIF ELSE IF tlr.cnt% <> rec.cnt% THEN BEGIN
1807: 2b11:          srp10.error% = srp10.error% OR 01H
1808: 2b21:       ENDIF
1809: 2b29:    ENDIF
1810: 2b31: 
1811: 2b31: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1812: 2b31: \* Read POGOK file - Retry if locked                               *\
1813: 2b31: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1814: 2b31: 
1815: 2b31:    no.read% = 0
1816: 2b3e: retry2:
1817: 2b4e:    rc% = READ.POGOK.LOCK
1818: 2b5e:    IF rc% <> 0 THEN BEGIN
1819: 2b6d:       GOSUB FILE.ERROR
1820: 2b7f:       IF no.read% > 0 THEN GOTO retry2
1821: 2b90:    ENDIF
1822: 2b98: 
1823: 2b98: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1824: 2b98: \* Update POGOK based on run results                               *\
1825: 2b98: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1826: 2b98: 
1827: 2b98:    IF init.load% THEN BEGIN
1828: 2ba7:       POGOK.RELOAD$ = "N"
1829: 2bbe:    ENDIF
1830: 2bc6: 
1831: 2bc6:    POGOK.PE10.RUNDATE$ = rundate$
1832: 2be1:    IF (srp10.error% AND 20H) <> 0 THEN BEGIN
1833: 2bf2:       ! Delta File not found or No header record
1834: 2bf2:       POGOK.PE10.RUNFLAG$ = "Y"
1835: 2c09:       POGOK.PE10.RETCODE% = 6
1836: 2c1c:    ENDIF ELSE IF (srp10.error% AND 83H) <> 0 THEN BEGIN
1837: 2c30:       ! Abend via Main error routine (80H)
1838: 2c30:       ! Incorrect record count (01H) or No trailer record (02H)
1839: 2c30:       srp10.event% = 4
1840: 2c3d:       GOSUB LOG.EVENT
1841: 2c4f:       POGOK.PE10.RUNFLAG$      = "X"
1842: 2c66:       IF (srp10.error% AND 80H) = 80H THEN BEGIN
1843: 2c77:          POGOK.PE10.RETCODE% = 8
1844: 2c89:       ENDIF ELSE BEGIN
1845: 2c91:          POGOK.PE10.RETCODE% = (srp10.error% AND 03H)
1846: 2ca5:       ENDIF
1847: 2cad:       POGOK.SRD.REC.COUNT%     = rec.cnt%
1848: 2cc4:       POGOK.FAILED.SRD.SER.NO$ = RIGHT$("0000"                      \
1849: 2d0c:                                       + STR$(POGDE.SER.NO%),4)
1850: 2d0c:       POGOK.FAILED.SRD.DATE$   = POGDE.DATE$
1851: 2d2a:    ENDIF ELSE IF (srp10.error% AND 04H) <> 0 THEN BEGIN
1852: 2d3b:       ! Old data
1853: 2d3b:       POGOK.PE10.RUNFLAG$ = "Y"
1854: 2d52:       POGOK.PE10.RETCODE% = 3
1855: 2d65:    ENDIF ELSE IF (srp10.error% AND 08H) <> 0 THEN BEGIN
1856: 2d76:       ! Already processed (Not 'RERUN')
1857: 2d76:       POGOK.PE10.RUNFLAG$ = "E"
1858: 2d8d:       POGOK.PE10.RETCODE% = 4
1859: 2da0:    ENDIF ELSE IF (srp10.error% AND 10H) <> 0 THEN BEGIN
1860: 2db1:       ! Init Load expected - Delta received
1861: 2db1:       POGOK.PE10.RUNFLAG$ = "Y"
1862: 2dc8:       POGOK.PE10.RETCODE% = 5
1863: 2dd8:       POGOK.RELOAD$       = "Y"
1864: 2df1:    ENDIF ELSE BEGIN
1865: 2df9:       ! No problems
1866: 2df9:       POGOK.PE10.RUNFLAG$ = "E"
1867: 2e10:       POGOK.PE10.RETCODE% = 0
1868: 2e20:    ENDIF
1869: 2e28: 
1870: 2e28:    IF POGOK.PE10.RETCODE% = 0                                       \
1871: 2e55:    OR POGOK.PE10.RETCODE% = 5 THEN BEGIN
1872: 2e55:       POGOK.SRD.SER.NO$     = RIGHT$("0000"+STR$(POGDE.SER.NO%),4)
1873: 2e9d:       POGOK.SRD.DATE$       = POGDE.DATE$
1874: 2eb8:       POGOK.SRD.REC.COUNT%  = rec.cnt%
1875: 2ecf:       POGOK.DAYS.TO.RETAIN% = POGDE.DTR%
1876: 2ee1:    ENDIF
1877: 2ee9: 
1878: 2ee9: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1879: 2ee9: \* Write to POGOK                                                  *\
1880: 2ee9: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1881: 2ee9: 
1882: 2ee9:    rc% = WRITE.POGOK.UNLOCK
1883: 2ef9:    IF rc% <> 0 THEN BEGIN
1884: 2f08:       GOSUB FILE.ERROR
1885: 2f1a:    ENDIF
1886: 2f22: 
1887: 2f22: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1888: 2f22: \* Delete copies of SRPOG/SRMOD if they exist (Not if abended)     *\
1889: 2f22: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1890: 2f22: 
1891: 2f22:    IF POGOK.PE10.RUNFLAG$ <> "X" THEN BEGIN
1892: 2f43:       IF SIZE(SRPOG.COPY.NAME$) > 0 THEN BEGIN
1893: 2f72:          CLOSE SRPOG.SESS.NUM%
1894: 2f86:          OPEN SRPOG.COPY.NAME$ AS SRPOG.SESS.NUM%
1895: 2fad:          DELETE SRPOG.SESS.NUM%
1896: 2fc1:       ENDIF
1897: 2fc9:       IF SIZE(SRMOD.COPY.NAME$) > 0 THEN BEGIN
1898: 2ff8:          CLOSE SRMOD.SESS.NUM%
1899: 300c:          OPEN SRMOD.COPY.NAME$ AS SRMOD.SESS.NUM%
1900: 3033:          DELETE SRMOD.SESS.NUM%
1901: 3047:       ENDIF
1902: 304f:    ENDIF
1903: 3057: 
1904: 3057: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1905: 3057: \* Delete old copy of delta file/ Save current (Not if abended)    *\
1906: 3057: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1907: 3057: 
1908: 3057:    IF POGOK.PE10.RUNFLAG$ <> "X" THEN BEGIN
1909: 3078:       IF SIZE(POGDE.COPY.NAME$) > 0 THEN BEGIN
1910: 30a7:          CLOSE POGDE.SESS.NUM%
1911: 30bb:          OPEN POGDE.COPY.NAME$ AS POGDE.SESS.NUM%
1912: 30e2:          DELETE POGDE.SESS.NUM%
1913: 30f6:       ENDIF
1914: 30fe:       rc% = RENAME(POGDE.COPY.NAME$,POGDE.FILE.NAME$)
1915: 3124:    ENDIF
1916: 312c: 
1917: 312c: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1918: 312c: \* Start - House keeping & Index Prime                             *\
1919: 312c: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1920: 312c: 
1921: 312c:    GOSUB START.SRP6
1922: 313e: 
1923: 313e: RETURN
1924: 314e: 
1925: 314e: \********************************************************************
1926: 314e: \***
1927: 314e: \***    SUBROUTINE      :       TERMINATION
1928: 314e: \***
1929: 314e: \********************************************************************
1930: 314e: \***
1931: 314e: \***    Deallocate all session numbers
1932: 314e: \***
1933: 314e: \***    CLOSE the required files
1934: 314e: \***
1935: 314e: \********************************************************************
1936: 314e: 
1937: 314e: TERMINATION:
1938: 315e: 
1939: 315e:     SB.ACTION$ = "C"
1940: 3175:     SB.STRING$ = ""
1941: 318c: 
1942: 318c:     SB.INTEGER% = POGDE.SESS.NUM%
1943: 31a2:     CLOSE SB.INTEGER%
1944: 31b6:     GOSUB SB.FILE.UTILS
1945: 31c8: 
1946: 31c8:     SB.INTEGER% = POGOK.SESS.NUM%
1947: 31de:     CLOSE SB.INTEGER%
1948: 31f2:     GOSUB SB.FILE.UTILS
1949: 3204: 
1950: 3204:     SB.INTEGER% = SRPDF.SESS.NUM%
1951: 321a:     CLOSE SB.INTEGER%
1952: 322e:     GOSUB SB.FILE.UTILS
1953: 3240: 
1954: 3240:     SB.INTEGER% = SRPOG.SESS.NUM%
1955: 3256:     CLOSE SB.INTEGER%
1956: 326a:     GOSUB SB.FILE.UTILS
1957: 327c: 
1958: 327c:     SB.INTEGER% = SRMOD.SESS.NUM%
1959: 3292:     CLOSE SB.INTEGER%
1960: 32a6:     GOSUB SB.FILE.UTILS
1961: 32b8: 
1962: 32b8:     SB.INTEGER% = SRSXF.SESS.NUM%
1963: 32ce:     CLOSE SB.INTEGER%
1964: 32e2:     GOSUB SB.FILE.UTILS
1965: 32f4: 
1966: 32f4: RETURN
1967: 3304: 
1968: 3304: \********************************************************************
1969: 3304: \***
1970: 3304: \***    SUBROUTINE      :       START.SRP5
1971: 3304: \***
1972: 3304: \********************************************************************
1973: 3304: 
1974: 3304: 
1975: 3304: START.SRP5:
1976: 3314: 
1977: 3314:    file$ = "ADX_UPGM:SRP05.286"
1978: 3329:    parm$ = comm.tail$
1979: 3342:    text$ = "S&R MAPPING LOAD - Started by SRP10 -"                  \
1980: 33c3:          + MID$(TIME$,1,2) + ":"                                    \
1981: 33c3:          + MID$(TIME$,3,2) + ":"                                    \
1982: 33c3:          + MID$(TIME$,5,2)                                          !
1983: 33c3:    rc%   = ADXSTART(file$, parm$, text$)
1984: 33ee:    IF rc% <> 0 THEN BEGIN
1985: 33fd:       srp10.event% = 8
1986: 340a:       GOSUB LOG.EVENT
1987: 341c:    ENDIF
1988: 3424: 
1989: 3424: RETURN
1990: 3434: 
1991: 3434: \********************************************************************
1992: 3434: \***
1993: 3434: \***    SUBROUTINE      :       START.SRP6
1994: 3434: \***
1995: 3434: \********************************************************************
1996: 3434: 
1997: 3434: 
1998: 3434: START.SRP6:
1999: 3444: 
2000: 3444:    file$ = "ADX_UPGM:SRP06.286"
2001: 3459:    parm$ = comm.tail$
2002: 3472:    text$ = "S&R Housekeeping + Index from SRP10 -"                  \
2003: 34f3:          + MID$(TIME$,1,2) + ":"                                    \
2004: 34f3:          + MID$(TIME$,3,2) + ":"                                    \
2005: 34f3:          + MID$(TIME$,5,2)                                          !
2006: 34f3:    rc%   = ADXSTART(file$, parm$, text$)
2007: 351e:    IF rc% <> 0 THEN BEGIN
2008: 352d:       srp10.event% = 8
2009: 353a:       GOSUB LOG.EVENT
2010: 354c:    ENDIF
2011: 3554: 
2012: 3554: RETURN
2013: 3564: 
2014: 3564: \********************************************************************
2015: 3564: \***
2016: 3564: \***    SUBROUTINE      :       CREATE.SRPOG
2017: 3564: \***
2018: 3564: \********************************************************************
2019: 3564: 
2020: 3564: CREATE.SRPOG:
2021: 3574: 
2022: 3574:    IF END #SRPOG.SESS.NUM% THEN CREATE.ERROR
2023: 3590:    CURRENT.REPORT.NUM% = SRPOG.REPORT.NUM%
2024: 35a6:    
2025: 35a6:    ! Planner refresh from inctactix has been increased over time so     ! CRG 
2026: 35a6:    ! doubling the file capacity to double of its current size           ! CRG 
2027: 35a6:    
2028: 35a6:    ! CREATE POSFILE SRPOG.FILE.NAME$ KEYED 4,,,3000                   \ ! CRG
2029: 35a6:      CREATE POSFILE SRPOG.FILE.NAME$ KEYED 4,,,6000                   \ ! CRG
2030: 35a6:           RECL SRPOG.RECL% AS SRPOG.SESS.NUM% MIRRORED ATCLOSE
2031: 35a6: 
2032: 35a6:    no.pog.file% = 0
2033: 35b3: 
2034: 35b3:    RETURN
2035: 35c3: 
2036: 35c3: \********************************************************************
2037: 35c3: \***
2038: 35c3: \***    SUBROUTINE      :       CREATE.SRMOD
2039: 35c3: \***
2040: 35c3: \********************************************************************
2041: 35c3: 
2042: 35c3: 
2043: 35c3: CREATE.SRMOD:
2044: 35d3: 
2045: 35d3:    IF END #SRMOD.SESS.NUM% THEN CREATE.ERROR
2046: 35ef:    CURRENT.REPORT.NUM% = SRMOD.REPORT.NUM%
2047: 3605:    
2048: 3605:    ! Planner refresh from inctactix has been increased over time so     ! CRG 
2049: 3605:    ! doubling the file capacity to double of its current size           ! CRG 
2050: 3605:    ! CREATE POSFILE SRMOD.FILE.NAME$ KEYED 6,,,4000                   \ ! CRG
2051: 3605:      CREATE POSFILE SRMOD.FILE.NAME$ KEYED 6,,,8000                   \ ! CRG
2052: 3605:           RECL SRMOD.RECL% AS SRMOD.SESS.NUM% MIRRORED ATCLOSE
2053: 3605: 
2054: 3605:    no.mod.file% = 0
2055: 3612: 
2056: 3612:    RETURN
2057: 3622: 
2058: 3622: \********************************************************************
2059: 3622: \***
2060: 3622: \***    SUBROUTINE      :       DISPLAY.MSG
2061: 3622: \***
2062: 3622: \********************************************************************
2063: 3622: 
2064: 3622: DISPLAY.MSG:
2065: 3632: 
2066: 3632:    mess$ = LEFT$(mess$ + STRING$(36," "), 36) + " "                 \
2067: 36f7:          + MID$(TIME$,1,2) + ":"                                    \
2068: 36f7:          + MID$(TIME$,3,2) + ":"                                    \
2069: 36f7:          + MID$(TIME$,5,2)                                          !
2070: 36f7: 
2071: 36f7:    IF bg% = 1 THEN BEGIN
2072: 3706:       CALL ADXSERVE (rc4%, 26, 0, mess$)
2073: 3740:    ENDIF ELSE BEGIN
2074: 3748:       PRINT mess$
2075: 375d:    ENDIF
2076: 3765: 
2077: 3765: RETURN
2078: 3775: 
2079: 3775: \********************************************************************
2080: 3775: \***
2081: 3775: \***    SUBROUTINE      :       LOG.EVENT
2082: 3775: \***
2083: 3775: \***    srp10.event% = 1 - Header not 1st record in Delta file
2084: 3775: \***                   2 - Duplicate Delta File
2085: 3775: \***                   3 - Old Delta File
2086: 3775: \***                   4 - Premature eof on Delta file
2087: 3775: \***                   5 - Delta received - no existing POG/MOD file
2088: 3775: \***                   6 - ID of module record <> ID of POG Header
2089: 3775: \***                   7 - POG module records < POG module count
2090: 3775: \***                   8 - ADXSTART error
2091: 3775: \***
2092: 3775: \********************************************************************
2093: 3775: 
2094: 3775: LOG.EVENT:
2095: 3785: 
2096: 3785:    IF srp10.event% <  1                                             \
2097: 37a4:    OR srp10.event% >  8 THEN BEGIN
2098: 37a4:       GOTO 0
2099: 37af:    ENDIF
2100: 37b7: 
2101: 37b7:    message.no%   = 0
2102: 37c5: 
2103: 37c5:    ON srp10.event% GOSUB 1, 2, 3, 4, 5, 6, 7, 8
2104: 37ed: 
2105: 37ed: 0:
2106: 37fd:    srp10.event% = 0
2107: 380a: 
2108: 380a: RETURN
2109: 381a: 
2110: 381a: 1:
2111: 382a:    event.no%     = 17
2112: 3838:    var.string.1$ = RIGHT$("000" + STR$(POGDE.REPORT.NUM%),3)        \
2113: 38b9:                  + "00 " + LEFT$(rectyp$ + "   ",3)
2114: 38b9:    var.string.2$ = ""
2115: 38ce:    GOTO LOG.IT
2116: 38d9: 
2117: 38d9: 2:
2118: 38e9:    event.no%     = 177
2119: 38f7:    var.string.1$ = CHR$(SHIFT(POGDE.REPORT.NUM%,8))                 \
2120: 3957:                  + CHR$(SHIFT(POGDE.REPORT.NUM%,0))                 \
2121: 3957:                  + "D"
2122: 3957:    var.string.2$ = ""
2123: 396c:    GOTO LOG.IT
2124: 3977: 
2125: 3977: 3:
2126: 3987:    event.no%     = 177
2127: 3995:    var.string.1$ = CHR$(SHIFT(POGDE.REPORT.NUM%,8))                 \
2128: 39f5:                  + CHR$(SHIFT(POGDE.REPORT.NUM%,0))                 \
2129: 39f5:                  + "O"
2130: 39f5:    var.string.2$ = ""
2131: 3a0a:    GOTO LOG.IT
2132: 3a15: 
2133: 3a15: 4:
2134: 3a25:    ! (Serial number not logged)
2135: 3a25:    event.no%     = 92
2136: 3a33:    var.string.1$ = CHR$(SHIFT(POGDE.REPORT.NUM%,8))                 \
2137: 3b19:                  + CHR$(SHIFT(POGDE.REPORT.NUM%,0))                 \
2138: 3b19:                  + PACK$(RIGHT$("00000000" +STR$(tlr.cnt%),8))      \
2139: 3b19:                  + PACK$(RIGHT$("00000000" +STR$(rec.cnt%),8))
2140: 3b19:    var.string.2$ = ""
2141: 3b2e:    GOTO LOG.IT
2142: 3b39: 
2143: 3b39: 5:
2144: 3b49:    event.no%     = 178
2145: 3b57:    IF no.pog.file% THEN BEGIN
2146: 3b66:       work$ = "SRPOG"
2147: 3b7d:    ENDIF ELSE BEGIN
2148: 3b85:       work$ = "     "
2149: 3b9a:    ENDIF
2150: 3ba2:    IF no.mod.file% THEN BEGIN
2151: 3bb1:       work$ = work$                                                 \
2152: 3bd3:             + "SRMOD"
2153: 3bd3:    ENDIF ELSE BEGIN
2154: 3bdb:       work$ = work$                                                 \
2155: 3bfb:             + "     "
2156: 3bfb:    ENDIF
2157: 3c03:    var.string.1$ = work$
2158: 3c1c:    var.string.2$ = ""
2159: 3c31:    work$         = ""
2160: 3c46:    GOTO LOG.IT
2161: 3c51: 
2162: 3c51: 6:
2163: 3c61:    event.no%     = 181
2164: 3c6f:    work$         = STRING$(8,CHR$(0))
2165: 3c8e:    CALL PUTN4(work$,0,VAL(UNPACK$(MID$(POGDE.RCD$,2,3))))
2166: 3ccd:    CALL PUTN4(work$,4,SRPOG.POGID%)
2167: 3cf2:    var.string.1$ = CHR$(SHIFT(POGDE.REPORT.NUM%,8))                 \
2168: 3d56:                  + CHR$(SHIFT(POGDE.REPORT.NUM%,0))                 \
2169: 3d56:                  + work$
2170: 3d56:    var.string.2$ = ""
2171: 3d6b:    GOTO LOG.IT
2172: 3d76: 
2173: 3d76: 7:
2174: 3d86:    event.no%     = 182
2175: 3d94:    work$     = STRING$(2,CHR$(0))
2176: 3db3:    CALL PUTN1(work$,0,mod.cnt%)
2177: 3dd2:    CALL PUTN1(work$,1,SRPOG.MODULE.COUNT%)
2178: 3df5:    var.string.1$ = CHR$(SHIFT(POGDE.REPORT.NUM%,8))                 \
2179: 3e59:                  + CHR$(SHIFT(POGDE.REPORT.NUM%,0))                 \
2180: 3e59:                  + work$
2181: 3e59:    var.string.2$ = ""
2182: 3e6e:    GOTO LOG.IT
2183: 3e78: 
2184: 3e78: 8:
2185: 3e88:    event.no%     =  42
2186: 3e96:    var.string.1$ = STR$(rc%)
2187: 3eb2:    var.string.2$ = ""
2188: 3ec7: 
2189: 3ec7: LOG.IT:
2190: 3ed7: 
2191: 3ed7:    CALL APPLICATION.LOG(message.no%,                                \
2192: 3f00:                         var.string.1$,                              \
2193: 3f00:                         var.string.2$,                              \
2194: 3f00:                         event.no%)
2195: 3f00: 
2196: 3f00: RETURN
2197: 3f10: 
2198: 3f10: \********************************************************************
2199: 3f10: \***
2200: 3f10: \***    SUBROUTINE      :       SB.FILE.UTILS
2201: 3f10: \***
2202: 3f10: \********************************************************************
2203: 3f10: \***
2204: 3f10: \***      Allocate/report/de-allocate a file session number
2205: 3f10: \***
2206: 3f10: \********************************************************************
2207: 3f10: \***
2208: 3f10: \***      Parameters : 2 or 3 (depending on action)
2209: 3f10: \***
2210: 3f10: \***         SB.ACTION$  = "O" for allocate file session number
2211: 3f10: \***                       "R" for report file session number
2212: 3f10: \***                       "C" for de-allocate file session number
2213: 3f10: \***
2214: 3f10: \***         SB.INTEGER% = file reporting number for action "O" or
2215: 3f10: \***                       file session number for actions "R" or "C"
2216: 3f10: \***
2217: 3f10: \***         SB.STRING$  = logical file name for action "O" or
2218: 3f10: \***                       null ("") for action "R" and "C"
2219: 3f10: \***
2220: 3f10: \***      Output : 1 or 2 (depending on action)
2221: 3f10: \***
2222: 3f10: \***         SB.FILE.NAME$     = logical file name for action "R"
2223: 3f10: \***
2224: 3f10: \***         SB.FILE.SESS.NUM% = file session number for action "O"
2225: 3f10: \***                             or undefined for action "C"
2226: 3f10: \***         OR
2227: 3f10: \***         SB.FILE.REP.NUM%  = file reporting number for action "R"
2228: 3f10: \***                             or undefined for action "C"
2229: 3f10: \***
2230: 3f10: \********************************************************************
2231: 3f10: 
2232: 3f10: SB.FILE.UTILS:
2233: 3f20: 
2234: 3f20:     CALL SESS.NUM.UTILITY(SB.ACTION$, SB.INTEGER%, SB.STRING$)
2235: 3f4d: 
2236: 3f4d:     IF SB.ACTION$ = "O" THEN BEGIN
2237: 3f6b: 
2238: 3f6b:         SB.FILE.SESS.NUM% = F20.INTEGER.FILE.NO%
2239: 3f83: 
2240: 3f83:     ENDIF ELSE IF SB.ACTION$ = "R" THEN BEGIN
2241: 3fa1: 
2242: 3fa1:         SB.FILE.REP.NUM% = F20.INTEGER.FILE.NO%
2243: 3fb7:         SB.FILE.NAME$ = F20.FILE.NAME$
2244: 3fd5: 
2245: 3fd5:     ENDIF
2246: 3fdd: 
2247: 3fdd: RETURN
2248: 3fed: 
2249: 3fed: \********************************************************************
2250: 3fed: \***
2251: 3fed: \***    SUBROUTINE      :       CREATE.ERROR
2252: 3fed: \***
2253: 3fed: \********************************************************************
2254: 3fed: 
2255: 3fed: CREATE.ERROR:
2256: 3ffd: 
2257: 3ffd:    FILE.OPERATION$ = "C"
2258: 4014: 
2259: 4014:    GOSUB FILE.ERROR
2260: 4026: 
2261: 4026:    GOTO TIDY.END.PROG
2262: 4031: 
2263: 4031: RETURN
2264: 4041: 
2265: 4041: \********************************************************************
2266: 4041: \********************************************************************
2267: 4041: \***
2268: 4041: \***    E N D  O F  L O W  L E V E L  S U B R O U T I N E S
2269: 4041: \***
2270: 4041: \********************************************************************
2271: 4041: \********************************************************************
2272: 4041: 
2273: 4041: 
2274: 4041: \********************************************************************
2275: 4041: \********************************************************************
2276: 4041: \***
2277: 4041: \***    S T A R T  O F  E R R O R  R O U T I N E S
2278: 4041: \***
2279: 4041: \********************************************************************
2280: 4041: \********************************************************************
2281: 4041: \********************************************************************
2282: 4041: \***
2283: 4041: \***    ERROR ROUTINE   :       FILE.ERROR
2284: 4041: \***
2285: 4041: \********************************************************************
2286: 4041: 
2287: 4041: FILE.ERROR:
2288: 4051: 
2289: 4051:     IF SB.ACTION$ = "C" THEN RETURN             ! Ignore close errs
2290: 4077: 
2291: 4077:     event.no%   = 106
2292: 4085:     message.no% = 0
2293: 4093: 
2294: 4093:     file.no$ = CHR$(SHIFT(CURRENT.REPORT.NUM%,8)) +                 \
2295: 40e4:                CHR$(SHIFT(CURRENT.REPORT.NUM%,0))
2296: 40e4: 
2297: 40e4:     var.string.2$ = RIGHT$("000" + STR$(CURRENT.REPORT.NUM%),3)
2298: 412c: 
2299: 412c:     IF FILE.OPERATION$ = "R" THEN BEGIN
2300: 414d:         IF no.read% < 60                                             \
2301: 4178:        AND CURRENT.REPORT.NUM% = POGOK.REPORT.NUM% THEN BEGIN
2302: 4178:            WAIT ; 500
2303: 418f:            no.read% = no.read% +1
2304: 419d:         ENDIF ELSE BEGIN
2305: 41a5:            var.string.2$ = var.string.2$                            \
2306: 41d1:                          + UNPACK$(CURRENT.CODE$)
2307: 41d1:         ENDIF
2308: 41d9:     ENDIF
2309: 41e1: 
2310: 41e1:     var.string.1$ = FILE.OPERATION$ +                               \
2311: 4218:                     file.no$ +                                      \
2312: 4218:                     PACK$(STRING$(12,"0"))
2313: 4218: 
2314: 4218:     CALL APPLICATION.LOG(message.no%,                               \
2315: 4241:                          var.string.1$,                             \
2316: 4241:                          var.string.2$,                             \
2317: 4241:                          event.no%)
2318: 4241: 
2319: 4241: RETURN
2320: 4251: 
2321: 4251: \********************************************************************
2322: 4251: \***
2323: 4251: \***    ERROR ROUTINE   :       ERROR.DETECTED
2324: 4251: \***
2325: 4251: \********************************************************************
2326: 4251: 
2327: 4251: ERROR.DETECTED:
2328: 4261: 
2329: 4261:     IF ERR = "OE" AND ERRF% = 0 THEN RESUME     ! Size errors
2330: 42b8:     IF ERR = "CU" THEN RESUME
2331: 42ed: 
2332: 42ed:     CALL STANDARD.ERROR.DETECTED(ERRN,                              \
2333: 431a:                                  ERRF%,                             \
2334: 431a:                                  ERRL,                              \
2335: 431a:                                  ERR)
2336: 431a: 
2337: 431a:     err.cd$ = ERR + " rec " + str$(rec.cnt%)
2338: 434f: 
2339: 434f:     IF (srp10.error% AND 80H) = 0 THEN BEGIN
2340: 4360:        srp10.error% = srp10.error% OR 80H
2341: 4370:        RESUME TIDY.END.PROG
2342: 4389:     ENDIF ELSE BEGIN
2343: 4391:        RESUME FATAL.END.PROG
2344: 43a8:     ENDIF
2345: 43b5: 
2346: 43b5: END
2347: 43b5: End of Compilation
