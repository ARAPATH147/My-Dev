   1: 0000: \*******************************************************************************
   2: 0000: \*******************************************************************************
   3: 0000: \***
   4: 0000: \***    %ITEM-DEALS FILE FUNCTIONS
   5: 0000: \***
   6: 0000: \***        REFERENCE   :   ITMDLFUN.BAS
   7: 0000: \***        FILE TYPE   :   Keyed
   8: 0000: \***        AUTHOR      :   Sandhya Pillai
   9: 0000: \***        DATE        :   09/06/2014
  10: 0000: \***
  11: 0000: \***
  12: 0000: \***    Version B               Charles Skadorwa                      09/07/2014
  13: 0000: \***    Minor changes following internal code review
  14: 0000: \***
  15: 0000: \***    Version C               Mark Walker                           11/07/2014
  16: 0000: \***    Added functions for adding and removing individual items.
  17: 0000: \***    Improved efficiency and consistency in a few areas.
  18: 0000: \***
  19: 0000: \***    Version D               Mark Walker                           15/07/2014
  20: 0000: \***    Added local pricing support.
  21: 0000: \***
  22: 0000: \***    Version E               Mark Walker                           16/07/2014
  23: 0000: \***    Incorporated changes following Applications Management code review:
  24: 0000: \***    - Sorted variables into alphabetical order (grouped by type)
  25: 0000: \***    - Corrected usage of the ITMDL.DEAL.END% variable
  26: 0000: \***    Fixed the WRITE.ITMDL.REC function to handle more than 20 deals.
  27: 0000: \***
  28: 0000: \***    Version F              Sandhya Pillai                         17/07/2014
  29: 0000: \***    Added Maximum deals per Item variable as a global which can be
  30: 0000: \***    used by the calling program
  31: 0000: \***
  32: 0000: \***    Version G               Mark Walker                           24/07/2014
  33: 0000: \***    Includes the following enhancements:
  34: 0000: \***    - Corrected value of ITMDL.DEALID.START.POS% and modified code to
  35: 0000: \***      work with the proper value.
  36: 0000: \***    - Improved efficiency of the SPLIT.READ.ITMDL.DIRECT function.
  37: 0000: \***    - Changed local variables ITMDL.DEAL.MAX% and ITMDL.DEALID.START.POS%
  38: 0000: \***      to global (in ITMDLDEC.J86) to allow them to be referenced by 
  39: 0000: \***      calling programs.
  40: 0000: \***
  41: 0000: \***    Version H               Mark Walker                           24/07/2014
  42: 0000: \***    Calculate the value of ITMDL.MAXDEALS.PER.ITEM%.
  43: 0000: \***
  44: 0000: \***    Version I               Mark Walker                           01/08/2014
  45: 0000: \***    Includes the following AM code review comments:
  46: 0000: \***    - Sorted further variable definitions and declarations into
  47: 0000: \***      alphabetical order (grouped by type).
  48: 0000: \***
  49: 0000: \***    Version J               Mark Walker                           14/08/2014
  50: 0000: \***    Added file function to open the ITMDL file.
  51: 0000: \***
  52: 0000: \*******************************************************************************
  53: 0000: \*******************************************************************************
  54: 0000: %INCLUDE ITMDLDEC.J86 ! ITMDL variable declarations
  55: 0000: \*******************************************************************************
  56: 0000: \*******************************************************************************
  57: 0000: \***
  58: 0000: \***    %INCLUDE FOR ITEM-DEALS FILE VARIABLE DECLARATIONS
  59: 0000: \***
  60: 0000: \***        REFERENCE   :   ITMDLDEC.J86
  61: 0000: \***        FILE TYPE   :   Keyed
  62: 0000: \***        AUTHOR      :   Sandhya Pillai
  63: 0000: \***        DATE        :   09/06/2014
  64: 0000: \***
  65: 0000: \***    Version B               Mark Walker                           11/07/2014
  66: 0000: \***    Added variable for ITMDL.DEAL.NUM$ an individual deal number.
  67: 0000: \***
  68: 0000: \***    Version C               Sandhya Pillai                        17/07/2014
  69: 0000: \***    Added variable ITMDL.MAXDEALS.PER.ITEM% for use by other modules
  70: 0000: \***
  71: 0000: \***    Version D               Mark Walker                           24/07/2014
  72: 0000: \***    Includes the following enhancements:
  73: 0000: \***    - Changed local variables ITMDL.DEAL.MAX% and ITMDL.DEALID.START.POS%
  74: 0000: \***      to global to allow them to be referenced by calling programs.
  75: 0000: \***    - Added global variable ITMDL.MAX.ITEMS.PER.DEAL% for use by
  76: 0000: \***      calling programs.
  77: 0000: \***
  78: 0000: \***********************************************************************
  79: 0000: \***********************************************************************
  80: 0000: \*
  81: 0000: \*    ITMDL RECORD LAYOUT
  82: 0000: \*
  83: 0000: \*    St Ln  Typ   Variable Name        Description
  84: 0000: \*                 excl prefix ITMDL.
  85: 0000: \*
  86: 0000: \*    1  4  UPD   ITEM.REC.KEY$          Record key - Combination of
  87: 0000: \*                                        item code and record number
  88: 0000: \*    1  3  UPD   ITEM.CODE$             Six digit Boots item code
  89: 0000: \*    4  1  UPD   REC.NUM$                From 1-99 records per item
  90: 0000: \*                                        (giving max 1980 deals per
  91: 0000: \*                                        items)
  92: 0000: \*    5  1  ASC   EXCLUSION$              "L" Local priced item excluded
  93: 0000: \*                                        from deal (or blank X'20')
  94: 0000: \*    6  7  ASC   RESERVED$               Null - Reserved for future use
  95: 0000: \*   13  *  60    ITMDL.DEAL.NUM.LID.20$  Deal number List ID array
  96: 0000: \*    *  3  UPD   DEAL.NUM.LID$(n)        Occurs up to 20 times per
  97: 0000: \*                                        record with unused entries
  98: 0000: \*                                        set to null
  99: 0000: \*    *  2  UPD   DEAL.NUM$(n)            Four digit deal number
 100: 0000: \*    *  1  UPD   LIST.ID$(n)             List ID is INT (on DINF) but
 101: 0000: \*                                        only holds values 0-3 so will
 102: 0000: \*                                        be read as UPD
 103: 0000: \***********************************************************************
 104: 0000: 
 105: 0000:     STRING GLOBAL                                                       \
 106: 0000:         ITMDL.ALL.DEAL.NUM.LIST.ID$,                                    \
 107: 0000:         ITMDL.DEAL.NUM$,                                                \   !BMW
 108: 0000:         ITMDL.EXCLUSION$,                                               \
 109: 0000:         ITMDL.FILE.NAME$,                                               \
 110: 0000:         ITMDL.ITEM.CODE$,                                               \
 111: 0000:         ITMDL.REC.NUM$
 112: 0000: 
 113: 0000:     INTEGER*1 GLOBAL                                                    \
 114: 0000:         ITMDL.DEALID.START.POS%,                                        \   !DMW
 115: 0000:         ITMDL.DEALNUM.LID.LEN%,                                         \
 116: 0000:         ITMDL.RECL%
 117: 0000: 
 118: 0000:     INTEGER*2 GLOBAL                                                    \
 119: 0000:         ITMDL.DEAL.COUNT%,                                              \
 120: 0000:         ITMDL.DEAL.MAX%,                                                \   !DMW
 121: 0000:         ITMDL.MAXDEALS.PER.ITEM%,                                       \   !CSP
 122: 0000:         ITMDL.MAX.ITEMS.PER.DEAL%,                                      \   !DMW
 123: 0000:         ITMDL.REPORT.NUM%,                                              \
 124: 0000:         ITMDL.SESS.NUM%
 125: 0000: 
 126: 0000: 
 127: 0000:     STRING GLOBAL                                                       \
 128: 0000:         CURRENT.CODE$,                                                  \
 129: 0000:         FILE.OPERATION$
 130: 0000: 
 131: 0000:     INTEGER*1 GLOBAL                                                    \   !CMW
 132: 0000:         FALSE,                                                          \   !CMW
 133: 0000:         TRUE                                                                !CMW
 134: 0000: 
 135: 0000:     INTEGER*2 GLOBAL                                                    \
 136: 0000:         CURRENT.REPORT.NUM%
 137: 0000: 
 138: 0000:     STRING                                                              \
 139: 0000:         ITMDL.DEAL.NUM.LID$,                                            \   !CMW
 140: 0000:         ITMDL.DEAL.NUM.LID.20$,                                         \
 141: 0000:         ITMDL.ITEM.REC.KEY$,                                            \
 142: 0000:         ITMDL.RECORD$,                                                  \
 143: 0000:         ITMDL.RESERVED$,                                                \
 144: 0000:         NULL.DEAL.NUM.LID$                                                  !CMW
 145: 0000: 
 146: 0000:     INTEGER*1                                                           \
 147: 0000: \       ITMDL.DEALID.START.POS%,                                        \   !GMW
 148: 0000:         ITMDL.DEALS.TO.WRITE%,                                          \
 149: 0000:         ITMDL.RC%,                                                      \
 150: 0000:         ITMDL.REC.MAX%,                                                 \
 151: 0000:         ITMDL.RECS.TO.WRITE%
 152: 0000: 
 153: 0000:     INTEGER*2                                                          \
 154: 0000:         ITMDL.DEAL.END%,                                               \
 155: 0000: \       ITMDL.DEAL.MAX%,                                               \    !GMW
 156: 0000:         ITMDL.DEAL.START%,                                             \
 157: 0000:         ITMDL.REC.NUM%
 158: 0000: 
 159: 0000: %INCLUDE BASROUT.J86 ! 'C' utility functions                                !CMW
 160: 0000: \*LIB   BVEJ BASROUT  J86      03/11/97 08:16:26 PIDBLD3  *    FIX
 161: 0000: \*PROM  BVEJ BASROUT  J86      03/10/97 17:18:40 PIDBLD3  MVEJ IR34352
 162: 0000: \*RTIME BVEJ BASROUT  J86      03/10/97 17:18:41 PIDBLD3  MVEJ IR34352
 163: 0000: \*LIB   MVEJ BASROUT  J86      03/05/97 10:48:46 EDJRAL   *    IR34352
 164: 0000: \*LIB   MVEJ BASROUT  J86      02/17/97 11:19:56 EDJRAL   *    REASONAR
 165: 0000: \*LIB   MVEJ BASROUT  J86      02/14/97 15:59:11 EDJRAL   *    REASONAR
 166: 0000: ! BASROUT.J86 - this file is to be included in any BASIC code which utilizes
 167: 0000: !   the BASROUT.OBJ routines.  These routines were written
 168: 0000: !  using Metaware C and are intended to provide functions which
 169: 0000: !         are either not available in 4680 CBASIC or which can be more
 170: 0000: !               efficiently handled by the C language.  Their usage is
 171: 0000: !  offered on an "AT YOUR OWN RISK" basis.
 172: 0000: !
 173: 0000: !               The insert/extract routines usefulness may not be immediately
 174: 0000: !               apparent.  Their intention is that they be used in conjunction
 175: 0000: !               with a read/write form command.  They can more efficiently
 176: 0000: !               parse a string into many different variables than can the
 177: 0000: !               read form statement.  So instead of a long list of data var's
 178: 0000: !               it may be more efficient to just read/write one long string
 179: 0000: !               and then use the insert/extract routines to parse out the
 180: 0000: !   data.
 181: 0000: 
 182: 0000: ! ******************* SUB PROCESS FUNCTIONS *********************************
 183: 0000: 
 184: 0000: function osshell(cmd.line$) external   ! routine to start
 185: 0000:        ! another program.
 186: 0000:            integer*4    osshell    ! Upon completion of
 187: 0000:            string       cmd.line$   ! program, control is
 188: 0000:        ! returned to calling
 189: 0000: end function      ! program.
 190: 0000: !
 191: 0000: ! NOTES:  Program must be a 286 type file.  This does not exclude
 192: 0000: !         the capability to execute a batch file however.  Simply pass the
 193: 0000: !         following:
 194: 0000: !              c:\adx_spgm\command.286 batfile
 195: 0000: !         where batfile is the name of the batch file to be executed.
 196: 0000: !
 197: 0000: ! IMPORTANT: When using osshell to execute a batch file as described above,
 198: 0000: !            the final command in the batch file must be "exit".  If not,
 199: 0000: !       control is never given back to the calling program.
 200: 0000: 
 201: 0000: ! ************************ MEMORY RELATED FUNCTIONS ************************
 202: 0000: 
 203: 0000: function memfree(choice) external   ! routine to que the
 204: 0000:        ! status of the
 205: 0000:  integer*4 memfree    ! machine's memory:
 206: 0000:  integer*2 choice    ! Options:
 207: 0000:        !    1 - free
 208: 0000: end function      !    2 - total
 209: 0000:        !    3 - system
 210: 0000: 
 211: 0000: ! ********************** TIMEDATE RELATED FUNCTIONS ************************
 212: 0000: 
 213: 0000: function timedate(choice) external   ! routine to que the
 214: 0000:        ! OS's timedate table
 215: 0000:  integer*4 timedate   ! Choices:
 216: 0000:  integer*2 choice    !    1 - millisec's
 217: 0000:        !        since midnight
 218: 0000: end function      !    2 - minutes from
 219: 0000:        !  UCT (timezone)
 220: 0000:        !    3 - day of week
 221: 0000:        !   0-Sunday
 222: 0000:        !  6-Saturday
 223: 0000: 
 224: 0000: function settime(msecs) external   ! routine to set the
 225: 0000:        ! time on the controller
 226: 0000:  integer*4  settime    ! msecs is the desired
 227: 0000:  integer*4 msecs    ! number of milliseconds
 228: 0000:        ! since midnight
 229: 0000: end function      ! Returns negative on
 230: 0000:        ! error
 231: 0000: ! NOTE:  This routine sets the time only on the controller.  The terminals'
 232: 0000: ! time will not be updated until 1 AM or unless a terminal is STC'd.
 233: 0000: ! At 1 AM the controller broadcasts the new time to all terminals.
 234: 0000: ! Insure this is taken into consideration when using this routine.
 235: 0000: 
 236: 0000: !******************** DISK FILE RELATED FUNCTIONS *************************
 237: 0000: 
 238: 0000: function truncate(name,length) external   ! routine to truncate
 239: 0000:        ! the specified file
 240: 0000:  integer*4 truncate   ! to a given length.
 241: 0000:  string  name
 242: 0000:  integer*4 length
 243: 0000: 
 244: 0000: end function
 245: 0000: 
 246: 0000: !******************** STRING VALUE RELATED FUNCTIONS **********************
 247: 0000: 
 248: 0000: function isalpha(bstrn) external   ! routine to identify
 249: 0000:        ! if the specified
 250: 0000:  integer*1 isalpha    ! string contains all
 251: 0000:  string  bstrn    ! alphabetic char's
 252: 0000:        ! Returns:
 253: 0000: end function      !     0 - all alpha
 254: 0000:        !     X - byte of 1st
 255: 0000:        !         non-alpha
 256: 0000:        !   char
 257: 0000: 
 258: 0000: function isdigit(bstrn) external   ! routine to identify
 259: 0000:        ! if the specified
 260: 0000:  integer*1 isdigit    ! string contains all
 261: 0000:  string  bstrn    ! numeric char's
 262: 0000:        ! Returns:
 263: 0000: end function      !     0 - all numeric
 264: 0000:        !     X - byte of 1st
 265: 0000:        !         non-numeric
 266: 0000:        !   char
 267: 0000: 
 268: 0000: function islower(bstrn) external   ! routine to identify
 269: 0000:        ! if the specified
 270: 0000:  integer*1 islower    ! string contains all
 271: 0000:  string  bstrn    ! lower case char's
 272: 0000:        ! Returns:
 273: 0000: end function      !     0 - all lowercase
 274: 0000:        !     X - byte of 1st
 275: 0000:        !         non-lowercase
 276: 0000:        !   char
 277: 0000: 
 278: 0000: function isupper(bstrn) external   ! routine to identify
 279: 0000:        ! if the specified
 280: 0000:  integer*1 isupper    ! string contains all
 281: 0000:  string  bstrn    ! upper case char's
 282: 0000:        ! Returns:
 283: 0000: end function      !     0 - all uppercase
 284: 0000:        !     X - byte of 1st
 285: 0000:        !         non-uppercase
 286: 0000:        !   char
 287: 0000: 
 288: 0000: function toalpha(bstrn) external   ! routine to convert
 289: 0000:        ! non-alpha or non-num
 290: 0000:    integer*2 toalpha    ! char's to spaces
 291: 0000:  string  bstrn    ! Returns:
 292: 0000: end function      !   x - no. of char's
 293: 0000:        !       changed
 294: 0000: 
 295: 0000: ! ********************* USER/GROUP ZERO LEVEL FUNCTIONS *********************
 296: 0000: 
 297: 0000: function idlecount(choice) external   ! routine to either
 298: 0000:        ! set to zero or queue
 299: 0000:  integer*4 idlecount   ! the value of the
 300: 0000:  integer*1 choice    ! processor's idlecount
 301: 0000:        ! Choice:
 302: 0000: end function      !     0 - set to zero
 303: 0000: !       !     1 - get value
 304: 0000: ! NEEDS USER/GROUP 0 LEVEL OF AUTHORIZATION  ! Returns:
 305: 0000: ! TO WORK - This level is not available unless  !     X - idlecount
 306: 0000: ! the file ADXCSOUF.DAT file is "patched".  This !    -X - error code
 307: 0000: ! is highly unrecommended.
 308: 0000: 
 309: 0000: function logical(actname,logname,choice) external ! routine to set a
 310: 0000:        ! a logical name.
 311: 0000:  integer*4 logical    ! parms are self
 312: 0000:         string  logname    ! explanatory except
 313: 0000:  string  actname    ! for choice:
 314: 0000:  integer*1 choice    !   0 - set process
 315: 0000:        !   1 - set system
 316: 0000: end function      !   2 - get process
 317: 0000:        !   3 - get system
 318: 0000: 
 319: 0000: ! NOTE:  Only the setting of a system level of logical name requires
 320: 0000: ! user/group zero level of authorization.  Any application may query any
 321: 0000: ! logical name.  Setting of a system logical name is only applicable until
 322: 0000: ! the system is IPL'd.  A process logical name is only active when that
 323: 0000: ! process is active.
 324: 0000: 
 325: 0000: !******************** STRING PARSING FUNCTIONS *****************************
 326: 0000: 
 327: 0000: function inserts(whole,part,offset) external  ! routine to insert a
 328: 0000:        ! string (part) into
 329: 0000:  integer*2 INSERTS    ! another string (whole)
 330: 0000:  string  whole    ! starting at specified
 331: 0000:  string  part    ! character (offset)
 332: 0000:  integer*2 offset
 333: 0000: 
 334: 0000: end function
 335: 0000: 
 336: 0000: function cinsert4(integer4,bstring,offset) external   ! routine to insert
 337: 0000:        ! a 4-byte integer into
 338: 0000:  integer*1 cinsert4   ! a string starting at
 339: 0000:  integer*4 integer4   ! byte specified by
 340: 0000:  string  bstring    ! offset (1-based)
 341: 0000:  integer*2 offset    ! Returns:
 342: 0000:        !     0 - Success
 343: 0000: end function      !    -1 - String overrun
 344: 0000: 
 345: 0000: function cinsert2(integer2,bstring,offset) external  ! routine to insert
 346: 0000:        ! a 2-byte integer into
 347: 0000:  integer*1 cinsert2   ! a string starting at
 348: 0000:  integer*2 integer2   ! byte specified by
 349: 0000:  string  bstring    ! offset (1-based)
 350: 0000:  integer*2 offset    ! Returns:
 351: 0000:        !     0 - Success
 352: 0000: end function      !    -1 - String overrun
 353: 0000: 
 354: 0000: function cinsert1(bstring,integer1,offset) external  ! routine to insert
 355: 0000:        ! a 1-byte integer into
 356: 0000:  integer*1 cinsert1   ! a string starting at
 357: 0000:  integer*1 integer1   ! byte specified by
 358: 0000:  string  bstring    ! offset (1-based)
 359: 0000:  integer*2 offset    ! Returns:
 360: 0000:        !     0 - Success
 361: 0000: end function      !    -1 - String overrun
 362: 0000: 
 363: 0000: function extracts(whole,part,offset) external  ! routine to extract a
 364: 0000:        ! string (part) from
 365: 0000:  integer*2 EXTRACTS   ! another string (whole)
 366: 0000:  string  whole    ! starting at specified
 367: 0000:  string  part    ! character (offset)
 368: 0000:  integer*2 offset
 369: 0000: 
 370: 0000: end function
 371: 0000: 
 372: 0000: function cextract4(bstring,offset) external  ! routine to extract
 373: 0000:        ! a 4-byte integer from
 374: 0000:  integer*4 cextract4   ! a string starting at
 375: 0000:                        ! byte specified by
 376: 0000:  string  bstring    ! offset (1-based)
 377: 0000:  integer*2 offset    ! Returns:
 378: 0000:        !     X - 4 byte integer
 379: 0000: end function      !    -1 - String overrun
 380: 0000: 
 381: 0000: function cextract2(bstring,offset) external  ! routine to extract
 382: 0000:        ! a 2-byte integer from
 383: 0000:  integer*2 cextract2   ! a string starting at
 384: 0000:                        ! byte specified by
 385: 0000:  string  bstring    ! offset (1-based)
 386: 0000:  integer*2 offset    ! Returns:
 387: 0000:        !     X - 2 byte integer
 388: 0000: end function      !    -1 - String overrun
 389: 0000: 
 390: 0000: function cextract1(bstring,offset) external  ! routine to extract
 391: 0000:        ! a 1-byte integer from
 392: 0000:  integer*1 cextract1   ! a string starting at
 393: 0000:                        ! byte specified by
 394: 0000:  string  bstring    ! offset (1-based)
 395: 0000:  integer*2 offset    ! Returns:
 396: 0000:        !     X - 1 byte integer
 397: 0000: end function      !    -1 - String overrun
 398: 0000: 
 399: 0000: 
 400: 0000: function srchdir (file.name$,dtbl.buffer$) external ! routine to return
 401: 0000:        ! file names and sizes
 402: 0000:        ! Return values:
 403: 0000:        !    -1  no matches
 404: 0000:        !        found on first
 405: 0000:        !        call
 406: 0000:        !    0   no matches
 407: 0000:        !        found on sub-
 408: 0000:        !        sequent calls
 409: 0000:        !    Pos Success
 410: 0000:        !    Neg OS Rtn Code
 411: 0000: ! Usage Note:  If searching for all occurences of a particular file name,
 412: 0000: ! first initialize dtbl.buffer$ to 48 Nulls (pack$("00")) and issue a call
 413: 0000: ! to srchdir.  If any matches are found, a positive value will be returned.
 414: 0000: ! To see if any more matches exist, just issue another call to srchdir without
 415: 0000: ! resetting the values of dtbl.buffer$.  If any are found, a positive value
 416: 0000: ! will be returned.  This can be repeated until a Zero is returned.  All data
 417: 0000: ! describing file will be returned in the dtbl.buffer$ after each call.  Format
 418: 0000: ! of this data is defined below.
 419: 0000: 
 420: 0000:  integer*4 srchdir
 421: 0000: 
 422: 0000:  string  file.name$   ! file name to start
 423: 0000:        ! search (18 bytes max)
 424: 0000:        ! Wild cards and logical
 425: 0000:        ! names supported.
 426: 0000: 
 427: 0000:  string  dtbl.buffer$   ! must be initialized
 428: 0000:        ! to 48 bytes.  Contains
 429: 0000:        ! all of directory info
 430: 0000:        ! Initialize to nulls
 431: 0000:        ! each time a new file
 432: 0000:        ! name is used.
 433: 0000: 
 434: 0000: ! NOTE:  Format of dtbl.buffer$ string is as follows:
 435: 0000: !
 436: 0000: ! Offs  Type                    Description Notes
 437: 0000: !  0 integer*4  key  use extract4 to access
 438: 0000: !  4  string (18 bytes) file name
 439: 0000: ! 22 integer*2  attributes use extract2 to access
 440: 0000: !      0x01 - Read Only
 441: 0000: !      0x02 - Hidden
 442: 0000: !      0x04 - System
 443: 0000: !      0x08 - Volume Label
 444: 0000: !      0x10 - Subdirectory
 445: 0000: !      0x20 - Archive (Files)
 446: 0000: !      0x40 - Security enabled
 447: 0000: !      0x80 - Reserved
 448: 0000: !      0x0000 - Local
 449: 0000: !      0x4000 - Mirrored/Update
 450: 0000: !      0xC000 - Mirrored/Close
 451: 0000: !
 452: 0000: !      0x6000 - Compound/Update
 453: 0000: !      0xE000 - Compound/Close
 454: 0000: ! 24 integer*2  record size use extract2 to access
 455: 0000: ! 26 integer*1  User ID of Owner
 456: 0000: ! 27 integer*1  Group ID of Owner
 457: 0000: ! 28 integer*2  File Security
 458: 0000: ! 30 string (6 bytes) Reserved
 459: 0000: ! 36 integer*4  File Size use extract4 to access
 460: 0000: ! 40 integer*2  Year  use extract2 to access
 461: 0000: ! 42 integer*1  Month
 462: 0000: ! 43 integer*1  Day
 463: 0000: ! 44 integer*1  Hour
 464: 0000: ! 45 integer*1  Minute
 465: 0000: ! 46 integer*1  Second
 466: 0000: ! 47 integer*1  Reserved
 467: 0000: 
 468: 0000: end function
 469: 0000: 
 470: 0000: function srchproc (proc.name$,ptbl.buffer$) external ! routine to return
 471: 0000:        ! process names and
 472: 0000:        ! status.  Handy to
 473: 0000:        ! determine if a
 474: 0000:        ! program is currently
 475: 0000:        ! running.
 476: 0000:        ! Return values:
 477: 0000:        !    -1  no matches
 478: 0000:        !        found on first
 479: 0000:        !        call
 480: 0000:        !    0   no matches
 481: 0000:        !        found on sub-
 482: 0000:        !        sequent calls
 483: 0000:        !    Pos Success
 484: 0000:        !    Neg Failure
 485: 0000:        !        OS Rtn Code
 486: 0000:        ! 80000001h - Insuff
 487: 0000:         !        ptbl buffer
 488: 0000:        !        Length
 489: 0000: ! Usage Note:  If searching for all occurences of a particular process name,
 490: 0000: ! first initialize ptbl.buffer$ to 60 Nulls (pack$("00")) and issue a call
 491: 0000: ! to srchproc.  If any matches are found, a positive value will be returned.
 492: 0000: ! To see if any more matches exist, just issue another call to srchproc without
 493: 0000: ! resetting the values of ptbl.buffer$.  If any are found, a positive value
 494: 0000: ! will be returned.  This can be repeated until a Zero is returned.  All data
 495: 0000: ! describing file will be returned in the ptbl.buffer$ after each call.  Format
 496: 0000: ! of this data is defined as follows:
 497: 0000: !
 498: 0000: !       --------------------------------------------------------
 499: 0000: !   0   |                         PID                          |
 500: 0000: !       --------------------------------------------------------
 501: 0000: !   4   |           FID             |   CID        |   VCID    |
 502: 0000: !       --------------------------------------------------------
 503: 0000: !   8   |                         NAME                         |
 504: 0000: !       --------------------------------------------------------
 505: 0000: !  12   |                         NAME cont'd                  |
 506: 0000: !       --------------------------------------------------------
 507: 0000: !  16   |       NAME cont'd         |   STATE      |  PRIOR    |
 508: 0000: !       --------------------------------------------------------
 509: 0000: !  20   |                         MAXMEM                       |
 510: 0000: !       --------------------------------------------------------
 511: 0000: !  24   |       FLAGS               |   USER        |  GROUP   |
 512: 0000: !       --------------------------------------------------------
 513: 0000: !  28   |                         PARENT                       |
 514: 0000: !       --------------------------------------------------------
 515: 0000: !  32   |                         EVENTS                       |
 516: 0000: !       --------------------------------------------------------
 517: 0000: !  36   |                         CODE                         |
 518: 0000: !       --------------------------------------------------------
 519: 0000: !  40   |                         CSIZE                        |
 520: 0000: !       --------------------------------------------------------
 521: 0000: !  44   |                         DATA                         |
 522: 0000: !       --------------------------------------------------------
 523: 0000: !  48   |                         DSIZE                        |
 524: 0000: !       --------------------------------------------------------
 525: 0000: !  52   |                         HEAP                         |
 526: 0000: !       --------------------------------------------------------
 527: 0000: !  56   |                         HSIZE                        |
 528: 0000: !       --------------------------------------------------------
 529: 0000: !
 530: 0000: !       PID   Process ID
 531: 0000: !       FID  Process's Family ID
 532: 0000: !       CID   Physical Console Device Number
 533: 0000: !       VCID  Process's Virtual Console Number
 534: 0000: !       NAME  Process Name (Application Running)
 535: 0000: ! STATE    Process State (0-Run, 1-Waiting, 2-Terminating)
 536: 0000: ! PRIOR    Priority
 537: 0000: !       MAXMEM  Maximum Memory Allowed
 538: 0000: !       FLAGS  Bit 0 (1-System Process, 0-User Process)
 539: 0000: !   Bit 1 (1-Locked in Memory, 0-Swappable)
 540: 0000: !   Bit 2 (1-Running in SWI context, 0-Running in main context)
 541: 0000: !   Bit 3 (1-Superuser Process,0-Not a Superuser Process)
 542: 0000: ! USER  User Number
 543: 0000: ! GROUP  Group Number
 544: 0000: !       PARENT   Parent Process ID
 545: 0000: !       EVENTS   Bit Map of events that have completed but not retrieved
 546: 0000: !       CODE  Start of code area in user space
 547: 0000: ! CSIZE  Size in bytes of code area
 548: 0000: !       DATA  Start of data area in user space
 549: 0000: ! DSIZE  Size in bytes of data area
 550: 0000: !       HEAP  Start of heap area in user space
 551: 0000: ! HSIZE  Size in bytes of heap area
 552: 0000: !
 553: 0000:  integer*4 srchproc
 554: 0000: 
 555: 0000:  string  proc.name$   ! process name to start
 556: 0000:        ! search (10 bytes max)
 557: 0000:        ! Wild cards and logical
 558: 0000:        ! names supported.
 559: 0000: 
 560: 0000:  string  ptbl.buffer$   ! must be initialized
 561: 0000:        ! to 60 bytes.  Contains
 562: 0000:        ! all of process info
 563: 0000:        ! Initialize to nulls
 564: 0000:        ! each time a new
 565: 0000:        ! process name is used.
 566: 0000: 
 567: 0000: end function
 568: 0000: 
 569: 0000: function cconstat(timeout) external       ! function similar
 570: 0000:                                               ! to BASIC constat%
 571: 0000:  integer*2 cconstat   ! waits for either a
 572: 0000:  integer*4 timeout    ! key being hit or
 573: 0000:        ! the timer expiring
 574: 0000:        ! before returning
 575: 0000:        ! returns:
 576: 0000:        !   -1 error
 577: 0000:        !    0 timer expired
 578: 0000:        !    x scan code of
 579: 0000:        !      key hit
 580: 0000: end function
 581: 0000: 
 582: 0000: function disksize(disk.name$) external   ! function to find
 583: 0000:        ! the total size of
 584: 0000:  integer*4 disksize   ! the specified disk
 585: 0000:  string  disk.name$   ! name (e.g. "h0:")
 586: 0000:        ! if return value is
 587: 0000:        ! negative, error
 588: 0000: end function      ! was received
 589: 0000: 
 590: 0000: 
 591: 0000: 
 592: 0000: \***********************************************************************
 593: 0000: \*
 594: 0000: \* FUNCTION: ITMDL.SET
 595: 0000: \* Sets Item-Deals File Variables
 596: 0000: \*
 597: 0000: \***********************************************************************
 598: 0000: FUNCTION ITMDL.SET PUBLIC
 599: 0014: 
 600: 0014:     INTEGER*1 ITMDL.SET
 601: 0014: 
 602: 0014:     ! Set Boolean flag values (just in case!)                               !CMW
 603: 0014:     TRUE = -1                                                               !CMW
 604: 001c:     FALSE = 0                                                               !CMW
 605: 0024: 
 606: 0024:     ITMDL.SET = 1                     ! Error
 607: 0028: 
 608: 0028:     ITMDL.DEAL.COUNT%         = 0       ! Count of Deal Number - List ID
 609: 0031:     ITMDL.DEAL.MAX%           = 20      ! Max deals per ITMDL record        !HMW
 610: 003a:     ITMDL.DEALID.START.POS%   = 13      ! Deal ID Start Position            !GMW
 611: 0042:     ITMDL.DEALNUM.LID.LEN%    = 3       ! Deal Number and List ID Length
 612: 004a:     ITMDL.FILE.NAME$          = "ITMDL" ! Item-Deals Logical file name
 613: 0059: !   ITMDL.MAXDEALS.PER.ITEM%  = 1980    ! Max number of deals per item      !HMW
 614: 0059:     ITMDL.MAX.ITEMS.PER.DEAL% = 40000   ! Max number of items per deal      !GMW
 615: 0062:     ITMDL.REC.MAX%            = 99      ! Max ITMDL records per item        !HMW
 616: 0067:     ITMDL.RECL%               = 72      ! Item-Deal File Record Length
 617: 006f:     ITMDL.REPORT.NUM%         = 235     ! Report Number
 618: 0078:     ITMDL.RESERVED$           = STRING$(7,CHR$(0))! Reserved                !GMW
 619: 008f:     NULL.DEAL.NUM.LID$        = PACK$("000000") ! Null deal/list ID         !GMW
 620: 00a1: 
 621: 00a1:     ITMDL.DEAL.NUM.LID.20$  = STRING$(ITMDL.DEALNUM.LID.LEN% *          \   !CMW
 622: 00c6:                               ITMDL.DEAL.MAX%,CHR$(0)) ! Set to Null        !CMW
 623: 00c6: 
 624: 00c6:     ! Calculate the maximum number of deals per item that can possibly      !HMW
 625: 00c6:     ! occur on the ITMDL file (in reality, this is limited at present       !HMW
 626: 00c6:     ! to 40 deals per item)                                                 !HMW
 627: 00c6:     ITMDL.MAXDEALS.PER.ITEM% = ITMDL.DEAL.MAX% * ITMDL.REC.MAX%             !HMW
 628: 00de:     
 629: 00de:     ITMDL.ALL.DEAL.NUM.LIST.ID$ = ""
 630: 00ed: 
 631: 00ed:     ITMDL.SET = 0                     ! No Error
 632: 00f1: 
 633: 00f1: END FUNCTION
 634: 0100: 
 635: 0100: \***********************************************************************
 636: 0100: \*
 637: 0100: \* FUNCTION: READ.ITMDL.REC
 638: 0100: \* Physical Read of Item-Deal File and populate string to holds all of
 639: 0100: \* an items deal-numbers-list-ID pairs accumulated from successive reads
 640: 0100: \* of all of an items ITMDL records
 641: 0100: \*
 642: 0100: \***********************************************************************
 643: 0100: FUNCTION READ.ITMDL.REC
 644: 0114: 
 645: 0114:     INTEGER*1 READ.ITMDL.REC
 646: 0114: 
 647: 0114:     ON ERROR GOTO READ.ITMDL.REC.ERROR                                      !CMW
 648: 0121: 
 649: 0121:     READ.ITMDL.REC = 1  ! Error
 650: 0125: 
 651: 0125:     ITMDL.DEAL.START% = 1
 652: 012b: 
 653: 012b:     IF END # ITMDL.SESS.NUM% THEN READ.ITMDL.REC.IF.END
 654: 013f:     READ FORM "T5,C1,C7,C60"; #ITMDL.SESS.NUM%                          \
 655: 0180:                     KEY ITMDL.ITEM.REC.KEY$;                            \
 656: 0180:                         ITMDL.EXCLUSION$,                               \
 657: 0180:                         ITMDL.RESERVED$,                                \
 658: 0180:                         ITMDL.DEAL.NUM.LID.20$
 659: 0180: 
 660: 0180:     ! Checking whether ITMDL.DEAL.NUM.LID.20$ holds Deal Number and
 661: 0180:     ! List ID for 20 times per record
 662: 0180:     WHILE ITMDL.DEAL.START% <= ITMDL.DEAL.MAX%
 663: 0183: 
 664: 0183:         ! Get next deal number/list ID                                      !CMW
 665: 0183:         ITMDL.DEAL.NUM.LID$ = MID$(ITMDL.DEAL.NUM.LID.20$,              \   !CMW
 666: 01b7:             (1 + ((ITMDL.DEAL.START% - 1) * ITMDL.DEALNUM.LID.LEN%)),   \   !CMW
 667: 01b7:             ITMDL.DEALNUM.LID.LEN%)                                         !CMW
 668: 01b7: 
 669: 01b7:         IF ITMDL.DEAL.NUM.LID$ <> NULL.DEAL.NUM.LID$ THEN BEGIN             !CMW
 670: 01ce: 
 671: 01ce:             ! Store ITMDL.DEAL.NUM.LID.20$ without null values to
 672: 01ce:             ! ITMDL.ALL.DEAL.NUM.LIST.ID$
 673: 01ce: 
 674: 01ce:             ITMDL.ALL.DEAL.NUM.LIST.ID$ =                               \
 675: 01ef:                 ITMDL.ALL.DEAL.NUM.LIST.ID$ +                           \
 676: 01ef:                 ITMDL.DEAL.NUM.LID$                                         !CMW
 677: 01ef: 
 678: 01ef:             ! Increment counter
 679: 01ef:             ITMDL.DEAL.START% = ITMDL.DEAL.START% + 1
 680: 01f5:         ENDIF ELSE BEGIN
 681: 01f5:             ITMDL.DEAL.START% = ITMDL.DEAL.MAX% + 1
 682: 0200:         ENDIF
 683: 0200:     WEND
 684: 0210: 
 685: 0210:     READ.ITMDL.REC = 0  ! No error
 686: 0214: 
 687: 0214: EXIT.FUNCTION:                                                              !CMW
 688: 0214: 
 689: 0214:     EXIT FUNCTION
 690: 0216: 
 691: 0216: READ.ITMDL.REC.IF.END:
 692: 0216: 
 693: 0216:     FILE.OPERATION$     = "R" ! Read
 694: 0225:     CURRENT.REPORT.NUM% = ITMDL.REPORT.NUM%
 695: 0233:     CURRENT.CODE$       = ITMDL.ITEM.REC.KEY$
 696: 0246: 
 697: 0246: READ.ITMDL.REC.ERROR:                                                       !CMW
 698: 0246: 
 699: 0246:     RESUME EXIT.FUNCTION                                                    !CMW
 700: 0255: 
 701: 0255: END FUNCTION
 702: 0264: 
 703: 0264: \***********************************************************************
 704: 0264: \*
 705: 0264: \* FUNCTION: READ.ITMDL
 706: 0264: \* Read Item-Deal File. This function will populate ITMDL.ALL.DEAL.NUM.
 707: 0264: \* LIST.ID$ and ITMDL.DEAL.COUNT% variables to be used for the calling
 708: 0264: \* program
 709: 0264: \*
 710: 0264: \***********************************************************************
 711: 0264: FUNCTION READ.ITMDL PUBLIC
 712: 0278: 
 713: 0278:     INTEGER*1 READ.ITMDL
 714: 0278: 
 715: 0278:     ON ERROR GOTO READ.ITMDL.ERROR                                          !CMW
 716: 0285: 
 717: 0285:     READ.ITMDL = 1  ! Error
 718: 0289: 
 719: 0289:     ITMDL.DEAL.COUNT% = 0
 720: 0292:     ITMDL.REC.NUM%    = 1       ! Read first record from ITMDL
 721: 0298: 
 722: 0298:     ITMDL.ALL.DEAL.NUM.LIST.ID$ = ""
 723: 02a7: 
 724: 02a7:     ! Set Item Record Number
 725: 02a7:     ITMDL.REC.NUM$ = PACK$(RIGHT$("00" + STR$(ITMDL.REC.NUM%),2))
 726: 02ea: 
 727: 02ea:     !Set Item Key from Item Code and Record Number
 728: 02ea:     ITMDL.ITEM.REC.KEY$ = ITMDL.ITEM.CODE$ + ITMDL.REC.NUM$
 729: 030c: 
 730: 030c:     ! Read first record
 731: 030c:     ITMDL.RC% = READ.ITMDL.REC  ! Populates ITMDL.ALL.DEAL.NUM.LIST.ID$
 732: 0313: 
 733: 0313:     ! First record expected but not found
 734: 0313:     IF ITMDL.RC% <> 0 THEN BEGIN
 735: 031a:         EXIT FUNCTION  ! Item has not records and so no more deals
 736: 031d:     ENDIF
 737: 031d: 
 738: 031d:     ! If ITMDL final deal entry is not in use, then there are no
 739: 031d:     ! more deals for this item so exit function
 740: 031d:     IF RIGHT$(ITMDL.DEAL.NUM.LID.20$,                                   \   !CMW
 741: 0350:            ITMDL.DEALNUM.LID.LEN%) = NULL.DEAL.NUM.LID$ THEN BEGIN          !CMW
 742: 0350:         ITMDL.DEAL.COUNT% = LEN(ITMDL.ALL.DEAL.NUM.LIST.ID$) /          \
 743: 0374:                             ITMDL.DEALNUM.LID.LEN%
 744: 0374:         READ.ITMDL = 0
 745: 0378:         EXIT FUNCTION
 746: 037b:     ENDIF
 747: 037b: 
 748: 037b:     ! Read second record
 749: 037b:     ITMDL.REC.NUM% = ITMDL.REC.NUM% + 1
 750: 037f: 
 751: 037f:     WHILE ITMDL.REC.NUM% <= ITMDL.REC.MAX%
 752: 0382:         ! Set Item Record Number
 753: 0382:         ITMDL.REC.NUM$ = PACK$(RIGHT$("00" + STR$(ITMDL.REC.NUM%),2))
 754: 03c5: 
 755: 03c5:         ! Set Item Key from Item Code and Record Number
 756: 03c5:         ITMDL.ITEM.REC.KEY$ = ITMDL.ITEM.CODE$ + ITMDL.REC.NUM$
 757: 03e7: 
 758: 03e7:         ! Read next record
 759: 03e7:         ! Populate ITMDL.ALL.DEAL.NUM.LIST.ID$
 760: 03e7:         ITMDL.RC% = READ.ITMDL.REC
 761: 03ee: 
 762: 03ee:         ! Next record not found.
 763: 03ee:         IF ITMDL.RC% <> 0 THEN BEGIN
 764: 03f5:             ITMDL.DEAL.COUNT% = LEN(ITMDL.ALL.DEAL.NUM.LIST.ID$) /      \
 765: 0419:                                 ITMDL.DEALNUM.LID.LEN%
 766: 0419:             READ.ITMDL = 0
 767: 041d:             EXIT FUNCTION
 768: 0420:         ENDIF
 769: 0420:         ! If ITMDL final deal entry is not in use, then there are no
 770: 0420:         ! more deals for this item so exit function
 771: 0420:         IF RIGHT$(ITMDL.DEAL.NUM.LID.20$,                               \   !CMW
 772: 0453:                ITMDL.DEALNUM.LID.LEN%) = NULL.DEAL.NUM.LID$ THEN BEGIN      !CMW
 773: 0453:             ITMDL.DEAL.COUNT% = LEN(ITMDL.ALL.DEAL.NUM.LIST.ID$) /      \
 774: 0477:                                 ITMDL.DEALNUM.LID.LEN%
 775: 0477:             READ.ITMDL = 0
 776: 047b:             EXIT FUNCTION
 777: 047d:         ENDIF
 778: 047d: 
 779: 047d:         ! Increment record count
 780: 047d:         ITMDL.REC.NUM% = ITMDL.REC.NUM% + 1
 781: 0481: 
 782: 0481:     WEND
 783: 048e: 
 784: 048e:     ITMDL.DEAL.COUNT% = LEN(ITMDL.ALL.DEAL.NUM.LIST.ID$) /              \
 785: 04b2:                         ITMDL.DEALNUM.LID.LEN%
 786: 04b2: 
 787: 04b2:     ! Set return code to zero on successful completion
 788: 04b2:     READ.ITMDL = 0
 789: 04b6: 
 790: 04b6: EXIT.FUNCTION:                                                              !CMW
 791: 04b6: 
 792: 04b6:     EXIT FUNCTION
 793: 04b8: 
 794: 04b8: READ.ITMDL.ERROR:                                                           !CMW
 795: 04b8: 
 796: 04b8:     RESUME EXIT.FUNCTION                                                    !CMW
 797: 04c7: 
 798: 04c7: END FUNCTION
 799: 04d6: 
 800: 04d6: \***********************************************************************
 801: 04d6: \*
 802: 04d6: \* FUNCTION: WRITE.ITMDL.REC
 803: 04d6: \* Physical write to Item-Deal File with string that holds all of
 804: 04d6: \* an items deal-numbers-list-ID pairs
 805: 04d6: \*
 806: 04d6: \***********************************************************************
 807: 04d6: FUNCTION WRITE.ITMDL.REC
 808: 04ea: 
 809: 04ea:     INTEGER*1 WRITE.ITMDL.REC
 810: 04ea: 
 811: 04ea:     ON ERROR GOTO WRITE.ITMDL.REC.ERROR
 812: 04f7: 
 813: 04f7:     WRITE.ITMDL.REC = 1 ! Error
 814: 04fb: 
 815: 04fb:     ITMDL.DEAL.NUM.LID.20$  = ""
 816: 0508: 
 817: 0508:     ! Populate ITMDL.DEAL.NUM.LID.20$ variable
 818: 0508:     WHILE ITMDL.DEAL.START% <= ITMDL.DEAL.END% AND                      \   !EMW
 819: 050a:           ITMDL.DEAL.START% <= ITMDL.DEALS.TO.WRITE%                        !EMW
 820: 050a: 
 821: 050a:         ! Get next deal number/list ID                                      !CMW
 822: 050a:         ITMDL.DEAL.NUM.LID$ = MID$(ITMDL.ALL.DEAL.NUM.LIST.ID$,         \   !CMW
 823: 0541:             (1 + ((ITMDL.DEAL.START% - 1) * ITMDL.DEALNUM.LID.LEN%)),   \   !CMW
 824: 0541:             ITMDL.DEALNUM.LID.LEN%)                                         !CMW
 825: 0541: 
 826: 0541:         IF ITMDL.DEAL.NUM.LID$ <> NULL.DEAL.NUM.LID$ THEN BEGIN             !CMW
 827: 0558: 
 828: 0558:             ! Store ITMDL.DEAL.NUM.LID.20$ without null values from
 829: 0558:             ! ITMDL.ALL.DEAL.NUM.LIST.ID$
 830: 0558: 
 831: 0558:             ITMDL.DEAL.NUM.LID.20$ =                                    \
 832: 0574:                 ITMDL.DEAL.NUM.LID.20$ +                                \
 833: 0574:                 ITMDL.DEAL.NUM.LID$                                         !CMW
 834: 0574: 
 835: 0574:             ! Increment counter
 836: 0574:             ITMDL.DEAL.START% = ITMDL.DEAL.START% + 1
 837: 0578:         ENDIF
 838: 0578:     WEND
 839: 059a: 
 840: 059a:     ITMDL.DEAL.END% =  ITMDL.DEAL.START% + ITMDL.DEAL.MAX% - 1
 841: 05ac: 
 842: 05ac:     ! Padding zeros to ITMDL.DEAL.NUM.LID.20% if the string doesn't
 843: 05ac:     ! have 20 deals in it.
 844: 05ac:     ITMDL.DEAL.NUM.LID.20$ =                                           \    !CMW
 845: 0605:         LEFT$(ITMDL.DEAL.NUM.LID.20$ +                                 \    !CMW
 846: 0605:         STRING$(ITMDL.DEAL.MAX%,NULL.DEAL.NUM.LID$),                   \    !CMW
 847: 0605:         ITMDL.DEAL.MAX% * ITMDL.DEALNUM.LID.LEN%)                           !CMW
 848: 0605: 
 849: 0605:     IF END # ITMDL.SESS.NUM% THEN WRITE.ITMDL.IF.END
 850: 0619:     WRITE FORM "C3,C1,C1,C7,C60"; #ITMDL.SESS.NUM%;                    \
 851: 0675:                                  ITMDL.ITEM.CODE$,                     \
 852: 0675:                                  ITMDL.REC.NUM$,                       \
 853: 0675:                                  ITMDL.EXCLUSION$,                     \
 854: 0675:                                  ITMDL.RESERVED$,                      \
 855: 0675:                                  ITMDL.DEAL.NUM.LID.20$
 856: 0675: 
 857: 0675:     WRITE.ITMDL.REC = 0 ! No error
 858: 0679: 
 859: 0679: EXIT.FUNCTION:                                                              !CMW
 860: 0679: 
 861: 0679:     EXIT FUNCTION
 862: 067b: 
 863: 067b: WRITE.ITMDL.IF.END:
 864: 067b: 
 865: 067b:     FILE.OPERATION$     = "W" ! Write
 866: 068a:     CURRENT.REPORT.NUM% = ITMDL.REPORT.NUM%
 867: 0698:     CURRENT.CODE$       = ITMDL.ITEM.REC.KEY$
 868: 06ab: 
 869: 06ab:     EXIT FUNCTION
 870: 06ad: 
 871: 06ad: WRITE.ITMDL.REC.ERROR:                                                      !CMW
 872: 06ad: 
 873: 06ad:     RESUME EXIT.FUNCTION                                                    !CMW
 874: 06bc: 
 875: 06bc: END FUNCTION
 876: 06cb: 
 877: 06cb: \***********************************************************************
 878: 06cb: \*
 879: 06cb: \* FUNCTION: WRITE.ITMDL
 880: 06cb: \* Write Item-Deal File. The calling program will populate
 881: 06cb: \* ITMDL.ALL.DEAL.NUM.LIST.ID$ variables and all ITMDL file variables.
 882: 06cb: \* Calculate the records to be written to the file and write to ITMDL
 883: 06cb: \* file. Delete remaining records from the file
 884: 06cb: \*
 885: 06cb: \***********************************************************************
 886: 06cb: FUNCTION WRITE.ITMDL PUBLIC
 887: 06df: 
 888: 06df:     INTEGER*1 WRITE.ITMDL
 889: 06df: 
 890: 06df:     ON ERROR GOTO WRITE.ITMDL.ERROR                                         !CMW
 891: 06ec: 
 892: 06ec:     WRITE.ITMDL = 1 ! Error
 893: 06f0: 
 894: 06f0:     ITMDL.DEAL.END%   = ITMDL.DEAL.MAX%
 895: 06fa:     ITMDL.DEAL.START% = 1
 896: 0700:     ITMDL.RESERVED$   = STRING$(7,CHR$(0)) ! Null 7 bytes
 897: 0717: 
 898: 0717:     ! Number of deals to write to ITMDL file
 899: 0717:     ITMDL.DEALS.TO.WRITE% = LEN(ITMDL.ALL.DEAL.NUM.LIST.ID$) /          \
 900: 0737:                             ITMDL.DEALNUM.LID.LEN%
 901: 0737: 
 902: 0737:     ! Number of records in which the deals will be written
 903: 0737:     ITMDL.RECS.TO.WRITE%  = (ITMDL.DEALS.TO.WRITE% +                    \
 904: 074e:                              ITMDL.DEAL.MAX% - 1) / ITMDL.DEAL.MAX%
 905: 074e: 
 906: 074e:     ITMDL.REC.NUM% = 1
 907: 0754: 
 908: 0754:     WHILE ITMDL.REC.NUM% <= ITMDL.RECS.TO.WRITE%
 909: 0756:         ! Set Item Record Number
 910: 0756:         ITMDL.REC.NUM$ = PACK$(RIGHT$("00" + STR$(ITMDL.REC.NUM%),2))
 911: 0799: 
 912: 0799:         !Set Item Key from Item Code and Record Number
 913: 0799:         ITMDL.ITEM.REC.KEY$ = ITMDL.ITEM.CODE$ + ITMDL.REC.NUM$
 914: 07bb: 
 915: 07bb:         ! Write ITMDL record
 916: 07bb:         ! Fields are populated from the calling program
 917: 07bb:         ! to write to ITMDL file
 918: 07bb:         ITMDL.RC% = WRITE.ITMDL.REC
 919: 07c2: 
 920: 07c2:         ! Return code not set to zero
 921: 07c2:         IF ITMDL.RC% <> 0 THEN BEGIN
 922: 07c9:             EXIT FUNCTION
 923: 07cc:         ENDIF
 924: 07cc: 
 925: 07cc:         ! Increment record count
 926: 07cc:         ITMDL.REC.NUM% = ITMDL.REC.NUM% + 1
 927: 07d0: 
 928: 07d0:     WEND
 929: 07dd: 
 930: 07dd:     WHILE ((ITMDL.REC.NUM% = ITMDL.RECS.TO.WRITE%)  OR                  \
 931: 07e0:           (ITMDL.REC.NUM% <= ITMDL.REC.MAX% ))
 932: 07e0:         ! Set Item Record Number
 933: 07e0:         ITMDL.REC.NUM$ = PACK$(RIGHT$("00" + STR$(ITMDL.REC.NUM%),2))
 934: 0823: 
 935: 0823:         !Set Item Key from Item Code and Record Number
 936: 0823:         ITMDL.ITEM.REC.KEY$ = ITMDL.ITEM.CODE$ + ITMDL.REC.NUM$
 937: 0845: 
 938: 0845:         !Delete the remaining records after writing to the file
 939: 0845:         IF END #ITMDL.SESS.NUM% THEN DEL.ITMDL.ERROR
 940: 0859:         DELREC ITMDL.SESS.NUM%; ITMDL.ITEM.REC.KEY$
 941: 086d: 
 942: 086d:         ! Increment record count
 943: 086d:         ITMDL.REC.NUM% = ITMDL.REC.NUM% + 1
 944: 0871:     WEND
 945: 0894:     ! Set return code to zero on successful completion
 946: 0894:     WRITE.ITMDL = 0
 947: 0898: 
 948: 0898: EXIT.FUNCTION:                                                              !CMW
 949: 0898: 
 950: 0898:     EXIT FUNCTION
 951: 089a: 
 952: 089a: DEL.ITMDL.ERROR:
 953: 089a: 
 954: 089a:     ! Set return code to zero on successful completion
 955: 089a:     WRITE.ITMDL = 0
 956: 089e: 
 957: 089e: EXIT FUNCTION
 958: 08a0: 
 959: 08a0: WRITE.ITMDL.ERROR:                                                          !CMW
 960: 08a0: 
 961: 08a0:     RESUME EXIT.FUNCTION                                                    !CMW
 962: 08af: 
 963: 08af: END FUNCTION
 964: 08be: 
 965: 08be: \***********************************************************************
 966: 08be: \*
 967: 08be: \* FUNCTION: SPLIT.READ.ITMDL.DIRECT
 968: 08be: \* Calling Program uses PROCESS.KEYED.FILE to open ITMDL in direct mode
 969: 08be: \* and gets full record into ITMDL.RECORD$ and split the records as
 970: 08be: \* populated by READ.ITMDL.
 971: 08be: \* Programs calling this function will only pass if the item is first(or
 972: 08be: \* only record) in ITMDL and reject any others
 973: 08be: \* Function will perform further physical reads of ITMDL to obtain all
 974: 08be: \* items deal data and populate string ITMDL.ALL.DEAL.NUM.LIST.ID$
 975: 08be: \*
 976: 08be: \***********************************************************************
 977: 08be: FUNCTION SPLIT.READ.ITMDL.DIRECT(ITMDL.RECORD$) PUBLIC
 978: 08d7:     INTEGER*1 SPLIT.READ.ITMDL.DIRECT
 979: 08d7:     INTEGER*2 DEAL.POS%                                                     !GMW
 980: 08d7:     STRING DEAL.NUM.LID$                                                    !GMW
 981: 08d7:     STRING ITMDL.RECORD$
 982: 08d7: 
 983: 08d7:     SPLIT.READ.ITMDL.DIRECT = 1 ! Error
 984: 08db: 
 985: 08db:     ON ERROR GOTO SPLIT.READ.ITMDL.DIRECT.ERROR                             !CMW
 986: 08e8: 
 987: 08e8:     ITMDL.DEAL.START% = 1
 988: 08ee:     ITMDL.ALL.DEAL.NUM.LIST.ID$ = ""
 989: 08fd:     ITMDL.DEAL.NUM.LID.20$      = ""
 990: 090a: 
 991: 090a:     ITMDL.ITEM.REC.KEY$ = MID$(ITMDL.RECORD$,1,4)
 992: 0922:     ITMDL.ITEM.CODE$    = MID$(ITMDL.RECORD$,1,3)
 993: 093c:     ITMDL.REC.NUM$      = MID$(ITMDL.RECORD$,4,1)
 994: 0956:     ITMDL.REC.NUM%      = VAL(UNPACK$(ITMDL.REC.NUM$))
 995: 0973: 
 996: 0973:     ! Reject any ITMDL records that are not the first(or only)
 997: 0973:     ! record for the item
 998: 0973:     IF ITMDL.REC.NUM% <> 1 THEN BEGIN
 999: 0978:         EXIT FUNCTION
1000: 097b:     ENDIF
1001: 097b: 
1002: 097b:     ! Populate remaining ITMDL variables from ITMDL.RECORD
1003: 097b:     ITMDL.EXCLUSION$ = MID$(ITMDL.RECORD$,5,1)
1004: 0995:     ITMDL.RESERVED$  = MID$(ITMDL.RECORD$,6,7)
1005: 09ad: 
1006: 09ad:     ! Populate ITMDL.ALL.DEAL.NUM.LIST.ID$ and ITMDL.DEAL.NUM.LID.20$
1007: 09ad:     ! from ITMDL.RECORD$ bytes 13 to 72
1008: 09ad:     ! which holds the Deal Number List ID value
1009: 09ad: 
1010: 09ad:     ! Initialise deal number/list ID                                        !GMW
1011: 09ad:     DEAL.NUM.LID$ = STRING$(ITMDL.DEALNUM.LID.LEN%,CHR$(0))                 !GMW
1012: 09cb:     WHILE ITMDL.DEAL.START% <= ITMDL.DEAL.MAX%
1013: 09ce: 
1014: 09ce:         ! Get index position of the next deal number/list ID                !GMW
1015: 09ce:         DEAL.POS% = ((ITMDL.DEAL.START% - 1) *                          \   !GMW
1016: 09f1:                     ITMDL.DEALNUM.LID.LEN%) +                           \   !GMW
1017: 09f1:                     ITMDL.DEALID.START.POS%                                 !GMW
1018: 09f1:                                                                             !GMW
1019: 09f1:         ! Get the next deal number/list ID                                  !GMW
1020: 09f1:         CALL EXTRACTS(ITMDL.RECORD$,                                    \   !GMW
1021: 0a08:                       DEAL.NUM.LID$,                                    \   !GMW
1022: 0a08:                       DEAL.POS%)                                            !GMW
1023: 0a08:         
1024: 0a08:         ! IF deal number/list ID NOT found                                  !GMW
1025: 0a08:         IF DEAL.NUM.LID$ <> NULL.DEAL.NUM.LID$ THEN BEGIN                   !GMW
1026: 0a1f:                                                                             !GMW
1027: 0a1f:             ! Add deal number/list ID to the current deals list             !GMW
1028: 0a1f:             ITMDL.ALL.DEAL.NUM.LIST.ID$ =                               \   !GMW
1029: 0a40:                 ITMDL.ALL.DEAL.NUM.LIST.ID$ + DEAL.NUM.LID$                 !GMW
1030: 0a40:                                                                             !GMW
1031: 0a40:             ! Add deal number/list ID to the deals list                     !GMW
1032: 0a40:             ! for this record                                               !GMW
1033: 0a40:             ITMDL.DEAL.NUM.LID.20$ =                                    \   !GMW
1034: 0a5c:                 ITMDL.DEAL.NUM.LID.20$ + DEAL.NUM.LID$                      !GMW
1035: 0a5c: 
1036: 0a5c:             ITMDL.DEAL.START% = ITMDL.DEAL.START% + 1
1037: 0a62:         ENDIF ELSE BEGIN
1038: 0a62:             ITMDL.DEAL.START% = ITMDL.DEAL.MAX% + 1
1039: 0a6d:         ENDIF
1040: 0a6d:     WEND
1041: 0a7d: 
1042: 0a7d:     ! Read second record
1043: 0a7d:     ITMDL.REC.NUM% = ITMDL.REC.NUM% + 1
1044: 0a81: 
1045: 0a81:     WHILE ITMDL.REC.NUM% <= ITMDL.REC.MAX%
1046: 0a84:         ! Set Item Record Number
1047: 0a84:         ITMDL.REC.NUM$ = PACK$(RIGHT$("00" + STR$(ITMDL.REC.NUM%),2))
1048: 0ac7: 
1049: 0ac7:         ! Set Item Key from Item Code and Record Number
1050: 0ac7:         ITMDL.ITEM.REC.KEY$ = ITMDL.ITEM.CODE$ + ITMDL.REC.NUM$
1051: 0ae9: 
1052: 0ae9:         ! Read next record
1053: 0ae9:         ! Populate ITMDL.ALL.DEAL.NUM.LIST.ID$
1054: 0ae9:         ITMDL.RC% = READ.ITMDL.REC
1055: 0af0: 
1056: 0af0:         ! Next record not found.
1057: 0af0:         IF ITMDL.RC% <> 0 THEN BEGIN
1058: 0af7:             ITMDL.DEAL.COUNT% = LEN(ITMDL.ALL.DEAL.NUM.LIST.ID$) /      \
1059: 0b1b:                                 ITMDL.DEALNUM.LID.LEN%
1060: 0b1b:             SPLIT.READ.ITMDL.DIRECT = 0 ! Item has no further records
1061: 0b1f:             EXIT FUNCTION
1062: 0b22:         ENDIF
1063: 0b22: 
1064: 0b22:         ! If ITMDL final deal entry is not in use, then there are no
1065: 0b22:         ! more deals for this item so exit function
1066: 0b22:         IF RIGHT$(ITMDL.DEAL.NUM.LID.20$,ITMDL.DEALNUM.LID.LEN%) =      \   !CMW
1067: 0b55:                NULL.DEAL.NUM.LID$ THEN BEGIN                                !CMW
1068: 0b55:             ITMDL.DEAL.COUNT% = LEN(ITMDL.ALL.DEAL.NUM.LIST.ID$) /      \
1069: 0b79:                                 ITMDL.DEALNUM.LID.LEN%
1070: 0b79:             SPLIT.READ.ITMDL.DIRECT = 0
1071: 0b7d:             EXIT FUNCTION
1072: 0b7f:         ENDIF
1073: 0b7f: 
1074: 0b7f:         ! Increment record count
1075: 0b7f:         ITMDL.REC.NUM% = ITMDL.REC.NUM% + 1
1076: 0b83: 
1077: 0b83:     WEND
1078: 0b90:     ITMDL.DEAL.COUNT% = LEN(ITMDL.ALL.DEAL.NUM.LIST.ID$) /              \
1079: 0bb4:                             ITMDL.DEALNUM.LID.LEN%
1080: 0bb4:     SPLIT.READ.ITMDL.DIRECT = 0 ! No Error
1081: 0bb8: 
1082: 0bb8: EXIT.FUNCTION:                                                              !CMW
1083: 0bb8: 
1084: 0bb8:     EXIT FUNCTION
1085: 0bba: 
1086: 0bba: SPLIT.READ.ITMDL.DIRECT.ERROR:                                              !CMW
1087: 0bba: 
1088: 0bba:     RESUME EXIT.FUNCTION                                                    !CMW
1089: 0bc9: 
1090: 0bc9: END FUNCTION
1091: 0bdd: 
1092: 0bdd: \***********************************************************************
1093: 0bdd: \*
1094: 0bdd: \* SubProgram: ITMDL.SAVE
1095: 0bdd: \* Save ITMDL field variables. This sub-program is in use for PSBF42
1096: 0bdd: \* program which when calls ITMDL.SAVE will save the ITMDL data
1097: 0bdd: \* The parameter SAVE$ holds the value and passes it back to PSBF42
1098: 0bdd: \*
1099: 0bdd: \***********************************************************************
1100: 0bdd: SUB ITMDL.SAVE(SAVE$) PUBLIC
1101: 0bf1:     STRING SAVE$
1102: 0bf1: 
1103: 0bf1:     SAVE$ = ITMDL.ITEM.CODE$ + ITMDL.REC.NUM$ + ITMDL.EXCLUSION$ +      \
1104: 0c2f:             ITMDL.RESERVED$  + ITMDL.DEAL.NUM.LID.20$
1105: 0c2f: 
1106: 0c2f: END SUB
1107: 0c3b: 
1108: 0c3b: \***********************************************************************
1109: 0c3b: \*
1110: 0c3b: \* Sub-Program: ITMDL.RESTORE
1111: 0c3b: \* Restore ITMDL file variables. This function is called after
1112: 0c3b: \* ITMDL.SAVE and prior to function exit. It is used in PSBF42
1113: 0c3b: \*
1114: 0c3b: \***********************************************************************
1115: 0c3b: SUB ITMDL.RESTORE(RESTORE$) PUBLIC
1116: 0c4f:     STRING RESTORE$
1117: 0c4f: 
1118: 0c4f:     ITMDL.ITEM.REC.KEY$    = MID$(RESTORE$,1,4)
1119: 0c6b:     ITMDL.ITEM.CODE$       = MID$(RESTORE$,1,3)
1120: 0c89:     ITMDL.REC.NUM$         = MID$(RESTORE$,4,1)
1121: 0ca7:     ITMDL.EXCLUSION$       = MID$(RESTORE$,5,1)
1122: 0cc5:     ITMDL.RESERVED$        = MID$(RESTORE$,6,7)
1123: 0ce1:     ITMDL.DEAL.NUM.LID.20$ = MID$(RESTORE$,13,LEN(RESTORE$))                !CMW
1124: 0d0c: 
1125: 0d0c: END SUB
1126: 0d18: 
1127: 0d18: \***************************************************************************!CMW
1128: 0d18: \***                                                                        !CMW
1129: 0d18: \***   ITMDL.ADD.DEAL.ITEM                                                  !CMW
1130: 0d18: \***                                                                        !CMW
1131: 0d18: \***   Add an individual item to the Item Deal file (ITMDL)                 !CMW
1132: 0d18: \***                                                                        !CMW
1133: 0d18: \***************************************************************************!CMW
1134: 0d18:                                                                             !CMW
1135: 0d18: FUNCTION ITMDL.ADD.DEAL.ITEM(DEAL.NUMBER$,                              \   !DMW
1136: 0d18:                              LIST.NUMBER%,                              \   !DMW
1137: 0d18:                              ITEM.CODE$,                                \   !DMW
1138: 0d18:                              EXCLUSION.FLAG%) PUBLIC                        !DMW
1139: 0d36:                                                                             !CMW
1140: 0d36:     INTEGER*1   DEAL.FOUND                                                  !CMW
1141: 0d36:     INTEGER*1   END.OF.DEAL.LIST                                            !CMW
1142: 0d36:     INTEGER*1   EXCLUSION.FLAG% ! Local price flag                          !DMW
1143: 0d36:     INTEGER*1   ITMDL.ADD.DEAL.ITEM                                         !CMW
1144: 0d36:     INTEGER*1   LIST.NUMBER%                                                !CMW
1145: 0d36:     INTEGER*1   NEW.DEAL                                                    !CMW
1146: 0d36:                                                                             !CMW
1147: 0d36:     INTEGER*2   DEAL.COUNT%                                                 !CMW
1148: 0d36:     INTEGER*2   DEAL.POS%                                                   !CMW
1149: 0d36:     INTEGER*2   LIST.POS%                                                   !CMW
1150: 0d36:     INTEGER*2   LOOP%                                                       !CMW
1151: 0d36:                                                                             !CMW
1152: 0d36:     STRING      DEAL.NUMBER$                                                !IMW
1153: 0d36:     STRING      EXCLUSION$                                                  !DMW
1154: 0d36:     STRING      EXISTING.DEAL.NUMBER$                                       !CMW
1155: 0d36:     STRING      EXISTING.LIST.ID$                                           !CMW
1156: 0d36:     STRING      ITEM.CODE$                                                  !CMW
1157: 0d36:     STRING      LIST.ID$                                                    !CMW
1158: 0d36:                                                                             !CMW
1159: 0d36:     ON ERROR GOTO ITMDL.ADD.DEAL.ITEM.ERROR                                 !CMW
1160: 0d43:                                                                             !CMW
1161: 0d43:     ITMDL.ADD.DEAL.ITEM = 0 ! Assume success                                !CMW
1162: 0d47:                                                                             !CMW
1163: 0d47:     DEAL.FOUND           = FALSE                                            !CMW
1164: 0d51:     END.OF.DEAL.LIST     = FALSE                                            !IMW
1165: 0d5b:     NEW.DEAL             = FALSE                                            !IMW
1166: 0d65:                                                                             !CMW
1167: 0d65:     ITMDL.ITEM.CODE$ = ITEM.CODE$                                           !CMW
1168: 0d76:                                                                             !CMW
1169: 0d76:     ! Convert list number to list ID                                        !CMW
1170: 0d76:     LIST.ID$ = PACK$(RIGHT$("00" + STR$(LIST.NUMBER%),2))                   !CMW
1171: 0db8:                                                                             !CMW
1172: 0db8:     ! IF item is locally priced                                             !DMW
1173: 0db8:     IF EXCLUSION.FLAG% = 1 THEN BEGIN                                       !DMW
1174: 0dbe:         EXCLUSION$ = "L"                                                    !DMW
1175: 0dcd:     ENDIF ELSE BEGIN                                                        !DMW
1176: 0dcd:         EXCLUSION$ = " "                                                    !DMW
1177: 0dda:     ENDIF                                                                   !DMW
1178: 0dda:                                                                             !DMW
1179: 0dda:     ! Initialise current deals list                                         !CMW
1180: 0dda:     ITMDL.ALL.DEAL.NUM.LIST.ID$ = ""                                        !CMW
1181: 0de9:                                                                             !CMW
1182: 0de9:     ! Read ITMDL record                                                     !CMW
1183: 0de9:     ITMDL.RC% = READ.ITMDL                                                  !CMW
1184: 0df0:                                                                             !CMW
1185: 0df0:     ! IF ITMDL record found                                                 !CMW
1186: 0df0:     IF ITMDL.RC% <> 0 THEN BEGIN                                            !CMW
1187: 0df7:         NEW.DEAL = TRUE                                                     !CMW
1188: 0e01:     ENDIF                                                                   !CMW
1189: 0e01:                                                                             !CMW
1190: 0e01:     ! Get count of existing deals                                           !CMW
1191: 0e01:     DEAL.COUNT% =                                                       \   !CMW
1192: 0e21:         LEN(ITMDL.ALL.DEAL.NUM.LIST.ID$) / ITMDL.DEALNUM.LID.LEN%           !CMW
1193: 0e21:                                                                             !CMW
1194: 0e21:     ! Initialise existing deal number, list ID and local price flag         !DMW
1195: 0e21:     EXISTING.DEAL.NUMBER$ = STRING$(2,CHR$(0))                              !CMW
1196: 0e38:     EXISTING.LIST.ID$     = CHR$(0)                                         !CMW
1197: 0e48:                                                                             !CMW
1198: 0e48:     ! Initialise loop counter                                               !CMW
1199: 0e48:     LOOP% = 0                                                               !CMW
1200: 0e4e:                                                                             !CMW
1201: 0e4e:     ! WHILE the end of the current deals list has NOT been reached AND      !CMW
1202: 0e4e:     !       the deal has NOT been found in the current deals list AND       !CMW
1203: 0e4e:     !       the current deals list already contained some deals             !CMW
1204: 0e4e:     WHILE (NOT END.OF.DEAL.LIST) AND                                    \   !CMW
1205: 0e51:           (NOT DEAL.FOUND) AND                                          \   !CMW
1206: 0e51:           (DEAL.COUNT% > 0)                                                 !CMW
1207: 0e51:                                                                             !CMW
1208: 0e51:         DEAL.POS% =                                                     \   !CMW
1209: 0e61:             (LOOP% * ITMDL.DEALNUM.LID.LEN%) + 1 ! Deal index position      !CMW
1210: 0e61:                                                                             !CMW
1211: 0e61:         LIST.POS% = DEAL.POS% + 2 ! List ID index position                  !CMW
1212: 0e67:                                                                             !CMW
1213: 0e67:         ! Get the next existing deal number                                 !CMW
1214: 0e67:         CALL EXTRACTS(ITMDL.ALL.DEAL.NUM.LIST.ID$,                      \   !CMW
1215: 0e86:                       EXISTING.DEAL.NUMBER$,                            \   !CMW
1216: 0e86:                       DEAL.POS%)                                            !CMW
1217: 0e86:                                                                             !CMW
1218: 0e86:         ! Get the next existing list ID                                     !CMW
1219: 0e86:         CALL EXTRACTS(ITMDL.ALL.DEAL.NUM.LIST.ID$,                      \   !CMW
1220: 0ea5:                       EXISTING.LIST.ID$,                                \   !CMW
1221: 0ea5:                       LIST.POS%)                                            !CMW
1222: 0ea5:                                                                             !CMW
1223: 0ea5:         ! IF the specified deal number already exists for this item         !CMW
1224: 0ea5:         IF DEAL.NUMBER$ = EXISTING.DEAL.NUMBER$ THEN BEGIN                  !CMW
1225: 0eba:                                                                             !CMW
1226: 0eba:             ! IF the list number has changed                                !CMW
1227: 0eba:             IF LIST.ID$ <> EXISTING.LIST.ID$ THEN BEGIN                     !CMW
1228: 0ed1:                                                                             !CMW
1229: 0ed1:                 ! Update the list number only                               !CMW
1230: 0ed1:                 CALL INSERTS(ITMDL.ALL.DEAL.NUM.LIST.ID$,               \   !CMW
1231: 0ef0:                              LIST.ID$,                                  \   !CMW
1232: 0ef0:                              LIST.POS%)                                     !CMW
1233: 0ef0:                                                                             !CMW
1234: 0ef0:             ENDIF                                                           !CMW
1235: 0ef0:                                                                             !CMW
1236: 0ef0:             DEAL.FOUND = TRUE                                               !CMW
1237: 0efa:                                                                             !CMW
1238: 0efa:         ENDIF                                                               !CMW
1239: 0efa:                                                                             !CMW
1240: 0efa:         LOOP% = LOOP% + 1                                                   !CMW
1241: 0efe:                                                                             !CMW
1242: 0efe:         ! IF end of the current deals list has been reached                 !CMW
1243: 0efe:         IF LOOP% = DEAL.COUNT% THEN BEGIN                                   !CMW
1244: 0f07:             END.OF.DEAL.LIST = TRUE                                         !CMW
1245: 0f11:         ENDIF                                                               !CMW
1246: 0f11:                                                                             !CMW
1247: 0f11:     WEND                                                                    !CMW
1248: 0f32:                                                                             !CMW
1249: 0f32:     ! IF the specified deal does NOT exist in the current deals list OR     !CMW
1250: 0f32:     !    the deal itself currently does NOT exist at all                    !CMW
1251: 0f32:     IF (NOT DEAL.FOUND) OR                                              \   !CMW
1252: 0f3d:        (NEW.DEAL) THEN BEGIN                                                !CMW
1253: 0f3d:                                                                             !CMW
1254: 0f3d:         ! Set local price flag to its current value                         !DMW
1255: 0f3d:         ITMDL.EXCLUSION$ = EXCLUSION$                                       !DMW
1256: 0f50:                                                                             !DMW
1257: 0f50:         ! Add deal number and list ID to the current deals list             !CMW
1258: 0f50:         ITMDL.ALL.DEAL.NUM.LIST.ID$ =                                   \   !CMW
1259: 0f77:             ITMDL.ALL.DEAL.NUM.LIST.ID$ +                               \   !CMW
1260: 0f77:             DEAL.NUMBER$ +                                              \   !CMW
1261: 0f77:             LIST.ID$                                                        !CMW
1262: 0f77:                                                                             !CMW
1263: 0f77:         ! Update ITMDL record                                               !CMW
1264: 0f77:         ITMDL.RC% = WRITE.ITMDL                                             !CMW
1265: 0f7e:                                                                             !CMW
1266: 0f7e:         ! IF error writing to ITMDL                                         !CMW
1267: 0f7e:         IF ITMDL.RC% <> 0 THEN BEGIN                                        !CMW
1268: 0f85:             ITMDL.ADD.DEAL.ITEM = 1 ! Failure                               !CMW
1269: 0f89:         ENDIF                                                               !CMW
1270: 0f89:                                                                             !CMW
1271: 0f89:     ENDIF                                                                   !CMW
1272: 0f89:                                                                             !CMW
1273: 0f89: EXIT.FUNCTION:                                                              !CMW
1274: 0f89:                                                                             !CMW
1275: 0f89:     EXIT FUNCTION                                                           !CMW
1276: 0f8b:                                                                             !CMW
1277: 0f8b: ITMDL.ADD.DEAL.ITEM.ERROR:                                                  !CMW
1278: 0f8b:                                                                             !CMW
1279: 0f8b:     ITMDL.ADD.DEAL.ITEM = 1 ! Failure                                       !CMW
1280: 0f8f:     RESUME EXIT.FUNCTION                                                    !CMW
1281: 0f9e:                                                                             !CMW
1282: 0f9e: END FUNCTION                                                                !CMW
1283: 0fb7:                                                                             !CMW
1284: 0fb7: \***************************************************************************!CMW
1285: 0fb7: \***                                                                        !CMW
1286: 0fb7: \***   ITMDL.REMOVE.DEAL.ITEM                                               !CMW
1287: 0fb7: \***                                                                        !CMW
1288: 0fb7: \***   Remove an individual item from the Item Deal file (ITMDL)            !CMW
1289: 0fb7: \***                                                                        !CMW
1290: 0fb7: \***************************************************************************!CMW
1291: 0fb7:                                                                             !CMW
1292: 0fb7: FUNCTION ITMDL.REMOVE.DEAL.ITEM(DEAL.NUMBER$,ITEM.CODE$) PUBLIC             !CMW
1293: 0fd5:                                                                             !CMW
1294: 0fd5:     INTEGER*1   DEAL.FOUND                                                  !CMW
1295: 0fd5:     INTEGER*1   END.OF.DEAL.LIST                                            !CMW
1296: 0fd5:     INTEGER*1   ITMDL.REMOVE.DEAL.ITEM                                      !CMW
1297: 0fd5:                                                                             !CMW
1298: 0fd5:     INTEGER*2   DEAL.COUNT%                                                 !CMW
1299: 0fd5:     INTEGER*2   DEAL.POS%                                                   !CMW
1300: 0fd5:     INTEGER*2   LEFT.LEN%                                                   !CMW
1301: 0fd5:     INTEGER*2   LOOP%                                                       !CMW
1302: 0fd5:     INTEGER*2   RIGHT.LEN%                                                  !CMW
1303: 0fd5:                                                                             !CMW
1304: 0fd5:     STRING      DEAL.NUMBER$                                                !IMW
1305: 0fd5:     STRING      EXISTING.DEAL.NUMBER$                                       !CMW
1306: 0fd5:     STRING      ITEM.CODE$                                                  !CMW
1307: 0fd5:                                                                             !CMW
1308: 0fd5:     ON ERROR GOTO ITMDL.REMOVE.DEAL.ITEM.ERROR                              !CMW
1309: 0fe2:                                                                             !CMW
1310: 0fe2:     ITMDL.REMOVE.DEAL.ITEM = 0 ! Assume success                             !CMW
1311: 0fe6:                                                                             !CMW
1312: 0fe6:     DEAL.FOUND       = FALSE                                                !CMW
1313: 0ff0:     END.OF.DEAL.LIST = FALSE                                                !CMW
1314: 0ffa:                                                                             !CMW
1315: 0ffa:     ITMDL.ITEM.CODE$ = ITEM.CODE$                                           !CMW
1316: 100b:                                                                             !CMW
1317: 100b:     ! Initialise current deals list                                         !CMW
1318: 100b:     ITMDL.ALL.DEAL.NUM.LIST.ID$ = ""                                        !CMW
1319: 101a:                                                                             !CMW
1320: 101a:     ! Read ITMDL record                                                     !CMW
1321: 101a:     ITMDL.RC% = READ.ITMDL                                                  !CMW
1322: 1021:                                                                             !CMW
1323: 1021:     ! IF ITMDL record found                                                 !CMW
1324: 1021:     IF ITMDL.RC% <> 0 THEN BEGIN                                            !CMW
1325: 1028:         EXIT FUNCTION                                                       !CMW
1326: 102b:     ENDIF                                                                   !CMW
1327: 102b:                                                                             !CMW
1328: 102b:     ! Get count of existing deals                                           !CMW
1329: 102b:     DEAL.COUNT% =                                                       \   !CMW
1330: 104b:         LEN(ITMDL.ALL.DEAL.NUM.LIST.ID$) / ITMDL.DEALNUM.LID.LEN%           !CMW
1331: 104b:                                                                             !CMW
1332: 104b:     ! Initialise existing deal number                                       !CMW
1333: 104b:     EXISTING.DEAL.NUMBER$ = STRING$(2,CHR$(0))                              !CMW
1334: 1062:                                                                             !CMW
1335: 1062:     ! Initialise loop counter                                               !CMW
1336: 1062:     LOOP% = 0                                                               !CMW
1337: 1068:                                                                             !CMW
1338: 1068:     ! WHILE the end of the current deals list has NOT been reached AND      !CMW
1339: 1068:     !       the deal has NOT been found in the current deals list AND       !CMW
1340: 1068:     !       the current deals list already contained some deals             !CMW
1341: 1068:     WHILE (NOT END.OF.DEAL.LIST) AND                                    \   !CMW
1342: 106a:           (NOT DEAL.FOUND) AND                                          \   !CMW
1343: 106a:           (DEAL.COUNT% > 0)                                                 !CMW
1344: 106a:                                                                             !CMW
1345: 106a:         DEAL.POS% =                                                     \   !CMW
1346: 107a:             (LOOP% * ITMDL.DEALNUM.LID.LEN%) + 1 ! Deal index position      !CMW
1347: 107a:                                                                             !CMW
1348: 107a:         ! Get the next existing deal number                                 !CMW
1349: 107a:         CALL EXTRACTS(ITMDL.ALL.DEAL.NUM.LIST.ID$,                      \   !CMW
1350: 1096:                       EXISTING.DEAL.NUMBER$,                            \   !CMW
1351: 1096:                       DEAL.POS%)                                            !CMW
1352: 1096:                                                                             !CMW
1353: 1096:         ! IF match found for the specified deal number                      !CMW
1354: 1096:         IF DEAL.NUMBER$ = EXISTING.DEAL.NUMBER$ THEN BEGIN                  !CMW
1355: 10ab:             DEAL.FOUND = TRUE                                               !CMW
1356: 10b5:         ENDIF                                                               !CMW
1357: 10b5:                                                                             !CMW
1358: 10b5:         LOOP% = LOOP% + 1                                                   !CMW
1359: 10b9:                                                                             !CMW
1360: 10b9:         ! IF end of the current deals list has been reached                 !CMW
1361: 10b9:         IF LOOP% = DEAL.COUNT% THEN BEGIN                                   !CMW
1362: 10c2:             END.OF.DEAL.LIST = TRUE                                         !CMW
1363: 10cc:         ENDIF                                                               !CMW
1364: 10cc:                                                                             !CMW
1365: 10cc:     WEND                                                                    !CMW
1366: 10ea:                                                                             !CMW
1367: 10ea:     ! IF the specified deal exists in the current deals list                !CMW
1368: 10ea:     IF DEAL.FOUND THEN BEGIN                                                !CMW
1369: 10f1:                                                                             !CMW
1370: 10f1:         ! Calculate length of leftmost section of deal list to retain       !CMW
1371: 10f1:         LEFT.LEN%  = DEAL.POS% - 1                                          !CMW
1372: 10f8:                                                                             !CMW
1373: 10f8:         ! Calculate length of rightmost section of deal list to retain      !CMW
1374: 10f8:         RIGHT.LEN% = LEN(ITMDL.ALL.DEAL.NUM.LIST.ID$) -                 \   !CMW
1375: 111b:                      LEFT.LEN% -                                        \   !CMW
1376: 111b:                      ITMDL.DEALNUM.LID.LEN%                                 !CMW
1377: 111b:                                                                             !CMW
1378: 111b:         ! Remove specified deal and list ID from the current deals list     !CMW
1379: 111b:         ITMDL.ALL.DEAL.NUM.LIST.ID$ =                                   \   !CMW
1380: 115b:             LEFT$(ITMDL.ALL.DEAL.NUM.LIST.ID$,LEFT.LEN%) +              \   !CMW
1381: 115b:             RIGHT$(ITMDL.ALL.DEAL.NUM.LIST.ID$,RIGHT.LEN%)                  !CMW
1382: 115b:                                                                             !CMW
1383: 115b:         ! Update ITMDL record                                               !CMW
1384: 115b:         ITMDL.RC% = WRITE.ITMDL                                             !CMW
1385: 1162:                                                                             !CMW
1386: 1162:         ! IF error writing to ITMDL                                         !CMW
1387: 1162:         IF ITMDL.RC% <> 0 THEN BEGIN                                        !CMW
1388: 1169:             ITMDL.REMOVE.DEAL.ITEM = 1 ! Failure                            !CMW
1389: 116d:         ENDIF                                                               !CMW
1390: 116d:                                                                             !CMW
1391: 116d:     ENDIF                                                                   !CMW
1392: 116d:                                                                             !CMW
1393: 116d: EXIT.FUNCTION:                                                              !CMW
1394: 116d:                                                                             !CMW
1395: 116d:     EXIT FUNCTION                                                           !CMW
1396: 116f:                                                                             !CMW
1397: 116f: ITMDL.REMOVE.DEAL.ITEM.ERROR:                                               !CMW
1398: 116f:                                                                             !CMW
1399: 116f:     ITMDL.REMOVE.DEAL.ITEM = 1 ! Failure                                    !CMW
1400: 1173:     RESUME EXIT.FUNCTION                                                    !CMW
1401: 1182:                                                                             !CMW
1402: 1182: END FUNCTION                                                                !CMW
1403: 119b: 
1404: 119b: \***************************************************************************!JMW
1405: 119b: \***                                                                        !JMW
1406: 119b: \***   OPEN.ITMDL                                                           !JMW
1407: 119b: \***                                                                        !JMW
1408: 119b: \***   Opens the ITMDL file                                                 !JMW
1409: 119b: \***                                                                        !JMW
1410: 119b: \***************************************************************************!JMW
1411: 119b:                                                                             !JMW
1412: 119b: FUNCTION OPEN.ITMDL PUBLIC                                                  !JMW
1413: 11af:                                                                             !JMW
1414: 11af:     INTEGER*1 OPEN.ITMDL                                                    !JMW
1415: 11af:                                                                             !JMW
1416: 11af:     ON ERROR GOTO OPEN.ITMDL.ERROR                                          !JMW
1417: 11bc:                                                                             !JMW
1418: 11bc:     OPEN.ITMDL = 0                                                          !JMW
1419: 11c0:                                                                             !JMW
1420: 11c0:     OPEN ITMDL.FILE.NAME$ KEYED RECL ITMDL.RECL%                        \   !JMW
1421: 11e7:         AS ITMDL.SESS.NUM% NODEL                                            !JMW
1422: 11e7:                                                                             !JMW
1423: 11e7: EXIT.FUNCTION:                                                              !JMW
1424: 11e7:                                                                             !JMW
1425: 11e7:     EXIT FUNCTION                                                           !JMW
1426: 11e9:                                                                             !JMW
1427: 11e9: OPEN.ITMDL.ERROR:                                                           !JMW
1428: 11e9:                                                                             !JMW
1429: 11e9:     OPEN.ITMDL = 1                                                          !JMW
1430: 11ed:                                                                             !JMW
1431: 11ed:     FILE.OPERATION$ = "O"                                                   !JMW
1432: 11fc:     CURRENT.REPORT.NUM% = ITMDL.REPORT.NUM%                                 !JMW
1433: 120a:                                                                             !JMW
1434: 120a:     RESUME EXIT.FUNCTION                                                    !JMW
1435: 1219:                                                                             !JMW
1436: 1219: END FUNCTION                                                                !JMW
1437: 1228: 
1438: 1228: 
1439: 1228: End of Compilation
