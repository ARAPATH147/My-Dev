   1: 0000: 
   2: 0000: \*******************************************************************************
   3: 0000: \*******************************************************************************
   4: 0000: \***
   5: 0000: \***
   6: 0000: \***        PROGRAM       : PSB72
   7: 0000: \***        AUTHOR        : Bruce Scriver (Pseudocode)
   8: 0000: \***                      : Stephen Kelsey (Basic Code)
   9: 0000: \***        DATE WRITTEN  : 24th April 1986 (Pseudocode)
  10: 0000: \***                      : 2nd May 1986    (Basic Code)
  11: 0000: \***
  12: 0000: \***        MODULE        : PSB7200
  13: 0000: \***
  14: 0000: \*******************************************************************************
  15: 0000: \*******************************************************************************
  16: 0000: 
  17: 0000: REM pseudocode follows..
  18: 0000: 
  19: 0000: \*******************************************************************************
  20: 0000: \*******************************************************************************
  21: 0000: \***
  22: 0000: \***
  23: 0000: \***                         MODULE OVERVIEW
  24: 0000: \***                         ---------------
  25: 0000: \***
  26: 0000: \***   R.J.Hopkinson     28th March 1988
  27: 0000: \***
  28: 0000: \***   This program was previously module 00 of PSB03 - code was altered in
  29: 0000: \***   line with changes to menu structure required by new small store system.
  30: 0000: \***   Additional alterations were made to use new method of chaining to other
  31: 0000: \***   programs, i.e. via included code PSBCHNE.J86, PSBUSEE.J86 & PSBUSEG.J86.
  32: 0000: \***
  33: 0000: \*******************************************************************************
  34: 0000: 
  35: 0000: \*******************************************************************************
  36: 0000: \***
  37: 0000: \***    VERSION B.      MARK WALKER                     10th April 1991
  38: 0000: \***    1) Redundant code has been removed from subroutines PROCESS.ENTRY
  39: 0000: \***    and AUTO.EFFECT.DECREASES.
  40: 0000: \***    2) Subroutine IRF.WRITE.ERROR has been removed, as this is also
  41: 0000: \***    redundant.
  42: 0000: \***    3) A 'Processing - Please Wait ....' message is displayed when
  43: 0000: \***    extracting data.
  44: 0000: \***    4) If an error routine is called and the program was called by
  45: 0000: \***    PSB51, add the message number to the the passed parameter.
  46: 0000: \***    5) Move the opening of the PPFI in subroutine PROCESS.SELECTION.
  47: 0000: \***    6) Allow the HELP key to be selected from the 'Are you sure? (Y/N)'
  48: 0000: \***    prompt.
  49: 0000: \***    7) Add an extra parameter to a call to subroutine UPDT.IRF.UPDT.
  50: 0000: \***    8) Use PSBF20 to allocate session numbers to files.
  51: 0000: \***    9) Update error messages using session numbers to report numbers.
  52: 0000: \***    10) Change the format of message 553.
  53: 0000: \***    11) Update events to use a report number.
  54: 0000: \***    12) Update all included code.
  55: 0000: \***    13) Alter input field number 8 to allow function keys and bad keys
  56: 0000: \***    to terminate input.
  57: 0000: \***    14) Update messages to use a report number.
  58: 0000: \***    15) Change GOTO to RESUME within ERROR.DETECTED
  59: 0000: \***    16) Message 273 redisplayed when processing continues after an error.
  60: 0000: \***
  61: 0000: \***    VERSION C.      Stephen Windsor                 3rd  March  1992
  62: 0000: \***     Update included code for PPFI/PPFO
  63: 0000: \***     Update included code for PSBF20
  64: 0000: \***
  65: 0000: \***    VERSION D.      Stephen Windsor                 23rd September 1993
  66: 0000: \***     New deals system requires changes to the way items are updated on
  67: 0000: \***     the IRF.
  68: 0000: \***       - Items on deal may now have their prices altered.
  69: 0000: \***       - Items with a local price must have their HO price maintained on
  70: 0000: \***          the LOCAL file now (not HOLDING PRICE on the IRF).
  71: 0000: \***          If the item is not on the LOCAL file, add it.
  72: 0000: \***     The processing of the PPFI/O is speeded up by reading and writing
  73: 0000: \***     in large blocks.
  74: 0000: \***     Fix to Boots problem 1062:-
  75: 0000: \***     Price changes to items that cannot be found (on IDF or IRF), are
  76: 0000: \***     thrown out and NOT written back to the PPFO. The read error is STILL
  77: 0000: \***     logged. (Reason: Stores are not interested in knowing about price
  78: 0000: \***                      changes to items NOT on their inventory. Currently
  79: 0000: \***                      these items have to be "ESCaped" past or are listed
  80: 0000: \***                      at the end of Store Open - causing unnecessary calls
  81: 0000: \***                      to the Help Desk.)
  82: 0000: \***     The program is also streamlined in this version.
  83: 0000: \***
  84: 0000: \***    VERSION E.      Stephen Windsor                          4th  March    1994
  85: 0000: \***    Swop the positions of delete PPFI and close PPFO.
  86: 0000: \***    Reason : When utilizing the large buffsize during I/O functions the
  87: 0000: \***    remaining data in the buffer only gets written to the file at the
  88: 0000: \***    CLOSE statement. If the controller IPL's between the delete and close
  89: 0000: \***    the data within the buffer is lost.
  90: 0000: \***
  91: 0000: \***
  92: 0000: \***    Version F                Andrew Wedgeworth        27th September 1995
  93: 0000: \***
  94: 0000: \***    Changes for new Customer Card system.  The redemption points value on
  95: 0000: \***    the IRF is updated when an item's price changes.
  96: 0000: \***
  97: 0000: \***    Version G                Scott Baker              13th January 1998
  98: 0000: \***
  99: 0000: \***    Changes required for y2k compliance. Also removed code pertaining to
 100: 0000: \***    'unconverted records' and replaced IRF.MPGROUP with IRF.INDICAT5.
 101: 0000: \***
 102: 0000: \***    Version H           Stuart William McConnachie         2nd March 2000
 103: 0000: \***    Updated IRF fields for meal deal.
 104: 0000: \***
 105: 0000: \***    Version I           Brian Greenfield                   3rd October 2002
 106: 0000: \***    Changes made to accomodate new IRF layout for Deals rewrite.
 107: 0000: \***
 108: 0000: \***    Version J            Jamie Thorpe                      24th October 2006
 109: 0000: \***    Emergency Price Changes:
 110: 0000: \***    Added code so that Emergency Price change RPD's (denoted by EPC on the 
 111: 0000: \***    LOCAL file) are removed from Local Pricing.
 112: 0000: \***
 113: 0000: \***    REVISION 1.19.                ROBERT COWEY.                02 APR 2009.
 114: 0000: \***    Corrected error handling to display message B513 when PPFI access.
 115: 0000: \***    conflict occurs on entry to initial menu screen B7201.
 116: 0000: \***
 117: 0000: \***    Separated file open and close statements into distinct sub-routines 
 118: 0000: \***    and called these only as needed to keep files closed when not in use.
 119: 0000: \***    Nullified PPFI.OPEN.FLAG$ as this is now redundant.
 120: 0000: \***    Nullified other variables identified by compiler as redundant.
 121: 0000: \***
 122: 0000: \***    REVISION 1.20.                ROBERT COWEY.                21 JUN 2010.
 123: 0000: \***    Fix for OM error 00000058 on 19,870 item PPFI and other changes for 
 124: 0000: \***    "VAT Preparation Jan 2011" project creating PSB72.286 Rv 1.20.
 125: 0000: \***    Catered for NP error to allow program launch from command line.
 126: 0000: \***    Loaded PPFI directly into F14.TABLE$ to avoid appending data into 
 127: 0000: \***    FIRST.DATA.STRING$ (which eventually fails when somewhere above 32k).
 128: 0000: \***    Also loaded F14.TABLE$ data directly into DISPLAY.TABLE$ to avoid using
 129: 0000: \***    SECOND.DATA.STRING$ in a similar way.
 130: 0000: \***    Set both table limits to 14,400 and used this for other internal limits.
 131: 0000: \***    Ensured BEMF message 265 continues to be displayed on initial entry to
 132: 0000: \***    RPD selection screen.
 133: 0000: \***
 134: 0000: \*******************************************************************************
 135: 0000: 
 136: 0000: 
 137: 0000: \*******************************************************************************
 138: 0000: \***
 139: 0000: \***   %INCLUDE globals for DISPLAY.MANAGER functions
 140: 0000: \***   %INCLUDE globals for READ.NEXT.IEF function
 141: 0000: \***   %INCLUDE globals for SORT.TABLE function
 142: 0000: \***   %INCLUDE globals for CONV.TO.HEX function
 143: 0000: \***   %INCLUDE globals for CONV.TO.STRING function
 144: 0000: \***   %INCLUDE globals for IRF.UPDATE function
 145: 0000: \***   %INCLUDE globals for screen chaining parameters
 146: 0000: \***   %INCLUDE field definitions for IDF
 147: 0000: \***   %INCLUDE field definitions for IEF
 148: 0000: \***   %INCLUDE field definitions for IRF
 149: 0000: \***   %INCLUDE field definitions for PPF
 150: 0000: \***   %INCLUDE session number definitions for IDF
 151: 0000: \***   %INCLUDE session number definitions for IEF
 152: 0000: \***   %INCLUDE session number definitions for IRF
 153: 0000: \***   %INCLUDE session number definitions for PPFI/O
 154: 0000: \***
 155: 0000: \...............................................................................
 156: 0000: 
 157: 0000:    %INCLUDE PSBF02G.J86                                                ! FAW
 158: 0000: REM\
 159: 0000: \*******************************************************************************
 160: 0000: \*******************************************************************************
 161: 0000: \***
 162: 0000: \***        INCLUDE       : UPDATE.DATE globals
 163: 0000: \***
 164: 0000: \***        REFERENCE     : PSBF02G.J86
 165: 0000: \***
 166: 0000: \***        Version A     Bruce Scriver      4th March 1986
 167: 0000: \*** 
 168: 0000: \***        Version B     Andrew Wedgeworth   6th July 1992
 169: 0000: \***        Removal of return code field which no longer required.
 170: 0000: \***
 171: 0000: \*******************************************************************************
 172: 0000: \*******************************************************************************
 173: 0000: 
 174: 0000:       STRING   GLOBAL F02.DATE$
 175: 0000: 
 176: 0000:       ! 1 line deleted from here                                       ! BAW
 177: 0000: 
 178: 0000:    %INCLUDE PSBF03G.J86                                                ! FAW
 179: 0000: REM \
 180: 0000: \*******************************************************************************
 181: 0000: \***
 182: 0000: \***      INCLUDED CODE FOR DISPLAY MANAGER FUNCTIONS GLOBAL DECLARATIONS
 183: 0000: \***
 184: 0000: \***                    REFERENCE :  PSBF03G.J86
 185: 0000: \***              
 186: 0000: \***      Version A                                        21st March 1986
 187: 0000: \***
 188: 0000: \***      Version B          Andrew Wedgeworth              27th July 1992
 189: 0000: \***      Removal of F03.RETURN.CODE% which is no longer used.
 190: 0000: \***
 191: 0000: \*******************************************************************************
 192: 0000: 
 193: 0000:    ! 1 line deleted from here                                          ! BAW
 194: 0000:    INTEGER*2   GLOBAL   F03.RETURNED.INTEGER%    ! from IBM Display Manager
 195: 0000:    STRING      GLOBAL   F03.RETURNED.STRING$     ! from IBM Display Manager
 196: 0000: 
 197: 0000: 
 198: 0000: 
 199: 0000: 
 200: 0000: 
 201: 0000: 
 202: 0000:    %INCLUDE PSBF11G.J86                                                ! FAW
 203: 0000: REM \
 204: 0000: \*******************************************************************************
 205: 0000: \*******************************************************************************
 206: 0000: \***
 207: 0000: \***    %INCLUDE FOR GLOBALS DEFINITIONS FOR FUNCTION READ.NEXT.IEF
 208: 0000: \***
 209: 0000: \***            FUNCTION NUMBER    : PSBF11
 210: 0000: \***
 211: 0000: \***            REFERENCE          : PSBF11G.J86
 212: 0000: \***
 213: 0000: \***    Version B            Bruce Scriver             11th December 1986 
 214: 0000: \***
 215: 0000: \***    Version C            Andrew Wedgeworth             15th July 1992
 216: 0000: \***    Redundant return code field removed.
 217: 0000: \***
 218: 0000: \*******************************************************************************
 219: 0000: \*******************************************************************************
 220: 0000: 
 221: 0000:       STRING    GLOBAL  F11.ERROR.FLAG$,                               \ BBAAS
 222: 0000:                         F11.NEXT.BAR.CODE$                             ! BBAAS
 223: 0000: 
 224: 0000:       INTEGER*2 GLOBAL  F11.CURRENT.COUNT%
 225: 0000: 
 226: 0000: 
 227: 0000:    %INCLUDE PSBF14G.J86                                                ! FAW
 228: 0000: REM\
 229: 0000: \*******************************************************************************
 230: 0000: \*******************************************************************************
 231: 0000: \***
 232: 0000: \***        INCLUDE       : SORT.TABLE globals
 233: 0000: \***
 234: 0000: \***        REFERENCE     : PSBF14G.J86
 235: 0000: \***
 236: 0000: \***        Version A     Bruce Scriver                3rd March 1986
 237: 0000: \*** 
 238: 0000: \***        Version B     Andrew Wedgeworth            17th July 1992
 239: 0000: \***        Removal of now redundant return code field.
 240: 0000: \***
 241: 0000: \*******************************************************************************
 242: 0000: \*******************************************************************************
 243: 0000: 
 244: 0000:       STRING   GLOBAL F14.TABLE$(1)
 245: 0000: 
 246: 0000: 
 247: 0000:    %INCLUDE PSBF16G.J86                                                ! FAW
 248: 0000: REM\
 249: 0000: \*******************************************************************************
 250: 0000: \*******************************************************************************
 251: 0000: \***
 252: 0000: \***           %INCLUDE GLOBAL DEFINITIONS FOR CONV.TO.HEX FUNCTION
 253: 0000: \***
 254: 0000: \***                       REFERENCE     : PSBF16G.J86
 255: 0000: \*** 
 256: 0000: \***       Version A           Bruce Scriver            25th February 1986
 257: 0000: \***
 258: 0000: \***       Version B         Andrew Wedgeworth               2nd July 1992
 259: 0000: \***       Removal of now redundant F16.RETURN.CODE%.
 260: 0000: \***
 261: 0000: \*******************************************************************************
 262: 0000: \*******************************************************************************
 263: 0000: 
 264: 0000:       STRING   GLOBAL F16.HEX.STRING$
 265: 0000: 
 266: 0000:       ! 1 line deleted from here                                       ! BAW
 267: 0000:    %INCLUDE PSBF17G.J86                                                ! FAW
 268: 0000: REM \
 269: 0000: \*******************************************************************************
 270: 0000: \*******************************************************************************
 271: 0000: \***
 272: 0000: \***
 273: 0000: \***        %INCLUDE GLOBAL DEFINITIONS FOR CONV.TO.STRING FUNCTION
 274: 0000: \***
 275: 0000: \***                    REFERENCE     : PSBF17G.J86
 276: 0000: \***
 277: 0000: \***        Version A         Bruce Scriver      24th February 1986
 278: 0000: \***
 279: 0000: \***        Version B       Andrew Wedgeworth         2nd July 1992
 280: 0000: \***        Removal of now redundant F17.RETURN.CODE%
 281: 0000: \***
 282: 0000: \*******************************************************************************
 283: 0000: \*******************************************************************************
 284: 0000: 
 285: 0000:       STRING   GLOBAL F17.RETURNED.STRING$
 286: 0000: 
 287: 0000:       ! 1 line deleted from here                                       ! BAW
 288: 0000: 
 289: 0000:    %INCLUDE PSBF18G.J86                                                ! FAW
 290: 0000: REM\
 291: 0000: \*******************************************************************************
 292: 0000: \*******************************************************************************
 293: 0000: \***
 294: 0000: \***        INCLUDE       : CALC.BOOTS.CODE.CHECK.DIGIT globals
 295: 0000: \***
 296: 0000: \***        REFERENCE     : PSBF18G.J86
 297: 0000: \***
 298: 0000: \***        Version A     Stephen Kelsey                  23rd March 1987
 299: 0000: \***
 300: 0000: \***        Version B     Andrew Wedgeworth                 7th July 1992
 301: 0000: \***        Removal of return code field which no longer required.
 302: 0000: \***
 303: 0000: \*******************************************************************************
 304: 0000: \*******************************************************************************
 305: 0000: 
 306: 0000:       STRING   GLOBAL F18.CHECK.DIGIT$
 307: 0000:     
 308: 0000:       ! 1 line deleted from here                                       ! BAW    
 309: 0000: 
 310: 0000:    %INCLUDE PSBF19G.J86                                                ! FAW
 311: 0000: REM \
 312: 0000: \*******************************************************************************
 313: 0000: \*******************************************************************************
 314: 0000: \***
 315: 0000: \***
 316: 0000: \***            INCLUDE       : UPDATE IRF globals
 317: 0000: \***
 318: 0000: \***            REFERENCE     : PSBF19G.J86
 319: 0000: \***
 320: 0000: \***      Version A              Richard Hopkinson            16th March 1988
 321: 0000: \***
 322: 0000: \***      Version B              Janet Lawrence               12th April 1989
 323: 0000: \***      Version letter incremented to match that of external defintion of 
 324: 0000: \***      function 19.  
 325: 0000: \***
 326: 0000: \***      Version C              Andrew Wedgeworth             21st July 1992
 327: 0000: \***      Return code field removed as no longer used.
 328: 0000: \***
 329: 0000: \***      Version F              Steve Perkins                 20th October 1993
 330: 0000: \***      Version letter updated to keep in line with PSBF19.BAS
 331: 0000: \***
 332: 0000: \***    REVISION 1.9.                ROBERT COWEY.                08 DEC 2003.
 333: 0000: \***    Changes for Deal Limit removal project.
 334: 0000: \***    Revision number updated to keep in step with PSBF19.BAS.
 335: 0000: \***    Declared variables for IRFDEX and F19.NODE.FILE...
 336: 0000: \***
 337: 0000: \*******************************************************************************
 338: 0000: \*******************************************************************************
 339: 0000: 
 340: 0000:       STRING   F19.RETURNED.STRING                                     ! CAW
 341: 0000:       STRING   F19.NODE.FILE.NAME$                                         ! 1.9 RC
 342: 0000: 
 343: 0000:       STRING   GLOBAL NODE.ID$
 344: 0000:       STRING   GLOBAL TIF.FULL$
 345: 0000:       STRING   GLOBAL TIF.OPEN.FLAG$
 346: 0000:       STRING   GLOBAL TMCF.FULL$
 347: 0000:       STRING   GLOBAL TMCF.OPEN.FLAG$
 348: 0000:       
 349: 0000:       INTEGER*2 GLOBAL F19.IRFDEX.SESS.NUM%                                ! 1.9 RC
 350: 0000:       
 351: 0000:       INTEGER*2 F19.NODE.REPORT.NUM%                                       ! 1.9 RC
 352: 0000:       INTEGER*2 F19.NODE.SESS.NUM%                                         ! 1.9 RC
 353: 0000:    %INCLUDE PSBF20G.J86                                                ! FAW
 354: 0000: REM\
 355: 0000: \*******************************************************************************
 356: 0000: \*******************************************************************************
 357: 0000: \***
 358: 0000: \***     %INCLUDE GLOBAL VARIABLE DEFINITIONS FOR SESS.NUM.UTILITY FUNCTION
 359: 0000: \***
 360: 0000: \***                       REFERENCE     : PSBF20G.J86
 361: 0000: \*** 
 362: 0000: \***     Version A              Bruce Scrive                   5th May 1988   
 363: 0000: \*** 
 364: 0000: \***     Version B              Robert Cowey                   7th May 1991
 365: 0000: \***     Global variable F20.INTEGER.FILE.NO% changed from one byte integer
 366: 0000: \***     to two byte integer.
 367: 0000: \***
 368: 0000: \***     Version D              Andrew Wedgeworth             1st July 1992
 369: 0000: \***     F20.RETURN.CODE% removed as it is no longer required.
 370: 0000: \***
 371: 0000: \*******************************************************************************
 372: 0000: \*******************************************************************************
 373: 0000: 
 374: 0000:       STRING    GLOBAL F20.FILE.NAME$,                                 \
 375: 0000:                        F20.STRING.FILE.NO$,                            \
 376: 0000:                        F20.TABLE.DIMENSIONED.FLAG$,                    \
 377: 0000:                        SESS.NUM.TABLE$(1)
 378: 0000: 
 379: 0000:       INTEGER*2 GLOBAL F20.INTEGER.FILE.NO%
 380: 0000: 
 381: 0000:       ! 1 line deleted from here                                       ! DAW 
 382: 0000: 
 383: 0000:    %INCLUDE PSBUSEG.J86
 384: 0000: \/*********************************************************************/ PSBUSEG
 385: 0000: \/*                                                                   */ PSBUSEG
 386: 0000: \/* PSBUSEG.J86  -  Definitions for Chain/Use with PSB Screen Program */ PSBUSEG
 387: 0000: \/* ----------------------------------------------------------------- */ PSBUSEG
 388: 0000: \/*                                                                   */ PSBUSEG
 389: 0000: \/*********************************************************************/ PSBUSEG
 390: 0000:                                                                        ! PSBUSEG
 391: 0000:         STRING GLOBAL  PSBCHN.PRG,      \ Program to chain to          ! PSBUSEG
 392: 0000:                        PSBCHN.OP,       \ Operator Id                  ! PSBUSEG
 393: 0000:                        PSBCHN.APP,      \ Program chained from         ! PSBUSEG
 394: 0000:                        PSBCHN.MENCON,   \ Menu Control                 ! PSBUSEG
 395: 0000:                        PSBCHN.U1,       \ User parameter               ! PSBUSEG
 396: 0000:                        PSBCHN.U2,       \ User parameter               ! PSBUSEG
 397: 0000:                        PSBCHN.U3        ! User parameter               ! PSBUSEG
 398: 0000:                                                                        ! PSBUSEG
 399: 0000: 
 400: 0000:    %INCLUDE IDFDEC.J86                                                 ! FAW
 401: 0000: REM \
 402: 0000: \******************************************************************************
 403: 0000: \******************************************************************************
 404: 0000: \***
 405: 0000: \***         %INCLUDE FOR ITEM DATA FILE - FIELD DECLARATIONS
 406: 0000: \***                                       FILE REFERENCE PARAMETERS
 407: 0000: \***
 408: 0000: \***                  FILE TYPE    : Keyed
 409: 0000: \***
 410: 0000: \***                  REFERENCE    : IDFDEC.J86
 411: 0000: \***
 412: 0000: \***         VERSION A : Andrew Wedgeworth  29th June 1992    
 413: 0000: \***
 414: 0000: \***    VERSION C.              Robert Cowey.                       25 AUG 1993.
 415: 0000: \***    Replaced un-used RANK$ with BSNS.CNTR$ and FILLER$.
 416: 0000: \***
 417: 0000: \***    VERSION D.              Andrew Wedgeworth               15th March 1995
 418: 0000: \***    Comments updated to reflect the fact that some bits on the file are
 419: 0000: \***    no longer used.
 420: 0000: \***
 421: 0000: \*******************************************************************************
 422: 0000: \*******************************************************************************
 423: 0000: 
 424: 0000:   STRING GLOBAL           \
 425: 0000:     IDF.FILE.NAME$,       \  
 426: 0000:     IDF.BOOTS.CODE$,      \ 4 byte UPD with check digit (key)
 427: 0000:     IDF.FIRST.BAR.CODE$,  \ 6 byte UPD without check digit
 428: 0000:     IDF.SECOND.BAR.CODE$, \ 6 byte UPD without check digit
 429: 0000:     IDF.NO.OF.BAR.CODES$, \ 2 byte UPD. Total number of bar codes for this item
 430: 0000:     IDF.PRODUCT.GRP$,     \ 3 byte UPD. The first two digits are the concept
 431: 0000:                           \ group and the last four the concept sequence
 432: 0000:     IDF.STNDRD.DESC$,     \ 24 bytes
 433: 0000:     IDF.STATUS.1$,        \ 1 byte, values B,C,D,P,X,Z and blank
 434: 0000:     IDF.INTRO.DATE$,      \ 3 byte UPD YYMMDD. Date first added to this file
 435: 0000:     IDF.BSNS.CNTR$,       \ 1 byte ASC. Business Centre ID letter      ! CRC
 436: 0000:     IDF.FILLER$,          \ 1 byte un-used                             ! CRC
 437: 0000:     IDF.PARENT.CODE$,     \ 4 byte UPD with check digit ; may be zero if no
 438: 0000:                           \ flashpacks, current IDF.BOOTS.CODE$ if parent line
 439: 0000:                           \ or Boots Code of parent line if a flashpack.
 440: 0000:     IDF.DATE.OF.LAST.SALE$! 3 byte UPD. Date of last sale.
 441: 0000: 
 442: 0000:   INTEGER*1 GLOBAL        \
 443: 0000:     IDF.BIT.FLAGS.1%,     \ 1 byte - bit values
 444: 0000:                           \ X"80"  - Group code flag
 445: 0000:                           \ X"40"  - Keylines flag
 446: 0000:                           \ X"20"  - Markdown flag
 447: 0000:                           \ X"10"  - Warehouse flag
 448: 0000:                           \ X"08"  - CSR flag
 449: 0000:                           \ X"04"  - Directs A flag
 450: 0000:                           \ X"02"  - Directs B flag
 451: 0000:                           \ X"01"  - Directs C flag
 452: 0000:     IDF.BIT.FLAGS.2%      \ 1 byte - bit values
 453: 0000:                           \ X"80"  - Own brand line flag
 454: 0000:                           \ X"40"  - Exclusive line flag
 455: 0000:                           \ X"20"  - Unused 
 456: 0000:                           \ X"10"  - Unused
 457: 0000:                           \ X"08"  - Stock system flag
 458: 0000:                           \ X"04"  - Pending count flag
 459: 0000:                           \ X"02"  - Reserved
 460: 0000:                           ! X"01"  - Reserved
 461: 0000: 
 462: 0000:   INTEGER*2 GLOBAL        \
 463: 0000:     IDF.RECL%,            \  
 464: 0000:     IDF.REPORT.NUM%,      \ 
 465: 0000:     IDF.SESS.NUM%
 466: 0000:    %INCLUDE IEFDEC.J86                                                 ! FAW
 467: 0000: REM \
 468: 0000: \******************************************************************************
 469: 0000: \******************************************************************************
 470: 0000: \***
 471: 0000: \***         %INCLUDE FOR ITEM EAN CODES FILE - FIELD DECLARATIONS
 472: 0000: \***                                            FILE REFERENCE PARAMETERS
 473: 0000: \***
 474: 0000: \***               FILE TYPE    : Keyed
 475: 0000: \***
 476: 0000: \***               REFERENCE    : IEFDEC.J86
 477: 0000: \***
 478: 0000: \***    VERSION B.              ROBERT COWEY.                       21 OCT 1993.
 479: 0000: \***    No changes to this file.
 480: 0000: \***
 481: 0000: \*******************************************************************************
 482: 0000: \*******************************************************************************
 483: 0000: 
 484: 0000:   STRING GLOBAL                      \
 485: 0000:     IEF.FILE.NAME$,		     \
 486: 0000:     IEF.BOOTS.CODE.BAR.CODE$,        \ 9 byte UPD -                        BBAAS
 487: 0000:                                      \ 3 bytes UPD boots code              BBAAS   
 488: 0000:                                      \ + 6 UPD bar code,                   BBAAS
 489: 0000:                                      \ no check digits. (key)              BBAAS
 490: 0000:     IEF.NEXT.BAR.CODE$               ! 6 byte UPD without check digit
 491: 0000: 
 492: 0000:   INTEGER*2 GLOBAL        \
 493: 0000:     IEF.REPORT.NUM%,	  \
 494: 0000:     IEF.SESS.NUM%,	  \ 
 495: 0000:     IEF.RECL%
 496: 0000:    %INCLUDE IRFDEC.J86                                                 ! FAW
 497: 0000: 
 498: 0000: \**********************************************************************************
 499: 0000: \***
 500: 0000: \***       %INCLUDE FOR ITEM RECORD FILE - FIELD DECLARATIONS
 501: 0000: \***                                     - FILE REFERENCE PARAMETERS
 502: 0000: \***
 503: 0000: \***                      FILE TYPE    : Keyed
 504: 0000: \***
 505: 0000: \***                      REFERENCE    : IRFDEC.J86
 506: 0000: \***
 507: 0000: \***     Version A               Andrew Wedgeworth            29th June 1992
 508: 0000: \***
 509: 0000: \***     Version B               Andrew Wedgeworth        14th December 1992
 510: 0000: \***     Version letter incremented to match other IRF code.
 511: 0000: \***
 512: 0000: \***     Version C             Steve Windsor          12.02.93
 513: 0000: \***     Version letter incremented to match other IRF code.
 514: 0000: \***
 515: 0000: \***     Version D             Steve Windsor          12.05.93
 516: 0000: \***     Version letter incremented to match other IRF code.
 517: 0000: \***
 518: 0000: \***     Version E           Steve Perkins       20th September 1993
 519: 0000: \***     Deals project : Handling of Converted/Unconverted records
 520: 0000: \***     ++   Anything with 'Delete' after initials should be   ++
 521: 0000: \***     ++   deleted once the IRF has been converted in all    ++
 522: 0000: \***     ++   stores.                                           ++
 523: 0000: \***
 524: 0000: \***     Version F           Mark Walker            5th January 1994
 525: 0000: \***     Version letter incremented to match other IRF code.
 526: 0000: \***
 527: 0000: \***     Version 96A         Mark Walker               22nd May 1995
 528: 0000: \***     Definition for IRF.POINTS% added.
 529: 0000: \***
 530: 0000: \***                     Stuart McConnachie           12th June 1995
 531: 0000: \***     INDICAT3% comments added for discount/loyalty flags.
 532: 0000: \***
 533: 0000: \***     Version for 96C  Andrew Wedgeworth            22nd May 1996
 534: 0000: \***     Removed IRF.FILLER$ field, as this is now redundant.
 535: 0000: \***
 536: 0000: \***     Version G     Stuart William McConnachie      11th February 2000
 537: 0000: \***     Converted IRF.INDICAT2$ to integer flag byte.
 538: 0000: \***
 539: 0000: \***     REVISION 1.6.               ROBERT COWEY.               9 JUL 2002.
 540: 0000: \***     Major changes for 2002 Deals Rewrite project.
 541: 0000: \***     Incorporated up to date record layout to assist development work
 542: 0000: \***     (placed in the IRFDEC.J86 to make it visible from ...LST files).
 543: 0000: \***     Moved various comments against variables to record layout.
 544: 0000: \***     Relisted variables in alphabetical order.
 545: 0000: \***     Deleted redundant variables associated with the old deals system ...
 546: 0000: \***     DEAL.NUM$, DEAL.SAVING$
 547: 0000: \***     Retained variables that are otherwise redundant (to be set to null X'00'
 548: 0000: \***     within file functions) ...
 549: 0000: \***     INDICAT2%, INDICAT4%, SALEQUAN$, POINTS%
 550: 0000: \***     Defined variables to hold interpreted deals data for new deals system ...
 551: 0000: \***     DEAL.NUM$(n) and LIST.ID%(n) (where 'n' represents entry 0, 1 and 2).
 552: 0000: \***     These two variables are interpretations of DEAL.DATA% which is defined
 553: 0000: \***     locally within IRFFUN.BAS to keep underlying data invisible to programs.
 554: 0000: \***
 555: 0000: \***     REVISION 1.7                ROBERT COWEY.               5 AUG 2002.
 556: 0000: \***     Further changes for 2002 Deals Rewrite project (PSBF19 related).
 557: 0000: \***     Defined NEW.IRF.DATA$ as a global variable for use with new functions
 558: 0000: \***     CONCAT.NEW.IRF.DATA$ and SPLIT.NEW.IRF.DATA$.
 559: 0000: \***
 560: 0000: \***     REVISION 1.8                ROBERT COWEY.              15 JUL 2003.
 561: 0000: \***     Usage of INDICAT0% bit-3 X'08' changed to Item Contains Alcohol.
 562: 0000: \***     No changes to this file other than description.
 563: 0000: \***     No changes to IRF file functions.
 564: 0000: \***
 565: 0000: \***     REVISION 1.9.      STUART WILLIAM MCCONNACHIE           22 OCT 2003.
 566: 0000: \***     Changes to remove limit of 3 deals per item.
 567: 0000: \***     Declaration of new variables for IRF Deal Extension file (IRFDEX).
 568: 0000: \***
 569: 0000: \***     REVISION 2.0.            ALAN CARR                       9 FEB 2006.
 570: 0000: \***     Add new IRF.INDICAT8% 1 byte, amend IRF.UNUSED$ from 3 to 2 bytes.
 571: 0000: \***
 572: 0000: \***     REVISION 2.1              TITTOO THOMAS                  01 July 2011
 573: 0000: \***     The IRF.UNUSED field is disintegrated to 2 new indicator fields
 574: 0000: \***                      IRF.INDICAT9%   1 INT
 575: 0000: \***                      IRF.INDICAT10%  1 INT
 576: 0000: \***...............................................................................
 577: 0000: 
 578: 0000: 
 579: 0000: \**********************************************************************************
 580: 0000: \***
 581: 0000: \***    IRF RECORD LAYOUT - REVISION 1.7 - CORRECT FOR 2011 CORE Stores PROJECT
 582: 0000: \***
 583: 0000: \***     1 11  UPD  BAR.CODE$   Without check digit - File KEY
 584: 0000: \***    12  1  INT  INDICAT0%
 585: 0000: \***                    X"01" - Contains statins                           ! 2.2 TT
 586: 0000: \***                    X"02" - Item not priced (giveaway)
 587: 0000: \***                    X"04" - Item not returnable
 588: 0000: \***                    X"08" - Item contains alcohol
 589: 0000: \***                    X"10" - Blocked from sale                          ! 2.2 TT
 590: 0000: \***                    X"20" - Enforced price entry
 591: 0000: \***                    X"40" - Enforced quantity entry
 592: 0000: \***                    X"80" - Movement kept
 593: 0000: \***    13  1  INT  INDICAT1%
 594: 0000: \***                    X"01" - Asprin
 595: 0000: \***                    X"02" - Paracetamol
 596: 0000: \***                    X"04" - TPLU inclusion flag
 597: 0000: \***                    X"08" - Giftcard item                              ! 2.2 TT
 598: 0000: \***                    X"10" - Withdrawn Block from sale                  ! 2.2 TT
 599: 0000: \***                    X"20" - Non-solid dose painkiller                  ! 2.2 TT
 600: 0000: \***                    X"40" - Insurance policy item                      ! 2.2 TT
 601: 0000: \***                    X"80" - Ibuprofen
 602: 0000: \***    14  2  INT  DEAL.DATA%(0)   Interpreted into sub-variables ...
 603: 0000: \***                    X'3F' - into DEAL.NUM$(0) "0000" to "9999" (2 byte UPD)
 604: 0000: \***                    X'C0' - into LIST.ID%(0) X'00' X
 605: 0000: \***                                             X'01' A
 606: 0000: \***                                             X'10' B
 607: 0000: \***                                             X'11' C                   ! 1.9 RC
 608: 0000: \***    16  1  INT  INDICAT8%                                              ! 2.0 AJC
 609: 0000: \***                    X"01" - Chlamydia NHS test kit                     ! 2.2 TT
 610: 0000: \***                    X"02" - Chlamydia open sell test kit               ! 2.2 TT
 611: 0000: \***                    X"04" - Unrestricted group code                    ! 2.2 TT
 612: 0000: \***                    X"08" - Nightingale Till prompt                    ! 2.2 TT
 613: 0000: \***                    X"10" - Contains Ephedrine                         ! 2.2 TT
 614: 0000: \***                    X"60" -  X'00' - If also Blocked From Sale Recall, ! 2.2 TT
 615: 0000: \***                                        Emergency                      ! 2.2 TT
 616: 0000: \***                             X'00' - If NOT Blocked From Sale Recall,  ! 2.2 TT
 617: 0000: \***                                        No recall                      ! 2.2 TT
 618: 0000: \***                             X'20' 100% returns                        ! 2.2 TT
 619: 0000: \***                             X'40' Withdrawn recall                    ! 2.2 TT
 620: 0000: \***                             X'60' Reverse Logistics                   ! 2.2 TT
 621: 0000: \***                    X"80" - WEEE item flag                             ! 2.0 AJC
 622: 0000: \***    17  1  INT  INDICAT9%
 623: 0000: \***                    X'3F' - Disposal special instruction (0-63)
 624: 0000: \***                    X"40" - Resaleable Indicator
 625: 0000: \***                    X"80" - Boots.com Extended Indicator
 626: 0000: \***    18  1  INT  INDICAT10%
 627: 0000: \***                    X'07' - Age restrictions
 628: 0000: \***                             X'00' - No Age restriction
 629: 0000: \***                             X'01' - Age 12 or over
 630: 0000: \***                             X'02' - Age 15 or over
 631: 0000: \***                             X'03' - Age 16 or over
 632: 0000: \***                             X'04' - Age 18 or over
 633: 0000: \***                             X'05' - Age 21 or over
 634: 0000: \***                             X'06' - Reserved
 635: 0000: \***                             X'07' - Reserved
 636: 0000: \***                    X'38' - Ethical classification
 637: 0000: \***                             X'00' - No ethical classification
 638: 0000: \***                             X'08' - Pharmacy medicine (P)
 639: 0000: \***                             X'10' - General Sale License (GSL)
 640: 0000: \***                             X'18' - Prescription Only Medicine (POM)
 641: 0000: \***                             X'20' - Reserved
 642: 0000: \***                             X'28' - Reserved
 643: 0000: \***                             X'30' - Reserved
 644: 0000: \***                             X'38' - Reserved
 645: 0000: \***                    X'C0' - Returns route
 646: 0000: \***                             X'00' - Not Returnable (Destroy)
 647: 0000: \***                             X'40' - Returns & Recovery
 648: 0000: \***                             X'80' - Direct
 649: 0000: \***                             X'C0' - Semi-centralised
 650: 0000: \***    19  5  UPD  SALEPRIC$   Current price in pence
 651: 0000: \***    24  1  INT  INDICAT5%   Guarantee duration
 652: 0000: \***                    X'3F' - Lowest 6 bits indicate duration (1-63)
 653: 0000: \***                    X'40' - Contains Pseudoephedrine                   ! 2.2 TT
 654: 0000: \***                    X'80' - Guarantee Duration Type                    ! 2.2 TT
 655: 0000: \***                              (1 = Months, 0 = Years)                  ! 2.2 TT
 656: 0000: \***    25 18  ASC  ITEMNAME$   Description used by till
 657: 0000: \***    43  3  UPD  BOOTS.CODE$ Without check digit
 658: 0000: \***    46  2  INT  DEAL.DATA%(1)   Similar structure to DEAL.DATA%(0)
 659: 0000: \***    48  2  INT  DEAL.DATA%(2)   Similar structure to DEAL.DATA%(0)
 660: 0000: \***    50  1  INT  INDICAT3%
 661: 0000: \***                    X"01" - Discountexempt (item exempt from discount)
 662: 0000: \***                    X"02" - Boots brand item
 663: 0000: \***                    X"04" - Item redeemable for loyalty
 664: 0000: \***                    X"08" - Loyalty exempt (item exempt from loyalty)
 665: 0000: \***                    X"10" - **Redundant                                ! 2.2 TT
 666: 0000: \***                    X"20" - Local Price active
 667: 0000: \***                    X"40" - Stock system item
 668: 0000: \***                    X"80" - **Redundant                                ! 2.2 TT
 669: 0000: \***
 670: 0000: \***    Record Length 50
 671: 0000: \***
 672: 0000: \***
 673: 0000: \***    IRF DEAL EXTENSION RECORD LAYOUT ! 1.9 RC
 674: 0000: \***
 675: 0000: \***     1  3  UPD  BOOTS.CODE$
 676: 0000: \***     4  2  INT  IRF.DEAL.DATA%(3)   Similar structure to DEAL.DATA%(0)
 677: 0000: \***     6  2  INT  IRF.DEAL.DATA%(4)   Similar structure to DEAL.DATA%(0)
 678: 0000: \***     8  2  INT  IRF.DEAL.DATA%(5)   Similar structure to DEAL.DATA%(0)
 679: 0000: \***    10  2  INT  IRF.DEAL.DATA%(6)   Similar structure to DEAL.DATA%(0)
 680: 0000: \***    12  2  INT  IRF.DEAL.DATA%(7)   Similar structure to DEAL.DATA%(0)
 681: 0000: \***    14  2  INT  IRF.DEAL.DATA%(8)   Similar structure to DEAL.DATA%(0)
 682: 0000: \***    16  2  INT  IRF.DEAL.DATA%(9)   Similar structure to DEAL.DATA%(0)
 683: 0000: \***
 684: 0000: \***    Record Length 17
 685: 0000: \***
 686: 0000: \**********************************************************************************
 687: 0000: 
 688: 0000: 
 689: 0000:     STRING GLOBAL            \
 690: 0000:         IRF.ALT.FILE.NAME$,  \
 691: 0000:         IRF.BAR.CODE$,       \
 692: 0000:         IRF.BOOTS.CODE$,     \
 693: 0000:         IRF.DEAL.SAVING$,    \ 2 byte - deal saving amount (0 - œ99.99) ! ESP
 694: 0000:         IRF.DEPARTME$,       \ 3 byte UPD. Department number          ! ESP Delete
 695: 0000:         IRF.FILE.NAME$,      \
 696: 0000:         IRF.HOLDING.PRICE$,  \ 4 byte UPD. Current H.O. price in pence if a local
 697: 0000:                              \ price is in effect, zero otherwise.     ! ESP Delete
 698: 0000:         IRF.ITEMNAME$,       \
 699: 0000: \       IRF.MPGROUP$,        \ Removed SBH 31/1/96
 700: 0000:         IRF.RECORD$,         \                                         ! ESP Delete
 701: 0000:         IRF.SALEPRIC$,       \
 702: 0000:         IRF.SALEQUAN$,       \ Redundant (set to null within functions)    ! 1.6 RC
 703: 0000:         IRF.UNUSED$,         \                                                        ! 1.6 RC
 704: 0000:         NEW.IRF.DATA$        !                                             ! 1.7 RC
 705: 0000: 
 706: 0000:     STRING GLOBAL            \                                             ! 1.6 RC
 707: 0000:         IRF.DEAL.NUM$(1)                                                   ! 1.6 RC
 708: 0000: 
 709: 0000:     INTEGER*1 GLOBAL         \
 710: 0000:         IRF.DD.SUB%,         \ IRF.DEAL.DATA% subscript                    ! 1.6 RC
 711: 0000:         IRF.INDICAT0%,       \
 712: 0000:         IRF.INDICAT1%,       \
 713: 0000:         IRF.INDICAT2%,       \ Redundant (set to null within functions)    ! 1.6 RC
 714: 0000:         IRF.INDICAT3%,       \
 715: 0000:         IRF.INDICAT4%,       \ Redundant (set to null within functions)    ! 1.6 RC
 716: 0000:         IRF.INDICAT5%,       \                                             ! 2.0 AJC
 717: 0000:         IRF.INDICAT8%,       \                                             ! 2.0 AJC
 718: 0000:         IRF.INDICAT9%,       \                                             ! 2.2 TT
 719: 0000:         IRF.INDICAT10%                                                     ! 2.2 TT
 720: 0000: 
 721: 0000:     INTEGER*1 GLOBAL         \                                             ! 1.6 RC
 722: 0000:         IRF.LIST.ID%(1)                                                    ! 1.6 RC
 723: 0000: 
 724: 0000:     INTEGER*2 GLOBAL         \
 725: 0000:         IRF.ALT.REPORT.NUM%, \
 726: 0000:         IRF.ALT.SESS.NUM%,   \
 727: 0000:         IRF.POINTS%,         \ Redundant (set to null within functions)    ! 1.6 RC
 728: 0000:         IRF.RECL%,           \
 729: 0000:         IRF.REPORT.NUM%,     \
 730: 0000:         IRF.SESS.NUM%,       \
 731: 0000:         IRF.MAX.DEALS%       !                                             ! 1.9 SM
 732: 0000: 
 733: 0000:     STRING GLOBAL IRFDEX.FILE.NAME$                                        ! 1.9 SM
 734: 0000: 
 735: 0000:     INTEGER*2 GLOBAL IRFDEX.SESS.NUM%                                      ! 1.9 SM
 736: 0000:     INTEGER*2 GLOBAL IRFDEX.REPORT.NUM%                                    ! 1.9 SM
 737: 0000:     INTEGER*2 GLOBAL IRFDEX.RECL%                                          ! 1.9 SM
 738: 0000: 
 739: 0000: 
 740: 0000: !   INTEGER*2 GLOBAL      \ IRF.DEAL.DATA%(n) variables are defined locally  1.6 RC
 741: 0000: !       IRF.DEAL.DATA%(1) \ within IRFFUN.BAS to keep invisible to programs  1.6 RC
 742: 0000: 
 743: 0000:    %INCLUDE PPFDEC.J86                                                 ! FAW
 744: 0000: 
 745: 0000: \REM
 746: 0000: \*******************************************************************************
 747: 0000: \*******************************************************************************
 748: 0000: \***
 749: 0000: \***    %INCLUDE FOR PENDING PRICES FILES VARIABLE DECLARATIONS
 750: 0000: \***
 751: 0000: \***        REFERENCE   :   PPFDEC (J86)
 752: 0000: \***
 753: 0000: \***        FILE TYPE   :   Sequential
 754: 0000: \***
 755: 0000: \***    VERSION D.              ROBERT COWEY.                       23 AUG 1993.
 756: 0000: \***    Original version created by combining PPFFLDC, PPFINUMC and PPFONUMC.
 757: 0000: \***
 758: 0000: \***    VERSION E.              ROBERT COWEY.                       26 OCT 1993.
 759: 0000: \***    Removed SPLAN.ID$ from RPD and Deal records.
 760: 0000: \***    Defined Link-Save Multi-Buy Deal record.
 761: 0000: \***
 762: 0000: \***    VERSION F               BRIAN GREENFIELD                    24 JUN 2004.
 763: 0000: \***    Added Markdown variables to RPD record.
 764: 0000: \***    
 765: 0000: \*******************************************************************************
 766: 0000: \*******************************************************************************
 767: 0000: 
 768: 0000: 
 769: 0000: \*******************************************************************************
 770: 0000: \*******************************************************************************
 771: 0000: \***
 772: 0000: \***    RECORD LAYOUTS
 773: 0000: \***
 774: 0000: \***    TRAILER RECORD
 775: 0000: \***
 776: 0000: \***     1  7  ASC  BOOTS.CODE$     "99999999"
 777: 0000: \***     8  1  ASC  REC.TYPE.FLAG$  "T" Trailer
 778: 0000: \***     9  5  ASC  REC.COUNT$
 779: 0000: \***
 780: 0000: \***    RPD RECORD
 781: 0000: \***
 782: 0000: \***     1  7  ASC  BOOTS.CODE$       Boots code including check digit
 783: 0000: \***     8  1  ASC  REC.TYPE.FLAG$    "R" RPD
 784: 0000: \***     9  6  ASC  DATE.DUE$         YYMMDD
 785: 0000: \***    15  5  ASC  RPD.NO$
 786: 0000: \***    20  1  ASC  STATUS.FLAG$      "S" label printed but price not effected
 787: 0000: \***                                  "L" Locally priced - No label printed
 788: 0000: \***                                  "D" Deal priced - No label printed
 789: 0000: \***                                  " " Yet to be processed
 790: 0000: \***    21  1  ASC  INC.DEC.FLAG$     "D", "I", (" " if no change or deal price)
 791: 0000: \***    22  8  ASC  PRICE$
 792: 0000: \***    30  1  ASC  MARKDOWN$         Mark-down "Y" or "N"               ! FBG
 793: 0000: \***
 794: 0000: \***    DEAL PRICE RECORD
 795: 0000: \***
 796: 0000: \***     1  7  ASC  BOOTS.CODE$       Boots code including check digit
 797: 0000: \***     8  1  ASC  REC.TYPE.FLAG$    "D" Deal price
 798: 0000: \***     9  1  ASC  DEAL.TYPE$        "0", "1", "2", "3"
 799: 0000: \***    10  2  ASC  DEAL.QUANTITY$
 800: 0000: \***    12  5  ASC  SPECIAL.PRICE$
 801: 0000: \***    17  2  ASC  M.P.GROUP$
 802: 0000: \***    19  6  ASC  FIRST.DATE$       YYMMDD
 803: 0000: \***    25  6  ASC  LAST.DATE$        YYMMDD
 804: 0000: \***    31  1  ASC  EFFECT.FLAG$
 805: 0000: \***
 806: 0000: \***    LINK-SAVE MULTI-BUY DEAL RECORD
 807: 0000: \***
 808: 0000: \***     1  7  ASC  BOOTS.CODE$       Boots code including check digit
 809: 0000: \***     8  1  ASC  REC.TYPE.FLAG$    "B" Link-Save Multi-Buy deal record
 810: 0000: \***     9  1  ASC  DEAL.ID$          "M", "A", "B", "X"
 811: 0000: \***    10  1  ASC  PAIR.TRIP.FLAG$   "P", "T", " "
 812: 0000: \***    11  1  ASC  3FOR2.FLAG$       "T", " "
 813: 0000: \***    12  2  ASC  DEAL.LIMIT$       1 to 15
 814: 0000: \***    14  4  ASC  DEAL.NUM$         1 to 9999
 815: 0000: \***    18  4  ASC  SAVED.AMOUNT$     0 to 9999
 816: 0000: \***    22  6  ASC  DEAL.DATE.START$  YYMMDD of deal start
 817: 0000: \***    28  6  ASC  DEAL.DATE.FINISH$ YYMMDD of deal finish
 818: 0000: \***    34  1  ASC  ACTIVE.FLAG$      "Y", "N"
 819: 0000: \***
 820: 0000: \*******************************************************************************
 821: 0000: \*******************************************************************************
 822: 0000: \***
 823: 0000: \***    OTHER INFORMATION
 824: 0000: \***
 825: 0000: \***    Prefixes PPFI... and PPFO... are used for variables that are specific
 826: 0000: \***    to the INPUT or OUTPUT usage of the file.
 827: 0000: \***
 828: 0000: \*******************************************************************************
 829: 0000: \*******************************************************************************
 830: 0000: 
 831: 0000:  
 832: 0000:     STRING GLOBAL \
 833: 0000:         PPF.3FOR2.FLAG$, \                                             ! ERC
 834: 0000:         PPF.ACTIVE.FLAG$, \                                            ! ERC
 835: 0000:         PPF.BOOTS.CODE$, \
 836: 0000:         PPF.DATE.DUE$, \
 837: 0000:         PPF.DEAL.DATE.FINISH$, \                                       ! ERC
 838: 0000:         PPF.DEAL.DATE.START$, \                                        ! ERC
 839: 0000:         PPF.DEAL.ID$, \                                                ! ERC
 840: 0000:         PPF.DEAL.LIMIT$, \                                             ! ERC
 841: 0000:         PPF.DEAL.NUM$, \                                               ! ERC
 842: 0000:         PPF.DEAL.QUANTITY$, \
 843: 0000:         PPF.DEAL.TYPE$, \
 844: 0000:         PPF.EFFECT.FLAG$, \
 845: 0000:         PPF.FIRST.DATE$, \
 846: 0000:         PPF.INC.DEC.FLAG$, \
 847: 0000:         PPF.LAST.DATE$, \
 848: 0000:         PPF.MARKDOWN$, \                                               ! FBG
 849: 0000:         PPF.M.P.GROUP$, \
 850: 0000:         PPF.PAIR.TRIP.FLAG$, \                                         ! ERC
 851: 0000:         PPF.PRICE$, \
 852: 0000:         PPF.REC.COUNT$, \
 853: 0000:         PPF.REC.TYPE.FLAG$, \
 854: 0000:         PPF.RECORD$, \
 855: 0000:         PPF.RPD.NO$, \
 856: 0000:         PPF.SAVED.AMOUNT$, \                                           ! ERC
 857: 0000:         PPF.SPECIAL.PRICE$, \
 858: 0000:         PPF.STATUS.FLAG$, \
 859: 0000:         PPFI.3FOR2.FLAG$, \                                            ! ERC
 860: 0000:         PPFI.ACTIVE.FLAG$, \                                           ! ERC
 861: 0000:         PPFI.BOOTS.CODE$, \
 862: 0000:         PPFI.DATE.DUE$, \
 863: 0000:         PPFI.DEAL.DATE.FINISH$, \                                      ! ERC
 864: 0000:         PPFI.DEAL.DATE.START$, \                                       ! ERC
 865: 0000:         PPFI.DEAL.ID$, \                                               ! ERC
 866: 0000:         PPFI.DEAL.LIMIT$, \                                            ! ERC
 867: 0000:         PPFI.DEAL.NUM$, \                                              ! ERC
 868: 0000:         PPFI.DEAL.QUANTITY$, \
 869: 0000:         PPFI.DEAL.TYPE$, \
 870: 0000:         PPFI.EFFECT.FLAG$, \
 871: 0000:         PPFI.FILE.NAME$, \
 872: 0000:         PPFI.FIRST.DATE$, \
 873: 0000:         PPFI.INC.DEC.FLAG$, \
 874: 0000:         PPFI.LAST.DATE$, \
 875: 0000:         PPFI.MARKDOWN$, \                                               ! FBG
 876: 0000:         PPFI.M.P.GROUP$, \
 877: 0000:         PPFI.PAIR.TRIP.FLAG$, \                                        ! ERC
 878: 0000:         PPFI.PRICE$, \
 879: 0000:         PPFI.REC.COUNT$, \
 880: 0000:         PPFI.REC.TYPE.FLAG$, \
 881: 0000:         PPFI.RECORD$, \
 882: 0000:         PPFI.RPD.NO$, \
 883: 0000:         PPFI.SAVED.AMOUNT$, \                                          ! ERC
 884: 0000:         PPFI.SPECIAL.PRICE$, \
 885: 0000:         PPFI.STATUS.FLAG$, \
 886: 0000:         PPFO.FILE.NAME$
 887: 0000: 
 888: 0000:     INTEGER*2 GLOBAL \
 889: 0000:         PPFI.REPORT.NUM%, \
 890: 0000:         PPFO.REPORT.NUM%, \
 891: 0000:         PPFI.SESS.NUM%, \
 892: 0000:         PPFO.SESS.NUM%
 893: 0000: 
 894: 0000:    %INCLUDE LOCALDEC.J86                                               ! FAW
 895: 0000: \******************************************************************************
 896: 0000: \******************************************************************************
 897: 0000: \***
 898: 0000: \***   $Workfile:   LOCALDEC.J86  $
 899: 0000: \***
 900: 0000: \***   $Revision:   1.1  $
 901: 0000: \***
 902: 0000: \******************************************************************************
 903: 0000: \******************************************************************************
 904: 0000: \***
 905: 0000: \***   $Log:   V:\archive\j86\localdec.j8v  $
 906: 0000: \***   
 907: 0000: \***      Rev 1.1   06 Dec 1994 17:32:36   DEVMJPS
 908: 0000: \***    
 909: 0000: \***   
 910: 0000: \******************************************************************************
 911: 0000: \******************************************************************************
 912: 0000: \*****************************************************************************
 913: 0000: \***            %INCLUDE FOR LOCAL DATA FILE
 914: 0000: \***               - FIELD DECLARATIONS
 915: 0000: \***               - FILE REFERENCE PARAMETERS
 916: 0000: \***               FILE TYPE    : Keyed
 917: 0000: \***               REFERENCE    : LOCALDE.J86
 918: 0000: \***            Version A    Paul Flannagan         1st July 1993
 919: 0000: \***
 920: 0000: \***            Version B    Clive Norris           24th November 1993
 921: 0000: \***       (Replaced filler with AUTH.NUM$, STOCK.FIG%, and RETRIEVAL.FLAG$
 922: 0000: \***       as part of RETURNS/AUTOMATIC CREDIT CLAIMING project)
 923: 0000: \***
 924: 0000: \***            Version C    Mick Bayliss            6 Dec 1994       
 925: 0000: \***       Add missing field.
 926: 0000: \*** 
 927: 0000: \*****************************************************************************
 928: 0000: 
 929: 0000:   STRING GLOBAL           \
 930: 0000:     LOCAL.FILE.NAME$,     \
 931: 0000:     LOCAL.ITEM.CODE$,     \ 4 bytes UPD (key) Boots code with check digit. 
 932: 0000:     LOCAL.PRICE$,         \ 5 bytes UPD.
 933: 0000:     LOCAL.START.DATE$,    \ 3 bytes UPD yymmdd. 
 934: 0000:     LOCAL.START.TIME$,    \ 2 bytes UPD hhmm .
 935: 0000:     LOCAL.END.DATE$,      \ 3 bytes UPD yymmdd.
 936: 0000:     LOCAL.OPERATOR$,      \ 4 bytes UPD operator id (when set up).
 937: 0000:     LOCAL.REASON$,        \ 4 byte ASCII 
 938: 0000:     LOCAL.H.O.PRICE$,     \ 5 byte UPD.
 939: 0000:     LOCAL.HO.CHANGE$,     \ 3 bytes UPD. Date of head office price change
 940: 0000:                           \ (this will be zero if no change since local
 941: 0000:                              \ price was initiated).
 942: 0000:     LOCAL.AUTH.NUM$,      \ 4 bytes UPD Auth'n number from Business Centre.
 943: 0000:     LOCAL.RETRIEVAL.FLAG$,\ 1 byte ASC; "Y" or "N"  
 944: 0000:     LOCAL.SPACE$          !                                            !CMJB
 945: 0000:         
 946: 0000:   INTEGER*2 GLOBAL        \
 947: 0000:     LOCAL.SESS.NUM%,      \
 948: 0000:     LOCAL.REPORT.NUM%,    \
 949: 0000:     LOCAL.RECL%,          \
 950: 0000:     LOCAL.STOCK.FIG%      !  No. of items authorised at the price.  
 951: 0000: 
 952: 0000:     STRING                                                             \
 953: 0000:           ACD.FLAG$,                                                   \
 954: 0000:           B7201.SCREEN.NO$,                                            \
 955: 0000:           B7203.SCREEN.NO$,                                            \
 956: 0000:           BAR.CODE.FRONT$,                                             \
 957: 0000: \         CALLING.PROG.NO$,                                            \ ! 1.19 RC
 958: 0000:           CURRENT.BOOTS.CODE$,                                         \
 959: 0000:           CURRENT.IEF.BAR.CODE$,                                       \
 960: 0000:           CURRENT.KEY$,                                                \
 961: 0000: \         CURRENT.SCREEN$,                                             \ ! 1.19 RC
 962: 0000:           DEAL.PRICE$,                                                 \
 963: 0000:           DECREASES.RUN.ALREADY.FLAG$,                                 \
 964: 0000:           DECREASE.PERFORMED.$,                                        \
 965: 0000:           DISP.2.TABLE$(1),                                            \
 966: 0000:           DISPLAY.TABLE$(1),                                           \
 967: 0000:           DISP.TABLE.FLAG$,                                            \
 968: 0000:           EFFECT.FLAG$,                                                \
 969: 0000:           END.LOOP$,                                                   \
 970: 0000:           END.OF.FILE$,                                                \
 971: 0000:           ERRL.STRING$,                                                \
 972: 0000:           ERRN.STRING$,                                                \
 973: 0000:           FAIL.TYPE$,                                                  \
 974: 0000: \         FIRST.DATA.STRING$,                                          \ 1.20 RC
 975: 0000:           FIRST.EAN$,                                                  \
 976: 0000:           IDF.BAR.CODE$,                                               \
 977: 0000:           IDF.GROUP.EAN.CODE$,                                         \
 978: 0000:           INC.DEC$,                                                    \
 979: 0000: \         INDICAT2$,                                                   \ HSWM
 980: 0000:           IRF.LOCKED.FLAG$,                                            \ BMW
 981: 0000:           KEY$,                                                        \ BMW
 982: 0000:           LOCAL.PRICE.FLAG$,                                           \
 983: 0000:           MATCH.FOUND$,                                                \
 984: 0000:           MOVE.CURSOR$,                                                \
 985: 0000: \         PPFI.OPEN.FLAG$,                                             \ BMW ! 1.19 RC
 986: 0000:           PPFI.TRAILER.ERROR$,                                         \
 987: 0000:           PPFO.THERE.FLAG$,                                            \
 988: 0000:           QUIT.FLAG$,                                                  \
 989: 0000:           QUIT.PRESSED$,                                               \
 990: 0000:           RESF.CALLED$,                                                \
 991: 0000: \         SALEQUAN$,                                                   \ HSWM
 992: 0000:           SAVED.DISP.FLAG$,                                            \
 993: 0000:           SAVED.DISP.MESSAGE$,                                         \
 994: 0000:           SAVED.ENTRY$,                                                \
 995: 0000:           SAVED.IDF.BOOTS.CODE$,                                       \
 996: 0000: \         SAVED.INDICAT2$,                                             \ HSWM
 997: 0000:           SAVED.PRICE$,                                                \
 998: 0000: \         SAVED.SALEQUAN$,                                             \ IBG SAVED.SALEQUAN$ REMOVED
 999: 0000:           SB.ACTION$,                                                  \ BMW
1000: 0000:           SB.STRING$,                                                  \ BMW
1001: 0000:           SB.FILE.NAME$,                                               \ BMW
1002: 0000: \         SECOND.DATA.STRING$,                                         \ 1.20 RC
1003: 0000:           SELECTION$,                                                  \
1004: 0000:           STRING.DATA$,                                                \
1005: 0000:           TABLE.DATE$,                                                 \
1006: 0000:           UNIQUE$,                                                     \
1007: 0000:           UPDATE.FAILED$,                                              \
1008: 0000:           VARIABLE.STRING$,                                            \
1009: 0000:           VAR.STRING.1$,                                               \
1010: 0000:           VAR.STRING.2$,                                               \
1011: 0000:           ZERO.ENTRY.FLAG$
1012: 0000: 
1013: 0000: STRING GLOBAL BOOTS.CODE.SIX.DIGIT$, BOOTS.CODE.SEVEN.DIGIT$,          \DSJW
1014: 0000:               SAVED.DEAL.NUM$(1),                                      \DSJW IBG SAVED.DEAL.SAVING$ REMOVED
1015: 0000:               CURRENT.DATE$, BATCH.SCREEN.FLAG$, OPERATOR.NUMBER$,     \DSJW
1016: 0000:               MODULE.NUMBER$, DATE.NEXT.WEEK$                          !DSJW
1017: 0000: 
1018: 0000: INTEGER*1 GLOBAL TRUE, FALSE, LOCAL.FILE.OPEN                          !DSJW
1019: 0000: 
1020: 0000:     INTEGER*1                                                          \
1021: 0000:           BIT.7.MASK%,                                                 \
1022: 0000:           EVENT.NO%,                                                   \
1023: 0000:           GROUP.CODE.FLAG%,                                            \
1024: 0000:           MSGGRP%,                                                     \
1025: 0000:           SEVERITY%, SAVED.INDICAT3%, FORTNIGHT%,                      \DSJW  IBG SAVED.INDICAT4% REMOVED
1026: 0000: \         SAVED.INDICAT2%,                                             \HSWM IBG SAVED.INDICAT2% REMOVED
1027: 0000:           SAVED.INDICAT5%,                                             \GSB
1028: 0000:           SAVED.LIST.ID%(1)                                            !IBG 
1029: 0000: 
1030: 0000:     INTEGER*2                                                          \
1031: 0000:           CURRENT.ENTRY%,                                              \
1032: 0000:           CURRENT.FIELD%,                                              \
1033: 0000:           CURRENT.PAGE%,                                               \
1034: 0000:           CURRENT.SESS.NUM%,                                           \
1035: 0000:           DISPLAY.ENTRY%,                                              \
1036: 0000: \         DISPLAY.INDEX%,                                              \ ! 1.19 RC
1037: 0000:           END.KEY%,                                                    \
1038: 0000:           ENTER%,                                                      \
1039: 0000:           ESCAPE%,                                                     \
1040: 0000:           EXIT.KEY%,                                                   \ BMW
1041: 0000:           HELP%,                                                       \
1042: 0000:           HOME%,                                                       \
1043: 0000:           INDEX%,                                                      \
1044: 0000:           INTEGER.DATA%,                                               \
1045: 0000:           LINES%,                                                      \
1046: 0000:           KEY.PRESSED%,                                                \
1047: 0000:           LAST.INPUT.FIELD.NO%,                                        \
1048: 0000:           MESSAGE.NO%,                                                 \
1049: 0000:           MSGNUM%,                                                     \
1050: 0000:           NEXTF.PARM%,                                                 \
1051: 0000:           NUM.ON.PAGE%,                                                \
1052: 0000:           PAGE.DOWN%,                                                  \
1053: 0000:           PAGE.UP%,                                                    \
1054: 0000:           QUIT%,                                                       \
1055: 0000:           RENAME.RET.CODE%,                                            \
1056: 0000:           RETURN.FIELD%,                                               \
1057: 0000:           SB.INTEGER%,                                                 \ BMW
1058: 0000:           SB.FILE.SESS.NUM%,                                           \ BMW
1059: 0000:           SB.FILE.REP.NUM%,                                            \ BMW
1060: 0000:           TAB%,                                                        \
1061: 0000:           TERM%
1062: 0000: 
1063: 0000: INTEGER*2 GLOBAL PPFO.BUFF.SIZE%, RC%, PPFI.BUFF.SIZE%, I%, SUB%        !DSJW
1064: 0000: 
1065: 0000:     INTEGER*4                                                          \
1066: 0000:           COUNT%,                                                      \
1067: 0000:           DISPLAY.COUNT%,                                              \
1068: 0000:           ENTRY.COUNT%,                                                \
1069: 0000:           INTEGER.4%,                                                  \
1070: 0000:           PPFI.RECORD.COUNT%,                                          \
1071: 0000:           PPFI.TRAILER.COUNT%,                                         \
1072: 0000:           PPFO.RECORD.COUNT%,                                          \
1073: 0000: \         REDEEM.POINTS%,                                              \ FAW ! 1.19 RC
1074: 0000:           RPD.NUMBER%,                                                 \
1075: 0000:           TABLE.LIMIT.14K%,                                            \ 1.20 RC
1076: 0000:           TOTAL.BAR.CODE.COUNT%,                                       \
1077: 0000:           TOTAL.ENTRIES%,                                              \
1078: 0000:           TOTAL.PAGES%
1079: 0000: 
1080: 0000: \...............................................................................
1081: 0000: \***
1082: 0000: \***   %INCLUDE external definition of ADXERROR function
1083: 0000: \***   %INCLUDE external definition of APPLICATION.LOG function
1084: 0000: \***   %INCLUDE external definition of DISPLAY.MANAGER functions
1085: 0000: \***   %INCLUDE external definition of EXTERNAL.MESSAGE function
1086: 0000: \***   %INCLUDE external definition of READ.NEXT.IEF function
1087: 0000: \***   %INCLUDE external definition of HELP function
1088: 0000: \***   %INCLUDE external definition of SORT.TABLE function
1089: 0000: \***   %INCLUDE external definition of CONV.TO.HEX function
1090: 0000: \***   %INCLUDE external definition of CONV.TO.STRING function
1091: 0000: \***   %INCLUDE external definition of IRF.UPDATE function
1092: 0000: \***   %INCLUDE i/o function definitions of IDF
1093: 0000: \***   %INCLUDE i/o function definitions of IEF
1094: 0000: \***   %INCLUDE i/o function definitions of IRF
1095: 0000: \***   %INCLUDE i/o function definitions of PPFI
1096: 0000: \***   %INCLUDE i/o function definitions of PPFO
1097: 0000: \***
1098: 0000: \...............................................................................
1099: 0000: 
1100: 0000:    %INCLUDE ADXERROR.J86                                               ! FAW
1101: 0000: \******************************************************************************
1102: 0000: \******************************************************************************
1103: 0000: \***                                                                        ***
1104: 0000: \***    %INCLUDE FOR FUNCTION ADXERROR (an I.B.M. system function)          ***
1105: 0000: \***                                                                        ***
1106: 0000: \***         AUTHOR        :  Stephen Kelsey                                ***
1107: 0000: \***                                                                        ***
1108: 0000: \***         DATE WRITTEN  :  21st February 1986                            ***
1109: 0000: \***                                                                        ***
1110: 0000: \***         DATE OF LAST REVISION  - 21st February 1986                    ***
1111: 0000: \***                                                                        ***
1112: 0000: \***         VERSION B     :  Stuart William McConnachie  18th March 1997   ***
1113: 0000: \***    Define size of ADXERROR return value from function.  This change    ***
1114: 0000: \***    was introduced by IBM in the 4690 Programming Guide.  Not defining  ***
1115: 0000: \***    this variable can cause Memory Protection Violations at run time.   ***
1116: 0000: \***                                                                        ***
1117: 0000: \******************************************************************************
1118: 0000: \******************************************************************************
1119: 0000: 
1120: 0000:    FUNCTION ADXERROR (TERM%,                                                  \
1121: 0000:                       MSGGRP%,                                                \
1122: 0000:                       MSGNUM%,                                                \
1123: 0000:                       SEVERITY%,                                              \
1124: 0000:                       EVENT.NUM%,                                             \
1125: 0000:                       UNIQUE$) EXTERNAL
1126: 0000: 
1127: 0000:       INTEGER*2  MSGNUM%,                                                     \
1128: 0000:                  TERM%,                                                       \
1129: 0000:                  ADXERROR                                                     !BSWM
1130: 0000: 
1131: 0000:       INTEGER*1 EVENT.NUM%,                                                   \
1132: 0000:                 MSGGRP%,                                                      \
1133: 0000:                 SEVERITY%
1134: 0000: 
1135: 0000:       STRING  UNIQUE$
1136: 0000: 
1137: 0000:    END FUNCTION
1138: 0000: 
1139: 0000:    %INCLUDE PSBF01E.J86                                                ! FAW
1140: 0000: REM \
1141: 0000: \*******************************************************************************
1142: 0000: \*******************************************************************************
1143: 0000: \***
1144: 0000: \***      %INCLUDE FOR EXTERNAL DEFINITION OF FUNCTION APPLICATION.LOG
1145: 0000: \***
1146: 0000: \***                      FUNCTION NUMBER   : PSBF01
1147: 0000: \***
1148: 0000: \***                    INCLUDE REFERENCE : PSBF01E.J86
1149: 0000: \*** 
1150: 0000: \***      Version B           Andrew Wedgeworth          1st July 1992
1151: 0000: \***      Three parameters which passed to the function have been removed.
1152: 0000: \***      APPLICATION.LOG has been added as a variable name (this holds the
1153: 0000: \***      return code).
1154: 0000: \***
1155: 0000: \*******************************************************************************
1156: 0000: 
1157: 0000: 
1158: 0000:    FUNCTION APPLICATION.LOG (MESSAGE.NO%,                                     \
1159: 0000:                              VAR.STRING.1$,                                   \
1160: 0000:                              VAR.STRING.2$,                                   \
1161: 0000:                              EVENT.NO%)  EXTERNAL
1162: 0000: 
1163: 0000:       INTEGER*1 EVENT.NO%
1164: 0000: 
1165: 0000:       INTEGER*2 APPLICATION.LOG,                                       \ GAW
1166: 0000:                 MESSAGE.NO%
1167: 0000: 
1168: 0000:       STRING VAR.STRING.1$,                                            \
1169: 0000:              VAR.STRING.2$
1170: 0000: 
1171: 0000:    END FUNCTION
1172: 0000: 
1173: 0000: \*******************************************************************************
1174: 0000:    %INCLUDE PSBF02E.J86                                                ! FAW
1175: 0000: REM\
1176: 0000: \*******************************************************************************
1177: 0000: \*******************************************************************************
1178: 0000: \***
1179: 0000: \***        INCLUDE       : UPDATE.DATE external definition
1180: 0000: \***        AUTHOR        : Bruce Scriver (Basic Code)
1181: 0000: \***        DATE WRITTEN  : 4th March 1986 (Basic Code)
1182: 0000: \***
1183: 0000: \***        REFERENCE     : PSBF02E.J86
1184: 0000: \***
1185: 0000: \***        Version A     Bruce Scriver          4th March 1986
1186: 0000: \***
1187: 0000: \***        Version B     Andrew Wedgeworth       6th July 1992
1188: 0000: \***        Removal of redundant parameters, and inclusion of UPDATE.DATE as
1189: 0000: \***        a variable to hold the return code.
1190: 0000: \***
1191: 0000: \*******************************************************************************
1192: 0000: \*******************************************************************************
1193: 0000: 
1194: 0000:    FUNCTION UPDATE.DATE (INCREMENT%)                                   \
1195: 0000:    EXTERNAL
1196: 0000:    ! 3 parameters removed from here                                    ! BAW
1197: 0000: 
1198: 0000:    ! 3 lines deleted from here                                         ! BAW
1199: 0000:    
1200: 0000:       INTEGER*2 UPDATE.DATE                                            ! BAW
1201: 0000: 
1202: 0000:       INTEGER*4 INCREMENT%
1203: 0000: 
1204: 0000:    END FUNCTION
1205: 0000: 
1206: 0000:    %INCLUDE PSBF03E.J86                                                ! FAW
1207: 0000: REM \
1208: 0000: \*******************************************************************************
1209: 0000: \***
1210: 0000: \***    %INCLUDED CODE FOR EXTERNAL DEFINITIONS OF DISPLAY MANAGER FUNCTIONS
1211: 0000: \***     
1212: 0000: \***            REFERENCE       : PSBF03E.J86     
1213: 0000: \***     
1214: 0000: \***            DATE.WRITTEN    : 21/03/1986     
1215: 0000: \***     
1216: 0000: \***    Version B              Andrew Wedgeworth              21st July 1992
1217: 0000: \***    Remove redundant function parameters (BATCH.SCREEN.FLAG$, 
1218: 0000: \***    MODULE.NUMBER$ and OPERATOR.NUMBER$).  Function names defined as 
1219: 0000: \***    variables to hold return codes.
1220: 0000: \***
1221: 0000: \*******************************************************************************
1222: 0000: 
1223: 0000:    FUNCTION DM.INITDM (STRING.DATA$,                                   \
1224: 0000:                        INTEGER.DATA%)   EXTERNAL
1225: 0000: 
1226: 0000:       STRING      STRING.DATA$
1227: 0000: 
1228: 0000:       INTEGER*2   DM.INITDM,                                           \ BAW
1229: 0000:                   INTEGER.DATA%
1230: 0000:                          
1231: 0000:      
1232: 0000: 
1233: 0000:    END FUNCTION
1234: 0000: 
1235: 0000:    FUNCTION DM.CLRSCR (STRING.DATA$,                                   \
1236: 0000:                        INTEGER.DATA%)   EXTERNAL
1237: 0000: 
1238: 0000:       STRING      STRING.DATA$
1239: 0000: 
1240: 0000:       INTEGER*2   DM.CLRSCR,                                           \ BAW
1241: 0000:                   INTEGER.DATA%
1242: 0000: 
1243: 0000:    END FUNCTION
1244: 0000: 
1245: 0000:    FUNCTION DM.CLSDIS (STRING.DATA$,                                   \
1246: 0000:                        INTEGER.DATA%)   EXTERNAL
1247: 0000: 
1248: 0000:       STRING      STRING.DATA$
1249: 0000: 
1250: 0000:       INTEGER*2   DM.CLSDIS,                                           \ BAW
1251: 0000:                   INTEGER.DATA%
1252: 0000: 
1253: 0000:    END FUNCTION
1254: 0000: 
1255: 0000:    FUNCTION DM.OPNDIS (STRING.DATA$,                                   \
1256: 0000:                        INTEGER.DATA%)   EXTERNAL
1257: 0000: 
1258: 0000:       STRING      STRING.DATA$
1259: 0000: 
1260: 0000:       INTEGER*2   DM.OPNDIS,                                           \ BAW 
1261: 0000:                   INTEGER.DATA%
1262: 0000: 
1263: 0000:    END FUNCTION
1264: 0000: 
1265: 0000:    FUNCTION DM.DISPD  (STRING.DATA$,                                   \
1266: 0000:                        INTEGER.DATA%)   EXTERNAL
1267: 0000: 
1268: 0000:       STRING      STRING.DATA$
1269: 0000: 
1270: 0000:       INTEGER*2   DM.DISPD,                                            \ BAW
1271: 0000:                   INTEGER.DATA%
1272: 0000: 
1273: 0000:    END FUNCTION
1274: 0000: 
1275: 0000:    FUNCTION DM.RETDM  (STRING.DATA$,                                   \
1276: 0000:                        INTEGER.DATA%)   EXTERNAL
1277: 0000: 
1278: 0000:       STRING      STRING.DATA$
1279: 0000: 
1280: 0000:       INTEGER*2   DM.RETDM,                                            \ BAW 
1281: 0000:                   INTEGER.DATA%
1282: 0000: 
1283: 0000:    END FUNCTION
1284: 0000: 
1285: 0000:    FUNCTION DM.CURS   (STRING.DATA$,                                   \
1286: 0000:                        INTEGER.DATA%)   EXTERNAL
1287: 0000: 
1288: 0000:       STRING      STRING.DATA$
1289: 0000: 
1290: 0000:       INTEGER*2   DM.CURS,                                             \ BAW      
1291: 0000:                   INTEGER.DATA%
1292: 0000: 
1293: 0000:    END FUNCTION
1294: 0000: 
1295: 0000:    FUNCTION DM.RETF   (STRING.DATA$,                                   \
1296: 0000:                        INTEGER.DATA%)   EXTERNAL
1297: 0000: 
1298: 0000:       STRING      STRING.DATA$
1299: 0000: 
1300: 0000:       INTEGER*2   DM.RETF,                                             \ BAW
1301: 0000:                   INTEGER.DATA%
1302: 0000: 
1303: 0000:    END FUNCTION
1304: 0000: 
1305: 0000:    FUNCTION DM.SETF   (STRING.DATA$,                                   \
1306: 0000:                        INTEGER.DATA%)   EXTERNAL
1307: 0000: 
1308: 0000:       STRING      STRING.DATA$
1309: 0000: 
1310: 0000:       INTEGER*2   DM.SETF,                                             \ BAW
1311: 0000:                   INTEGER.DATA%
1312: 0000: 
1313: 0000:    END FUNCTION
1314: 0000: 
1315: 0000:    FUNCTION DM.POSF   (STRING.DATA$,                            \
1316: 0000:                        INTEGER.DATA%)   EXTERNAL
1317: 0000: 
1318: 0000:       STRING      STRING.DATA$
1319: 0000: 
1320: 0000:       INTEGER*2   DM.POSF,                                             \ BAW
1321: 0000:                   INTEGER.DATA%
1322: 0000: 
1323: 0000:    END FUNCTION
1324: 0000: 
1325: 0000:    FUNCTION DM.NEXTF  (STRING.DATA$,                                   \
1326: 0000:                        INTEGER.DATA%)   EXTERNAL
1327: 0000: 
1328: 0000:       STRING      STRING.DATA$
1329: 0000: 
1330: 0000:       INTEGER*2   DM.NEXTF,                                            \ BAW
1331: 0000:                   INTEGER.DATA%
1332: 0000: 
1333: 0000:    END FUNCTION
1334: 0000: 
1335: 0000:    FUNCTION DM.PUTF   (STRING.DATA$,                                   \
1336: 0000:                        INTEGER.DATA%)   EXTERNAL
1337: 0000: 
1338: 0000:       STRING      STRING.DATA$
1339: 0000: 
1340: 0000:       INTEGER*2   DM.PUTF,                                             \ BAW
1341: 0000:                   INTEGER.DATA%
1342: 0000: 
1343: 0000:    END FUNCTION
1344: 0000: 
1345: 0000:    FUNCTION DM.GETF   (STRING.DATA$,                                   \ BAW
1346: 0000:                        INTEGER.DATA%)   EXTERNAL
1347: 0000: 
1348: 0000:       STRING      STRING.DATA$
1349: 0000: 
1350: 0000:       INTEGER*2   DM.GETF,                                             \ BAW 
1351: 0000:                   INTEGER.DATA%
1352: 0000: 
1353: 0000:    END FUNCTION
1354: 0000: 
1355: 0000:    FUNCTION DM.UPDF   (STRING.DATA$,                                   \
1356: 0000:                        INTEGER.DATA%)   EXTERNAL
1357: 0000: 
1358: 0000:       STRING      STRING.DATA$
1359: 0000: 
1360: 0000:       INTEGER*2   DM.UPDF,                                             \ BAW
1361: 0000:                   INTEGER.DATA%
1362: 0000: 
1363: 0000:    END FUNCTION
1364: 0000: 
1365: 0000:    FUNCTION DM.RESF   (STRING.DATA$,                                   \
1366: 0000:                        INTEGER.DATA%)   EXTERNAL
1367: 0000: 
1368: 0000:       STRING      STRING.DATA$
1369: 0000: 
1370: 0000:       INTEGER*2   DM.RESF,                                             \ BAW
1371: 0000:                   INTEGER.DATA%
1372: 0000: 
1373: 0000:    END FUNCTION
1374: 0000: 
1375: 0000: \*******************************************************************************
1376: 0000:    %INCLUDE PSBF04E.J86                                                ! FAW
1377: 0000: REM \
1378: 0000: \*******************************************************************************
1379: 0000: \*******************************************************************************
1380: 0000: \***
1381: 0000: \***      %INCLUDE FOR EXTERNAL DEFINITION OF FUNCTION EXTERNAL.MESSAGE
1382: 0000: \***
1383: 0000: \***
1384: 0000: \***            FUNCTION NUMBER    : PSBF04
1385: 0000: \***
1386: 0000: \***            INCLUDE REFERENCE  : PSBF04E.J86
1387: 0000: \***
1388: 0000: \***            DATE WRITTEN       : 5th March 1986
1389: 0000: \***
1390: 0000: \***        Version B        Andrew Wedgeworth         15th July 1992
1391: 0000: \***        Redundant function parameters removed.  EXTERNAL.MESSAGE
1392: 0000: \***        is defined as a variable which holds the return code.  
1393: 0000: \***
1394: 0000: \*******************************************************************************
1395: 0000: \*******************************************************************************
1396: 0000: 
1397: 0000:    FUNCTION EXTERNAL.MESSAGE  (MESSAGE.NO%,                            \
1398: 0000:                                STRING.DATA$,                           \
1399: 0000:                                RETURN.FIELD%) EXTERNAL
1400: 0000:    ! 3 parameters deleted from here                                    ! BAW
1401: 0000: 
1402: 0000:       STRING     STRING.DATA$
1403: 0000: 
1404: 0000:       INTEGER*2  EXTERNAL.MESSAGE,                                     \ BAW
1405: 0000:                  MESSAGE.NO%,                                          \
1406: 0000:                  RETURN.FIELD%
1407: 0000: 
1408: 0000:    END FUNCTION
1409: 0000: 
1410: 0000: \*******************************************************************************
1411: 0000:    %INCLUDE PSBF11E.J86                                                ! FAW
1412: 0000: REM \
1413: 0000: \*******************************************************************************
1414: 0000: \*******************************************************************************
1415: 0000: \***
1416: 0000: \***    %INCLUDE FOR EXTERNAL DEFINITION OF FUNCTION READ.NEXT.IEF
1417: 0000: \***
1418: 0000: \***
1419: 0000: \***            FUNCTION NUMBER       : PSBF11
1420: 0000: \***
1421: 0000: \***            INCLUDE REFERENCE     : PSBF11E.J86
1422: 0000: \***
1423: 0000: \***            DATE OF LAST AMENDMENT -  3rd March 1986
1424: 0000: \***
1425: 0000: \***     Version B             Andrew Wedgeworth          15th July 1992
1426: 0000: \***     Removal of redundant function parameters.  READ.NEXT.IEF defined as
1427: 0000: \***     a variable to hold the return code.
1428: 0000: \***
1429: 0000: \*******************************************************************************
1430: 0000: \*******************************************************************************
1431: 0000: 
1432: 0000: REM \
1433: 0000: \*******************************************************************************
1434: 0000: \*******************************************************************************
1435: 0000: \***
1436: 0000: \***
1437: 0000: \***            FUNCTION OVERVIEW
1438: 0000: \***            -----------------
1439: 0000: \***
1440: 0000: \***   This function finds and retreives the next bar code in an IEF chain.
1441: 0000: \***   If the code found is the last code in the chain, the function checks that
1442: 0000: \***   the number of codes in the chain is equal to the expected number.  If it
1443: 0000: \***   is not, a message is displayed and logged.  If an error occurs in reading
1444: 0000: \***   the IEF, a message is displayed and logged, and the function returns to
1445: 0000: \***   the calling program with a return code of 1.
1446: 0000: \***
1447: 0000: \***
1448: 0000: \*******************************************************************************
1449: 0000: \*******************************************************************************
1450: 0000: 
1451: 0000:    FUNCTION READ.NEXT.IEF (LAST.BAR.CODE$,                             \
1452: 0000:                            TOTAL.COUNT%,                               \
1453: 0000:                            BOOTS.CODE$)  EXTERNAL
1454: 0000:    ! 3 parameters deleted from here                                    ! BAW			   
1455: 0000: 
1456: 0000:       STRING  BOOTS.CODE$,                                             \
1457: 0000:               LAST.BAR.CODE$
1458: 0000:       ! 3 variables removed from here                                  ! BAW
1459: 0000: 
1460: 0000:       INTEGER*2 READ.NEXT.IEF,                                         \ BAW
1461: 0000:                 TOTAL.COUNT%
1462: 0000:              
1463: 0000: 
1464: 0000: 
1465: 0000:    END FUNCTION
1466: 0000: 
1467: 0000: \*******************************************************************************
1468: 0000:    %INCLUDE PSBF12E.J86                                                ! FAW
1469: 0000: REM \
1470: 0000: \*****************************************************************************
1471: 0000: \*****************************************************************************
1472: 0000: \***
1473: 0000: \***      %INCLUDE FOR EXTERNAL DEFINITION OF HELP FUNCTION
1474: 0000: \***
1475: 0000: \***            FUNCTION NUMBER      : PSBF12
1476: 0000: \***
1477: 0000: \***            REFERENCE            : PSBF12E.J86
1478: 0000: \***
1479: 0000: \***            DATE WRITTEN         : 17th March 1986
1480: 0000: \***
1481: 0000: \***      Version B           Andrew Wedgeworth           21st July 1992
1482: 0000: \***      Removal of redundant function parameters. HELP included as a 
1483: 0000: \***      variable to hold the return code.
1484: 0000: \***
1485: 0000: \*****************************************************************************
1486: 0000: \*****************************************************************************
1487: 0000: 
1488: 0000:    FUNCTION HELP (SCREEN.NO$) EXTERNAL
1489: 0000: 
1490: 0000:        STRING SCREEN.NO$
1491: 0000:        
1492: 0000:        INTEGER*2 HELP       
1493: 0000: 
1494: 0000:    END FUNCTION
1495: 0000: 
1496: 0000: \******************************************************************************
1497: 0000:    %INCLUDE PSBF14E.J86                                                ! FAW
1498: 0000: REM\
1499: 0000: \*******************************************************************************
1500: 0000: \*******************************************************************************
1501: 0000: \***
1502: 0000: \***        INCLUDE       : SORT.TABLE external definition
1503: 0000: \***
1504: 0000: \***        REFERENCE     : PSBF14E.J86
1505: 0000: \***
1506: 0000: \***        Version A     Bruce Scriver                   3rd March 1986   
1507: 0000: \*** 
1508: 0000: \***        Version B     Andrew Wedgeworth               17th July 1992
1509: 0000: \***        Redundant function parameters removed.  SORT.TABLE defined as a
1510: 0000: \***        variable to hold the return code.
1511: 0000: \***
1512: 0000: \*******************************************************************************
1513: 0000: \*******************************************************************************
1514: 0000: 
1515: 0000:    FUNCTION SORT.TABLE (NUMBER.OF.ENTRIES%)                                    \
1516: 0000:    EXTERNAL
1517: 0000: 
1518: 0000:       INTEGER   NUMBER.OF.ENTRIES%,                                    \ BAW
1519: 0000:                 SORT.TABLE                 
1520: 0000: 
1521: 0000:    END FUNCTION
1522: 0000: 
1523: 0000:    %INCLUDE PSBF16E.J86                                                ! FAW
1524: 0000: REM\
1525: 0000: \*******************************************************************************
1526: 0000: \*******************************************************************************
1527: 0000: \***
1528: 0000: \***       %INCLUDE FOR EXTERNAL DEFINITION OF CONV.TO.HEX FUNCTION
1529: 0000: \***
1530: 0000: \***                  REFERENCE     : PSBF16E.J86
1531: 0000: \***
1532: 0000: \***       Version A            Bruce Scriver          25th February 1986
1533: 0000: \***
1534: 0000: \***       Version B           Andrew Wedgeworth            2nd July 1992
1535: 0000: \***       Removal of redundant parameters, and CONV.TO.HEX defined as a 
1536: 0000: \***       variable to hold the return code. 
1537: 0000: \***
1538: 0000: \*******************************************************************************
1539: 0000: \*******************************************************************************
1540: 0000: 
1541: 0000:    FUNCTION CONV.TO.HEX (INTEGER4%)                                            \
1542: 0000:    EXTERNAL
1543: 0000:    ! 3 parameters removed from here                                    ! BAW
1544: 0000: 
1545: 0000:    ! 3 lines deleted from here                                         ! BAW
1546: 0000:    
1547: 0000:       INTEGER*2 CONV.TO.HEX                                            ! BAW
1548: 0000: 
1549: 0000:       INTEGER*4 INTEGER4%
1550: 0000: 
1551: 0000:    END FUNCTION
1552: 0000: 
1553: 0000:    %INCLUDE PSBF17E.J86                                                ! FAW
1554: 0000: REM \
1555: 0000: \*******************************************************************************
1556: 0000: \*******************************************************************************
1557: 0000: \***
1558: 0000: \***
1559: 0000: \***       %INCLUDE FOR EXTERNAL DEFINITION OF CONV.TO.STRING FUNCTION
1560: 0000: \***
1561: 0000: \***                     REFERENCE     : PSBF17E.J86
1562: 0000: \***
1563: 0000: \***       Version A            Bruce Scriver       24th February 1986           
1564: 0000: \***
1565: 0000: \***       Version B          Andrew Wedgeworth          2nd July 1992
1566: 0000: \***       Redundant parameters removed, and the function's name is 
1567: 0000: \***       is defined as a variable to hold the return code. 
1568: 0000: \***
1569: 0000: \*******************************************************************************
1570: 0000: \*******************************************************************************
1571: 0000: 
1572: 0000:    FUNCTION CONV.TO.STRING (EVENT.NUMBER%,                                     \
1573: 0000:                             INTEGER4%)                                         \
1574: 0000:    EXTERNAL
1575: 0000: ! 3 parameters removed from here                                       ! BAW
1576: 0000: 
1577: 0000: ! 3 lines deleted from here                                            ! BAW
1578: 0000: 
1579: 0000:       INTEGER*1 EVENT.NUMBER%
1580: 0000: 
1581: 0000:       INTEGER*2 CONV.TO.STRING                                         ! BAW
1582: 0000: 
1583: 0000:       INTEGER*4 INTEGER4%
1584: 0000: 
1585: 0000:    END FUNCTION
1586: 0000: 
1587: 0000:    %INCLUDE PSBF18E.J86                                                ! FAW
1588: 0000: REM\
1589: 0000: \*******************************************************************************
1590: 0000: \*******************************************************************************
1591: 0000: \***
1592: 0000: \***        INCLUDE       : CALC.BOOTS.CODE.CHECK.DIGIT external definition
1593: 0000: \***
1594: 0000: \***        REFERENCE     : PSBF18E.J86
1595: 0000: \***
1596: 0000: \***        Version A      Stephen Kelsey                   23rd March 1987 
1597: 0000: \***
1598: 0000: \***        Version B      Andrew Wedgeworth                  7th July 1992 
1599: 0000: \***        Removal of redundant parameters, and inclusion of function's 
1600: 0000: \***        name as a variable to hold the return code.
1601: 0000: \***
1602: 0000: \*******************************************************************************
1603: 0000: \*******************************************************************************
1604: 0000: 
1605: 0000:    FUNCTION CALC.BOOTS.CODE.CHECK.DIGIT (BOOTS.CODE.6.DIGIT$)          \ 
1606: 0000:    EXTERNAL
1607: 0000:    ! 3 parameters removed from here                                    ! BAW
1608: 0000: 
1609: 0000:    STRING BOOTS.CODE.6.DIGIT$
1610: 0000:    ! 3 variables deleted from here                                     ! BAW
1611: 0000:    
1612: 0000:    INTEGER* 2 CALC.BOOTS.CODE.CHECK.DIGIT                              ! BAW
1613: 0000:    
1614: 0000:    END FUNCTION
1615: 0000: 
1616: 0000:    %INCLUDE PSBF19E.J86                                                ! FAW
1617: 0000: REM \
1618: 0000: \*******************************************************************************
1619: 0000: \*******************************************************************************
1620: 0000: \***
1621: 0000: \***
1622: 0000: \***            INCLUDE       : IRF.UPDATE external definition
1623: 0000: \***
1624: 0000: \***            REFERENCE     : PSBF19E.J86
1625: 0000: \***
1626: 0000: \***      Version A      Richard Hopkinson                  16th March 1988
1627: 0000: \***
1628: 0000: \***      Version B      Janet Lawrence                     12th April 1989
1629: 0000: \***      Add extra parameter, IRF.LOCKED.FLAG$, to each function definition.
1630: 0000: \***
1631: 0000: \***      Version C      Andrew Wedgeworth                   21st July 1992
1632: 0000: \***      Redundant parameters removed (ie. BATCH.SCREEN.FLAG$, 
1633: 0000: \***      MODULE.NUMBER$ and OPERATOR.NUMBER$).  Function names defined as 
1634: 0000: \***      variables to hold the return code.
1635: 0000: \***
1636: 0000: \***      Version F     Steve Perkins                      20th October 1993
1637: 0000: \***      Version letter updated to keep in line with PSBF19.BAS
1638: 0000: \***
1639: 0000: \***    REVISION 1.9.                ROBERT COWEY.                08 DEC 2003.
1640: 0000: \***    Changes for Deal Limit removal project.
1641: 0000: \***    Revision number updated to keep in step with PSBF19.BAS.
1642: 0000: \***    No actual coding changes to this file.
1643: 0000: \***
1644: 0000: \*******************************************************************************
1645: 0000: \*******************************************************************************
1646: 0000: 
1647: 0000:    FUNCTION OPEN.IRF.UPDT (NEW.IRF.DATA$,                                  \
1648: 0000:                            ACD.FLAG$)                                      \
1649: 0000:    EXTERNAL
1650: 0000: 
1651: 0000:       STRING    ACD.FLAG$,                                                 \
1652: 0000:                 NEW.IRF.DATA$
1653: 0000:                 
1654: 0000:       INTEGER*2 OPEN.IRF.UPDT                                          ! CAW            
1655: 0000: 
1656: 0000:    END FUNCTION
1657: 0000: 
1658: 0000: 
1659: 0000:    FUNCTION UPDT.IRF.UPDT (NEW.IRF.DATA$,                                  \
1660: 0000:                            ACD.FLAG$,                                      \
1661: 0000:                            IRF.LOCKED.FLAG$)                           \ BJAL
1662: 0000:    EXTERNAL
1663: 0000: 
1664: 0000:       STRING    ACD.FLAG$,                                                 \
1665: 0000:                 IRF.LOCKED.FLAG$,                                      \ BJAL
1666: 0000:                 NEW.IRF.DATA$
1667: 0000:          
1668: 0000:       INTEGER*2 UPDT.IRF.UPDT                                          ! CAW      
1669: 0000: 
1670: 0000:    END FUNCTION
1671: 0000: 
1672: 0000: 
1673: 0000:    FUNCTION CLOSE.IRF.UPDT (NEW.IRF.DATA$,                                 \
1674: 0000:                             ACD.FLAG$)                                     \
1675: 0000:    EXTERNAL
1676: 0000: 
1677: 0000:       STRING    ACD.FLAG$,                                                 \
1678: 0000:                 NEW.IRF.DATA$
1679: 0000:                 
1680: 0000:       INTEGER*2 CLOSE.IRF.UPDT                                         ! CAW            
1681: 0000: 
1682: 0000:    END FUNCTION
1683: 0000: 
1684: 0000:    %INCLUDE PSBF20E.J86                                                ! FAW
1685: 0000: REM\
1686: 0000: \*******************************************************************************
1687: 0000: \*******************************************************************************
1688: 0000: \***
1689: 0000: \***       %INCLUDE FOR EXTERNAL DEFINITION OF SESS.NUM.UTILITY
1690: 0000: \***
1691: 0000: \***                  REFERENCE     : PSBF20E.J86
1692: 0000: \***
1693: 0000: \***     VERSION C            Janet Smith                13th May 1992
1694: 0000: \***     Increased PASSED.INTEGER to 2 bytes to cater for more than
1695: 0000: \***     128 files.
1696: 0000: \***
1697: 0000: \***     VERSION D.           Andrew Wedgeworth          1st July 1992
1698: 0000: \***     Removal of redundant parameters and addition of SESS.NUM.UTILITY
1699: 0000: \***     as a variable.  This new variable contains the function's return
1700: 0000: \***     code.
1701: 0000: \***
1702: 0000: \*******************************************************************************
1703: 0000: \*******************************************************************************
1704: 0000: 
1705: 0000:    FUNCTION SESS.NUM.UTILITY (FUNCTION.FLAG$,                          \
1706: 0000:                               PASSED.INTEGER%,                         \
1707: 0000:                               PASSED.STRING$)                          \
1708: 0000:    EXTERNAL
1709: 0000: 
1710: 0000:    STRING    FUNCTION.FLAG$,                                           \
1711: 0000:              PASSED.STRING$
1712: 0000:    ! 3 variables removed from here                                     ! CAW
1713: 0000: 
1714: 0000: 
1715: 0000:    INTEGER*2 SESS.NUM.UTILITY,                                         \ CAW
1716: 0000:              PASSED.INTEGER%				               ! CJAS
1717: 0000: 
1718: 0000:    END FUNCTION
1719: 0000: 
1720: 0000:    %INCLUDE PSBF24E.J86                                                ! FAW
1721: 0000: REM \
1722: 0000: \*******************************************************************************
1723: 0000: \*******************************************************************************
1724: 0000: \***
1725: 0000: \***    %INCLUDE FOR EXTERNAL DEFINITION OF STANDARD.ERROR.DETECTED FUNCTION
1726: 0000: \***
1727: 0000: \***                      REFERENCE     : PSBF24E.J86
1728: 0000: \***
1729: 0000: \***    Version A                 Janet Smith                  13th May 1992
1730: 0000: \***
1731: 0000: \*******************************************************************************
1732: 0000: \*******************************************************************************
1733: 0000: 
1734: 0000:    FUNCTION STANDARD.ERROR.DETECTED(ERRN%,                 \
1735: 0000: 				    ERRFILE%,              \
1736: 0000: 				    ERRL%,                 \
1737: 0000: 				    ERR$)        EXTERNAL
1738: 0000: 				    
1739: 0000:           STRING    ERR$
1740: 0000: 
1741: 0000:           INTEGER*2 ERRFILE%,              \
1742: 0000: 	            ERRL%,                 \
1743: 0000: 		    STANDARD.ERROR.DETECTED
1744: 0000: 		    
1745: 0000:           INTEGER*4 ERRN%
1746: 0000: 	  		    
1747: 0000:    END FUNCTION
1748: 0000: 
1749: 0000: 
1750: 0000: 
1751: 0000:    %INCLUDE IDFEXT.J86                                                 ! FAW
1752: 0000: \*******************************************************************************
1753: 0000: \***                                                                         ***
1754: 0000: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE ITEM DESCRIPTION FILE        ***
1755: 0000: \***                                                                         ***
1756: 0000: \***                       REFERENCE : IDFEXT.J86                            ***
1757: 0000: \***                                                                         ***
1758: 0000: \***      Version A           Andrew Wedgeworth         9th July 1992        ***
1759: 0000: \***
1760: 0000: \***    VERSION C.              Robert Cowey.                       25 AUG 1993.
1761: 0000: \***    No changes to this file.
1762: 0000: \***
1763: 0000: \***   VERSION D               Nik Sen                 22nd December 1994
1764: 0000: \***   WRITE.IDF.HOLD added
1765: 0000: \***
1766: 0000: \*******************************************************************************
1767: 0000: 
1768: 0000:        FUNCTION IDF.SET EXTERNAL                                      
1769: 0000:        END FUNCTION                                                   
1770: 0000: 
1771: 0000: 
1772: 0000:        FUNCTION READ.IDF EXTERNAL                                     
1773: 0000:           INTEGER*2 READ.IDF                                          
1774: 0000:        END FUNCTION                                                   
1775: 0000: 
1776: 0000: 
1777: 0000:        FUNCTION READ.IDF.LOCK EXTERNAL                                
1778: 0000:           INTEGER*2 READ.IDF.LOCK                                     
1779: 0000:        END FUNCTION                                                   
1780: 0000: 
1781: 0000:        FUNCTION WRITE.IDF EXTERNAL
1782: 0000:           INTEGER*2 WRITE.IDF
1783: 0000:        END FUNCTION	       
1784: 0000: 
1785: 0000:        FUNCTION WRITE.IDF.HOLD EXTERNAL
1786: 0000:           INTEGER*2 WRITE.IDF.HOLD
1787: 0000:        END FUNCTION
1788: 0000: 
1789: 0000:        FUNCTION WRITE.IDF.UNLOCK EXTERNAL                                  
1790: 0000:           INTEGER*2 WRITE.IDF.UNLOCK                                      
1791: 0000:        END FUNCTION                                                   
1792: 0000:    %INCLUDE IEFEXT.J86                                                 ! FAW
1793: 0000: \*****************************************************************************
1794: 0000: \*****************************************************************************
1795: 0000: \***
1796: 0000: \***         EXTERNAL FUNCTION DEFINITIONS FOR IEF
1797: 0000: \***
1798: 0000: \***         REFERENCE: IEFEXT.J86
1799: 0000: \***
1800: 0000: \***    VERSION B.              ROBERT COWEY.                       21 OCT 1993.
1801: 0000: \***    No changes to this file.
1802: 0000: \***
1803: 0000: \*******************************************************************************
1804: 0000: \*******************************************************************************
1805: 0000: 
1806: 0000:    FUNCTION IEF.SET EXTERNAL
1807: 0000:    END FUNCTION
1808: 0000:    
1809: 0000:    FUNCTION READ.IEF EXTERNAL
1810: 0000:       INTEGER*2 READ.IEF
1811: 0000:    END FUNCTION
1812: 0000:    
1813: 0000:    FUNCTION WRITE.IEF EXTERNAL
1814: 0000:       INTEGER*2 WRITE.IEF
1815: 0000:    END FUNCTION
1816: 0000:    
1817: 0000:    
1818: 0000:    %INCLUDE IRFEXT.J86                                                 ! FAW
1819: 0000: \*********************************************************************************
1820: 0000: \***
1821: 0000: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE ITEM REFERENCE FILE
1822: 0000: \***
1823: 0000: \***                    REFERENCE : IRFEXT.J86
1824: 0000: \***
1825: 0000: \***      Version A          Andrew Wedgeworth        9th July 1992
1826: 0000: \***
1827: 0000: \***      Version B          Andrew Wedgeworth        14th December 1992
1828: 0000: \***      Version letter incremented to match other IRF code.
1829: 0000: \***
1830: 0000: \***      Version C           Steve Windsor        12.02.93
1831: 0000: \***      Added external reference to read the alternate IRF.
1832: 0000: \***
1833: 0000: \***      Version D           Steve Windsor        12.05.93
1834: 0000: \***      Added all external references that wre in the original FNS.
1835: 0000: \***
1836: 0000: \***      Version E           Steve Perkins        21.09.93
1837: 0000: \***      Deals project: Fields changed for new deals project
1838: 0000: \*** 
1839: 0000: \***      Version F           Mark Walker          5th January 1994
1840: 0000: \***      Version letter incremented to match other IRF code.           
1841: 0000: \***                                                                    
1842: 0000: \***      Version G     Stuart William McConnachie      11th February 2000
1843: 0000: \***      Converted IRF.INDICAT2$ to integer flag byte.
1844: 0000: \***
1845: 0000: \***      REVISION 1.6.               ROBERT COWEY.               9 JUL 2002.
1846: 0000: \***      Major changes to IRF layout for 2002 Deals Rewrite project.
1847: 0000: \***      No changes to this particular file for this revision.
1848: 0000: \***
1849: 0000: \***      REVISION 1.7.               ROBERT COWEY.               5 AUG 2002.
1850: 0000: \***      Further changes for 2002 Deals Rewrite project (PSBF19 related).
1851: 0000: \***      Defined new functions CONCAT.NEW.IRF.DATA$ and SPLIT.NEW.IRF.DATA$.
1852: 0000: \***
1853: 0000: \***      REVISION 1.8                ROBERT COWEY.              15 JUL 2003.
1854: 0000: \***      Usage of INDICAT0% bit-3 X'08' changed to Item Contains Alcohol.
1855: 0000: \***      No changes to this file other than description.
1856: 0000: \***      No changes to IRF file functions.
1857: 0000: \***
1858: 0000: \***      REVISION 1.9.      STUART WILLIAM MCCONNACHIE           22 OCT 2003.
1859: 0000: \***      Changes to remove limit of 3 deals per item.
1860: 0000: \***      No changes to this file.
1861: 0000: \***
1862: 0000: \***      REVISION 2.0.             ALAN CARR                      9 FEB 2006.
1863: 0000: \***      Add new IRF.INDICAT8% 1 byte, amend IRF.UNUSED$ from 3 to 2 bytes.
1864: 0000: \***      No changes to this file.
1865: 0000: \***
1866: 0000: \***..............................................................................
1867: 0000:    
1868: 0000:    FUNCTION IRF.SET EXTERNAL
1869: 0000:    END FUNCTION
1870: 0000: 
1871: 0000:   FUNCTION CONCAT.NEW.IRF.DATA$ EXTERNAL                                  ! 1.7 RC
1872: 0000:   END FUNCTION                                                            ! 1.7 RC
1873: 0000: 
1874: 0000:   FUNCTION SPLIT.NEW.IRF.DATA$ EXTERNAL                                   ! 1.7 RC
1875: 0000:   END FUNCTION                                                            ! 1.7 RC
1876: 0000:   
1877: 0000:   FUNCTION READ.IRF EXTERNAL
1878: 0000:    INTEGER*2 READ.IRF
1879: 0000:   END FUNCTION
1880: 0000: 
1881: 0000:   FUNCTION READ.IRF.ALT EXTERNAL
1882: 0000:    INTEGER*2 READ.IRF.ALT
1883: 0000:   END FUNCTION
1884: 0000: 
1885: 0000:   FUNCTION READ.IRF.LOCK EXTERNAL
1886: 0000:    INTEGER*2 READ.IRF.LOCK
1887: 0000:   END FUNCTION
1888: 0000: 
1889: 0000:   FUNCTION WRITE.IRF EXTERNAL
1890: 0000:    INTEGER*2 WRITE.IRF
1891: 0000:   END FUNCTION
1892: 0000: 
1893: 0000:   FUNCTION WRITE.IRF.UNLOCK EXTERNAL
1894: 0000:    INTEGER*2 WRITE.IRF.UNLOCK
1895: 0000:   END FUNCTION
1896: 0000: 
1897: 0000:   FUNCTION WRITE.IRF.HOLD EXTERNAL
1898: 0000:    INTEGER*2 WRITE.IRF.HOLD
1899: 0000:   END FUNCTION
1900: 0000: 
1901: 0000:   FUNCTION WRITE.IRF.HOLD.UNLOCK EXTERNAL
1902: 0000:    INTEGER*2 WRITE.IRF.HOLD.UNLOCK
1903: 0000:   END FUNCTION
1904: 0000: 
1905: 0000:   
1906: 0000:    %INCLUDE PPFEXT.J86                                                 ! FAW
1907: 0000: 
1908: 0000: \REM
1909: 0000: \*******************************************************************************
1910: 0000: \*******************************************************************************
1911: 0000: \***
1912: 0000: \***    %INCLUDE FOR PENDING PRICES FILES EXTERNAL FUNCTIONS
1913: 0000: \***
1914: 0000: \***        REFERENCE   :   PPFEXT (J86)
1915: 0000: \***
1916: 0000: \***        FILE TYPE   :   Sequential
1917: 0000: \***
1918: 0000: \***    VERSION D.              ROBERT COWEY.                       23 AUG 1993.
1919: 0000: \***    Original version created from PPFFUND.
1920: 0000: \***
1921: 0000: \***    VERSION E.              STEVE PERKINS.                      22 OCT 1993.
1922: 0000: \***    Defined functions READ.PPFI.SHORT and PPFI.LOAD.FIELDS(RECORD$).
1923: 0000: \***
1924: 0000: \*******************************************************************************
1925: 0000: \*******************************************************************************
1926: 0000: 
1927: 0000: 
1928: 0000: FUNCTION PPFI.SET EXTERNAL
1929: 0000:     INTEGER*2 PPFI.SET
1930: 0000: END FUNCTION
1931: 0000: 
1932: 0000: FUNCTION PPFO.SET EXTERNAL
1933: 0000:     INTEGER*2 PPFO.SET
1934: 0000: END FUNCTION
1935: 0000: 
1936: 0000: FUNCTION READ.PPFI EXTERNAL
1937: 0000:     INTEGER*2 READ.PPFI
1938: 0000: END FUNCTION
1939: 0000: 
1940: 0000: FUNCTION READ.PPFI.SHORT EXTERNAL                                      ! ESP
1941: 0000:     INTEGER*2 READ.PPFI.SHORT                                          ! ESP
1942: 0000: END FUNCTION                                                           ! ESP
1943: 0000: 
1944: 0000: FUNCTION WRITE.PPFO EXTERNAL
1945: 0000:     INTEGER*2 WRITE.PPFO
1946: 0000: END FUNCTION
1947: 0000: 
1948: 0000: FUNCTION PPFI.LOAD.FIELDS(RECORD$) EXTERNAL                            ! ESP
1949: 0000:     STRING    RECORD$                                                  ! ESP
1950: 0000:     INTEGER*2 PPFI.LOAD.FIELDS                                         ! ESP
1951: 0000: END FUNCTION                                                           ! ESP
1952: 0000:  
1953: 0000:    %INCLUDE LOCALEXT.J86                                               ! FAW
1954: 0000: \*****************************************************************************
1955: 0000: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE LOCAL FILE                 
1956: 0000: \***      REFERENCE : LOCALEX.J86                         
1957: 0000: \***      Version A           Paul Flanagan             1ST July 1993      
1958: 0000: \***                                                                       
1959: 0000: \***      Version B           Clive Norris              30th Nov 1993      
1960: 0000: \***         Renamed to keep the versions in line.                         
1961: 0000: \***                                                                       
1962: 0000: \*****************************************************************************
1963: 0000: 
1964: 0000:        FUNCTION LOCAL.SET EXTERNAL                                      
1965: 0000:        END FUNCTION                                                   
1966: 0000: 
1967: 0000:        FUNCTION READ.LOCAL EXTERNAL                                     
1968: 0000:           INTEGER*2 READ.LOCAL                                          
1969: 0000:        END FUNCTION                                                   
1970: 0000: 
1971: 0000:        FUNCTION READ.LOCAL.LOCK EXTERNAL                                     
1972: 0000:           INTEGER*2 READ.LOCAL.LOCK                                          
1973: 0000:        END FUNCTION                                                   
1974: 0000: 
1975: 0000:        FUNCTION WRITE.LOCAL EXTERNAL
1976: 0000:           INTEGER*2 WRITE.LOCAL
1977: 0000:        END FUNCTION	             
1978: 0000: 
1979: 0000:        FUNCTION WRITE.LOCAL.UNLOCK EXTERNAL
1980: 0000:           INTEGER*2 WRITE.LOCAL.UNLOCK
1981: 0000:        END FUNCTION	             
1982: 0000: 
1983: 0000: \*******************************************************************************
1984: 0000: \***
1985: 0000: \***   ON ERROR GOTO ERROR.DETECTED
1986: 0000: \***
1987: 0000: \***   set unique to ten spaces
1988: 0000: \***   set PPFO there flag off
1989: 0000: \***   set string errl to 6 spaces
1990: 0000: \***   set string errn to 8 spaces
1991: 0000: \***
1992: 0000: \***   %INCLUDE file initialisations for IDF
1993: 0000: \***   %INCLUDE file initialisations for IEF
1994: 0000: \***   %INCLUDE file initialisations for IRF
1995: 0000: \***   %INCLUDE file initialisations for PPFI
1996: 0000: \***   %INCLUDE file initialisations for PPFO
1997: 0000: \***   %INCLUDE file initialisations for LOCAL
1998: 0000: \***
1999: 0000: \***   set key values for input key comparisons:
2000: 0000: \***   Enter = 0, F1 = -1, F3 = -3, ESC = 27, Tab = 9, Home = 327, End = 335,
2001: 0000: \***   PgUp = 329, PgDn = 337
2002: 0000: \***
2003: 0000: \***   execute USE function to obtain operator number and passed program number
2004: 0000: \***
2005: 0000: \***   Reset successful completion flag for return to store opening
2006: 0000: \***
2007: 0000: \***   set operator number to psbchn op
2008: 0000: \***
2009: 0000: \***   Allocate all file session numbers
2010: 0000: \***
2011: 0000: \***   IF not called from STORE OPEN then initialise DISPLAY MGR
2012: 0000: \***
2013: 0000: \***   IF END occurs on open idf THEN OPEN.IDF.ERROR
2014: 0000: \***   OPEN idf NOWRITE NODEL
2015: 0000: \***
2016: 0000: \***   IF END occurs on open ief THEN OPEN.IEF.ERROR
2017: 0000: \***   OPEN ief NOWRITE NODEL
2018: 0000: \***
2019: 0000: \***   IF END occurs on open irf THEN OPEN.IRF.ERROR
2020: 0000: \***   OPEN irf NODEL
2021: 0000: \***   CALL OPEN.IRF.UPDT
2022: 0000: \***
2023: 0000: \***   CALL OPEN.PPFI
2024: 0000: \***
2025: 0000: \***   IF called from Store Opening  THEN
2026: 0000: \***      set selection to "2" (Decreases)
2027: 0000: \***      GOSUB PROCESS.SELECTION
2028: 0000: \***      Set successful completion flag for return
2029: 0000: \***      GOTO  END.OF.PROGRAM
2030: 0000: \***   endif
2031: 0000: \***
2032: 0000: \***   Set default option to "1"  (Increases)
2033: 0000: \***   GOSUB PUT.SELECTION
2034: 0000: \***
2035: 0000: \...............................................................................
2036: 0000: 
2037: 0000:    ON ERROR GOTO ERROR.DETECTED
2038: 002f: 
2039: 002f:    UNIQUE$ = "          "
2040: 0044:    ERRL.STRING$ = "      "
2041: 0059:    ERRN.STRING$ = "        "
2042: 006e:    PPFO.THERE.FLAG$ = "N"
2043: 0083: 
2044: 0083:   FALSE EQ 0                                                            !DSJW
2045: 0093:   TRUE  EQ -1                                                           !DSJW
2046: 00a3: 
2047: 00a3:   PPFI.BUFF.SIZE%   EQ 32256                                            !DSJW
2048: 00b4:   PPFO.BUFF.SIZE%   EQ 32256                                            !DSJW
2049: 00c5:   
2050: 00c5:   DIM SAVED.DEAL.NUM$(3)                                                !IBG
2051: 00f4:   DIM SAVED.LIST.ID%(3)                                                 !IBG
2052: 011d: 
2053: 011d:   RC% EQ IDF.SET                                                        !DSJW
2054: 013b:   RC% EQ IRF.SET                                                        !DSJW
2055: 0159:   RC% EQ IEF.SET                                                        !DSJW
2056: 0177:   RC% EQ PPFI.SET                                                       !DSJW
2057: 018b:   RC% EQ PPFO.SET                                                       !DSJW
2058: 019f:   RC% EQ LOCAL.SET                                                      !DSJW
2059: 01bd:   
2060: 01bd:   CREATE POSFILE "C:\PSB7200.OUT" AS 992
2061: 01d8: 
2062: 01d8:    BATCH.SCREEN.FLAG$ = "S"
2063: 01ef:    MODULE.NUMBER$ = "PSB7200"
2064: 0206:    PPFI.TRAILER.ERROR$ = "N"
2065: 021b:    B7201.SCREEN.NO$ = "B7201"
2066: 0230:    B7203.SCREEN.NO$ = "B7203"
2067: 0245:    TOTAL.ENTRIES% = 0
2068: 025a:    ENTRY.COUNT% = 0
2069: 026f:    PPFI.RECORD.COUNT% = 0
2070: 0284:    TOTAL.PAGES% = 0
2071: 0299:    BIT.7.MASK% = 10000000B
2072: 02a6:    IRF.LOCKED.FLAG$ = "Y"                                              ! BMW
2073: 02bb: !  PPFI.OPEN.FLAG$ = "N"                                               ! BMW ! 1.19 RC
2074: 02bb: 
2075: 02bb:    QUIT% = -3
2076: 02c9:    HELP% = -1
2077: 02d7:    ENTER% = 0
2078: 02e5:    TAB% = 9
2079: 02f3:    ESCAPE% = 27
2080: 0301:    HOME% = 327
2081: 030f:    PAGE.UP% = 329
2082: 031d:    END.KEY% = 335
2083: 032b:    PAGE.DOWN% = 337
2084: 0339: 
2085: 0339:    TABLE.LIMIT.14K% = 14400 ! Slightly below 4690 maximum of 14464     ! 1.20 RC
2086: 034e: 
2087: 034e:    %INCLUDE PSBUSEE.J86                                                ! FAW
2088: 034e: \/*********************************************************************/ PSBUSEE
2089: 034e: \/*                                                                   */ PSBUSEE
2090: 034e: \/*      PSBUSEE.J86  -  USE in PSB Application Program               */ PSBUSEE
2091: 034e: \/*      ----------------------------------------------               */ PSBUSEE
2092: 034e: \/*                                                                   */ PSBUSEE
2093: 034e: \/*********************************************************************/ PSBUSEE
2094: 034e:                                                                        ! PSBUSEE
2095: 034e:         USE  PSBCHN.OP , PSBCHN.APP , PSBCHN.MENCON , PSBCHN.U1 ,      \ PSBUSEE
2096: 03a2:              PSBCHN.U2 , PSBCHN.U3                                     ! PSBUSEE
2097: 03a2:                                                                        ! PSBUSEE
2098: 03a2: 
2099: 03a2: RESUME.FROM.NP.ERROR:                                                  ! 1.20 RC
2100: 03b2: 
2101: 03b2:    PSBCHN.U2 = ""
2102: 03c9: 
2103: 03c9:    OPERATOR.NUMBER$ = PSBCHN.OP
2104: 03e7: 
2105: 03e7:    GOSUB ALLOCATE.SESS.NUMS                                            ! BMW
2106: 03f9: 
2107: 03f9:    IF PSBCHN.APP NE "PSB51" THEN BEGIN
2108: 0417:       STRING.DATA$ = ""
2109: 042c:       INTEGER.DATA% = 1
2110: 043a:       RC% EQ DM.INITDM (STRING.DATA$,INTEGER.DATA%)                    !DSJW
2111: 045d:       IF RC% NE 0 THEN BEGIN
2112: 046f:          GOTO CHAIN.OUT
2113: 047a:       ENDIF
2114: 0482:    ENDIF
2115: 048a: 
2116: 048a:    GOSUB OPEN.ITEM.FILES  ! Files opened on initial entry to menu      ! 1.19 RC
2117: 049c:    GOSUB CLOSE.ITEM.FILES ! selection screen to confirm availability   ! 1.19 RC
2118: 04ae:    CLOSE PPFI.SESS.NUM%   ! and then closed until needed               ! 1.19 RC
2119: 04c2: 
2120: 04c2:    IF PSBCHN.APP = "PSB51" THEN BEGIN
2121: 04e0:       SELECTION$ = "2"
2122: 04f5:       GOSUB PROCESS.SELECTION
2123: 0507:       GOTO  END.OF.PROGRAM
2124: 0512:    ENDIF
2125: 051a: 
2126: 051a:    SELECTION$ = "1"
2127: 052f:    GOSUB PUT.SELECTION
2128: 0541: 
2129: 0541: \...............................................................................
2130: 0541: \***
2131: 0541: \***   set key pressed to 999
2132: 0541: \***   set resf called flag off
2133: 0541: \***
2134: 0541: \***   WHILE key pressed is not F3 or ESC
2135: 0541: \***
2136: 0541: \***      IF resf called flag is off THEN
2137: 0541: \***         set string data to spaces
2138: 0541: \***         set integer data to 5
2139: 0541: \***         CALL DM.POSF function to position the cursor in field 5
2140: 0541: \***         IF F03.RETURN.CODE% = 0 THEN
2141: 0541: \***            set string data to spaces
2142: 0541: \***            set integer data to 0
2143: 0541: \***            CALL DM.UPDF function to get user input
2144: 0541: \***            IF F03.RETURN.CODE% <> 0 THEN
2145: 0541: \***               GOTO CHAIN.OUT
2146: 0541: \***            endif
2147: 0541: \***         ELSE
2148: 0541: \***            GOTO CHAIN.OUT
2149: 0541: \***         endif
2150: 0541: \***      endif
2151: 0541: \***
2152: 0541: \***      set key pressed to F03.RETURNED.INTEGER%
2153: 0541: \***      set selection to F03.RETURNED.STRING$
2154: 0541: \***
2155: 0541: \***      set resf called flag off
2156: 0541: \***
2157: 0541: \***      on case of
2158: 0541: \***         key pressed is Enter
2159: 0541: \***            GOSUB PROCESS.SELECTION
2160: 0541: \***         key pressed is F1
2161: 0541: \***            GOSUB HELP.ON.7201
2162: 0541: \***         key pressed is not Enter, F1, F3 or ESC
2163: 0541: \***            IF key pressed is in the range 32 to 127 ascii THEN
2164: 0541: \***               set resf called flag on
2165: 0541: \***               set string data to spaces
2166: 0541: \***               set integer data to 0
2167: 0541: \***               CALL DM.RESF function to indicate invalid entry
2168: 0541: \***               IF F03.RETURN.CODE% <> 0 THEN
2169: 0541: \***                  GOTO CHAIN.OUT
2170: 0541: \***               ELSE
2171: 0541: \***               endif
2172: 0541: \***            ELSE
2173: 0541: \***               CALL EXTERNAL.MESSAGE function to display message 001,
2174: 0541: \***                                                 return to field 5
2175: 0541: \***               IF F04.RETURN.CODE% <> 0 THEN
2176: 0541: \***                  GOTO CHAIN.OUT
2177: 0541: \***               endif
2178: 0541: \***            endif
2179: 0541: \***      endcase
2180: 0541: \***
2181: 0541: \***   WEND
2182: 0541: \***
2183: 0541: \*** END.OF.PROGRAM:
2184: 0541: \***
2185: 0541: \***   CLOSE idf
2186: 0541: \***
2187: 0541: \***   CLOSE ief
2188: 0541: \***
2189: 0541: \***   CLOSE irf
2190: 0541: \***   CLOSE LOCAL if open
2191: 0541: \***   CALL CLOSE.IRF.UPDT
2192: 0541: \***
2193: 0541: \***   Deallocate all file session numbers
2194: 0541: \***
2195: 0541: \***   CHAIN.OUT:
2196: 0541: \***
2197: 0541: \***      IF PPFO.THERE.FLAG$ = Y THEN
2198: 0541: \***         set PPFO.THERE.FLAG off
2199: 0541: \***         CLOSE PPFO file
2200: 0541: \***
2201: 0541: \***      CHAIN back to calling program
2202: 0541: \***
2203: 0541: \***
2204: 0541: \...............................................................................
2205: 0541: 
2206: 0541:    KEY.PRESSED% = 999
2207: 054f:    RESF.CALLED$ = "N"
2208: 0564: 
2209: 0564:    WHILE KEY.PRESSED% <> QUIT% AND KEY.PRESSED% <> ESCAPE%
2210: 056f: 
2211: 056f:       IF RESF.CALLED$ = "N" THEN BEGIN
2212: 058d:          STRING.DATA$ = ""
2213: 05a2:          INTEGER.DATA% = 5
2214: 05b0:          RC% EQ DM.POSF (STRING.DATA$,INTEGER.DATA%)
2215: 05d3:          IF RC% EQ 0 THEN BEGIN
2216: 05e5:             STRING.DATA$ = ""
2217: 05fa:             INTEGER.DATA% = 0
2218: 0608:             RC% EQ DM.UPDF (STRING.DATA$,INTEGER.DATA%)
2219: 062b:             IF RC% NE 0 THEN BEGIN
2220: 063d:                GOTO CHAIN.OUT
2221: 0648:             ENDIF
2222: 0652:          ENDIF ELSE BEGIN
2223: 065a:             GOTO CHAIN.OUT
2224: 0665:          ENDIF
2225: 066d:       ENDIF
2226: 0675: 
2227: 0675:       KEY.PRESSED% = F03.RETURNED.INTEGER%
2228: 0687:       SELECTION$ = F03.RETURNED.STRING$
2229: 06a3: 
2230: 06a3:       RESF.CALLED$ = "N"
2231: 06b8: 
2232: 06b8:       IF KEY.PRESSED% = ENTER% THEN                                    \
2233: 06c9:          GOSUB PROCESS.SELECTION                                      :\
2234: 06de:       ELSE                                                             \
2235: 06e6:          IF KEY.PRESSED% = HELP% THEN                                  \
2236: 06f7:             GOSUB HELP.ON.7201                                        :\
2237: 070c:          ELSE                                                          \
2238: 0714:             IF KEY.PRESSED% <> QUIT% AND KEY.PRESSED% <> ESCAPE% THEN  \
2239: 073a:                IF KEY.PRESSED% > 31 AND KEY.PRESSED% < 128 THEN        \
2240: 075e:                   RESF.CALLED$ = "Y"                                  :\
2241: 0773:                   STRING.DATA$ = ""                                   :\
2242: 0788:                   INTEGER.DATA% = 0                                   :\
2243: 0796:                   RC% EQ DM.RESF (STRING.DATA$,INTEGER.DATA%)         :\
2244: 07b9:                   IF RC% NE 0 THEN                                     \
2245: 07cb:                      GOTO CHAIN.OUT                                   :\
2246: 07d8:                   ELSE                                                 \
2247: 07d8:                ELSE                                                    \
2248: 07e2:                   VARIABLE.STRING$ = ""                               :\
2249: 07f7:                   MESSAGE.NO% = 1                                     :\
2250: 0805:                   RETURN.FIELD% = 5                                   :\
2251: 0813:                   RC% EQ EXTERNAL.MESSAGE (MESSAGE.NO%,                \
2252: 083a:                                            VARIABLE.STRING$,           \
2253: 083a:                                            RETURN.FIELD%)             :\
2254: 083a:                   IF RC% NE 0 THEN                                     \
2255: 084c:                      GOTO CHAIN.OUT
2256: 0856: 
2257: 0856:    WEND
2258: 087c: 
2259: 087c: END.OF.PROGRAM:
2260: 088c: 
2261: 088c: !  File CLOSE statements moved to separate subroutine                  ! 1.19 RC
2262: 088c:    
2263: 088c:    GOSUB DEALLOCATE.SESS.NUMS                                          ! BMW
2264: 089e: 
2265: 089e:    CHAIN.OUT:
2266: 08ae: 
2267: 08ae:    IF PPFO.THERE.FLAG$ = "Y" THEN                                      \
2268: 08c9:       PPFO.THERE.FLAG$ = "N"                                          :\
2269: 08de:       CLOSE PPFO.SESS.NUM%
2270: 08f2: 
2271: 08f2:    IF KEY.PRESSED% = ESCAPE% THEN                                      \
2272: 0903:       GOTO ESCAPE.TO.MAIN.MENU
2273: 090e: 
2274: 090e:    PSBCHN.PRG = "ADX_UPGM:" + PSBCHN.APP + ".286"
2275: 0937:    PSBCHN.APP = "PSB72"
2276: 094e:    %INCLUDE PSBCHNE.J86                                                ! FAW
2277: 094e: \/*********************************************************************/ PSBCHNE
2278: 094e: \/*                                                                   */ PSBCHNE
2279: 094e: \/*      PSBCHNE.J86  -  Chain to PSB Application Program             */ PSBCHNE
2280: 094e: \/*      ------------------------------------------------             */ PSBCHNE
2281: 094e: \/*                                                                   */ PSBCHNE
2282: 094e: \/*********************************************************************/ PSBCHNE
2283: 094e:                                                                        ! PSBCHNE
2284: 094e:         CHAIN  PSBCHN.PRG , PSBCHN.OP , PSBCHN.APP , PSBCHN.MENCON ,   \ PSBCHNE
2285: 09ce:                             PSBCHN.U1 , PSBCHN.U2  , PSBCHN.U3         ! PSBCHNE
2286: 09ce:                                                                        ! PSBCHNE
2287: 09ce: 
2288: 09ce: 
2289: 09ce: \*******************************************************************************
2290: 09ce: \********************** subroutines follow *************************************
2291: 09ce: \*******************************************************************************
2292: 09ce: 
2293: 09ce: 
2294: 09ce: \*******************************************************************************
2295: 09ce: \***
2296: 09ce: \***   OPEN.ITEM.FILES:
2297: 09ce: \***   Opens item files including IRF update function PSBF19.
2298: 09ce: \***   Open of PPFI performed within separate sub-routine.
2299: 09ce: \***
2300: 09ce: \***............................................................................
2301: 09ce: 
2302: 09ce: 
2303: 09ce: OPEN.ITEM.FILES: ! New sub-routine containing existing and unchanged   ! 1.19 RC
2304: 09de:                  ! file open commands (except PPFI now opened first)   ! 1.19 RC
2305: 09de: 
2306: 09de:    GOSUB OPEN.PPFI.LOCKED                                              ! 1.19 RC
2307: 09f0:    
2308: 09f0:    IF END #IDF.SESS.NUM% THEN OPEN.IDF.ERROR
2309: 0a0c:    OPEN IDF.FILE.NAME$ KEYED RECL IDF.RECL% AS IDF.SESS.NUM%           \
2310: 0a39:                        NOWRITE NODEL
2311: 0a39: 
2312: 0a39:    IF END #IEF.SESS.NUM% THEN OPEN.IEF.ERROR
2313: 0a55:    OPEN IEF.FILE.NAME$ KEYED RECL IEF.RECL% AS IEF.SESS.NUM%           \
2314: 0a82:                        NOWRITE NODEL
2315: 0a82: 
2316: 0a82:    LOCAL.FILE.OPEN EQ FALSE                                             !DSJW
2317: 0a98:    IF END #LOCAL.SESS.NUM% THEN OPEN.LOCAL.ERROR                        !DSJW
2318: 0ab4:    OPEN LOCAL.FILE.NAME$ KEYED RECL LOCAL.RECL% AS LOCAL.SESS.NUM%      !DSJW
2319: 0ae0:    LOCAL.FILE.OPEN EQ TRUE                                              !DSJW
2320: 0af6: 
2321: 0af6:    END.OPEN.LOCAL.FILE:                                                 !DSJW
2322: 0b06: 
2323: 0b06:    IF END #IRF.SESS.NUM% THEN OPEN.IRF.ERROR
2324: 0b22:    OPEN IRF.FILE.NAME$ KEYED RECL IRF.RECL% AS IRF.SESS.NUM% NODEL
2325: 0b4f:    
2326: 0b4f:    RC% EQ OPEN.IRF.UPDT (NEW.IRF.DATA$,ACD.FLAG$)
2327: 0b79:    IF RC% NE 0 THEN BEGIN
2328: 0b8b:       GOTO CHAIN.OUT
2329: 0b96:    ENDIF
2330: 0b9e: 
2331: 0b9e: RETURN                                                                 ! 1.19 RC
2332: 0bae: 
2333: 0bae: 
2334: 0bae: \*******************************************************************************
2335: 0bae: \***
2336: 0bae: \***   OPEN.PPFI.LOCKED:
2337: 0bae: \***   Opens PPFI locked.
2338: 0bae: \***
2339: 0bae: \***............................................................................
2340: 0bae: 
2341: 0bae: 
2342: 0bae: OPEN.PPFI.LOCKED: ! New sub-routine containing existing and unchanged  ! 1.19 RC
2343: 0bbe:                   ! PPFI open command                                  ! 1.19 RC
2344: 0bbe: 
2345: 0bbe:    IF END # PPFI.SESS.NUM% THEN OPEN.PPFI.ERROR                         !DSJW
2346: 0bda:    OPEN PPFI.FILE.NAME$ AS PPFI.SESS.NUM% BUFFSIZE PPFI.BUFF.SIZE% \    !DSJW
2347: 0c07:                                           LOCKED NOWRITE                !DSJW
2348: 0c07: !  PPFI.OPEN.FLAG$ = "Y"                                                !DSJW ! 1.19 RC
2349: 0c07: 
2350: 0c07: RETURN
2351: 0c17: 
2352: 0c17: 
2353: 0c17: \*******************************************************************************
2354: 0c17: \***
2355: 0c17: \***   CLOSE.ITEM.FILES:
2356: 0c17: \***   Closes item files including IRF update function PSBF19.
2357: 0c17: \***   Does not close PPFI as this is done within main code.
2358: 0c17: \***
2359: 0c17: \***............................................................................
2360: 0c17: 
2361: 0c17: 
2362: 0c17: CLOSE.ITEM.FILES: ! New sub-routine containing existing and unchanged  ! 1.19 RC
2363: 0c27:                   ! file close commands (excluding PPFI close)         ! 1.19 RC
2364: 0c27: 
2365: 0c27:    IF LOCAL.FILE.OPEN THEN \                                            !DSJW
2366: 0c39:       CLOSE LOCAL.SESS.NUM%                                             !DSJW
2367: 0c4d: 
2368: 0c4d:    CLOSE IDF.SESS.NUM%, \                                               !DSJW
2369: 0c61:          IEF.SESS.NUM%, \                                               !DSJW
2370: 0c75:          IRF.SESS.NUM%
2371: 0c89: 
2372: 0c89:    RC% EQ CLOSE.IRF.UPDT (NEW.IRF.DATA$,ACD.FLAG$)                      !DSJW
2373: 0cb3:    IF RC% NE 0 THEN \                                                   !DSJW
2374: 0cc5:       GOTO CHAIN.OUT
2375: 0cd0: 
2376: 0cd0: RETURN                                                                 ! 1.19 RC
2377: 0ce0: 
2378: 0ce0: 
2379: 0ce0: \*******************************************************************************
2380: 0ce0: \***
2381: 0ce0: \***   OPEN.IDF.ERROR:
2382: 0ce0: \***
2383: 0ce0: \***   set fail type to "O"
2384: 0ce0: \***   set current session number to idf session number
2385: 0ce0: \***   set key to null
2386: 0ce0: \***
2387: 0ce0: \***   GOSUB FILE.ERROR
2388: 0ce0: \***
2389: 0ce0: \***   GOTO CHAIN.OUT
2390: 0ce0: \***
2391: 0ce0: \...............................................................................
2392: 0ce0: 
2393: 0ce0:    OPEN.IDF.ERROR:
2394: 0cf0: 
2395: 0cf0:       FAIL.TYPE$ = "O"
2396: 0d05:       CURRENT.SESS.NUM% = IDF.SESS.NUM%
2397: 0d17:       CURRENT.KEY$ = ""
2398: 0d2c: 
2399: 0d2c:       GOSUB FILE.ERROR
2400: 0d3e: 
2401: 0d3e:       GOTO CHAIN.OUT
2402: 0d49: 
2403: 0d49: \*******************************************************************************
2404: 0d49: \***
2405: 0d49: \***   OPEN.IEF.ERROR:
2406: 0d49: \***
2407: 0d49: \***   set fail type to "O"
2408: 0d49: \***   set current session number to ief session number
2409: 0d49: \***   set key to null
2410: 0d49: \***
2411: 0d49: \***   GOSUB FILE.ERROR
2412: 0d49: \***
2413: 0d49: \***   GOTO CHAIN.OUT
2414: 0d49: \***
2415: 0d49: \...............................................................................
2416: 0d49: 
2417: 0d49:    OPEN.IEF.ERROR:
2418: 0d59: 
2419: 0d59:       FAIL.TYPE$ = "O"
2420: 0d6e:       CURRENT.SESS.NUM% = IEF.SESS.NUM%
2421: 0d80:       CURRENT.KEY$ = ""
2422: 0d95: 
2423: 0d95:       GOSUB FILE.ERROR
2424: 0da7: 
2425: 0da7:       GOTO CHAIN.OUT
2426: 0db2: 
2427: 0db2: \*******************************************************************************
2428: 0db2: \***   OPEN.LOCAL.ERROR
2429: 0db2: \***   set fail type to "O"
2430: 0db2: \***   set current session number to irf session number
2431: 0db2: \***   set key to null
2432: 0db2: \***   GOSUB FILE.ERROR
2433: 0db2: \***   GOTO END.OPEN.LOCAL.FILE (INITIALISATION)
2434: 0db2: \...............................................................................
2435: 0db2: 
2436: 0db2:    OPEN.LOCAL.ERROR:
2437: 0dc2: 
2438: 0dc2:       FAIL.TYPE$ = "O"
2439: 0dd7:       CURRENT.SESS.NUM% = LOCAL.SESS.NUM%
2440: 0de9:       CURRENT.KEY$ = ""
2441: 0dfe: 
2442: 0dfe:       GOSUB FILE.ERROR
2443: 0e10: 
2444: 0e10:       GOTO END.OPEN.LOCAL.FILE
2445: 0e1b: 
2446: 0e1b: \*******************************************************************************
2447: 0e1b: \***
2448: 0e1b: \***   OPEN.IRF.ERROR:
2449: 0e1b: \***
2450: 0e1b: \***   set fail type to "O"
2451: 0e1b: \***   set current session number to irf session number
2452: 0e1b: \***   set key to null
2453: 0e1b: \***
2454: 0e1b: \***   GOSUB FILE.ERROR
2455: 0e1b: \***
2456: 0e1b: \***   GOTO CHAIN.OUT
2457: 0e1b: \***
2458: 0e1b: \...............................................................................
2459: 0e1b: 
2460: 0e1b:    OPEN.IRF.ERROR:
2461: 0e2b: 
2462: 0e2b:       FAIL.TYPE$ = "O"
2463: 0e40:       CURRENT.SESS.NUM% = IRF.SESS.NUM%
2464: 0e52:       CURRENT.KEY$ = ""
2465: 0e67: 
2466: 0e67:       GOSUB FILE.ERROR
2467: 0e79: 
2468: 0e79:       GOTO CHAIN.OUT
2469: 0e84: 
2470: 0e84: \*******************************************************************************
2471: 0e84: \***
2472: 0e84: \***   PROCESS.SELECTION:
2473: 0e84: \***
2474: 0e84: \***   IF selection is "2" THEN
2475: 0e84: \***      set increase/decrease flag to "D"
2476: 0e84: \***   ELSE
2477: 0e84: \***      IF selection is "1" THEN
2478: 0e84: \***         set increase/decrease flag to "I"
2479: 0e84: \***      ELSE
2480: 0e84: \***         CALL EXTERNAL.MESSAGE function to display message 003,
2481: 0e84: \***                                           return to field 5
2482: 0e84: \***         IF F04.RETURN.CODE% <> 0 THEN
2483: 0e84: \***            GOTO CHAIN.OUT
2484: 0e84: \***         ELSE
2485: 0e84: \***            RETURN
2486: 0e84: \***         endif
2487: 0e84: \***      endif
2488: 0e84: \***   endif
2489: 0e84: \***
2490: 0e84: \***   CHECK.ANSWER:
2491: 0e84: \***
2492: 0e84: \***   IF increase/decrease flag is "I" AND
2493: 0e84: \***      DECREASES RUN ALREADY FLAG IS "Y" then
2494: 0e84: \***      OPEN the ppfi LOCKED NOWRITE
2495: 0e84: \***
2496: 0e84: \***   IF increase/decrease flag is "D" AND
2497: 0e84: \***      not called from store opening  THEN
2498: 0e84: \***      CALL DM.POSF function to position the cursor in field number 7
2499: 0e84: \***      IF F03.RETURN.CODE% <> 0 THEN
2500: 0e84: \***         GOTO CHAIN.OUT
2501: 0e84: \***      ELSE
2502: 0e84: \***         set string data to "Are you sure? (Y/N)"
2503: 0e84: \***         set integer data to 0
2504: 0e84: \***         CALL DM.PUTF to put message in field 7
2505: 0e84: \***         IF F03.RETURN.CODE% <> 0 THEN
2506: 0e84: \***            GOTO CHAIN.OUT
2507: 0e84: \***         ELSE
2508: 0e84: \***            CALL DM.POSF function to position the cursor in field 8
2509: 0e84: \***            IF F03.RETURN.CODE% <> 0 THEN
2510: 0e84: \***               GOTO CHAIN.OUT
2511: 0e84: \***            ELSE
2512: 0e84: \***               GOSUB CONFIRM.CHOICE
2513: 0e84: \***
2514: 0e84: \***   IF not called from store opening  THEN
2515: 0e84: \***      IF increase/decrease flag is "D" THEN
2516: 0e84: \***         set string data to "B7202"
2517: 0e84: \***         set integer data to 0
2518: 0e84: \***         CALL DM.DISPD function to display required screen
2519: 0e84: \***         IF F03.RETURN.CODE% <> 0 THEN
2520: 0e84: \***            GOTO CHAIN.OUT
2521: 0e84: \***         ELSE
2522: 0e84: \***      ELSE
2523: 0e84: \***         set string data to "B7203"
2524: 0e84: \***         set integer data to 0
2525: 0e84: \***         CALL DM.DISPD function to display required screen
2526: 0e84: \***         IF F03.RETURN.CODE% <> 0 THEN
2527: 0e84: \***            GOTO CHAIN.OUT
2528: 0e84: \***         endif
2529: 0e84: \***      endif
2530: 0e84: \***   endif
2531: 0e84: \***
2532: 0e84: \***   IF increase/decrease flag = "D" THEN
2533: 0e84: \***      GOSUB AUTO.EFFECT.DECREASES
2534: 0e84: \***      IF not called from store opening  THEN
2535: 0e84: \***         GOTO PROCESS.RETURN
2536: 0e84: \***      ELSE
2537: 0e84: \***         GOTO CHAIN.OUT
2538: 0e84: \***      endif
2539: 0e84: \***   endif
2540: 0e84: \***
2541: 0e84: \***
2542: 0e84: \***   GOSUB GET.DATA
2543: 0e84: \***
2544: 0e84: \...............................................................................
2545: 0e84: 
2546: 0e84:    PROCESS.SELECTION:
2547: 0e94: 
2548: 0e94:       IF SELECTION$ = "2" THEN                                         \
2549: 0eaf:          INC.DEC$ = "D"                                               :\
2550: 0ec7:       ELSE                                                             \
2551: 0ecf:          IF SELECTION$ = "1" THEN                                      \
2552: 0eea:             INC.DEC$ = "I"                                            :\
2553: 0f02:          ELSE                                                          \
2554: 0f0a:             VARIABLE.STRING$ = ""                                     :\
2555: 0f1f:             MESSAGE.NO% = 3                                           :\
2556: 0f2d:             RETURN.FIELD% = 5                                         :\
2557: 0f3b:             RC% EQ EXTERNAL.MESSAGE (MESSAGE.NO%,                      \
2558: 0f62:                                      VARIABLE.STRING$,                 \
2559: 0f62:                                      RETURN.FIELD%)                   :\
2560: 0f62:             IF RC% NE 0 THEN                                           \
2561: 0f74:                GOTO CHAIN.OUT                                         :\
2562: 0f81:             ELSE                                                       \
2563: 0f89:                RETURN
2564: 0f99: 
2565: 0f99:       IF INC.DEC$ = "I" AND                                            \
2566: 0fe5:          DECREASES.RUN.ALREADY.FLAG$ = "Y" THEN                        \
2567: 0fe5:          DECREASE.PERFORMED.$ = "N"
2568: 0ffa: 
2569: 0ffa:       ! 2 lines deleted from here !!!!!                                ! BMW
2570: 0ffa: 
2571: 0ffa:       IF INC.DEC$ = "D" AND                                            \
2572: 106f:          PSBCHN.APP <> "PSB51"  AND                                    \
2573: 106f:          DECREASES.RUN.ALREADY.FLAG$ = "Y" THEN                        \
2574: 106f:          DECREASE.PERFORMED.$ = "N"                                   :\
2575: 1084:          VARIABLE.STRING$ = ""                                        :\
2576: 1099:          MESSAGE.NO% = 277                                            :\
2577: 10a7:          RETURN.FIELD% = 5                                            :\
2578: 10b5:          RC% EQ EXTERNAL.MESSAGE (MESSAGE.NO%,                         \
2579: 10dc:                                   VARIABLE.STRING$,                    \
2580: 10dc:                                   RETURN.FIELD%)                      :\
2581: 10dc:          IF RC% NE 0 THEN                                              \
2582: 10ee:             GOTO CHAIN.OUT                                            :\
2583: 10fb:          ELSE                                                          \
2584: 10fb:             STRING.DATA$ = ""                                         :\
2585: 1110:             INTEGER.DATA% = 0                                         :\
2586: 111e:             RC% EQ DM.UPDF (STRING.DATA$,INTEGER.DATA%)               :\
2587: 1141:             IF RC% NE 0 THEN                                           \
2588: 1153:                GOTO CHAIN.OUT                                         :\
2589: 1160:             ELSE                                                       \
2590: 1160:                GOTO PROCESS.RETURN
2591: 116b: 
2592: 116b:       IF INC.DEC$ = "D" AND                                            \
2593: 11bb:          PSBCHN.APP <> "PSB51"  THEN                                   \
2594: 11bb:          STRING.DATA$ = ""                                            :\
2595: 11d0:          INTEGER.DATA% = 7                                            :\
2596: 11de:          RC% EQ DM.POSF (STRING.DATA$,INTEGER.DATA%)                  :\
2597: 1201:          IF RC% NE 0 THEN                                              \
2598: 1213:             GOTO CHAIN.OUT                                            :\
2599: 1221:          ELSE                                                          \
2600: 1221:             STRING.DATA$ = "Are you sure? (Y/N)"                      :\
2601: 1236:             INTEGER.DATA% = 0                                         :\
2602: 1244:             RC% EQ DM.PUTF (STRING.DATA$,INTEGER.DATA%)               :\
2603: 1267:             IF RC% NE 0 THEN                                           \
2604: 1279:                GOTO CHAIN.OUT                                         :\
2605: 1287:             ELSE                                                       \
2606: 1287:                STRING.DATA$ = ""                                      :\
2607: 129c:                INTEGER.DATA% = 8                                      :\
2608: 12aa:                RC% EQ DM.POSF (STRING.DATA$,INTEGER.DATA%)            :\
2609: 12cd:                IF RC% NE 0 THEN                                        \
2610: 12df:                   GOTO CHAIN.OUT                                      :\
2611: 12ec:                ELSE                                                    \
2612: 12ec:                BEGIN                                                   ! BMW
2613: 12f4:                   GOSUB CONFIRM.CHOICE                                 ! BMW
2614: 1306:                   IF KEY$ = "N" THEN                                   \ BMW
2615: 1321:                   BEGIN                                                ! BMW
2616: 1321:                      DECREASE.PERFORMED.$ = "N"                        ! BMW
2617: 1336:                      GOTO PROCESS.RETURN                               ! BMW
2618: 1341:                   ENDIF                                                ! BMW
2619: 1349:                ENDIF                                                   ! BMW
2620: 1351: 
2621: 1351:       IF PSBCHN.APP <> "PSB51"  THEN                                   \
2622: 1372:          IF INC.DEC$ = "D" THEN                                        \
2623: 138d:             STRING.DATA$ = "B7202"                                    :\
2624: 13a2:             INTEGER.DATA% = 0                                         :\
2625: 13b0:             RC% EQ DM.DISPD (STRING.DATA$,INTEGER.DATA%)              :\
2626: 13d3:             IF RC% NE 0 THEN                                           \
2627: 13e5:                GOTO CHAIN.OUT                                         :\
2628: 13f2:             ELSE                                                       \
2629: 13f2:          ELSE                                                          \
2630: 13fc:             STRING.DATA$ = "B7203"                                    :\
2631: 1411:             INTEGER.DATA% = 0                                         :\
2632: 141f:             RC% EQ DM.DISPD (STRING.DATA$,INTEGER.DATA%)              :\
2633: 1442:             IF RC% NE 0 THEN                                           \
2634: 1454:                GOTO CHAIN.OUT
2635: 145f: 
2636: 145f:       IF INC.DEC$ = "D" THEN                                           \
2637: 147a:       BEGIN                                                            ! BMW
2638: 147a:          GOSUB AUTO.EFFECT.DECREASES
2639: 148c: 
2640: 148c: !        Lines deleted - PPFI close and reopen                         ! 1.19 RC
2641: 148c: 
2642: 148c:          IF PSBCHN.APP <> "PSB51"  THEN                                \
2643: 14aa:             GOTO PROCESS.RETURN                                        \
2644: 14b7:          ELSE                                                          \
2645: 14bf:             GOTO CHAIN.OUT
2646: 14ca:       ENDIF                                                            ! BMW
2647: 14d2: 
2648: 14d2:       GOSUB GET.DATA
2649: 14e4: 
2650: 14e4: \...............................................................................
2651: 14e4: \***
2652: 14e4: \***   set key pressed to 999
2653: 14e4: \***   set nextf parameter to -20 (first input field)
2654: 14e4: \***   set move cursor flag on
2655: 14e4: \***   set quit flag off
2656: 14e4: \***   set zero entry flag off
2657: 14e4: \***   set effect flag off
2658: 14e4: \***
2659: 14e4: \***   WHILE key pressed is not ESC
2660: 14e4: \***   AND quit flag is off
2661: 14e4: \***
2662: 14e4: \***      IF total entries is 0
2663: 14e4: \***      AND effect flag is off THEN
2664: 14e4: \***         GOSUB NO.ENTRIES.MESSAGE
2665: 14e4: \***         set zero entry flag on
2666: 14e4: \***         set nextf parameter to 20 (last input field)
2667: 14e4: \***         set move cursor flag on
2668: 14e4: \***      endif
2669: 14e4: \***
2670: 14e4: \***      IF move cursor flag is on THEN
2671: 14e4: \***         set string data to spaces
2672: 14e4: \***         set integer data to nextf parameter
2673: 14e4: \***         CALL DM.NEXTF function to position the cursor accordingly
2674: 14e4: \***         IF F03.RETURN.CODE% <> 0 THEN
2675: 14e4: \***            GOTO CHAIN.OUT
2676: 14e4: \***         endif
2677: 14e4: \***      endif
2678: 14e4: \***
2679: 14e4: \***      set string data to spaces
2680: 14e4: \***      set integer data to 0
2681: 14e4: \***      CALL DM.UPDF function to get user input
2682: 14e4: \***      IF F03.RETURN.CODE% <> 0 THEN
2683: 14e4: \***         GOTO CHAIN.OUT
2684: 14e4: \***      endif
2685: 14e4: \***
2686: 14e4: \***      set key pressed to F03.RETURNED.INTEGER%
2687: 14e4: \***
2688: 14e4: \***      on case of
2689: 14e4: \***         key pressed is F3 and total entries = 0
2690: 14e4: \***           set quit flag to "Y"
2691: 14e4: \***         key pressed is F3, Enter, Tab, Home, End, PgUp or PgDn
2692: 14e4: \***            GOSUB PROCESS.ENTRY
2693: 14e4: \***         key pressed is F1
2694: 14e4: \***            GOSUB HELP.ON.7203
2695: 14e4: \***         key pressed is not Enter,PgUp,PgDn,F1,Tab,Home,End,F3 or ESC and
2696: 14e4: \***            zero entry flag is off
2697: 14e4: \***            set move cursor flag off
2698: 14e4: \***            set string data to spaces
2699: 14e4: \***            set integer data to 0 (current field)
2700: 14e4: \***            CALL DM.POSF function to retrieve the current field
2701: 14e4: \***            IF F03.RETURN.CODE% <> 0 THEN
2702: 14e4: \***               GOTO CHAIN.OUT
2703: 14e4: \***            ELSE
2704: 14e4: \***               CALL EXTERNAL.MESSAGE function to display message 001,
2705: 14e4: \***                                              return to current field
2706: 14e4: \***               IF F04.RETURN.CODE% <> 0 THEN
2707: 14e4: \***                  GOTO CHAIN.OUT
2708: 14e4: \***               endif
2709: 14e4: \***            endif
2710: 14e4: \***      endcase
2711: 14e4: \***
2712: 14e4: \***   WEND
2713: 14e4: \***
2714: 14e4: \...............................................................................
2715: 14e4: 
2716: 14e4:       KEY.PRESSED% = 999
2717: 14f2:       NEXTF.PARM% = -20
2718: 1500:       MOVE.CURSOR$ = "Y"
2719: 1515:       QUIT.FLAG$ = "N"
2720: 152a:       QUIT.PRESSED$ = "N"
2721: 153f:       ZERO.ENTRY.FLAG$ = "N"
2722: 1554:       EFFECT.FLAG$ = "N"
2723: 1569: 
2724: 1569:       WHILE KEY.PRESSED% <> ESCAPE% AND QUIT.FLAG$ = "N"
2725: 1574: 
2726: 1574:          IF TOTAL.ENTRIES% = 0                                         \
2727: 15ba:          AND EFFECT.FLAG$ = "N" THEN                                   \
2728: 15ba:             GOSUB NO.ENTRIES.MESSAGE                                  :\
2729: 15cc:             ZERO.ENTRY.FLAG$ = "Y"                                    :\
2730: 15e1:             NEXTF.PARM% = 20                                          :\
2731: 15ef:             MOVE.CURSOR$ = "Y"
2732: 1604: 
2733: 1604:          IF MOVE.CURSOR$ = "Y" THEN                                    \
2734: 161f:             STRING.DATA$ = ""                                         :\
2735: 1634:             INTEGER.DATA% = NEXTF.PARM%                               :\
2736: 1642:             RC% EQ DM.NEXTF (STRING.DATA$,INTEGER.DATA%)              :\
2737: 1665:             IF RC% NE 0 THEN                                           \
2738: 1677:                GOTO CHAIN.OUT
2739: 1682: 
2740: 1682:          STRING.DATA$ = ""
2741: 1697:          INTEGER.DATA% = 0
2742: 16a5:          RC% EQ DM.UPDF (STRING.DATA$,INTEGER.DATA%)
2743: 16c8:          IF RC% NE 0 THEN                                              \
2744: 16da:             GOTO CHAIN.OUT
2745: 16e5: 
2746: 16e5:          KEY.PRESSED% = F03.RETURNED.INTEGER%
2747: 16f7: 
2748: 16f7:          IF KEY.PRESSED% = QUIT% AND TOTAL.ENTRIES% = 0 THEN           \
2749: 1727:             QUIT.FLAG$ = "Y"                                          :\
2750: 173f:          ELSE                                                          \
2751: 1747:             IF KEY.PRESSED% = QUIT% OR                                 \
2752: 17a6:                KEY.PRESSED% = ENTER% OR                                \
2753: 17a6:                KEY.PRESSED% = TAB% OR                                  \
2754: 17a6:                KEY.PRESSED% = HOME% OR                                 \
2755: 17a6:                KEY.PRESSED% = END.KEY% OR                              \
2756: 17a6:                KEY.PRESSED% = PAGE.UP% OR                              \
2757: 17a6:                KEY.PRESSED% = PAGE.DOWN% THEN                         :\
2758: 17a6:                GOSUB PROCESS.ENTRY                                    :\
2759: 17bb:             ELSE                                                       \
2760: 17c3:                IF KEY.PRESSED% = HELP% THEN                            \
2761: 17d4:                   GOSUB HELP.ON.7203                                  :\
2762: 17e9:                ELSE                                                    \
2763: 17f1:                   IF KEY.PRESSED% <> ESCAPE% AND                       \
2764: 1830:                      ZERO.ENTRY.FLAG$ = "N" THEN                       \
2765: 1830:                      MOVE.CURSOR$ = "N"                               :\
2766: 1845:                      STRING.DATA$ = ""                                :\
2767: 185a:                      INTEGER.DATA% = 0                                :\
2768: 1868:                      RC% EQ DM.POSF (STRING.DATA$,INTEGER.DATA%)      :\
2769: 188b:                      IF RC% NE 0 THEN                                  \
2770: 189d:                         GOTO CHAIN.OUT                                :\
2771: 18aa:                      ELSE                                              \
2772: 18aa:                         MESSAGE.NO% = 1                               :\
2773: 18b8:                         VARIABLE.STRING$ = ""                         :\
2774: 18cd:                         RETURN.FIELD% = F03.RETURNED.INTEGER%         :\
2775: 18df:                         RC% EQ EXTERNAL.MESSAGE (MESSAGE.NO%,          \
2776: 1906:                                                  VARIABLE.STRING$,     \
2777: 1906:                                                  RETURN.FIELD%)       :\
2778: 1906:                         IF RC% NE 0 THEN                               \
2779: 1918:                            GOTO CHAIN.OUT
2780: 1923: 
2781: 1923:       WEND
2782: 1962: 
2783: 1962: \...............................................................................
2784: 1962: \***
2785: 1962: \***   IF key pressed is ESC THEN
2786: 1962: \***      CHAIN to "ADX_UPGM:PSB50.286"
2787: 1962: \***   endif
2788: 1962: \***
2789: 1962: \***   CLOSE the ppfi
2790: 1962: \***   IF END occurs on open ppfi THEN OPEN.PPFI.ERROR
2791: 1962: \***   OPEN ppfi LOCKED NOWRITE
2792: 1962: \***
2793: 1962: \***   PROCESS.RETURN:
2794: 1962: \***
2795: 1962: \***   set string data to "B7201"
2796: 1962: \***   set integer data to 0
2797: 1962: \***   CALL DM.DISPD function to display the screen
2798: 1962: \***   IF F03.RETURN.CODE% <> 0 THEN
2799: 1962: \***      GOTO CHAIN.OUT
2800: 1962: \***   endif
2801: 1962: \***
2802: 1962: \***   IF increase/decrease flag is "I" THEN
2803: 1962: \***      GOSUB PUT.SELECTION
2804: 1962: \***   endif
2805: 1962: \***
2806: 1962: \***   set key pressed to 999
2807: 1962: \***
2808: 1962: \***   RETURN
2809: 1962: \***
2810: 1962: \...............................................................................
2811: 1962: 
2812: 1962:       IF KEY.PRESSED% = ESCAPE% AND                                    \
2813: 199e:          PPFO.THERE.FLAG$ = "Y" THEN                                   \
2814: 199e:          PPFO.THERE.FLAG$ = "N"                                       :\
2815: 19b3:          CLOSE PPFO.SESS.NUM%
2816: 19c7: 
2817: 19c7:       IF KEY.PRESSED% = ESCAPE% THEN                                   \
2818: 19d8:          GOTO ESCAPE.TO.MAIN.MENU
2819: 19e3: 
2820: 19e3: !     Lines deleted - PPFI close and re-open                           ! 1.19 RC
2821: 19e3: 
2822: 19e3:    PROCESS.RETURN:
2823: 19f3: 
2824: 19f3:       STRING.DATA$ = "B7201"
2825: 1a08:       INTEGER.DATA% = 0
2826: 1a16:       RC% EQ DM.DISPD (STRING.DATA$,INTEGER.DATA%)
2827: 1a39:       IF RC% NE 0 THEN                                                 \
2828: 1a4b:          GOTO CHAIN.OUT
2829: 1a56: 
2830: 1a56:       IF INC.DEC$ = "I" THEN                                           \
2831: 1a71:          GOSUB PUT.SELECTION
2832: 1a83: 
2833: 1a83:       STRING.DATA$ = ""
2834: 1a98:       INTEGER.DATA% = 1
2835: 1aa6:       RC% EQ DM.POSF (STRING.DATA$,INTEGER.DATA%)
2836: 1ac9:       IF RC% NE 0 THEN                                                 \
2837: 1adb:          GOTO CHAIN.OUT
2838: 1ae6: 
2839: 1ae6:       IF DECREASE.PERFORMED.$ = "Y" THEN                                 \
2840: 1b01:         VARIABLE.STRING$ = ""                                           :\
2841: 1b16:         MESSAGE.NO% = 276                                               :\
2842: 1b24:         RETURN.FIELD% = 5                                               :\
2843: 1b32:         RC% EQ EXTERNAL.MESSAGE (MESSAGE.NO%,                            \
2844: 1b59:                                  VARIABLE.STRING$,                       \
2845: 1b59:                                  RETURN.FIELD%)                         :\
2846: 1b59:         IF RC% NE 0 THEN                                                 \
2847: 1b6b:            GOTO CHAIN.OUT
2848: 1b76: 
2849: 1b76:       KEY.PRESSED% = 999
2850: 1b84: 
2851: 1b84:    RETURN
2852: 1b94: 
2853: 1b94: \*******************************************************************************
2854: 1b94: \***
2855: 1b94: \***   ESCAPE.TO.MAIN.MENU:
2856: 1b94: \***
2857: 1b94: \***   set psbchn mencon to null
2858: 1b94: \***   set psbchn prg to "ADX_UPGM:PSB50.286"
2859: 1b94: \***   %INCLUDE PSBCHN.J86
2860: 1b94: \***
2861: 1b94: \...............................................................................
2862: 1b94: 
2863: 1b94:       ESCAPE.TO.MAIN.MENU:
2864: 1ba4: 
2865: 1ba4:          PSBCHN.MENCON = ""
2866: 1bbb:          PSBCHN.PRG = "ADX_UPGM:PSB50.286"
2867: 1bd2:          %INCLUDE PSBCHNE.J86                                          ! FAW
2868: 1bd2: \/*********************************************************************/ PSBCHNE
2869: 1bd2: \/*                                                                   */ PSBCHNE
2870: 1bd2: \/*      PSBCHNE.J86  -  Chain to PSB Application Program             */ PSBCHNE
2871: 1bd2: \/*      ------------------------------------------------             */ PSBCHNE
2872: 1bd2: \/*                                                                   */ PSBCHNE
2873: 1bd2: \/*********************************************************************/ PSBCHNE
2874: 1bd2:                                                                        ! PSBCHNE
2875: 1bd2:         CHAIN  PSBCHN.PRG , PSBCHN.OP , PSBCHN.APP , PSBCHN.MENCON ,   \ PSBCHNE
2876: 1c52:                             PSBCHN.U1 , PSBCHN.U2  , PSBCHN.U3         ! PSBCHNE
2877: 1c52:                                                                        ! PSBCHNE
2878: 1c52: 
2879: 1c52: \*******************************************************************************
2880: 1c52: \***
2881: 1c52: \***   HELP.ON.7201:
2882: 1c52: \***
2883: 1c52: \***   set string data to spaces
2884: 1c52: \***   set integer data to 1
2885: 1c52: \***   CALL DM.POSF function to position the cursor in field 01
2886: 1c52: \***   IF F03.RETURN.CODE% <> 0 THEN
2887: 1c52: \***      GOTO CHAIN.OUT
2888: 1c52: \***   endif
2889: 1c52: \***
2890: 1c52: \***   set string data to spaces
2891: 1c52: \***   set integer data to 0
2892: 1c52: \***   CALL DM.UPDF function to get message
2893: 1c52: \***   IF F03.RETURN.CODE% <> 0 THEN
2894: 1c52: \***      GOTO CHAIN.OUT
2895: 1c52: \***   endif
2896: 1c52: \***
2897: 1c52: \***   CALL HELP function
2898: 1c52: \***   IF F12.RETURN.CODE% <> 0 THEN
2899: 1c52: \***      GOTO CHAIN.OUT
2900: 1c52: \***   endif
2901: 1c52: \***
2902: 1c52: \***   set string data to spaces
2903: 1c52: \***   set integer data to 1
2904: 1c52: \***   CALL DM.POSF function to position cursor in field 01
2905: 1c52: \***   IF F03.RETURN.CODE% <> 0 THEN
2906: 1c52: \***      GOTO CHAIN.OUT
2907: 1c52: \***   endif
2908: 1c52: \***
2909: 1c52: \***   set string data to message
2910: 1c52: \***   set integer data to 0
2911: 1c52: \***   CALL DM.PUTF function to put message in field 01
2912: 1c52: \***   IF F03.RETURN.CODE% <> 0 THEN
2913: 1c52: \***      GOTO CHAIN.OUT
2914: 1c52: \***   endif
2915: 1c52: \***
2916: 1c52: \***   GOSUB PUT.SELECTION
2917: 1c52: \***
2918: 1c52: \***   RETURN
2919: 1c52: \***
2920: 1c52: \...............................................................................
2921: 1c52: 
2922: 1c52:    HELP.ON.7201:
2923: 1c62: 
2924: 1c62:       STRING.DATA$ = ""
2925: 1c77:       INTEGER.DATA% = 1
2926: 1c85:       RC% EQ DM.POSF (STRING.DATA$,INTEGER.DATA%)
2927: 1ca8:       IF RC% NE 0 THEN                                                 \
2928: 1cba:          GOTO CHAIN.OUT
2929: 1cc5: 
2930: 1cc5:       STRING.DATA$ = ""
2931: 1cda:       INTEGER.DATA% = 0
2932: 1ce8:       RC% EQ DM.UPDF (STRING.DATA$,INTEGER.DATA%)
2933: 1d0b:       IF RC% NE 0 THEN                                                 \
2934: 1d1d:          GOTO CHAIN.OUT
2935: 1d28:       SAVED.DISP.MESSAGE$ = F03.RETURNED.STRING$
2936: 1d44: 
2937: 1d44:       RC% EQ HELP (B7201.SCREEN.NO$)
2938: 1d63:       IF RC% NE 0 THEN                                                 \
2939: 1d75:          GOTO CHAIN.OUT
2940: 1d80: 
2941: 1d80:       STRING.DATA$ = ""
2942: 1d95:       INTEGER.DATA% = 1
2943: 1da3:       RC% EQ DM.POSF (STRING.DATA$,INTEGER.DATA%)
2944: 1dc6:       IF RC% NE 0 THEN                                                 \
2945: 1dd8:          GOTO CHAIN.OUT
2946: 1de3: 
2947: 1de3:       STRING.DATA$ = SAVED.DISP.MESSAGE$
2948: 1dfc:       INTEGER.DATA% = 0
2949: 1e0a:       RC% EQ DM.PUTF (STRING.DATA$,INTEGER.DATA%)
2950: 1e2d:       IF RC% NE 0 THEN                                                 \
2951: 1e3f:          GOTO CHAIN.OUT
2952: 1e4a: 
2953: 1e4a:       GOSUB PUT.SELECTION
2954: 1e5c: 
2955: 1e5c:    RETURN
2956: 1e6c: 
2957: 1e6c: \*******************************************************************************
2958: 1e6c: \***
2959: 1e6c: \***   PUT.SELECTION:
2960: 1e6c: \***
2961: 1e6c: \***   set string data to spaces
2962: 1e6c: \***   set integer data to 5
2963: 1e6c: \***   CALL DM.POSF function to position the cursor in field 5
2964: 1e6c: \***   IF F03.RETURN.CODE% <> 0 THEN
2965: 1e6c: \***      GOTO CHAIN.OUT
2966: 1e6c: \***   endif
2967: 1e6c: \***
2968: 1e6c: \***   set string data to selection
2969: 1e6c: \***   set integer data to 0
2970: 1e6c: \***   CALL DM.PUTF function to put selection in field 5
2971: 1e6c: \***   IF F03.RETURN.CODE% <> 0 THEN
2972: 1e6c: \***      GOTO CHAIN.OUT
2973: 1e6c: \***   endif
2974: 1e6c: \***
2975: 1e6c: \***   RETURN
2976: 1e6c: \***
2977: 1e6c: \...............................................................................
2978: 1e6c: 
2979: 1e6c:    PUT.SELECTION:
2980: 1e7c: 
2981: 1e7c:       STRING.DATA$ = ""
2982: 1e91:       INTEGER.DATA% = 5
2983: 1e9f:       RC% EQ DM.POSF (STRING.DATA$,INTEGER.DATA%)
2984: 1ec2:       IF RC% NE 0 THEN                                                 \
2985: 1ed4:          GOTO CHAIN.OUT
2986: 1edf: 
2987: 1edf:       STRING.DATA$ = SELECTION$
2988: 1ef8:       INTEGER.DATA% = 0
2989: 1f06:       RC% EQ DM.PUTF (STRING.DATA$,INTEGER.DATA%)
2990: 1f29:       IF RC% NE 0 THEN                                                 \
2991: 1f3b:          GOTO CHAIN.OUT
2992: 1f46: 
2993: 1f46:    RETURN
2994: 1f56: 
2995: 1f56: \*******************************************************************************
2996: 1f56: \***
2997: 1f56: \***    CONFIRM.CHOICE:
2998: 1f56: \***
2999: 1f56: \***    WHILE key selected <> "N" AND key selected <> "Y"
3000: 1f56: \***            CALL DM.UPDF to get key selected and exit key
3001: 1f56: \***            IF exit key is the HELP key THEN
3002: 1f56: \***            BEGIN
3003: 1f56: \***                    Save the returned string
3004: 1f56: \***                    Call the required help routine
3005: 1f56: \***                    Restore the returned string
3006: 1f56: \***                    Restore the 'Are you sure (Y/N) ?' prompt
3007: 1f56: \***            ENDIF
3008: 1f56: \***            ELSE
3009: 1f56: \***            IF key selected <> "N" AND key selected <> "Y" THEN
3010: 1f56: \***            BEGIN
3011: 1f56: \***                    Set message number to 1
3012: 1f56: \***                    CALL EXTERNAL.MESSAGE to display message B001
3013: 1f56: \***                    IF the return code <> 0 THEN
3014: 1f56: \***                            GOTO CHAIN.OUT to exit the program
3015: 1f56: \***            ENDIF
3016: 1f56: \***    WEND
3017: 1f56: \***
3018: 1f56: \***    IF key selected = "N" THEN
3019: 1f56: \***    BEGIN
3020: 1f56: \***            Set decreases already performed flag to "N"
3021: 1f56: \***    ENDIF
3022: 1f56: \***
3023: 1f56: \***    RETURN
3024: 1f56: \***
3025: 1f56: \*******************************************************************************
3026: 1f56: 
3027: 1f56:         CONFIRM.CHOICE:
3028: 1f66: 
3029: 1f66:         KEY$ = ""                                                       ! BMW
3030: 1f7b:         EXIT.KEY% = 999                                                 ! BMW
3031: 1f89: 
3032: 1f89:         WHILE (KEY$ <> "N" AND KEY$ <> "Y") OR EXIT.KEY% <> ENTER%      ! BMW
3033: 1f94: 
3034: 1f94:                 STRING.DATA$ = ""                                       ! BMW
3035: 1fa9:                 INTEGER.DATA% = 0                                       ! BMW
3036: 1fb7: 
3037: 1fb7:                 RC% EQ DM.UPDF(STRING.DATA$,INTEGER.DATA%)              !DSJW
3038: 1fda:                 IF RC% NE 0 THEN                                        \DSJW
3039: 1fec:                    GOTO CHAIN.OUT                                       !DSJW
3040: 1ff7: 
3041: 1ff7:                 KEY$ = F03.RETURNED.STRING$                             ! BMW
3042: 2013:                 EXIT.KEY% = F03.RETURNED.INTEGER%                       ! BMW
3043: 2025: 
3044: 2025:                 IF EXIT.KEY% = HELP% THEN                               \ BMW
3045: 2039:                 BEGIN                                                   ! BMW
3046: 2039:                         GOSUB HELP.ON.7201                              ! BMW
3047: 204b: 
3048: 204b:                         STRING.DATA$ = ""                               ! BMW
3049: 2060:                         INTEGER.DATA% = 7                               ! BMW
3050: 206e: 
3051: 206e:                         RC% EQ DM.POSF(STRING.DATA$,INTEGER.DATA%)      !DSJW
3052: 2091:                         IF RC% NE 0 THEN                                \DSJW
3053: 20a3:                                 GOTO CHAIN.OUT                          !DSJW
3054: 20ae: 
3055: 20ae:                         STRING.DATA$ = "Are you sure? (Y/N)"            ! BMW
3056: 20c3:                         INTEGER.DATA% = 0                               ! BMW
3057: 20d1: 
3058: 20d1:                         RC% EQ DM.PUTF(STRING.DATA$,INTEGER.DATA%)      !DSJW
3059: 20f4:                         IF RC% NE 0 THEN                                \DSJW
3060: 2106:                                 GOTO CHAIN.OUT                          !DSJW
3061: 2111: 
3062: 2111:                         STRING.DATA$ = "0"                              ! BMW
3063: 2126:                         INTEGER.DATA% = 0                               ! BMW
3064: 2134: 
3065: 2134:                         RC% EQ DM.SETF(STRING.DATA$,INTEGER.DATA%)      !DSJW
3066: 2157:                         IF RC% NE 0 THEN                                \DSJW
3067: 2169:                                 GOTO CHAIN.OUT                          !DSJW
3068: 2174: 
3069: 2174:                         STRING.DATA$ = ""                               ! BMW
3070: 2189:                         INTEGER.DATA% = 8                               ! BMW
3071: 2197: 
3072: 2197:                         RC% EQ DM.POSF(STRING.DATA$,INTEGER.DATA%)      !DSJW
3073: 21ba:                         IF RC% NE 0 THEN                                \DSJW
3074: 21cc:                                 GOTO CHAIN.OUT                          !DSJW
3075: 21d7: 
3076: 21d7:                         STRING.DATA$ = KEY$                             ! BMW
3077: 21f0:                         INTEGER.DATA% = 0                               ! BMW
3078: 21fe: 
3079: 21fe:                         RC% EQ DM.PUTF(STRING.DATA$,INTEGER.DATA%)      !DSJW
3080: 2221:                         IF RC% NE 0 THEN                                \DSJW
3081: 2233:                                 GOTO CHAIN.OUT                          !DSJW
3082: 2241:                 ENDIF                                                   \ BMW
3083: 2241:                 ELSE                                                    \ BMW
3084: 2249:                 IF KEY$ <> "N" AND KEY$ <> "Y" THEN                     \ BMW
3085: 2298:                 BEGIN                                                   ! BMW
3086: 2298:                         MESSAGE.NO% = 1                                 ! BMW
3087: 22a6:                         VARIABLE.STRING$ = ""                           ! BMW
3088: 22bb:                         RETURN.FIELD% = 8                               ! BMW
3089: 22c9: 
3090: 22c9:                         RC% EQ EXTERNAL.MESSAGE(MESSAGE.NO%,            \DSJW
3091: 22f0:                                                 VARIABLE.STRING$,       \DSJW
3092: 22f0:                                                 RETURN.FIELD%)          !DSJW
3093: 22f0:                         IF RC% NE 0 THEN                                \DSJW
3094: 2302:                                 GOTO CHAIN.OUT                          !DSJW
3095: 230d:                 ENDIF                                                   ! BMW
3096: 2315:         WEND                                                            ! BMW
3097: 2374: 
3098: 2374:         RETURN                                                          ! BMW
3099: 2384: 
3100: 2384: \*******************************************************************************
3101: 2384: \***
3102: 2384: \***   GET.DATA:
3103: 2384: \***
3104: 2384: \***   set count of entries to 0
3105: 2384: \***   set eof flag off
3106: 2384: \***   set first string to null
3107: 2384: \***   set ppfi record count to 0
3108: 2384: \***
3109: 2384: \***   IF END occurs on read ppfi THEN READ.PPFI.ERROR
3110: 2384: \***   CALL READ.PPFI
3111: 2384: \***   increment ppfi record count by 1
3112: 2384: \***
3113: 2384: \***   WHILE eof flag is off
3114: 2384: \***   AND ppfi boots code is not 9999999 (trailer record)
3115: 2384: \***   AND count of entries is less than 7250
3116: 2384: \***
3117: 2384: \***      IF ppf rec type = "R" THEN
3118: 2384: \***         IF ppfi increase/decrease flag is same as increase/decrease flag
3119: 2384: \***         AND ppfi status flag is not blank THEN
3120: 2384: \***            increment count of entries by 1
3121: 2384: \***            IF ppfi rpd number is 99999 THEN
3122: 2384: \***               set ppfi rpd number to 0
3123: 2384: \***               set ppfi date to 0
3124: 2384: \***               set first string to first string + ppfi date and rpd number
3125: 2384: \***            ELSE
3126: 2384: \***               set first string to first string + ppfi date and rpd number
3127: 2384: \***            endif
3128: 2384: \***         endif
3129: 2384: \***      endif
3130: 2384: \***
3131: 2384: \***      IF END occurs on read ppfi THEN READ.PPFI.ERROR
3132: 2384: \***      CALL READ.PPFI
3133: 2384: \***      increment ppfi record count by 1
3134: 2384: \***
3135: 2384: \***   WEND
3136: 2384: \***
3137: 2384: \***   GOSUB CHECK.PPFI.TRAILER
3138: 2384: \***
3139: 2384: \...............................................................................
3140: 2384: 
3141: 2384:    GET.DATA:
3142: 2394: 
3143: 2394:       STRING.DATA$ = ""                                                ! BMW
3144: 23a9:       INTEGER.DATA% = 107                                              ! BMW
3145: 23b7: 
3146: 23b7:       RC% EQ DM.POSF (STRING.DATA$,INTEGER.DATA%)                      !DSJW
3147: 23da: 
3148: 23da:       IF RC% NE 0 THEN                                                 \DSJW
3149: 23ec:          GOTO CHAIN.OUT                                                \ BMW
3150: 23fa:       ELSE                                                             \ BMW
3151: 2402:          MESSAGE.NO% = 405                                            :\ BMW
3152: 2410:          RETURN.FIELD% = F03.RETURNED.INTEGER%                        :\ BMW
3153: 2422:          VARIABLE.STRING$ = ""                                        :\ BMW
3154: 2437:          RC% EQ EXTERNAL.MESSAGE (MESSAGE.NO%,                         \DSJW
3155: 245e:                                   VARIABLE.STRING$,                    \DSJW
3156: 245e:                                   RETURN.FIELD%)                      :\DSJW
3157: 245e:          IF RC% NE 0 THEN                                              \DSJW
3158: 2470:             GOTO CHAIN.OUT                                             !DSJW
3159: 247b: 
3160: 247b:       ENTRY.COUNT% = 0
3161: 2490:       END.OF.FILE$ = "N"
3162: 24a5: !     Line deleted                                                     ! 1.20 RC
3163: 24a5:       PPFI.RECORD.COUNT% = 0
3164: 24ba: 
3165: 24ba:       DIM F14.TABLE$ (TABLE.LIMIT.14K%)                                ! 1.20 RC
3166: 24ef:       F14.TABLE$(0) = ""                                               ! 1.20 RC
3167: 2512: 
3168: 2512:       GOSUB OPEN.PPFI.LOCKED                                           ! 1.19 RC
3169: 2524:        
3170: 2524:       RC% EQ READ.PPFI                                                  !DSJW
3171: 2538:       IF RC% NE 0 THEN GOTO READ.PPFI.ERROR                             !DSJW
3172: 254d:       PPFI.RECORD.COUNT% = PPFI.RECORD.COUNT% + 1
3173: 2566: 
3174: 2566:       WHILE END.OF.FILE$ = "N"                                         \
3175: 2571:       AND PPF.BOOTS.CODE$ <> "9999999"                                 \CSJW
3176: 2571:       AND ENTRY.COUNT% < TABLE.LIMIT.14K%                              ! 1.20 RC
3177: 2571: 
3178: 2571:          IF PPF.REC.TYPE.FLAG$ = "R" THEN                              \
3179: 2592:             IF PPF.INC.DEC.FLAG$ = INC.DEC$                            \
3180: 25eb:             AND PPF.STATUS.FLAG$ <> " " THEN                           \
3181: 25eb:                ENTRY.COUNT% = ENTRY.COUNT% + 1                        :\
3182: 2604:                IF VAL(PPF.RPD.NO$) = 99999 THEN BEGIN                  !CSJW
3183: 2639:                   F14.TABLE$(ENTRY.COUNT%) = \                         ! 1.20 RC
3184: 269e:                                        F14.TABLE$(ENTRY.COUNT%) + \    ! 1.20 RC
3185: 269e:                                        PACK$("00000000") +             \GSB
3186: 269e:                                        PACK$("000000")
3187: 269e:                ENDIF ELSE BEGIN
3188: 26a6:                   IF LEFT$(PPF.DATE.DUE$,2) < "85" THEN BEGIN          !GSB
3189: 26de:                      F14.TABLE$(ENTRY.COUNT%) = \                      ! 1.20 RC
3190: 2773:                                        F14.TABLE$(ENTRY.COUNT%) + \    ! 1.20 RC
3191: 2773:                                        PACK$("20" + PPF.DATE.DUE$) +   \CSJW GSB
3192: 2773:                                        PACK$("0" + PPF.RPD.NO$)        !CSJW
3193: 2773:                   ENDIF ELSE BEGIN
3194: 277b:                      F14.TABLE$(ENTRY.COUNT%) = \                      ! 1.20 RC
3195: 280d:                                        F14.TABLE$(ENTRY.COUNT%) + \    ! 1.20 RC
3196: 280d:                                        PACK$("19" + PPF.DATE.DUE$) +   \GSB
3197: 280d:                                        PACK$("0" + PPF.RPD.NO$)        !GSB
3198: 280d:                   ENDIF                                                !GSB
3199: 2815:                ENDIF
3200: 281d: 
3201: 281d:          RC% EQ READ.PPFI                                               !DSJW
3202: 2831:          IF RC% NE 0 THEN GOTO READ.PPFI.ERROR                          !DSJW
3203: 2846:          PPFI.RECORD.COUNT% = PPFI.RECORD.COUNT% + 1
3204: 285f: 
3205: 285f:       WEND
3206: 28c6: 
3207: 28c6:       GOSUB CHECK.PPFI.TRAILER
3208: 28d8: 
3209: 28d8:       CLOSE PPFI.SESS.NUM%                                             ! 1.19 RC
3210: 28ec: 
3211: 28ec: \...............................................................................
3212: 28ec: \***
3213: 28ec: \***   DIMension F14.TABLE$ to have count of entries entries
3214: 28ec: \***
3215: 28ec: \***   set F14.TABLE$(0) to null
3216: 28ec: \***
3217: 28ec: \***   IF count of entries is 0 THEN
3218: 28ec: \***      set current page to 1
3219: 28ec: \***      set total pages to 1
3220: 28ec: \***      set total entries to 0
3221: 28ec: \***      GOSUB SHOW.PAGE
3222: 28ec: \***      RETURN
3223: 28ec: \***   endif
3224: 28ec: \***
3225: 28ec: \***   FOR entry from 1 to count of entries
3226: 28ec: \***
3227: 28ec: \***      set F14.TABLE$(entry) to part of first string starting at
3228: 28ec: \***                                   ((entry - 1) * length of entry) + 1, for
3229: 28ec: \***                                   length of entry
3230: 28ec: \***
3231: 28ec: \***   NEXT entry
3232: 28ec: \***
3233: 28ec: \***   IF count of entries is greater than or equal to 7250 THEN
3234: 28ec: \***      set string data to spaces
3235: 28ec: \***      set integer data to 0 (current field)
3236: 28ec: \***      CALL DM.POSF function to retrieve the current field
3237: 28ec: \***      IF F03.RETURN.CODE% <> 0 THEN
3238: 28ec: \***         GOTO CHAIN.OUT
3239: 28ec: \***      ELSE
3240: 28ec: \***         CALL EXTERNAL.MESSAGE function to display message number 265,
3241: 28ec: \***                                           return to current field
3242: 28ec: \***    "All RPD's may not be displayed - repeat later"
3243: 28ec: \***         IF F04.RETURN.CODE% <> 0 THEN
3244: 28ec: \***            GOTO CHAIN.OUT
3245: 28ec: \***         endif
3246: 28ec: \***      endif
3247: 28ec: \***   endif
3248: 28ec: \***
3249: 28ec: \***   CALL SORT.TABLE function to sort F14.TABLE$, using count of entries
3250: 28ec: \***   IF F14.RETURN.CODE% <> 0 THEN
3251: 28ec: \***      GOTO CHAIN.OUT
3252: 28ec: \***   endif
3253: 28ec: \***
3254: 28ec: \...............................................................................
3255: 28ec: 
3256: 28ec: !     F14.TABLE$ initialisation moved to start of procedure          ! 1.20 RC
3257: 28ec: 
3258: 28ec:       IF ENTRY.COUNT% = 0 THEN                                         \
3259: 2907:          CURRENT.PAGE% = 1                                            :\
3260: 2915:          TOTAL.PAGES% = 1                                             :\
3261: 292a:          TOTAL.ENTRIES% = 0                                           :\
3262: 293f:          GOSUB SHOW.PAGE                                              :\
3263: 2951:          RETURN
3264: 2961: 
3265: 2961: !     Lines deleted                                                  ! 1.20 RC
3266: 2961: 
3267: 2961:       IF ENTRY.COUNT% >= TABLE.LIMIT.14K% THEN BEGIN                 ! 1.20 RC
3268: 297d:          STRING.DATA$ = ""                                           ! 1.20 RC
3269: 2992:          INTEGER.DATA% = 0                                           ! 1.20 RC
3270: 29a0:          RC% EQ DM.POSF (STRING.DATA$,INTEGER.DATA%)                 ! 1.20 RC
3271: 29c3:          IF RC% NE 0 THEN BEGIN                                      ! 1.20 RC
3272: 29d5:             GOTO CHAIN.OUT                                           ! 1.20 RC
3273: 29e2:          ENDIF ELSE BEGIN                                            ! 1.20 RC
3274: 29ea: !           WAIT ; 500 ! Make initial of message more visible        ! 1.20 RC
3275: 29ea:             MESSAGE.NO% = 265
3276: 29f8:             GOSUB DISPLAY.BEMF.MSG.265                               ! 1.20 RC
3277: 2a0a: !           MESSAGE.NO% = 265                                        ! 1.20 RC
3278: 2a0a: !           RETURN.FIELD% = F03.RETURNED.INTEGER%                    ! 1.20 RC
3279: 2a0a: !           VARIABLE.STRING$ = ""                                    ! 1.20 RC
3280: 2a0a: !           RC% EQ EXTERNAL.MESSAGE (MESSAGE.NO%,                      \DJSW
3281: 2a0a: !                                    VARIABLE.STRING$,                 \DSJW
3282: 2a0a: !                                    RETURN.FIELD%)                   ! 1.20 RC
3283: 2a0a: !           IF RC% NE 0 THEN                                           \DSJW
3284: 2a0a: !              GOTO CHAIN.OUT
3285: 2a0a: !           WAIT ; 1500 ! Allow message to be read                   ! 1.20 RC
3286: 2a0a:          ENDIF                                                       ! 1.20 RC
3287: 2a12:       ENDIF                                                          ! 1.20 RC
3288: 2a1a:       
3289: 2a1a:       RC% EQ SORT.TABLE(ENTRY.COUNT%)                                   !DSJW
3290: 2a38:       IF RC% NE 0 THEN                                                  \DSJW
3291: 2a4a:          GOTO CHAIN.OUT
3292: 2a55: 
3293: 2a55: \..............................................................................
3294: 2a55: \***
3295: 2a55: \***   set display count to 0
3296: 2a55: \***   set saved entry to F14.TABLE$(1)
3297: 2a55: \***   set lines to 1
3298: 2a55: \***
3299: 2a55: \***   FOR entry from 2 to count of entries
3300: 2a55: \***
3301: 2a55: \***      IF F14.TABLE$(entry) <> saved entry THEN
3302: 2a55: \***         increment display count by 1
3303: 2a55: \***         set second string to second string + saved entry and lines
3304: 2a55: \***                             and blank space (for increase/decrease flag)
3305: 2a55: \***         set saved entry to F14.TABLE$(entry)
3306: 2a55: \***         set lines to 1
3307: 2a55: \***      ELSE
3308: 2a55: \***         increment lines by 1
3309: 2a55: \***      endif
3310: 2a55: \***
3311: 2a55: \***   NEXT entry
3312: 2a55: \***
3313: 2a55: \***   increment display count by 1
3314: 2a55: \***   set second string to second string + saved entry and lines
3315: 2a55: \***                              and blank space (for increase/decrease flag)
3316: 2a55: \***
3317: 2a55: \...............................................................................
3318: 2a55: 
3319: 2a55:       DIM DISPLAY.TABLE$ (TABLE.LIMIT.14K%)                          ! 1.20 RC
3320: 2a84: 
3321: 2a84:       DISPLAY.COUNT% = 0
3322: 2a99:       SAVED.ENTRY$ = F14.TABLE$(1)
3323: 2ac1:       LINES% = 1
3324: 2acf: 
3325: 2acf:       FOR INDEX% = 2 TO ENTRY.COUNT%
3326: 2ae0: 
3327: 2ae0:          IF F14.TABLE$ (INDEX%) <> SAVED.ENTRY$ THEN BEGIN           ! 1.20 RC
3328: 2b13:             DISPLAY.COUNT% = DISPLAY.COUNT% + 1
3329: 2b2c:             DISPLAY.TABLE$ (DISPLAY.COUNT%) = \                      ! 1.20 RC
3330: 2bbd:                                   RIGHT$(SAVED.ENTRY$,6) +             \GSB
3331: 2bbd:                                   PACK$(RIGHT$("0000" +                \
3332: 2bbd:                                         STR$(LINES%),4)) +             \
3333: 2bbd:                                   " "                                ! 1.20 RC
3334: 2bbd:             SAVED.ENTRY$ = F14.TABLE$ (INDEX%)                       ! 1.20 RC
3335: 2be7:             LINES% = 1                                               ! 1.20 RC
3336: 2bf7:          ENDIF ELSE BEGIN                                            ! 1.20 RC
3337: 2bff:             LINES% = LINES% + 1
3338: 2c0b:          ENDIF                                                       ! 1.20 RC
3339: 2c13:       
3340: 2c13:       NEXT INDEX%
3341: 2c32: 
3342: 2c32:       DISPLAY.COUNT% = DISPLAY.COUNT% + 1
3343: 2c4b:       DISPLAY.TABLE$ (DISPLAY.COUNT%) = \                            ! 1.20 RC
3344: 2cdc:                                   RIGHT$(SAVED.ENTRY$,6) +             \GSB
3345: 2cdc:                                   PACK$(RIGHT$("0000" +                \
3346: 2cdc:                                         STR$(LINES%),4)) +             \
3347: 2cdc:                                   " "
3348: 2cdc: 
3349: 2cdc: \...............................................................................
3350: 2cdc: \***
3351: 2cdc: \***   DIMension display table to have display count entries
3352: 2cdc: \***
3353: 2cdc: \***   FOR entry from 1 to display count
3354: 2cdc: \***
3355: 2cdc: \***      set display table(entry) to part of second string starting at
3356: 2cdc: \***                                  ((entry - 1) * length of entry) + 1, for
3357: 2cdc: \***                                  length of entry
3358: 2cdc: \***
3359: 2cdc: \***   NEXT entry
3360: 2cdc: \***
3361: 2cdc: \***   DIMension F14.TABLE$ to 0
3362: 2cdc: \***   set first string to null
3363: 2cdc: \***   set second string to null
3364: 2cdc: \***
3365: 2cdc: \***   set total entries to display count
3366: 2cdc: \***
3367: 2cdc: \***   IF remainder of (total entries divided by 26) is not 0 THEN
3368: 2cdc: \***      set total pages to (total entries divided by 26) plus 1
3369: 2cdc: \***   ELSE
3370: 2cdc: \***      set total pages to total entries divided by 26
3371: 2cdc: \***   endif
3372: 2cdc: \***
3373: 2cdc: \***   set current page to 1
3374: 2cdc: \***
3375: 2cdc: \***   GOSUB SHOW.PAGE
3376: 2cdc: \***
3377: 2cdc: \***   RETURN
3378: 2cdc: \***
3379: 2cdc: \...............................................................................
3380: 2cdc: 
3381: 2cdc: !     Lines deleted                                                  ! 1.20 RC
3382: 2cdc:       DIM F14.TABLE$(0)
3383: 2d0b: !     Lines deleted                                                  ! 1.20 RC
3384: 2d0b: 
3385: 2d0b:       TOTAL.ENTRIES% = DISPLAY.COUNT%
3386: 2d20: 
3387: 2d20:       IF MOD (TOTAL.ENTRIES%,26) <> 0 THEN                             \
3388: 2d41:          TOTAL.PAGES% = (TOTAL.ENTRIES% / 26) + 1                     :\
3389: 2d67:       ELSE                                                             \
3390: 2d6f:          TOTAL.PAGES% = (TOTAL.ENTRIES% / 26)
3391: 2d88: 
3392: 2d88:       CURRENT.PAGE% = 1
3393: 2d96: 
3394: 2d96:       GOSUB SHOW.PAGE
3395: 2da8: 
3396: 2da8:    RETURN
3397: 2db8: 
3398: 2db8: 
3399: 2db8: \*****************************************************************************
3400: 2db8: \***   DISPLAY.BEMF.MSG.265
3401: 2db8: \*****************************************************************************
3402: 2db8: 
3403: 2db8: DISPLAY.BEMF.MSG.265: ! Code extracted into separate procedure       ! 1.20 RC
3404: 2dc8: 
3405: 2dc8:     MESSAGE.NO% = 265
3406: 2dd6:     RETURN.FIELD% = F03.RETURNED.INTEGER%
3407: 2de8:     VARIABLE.STRING$ = ""
3408: 2dfd:     
3409: 2dfd:     RC% EQ EXTERNAL.MESSAGE (MESSAGE.NO%, \
3410: 2e24:                              VARIABLE.STRING$, \
3411: 2e24:                              RETURN.FIELD%)
3412: 2e24:     
3413: 2e24:     IF RC% NE 0 THEN GOTO CHAIN.OUT
3414: 2e39: 
3415: 2e39: RETURN
3416: 2e49: 
3417: 2e49: 
3418: 2e49: \*****************************************************************************
3419: 2e49: \***   CREATE.PPFO
3420: 2e49: \*****************************************************************************
3421: 2e49: 
3422: 2e49:    CREATE.PPFO:                                                         !DSJW
3423: 2e59: 
3424: 2e59:       CURRENT.SESS.NUM% = PPFO.SESS.NUM%                                !DSJW
3425: 2e6b:       IF END # PPFO.SESS.NUM% THEN CREATE.ERROR                         !DSJW
3426: 2e87:       CREATE POSFILE PPFO.FILE.NAME$ AS PPFO.SESS.NUM% \                !DSJW
3427: 2eb2:              BUFFSIZE PPFO.BUFF.SIZE% LOCKED MIRRORED ATCLOSE           !DSJW
3428: 2eb2:       PPFO.THERE.FLAG$ = "Y"                                            !DSJW
3429: 2ec7: 
3430: 2ec7:    RETURN                                                               !DSJW
3431: 2ed7: 
3432: 2ed7: \***************************************************************************
3433: 2ed7: \***
3434: 2ed7: \***   PROCESS.ENTRY:
3435: 2ed7: \***
3436: 2ed7: \***   set effect flag off
3437: 2ed7: \***   IF count of entries is 0 THEN
3438: 2ed7: \***      set move cursor flag off
3439: 2ed7: \***      RETURN
3440: 2ed7: \***   endif
3441: 2ed7: \***
3442: 2ed7: \***   IF F03.RETURNED.STRING$ is not blank or increase/decrease flag THEN
3443: 2ed7: \***      set string data to spaces
3444: 2ed7: \***      set integer data to 0 (current field)
3445: 2ed7: \***      CALL DM.POSF function to retrieve the number of the current field
3446: 2ed7: \***      IF F03.RETURN.CODE% <> 0 THEN
3447: 2ed7: \***         GOTO CHAIN.OUT
3448: 2ed7: \***      ELSE
3449: 2ed7: \***         CALL EXTERNAL.MESSAGE function to display message number 061,
3450: 2ed7: \***                                           return to current field
3451: 2ed7: \***         IF F04.RETURN.CODE% <> 0 THEN
3452: 2ed7: \***            GOTO CHAIN.OUT
3453: 2ed7: \***         ELSE
3454: 2ed7: \***            set move cursor flag off
3455: 2ed7: \***            RETURN
3456: 2ed7: \***         endif
3457: 2ed7: \***      endif
3458: 2ed7: \***   endif
3459: 2ed7: \***
3460: 2ed7: \***   set display table(display entry) to F03.RETURNED.STRING$
3461: 2ed7: \***
3462: 2ed7: \...............................................................................
3463: 2ed7: 
3464: 2ed7:    PROCESS.ENTRY:
3465: 2ee7: 
3466: 2ee7:       EFFECT.FLAG$ = "N"
3467: 2efc: 
3468: 2efc:       IF ENTRY.COUNT% = 0 THEN                                         \
3469: 2f17:          MOVE.CURSOR$ = "N"                                           :\
3470: 2f2c:          RETURN
3471: 2f3c: 
3472: 2f3c:       IF F03.RETURNED.STRING$ <> " " AND                               \
3473: 2f95:          F03.RETURNED.STRING$ <> INC.DEC$ THEN                         \
3474: 2f95:          \ 26 lines deleted from here !!!!!                            ! BMW
3475: 2f95:          STRING.DATA$ = ""                                            :\
3476: 2faa:          INTEGER.DATA% = 0                                            :\
3477: 2fb8:          RC% EQ DM.POSF (STRING.DATA$,INTEGER.DATA%)                  :\DSJW
3478: 2fdb:          IF RC% NE 0 THEN                                              \DSJW
3479: 2fed:             GOTO CHAIN.OUT                                            :\
3480: 2ffb:          ELSE                                                          \
3481: 2ffb:             RETURN.FIELD% = F03.RETURNED.INTEGER%                     :\
3482: 300d:             MESSAGE.NO% = 61                                          :\
3483: 301b:             VARIABLE.STRING$ = ""                                     :\
3484: 3030:             RC% EQ EXTERNAL.MESSAGE (MESSAGE.NO%,VARIABLE.STRING$,     \DSJW
3485: 3057:                                      RETURN.FIELD%)                   :\DSJW
3486: 3057:             IF RC% NE 0 THEN                                           \DSJW
3487: 3069:                GOTO CHAIN.OUT                                         :\
3488: 3076:             ELSE                                                       \
3489: 3076:                MOVE.CURSOR$ = "N"                                     :\
3490: 308b:                RETURN
3491: 309b: 
3492: 309b:       DISPLAY.TABLE$ (DISPLAY.ENTRY%) =                                \
3493: 30f1:                      LEFT$(DISPLAY.TABLE$ (DISPLAY.ENTRY%),8) +        \
3494: 30f1:                      F03.RETURNED.STRING$
3495: 30f1: 
3496: 30f1: \...............................................................................
3497: 30f1: \***
3498: 30f1: \***   IF key pressed is F3
3499: 30f1: \***      IF f3 pressed flag is on THEN
3500: 30f1: \***         set quit flag on
3501: 30f1: \***         RETURN
3502: 30f1: \***      ELSE
3503: 30f1: \***         GOSUB QUIT.KEY.PRESSED
3504: 30f1: \***         RETURN
3505: 30f1: \***      endif
3506: 30f1: \***
3507: 30f1: \***   set f3 pressed flag off
3508: 30f1: \***
3509: 30f1: \***   IF key pressed is Home THEN
3510: 30f1: \***      set nextf parameter to -20 (first input field)
3511: 30f1: \***      set current entry to 1
3512: 30f1: \***      set display entry to ((current page - 1) * 26) + current entry
3513: 30f1: \***      set move cursor flag on
3514: 30f1: \***      RETURN
3515: 30f1: \***   endif
3516: 30f1: \***
3517: 30f1: \***   IF key pressed is End THEN
3518: 30f1: \***      set current entry to number on page
3519: 30f1: \***      set display entry to ((current page - 1) * 26) + current entry
3520: 30f1: \***      set string data to spaces
3521: 30f1: \***      set integer data to last input field number
3522: 30f1: \***      CALL DM.POSF function to position the cursor accordingly
3523: 30f1: \***      IF F03.RETURN.CODE% <> 0 THEN
3524: 30f1: \***         GOTO CHAIN.OUT
3525: 30f1: \***      ELSE
3526: 30f1: \***         set move cursor flag off
3527: 30f1: \***         RETURN
3528: 30f1: \***      endif
3529: 30f1: \***   endif
3530: 30f1: \***
3531: 30f1: \...............................................................................
3532: 30f1: 
3533: 30f1:       IF KEY.PRESSED% = QUIT% THEN                                     \
3534: 3102:          IF QUIT.PRESSED$ = "Y" THEN                                   \
3535: 311d:             QUIT.FLAG$ = "Y"                                          :\
3536: 3132:             RETURN                                                    :\
3537: 3144:          ELSE                                                          \
3538: 3144:             GOSUB QUIT.KEY.PRESSED                                    :\
3539: 3156:             RETURN
3540: 3166: 
3541: 3166:       QUIT.PRESSED$ = "N"
3542: 317b: 
3543: 317b:       IF KEY.PRESSED% = HOME% THEN                                     \
3544: 318c:          NEXTF.PARM% = -20                                            :\
3545: 319a:          CURRENT.ENTRY% = 1                                           :\
3546: 31a8:          DISPLAY.ENTRY% = ((CURRENT.PAGE% - 1) * 26) + CURRENT.ENTRY% :\
3547: 31bf:          MOVE.CURSOR$ = "Y"                                           :\
3548: 31d4:          RETURN
3549: 31e4: 
3550: 31e4:       IF KEY.PRESSED% = END.KEY% THEN                                  \
3551: 31f8:          CURRENT.ENTRY% = NUM.ON.PAGE%                                :\
3552: 3206:          DISPLAY.ENTRY% = ((CURRENT.PAGE% - 1) * 26) + CURRENT.ENTRY% :\
3553: 321d:          STRING.DATA$ = ""                                            :\
3554: 3232:          INTEGER.DATA% = LAST.INPUT.FIELD.NO%                         :\
3555: 3240:          RC% EQ DM.POSF (STRING.DATA$,INTEGER.DATA%)                  :\DSJW
3556: 3263:          IF RC% NE 0 THEN                                              \DSJW
3557: 3275:             GOTO CHAIN.OUT                                            :\
3558: 3282:          ELSE                                                          \
3559: 3282:             MOVE.CURSOR$ = "N"                                        :\
3560: 3297:             RETURN
3561: 32a7: 
3562: 32a7: \...............................................................................
3563: 32a7: \***
3564: 32a7: \***   IF key pressed is Tab THEN
3565: 32a7: \***      IF current entry is greater than or equal to number on page THEN
3566: 32a7: \***         set string data to spaces
3567: 32a7: \***         set integer data to 0 (current field)
3568: 32a7: \***         CALL DM.POSF function to retrieve the number of the current field
3569: 32a7: \***         IF F03.RETURN.CODE% <> 0 THEN
3570: 32a7: \***            GOTO CHAIN.OUT
3571: 32a7: \***         ELSE
3572: 32a7: \***            CALL EXTERNAL.MESSAGE function to display message number 001
3573: 32a7: \***                                               return to current field
3574: 32a7: \***            IF F04.RETURN.CODE% <> 0 THEN
3575: 32a7: \***               GOTO CHAIN.OUT
3576: 32a7: \***            ELSE
3577: 32a7: \***               set move cursor flag off
3578: 32a7: \***               RETURN
3579: 32a7: \***            endif
3580: 32a7: \***         endif
3581: 32a7: \***      ELSE
3582: 32a7: \***         IF current entry is 13 THEN
3583: 32a7: \***            set current entry to 14
3584: 32a7: \***            set display entry to ((current page - 1) * 26) + current entry
3585: 32a7: \***            set string data to spaces
3586: 32a7: \***            set integer data to -20 (first input field)
3587: 32a7: \***            CALL DM.NEXTF function to position the cursor accordingly
3588: 32a7: \***            IF F03.RETURN.CODE% <> 0 THEN
3589: 32a7: \***               GOTO CHAIN.OUT
3590: 32a7: \***            ELSE
3591: 32a7: \***               set nextf parameter to 2(next input field)
3592: 32a7: \***               set move cursor flag on
3593: 32a7: \***               RETURN
3594: 32a7: \***            endif
3595: 32a7: \***         ELSE
3596: 32a7: \***            increment current entry by 1
3597: 32a7: \***            set display entry to ((current page - 1) * 26) + current entry
3598: 32a7: \***            set string data to spaces
3599: 32a7: \***            set integer data to 2 (next input field)
3600: 32a7: \***            CALL DM.NEXTF function to position the cursor accordingly
3601: 32a7: \***            IF F03.RETURN.CODE% <> 0 THEN
3602: 32a7: \***               GOTO CHAIN.OUT
3603: 32a7: \***            ELSE
3604: 32a7: \***               set nextf parameter to 2 (next input field)
3605: 32a7: \***               set move cursor flag on
3606: 32a7: \***               RETURN
3607: 32a7: \***         endif
3608: 32a7: \***      endif
3609: 32a7: \***   endif
3610: 32a7: \***
3611: 32a7: \...............................................................................
3612: 32a7: 
3613: 32a7:       IF KEY.PRESSED% = TAB% THEN                                      \
3614: 32bb:          IF CURRENT.ENTRY% >= NUM.ON.PAGE% THEN                        \
3615: 32cf:             STRING.DATA$ = ""                                         :\
3616: 32e4:             INTEGER.DATA% = 0                                         :\
3617: 32f2:             RC% EQ DM.POSF (STRING.DATA$,INTEGER.DATA%)               :\DSJW
3618: 3315:             IF RC% NE 0 THEN                                           \DSJW
3619: 3327:                GOTO CHAIN.OUT                                         :\
3620: 3335:             ELSE                                                       \
3621: 3335:                VARIABLE.STRING$ = ""                                  :\
3622: 334a:                MESSAGE.NO% = 1                                        :\
3623: 3358:                RETURN.FIELD% = F03.RETURNED.INTEGER%                  :\
3624: 336a:                RC% EQ EXTERNAL.MESSAGE (MESSAGE.NO%,                   \DSJW
3625: 3391:                                         VARIABLE.STRING$,              \DSJW
3626: 3391:                                         RETURN.FIELD%)                :\DSJW
3627: 3391:                IF RC% NE 0 THEN                                        \DSJW
3628: 33a3:                   GOTO CHAIN.OUT                                      :\
3629: 33b0:                ELSE                                                    \
3630: 33b0:                   MOVE.CURSOR$ = "N"                                  :\
3631: 33c5:                   RETURN                                              :\
3632: 33d5:          ELSE                                                          \
3633: 33e0:             IF CURRENT.ENTRY% = 13 THEN                                \
3634: 33f2:                CURRENT.ENTRY% = 14                                    :\
3635: 3400:                DISPLAY.ENTRY% = ((CURRENT.PAGE% - 1) * 26) +           \
3636: 3417:                                 CURRENT.ENTRY%                        :\
3637: 3417:                STRING.DATA$ = ""                                      :\
3638: 342c:                INTEGER.DATA% = -20                                    :\
3639: 343a:                RC% EQ DM.NEXTF (STRING.DATA$,INTEGER.DATA%)           :\DSJW
3640: 345d:                IF RC% NE 0 THEN                                        \DSJW
3641: 346f:                   GOTO CHAIN.OUT                                      :\
3642: 347c:                ELSE                                                    \
3643: 347c:                   NEXTF.PARM% = 2                                     :\
3644: 348a:                   MOVE.CURSOR$ = "Y"                                  :\
3645: 349f:                   RETURN                                              :\
3646: 34af:             ELSE                                                       \
3647: 34ba:                CURRENT.ENTRY% = CURRENT.ENTRY% + 1                    :\
3648: 34c6:                DISPLAY.ENTRY% = ((CURRENT.PAGE% - 1) * 26) +           \
3649: 34dd:                                 CURRENT.ENTRY%                        :\
3650: 34dd:                STRING.DATA$ = ""                                      :\
3651: 34f2:                INTEGER.DATA% = 2                                      :\
3652: 3500:                RC% EQ DM.NEXTF (STRING.DATA$,INTEGER.DATA%)           :\DSJW
3653: 3523:                IF RC% NE 0 THEN                                        \DSJW
3654: 3535:                   GOTO CHAIN.OUT                                      :\
3655: 3542:                ELSE                                                    \
3656: 3542:                   NEXTF.PARM% = 2                                     :\
3657: 3550:                   MOVE.CURSOR$ = "Y"                                  :\
3658: 3565:                   RETURN
3659: 3575: 
3660: 3575: \...............................................................................
3661: 3575: \***
3662: 3575: \***   IF key pressed is PgUp THEN
3663: 3575: \***      IF current page is 1 THEN
3664: 3575: \***         set string data to spaces
3665: 3575: \***         set integer data to 0 (current field)
3666: 3575: \***         CALL DM.POSF function to retrieve the number of the current field
3667: 3575: \***         IF F03.RETURN.CODE% <> 0 THEN
3668: 3575: \***            GOTO CHAIN.OUT
3669: 3575: \***         ELSE
3670: 3575: \***            CALL EXTERNAL.MESSAGE function to display message number 074,
3671: 3575: \***                                              return to current field
3672: 3575: \***            IF F04.RETURN.CODE% <> 0 THEN
3673: 3575: \***               GOTO CHAIN.OUT
3674: 3575: \***            ELSE
3675: 3575: \***               set move cursor flag off
3676: 3575: \***               RETURN
3677: 3575: \***            endif
3678: 3575: \***         endif
3679: 3575: \***      ELSE
3680: 3575: \***         decrement current page by 1
3681: 3575: \***         GOSUB SHOW.PAGE
3682: 3575: \***         set nextf parameter to -20 (first input field)
3683: 3575: \***         set current entry to 1
3684: 3575: \***         set display entry to ((current page - 1) * 26) + current entry
3685: 3575: \***         set move cursor flag on
3686: 3575: \***         RETURN
3687: 3575: \***      endif
3688: 3575: \***   endif
3689: 3575: \***
3690: 3575: \...............................................................................
3691: 3575: 
3692: 3575:       IF KEY.PRESSED% = PAGE.UP% THEN                                  \
3693: 3589:          IF CURRENT.PAGE% = 1 THEN                                     \
3694: 359b:             STRING.DATA$ = ""                                         :\
3695: 35b0:             INTEGER.DATA% = 0                                         :\
3696: 35be:             RC% EQ DM.POSF(STRING.DATA$,INTEGER.DATA%)                :\DJSW
3697: 35e1:             IF RC% NE 0 THEN                                           \DSJW
3698: 35f3:                GOTO CHAIN.OUT                                         :\
3699: 3601:             ELSE                                                       \
3700: 3601:                VARIABLE.STRING$ = ""                                  :\
3701: 3616:                MESSAGE.NO% = 74                                       :\
3702: 3624:                RETURN.FIELD% = F03.RETURNED.INTEGER%                  :\
3703: 3636:                RC% EQ EXTERNAL.MESSAGE (MESSAGE.NO%,                   \DSJW
3704: 365d:                                         VARIABLE.STRING$,              \DSJW
3705: 365d:                                         RETURN.FIELD%)                :\DSJW
3706: 365d:                IF RC% NE 0 THEN                                        \DSJW
3707: 366f:                   GOTO CHAIN.OUT                                      :\
3708: 367c:                ELSE                                                    \
3709: 367c:                   MOVE.CURSOR$ = "N"                                  :\
3710: 3691:                   RETURN                                              :\
3711: 36a1:          ELSE                                                          \
3712: 36ab:             CURRENT.PAGE% = CURRENT.PAGE% - 1                         :\
3713: 36b7:             GOSUB SHOW.PAGE                                           :\
3714: 36c9:             NEXTF.PARM% = -20                                         :\
3715: 36d7:             CURRENT.ENTRY% = 1                                        :\
3716: 36e5:             DISPLAY.ENTRY% = ((CURRENT.PAGE% - 1) * 26) +              \
3717: 36fc:                              CURRENT.ENTRY%                           :\
3718: 36fc:             MOVE.CURSOR$ = "Y"                                        :\
3719: 3711:             RETURN
3720: 3721: 
3721: 3721: \...............................................................................
3722: 3721: \***
3723: 3721: \***   IF key pressed is PgDn THEN
3724: 3721: \***      IF current page = total pages THEN
3725: 3721: \***         set string data to spaces
3726: 3721: \***         set integer data to 0 (current field)
3727: 3721: \***         CALL DM.POSF function to retrieve the number of the current field
3728: 3721: \***         IF F03.RETURN.CODE% <> 0 THEN
3729: 3721: \***            GOTO CHAIN.OUT
3730: 3721: \***         ELSE
3731: 3721: \***            CALL EXTERNAL.MESSAGE function to display message number 075,
3732: 3721: \***                                              return to current field
3733: 3721: \***            IF F04.RETURN.CODE% <> 0 THEN
3734: 3721: \***               GOTO CHAIN.OUT
3735: 3721: \***            ELSE
3736: 3721: \***               set move cursor flag off
3737: 3721: \***               RETURN
3738: 3721: \***            endif
3739: 3721: \***         endif
3740: 3721: \***      ELSE
3741: 3721: \***         increment current page by 1
3742: 3721: \***         GOSUB SHOW.PAGE
3743: 3721: \***         set nextf parameter to -20 (first input field)
3744: 3721: \***         set current entry to 1
3745: 3721: \***         set display entry to ((current page - 1) * 26) + current entry
3746: 3721: \***         set move cursor flag on
3747: 3721: \***         RETURN
3748: 3721: \***      endif
3749: 3721: \***   endif
3750: 3721: \***
3751: 3721: \...............................................................................
3752: 3721: 
3753: 3721:       IF KEY.PRESSED% = PAGE.DOWN% THEN                                \
3754: 3735:          IF CURRENT.PAGE% = TOTAL.PAGES% THEN                          \
3755: 3750:             STRING.DATA$ = ""                                         :\
3756: 3765:             INTEGER.DATA% = 0                                         :\
3757: 3773:             RC% EQ DM.POSF(STRING.DATA$,INTEGER.DATA%)                :\DJSW
3758: 3796:             IF RC% NE 0 THEN                                           \DSJW
3759: 37a8:                GOTO CHAIN.OUT                                         :\
3760: 37b6:             ELSE                                                       \
3761: 37b6:                VARIABLE.STRING$ = ""                                  :\
3762: 37cb:                MESSAGE.NO% = 75                                       :\
3763: 37d9:                RETURN.FIELD% = F03.RETURNED.INTEGER%                  :\
3764: 37eb:                RC% EQ EXTERNAL.MESSAGE (MESSAGE.NO%,                   \DSJW
3765: 3812:                                         VARIABLE.STRING$,              \DSJW
3766: 3812:                                         RETURN.FIELD%)                :\DSJW
3767: 3812:                IF RC% NE 0 THEN                                        \DSJW
3768: 3824:                   GOTO CHAIN.OUT                                      :\
3769: 3831:                ELSE                                                    \
3770: 3831:                   MOVE.CURSOR$ = "N"                                  :\
3771: 3846:                   RETURN                                              :\
3772: 3856:          ELSE                                                          \
3773: 3860:             CURRENT.PAGE% = CURRENT.PAGE% + 1                         :\
3774: 386c:             GOSUB SHOW.PAGE                                           :\
3775: 387e:             NEXTF.PARM% = -20                                         :\
3776: 388c:             CURRENT.ENTRY% = 1                                        :\
3777: 389a:             DISPLAY.ENTRY% = ((CURRENT.PAGE% - 1) * 26) +              \
3778: 38b1:                              CURRENT.ENTRY%                           :\
3779: 38b1:             MOVE.CURSOR$ = "Y"                                        :\
3780: 38c6:             RETURN
3781: 38d6: 
3782: 38d6: \...............................................................................
3783: 38d6: \***
3784: 38d6: \***   set count to 1
3785: 38d6: \***
3786: 38d6: \***   WHILE count is less than or equal to total entries
3787: 38d6: \***   AND effect flag is off
3788: 38d6: \***
3789: 38d6: \***      IF display table(count) flag is increase/decrease flag THEN
3790: 38d6: \***         set effect flag on
3791: 38d6: \***      endif
3792: 38d6: \***      increment count by 1
3793: 38d6: \***
3794: 38d6: \***   WEND
3795: 38d6: \***
3796: 38d6: \***   IF effect flag is off THEN
3797: 38d6: \***      set string data to spaces
3798: 38d6: \***      set integer data to 0 (current field)
3799: 38d6: \***      CALL DM.POSF function to retrieve the number of the current field
3800: 38d6: \***      IF F03.RETURN.CODE% <> 0 THEN
3801: 38d6: \***         GOTO CHAIN.OUT
3802: 38d6: \***      ELSE
3803: 38d6: \***         CALL EXTERNAL.MESSAGE function to display message number 002
3804: 38d6: \***                                           return to current field
3805: 38d6: \***         IF F04.RETURN.CODE% <> 0 THEN
3806: 38d6: \***            GOTO CHAIN.OUT
3807: 38d6: \***         ELSE
3808: 38d6: \***            set move cursor flag off
3809: 38d6: \***            RETURN
3810: 38d6: \***         endif
3811: 38d6: \***      endif
3812: 38d6: \***   endif
3813: 38d6: \***
3814: 38d6: \***   CALL DM.POSF function to obtain the current field number
3815: 38d6: \***   IF F03.RETURN.CODE% <> 0 THEN
3816: 38d6: \***      GOTO CHAIN.OUT
3817: 38d6: \***   endif
3818: 38d6: \***
3819: 38d6: \***   CALL EXTERNAL.MESSAGE function to display message number 273,
3820: 38d6: \***                                       return to current field
3821: 38d6: \***   IF F04.RETURN.CODE% <> 0 THEN
3822: 38d6: \***      GOTO CHAIN.OUT
3823: 38d6: \***   endif
3824: 38d6: \***
3825: 38d6: \...............................................................................
3826: 38d6: 
3827: 38d6:       INDEX% = 1
3828: 38e4: 
3829: 38e4:       WHILE INDEX% <= TOTAL.ENTRIES%                                   \
3830: 38ee:       AND EFFECT.FLAG$ = "N"
3831: 38ee: 
3832: 38ee:          IF RIGHT$(DISPLAY.TABLE$ (INDEX%), 1) = INC.DEC$ THEN         \
3833: 3930:             EFFECT.FLAG$ = "Y"
3834: 3945: 
3835: 3945:          INDEX% = INDEX% + 1
3836: 3951: 
3837: 3951:       WEND
3838: 39a0: 
3839: 39a0:       IF EFFECT.FLAG$ = "N" THEN                                       \
3840: 39be:          STRING.DATA$ = ""                                            :\
3841: 39d3:          INTEGER.DATA% = 0                                            :\
3842: 39e1:          RC% EQ DM.POSF(STRING.DATA$,INTEGER.DATA%)                   :\DJSW
3843: 3a04:          IF RC% NE 0 THEN                                              \DSJW
3844: 3a16:                GOTO CHAIN.OUT                                         :\
3845: 3a24:          ELSE                                                          \
3846: 3a24:             MESSAGE.NO% = 2                                           :\
3847: 3a32:             RETURN.FIELD% = F03.RETURNED.INTEGER%                     :\
3848: 3a44:             VARIABLE.STRING$ = ""                                     :\
3849: 3a59:             RC% EQ EXTERNAL.MESSAGE (MESSAGE.NO%,                      \DSJW
3850: 3a80:                                      VARIABLE.STRING$,                 \DSJW
3851: 3a80:                                      RETURN.FIELD%)                   :\DSJW
3852: 3a80:             IF RC% NE 0 THEN                                           \DSJW
3853: 3a92:                GOTO CHAIN.OUT                                         :\
3854: 3a9f:             ELSE                                                       \
3855: 3a9f:                MOVE.CURSOR$ = "N"                                     :\
3856: 3ab4:                RETURN
3857: 3ac4: 
3858: 3ac4:       STRING.DATA$ = ""
3859: 3ad9:       INTEGER.DATA% = 107                                              ! BMW
3860: 3ae7: 
3861: 3ae7:       RC% EQ DM.POSF(STRING.DATA$,INTEGER.DATA%)                       !DJSW
3862: 3b0a:       IF RC% NE 0 THEN                                                 \DSJW
3863: 3b1c:           GOTO CHAIN.OUT
3864: 3b27: 
3865: 3b27:       MESSAGE.NO% = 273
3866: 3b35:       VARIABLE.STRING$ = ""
3867: 3b4a:       RETURN.FIELD% = F03.RETURNED.INTEGER%
3868: 3b5c:       RC% EQ EXTERNAL.MESSAGE (MESSAGE.NO%,VARIABLE.STRING$,           \DSJW
3869: 3b83:                                RETURN.FIELD%)                          !DSJW
3870: 3b83:       IF RC% NE 0 THEN                                                 \DSJW
3871: 3b95:          GOTO CHAIN.OUT
3872: 3ba0: 
3873: 3ba0: \...............................................................................
3874: 3ba0: \***
3875: 3ba0: \***   CREATE the ppfo
3876: 3ba0: \***   CLOSE the ppfi
3877: 3ba0: \***   IF END occurs on opening the ppfi THEN OPEN.PPFI.ERROR
3878: 3ba0: \***   OPEN the ppfi LOCKED NOWRITE
3879: 3ba0: \***   set the ppfi record count to 0
3880: 3ba0: \***   set the ppfo record count to 0
3881: 3ba0: \***
3882: 3ba0: \***   IF END occurs on read ppfi THEN READ.PPFI.ERROR
3883: 3ba0: \***   CALL READ.PPFI
3884: 3ba0: \***   increment ppfi record count by 1
3885: 3ba0: \***
3886: 3ba0: \***   WHILE eof flag is off
3887: 3ba0: \***   AND ppfi boots code is not 9999999 (trailer)
3888: 3ba0: \***
3889: 3ba0: \***      IF ppf rec type flag = "R" AND
3890: 3ba0: \***         ppfi increase/decrease flag is increase/decrease flag AND
3891: 3ba0: \***         ppfi status flag is not blank THEN
3892: 3ba0: \***         GOSUB CHECK.FOR.IRF.UPDATE
3893: 3ba0: \***      ELSE
3894: 3ba0: \***         IF END occurs on writing ppfo THEN FILE.ERROR
3895: 3ba0: \***         CALL WRITE.PPFO to write out ppfi record
3896: 3ba0: \***         increment ppfo record count by 1
3897: 3ba0: \***      endif
3898: 3ba0: \***
3899: 3ba0: \***      IF END occurs on read ppfi THEN READ.PPFI.ERROR
3900: 3ba0: \***      CALL READ.PPFI
3901: 3ba0: \***      increment ppfi record count by 1
3902: 3ba0: \***
3903: 3ba0: \***   WEND
3904: 3ba0: \***
3905: 3ba0: \***   IF ppfi trailer error flag = "N" THEN
3906: 3ba0: \***      GOSUB CHECK.PPFI.TRAILER
3907: 3ba0: \***   endif
3908: 3ba0: \***
3909: 3ba0: \***   WRITE trailer record to ppfo
3910: 3ba0: \***
3911: 3ba0: \***   CLOSE ppfo
3912: 3ba0: \***
3913: 3ba0: \***   DELETE ppfi
3914: 3ba0: \***
3915: 3ba0: \***   RENAME ppfo as ppfi
3916: 3ba0: \***   IF rename return code is not -1 THEN
3917: 3ba0: \***      CALL APPLICATION.LOG function to log event 14
3918: 3ba0: \***      GOTO CHAIN.OUT
3919: 3ba0: \***   endif
3920: 3ba0: \***
3921: 3ba0: \***   IF END occurs on open ppfi THEN OPEN.PPFI.ERROR
3922: 3ba0: \***   OPEN ppfi LOCKED NOWRITE
3923: 3ba0: \***
3924: 3ba0: \...............................................................................
3925: 3ba0: 
3926: 3ba0:       GOSUB CREATE.PPFO                                                 !DSJW
3927: 3bb2: 
3928: 3bb2: !     Lines deleted - PPFI close and re-open                           ! 1.19 RC
3929: 3bb2: 
3930: 3bb2:       GOSUB OPEN.ITEM.FILES                                            ! 1.19 RC
3931: 3bc4: 
3932: 3bc4:       PPFI.RECORD.COUNT% = 0
3933: 3bd9:       PPFO.RECORD.COUNT% = 0
3934: 3bee: 
3935: 3bee:       RC% EQ READ.PPFI                                                  !DSJW
3936: 3c02:       IF RC% NE 0 THEN GOTO READ.PPFI.ERROR                             !DSJW
3937: 3c17:       PPFI.RECORD.COUNT% = PPFI.RECORD.COUNT% + 1
3938: 3c30: 
3939: 3c30:       END.OF.FILE$ = "N"
3940: 3c45: 
3941: 3c45:       WHILE END.OF.FILE$ = "N"                                         \
3942: 3c50:       AND PPF.BOOTS.CODE$ <> "9999999"                                 !CSJW
3943: 3c50: 
3944: 3c50:          IF   PPF.REC.TYPE.FLAG$ = "R" \                                !DSJW
3945: 3cce:           AND PPF.INC.DEC.FLAG$ = INC.DEC$ \                            !DSJW
3946: 3cce:           AND PPF.STATUS.FLAG$ <> " " THEN BEGIN                        !DSJW
3947: 3cce:             GOSUB CHECK.FOR.IRF.UPDATE                                  !DSJW
3948: 3ce3:          ENDIF ELSE BEGIN                                               !DSJW
3949: 3ceb:             FAIL.TYPE$ = "W"                                            !DSJW
3950: 3d00:             RC% EQ WRITE.PPFO                                           !DSJW
3951: 3d14: 			PRINT #992 ; "ADDED FROM LINE 2281 " , PPF.RECORD$
3952: 3d3f:             IF RC% NE 0 THEN GOTO FILE.ERROR                            !DSJW
3953: 3d54:             PPFO.RECORD.COUNT% = PPFO.RECORD.COUNT% + 1                 !DSJW
3954: 3d6d:          ENDIF                                                          !DSJW
3955: 3d75: 
3956: 3d75:          RC% EQ READ.PPFI                                               !DSJW
3957: 3d89:          IF RC% NE 0 THEN GOTO READ.PPFI.ERROR                          !DSJW
3958: 3d9e:          PPFI.RECORD.COUNT% = PPFI.RECORD.COUNT% + 1
3959: 3db7: 
3960: 3db7:       WEND
3961: 3e07: 
3962: 3e07:       IF PPFI.TRAILER.ERROR$ = "N" THEN                                \
3963: 3e22:          GOSUB CHECK.PPFI.TRAILER
3964: 3e34: 
3965: 3e34:       PPFO.RECORD.COUNT% = PPFO.RECORD.COUNT% + 1
3966: 3e4d:       PPF.BOOTS.CODE$ = "9999999"                                       !CSJW
3967: 3e64:       PPF.REC.COUNT$ = RIGHT$("00000" + STR$(PPFO.RECORD.COUNT%),5)
3968: 3eac:       FAIL.TYPE$ = "W"                                                  !DSJW
3969: 3ec1:       RC% EQ WRITE.PPFO                                                 !DSJW
3970: 3ed5: 	  PRINT #992 ; "ADDED FROM LINE 2300 " , PPF.RECORD$
3971: 3f00:       IF RC% NE 0 THEN GOTO FILE.ERROR                                  !DSJW
3972: 3f15: 
3973: 3f15:       IF PPFO.THERE.FLAG$ = "Y" THEN                                   \
3974: 3f30:          PPFO.THERE.FLAG$ = "N"                                       :\
3975: 3f45:          CLOSE PPFO.SESS.NUM%
3976: 3f59: 
3977: 3f59:       DELETE PPFI.SESS.NUM%                                             !ESJW
3978: 3f6d: 
3979: 3f6d:       RENAME.RET.CODE% = RENAME (PPFI.FILE.NAME$, PPFO.FILE.NAME$)
3980: 3f93:       IF RENAME.RET.CODE% <> -1 THEN BEGIN
3981: 3fa5:          VAR.STRING.2$ = "PPFO PPFI "
3982: 3fba:          VAR.STRING.1$ = "PPFO"
3983: 3fcf:          MESSAGE.NO% = 554
3984: 3fdd:          EVENT.NO% = 14
3985: 3fea:          IF PSBCHN.APP = "PSB51" THEN                                  \
3986: 4008:             PSBCHN.U2 = PSBCHN.U2 + "554" + VAR.STRING.2$             :\
3987: 4035:             BATCH.SCREEN.FLAG$ = "B"
3988: 404c:          RC% EQ APPLICATION.LOG (MESSAGE.NO%,VAR.STRING.1$,            \DSJW
3989: 407c:                                  VAR.STRING.2$,EVENT.NO%)              !DSJW
3990: 407c:          BATCH.SCREEN.FLAG$ = "S"
3991: 4093:          GOTO CHAIN.OUT
3992: 409e:          ENDIF
3993: 40a6: 
3994: 40a6:       GOSUB CLOSE.ITEM.FILES                                           ! 1.19 RC
3995: 40b8: 
3996: 40b8: !     Lines deleted - PPFI related                                     ! 1.19 RC
3997: 40b8: 
3998: 40b8: 
3999: 40b8: \...............................................................................
4000: 40b8: \***
4001: 40b8: \***   DIMension second table to size of display table
4002: 40b8: \***
4003: 40b8: \***   set count to 0
4004: 40b8: \***
4005: 40b8: \***   FOR entry from 1 to total entries
4006: 40b8: \***
4007: 40b8: \***      IF display table(entry) flag is blank THEN
4008: 40b8: \***         increment count by 1
4009: 40b8: \***         set second table(count) to display table(entry)
4010: 40b8: \***      endif
4011: 40b8: \***
4012: 40b8: \***   NEXT entry
4013: 40b8: \***
4014: 40b8: \***   DIMension display table to count entries
4015: 40b8: \***
4016: 40b8: \***   FOR entry from 1 to count
4017: 40b8: \***
4018: 40b8: \***      set display table(entry) to second table(entry)
4019: 40b8: \***
4020: 40b8: \***   NEXT entry
4021: 40b8: \***
4022: 40b8: \***   DIMension second table to 0
4023: 40b8: \***
4024: 40b8: \***   set total entries to count
4025: 40b8: \***
4026: 40b8: \***   IF remainder of (total entries divided by 26) is not 0 THEN
4027: 40b8: \***      set total pages to (total entries divided by 26) plus 1
4028: 40b8: \***   ELSE
4029: 40b8: \***      set total pages to total entries divided by 26
4030: 40b8: \***   endif
4031: 40b8: \***
4032: 40b8: \***   IF total pages is 0 THEN
4033: 40b8: \***      set total pages to 1
4034: 40b8: \***      set count of entries to 0
4035: 40b8: \***   endif
4036: 40b8: \***
4037: 40b8: \***   set current page to 1
4038: 40b8: \***
4039: 40b8: \***   GOSUB SHOW.PAGE
4040: 40b8: \***
4041: 40b8: \***   CALL DM.POSF function to obtain the current field number
4042: 40b8: \***   IF F03.RETURN.CODE% <> 0 THEN
4043: 40b8: \***      GOTO CHAIN.OUT
4044: 40b8: \***   endif
4045: 40b8: \***
4046: 40b8: \***   CALL EXTERNAL.MESSAGE function to display message number 274,
4047: 40b8: \***                                       return to current field
4048: 40b8: \***   IF F04.RETURN.CODE% <> 0 THEN
4049: 40b8: \***      GOTO CHAIN.OUT
4050: 40b8: \***   endif
4051: 40b8: \***
4052: 40b8: \***   set move cursor flag on
4053: 40b8: \***   IF entry count = 0 THEN
4054: 40b8: \***      set nextf parm to 20
4055: 40b8: \***      set zero entry flag to "Y"
4056: 40b8: \***   endif
4057: 40b8: \***
4058: 40b8: \***   RETURN
4059: 40b8: \***
4060: 40b8: \...............................................................................
4061: 40b8: 
4062: 40b8:       DIM DISP.2.TABLE$ (DISPLAY.COUNT%)
4063: 40e7: 
4064: 40e7:       COUNT% = 0
4065: 40fc: 
4066: 40fc:       FOR INDEX% = 1 TO TOTAL.ENTRIES%
4067: 410d: 
4068: 410d:          IF RIGHT$(DISPLAY.TABLE$ (INDEX%), 1) = " " THEN              \
4069: 414b:             COUNT% = COUNT% + 1                                       :\
4070: 4164:             DISP.2.TABLE$ (COUNT%) = DISPLAY.TABLE$ (INDEX%)
4071: 419c: 
4072: 419c:       NEXT INDEX%
4073: 41bb: 
4074: 41bb:       DIM DISPLAY.TABLE$ (COUNT%)
4075: 41ea: 
4076: 41ea:       FOR INDEX% = 1 TO COUNT%
4077: 41fa: 
4078: 41fa:           DISPLAY.TABLE$ (INDEX%) = DISP.2.TABLE$ (INDEX%)
4079: 422e: 
4080: 422e:       NEXT INDEX%
4081: 424a: 
4082: 424a:       DIM DISP.2.TABLE$ (0)
4083: 4273: 
4084: 4273:       TOTAL.ENTRIES% = COUNT%
4085: 4288: 
4086: 4288:       IF MOD (TOTAL.ENTRIES%, 26) <> 0 THEN                            \
4087: 42a9:          TOTAL.PAGES% = (TOTAL.ENTRIES% / 26) + 1                     :\
4088: 42cf:       ELSE                                                             \
4089: 42d7:          TOTAL.PAGES% = TOTAL.ENTRIES% / 26
4090: 42f0: 
4091: 42f0:       IF TOTAL.PAGES% = 0 THEN                                         \
4092: 430b:          TOTAL.PAGES% = 1                                             :\
4093: 4320:          ENTRY.COUNT% = 0
4094: 4335: 
4095: 4335:       CURRENT.PAGE% = 1
4096: 4343: 
4097: 4343:       GOSUB SHOW.PAGE
4098: 4355: 
4099: 4355:       STRING.DATA$ = ""
4100: 436a:       INTEGER.DATA% = 0
4101: 4378:       RC% EQ DM.POSF(STRING.DATA$,INTEGER.DATA%)                        !DJSW
4102: 439b:       IF RC% NE 0 THEN                                                  \DSJW
4103: 43ad:          GOTO CHAIN.OUT
4104: 43b8: 
4105: 43b8:       RETURN.FIELD% = F03.RETURNED.INTEGER%
4106: 43ca:       MESSAGE.NO% = 274
4107: 43d8:       VARIABLE.STRING$ = ""
4108: 43ed:       RC% EQ EXTERNAL.MESSAGE (MESSAGE.NO%,VARIABLE.STRING$,            \DSJW
4109: 4414:                                RETURN.FIELD%)                           !DSJW
4110: 4414:       IF RC% NE 0 THEN GOTO CHAIN.OUT                                   !DSJW
4111: 4429: 
4112: 4429:       MOVE.CURSOR$ = "Y"
4113: 443e:       IF ENTRY.COUNT% = 0 THEN                                         \
4114: 4459:          NEXTF.PARM% = 20                                             :\
4115: 4467:          ZERO.ENTRY.FLAG$ = "Y"
4116: 447c: 
4117: 447c:    DECREASE.PERFORMED.$ = "N"
4118: 4491: 
4119: 4491:    RETURN
4120: 44a1: 
4121: 44a1: \*******************************************************************************
4122: 44a1: \***
4123: 44a1: \***   AUTO.EFFECT.DECREASES:
4124: 44a1: \***
4125: 44a1: \***   IF  not called from store opening  THEN
4126: 44a1: \***       CALL EXTERNAL.MESSAGE to display message number 275,
4127: 44a1: \***                             returning to field number 2
4128: 44a1: \***
4129: 44a1: \***   CREATE the ppfo
4130: 44a1: \***   CLOSE the ppfi
4131: 44a1: \***   IF END occurs on opening the ppfi THEN OPEN.PPFI.ERROR
4132: 44a1: \***   OPEN the ppfi LOCKED NOWRITE
4133: 44a1: \***   set the ppfi record count to 0
4134: 44a1: \***   set the ppfo record count to 0
4135: 44a1: \***
4136: 44a1: \***   IF END occurs on read ppfi THEN READ.PPFI.ERROR
4137: 44a1: \***   CALL READ.PPFI
4138: 44a1: \***   increment ppfi record count by 1
4139: 44a1: \***
4140: 44a1: \***   WHILE eof flag is off
4141: 44a1: \***   AND ppfi boots code is not 9999999 (trailer)
4142: 44a1: \***
4143: 44a1: \***      IF ppf rec type flag = "R" AND
4144: 44a1: \***         ppfi increase/decrease flag is increase/decrease flag AND
4145: 44a1: \***         ppfi status flag is not blank THEN
4146: 44a1: \***         GOSUB UPDATE.IRF
4147: 44a1: \***      ELSE
4148: 44a1: \***         IF END occurs on writing ppfo THEN FILE.ERROR
4149: 44a1: \***         CALL WRITE.PPFO to write out ppfi record
4150: 44a1: \***         increment ppfo record count by 1
4151: 44a1: \***      endif
4152: 44a1: \***
4153: 44a1: \***      IF END occurs on read ppfi THEN READ.PPFI.ERROR
4154: 44a1: \***      CALL READ.PPFI
4155: 44a1: \***      increment ppfi record count by 1
4156: 44a1: \***
4157: 44a1: \***   WEND
4158: 44a1: \***
4159: 44a1: \***   GOSUB CHECK.PPFI.TRAILER
4160: 44a1: \***
4161: 44a1: \***   WRITE trailer record to ppfo
4162: 44a1: \***
4163: 44a1: \***   CLOSE ppfo
4164: 44a1: \***
4165: 44a1: \***   DELETE ppfi
4166: 44a1: \***
4167: 44a1: \***   RENAME ppfo as ppfi
4168: 44a1: \***   IF rename return code is not -1 THEN
4169: 44a1: \***      CALL APPLICATION.LOG function to log event 14
4170: 44a1: \***      GOTO CHAIN.OUT
4171: 44a1: \***   endif
4172: 44a1: \***
4173: 44a1: \***   CALL EXTERNAL.MESSAGE function to display message number 276
4174: 44a1: \***                         returning to field number 2
4175: 44a1: \***   IF F04.RETURN.CODE% <> 0 THEN
4176: 44a1: \***      GOTO CHAIN.OUT
4177: 44a1: \***   endif
4178: 44a1: \***
4179: 44a1: \***   set key pressed to 999
4180: 44a1: \***
4181: 44a1: \***   RETURN
4182: 44a1: \***
4183: 44a1: \***
4184: 44a1: \*******************************************************************************
4185: 44a1: 
4186: 44a1:    AUTO.EFFECT.DECREASES:
4187: 44b1: 
4188: 44b1:       IF PSBCHN.APP <> "PSB51" THEN BEGIN                               !DSJW
4189: 44cf:          VARIABLE.STRING$ = ""                                          !DSJW
4190: 44e4:          MESSAGE.NO% = 275    ! RPD price decreases are being effected  !DSJW
4191: 44f2:          RETURN.FIELD% = 2                                              !DSJW
4192: 4500:          RC% EQ EXTERNAL.MESSAGE (MESSAGE.NO%,VARIABLE.STRING$,         \DSJW
4193: 4527:                                   RETURN.FIELD%)                        !DSJW
4194: 4527:          IF RC% NE 0 THEN GOTO CHAIN.OUT                                !DSJW
4195: 453c:       ENDIF                                                             !DSJW
4196: 4544: 
4197: 4544:       GOSUB CREATE.PPFO                                                 !DSJW
4198: 4556: 
4199: 4556: !     Lines deleted - PPFI close and re-open                           ! 1.19 RC
4200: 4556: 
4201: 4556:       GOSUB OPEN.ITEM.FILES                                            ! 1.19 RC
4202: 4568: 
4203: 4568:       PPFI.RECORD.COUNT% = 0
4204: 457d:       PPFO.RECORD.COUNT% = 0
4205: 4592: 
4206: 4592:       RC% EQ READ.PPFI                                                  !DSJW
4207: 45a6:       IF RC% NE 0 THEN GOTO READ.PPFI.ERROR                             !DSJW
4208: 45bb:       PPFI.RECORD.COUNT% = PPFI.RECORD.COUNT% + 1
4209: 45d4: 
4210: 45d4:       END.OF.FILE$ = "N"
4211: 45e9: 
4212: 45e9:       WHILE END.OF.FILE$ = "N"                                         \
4213: 45f4:       AND PPF.BOOTS.CODE$ <> "9999999"                                 !CSJW
4214: 45f4: 
4215: 45f4:          IF  PPF.REC.TYPE.FLAG$ = "R" \                                 !DSJW
4216: 4672:          AND PPF.INC.DEC.FLAG$ = INC.DEC$ \                             !DSJW
4217: 4672:          AND PPF.STATUS.FLAG$ <> " " THEN BEGIN                         !DSJW
4218: 4672:              GOSUB UPDATE.IRF                                           !DSJW
4219: 4687:          ENDIF ELSE BEGIN                                               !DSJW
4220: 468f:              FAIL.TYPE$ = "W"                                           !DSJW
4221: 46a4:              RC% EQ WRITE.PPFO                                          !DSJW
4222: 46b8: 			 PRINT #992 ; "ADDED FROM LINE 2552 " , PPF.RECORD$
4223: 46e3:              IF RC% NE 0 THEN GOTO FILE.ERROR                           !DSJW
4224: 46f8:              PPFO.RECORD.COUNT% = PPFO.RECORD.COUNT% + 1                !DSJW
4225: 4711:          ENDIF                                                          !DSJW
4226: 4719: 
4227: 4719:        RC% EQ READ.PPFI                                                 !DSJW
4228: 472d:        IF RC% NE 0 THEN GOTO READ.PPFI.ERROR                            !DSJW
4229: 4742:        PPFI.RECORD.COUNT% = PPFI.RECORD.COUNT% + 1
4230: 475b: 
4231: 475b:       WEND
4232: 47ab: 
4233: 47ab:       GOSUB CHECK.PPFI.TRAILER
4234: 47bd: 
4235: 47bd:       PPFO.RECORD.COUNT% = PPFO.RECORD.COUNT% + 1
4236: 47d6:       PPF.BOOTS.CODE$ = "9999999"                                       !CSJW
4237: 47ed:       PPF.REC.COUNT$ = RIGHT$("00000" + STR$(PPFO.RECORD.COUNT%),5)
4238: 4835:       FAIL.TYPE$ = "W"                                                  !DSJW
4239: 484a:       RC% EQ WRITE.PPFO                                                 !DSJW
4240: 485e: 	  PRINT #992 ; "ADDED FROM LINE 2570 " , PPF.RECORD$
4241: 4889:       IF RC% NE 0 THEN GOTO FILE.ERROR                                  !DSJW
4242: 489e: 
4243: 489e:       IF PPFO.THERE.FLAG$ = "Y" THEN                                   \
4244: 48b9:          PPFO.THERE.FLAG$ = "N"                                       :\
4245: 48ce:          CLOSE PPFO.SESS.NUM%
4246: 48e2: 
4247: 48e2:       DELETE PPFI.SESS.NUM%                                             !ESJW
4248: 48f6: !     PPFI.OPEN.FLAG$ = "N"                                             !BMW ! 1.19 RC
4249: 48f6: 
4250: 48f6:       RENAME.RET.CODE% = RENAME (PPFI.FILE.NAME$, PPFO.FILE.NAME$)
4251: 491c:       IF RENAME.RET.CODE% <> -1 THEN BEGIN
4252: 492e:          VAR.STRING.2$ = "PPFO PPFI "
4253: 4943:          VAR.STRING.1$ = "PPFO"
4254: 4958:          MESSAGE.NO% = 554
4255: 4966:          EVENT.NO% = 14
4256: 4973:          IF PSBCHN.APP = "PSB51"  THEN                                 \
4257: 4991:             PSBCHN.U2 = PSBCHN.U2 + "554" + VAR.STRING.2$             :\
4258: 49be:             BATCH.SCREEN.FLAG$ = "B"
4259: 49d5:          RC% EQ APPLICATION.LOG (MESSAGE.NO%,VAR.STRING.1$,             \DSJW
4260: 4a05:                                  VAR.STRING.2$,EVENT.NO%)               !DSJW
4261: 4a05:          BATCH.SCREEN.FLAG$ = "S"
4262: 4a1c:          GOTO CHAIN.OUT
4263: 4a27:          ENDIF
4264: 4a2f: 
4265: 4a2f:       ! 52 lines deleted from here!!!!!
4266: 4a2f: 
4267: 4a2f:       GOSUB CLOSE.ITEM.FILES                                           ! 1.19 RC
4268: 4a41: 
4269: 4a41:       KEY.PRESSED% = 999
4270: 4a4f:       DECREASES.RUN.ALREADY.FLAG$ = "Y"
4271: 4a64:       DECREASE.PERFORMED.$ = "Y"
4272: 4a79: 
4273: 4a79:       RETURN
4274: 4a89: 
4275: 4a89: 
4276: 4a89: \*******************************************************************************
4277: 4a89: \***
4278: 4a89: \***   QUIT.KEY.PRESSED:
4279: 4a89: \***
4280: 4a89: \***   set effect flag off
4281: 4a89: \***   WHILE effect flag is off
4282: 4a89: \***   AND entry is less than or equal to total entries
4283: 4a89: \***
4284: 4a89: \***      IF display table(entry)flag is increase/decrease flag THEN
4285: 4a89: \***         set effect flag on
4286: 4a89: \***      endif
4287: 4a89: \***
4288: 4a89: \***   WEND
4289: 4a89: \***   IF effect flag is off THEN
4290: 4a89: \***      set quit flag on
4291: 4a89: \***   ELSE
4292: 4a89: \***      set string data to spaces
4293: 4a89: \***      set integer data to 0
4294: 4a89: \***      CALL DM.POSF function to obtain current field number
4295: 4a89: \***      IF F03.RETURN.CODE% <> 0 THEN
4296: 4a89: \***         GOTO CHAIN.OUT
4297: 4a89: \***      ELSE
4298: 4a89: \***         CALL EXTERNAL.MESSAGE function to display message 253
4299: 4a89: \***                                            return to current field
4300: 4a89: \***         IF F04.RETURN.CODE% <> 0 THEN
4301: 4a89: \***            GOTO CHAIN.OUT
4302: 4a89: \***         ELSE
4303: 4a89: \***            set f3 pressed flag on
4304: 4a89: \***            set move cursor flag off
4305: 4a89: \***         endif
4306: 4a89: \***      endif
4307: 4a89: \***   endif
4308: 4a89: \***
4309: 4a89: \...............................................................................
4310: 4a89: 
4311: 4a89:    QUIT.KEY.PRESSED:
4312: 4a99: 
4313: 4a99:       EFFECT.FLAG$ = "N"
4314: 4aae:       INDEX% = 1
4315: 4abc: 
4316: 4abc:       WHILE EFFECT.FLAG$ = "N" AND TOTAL.ENTRIES% > INDEX%
4317: 4ac6: 
4318: 4ac6:          IF RIGHT$(DISPLAY.TABLE$ (INDEX%),1) = INC.DEC$ THEN          \
4319: 4b08:             EFFECT.FLAG$ = "Y"
4320: 4b1d: 
4321: 4b1d:          INDEX% = INDEX% + 1
4322: 4b29: 
4323: 4b29:       WEND
4324: 4b6b: 
4325: 4b6b:       IF EFFECT.FLAG$ = "N" THEN                                       \
4326: 4b86:          QUIT.FLAG$ = "Y"                                             :\
4327: 4b9e:       ELSE                                                             \
4328: 4ba6:          STRING.DATA$ = ""                                            :\
4329: 4bbb:          INTEGER.DATA% = 0                                            :\
4330: 4bc9:          RC% EQ DM.POSF(STRING.DATA$,INTEGER.DATA%)                   :\DJSW
4331: 4bec:          IF RC% NE 0 THEN                                              \DSJW
4332: 4bfe:             GOTO CHAIN.OUT                                            :\
4333: 4c0c:          ELSE                                                          \
4334: 4c14:             CURRENT.FIELD% = F03.RETURNED.INTEGER%                    :\
4335: 4c26:             VARIABLE.STRING$ = ""                                     :\
4336: 4c3b:             MESSAGE.NO% = 253                                         :\
4337: 4c49:             RETURN.FIELD% = CURRENT.FIELD%                            :\
4338: 4c57:             RC% EQ EXTERNAL.MESSAGE (MESSAGE.NO%,                      \DSJW
4339: 4c7e:                                      VARIABLE.STRING$,                 \DSJW
4340: 4c7e:                                      RETURN.FIELD%)                   :\DSJW
4341: 4c7e:             IF RC% NE 0 THEN                                           \DSJW
4342: 4c90:                GOTO CHAIN.OUT                                         :\
4343: 4c9d:             ELSE                                                       \
4344: 4ca5:                MOVE.CURSOR$ = "N"                                     :\
4345: 4cba:                QUIT.PRESSED$ = "Y"
4346: 4ccf: 
4347: 4ccf:    RETURN
4348: 4cdf: 
4349: 4cdf: \*******************************************************************************
4350: 4cdf: \***
4351: 4cdf: \***   HELP.ON.7203:
4352: 4cdf: \***
4353: 4cdf: \***   save current flag to F03.RETURNED.STRING$
4354: 4cdf: \***
4355: 4cdf: \***   set string data to spaces
4356: 4cdf: \***   set integer data to 0
4357: 4cdf: \***   CALL DM.POSF function to return the number of the current field
4358: 4cdf: \***   IF F03.RETURN.CODE% <> 0 THEN
4359: 4cdf: \***      GOTO CHAIN.OUT
4360: 4cdf: \***   endif
4361: 4cdf: \***
4362: 4cdf: \***   set string data to spaces
4363: 4cdf: \***   set integer data to 1
4364: 4cdf: \***   CALL DM.POSF function to position the cursor in field 01
4365: 4cdf: \***   IF F03.RETURN.CODE% <> 0 THEN
4366: 4cdf: \***      GOTO CHAIN.OUT
4367: 4cdf: \***   endif
4368: 4cdf: \***
4369: 4cdf: \***   set string data to spaces
4370: 4cdf: \***   set integer data to 0
4371: 4cdf: \***   CALL DM.UPDF function to get message
4372: 4cdf: \***   IF F03.RETURN.CODE% <> 0 THEN
4373: 4cdf: \***      GOTO CHAIN.OUT
4374: 4cdf: \***   endif
4375: 4cdf: \***
4376: 4cdf: \***   CALL HELP function
4377: 4cdf: \***   IF F12.RETURN.CODE% <> 0 THEN
4378: 4cdf: \***      GOTO CHAIN.OUT
4379: 4cdf: \***   endif
4380: 4cdf: \***
4381: 4cdf: \***   GOSUB SHOW.PAGE
4382: 4cdf: \***
4383: 4cdf: \***   set string data to spaces
4384: 4cdf: \***   set integer data to 1
4385: 4cdf: \***   CALL DM.POSF function to position the cursor in field 01
4386: 4cdf: \***   IF F03.RETURN.CODE% <> 0 THEN
4387: 4cdf: \***      GOTO CHAIN.OUT
4388: 4cdf: \***   endif
4389: 4cdf: \***
4390: 4cdf: \***   set string data to message
4391: 4cdf: \***   set integer data to 0
4392: 4cdf: \***   CALL DM.PUTF function to place message in field 01
4393: 4cdf: \***   IF F03.RETURN.CODE% <> 0 THEN
4394: 4cdf: \***      GOTO CHAIN.OUT
4395: 4cdf: \***   endif
4396: 4cdf: \***
4397: 4cdf: \***   set string data to spaces
4398: 4cdf: \***   set integer data to current field
4399: 4cdf: \***   CALL DM.POSF function to position the cursor in the current field
4400: 4cdf: \***   IF F03.RETURN.CODE% <> 0 THEN
4401: 4cdf: \***      GOTO CHAIN.OUT
4402: 4cdf: \***   endif
4403: 4cdf: \***
4404: 4cdf: \***   set string data to current flag
4405: 4cdf: \***   set integer data to 0
4406: 4cdf: \***   CALL DM.PUTF function to place current flag in current field
4407: 4cdf: \***   IF F03.RETURN.CODE% <> 0 THEN
4408: 4cdf: \***      GOTO CHAIN.OUT
4409: 4cdf: \***   endif
4410: 4cdf: \***
4411: 4cdf: \***   set move cursor flag off
4412: 4cdf: \***
4413: 4cdf: \***   RETURN
4414: 4cdf: \***
4415: 4cdf: \...............................................................................
4416: 4cdf: 
4417: 4cdf:    HELP.ON.7203:
4418: 4cef: 
4419: 4cef:       SAVED.DISP.FLAG$ = F03.RETURNED.STRING$
4420: 4d0b: 
4421: 4d0b:       STRING.DATA$ = ""
4422: 4d20:       INTEGER.DATA% = 0
4423: 4d2e:       RC% EQ DM.POSF(STRING.DATA$,INTEGER.DATA%)                        !DJSW
4424: 4d51:       IF RC% NE 0 THEN GOTO CHAIN.OUT                                   !DSJW
4425: 4d66:       CURRENT.FIELD% = F03.RETURNED.INTEGER%
4426: 4d78: 
4427: 4d78:       STRING.DATA$ = ""
4428: 4d8d:       INTEGER.DATA% = 1
4429: 4d9b:       RC% EQ DM.POSF(STRING.DATA$,INTEGER.DATA%)                        !DJSW
4430: 4dbe:       IF RC% NE 0 THEN GOTO CHAIN.OUT                                   !DSJW
4431: 4dd3: 
4432: 4dd3:       STRING.DATA$ = ""
4433: 4de8:       INTEGER.DATA% = 0
4434: 4df6:       RC% EQ DM.UPDF(STRING.DATA$,INTEGER.DATA%)                        !DJSW
4435: 4e19:       IF RC% NE 0 THEN GOTO CHAIN.OUT                                   !DSJW
4436: 4e2e:       SAVED.DISP.MESSAGE$ = F03.RETURNED.STRING$
4437: 4e4a: 
4438: 4e4a:       RC% EQ HELP(B7203.SCREEN.NO$)                                     !DJSW
4439: 4e69:       IF RC% NE 0 THEN GOTO CHAIN.OUT                                   !DSJW
4440: 4e7e: 
4441: 4e7e:       GOSUB SHOW.PAGE
4442: 4e90: 
4443: 4e90:       STRING.DATA$ = ""
4444: 4ea5:       INTEGER.DATA% = 1
4445: 4eb3:       RC% EQ DM.POSF(STRING.DATA$,INTEGER.DATA%)                        !DJSW
4446: 4ed6:       IF RC% NE 0 THEN GOTO CHAIN.OUT                                   !DSJW
4447: 4eeb: 
4448: 4eeb:       STRING.DATA$ = SAVED.DISP.MESSAGE$
4449: 4f04:       INTEGER.DATA% = 0
4450: 4f12:       RC% EQ DM.PUTF(STRING.DATA$,INTEGER.DATA%)                        !DJSW
4451: 4f35:       IF RC% NE 0 THEN GOTO CHAIN.OUT                                   !DSJW
4452: 4f4a: 
4453: 4f4a:       STRING.DATA$ = ""
4454: 4f5f:       INTEGER.DATA% = CURRENT.FIELD%
4455: 4f6d:       RC% EQ DM.POSF(STRING.DATA$,INTEGER.DATA%)                        !DJSW
4456: 4f90:       IF RC% NE 0 THEN GOTO CHAIN.OUT                                   !DSJW
4457: 4fa5: 
4458: 4fa5:       STRING.DATA$ = SAVED.DISP.FLAG$
4459: 4fbe:       INTEGER.DATA% = 0
4460: 4fcc:       RC% EQ DM.PUTF(STRING.DATA$,INTEGER.DATA%)                        !DJSW
4461: 4fef:       IF RC% NE 0 THEN GOTO CHAIN.OUT                                   !DSJW
4462: 5004: 
4463: 5004:       MOVE.CURSOR$ = "N"
4464: 5019: 
4465: 5019:    RETURN
4466: 5029: 
4467: 5029: \*******************************************************************************
4468: 5029: \***
4469: 5029: \***   OPEN.PPFI.ERROR:
4470: 5029: \***
4471: 5029: \***   set fail type to "O"
4472: 5029: \***   set current session number to ppfi session number
4473: 5029: \***   set key to null
4474: 5029: \***
4475: 5029: \***   GOSUB FILE.ERROR
4476: 5029: \***
4477: 5029: \***   GOTO CHAIN.OUT
4478: 5029: \***
4479: 5029: \...............................................................................
4480: 5029: 
4481: 5029:    OPEN.PPFI.ERROR:
4482: 5039: 
4483: 5039:       FAIL.TYPE$ = "O"
4484: 504e:       CURRENT.SESS.NUM% = PPFI.SESS.NUM%
4485: 5060:       CURRENT.KEY$ = ""
4486: 5075: 
4487: 5075:       GOSUB FILE.ERROR
4488: 5087: 
4489: 5087:       GOTO CHAIN.OUT
4490: 5092: 
4491: 5092: \*******************************************************************************
4492: 5092: \***
4493: 5092: \***   READ.PPFI.ERROR:
4494: 5092: \***
4495: 5092: \***   set fail type to "R"
4496: 5092: \***   set current session number to ppfi session number
4497: 5092: \***   set key to null
4498: 5092: \***
4499: 5092: \***   GOSUB FILE.ERROR
4500: 5092: \***
4501: 5092: \***   GOTO CHAIN.OUT
4502: 5092: \***
4503: 5092: \...............................................................................
4504: 5092: 
4505: 5092:    READ.PPFI.ERROR:
4506: 50a2: 
4507: 50a2:       FAIL.TYPE$ = "R"
4508: 50b7:       CURRENT.SESS.NUM% = PPFI.SESS.NUM%
4509: 50c9:       CURRENT.KEY$ = ""
4510: 50de: 
4511: 50de:       GOSUB FILE.ERROR
4512: 50f0: 
4513: 50f0:       GOTO CHAIN.OUT
4514: 50fb: 
4515: 50fb: \*******************************************************************************
4516: 50fb: \***
4517: 50fb: \***   NO.ENTRIES.MESSAGE:
4518: 50fb: \***
4519: 50fb: \***   IF increase/decrease flag is "D" THEN
4520: 50fb: \***      set string data to spaces
4521: 50fb: \***      set integer data to 0 (current field)
4522: 50fb: \***      CALL DM.POSF function to retrieve the current field
4523: 50fb: \***      IF F03.RETURN.CODE% <> 0 THEN
4524: 50fb: \***         GOTO CHAIN.OUT
4525: 50fb: \***      ELSE
4526: 50fb: \***         CALL EXTERNAL.MESSAGE function to display message number 272,
4527: 50fb: \***                                           return to current field
4528: 50fb: \***         IF F04.RETURN.CODE% <> 0 THEN
4529: 50fb: \***            GOTO CHAIN.OUT
4530: 50fb: \***         ELSE
4531: 50fb: \***            RETURN
4532: 50fb: \***         endif
4533: 50fb: \***      endif
4534: 50fb: \***   ELSE
4535: 50fb: \***      set string data to spaces
4536: 50fb: \***      set integer data to 0 (current field)
4537: 50fb: \***      CALL DM.POSF function to retrieve the current field
4538: 50fb: \***      IF F03.RETURN.CODE% <> 0 THEN
4539: 50fb: \***         GOTO CHAIN.OUT
4540: 50fb: \***      ELSE
4541: 50fb: \***         CALL EXTERNAL.MESSAGE function to display message number 271,
4542: 50fb: \***                                           return to current field
4543: 50fb: \***         IF F04.RETURN.CODE% <> 0 THEN
4544: 50fb: \***            GOTO CHAIN.OUT
4545: 50fb: \***         ELSE
4546: 50fb: \***            RETURN
4547: 50fb: \***         endif
4548: 50fb: \***      endif
4549: 50fb: \***   endif
4550: 50fb: \***
4551: 50fb: \***   RETURN
4552: 50fb: \***
4553: 50fb: \...............................................................................
4554: 50fb: 
4555: 50fb:    NO.ENTRIES.MESSAGE:
4556: 510b: 
4557: 510b:       IF INC.DEC$ = "D" THEN BEGIN                                     !DSJW
4558: 5129:          STRING.DATA$ = ""                                             !DSJW
4559: 513e:          INTEGER.DATA% = 0                                             !DSJW
4560: 514c:          RC% EQ DM.POSF(STRING.DATA$,INTEGER.DATA%)                    !DSJW
4561: 516f:          IF RC% NE 0 THEN GOTO CHAIN.OUT                              :\DSJW
4562: 5187:          ELSE                                                          \
4563: 518f:             MESSAGE.NO% = 272                                         :\
4564: 519d:             RETURN.FIELD% = F03.RETURNED.INTEGER%                     :\
4565: 51af:             VARIABLE.STRING$ = ""                                     :\
4566: 51c4:             RC% EQ EXTERNAL.MESSAGE (MESSAGE.NO%,                      \DSJW
4567: 51eb:                                      VARIABLE.STRING$,                 \DSJW
4568: 51eb:                                      RETURN.FIELD%)                   :\DSJW
4569: 51eb:             IF RC% NE 0 THEN                                           \DSJW
4570: 51fd:                GOTO CHAIN.OUT
4571: 520b:       ENDIF ELSE BEGIN                                                 !DSJW
4572: 5213:          STRING.DATA$ = ""                                             !DSJW
4573: 5228:          INTEGER.DATA% = 0                                             !DSJW
4574: 5236:          RC% EQ DM.POSF(STRING.DATA$,INTEGER.DATA%)                    !DSJW
4575: 5259:          IF RC% NE 0 THEN                                              \DSJW
4576: 526b:             GOTO CHAIN.OUT                                            :\
4577: 5279:          ELSE                                                          \
4578: 5281:             MESSAGE.NO% = 271                                         :\
4579: 528f:             RETURN.FIELD% = F03.RETURNED.INTEGER%                     :\
4580: 52a1:             VARIABLE.STRING$ = ""                                     :\
4581: 52b6:             RC% EQ EXTERNAL.MESSAGE (MESSAGE.NO%,                      \DSJW
4582: 52dd:                                      VARIABLE.STRING$,                 \DSJW
4583: 52dd:                                      RETURN.FIELD%)                   :\DSJW
4584: 52dd:             IF RC% NE 0 THEN                                           \DSJW
4585: 52ef:                GOTO CHAIN.OUT
4586: 52fa:        ENDIF
4587: 5302: 
4588: 5302:    RETURN
4589: 5312: 
4590: 5312: \*******************************************************************************
4591: 5312: \***
4592: 5312: \***   SHOW.PAGE:
4593: 5312: \***
4594: 5312: \***   IF increase/decrease flag is "D" THEN
4595: 5312: \***      set string data to "B7202"
4596: 5312: \***   ELSE
4597: 5312: \***      set string data to "B7203"
4598: 5312: \***   endif
4599: 5312: \***
4600: 5312: \***   set integer data to 0
4601: 5312: \***   CALL DM.DISPD function to display the required screen
4602: 5312: \***   IF F03.RETURN.CODE% <> 0 THEN
4603: 5312: \***      GOTO CHAIN.OUT
4604: 5312: \***   endif
4605: 5312: \***
4606: 5312: \***   set string data to spaces
4607: 5312: \***   set integer data to -30 (first output field)
4608: 5312: \***   CALL DM.NEXTF function to position the cursor accordingly
4609: 5312: \***   IF F03.RETURN.CODE% <> 0 THEN
4610: 5312: \***      GOTO CHAIN.OUT
4611: 5312: \***   endif
4612: 5312: \***
4613: 5312: \***   set string data to current page
4614: 5312: \***   set integer data to 0
4615: 5312: \***   CALL DM.PUTF function to put current page in the field
4616: 5312: \***   IF F03.RETURN.CODE% <> 0 THEN
4617: 5312: \***      GOTO CHAIN.OUT
4618: 5312: \***   endif
4619: 5312: \***
4620: 5312: \***   set string data to spaces
4621: 5312: \***   set integer data to 3 (next output field)
4622: 5312: \***   CALL DM.NEXTF function to position the cursor accordingly
4623: 5312: \***   IF F03.RETURN.CODE% <> 0 THEN
4624: 5312: \***      GOTO CHAIN.OUT
4625: 5312: \***   endif
4626: 5312: \***
4627: 5312: \***   set string data to total pages
4628: 5312: \***   set integer data to 0
4629: 5312: \***   CALL DM.PUTF function to put total pages in the field
4630: 5312: \***   IF F03.RETURN.CODE% <> 0 THEN
4631: 5312: \***      GOTO CHAIN.OUT
4632: 5312: \***   endif
4633: 5312: \***
4634: 5312: \***   set string data to spaces
4635: 5312: \***   set integer data to 3 (next output field)
4636: 5312: \***   CALL DM.NEXTF function to position the cursor accordingly
4637: 5312: \***   IF F03.RETURN.CODE% <> 0 THEN
4638: 5312: \***      GOTO CHAIN.OUT
4639: 5312: \***   endif
4640: 5312: \***
4641: 5312: \...............................................................................
4642: 5312: 
4643: 5312:    SHOW.PAGE:
4644: 5322: 
4645: 5322:       IF INC.DEC$ = "D" THEN                                           \
4646: 533d:          STRING.DATA$ = "B7202"                                       :\
4647: 5354:       ELSE                                                             \
4648: 535c:          STRING.DATA$ = "B7203"
4649: 5371: 
4650: 5371:       INTEGER.DATA% = 0
4651: 537f:       RC% EQ DM.DISPD(STRING.DATA$,INTEGER.DATA%)                       !DJSW
4652: 53a2:       IF RC% NE 0 THEN GOTO CHAIN.OUT                                   !DSJW
4653: 53b7: 
4654: 53b7:       STRING.DATA$ = ""
4655: 53cc:       INTEGER.DATA% = -30
4656: 53da:       RC% EQ DM.NEXTF(STRING.DATA$,INTEGER.DATA%)                       !DJSW
4657: 53fd:       IF RC% NE 0 THEN GOTO CHAIN.OUT                                   !DSJW
4658: 5412: 
4659: 5412:       STRING.DATA$ = STR$ (CURRENT.PAGE%)
4660: 542e:       INTEGER.DATA% = 0
4661: 543c:       RC% EQ DM.PUTF(STRING.DATA$,INTEGER.DATA%)                        !DJSW
4662: 545f:       IF RC% NE 0 THEN GOTO CHAIN.OUT                                   !DSJW
4663: 5474: 
4664: 5474:       STRING.DATA$ = ""
4665: 5489:       INTEGER.DATA% = 3
4666: 5497:       RC% EQ DM.NEXTF(STRING.DATA$,INTEGER.DATA%)                       !DJSW
4667: 54ba:       IF RC% NE 0 THEN GOTO CHAIN.OUT                                   !DSJW
4668: 54cf: 
4669: 54cf:       STRING.DATA$ = STR$ (TOTAL.PAGES%)
4670: 54ed:       INTEGER.DATA% = 0
4671: 54fb:       RC% EQ DM.PUTF(STRING.DATA$,INTEGER.DATA%)                        !DJSW
4672: 551e:       IF RC% NE 0 THEN GOTO CHAIN.OUT                                   !DSJW
4673: 5533: 
4674: 5533:       STRING.DATA$ = ""
4675: 5548:       INTEGER.DATA% = 3
4676: 5556:       RC% EQ DM.NEXTF(STRING.DATA$,INTEGER.DATA%)                       !DJSW
4677: 5579:       IF RC% NE 0 THEN GOTO CHAIN.OUT                                   !DSJW
4678: 558e: 
4679: 558e: \...............................................................................
4680: 558e: \***
4681: 558e: \***   set current entry to 1
4682: 558e: \***
4683: 558e: \***   WHILE current entry is less than 27
4684: 558e: \***   AND ((current page - 1) * 26) + current entry is <= total entries
4685: 558e: \***
4686: 558e: \***      IF current entry is 14 THEN
4687: 558e: \***         set string data to spaces
4688: 558e: \***         set integer data to -20 (first input field)
4689: 558e: \***         CALL DM.NEXTF function to position the cursor accordingly
4690: 558e: \***         IF F03.RETURN.CODE% <> 0 THEN
4691: 558e: \***            GOTO CHAIN.OUT
4692: 558e: \***         ELSE
4693: 558e: \***            set string data to spaces
4694: 558e: \***            set integer data to 3 (next output field)
4695: 558e: \***            CALL DM.NEXTF function to position the cursor accordingly
4696: 558e: \***            IF F03.RETURN.CODE% <> 0 THEN
4697: 558e: \***               GOTO CHAIN.OUT
4698: 558e: \***            endif
4699: 558e: \***         endif
4700: 558e: \***      ELSE
4701: 558e: \***         IF current entry > 1 THEN
4702: 558e: \***            GOSUB MOVE.NEXT.LINE
4703: 558e: \***         endif
4704: 558e: \***      endif
4705: 558e: \***
4706: 558e: \***      set display entry to ((current page -1) * 26) + current entry
4707: 558e: \***
4708: 558e: \***      IF display table(display entry) rpd number is 0
4709: 558e: \***      AND display table(display entry) rpd date is 000000 THEN
4710: 558e: \***         set string data to 99999
4711: 558e: \***      ELSE
4712: 558e: \***         set string data to display table(display entry) rpd number
4713: 558e: \***      endif
4714: 558e: \***
4715: 558e: \***      set integer data to 0
4716: 558e: \***      CALL DM.PUTF function to put the rpd number in the field
4717: 558e: \***      IF F03.RETURN.CODE% <> 0 THEN
4718: 558e: \***         GOTO CHAIN.OUT
4719: 558e: \***      endif
4720: 558e: \***
4721: 558e: \***      set string data to spaces
4722: 558e: \***      set integer data to 3 (next output field)
4723: 558e: \***      CALL DM.NEXTF function to position the cursor accordingly
4724: 558e: \***      IF F03.RETURN.CODE% <> 0 THEN
4725: 558e: \***         GOTO CHAIN.OUT
4726: 558e: \***      endif
4727: 558e: \***
4728: 558e: \***      set string data to display table(display entry) lines
4729: 558e: \***      set integer data to 0
4730: 558e: \***      CALL DM.PUTF function to put lines in the field
4731: 558e: \***      IF F03.RETURN.CODE% <> 0 THEN
4732: 558e: \***         GOTO CHAIN.OUT
4733: 558e: \***      endif
4734: 558e: \***
4735: 558e: \***      set string data to spaces
4736: 558e: \***      set integer data to 3 (next output field)
4737: 558e: \***      CALL DM.NEXTF function to position the cursor accordingly
4738: 558e: \***      IF F03.RETURN.CODE% <> 0 THEN
4739: 558e: \***         GOTO CHAIN.OUT
4740: 558e: \***      endif
4741: 558e: \***
4742: 558e: \***      IF display table(display entry) date is 0 THEN
4743: 558e: \***         set string data to current date (DDMMYY)
4744: 558e: \***      ELSE
4745: 558e: \***         set string data to display table(display entry) date (DDMMYY)
4746: 558e: \***      endif
4747: 558e: \***
4748: 558e: \***      set integer data to 0
4749: 558e: \***      CALL DM.PUTF function to put date in the field
4750: 558e: \***      IF F03.RETURN.CODE% <> 0 THEN
4751: 558e: \***         GOTO CHAIN.OUT
4752: 558e: \***      endif
4753: 558e: \***
4754: 558e: \***      set string data to spaces
4755: 558e: \***      set integer data to 2 (next input field)
4756: 558e: \***      CALL DM.NEXTF function to position the cursor accordingly
4757: 558e: \***      IF F03.RETURN.CODE% <> 0 THEN
4758: 558e: \***         GOTO CHAIN.OUT
4759: 558e: \***      endif
4760: 558e: \***
4761: 558e: \***      set string data to the increase decrease flag in the table
4762: 558e: \***      set integer data to 0
4763: 558e: \***      CALL DM.PUTF function to put flag in the field
4764: 558e: \***      IF F03.RETURN.CODE% <> 0 THEN
4765: 558e: \***         GOTO CHAIN.OUT
4766: 558e: \***      endif
4767: 558e: \***
4768: 558e: \***      increment current entry by 1
4769: 558e: \***
4770: 558e: \***   WEND
4771: 558e: \***
4772: 558e: \...............................................................................
4773: 558e: 
4774: 558e:       CURRENT.ENTRY% = 1
4775: 559c: 
4776: 559c:       WHILE CURRENT.ENTRY% < 27                                        \
4777: 55a7:       AND ((CURRENT.PAGE% - 1) * 26) + CURRENT.ENTRY% <= TOTAL.ENTRIES%
4778: 55a7: 
4779: 55a7:          IF CURRENT.ENTRY% = 14 THEN                                   \
4780: 55b9:             STRING.DATA$ = ""                                         :\
4781: 55ce:             INTEGER.DATA% = -20                                       :\
4782: 55dc:             RC% EQ DM.NEXTF(STRING.DATA$,INTEGER.DATA%)               :\DJSW
4783: 55ff:             IF RC% NE 0 THEN GOTO CHAIN.OUT                           :\DSJW
4784: 5616:             ELSE                                                       \
4785: 5616:                STRING.DATA$ = ""                                      :\
4786: 562b:                INTEGER.DATA% = 3                                      :\
4787: 5639:                RC% EQ DM.NEXTF(STRING.DATA$,INTEGER.DATA%)            :\DJSW
4788: 565c:                IF RC% NE 0 THEN GOTO CHAIN.OUT                        :\DSJW
4789: 5673:                ELSE                                                    \
4790: 5673:          ELSE                                                          \
4791: 567d:             IF CURRENT.ENTRY% > 1 THEN                                 \
4792: 568c:                GOSUB MOVE.NEXT.LINE
4793: 569e: 
4794: 569e:          DISPLAY.ENTRY% = ((CURRENT.PAGE% - 1) * 26) + CURRENT.ENTRY%
4795: 56b5: 
4796: 56b5:          RPD.NUMBER% = VAL(UNPACK$(MID$(DISPLAY.TABLE$                 \
4797: 56f6:                            (DISPLAY.ENTRY%),4,3)))
4798: 56f6:          TABLE.DATE$ = UNPACK$(LEFT$ (DISPLAY.TABLE$                   \
4799: 572b:                                (DISPLAY.ENTRY%), 3))
4800: 572b:          IF RPD.NUMBER% = 0                                            \
4801: 5771:          AND TABLE.DATE$ = "000000" THEN                               \
4802: 5771:             STRING.DATA$ = "99999"                                    :\
4803: 5788:          ELSE                                                          \
4804: 5790:             STRING.DATA$ = STR$ (RPD.NUMBER%)
4805: 57ae: 
4806: 57ae:          INTEGER.DATA% = 0
4807: 57bc:          RC% EQ DM.PUTF(STRING.DATA$,INTEGER.DATA%)                     !DJSW
4808: 57df:          IF RC% NE 0 THEN GOTO CHAIN.OUT                                !DSJW
4809: 57f4: 
4810: 57f4:          STRING.DATA$ = ""
4811: 5809:          INTEGER.DATA% = 3
4812: 5817:          RC% EQ DM.NEXTF(STRING.DATA$,INTEGER.DATA%)                    !DJSW
4813: 583a:          IF RC% NE 0 THEN GOTO CHAIN.OUT                                !DSJW
4814: 584f: 
4815: 584f:          STRING.DATA$ = UNPACK$(MID$ (DISPLAY.TABLE$ (DISPLAY.ENTRY%), 7, 2))
4816: 5884:          INTEGER.DATA% = 0
4817: 5892:          RC% EQ DM.PUTF(STRING.DATA$,INTEGER.DATA%)                     !DJSW
4818: 58b5:          IF RC% NE 0 THEN GOTO CHAIN.OUT                                !DSJW
4819: 58ca: 
4820: 58ca:          STRING.DATA$ = ""
4821: 58df:          INTEGER.DATA% = 3
4822: 58ed:          RC% EQ DM.NEXTF(STRING.DATA$,INTEGER.DATA%)                    !DJSW
4823: 5910:          IF RC% NE 0 THEN GOTO CHAIN.OUT                                !DSJW
4824: 5925: 
4825: 5925:          IF TABLE.DATE$ = "000000" THEN                                \
4826: 5943:             STRING.DATA$ = RIGHT$ (DATE$, 2) + "/"                     \
4827: 59c0:                          + MID$ (DATE$, 3, 2) + "/"                    \
4828: 59c0:                          + LEFT$ (DATE$, 2)                           :\
4829: 59c0:          ELSE                                                          \
4830: 59c8:             STRING.DATA$ = RIGHT$ (TABLE.DATE$, 2) + "/"               \
4831: 5a2b:                          + MID$ (TABLE.DATE$, 3, 2) + "/"              \
4832: 5a2b:                          + LEFT$ (TABLE.DATE$, 2)
4833: 5a33: 
4834: 5a33:          INTEGER.DATA% = 0
4835: 5a41:          RC% EQ DM.PUTF(STRING.DATA$,INTEGER.DATA%)                     !DJSW
4836: 5a64:          IF RC% NE 0 THEN GOTO CHAIN.OUT                                !DSJW
4837: 5a79: 
4838: 5a79:          STRING.DATA$ = ""
4839: 5a8e:          INTEGER.DATA% = 2
4840: 5a9c:          RC% EQ DM.NEXTF(STRING.DATA$,INTEGER.DATA%)                    !DJSW
4841: 5abf:          IF RC% NE 0 THEN GOTO CHAIN.OUT                                !DSJW
4842: 5ad4: 
4843: 5ad4:          STRING.DATA$ = RIGHT$(DISPLAY.TABLE$ (DISPLAY.ENTRY%), 1)
4844: 5b02:          INTEGER.DATA% = 0
4845: 5b10:          RC% EQ DM.PUTF(STRING.DATA$,INTEGER.DATA%)                     !DJSW
4846: 5b33:          IF RC% NE 0 THEN GOTO CHAIN.OUT                                !DSJW
4847: 5b48: 
4848: 5b48:          CURRENT.ENTRY% = CURRENT.ENTRY% + 1
4849: 5b54: 
4850: 5b54:       WEND
4851: 5b98: 
4852: 5b98: \...............................................................................
4853: 5b98: \***
4854: 5b98: \***   set string data to spaces
4855: 5b98: \***   set integer data to 0
4856: 5b98: \***   CALL DM.POSF function to obtain the value of last input field number
4857: 5b98: \***   IF F03.RETURN.CODE% <> 0 THEN
4858: 5b98: \***      GOTO CHAIN.OUT
4859: 5b98: \***   endif
4860: 5b98: \***
4861: 5b98: \***   set number on page to current entry - 1
4862: 5b98: \***   set nextf parameter to -20 (first input field)
4863: 5b98: \***   set current entry to 1
4864: 5b98: \***   set display entry to ((current page - 1) * 26) + current entry
4865: 5b98: \***
4866: 5b98: \***   RETURN
4867: 5b98: \***
4868: 5b98: \...............................................................................
4869: 5b98: 
4870: 5b98:       STRING.DATA$ = ""
4871: 5bad:       INTEGER.DATA% = 0
4872: 5bbb:       RC% EQ DM.POSF(STRING.DATA$,INTEGER.DATA%)                        !DJSW
4873: 5bde:       IF RC% NE 0 THEN GOTO CHAIN.OUT                                   !DSJW
4874: 5bf3:       LAST.INPUT.FIELD.NO% = F03.RETURNED.INTEGER%
4875: 5c05: 
4876: 5c05:       NUM.ON.PAGE% = CURRENT.ENTRY% - 1
4877: 5c14:       NEXTF.PARM% = -20
4878: 5c22:       CURRENT.ENTRY% = 1
4879: 5c30:       DISPLAY.ENTRY% = ((CURRENT.ENTRY% - 1) * 26) + CURRENT.ENTRY%
4880: 5c47: 
4881: 5c47: ! NEW CODE
4882: 5c47:       IF CURRENT.PAGE% = 1 \             ! Re-display message 265 on  ! 1.20 RC
4883: 5c6d:         AND MESSAGE.NO% = 265 THEN BEGIN ! entry to selection screee  ! 1.20 RC
4884: 5c6d:           GOSUB DISPLAY.BEMF.MSG.265                                  ! 1.20 RC
4885: 5c7f:           MESSAGE.NO% = 0 ! Prevents redisplay                        ! 1.20 RC
4886: 5c8d:       ENDIF                                                           ! 1.20 RC
4887: 5c95: 
4888: 5c95:    RETURN
4889: 5ca5: 
4890: 5ca5: 
4891: 5ca5: \*******************************************************************************
4892: 5ca5: \***
4893: 5ca5: \***   MOVE.NEXT.LINE:
4894: 5ca5: \***
4895: 5ca5: \***   set string data to spaces
4896: 5ca5: \***   set integer data to 3 (next output field)
4897: 5ca5: \***
4898: 5ca5: \***   FOR count from 1 to 4
4899: 5ca5: \***      CALL DM.NEXTF function to position the cursor accordingly
4900: 5ca5: \***      IF F03.RETURN.CODE% <> 0 THEN
4901: 5ca5: \***         GOTO CHAIN.OUT
4902: 5ca5: \***      endif
4903: 5ca5: \***
4904: 5ca5: \***   NEXT count
4905: 5ca5: \***
4906: 5ca5: \***   RETURN
4907: 5ca5: \***
4908: 5ca5: \...............................................................................
4909: 5ca5: 
4910: 5ca5:    MOVE.NEXT.LINE:
4911: 5cb5: 
4912: 5cb5:       STRING.DATA$ = ""
4913: 5cca:       INTEGER.DATA% = 3
4914: 5cd8: 
4915: 5cd8:       FOR COUNT% = 1 TO 4
4916: 5cef: 
4917: 5cef:          RC% EQ DM.NEXTF(STRING.DATA$,INTEGER.DATA%)                    !DJSW
4918: 5d12:          IF RC% NE 0 THEN GOTO CHAIN.OUT                                !DSJW
4919: 5d27: 
4920: 5d27:       NEXT COUNT%
4921: 5d51: 
4922: 5d51:    RETURN
4923: 5d61: 
4924: 5d61: \*******************************************************************************
4925: 5d61: \***
4926: 5d61: \***   CHECK.FOR.IRF.UPDATE:
4927: 5d61: \***
4928: 5d61: \***   set entry to 1
4929: 5d61: \***   set end loop flag to "N"
4930: 5d61: \***
4931: 5d61: \***   WHILE end loop flag = "N"
4932: 5d61: \***
4933: 5d61: \***      IF entry > total entries THEN
4934: 5d61: \***         set end loop flag to "Y"
4935: 5d61: \***      ELSE
4936: 5d61: \***         IF display table(entry) rpd/date = ppfi rpd/date THEN
4937: 5d61: \***            set end loop flag to "Y"
4938: 5d61: \***         ELSE
4939: 5d61: \***            increment entry by 1
4940: 5d61: \***         endif
4941: 5d61: \***      endif
4942: 5d61: \***
4943: 5d61: \***   WEND
4944: 5d61: \***
4945: 5d61: \***   IF entry greater than  total entries THEN
4946: 5d61: \***      CALL WRITE.PPFO to write out ppfi record
4947: 5d61: \***      increment ppfo record count by 1
4948: 5d61: \***   ELSE
4949: 5d61: \***      IF display table (entry) flag <> increase decrease flag THEN
4950: 5d61: \***         CALL WRITE.PPFO to write out ppfi record
4951: 5d61: \***         increment ppfo record count by 1
4952: 5d61: \***      ELSE
4953: 5d61: \***         GOSUB UPDATE.IRF
4954: 5d61: \***      endif
4955: 5d61: \***   endif
4956: 5d61: \***
4957: 5d61: \***   RETURN
4958: 5d61: \***
4959: 5d61: \...............................................................................
4960: 5d61: 
4961: 5d61:    CHECK.FOR.IRF.UPDATE:
4962: 5d71: 
4963: 5d71:       INDEX% = 1
4964: 5d7f:       END.LOOP$ = "N"
4965: 5d94: 
4966: 5d94:       WHILE END.LOOP$ = "N"
4967: 5d9f: 
4968: 5d9f:          IF INDEX% > TOTAL.ENTRIES% THEN BEGIN                          !DSJW
4969: 5dc0:             END.LOOP$ = "Y"                                             !DSJW
4970: 5dd8:          ENDIF ELSE BEGIN                                               !DSJW
4971: 5de0:             IF LEFT$(DISPLAY.TABLE$(INDEX%),6) = PACK$("000000000000") \!DSJW
4972: 5e59:             AND PPF.RPD.NO$ = "99999" THEN BEGIN                        !DSJW
4973: 5e59:                END.LOOP$ = "Y"                                          !DSJW
4974: 5e71:             ENDIF ELSE BEGIN                                            !DSJW
4975: 5e79:                IF LEFT$(DISPLAY.TABLE$(INDEX%),6) = \                   !DSJW
4976: 5edc:                   PACK$(PPF.DATE.DUE$ + "0" + PPF.RPD.NO$) THEN BEGIN   !DSJW
4977: 5edc:                   END.LOOP$ = "Y"                                       !DSJW
4978: 5ef3:                ENDIF ELSE BEGIN                                         !DSJW
4979: 5efb:                   INDEX% = INDEX% + 1                                   !DSJW
4980: 5f07:                ENDIF                                                    !DSJW
4981: 5f0f:             ENDIF                                                       !DSJW
4982: 5f17:          ENDIF                                                          !DSJW
4983: 5f1f: 
4984: 5f1f:        WEND
4985: 5f3d: 
4986: 5f3d:        IF INDEX% > TOTAL.ENTRIES% THEN BEGIN                            !DSJW
4987: 5f61:           FAIL.TYPE$ = "W"                                              !DSJW
4988: 5f76:           RC% EQ WRITE.PPFO                                             !DSJW
4989: 5f8a: 		  PRINT #992 ; "ADDED FROM LINE 3319" , PPF.RECORD$
4990: 5fb5:           IF RC% NE 0 THEN GOTO FILE.ERROR                              !DSJW
4991: 5fca:           PPFO.RECORD.COUNT% = PPFO.RECORD.COUNT% + 1                   !DSJW
4992: 5fe6:        ENDIF ELSE BEGIN                                                 !DSJW
4993: 5fee:           DISP.TABLE.FLAG$ = RIGHT$(DISPLAY.TABLE$(INDEX%),1)           !DSJW
4994: 601c:           IF DISP.TABLE.FLAG$ <> INC.DEC$ THEN BEGIN                    !DSJW
4995: 603e:              FAIL.TYPE$ = "W"                                           !DSJW
4996: 6053:              RC% EQ WRITE.PPFO                                          !DSJW
4997: 6067: 			 PRINT #992 ; "ADDED FROM LINE 3327 " , PPF.RECORD$
4998: 6092:              IF RC% NE 0 THEN GOTO FILE.ERROR                           !DSJW
4999: 60a7:              PPFO.RECORD.COUNT% = PPFO.RECORD.COUNT% + 1                !DSJW
5000: 60c2:           ENDIF ELSE BEGIN                                              !DSJW
5001: 60ca:              GOSUB UPDATE.IRF                                           !DSJW
5002: 60dc:           ENDIF                                                         !DSJW
5003: 60e4:        ENDIF                                                            !DSJW
5004: 60ec: 
5005: 60ec:    RETURN
5006: 60fc: 
5007: 60fc: \*******************************************************************************
5008: 60fc: \***
5009: 60fc: \***   UPDATE.IRF:
5010: 60fc: \***
5011: 60fc: \***   IF END occurs on read idf THEN READ.IDF.ERROR
5012: 60fc: \***   CALL READ.IDF using ppfi boots code as key
5013: 60fc: \***
5014: 60fc: \***   set group code flag to idf bit flags 1 and group code mask
5015: 60fc: \***
5016: 60fc: \***   set saved idf Boots code to
5017: 60fc: \***     middle six numbers of IDF.BOOTS.CODE$ packed
5018: 60fc: \***
5019: 60fc: \***   IF group code flag is not 0 THEN
5020: 60fc: \***      set bar code front end to "2000000000" packed
5021: 60fc: \***   ELSE
5022: 60fc: \***      set bar code front end to "0000000000" packed
5023: 60fc: \***   endif
5024: 60fc: \***
5025: 60fc: \***   IF idf first ean code = 0 THEN
5026: 60fc: \***      GOSUB ZERO.IDF.BAR.CODE
5027: 60fc: \***      GOTO END.UPDATE.IRF
5028: 60fc: \***   endif
5029: 60fc: \***
5030: 60fc: \***   IF END occurs on read irf THEN READ.IRF.ERROR
5031: 60fc: \***   CALL READ.IRF using bar code front end + idf first ean code as key,
5032: 60fc: \***                 using autolock
5033: 60fc: \***
5034: 60fc: \***   set first ean flag on
5035: 60fc: \***   set match found flag to "N"
5036: 60fc: \***   set update failed flag off
5037: 60fc: \***
5038: 60fc: \***   IF IRF.BOOTS.CODE$ = saved Boots code THEN
5039: 60fc: \***      set match found flag to "Y"
5040: 60fc: \***      GOSUB DO.UPDATE
5041: 60fc: \***   endif
5042: 60fc: \***
5043: 60fc: \***   GOSUB WRITE.IRF.REC
5044: 60fc: \***
5045: 60fc: \***   IF update failed flag is on THEN
5046: 60fc: \***      CALL WRITE.PPFO to write ppfi record
5047: 60fc: \***      increment ppfo record count by 1
5048: 60fc: \***      RETURN
5049: 60fc: \***   endif
5050: 60fc: \***
5051: 60fc: \...............................................................................
5052: 60fc: 
5053: 60fc:    UPDATE.IRF:
5054: 610c: 
5055: 610c:       IDF.BOOTS.CODE$ = PACK$("0" + PPF.BOOTS.CODE$)
5056: 613b:       RC% EQ READ.IDF                                                   !DSJW
5057: 614f:       IF RC% NE 0 THEN GOTO READ.IDF.ERROR                              !DSJW
5058: 6164: 
5059: 6164:       GROUP.CODE.FLAG% = IDF.BIT.FLAGS.1% AND BIT.7.MASK%
5060: 617a: 
5061: 617a:       SAVED.IDF.BOOTS.CODE$ = PACK$(MID$(UNPACK$(IDF.BOOTS.CODE$),2,6))
5062: 61b4: 
5063: 61b4:       IF GROUP.CODE.FLAG% <> 0 THEN                                     \
5064: 61c3:          BAR.CODE.FRONT$ = PACK$ ("2000000000")                        :\
5065: 61df:       ELSE                                                              \
5066: 61e7:          BAR.CODE.FRONT$ = PACK$ ("0000000000")
5067: 6201: 
5068: 6201:       TOTAL.BAR.CODE.COUNT% = VAL(UNPACK$(IDF.NO.OF.BAR.CODES$))
5069: 622e: \ line deleted from here
5070: 622e:       IDF.BAR.CODE$ = UNPACK$ (IDF.FIRST.BAR.CODE$)
5071: 624f:       IF IDF.BAR.CODE$ = "000000000000" THEN                           \
5072: 626a:          GOSUB ZERO.IDF.BAR.CODE                                      :\
5073: 627c:          GOTO END.UPDATE.IRF
5074: 6287: 
5075: 6287:       IRF.BAR.CODE$ = BAR.CODE.FRONT$ + IDF.FIRST.BAR.CODE$
5076: 62b0:       RC% EQ READ.IRF.LOCK                                              !DSJW
5077: 62c4:       IF RC% NE 0 THEN GOTO READ.IRF.ERROR                              !DSJW
5078: 62d9: 
5079: 62d9:       FIRST.EAN$ = "Y"
5080: 62ee:       MATCH.FOUND$ = "N"
5081: 6303:       UPDATE.FAILED$ = "N"
5082: 6318: 
5083: 6318:       IF IRF.BOOTS.CODE$ = SAVED.IDF.BOOTS.CODE$ THEN                  \
5084: 633a:          MATCH.FOUND$ = "Y"                                           :\
5085: 634f:          GOSUB DO.UPDATE
5086: 6361: 
5087: 6361:       GOSUB WRITE.IRF.REC
5088: 6373: 
5089: 6373:       IF UPDATE.FAILED$ = "Y" THEN BEGIN                                !DSJW
5090: 6391:          FAIL.TYPE$ = "W"                                               !DSJW
5091: 63a6:          RC% EQ WRITE.PPFO                                              !DSJW
5092: 63ba: 		 PRINT #992 ; "ADDED FROM LINE 3422 " , PPF.RECORD$
5093: 63e5:          IF RC% NE 0 THEN GOTO FILE.ERROR                               !DSJW
5094: 63fa:          PPFO.RECORD.COUNT% = PPFO.RECORD.COUNT% + 1                    !DSJW
5095: 6413:          RETURN
5096: 6423:       ENDIF                                                             !DSJW
5097: 642b: 
5098: 642b: \...............................................................................
5099: 642b: \***
5100: 642b: \***   set idf group ean code to idf first ean code
5101: 642b: \***   IF group code flag is not 0 THEN
5102: 642b: \***      GOSUB GROUP.CODE.UPDATE
5103: 642b: \***   endif
5104: 642b: \***
5105: 642b: \***   IF idf number of eans is 1 THEN
5106: 642b: \***      IF match found flag is "N" THEN
5107: 642b: \***         GOSUB UNMATCHED.CODE.ERR
5108: 642b: \***         CALL WRITE.PPFO to write ppfi record
5109: 642b: \***         increment ppfo record count by 1
5110: 642b: \***         RETURN
5111: 642b: \***      ELSE
5112: 642b: \***         RETURN
5113: 642b: \***      endif
5114: 642b: \***   endif
5115: 642b: \***
5116: 642b: \***   IF idf second ean code = 0 THEN
5117: 642b: \***      GOSUB ZERO.IDF.BAR.CODE
5118: 642b: \***      GOTO END.UPDATE.IRF
5119: 642b: \***   endif
5120: 642b: \***
5121: 642b: \***   IF IRF.BOOTS.CODE$ = saved Boots code THEN
5122: 642b: \***      set match found flag to "Y"
5123: 642b: \***      GOSUB DO.UPDATE
5124: 642b: \***   endif
5125: 642b: \***
5126: 642b: \***   GOSUB WRITE.IRF.REC
5127: 642b: \***
5128: 642b: \***   set idf group ean code to idf second ean code
5129: 642b: \***   IF group code flag is not 0 THEN
5130: 642b: \***      GOSUB GROUP.CODE.UPDATE
5131: 642b: \***   endif
5132: 642b: \***
5133: 642b: \***   IF idf number of eans is 2 THEN
5134: 642b: \***      IF match found flag is "N" THEN
5135: 642b: \***         GOSUB UNMATCHED.CODE.ERR
5136: 642b: \***         CALL WRITE.PPFO to write ppfi record
5137: 642b: \***         increment ppfo record count by 1
5138: 642b: \***         RETURN
5139: 642b: \***      ELSE
5140: 642b: \***         RETURN
5141: 642b: \***      endif
5142: 642b: \***   endif
5143: 642b: \***
5144: 642b: \***   CALL READ.NEXT.IEF function passing irf bar code
5145: 642b: \***   IF F11.RETURN.CODE% <> 0 THEN
5146: 642b: \***      CALL WRITE.PPFO to write out the ppfi record
5147: 642b: \***      increment ppfo record count by 1
5148: 642b: \***      RETURN
5149: 642b: \***   endif
5150: 642b: \***
5151: 642b: \***   WHILE F11.NEXT.BAR.CODE$ is not "0"
5152: 642b: \***
5153: 642b: \***      IF END occurs on read irf THEN READ.IRF.ERROR
5154: 642b: \***      CALL READ.IRF using F11.NEXT.BAR.CODE$ as key using autolock
5155: 642b: \***
5156: 642b: \***      IF IRF.BOOTS.CODE$ = saved Boots code THEN
5157: 642b: \***         set match found flag to "Y"
5158: 642b: \***         GOSUB DO.UPDATE
5159: 642b: \***      endif
5160: 642b: \***
5161: 642b: \***      GOSUB WRITE.IRF.REC
5162: 642b: \***
5163: 642b: \***      set idf group ean code to F11.NEXT.BAR.CODE$
5164: 642b: \***      IF group code flag is not 0 THEN
5165: 642b: \***         GOSUB GROUP.CODE.UPDATE
5166: 642b: \***      endif
5167: 642b: \***
5168: 642b: \***      CALL READ.NEXT.IEF function
5169: 642b: \***      IF F11.RETURN.CODE% <> 0 THEN
5170: 642b: \***         CALL WRITE.PPFO to write out the ppfi record
5171: 642b: \***         increment ppfo record count by 1
5172: 642b: \***         RETURN
5173: 642b: \***      endif
5174: 642b: \***
5175: 642b: \***   WEND
5176: 642b: \***
5177: 642b: \***   IF match found flag is "N" THEN
5178: 642b: \***      GOSUB UNMATCHED.CODE.ERR
5179: 642b: \***      CALL WRITE.PPFO to write ppfi record
5180: 642b: \***      increment ppfo record count by 1
5181: 642b: \***      RETURN
5182: 642b: \***   endif
5183: 642b: \***
5184: 642b: \***   END.UPDATE.IRF:
5185: 642b: \***
5186: 642b: \***   RETURN
5187: 642b: \***
5188: 642b: \...............................................................................
5189: 642b: 
5190: 642b:       IDF.GROUP.EAN.CODE$ = IDF.FIRST.BAR.CODE$
5191: 6447:       IF GROUP.CODE.FLAG% <> 0 THEN                                    \
5192: 6456:          GOSUB GROUP.CODE.UPDATE
5193: 6468: 
5194: 6468:       IF TOTAL.BAR.CODE.COUNT% = 1 THEN BEGIN                           !DSJW
5195: 6486:          IF MATCH.FOUND$ = "N" THEN BEGIN                               !DSJW
5196: 64a4:             GOSUB UNMATCHED.CODE.ERR                                    !DSJW
5197: 64b6:             FAIL.TYPE$ = "W"                                            !DSJW
5198: 64cb:             RC% EQ WRITE.PPFO                                           !DSJW
5199: 64df: 			PRINT #992 ; "ADDED FROM LINE 3529" , PPF.RECORD$
5200: 650a: 			
5201: 650a:             IF RC% NE 0 THEN GOTO FILE.ERROR                            !DSJW
5202: 651f:             PPFO.RECORD.COUNT% = PPFO.RECORD.COUNT% + 1                 !DSJW
5203: 6538:             RETURN                                                      !DSJW
5204: 654a:          ENDIF ELSE BEGIN                                               !DSJW
5205: 6552:             RETURN                                                      !DSJW
5206: 6562:          ENDIF                                                          !DSJW
5207: 656a:       ENDIF                                                             !DSJW
5208: 6572: 
5209: 6572:       IDF.BAR.CODE$ = UNPACK$ (IDF.SECOND.BAR.CODE$)
5210: 6593:       IF IDF.BAR.CODE$ = "000000000000" THEN                           \
5211: 65ae:          GOSUB ZERO.IDF.BAR.CODE                                      :\
5212: 65c0:          GOTO END.UPDATE.IRF
5213: 65cb: 
5214: 65cb:       IRF.BAR.CODE$ = BAR.CODE.FRONT$ + IDF.SECOND.BAR.CODE$
5215: 65f4:       RC% EQ READ.IRF.LOCK                                              !DSJW
5216: 6608:       IF RC% NE 0 THEN GOTO READ.IRF.ERROR                              !DSJW
5217: 661d: 
5218: 661d: \ line deleted from here
5219: 661d: 
5220: 661d:       IF IRF.BOOTS.CODE$ = SAVED.IDF.BOOTS.CODE$ THEN                  \
5221: 663f:          MATCH.FOUND$ = "Y"                                           :\
5222: 6654:          GOSUB DO.UPDATE
5223: 6666: 
5224: 6666:       GOSUB WRITE.IRF.REC
5225: 6678: 
5226: 6678:       IDF.GROUP.EAN.CODE$ = IDF.SECOND.BAR.CODE$
5227: 6694:       IF GROUP.CODE.FLAG% <> 0 THEN                                    \
5228: 66a3:          GOSUB GROUP.CODE.UPDATE
5229: 66b5: 
5230: 66b5:       IF TOTAL.BAR.CODE.COUNT% = 2 THEN BEGIN                           !DSJW
5231: 66d3:          IF MATCH.FOUND$ = "N" THEN BEGIN                               !DSJW
5232: 66f1:             GOSUB UNMATCHED.CODE.ERR                                    !DSJW
5233: 6703:             FAIL.TYPE$ = "W"                                            !DSJW
5234: 6718:             RC% EQ WRITE.PPFO                                           !DSJW
5235: 672c: 			PRINT #992 ; "ADDED FROM LINE 3565" , PPF.RECORD$
5236: 6757:             IF RC% NE 0 THEN GOTO FILE.ERROR                            !DSJW
5237: 676c:             PPFO.RECORD.COUNT% = PPFO.RECORD.COUNT% + 1                 !DSJW
5238: 6785:             RETURN                                                      !DSJW
5239: 6797:          ENDIF ELSE BEGIN                                               !DSJW
5240: 679f:             RETURN                                                      !DSJW
5241: 67af:          ENDIF                                                          !DSJW
5242: 67b7:       ENDIF                                                             !DSJW
5243: 67bf: 
5244: 67bf:       F11.CURRENT.COUNT% = 0
5245: 67d0:       TOTAL.BAR.CODE.COUNT% = TOTAL.BAR.CODE.COUNT% - 1
5246: 67e9: 
5247: 67e9: \ REM the above line is due to PSBF11 performing a check on IEF records
5248: 67e9: \ REM NOT number of bar codes.
5249: 67e9: 
5250: 67e9:       F11.NEXT.BAR.CODE$ = PACK$("999999999999")
5251: 6805:       CURRENT.BOOTS.CODE$ = PPF.BOOTS.CODE$                             !CSJW
5252: 6821:       CURRENT.IEF.BAR.CODE$ = RIGHT$(IRF.BAR.CODE$,6)
5253: 6844:       RC% EQ READ.NEXT.IEF (CURRENT.IEF.BAR.CODE$,                      \DSJW
5254: 6873:                             TOTAL.BAR.CODE.COUNT%,                      \DSJW
5255: 6873:                             CURRENT.BOOTS.CODE$)
5256: 6873:       IF RC% NE 0 THEN BEGIN                                            !DSJW
5257: 6888:          FAIL.TYPE$ = "W"                                               !DSJW
5258: 689d:          RC% EQ WRITE.PPFO                                              !DSJW
5259: 68b1: 		 PRINT #992 ; "ADDED FROM LINE 3589" , PPF.RECORD$
5260: 68dc:          IF RC% NE 0 THEN GOTO FILE.ERROR                               !DSJW
5261: 68f1:          PPFO.RECORD.COUNT% = PPFO.RECORD.COUNT% + 1                    !DSJW
5262: 690a:          RETURN                                                         !DSJW
5263: 691a:       ENDIF                                                             !DSJW
5264: 6922: 
5265: 6922:       WHILE VAL(UNPACK$(F11.NEXT.BAR.CODE$)) <> 0
5266: 692d: 
5267: 692d:          IRF.BAR.CODE$ = BAR.CODE.FRONT$ + F11.NEXT.BAR.CODE$
5268: 6956:          RC% EQ READ.IRF.LOCK                                           !DSJW
5269: 696a:          IF RC% NE 0 THEN GOTO READ.IRF.ERROR                           !DSJW
5270: 697f: 
5271: 697f:          IF IRF.BOOTS.CODE$ = SAVED.IDF.BOOTS.CODE$ THEN               \
5272: 69a1:             MATCH.FOUND$ = "Y"                                        :\
5273: 69b6:             GOSUB DO.UPDATE
5274: 69c8: 
5275: 69c8:          GOSUB WRITE.IRF.REC
5276: 69da: 
5277: 69da:          IDF.GROUP.EAN.CODE$ = F11.NEXT.BAR.CODE$
5278: 69f6:          IF GROUP.CODE.FLAG% <> 0 THEN                                 \
5279: 6a05:             GOSUB GROUP.CODE.UPDATE
5280: 6a17: 
5281: 6a17: 
5282: 6a17:          CURRENT.IEF.BAR.CODE$ = RIGHT$(IRF.BAR.CODE$,6)
5283: 6a3a:          RC% EQ READ.NEXT.IEF (CURRENT.IEF.BAR.CODE$,                   \DSJW
5284: 6a69:                                TOTAL.BAR.CODE.COUNT%,                   \DSJW
5285: 6a69:                                CURRENT.BOOTS.CODE$)
5286: 6a69:          IF RC% NE 0 THEN BEGIN                                         !DSJW
5287: 6a7e:             FAIL.TYPE$ = "W"                                            !DSJW
5288: 6a93:             RC% EQ WRITE.PPFO                                           !DSJW
5289: 6aa7: 			PRINT #992 ; "ADDED FROM LINE 3619" , PPF.RECORD$
5290: 6ad2:             IF RC% NE 0 THEN GOTO FILE.ERROR                            !DSJW
5291: 6ae7:             PPFO.RECORD.COUNT% = PPFO.RECORD.COUNT% + 1                 !DSJW
5292: 6b00:             RETURN                                                      !DSJW
5293: 6b10:          ENDIF                                                          !DSJW
5294: 6b18: 
5295: 6b18:       WEND
5296: 6b63: 
5297: 6b63:       IF MATCH.FOUND$ = "N" THEN BEGIN                                  !DSJW
5298: 6b81:          GOSUB UNMATCHED.CODE.ERR                                       !DSJW
5299: 6b93:          FAIL.TYPE$ = "W"                                               !DSJW
5300: 6ba8:          RC% EQ WRITE.PPFO                                              !DSJW
5301: 6bbc: 		 PRINT #992 ; "ADDED FROM LINE 3631" , PPF.RECORD$
5302: 6be7:          IF RC% NE 0 THEN GOTO FILE.ERROR                               !DSJW
5303: 6bfc:          PPFO.RECORD.COUNT% = PPFO.RECORD.COUNT% + 1                    !DSJW
5304: 6c15:          RETURN                                                         !DSJW
5305: 6c27:       ENDIF ELSE BEGIN                                                  !DSJW
5306: 6c2f:          RETURN                                                         !DSJW
5307: 6c3f:       ENDIF                                                             !DSJW
5308: 6c47: 
5309: 6c47:    END.UPDATE.IRF:
5310: 6c57: 
5311: 6c57:    RETURN
5312: 6c67: 
5313: 6c67: \*******************************************************************************
5314: 6c67: \***
5315: 6c67: \***   GROUP.CODE.UPDATE:
5316: 6c67: \***
5317: 6c67: \***   set bar code grp front end to "0000000000" packed
5318: 6c67: \***   IF END occurs on read irf THEN READ.IRF.ERROR
5319: 6c67: \***   CALL READ.IRF using bar code grp front end + idf group ean code as key,
5320: 6c67: \***                 using autolock
5321: 6c67: \***
5322: 6c67: \***   IF IRF.BOOTS.CODE$ = saved Boots code THEN
5323: 6c67: \***      GOSUB DO.UPDATE
5324: 6c67: \***   ELSE
5325: 6c67: \***      CALL APPLICATION.LOG function to log event 33,
5326: 6c67: \***            message number 557
5327: 6c67: \***      CALL WRITE.PPFO to write ppfi record
5328: 6c67: \***      increment ppfo record count by 1
5329: 6c67: \***      RETURN
5330: 6c67: \***   endif
5331: 6c67: \***
5332: 6c67: \***   GOSUB WRITE.IRF.REC
5333: 6c67: \***
5334: 6c67: \***   RETURN
5335: 6c67: \***
5336: 6c67: \...............................................................................
5337: 6c67: 
5338: 6c67:    GROUP.CODE.UPDATE:
5339: 6c77: 
5340: 6c77:       BAR.CODE.FRONT$ = PACK$("0000000000")
5341: 6c91:       IRF.BAR.CODE$ = BAR.CODE.FRONT$ + IDF.GROUP.EAN.CODE$
5342: 6cb7:       RC% EQ READ.IRF.LOCK                                              !DSJW
5343: 6ccb:       IF RC% NE 0 THEN GOTO READ.IRF.ERROR                              !DSJW
5344: 6ce0: 
5345: 6ce0:       IF IRF.BOOTS.CODE$ = SAVED.IDF.BOOTS.CODE$ THEN                   \
5346: 6d02:          GOSUB DO.UPDATE                                               :\
5347: 6d17:       ELSE  BEGIN
5348: 6d1f:          MESSAGE.NO% = 557
5349: 6d2d:          EVENT.NO% = 33
5350: 6d3a:          VAR.STRING.1$ = IDF.GROUP.EAN.CODE$ + PACK$("00000000")
5351: 6d5f:          VAR.STRING.2$ = UNPACK$(IDF.GROUP.EAN.CODE$)
5352: 6d7d:          IF PSBCHN.APP = "PSB51" THEN                                   \
5353: 6d9b:             PSBCHN.U2 = PSBCHN.U2 + "557" + VAR.STRING.1$              :\
5354: 6dc8:             BATCH.SCREEN.FLAG$ = "B"
5355: 6ddf:          RC% EQ APPLICATION.LOG (MESSAGE.NO%,VAR.STRING.1$,             \DSJW
5356: 6e0f:                                  VAR.STRING.2$,EVENT.NO%)               !DSJW
5357: 6e0f:          BATCH.SCREEN.FLAG$ = "S"
5358: 6e26: 
5359: 6e26:          GOSUB RESTORE.MESSAGE                                          ! BMW
5360: 6e38: 
5361: 6e38:          FAIL.TYPE$ = "W"                                               !DSJW
5362: 6e4d:          RC% EQ WRITE.PPFO                                              !DSJW
5363: 6e61: 		 PRINT #992 ; "ADDED FROM LINE 3693" , PPF.RECORD$
5364: 6e8c:          IF RC% NE 0 THEN GOTO FILE.ERROR                               !DSJW
5365: 6ea1:          PPFO.RECORD.COUNT% = PPFO.RECORD.COUNT% + 1                    !DSJW
5366: 6eba:          RETURN
5367: 6eca:       ENDIF
5368: 6ed2: 
5369: 6ed2:       GOSUB WRITE.IRF.REC
5370: 6ee4: 
5371: 6ee4:    RETURN
5372: 6ef4: 
5373: 6ef4: \******************************************************************************
5374: 6ef4: \***
5375: 6ef4: \***   UNMATCHED.CODE.ERR:
5376: 6ef4: \***
5377: 6ef4: \***   CALL APPLICATION.LOG function to log event 32,
5378: 6ef4: \***         message number 556
5379: 6ef4: \***
5380: 6ef4: \***   RETURN
5381: 6ef4: \***
5382: 6ef4: \...............................................................................
5383: 6ef4: 
5384: 6ef4:    UNMATCHED.CODE.ERR:
5385: 6f04: 
5386: 6f04:       MESSAGE.NO% = 556
5387: 6f12:       EVENT.NO% = 32
5388: 6f1f:       VAR.STRING.1$ = RIGHT$(UNPACK$(IDF.BOOTS.CODE$),7)
5389: 6f52:       VAR.STRING.2$ = VAR.STRING.1$ + "   "                             ! BMW
5390: 6f72:       IF PSBCHN.APP = "PSB51" THEN                                      \ BMW
5391: 6f90:          PSBCHN.U2 = PSBCHN.U2 + "556" + VAR.STRING.2$                 :\ BMW
5392: 6fbd:          BATCH.SCREEN.FLAG$ = "B"                                       ! BMW
5393: 6fd4: 
5394: 6fd4:       RC% EQ APPLICATION.LOG (MESSAGE.NO%,VAR.STRING.1$,                \DSJW
5395: 7004:                               VAR.STRING.2$,EVENT.NO%)                  !DSJW
5396: 7004: 
5397: 7004:       BATCH.SCREEN.FLAG$ = "S"                                          ! BMW
5398: 701b: 
5399: 701b:       GOSUB RESTORE.MESSAGE                                             ! BMW
5400: 702d: 
5401: 702d:       RETURN
5402: 703d: 
5403: 703d: \*******************************************************************************
5404: 703d: \***
5405: 703d: \***   CHECK.PPFI.TRAILER:
5406: 703d: \***
5407: 703d: \***   set ppfi trailer error flag to "N"
5408: 703d: \***   IF ppfi boots code is 9999999 (trailer) THEN
5409: 703d: \***      IF ppfi record count is not ppfi trailer record count THEN
5410: 703d: \***         CALL APPLICATION.LOG function to log event 5, message 602
5411: 703d: \***         GOTO CHAIN.OUT
5412: 703d: \***      ELSE
5413: 703d: \***         IF END occurs on read ppfi THEN NO.RECORDS.AFTER.TRAILER
5414: 703d: \***         CALL READ.PPFI
5415: 703d: \***         CALL APPLICATION.LOG function to log event 17
5416: 703d: \***         set ppfi trailer error flag to "Y"
5417: 703d: \***      endif
5418: 703d: \***   endif
5419: 703d: \***
5420: 703d: \***   NO.RECORDS.AFTER.TRAILER:
5421: 703d: \***
5422: 703d: \***   RETURN
5423: 703d: \***
5424: 703d: \...............................................................................
5425: 703d: 
5426: 703d:    CHECK.PPFI.TRAILER:
5427: 704d: 
5428: 704d:       PPFI.TRAILER.ERROR$ = "N"
5429: 7062:       PPFI.BOOTS.CODE$ = PPF.BOOTS.CODE$                               !CSJW
5430: 7080:       PPFI.TRAILER.COUNT% = VAL(PPF.REC.COUNT$)
5431: 70a5: 
5432: 70a5:       IF PPFI.BOOTS.CODE$ = "9999999" THEN                             \CSJW
5433: 70c6:          IF PPFI.RECORD.COUNT% <> PPFI.TRAILER.COUNT% THEN             \
5434: 70e4:             EVENT.NO% = 5                                             :\
5435: 70f1:             MESSAGE.NO% = 602                                         :\
5436: 70ff:             VAR.STRING.1$ = "I" + CHR$(SHIFT(PPFI.REPORT.NUM%,8)) \     !DSJW
5437: 7154:                                 + CHR$(SHIFT(PPFI.REPORT.NUM%,0))     :\!DSJW
5438: 7154:             INTEGER.4% = PPFI.RECORD.COUNT%                           :\
5439: 7169:             RC% EQ CONV.TO.STRING (EVENT.NO%,INTEGER.4%)              :\DSJW
5440: 718d:             IF RC% = 0 THEN                                            \DSJW
5441: 71a2:                VAR.STRING.1$ = VAR.STRING.1$ +                         \
5442: 71d0:                                RIGHT$(F17.RETURNED.STRING$,2)         :\
5443: 71d0:                INTEGER.4% = PPFI.TRAILER.COUNT%                       :\
5444: 71e5:                RC% EQ CONV.TO.STRING (EVENT.NO%,INTEGER.4%)           :\DSJW
5445: 7209:                IF RC% = 0 THEN BEGIN
5446: 721e:                   VAR.STRING.1$ = VAR.STRING.1$ +                      \
5447: 724c:                                   RIGHT$ (F17.RETURNED.STRING$,2)      !DSJW
5448: 724c:                   VAR.STRING.2$ =                                      \
5449: 72d5:                       RIGHT$ ("     " + STR$(PPFI.RECORD.COUNT%), 5) + \
5450: 72d5:                       RIGHT$ ("     " + STR$(PPFI.TRAILER.COUNT%), 5)
5451: 72d5:                   IF PSBCHN.APP = "PSB51" THEN                         \
5452: 72f3:                      PSBCHN.U2 = PSBCHN.U2 + "602" + VAR.STRING.2$    :\
5453: 7320:                      BATCH.SCREEN.FLAG$ = "B"
5454: 7337:                   RC% EQ APPLICATION.LOG (MESSAGE.NO%,VAR.STRING.1$,   \DSJW
5455: 7367:                                           VAR.STRING.2$,EVENT.NO%)     !DSJW
5456: 7367:                   BATCH.SCREEN.FLAG$ = "S"
5457: 737e:                   GOTO CHAIN.OUT
5458: 738b:                   ENDIF                                                \
5459: 738b:                ELSE                                                    \
5460: 738b:                   GOTO CHAIN.OUT                                       \
5461: 7396:             ELSE                                                       \
5462: 73a0:                GOTO CHAIN.OUT                                          \
5463: 73ab:          ELSE  BEGIN
5464: 73b6:             RC% EQ READ.PPFI                                            !DSJW
5465: 73ca:             IF RC% NE 0 THEN GOTO NO.RECORDS.AFTER.TRAILER              !DSJW
5466: 73df:             EVENT.NO% = 17
5467: 73ec:             MESSAGE.NO% = 555
5468: 73fa:             VAR.STRING.1$ = "I" + CHR$(SHIFT(PPFI.REPORT.NUM%,8)) \     !DSJW
5469: 748a:                                 + CHR$(SHIFT(PPFI.REPORT.NUM%,0)) \     !DSJW
5470: 748a:                                 + PACK$("00000000") \                   !DSJW
5471: 748a:                                 + PACK$("0" + PPF.BOOTS.CODE$)          !DSJW
5472: 748a:             VAR.STRING.2$ = LEFT$("0" + PPF.BOOTS.CODE$ \               !CSJW
5473: 74c9:                                   + "        ",10)                             ! BMW
5474: 74c9:             IF PSBCHN.APP = "PSB51" THEN                               \
5475: 74e7:                PSBCHN.U2 = PSBCHN.U2 +                                 \ BMW
5476: 7514:                            "555" + VAR.STRING.2$                      :\ BMW
5477: 7514:                BATCH.SCREEN.FLAG$ = "B"
5478: 752b:             RC% EQ APPLICATION.LOG (MESSAGE.NO%,VAR.STRING.1$,          \DSJW
5479: 755b:                                     VAR.STRING.2$,EVENT.NO%)            !DSJW
5480: 755b:             PPFI.TRAILER.ERROR$ = "Y"
5481: 7570:             BATCH.SCREEN.FLAG$ = "S"
5482: 7587:             ENDIF
5483: 758f: 
5484: 758f:    NO.RECORDS.AFTER.TRAILER:
5485: 759f: 
5486: 759f:    RETURN
5487: 75af: 
5488: 75af: \*******************************************************************************
5489: 75af: \***
5490: 75af: \***   READ.IDF.ERROR:
5491: 75af: \***
5492: 75af: \***   Log Event 106
5493: 75af: \***   NB:
5494: 75af: \***    - Do not display message
5495: 75af: \***    - Do not report error to PSB51 (Opening Log)
5496: 75af: \***
5497: 75af: \***   GOTO END.UPDATE.IRF
5498: 75af: \***
5499: 75af: \...............................................................................
5500: 75af: 
5501: 75af:    READ.IDF.ERROR:
5502: 75bf: 
5503: 75bf:       CURRENT.SESS.NUM% = IDF.SESS.NUM%
5504: 75d1:       CURRENT.KEY$ = PACK$("0" + PPF.BOOTS.CODE$)                       !CSJW
5505: 75fe:       FAIL.TYPE$ = "R"
5506: 7613: 
5507: 7613:       SB.ACTION$ = "R"                                                  !DSJW
5508: 7628:       SB.INTEGER% = CURRENT.SESS.NUM%                                   !DSJW
5509: 7636:       GOSUB SB.FILE.UTILS                                               !DSJW
5510: 7648: 
5511: 7648:       VAR.STRING.2$ = ""                                                !DSJW
5512: 765d:       MESSAGE.NO% = 0                                                   !DSJW
5513: 766b:       BATCH.SCREEN.FLAG$ = "B"                                          !DSJW
5514: 7682:       VAR.STRING.1$ = FAIL.TYPE$ + CHR$(SHIFT(SB.FILE.REP.NUM%,8)) \    !DSJW
5515: 7713:                                  + CHR$(SHIFT(SB.FILE.REP.NUM%,0)) \    !DSJW
5516: 7713:                                  + RIGHT$(PACK$("00000000000000") \     !DSJW
5517: 7713:                                  + CURRENT.KEY$,7)                      !DSJW
5518: 7713:       EVENT.NO% = 106                                                   !DSJW
5519: 7720:       RC% EQ APPLICATION.LOG (MESSAGE.NO%,VAR.STRING.1$, \              !DSJW
5520: 7750:                               VAR.STRING.2$,EVENT.NO%)                  !DSJW
5521: 7750: 
5522: 7750:       BATCH.SCREEN.FLAG$ = "S"                                          !DSJW
5523: 7767: 
5524: 7767:       GOTO END.UPDATE.IRF
5525: 7772: 
5526: 7772: \*******************************************************************************
5527: 7772: \***
5528: 7772: \***   READ.IRF.ERROR:
5529: 7772: \***
5530: 7772: \***   Log Event 106
5531: 7772: \***   NB:
5532: 7772: \***    - Do not write PPFI rec to PPFO
5533: 7772: \***    - Do not display message
5534: 7772: \***    - Do not report error to PSB51 (Opening Log)
5535: 7772: \***
5536: 7772: \***   GOTO END.UPDATE.IRF
5537: 7772: \***
5538: 7772: \...............................................................................
5539: 7772: 
5540: 7772:    READ.IRF.ERROR:
5541: 7782: 
5542: 7782:       CURRENT.SESS.NUM% = IRF.SESS.NUM%
5543: 7794:       FAIL.TYPE$ = "R"
5544: 77a9:       CURRENT.KEY$ = IRF.BAR.CODE$
5545: 77c5: 
5546: 77c5:       SB.ACTION$ = "R"                                                  !DSJW
5547: 77da:       SB.INTEGER% = CURRENT.SESS.NUM%                                   !DSJW
5548: 77e8:       GOSUB SB.FILE.UTILS                                               !DSJW
5549: 77fa: 
5550: 77fa:       VAR.STRING.2$ = ""                                                !DSJW
5551: 780f:       MESSAGE.NO% = 0                                                   !DSJW
5552: 781d:       BATCH.SCREEN.FLAG$ = "B"                                          !DSJW
5553: 7834:       VAR.STRING.1$ = FAIL.TYPE$ + CHR$(SHIFT(SB.FILE.REP.NUM%,8)) \    !DSJW
5554: 78c5:                                  + CHR$(SHIFT(SB.FILE.REP.NUM%,0)) \    !DSJW
5555: 78c5:                                  + RIGHT$(PACK$("00000000000000") \     !DSJW
5556: 78c5:                                  + CURRENT.KEY$,7)                      !DSJW
5557: 78c5:       EVENT.NO% = 106                                                   !DSJW
5558: 78d2:       RC% EQ APPLICATION.LOG (MESSAGE.NO%,VAR.STRING.1$, \              !DSJW
5559: 7902:                               VAR.STRING.2$,EVENT.NO%)                  !DSJW
5560: 7902: 
5561: 7902:       BATCH.SCREEN.FLAG$ = "S"                                          !DSJW
5562: 7919: 
5563: 7919:       GOTO END.UPDATE.IRF
5564: 7924: 
5565: 7924: \*******************************************************************************
5566: 7924: \***
5567: 7924: \***   CREATE.ERROR:
5568: 7924: \***
5569: 7924: \***   set fail type to "C"
5570: 7924: \***   set key to null
5571: 7924: \***
5572: 7924: \***   GOSUB FILE.ERROR
5573: 7924: \***
5574: 7924: \***   GOTO CHAIN.OUT
5575: 7924: \***
5576: 7924: \...............................................................................
5577: 7924: 
5578: 7924:    CREATE.ERROR:
5579: 7934: 
5580: 7934:       FAIL.TYPE$ = "C"
5581: 7949:       CURRENT.KEY$ = ""
5582: 795e: 
5583: 795e:       GOSUB FILE.ERROR
5584: 7970: 
5585: 7970:       GOTO CHAIN.OUT
5586: 797b: 
5587: 797b: \*****************************************************************************
5588: 797b: \***
5589: 797b: \***   WRITE.IRF.REC:
5590: 797b: \***
5591: 797b: \***   The points value of the item (for Customer Card redemption) is set to
5592: 797b: \***   the default value of zero.  If the item is eligible for redemption and
5593: 797b: \***   the price value is small enough to fit into a 2 byte integer, the price
5594: 797b: \***   is written to the points field.
5595: 797b: \***
5596: 797b: \***   CALL UPDT.IRF.UPDT to write out the modified irf record using autounlock,
5597: 797b: \***                      and update TIF/TMCF
5598: 797b: \***
5599: 797b: \***   RETURN
5600: 797b: \***
5601: 797b: \...............................................................................
5602: 797b: 
5603: 797b:    WRITE.IRF.REC:
5604: 798b: 
5605: 798b: !      IRF.POINTS% = 0                                                  ! FAW   !IBG
5606: 798b: 
5607: 798b: !      IF (IRF.INDICAT3% AND 04H) = 04H THEN BEGIN                      ! FAW   !IBG
5608: 798b: 
5609: 798b: !         REDEEM.POINTS% = VAL(UNPACK$(IRF.SALEPRIC$))                  ! FAW   !IBG
5610: 798b: 
5611: 798b: !         IF REDEEM.POINTS% < 8000H THEN BEGIN                          ! FAW   !IBG
5612: 798b: 
5613: 798b: !            IRF.POINTS% = REDEEM.POINTS%                               ! FAW   !IBG
5614: 798b: 
5615: 798b: !         ENDIF                                                         ! FAW   !IBG
5616: 798b: 
5617: 798b: !      ENDIF                                                            ! FAW   !IBG
5618: 798b: 
5619: 798b: !      NEW.IRF.DATA$ = IRF.BAR.CODE$       +                            \       !IBG
5620: 798b: !                      CHR$(IRF.INDICAT0%) +                            \       !IBG
5621: 798b: !                      CHR$(IRF.INDICAT1%) +                            \       !IBG
5622: 798b: !                      CHR$(IRF.INDICAT2%) +                            \ HSWM  !IBG
5623: 798b: !                      IRF.DEAL.NUM$       +                            \       !IBG
5624: 798b: !                      CHR$(IRF.INDICAT4%) +                            \       !IBG
5625: 798b: !                      IRF.SALEQUAN$       +                            \       !IBG
5626: 798b: !                      IRF.SALEPRIC$       +                            \       !IBG
5627: 798b: !                      CHR$(IRF.INDICAT5%) +                            \ GSB   !IBG
5628: 798b: !                      IRF.ITEMNAME$       +                            \       !IBG
5629: 798b: !                      IRF.BOOTS.CODE$     +                            \       !IBG
5630: 798b: !                      IRF.DEAL.SAVING$    +                            \       !IBG
5631: 798b: !                      CHR$(IRF.POINTS%  AND 0FFH)          +           \ FAW   !IBG
5632: 798b: !                      CHR$(SHIFT(IRF.POINTS%, 8) AND 0FFH) +           \ FAW   !IBG
5633: 798b: !                      CHR$(IRF.INDICAT3%)
5634: 798b: 
5635: 798b:       ACD.FLAG$ = "CHANGE"
5636: 79a0:       
5637: 79a0:       CALL CONCAT.NEW.IRF.DATA$                                                 !IBG
5638: 79ad: 
5639: 79ad:       RC% EQ UPDT.IRF.UPDT (NEW.IRF.DATA$,ACD.FLAG$,IRF.LOCKED.FLAG$)   !DSJW
5640: 79df:       IF RC% NE 0 THEN GOTO CHAIN.OUT                                   !DSJW
5641: 79f4: 
5642: 79f4:    ! 1 line deleted from here                                           ! BMW
5643: 79f4: 
5644: 79f4:    RETURN
5645: 7a04: 
5646: 7a04:    ! Subroutine deleted from here !!!!!                                 ! BMW
5647: 7a04: 
5648: 7a04: \*******************************************************************************
5649: 7a04: \***
5650: 7a04: \***   ZERO.IDF.BAR.CODE:
5651: 7a04: \***
5652: 7a04: \***   CALL APPLICATION.LOG to log event number 5, message number 603
5653: 7a04: \***
5654: 7a04: \***   RETURN
5655: 7a04: \***
5656: 7a04: \...............................................................................
5657: 7a04: 
5658: 7a04:    ZERO.IDF.BAR.CODE:
5659: 7a14: 
5660: 7a14:       VAR.STRING.1$ = "I" + CHR$(IDF.REPORT.NUM%)                       ! BMW
5661: 7a38:       EVENT.NO% = 5
5662: 7a45:       INTEGER.4% = F11.CURRENT.COUNT%
5663: 7a60:       RC% EQ CONV.TO.STRING (EVENT.NO%,INTEGER.4%)                      !DSJW
5664: 7a84:       IF RC% NE 0 THEN RETURN                                           !DSJW
5665: 7a9e: 
5666: 7a9e:       VAR.STRING.1$ = VAR.STRING.1$ + RIGHT$(F17.RETURNED.STRING$,2)
5667: 7acc: 
5668: 7acc:       INTEGER.4% = TOTAL.BAR.CODE.COUNT%
5669: 7ae1:       RC% EQ CONV.TO.STRING (EVENT.NO%,INTEGER.4%)                      !DSJW
5670: 7b05:       IF RC% NE 0 THEN RETURN                                           !DSJW
5671: 7b1f: 
5672: 7b1f:       VAR.STRING.1$ = VAR.STRING.1$ +                                  \
5673: 7b63:                       RIGHT$(F17.RETURNED.STRING$,2) +                 \
5674: 7b63:                       IDF.BOOTS.CODE$
5675: 7b63: 
5676: 7b63:       VAR.STRING.2$ = RIGHT$ (STR$(F11.CURRENT.COUNT%), 1) +           \
5677: 7bd8:                       RIGHT$ ("    " + STR$(TOTAL.BAR.CODE.COUNT%), 4)
5678: 7bd8:       MESSAGE.NO% = 603
5679: 7be6: 
5680: 7be6:       IF PSBCHN.APP = "PSB51" THEN                                     \
5681: 7c04:          PSBCHN.U2 = PSBCHN.U2 + "603" + LEFT$(                        \
5682: 7c63:                       UNPACK$(IDF.BOOTS.CODE$) + "          ",10)     :\
5683: 7c63:          BATCH.SCREEN.FLAG$ = "B"
5684: 7c7a:       RC% EQ APPLICATION.LOG (MESSAGE.NO%,VAR.STRING.1$,                \DSJW
5685: 7caa:                               VAR.STRING.2$,EVENT.NO%)                  !DSJW
5686: 7caa:       BATCH.SCREEN.FLAG$ = "S"
5687: 7cc1: 
5688: 7cc1:       GOSUB RESTORE.MESSAGE                                            ! BMW
5689: 7cd3: 
5690: 7cd3:       RETURN
5691: 7ce3: 
5692: 7ce3: \*******************************************************************************
5693: 7ce3: \***
5694: 7ce3: \***   DO.UPDATE:
5695: 7ce3: \***
5696: 7ce3: \***   set deal flag off
5697: 7ce3: \***   set local price flag off
5698: 7ce3: \***
5699: 7ce3: \***   Check whether the IRF is converted or not, depending on the result
5700: 7ce3: \***   set local flag according to the correct field,
5701: 7ce3: \***                     ie: Converted   -> HOLDING PRICE,
5702: 7ce3: \***                         Unconverted -> IRF INDICAT3% (bit-6)
5703: 7ce3: \***
5704: 7ce3: \***
5705: 7ce3: \***   IF (irf indicat2 unpacks to give a non-zero second digit
5706: 7ce3: \***   OR irf salequan unpacked is not "00" or "01")
5707: 7ce3: \***   AND local price flag not set) THEN
5708: 7ce3: \***      set deal flag on
5709: 7ce3: \***      IF first ean flag is on THEN
5710: 7ce3: \***         set external message string data to boots code
5711: 7ce3: \***         set disp. mess. to 261
5712: 7ce3: \***         GOSUB SHOW.MESSAGE
5713: 7ce3: \***         set update failed flag on
5714: 7ce3: \***         RETURN
5715: 7ce3: \***      ELSE
5716: 7ce3: \***         set unique to bar code last 12 digits packed + "D" + ppfi status
5717: 7ce3: \***         CALL ADXERROR function to log event number 25
5718: 7ce3: \***      endif
5719: 7ce3: \***   endif
5720: 7ce3: \***
5721: 7ce3: \...............................................................................
5722: 7ce3: 
5723: 7ce3:    DO.UPDATE:
5724: 7cf3: 
5725: 7cf3:       DEAL.PRICE$ = "N"
5726: 7d08:       LOCAL.PRICE.FLAG$ = "N"                                           !DSJW
5727: 7d1d: 
5728: 7d1d: ! Code removed refering to UNCONVERTED RECORDS                              GSB
5729: 7d1d: 
5730: 7d1d:       IF (IRF.INDICAT3% AND 00100000B) <> 0 THEN \                      !DSJW
5731: 7d32:       BEGIN                                                             !DSJW
5732: 7d32:          LOCAL.PRICE.FLAG$ = "Y"                                        !DSJW
5733: 7d47:       ENDIF                                                             !DSJW
5734: 7d4f: 
5735: 7d4f: !! All records are written back to the IRF converted                    !DSJW
5736: 7d4f:       IRF.RECORD$ = "CONVERTED RECORD"                                  !DSJW
5737: 7d66: 
5738: 7d66: !     INDICAT2$ = RIGHT$ (UNPACK$(IRF.INDICAT2$),1)                    ! HSWM
5739: 7d66: !     SALEQUAN$ = UNPACK$ (IRF.SALEQUAN$)                              ! HSWM
5740: 7d66: !     IF (INDICAT2$ <> "0"                                             \ HSWM
5741: 7d66: !     OR (SALEQUAN$ <> "00" AND SALEQUAN$ <> "01"))                    \ HSWM
5742: 7d66: !     AND LOCAL.PRICE.FLAG$ = "N" THEN                                 \!HSWM
5743: 7d66: !        DEAL.PRICE$ = "Y"                                            :\ HSWM
5744: 7d66: !        IF FIRST.EAN$ = "Y" THEN                                      \ HSWM
5745: 7d66: !           VARIABLE.STRING$  = PPF.BOOTS.CODE$                       :\ HSWM
5746: 7d66: !           MESSAGE.NO% = 261                                         :\ HSWM
5747: 7d66: !           GOSUB SHOW.MESSAGE                                        :\ HSWM
5748: 7d66: !           GOSUB RESTORE.MESSAGE                                     :\ HSWM
5749: 7d66: !           UPDATE.FAILED$ = "Y"                                      :\ HSWM
5750: 7d66: !           RETURN                                                    :\ HSWM
5751: 7d66: !        ELSE                                                          \ HSWM
5752: 7d66: !           UNIQUE$ = RIGHT$(IRF.BAR.CODE$,6) + "D" + PPF.STATUS.FLAG$ :\HSWM
5753: 7d66: !           TERM% = 0                                                 :\ HSWM
5754: 7d66: !           MSGGRP% = ASC("J")                                        :\ HSWM
5755: 7d66: !           MSGNUM% = 0                                               :\ HSWM
5756: 7d66: !           SEVERITY% = 3                                             :\ HSWM
5757: 7d66: !           EVENT.NO% = 25                                            :\ HSWM
5758: 7d66: !           CALL ADXERROR (TERM%,                                      \ HSWM
5759: 7d66: !                          MSGGRP%,                                    \ HSWM
5760: 7d66: !                          MSGNUM%,                                    \ HSWM
5761: 7d66: !                          SEVERITY%,                                  \ HSWM
5762: 7d66: !                          EVENT.NO%,                                  \ HSWM
5763: 7d66: !                          UNIQUE$)                                      HSWM
5764: 7d66: 
5765: 7d66: \...............................................................................
5766: 7d66: \***
5767: 7d66: \***   IF local price flag is on THEN
5768: 7d66: \***      IF ppfi status flag is not "L" THEN
5769: 7d66: \***         IF first ean flag is on THEN
5770: 7d66: \***            set external message string data to boots code
5771: 7d66: \***            set disp. mess. to 262
5772: 7d66: \***            GOSUB SHOW.MESSAGE
5773: 7d66: \***            set update failed flag on
5774: 7d66: \***            RETURN
5775: 7d66: \***         ELSE
5776: 7d66: \***            set unique to bar code last 12 digits packed + "L" + ppfi status
5777: 7d66: \***            CALL ADXERROR function to log event number 25
5778: 7d66: \***         endif
5779: 7d66: \***      ELSE
5780: 7d66: \***      endif
5781: 7d66: \***   ELSE
5782: 7d66: \***      IF ppfi status flag is "L" THEN
5783: 7d66: \***         IF first ean flag is on THEN
5784: 7d66: \***            set external message string data to boots code
5785: 7d66: \***            set disp. mess. to 263
5786: 7d66: \***            GOSUB SHOW.MESSAGE
5787: 7d66: \***            set update failed flag on
5788: 7d66: \***            RETURN
5789: 7d66: \***         ELSE
5790: 7d66: \***            set unique to bar code last 12 digits packed + " " + ppfi status
5791: 7d66: \***            CALL ADXERROR function to log event number 25
5792: 7d66: \***         endif
5793: 7d66: \***      endif
5794: 7d66: \***   endif
5795: 7d66: \***
5796: 7d66: \...............................................................................
5797: 7d66: 
5798: 7d66:       IF LOCAL.PRICE.FLAG$ = "Y" THEN                                  \!DSJW
5799: 7d84:          IF PPF.STATUS.FLAG$ <> "L" THEN                               \
5800: 7da5:             IF FIRST.EAN$ = "Y" THEN                                   \
5801: 7dc0:                VARIABLE.STRING$ = PPF.BOOTS.CODE$                     :\CSJW
5802: 7ddc:                MESSAGE.NO% = 262                                      :\
5803: 7dea:                GOSUB SHOW.MESSAGE                                     :\
5804: 7dfc:                GOSUB RESTORE.MESSAGE                                  :\ BMW
5805: 7e0e:                UPDATE.FAILED$ = "Y"                                   :\
5806: 7e23:                RETURN                                                 :\
5807: 7e36:             ELSE                                                       \
5808: 7e36:                UNIQUE$ = RIGHT$(IRF.BAR.CODE$,6) + "L" +               \
5809: 7e76:                                                     PPF.STATUS.FLAG$  :\
5810: 7e76:                TERM% = 0                                              :\
5811: 7e84:                MSGGRP% = ASC("J")                                     :\
5812: 7e98:                MSGNUM% = 0                                            :\
5813: 7ea6:                SEVERITY% = 3                                          :\
5814: 7eb3:                EVENT.NO% = 25                                         :\
5815: 7ec0:                CALL ADXERROR (TERM%,                                   \
5816: 7eef:                               MSGGRP%,                                 \
5817: 7eef:                               MSGNUM%,                                 \
5818: 7eef:                               SEVERITY%,                               \
5819: 7eef:                               EVENT.NO%,                               \
5820: 7eef:                               UNIQUE$)                                :\
5821: 7eef:          ELSE                                                          \
5822: 7ef9:       ELSE                                                             \
5823: 7f04:          IF PPF.STATUS.FLAG$ = "L" THEN                                \
5824: 7f25:             IF FIRST.EAN$ = "Y" THEN                                   \
5825: 7f40:                VARIABLE.STRING$ = PPF.BOOTS.CODE$                     :\CSJW
5826: 7f5c:                MESSAGE.NO% = 263                                      :\
5827: 7f6a:                GOSUB SHOW.MESSAGE                                     :\
5828: 7f7c:                GOSUB RESTORE.MESSAGE                                  :\ BMW
5829: 7f8e:                UPDATE.FAILED$ = "Y"                                   :\
5830: 7fa3:                RETURN                                                 :\
5831: 7fb6:             ELSE                                                       \
5832: 7fb6:                UNIQUE$ = RIGHT$(IRF.BAR.CODE$,6) + " " +               \
5833: 7ff6:                                                    PPF.STATUS.FLAG$   :\
5834: 7ff6:                TERM% = 0                                              :\
5835: 8004:                MSGGRP% = ASC("J")                                     :\
5836: 8018:                MSGNUM% = 0                                            :\
5837: 8026:                SEVERITY% = 3                                          :\
5838: 8033:                EVENT.NO% = 25                                         :\
5839: 8040:                CALL ADXERROR (TERM%,                                   \
5840: 806f:                               MSGGRP%,                                 \
5841: 806f:                               MSGNUM%,                                 \
5842: 806f:                               SEVERITY%,                               \
5843: 806f:                               EVENT.NO%,                               \
5844: 806f:                               UNIQUE$)
5845: 8077: 
5846: 8077: \...............................................................................
5847: 8077: \***
5848: 8077: \***   IF first ean flag is on THEN
5849: 8077: \***      set first ean flag off
5850: 8077: \***      set saved price to irf salepric
5851: 8077: \***      set saved mpgroup to irf mpgroup
5852: 8077: \***      set saved idicat2 to irf indicat2
5853: 8077: \***      set saved.deal.num$ = irf.deal.num$
5854: 8077: \***      set saved.indicat4% = irf.indicat4%
5855: 8077: \***      set saved.indicat3% = irf.indicat3%
5856: 8077: \***      set saved.deal.saving$ = irf.deal.saving$
5857: 8077: \***      set saved salequan to irf salequan
5858: 8077: \***      IF local price flag is ON
5859: 8077: \***      AND local price file is OPEN THEN
5860: 8077: \***         update the item on the local file
5861: 8077: \***      ELSE
5862: 8077: \***         set irf salepric to ppfi new price
5863: 8077: \***         set saved price to irf salepric
5864: 8077: \***      endif
5865: 8077: \***   ELSE
5866: 8077: \***      set irf salepric to saved price
5867: 8077: \***      set irf indicat2 to saved indicat2
5868: 8077: \***      set irf.deal.num$ = saved.deal.num$
5869: 8077: \***      set irf.indicat4% = saved.indicat4%
5870: 8077: \***      set irf.indicat3% = saved.indicat3%
5871: 8077: \***      set irf.deal.saving$ = saved.deal.saving$
5872: 8077: \***      set irf salequan to saved salequan
5873: 8077: \***      set irf mpgroup to saved mpgroup
5874: 8077: \***   endif
5875: 8077: \***
5876: 8077: \***
5877: 8077: \***   RETURN
5878: 8077: \***
5879: 8077: \............................................................................
5880: 8077: 
5881: 8077:       IF FIRST.EAN$ = "Y" THEN BEGIN                                    !DSJW
5882: 8095:          FIRST.EAN$ = "N"                                               !DSJW
5883: 80aa: !        SAVED.DEAL.NUM$ = IRF.DEAL.NUM$                                !DSJW     !IBG
5884: 80aa: !        SAVED.INDICAT4% = IRF.INDICAT4%                                !DSJW     !IBG
5885: 80aa: !        SAVED.DEAL.SAVING$ = IRF.DEAL.SAVING$                          !DSJW     !IBG
5886: 80aa:          SAVED.INDICAT5% = IRF.INDICAT5%                                !DSJW GSB
5887: 80bc: !        SAVED.INDICAT2% = IRF.INDICAT2%                                !HSWM     !IBG
5888: 80bc: !        SAVED.SALEQUAN$ = IRF.SALEQUAN$                                !DSJW     !IBG
5889: 80bc:          SAVED.DEAL.NUM$(0) = IRF.DEAL.NUM$(0)                                    !IBG
5890: 80f2:          SAVED.DEAL.NUM$(1) = IRF.DEAL.NUM$(1)                                    !IBG
5891: 8128:          SAVED.DEAL.NUM$(2) = IRF.DEAL.NUM$(2)                                    !IBG
5892: 815e:          SAVED.LIST.ID%(0) = IRF.LIST.ID%(0)                                      !IBG
5893: 818f:          SAVED.LIST.ID%(1) = IRF.LIST.ID%(1)                                      !IBG
5894: 81c0:          SAVED.LIST.ID%(2) = IRF.LIST.ID%(2)                                      !IBG
5895: 81f1:          IF LOCAL.PRICE.FLAG$ = "Y" THEN \                              !DSJW
5896: 820c:          BEGIN                                                          !DSJW
5897: 820c:             GOSUB UPDATE.LOCAL.FILE                                     !DSJW
5898: 8220:          ENDIF \                                                        !DSJW
5899: 8220:          ELSE \                                                         !DSJW
5900: 8228:          BEGIN                                                          !DSJW
5901: 8228:             IRF.SALEPRIC$ = PACK$("00" + PPF.PRICE$)                    !DSJW
5902: 8257:             SAVED.PRICE$ = IRF.SALEPRIC$                                !DSJW
5903: 8273:             SAVED.INDICAT3% = IRF.INDICAT3%                             !DSJW
5904: 8285:          ENDIF                                                          !DSJW
5905: 8290:        ENDIF ELSE BEGIN                                                 !DSJW
5906: 8298:          IRF.SALEPRIC$ = SAVED.PRICE$                                   !DSJW
5907: 82b3: !        IRF.DEAL.NUM$ = SAVED.DEAL.NUM$                                !DSJW     !IBG
5908: 82b3: !        IRF.INDICAT4% = SAVED.INDICAT4%                                !DSJW     !IBG
5909: 82b3:          IRF.INDICAT3% = SAVED.INDICAT3%                                !DSJW
5910: 82c5: !        IRF.DEAL.SAVING$ = SAVED.DEAL.SAVING$                          !DSJW     !IBG
5911: 82c5: !        IRF.INDICAT2% = SAVED.INDICAT2%                                !HSWM     !IBG
5912: 82c5: !        IRF.SALEQUAN$ = SAVED.SALEQUAN$                                !DSJW     !IBG
5913: 82c5:          IRF.DEAL.NUM$(0) = SAVED.DEAL.NUM$(0)                                    !IBG
5914: 82fb:          IRF.DEAL.NUM$(1) = SAVED.DEAL.NUM$(1)                                    !IBG
5915: 8331:          IRF.DEAL.NUM$(2) = SAVED.DEAL.NUM$(2)                                    !IBG
5916: 8367:          IRF.LIST.ID%(0) = SAVED.LIST.ID%(0)                                      !IBG
5917: 8398:          IRF.LIST.ID%(1) = SAVED.LIST.ID%(1)                                      !IBG
5918: 83c9:          IRF.LIST.ID%(2) = SAVED.LIST.ID%(2)                                      !IBG
5919: 83fa:          IRF.INDICAT5% = SAVED.INDICAT5%                                !DSJW GSB
5920: 840c:        ENDIF                                                            !DSJW
5921: 8414: 
5922: 8414:    RETURN
5923: 8424: 
5924: 8424: \*****************************************************************************
5925: 8424: \***   UPDATE.LOCAL.FILE
5926: 8424: \***   Key for the local file is boots code with check digit packed.
5927: 8424: \***   Create key and read the file
5928: 8424: \***   If not found, add a record with default settings
5929: 8424: \***   Update HO price and HO price date changed fields
5930: 8424: \***   Write the rec back to the file
5931: 8424: \*****************************************************************************
5932: 8424: 
5933: 8424:    UPDATE.LOCAL.FILE:                                                   !DSJW
5934: 8434: 
5935: 8434:       IF NOT LOCAL.FILE.OPEN THEN \                                     !DSJW
5936: 8446:          GOTO INVALID.BOOTS.CODE                                        !DSJW
5937: 8451:                                                            
5938: 8451:       BOOTS.CODE.SIX.DIGIT$ EQ UNPACK$(IRF.BOOTS.CODE$)                 !DSJW
5939: 8474:       CALL CALC.BOOTS.CODE.CHECK.DIGIT(BOOTS.CODE.SIX.DIGIT$)           !DSJW
5940: 848f:       IF F18.CHECK.DIGIT$ EQ "A" THEN BEGIN                             !DSJW
5941: 84ad:          GOTO INVALID.BOOTS.CODE                                        !DSJW
5942: 84ba:       ENDIF ELSE BEGIN                                                  !DSJW
5943: 84c2:          BOOTS.CODE.SEVEN.DIGIT$ EQ BOOTS.CODE.SIX.DIGIT$ \             !DSJW
5944: 84ee:                                          + F18.CHECK.DIGIT$             !DSJW
5945: 84ee:       ENDIF                                                             !DSJW
5946: 84f6: 
5947: 84f6:       FAIL.TYPE$ EQ "R"                                                 !DSJW
5948: 850b:       CURRENT.SESS.NUM% EQ LOCAL.SESS.NUM%                              !DSJW
5949: 851d:       LOCAL.ITEM.CODE$ EQ PACK$("0" + BOOTS.CODE.SEVEN.DIGIT$)          !DSJW
5950: 854c:       RC% EQ READ.LOCAL                                                 !DSJW
5951: 8560:       IF RC% NE 0 THEN \                                                !DSJW
5952: 8572:          GOSUB SET.LOCAL.RECORD.FIELDS                                  !DSJW
5953: 8584: 
5954: 8584:      !If the item is an emergency price change, remove the LOCAL price  !JJT
5955: 8584:       IF LEFT$(LOCAL.REASON$,3) = "EPC" THEN BEGIN                      !JJT
5956: 85b9:          DELREC LOCAL.SESS.NUM%; LOCAL.ITEM.CODE$                       !JJT
5957: 85d8:      !And set the IRF local price flag off                              !JJT
5958: 85d8:          IRF.INDICAT3% = (IRF.INDICAT3% AND 11011111B)                  !JJT
5959: 85f0:          IRF.SALEPRIC$ = PACK$("00" + PPF.PRICE$)                       !JJT
5960: 8622:       ENDIF ELSE BEGIN                                                  !JJT
5961: 862a:          CURRENT.DATE$ EQ DATE$                                         !DSJW
5962: 8642:          LOCAL.H.O.PRICE$ EQ PACK$("00" + PPF.PRICE$)                   !DSJW
5963: 8671:          LOCAL.HO.CHANGE$ EQ PACK$(CURRENT.DATE$)                       !DSJW
5964: 8694: 
5965: 8694:          FAIL.TYPE$ EQ "W"                                              !DSJW
5966: 86a9:          RC% EQ WRITE.LOCAL                                             !DSJW
5967: 86bd:          IF RC% NE 0 THEN GOTO FILE.ERROR                               !DSJW
5968: 86d2:          IRF.INDICAT3% = (IRF.INDICAT3% OR 00100000b)                   !DSJW
5969: 86ea: 
5970: 86ea:       ENDIF                                                             !JJT
5971: 86f2:       
5972: 86f2:       SAVED.INDICAT3% = IRF.INDICAT3%                             !DSJW
5973: 8704:       SAVED.PRICE$ = IRF.SALEPRIC$                                !DSJW
5974: 8720:       
5975: 8720:       INVALID.BOOTS.CODE:                                               !DSJW
5976: 8730: 
5977: 8730:    RETURN                                                               !DSJW
5978: 8740: 
5979: 8740: \*****************************************************************************
5980: 8740: \***   SET.LOCAL.RECORD.FIELDS
5981: 8740: \***   Set fields to default values
5982: 8740: \*****************************************************************************
5983: 8740: 
5984: 8740:    SET.LOCAL.RECORD.FIELDS:                                             !DSJW
5985: 8750: 
5986: 8750:            FORTNIGHT% EQ 14                                             !DSJW
5987: 875d:            F02.DATE$ EQ DATE$                                           !DSJW
5988: 8775:            RC% EQ UPDATE.DATE(FORTNIGHT%)                               !DSJW
5989: 8793:            IF RC% EQ 0 THEN BEGIN                                       !DSJW
5990: 87a5:               DATE.NEXT.WEEK$ EQ F02.DATE$                              !DSJW
5991: 87c5:            ENDIF ELSE BEGIN                                             !DSJW
5992: 87cd:               DATE.NEXT.WEEK$ EQ "000000"                               !DSJW
5993: 87e4:            ENDIF                                                        !DSJW
5994: 87ec: 
5995: 87ec:            LOCAL.PRICE$ EQ IRF.SALEPRIC$                                !DSJW
5996: 880a:            LOCAL.START.DATE$ EQ PACK$(DATE$)                            !DSJW
5997: 8827:            LOCAL.START.TIME$ EQ PACK$(MID$(TIME$,1,4))                  !DSJW
5998: 8858:            LOCAL.END.DATE$ EQ PACK$(DATE.NEXT.WEEK$)                    !DSJW
5999: 887b:            LOCAL.OPERATOR$ EQ PACK$(RIGHT$("00000000" + \               !DSJW
6000: 88bb:                                            OPERATOR.NUMBER$,8))         !DSJW
6001: 88bb:            LOCAL.REASON$ EQ "    "                                      !DSJW
6002: 88d2:            LOCAL.SPACE$ EQ PACK$("00000000000000")                      !DSJW
6003: 88ee: 
6004: 88ee:         RETURN                                                          !DSJW
6005: 88fe: 
6006: 88fe: 
6007: 88fe: \*******************************************************************************
6008: 88fe: \***
6009: 88fe: \***   SHOW.MESSAGE:
6010: 88fe: \***
6011: 88fe: \***   IF  called from store opening  THEN
6012: 88fe: \***      Log the message in the user parameter for return
6013: 88fe: \***      RETURN
6014: 88fe: \***   ENDIF
6015: 88fe: \***
6016: 88fe: \***   IF increase/decrease flag <> "D" THEN
6017: 88fe: \***      set string data to spaces
6018: 88fe: \***      set integer data to -3 (previous output field)
6019: 88fe: \***      CALL DM.NEXTF function to position the cursor in the prev. output field
6020: 88fe: \***      IF F03.RETURN.CODE% <> 0 THEN
6021: 88fe: \***         GOTO CHAIN.OUT
6022: 88fe: \***      endif
6023: 88fe: \***   endif
6024: 88fe: \***
6025: 88fe: \***   set string data to spaces
6026: 88fe: \***   set integer data to 0
6027: 88fe: \***   CALL DM.POSF function to obtain the number of the current field
6028: 88fe: \***   IF F03.RETURN.CODE% <> 0 THEN
6029: 88fe: \***      GOTO CHAIN.OUT
6030: 88fe: \***   endif
6031: 88fe: \***
6032: 88fe: \***   set string data to spaces
6033: 88fe: \***   set integer data to 20 (last input field)
6034: 88fe: \***   CALL DM.NEXTF function to position the cursor in the last input field
6035: 88fe: \***   IF F03.RETURN.CODE% <> 0 THEN
6036: 88fe: \***      GOTO CHAIN.OUT
6037: 88fe: \***   endif
6038: 88fe: \***
6039: 88fe: \***   set key pressed to 999
6040: 88fe: \***
6041: 88fe: \***   WHILE key pressed is not ESC
6042: 88fe: \***
6043: 88fe: \***      CALL EXTERNAL.MESSAGE function to display message number disp.mess.
6044: 88fe: \***                                         return to current field
6045: 88fe: \***      IF F04.RETURN.CODE% <> 0 THEN
6046: 88fe: \***         GOTO CHAIN.OUT
6047: 88fe: \***      endif
6048: 88fe: \***
6049: 88fe: \***      set string data to spaces
6050: 88fe: \***      set integer data to 20 (last input field)
6051: 88fe: \***      CALL DM.NEXTF function to position the cursor in the last input field
6052: 88fe: \***      IF F03.RETURN.CODE% <> 0 THEN
6053: 88fe: \***         GOTO CHAIN.OUT
6054: 88fe: \***      endif
6055: 88fe: \***
6056: 88fe: \***      set string data to spaces
6057: 88fe: \***      set integer data to 0
6058: 88fe: \***      CALL DM.UPDF function to get user input
6059: 88fe: \***      IF F03.RETURN.CODE% <> 0 THEN
6060: 88fe: \***         GOTO CHAIN.OUT
6061: 88fe: \***      endif
6062: 88fe: \***
6063: 88fe: \***   WEND
6064: 88fe: \***
6065: 88fe: \***   RETURN
6066: 88fe: \***
6067: 88fe: \...............................................................................
6068: 88fe: 
6069: 88fe:    SHOW.MESSAGE:
6070: 890e: 
6071: 890e:       IF PSBCHN.APP = "PSB51"  THEN BEGIN                               !DSJW
6072: 892c:          PSBCHN.U2 = PSBCHN.U2 + RIGHT$(STR$(1000+MESSAGE.NO%),3) + \   !DSJW
6073: 8985:                         VARIABLE.STRING$ + "   "                        !DSJW
6074: 8985:          KEY.PRESSED% = 999                                             !DSJW
6075: 8993:          RETURN
6076: 89a3:       ENDIF                                                             !DSJW
6077: 89ab: 
6078: 89ab:       IF INC.DEC$ <> "D" THEN BEGIN                                     !DSJW
6079: 89c6:          STRING.DATA$ = ""                                              !DSJW
6080: 89db:          INTEGER.DATA% = -3                                             !DSJW
6081: 89e9:          RC% EQ DM.NEXTF(STRING.DATA$,INTEGER.DATA%)                    !DSJW
6082: 8a0c:          IF RC% NE 0 THEN GOTO CHAIN.OUT                                !DSJW
6083: 8a21:       ENDIF                                                             !DSJW
6084: 8a29: 
6085: 8a29:       STRING.DATA$ = ""
6086: 8a3e:       INTEGER.DATA% = 0
6087: 8a4c:       RC% EQ DM.POSF(STRING.DATA$,INTEGER.DATA%)                       !DJSW
6088: 8a6f:       IF RC% NE 0 THEN BEGIN                                           !DSJW
6089: 8a81:          GOTO CHAIN.OUT                                                !DSJW
6090: 8a8e:       ENDIF ELSE BEGIN                                                 !DSJW
6091: 8a96:          CURRENT.FIELD% = F03.RETURNED.INTEGER%
6092: 8aa8:       ENDIF                                                            !DSJW
6093: 8ab0: 
6094: 8ab0:       STRING.DATA$ = ""
6095: 8ac5:       INTEGER.DATA% = 20
6096: 8ad3:       RC% EQ DM.NEXTF(STRING.DATA$,INTEGER.DATA%)                       !DJSW
6097: 8af6:       IF RC% NE 0 THEN GOTO CHAIN.OUT                                   !DSJW
6098: 8b0b: 
6099: 8b0b:       KEY.PRESSED% = 999
6100: 8b19: 
6101: 8b19:       WHILE KEY.PRESSED% <> ESCAPE%
6102: 8b24: 
6103: 8b24:          RETURN.FIELD% = CURRENT.FIELD%
6104: 8b32:          RC% EQ EXTERNAL.MESSAGE (MESSAGE.NO%,VARIABLE.STRING$,         \DSJW
6105: 8b59:                                   RETURN.FIELD%)                        !DSJW
6106: 8b59:          IF RC% NE 0 THEN GOTO CHAIN.OUT                                !DSJW
6107: 8b6e: 
6108: 8b6e:          STRING.DATA$ = ""
6109: 8b83:          INTEGER.DATA% = 20
6110: 8b91:          RC% EQ DM.NEXTF(STRING.DATA$,INTEGER.DATA%)                    !DJSW
6111: 8bb4:          IF RC% NE 0 THEN GOTO CHAIN.OUT                                !DSJW
6112: 8bc9: 
6113: 8bc9:          STRING.DATA$ = ""
6114: 8bde:          INTEGER.DATA% = 0
6115: 8bec:          RC% EQ DM.UPDF(STRING.DATA$,INTEGER.DATA%)                     !DJSW
6116: 8c0f:          IF RC% NE 0 THEN GOTO CHAIN.OUT                                !DSJW
6117: 8c24:          KEY.PRESSED% = F03.RETURNED.INTEGER%
6118: 8c36: 
6119: 8c36:       WEND
6120: 8c4a: 
6121: 8c4a:       KEY.PRESSED% = 999
6122: 8c58: 
6123: 8c58:    RETURN
6124: 8c68: 
6125: 8c68: \******************************************************************************
6126: 8c68: \***
6127: 8c68: \***    RESTORE.MESSAGE:
6128: 8c68: \***
6129: 8c68: \***    IF NOT called from store opening THEN
6130: 8c68: \***    BEGIN
6131: 8c68: \***            Display message 273 ! RPD price changes are being effected
6132: 8c68: \***    ENDIF
6133: 8c68: \***
6134: 8c68: \***    RETURN
6135: 8c68: \***
6136: 8c68: \..............................................................................
6137: 8c68: 
6138: 8c68:       RESTORE.MESSAGE:                                                  ! BMW
6139: 8c78: 
6140: 8c78:       IF PSBCHN.APP <> "PSB51" THEN                                     \ BMW
6141: 8c99:       BEGIN                                                             ! BMW
6142: 8c99:          STRING.DATA$ = ""                                              ! BMW
6143: 8cae:          INTEGER.DATA% = 107                                            ! BMW
6144: 8cbc:          RC% EQ DM.POSF(STRING.DATA$,INTEGER.DATA%)                     !DJSW
6145: 8cdf:          IF RC% NE 0 THEN GOTO CHAIN.OUT                                !DSJW
6146: 8cf4:          MESSAGE.NO% = 273                                              ! BMW
6147: 8d02:          VARIABLE.STRING$ = ""                                          ! BMW
6148: 8d17:          RETURN.FIELD% = F03.RETURNED.INTEGER%                          ! BMW
6149: 8d29:          RC% EQ EXTERNAL.MESSAGE (MESSAGE.NO%,                          \DSJW
6150: 8d50:                                   VARIABLE.STRING$,                     \DSJW
6151: 8d50:                                   RETURN.FIELD%)                        !DSJW
6152: 8d50:          IF RC% NE 0 THEN GOTO CHAIN.OUT                                !DSJW
6153: 8d65:       ENDIF                                                             ! BMW
6154: 8d6d: 
6155: 8d6d:       RETURN                                                            ! BMW
6156: 8d7d: 
6157: 8d7d: \*******************************************************************************
6158: 8d7d: \***
6159: 8d7d: \***   FILE.ERROR:
6160: 8d7d: \***
6161: 8d7d: \***   set string file to STR$ of current session number, length 2 bytes
6162: 8d7d: \***
6163: 8d7d: \***   IF fail type is "O" THEN
6164: 8d7d: \***      set message number to 501
6165: 8d7d: \***   ELSE
6166: 8d7d: \***      IF fail type is "R" THEN
6167: 8d7d: \***         set message number to 503
6168: 8d7d: \***      ELSE
6169: 8d7d: \***         IF fail type is "C" THEN
6170: 8d7d: \***            set message number to 505
6171: 8d7d: \***         ELSE
6172: 8d7d: \***            set message number to 504
6173: 8d7d: \***
6174: 8d7d: \***   set string session number to CHR$ of current session number
6175: 8d7d: \***   set variable string 1 to fail type and string session number and key
6176: 8d7d: \***   set variable string 2 to string file
6177: 8d7d: \***
6178: 8d7d: \***   IF  called from store opening
6179: 8d7d: \***     AND not an IDF or IRF read error THEN
6180: 8d7d: \***      Save error in user parameter 2
6181: 8d7d: \***      Set batch/screen flag to batch and to suppress screen message
6182: 8d7d: \***   endif
6183: 8d7d: \***
6184: 8d7d: \***   CALL APPLICATION.LOG function to log event 106, message number
6185: 8d7d: \***   as indicated
6186: 8d7d: \***
6187: 8d7d: \***   Reset batch/screen flag to screen
6188: 8d7d: \***
6189: 8d7d: \***   RETURN
6190: 8d7d: \***
6191: 8d7d: \...............................................................................
6192: 8d7d: 
6193: 8d7d:    FILE.ERROR:
6194: 8d8d: 
6195: 8d8d:       SB.ACTION$ = "R"                                                 ! BMW
6196: 8da2:       SB.INTEGER% = CURRENT.SESS.NUM%                                  ! BMW
6197: 8db0:       GOSUB SB.FILE.UTILS                                              ! BMW
6198: 8dc2: 
6199: 8dc2:       VAR.STRING.2$ = RIGHT$ ("000" + F20.STRING.FILE.NO$,3) +         \
6200: 8e16:                       UNPACK$(CURRENT.KEY$)
6201: 8e16: 
6202: 8e16:       IF MESSAGE.NO% = 513 THEN VAR.STRING.2$ = "" ! B513 has no data  ! 1.19 RC
6203: 8e33: 
6204: 8e33:       IF FAIL.TYPE$ = "O" THEN \
6205: 8e4e:           BEGIN                                                        ! 1.19 RC
6206: 8e4e:           IF MESSAGE.NO% <> 513 THEN \ ! Access conflict opening PPFI  ! 1.19 RC
6207: 8e5e:               BEGIN                                                    ! 1.19 RC
6208: 8e5e:               MESSAGE.NO% = 501
6209: 8e6c:               ENDIF                                                    ! 1.19 RC
6210: 8e77:           ENDIF \                                                      ! 1.19 RC
6211: 8e77:       ELSE \
6212: 8e7f:           IF FAIL.TYPE$ = "R" THEN \
6213: 8e9a:               BEGIN                                                    ! 1.19 RC
6214: 8e9a:               MESSAGE.NO% = 503
6215: 8eaa:               ENDIF \                                                  ! 1.19 RC
6216: 8eaa:           ELSE \
6217: 8eb2:               IF FAIL.TYPE$ = "C" THEN \
6218: 8ecd:                   BEGIN                                                ! 1.19 RC
6219: 8ecd:                   MESSAGE.NO% = 505
6220: 8edd:                   ENDIF \                                              ! 1.19 RC
6221: 8edd:               ELSE \
6222: 8ee5:                   BEGIN                                                ! 1.19 RC
6223: 8ee5:                   MESSAGE.NO% = 504
6224: 8ef3:                   ENDIF                                                ! 1.19 RC
6225: 8efb: 
6226: 8efb:       VAR.STRING.1$ = FAIL.TYPE$ + CHR$(SHIFT(SB.FILE.REP.NUM%,8)) \    !DSJW
6227: 8f8c:                                  + CHR$(SHIFT(SB.FILE.REP.NUM%,0)) \    !DSJW
6228: 8f8c:                                  + RIGHT$(PACK$("00000000000000") \     !DSJW
6229: 8f8c:                                  + CURRENT.KEY$,7)                      !DSJW
6230: 8f8c:       EVENT.NO% = 106                                                   !DSJW
6231: 8f99: 
6232: 8f99:       IF PSBCHN.APP = "PSB51" THEN                                      \
6233: 8fb7:          PSBCHN.U2 = PSBCHN.U2 + RIGHT$(STR$(1000+MESSAGE.NO%),3)       \
6234: 900c:                                + VAR.STRING.1$                         :\
6235: 900c:          BATCH.SCREEN.FLAG$ = "B"
6236: 9023: 
6237: 9023:       RC% EQ APPLICATION.LOG (MESSAGE.NO%,VAR.STRING.1$,                \DSJW
6238: 9053:                               VAR.STRING.2$,EVENT.NO%)                  !DSJW
6239: 9053: 
6240: 9053:       BATCH.SCREEN.FLAG$ = "S"
6241: 906a: 
6242: 906a:       IF SELECTION$ = "" THEN \ ! File error occured on B7201 menu     ! 1.19 RC
6243: 9085:           BEGIN                 ! screen prior to selecting any option ! 1.19 RC
6244: 9085:           RETURN                ! so bypass RESTORE.MESSAGE (used to   ! 1.19 RC
6245: 9095:           ENDIF                 ! re-displays B273 for other screens)  ! 1.19 RC
6246: 909d:       
6247: 909d:       GOSUB RESTORE.MESSAGE                                            ! BMW
6248: 90af:    
6249: 90af:    RETURN
6250: 90bf: 
6251: 90bf: \******************************************************************************
6252: 90bf: \***
6253: 90bf: \***   ALLOCATE.SESS.NUMS:
6254: 90bf: \***
6255: 90bf: \***      Allocate all file session numbers
6256: 90bf: \***
6257: 90bf: \******************************************************************************
6258: 90bf: 
6259: 90bf:        ALLOCATE.SESS.NUMS:                                             !  BMW
6260: 90cf: 
6261: 90cf:        SB.ACTION$ = "O"                                                !  BMW
6262: 90e4: 
6263: 90e4:        SB.INTEGER% = IDF.REPORT.NUM%                                   !  BMW
6264: 90f6:        SB.STRING$ = IDF.FILE.NAME$                                     !  BMW
6265: 9112:        GOSUB SB.FILE.UTILS                                             !  BMW
6266: 9124:        IDF.SESS.NUM% = SB.FILE.SESS.NUM%                               !  BMW
6267: 9136: 
6268: 9136:        SB.INTEGER% = IEF.REPORT.NUM%                                   !  BMW
6269: 9148:        SB.STRING$ = IEF.FILE.NAME$                                     !  BMW
6270: 9164:        GOSUB SB.FILE.UTILS                                             !  BMW
6271: 9176:        IEF.SESS.NUM% = SB.FILE.SESS.NUM%                               !  BMW
6272: 9188: 
6273: 9188:        SB.INTEGER% = IRF.REPORT.NUM%                                   !  BMW
6274: 919a:        SB.STRING$ = IRF.FILE.NAME$                                     !  BMW
6275: 91b6:        GOSUB SB.FILE.UTILS                                             !  BMW
6276: 91c8:        IRF.SESS.NUM% = SB.FILE.SESS.NUM%                               !  BMW
6277: 91da: 
6278: 91da:        SB.INTEGER% = PPFI.REPORT.NUM%                                  !  BMW
6279: 91ec:        SB.STRING$ = PPFI.FILE.NAME$                                    !  BMW
6280: 9208:        GOSUB SB.FILE.UTILS                                             !  BMW
6281: 921a:        PPFI.SESS.NUM% = SB.FILE.SESS.NUM%                              !  BMW
6282: 922c: 
6283: 922c:        SB.INTEGER% = PPFO.REPORT.NUM%                                  !  BMW
6284: 923e:        SB.STRING$ = PPFO.FILE.NAME$                                    !  BMW
6285: 925a:        GOSUB SB.FILE.UTILS                                             !  BMW
6286: 926c:        PPFO.SESS.NUM% = SB.FILE.SESS.NUM%                              !  BMW
6287: 927e: 
6288: 927e:        SB.INTEGER% = LOCAL.REPORT.NUM%                                  !DSJW
6289: 9290:        SB.STRING$ = LOCAL.FILE.NAME$                                    !DSJW
6290: 92ac:        GOSUB SB.FILE.UTILS                                              !DSJW
6291: 92be:        LOCAL.SESS.NUM% = SB.FILE.SESS.NUM%                              !DSJW
6292: 92d0: 
6293: 92d0:        RETURN                                                          !  BMW
6294: 92e0: 
6295: 92e0: \******************************************************************************
6296: 92e0: \***
6297: 92e0: \***    DEALLOCATE.SESS.NUMS:
6298: 92e0: \***
6299: 92e0: \***    Deallocate all file session numbers
6300: 92e0: \***
6301: 92e0: \******************************************************************************
6302: 92e0: 
6303: 92e0:          DEALLOCATE.SESS.NUMS:                                         ! BMW
6304: 92f0: 
6305: 92f0:          SB.ACTION$ = "C"                                              ! BMW
6306: 9305:          SB.STRING$ = ""                                               ! BMW
6307: 931a: 
6308: 931a:          SB.INTEGER% = PPFI.SESS.NUM%                                  ! BMW
6309: 932c:          GOSUB SB.FILE.UTILS                                           ! BMW
6310: 933e: 
6311: 933e:          SB.INTEGER% = IRF.SESS.NUM%                                   ! BMW
6312: 9350:          GOSUB SB.FILE.UTILS                                           ! BMW
6313: 9362: 
6314: 9362:          SB.INTEGER% = IDF.SESS.NUM%                                   ! BMW
6315: 9374:          GOSUB SB.FILE.UTILS                                           ! BMW
6316: 9386: 
6317: 9386:          SB.INTEGER% = IEF.SESS.NUM%                                   ! BMW
6318: 9398:          GOSUB SB.FILE.UTILS                                           ! BMW
6319: 93aa: 
6320: 93aa:          SB.INTEGER% = PPFO.SESS.NUM%                                  ! BMW
6321: 93bc:          GOSUB SB.FILE.UTILS                                           ! BMW
6322: 93ce: 
6323: 93ce:          SB.INTEGER% = LOCAL.SESS.NUM%                                  !DSJW
6324: 93e0:          GOSUB SB.FILE.UTILS                                            !DSJW
6325: 93f2: 
6326: 93f2:          RETURN                                                        ! BMW
6327: 9402: 
6328: 9402: \******************************************************************************
6329: 9402: \***
6330: 9402: \***   SB.FILE.UTILS:
6331: 9402: \***
6332: 9402: \***      Allocate/report/de-allocate a file session number
6333: 9402: \***
6334: 9402: \***      Parameters : 2 or 3 (depending on action)
6335: 9402: \***
6336: 9402: \***         SB.ACTION$  = "O" for allocate file session number
6337: 9402: \***                       "R" for report file session number
6338: 9402: \***                       "C" for de-allocate file session number
6339: 9402: \***
6340: 9402: \***         SB.INTEGER% = file reporting number for action "O" or
6341: 9402: \***                       file session number for actions "R" or "C"
6342: 9402: \***
6343: 9402: \***         SB.STRING$  = logical file name for action "O" or
6344: 9402: \***                       null ("") for action "R" and "C"
6345: 9402: \***
6346: 9402: \***      Output : 1 or 2 (depending on action)
6347: 9402: \***
6348: 9402: \***         SB.FILE.NAME$     = logical file name for action "R"
6349: 9402: \***
6350: 9402: \***         SB.FILE.SESS.NUM% = file session number for action "O" or
6351: 9402: \***                             undefined for action "C"
6352: 9402: \***         OR
6353: 9402: \***         SB.FILE.REP.NUM%  = file reporting number for action "R" or
6354: 9402: \***                             undefined for action "C"
6355: 9402: \***
6356: 9402: \******************************************************************************
6357: 9402: 
6358: 9402:        SB.FILE.UTILS:                                                   ! BMW
6359: 9412: 
6360: 9412:        RC% EQ SESS.NUM.UTILITY(SB.ACTION$,SB.INTEGER%,SB.STRING$)       !DSJW
6361: 943d:        IF RC% NE 0 THEN GOTO CHAIN.OUT                                  !DSJW
6362: 9452: 
6363: 9452:        IF SB.ACTION$ = "O" THEN                                         \ BMW
6364: 946d:           SB.FILE.SESS.NUM% = F20.INTEGER.FILE.NO%                      ! BMW
6365: 947f: 
6366: 947f:        IF SB.ACTION$ = "R" THEN                                         \ BMW
6367: 949a:           SB.FILE.REP.NUM% = F20.INTEGER.FILE.NO%                      :\ BMW
6368: 94ac:           SB.FILE.NAME$ = F20.FILE.NAME$                                ! BMW
6369: 94c8: 
6370: 94c8:        RETURN                                                           ! BMW
6371: 94d8: 
6372: 94d8: \*******************************************************************************
6373: 94d8: \***
6374: 94d8: \***   ERROR.DETECTED:
6375: 94d8: \***
6376: 94d8: \***      IF ERR is "*I" and ERRN is 80F3400C THEN
6377: 94d8: \***         GOTO CREATE.ERROR
6378: 94d8: \***      endif
6379: 94d8: \***
6380: 94d8: \***      IF ERR is "CM" or "CT"                    \REM chain failure
6381: 94d8: \***         CALL APPLICATION.LOG function to log event 18, message number 553
6382: 94d8: \***      endif
6383: 94d8: \***
6384: 94d8: \***      Call STANDARD ERROR DETECTED
6385: 94d8: \***
6386: 94d8: \***      resume
6387: 94d8: \***
6388: 94d8: \***   END
6389: 94d8: \***
6390: 94d8: \..............................................................................
6391: 94d8: 
6392: 94d8:    ERROR.DETECTED:
6393: 94e8: 
6394: 94e8:     IF ERR = "NP" THEN BEGIN                                           ! 1.20 RC
6395: 9511:         PSBCHN.OP     = "99999999"                                     ! 1.20 RC
6396: 9528:         PSBCHN.APP    = "PSB50"                                        ! 1.20 RC
6397: 953f:         PSBCHN.MENCON = "421100"                                       ! 1.20 RC
6398: 9556:         PSBCHN.U1     = ""                                             ! 1.20 RC
6399: 956d:         PSBCHN.U2     = ""                                             ! 1.20 RC
6400: 9584:         PSBCHN.U3     = ""                                             ! 1.20 RC
6401: 959b:         RESUME RESUME.FROM.NP.ERROR                                    ! 1.20 RC
6402: 95b2:     ENDIF                                                              ! 1.20 RC
6403: 95ba:     
6404: 95ba:       IF    ERR = "*I" \                                               ! 1.19 RC
6405: 962b:         AND ERRN = 80F3400CH \                ! Access conflict        ! 1.19 RC
6406: 962b:         AND ERRF% = PPFI.SESS.NUM% THEN BEGIN ! opening PPFI           ! 1.19 RC
6407: 962b:           MESSAGE.NO% = 513     ! Message number used in FILE.ERROR    ! 1.19 RC
6408: 9639:           GOSUB OPEN.PPFI.ERROR ! to indicate PPFI access conflict     ! 1.19 RC
6409: 964b:       ENDIF                                                            ! 1.19 RC
6410: 9653:       
6411: 9653:       IF ERR = "*I" AND ERRN = 80F3400CH THEN BEGIN                     !DSJW
6412: 96a4:          GOTO CREATE.ERROR
6413: 96af:       ENDIF                                                             !DSJW
6414: 96b7: 
6415: 96b7:       IF ERR = "CM" OR ERR = "CT" THEN BEGIN                            !DSJW
6416: 9719:          VAR.STRING.1$ = "B72  B50  "                                   !DSJW
6417: 972e:          VAR.STRING.2$ = "PSB50" + "     "                              !DSJW
6418: 974a:          MESSAGE.NO% = 553                                              !DSJW
6419: 9758:          EVENT.NO% = 18                                                 !DSJW
6420: 9765:          IF PSBCHN.APP = "PSB51" THEN                                   \DSJW
6421: 9783:          BEGIN                                                          !DSJW
6422: 9783:             PSBCHN.U2 = PSBCHN.U2 + "553" + VAR.STRING.2$               !DSJW
6423: 97b0:             BATCH.SCREEN.FLAG$ = "B"                                    !DSJW
6424: 97c7:          ENDIF                                                          !DSJW
6425: 97cf:          RC% EQ APPLICATION.LOG (MESSAGE.NO%,VAR.STRING.1$,             \DSJW
6426: 97ff:                                  VAR.STRING.2$,EVENT.NO%)               !DSJW
6427: 97ff:          BATCH.SCREEN.FLAG$ = "S"                                       !DSJW
6428: 9816:       ENDIF                                                             !DSJW
6429: 981e: 
6430: 981e:       RC% EQ STANDARD.ERROR.DETECTED(ERRN,ERRF%,ERRL,ERR)               !DSJW
6431: 9852: 
6432: 9852:       RESUME                                                            ! BMW
6433: 986e: 
6434: 986e:    END
6435: 986e: 
6436: 986e: End of Compilation
