\***********************************************************************
\*
\*            PROGRAM         :       XRESTORE
\*            MODULE          :       XREST000
\*            AUTHOR          :       Jaya Kumar Inbaraj
\*            DATE WRITTEN    :       Mar 2014
\*
\***********************************************************************

\***********************************************************************
\*
\* Program: XRESTORE          Jaya Kumar Inbaraj              04/03/2014
\*
\* FOD260 - Enhanced Backup and Recovery
\*
\* This program displays user friendly screens and allows the user to
\* restore both drives OR single drive OR a single directory OR a
\* single file. This program will only restore on the Acting Master
\* & File Server.
\*
\* For Drive restore, the program checks the existence of BKPFAIL and
\* displays the number of available backup dates. Using available
\* Backup dates, the drive restoration process will be proceeded.
\*
\* For Directory restore, the available directory will be shown from
\* BKPSCRPT file. Then selected directory will be checked in XDISKIMG
\* or XDISKALT (If C:/ADX_UPGM/ is selected, CUPGM.* will be searched)
\* and all the available days will be displayed in the next screen.
\* Using available backup dates, the directory restoration process
\* will be proceeded.
\*
\* For File restore, name of the complete file will be taken as an
\* input. Then the directory of the file will be checked, similar as
\* above directory search. All the available dates will be displayed.
\* ADXUNZIP will be used for File Restore as it has option to extract
\* single file from ZIP archive.
\*
\* Refer BKPSCRPT.TXT for all the available directories eligible
\* under restore.
\*
\* SCRIPT FILE
\* ===========
\* BKPSCRPT file would be in following record format:
\*
\*      COMMAND          REQUIRED VALUES FOLLOWING
\*      -------          -------------------------
\*      TIME RANGE       START TIME     END TIME
\*      DAYS TO KEEP     NO. OF DAYS
\*      BACKUP           DIRECTORY      PRIMARY     SECONDARY
\*                                      ARCHIVE     ARCHIVE
\*                                      DIRECTORY   DIRECTORY
\*      EXCLUDE          FILE NAME
\*
\* PASSED PARAMTERS N/A
\* ================
\*
\* INPUT AND OUTPUT FILES
\* ======================
\* Input files : BKPSCRPT.TXT  (Backup Script File)
\*               BKPLIST.MDD   (Backup List File)
\*               BKPFAILC.MDD  (Backup Fail File for C drive)
\*               BKPFAILD.MDD  (Backup Fail File for D drive)
\*               C:\XDISKIMG\*.* (D directories primary archive)
\*               D:\XDISKIMG\*.* (C directories primary archive)
\*               C:\XDISKALT\*.* (D directories Secondary archive)
\*               D:\XDISKALT\*.* (C directories Secondary archive)
\*
\* Output files: XRESTORE.LOG    (XRESTORE Log File)
\*               EXTRACTED FILES
\*               (e.g. Files will be restored to C:\ADX_SPGM\
\*                from CSPGM.* archive files)
\*
\*======================================================================
\*                   V E R S I O N   C O N T R O L
\* (Update STATUS.TEXT.MSG$(12) for Application Version. Consider
\*  Version H as a Base version 1.0)
\*======================================================================
\*
\* Version B               Jaya kumar Inbaraj                 18/04/2014
\* FOD260 - Enhanced Backup and Recovery
\* Updated the code with respect to the BKPLIST file function changes
\*
\* Version C               Jaya kumar Inbaraj                 29/04/2014
\* FOD260 - Enhanced Backup and Recovery
\* Updated the code with respect to Internal review comments
\*
\* Version D               Jaya kumar Inbaraj                 09/05/2014
\* FOD260 - Enhanced Backup and Recovery
\* Updated the code with respect to Application Management Team
\* review comments
\*
\* Version E               Jaya kumar Inbaraj                 14/05/2014
\* FOD260 - Enhanced Backup and Recovery
\* Updated the code with respect to Application Management Team
\* review comments
\*
\* Version F     Jaya kumar Inbaraj / Dave Constable          21/05/2014
\* FOD260 - Enhanced Backup and Recovery
\* Internal and Application Management Team review comments
\* QC671 - adjusted max directory length to 12 (from 20)
\* QC665 - added termination call to sequence to get correct message
\*
\* Version G               Jaya kumar Inbaraj                 04/06/2014
\* FOD260 - Enhanced Backup and Recovery
\* QC 653, 654, 656, 660, 662, 663, 664, 674, 675, 676
\* Text on the screen / log and the logic has been updated. Also updated
\* the corresponding screen files.
\*
\* Version H               Jaya kumar Inbaraj                 09/06/2014
\* FOD260 - Enhanced Backup and Recovery
\* Added a separate variable to detect the directory creation error in
\* File restoration.
\*
\* Version I                 Dave Constable                   05/06/2014
\* FOD260 - Enhanced Backup and Recovery changes to enable CR for
\* configurable Full backup day and code review changes
\*
\* Version J                 Dave Constable                   25/06/2014
\* FOD260 - Enhanced Backup and Recovery
\* Code review changes; alignment of file open status
\* QC824 - corrected LAN file name for slpcf to local or SUPPS fail
\*
\*       MODULE RENAMED TO XREST000.BAS AS BREACHED 64K LIMIT
\*       ORIGINAL SUB PROGRAM MOVED INTO XREST001.BAS
\*
\* Version K                 Dave Constable                   10/07/2014
\* FOD260 - Enhanced Backup and Recovery
\* CR4 - Help screen changes
\*
\* Version L                 Jaya Kumar Inbaraj               01/08/2014
\* FOD260 - Enhanced Backup and Recovery
\* QC717 and QC724 - Restoration for files in BKPFAIL has been fixed.
\*
\* Version M                 Jaya Kumar Inbaraj               23/08/2014
\* FOD260 - Enhanced Backup and Recovery
\* CR5 changes to have configuration files in both C and D drives. Also
\* BKPFAIL.MDD file has been replaced with BKPFAILC.MDD and BKPFAILD.MDD
\* to have separate BKPFAIL file for C and D drive.
\* Also worked on Internal and APPS management review comments.
\* Added an Header for easy reference on multi-modular program.
\*
\* Version N                 Jaya Kumar Inbaraj               04/09/2014
\* FOD260 - Enhanced Backup and Recovery
\* Worked on APPS management review comments.
\*
\* Version O                 Jaya Kumar Inbaraj               12/09/2014
\* QC1145 - Using ADXUNZIP for file restore.
\*
\***********************************************************************

\***********************************************************************
\*
\* Included global variables                                            !KDC
\*
\***********************************************************************
    %INCLUDE XRESTORG.J86                                               !MJK
\***********************************************************************
\*
\* Program: XRESTORE          Jaya Kumar Inbaraj              04/03/2014
\*
\* FOD260 - Enhanced Backup and Recovery
\*
\*           %INCLUDE for Global variables used in XRESTORE
\*
\*                    REFERENCE: XRESTORG.J86
\*
\*       MODULE EXTRACTED FROM ORIGINAL XRESTORE.BAS (RENAMED TO
\*       XREST000.BAS) AS BREACHED 64K LIMIT AND CRETAED AS XREST001.BAS
\*
\*======================================================================
\*                   V E R S I O N   C O N T R O L
\*======================================================================
\*
\*                            Dave Constable                  25/06/2014
\* FOD260 - Enhanced Backup and Recovery
\* Code extracted originally from single module (XRESTORE.BAS) and all
\* code change markers removed.
\* For maintenance and usage all included variables and includes are
\* also replicated here and included into both modules.
\*
\* Version B                Jaya Kumar Inbaraj                01/08/2014
\* FOD260 - Enhanced Backup and Recovery
\* Created a variable for BKPFAIL restore.
\*
\* Version C                Jaya Kumar Inbaraj                23/08/2014
\* FOD260 - Enhanced Backup and Recovery
\* CR5 changes to perform the drive restore if a drive is empty.
\* Also updated the header block comments.
\*
\* Version D                Jaya Kumar Inbaraj                12/09/2014
\* QC1145 - Added ADXUNZIP related variables
\*
\***********************************************************************

\***********************************************************************
\*
\* Included code defining file related global variables
\*
\***********************************************************************
    !-----------------------------------------------------------------!
    ! Changed the BKPLIST file variables prefix from BKPLIST to BKPLI !
    ! and hence applied the changes in whole XRESTORE program also    !
    !-----------------------------------------------------------------!
    %INCLUDE BKPLIDEC.J86    ! BKPLIST file variables
\***********************************************************************
\***********************************************************************
\*
\*    BKPLIST - Backup List File
\*
\*    %INCLUDE FOR VARIABLE DECLARATIONS
\*
\*        REFERENCE   :   BKPLIDEC.J86
\*
\*        FILE TYPE   :   Sequential
\*
\* Version A              Jaya Kumar Inbaraj              04/02/2014
\* Original version.
\*
\* Version B              Jaya Kumar Inbaraj              09/04/2014
\* FOD260 - Enhanced Backup and Recovery
\* Changed all the file function variables from BKPLIST prefix to
\* BKPLI prefix.
\*
\* Version C              Jaya Kumar Inbaraj              29/04/2014
\* FOD260 - Enhanced Backup and Recovery
\* Commented out the unused variables
\*
\* Version D              Dave Constable                  05/06/2014
\* changes for generic full and incremental backups rather than forced 
\* Sunday
\*
\***********************************************************************
\***********************************************************************

    ! Changed the File related variables from BKPLIST to BKPLI prefix   !BJK
    STRING GLOBAL                     \
\        BKPLIST.CRLF$,                \                                !CJK
        BKPLI.FILE.NAME$,             \ BKPLIST file name
        BKPLI.FILENAME$,              \ File present in BKPLIST
        BKPLI.FULL.EXIST$,            \                                 !DDC
        BKPLI.FULL.FILE.CHNG$,        \                                 !DDC
        BKPLI.INCREMENTAL.EXIST$(1),  \                                 !DDC
        BKPLI.INCREMENTAL.FILE.CHNG$(1), \                              !DDC
        BKPLI.VALUE$                                                    !DDC        

    ! Changed the File related variables from BKPLIST to BKPLI prefix   !BJK
    INTEGER*2 GLOBAL                  \
\        BKPLI.RECL%,                  \                                !CJK
        BKPLI.RECORD.NUM%,            \
        BKPLI.REPORT.NUM%,            \
        BKPLI.SESS.NUM%

    INTEGER*1 GLOBAL                  \
        BKPLIST.NO.OF.FIELDS%



\***********************************************************************
\*
\* Included code defining function related global variables
\*
\***********************************************************************
    %INCLUDE PSBF02G.J86     ! Update Date
REM\
\*******************************************************************************
\*******************************************************************************
\***
\***        INCLUDE       : UPDATE.DATE globals
\***
\***        REFERENCE     : PSBF02G.J86
\***
\***        Version A     Bruce Scriver      4th March 1986
\*** 
\***        Version B     Andrew Wedgeworth   6th July 1992
\***        Removal of return code field which no longer required.
\***
\*******************************************************************************
\*******************************************************************************

      STRING   GLOBAL F02.DATE$

      ! 1 line deleted from here                                       ! BAW

    %INCLUDE PSBF13G.J86     ! PSDATE function
REM\
\*******************************************************************************
\*******************************************************************************
\***
\***        INCLUDE       : PSDATE globals
\***
\***        REFERENCE     : PSBF13G.J86
\***
\***     VERSION A                                  Bruce Scriver  6th Mar 86             
\***            
\***     VERSION B                                  Janet Lawrence 17 Aug 90
\***     Add global to be used to indicate whether or not the function should
\***     log an event when an invalid date is passed to it.
\***
\***     VERSION C                               Andrew Wedgeworth 17 July 92
\***     Return code removed as no longer required.
\***
\*******************************************************************************
\*******************************************************************************

      STRING    GLOBAL F13.DAY$,			\
                       F13.DISPLAY.MESSAGE$		! BJAL


    %INCLUDE PSBF20G.J86     ! Session number Utility
REM\
\*******************************************************************************
\*******************************************************************************
\***
\***     %INCLUDE GLOBAL VARIABLE DEFINITIONS FOR SESS.NUM.UTILITY FUNCTION
\***
\***                       REFERENCE     : PSBF20G.J86
\*** 
\***     Version A              Bruce Scrive                   5th May 1988   
\*** 
\***     Version B              Robert Cowey                   7th May 1991
\***     Global variable F20.INTEGER.FILE.NO% changed from one byte integer
\***     to two byte integer.
\***
\***     Version D              Andrew Wedgeworth             1st July 1992
\***     F20.RETURN.CODE% removed as it is no longer required.
\***
\*******************************************************************************
\*******************************************************************************

      STRING    GLOBAL F20.FILE.NAME$,                                 \
                       F20.STRING.FILE.NO$,                            \
                       F20.TABLE.DIMENSIONED.FLAG$,                    \
                       SESS.NUM.TABLE$(1)

      INTEGER*2 GLOBAL F20.INTEGER.FILE.NO%

      ! 1 line deleted from here                                       ! DAW 

    %INCLUDE PSBF39G.J86     ! Display Manager
!******************************************************************************
!******************************************************************************
!***
!***            PROGRAM         :       PSBF39G.J86
!***
!***            DESCRIPTION     :       DISPLAY MANAGER INTERFACE
!***
!***            AUTHOR          :       Stuart William McConnachie
!***            DATE WRITTEN    :       September 2000
!***
!***        Provides a much needed and easier to use interface to
!***        IBM Display Manager.
!***
!***        Saves the user having to set up, highlight, tab between and
!***        validate fields.  Also handles the help screens and conversion
!***        of date fields to external/internal format.
!***
!******************************************************************************
!******************************************************************************
    
    STRING GLOBAL       MESSAGE$(1)
    STRING GLOBAL       VALID$(1)
    STRING GLOBAL       VISIBLE$(1)
    STRING GLOBAL       FIELD$(1)
    STRING GLOBAL       TITLE$

    INTEGER*2 GLOBAL    DM.SCREEN%
    INTEGER*2 GLOBAL    DM.FIELD%
    
    INTEGER*2 GLOBAL    HOME.KEY%
    INTEGER*2 GLOBAL    END.KEY%
    INTEGER*2 GLOBAL    PGUP.KEY%
    INTEGER*2 GLOBAL    PGDN.KEY%
    INTEGER*2 GLOBAL    TAB.KEY%
    INTEGER*2 GLOBAL    BTAB.KEY%
    INTEGER*2 GLOBAL    UP.KEY%
    INTEGER*2 GLOBAL    DOWN.KEY%
    INTEGER*2 GLOBAL    ESC.KEY%
    INTEGER*2 GLOBAL    ENTER.KEY%
    INTEGER*2 GLOBAL    INS.KEY%
    INTEGER*2 GLOBAL    PREV.KEY%
    INTEGER*2 GLOBAL    NEXT.KEY%
        
    INTEGER*2 GLOBAL    F1.KEY%
    INTEGER*2 GLOBAL    F2.KEY%
    INTEGER*2 GLOBAL    F3.KEY%
    INTEGER*2 GLOBAL    F4.KEY%
    INTEGER*2 GLOBAL    F5.KEY%
    INTEGER*2 GLOBAL    F6.KEY%
    INTEGER*2 GLOBAL    F7.KEY%
    INTEGER*2 GLOBAL    F8.KEY%
    INTEGER*2 GLOBAL    F9.KEY%
    INTEGER*2 GLOBAL    F10.KEY%
                
!******************************************************************************


    %INCLUDE PSBUSEG.J86     ! Chain Parameters
\/*********************************************************************/ PSBUSEG
\/*                                                                   */ PSBUSEG
\/* PSBUSEG.J86  -  Definitions for Chain/Use with PSB Screen Program */ PSBUSEG
\/* ----------------------------------------------------------------- */ PSBUSEG
\/*                                                                   */ PSBUSEG
\/*********************************************************************/ PSBUSEG
                                                                       ! PSBUSEG
        STRING GLOBAL  PSBCHN.PRG,      \ Program to chain to          ! PSBUSEG
                       PSBCHN.OP,       \ Operator Id                  ! PSBUSEG
                       PSBCHN.APP,      \ Program chained from         ! PSBUSEG
                       PSBCHN.MENCON,   \ Menu Control                 ! PSBUSEG
                       PSBCHN.U1,       \ User parameter               ! PSBUSEG
                       PSBCHN.U2,       \ User parameter               ! PSBUSEG
                       PSBCHN.U3        ! User parameter               ! PSBUSEG
                                                                       ! PSBUSEG
    %INCLUDE SLPCFDEC.J86    ! Sleeper control
\*****************************************************************************
\*****************************************************************************
\***
\***             %INCLUDE FOR SLEEPER CHECK FILE - FIELD DECLARATIONS
\***                                          FILE REFERENCE PARAMETERS
\***
\***                      FILE TYPE    :
\***
\***                      REFERENCE    : slpcfdeb.J86
\***
\***      Version A             Steve Windsor          8.2.93
\***
\***      Version B             Richard Foster         28.6.93
\***
\***      Version C             Mark Goode             6.03.00
\***
\***      Version D         Jaya Kumar Inbaraj               28/04/2014
\***      FOD260 - Enhanced Backup and Recovery
\***      Updated Filler variable usage has been explained. Added two
\***      variables related to SLPCF Filler variable.
\***
\*****************************************************************************
\*****************************************************************************


  STRING GLOBAL          \
    SLPCF.FILE.NAME$

  INTEGER*2 GLOBAL        \
    SLPCF.REPORT.NUM%,    \
    SLPCF.SESS.NUM%

  STRING GLOBAL              \
    SLPCF.APP.NAME$,         \ 21 bytes - Application to be started
    SLPCF.RUN.FREQUENCY$,    \ 1 byte   - d=daily, m=monthly              !BRCF
    SLPCF.DAY.NUM$,          \ 6 bytes  - blank = evry day                !BRCF
                             \            1 = sun  2 = mon                !BRCF
              \            3 = tue  4 = wed                !BRCF
              \            5 = thu  6 = fri                !BRCF
              \            7 = sat                         !BRCF
              \         OR nn = date (monthly run) up to   !BRCF
              \                 3 2-digit numbers          !BRCF
    SLPCF.RUN.TIME$,         \ 6 bytes  - time due to be started (HHMMSS) !BRCF
    SLPCF.LAST.RUN.DATE$,    \ 6 bytes  - Date last run (YYMMDD)          !BRCF
    SLPCF.FILE.PRESENT$,     \ 3 bytes  - Report number of file which must!BRCRF
                             \            be present                      !BRCF
    SLPCF.FILE.PRESENT.NAME$,\ 8 bytes  - Name of above file              !BRCF
    SLPCF.FILE.ABSENT$,      \ 3 bytes  - Report number of file which must!BRCF
                             \            not be present                  !BRCF
    SLPCF.FILE.ABSENT.NAME$, \ 8 bytes  - Name of above file              !BRCF
    SLPCF.NODE.ID$,          \ 2 bytes  - Node on which to run application!BRCF
                             \            CE = Master only                !BRCF
              \            CF = File Server only           !BRCF
              \            DE = Single only                !BRCF
              \            SM = Single and Master          !BRCF
              \            SF = Single and File Server     !BRCF
    SLPCF.SOFTS.REC$,        \ 4 bytes  - The record number on the SOFTS file !LMG
    SLPCF.FILLER$,           \ 12 bytes - Format can be xYYYYYYYYY      !DJK LMG
              \ where; If x is 1-9 then the first x characters of Y are !DJK
              \ passed to the starting application as a start parameter !DJK
              \ and a CrLf                                              !DJK
    SLPCF.PARM$              ! Value Y from SLPCF.FILLER                !DJK

  INTEGER*2 GLOBAL        \
    SLPCF.RECL%           ! Length of record

  INTEGER*1 GLOBAL        \                                             !DJK
    SLPCF.PARM.LEN%       ! Value X from SLPCF.FILLER                   !DJK

  INTEGER*4 GLOBAL        \
    SLPCF.REC.NO%         ! Record Number


\***********************************************************************
\*
\* Global variable definitions
\*
\***********************************************************************
    STRING GLOBAL                   \
        BATCH.SCREEN.FLAG$,         \
        CHAIN.TO.PROG$,             \
        MODULE.NUMBER$

    INTEGER*4 GLOBAL                \
        BKPLIST.FILE.RC%,           \
        DIR.FILE.RC%,               \
        XRE.FILE.RC%

\***********************************************************************
\*
\* Local Variables Made Global when multi-modular
\*
\***********************************************************************
    STRING GLOBAL                   \
        ADX.PARM.2$,                \
        ADXCSU0L.FILE.NAME$,        \                                   !CJK
        ADXUNZIP.FILE.NAME$,        \                                   !DJK
        ADXZUDIR.FILE.NAME$,        \
        BACKUP.DAYS$,               \
        BACKUP.LONG.DAYS$,          \
        BKP.DRIVE$,                 \                                   !CJK
        BKP.FILENAME.ALT$,          \
        BKP.FILENAME.IMG$,          \
        BKP.ZIP.FILE$,              \                                   !DJK
        BKPFAIL.CURR.FILE$,         \
        BKPFAIL.PREFIX$,            \                                   !CJK
        BKPLIST.CURR.FILE$,         \
        BKPLIST.DIR.VALUE$,         \
        BKPLIST.FIELD$(1),          \
        BKPLIST.PREFIX.C.DRIVE$,    \                                   !CJK
        BKPLIST.PREFIX.D.DRIVE$,    \                                   !CJK
        BKPLIST.VALUE$,             \
        BKPSCRPT.COMMAND$,          \
        BKPSCRPT.DIRECTORY$,        \
        BKPSCRPT.FILE.NAME$,        \
        BKPSCRPT.OUT.FILE.NAME$,    \
        C.BKP.ALT$,                 \
        C.BKP.IMG$,                 \
        CDRIVE$,                    \
        CNTLR.ID$,                  \
        COMMA.VALUE$,               \
        CONSTANT.COLON$,            \
        CONSTANT.DAY$(1),           \
        CONSTANT.FRIDAY.LONG$,      \
        CONSTANT.FRIDAY.SHORT$,     \
        CONSTANT.LONG.DAY$(1),      \
        CONSTANT.MONDAY.LONG$,      \
        CONSTANT.MONDAY.SHORT$,     \
        CONSTANT.SATURDAY.LONG$,    \
        CONSTANT.SATURDAY.SHORT$,   \
        CONSTANT.SUNDAY.LONG$,      \
        CONSTANT.SUNDAY.SHORT$,     \
        CONSTANT.THURSDAY.LONG$,    \
        CONSTANT.THURSDAY.SHORT$,   \
        CONSTANT.TUESDAY.LONG$,     \
        CONSTANT.TUESDAY.SHORT$,    \
        CONSTANT.WEDNESDAY.LONG$,   \
        CONSTANT.WEDNESDAY.SHORT$,  \
        CRLF$,                      \
        D.BKP.ALT$,                 \
        D.BKP.IMG$,                 \
        DDRIVE$,                    \
        DIR.OUT$,                   \
        DIR1.OUT$,                  \   Command pipe output file        !DJK
        DIR.VALUE$,                 \
        DIRECT.TO.RESTORE$,         \
        DRIVE$,                     \
        ERROR.MSG$,                 \
        EXTENSION$,                 \
        FAILED.FILE$,               \
        FAILED.FILE.DIST$,          \
        FILENAME$,                  \
        FIRST.FILE$,                \
        FSEL$,                      \
        FULL.DATE$,                 \
        FULL.MDD.DATE$,             \
        FULL.TO.MOVING.DATE$,       \
        FUNC.FLAG$,                 \
        MDD.DATE$,                  \
        NORMAL.SLEEPER.FILE.NAME$,  \
        OPT.HEADER$,                \
        OPT.HEADER.1$,              \
        OPT.SELECTED$,              \
        OS.DESTINATION$,            \
        OS.FILE$(1),                \
        OS.SOURCE$,                 \
        PARM.FULL$,                 \
\        PARM.INCREMENTAL$,          \                                  !CJK
        PASSED.STRING$,             \
        RESTORE.FILENAME$,          \                                   !BJK
        SCR.HEADER$,                \
        SCREEN.NUM$,                \
        SCREEN.TEXT.MSG$(1),        \
        SECOND.FILE$,               \
        SELECT.FILE.NAME$,          \
        SELECTED.FILENAME$,         \
\        SHELL.COMMAND$,             \  ! variable passed into OSSHELL  !CJK
        SLEEPER.RECORD$,            \
        STATUS.MSG$,                \
        STATUS.TEXT.ERROR$(1),      \
        STATUS.TEXT.MSG$(1),        \
        SUPPS.SLEEPER.FILE.NAME$,   \
        TEMP.DIR$,                  \
        TODAY.DATE$,                \
        USER.TEXT$,                 \
        VERSION$,                   \                                   !CJK
        WORK.DATE.MMDD$,            \
        XBACK.PIPE.NAME$,           \
        XRE.LOG.FILENAME$,          \
        XRE.NULL$,                  \
        XRE.PIPE.NAME$,             \
        XRE.SPACE$

    ! Grouping Arrays
    STRING GLOBAL                   \
        BKP.AVAIL.ARRAY$(1),        \
        BKP.DATE.ARRAY$(1),         \
        BKP.FILE.MDD.ARRAY$(1),     \
        BKP.FILE.MMDD.ARRAY$(1),    \
        BKPSCRPT.DIRECTORIES$(1),   \
        DAY.ARRAY$(1),              \
        PRIMARY.ARCHIVED.NAMES$(1), \
        SECONDARY.ARCHVD.NAMES$(1), \
        SELECTED.DIR.ARRAY$(1)

    INTEGER*1 GLOBAL                \
        ADX.FUNCTION%,              \
        BKP.INDEX%,                 \
        CNTLR.CONFIG%,              \
        CONSTANT.LONGEST.DAY%,      \
        DAY.INDEX%,                 \
        DAY.SINCE.FULL%,            \
        DAYS.AFTER.FULL.BAKUP%,     \
        DD.MM.INDEX%,               \
        DIR.INDEX%,                 \
        DIR.TO.SHOW%,               \
        DIRECTORY.CREATE,           \
        DIRECTORY.DAY.SELECT.SCR%,  \
        DIRECTORY.PROCESS.SCR%,     \
        DISPLAY.MAIN.SCR%,          \
        DRIVE.DAY.SELECT.SCR%,      \
        DRIVE.DISK.SELECT.SCR%,     \
        DRIVE.PROCESS.SCR%,         \
        ERROR.COUNT%,               \
        F.RECORD.COUNT%,            \ count for header lines in DIR
        FILE.CONFIRMATION.SCR%,     \
        FILE.DAY.SELECT.SCR%,       \
        FILE.DIR.AND.DIST.SCR%,     \
        FILE.PROCESS.SCR%,          \
        FULL.BACKUP.NOT.FOUND%,     \
        INPUT.INDEX%,               \
        MASTER.AND.FILE.SERVER%,    \
        OPT.SEL%,                   \
        PAGE.DIV%,                  \
        PAGE.NO%,                   \
        RESTORE.A.DIRECTORY.SCR%,   \
        RESTORE.A.FILE.SCR%,        \
        SCREEN%,                    \
        SCREEN.NUM%,                \
        SLEEPER.DAY%,               \
        SLPCF.OPEN,                 \
        XRE.ZERO%

    ! Grouping Boolean variables
    INTEGER*1 GLOBAL                \
        BKPLIST.OPEN,               \
        COMMAND.MODE,               \
        DIR.OPEN,                   \
        DUPLICATE.RECORD,           \                                   !CJK
        ERROR.EXIST,                \
        FALSE,                      \
        FUNCTION.ERROR.NOT.EXIST,   \
\        IN.LOG.STATUS.MSG,          \                                  !CJK
\        IN.UPDATE.DATE.RC,          \                                  !CJK
        NON.X.VALUES,               \
        PREVIOUS.KEY,               \
        RESTORE.ERR.EXIST,          \
        RESTORE.HAPPENED,           \                                   !CJK
        RESTORE.STATUS,             \
        SUPPS.ON,                   \
        TRUE,                       \
        VALUE.EXISTS,               \
        VALUE.PRESENT,              \
        XBACK.OPEN,                 \
        XRE.LOG.OPEN,               \
        XRE.OPEN

    INTEGER*2 GLOBAL                \
        ARRAY.LIMIT%,               \                                   !CJK
        BEGIN.POS%,                 \
        BEGIN.POSITION%,            \
        BKP.DAYS%,                  \
        BKPSCRPT.INDEX%,            \
        COMMA.POSITION%,            \
        DAY.LOOP%,                  \
        DD.MM.LOOP%,                \
        DIR.INPUT.INDEX%,           \
        DIR.INPUT.LOOP%,            \
        DIR.LOOP%,                  \
        FUN.RC2%,                   \ function return value for check
        INDEX%,                     \
        INPUT.LOOP%,                \
        LONG.DAY.INDEX%,            \
        LOOP%,                      \
        MATCH.POS%,                 \
        MAX.DIRECTORIES%,           \
        PASSED.INTEGER%,            \
        RET.KEY%,                   \
        SEL.INDEX%,                 \
        SEL.INPUT.LOOP%,            \
        SELECT.COUNT%,              \
        SELECT.INDEX%,              \
        SLASH.POSITION%,            \
        VALUE.INDEX%,               \
        XBACK.PIPE.REPORT.NUM%,     \
        XBACK.PIPE.SESS.NUM%,       \
        XRE.LOG.REPORT.NUM%,        \
        XRE.LOG.SESS.NUM%,          \
        XRE.PIPE.REPORT.NUM%,       \
        XRE.PIPE.SESS.NUM%

    INTEGER*4 GLOBAL                \
        ADXSERVE.RC%,               \
        FILE.RC%


\***********************************************************************
\*
\* Included external functions                                          !KDC
\*
\***********************************************************************
    %INCLUDE XRESTORE.J86                                               !MJK
\***********************************************************************
\*
\* Program: XRESTORE          Jaya Kumar Inbaraj              04/03/2014
\*
\* FOD260 - Enhanced Backup and Recovery
\*
\*           %INCLUDE for External Functions in XRESTORE
\*
\*                    REFERENCE: XRESTORE.J86
\*
\*       MODULE EXTRACTED FROM ORIGINAL XRESTORE.BAS (RENAMED TO
\*       XREST000.BAS) AS BREACHED 64K LIMIT AND CRETAED AS XREST001.BAS
\*
\*======================================================================
\*                   V E R S I O N   C O N T R O L
\*======================================================================
\*
\*                            Dave Constable                  25/06/2014
\* FOD260 - Enhanced Backup and Recovery
\* Code extracted originally from single module (XRESTORE.BAS) and all
\* code change markers removed.
\* For maintenance and usage all included externals and includes are
\* also replicated here and included into both modules.
\*
\* Version B                Jaya Kumar Inbaraj                23/08/2014
\* FOD260 - Enhanced Backup and Recovery
\* Updated the Header block comments
\*
\* Version C                Jaya Kumar Inbaraj                04/09/2014
\* FOD260 - Enhanced Backup and Recovery
\* Updated the C file function names
\*
\***********************************************************************

\***********************************************************************
\*
\* Included code defining file related global variables
\*
\***********************************************************************

\***********************************************************************
\*
\* Included code defining function related external functions
\*
\***********************************************************************
    %INCLUDE PSBF02E.J86     ! Update Date
REM\
\*******************************************************************************
\*******************************************************************************
\***
\***        INCLUDE       : UPDATE.DATE external definition
\***        AUTHOR        : Bruce Scriver (Basic Code)
\***        DATE WRITTEN  : 4th March 1986 (Basic Code)
\***
\***        REFERENCE     : PSBF02E.J86
\***
\***        Version A     Bruce Scriver          4th March 1986
\***
\***        Version B     Andrew Wedgeworth       6th July 1992
\***        Removal of redundant parameters, and inclusion of UPDATE.DATE as
\***        a variable to hold the return code.
\***
\*******************************************************************************
\*******************************************************************************

   FUNCTION UPDATE.DATE (INCREMENT%)                                   \
   EXTERNAL
   ! 3 parameters removed from here                                    ! BAW

   ! 3 lines deleted from here                                         ! BAW
   
      INTEGER*2 UPDATE.DATE                                            ! BAW

      INTEGER*4 INCREMENT%

   END FUNCTION

    %INCLUDE PSBF13E.J86     ! PSDATE function
REM\
\*******************************************************************************
\*******************************************************************************
\***
\***        INCLUDE       : PSDATE external definition
\***
\***        REFERENCE     : PSBF13E.J86
\***
\***        Version A     Bruce Scriver                6th March 1986
\*** 
\***        Version B     Andrew Wedgeworth            17th July 1992  
\***        Redundant parameters removed and PSDATE defined as a variable
\***        to hold the return code. 
\***
\*******************************************************************************
\*******************************************************************************

   FUNCTION PSDATE (INPUT.DATE$)                                               \
   EXTERNAL

     STRING    INPUT.DATE$                                                   
   
     INTEGER*2 PSDATE 

   END FUNCTION

    %INCLUDE PSBF20E.J86     ! Session number utility
REM\
\*******************************************************************************
\*******************************************************************************
\***
\***       %INCLUDE FOR EXTERNAL DEFINITION OF SESS.NUM.UTILITY
\***
\***                  REFERENCE     : PSBF20E.J86
\***
\***     VERSION C            Janet Smith                13th May 1992
\***     Increased PASSED.INTEGER to 2 bytes to cater for more than
\***     128 files.
\***
\***     VERSION D.           Andrew Wedgeworth          1st July 1992
\***     Removal of redundant parameters and addition of SESS.NUM.UTILITY
\***     as a variable.  This new variable contains the function's return
\***     code.
\***
\*******************************************************************************
\*******************************************************************************

   FUNCTION SESS.NUM.UTILITY (FUNCTION.FLAG$,                          \
                              PASSED.INTEGER%,                         \
                              PASSED.STRING$)                          \
   EXTERNAL

   STRING    FUNCTION.FLAG$,                                           \
             PASSED.STRING$
   ! 3 variables removed from here                                     ! CAW


   INTEGER*2 SESS.NUM.UTILITY,                                         \ CAW
             PASSED.INTEGER%				               ! CJAS

   END FUNCTION

    %INCLUDE PSBF24E.J86     ! Standard error detected
REM \
\*******************************************************************************
\*******************************************************************************
\***
\***    %INCLUDE FOR EXTERNAL DEFINITION OF STANDARD.ERROR.DETECTED FUNCTION
\***
\***                      REFERENCE     : PSBF24E.J86
\***
\***    Version A                 Janet Smith                  13th May 1992
\***
\*******************************************************************************
\*******************************************************************************

   FUNCTION STANDARD.ERROR.DETECTED(ERRN%,                 \
				    ERRFILE%,              \
				    ERRL%,                 \
				    ERR$)        EXTERNAL
				    
          STRING    ERR$

          INTEGER*2 ERRFILE%,              \
	            ERRL%,                 \
		    STANDARD.ERROR.DETECTED
		    
          INTEGER*4 ERRN%
	  		    
   END FUNCTION


    %INCLUDE PSBF39E.J86     ! Display Manager
!******************************************************************************
!******************************************************************************
!***
!***            PROGRAM         :       PSBF39E.J86
!***
!***            DESCRIPTION     :       DISPLAY MANAGER INTERFACE
!***
!***            AUTHOR          :       Stuart William McConnachie
!***            DATE WRITTEN    :       September 2000
!***
!***        Provides a much needed and easier to use interface to
!***        IBM Display Manager.
!***
!***        Saves the user having to set up, highlight, tab between and
!***        validate fields.  Also handles the help screens and conversion
!***        of date fields to external/internal format.
!***
!******************************************************************************
!******************************************************************************

!******************************************************************************
!   Initialises the display manager functions.
!   You should call this from your program initialisation for screen programs.
!   Note that the name of the display manager file is determined from the
!   global variable MODULE.NUMBER$.  For example PSB1200 uses PSBD12.dat
!   where the PSB and 12 have been derived from MODULE.NUMBER$.

    FUNCTION DM.INIT EXTERNAL
        INTEGER*1   DM.INIT
    END FUNCTION

!******************************************************************************
!   Quits the display manager program and frees resources.
!   You should call this from your program termination.

    FUNCTION DM.QUIT EXTERNAL
        INTEGER*1   DM.QUIT
    END FUNCTION

!******************************************************************************
!   Initialises a particular screen from the current display manager file
!   for display.  You supply the screen number, optional title message and
!   the first and last help screens associated with the display.
!   Once you have SHOWN a screen, you can use the remaining functions in
!   this library to set field values, and actually retrieve input from the
!   screen.  Note that showing a screen just displays it on the screen,
!   you need to call PROCESS.SCREEN to actually get any user input.

    FUNCTION DM.SHOW.SCREEN (SCREEN%, TITLE$, FIRST.HELP%, LAST.HELP%) EXTERNAL
        INTEGER*1   DM.SHOW.SCREEN
        INTEGER*2   SCREEN%
        STRING      TITLE$
        INTEGER*2   FIRST.HELP%
        INTEGER*2   LAST.HELP%
    END FUNCTION

!******************************************************************************
!   Sets a function key message to visible.  Optionally sets the text on that
!   key to the message string passed, if it is not null.
!   Note you must have shown a screen first, and that the function key fields
!   need to be defined in your display file with field IDs 241-250.

    FUNCTION DM.SHOW.FN.KEY (KEY.NUM%, MESSAGE$) EXTERNAL
        INTEGER*1   DM.SHOW.FN.KEY
        INTEGER*2   KEY.NUM%
        STRING      MESSAGE$
    END FUNCTION

!******************************************************************************
!   Sets a function key message to invisible.
!   Note you must have shown a screen first, and that the function key fields
!   need to be defined in your display file with field IDs 241-250.

    FUNCTION DM.HIDE.FN.KEY (KEY.NUM%) EXTERNAL
        INTEGER*1   DM.HIDE.FN.KEY
        INTEGER*2   KEY.NUM%
    END FUNCTION

!******************************************************************************
!   LEGACY: Do not use in new programs, use DM.FN.VISIBLE instead which takes
!   an infix notation expression, as opposed to reverse polish
!   This definition has been commented out accordingly.  If you are
!   recompiling an application, change to useing the new function.
!
!   FUNCTION DM.FN.KEY.VISIBLE (KEY.NUM%, EXPR$) EXTERNAL
!       INTEGER*1   DM.FN.KEY.VISIBILITY
!       INTEGER*2   KEY.NUM%
!       STRING      EXPR$
!   END FUNCTION

!******************************************************************************
!   Sets a runtine expression to determine if a function key is visible.
!   This is the new version of the above which takes an infix notation EXPR$.
!   Note you must have shown a screen first, and that the function key fields
!   need to be defined in your display file with field IDs 241-250.

    FUNCTION DM.FN.VISIBLE (KEY.NUM%, EXPR$) EXTERNAL
        INTEGER*1   DM.FN.VISIBILITY
        INTEGER*2   KEY.NUM%
        STRING      EXPR$
    END FUNCTION

!******************************************************************************
!   Specifies that a given field contains a date.
!   This means that the date will be displayed on screen in the system date
!   format (e.g. DD/MM/YY or MM/DD/YY, but will be returned and set by your
!   application in YYMMDD format.
!   It does NOT mean that the field will be validated as a date, you must do
!   that explicitly using the VALID$ string.

    FUNCTION DM.DATE.FIELD (FIELD%) EXTERNAL
        INTEGER*1   DM.DATE.FIELD
        INTEGER*2   FIELD%
    END FUNCTION

!******************************************************************************
!   Specifies that a given field will contain a time.
!   This means that the time will be displayed on screen using the system time
!   format.  e.g. HH:MM

    FUNCTION DM.TIME.FIELD (FIELD%) EXTERNAL                                !CSWM
        INTEGER*1   DM.TIME.FIELD                                           !CSWM
        INTEGER*2   FIELD%                                                  !CSWM
    END FUNCTION                                                            !CSWM

!******************************************************************************
!   Specifies that a given input field will be read only.
!   This allows you to select an item from a list by highlighting it.

    FUNCTION DM.RO.FIELD (FIELD%) EXTERNAL                                  !ESWM
        INTEGER*1   DM.RO.FIELD                                             !ESWM
        INTEGER*2   FIELD%                                                  !ESWM
    END FUNCTION                                                            !ESWM

!******************************************************************************
!   Specifies that a given input field will be read write.
!   Undoes the effect of DM.RO.FIELD.

    FUNCTION DM.RW.FIELD (FIELD%) EXTERNAL                                  !ESWM
        INTEGER*1   DM.RW.FIELD                                             !ESWM
        INTEGER*2   FIELD%                                                  !ESWM
    END FUNCTION                                                            !ESWM

!******************************************************************************
!   LEGACY: Do not use in new programs, use DM.STATUS instead which takes
!   an infix notation expression, as opposed to reverse polish.
!   This definition has been commented out accordingly.  If you are
!   recompiling an application, change to useing the new function.
!
!   FUNCTION DM.DISPLAY.MESSAGE (MESSAGE$) EXTERNAL                         !DSWM
!       INTEGER*1   DM.DISPLAY.MESSAGE                                      !DSWM
!       STRING      MESSAGE$                                                !DSWM
!   END FUNCTION                                                            !DSWM

!******************************************************************************
!   Displays a message in the status line of the display.  Does not wait for
!   input.  Use this function for display messages such as B251 Processing...
!   You must have field 1 defined in your display manager file.
!   This is the new version of the above which takes an infix notation MESSAGE$.

    FUNCTION DM.STATUS (MESSAGE$) EXTERNAL                                  !DSWM
        INTEGER*1   DM.STATUS                                               !DSWM
        STRING      MESSAGE$                                                !DSWM
    END FUNCTION                                                            !DSWM

!******************************************************************************
!   Waits for input in the invisible input field of the display.  Additionally
!   displays a message prompting the user on the status line.
!   You must have fields 1 and 240 defined in your display manager file.
!   The message supplied should be in Reverse Polish form.
!   The function returns the key value that ended the input.

    FUNCTION DM.INVISIBLE.INPUT (MESSAGE$) EXTERNAL
        STRING      MESSAGE$
        INTEGER*2   DM.INVISIBLE.INPUT
    END FUNCTION

!******************************************************************************
!   Gets the contents of the invisible field from the display.  This will
!   allow you to get the Y or N answer that the user typed, for example.

    FUNCTION DM.INVISIBLE.FIELD EXTERNAL
        STRING      DM.INVISIBLE.FIELD
    END FUNCTION

!******************************************************************************
!   Returns or sets the current field used for input on the current display.
!   If NEW.FIELD% is zero, the function simply returns the current field.
!   If NEW.FIELD% is non zero, the function sets the current field.

    FUNCTION DM.CURRENT.FIELD (NEW.FIELD%) EXTERNAL
        INTEGER*2   DM.CURRENT.FIELD
        INTEGER*2   NEW.FIELD%
    END FUNCTION

!******************************************************************************
!   Sets a key number as being a validation key.  When this key is used the
!   function will handle the key in the same way as the ENTER key.  i.e. all
!   the visible fields on in input form are check for validity, and the key
!   press is only returned to the user if the form entries are valid.
!   Use this function to add the PGUP.KEY% and PGDN.KEY% keys, for example.

    FUNCTION DM.VALIDATE.KEY (KEY%) EXTERNAL                                !BSWM
        INTEGER*1   DM.VALIDATE.KEY                                         !BSWM
        INTEGER*2   KEY%                                                    !BSWM
    END FUNCTION                                                            !BSWM

!******************************************************************************
!   Returns or sets the flag which says if the screen contents have been
!   changed or not.  Use this function when you have multiple pages to a
!   form, but want the user to be prompted to save any changes on exit.
!   When called with FLAG% set 0 or -1, the function updates the current
!   displays setting.  When called with any other value, the function simply
!   returns the current setting and does not update it.

    FUNCTION DM.CHANGED.FLAG (FLAG%) EXTERNAL                               !BSWM
        INTEGER*1   FLAG%                                                   !BSWM
        INTEGER*1   DM.CHANGED.FLAG                                         !BSWM
    END FUNCTION                                                            !BSWM

!******************************************************************************
!   Sets the field tab order.  The tab order can be either:
!   0 - The TAB order is defined by the fields position on the display,
!       left to right then top to bottom of the display.
!   1 - The TAB order is defined by the number order of the fields.  This is
!       a new option which allows greater control over the field TAB order.
!   -1  Returns the current setting without changing it.
!   The default tab order is 0.  Once set, the TAB order is a global setting
!   for the current and all future screens.

    FUNCTION DM.TAB.ORDER (ORDER%) EXTERNAL                                 !DSWM
        INTEGER*1   ORDER%                                                  !DSWM
        INTEGER*1   DM.TAB.ORDER                                            !DSWM
    END FUNCTION                                                            !DSWM

!******************************************************************************
!   This function actually processes user input on the currently shown form.
!   The function returns when any unrecognised key terminates input in a
!   field.  The keys which will do this are determined by the properties of
!   the Display Manager fields on your form.  The function internally handles
!   most of the form navigation keys (e.g. Tab, Back Tab, Home End) the
!   rest are up to the user application.

    FUNCTION DM.PROCESS.SCREEN (FIRST.FIELD%, LAST.FIELD%, CONFIRM) EXTERNAL
        INTEGER*2   DM.PROCESS.SCREEN
        INTEGER*2   FIRST.FIELD%
        INTEGER*2   LAST.FIELD%
        INTEGER*1   CONFIRM
    END FUNCTION

!******************************************************************************
!   Associates a field on the current display with a given compile time
!   variable.  This allows the varibale to be used in your program code
!   AND be updated by the display manager fields in PROCESS.SCREEN.
!
!   NOTE: PLEASE BE VERY CAREFUL WITH THE THIRD PARAMETER TO THIS SUB
!   Always use an absolute variable for VARIABLE$:
!       CALL DM.NAME (2, "MY.VAR$", MY.VAR$)
!   NEVER use a calcualted value. These forms are all ILLEGAL:
!       CALL DM.NAME (2, "MY.VAR$", "1234")
!       CALL DM.NAME (2, "MY.VAR$", STR$(MY.VAR%))
!   Also, if you MUST pass in an array element, for example:
!       CALL DM.NAME (2, "MY.VAR$", ARRAY.ELEMENT$(I%))
!   then you must make sure you do not reDIM the array until you have finished
!   displaying and processing the screen.

    SUB DM.NAME (FIELD%, NAME$, VARIABLE$) EXTERNAL                         !DSWM
        INTEGER*2 FIELD%                                                    !DSWM
        STRING NAME$                                                        !DSWM
        STRING VARIABLE$                                                    !DSWM
    END SUB                                                                 !DSWM

!******************************************************************************
!   Returns the index of a field on the current screen, given its name.

    FUNCTION DM.INDEX (FIELD$) EXTERNAL                                     !DSWM
        STRING FIELD$                                                       !DSWM
        INTEGER*2 DM.INDEX                                                  !DSWM
    END FUNCTION                                                            !DSWM

!******************************************************************************
!   Sets the validation expression for a field on the display.  Exactly the
!   same as setting the global VALID$ array yourself, except it is done
!   via the fields name as assoicated via DM.NAME.FIELD and the expression
!   is in standard infix notation.

    FUNCTION DM.VALID (FIELD$, VALID$) EXTERNAL                             !DSWM
        STRING FIELD$                                                       !DSWM
        STRING VALID$                                                       !DSWM
        INTEGER*2 DM.VALID                                                  !DSWM
    END FUNCTION                                                            !DSWM

!******************************************************************************
!   Sets the message expression for a field on the display.  Exactly the
!   same as setting the global MESSAGE$ array yourself, except it is done
!   via the fields name as assoicated via DM.NAME.FIELD and the expression
!   is in standard infix notation.

    FUNCTION DM.MESSAGE (FIELD$, MESSAGE$) EXTERNAL                         !DSWM
        STRING FIELD$                                                       !DSWM
        STRING MESSAGE$                                                     !DSWM
        INTEGER*2 DM.MESSAGE                                                !DSWM
    END FUNCTION                                                            !DSWM

!******************************************************************************
!   Sets the field attributes for a field on the display. Exactly the
!   same as using the SETF command yourself except that it is done by
!   using the fields name as associated via the DM.NAME.FIELD.

SUB DM.FLD.ATT (FIELD$, VALUE$) EXTERNAL                                    !FNWB
    STRING      FIELD$                                                      !FNWB
    STRING      VALUE$                                                      !FNWB
END SUB                                                                     !FNWB

!******************************************************************************
!   Sets an input field to act as an output only field on the display. This
!   allows setting input fields that contain headings etc. to be skipped by
!   the cursor movement keys.

FUNCTION DM.OO.FIELD (FIELD$) EXTERNAL                                      !FNWB
    INTEGER*2   DM.OO.FIELD                                                 !FNWB
    STRING      FIELD$                                                      !FNWB
END FUNCTION                                                                !FNWB

!******************************************************************************
!   Sets an input field back to an i/o field

FUNCTION DM.IO.FIELD (FIELD$) EXTERNAL                                      !FNWB
    INTEGER*2   DM.IO.FIELD                                                 !FNWB
    STRING      FIELD$                                                      !FNWB
END FUNCTION                                                                !FNWB

!******************************************************************************
!   Sets the visibility expression for a field on the display.  Exactly the
!   same as setting the global VISIBLE$ array yourself, except it is done
!   via the fields name as assoicated via DM.NAME.FIELD and the expression
!   is in standard infix notation.

    FUNCTION DM.VISIBLE (FIELD$, VISIBLE$) EXTERNAL                         !DSWM
        STRING FIELD$                                                       !DSWM
        STRING VISIBLE$                                                     !DSWM
        INTEGER*2 DM.VISIBLE                                                !DSWM
    END FUNCTION                                                            !DSWM

!******************************************************************************
!   Sets an error message in field 1 of the display and moves the input
!   focus to the offending line of the display.  Should be called from user
!   validation code.  Equivalent of the following separate calls:
!       CALL DM.CURRENT.FIELD%(DM.INDEX(FIELD$))
!       FIELD$(1) = POLISH$(MESSAGE$)
!   Can also be called with a null field name, in which case the cursor
!   remains in the current input field, but the error is displayed.

    FUNCTION DM.FOCUS (FIELD$, MESSAGE$) EXTERNAL                           !DSWM
        STRING FIELD$                                                       !DSWM
        STRING MESSAGE$                                                     !DSWM
        INTEGER*2 DM.FOCUS                                                  !DSWM
    END FUNCTION                                                            !DSWM

!******************************************************************************


    %INCLUDE DMEXTR.J86      ! IBM DISPLAY MANAGER functions
\/* TIME STAMP BLOCK **************************************************
\** END OF TIME STAMP BLOCK ******************************************/
 REM  INCLUDE FILE FOR  DISPLAY MANAGER EXTERNAL FUNCTIONS FOR CB80  June 7/82
 REM  IR91470 01 10 91  LAB G53  marked for EFT
        DEF CLRSCR EXTERNAL             REM Clear screen for Display Manager
        INTEGER CLRSCR
        FEND
        DEF CLSDIS EXTERNAL
        INTEGER CLSDIS
        FEND                            REM Close Display Manager
        DEF DISPD(I%) EXTERNAL          REM Display a display.
        INTEGER DISPD
        FEND
        DEF CURS(X$) EXTERNAL           REM turn on/off cursor visibility.
        STRING CURS
        FEND
        DEF ENDF EXTERNAL               REM ENDF method of return.
        INTEGER ENDF
        FEND
        DEF GETF EXTERNAL               REM GETF get data from a field
        STRING GETF
        FEND
        DEF INITDM(A$) EXTERNAL         REM INITIALIZE Display Manager
        INTEGER INITDM
        FEND
        DEF NXTF(I%)  EXTERNAL          REM NXTF Go to Next Field
        INTEGER NXTF
        FEND
        DEF POSF(I%) EXTERNAL           REM POSTION on Field
        INTEGER POSF
        FEND

        DEF OPNDIS(A$) EXTERNAL         REM OPEN DISPLAY FILE
        INTEGER OPNDIS
        FEND
        DEF PUTF(A$)  EXTERNAL          REM PUT data to Field
        INTEGER PUTF
        FEND
        DEF RESF(I%)  EXTERNAL          REM RESUME field
        STRING RESF
        FEND

        DEF RETDM  EXTERNAL             REM RETURN Display Mgr Characteristics
        STRING RETDM
        FEND
        DEF SETF(A$) EXTERNAL           REM SET Field  video attributes
        STRING SETF
        FEND
        DEF UPDF  EXTERNAL                      REM UPDATE Field data
        STRING UPDF
        FEND

        DEF RETF EXTERNAL
        STRING RETF
        FEND
   REM  END OF INCLUDE FILE FOR DISPLAY MANAGER CALLS FOR CB80

\***********************************************************************
\*
\* Included code defining external Boots functions
\*
\***********************************************************************
    %INCLUDE ADXCOPY.J86     ! To copy files
\******************************************************************************
\******************************************************************************
\***                                                                        ***
\***    %INCLUDE FOR SUBROUTINE ADXCOPYF (an I.B.M. system subroutine)      ***
\***                                                                        ***
\***         DATE WRITTEN  :  13th May 1988                                 ***
\***                                                                        ***
\******************************************************************************
\******************************************************************************

   SUB  ADXCOPYF (RETC, INFILE, OUTFILE, OPT0, OPT1, OPT2) EXTERNAL

      INTEGER*4   RETC
      STRING      INFILE, OUTFILE
      INTEGER*2   OPT0, OPT1, OPT2

   END  SUB

    %INCLUDE ADXSERVE.J86    ! ADXSERVE function
\******************************************************************************
\******************************************************************************
\***                                                                        ***
\***    %INCLUDE FOR FUNCTION ADXSERVE (an I.B.M. system function)          ***
\***                                                                        ***
\***         AUTHOR        :  Bruce Scriver                                 ***
\***                                                                        ***
\***         DATE WRITTEN  :  14th March 1986                               ***
\***                                                                        ***
\***         DATE OF LAST REVISION  - 14th March 1986                       ***
\***                                                                        ***
\***                                                                        ***
\******************************************************************************
\******************************************************************************

   SUB ADXSERVE (RETURN.CODE%,                                                \
                 ADX.FUNCTION%,                                               \
                 ADX.PARM.1%,                                                 \
                 ADX.PARM.2$)                                                 \
   EXTERNAL
  
      STRING     ADX.PARM.2$

      INTEGER*2  ADX.FUNCTION%,                                               \
                 ADX.PARM.1%

      INTEGER*4  RETURN.CODE%                                                 \

   END SUB     

    %INCLUDE BASROUT.J86     ! OSShell function
\*LIB   BVEJ BASROUT  J86      03/11/97 08:16:26 PIDBLD3  *    FIX
\*PROM  BVEJ BASROUT  J86      03/10/97 17:18:40 PIDBLD3  MVEJ IR34352
\*RTIME BVEJ BASROUT  J86      03/10/97 17:18:41 PIDBLD3  MVEJ IR34352
\*LIB   MVEJ BASROUT  J86      03/05/97 10:48:46 EDJRAL   *    IR34352
\*LIB   MVEJ BASROUT  J86      02/17/97 11:19:56 EDJRAL   *    REASONAR
\*LIB   MVEJ BASROUT  J86      02/14/97 15:59:11 EDJRAL   *    REASONAR
! BASROUT.J86 - this file is to be included in any BASIC code which utilizes
!   the BASROUT.OBJ routines.  These routines were written
!  using Metaware C and are intended to provide functions which
!         are either not available in 4680 CBASIC or which can be more
!               efficiently handled by the C language.  Their usage is
!  offered on an "AT YOUR OWN RISK" basis.
!
!               The insert/extract routines usefulness may not be immediately
!               apparent.  Their intention is that they be used in conjunction
!               with a read/write form command.  They can more efficiently
!               parse a string into many different variables than can the
!               read form statement.  So instead of a long list of data var's
!               it may be more efficient to just read/write one long string
!               and then use the insert/extract routines to parse out the
!   data.

! ******************* SUB PROCESS FUNCTIONS *********************************

function osshell(cmd.line$) external   ! routine to start
       ! another program.
           integer*4    osshell    ! Upon completion of
           string       cmd.line$   ! program, control is
       ! returned to calling
end function      ! program.
!
! NOTES:  Program must be a 286 type file.  This does not exclude
!         the capability to execute a batch file however.  Simply pass the
!         following:
!              c:\adx_spgm\command.286 batfile
!         where batfile is the name of the batch file to be executed.
!
! IMPORTANT: When using osshell to execute a batch file as described above,
!            the final command in the batch file must be "exit".  If not,
!       control is never given back to the calling program.

! ************************ MEMORY RELATED FUNCTIONS ************************

function memfree(choice) external   ! routine to que the
       ! status of the
 integer*4 memfree    ! machine's memory:
 integer*2 choice    ! Options:
       !    1 - free
end function      !    2 - total
       !    3 - system

! ********************** TIMEDATE RELATED FUNCTIONS ************************

function timedate(choice) external   ! routine to que the
       ! OS's timedate table
 integer*4 timedate   ! Choices:
 integer*2 choice    !    1 - millisec's
       !        since midnight
end function      !    2 - minutes from
       !  UCT (timezone)
       !    3 - day of week
       !   0-Sunday
       !  6-Saturday

function settime(msecs) external   ! routine to set the
       ! time on the controller
 integer*4  settime    ! msecs is the desired
 integer*4 msecs    ! number of milliseconds
       ! since midnight
end function      ! Returns negative on
       ! error
! NOTE:  This routine sets the time only on the controller.  The terminals'
! time will not be updated until 1 AM or unless a terminal is STC'd.
! At 1 AM the controller broadcasts the new time to all terminals.
! Insure this is taken into consideration when using this routine.

!******************** DISK FILE RELATED FUNCTIONS *************************

function truncate(name,length) external   ! routine to truncate
       ! the specified file
 integer*4 truncate   ! to a given length.
 string  name
 integer*4 length

end function

!******************** STRING VALUE RELATED FUNCTIONS **********************

function isalpha(bstrn) external   ! routine to identify
       ! if the specified
 integer*1 isalpha    ! string contains all
 string  bstrn    ! alphabetic char's
       ! Returns:
end function      !     0 - all alpha
       !     X - byte of 1st
       !         non-alpha
       !   char

function isdigit(bstrn) external   ! routine to identify
       ! if the specified
 integer*1 isdigit    ! string contains all
 string  bstrn    ! numeric char's
       ! Returns:
end function      !     0 - all numeric
       !     X - byte of 1st
       !         non-numeric
       !   char

function islower(bstrn) external   ! routine to identify
       ! if the specified
 integer*1 islower    ! string contains all
 string  bstrn    ! lower case char's
       ! Returns:
end function      !     0 - all lowercase
       !     X - byte of 1st
       !         non-lowercase
       !   char

function isupper(bstrn) external   ! routine to identify
       ! if the specified
 integer*1 isupper    ! string contains all
 string  bstrn    ! upper case char's
       ! Returns:
end function      !     0 - all uppercase
       !     X - byte of 1st
       !         non-uppercase
       !   char

function toalpha(bstrn) external   ! routine to convert
       ! non-alpha or non-num
   integer*2 toalpha    ! char's to spaces
 string  bstrn    ! Returns:
end function      !   x - no. of char's
       !       changed

! ********************* USER/GROUP ZERO LEVEL FUNCTIONS *********************

function idlecount(choice) external   ! routine to either
       ! set to zero or queue
 integer*4 idlecount   ! the value of the
 integer*1 choice    ! processor's idlecount
       ! Choice:
end function      !     0 - set to zero
!       !     1 - get value
! NEEDS USER/GROUP 0 LEVEL OF AUTHORIZATION  ! Returns:
! TO WORK - This level is not available unless  !     X - idlecount
! the file ADXCSOUF.DAT file is "patched".  This !    -X - error code
! is highly unrecommended.

function logical(actname,logname,choice) external ! routine to set a
       ! a logical name.
 integer*4 logical    ! parms are self
        string  logname    ! explanatory except
 string  actname    ! for choice:
 integer*1 choice    !   0 - set process
       !   1 - set system
end function      !   2 - get process
       !   3 - get system

! NOTE:  Only the setting of a system level of logical name requires
! user/group zero level of authorization.  Any application may query any
! logical name.  Setting of a system logical name is only applicable until
! the system is IPL'd.  A process logical name is only active when that
! process is active.

!******************** STRING PARSING FUNCTIONS *****************************

function inserts(whole,part,offset) external  ! routine to insert a
       ! string (part) into
 integer*2 INSERTS    ! another string (whole)
 string  whole    ! starting at specified
 string  part    ! character (offset)
 integer*2 offset

end function

function cinsert4(integer4,bstring,offset) external   ! routine to insert
       ! a 4-byte integer into
 integer*1 cinsert4   ! a string starting at
 integer*4 integer4   ! byte specified by
 string  bstring    ! offset (1-based)
 integer*2 offset    ! Returns:
       !     0 - Success
end function      !    -1 - String overrun

function cinsert2(integer2,bstring,offset) external  ! routine to insert
       ! a 2-byte integer into
 integer*1 cinsert2   ! a string starting at
 integer*2 integer2   ! byte specified by
 string  bstring    ! offset (1-based)
 integer*2 offset    ! Returns:
       !     0 - Success
end function      !    -1 - String overrun

function cinsert1(bstring,integer1,offset) external  ! routine to insert
       ! a 1-byte integer into
 integer*1 cinsert1   ! a string starting at
 integer*1 integer1   ! byte specified by
 string  bstring    ! offset (1-based)
 integer*2 offset    ! Returns:
       !     0 - Success
end function      !    -1 - String overrun

function extracts(whole,part,offset) external  ! routine to extract a
       ! string (part) from
 integer*2 EXTRACTS   ! another string (whole)
 string  whole    ! starting at specified
 string  part    ! character (offset)
 integer*2 offset

end function

function cextract4(bstring,offset) external  ! routine to extract
       ! a 4-byte integer from
 integer*4 cextract4   ! a string starting at
                       ! byte specified by
 string  bstring    ! offset (1-based)
 integer*2 offset    ! Returns:
       !     X - 4 byte integer
end function      !    -1 - String overrun

function cextract2(bstring,offset) external  ! routine to extract
       ! a 2-byte integer from
 integer*2 cextract2   ! a string starting at
                       ! byte specified by
 string  bstring    ! offset (1-based)
 integer*2 offset    ! Returns:
       !     X - 2 byte integer
end function      !    -1 - String overrun

function cextract1(bstring,offset) external  ! routine to extract
       ! a 1-byte integer from
 integer*1 cextract1   ! a string starting at
                       ! byte specified by
 string  bstring    ! offset (1-based)
 integer*2 offset    ! Returns:
       !     X - 1 byte integer
end function      !    -1 - String overrun


function srchdir (file.name$,dtbl.buffer$) external ! routine to return
       ! file names and sizes
       ! Return values:
       !    -1  no matches
       !        found on first
       !        call
       !    0   no matches
       !        found on sub-
       !        sequent calls
       !    Pos Success
       !    Neg OS Rtn Code
! Usage Note:  If searching for all occurences of a particular file name,
! first initialize dtbl.buffer$ to 48 Nulls (pack$("00")) and issue a call
! to srchdir.  If any matches are found, a positive value will be returned.
! To see if any more matches exist, just issue another call to srchdir without
! resetting the values of dtbl.buffer$.  If any are found, a positive value
! will be returned.  This can be repeated until a Zero is returned.  All data
! describing file will be returned in the dtbl.buffer$ after each call.  Format
! of this data is defined below.

 integer*4 srchdir

 string  file.name$   ! file name to start
       ! search (18 bytes max)
       ! Wild cards and logical
       ! names supported.

 string  dtbl.buffer$   ! must be initialized
       ! to 48 bytes.  Contains
       ! all of directory info
       ! Initialize to nulls
       ! each time a new file
       ! name is used.

! NOTE:  Format of dtbl.buffer$ string is as follows:
!
! Offs  Type                    Description Notes
!  0 integer*4  key  use extract4 to access
!  4  string (18 bytes) file name
! 22 integer*2  attributes use extract2 to access
!      0x01 - Read Only
!      0x02 - Hidden
!      0x04 - System
!      0x08 - Volume Label
!      0x10 - Subdirectory
!      0x20 - Archive (Files)
!      0x40 - Security enabled
!      0x80 - Reserved
!      0x0000 - Local
!      0x4000 - Mirrored/Update
!      0xC000 - Mirrored/Close
!
!      0x6000 - Compound/Update
!      0xE000 - Compound/Close
! 24 integer*2  record size use extract2 to access
! 26 integer*1  User ID of Owner
! 27 integer*1  Group ID of Owner
! 28 integer*2  File Security
! 30 string (6 bytes) Reserved
! 36 integer*4  File Size use extract4 to access
! 40 integer*2  Year  use extract2 to access
! 42 integer*1  Month
! 43 integer*1  Day
! 44 integer*1  Hour
! 45 integer*1  Minute
! 46 integer*1  Second
! 47 integer*1  Reserved

end function

function srchproc (proc.name$,ptbl.buffer$) external ! routine to return
       ! process names and
       ! status.  Handy to
       ! determine if a
       ! program is currently
       ! running.
       ! Return values:
       !    -1  no matches
       !        found on first
       !        call
       !    0   no matches
       !        found on sub-
       !        sequent calls
       !    Pos Success
       !    Neg Failure
       !        OS Rtn Code
       ! 80000001h - Insuff
        !        ptbl buffer
       !        Length
! Usage Note:  If searching for all occurences of a particular process name,
! first initialize ptbl.buffer$ to 60 Nulls (pack$("00")) and issue a call
! to srchproc.  If any matches are found, a positive value will be returned.
! To see if any more matches exist, just issue another call to srchproc without
! resetting the values of ptbl.buffer$.  If any are found, a positive value
! will be returned.  This can be repeated until a Zero is returned.  All data
! describing file will be returned in the ptbl.buffer$ after each call.  Format
! of this data is defined as follows:
!
!       --------------------------------------------------------
!   0   |                         PID                          |
!       --------------------------------------------------------
!   4   |           FID             |   CID        |   VCID    |
!       --------------------------------------------------------
!   8   |                         NAME                         |
!       --------------------------------------------------------
!  12   |                         NAME cont'd                  |
!       --------------------------------------------------------
!  16   |       NAME cont'd         |   STATE      |  PRIOR    |
!       --------------------------------------------------------
!  20   |                         MAXMEM                       |
!       --------------------------------------------------------
!  24   |       FLAGS               |   USER        |  GROUP   |
!       --------------------------------------------------------
!  28   |                         PARENT                       |
!       --------------------------------------------------------
!  32   |                         EVENTS                       |
!       --------------------------------------------------------
!  36   |                         CODE                         |
!       --------------------------------------------------------
!  40   |                         CSIZE                        |
!       --------------------------------------------------------
!  44   |                         DATA                         |
!       --------------------------------------------------------
!  48   |                         DSIZE                        |
!       --------------------------------------------------------
!  52   |                         HEAP                         |
!       --------------------------------------------------------
!  56   |                         HSIZE                        |
!       --------------------------------------------------------
!
!       PID   Process ID
!       FID  Process's Family ID
!       CID   Physical Console Device Number
!       VCID  Process's Virtual Console Number
!       NAME  Process Name (Application Running)
! STATE    Process State (0-Run, 1-Waiting, 2-Terminating)
! PRIOR    Priority
!       MAXMEM  Maximum Memory Allowed
!       FLAGS  Bit 0 (1-System Process, 0-User Process)
!   Bit 1 (1-Locked in Memory, 0-Swappable)
!   Bit 2 (1-Running in SWI context, 0-Running in main context)
!   Bit 3 (1-Superuser Process,0-Not a Superuser Process)
! USER  User Number
! GROUP  Group Number
!       PARENT   Parent Process ID
!       EVENTS   Bit Map of events that have completed but not retrieved
!       CODE  Start of code area in user space
! CSIZE  Size in bytes of code area
!       DATA  Start of data area in user space
! DSIZE  Size in bytes of data area
!       HEAP  Start of heap area in user space
! HSIZE  Size in bytes of heap area
!
 integer*4 srchproc

 string  proc.name$   ! process name to start
       ! search (10 bytes max)
       ! Wild cards and logical
       ! names supported.

 string  ptbl.buffer$   ! must be initialized
       ! to 60 bytes.  Contains
       ! all of process info
       ! Initialize to nulls
       ! each time a new
       ! process name is used.

end function

function cconstat(timeout) external       ! function similar
                                              ! to BASIC constat%
 integer*2 cconstat   ! waits for either a
 integer*4 timeout    ! key being hit or
       ! the timer expiring
       ! before returning
       ! returns:
       !   -1 error
       !    0 timer expired
       !    x scan code of
       !      key hit
end function

function disksize(disk.name$) external   ! function to find
       ! the total size of
 integer*4 disksize   ! the specified disk
 string  disk.name$   ! name (e.g. "h0:")
       ! if return value is
       ! negative, error
end function      ! was received


    %INCLUDE BTCSTR.J86      ! String functions
!********************************************************************
!***
!***    INCLUDED CODE:  BTCSTR.J86
!***    AUTHOR:         Stuart William McConnachie
!***    DATE:           26th February 2006
!***
!********************************************************************
!***
!***    Controller CBASIC String Functions
!***
!********************************************************************

!Swaps to CBASIC strings
SUB SWAPSTR (S1$, S2$) EXTERNAL
    STRING S1$, S2$
END SUB

!Left trim a string of spaces
SUB LTRIM (S$) EXTERNAL
    STRING S$
END SUB

!Right trim a string of spaces
SUB RTRIM (S$) EXTERNAL
    STRING S$
END SUB

!Left and right trim a string of spaces
SUB TRIM (S$) EXTERNAL
    STRING S$
END SUB

!Left trim a string of a given ASCII character
SUB LTRIMC (S$, C%) EXTERNAL
    STRING S$
    INTEGER*1 C%
END SUB

!Right trim a string of a given ASCII character
SUB RTRIMC (S$, C%) EXTERNAL
    STRING S$
    INTEGER*1 C%
END SUB

!Left and right trim a string of a given ASCII character
SUB TRIMC (S$, C%) EXTERNAL
    STRING S$
    INTEGER*1 C%
END SUB

!Insert one string into another
FUNCTION SUBSTR(S1$, O1%, S2$, O2%, L2%) EXTERNAL
    STRING    S1$, S2$
    INTEGER*2 O1%, O2%, L2%
    INTEGER*1 SUBSTR
END FUNCTION
    
    %INCLUDE CMPDATE.J86     ! Compare date utility
!********************************************************************
!***
!***    INCLUDED CODE:  CMPDATE.J86
!***    AUTHOR:         Stuart William McConnachie
!***    DATE:           27th January 1997
!***
!********************************************************************
!***   
!***    Version B            Nik Sen                 30th March 1998
!***    Changes to cope with a date of '000000' by replacing it with
!***    '850101' before comparison. An all zero's date is valid in 
!***    certain date fields and CMPDATE was returning the wrong result
!***    when comparing with an actual date. Also change to cope with
!***    dates of '999999' as some date fields are initialised to this
!***    as a high value.
!***
!***    Version C    Stuart William McConnachie   20th December 1999
!***    Improved function efficiency by changing tests for high and
!***    low values, added above, to integers (rather than strings).
!***    Also, using 850101 as a replacement for 000000, will not give
!***    valid results after 350101 because of the 50 year wrap, so
!***    corrected this.
!***
!***    Version D.  Stuart William McConnachie    26th February 2006
!***    Place this code in it's own module in FUNLIB.  Make all
!***    the functions herein EXTERNAL accordingly.
!***
!********************************************************************
!***    
!***    The following functions compare dates, checking for
!***    century boundries.  Dates in the 50 years prior to the
!***    compared date are less than the compared date, dates in
!***    50 years after the compared date are greater than the
!***    compared date.
!***    Can handle dates in both packed and unpacked formats, or
!***    a mixture of both.
!***    In the case of a error, for example IH after detecting
!***    illegal characters in VAL, the functions default to
!***    comparing strings without testing for a change of century.
!***
!***    DATE.GT(DATE1$, DATE2$)  same as  DATE1$ >  DATE2$
!***    DATE.GE(DATE1$, DATE2$)  same as  DATE1$ >= DATE2$
!***    DATE.LT(DATE1$, DATE2$)  same as  DATE1$ <  DATE2$
!***    DATE.LE(DATE1$, DATE2$)  same as  DATE1$ <= DATE2$
!***
!********************************************************************

FUNCTION DATE.GT(DATE1$, DATE2$) EXTERNAL                               !DSWM
    STRING    DATE1$, DATE2$
    INTEGER*1 DATE.GT
END FUNCTION


FUNCTION DATE.GE(DATE1$, DATE2$) EXTERNAL                               !DSWM
    STRING    DATE1$, DATE2$
    INTEGER*1 DATE.GE
END FUNCTION


FUNCTION DATE.LT(DATE1$, DATE2$) EXTERNAL                               !DSWM
    STRING    DATE1$, DATE2$
    INTEGER*1 DATE.LT
END FUNCTION


FUNCTION DATE.LE(DATE1$, DATE2$) EXTERNAL                               !DSWM
    STRING    DATE1$, DATE2$
    INTEGER*1 DATE.LE
END FUNCTION

    %INCLUDE ERRNH.J86       ! Converts ERRN to 8-byte ASCII string
\******************************************************************************
\***
\***	FUNCTION ERRNH
\***
\***	Convert the 4-byte error number to an 8-byte ASCII string
\***
\******************************************************************************

	FUNCTION ERRNH PUBLIC

	STRING			ERRNH,					\
				E$

	INTEGER*2		I%
	INTEGER*4		H%

	E$ = ""
	H% = ERRN

	FOR I% = 28 TO 0 STEP -4
	    E$ = E$ + CHR$((SHIFT(H%,I%) AND 000FH) + 48)
	NEXT I%

	ERRNH = TRANSLATE$(E$,":;<=>?","ABCDEF")

	END FUNCTION
    %INCLUDE SLPCFEXT.J86    ! Sleeper control
\*****************************************************************************
\*****************************************************************************
\***
\***         FUNCTION DEFINITIONS FOR SLEEPER CHECK FILE
\***
\***                    REFERENCE : slpcfexa.J86
\***
\***    Version A           Steve Windsor          8.2.93
\***
\***    Version B           Richard Foster         8.7.93
\***  
\*****************************************************************************
\*****************************************************************************

   FUNCTION SLPCF.SET EXTERNAL
   END FUNCTION

  FUNCTION READ.SLPCF EXTERNAL
   INTEGER*2 READ.SLPCF
  END FUNCTION

  FUNCTION WRITE.SLPCF EXTERNAL
   INTEGER*2 WRITE.SLPCF
  END FUNCTION


\***********************************************************************
\*
\* OPEN.SEQUENTIAL.FILE : External C file function helps in opening
\*                        a sequential file as BASIC does not support
\*                        this when running under Supplemental Mode.
\*
\***********************************************************************
FUNCTION FUNC.OPEN.SEQUENTIAL.FILE( FILE.NAME$ ) EXTERNAL               !CJK
    INTEGER*4 FUNC.OPEN.SEQUENTIAL.FILE                                 !CJK
    STRING FILE.NAME$
END FUNCTION

\***********************************************************************
\*
\* READ.SEQUENTIAL.FILE : External C file function helps in reading
\*                        a sequential file as BASIC does not support
\*                        this when running under Supplemental Mode.
\*
\***********************************************************************
FUNCTION FUNC.READ.SEQUENTIAL.FILE( FILE.HANDLE% ) EXTERNAL             !CJK
    STRING FUNC.READ.SEQUENTIAL.FILE                                    !CJK
    INTEGER*4 FILE.HANDLE%
END FUNCTION

\***********************************************************************
\*
\* WRITE.SEQUENTIAL.FILE : External C file function helps in writing
\*                         a sequential file as BASIC does not support
\*                         this when running under Supplemental Mode.
\*
\***********************************************************************
FUNCTION FUNC.WRITE.SEQUENTIAL.FILE(FILE.HANDLE%, FILE.RECORD$) EXTERNAL!CJK
    INTEGER*4 FUNC.WRITE.SEQUENTIAL.FILE                                !CJK
    INTEGER*4 FILE.HANDLE%
    STRING FILE.RECORD$
END FUNCTION

\***********************************************************************
\*
\* CLOSE.FILE : External C file function helps in closing a file as
\*              BASIC does not support this when running under
\*              Supplemental Mode.
\*
\***********************************************************************
FUNCTION FUNC.CLOSE.FILE ( FILE.HANDLE% ) EXTERNAL                      !CJK
    INTEGER*4 FILE.HANDLE%
END FUNCTION


\***********************************************************************
\*
\* SUB.PROCESS.DAY.DIR.SCREEN: This Sub-Program does all the necessary  !MJK
\*                             actions needed for directory restore     !MJK
\*                             processing including screen navigation.  !MJK
\*
\*                             It receives the directory values as an   !MJK
\*                             input.                                   !MJK
\*
\* As a program modularisation, Directory restore has been made as a
\* Sub-program to perform all the Directory restore functionalities
\* within itself. This enables quick extraction from the main module
\* should breach the 64k limit
\*
\***********************************************************************
SUB SUB.PROCESS.DAY.DIR.SCREEN(IMG.FILE$, ALT.FILE$) EXTERNAL           !KDC
    STRING              \
        ALT.FILE$,      \
        IMG.FILE$
END SUB

\***********************************************************************
\*
\*    FUNC.DIR.NOT.EXISTS: This function checks the existence of given
\*                         directory by using CHDIR command.
\*
\***********************************************************************
FUNCTION FUNC.DIR.NOT.EXISTS(DIRECTORY.NAME$) PUBLIC                    !KDC

    INTEGER*1 FUNC.DIR.NOT.EXISTS
    STRING    DIRECTORY.NAME$

ON ERROR GOTO DIR.NOT.EXISTS.ERR                                        !CJK

    FUNC.DIR.NOT.EXISTS = TRUE

    ! Trim the last slash found to avoid error using CHDIR
    CALL TRIM   (DIRECTORY.NAME$)
    CALL RTRIMC (DIRECTORY.NAME$, ASC("/"))
    CALL RTRIMC (DIRECTORY.NAME$, ASC("\\"))

    CHDIR DIRECTORY.NAME$
    FUNC.DIR.NOT.EXISTS = FALSE

DIR.NOT.EXISTS.ERR:

END FUNCTION

\***********************************************************************
\*
\*    FUNC.FILE.EXISTS: This function checks the existence of
\*                      passed file by using SIZE function.
\*
\***********************************************************************
FUNCTION FUNC.FILE.EXISTS(FILE.NAME$) PUBLIC                            !KDC

    STRING    FILE.NAME$
    INTEGER*1 FUNC.FILE.EXISTS

    ON ERROR GOTO FILE.DOES.NOT.EXIST                                   !CJK

    CALL TRIM(FILE.NAME$)

    FUNC.FILE.EXISTS = TRUE

    FUN.RC2% = SIZE(FILE.NAME$)                                         !MJK

    EXIT FUNCTION

FILE.DOES.NOT.EXIST:
    FUNC.FILE.EXISTS = FALSE

END FUNCTION

\***********************************************************************
\*
\* Generic Comments: For all the screens, FIELD$(1) (status line) value
\*                   is hard-coded instead of using "Message no.". This
\*                   is because "Message No." is not accessible from
\*                   SUPPS mode, as BEMF.BIN file is not accessible.
\*
\***********************************************************************

\***********************************************************************
\***********************************************************************
\***********************************************************************
\*                                                                     *
\*          S T A R T   O F   M A I N L I N E   C O D E                *
\*                                                                     *
\***********************************************************************
\***********************************************************************
\***********************************************************************

ON ERROR GOTO ERROR.DETECTED

    !----------------------------------------------------------!
    ! Executes USE statement. Throws 'NP' error when initiated !
    ! directly. As only two modes are defined, this error is   !
    ! utilized to differentiate the modes.                     !
    !----------------------------------------------------------!
    %INCLUDE PSBUSEE.J86
\/*********************************************************************/ PSBUSEE
\/*                                                                   */ PSBUSEE
\/*      PSBUSEE.J86  -  USE in PSB Application Program               */ PSBUSEE
\/*      ----------------------------------------------               */ PSBUSEE
\/*                                                                   */ PSBUSEE
\/*********************************************************************/ PSBUSEE
                                                                       ! PSBUSEE
        USE  PSBCHN.OP , PSBCHN.APP , PSBCHN.MENCON , PSBCHN.U1 ,      \ PSBUSEE
             PSBCHN.U2 , PSBCHN.U3                                     ! PSBUSEE
                                                                       ! PSBUSEE

START.OF.PROGRAM:
    ! XRESTORE started

    GOSUB INITIALISATION
    GOSUB MAIN.PROCESSING
    GOSUB TERMINATION

    ! XRESTORE completed

! Called during abnormal run
STOP.PROGRAM:
    STOP

\***********************************************************************
\*
\* INITIALISATION : This Sub-routine does all the initial processing
\*                     before starting the main process
\*
\***********************************************************************
INITIALISATION:

    GOSUB INITIALISE.VARIABLES
    GOSUB ALLOCATE.SESSION.NUMBERS
    GOSUB CREATE.DIRECTORIES                                            !MJK
    GOSUB CREATE.XRESTORE.LOG
    GOSUB CHECK.XBACKUP.RUN
    GOSUB CREATE.RUN.PIPE
    GOSUB CONTROLLER.CONFIG.CHECK
    GOSUB GET.SLEEPER.CONFIGURATION                                     !IDC
    GOSUB DRIVE.FAT32.CHECK
    GOSUB INITIATE.DISP.MNGR

RETURN

\***********************************************************************
\*
\* MAIN.PROCESSING : This Sub-routine does the main processing for
\*                      creating the Backup.
\*
\***********************************************************************
MAIN.PROCESSING:

    GOSUB PROCESS.BKPSCRPT
    GOSUB SCREEN.NAVIGATION

RETURN

\***********************************************************************
\*
\* TERMINATION: Termination Sub-routine will be called before
\*                 program closure.
\*
\***********************************************************************
TERMINATION:

    GOSUB CLOSE.AND.DEALLOC.SESSIONS

RETURN

\**********************************************************************\
\**********************************************************************\
\*                                                                    *\
\*                 INITIALISATION SPECIFIC ROUTINES                   *\
\*                                                                    *\
\**********************************************************************\
\**********************************************************************\

\***********************************************************************
\*
\* INITIALISE.VARIABLES : This Sub-routine Initialize all the
\*                        necessary variables which will be used
\*                        in this program.
\*
\***********************************************************************
INITIALISE.VARIABLES:

    ! set messages first in case of usage
    GOSUB INITALISE.MESSAGES

    ! Program variables
    BATCH.SCREEN.FLAG$ = "S"            ! Screen

    CHAIN.TO.PROG$     = "PSB50"        ! PSB50 for chain
    MODULE.NUMBER$     = "XRESTORE"     ! Current Module

    ! Screen related variables
    DAY.INDEX%   = 77                   ! Screen 2's Day                !MJK
    DD.MM.INDEX% = 3                    !            DD/MM              !MJK
    INPUT.INDEX% = 92                   !            Input              !MJK
    SCREEN%      = 1                    ! variables

    ! Screen number variables
    DIRECTORY.DAY.SELECT.SCR%    = 6    ! Directory day selection       !CJK
    DIRECTORY.PROCESS.SCR%       = 61   ! Directory restore process     !CJK
    DISPLAY.MAIN.SCR%            = 1    ! Restore main screen           !CJK
    DRIVE.DAY.SELECT.SCR%        = 2    ! Drive day selection           !CJK
    DRIVE.DISK.SELECT.SCR%       = 3    ! Drive Disk selection          !CJK
    DRIVE.PROCESS.SCR%           = 4    ! Drive restore process         !CJK
    FILE.CONFIRMATION.SCR%       = 10   ! File restore confirmation     !CJK
    FILE.DAY.SELECT.SCR%         = 8    ! File restore day selection    !CJK
    FILE.DIR.AND.DIST.SCR%       = 9    ! File directory & distribution !CJK
    FILE.PROCESS.SCR%            = 11   ! File restore process          !CJK
    RESTORE.A.DIRECTORY.SCR%     = 5    ! Directory display             !CJK
    RESTORE.A.FILE.SCR%          = 7    ! File name entry screen        !CJK

    ! Constant variables
    ARRAY.LIMIT%     = 200                 ! Setting the Array Index%   !MJK
    COMMA.VALUE$     = ","                 ! Comma value                !MJK
    CONSTANT.COLON$  = ":"                 ! Colon value                !MJK
    CRLF$            = CHR$(13) + CHR$(10) ! Assigning CR/LF            !MJK
    DIR.TO.SHOW%     = 23                  ! No. of directories/screen  !MJK
    FALSE            = 0                   ! False = 0                  !MJK
    TRUE             = -1                  ! True  = -1                 !MJK
    XRE.NULL$        = ""                  ! NULL value                 !MJK
    XRE.SPACE$       = " "                 ! Single space               !MJK
    XRE.ZERO%        = 0                   ! zero use                   !MJK

    ! Array variables
    BKP.INDEX% = XRE.ZERO%

    ! Controller variables
    MASTER.AND.FILE.SERVER% = 21        ! Master/File server value

    BKP.DAYS%   = 14                    ! Number of available backups

    ! File related variables
    C.BKP.ALT$  = "C:\XDISKALT\"        ! Alternate C BACKUP
    C.BKP.IMG$  = "C:\XDISKIMG\"        ! Primary C Backup
    D.BKP.ALT$  = "D:\XDISKALT\"        ! Alternate D BACKUP
    D.BKP.IMG$  = "D:\XDISKIMG\"        ! Primary D BACKUP
    DIR.OUT$    = "C:\DIR.OUT"          ! Directory listing             !MJK
    DIR1.OUT$   = "C:\DIR1.OUT"         ! STDOUT file                   !OJK
    TEMP.DIR$   = "C:\TEMP\"            ! Temp directory

    XBACK.PIPE.NAME$       = "pi:XBACKUP"               ! XBACKUP pipe
    XBACK.PIPE.REPORT.NUM% = 426                        ! Temporary num
    XRE.LOG.FILENAME$      = "D:/ADX_UDT1/XRESTORE.LOG" ! Log file name
    XRE.LOG.REPORT.NUM%    = 428                        ! Temporary num
    XRE.PIPE.NAME$         = "pi:XRESTORE"              ! Run pipe
    XRE.PIPE.REPORT.NUM%   = 427                        ! Temporary num

    ! It is arranged in weekly order                                    !MJK
    ! set day constants to avoid mistakes and repeats                   !IDC
    CONSTANT.SUNDAY.SHORT$    = "SUN"                                   !IDC
    CONSTANT.MONDAY.SHORT$    = "MON"                                   !IDC
    CONSTANT.TUESDAY.SHORT$   = "TUE"                                   !IDC
    CONSTANT.WEDNESDAY.SHORT$ = "WED"                                   !IDC
    CONSTANT.THURSDAY.SHORT$  = "THU"                                   !IDC
    CONSTANT.FRIDAY.SHORT$    = "FRI"                                   !IDC
    CONSTANT.SATURDAY.SHORT$  = "SAT"                                   !IDC
    ! It is arranged in weekly order                                    !MJK
    CONSTANT.SUNDAY.LONG$     = "Sunday"                                !IDC
    CONSTANT.MONDAY.LONG$     = "Monday"                                !IDC
    CONSTANT.TUESDAY.LONG$    = "Tuesday"                               !IDC
    CONSTANT.WEDNESDAY.LONG$  = "Wednesday"                             !IDC
    ! set this to the longest named day if the day identifiers change   !IDC
    ! at all so that later matching and extracting works ok             !IDC
    CONSTANT.LONGEST.DAY%     = LEN(CONSTANT.WEDNESDAY.LONG$)           !IDC
    CONSTANT.THURSDAY.LONG$   = "Thursday"                              !IDC
    CONSTANT.FRIDAY.LONG$     = "Friday"                                !IDC
    CONSTANT.SATURDAY.LONG$   = "Saturday"                              !IDC

    PARM.FULL$          = "F"                                           !IDC

    CALL SLPCF.SET

    ! Initialize variables before actual use
    ERROR.EXIST = FALSE
    SUPPS.ON    = FALSE                                                 !CJK

    ! File not opened yet, hence defaulting to false                    !MJK
    BKPLIST.OPEN = FALSE                                                !MJK
    DIR.OPEN     = FALSE                                                !MJK
    SLPCF.OPEN   = FALSE                                                !MJK
    XBACK.OPEN   = FALSE                                                !MJK
    XRE.LOG.OPEN = FALSE                                                !MJK
    XRE.OPEN     = FALSE                                                !MJK

    ! Incremental file flag for existing and changed                    !IDC
    DIM BKPLI.INCREMENTAL.EXIST$(6)                                     !IDC
    DIM BKPLI.INCREMENTAL.FILE.CHNG$(6)                                 !IDC

    ! Dimensioning array
    DIM BKP.FILE.MDD.ARRAY$(ARRAY.LIMIT%)                               !MJK
    DIM BKP.FILE.MMDD.ARRAY$(ARRAY.LIMIT%)                              !MJK
    DIM BKPSCRPT.DIRECTORIES$(ARRAY.LIMIT%)                             !MJK
    DIM PRIMARY.ARCHIVED.NAMES$(ARRAY.LIMIT%)                           !MJK
    DIM SECONDARY.ARCHVD.NAMES$(ARRAY.LIMIT%)                           !MJK

    GOSUB SET.FILE.NAMES                                                !MJK

RETURN

! IDC START BLOCK
\***********************************************************************
\*
\*    INITALISE.MESSAGES:This Sub-routine Initialize all the messages
\*                       used for status update and errors
\*
\***********************************************************************
INITALISE.MESSAGES:

    VERSION$ = "### XRESTORE.286 - Version M - 23/08/2014 ###"          !MJK

    DIM STATUS.TEXT.MSG$(63)                                            !JDC
    DIM STATUS.TEXT.ERROR$(22)                                          !JDC
    DIM SCREEN.TEXT.MSG$(31)                                            !JDC

    !******************************************************************
    ! Status update messages
    !******************************************************************
    STATUS.TEXT.MSG$(1)  = " directory is created"
    STATUS.TEXT.MSG$(2)  = "Checking "
    STATUS.TEXT.MSG$(3)  = " to check the"
    STATUS.TEXT.MSG$(4)  = "Restore completed successfully"
    STATUS.TEXT.MSG$(5)  = "Restore completed with exception"
    STATUS.TEXT.MSG$(6)  = "Backup file not present"
    STATUS.TEXT.MSG$(7)  = "Deleting file "
    STATUS.TEXT.MSG$(8)  = "Checking BKPFAIL "
    STATUS.TEXT.MSG$(9)  = "File found in BKPFAIL file"
    STATUS.TEXT.MSG$(10) = "Copying and distributing "
    STATUS.TEXT.MSG$(11) = " is extracted to "
    STATUS.TEXT.MSG$(12) = "Restore application started Version ""M"""  !MJK
    STATUS.TEXT.MSG$(13) = "Checking Controller configuration"
    STATUS.TEXT.MSG$(14) = "Controller status not obtainable"
    STATUS.TEXT.MSG$(15) = "This Controller is not configured "
    STATUS.TEXT.MSG$(16) = "SLPCF Full backup day is "
    STATUS.TEXT.MSG$(17) = "SLPCF Full backup configuration not found"
    STATUS.TEXT.MSG$(18) = "Checking the DRIVE format"
    STATUS.TEXT.MSG$(19) = "C drive is not in FAT32 format"
    STATUS.TEXT.MSG$(20) = "D drive is not in FAT32 format"
    STATUS.TEXT.MSG$(21) = "Initializing the display manager"
    STATUS.TEXT.MSG$(22) = "Checking the Backup script file"
    STATUS.TEXT.MSG$(23) = "'BKPSCRPT array index error"
    STATUS.TEXT.MSG$(24) = " day is selected"
    STATUS.TEXT.MSG$(25) = "C Drive restoration process started"
    STATUS.TEXT.MSG$(26) = "D Drive restoration process started"
    STATUS.TEXT.MSG$(27) = ""           ! duplicate                     !JDC
    STATUS.TEXT.MSG$(28) = "Restore completed successfully"
    STATUS.TEXT.MSG$(29) = " restoration "
    STATUS.TEXT.MSG$(30) = " directory is created"
    STATUS.TEXT.MSG$(31) = " dated "
    STATUS.TEXT.MSG$(32) = "Checking BKPFAIL "
    STATUS.TEXT.MSG$(33) = ""           ! duplicate                     !JDC
    STATUS.TEXT.MSG$(34) = ""           ! duplicate                     !JDC
    STATUS.TEXT.MSG$(35) = " is extracted to "
    STATUS.TEXT.MSG$(36) = "Checking "
    STATUS.TEXT.MSG$(37) = " to check the"
    STATUS.TEXT.MSG$(38) = ""           ! duplicate                     !JDC
    STATUS.TEXT.MSG$(39) = " file is entered "
    STATUS.TEXT.MSG$(40) = ""           ! duplicate                     !JDC
    STATUS.TEXT.MSG$(41) = "File doesn't exist in the selected day "
    STATUS.TEXT.MSG$(42) = "Checking the archive file "
    STATUS.TEXT.MSG$(43) = " directory is selected "
    STATUS.TEXT.MSG$(44) = " directory is created"
    STATUS.TEXT.MSG$(45) = " directory is created"
    STATUS.TEXT.MSG$(46) = " is extracted "                             !OJK
    STATUS.TEXT.MSG$(47) = "File is being extracted from BKPFAIL file"
    STATUS.TEXT.MSG$(48) = "File is extracted to "
    STATUS.TEXT.MSG$(49) = "Copying and Restoring the file"
    STATUS.TEXT.MSG$(50) = "File restoration successful"
    STATUS.TEXT.MSG$(51) = "File restored with an exception"
    STATUS.TEXT.MSG$(52) = "Ended: Error while opening "
    STATUS.TEXT.MSG$(53) = "RESTORE not allowed when XBACKUP is active"
    STATUS.TEXT.MSG$(54) = "XRESTORE is already active somewhere"
    STATUS.TEXT.MSG$(55) = "archive file"
    STATUS.TEXT.MSG$(56) = \                                            !JDC
          "'File doesn't exist in the selected archive file."           !JDC
    STATUS.TEXT.MSG$(57) = \                                            !JDC
          "'File doesn't exist in the selected date archive file. "     !JDC
    STATUS.TEXT.MSG$(58) = "Press F3 or ESC"
    STATUS.TEXT.MSG$(59) = \                                            !JDC
          "'Checking the restored file - Please wait..."                !JDC
    STATUS.TEXT.MSG$(60) = "FALSE"
    STATUS.TEXT.MSG$(61) = "TRUE"
    STATUS.TEXT.MSG$(62) = \                                            !JDC
          "All directories and files have been restored to the "        !JDC
    STATUS.TEXT.MSG$(63) = " for restore"                               !JDC

    !******************************************************************
    ! Error messages
    !******************************************************************
    STATUS.TEXT.ERROR$(1)  = "UPDATE date function error in "
    STATUS.TEXT.ERROR$(2)  = "Error in opening DIR output file"
    STATUS.TEXT.ERROR$(3)  = "Error in reading DIR header output file"
    STATUS.TEXT.ERROR$(4)  = "'MDD array index error"
    STATUS.TEXT.ERROR$(5)  = "'BKP array index error"
    STATUS.TEXT.ERROR$(6)  = "PSDATE function error"
    STATUS.TEXT.ERROR$(7)  = "'MDD array index error"
    STATUS.TEXT.ERROR$(8)  = "'MDD array index error"
    STATUS.TEXT.ERROR$(9)  = "Error in opening BKPLIST file"
    STATUS.TEXT.ERROR$(10) = ""                 ! duplication           !JDC
    STATUS.TEXT.ERROR$(11) = ""                 ! duplication           !JDC
    STATUS.TEXT.ERROR$(12) = "Error found in extracting files"
    STATUS.TEXT.ERROR$(13) = "Error in opening BKPSCRPT file"
    STATUS.TEXT.ERROR$(14) = "Error when copying/distributing file"
    STATUS.TEXT.ERROR$(15) = "Error while extracting files"             !OJK
    STATUS.TEXT.ERROR$(16) = "Error while distributing the file"        !OJK
    STATUS.TEXT.ERROR$(17) = "Error in opening BKPFAIL file"
    STATUS.TEXT.ERROR$(18) = "Error in opening BKPLIST file"
    STATUS.TEXT.ERROR$(19) = "Error while creating directory"
    STATUS.TEXT.ERROR$(20) = "'Invalid key pressed"
    STATUS.TEXT.ERROR$(21) = "'No Backups available. "                  !MJK
    STATUS.TEXT.ERROR$(22) = "Error in opening Sleeper file"            !JDC

    !****************************************************************** !JDC
    ! Screen messages                                                   !JDC
    !****************************************************************** !JDC
    SCREEN.TEXT.MSG$(1)  = "RESTORE A DIRECTORY DAY SELECTION"          !JDC
    SCREEN.TEXT.MSG$(2)  = "Place an X in the box next to the day to "  !JDC
    SCREEN.TEXT.MSG$(3)  = "restore, then press ENTER"                  !JDC
    SCREEN.TEXT.MSG$(4)  = "You have chosen to restore the "            !JDC
    SCREEN.TEXT.MSG$(5)  = " directory."                                !JDC
    SCREEN.TEXT.MSG$(6)  = \                                            !JDC
          "Please choose which day you would like to restore:"          !JDC
    SCREEN.TEXT.MSG$(7)  = "'Error in Backup details retrieval."        !JDC
    SCREEN.TEXT.MSG$(8)  = " Refer XRESTORE log"                        !JDC
    SCREEN.TEXT.MSG$(9)  = "RESTORE A DIRECTORY STATUS"                 !JDC
    SCREEN.TEXT.MSG$(10) = " directory restoration in process - "       !JDC
    SCREEN.TEXT.MSG$(11) = " Directory of "                             !JDC
    SCREEN.TEXT.MSG$(12) = " date "                                     !JDC
    SCREEN.TEXT.MSG$(13) = "'Press ESC to go back to "                  !MJK
    SCREEN.TEXT.MSG$(14) = ""           ! duplicate                     !JDC
    SCREEN.TEXT.MSG$(15) = ""           ! duplicate                     !JDC
    SCREEN.TEXT.MSG$(16) = " are being extracted"                       !JDC
    SCREEN.TEXT.MSG$(17) = "RESTORE A DRIVE OR DRIVES"                  !JDC
    SCREEN.TEXT.MSG$(18) = ""           ! duplicate                     !JDC
    SCREEN.TEXT.MSG$(19) = ""           ! duplicate                     !JDC
    SCREEN.TEXT.MSG$(20) = "Please choose one of the following days:"   !JDC
    SCREEN.TEXT.MSG$(21) = "'No selection has been made. " + \          !JDC
                           "Value entered must be ""X"" OR ""x"" "      !JDC
    SCREEN.TEXT.MSG$(22) = ""           ! duplicate                     !JDC
    SCREEN.TEXT.MSG$(23) = "D: drive"                                   !JDC
    SCREEN.TEXT.MSG$(24) = "C: drive"                                   !JDC
    SCREEN.TEXT.MSG$(25) = "C: and D: drives"                           !JDC
    SCREEN.TEXT.MSG$(26) = "'Restore completed with exception." + \     !JDC
                           " Check XRESTORE log for more details"       !OJK
    SCREEN.TEXT.MSG$(27) = ""           ! duplicate                     !JDC
    SCREEN.TEXT.MSG$(28) = ""           ! duplicate                     !JDC
    SCREEN.TEXT.MSG$(29) = "previous screen"                            !JDC
    SCREEN.TEXT.MSG$(30) = "'No directories available to restore." + \  !MJK
                           " Press any key to exit screen"              !MJK
    SCREEN.TEXT.MSG$(31) = "'Data will be lost"                         !JDC

RETURN
! IDC END BLOCK

\***********************************************************************!MJK
\*                                                                      !MJK
\* SET.FILE.NAMES: This Sub-routine initialize the file names based     !MJK
\*                 on its presence                                      !MJK
\*                                                                      !MJK
\***********************************************************************!MJK
SET.FILE.NAMES:                                                         !MJK

    ADXZUDIR.FILE.NAME$ = "C:\ADX_SPGM\ADXZUDIR.386" ! ADXZUDIR         !MJK
    ADXUNZIP.FILE.NAME$ = "C:\ADX_SPGM\ADXUNZIP.386" ! ADXUNZIP         !OJK
    ADXCSU0L.FILE.NAME$ = "C:\ADX_SPGM\ADXCSU0L.286" ! ADXCSU0L         !MJK

    IF NOT FUNC.FILE.EXISTS(ADXZUDIR.FILE.NAME$) THEN BEGIN             !MJK
        ADXZUDIR.FILE.NAME$ = "D:\ADX_SPGM\ADXZUDIR.386" ! ADXZUDIR     !MJK
    ENDIF                                                               !MJK

    IF NOT FUNC.FILE.EXISTS(ADXUNZIP.FILE.NAME$) THEN BEGIN             !OJK
        ADXUNZIP.FILE.NAME$ = "D:\ADX_SPGM\ADXUNZIP.386" ! ADXUNZIP     !OJK
    ENDIF                                                               !OJK

    IF NOT FUNC.FILE.EXISTS(ADXCSU0L.FILE.NAME$) THEN BEGIN             !MJK
        ADXCSU0L.FILE.NAME$ = "D:\ADX_SPGM\ADXCSU0L.286" ! ADXCSU0L     !MJK
    ENDIF                                                               !MJK

    ! Set local drive for sleeper in supps mode                         !MJK
    SUPPS.SLEEPER.FILE.NAME$ = "D:\ADX_UDT1\SLPCF.BIN"                  !MJK

    IF NOT FUNC.FILE.EXISTS(SUPPS.SLEEPER.FILE.NAME$) THEN BEGIN        !MJK
        SUPPS.SLEEPER.FILE.NAME$  = "C:\ADX_UDT1\SLPCF.BIN"             !MJK
    ENDIF                                                               !MJK

    ! Set full path for sleeper in normal runs                          !MJK
    NORMAL.SLEEPER.FILE.NAME$ = "ADXLXACN::" + SUPPS.SLEEPER.FILE.NAME$ !MJK
                                                                        !MJK
    BKPLIST.PREFIX.D.DRIVE$ = "D:\ADX_UDT1\" + "BKPLIST."               !MJK
    BKPLIST.PREFIX.C.DRIVE$ = "C:\ADX_UDT1\" + "BKPLIST."               !MJK

RETURN                                                                  !MJK

\***********************************************************************
\*
\* ALLOCATE.SESSION.NUMBERS: This Sub-routine uses variables of FILE
\*                           functions and calls SESS.NUM.UTILITY to
\*                           allocate session numbers.
\*
\***********************************************************************
ALLOCATE.SESSION.NUMBERS:

    FUNC.FLAG$ = "O"   ! Setting the file operation

    ! XBACKUP pipe
    PASSED.INTEGER% = XBACK.PIPE.REPORT.NUM%
    PASSED.STRING$  = XBACK.PIPE.NAME$
    GOSUB GET.SESSION.NUMBER                                            !IDC
    XBACK.PIPE.SESS.NUM% = F20.INTEGER.FILE.NO%

    ! XRESTORE pipe
    PASSED.INTEGER% = XRE.PIPE.REPORT.NUM%
    PASSED.STRING$  = XRE.PIPE.NAME$
    GOSUB GET.SESSION.NUMBER                                            !IDC
    XRE.PIPE.SESS.NUM% = F20.INTEGER.FILE.NO%

    ! XRESTORE log
    PASSED.INTEGER% = XRE.LOG.REPORT.NUM%
    PASSED.STRING$  = XRE.LOG.FILENAME$
    GOSUB GET.SESSION.NUMBER                                            !IDC
    XRE.LOG.SESS.NUM% = F20.INTEGER.FILE.NO%

    ! Sleeper Control file                                              !IDC
    PASSED.INTEGER% = SLPCF.REPORT.NUM%                                 !IDC
    PASSED.STRING$  = NORMAL.SLEEPER.FILE.NAME$                         !JDC
    GOSUB GET.SESSION.NUMBER                                            !IDC
    SLPCF.SESS.NUM% = F20.INTEGER.FILE.NO%                              !IDC

RETURN

\***********************************************************************!MJK
\*                                                                      !MJK
\* CREATE.DIRECTORIES : This Sub-routine creates the C:/XDISKIMG        !MJK
\*                      and C:/TEMP directory if missing.               !MJK
\*                                                                      !MJK
\***********************************************************************!MJK
CREATE.DIRECTORIES:                                                     !MJK
                                                                        !MJK
    IF FUNC.DIR.NOT.EXISTS(C.BKP.IMG$) THEN BEGIN                       !MJK
        CALL RTRIMC (C.BKP.IMG$, ASC("/"))                              !MJK
        CALL RTRIMC (C.BKP.IMG$, ASC("\\"))                             !MJK
        CALL OSSHELL("MKDIR " + C.BKP.IMG$ + " > " + "XRE.TMP" + \      !MJK
                     " >>* " + "XRE.TMP")                               !MJK
    ENDIF                                                               !MJK
                                                                        !MJK
    IF FUNC.DIR.NOT.EXISTS(TEMP.DIR$) THEN BEGIN                        !MJK
        CALL RTRIMC (TEMP.DIR$, ASC("/"))                               !MJK
        CALL RTRIMC (TEMP.DIR$, ASC("\\"))                              !MJK
        CALL OSSHELL("MKDIR " + TEMP.DIR$ + " > " + "XRE.TMP" + \       !MJK
                     " >>* " + "XRE.TMP")                               !MJK
    ENDIF                                                               !MJK
                                                                        !MJK
RETURN                                                                  !MJK

\***********************************************************************
\*
\* GET.SESSION.NUMBER: This Sub-routine calls SESS.NUM.UTILITY to
\*                     allocate session numbers.
\*
\***********************************************************************
GET.SESSION.NUMBER:

    FUN.RC2% = SESS.NUM.UTILITY(FUNC.FLAG$, PASSED.INTEGER%, \          !IDC
                                PASSED.STRING$)                         !MJK
    GOSUB CHECK.FUN.RC2                                                 !IDC

RETURN

\***********************************************************************
\*
\* CREATE.XRESTORE.LOG : This Sub-routine creates the XRESTORE log.
\*
\***********************************************************************
CREATE.XRESTORE.LOG:

    CREATE XRE.LOG.FILENAME$ AS XRE.LOG.SESS.NUM%
    XRE.LOG.OPEN = TRUE                                                 !MJK

XRE.LOG.CREATE.ERROR:                                                   !MJK

    !---------------------------------------------!
    ! CLOSE session and deallocate the number as  !
    ! file write will be done by C File functions !
    !---------------------------------------------!
    IF XRE.LOG.OPEN THEN BEGIN
        XRE.LOG.OPEN = FALSE                                            !JDC
        CLOSE  XRE.LOG.SESS.NUM%
        CALL SESS.NUM.UTILITY ("C",XRE.LOG.SESS.NUM%,XRE.NULL$)         !MJK
    ENDIF

    XRE.FILE.RC% = FUNC.OPEN.SEQUENTIAL.FILE( XRE.LOG.FILENAME$ )       !NJK
    ! if return is not a failure                                        !JDC
    IF XRE.FILE.RC% > XRE.ZERO% THEN BEGIN
        XRE.LOG.OPEN = TRUE
    ENDIF

    STATUS.MSG$ = STATUS.TEXT.MSG$(12)                                  !JDC
    GOSUB LOG.STATUS.MSG

RETURN

\***********************************************************************
\*
\* CHECK.XBACKUP.RUN : This Sub-routine stops the program if the        !MJK
\*                     XBACKUP program is running
\*
\***********************************************************************
CHECK.XBACKUP.RUN:

    CREATE XBACK.PIPE.NAME$ AS XBACK.PIPE.SESS.NUM% BUFFSIZE XRE.ZERO%
    XBACK.OPEN = TRUE                                                   !MJK

XBACK.PIPE.CREATE.ERROR:                                                !MJK

    ! Closing the session only if the pipe creation is successful
    IF XBACK.OPEN THEN BEGIN                                            !MJK
        CLOSE XBACK.PIPE.SESS.NUM%
        XBACK.OPEN = FALSE                                              !JDC
        CALL SESS.NUM.UTILITY ("C",XBACK.PIPE.SESS.NUM%,XRE.NULL$)      !MJK
    ENDIF

RETURN

\***********************************************************************
\*
\* CREATE.RUN.PIPE: This Sub-routine creates pipe for current module
\*                  to avoid any duplicate run.
\*
\***********************************************************************
CREATE.RUN.PIPE:

    CREATE XRE.PIPE.NAME$ AS XRE.PIPE.SESS.NUM% BUFFSIZE XRE.ZERO%
    XRE.OPEN = TRUE                                                     !MJK

XRE.PIPE.CREATE.ERROR:                                                  !MJK

RETURN

\***********************************************************************
\*
\* CONTROLLER.CONFIG.CHECK: This Sub-routine uses ADXSERVE function
\*                          and check whether the controller is
\*                          Master and File server.If not, program
\*                          should end, logging an appropriate error.
\*
\***********************************************************************
CONTROLLER.CONFIG.CHECK:

    STATUS.MSG$ = STATUS.TEXT.MSG$(13)                                  !JDC
    GOSUB LOG.STATUS.MSG

    ! Using Function 4 to get the Controller details
    ADX.FUNCTION% = 4              ! Adxserve function 4
    ADXSERVE.RC%  = 1              ! Initiate with non zero value

    CALL ADXSERVE (ADXSERVE.RC%,ADX.FUNCTION%,XRE.ZERO%,ADX.PARM.2$)

    IF ADXSERVE.RC% <> XRE.ZERO% THEN BEGIN    ! If return code non zero
        STATUS.MSG$ = STATUS.TEXT.MSG$(13)                              !JDC
        ERROR.MSG$  = STATUS.MSG$
        GOSUB LOG.STATUS.MSG
        ERROR.EXIST = TRUE
    ENDIF

    CNTLR.CONFIG% = VAL(MID$(ADX.PARM.2$, 25, 2)) ! Controller config
    CNTLR.ID$     = MID$(ADX.PARM.2$, 14, 2)      ! Master Controller ID

    !-------------------------------------------!
    ! If controller is not a Master/File server !
    ! OR not in SUPPS mode                      !
    !-------------------------------------------!

    ! Set the flag if controller is in SUPPS mode
    IF CNTLR.ID$ = "CC" THEN BEGIN
        SUPPS.ON = TRUE
    ENDIF

    IF NOT (CNTLR.CONFIG% = MASTER.AND.FILE.SERVER% OR                 \
            CNTLR.ID$     = "CC" ) THEN BEGIN
        STATUS.MSG$ = STATUS.TEXT.MSG$(15) + "to run this program"      !JDC
        ERROR.MSG$  = STATUS.MSG$
        GOSUB LOG.STATUS.MSG
        ERROR.EXIST = TRUE
    ENDIF

RETURN

\***********************************************************************!KDC
\*                                                                      !IDC
\*    GET.SLEEPER.CONFIGURATION:This Sub-routine looks through the      !IDC
\*                              Sleeper control file in order to see    !IDC
\*                              what the current setting for the Full   !IDC
\*                              backup is. It then assumes all are      !IDC
\*                              Incremental based upon this day         !IDC
\*                                                                      !IDC
\***********************************************************************!IDC
GET.SLEEPER.CONFIGURATION:                                              !IDC

    SLEEPER.DAY% = 0                                                    !JDC

    IF SUPPS.ON THEN BEGIN                                              !JDC

        DIR.FILE.RC% = \                                                !NJK
                FUNC.OPEN.SEQUENTIAL.FILE(SUPPS.SLEEPER.FILE.NAME$)     !NJK

        ! If file open unsuccessful                                     !JDC
        IF DIR.FILE.RC% <= XRE.ZERO% THEN BEGIN                         !JDC
            SLPCF.OPEN  = FALSE                                         !MJK
            STATUS.MSG$ = STATUS.TEXT.MSG$(22)                          !JDC
            GOSUB LOG.STATUS.MSG                                        !JDC
        ENDIF ELSE BEGIN                                                !JDC
            SLPCF.OPEN  = TRUE                                          !MJK
        ENDIF

        SLEEPER.RECORD$ = "X"                                           !JDC
        ! Read the file till EOF/read error                             !JDC
        WHILE LEN(SLEEPER.RECORD$) <> XRE.ZERO%                         !JDC
            SLEEPER.RECORD$ = FUNC.READ.SEQUENTIAL.FILE( DIR.FILE.RC% ) !NJK
            IF LEN(SLEEPER.RECORD$) <> XRE.ZERO% THEN BEGIN             !JDC
                GOSUB GET.SUPPS.SLEEPER.INFO                            !JDC
            ENDIF                                                       !JDC
        WEND                                                            !JDC

        ! Closing File                                                  !JDC
        IF SLPCF.OPEN THEN BEGIN                                        !JDC
            CALL FUNC.CLOSE.FILE( DIR.FILE.RC% )                        !NJK
            SLPCF.OPEN = FALSE                                          !JDC
        ENDIF                                                           !JDC

    ENDIF ELSE BEGIN                                                    !JDC

        !***************************************************************!JDC
        ! first find the full backup day configured in sleeper          !JDC
        !***************************************************************!JDC
        IF END #SLPCF.SESS.NUM% THEN SLPCF.NOT.FOUND

        OPEN NORMAL.SLEEPER.FILE.NAME$ DIRECT RECL SLPCF.RECL% \        !JDC
             AS SLPCF.SESS.NUM% NOWRITE NODEL

        SLPCF.OPEN             = TRUE
        SLPCF.REC.NO%          = 0
        FULL.BACKUP.NOT.FOUND% = 0

        WHILE FULL.BACKUP.NOT.FOUND% = 0
            SLPCF.REC.NO% = SLPCF.REC.NO% + 1
            IF READ.SLPCF = 0 THEN BEGIN
                IF SLPCF.APP.NAME$ = "ADX_UPGM:XBACKUP.286" THEN BEGIN
                    IF SLPCF.PARM$ = PARM.FULL$ THEN BEGIN
                        FULL.BACKUP.NOT.FOUND% = 1          !found
                        !extract single day for full build
                        SLEEPER.DAY% = VAL(SLPCF.DAY.NUM$)
                        STATUS.MSG$  = STATUS.TEXT.MSG$(16) + \         !MJK
                                       SLPCF.DAY.NUM$                   !MJK
                    ENDIF
                ENDIF
            ENDIF
        WEND

SLPCF.NOT.FOUND:                                                        !JDC
        IF SLPCF.OPEN THEN BEGIN                                        !IDC
            CLOSE SLPCF.SESS.NUM%                                       !IDC
            SLPCF.OPEN = FALSE                                          !JDC
            CALL SESS.NUM.UTILITY ("C",SLPCF.SESS.NUM%,XRE.NULL$)       !MJK
        ENDIF ELSE BEGIN
            STATUS.MSG$ = STATUS.TEXT.ERROR$(22)                        !JDC
            GOSUB LOG.STATUS.MSG                                        !JDC
        ENDIF                                                           !IDC

    ENDIF                                                               !JDC

    ! needed so end if not found                                        !JDC
    IF SLEEPER.DAY% = 0 THEN BEGIN                                      !JDC
        STATUS.MSG$ = STATUS.TEXT.MSG$(17)                              !JDC
        GOSUB LOG.STATUS.MSG                                            !JDC
        GOSUB STOP.PROGRAM                                              !JDC
    ENDIF ELSE BEGIN                                                    !JDC
        GOSUB LOG.STATUS.MSG                                            !JDC
    ENDIF                                                               !JDC

    !*******************************************************************!IDC
    !then set the data we will build from - note that the array elements!IDC
    !must match the sleeper settings (ie 1=Sunday) to work correctly    !IDC
    !*******************************************************************!IDC
    DIM CONSTANT.DAY$(7)                                                !IDC
    CONSTANT.DAY$(1) = CONSTANT.SUNDAY.SHORT$                           !IDC
    CONSTANT.DAY$(2) = CONSTANT.MONDAY.SHORT$                           !IDC
    CONSTANT.DAY$(3) = CONSTANT.TUESDAY.SHORT$                          !IDC
    CONSTANT.DAY$(4) = CONSTANT.WEDNESDAY.SHORT$                        !IDC
    CONSTANT.DAY$(5) = CONSTANT.THURSDAY.SHORT$                         !IDC
    CONSTANT.DAY$(6) = CONSTANT.FRIDAY.SHORT$                           !IDC
    CONSTANT.DAY$(7) = CONSTANT.SATURDAY.SHORT$                         !IDC

    !*******************************************************************!IDC
    !and now the same for the longer names we display so all match, so  !IDC
    !we make them all the same length for our matching process later    !IDC
    !*******************************************************************!IDC
    DIM CONSTANT.LONG.DAY$(7)
    CONSTANT.LONG.DAY$(1) = LEFT$(CONSTANT.SUNDAY.LONG$              + \!MJK
                            STRING$(CONSTANT.LONGEST.DAY%, XRE.SPACE$) \!MJK
                            , CONSTANT.LONGEST.DAY%)

    CONSTANT.LONG.DAY$(2) = LEFT$(CONSTANT.MONDAY.LONG$              + \!MJK
                            STRING$(CONSTANT.LONGEST.DAY%, XRE.SPACE$) \!MJK
                            , CONSTANT.LONGEST.DAY%)

    CONSTANT.LONG.DAY$(3) = LEFT$(CONSTANT.TUESDAY.LONG$             + \!MJK
                            STRING$(CONSTANT.LONGEST.DAY%, XRE.SPACE$) \!MJK
                            , CONSTANT.LONGEST.DAY%)

    CONSTANT.LONG.DAY$(4) = LEFT$(CONSTANT.WEDNESDAY.LONG$           + \!MJK
                            STRING$(CONSTANT.LONGEST.DAY%, XRE.SPACE$) \!MJK
                            , CONSTANT.LONGEST.DAY%)

    CONSTANT.LONG.DAY$(5) = LEFT$(CONSTANT.THURSDAY.LONG$            + \!MJK
                            STRING$(CONSTANT.LONGEST.DAY%, XRE.SPACE$) \!MJK
                            , CONSTANT.LONGEST.DAY%)

    CONSTANT.LONG.DAY$(6) = LEFT$(CONSTANT.FRIDAY.LONG$              + \!MJK
                            STRING$(CONSTANT.LONGEST.DAY%, XRE.SPACE$) \!MJK
                            , CONSTANT.LONGEST.DAY%)

    CONSTANT.LONG.DAY$(7) = LEFT$(CONSTANT.SATURDAY.LONG$            + \!MJK
                            STRING$(CONSTANT.LONGEST.DAY%, XRE.SPACE$) \!MJK
                            , CONSTANT.LONGEST.DAY%)

    !*******************************************************************!IDC
    !Build up the string with all the days, starting with the full      !IDC
    !backup day so it can be matched to any time to find the Full and   !IDC
    !Incremental days adding the : prevents mismatching characters that !IDC
    !might overlap on the short day name. for example if Sunday is the  !IDC
    !full configured day the string would be;                           !IDC
    !  ":SUN:MON:TUE:WED:THU:FRI:SAT"                                   !IDC
    !and the longer names would be;                                     !IDC
    !  "Monday   Tuesday  WednesdayThursday Friday   Saturday Sunday   "!IDC
    !*******************************************************************!IDC
    BACKUP.DAYS$      = CONSTANT.DAY$(SLEEPER.DAY%)                     !IDC
    BACKUP.LONG.DAYS$ = CONSTANT.LONG.DAY$(SLEEPER.DAY%)                !IDC
                                                                        !IDC
    FOR DAY.SINCE.FULL% = 2 TO 7                                        !IDC
                                                                        !IDC
        IF SLEEPER.DAY% = 7 THEN BEGIN              !if Saturday        !IDC
            SLEEPER.DAY% = 1                        !set to Sunday      !IDC
        ENDIF ELSE BEGIN                                                !IDC
            SLEEPER.DAY% = SLEEPER.DAY% + 1         !next day           !IDC
        ENDIF                                                           !IDC
                                                                        !IDC
        BACKUP.DAYS$      = BACKUP.DAYS$ + CONSTANT.COLON$ + \          !IDC
                            CONSTANT.DAY$(SLEEPER.DAY%)                 !IDC
                                                                        !IDC
        BACKUP.LONG.DAYS$ = BACKUP.LONG.DAYS$ + \                       !IDC
                            CONSTANT.LONG.DAY$(SLEEPER.DAY%)            !IDC
    NEXT DAY.SINCE.FULL%                                                !IDC
                                                                        !IDC
    DIM CONSTANT.DAY$(0)                                                !IDC
    DIM CONSTANT.LONG.DAY$(0)                                           !IDC
                                                                        !IDC
RETURN                                                                  !IDC

\***********************************************************************!JDC
\*                                                                      !JDC
\* GET.SUPPS.SLEEPER.INFO : This Sub-routine extracts the record from   !JDC
\*                          the sleeper file in supps mode so must use  !JDC
\*                          the whole record and extract each element   !JDC
\*                          looking for the Full run setting            !JDC
\*                                                                      !JDC
\***********************************************************************!JDC
GET.SUPPS.SLEEPER.INFO:                                                 !JDC

    IF LEFT$(SLEEPER.RECORD$, 20) = "ADX_UPGM:XBACKUP.286" THEN BEGIN   !MJK
        ! Checking whether the 1st letter of the filler                 !JDC
        ! variable is numeric                                           !JDC
        IF MATCH("#",MID$(SLEEPER.RECORD$, 69, 1) ,1) <> 0 THEN BEGIN   !JDC
            SLPCF.PARM.LEN% = VAL(MID$(SLEEPER.RECORD$, 69, 1))         !JDC
            ! If SLPCF Filler parameter length is greater than zero     !JDC
            IF SLPCF.PARM.LEN% > 0 THEN BEGIN                           !JDC
                ! Storing the SLPCF Filler parameter                    !JDC
                SLPCF.PARM$ = MID$(SLEEPER.RECORD$, 70, SLPCF.PARM.LEN%)!MJK
                IF SLPCF.PARM$ = PARM.FULL$ THEN BEGIN                  !JDC
                    !extract single day for full build                  !JDC
                    SLPCF.DAY.NUM$ = MID$(SLEEPER.RECORD$, 23, 6)       !JDC
                    SLEEPER.DAY%   = VAL(SLPCF.DAY.NUM$)                !MJK

                    STATUS.MSG$ = STATUS.TEXT.MSG$(16) + SLPCF.DAY.NUM$ !JDC

                    SLEEPER.RECORD$ = ""          !found                !JDC
                ENDIF                                                   !JDC
            ENDIF                                                       !JDC
        ENDIF                                                           !JDC
    ENDIF                                                               !JDC
                                                                        !JDC
RETURN                                                                  !JDC

\***********************************************************************
\*
\* DRIVE.FAT32.CHECK : This Sub-routine checks the format of C and D
\*                     drive to make sure it is in FAT32 format.
\*
\***********************************************************************
DRIVE.FAT32.CHECK:

    STATUS.MSG$ = STATUS.TEXT.MSG$(18)                                  !JDC
    GOSUB LOG.STATUS.MSG

    ! Storing the random DIR output and check C32 text in 2nd line
    CALL OSSHELL("DIR C:/DRIVE.CHK > " + DIR.OUT$ )                     !MJK

    DIR.FILE.RC% = FUNC.OPEN.SEQUENTIAL.FILE( DIR.OUT$ )                !NJK

    IF DIR.FILE.RC% > XRE.ZERO% THEN BEGIN
        DIR.OPEN   = TRUE
        !ignore return check for EOF or read error as will error in     !FDC
        !FAT32 check and fail correctly                                 !FDC
        DIR.VALUE$ = FUNC.READ.SEQUENTIAL.FILE( DIR.FILE.RC% )          !NJK
        DIR.VALUE$ = FUNC.READ.SEQUENTIAL.FILE( DIR.FILE.RC% )          !NJK
    ENDIF ELSE BEGIN
        DIR.OPEN    = FALSE                                             !MJK
        STATUS.MSG$ = STATUS.TEXT.ERROR$(2)                             !JDC
        GOSUB LOG.STATUS.MSG                                            !IDC
    ENDIF

    ! C drive FAT32 check
    IF RIGHT$(DIR.VALUE$,3) <> "C32" THEN BEGIN
        ERROR.EXIST = TRUE
        STATUS.MSG$ = STATUS.TEXT.MSG$(19)                              !JDC
        ERROR.MSG$  = STATUS.MSG$
        GOSUB LOG.STATUS.MSG
    ENDIF

    ! Closing File
    IF DIR.OPEN THEN BEGIN
        CALL FUNC.CLOSE.FILE( DIR.FILE.RC% )                            !NJK
        DIR.OPEN = FALSE
    ENDIF

    ! Storing the random DIR output and the check D32 text in 2nd line
    CALL OSSHELL("DIR D:/DRIVE.CHK > " + DIR.OUT$ )                     !MJK

    DIR.FILE.RC% = FUNC.OPEN.SEQUENTIAL.FILE( DIR.OUT$ )                !NJK

    IF DIR.FILE.RC% > XRE.ZERO% THEN BEGIN
        DIR.OPEN   = TRUE
        !ignore return check for EOF or read error as will error in     !FDC
        !FAT32 check and fail correctly                                 !FDC
        DIR.VALUE$ = FUNC.READ.SEQUENTIAL.FILE( DIR.FILE.RC% )          !NJK
        DIR.VALUE$ = FUNC.READ.SEQUENTIAL.FILE( DIR.FILE.RC% )          !NJK
    ENDIF ELSE BEGIN
        DIR.OPEN    = FALSE                                             !MJK
        STATUS.MSG$ = STATUS.TEXT.ERROR$(2)                             !JDC
        GOSUB LOG.STATUS.MSG
    ENDIF

    ! D drive FAT32 check
    IF RIGHT$(DIR.VALUE$,3) <> "D32" THEN BEGIN
        ERROR.EXIST = TRUE
        STATUS.MSG$ = STATUS.TEXT.MSG$(20)                              !MJK
        ERROR.MSG$  = STATUS.MSG$
        GOSUB LOG.STATUS.MSG
    ENDIF

    ! Closing File
    IF DIR.OPEN THEN BEGIN
        CALL FUNC.CLOSE.FILE( DIR.FILE.RC% )                            !NJK
        DIR.OPEN = FALSE
    ENDIF

RETURN

\***********************************************************************
\*
\* INITIATE.DISP.MNGR : This Sub-routine initiates the display manager.
\*
\***********************************************************************
INITIATE.DISP.MNGR:

    STATUS.MSG$ = STATUS.TEXT.MSG$(21)                                  !JDC
    GOSUB LOG.STATUS.MSG

    CALL DM.INIT                      ! Display Manager Initialisation

RETURN

                !   INITIALISATION SPECIFIC ROUTINES ENDS   !
                !...........................................!

\**********************************************************************\
\**********************************************************************\
\*                                                                    *\
\*                 MAIN.PROCESSING SPECIFIC ROUTINES                  *\
\*                                                                    *\
\**********************************************************************\
\**********************************************************************\

\***********************************************************************
\*
\* PROCESS.BKPSCRPT: This Subroutine process the BKPSCRPT file and store
\*                   all the BACKUP and EXCLUDE details in an array.
\*
\***********************************************************************
PROCESS.BKPSCRPT:

    STATUS.MSG$ = STATUS.TEXT.MSG$(22)                                  !JDC
    GOSUB LOG.STATUS.MSG

    BKPSCRPT.FILE.NAME$ = "D:/ADX_UDT1/BKPSCRPT.TXT"    ! Backup script

    IF NOT FUNC.FILE.EXISTS(BKPSCRPT.FILE.NAME$) THEN BEGIN             !MJK
        BKPSCRPT.FILE.NAME$ = "C:/ADX_UDT1/BKPSCRPT.TXT"                !MJK
    ENDIF                                                               !MJK

    DIR.FILE.RC% = FUNC.OPEN.SEQUENTIAL.FILE(BKPSCRPT.FILE.NAME$)       !NJK

    ! If the open successful, set the VALUE.EXISTS equals TRUE
    IF DIR.FILE.RC% > XRE.ZERO% THEN BEGIN
        DIR.OPEN     = TRUE
        VALUE.EXISTS = TRUE
    ENDIF ELSE BEGIN
        VALUE.EXISTS = FALSE
        DIR.OPEN     = FALSE                                            !CJK
        STATUS.MSG$  = "Error in opening BKPSCRPT file"
        GOSUB LOG.STATUS.MSG
    ENDIF

    BKPSCRPT.INDEX% = XRE.ZERO%

    !-----------------------------------------------------------------!
    ! Extracting EXCLUDE and BACKUP and performing respective process !
    !-----------------------------------------------------------------!
    WHILE VALUE.EXISTS

        DIR.VALUE$ = FUNC.READ.SEQUENTIAL.FILE( DIR.FILE.RC% )          !NJK

        COMMA.POSITION% = MATCH(COMMA.VALUE$,DIR.VALUE$,1)

        ! If comma found
        IF COMMA.POSITION% <> XRE.ZERO% THEN BEGIN

            ! Extracting Backup script command
            BKPSCRPT.COMMAND$ = LEFT$(DIR.VALUE$,(COMMA.POSITION% - 1)) !CJK
            CALL TRIM(BKPSCRPT.COMMAND$)

            ! Remaining Backup script value
            DIR.VALUE$ = MID$(DIR.VALUE$,(COMMA.POSITION% + 1),        \!CJK
                              LEN(DIR.VALUE$))
            !-----------------------!
            ! If command is Backup  !
            !-----------------------!
            IF BKPSCRPT.COMMAND$ = "BACKUP" THEN BEGIN

                BKPSCRPT.INDEX% = BKPSCRPT.INDEX% + 1

                IF BKPSCRPT.INDEX% > ARRAY.LIMIT% THEN BEGIN            !MJK
                    STATUS.MSG$ = STATUS.TEXT.MSG$(23)                  !JDC
                    GOSUB PROGRAM.EXIT
                ENDIF

                !------------------------------------------!
                ! Extracting Backup script directory value !
                !------------------------------------------!

                ! Comma position
                COMMA.POSITION%      = MATCH(COMMA.VALUE$,DIR.VALUE$,1) !CJK
                ! Backup directory
                BKPSCRPT.DIRECTORY$  = LEFT$(DIR.VALUE$,               \
                                             (COMMA.POSITION% - 1))

                CALL TRIM(BKPSCRPT.DIRECTORY$)

                BKPSCRPT.DIRECTORIES$(BKPSCRPT.INDEX%) =               \
                                                BKPSCRPT.DIRECTORY$

                ! Remaining Backup script value
                DIR.VALUE$ = MID$(DIR.VALUE$,(COMMA.POSITION% + 1),    \!CJK
                                  LEN(DIR.VALUE$))

                !-------------------------------------------------!
                ! Extracting Backup script output directory value !
                !-------------------------------------------------!

                ! Comma position
                COMMA.POSITION% = MATCH(COMMA.VALUE$,DIR.VALUE$,1)      !CJK

                ! Output directory
                BKPSCRPT.OUT.FILE.NAME$ = LEFT$(DIR.VALUE$,            \!CJK
                                               (COMMA.POSITION% - 1))
                CALL TRIM(BKPSCRPT.OUT.FILE.NAME$)

                PRIMARY.ARCHIVED.NAMES$(BKPSCRPT.INDEX%) =             \
                                            BKPSCRPT.OUT.FILE.NAME$

                ! Remaining Backup script value
                DIR.VALUE$ = MID$(DIR.VALUE$,(COMMA.POSITION% + 1),    \!CJK
                                  LEN(DIR.VALUE$))

                BKPSCRPT.OUT.FILE.NAME$ = DIR.VALUE$
                CALL TRIM(BKPSCRPT.OUT.FILE.NAME$)

                SECONDARY.ARCHVD.NAMES$(BKPSCRPT.INDEX%) =             \
                                            BKPSCRPT.OUT.FILE.NAME$

            ENDIF
        ENDIF

        ! If the read reaches EOF
        IF LEN(DIR.VALUE$) = XRE.ZERO% THEN BEGIN
            VALUE.EXISTS = FALSE
        ENDIF
    WEND

    ! Closing File
    IF DIR.OPEN THEN BEGIN
        CALL FUNC.CLOSE.FILE( DIR.FILE.RC% )                            !NJK
        DIR.OPEN = FALSE
    ENDIF

RETURN

\***********************************************************************
\*
\* SCREEN.NAVIGATION: This Subroutine navigates the screen based on
\*                    the user input.
\*
\***********************************************************************
SCREEN.NAVIGATION:

    ! Based on screen selection, display and process the screen
    WHILE SCREEN% <> XRE.ZERO%
        IF SCREEN% = DISPLAY.MAIN.SCR% THEN BEGIN                       !CJK

            ! Display Main Menu
            GOSUB DISPLAY.MAIN.SCREEN

            ! Process Main Menu
            GOSUB PROCESS.MAIN.SCREEN

        ENDIF ELSE BEGIN
            IF SCREEN% = DRIVE.DISK.SELECT.SCR% THEN BEGIN              !MJK

                ! Display and process Drive selection screen
                GOSUB DISPLAY.PROCESS.DRIVES                            !MJK

                ! Display and process Drive restore screen
                GOSUB PROCESS.DRIVE.DAY.SCREEN                          !MJK

            ENDIF ELSE BEGIN
                IF SCREEN% = RESTORE.A.DIRECTORY.SCR% THEN BEGIN        !CJK

                    ! Display directory screen                          !MJK
                    GOSUB DISPLAY.DIRECT.SCREEN

                    ! Process Directory screen
                    GOSUB PROCESS.DIRECT.SCREEN                         !MJK

                ENDIF ELSE BEGIN

                    ! Display file screen
                    CALL DM.SHOW.SCREEN (7, XRE.NULL$, 6, 6)

                    ! Process file screen
                    GOSUB PROCESS.FILE.SCREEN

                ENDIF
            ENDIF
        ENDIF
    WEND

    !-------------------------------------------------!
    ! If screen mode, chain back the program to PSB50 !
    ! else clears the screen and stop the program     !
    !-------------------------------------------------!
    IF SCREEN% = XRE.ZERO% THEN BEGIN                                   !CJK
        GOSUB CHAIN.TO.CALLER
    ENDIF

RETURN

\***********************************************************************
\*
\* DISPLAY.MAIN.SCREEN: This Subroutine displays the Main screen
\*                      for XRESTORE.
\*
\***********************************************************************
DISPLAY.MAIN.SCREEN:

    ! selection Input is stored in FSEL$
    !----------------------------------------
    FSEL$ = ""

    CALL DM.SHOW.SCREEN (1, XRE.NULL$, 1, 1)

    ! Initialising the output fields in the screen
    ! before processing the screen
    !--------------------------------------------
    CALL DM.NAME (2, "FSEL$", FSEL$)

    ! Validation the Menu selection is between 1 and 3
    !-------------------------------------------------
    CALL DM.VALID ("FSEL$", "FSEL$ >= 1 AND FSEL$ <= 3")
    !B003 Invalid selection number
    CALL DM.MESSAGE ("FSEL$", "'Invalid selection number")

RETURN

\***********************************************************************
\*
\* PROCESS.MAIN.SCREEN: This Subroutine processes the Main screen
\*                      for XRESTORE.
\*
\***********************************************************************
PROCESS.MAIN.SCREEN:

    ! Processing Main Menu screen
    !-------------------------------------
    WHILE SCREEN% = DISPLAY.MAIN.SCR%                                   !CJK

        RET.KEY% = DM.PROCESS.SCREEN (2, 2, XRE.ZERO%)

        IF (RET.KEY% = ESC.KEY%) OR (RET.KEY% = F3.KEY%) THEN BEGIN     !CJK

            ! Program exit
            SCREEN% = XRE.ZERO%

        ENDIF ELSE BEGIN

            ! If Enter key is pressed and no Error exist
            IF RET.KEY% = ENTER.KEY% AND NOT ERROR.EXIST THEN BEGIN

                ! Storing the option in a variable
                OPT.SEL% = VAL(FSEL$)

                IF OPT.SEL% = 1 THEN BEGIN

                    !------------------------------------------!
                    ! Before moving to Drive restore screen    !
                    ! need to make sure that controller is in  !
                    ! SUPPS mode                               !
                    !------------------------------------------!
                    IF NOT SUPPS.ON THEN BEGIN
                        CALL DM.FOCUS("11", "'This functionality "  + \
                                      "is only available under SUPPS")
                    ENDIF ELSE BEGIN
                    ! Drive restore screen
                        SCREEN% = DRIVE.DISK.SELECT.SCR%                !MJK
                    ENDIF

                ENDIF ELSE IF OPT.SEL% = 2 THEN BEGIN
                    ! Directory restore screen
                    SCREEN% = RESTORE.A.DIRECTORY.SCR%                  !CJK
                ENDIF ELSE BEGIN
                    ! File restore screen
                    SCREEN% = RESTORE.A.FILE.SCR%                       !CJK
                ENDIF
            ENDIF ELSE BEGIN                                            !NJK
                IF ERROR.EXIST THEN BEGIN                               !NJK
                    CALL DM.FOCUS("101", "'" + ERROR.MSG$)
                ENDIF ELSE BEGIN
                    ! B001 Invalid key pressed
                    CALL DM.FOCUS ("1", STATUS.TEXT.ERROR$(20))         !IDC
                ENDIF
            ENDIF                                                       !NJK
        ENDIF

    WEND

RETURN

! Sub-routine DISPLAY.PROCESS.DRIVES, CHECK.DRIVE.SELECTION has been    !MJK
! moved up with respect to the changes in the screen execution in CR5.  !MJK
\***********************************************************************
\*
\* DISPLAY.PROCESS.DRIVES: This Subroutine display and processes
\*                         the C and D drives.
\*
\***********************************************************************
DISPLAY.PROCESS.DRIVES:

    CALL DM.SHOW.SCREEN (3, XRE.NULL$, 3, 3)

    ! Processing Drive display screen
    WHILE SCREEN% = DRIVE.DISK.SELECT.SCR%                              !MJK

        RET.KEY% = DM.PROCESS.SCREEN (3, 4, TRUE)

        IF (RET.KEY% = ESC.KEY%) OR (RET.KEY% = F3.KEY%) THEN BEGIN     !CJK
            ! Return back to the Drive DAY screen
            SCREEN%      = DISPLAY.MAIN.SCR%                            !MJK

        ENDIF ELSE BEGIN
            IF RET.KEY% = ENTER.KEY% THEN BEGIN

                ! Checks the Drive selection input
                GOSUB CHECK.DRIVE.SELECTION

            ENDIF ELSE BEGIN
                ! B001 Invalid key pressed
                CALL DM.FOCUS ("1", STATUS.TEXT.ERROR$(20))             !IDC
            ENDIF
        ENDIF
    WEND

RETURN

\***********************************************************************
\*
\* CHECK.DRIVE.SELECTION: This Subroutine checks the input of Drive
\*                        Display screen
\*
\***********************************************************************
CHECK.DRIVE.SELECTION:

    ! Storing the C drive and D drive field
    CDRIVE$ = UCASE$(FIELD$(3))
    DDRIVE$ = UCASE$(FIELD$(4))

    CALL TRIM(CDRIVE$)                                                  !MJK
    CALL TRIM(DDRIVE$)                                                  !MJK

    ! If at least one of the value is X
    IF (CDRIVE$ = "X" AND LEN(DDRIVE$) = XRE.ZERO%) OR \                !MJK
       (DDRIVE$ = "X" AND LEN(CDRIVE$) = XRE.ZERO%) THEN BEGIN          !MJK

        SCREEN% = DRIVE.DAY.SELECT.SCR%                                 !MJK

    ENDIF ELSE BEGIN                                                    !NJK
        IF LEN(DDRIVE$) <> XRE.ZERO% OR \                               !NJK
           LEN(CDRIVE$) <> XRE.ZERO% THEN BEGIN                         !MJK
            FIELD$(1) = "'Value entered must be ""X"" OR ""x"". Only" + \MJK
                        " one drive is allowed"                         !MJK
        ENDIF ELSE BEGIN
            FIELD$(1) = SCREEN.TEXT.MSG$(21)                            !JDC
        ENDIF
    ENDIF                                                               !NJK

RETURN

\***********************************************************************!MJK
\*                                                                      !MJK
\* PROCESS.DRIVE.DAY.SCREEN: This Subroutine process the drive restore  !MJK
\*                           screen for XRESTORE.                       !MJK
\*                                                                      !MJK
\***********************************************************************!MJK
PROCESS.DRIVE.DAY.SCREEN:                                               !MJK
                                                                        !MJK
    WHILE SCREEN% = DRIVE.DAY.SELECT.SCR%                               !MJK
                                                                        !MJK
        GOSUB DISPLAY.DRIVE.SCREEN                                      !MJK
        GOSUB PROCESS.DRIVE.SCREEN                                      !MJK
                                                                        !MJK
    WEND                                                                !MJK
                                                                        !MJK
RETURN                                                                  !MJK

\***********************************************************************
\*
\* DISPLAY.DRIVE.SCREEN: This Subroutine displays the drive restore
\*                       screen for XRESTORE.
\*
\***********************************************************************
DISPLAY.DRIVE.SCREEN:

    ! Setting the Header and other variables used for screen display
    SCR.HEADER$   = SCREEN.TEXT.MSG$(17)                                !MJK
    OPT.SELECTED$ = SCREEN.TEXT.MSG$(2) + SCREEN.TEXT.MSG$(3)           !JDC

    OPT.HEADER$   = SCREEN.TEXT.MSG$(20)                                !JDC

    IF CDRIVE$ = "X" THEN BEGIN                                         !MJK
        OPT.HEADER.1$ = "You have chosen to restore the C drive."       !MJK
    ENDIF ELSE BEGIN                                                    !MJK
        OPT.HEADER.1$ = "You have chosen to restore the D drive."       !MJK
    ENDIF                                                               !MJK

    CALL DM.SHOW.SCREEN (2, SCR.HEADER$, 2, 2)

    ! Setting the XRE value which will be displayed in the Left corner
    SCREEN.NUM$ = "03"

    ! Dimensioning array
    DIM DAY.ARRAY$(ARRAY.LIMIT%)                                        !MJK
    DIM BKP.AVAIL.ARRAY$(ARRAY.LIMIT%)                                  !MJK

    ! Setting the screen number
    CALL DM.NAME (2, "SCREEN.NUM$", SCREEN.NUM$)

    ! Calling function to get the array of input values                 !IDC
    FUNCTION.ERROR.NOT.EXIST = 0                                        !IDC
    SECOND.FILE$ = XRE.NULL$                                            !MJK

    IF CDRIVE$ = "X" THEN BEGIN                                         !MJK
        FIRST.FILE$  = D.BKP.IMG$ + "BKPFAILC"                          !MJK
    ENDIF ELSE BEGIN                                                    !MJK
        FIRST.FILE$  = C.BKP.IMG$ + "BKPFAILD"                          !MJK
    ENDIF                                                               !MJK

    GOSUB GET.BKP.DETAILS                                               !IDC

    ! Initialising the output fields in the screen
    ! before processing the screen
    !--------------------------------------------
    CALL DM.NAME (48, "OPT.HEADER.1$", OPT.HEADER.1$)                   !MJK

    ! If backups are available
    IF VALUE.INDEX% <> XRE.ZERO% AND FUNCTION.ERROR.NOT.EXIST THEN BEGIN!EJK

        ! Initialising the output fields in the screen
        ! before processing the screen
        !--------------------------------------------
        CALL DM.NAME (49, "OPT.HEADER$",   OPT.HEADER$)                 !MJK
        CALL DM.NAME (50, "OPT.SELECTED$", OPT.SELECTED$)

        ! Enabling the DAY and DD/MM string
        CALL DM.VISIBLE ("75", STATUS.TEXT.MSG$(61))                    !IDC
        CALL DM.VISIBLE ("76", STATUS.TEXT.MSG$(61))                    !IDC

        ! Setting the first value of the fields before populating it
        DAY.LOOP%   = DAY.INDEX%
        DD.MM.LOOP% = DD.MM.INDEX%
        INPUT.LOOP% = INPUT.INDEX%

        ! Retrieving the values and storing in Field$
        FOR INDEX% = 1 TO VALUE.INDEX%

            ! DAY value and its visibility
            FIELD$(DAY.LOOP%) = DAY.ARRAY$(INDEX%)
            CALL DM.VISIBLE (STR$(DAY.LOOP%), STATUS.TEXT.MSG$(61))     !IDC

            ! DD/MM value
            FIELD$(DD.MM.LOOP%) = RIGHT$(BKP.AVAIL.ARRAY$(INDEX%),2) + \!GJK
                                  "/"                                + \
                                  LEFT$(BKP.AVAIL.ARRAY$(INDEX%),2)     !GJK

            ! Setting a space for input values
            FIELD$(INPUT.LOOP%) = XRE.SPACE$

            ! Setting the visibility for DD/MM and input
            CALL DM.VISIBLE (STR$(DD.MM.LOOP%), STATUS.TEXT.MSG$(61))   !IDC
            CALL DM.VISIBLE (STR$(INPUT.LOOP%), STATUS.TEXT.MSG$(61))   !IDC

            ! Incrementing to move to the next field
            DAY.LOOP%   = DAY.LOOP%   + 1
            DD.MM.LOOP% = DD.MM.LOOP% + 1
            INPUT.LOOP% = INPUT.LOOP% + 1
        NEXT INDEX%

    ENDIF ELSE BEGIN                                                    !NJK
        IF FUNCTION.ERROR.NOT.EXIST THEN BEGIN                          !NJK
            FIELD$(1) = STATUS.TEXT.ERROR$(21)                          !IDC
        ENDIF ELSE BEGIN                                                !EJK
            FIELD$(1) = SCREEN.TEXT.MSG$(7) + SCREEN.TEXT.MSG$(8)       !MJK
        ENDIF
    ENDIF                                                               !NJK

RETURN

\***********************************************************************
\*
\* PROCESS.DRIVE.SCREEN: This Subroutine processes the Drive screen
\*                       for XRESTORE.
\*
\***********************************************************************
PROCESS.DRIVE.SCREEN:

    ! Processing Drive screen
    !-------------------------------------
    WHILE SCREEN% = DRIVE.DAY.SELECT.SCR% OR \                          !MJK
          SCREEN% = DRIVE.PROCESS.SCR%                                  !MJK

        ! Drive restore day screen
        IF SCREEN% = DRIVE.DAY.SELECT.SCR% THEN BEGIN                   !MJK

            ! If the screen is accessed using F3 or ESC
            IF PREVIOUS.KEY THEN BEGIN
                GOSUB DISPLAY.DRIVE.SCREEN
                PREVIOUS.KEY = FALSE
            ENDIF

            RET.KEY% = DM.PROCESS.SCREEN (2, 105, TRUE)

            IF (RET.KEY% = ESC.KEY%) OR (RET.KEY% = F3.KEY%) THEN BEGIN !CJK

                ! Navigate to Drive disk selection screen
                SCREEN% = DRIVE.DISK.SELECT.SCR%                        !MJK

            ENDIF ELSE BEGIN                                            !MJK
                IF VALUE.INDEX% = XRE.ZERO% THEN BEGIN                  !MJK
                    CALL DM.FOCUS ("1", STATUS.TEXT.ERROR$(21) + \      !IDC
                                   STATUS.TEXT.MSG$(58))                !IDC
                ENDIF ELSE BEGIN
                    IF RET.KEY% = ENTER.KEY% THEN BEGIN

                        ! Check the entry in day selection screen
                        SCREEN.NUM% = DRIVE.PROCESS.SCR%                !MJK
                        GOSUB CHECK.DAY.SELECTION                       !IDC

                        ! If any error in function, set same screen
                        IF NOT FUNCTION.ERROR.NOT.EXIST THEN BEGIN      !EJK
                            SCREEN% = DRIVE.DAY.SELECT.SCR%             !EJK
                        ENDIF                                           !EJK

                    ENDIF ELSE BEGIN
                        ! B001 Invalid key pressed
                        CALL DM.FOCUS ("1", STATUS.TEXT.ERROR$(20))     !IDC
                    ENDIF
                ENDIF                                                   !MJK
            ENDIF
        ENDIF ELSE IF SCREEN% = DRIVE.PROCESS.SCR% THEN BEGIN           !MJK
            ! Display and Process Drives                                !MJK
            GOSUB PROCESS.DRIVE.RESTORE                                 !MJK
        ENDIF

    WEND

RETURN

\***********************************************************************
\*
\* PROCESS.DRIVE.RESTORE: This Subroutine uses the values entered in
\*                        previous pages and starts the restoration
\*                        process for DRIVE(S).
\*
\***********************************************************************
PROCESS.DRIVE.RESTORE:

    ! Changed the help screen to zero, as it is not needed
    CALL DM.SHOW.SCREEN(4, XRE.NULL$, XRE.ZERO%, XRE.ZERO%)             !GJK

    BKP.INDEX%        = XRE.ZERO%
    RESTORE.ERR.EXIST = FALSE

    STATUS.MSG$ = BKP.DATE.ARRAY$(SEL.INDEX%) + STATUS.TEXT.MSG$(24) + \!JDC
                  STATUS.TEXT.MSG$(63)
    GOSUB LOG.STATUS.MSG

    !----------------------------------------------------------!
    ! Setting the BKP.INDEX% and FULL.TO.MOVING.DATE$ based    !        !IDC
    ! on the selected DAY and depending on the SET values the  !
    ! restoration process will happen                          !
    !----------------------------------------------------------!

    GOSUB SET.BACKUP.INDEX                                              !IDC

    ! match for the day and set according to the Full backup day        !IDC
    BKP.INDEX% = LONG.DAY.INDEX%                                        !IDC
    F02.DATE$  = BKP.DATE.ARRAY$(SEL.INDEX%)                            !IDC
    FUN.RC2%   = XRE.ZERO%                                              !MJK

    IF BKP.INDEX% <> 0 THEN BEGIN                                       !IDC
        FUN.RC2% = UPDATE.DATE( ((BKP.INDEX% - 1)* -1 ) )               !MJK
    ENDIF                                                               !IDC

    ! Checking the Return code
    GOSUB CHECK.UPDATE.DATE.RC                                          !IDC
    FULL.TO.MOVING.DATE$ = F02.DATE$                                    !IDC

    ! Storing the Full date                                             !JDC
    FULL.DATE$ = FULL.TO.MOVING.DATE$                                   !IDC

    ! If C drive is selected
    IF CDRIVE$ = "X" THEN BEGIN

        STATUS.MSG$ = STATUS.TEXT.MSG$(25)                              !JDC
        GOSUB LOG.STATUS.MSG

        ! Setting the drive value as "C"
        DRIVE$ = "C"

        ! Reading the BACKUP directories using index
        FOR INDEX% = 1 TO BKPSCRPT.INDEX%
            ! Checking the C directory alone
            IF UCASE$(LEFT$(BKPSCRPT.DIRECTORIES$(INDEX%),1)) = DRIVE$ \
            THEN BEGIN
                ! Setting the Dynamic directory value                   !GJK
                IF POSF(5) = 5 THEN BEGIN                               !GJK
                    CALL PUTF(BKPSCRPT.DIRECTORIES$(INDEX%))            !GJK
                ENDIF                                                   !GJK
                ! Setting the file name based on selected drive
                BKPFAIL.PREFIX$    = D.BKP.IMG$ + "BKPFAILC."           !MJK
                BKPLIST.CURR.FILE$ = BKPLIST.PREFIX.D.DRIVE$            !MJK
                ! Perform the C drive backup process
                GOSUB PERFORM.BACKUP.DRIVE
            ENDIF
        NEXT INDEX%

        CALL DM.STATUS (STATUS.TEXT.MSG$(59))                           !IDC
        !-------------------------------------!
        ! Check the BKPLIST file to make sure !
        ! relevant files alone present        !
        !-------------------------------------!
        GOSUB PROCESS.BKPLIST.FILE
        ! Backing up configuration files. e.g. BKPLIST.MDD              !MJK
        GOSUB BACKUP.CONFIG.FILES                                       !MJK

    ENDIF

    ! If D drive is selected
    IF DDRIVE$ = "X" THEN BEGIN

        STATUS.MSG$ = STATUS.TEXT.MSG$(26)                              !JDC
        GOSUB LOG.STATUS.MSG

        ! Setting the drive value as "D"
        DRIVE$ = "D"

        ! Reading the BACKUP directories using index
        FOR INDEX% = 1 TO BKPSCRPT.INDEX%
            ! Checking the D directory alone
            IF UCASE$(LEFT$(BKPSCRPT.DIRECTORIES$(INDEX%),1)) = DRIVE$ \
            THEN BEGIN
                ! Setting the Dynamic directory value                   !GJK
                IF POSF(5) = 5 THEN BEGIN                               !GJK
                    CALL PUTF(BKPSCRPT.DIRECTORIES$(INDEX%))            !GJK
                ENDIF                                                   !GJK
                ! Setting the file name based on selected drive
                BKPFAIL.PREFIX$    = C.BKP.IMG$ + "BKPFAILD."           !MJK
                BKPLIST.CURR.FILE$ = BKPLIST.PREFIX.C.DRIVE$            !MJK
                ! Perform the D drive backup process
                GOSUB PERFORM.BACKUP.DRIVE
            ENDIF
        NEXT INDEX%

        CALL DM.STATUS (STATUS.TEXT.MSG$(59))                           !IDC
        !-------------------------------------!
        ! Check the BKPLIST file to make sure !
        ! relevant files alone present        !
        !-------------------------------------!
        GOSUB PROCESS.BKPLIST.FILE
        ! Backing up configuration files. e.g. BKPLIST.MDD              !MJK
        GOSUB BACKUP.CONFIG.FILES                                       !MJK

    ENDIF

    ! Set the visibility OFF for unrelated fields
    CALL DM.VISIBLE ("3", STATUS.TEXT.MSG$(60))                         !IDC
    CALL DM.VISIBLE ("5", STATUS.TEXT.MSG$(60))                         !IDC
    CALL DM.VISIBLE ("6", STATUS.TEXT.MSG$(60))                         !IDC
    CALL DM.VISIBLE ("7", STATUS.TEXT.MSG$(60))                         !IDC

    FIELD$(3) = XRE.SPACE$
    FIELD$(5) = XRE.SPACE$
    FIELD$(6) = XRE.SPACE$
    FIELD$(7) = XRE.SPACE$

    ! Depending on the drive selection, the field value gets displayed
    IF CDRIVE$ = "X" AND DDRIVE$ <> "X" THEN BEGIN
        FIELD$(4) = STATUS.TEXT.MSG$(62) + SCREEN.TEXT.MSG$(24)         !MJK
    ENDIF ELSE BEGIN                                                    !NJK
        IF DDRIVE$ = "X" AND CDRIVE$ <> "X" THEN BEGIN                  !NJK
            FIELD$(4) = STATUS.TEXT.MSG$(62) + SCREEN.TEXT.MSG$(23)     !MJK
        ENDIF ELSE BEGIN
            FIELD$(4) = STATUS.TEXT.MSG$(62) + SCREEN.TEXT.MSG$(25)     !MJK
        ENDIF
    ENDIF                                                               !NJK

    GOSUB COPY.OS.BLANK.FILES                                           !JDC

    ! If any error occurs in extraction process
    IF RESTORE.ERR.EXIST THEN BEGIN

        CALL DM.STATUS (SCREEN.TEXT.MSG$(26))                           !JDC
        STATUS.MSG$ = STATUS.TEXT.MSG$(5)                               !JDC
        GOSUB LOG.STATUS.MSG

    ENDIF ELSE BEGIN
    ! If no errors found

        CALL DM.STATUS ("'Restore completed successfully")
        STATUS.MSG$ = "Restore completed successfully"
        GOSUB LOG.STATUS.MSG

    ENDIF

    WHILE SCREEN% = DRIVE.PROCESS.SCR%                                  !CJK
        RET.KEY% = DM.PROCESS.SCREEN (3, 7, FALSE)

        IF RET.KEY% = ESC.KEY% THEN BEGIN                               !MJK
            ! Set the Drive screen
            SCREEN%      = DRIVE.DAY.SELECT.SCR%                        !MJK
            PREVIOUS.KEY = TRUE

        ENDIF ELSE BEGIN

            CALL DM.FOCUS ("1", SCREEN.TEXT.MSG$(13) + \                !JDC
                                SCREEN.TEXT.MSG$(29))                   !MJK
        ENDIF

    WEND

RETURN

! duplicated subroutine
%INCLUDE XREST00E.J86                                                   !NJK
\************************************************************************
\***                                                                    *
\***           %INCLUDE FOR REPEATED SUBROUTINES IN XRESTORE            *
\***                                                                    *
\***                    REFERENCE: XREST00E.J86                         *
\***                                                                    *
\***                                                                    *
\*** Version A              Dave Constable                   05/06/2014 *
\*** FOD260 - Enhanced Backup and Recovery                              *
\***                                                                    *
\*** Version B              Dave Constable                   25/06/2014 *
\*** FOD260 - Enhanced Backup and Recovery                              *
\*** QC775 - Incorrect file extension check changed                     *
\*** QC750 - Added OS file copy that used to be in CRESTORE batch       *
\*** Code review changes; alignment of file open status                 *
\***                                                                    *
\*** Version C                 Jaya Kumar Inbaraj            23/08/2014 *
\*** FOD260 - Enhanced Backup and Recovery                              *
\*** CR5 changes to perform the drive restore if a drive is empty.      *
\*** Also commented out few redundant labels and worked on Internal     *
\*** and APPS management review comments.                               *
\***                                                                    *
\*** Version D                 Jaya Kumar Inbaraj            04/09/2014 *
\*** FOD260 - Enhanced Backup and Recovery                              *
\*** Worked on APPS management review comments.                         *
\***                                                                    *
\************************************************************************

\************************************************************************
\*
\* SET.BACKUP.INDEX: Setting the BKP.INDEX% and FULL.TO.MOVING.DATE$
\*                   based on the selected DAY and depending on the SET
\*                   values the restoration process will happen
\*
\************************************************************************
SET.BACKUP.INDEX:

    ! Match for the long day name and set using the offset              !CJK
    LONG.DAY.INDEX% = MATCH( LEFT$(DAY.ARRAY$(SEL.INDEX%)        + \    !CJK
                      STRING$(CONSTANT.LONGEST.DAY%, XRE.SPACE$),  \    !CJK
                      CONSTANT.LONGEST.DAY%), BACKUP.LONG.DAYS$,1)      !CJK
    ! Use the offset to calculate the index                             !CJK
    LONG.DAY.INDEX% = ((LONG.DAY.INDEX%-1) / CONSTANT.LONGEST.DAY%) + 1

RETURN

\***********************************************************************
\*
\* GET.BKP.DETAILS: This function receives the Primary and secondary
\*                  backup file (without extension) as an input. Then
\*                  it checks the availability of archived files based
\*                  on number of BKP.DAYS and store it in arrays for
\*                  Screen to display.
\*
\***********************************************************************
GET.BKP.DETAILS:

    FUNCTION.ERROR.NOT.EXIST = TRUE

    BEGIN.POSITION% = 4        ! To Ignore the Drive being checked      !CJK
    SLASH.POSITION% = XRE.ZERO%                                         !CJK
    VALUE.EXISTS    = TRUE                                              !CJK

    DIM BKP.FILE.MDD.ARRAY$(ARRAY.LIMIT%)                               !CJK
    DIM BKP.DATE.ARRAY$(ARRAY.LIMIT%)                                   !CJK

    ! Extracting the archive file name
    WHILE VALUE.EXISTS
        SLASH.POSITION% = MATCH("\\", FIRST.FILE$, BEGIN.POSITION%)

        IF SLASH.POSITION% > XRE.ZERO% THEN BEGIN
            ! Move to next position to search next field
            BEGIN.POSITION% = SLASH.POSITION% + 1
        ENDIF ELSE BEGIN
            FILENAME$ = MID$(FIRST.FILE$,BEGIN.POSITION%, \
                            (LEN(FIRST.FILE$) - BEGIN.POSITION% + 1))
            VALUE.EXISTS = FALSE
        ENDIF
    WEND

    ! Getting all the archive files from Primary backup location
    CALL OSSHELL("DIR " + FIRST.FILE$ + ".* > " + DIR.OUT$ + " >>* " + \
                 DIR.OUT$ )

    CALL OSSHELL("DIR " + SECOND.FILE$ + ".* >> " + DIR.OUT$     + \
                 " >>* " + DIR.OUT$ )

    DIR.FILE.RC% = FUNC.OPEN.SEQUENTIAL.FILE( DIR.OUT$ )                !DJK

    ! If file open unsuccessful
    IF DIR.FILE.RC% <= XRE.ZERO% THEN BEGIN
        STATUS.MSG$ = "Error in opening DIR output file"
        GOSUB LOG.STATUS.MSG
        DIR.OPEN                 = FALSE
        FUNCTION.ERROR.NOT.EXIST = FALSE
!        RETURN                                                         !DJK
    ENDIF ELSE BEGIN
        DIR.OPEN = TRUE
    ENDIF

    FOR F.RECORD.COUNT% = 1 TO 4
        ! Ignoring the first 4 lines
        DIR.VALUE$ = FUNC.READ.SEQUENTIAL.FILE( DIR.FILE.RC% )          !DJK
    NEXT F.RECORD.COUNT%

    BKP.INDEX% = XRE.ZERO%

    WHILE LEN(DIR.VALUE$) <> XRE.ZERO%
        DIR.VALUE$ = FUNC.READ.SEQUENTIAL.FILE( DIR.FILE.RC% )          !DJK
        ! we treat an error here as end of file and drop out
        !--------------------------------------------------------!
        ! Checking the file name and also making sure that the   !      !BDC
        ! extension is numeric value ending                      !      !BDC
        !--------------------------------------------------------!      !BDC
        IF LEFT$(DIR.VALUE$,LEN(FILENAME$)) = FILENAME$     AND     \   !CJK
           MATCH("!",MID$(DIR.VALUE$,11,2) ,1) = XRE.ZERO% THEN BEGIN   !CJK

            DIR.VALUE$ = MID$(DIR.VALUE$,10,3)

            DUPLICATE.RECORD = FALSE                                    !CJK

            ! To make sure duplicate records are not added              !CJK
            IF BKP.INDEX% > XRE.ZERO% THEN BEGIN                        !CJK
                FOR INDEX% = 1 TO BKP.INDEX%                            !CJK
                    IF BKP.FILE.MDD.ARRAY$(INDEX%) = DIR.VALUE$ \       !CJK
                    THEN BEGIN                                          !CJK
                        DUPLICATE.RECORD = TRUE                         !CJK
                    ENDIF                                               !CJK
                NEXT INDEX%                                             !CJK
            ENDIF                                                       !CJK

            ! Checking the BKP.INDEX% to avoid out of bound error
            IF BKP.INDEX% < ARRAY.LIMIT% THEN BEGIN                     !CJK
                IF NOT DUPLICATE.RECORD THEN BEGIN                      !CJK
                    BKP.INDEX% = BKP.INDEX% + 1                         !CJK
                    ! Storing the MDD value in an array
                    BKP.FILE.MDD.ARRAY$(BKP.INDEX%) = DIR.VALUE$
                ENDIF                                                   !CJK
            ENDIF ELSE BEGIN
                STATUS.MSG$ = "'MDD array index error"
                GOSUB LOG.STATUS.MSG
                DIR.VALUE$               = XRE.NULL$                    !CJK
                FUNCTION.ERROR.NOT.EXIST = FALSE
                !-----------------------------------------------------! !CJK
                ! As the array index overflow happened, further read  ! !CJK
                ! is not required and hence setting the value to NULL ! !CJK
                ! to exit the WHILE loop                              ! !CJK
                !-----------------------------------------------------! !CJK
                DIR.VALUE$ = XRE.NULL$                                  !CJK
            ENDIF
        ENDIF
    WEND

    ! Closing File
    IF DIR.OPEN THEN BEGIN
        CALL FUNC.CLOSE.FILE( DIR.FILE.RC% )                            !DJK
        DIR.OPEN = FALSE
    ENDIF

    VALUE.INDEX% = XRE.ZERO%
    TODAY.DATE$  = DATE$

    !--------------------------------------------------------!
    ! As BKP.INDEX is used as an index parameter for all the !
    ! arrays in below FOR loop, checking the index to avoid  !
    ! out of bound error                                     !
    !--------------------------------------------------------!
    IF BKP.INDEX% > ARRAY.LIMIT% THEN BEGIN                             !CJK
        STATUS.MSG$ = "'BKP array index error"
        GOSUB LOG.STATUS.MSG
        FUNCTION.ERROR.NOT.EXIST = FALSE
!        RETURN                                                         !DJK
        ! Setting zero as there is an array limit breach                !DJK
        BKP.INDEX% = XRE.ZERO%                                          !DJK
    ENDIF

    ! If Backup available
    IF BKP.INDEX% <> XRE.ZERO% THEN BEGIN
        ! Checking last 14 days
        FOR LOOP% = 1 TO BKP.DAYS%
            ! Storing MMDD in a variable
            WORK.DATE.MMDD$ = RIGHT$(TODAY.DATE$,4)
            ! Checking the available backup dates
            FOR INDEX% = 1 TO BKP.INDEX%

                ! Getting the Month and date in MDD format
                IF LEFT$(BKP.FILE.MDD.ARRAY$(INDEX%),1) = "C" THEN BEGIN!CJK
                    BKP.FILE.MMDD.ARRAY$(INDEX%) = "12"   + \           !CJK
                        RIGHT$(BKP.FILE.MDD.ARRAY$(INDEX%),2)           !CJK
                ENDIF ELSE \
                IF LEFT$(BKP.FILE.MDD.ARRAY$(INDEX%),1) = "B" THEN BEGIN!CJK
                    BKP.FILE.MMDD.ARRAY$(INDEX%) = "11"   + \           !CJK
                        RIGHT$(BKP.FILE.MDD.ARRAY$(INDEX%),2)           !CJK
                ENDIF ELSE \
                IF LEFT$(BKP.FILE.MDD.ARRAY$(INDEX%),1) = "A" THEN BEGIN!CJK
                    BKP.FILE.MMDD.ARRAY$(INDEX%) = "10"   + \           !CJK
                        RIGHT$(BKP.FILE.MDD.ARRAY$(INDEX%),2)           !CJK
                ENDIF ELSE BEGIN
                    BKP.FILE.MMDD.ARRAY$(INDEX%) = "0"    + \           !CJK
                        BKP.FILE.MDD.ARRAY$(INDEX%)                     !CJK
                ENDIF

                ! If the Work date is available, store it in array
                IF BKP.FILE.MMDD.ARRAY$(INDEX%) = WORK.DATE.MMDD$ \
                THEN BEGIN

                    VALUE.INDEX% = VALUE.INDEX% + 1

                    ! Checking the VALUE.INDEX% to avoid out of bound
                    IF VALUE.INDEX% < ARRAY.LIMIT% THEN BEGIN           !CJK

                        ! Storing the date and MMDD
                        BKP.DATE.ARRAY$(VALUE.INDEX%)  = TODAY.DATE$
                        BKP.AVAIL.ARRAY$(VALUE.INDEX%) = WORK.DATE.MMDD$

                        FUN.RC2% = PSDATE(TODAY.DATE$)

                        ! Checking the return value
                        IF FUN.RC2% <> XRE.ZERO% THEN BEGIN
                            STATUS.MSG$ = "PSDATE function error"
                            GOSUB LOG.STATUS.MSG
                            DAY.ARRAY$(VALUE.INDEX%) = "Date error"
                            FUNCTION.ERROR.NOT.EXIST = FALSE
                        ENDIF ELSE BEGIN
                            ! Storing the DAY value
                            IF F13.DAY$ = "SUN" THEN BEGIN
                                DAY.ARRAY$(VALUE.INDEX%) = "Sunday"
                            ENDIF ELSE IF F13.DAY$ = "MON" THEN BEGIN
                                DAY.ARRAY$(VALUE.INDEX%) = "Monday"
                            ENDIF ELSE IF F13.DAY$ = "TUE" THEN BEGIN
                                DAY.ARRAY$(VALUE.INDEX%) = "Tuesday"
                            ENDIF ELSE IF F13.DAY$ = "WED" THEN BEGIN
                                DAY.ARRAY$(VALUE.INDEX%) = "Wednesday"
                            ENDIF ELSE IF F13.DAY$ = "THU" THEN BEGIN
                                DAY.ARRAY$(VALUE.INDEX%) = "Thursday"
                            ENDIF ELSE IF F13.DAY$ = "FRI" THEN BEGIN
                                DAY.ARRAY$(VALUE.INDEX%) = "Friday"
                            ENDIF ELSE IF F13.DAY$ = "SAT" THEN BEGIN
                                DAY.ARRAY$(VALUE.INDEX%) = "Saturday"
                            ENDIF
                        ENDIF

                    ENDIF ELSE BEGIN
                        STATUS.MSG$  = "'MDD array index error"
                        GOSUB LOG.STATUS.MSG
                        FUNCTION.ERROR.NOT.EXIST = FALSE
!                        RETURN                                         !DJK
                        LOOP%  = BKP.DAYS%  + 10   ! force to exit      !CJK
                        INDEX% = BKP.INDEX% + 10   ! force to exit      !CJK
                    ENDIF
                ENDIF
            NEXT INDEX%

            IF INDEX% < (BKP.INDEX% + 10) THEN BEGIN                    !CJK
                F02.DATE$ = TODAY.DATE$
                FUN.RC2%  = UPDATE.DATE( -1 )           ! Reduce one day!CJK

                GOSUB CHECK.UPDATE.DATE.RC

                TODAY.DATE$ = F02.DATE$
            ENDIF

        NEXT LOOP%
    ENDIF

RETURN

\***********************************************************************
\*
\* EXTRACT.BKPLIST.FIELDS:  This function receives the line value of
\*                          BKPLIST, process it and return the
\*                          individual BKPLIST field values for use.
\*
\***********************************************************************
EXTRACT.BKPLIST.FIELDS:

    FUNCTION.ERROR.NOT.EXIST = TRUE

    BKPLIST.VALUE$ = BKPLIST.DIR.VALUE$

    DIM BKPLIST.FIELD$(0)         ! Clear the array memory allocation
    DIM BKPLIST.FIELD$(15)        ! To store BKPLIST values

    BEGIN.POS%    = 1           ! Begin search position                 !CJK
    INDEX%        = XRE.ZERO%   ! Index for Field Array                 !CJK
    VALUE.PRESENT = TRUE        ! While Boolean                         !CJK

    !----------------------------------------------------------!
    ! Extracting all the variables using comma separator value !
    !----------------------------------------------------------!
    WHILE VALUE.PRESENT
        ! Get index of next field delimiter
        MATCH.POS% = MATCH(COMMA.VALUE$,BKPLIST.VALUE$,BEGIN.POS%)

        INDEX%     = INDEX% + 1     ! Incrementing the index            !CJK

        ! Checking the INDEX% to avoid out of bound error
        IF VALUE.INDEX% > ARRAY.LIMIT% THEN BEGIN                       !CJK
            STATUS.MSG$ = "'MDD array index error"
            GOSUB LOG.STATUS.MSG
            FUNCTION.ERROR.NOT.EXIST = FALSE
            !-----------------------------------------------------!     !CJK
            ! As the array index overflow happened, further check !     !CJK
            ! is not required and hence setting the value to      !     !CJK
            ! FALSE to exit the WHILE loop                        !     !CJK
            !-----------------------------------------------------!     !CJK
            VALUE.PRESENT = FALSE                                       !CJK
        ENDIF

        ! If we found a field delimiter
        IF MATCH.POS% > XRE.ZERO% THEN BEGIN
            ! Get contents of field
            BKPLIST.FIELD$(INDEX%) = MID$(BKPLIST.VALUE$, BEGIN.POS%, \
                                     (MATCH.POS% - BEGIN.POS%)  )
            ! Move next start position past field delimiter
            BEGIN.POS% = MATCH.POS% + 1
        ENDIF ELSE BEGIN
            ! Else we're at the last field
            VALUE.PRESENT = FALSE
        ENDIF
    WEND

    ! Storing the values
    BKPLI.FILENAME$                 = BKPLIST.FIELD$(1)
    BKPLI.FULL.EXIST$               = BKPLIST.FIELD$(2)
    BKPLI.FULL.FILE.CHNG$           = BKPLIST.FIELD$(3)
    BKPLI.INCREMENTAL.EXIST$(1)     = BKPLIST.FIELD$(4)
    BKPLI.INCREMENTAL.FILE.CHNG$(1) = BKPLIST.FIELD$(5)
    BKPLI.INCREMENTAL.EXIST$(2)     = BKPLIST.FIELD$(6)
    BKPLI.INCREMENTAL.FILE.CHNG$(2) = BKPLIST.FIELD$(7)
    BKPLI.INCREMENTAL.EXIST$(3)     = BKPLIST.FIELD$(8)
    BKPLI.INCREMENTAL.FILE.CHNG$(3) = BKPLIST.FIELD$(9)
    BKPLI.INCREMENTAL.EXIST$(4)     = BKPLIST.FIELD$(10)
    BKPLI.INCREMENTAL.FILE.CHNG$(4) = BKPLIST.FIELD$(11)
    BKPLI.INCREMENTAL.EXIST$(5)     = BKPLIST.FIELD$(12)
    BKPLI.INCREMENTAL.FILE.CHNG$(5) = BKPLIST.FIELD$(13)
    BKPLI.INCREMENTAL.EXIST$(6)     = BKPLIST.FIELD$(14)
    BKPLI.INCREMENTAL.FILE.CHNG$(6) = BKPLIST.FIELD$(15)

RETURN

\***********************************************************************
\*
\* CHECK.DAY.SELECTION: This function checks the DAY selection on
\*                      process. If successful selection, it sets
\*                      the passed screen number.
\*
\***********************************************************************
CHECK.DAY.SELECTION:

    FUNCTION.ERROR.NOT.EXIST = TRUE

    INPUT.LOOP%   = INPUT.INDEX%    ! First input field value
    SEL.INDEX%    = XRE.ZERO%
    SELECT.COUNT% = XRE.ZERO%
    NON.X.VALUES  = FALSE

    ! Checking the inputs entered
    FOR LOOP% = 1 TO VALUE.INDEX%

        ! If field contains any value
        IF FIELD$(INPUT.LOOP%) <> XRE.SPACE$ THEN BEGIN

            ! If entered value is not X
            IF UCASE$(FIELD$(INPUT.LOOP%)) <> "X" THEN BEGIN
                NON.X.VALUES = TRUE
            ENDIF ELSE BEGIN
                SEL.INDEX% = LOOP%
            ENDIF

            ! Increment the value to check the multiple selection
            SELECT.COUNT% = SELECT.COUNT% + 1
        ENDIF
        ! Increment to move to the next input field record
        INPUT.LOOP% = INPUT.LOOP% + 1
    NEXT LOOP%

    ! If multiple selections made
    IF SELECT.COUNT% > 1 THEN BEGIN
        FIELD$(1) = "'Multiple selections not allowed"
    ENDIF ELSE BEGIN

        ! If only one selection made and X value is entered
        IF SELECT.COUNT% = 1 AND NOT NON.X.VALUES THEN BEGIN
            SCREEN% = SCREEN.NUM%

        ! If no selection has been made
        ENDIF ELSE BEGIN
            FIELD$(1) = "'No selection has been made. "              + \
                        "Value entered must be ""X"" OR ""x"" "
        ENDIF
    ENDIF

RETURN

\***********************************************************************
\*
\* LOG.STATUS.MSG: Writes status message to log file
\*
\***********************************************************************
LOG.STATUS.MSG:

    IF XRE.LOG.OPEN THEN BEGIN

        ! DD/MM/YY, HH:MM:SS, Text and a CRLF
        STATUS.MSG$ = RIGHT$(DATE$,2) + "/"        + \    ! DD/         !CJK
                      MID$(DATE$,3,2) + "/"        + \    ! MM/         !CJK
                      LEFT$(DATE$,2)  + XRE.SPACE$ + \    ! YY          !CJK
                      LEFT$(TIME$,2)  + ":"        + \    ! HH:         !CJK
                      MID$(TIME$,3,2) + ":"        + \    ! MM:         !CJK
                      RIGHT$(TIME$,2) + XRE.SPACE$ + \    ! SS          !CJK
                      STATUS.MSG$                  + \    ! message     !CJK
                      CRLF$                               ! line return !CJK

        ! Return code is not checked here, as it is not mandatory.
        ! Checking return code is not required here, as it is a         !CJK
        ! screen program and displaying any error for logging might     !CJK
        ! confuse the user from actual restore functionality            !CJK
        FILE.RC% = FUNC.WRITE.SEQUENTIAL.FILE(XRE.FILE.RC%, STATUS.MSG$)!DJK

    ENDIF

RETURN

\***********************************************************************
\*
\* CHECK.UPDATE.DATE.RC: If FUN.RC2% is not equal to zero ... logs
\*                       the error for reference.
\***********************************************************************
CHECK.UPDATE.DATE.RC:

    ! Checking the return value
    IF FUN.RC2% <> XRE.ZERO% THEN BEGIN
        STATUS.MSG$ = "UPDATE date function error in " + F02.DATE$
        GOSUB LOG.STATUS.MSG
    ENDIF

RETURN

\***********************************************************************
\*
\*   GET.FILE.EXTENSION: Calculate the extension needed based on month
\*                       and day using month A/B/C for 10/11/12
\*
\***********************************************************************
GET.FILE.EXTENSION:

    EXTENSION$ = RIGHT$(FULL.TO.MOVING.DATE$, 4)

    ! Storing the Month and Date in MDD format in new logic
    IF LEFT$(EXTENSION$,2) = "12" THEN BEGIN            ! If Dec(12)    !CJK
        EXTENSION$ = "C" + RIGHT$(EXTENSION$, 2)
    ENDIF ELSE IF LEFT$(EXTENSION$,2) = "11" THEN BEGIN ! If Nov(11)    !CJK
        EXTENSION$ = "B" + RIGHT$(EXTENSION$, 2)
    ENDIF ELSE IF LEFT$(EXTENSION$,2) = "10" THEN BEGIN ! If Oct(10)    !CJK
        EXTENSION$ = "A" + RIGHT$(EXTENSION$, 2)
    ENDIF ELSE BEGIN                            ! Rest of the Month
        EXTENSION$ = RIGHT$(EXTENSION$, 3)
    ENDIF

RETURN

!* START CHANGE BLOCK FOR BDC
\***********************************************************************
\*
\* COPY.OS.BLANK.FILES: Copy the blank OS files needed that the old
\*                      CRESTORE batch file used to do
\*
\***********************************************************************
COPY.OS.BLANK.FILES:

    DIM OS.FILE$(0)
    DIM OS.FILE$(8)

    ! set the required files
    OS.FILE$(1) = "ADXCSOAF.DAT"
    OS.FILE$(2) = "ADXCSOBF.DAT"
    OS.FILE$(3) = "ADXCSOCF.DAT"
    OS.FILE$(4) = "ADXCSODF.DAT"
    OS.FILE$(5) = "ADXCSOEF.DAT"
    OS.FILE$(6) = "ADXCSOFF.DAT"
    OS.FILE$(7) = "ADXCSOIF.DAT"
    OS.FILE$(8) = "ADXCSONF.DAT"

    ! set the source and destination for copy
    OS.DESTINATION$ = "C:\ADX_SDT1\"
    OS.SOURCE$      = "D:\ADX_UPGM\"

    FOR SELECT.COUNT% = 1 TO 8
        ! Copying the file from TEMP to the entered location
        CALL OSSHELL("COPY " + OS.SOURCE$ + OS.FILE$(SELECT.COUNT%) + \ !CJK
                     XRE.SPACE$ + OS.DESTINATION$                   + \ !CJK
                     " > " + DIR.OUT$ + " >>* " + DIR.OUT$)

        DIR.FILE.RC% = FUNC.OPEN.SEQUENTIAL.FILE( DIR.OUT$ )            !DJK

        ! If file open unsuccessful
        IF DIR.FILE.RC% <= XRE.ZERO% THEN BEGIN
            DIR.OPEN    = FALSE                                         !CJK
            STATUS.MSG$ = "Error in opening DIR output file"
            GOSUB LOG.STATUS.MSG
            ! Setting NULL to avoid file read
            DIR.VALUE$ = XRE.NULL$
        ENDIF ELSE BEGIN
            DIR.OPEN   = TRUE
            DIR.VALUE$ = XRE.SPACE$
        ENDIF

        ! Read the file till EOF or read error
        WHILE LEN(DIR.VALUE$) <> XRE.ZERO%
            DIR.VALUE$ = FUNC.READ.SEQUENTIAL.FILE( DIR.FILE.RC% )      !DJK

            !-----------------------------------------------!
            ! If error string matches, write the error with !
            ! file name in LOG file                         !
            !-----------------------------------------------!
            IF MATCH(UCASE$("Error extracting file"),   \               !CJK
                     UCASE$(DIR.VALUE$),1) <> XRE.ZERO% THEN BEGIN      !CJK
                ! Logging copy error                                    !CJK
                STATUS.MSG$ = "Error when copying OS file " + \
                              OS.FILE$(SELECT.COUNT%)
                GOSUB LOG.STATUS.MSG
                RESTORE.STATUS = FALSE
            ENDIF
        WEND

        ! Closing File
        IF DIR.OPEN THEN BEGIN
            CALL FUNC.CLOSE.FILE( DIR.FILE.RC% )                        !DJK
            DIR.OPEN = FALSE
        ENDIF
    NEXT SELECT.COUNT%
RETURN
!* END CHANGE BLOCK FOR BDC


! Commenting out unused Sub-routine                                     !OJK
\***********************************************************************!OJK
\*                                                                      !OJK
\*    HOW.MANY.DAYS.SINCE.FULL: This Subroutine matches the day set     !OJK
\*                              in F13.DAY and sets the number of days  !OJK
\*                              since the Full backup was taken for     !OJK
\*                              this day                                !OJK
\*                                                                      !OJK
\***********************************************************************!OJK
!HOW.MANY.DAYS.SINCE.FULL:                                              !OJK
                                                                        !OJK
!    ! match for the day and set using the offset as days before        !OJK
!    DAYS.AFTER.FULL.BAKUP% = MATCH(":"+F13.DAY$, BACKUP.DAYS$,1)       !OJK
!    DAYS.AFTER.FULL.BAKUP% = (DAYS.AFTER.FULL.BAKUP%-1)/4              !OJK
                                                                        !OJK
!RETURN                                                                 !OJK

\***********************************************************************
\*
\* PERFORM.BACKUP.DRIVE: This Subroutine performs the Drive backup
\*                       process.
\*
\***********************************************************************
PERFORM.BACKUP.DRIVE:

    CALL DM.STATUS ("'" + BKPSCRPT.DIRECTORIES$(INDEX%)              + \
                    SCREEN.TEXT.MSG$(10) + "Please Wait .....")         !MJK

    STATUS.MSG$ = BKPSCRPT.DIRECTORIES$(INDEX%) + " restoration "    + \
                  "in progress"
    GOSUB LOG.STATUS.MSG

    ! If directory not present create it
    IF FUNC.DIR.NOT.EXISTS(BKPSCRPT.DIRECTORIES$(INDEX%)) THEN BEGIN

        DIRECT.TO.RESTORE$ = BKPSCRPT.DIRECTORIES$(INDEX%)

        ! Trim the last slash found to avoid error using MKDIR
        CALL TRIM   (DIRECT.TO.RESTORE$)
        CALL RTRIMC (DIRECT.TO.RESTORE$, ASC("/"))
        CALL RTRIMC (DIRECT.TO.RESTORE$, ASC("\\"))

        CALL OSSHELL("MKDIR " + DIRECT.TO.RESTORE$ + " >> "          + \
                     DIR.OUT$ + " >>* "  + DIR.OUT$)
        STATUS.MSG$ = DIRECT.TO.RESTORE$ + " directory is created"
        GOSUB LOG.STATUS.MSG

    ENDIF

    ! Store Full day moving date before processing each directory       !JDC
    FULL.TO.MOVING.DATE$ = FULL.DATE$                                   !IDC

    ! Initiating the Directory restore
    FOR LOOP% = 1 TO BKP.INDEX%

        RESTORE.STATUS = FALSE

        STATUS.MSG$ = BKPSCRPT.DIRECTORIES$(INDEX%)               + \   !MJK
                      STATUS.TEXT.MSG$(31) + FULL.TO.MOVING.DATE$ + \   !MJK
                      SCREEN.TEXT.MSG$(16)                              !MJK
        GOSUB LOG.STATUS.MSG

        GOSUB GET.FILE.EXTENSION                                        !IDC
        MDD.DATE$ = EXTENSION$                                          !IDC

        ! Storing the Full MDD                                          !JDC
        IF LOOP% = 1 THEN BEGIN
            FULL.MDD.DATE$ = MDD.DATE$                                  !IDC

            ! BKPLIST current file                                      !MJK
            BKPLIST.CURR.FILE$ = BKPLIST.CURR.FILE$ + FULL.MDD.DATE$    !MJK

        ENDIF

        ! Setting the Backup files based on the 1st field which is drive
        BKP.FILENAME.IMG$ = PRIMARY.ARCHIVED.NAMES$(INDEX%)          + \
                            "." + MDD.DATE$
        BKP.FILENAME.ALT$ = SECONDARY.ARCHVD.NAMES$(INDEX%)          + \
                            "." + MDD.DATE$

        ! Current BKPFAIL file
        BKPFAIL.CURR.FILE$ = BKPFAIL.PREFIX$ + MDD.DATE$                !MJK

        STATUS.MSG$ = "Checking BKPFAIL " + BKPFAIL.CURR.FILE$
        GOSUB LOG.STATUS.MSG

        DIR.FILE.RC% = FUNC.OPEN.SEQUENTIAL.FILE( BKPFAIL.CURR.FILE$ )  !NJK

        ! If file open unsuccessful
        IF DIR.FILE.RC% <= XRE.ZERO% THEN BEGIN
            ! Setting NULL to avoid file read
            DIR.VALUE$ = XRE.NULL$
            DIR.OPEN   = FALSE                                          !CJK
        ENDIF ELSE BEGIN
            DIR.OPEN   = TRUE
            DIR.VALUE$ = XRE.SPACE$
        ENDIF
        !-------------------------------------------------------------!
        ! Reading the file till the EOF file reached. C file function !
        ! returns NULL when EOF reached or error                      !FDC
        !-------------------------------------------------------------!
        WHILE LEN(DIR.VALUE$) <> XRE.ZERO%
            DIR.VALUE$ = FUNC.READ.SEQUENTIAL.FILE( DIR.FILE.RC% )      !NJK

            ! Checking the comma position
            COMMA.POSITION% = MATCH(COMMA.VALUE$,DIR.VALUE$,1)

            ! If comma found and drive matches
            IF COMMA.POSITION% <> XRE.ZERO% THEN BEGIN                  !GJK

                ! Storing the failed file                               !MJK
                FAILED.FILE$ = LEFT$(DIR.VALUE$,(COMMA.POSITION% - 1))
                ! Storing the Distribution type                         !MJK
                FAILED.FILE.DIST$ = MID$(DIR.VALUE$,            \       !MJK
                                        (COMMA.POSITION% + 1),1)        !MJK
                ! If directory in BKPFAIL matches with current directory!GJK
                IF (BKPSCRPT.DIRECTORIES$(INDEX%)) =                   \!GJK
                    LEFT$(FAILED.FILE$,                                \!GJK
                    LEN(BKPSCRPT.DIRECTORIES$(INDEX%))) THEN BEGIN      !MJK

                    BEGIN.POSITION% = 4         ! Setting the begin position
                    SLASH.POSITION% = XRE.ZERO%
                    VALUE.EXISTS    = TRUE
                    FILENAME$       = XRE.NULL$

                    WHILE VALUE.EXISTS
                        SLASH.POSITION% = MATCH("\\", FAILED.FILE$, \   !MJK
                                                 BEGIN.POSITION%)

                        IF SLASH.POSITION% > XRE.ZERO% THEN BEGIN
                            ! Move to next position to search next field
                            BEGIN.POSITION% = SLASH.POSITION% + 1
                        ENDIF ELSE BEGIN
                            FILENAME$ = MID$(FAILED.FILE$,          \   !MJK
                                             BEGIN.POSITION%,       \   !MJK
                                             (LEN(FAILED.FILE$) -   \   !MJK
                                              BEGIN.POSITION% + 1))     !MJK
                            ! Storing the file name
                            RESTORE.FILENAME$ = FILENAME$               !LJK
                            ! Checking the dot position                 !MJK
                            MATCH.POS% = MATCH(".", FILENAME$,1)        !LJK
                            IF MATCH.POS% <> XRE.ZERO% THEN BEGIN       !LJK
                                RESTORE.FILENAME$ = LEFT$(FILENAME$, \  !LJK
                                                    (MATCH.POS% - 1))   !LJK
                            ENDIF                                       !LJK
                            VALUE.EXISTS = FALSE
                        ENDIF
                    WEND

                    STATUS.MSG$ = STATUS.TEXT.MSG$(9)                   !JDC
                    GOSUB LOG.STATUS.MSG

                    STATUS.MSG$ = STATUS.TEXT.MSG$(10) + FILENAME$      !MJK
                    GOSUB LOG.STATUS.MSG

                    ! Depending on the drive, XDISKIMG directory will
                    ! be used in copying failed file
                    IF DRIVE$ = "D" THEN BEGIN                          !MJK
                        ! Copying the file to respective directory      !MJK
                        CALL OSSHELL("COPY " + C.BKP.IMG$       + \     !MJK
                                     RESTORE.FILENAME$ + "."    + \     !MJK
                                     MDD.DATE$ + XRE.SPACE$     + \     !MJK
                                     FAILED.FILE$ + " >> "      + \     !MJK
                                     DIR.OUT$ + " >>* " + DIR.OUT$)     !MJK
                    ENDIF ELSE BEGIN                                    !MJK
                        ! Copying the file to respective directory      !MJK
                        CALL OSSHELL("COPY " + D.BKP.IMG$       + \     !MJK
                                     RESTORE.FILENAME$ + "."    + \     !MJK
                                     MDD.DATE$ + XRE.SPACE$     + \     !MJK
                                     FAILED.FILE$ + " >> "      + \     !MJK
                                     DIR.OUT$ + " >>* " + DIR.OUT$)     !MJK
                    ENDIF                                               !MJK

                    !---------------------------------------------!
                    ! Not distributing the file if SUPPS mode, as !
                    ! ADXCSU0L won't work under SUPPS             !
                    !---------------------------------------------!
                    IF NOT SUPPS.ON THEN BEGIN
                        ! Setting the distribution type
                        CALL OSSHELL(ADXCSU0L.FILE.NAME$ + " 3 "    + \ !MJK
                                     FAILED.FILE.DIST$ + XRE.SPACE$ + \ !GJK
                                     FAILED.FILE$ + " >> "          + \ !MJK
                                     DIR.OUT$ + " >>* " + DIR.OUT$ )    !GJK
                    ENDIF

                    DIR.FILE.RC% = FUNC.OPEN.SEQUENTIAL.FILE( DIR.OUT$ )!NJK

                    ! If file open unsuccessful
                    IF DIR.FILE.RC% <= XRE.ZERO% THEN BEGIN
                        DIR.OPEN    = FALSE                             !MJK
                        STATUS.MSG$ = STATUS.TEXT.ERROR$(2)             !JDC
                        GOSUB LOG.STATUS.MSG
                        ! Setting NULL to avoid file read
                        DIR.VALUE$ = XRE.NULL$
                    ENDIF ELSE BEGIN
                        DIR.OPEN   = TRUE
                        DIR.VALUE$ = XRE.SPACE$
                    ENDIF

                    ! Read the file till EOF or read error              !GJK
                    WHILE LEN(DIR.VALUE$) <> XRE.ZERO%
                        DIR.VALUE$ = \                                  !NJK
                            FUNC.READ.SEQUENTIAL.FILE(DIR.FILE.RC%)     !NJK

                        !-----------------------------------------------!
                        ! If error string matches, write the error with !
                        ! file name in LOG file                         !
                        !-----------------------------------------------!
                        IF MATCH("ERROR",UCASE$(DIR.VALUE$),1)        \ !OJK
                           <> XRE.ZERO%                            OR \ !OJK
                           MATCH("cannot be found",(DIR.VALUE$),1) <> \ !OJK
                           XRE.ZERO% THEN BEGIN                         !OJK
                            ! Logging the copy / distribution error
                            STATUS.MSG$ = STATUS.TEXT.ERROR$(14)        !JDC
                            GOSUB LOG.STATUS.MSG
                            STATUS.MSG$ = DIR.VALUE$
                            GOSUB LOG.STATUS.MSG

                            RESTORE.ERR.EXIST = TRUE                    !OJK
                            ! To break the WHILE loop                   !OJK
                            DIR.VALUE$ = XRE.NULL$                      !OJK
                        ENDIF
                    WEND

                    ! Closing File
                    IF DIR.OPEN THEN BEGIN
                        CALL FUNC.CLOSE.FILE( DIR.FILE.RC% )            !NJK
                        DIR.OPEN = FALSE
                    ENDIF
                ENDIF                                                   !GJK
            ENDIF
        WEND

        ! Closing File
        IF DIR.OPEN THEN BEGIN
            CALL FUNC.CLOSE.FILE( DIR.FILE.RC% )                        !NJK
            DIR.OPEN = FALSE
        ENDIF

        !--------------------------------------------------------------!
        ! Checking the archive file existence before extraction. First !
        ! the file will be checked in IMG location and it not present, !
        ! then it will be tried in ALT location                        !
        !--------------------------------------------------------------!
        IF FUNC.FILE.EXISTS(BKP.FILENAME.IMG$) THEN BEGIN

            CALL OSSHELL(ADXZUDIR.FILE.NAME$ + " -x "                + \
                         BKP.FILENAME.IMG$   + XRE.SPACE$            + \
                         BKPSCRPT.DIRECTORIES$(INDEX%)               + \
                         " > " + DIR.OUT$ + " >>* " + DIR.OUT$)

            STATUS.MSG$ = BKP.FILENAME.IMG$ + STATUS.TEXT.MSG$(11)   + \!JDC
                          BKPSCRPT.DIRECTORIES$(INDEX%)
            GOSUB LOG.STATUS.MSG

            ! Setting the status to check the extraction output file
            RESTORE.STATUS = TRUE

        ENDIF ELSE BEGIN                                                !NJK
            IF FUNC.FILE.EXISTS(BKP.FILENAME.ALT$) THEN BEGIN           !NJK

                CALL OSSHELL(ADXZUDIR.FILE.NAME$ + " -x "            + \
                             BKP.FILENAME.ALT$   + XRE.SPACE$        + \
                             BKPSCRPT.DIRECTORIES$(INDEX%)           + \
                             " > " + DIR.OUT$ + " >>* " + DIR.OUT$)

                STATUS.MSG$ = BKP.FILENAME.ALT$ + STATUS.TEXT.MSG$(11)+ \JDC
                              BKPSCRPT.DIRECTORIES$(INDEX%)
                GOSUB LOG.STATUS.MSG

                ! Setting the status to check the extraction output file
                RESTORE.STATUS = TRUE

            ENDIF
        ENDIF                                                           !NJK

        ! Initializing to FALSE
        RESTORE.HAPPENED = FALSE                                        !MJK

        ! If file extraction happened
        IF RESTORE.STATUS THEN BEGIN                                    !MJK

            ! Setting TRUE for successful extraction
            RESTORE.HAPPENED = TRUE                                     !MJK
            ! Open file                                                 !MJK
            DIR.FILE.RC% = FUNC.OPEN.SEQUENTIAL.FILE( DIR.OUT$ )        !NJK

            ! If file open unsuccessful
            IF DIR.FILE.RC% <= XRE.ZERO% THEN BEGIN
                DIR.OPEN    = FALSE                                     !MJK
                STATUS.MSG$ = STATUS.TEXT.ERROR$(2)                     !JDC
                GOSUB LOG.STATUS.MSG
                ! Setting NULL to avoid file read
                DIR.VALUE$ = XRE.NULL$
            ENDIF ELSE BEGIN
                DIR.OPEN   = TRUE
                DIR.VALUE$ = XRE.SPACE$
            ENDIF

            ! Read the file till EOF or read error                      !FDC
            WHILE LEN(DIR.VALUE$) <> XRE.ZERO%
                DIR.VALUE$ = FUNC.READ.SEQUENTIAL.FILE( DIR.FILE.RC% )  !NJK

                !-----------------------------------------------!
                ! If error string matches, write the error with !
                ! file name in LOG file                         !
                !-----------------------------------------------!
                IF MATCH("Error extracting file",DIR.VALUE$,1) <>      \
                   XRE.ZERO% THEN BEGIN

!                    STATUS.MSG$ = STATUS.TEXT.ERROR$(12)               !OJK
!                    GOSUB LOG.STATUS.MSG                               !OJK

                    ! Setting the flag for extraction error
                    RESTORE.ERR.EXIST = TRUE
                    STATUS.MSG$       = DIR.VALUE$
                    GOSUB LOG.STATUS.MSG
                ENDIF
            WEND

            ! Closing File
            IF DIR.OPEN THEN BEGIN
                CALL FUNC.CLOSE.FILE( DIR.FILE.RC% )                    !NJK
                DIR.OPEN = FALSE
            ENDIF

        ENDIF
        ! Starting from Full day increment the date till requested date !JDC
        F02.DATE$ = FULL.TO.MOVING.DATE$
        FUN.RC2%  = UPDATE.DATE( 1 )                                    !MJK
        ! Checking the Return code
        GOSUB CHECK.UPDATE.DATE.RC                                      !IDC
        FULL.TO.MOVING.DATE$ = F02.DATE$

    NEXT LOOP%

RETURN

\***********************************************************************
\*
\* PROCESS.BKPLIST.FILE: This Subroutine reads the BKPLIST file and
\*                       removes the file, if any file has NOT EXIST
\*                       option enabled.
\*
\***********************************************************************
PROCESS.BKPLIST.FILE:

    STATUS.MSG$ = "Checking " + BKPLIST.CURR.FILE$ + " to check the" + \
                  " extracted file"
    GOSUB LOG.STATUS.MSG

    !--------------------------------------------------------!
    ! Checking whether BKPLIST file exist and the extraction !
    ! happened and also requested date is NOT Full           !          !JDC
    !--------------------------------------------------------!
    IF RESTORE.HAPPENED AND BKP.INDEX% > 1 THEN BEGIN                   !MJK
        ! only check the file when this far                             !JDC
        IF FUNC.FILE.EXISTS(BKPLIST.CURR.FILE$) THEN BEGIN              !JDC
            ! Opening the BKPLIST file                                  !MJK
            BKPLIST.FILE.RC% = \                                        !NJK
                    FUNC.OPEN.SEQUENTIAL.FILE (BKPLIST.CURR.FILE$)      !NJK
            ! If file open unsuccessful
            IF BKPLIST.FILE.RC% <= XRE.ZERO% THEN BEGIN
                BKPLIST.OPEN = FALSE                                    !MJK
                STATUS.MSG$  = "Error in opening BKPLIST file"          !MJK
                GOSUB LOG.STATUS.MSG
                ! Setting NULL to avoid file read
                BKPLIST.DIR.VALUE$ = XRE.NULL$
            ENDIF ELSE BEGIN
                BKPLIST.OPEN       = TRUE
                BKPLIST.DIR.VALUE$ = XRE.SPACE$
            ENDIF

            ! Read the file till the EOF
            WHILE LEN(BKPLIST.DIR.VALUE$) <> XRE.ZERO%
                BKPLIST.DIR.VALUE$ = \                                  !JDC
                    FUNC.READ.SEQUENTIAL.FILE(BKPLIST.FILE.RC%)         !NJK

                !---------------------------------------------------!
                ! Checking the directory name of BKPLIST files with !
                ! the requested drive                               !
                !---------------------------------------------------!
                IF UCASE$(LEFT$(BKPLIST.DIR.VALUE$,1)) = DRIVE$ \       !JDC
                THEN BEGIN                                              !JDC

                    ! Extract the individual fields using function
                    GOSUB EXTRACT.BKPLIST.FIELDS                        !IDC

                    IF NOT FUNCTION.ERROR.NOT.EXIST THEN BEGIN          !EJK
                        ! Setting the value for exception
                        RESTORE.ERR.EXIST = TRUE                        !EJK
                    ENDIF                                               !EJK

                    IF BKPLI.INCREMENTAL.EXIST$(BKP.INDEX% - 1) <> "Y" \!MJK
                    THEN BEGIN                                          !IDC
                        GOSUB DEL.BKPLIST.FILE                          !IDC
                    ENDIF                                               !IDC
                ENDIF
            WEND

            ! Closing File
            IF BKPLIST.OPEN THEN BEGIN
                CALL FUNC.CLOSE.FILE( BKPLIST.FILE.RC% )                !NJK
                BKPLIST.OPEN = FALSE
            ENDIF
        ENDIF                                                           !JDC
    ENDIF

RETURN

\***********************************************************************!EJK
\*                                                                      !EJK
\*  DEL.BKPLIST.FILE: This Sub-Routine deletes the BKPLIST file         !EJK
\*                    which is set as Non-exist.                        !EJK
\*                                                                      !EJK
\***********************************************************************!EJK
DEL.BKPLIST.FILE:

    CALL OSSHELL("DEL " + BKPLI.FILENAME$ + " >> " + DIR.OUT$ + \       !JDC
                 " >>* " + DIR.OUT$)
    STATUS.MSG$ = STATUS.TEXT.MSG$(7) + BKPLI.FILENAME$                 !JDC
    GOSUB LOG.STATUS.MSG

RETURN

\***********************************************************************!MJK
\*                                                                      !MJK
\* BACKUP.CONFIG.FILES: This Sub-Routine backs up the configuration     !MJK
\*                      files at the end of restore                     !MJK
\*                                                                      !MJK
\***********************************************************************!MJK
BACKUP.CONFIG.FILES:

    IF DRIVE$ = "C" THEN BEGIN
        BKP.DRIVE$ = "D"
    ENDIF ELSE BEGIN
        BKP.DRIVE$ = "C"
    ENDIF

    CALL OSSHELL("COPY " + BKP.DRIVE$ + ":\ADX_UDT1\BKPLIST.* " + \
                 DRIVE$ + ":\ADX_UDT1\" + " > " + DIR.OUT$      + \
                 " >>* " + DIR.OUT$)

    DIR.FILE.RC% = FUNC.OPEN.SEQUENTIAL.FILE( DIR.OUT$ )                !NJK

    ! If file open unsuccessful
    IF DIR.FILE.RC% <= XRE.ZERO% THEN BEGIN
        DIR.OPEN    = FALSE
        STATUS.MSG$ = "Error in opening DIR output file"
        GOSUB LOG.STATUS.MSG
        ! Setting NULL to avoid file read
        DIR.VALUE$ = XRE.NULL$
    ENDIF ELSE BEGIN
        DIR.OPEN   = TRUE
        DIR.VALUE$ = XRE.SPACE$
    ENDIF

    ! Read the file till EOF or read error
    WHILE LEN(DIR.VALUE$) <> XRE.ZERO%
        DIR.VALUE$ = FUNC.READ.SEQUENTIAL.FILE( DIR.FILE.RC% )          !NJK

        !-----------------------------------------------!
        ! If error string matches, write the error      !
        !-----------------------------------------------!
        IF MATCH(UCASE$("Error"),UCASE$(DIR.VALUE$),1) <> XRE.ZERO% \
        THEN BEGIN
            ! Logging the error
            STATUS.MSG$ = "Error when backing up BKPLIST files"
            GOSUB LOG.STATUS.MSG
            DIR.VALUE$        = XRE.NULL$
            RESTORE.ERR.EXIST = TRUE                                    !OJK
        ENDIF
    WEND

    ! Closing File
    IF DIR.OPEN THEN BEGIN
        CALL FUNC.CLOSE.FILE( DIR.FILE.RC% )                            !NJK
        DIR.OPEN = FALSE
    ENDIF

RETURN

\***********************************************************************
\*
\* DISPLAY.DIRECT.SCREEN: This Subroutine displays the DIRECTORY
\*                        screen for XRESTORE.
\*
\***********************************************************************
DISPLAY.DIRECT.SCREEN:

    ! Screen constant variables
    DIR.INDEX%       = 30               ! Directory name
    DIR.INPUT.INDEX% = 100              ! Input value

    PAGE.NO%         = 1                ! Setting the page number
    MAX.DIRECTORIES% = DIR.TO.SHOW%     ! Setting the number of entries

    ! Dimensioning the array
    DIM SELECTED.DIR.ARRAY$(ARRAY.LIMIT%)                               !MJK

    ! Initiating an array with spaces for input values
    FOR LOOP% = 1 TO BKPSCRPT.INDEX%
        !----------------------------------------------------!
        ! BKPSCRPT.INDEX% array index check has been already !
        ! handled when BKPSCRPT array has been added         !
        !----------------------------------------------------!
        SELECTED.DIR.ARRAY$(LOOP%) = XRE.SPACE$
    NEXT LOOP%

    ! Setting the variables to process
    DIR.LOOP%        = DIR.INDEX%
    DIR.INPUT.LOOP%  = DIR.INPUT.INDEX%

    CALL DM.SHOW.SCREEN (5, XRE.NULL$, 4, 4)

    ! Setting the variable for screen continuation text
    CALL DM.NAME (53, "USER.TEXT$", USER.TEXT$)
    USER.TEXT$ = "Continued...."

    ! Checking the Index for Backups
    IF BKPSCRPT.INDEX% > XRE.ZERO% THEN BEGIN
        ! Storing the page number
        PAGE.DIV% = BKPSCRPT.INDEX%/MAX.DIRECTORIES%

        IF MOD(BKPSCRPT.INDEX%,MAX.DIRECTORIES%) THEN BEGIN
            ! Incrementing by 1 if MOD value is greater than zero
            PAGE.DIV% = PAGE.DIV% + 1
        ENDIF

        ! Setting the total page number
        FIELD$(4) = STR$(PAGE.DIV%)

        GOSUB DISPLAY.DIR.PAGE

    ENDIF ELSE BEGIN
        FIELD$(3) = "1"
        FIELD$(4) = "1"
        FIELD$(1) = SCREEN.TEXT.MSG$(30)                                !JDC
    ENDIF

RETURN

\***********************************************************************
\*
\* PROCESS.DIRECT.SCREEN: This Subroutine displays the DIRECTORY
\*                        screen for XRESTORE.
\*
\***********************************************************************
PROCESS.DIRECT.SCREEN:

    WHILE SCREEN% = RESTORE.A.DIRECTORY.SCR% OR \                       !CJK
          SCREEN% = DIRECTORY.DAY.SELECT.SCR%                           !CJK

        IF SCREEN% = RESTORE.A.DIRECTORY.SCR% THEN BEGIN                !CJK
            ! If the screen is accessed using F3 or ESC
            IF PREVIOUS.KEY THEN BEGIN
                GOSUB DISPLAY.DIRECT.SCREEN
                PREVIOUS.KEY = FALSE
            ENDIF

            ! Process multi page directory screen
            GOSUB PROCESS.MULTI.DIR.SCREEN
        ENDIF ELSE IF SCREEN% = DIRECTORY.DAY.SELECT.SCR% THEN BEGIN    !CJK

            !------------------------------------------------------!
            ! Complete Directory restore process will be carried   !
            ! out by this Sub-program. This has been created as a  !
            ! Sub-program to overcome the foreseen 64K issue       !
            !------------------------------------------------------!
            CALL SUB.PROCESS.DAY.DIR.SCREEN                            \
                    (PRIMARY.ARCHIVED.NAMES$(SELECT.INDEX%),           \
                     SECONDARY.ARCHVD.NAMES$(SELECT.INDEX%))
        ENDIF
    WEND

RETURN

\***********************************************************************
\*
\* PROCESS.MULTI.DIR.SCREEN: This Subroutine displays the MULTI
\*                           DIRECTORY screen for XRESTORE.
\*
\***********************************************************************
PROCESS.MULTI.DIR.SCREEN:

    RET.KEY% = DM.PROCESS.SCREEN (2, 123, TRUE)

    ! ESC or F3 press or No Backup directories
    IF (RET.KEY% = ESC.KEY%) OR (RET.KEY% = F3.KEY%) OR \
       BKPSCRPT.INDEX% = XRE.ZERO% THEN BEGIN

        CALL DM.FOCUS("10",SCREEN.TEXT.MSG$(31))                        !JDC

        ! Main screen
        SCREEN% = DISPLAY.MAIN.SCR%                                     !CJK

    ENDIF ELSE IF RET.KEY% = F8.KEY% OR RET.KEY% = PGDN.KEY% THEN BEGIN
        ! When F8 or Page down key pressed

        ! If Page no. is lesser than the MAX page
        IF PAGE.NO% < PAGE.DIV% THEN BEGIN
            ! Save the fields first before moving to next page
            GOSUB SAVE.DIR.FIELD

            ! Increment the page
            PAGE.NO% = PAGE.NO% + 1

            ! Display the next page
            GOSUB DISPLAY.DIR.PAGE
        ENDIF ELSE BEGIN
            ! If invalid key press
            FIELD$(1) = "'There are no more pages to display"
        ENDIF
    ENDIF ELSE IF RET.KEY% = F7.KEY% OR RET.KEY% = PGUP.KEY% THEN BEGIN
        ! When F7 or Page up key pressed

        ! If Page no. is greater than 1
        IF PAGE.NO% > 1 THEN BEGIN
            ! Save the fields first before moving to next page
            GOSUB SAVE.DIR.FIELD

            ! Decrement the page
            PAGE.NO% = PAGE.NO% - 1

            ! Display the previous page
            GOSUB DISPLAY.DIR.PAGE
        ENDIF ELSE BEGIN
            ! If invalid key press
            FIELD$(1) = "'There is no previous page to display"
        ENDIF
    ENDIF ELSE IF RET.KEY% = ENTER.KEY% THEN BEGIN
        ! Save the field
        GOSUB SAVE.DIR.FIELD

        ! Process the input values
        GOSUB PROCESS.DIR.INPUT
    ENDIF ELSE BEGIN
        ! B001 Invalid key pressed
        CALL DM.FOCUS ("1", STATUS.TEXT.ERROR$(20))                     !IDC
    ENDIF

RETURN

\***********************************************************************
\*
\* DISPLAY.DIR.PAGE: This Subroutine the display the available
\*                   directories based on the page number value.
\*
\***********************************************************************
DISPLAY.DIR.PAGE:

    !---------------------------------------------------------!
    ! Index values are used as constant variables for screens !
    ! Loop values are used for populating the values in field !
    !---------------------------------------------------------!
    DIR.LOOP%        = DIR.INDEX%
    DIR.INPUT.LOOP%  = DIR.INPUT.INDEX%
    MAX.DIRECTORIES% = DIR.TO.SHOW%

    ! Setting the Page numbers
    FIELD$(3) = STR$(PAGE.NO%)
    FIELD$(4) = STR$(PAGE.DIV%)

    ! Setting the Current field
    CALL DM.CURRENT.FIELD(DIR.INPUT.INDEX%)

    !--------------------------------------------------------------!
    ! Checking whether total available directories is greater than !
    ! current screen values. If not, the condition will go to the  !
    ! Else loop which will show the last page.                     !
    !--------------------------------------------------------------!
    IF BKPSCRPT.INDEX% > (MAX.DIRECTORIES% * PAGE.NO%) THEN BEGIN

        ! If Page num 1, Page up disabled
        IF PAGE.NO% = 1 THEN BEGIN
            CALL DM.HIDE.FN.KEY (7)
            CALL DM.SHOW.FN.KEY (8, "PGDN")

        ENDIF ELSE BEGIN
            CALL DM.SHOW.FN.KEY (7, "PGUP")
            CALL DM.SHOW.FN.KEY (8, "PGDN")
        ENDIF

        ! Setting the visibility of the "Continued" text
        CALL DM.VISIBLE (STR$(53), STATUS.TEXT.MSG$(61))                !IDC

    ENDIF ELSE BEGIN
        ! Setting the max directories based on the available values
        MAX.DIRECTORIES% = BKPSCRPT.INDEX% - (MAX.DIRECTORIES% * \
                                             (PAGE.NO% - 1))
        ! As this is the last page, Hide the Page down key
        CALL DM.HIDE.FN.KEY (8)

        ! If only one page, hide both page up and page down keys
        IF PAGE.NO% = 1 THEN BEGIN
            CALL DM.HIDE.FN.KEY (7)
        ENDIF

        ! Disable the "Continued" text
        CALL DM.VISIBLE (STR$(53), STATUS.TEXT.MSG$(60))                !IDC

    ENDIF

    ! Looping to display the directories in selected page
    FOR LOOP% = 1 TO MAX.DIRECTORIES%

        ! Directory name
        FIELD$(DIR.LOOP%) = BKPSCRPT.DIRECTORIES$(                 \    !MJK
                            LOOP% + ((PAGE.NO% - 1) * DIR.TO.SHOW%))    !MJK
        ! Setting spaces for input value
        FIELD$(DIR.INPUT.LOOP%) = SELECTED.DIR.ARRAY$(LOOP%          + \!MJK
                                       ((PAGE.NO% - 1) * DIR.TO.SHOW%)) !MJK
        ! Setting the visibility
        CALL DM.VISIBLE (STR$(DIR.LOOP%)      , STATUS.TEXT.MSG$(61))   !MJK
        CALL DM.VISIBLE (STR$(DIR.INPUT.LOOP%), STATUS.TEXT.MSG$(61))   !IDC

        ! Incrementing to the next field
        DIR.LOOP%       = DIR.LOOP% + 1
        DIR.INPUT.LOOP% = DIR.INPUT.LOOP% + 1

    NEXT LOOP%

    !---------------------------------------!
    ! If last page, disable the remaining   !
    ! directory field and input field       !
    !---------------------------------------!
    IF MAX.DIRECTORIES% < DIR.TO.SHOW% THEN BEGIN

        ! Looping from above finished value till the MAX value in a page
        FOR LOOP% = MAX.DIRECTORIES% + 1 TO DIR.TO.SHOW%
            CALL DM.VISIBLE (STR$(DIR.LOOP%), STATUS.TEXT.MSG$(60))     !IDC
            CALL DM.VISIBLE (STR$(DIR.INPUT.LOOP%),STATUS.TEXT.MSG$(60))!MJK

            DIR.LOOP%       = DIR.LOOP% + 1
            DIR.INPUT.LOOP% = DIR.INPUT.LOOP% + 1

        NEXT LOOP%
    ENDIF

RETURN

\***********************************************************************
\*
\* SAVE.DIR.FIELD: This Subroutine will be used by Directory page when
\*                 Page up/down, F7/F8 or Enter key has been pressed.
\*                 It will help in saving the value of current page.
\*
\***********************************************************************
SAVE.DIR.FIELD:

    ! First input field
    DIR.INPUT.LOOP%  = DIR.INPUT.INDEX%
    SEL.INPUT.LOOP%  = 1        ! Initiating to 1 before use


    FOR LOOP% = 1 TO MAX.DIRECTORIES%

        ! Set depending on the current page
        SEL.INPUT.LOOP% = ((PAGE.NO% - 1) * DIR.TO.SHOW%) + LOOP%

        !----------------------------------------------------------!
        ! Stored the field value using the index value created by  !
        ! the current page number                                  !
        !----------------------------------------------------------!
        SELECTED.DIR.ARRAY$(SEL.INPUT.LOOP%) = FIELD$(DIR.INPUT.LOOP%)

        ! Incrementing the input field index
        DIR.INPUT.LOOP% = DIR.INPUT.LOOP% + 1

    NEXT LOOP%

RETURN

\***********************************************************************
\*
\* PROCESS.DIR.INPUT: This Subroutine processes the directory input
\*                    values.
\*
\***********************************************************************
PROCESS.DIR.INPUT:

    ! Initiating the variables before use
    SELECT.COUNT% = XRE.ZERO%
    NON.X.VALUES  = FALSE

    ! Checking all the input fields using array index
    FOR LOOP% = 1 TO BKPSCRPT.INDEX%

        ! If input value is not equal to space
        IF SELECTED.DIR.ARRAY$(LOOP%) <> XRE.SPACE$ THEN BEGIN
            ! If non X values are entered
            IF UCASE$(SELECTED.DIR.ARRAY$(LOOP%)) <> "X" THEN BEGIN
                NON.X.VALUES = TRUE
            ENDIF ELSE BEGIN
                ! Storing the X selection
                SELECT.INDEX% = LOOP%
            ENDIF
            ! Incrementing to check the Multiple selection
            SELECT.COUNT% = SELECT.COUNT% + 1
        ENDIF
    NEXT LOOP%

    ! If more than 1 input is selected
    IF SELECT.COUNT% > 1 THEN BEGIN
        FIELD$(1) = "'Multiple selections not allowed"
    ENDIF ELSE BEGIN
        ! If only one value is selected and no Non X values present
        IF SELECT.COUNT% = 1 AND NOT NON.X.VALUES THEN BEGIN            !MJK

            STATUS.MSG$ = BKPSCRPT.DIRECTORIES$(SELECT.INDEX%)       + \
                          " directory is selected for restore"
            GOSUB LOG.STATUS.MSG

            ! Setting screen number to display available days
            SCREEN% = DIRECTORY.DAY.SELECT.SCR%                         !CJK

        ENDIF ELSE BEGIN
            ! If error
            FIELD$(1) = SCREEN.TEXT.MSG$(21)                            !JDC
        ENDIF
    ENDIF

RETURN

\***********************************************************************
\*
\* PROCESS.FILE.SCREEN: This Subroutine displays the FILE screen
\*                      for XRESTORE.
\*
\***********************************************************************
PROCESS.FILE.SCREEN:

    ! If File enter screen or day availability screen
    WHILE SCREEN% = RESTORE.A.FILE.SCR% OR \                            !CJK
          SCREEN% = FILE.DAY.SELECT.SCR%                                !CJK

        IF SCREEN% = RESTORE.A.FILE.SCR% THEN BEGIN                     !CJK
            ! If screen is accessed using F3 or ESC
            IF PREVIOUS.KEY THEN BEGIN
                CALL DM.SHOW.SCREEN (7, XRE.NULL$, 6, 6)
                PREVIOUS.KEY = FALSE
            ENDIF

            RET.KEY% = DM.PROCESS.SCREEN (2, 2, TRUE)

            IF (RET.KEY% = ESC.KEY%) OR (RET.KEY% = F3.KEY%) THEN BEGIN !CJK

                ! Main screen
                SCREEN%      = DISPLAY.MAIN.SCR%                        !CJK
                PREVIOUS.KEY = FALSE

            ENDIF ELSE BEGIN
                IF RET.KEY% = ENTER.KEY% THEN BEGIN
                    ! Checks the entered file
                    GOSUB CHECK.ENTERED.FILE

                ENDIF ELSE BEGIN
                    ! B001 Invalid key pressed
                    CALL DM.FOCUS ("1", STATUS.TEXT.ERROR$(20))         !IDC
                ENDIF
            ENDIF

        ENDIF

        ! Checks the available restore days and display it
        IF SCREEN% = FILE.DAY.SELECT.SCR% THEN BEGIN                    !CJK
            GOSUB CHECK.PROCESSED.FILE
        ENDIF
    WEND

RETURN

\***********************************************************************
\*
\* CHECK.ENTERED.FILE: This Subroutine checks the FILE input entered
\*                     in Restore File screen
\*
\***********************************************************************
CHECK.ENTERED.FILE:

    ! Storing the File name
    SELECT.FILE.NAME$ = FIELD$(2)

    ! Trim it
    CALL TRIM(SELECT.FILE.NAME$)

    ! Setting the initial values
    SLASH.POSITION% = XRE.ZERO%
    BEGIN.POSITION% = 1
    SELECT.INDEX%   = XRE.ZERO%
    VALUE.EXISTS    = TRUE                                              !MJK

    !-------------------------------------------------------------!     !MJK
    ! BKPSCRPT has directory values with backward slashes. Hence  !     !MJK
    ! converting the forward slashes entered by USER to backward  !     !MJK
    ! slashes for easiness of string comparison                   !     !MJK
    !-------------------------------------------------------------!     !MJK

    ! To convert all forward slashes to backward slashes                !MJK
    WHILE VALUE.EXISTS                                                  !MJK
        ! Checks the forward slash position                             !MJK
        SLASH.POSITION% = MATCH("/",SELECT.FILE.NAME$,BEGIN.POSITION%)  !MJK

        IF SLASH.POSITION% > XRE.ZERO% THEN BEGIN                       !MJK
            SELECT.FILE.NAME$ = LEFT$(SELECT.FILE.NAME$,             \  !MJK
                                      (SLASH.POSITION% - 1)) + "\" + \  !MJK
                                RIGHT$(SELECT.FILE.NAME$,            \  !MJK
                                      (LEN(SELECT.FILE.NAME$) -      \  !MJK
                                       SLASH.POSITION%))                !MJK
            ! Move to next position to search next field                !MJK
            BEGIN.POSITION% = SLASH.POSITION% + 1                       !MJK
        ENDIF ELSE BEGIN                                                !MJK
            VALUE.EXISTS = FALSE                                        !MJK
        ENDIF                                                           !MJK
    WEND                                                                !MJK

    ! Reset the values
    BEGIN.POSITION% = 1
    SLASH.POSITION% = XRE.ZERO%
    VALUE.EXISTS    = TRUE

    ! Loop continues till last backward slash found
    WHILE VALUE.EXISTS
        ! Checks the backward slash position
        SLASH.POSITION% = MATCH("\\",SELECT.FILE.NAME$,BEGIN.POSITION%) !MJK

        IF SLASH.POSITION% > XRE.ZERO% THEN BEGIN
            ! Move to next position to search next field
            BEGIN.POSITION% = SLASH.POSITION% + 1
        ENDIF ELSE BEGIN
            VALUE.EXISTS = FALSE
        ENDIF
    WEND

    !--------------------------------------------------!
    ! Checking the BKPSCRPT directories to see if the  !
    ! entered file matches                             !
    !--------------------------------------------------!
    FOR INDEX% = 1 TO BKPSCRPT.INDEX%
        IF BKPSCRPT.DIRECTORIES$(INDEX%) = UCASE$(MID$(            \
                                           SELECT.FILE.NAME$,1,    \
                                           (BEGIN.POSITION% - 1))) \
        THEN BEGIN
            SELECT.INDEX% = INDEX%
        ENDIF
    NEXT INDEX%

    ! Storing the File name
    SELECTED.FILENAME$ = MID$(SELECT.FILE.NAME$,BEGIN.POSITION%,   \
                             (LEN(SELECT.FILE.NAME$) -             \
                              BEGIN.POSITION% + 1))
    ! Trim spaces
    CALL TRIM(SELECT.FILE.NAME$)

    ! If no matches found
    IF SELECT.INDEX% = XRE.ZERO% THEN BEGIN
        CALL DM.FOCUS ("3", "'Please enter a valid directory name")

    ! If no file name entered after the directory
    ENDIF ELSE BEGIN                                                    !NJK
        IF (BEGIN.POSITION% - 1)   = LEN(SELECT.FILE.NAME$) OR  \       !NJK
           LEN(SELECTED.FILENAME$) > 12 THEN BEGIN                      !NJK
            SELECT.INDEX% = XRE.ZERO%
            CALL DM.FOCUS ("3", "'Please enter a valid file name")
        ENDIF ELSE BEGIN
        ! Valid Directory entered

            STATUS.MSG$ = UCASE$(SELECT.FILE.NAME$)           + \       !OJK
                          " file is entered for restoration"            !OJK
            GOSUB LOG.STATUS.MSG
            ! Setting the screen to move to next screen
            SCREEN% = FILE.DAY.SELECT.SCR%                              !CJK
        ENDIF
    ENDIF                                                               !NJK

RETURN

\***********************************************************************
\*
\* CHECK.PROCESSED.FILE: This Subroutine displays the available days
\*                       for selected file backup. Also processes the
\*                       field for all key strokes.
\*
\***********************************************************************
CHECK.PROCESSED.FILE:

    GOSUB SHOW.FILE.RESTORE.DAYS

    GOSUB PROCESS.FILE.RESTORE

RETURN

\***********************************************************************
\*
\* SHOW.FILE.RESTORE.DAYS: This Subroutine display the available backup
\*                         days for Entered file name
\*
\***********************************************************************
SHOW.FILE.RESTORE.DAYS:

    ! Setting the Header and other variables used for screen display
    SCR.HEADER$   = "RESTORE A FILE PROCESSING"                         !MJK
    OPT.SELECTED$ = SCREEN.TEXT.MSG$(2) + SCREEN.TEXT.MSG$(3)           !JDC
    OPT.HEADER.1$ = "Please choose which day to restore the " + \
                    "file: " + SELECT.FILE.NAME$

    ! Display screen
    CALL DM.SHOW.SCREEN(2, SCR.HEADER$, 7, 7)

    ! Setting the XRE value which will be displayed in the Left corner
    SCREEN.NUM$ = "08"

    ! Dimensioning the array
    DIM DAY.ARRAY$(ARRAY.LIMIT%)                                        !MJK
    DIM BKP.AVAIL.ARRAY$(ARRAY.LIMIT%)                                  !MJK

    ! Setting the default value before calling the Sub-routine          !MJK
    FUNCTION.ERROR.NOT.EXIST = 0                                        !IDC

    FIRST.FILE$  = PRIMARY.ARCHIVED.NAMES$(SELECT.INDEX%)               !MJK
    SECOND.FILE$ = SECONDARY.ARCHVD.NAMES$(SELECT.INDEX%)               !IDC
    GOSUB GET.BKP.DETAILS                                               !IDC

    ! Setting the screen number
    CALL DM.NAME (2, "SCREEN.NUM$", SCREEN.NUM$)

    ! Initialising the output fields in the screen
    ! before processing the screen
    !--------------------------------------------
    CALL DM.NAME (48, "OPT.HEADER.1$", OPT.HEADER.1$)

    ! If backups are available
    IF VALUE.INDEX% <> XRE.ZERO% AND FUNCTION.ERROR.NOT.EXIST THEN BEGIN!EJK

        ! Enabling the DAY and DD/MM string
        CALL DM.VISIBLE ("75", STATUS.TEXT.MSG$(61))                    !IDC
        CALL DM.VISIBLE ("76", STATUS.TEXT.MSG$(61))                    !IDC

        ! Setting other relevant string
        CALL DM.NAME (50, "OPT.SELECTED$", OPT.SELECTED$)

        ! Setting the first value of the fields before populating it
        DAY.LOOP%   = DAY.INDEX%                                        !MJK
        DD.MM.LOOP% = DD.MM.INDEX%                                      !MJK
        INPUT.LOOP% = INPUT.INDEX%                                      !MJK

        ! Retrieving the values and storing in Field$
        FOR INDEX% = 1 TO VALUE.INDEX%

            ! DAY value and its visibility
            FIELD$(DAY.LOOP%) = DAY.ARRAY$(INDEX%)
            CALL DM.VISIBLE (STR$(DAY.LOOP%), STATUS.TEXT.MSG$(61))     !IDC

            ! DD/MM value
            FIELD$(DD.MM.LOOP%) = RIGHT$(BKP.AVAIL.ARRAY$(INDEX%),2) + \!GJK
                                  "/"                                + \
                                  LEFT$(BKP.AVAIL.ARRAY$(INDEX%),2)     !GJK

            ! Setting a space for input values
            FIELD$(INPUT.LOOP%) = XRE.SPACE$

            ! Setting the visibility for DD/MM and input
            CALL DM.VISIBLE (STR$(DD.MM.LOOP%), STATUS.TEXT.MSG$(61))   !IDC
            CALL DM.VISIBLE (STR$(INPUT.LOOP%), STATUS.TEXT.MSG$(61))   !IDC

            ! Incrementing to move to the next field
            DAY.LOOP%   = DAY.LOOP%   + 1
            DD.MM.LOOP% = DD.MM.LOOP% + 1
            INPUT.LOOP% = INPUT.LOOP% + 1

        NEXT INDEX%

    ENDIF ELSE BEGIN                                                    !NJK
        IF FUNCTION.ERROR.NOT.EXIST THEN BEGIN                          !NJK
            FIELD$(1) = STATUS.TEXT.ERROR$(21)                          !IDC
        ENDIF ELSE BEGIN                                                !EJK
            FIELD$(1) = SCREEN.TEXT.MSG$(7) + SCREEN.TEXT.MSG$(8)       !MJK
        ENDIF
    ENDIF                                                               !NJK

RETURN

\***********************************************************************
\*
\* PROCESS.FILE.RESTORE: This Subroutine helps in processing the input
\*                       values entered in File restore day selection
\*                       screen.
\*
\***********************************************************************
PROCESS.FILE.RESTORE:

    ! Handles restore day selection and confirmation screen
    WHILE SCREEN% = FILE.DAY.SELECT.SCR% OR \                           !CJK
          SCREEN% = FILE.DIR.AND.DIST.SCR%                              !CJK

        IF SCREEN% = FILE.DAY.SELECT.SCR% THEN BEGIN                    !CJK
            ! If screen is accessed using F3 or ESC
            IF PREVIOUS.KEY THEN BEGIN
                GOSUB SHOW.FILE.RESTORE.DAYS
                PREVIOUS.KEY = FALSE
            ENDIF

            RET.KEY% = DM.PROCESS.SCREEN (2, 105, TRUE)

            IF (RET.KEY% = ESC.KEY%) OR (RET.KEY% = F3.KEY%) THEN BEGIN !CJK

                ! Setting the screen number and previous key
                PREVIOUS.KEY = TRUE
                SCREEN% = RESTORE.A.FILE.SCR%                           !CJK
            ENDIF ELSE BEGIN                                            !MJK
                IF VALUE.INDEX% = XRE.ZERO% THEN BEGIN                  !MJK
                    CALL DM.FOCUS ("1", STATUS.TEXT.ERROR$(21) + \      !IDC
                                   STATUS.TEXT.MSG$(58))                !IDC
                ENDIF ELSE BEGIN
                    IF RET.KEY% = ENTER.KEY% THEN BEGIN

                        ! Check the entry in day selection screen
                        SCREEN.NUM% = FILE.DIR.AND.DIST.SCR%            !IDC
                        GOSUB CHECK.DAY.SELECTION                       !IDC

                        ! If any error in function, set same screen
                        IF NOT FUNCTION.ERROR.NOT.EXIST THEN BEGIN      !EJK
                            SCREEN% = FILE.DAY.SELECT.SCR%              !EJK
                        ENDIF                                           !EJK

                    ENDIF ELSE BEGIN
                        ! B001 Invalid key pressed
                        CALL DM.FOCUS ("1", STATUS.TEXT.ERROR$(20))     !IDC
                    ENDIF
                ENDIF                                                   !MJK
            ENDIF

        ENDIF

        ! Confirmation screen
        IF SCREEN% = FILE.DIR.AND.DIST.SCR% THEN BEGIN                  !CJK

            ! Setting the Distribution type 3 as default
            FSEL$ = "3"
            ! Display the screen and process it
            GOSUB CHECK.AND.DISPLAY.FILE

        ENDIF
    WEND

RETURN

\***********************************************************************
\*
\* CHECK.AND.DISPLAY.FILE: This Subroutine checks the archived file for
\*                         for the selected day. If file exist in the
\*                         archive file, the screen will be processed
\*                         for confirmation, else an error message will
\*                         be presented.
\*
\***********************************************************************
CHECK.AND.DISPLAY.FILE:

    STATUS.MSG$ = BKP.DATE.ARRAY$(SEL.INDEX%) + STATUS.TEXT.MSG$(24) + \!JDC
                  " for restoration"
    GOSUB LOG.STATUS.MSG

    ! Display the confirmation screen
    CALL DM.SHOW.SCREEN(8, XRE.NULL$, 9, 9)                             !KDC

    ! Set the field for distribution type
    CALL DM.NAME (4, "FSEL$", FSEL$)

    ! Validation the selection is between 1 and 5
    !-------------------------------------------------
    CALL DM.VALID   ("FSEL$", "FSEL$ >= 1 AND FSEL$ <= 5")              !MJK
    CALL DM.MESSAGE ("FSEL$", "'Invalid Distribution type")

    ! Display the status when the file check is going to happen
    CALL DM.STATUS ("'Processing - Please wait...")

    ! Populating the File name and the directory
    FIELD$(2) = UCASE$(SELECTED.FILENAME$)
    FIELD$(3) = BKPSCRPT.DIRECTORIES$(SELECT.INDEX%)

    RESTORE.STATUS = FALSE

    ! Checking the file presence in the selected archive file
    GOSUB CHECK.THE.FILE.PRESENCE

    ! This field will be notified if file present
    FIELD$(1) = "'Please verify and confirm for restore"

        ! If file not exist
        IF NOT RESTORE.STATUS THEN BEGIN

            ! Making the input filed as Read only
            CALL DM.RO.FIELD(3)
            CALL DM.RO.FIELD(4)

            ! Setting the error to display
            FIELD$(1) = STATUS.TEXT.MSG$(56)                            !IDC

            STATUS.MSG$ = STATUS.TEXT.MSG$(41) + STATUS.TEXT.MSG$(55)   !MJK
            GOSUB LOG.STATUS.MSG

        ENDIF

    ! Handles the confirmation and restoration screen
    WHILE SCREEN% = FILE.DIR.AND.DIST.SCR% OR \                         !CJK
          SCREEN% = FILE.CONFIRMATION.SCR%                              !CJK

        IF SCREEN% = FILE.DIR.AND.DIST.SCR% THEN BEGIN                  !CJK

            ! If screen is accessed by F3 or ESC
            IF PREVIOUS.KEY THEN BEGIN

                ! Display screen
                CALL DM.SHOW.SCREEN(8, XRE.NULL$, 9, 9)                 !KDC

                ! Setting the distribution type 3 as default            !MJK
                FSEL$ = "3"
                CALL DM.NAME (4, "FSEL$", FSEL$)

                ! Validation the selection is between 1 and 5
                !-------------------------------------------------
                CALL DM.VALID ("FSEL$", "FSEL$ >= 1 AND FSEL$ <= 5")
                CALL DM.MESSAGE ("FSEL$", "'Invalid Distribution type")

                ! Setting the File and directory value in field
                FIELD$(2) = UCASE$(SELECTED.FILENAME$)
                FIELD$(3) = DIRECT.TO.RESTORE$

                ! Setting space for status
                FIELD$(1) = XRE.SPACE$

                ! Reset the previous key
                PREVIOUS.KEY = FALSE

            ENDIF

            RET.KEY% = DM.PROCESS.SCREEN (3, 4, TRUE)

            IF (RET.KEY% = ESC.KEY%) OR  (RET.KEY% = F3.KEY%) THEN BEGIN

                ! Setting the screen number for F3 or ESC
                SCREEN%      = FILE.DAY.SELECT.SCR%                     !CJK
                PREVIOUS.KEY = TRUE

            ENDIF ELSE BEGIN                                            !MJK
                IF NOT RESTORE.STATUS THEN BEGIN                        !MJK
                    ! If selected file not exist in the archive
                    FIELD$(1) = STATUS.TEXT.MSG$(57)                    !OJK
                ENDIF ELSE BEGIN                                        !MJK
                    IF RET.KEY% = ENTER.KEY% THEN BEGIN                 !MJK
                    !--------------------------------------------------!
                    ! Checks the entered value again before proceeding !
                    ! with the file restore                            !
                    !--------------------------------------------------!
                        GOSUB RECHECK.DIRECTORY
                    ENDIF ELSE BEGIN
                        CALL DM.FOCUS ("1", STATUS.TEXT.ERROR$(20))     !IDC
                    ENDIF                                               !MJK
                ENDIF                                                   !MJK
            ENDIF
        ENDIF

        ! File restoration screen
        IF SCREEN% = FILE.CONFIRMATION.SCR% THEN BEGIN                  !CJK
            GOSUB CONFIRM.AND.RESTORE.FILE
        ENDIF
    WEND

RETURN

\***********************************************************************
\*
\* CHECK.THE.FILE.PRESENCE: This Subroutine checks the selected file
\*                          presence in the archive file.
\*
\***********************************************************************
CHECK.THE.FILE.PRESENCE:

    ! Date to restore
    FULL.TO.MOVING.DATE$ = BKP.DATE.ARRAY$(SEL.INDEX%)                  !IDC

    GOSUB GET.FILE.EXTENSION                                            !IDC
    MDD.DATE$ = EXTENSION$                                              !IDC

    ! Setting the Backup files based on the 1st field which is drive
    IF LEFT$(FILENAME$,1) = "D" THEN BEGIN
        ! IMG and ALT directory for C drive
        BKP.FILENAME.IMG$ = C.BKP.IMG$ + FILENAME$ + "." + MDD.DATE$    !MJK
        BKP.FILENAME.ALT$ = C.BKP.ALT$ + FILENAME$ + "." + MDD.DATE$    !MJK
        ! BKPFAIL prefix                                                !MJK
        BKPFAIL.PREFIX$   = C.BKP.IMG$ + "BKPFAILD."                    !MJK
    ENDIF ELSE BEGIN
        ! IMG and ALT directory for D drive
        BKP.FILENAME.IMG$ = D.BKP.IMG$ + FILENAME$ + "." + MDD.DATE$    !MJK
        BKP.FILENAME.ALT$ = D.BKP.ALT$ + FILENAME$ + "." + MDD.DATE$    !MJK
        ! BKPFAIL prefix                                                !MJK
        BKPFAIL.PREFIX$   = D.BKP.IMG$ + "BKPFAILC."                    !MJK
    ENDIF

    ! Current BKPFAIL file
    BKPFAIL.CURR.FILE$ = BKPFAIL.PREFIX$ + MDD.DATE$                    !MJK

    VALUE.EXISTS   = FALSE
    RESTORE.STATUS = FALSE

    ! Getting the file details of the Directory archive
    IF FUNC.FILE.EXISTS(BKP.FILENAME.IMG$) THEN BEGIN
        CALL OSSHELL(ADXZUDIR.FILE.NAME$ + " -l "                    + \
                     BKP.FILENAME.IMG$ + " > " + DIR.OUT$            + \
                     " >>* " + DIR.OUT$ )
        VALUE.EXISTS = 1
        STATUS.MSG$  = "Checking the archive file " + BKP.FILENAME.IMG$ !MJK
    ENDIF ELSE BEGIN                                                    !NJK
        IF FUNC.FILE.EXISTS(BKP.FILENAME.ALT$) THEN BEGIN               !NJK
            CALL OSSHELL(ADXZUDIR.FILE.NAME$ + " -l "                + \
                         BKP.FILENAME.ALT$ + " > " + DIR.OUT$        + \
                         " >>* " + DIR.OUT$)
            VALUE.EXISTS = 2
            STATUS.MSG$  = "Checking the archive file " + \             !NJK
                            BKP.FILENAME.ALT$                           !NJK
        ENDIF
    ENDIF                                                               !NJK

    GOSUB LOG.STATUS.MSG

    !------------------------------------------!
    ! If BKPFAIL file present, check to see if !
    ! that has the selected file record in it  !
    !------------------------------------------!
    IF FUNC.FILE.EXISTS(BKPFAIL.CURR.FILE$) THEN BEGIN

        DIR.FILE.RC% = FUNC.OPEN.SEQUENTIAL.FILE( BKPFAIL.CURR.FILE$ )  !NJK

        ! If file open unsuccessful
        IF DIR.FILE.RC% <= XRE.ZERO% THEN BEGIN
            ! Setting NULL to avoid file read
            DIR.VALUE$ = XRE.NULL$
            DIR.OPEN   = FALSE
        ENDIF ELSE BEGIN
            DIR.OPEN   = TRUE
            DIR.VALUE$ = XRE.SPACE$
        ENDIF

        !-------------------------------------------------------------!
        ! Reading the file till the EOF file reached. C file function !
        ! returns NULL when EOF reached or read error                 ! !FDC
        !-------------------------------------------------------------!
        WHILE LEN(DIR.VALUE$) <> XRE.ZERO%
            DIR.VALUE$ = FUNC.READ.SEQUENTIAL.FILE( DIR.FILE.RC% )      !NJK

            ! Checking the comma position
            COMMA.POSITION% = MATCH(COMMA.VALUE$,DIR.VALUE$,1)

            ! If comma found
            IF COMMA.POSITION% <> XRE.ZERO% THEN BEGIN

                ! Storing the failed file
                FAILED.FILE$ = LEFT$(DIR.VALUE$,(COMMA.POSITION% - 1))

                ! If BKPFAIL file matches with current file
                IF UCASE$(FAILED.FILE$) = UCASE$(SELECT.FILE.NAME$) \
                THEN BEGIN
                    VALUE.EXISTS   = 3
                    RESTORE.STATUS = TRUE
                ENDIF
            ENDIF
        WEND

        ! Closing File
        IF DIR.OPEN THEN BEGIN
            CALL FUNC.CLOSE.FILE( DIR.FILE.RC% )                        !NJK
            DIR.OPEN = FALSE
        ENDIF

    ENDIF

    ! If archive file details are STDOUT to DIR.OUT file
    IF VALUE.EXISTS = 1 OR VALUE.EXISTS = 2 THEN BEGIN

        DIR.FILE.RC% = FUNC.OPEN.SEQUENTIAL.FILE( DIR.OUT$ )            !NJK

        ! If file open unsuccessful
        IF DIR.FILE.RC% <= XRE.ZERO% THEN BEGIN
            DIR.OPEN    = FALSE                                         !MJK
            STATUS.MSG$ = STATUS.TEXT.ERROR$(2)                         !JDC
            GOSUB LOG.STATUS.MSG
            ! Setting NULL to avoid file read
            DIR.VALUE$ = XRE.NULL$
        ENDIF ELSE BEGIN
            DIR.OPEN   = TRUE
            DIR.VALUE$ = XRE.SPACE$
        ENDIF

        ! Reading the file till it reached the EOF or read error        !FDC
        WHILE LEN(DIR.VALUE$) <> XRE.ZERO%
            DIR.VALUE$ = FUNC.READ.SEQUENTIAL.FILE( DIR.FILE.RC% )      !NJK

            ! Compare the file names from DIR.OUT with Restore file
            IF LEN(DIR.VALUE$) > 29 THEN BEGIN ! If length is > 29
                IF MID$(DIR.VALUE$,30,(LEN(DIR.VALUE$) - 29)) = \
                   UCASE$(SELECTED.FILENAME$) THEN BEGIN
                    ! If file found enable the flag
                    RESTORE.STATUS = TRUE
                    ! To break the WHILE loop                           !OJK
                    DIR.VALUE$     = XRE.NULL$                          !OJK
                ENDIF
            ENDIF
        WEND

        ! Closing File
        IF DIR.OPEN THEN BEGIN
            CALL FUNC.CLOSE.FILE( DIR.FILE.RC% )                        !NJK
            DIR.OPEN = FALSE
        ENDIF
    ENDIF

RETURN

\***********************************************************************
\*
\* RECHECK.DIRECTORY: This Subroutine checks the value entered in the
\*                    confirmation screen.
\*
\***********************************************************************
RECHECK.DIRECTORY:

    ! Storing the Directory value
    DIRECT.TO.RESTORE$ = FIELD$(3)

    ! Trim it
    CALL TRIM(DIRECT.TO.RESTORE$)

    ! Checking whether the Directory is under C or D drive
    IF UCASE$(LEFT$(DIRECT.TO.RESTORE$,3)) <> "C:\" AND \
       UCASE$(LEFT$(DIRECT.TO.RESTORE$,3)) <> "D:\" THEN BEGIN

        CALL DM.STATUS ("'Incorrect directory value. Please use " + \
                        "C/D drive. Use backward slash (\)")

    ENDIF ELSE BEGIN                                                    !NJK
        ! Maximum allowed length for a directory value                  !OJK
        IF LEN(DIRECT.TO.RESTORE$) > 12 THEN BEGIN                      !OJK
            CALL DM.STATUS ("'Directory length is too high")            !OJK
        ! Checking whether any empty spaces in directory name           !OJK
        ENDIF ELSE IF MATCH(" ",DIRECT.TO.RESTORE$,1)  THEN BEGIN       !OJK
            CALL DM.STATUS ("'Directory name should not contain" + \    !OJK
                            " any spaces in between")                   !OJK
        ! Making sure that invalid characters are not allowed           !OJK
        ENDIF ELSE IF MATCH("""",DIRECT.TO.RESTORE$,1) OR \             !OJK
                      MATCH("\!",DIRECT.TO.RESTORE$,1) OR \             !OJK
                      MATCH("*",DIRECT.TO.RESTORE$,1)  OR \             !OJK
                      MATCH(".",DIRECT.TO.RESTORE$,1)  OR \             !OJK
                      MATCH("+",DIRECT.TO.RESTORE$,1)  OR \             !OJK
                      MATCH(",",DIRECT.TO.RESTORE$,1)  OR \             !OJK
                      MATCH("<",DIRECT.TO.RESTORE$,1)  OR \             !OJK
                      MATCH(">",DIRECT.TO.RESTORE$,1)  OR \             !OJK
                      MATCH("[",DIRECT.TO.RESTORE$,1)  OR \             !OJK
                      MATCH("]",DIRECT.TO.RESTORE$,1)  OR \             !OJK
                      MATCH("\?",DIRECT.TO.RESTORE$,1) THEN BEGIN       !OJK
            CALL DM.STATUS ("'Special/Operational characters are not" + \OJK
                            " recommended in Directory name")           !OJK
        ENDIF ELSE BEGIN

        ! If all the fields are fine, proceed to the restoration
            SCREEN% = FILE.CONFIRMATION.SCR%                            !CJK
            STATUS.MSG$ = DIRECT.TO.RESTORE$                         + \!NJK
                          " directory is selected " + "for file restore"!NJK
            GOSUB LOG.STATUS.MSG
        ENDIF
    ENDIF                                                               !NJK

RETURN

\***********************************************************************
\*
\* CONFIRM.AND.RESTORE.FILE: This Subroutine display the file restore
\*                           confirmation screen and then process it
\*
\***********************************************************************
CONFIRM.AND.RESTORE.FILE:

    ! Display the screen
    GOSUB DISPLAY.FILE.CONFIRMATION

    ! For Confirmation screen and final restoration screen
    WHILE SCREEN% = FILE.CONFIRMATION.SCR% OR \                         !CJK
          SCREEN% = FILE.PROCESS.SCR%                                   !CJK

        IF SCREEN% = FILE.CONFIRMATION.SCR% THEN BEGIN                  !CJK
            ! If screen accessed using F3 or ESC
            IF PREVIOUS.KEY THEN BEGIN
                GOSUB DISPLAY.FILE.CONFIRMATION
                PREVIOUS.KEY = FALSE
            ENDIF

            RET.KEY% = DM.PROCESS.SCREEN (5, 5, FALSE)

            IF (RET.KEY% = ESC.KEY%) OR (RET.KEY% = F3.KEY%) THEN BEGIN !CJK

                ! Previous screen
                SCREEN%      = FILE.DIR.AND.DIST.SCR%                   !CJK
                PREVIOUS.KEY = TRUE

            ENDIF ELSE IF RET.KEY% = ENTER.KEY% THEN BEGIN
                ! If the input is N, go back to the previous screen
                IF UCASE$(FIELD$(5)) = "N" THEN BEGIN
                    SCREEN%      = FILE.DIR.AND.DIST.SCR%               !CJK
                    PREVIOUS.KEY = TRUE
                ! If Y is entered
                ENDIF ELSE IF UCASE$(FIELD$(5)) = "Y" THEN BEGIN
                    ! Setting the screen number for restoration
                    SCREEN% = FILE.PROCESS.SCR%                         !CJK
                ENDIF ELSE BEGIN
                    ! Invalid entry
                    CALL DM.STATUS ("'Incorrect value entered. " + \
                                   "Enter Y or N ")
                ENDIF

            ENDIF ELSE BEGIN
                CALL DM.FOCUS ("1", STATUS.TEXT.ERROR$(20))             !IDC
            ENDIF
        ENDIF

        ! File restoration screen
        IF SCREEN% = FILE.PROCESS.SCR% THEN BEGIN                       !CJK
            GOSUB FILE.RESTORATION
        ENDIF
    WEND

RETURN

\***********************************************************************
\*
\* DISPLAY.FILE.CONFIRMATION: This Subroutine displays the confirmation
\*                            screen for file restoration.
\*
\***********************************************************************
DISPLAY.FILE.CONFIRMATION:

    CALL DM.SHOW.SCREEN(9, XRE.NULL$, 10, 10)                           !KDC

    ! Setting the required fields to display
    FIELD$(3) = "You are about to restore "                          + \
                UCASE$(SELECTED.FILENAME$) + " to "                  + \
                UCASE$(DIRECT.TO.RESTORE$) + " with the"

    FIELD$(4) = "distribution type of " + FSEL$

RETURN

\***********************************************************************
\*
\* FILE.RESTORATION: This Subroutine does the restoration of the file.
\*                   It uses ADXUNZIP to extract the file. If there is  !OJK
\*                   any extraction error then file will be extracted   !OJK
\*                   to C:/TEMP.                                        !OJK
\*
\***********************************************************************
FILE.RESTORATION:

    CALL DM.SHOW.SCREEN(10, XRE.NULL$, XRE.ZERO%, XRE.ZERO%)            !GJK

    !------------------------------------------!
    ! Display the processing notification, as  !
    ! the restore might take longer duration   !
    !------------------------------------------!
    CALL DM.STATUS ("'Processing - Please wait...")
    DIRECTORY.CREATE = TRUE                                             !HJK

    ! If the directory not exists, create it
    IF FUNC.DIR.NOT.EXISTS(DIRECT.TO.RESTORE$) THEN BEGIN

        ! Trim the last slash found to avoid error using MKDIR
        CALL TRIM   (DIRECT.TO.RESTORE$)
        CALL RTRIMC (DIRECT.TO.RESTORE$, ASC("/"))
        CALL RTRIMC (DIRECT.TO.RESTORE$, ASC("\\"))

        CALL OSSHELL("MKDIR " + DIRECT.TO.RESTORE$ + " >  " + \         !HJK
                     DIR.OUT$ + " >>* "  + DIR.OUT$ )
        STATUS.MSG$ = DIRECT.TO.RESTORE$ + " directory is created"
! HJK Starting block                                                    !HJK
        DIR.FILE.RC% = FUNC.OPEN.SEQUENTIAL.FILE( DIR.OUT$ )            !NJK

        ! If file open unsuccessful
        IF DIR.FILE.RC% <= XRE.ZERO% THEN BEGIN
            DIR.OPEN    = FALSE                                         !MJK
            STATUS.MSG$ = STATUS.TEXT.ERROR$(2)                         !JDC
            GOSUB LOG.STATUS.MSG
            ! Setting NULL to avoid file read
            DIR.VALUE$ = XRE.NULL$
        ENDIF ELSE BEGIN
            DIR.OPEN   = TRUE
            DIR.VALUE$ = XRE.SPACE$
        ENDIF

        ! Read the file till EOF or read error                          !FDC
        WHILE LEN(DIR.VALUE$) <> XRE.ZERO%
            DIR.VALUE$ = FUNC.READ.SEQUENTIAL.FILE( DIR.FILE.RC% )      !NJK

            !----------------------------------------!                  !OJK
            ! If error string matches, log the error !                  !OJK
            !----------------------------------------!                  !OJK
            IF MATCH("MKDIR",UCASE$(DIR.VALUE$),1) <> \                 !OJK
               XRE.ZERO% THEN BEGIN
                ! Error in creating directory
                STATUS.MSG$ = DIR.VALUE$                                !OJK
                GOSUB LOG.STATUS.MSG
                DIRECTORY.CREATE = FALSE
            ENDIF
        WEND

        IF DIRECTORY.CREATE THEN BEGIN
            STATUS.MSG$ = DIRECT.TO.RESTORE$ + " directory is created"
            GOSUB LOG.STATUS.MSG
        ENDIF ELSE BEGIN
            STATUS.MSG$ = DIRECT.TO.RESTORE$        + \
                          " directory is not created"
            GOSUB LOG.STATUS.MSG
        ENDIF

        ! Closing File
        IF DIR.OPEN THEN BEGIN
            CALL FUNC.CLOSE.FILE( DIR.FILE.RC% )                        !NJK
            DIR.OPEN = FALSE
        ENDIF
! HJK Ending block                                                      !HJK
    ENDIF

    ! Default value                                                     !OJK
    BKP.ZIP.FILE$     = XRE.NULL$                                       !OJK
    RESTORE.ERR.EXIST = FALSE                                           !OJK

    IF DIRECTORY.CREATE THEN BEGIN                                      !HJK

        IF RIGHT$(DIRECT.TO.RESTORE$,1) <> "\" THEN BEGIN
            !--------------------------------------------------!
            ! Adding slash for further processing if directory !
            ! value is not ending with slash                   !
            !--------------------------------------------------!
            DIRECT.TO.RESTORE$ = DIRECT.TO.RESTORE$ + "\"
        ENDIF

        ! If file present in IMG directory
        IF VALUE.EXISTS = 1 THEN BEGIN

! Commenting out the logic, as it is no longer needed                   !OJK
!            ! Extracting the archive file to C:/TEMP                   !OJK
!           CALL OSSHELL(ADXZUDIR.FILE.NAME$ + " -x "                + \!OJK
!                        BKP.FILENAME.IMG$ + XRE.SPACE$ + TEMP.DIR$  + \!OJK
!                        " > " + DIR.OUT$ + " >>* " + DIR.OUT$ )        !OJK

            ! Extracting the file using ADXUNZIP                        !OJK
            CALL OSSHELL(ADXUNZIP.FILE.NAME$ + " -C -o "       + \      !OJK
                         BKP.FILENAME.IMG$ + XRE.SPACE$        + \      !OJK
                         SELECTED.FILENAME$ + " -d "           + \      !OJK
                         DIRECT.TO.RESTORE$ + " > " + DIR.OUT$ + \      !OJK
                         " >>* " + DIR.OUT$ )                           !OJK

            STATUS.MSG$ = BKP.FILENAME.IMG$ + STATUS.TEXT.MSG$(46) + \  !JDC
                          "to get the file"
            GOSUB LOG.STATUS.MSG

            BKP.ZIP.FILE$ = BKP.FILENAME.IMG$                           !OJK

        ! If file present in ALT directory
        ENDIF ELSE IF VALUE.EXISTS = 2 THEN BEGIN

! Commenting out the logic, as it is no longer needed                   !OJK
!            ! Extracting the archive file to C:/TEMP                   !OJK
!           CALL OSSHELL(ADXZUDIR.FILE.NAME$ + " -x "                + \!OJK
!                        BKP.FILENAME.ALT$ + XRE.SPACE$ + TEMP.DIR$  + \!OJK
!                        " > " + DIR.OUT$ + " >>* " + DIR.OUT$ )        !OJK

            ! Extracting the file using ADXUNZIP                        !OJK
            CALL OSSHELL(ADXUNZIP.FILE.NAME$ + " -C -o "       + \      !OJK
                         BKP.FILENAME.ALT$ + XRE.SPACE$        + \      !OJK
                         SELECTED.FILENAME$ + " -d "           + \      !OJK
                         DIRECT.TO.RESTORE$ + " > " + DIR.OUT$ + \      !OJK
                         " >>* " + DIR.OUT$ )                           !OJK

            STATUS.MSG$ = BKP.FILENAME.ALT$ + STATUS.TEXT.MSG$(46) + \  !JDC
                          "to get the file"
            GOSUB LOG.STATUS.MSG

            BKP.ZIP.FILE$ = BKP.FILENAME.ALT$                           !OJK

        ! If the file present in BKPFAIL
        ENDIF ELSE IF VALUE.EXISTS = 3 THEN BEGIN
            RESTORE.FILENAME$ = SELECTED.FILENAME$                      !LJK
            MATCH.POS% = MATCH(".", SELECTED.FILENAME$,1)               !LJK
            IF MATCH.POS% <> XRE.ZERO% THEN BEGIN                       !LJK
                RESTORE.FILENAME$ = \                                   !LJK
                            LEFT$(SELECTED.FILENAME$,(MATCH.POS% - 1))  !LJK
            ENDIF                                                       !LJK

            ! Selecting the XDISKIMG directory location based on the    !MJK
            ! given file for restore                                    !MJK
            IF LEFT$(UCASE$(SELECT.FILE.NAME$),1) = "D" THEN BEGIN
                ! Copying the file to respective directory
                CALL OSSHELL("COPY " + C.BKP.IMG$ + RESTORE.FILENAME$ + \LJK
                             "." + MDD.DATE$ + XRE.SPACE$             + \LJK
                             DIRECT.TO.RESTORE$ + SELECTED.FILENAME$  + \LJK
                             " > " + DIR.OUT$ + " >>* " + DIR.OUT$)
            ENDIF ELSE BEGIN                                            !MJK
                ! Copying the file to respective directory
                CALL OSSHELL("COPY " + D.BKP.IMG$ + RESTORE.FILENAME$ + \MJK
                             "." + MDD.DATE$ + XRE.SPACE$             + \MJK
                             DIRECT.TO.RESTORE$ + SELECTED.FILENAME$  + \MJK
                             " > " + DIR.OUT$ + " >>* " + DIR.OUT$)     !MJK
            ENDIF
            !---------------------------------------------!
            ! Not distributing the file if SUPPS mode, as !
            ! ADXCSU0L won't work under SUPPS             !
            !---------------------------------------------!
            IF NOT SUPPS.ON THEN BEGIN
                ! Setting the distribution type
                CALL OSSHELL(ADXCSU0L.FILE.NAME$ + " 3 " + FSEL$     + \!MJK
                             XRE.SPACE$ + DIRECT.TO.RESTORE$         + \
                             SELECTED.FILENAME$ + " >> " + DIR.OUT$  + \
                             " >>* " + DIR.OUT$)
            ENDIF

            STATUS.MSG$ = "File is being extracted from BKPFAIL file"
            GOSUB LOG.STATUS.MSG

! Commenting the below, as it has become redundant                      !OJK
!            DIR.FILE.RC% = FUNC.OPEN.SEQUENTIAL.FILE( DIR.OUT$ )       !OJK
!                                                                       !OJK
!            ! If file open unsuccessful                                !OJK
!            IF DIR.FILE.RC% <= XRE.ZERO% THEN BEGIN                    !OJK
!                DIR.OPEN    = FALSE                                    !OJK
!                STATUS.MSG$ = STATUS.TEXT.ERROR$(2)                    !OJK
!                GOSUB LOG.STATUS.MSG                                   !OJK
!                ! Setting NULL to avoid file read                      !OJK
!                DIR.VALUE$ = XRE.NULL$                                 !OJK
!            ENDIF ELSE BEGIN                                           !OJK
!                DIR.OPEN   = TRUE                                      !OJK
!                DIR.VALUE$ = XRE.SPACE$                                !OJK
!            ENDIF                                                      !OJK
!                                                                       !OJK
!            ! Read the file till EOF or read error                     !OJK
!            WHILE LEN(DIR.VALUE$) <> XRE.ZERO%                         !OJK
!                DIR.VALUE$ = FUNC.READ.SEQUENTIAL.FILE( DIR.FILE.RC% ) !OJK
!                                                                       !OJK
!                !-----------------------------------------------!      !OJK
!                ! If error string matches, write the error with !      !OJK
!                ! file name in LOG file                         !      !OJK
!                !-----------------------------------------------!      !OJK
!                IF MATCH(UCASE$("Error"),UCASE$(DIR.VALUE$),1) <> \    !OJK
!                   XRE.ZERO% THEN BEGIN                                !OJK
!                    ! Logging the copy error and distribution error    !OJK
!                    STATUS.MSG$ = STATUS.TEXT.ERROR$(14)               !OJK
!                    GOSUB LOG.STATUS.MSG                               !OJK
!                    STATUS.MSG$ = DIR.VALUE$                           !OJK
!                    GOSUB LOG.STATUS.MSG                               !OJK
!                    RESTORE.STATUS = FALSE                             !OJK
!                ENDIF                                                  !OJK
!            WEND                                                       !OJK
!                                                                       !OJK
!            ! Closing File                                             !OJK
!            IF DIR.OPEN THEN BEGIN                                     !OJK
!                CALL FUNC.CLOSE.FILE( DIR.FILE.RC% )                   !OJK
!                DIR.OPEN = FALSE                                       !OJK
!            ENDIF                                                      !OJK
        ENDIF

        ! If valid restore
        IF VALUE.EXISTS > XRE.ZERO% THEN BEGIN

            ! Opening the STDOUT file to check for any error
            DIR.FILE.RC% = FUNC.OPEN.SEQUENTIAL.FILE( DIR.OUT$ )        !NJK

            ! If file open unsuccessful
            IF DIR.FILE.RC% <= XRE.ZERO% THEN BEGIN
                DIR.OPEN    = FALSE                                     !MJK
                STATUS.MSG$ = STATUS.TEXT.ERROR$(2)                     !JDC
                GOSUB LOG.STATUS.MSG
                ! Setting NULL to avoid file read
                DIR.VALUE$ = XRE.NULL$
            ENDIF ELSE BEGIN
                DIR.OPEN   = TRUE
                DIR.VALUE$ = XRE.SPACE$
            ENDIF

            ! Read the file till EOF or read error                      !FDC
            WHILE LEN(DIR.VALUE$) <> XRE.ZERO%
                DIR.VALUE$ = FUNC.READ.SEQUENTIAL.FILE( DIR.FILE.RC% )  !NJK

                !-----------------------------------------------!
                ! If error string matches, write the error with !
                ! file name in LOG file                         !
                !-----------------------------------------------!
                IF MATCH("ERROR",UCASE$(DIR.VALUE$),1) <> XRE.ZERO% OR  \OJK
                   MATCH("cannot be found",(DIR.VALUE$),1)  <>          \OJK
                   XRE.ZERO% THEN BEGIN
                    ! Logging the extraction error OR copy error
                    STATUS.MSG$ = DIR.VALUE$
                    GOSUB LOG.STATUS.MSG
                    ! Setting the status to show the notification
                    RESTORE.ERR.EXIST = TRUE                            !OJK

                    ! If BKPFAIL run
                    IF VALUE.EXISTS = 3 THEN BEGIN
                        STATUS.MSG$ = STATUS.TEXT.ERROR$(14)            !JDC
                        GOSUB LOG.STATUS.MSG
                    ENDIF ELSE BEGIN                                    !OJK
                        STATUS.MSG$ = STATUS.TEXT.ERROR$(15)            !OJK
                        GOSUB LOG.STATUS.MSG                            !OJK
                        ! Extracting the file using ADXUNZIP to C:/TEMP !OJK
                        CALL OSSHELL(ADXUNZIP.FILE.NAME$ + " -C -o "  + \OJK
                                     BKP.ZIP.FILE$ + XRE.SPACE$       + \OJK
                                     SELECTED.FILENAME$ + " -d "      + \OJK
                                     TEMP.DIR$ + " > " + DIR1.OUT$    + \OJK
                                     " >>* " + DIR1.OUT$ )              !OJK
                        STATUS.MSG$ = STATUS.TEXT.MSG$(48) + \          !OJK
                                      TEMP.DIR$ + " directory"          !OJK
                        GOSUB LOG.STATUS.MSG                            !OJK
                    ENDIF
                    ! To break the WHILE loop                           !OJK
                    DIR.VALUE$ = XRE.NULL$                              !OJK
                ENDIF
            WEND

            ! Closing File
            IF DIR.OPEN THEN BEGIN
                CALL FUNC.CLOSE.FILE( DIR.FILE.RC% )                    !NJK
                DIR.OPEN = FALSE
            ENDIF

        ENDIF

        ! If IMG or ALT directory run
        IF VALUE.EXISTS = 1 OR VALUE.EXISTS = 2 THEN BEGIN

!            STATUS.MSG$ = STATUS.TEXT.MSG$(48) + DIRECT.TO.RESTORE$ + \!OJK
!                          " directory"                                 !OJK
!            GOSUB LOG.STATUS.MSG                                       !OJK

!            STATUS.MSG$ = "Copying and Restoring the file"             !OJK
!            GOSUB LOG.STATUS.MSG                                       !OJK

            ! Copying the file from TEMP to the entered location
!            CALL OSSHELL("COPY " + TEMP.DIR$ + SELECTED.FILENAME$   + \!OJK
!                         XRE.SPACE$ + DIRECT.TO.RESTORE$            + \!OJK
!                         " > " + DIR.OUT$ + " >>* " + DIR.OUT$)        !OJK

            !------------------------------------------------!
            ! Not distributing the file if SUPPS mode, as    !
            ! ADXCSU0L won't work under SUPPS. Also make     !          !OJK
            ! sure no error has happened in file extraction  !          !OJK
            !------------------------------------------------!          !OJK
            IF NOT SUPPS.ON AND NOT RESTORE.ERR.EXIST THEN BEGIN        !OJK
                ! Setting the distribution type
                CALL OSSHELL(ADXCSU0L.FILE.NAME$ + " 3 " + FSEL$    + \ !MJK
                             XRE.SPACE$ + DIRECT.TO.RESTORE$        + \
                             SELECTED.FILENAME$ + " >  " + DIR.OUT$ + \ !OJK
                             " >>* " + DIR.OUT$)
!            ENDIF                                                      !OJK

                DIR.FILE.RC% = FUNC.OPEN.SEQUENTIAL.FILE( DIR.OUT$ )    !NJK

                ! If file open unsuccessful
                IF DIR.FILE.RC% <= XRE.ZERO% THEN BEGIN
                    DIR.OPEN    = FALSE                                 !MJK
                    STATUS.MSG$ = STATUS.TEXT.ERROR$(2)                 !JDC
                    GOSUB LOG.STATUS.MSG
                    ! Setting NULL to avoid file read
                    DIR.VALUE$ = XRE.NULL$
                ENDIF ELSE BEGIN
                    DIR.OPEN   = TRUE
                    DIR.VALUE$ = XRE.SPACE$
                ENDIF

                ! Read the file till EOF or read error                  !FDC
                WHILE LEN(DIR.VALUE$) <> XRE.ZERO%
                    DIR.VALUE$ = FUNC.READ.SEQUENTIAL.FILE(DIR.FILE.RC%)!NJK

                    !-----------------------------------------------!
                    ! If error string matches, write the error with !
                    ! file name in LOG file                         !
                    !-----------------------------------------------!
                    IF MATCH("ERROR",UCASE$(DIR.VALUE$),1) <> \         !OJK
                       XRE.ZERO% THEN BEGIN
                        ! Logging the distribution error                !OJK
                        STATUS.MSG$ = STATUS.TEXT.ERROR$(16)            !OJK
                        GOSUB LOG.STATUS.MSG
                        STATUS.MSG$ = DIR.VALUE$
                        GOSUB LOG.STATUS.MSG

                        RESTORE.ERR.EXIST = TRUE                        !OJK
                        ! To break the WHILE loop                       !OJK
                        DIR.VALUE$ = XRE.NULL$                          !OJK
                    ENDIF
                WEND

                ! Closing File
                IF DIR.OPEN THEN BEGIN
                    CALL FUNC.CLOSE.FILE( DIR.FILE.RC% )                !NJK
                    DIR.OPEN = FALSE
                ENDIF
            ENDIF                                                       !OJK
        ENDIF
    ENDIF                                                               !HJK

    ! Setting the notification based on the restore status flag
    IF NOT RESTORE.ERR.EXIST AND DIRECTORY.CREATE THEN BEGIN            !OJK
        FIELD$(1) = "'File restoration process successful"

        STATUS.MSG$ = "File restoration successful"

        ! Restore complete message
        FIELD$(3) = "The file " + UCASE$(SELECTED.FILENAME$)         + \
                    " has been restored from "                       + \
                    UCASE$(DAY.ARRAY$(SEL.INDEX%)) + ", "            + \
                    RIGHT$(BKP.DATE.ARRAY$(SEL.INDEX%),2) + "/"      + \
                    MID$(BKP.DATE.ARRAY$(SEL.INDEX%),3,2) + " to "   + \!HJK
                    UCASE$(DIRECT.TO.RESTORE$)                          !HJK
        FIELD$(4) = "This file has been distributed as a type " + FSEL$ !GJK

    ENDIF ELSE BEGIN
        IF DIRECTORY.CREATE THEN BEGIN                                  !HJK
            FIELD$(1) = "'Unable to restore this file because it " + \  !GJK
                        "is currently locked by another program"
            STATUS.MSG$ = "File restored with an exception"             !OJK
            ! Restore complete message
            FIELD$(3) = "The file " + UCASE$(SELECTED.FILENAME$) + \    !OJK
                        " has been restored with an exception from "    !OJK

            FIELD$(4) = UCASE$(DAY.ARRAY$(SEL.INDEX%)) + ", "       + \ !OJK
                        RIGHT$(BKP.DATE.ARRAY$(SEL.INDEX%),2) + "/" + \ !OJK
                        MID$(BKP.DATE.ARRAY$(SEL.INDEX%),3,2)       + \ !OJK
                        " to " + UCASE$(DIRECT.TO.RESTORE$) + "."       !OJK
        ENDIF ELSE BEGIN                                                !HJK
            FIELD$(1) = "'Error in creating directory"                  !HJK

            STATUS.MSG$ = "File restore unsuccessful"                   !OJK

            ! Restore unsuccessful message                              !OJK
            FIELD$(3) = "The file " + UCASE$(SELECTED.FILENAME$) + \    !OJK
                        " is not restored to "                   + \    !OJK
                        UCASE$(DIRECT.TO.RESTORE$)                      !OJK

            FIELD$(4) = "Please re-enter the directory and try again."  !OJK
        ENDIF

!        STATUS.MSG$ = "File restored with an exception"                !OJK

!        ! Restore complete message                                     !OJK
!        FIELD$(3) = "The file " + UCASE$(SELECTED.FILENAME$) + \       !OJK
!                    " has been restored with an exception from "       !OJK

!        FIELD$(4) = UCASE$(DAY.ARRAY$(SEL.INDEX%)) + ", "           + \!OJK
!                    RIGHT$(BKP.DATE.ARRAY$(SEL.INDEX%),2) + "/"     + \!OJK
!                    MID$(BKP.DATE.ARRAY$(SEL.INDEX%),3,2)           + \!OJK
!                    " to " + UCASE$(DIRECT.TO.RESTORE$) + "."          !OJK

    ENDIF

    GOSUB LOG.STATUS.MSG                                                !GJK

    FIELD$(2) = "File restoration complete"                             !MJK

    ! Setting the visibility
    CALL DM.VISIBLE ("5", STATUS.TEXT.MSG$(60))                         !IDC

    ! To Make sure no error occurs when F3 or ESC pressed
    RESTORE.STATUS = TRUE

    ! Handles the final restore screen
    WHILE SCREEN% = FILE.PROCESS.SCR%                                   !CJK
        IF SCREEN% = FILE.PROCESS.SCR% THEN BEGIN                       !CJK
            RET.KEY% = DM.PROCESS.SCREEN (5, 5, FALSE)

            IF RET.KEY% = ESC.KEY% THEN BEGIN                           !MJK

                ! Previous screen
                SCREEN%      = FILE.CONFIRMATION.SCR%                   !CJK
                PREVIOUS.KEY = TRUE

            ENDIF ELSE BEGIN
                CALL DM.FOCUS ("1", SCREEN.TEXT.MSG$(13) + \            !MJK
                                    "previous screen")                  !MJK
            ENDIF
        ENDIF
    WEND

RETURN

                !   MAIN.PROCESSING SPECIFIC ROUTINES ENDS   !
                !............................................!

\**********************************************************************\
\**********************************************************************\
\*                                                                    *\
\*                       GENERIC ROUTINES                             *\
\*                                                                    *\
\**********************************************************************\
\**********************************************************************\

\***********************************************************************
\*
\* CHECK.FUN.RC2: If FUN.RC2% is zero, By-passes rest of                !MJK
\*                 procedure. Stops program.
\*
\***********************************************************************
CHECK.FUN.RC2:                                                          !IDC

    IF FUN.RC2% = XRE.ZERO% THEN RETURN  ! No error                     !IDC

    STATUS.MSG$  = "Ended: Error while opening " + PASSED.STRING$

    GOSUB PROGRAM.EXIT

RETURN

                        !   GENERIC ROUTINES ENDS   !
                        !...........................!

\**********************************************************************\
\**********************************************************************\
\*                                                                    *\
\*                 TERMINATION SPECIFIC ROUTINES                      *\
\*                                                                    *\
\**********************************************************************\
\**********************************************************************\

\***********************************************************************
\*
\*    CLOSE.AND.DEALLOC.SESSIONS: This Sub-routine closes the active
\*                                sessions and De-allocates the session
\*                                numbers.
\*
\***********************************************************************
CLOSE.AND.DEALLOC.SESSIONS:

    ! Closing the pipe and deallocating the session if OPEN
    IF XBACK.OPEN THEN BEGIN                                            !MJK
        CLOSE XBACK.PIPE.SESS.NUM%
        XBACK.OPEN = FALSE                                              !JDC
        CALL SESS.NUM.UTILITY("C",XBACK.PIPE.SESS.NUM%,XRE.NULL$)       !MJK
    ENDIF

    ! Closing the Log if OPEN
    IF XRE.LOG.OPEN THEN BEGIN                                          !MJK
        CALL FUNC.CLOSE.FILE(XRE.FILE.RC%)                              !NJK
        XRE.LOG.OPEN = FALSE
    ENDIF

    ! Closing the pipe and deallocating the session if OPEN
    IF XRE.OPEN THEN BEGIN                                              !MJK
        CLOSE XRE.PIPE.SESS.NUM%
        XRE.OPEN = FALSE                                                !JDC
        CALL SESS.NUM.UTILITY("C",XRE.PIPE.SESS.NUM%,XRE.NULL$)         !MJK
    ENDIF

    ! Closing BKPLIST File if OPEN
    IF BKPLIST.OPEN THEN BEGIN
        CALL FUNC.CLOSE.FILE( BKPLIST.FILE.RC% )                        !NJK
        BKPLIST.OPEN = FALSE
    ENDIF

    ! Closing DIR File if OPEN
    IF DIR.OPEN THEN BEGIN
        CALL FUNC.CLOSE.FILE( DIR.FILE.RC% )                            !NJK
        DIR.OPEN = FALSE
    ENDIF

    ! Closing SLPCF File if OPEN                                        !IDC
    IF SLPCF.OPEN THEN BEGIN                                            !IDC
        CALL FUNC.CLOSE.FILE(SLPCF.SESS.NUM% )                          !NJK
        SLPCF.OPEN = FALSE                                              !IDC
    ENDIF                                                               !IDC

RETURN

\***********************************************************************
\*
\* CHAIN.TO.CALLER: Chain to Application or Program
\*
\***********************************************************************
CHAIN.TO.CALLER:

    ! Terminate if any active session present                           !FDC
    GOSUB TERMINATION                                                   !FDC

    ! If command mode, clears and stop the program
    IF COMMAND.MODE THEN BEGIN
        CLEARS
        GOSUB STOP.PROGRAM
    ENDIF

    CALL DM.STATUS ("'Processing - Please Wait .....")
    CALL DM.QUIT

    ! Current program and chaining program
    PSBCHN.APP = "C:/ADX_UPGM/XRESTORE.286"                             !MJK
    PSBCHN.PRG = "C:/ADX_UPGM/" + CHAIN.TO.PROG$ + ".286"               !MJK

    %INCLUDE PSBCHNE.J86          ! Include CHAIN operation
\/*********************************************************************/ PSBCHNE
\/*                                                                   */ PSBCHNE
\/*      PSBCHNE.J86  -  Chain to PSB Application Program             */ PSBCHNE
\/*      ------------------------------------------------             */ PSBCHNE
\/*                                                                   */ PSBCHNE
\/*********************************************************************/ PSBCHNE
                                                                       ! PSBCHNE
        CHAIN  PSBCHN.PRG , PSBCHN.OP , PSBCHN.APP , PSBCHN.MENCON ,   \ PSBCHNE
                            PSBCHN.U1 , PSBCHN.U2  , PSBCHN.U3         ! PSBCHNE
                                                                       ! PSBCHNE

    GOSUB STOP.PROGRAM

RETURN

\***********************************************************************
\*
\* PROGRAM.EXIT: Log the error, Deallocate the session and then chain
\*               back to the caller.
\*
\***********************************************************************
PROGRAM.EXIT:

    GOSUB LOG.STATUS.MSG
    GOSUB CHAIN.TO.CALLER

RETURN
                !   TERMINATION SPECIFIC ROUTINES ENDS   !
                !........................................!

\***********************************************************************
\*
\* ERROR.DETECTED:    Main Error Handling Routine. Starts with the
\*                    resume error conditions following ERROR.COUNT%
\*                    check to avoid error loop. Also References
\*                    STANDARD.ERROR.DETECTED to log Event 101.
\*
\***********************************************************************
ERROR.DETECTED:

    IF ERR = "CU" OR ERR = "DU" THEN RESUME     ! Close and delete
                                                ! session errors
    ! Incrementing the error count
    ERROR.COUNT% = ERROR.COUNT% + 1

    ! Handling infinite loop
    IF ERROR.COUNT% > 1 THEN BEGIN
        RESUME STOP.PROGRAM
    ENDIF

    ! When program runs in command, this error catch will be used
    IF ERR = "NP" THEN BEGIN
        COMMAND.MODE = -1                   ! TRUE
        ERROR.COUNT% = ERROR.COUNT% - 1     ! Non Fatal error
        RESUME START.OF.PROGRAM
    ENDIF

    ! Error creating XBACKUP pipe or XRESTORE pipe
    IF ERR = "ME" THEN BEGIN

        IF ERRF% = XBACK.PIPE.SESS.NUM% THEN BEGIN
            XBACK.OPEN  = FALSE                                         !JDC
            STATUS.MSG$ = "RESTORE not allowed when XBACKUP is active"
            ERROR.MSG$  = STATUS.MSG$
            GOSUB LOG.STATUS.MSG
            ERROR.EXIST  = TRUE                                         !MJK
            ERROR.COUNT% = ERROR.COUNT% - 1  ! Non Fatal error
            RESUME XBACK.PIPE.CREATE.ERROR                              !MJK
        ENDIF ELSE IF ERRF% = XRE.PIPE.SESS.NUM% THEN BEGIN             !MJK
            XRE.OPEN    = FALSE                                         !MJK
            STATUS.MSG$ = "XRESTORE is already active somewhere"
            ERROR.MSG$  = STATUS.MSG$
            GOSUB LOG.STATUS.MSG
            ERROR.EXIST  = TRUE
            ERROR.COUNT% = ERROR.COUNT% - 1  ! Non Fatal error
            RESUME XRE.PIPE.CREATE.ERROR                                !MJK
        ENDIF ELSE IF ERRF% = XRE.LOG.SESS.NUM% THEN BEGIN              !MJK
            XRE.LOG.OPEN = FALSE                                        !MJK
            STATUS.MSG$  = "Unable to create XRESTORE log"              !MJK
            ERROR.MSG$   = STATUS.MSG$                                  !MJK
            GOSUB LOG.STATUS.MSG                                        !MJK
            ERROR.EXIST  = TRUE                                         !MJK
            ERROR.COUNT% = ERROR.COUNT% - 1  ! Non Fatal error          !MJK
            RESUME XRE.LOG.CREATE.ERROR                                 !MJK
        ENDIF                                                           !MJK

    ENDIF

    STATUS.MSG$ = "Ended: " + ERR + " " + ERRNH + " ERRL "  + \
                  STR$(ERRL) + " ERRF% " + STR$(ERRF%)
    IF SUPPS.ON THEN BEGIN                                              !JDC
        CLEARS                                                          !MJK
        PRINT STATUS.MSG$                                               !JDC
    ENDIF ELSE BEGIN                                                    !JDC
        ! Log event 102
        CALL STANDARD.ERROR.DETECTED(ERRN, ERRF%, ERRL, ERR)            !DJK
    ENDIF                                                               !JDC
    ! Error message to log
    GOSUB PROGRAM.EXIT ! updates LOG and Program ends
END

\***********************************************************************
\***********************************************************************
\*
\*    End of program XRESTORE
\*
\***********************************************************************
\***********************************************************************

