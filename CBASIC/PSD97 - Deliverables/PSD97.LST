   1: 0002: \******************************************************************************
   2: 0002: \******************************************************************************
   3: 0002: \***
   4: 0002: \***
   5: 0002: \***   PSD97                 26/10/2015                 Ranjith Gopalankutty
   6: 0002: \***
   7: 0002: \***   Original version
   8: 0002: \***
   9: 0002: \***
  10: 0002: \***   Usage
  11: 0002: \***   This utility will help to clear the serial number of DVCHR,DIDIR
  12: 0002: \***   and DEALDIR bin files in BCF.BIN. Which will be used during deal 
  13: 0002: \***   initial load process.
  14: 0002: \***   
  15: 0002: \***   Screen will have below standard options          
  16: 0002: \***       F3  = To return to main menu       
  17: 0002: \***       F1  = Help Key 
  18: 0002: \***       ESC = To escape out of the screen
  19: 0002: \***   
  20: 0002: \***   
  21: 0002: \******************************************************************************
  22: 0002: \******************************************************************************
  23: 0002: \***
  24: 0002: \***    Included code defining function related Global variables
  25: 0002: \***
  26: 0002: \******************************************************************************
  27: 0002: \******************************************************************************
  28: 0002: 
  29: 0002:     %INCLUDE BCFDEC.J86     !   BCF file function
  30: 0002: \*****************************************************************************
  31: 0002: \*****************************************************************************
  32: 0002: \***
  33: 0002: \***               %INCLUDE FOR BCF - FIELD DECLARATIONS
  34: 0002: \***                                  FILE REFERENCE PARAMETERS
  35: 0002: \***
  36: 0002: \***                      FILE TYPE    : SEQUENTIAL
  37: 0002: \***
  38: 0002: \***                      REFERENCE    : BCFDEC.J86
  39: 0002: \***
  40: 0002: \***      Version A             Steve Windsor          5th Jan 1993
  41: 0002: \***
  42: 0002: \***      Version B             Michael J. Kelsall    01st Dec 1993
  43: 0002: \***      Addition to file of CCMVT serial number as part of
  44: 0002: \***      RETURNS/AUTOMATIC CREDIT CLAIMING package.
  45: 0002: \***
  46: 0002: \***      Version C           Stuart William McConnachie 23rd Jan 1995
  47: 0002: \***      Addition of TXR serial number as part of the TRANSACTION RETRIEVAL
  48: 0002: \***      project.
  49: 0002: \***
  50: 0002: \***      Version D           Stuart William McConnachie  7th June 1995
  51: 0002: \***      Converted calls to enable more than 1 record on the BCF.
  52: 0002: \***      The second record is to be used for the No7 customer card trial.
  53: 0002: \***
  54: 0002: \***      Version E                 Stuart Highley        7th April 1999
  55: 0002: \***      Added new fields for cash accounting.
  56: 0002: \***
  57: 0002: \***      Version F                 Mark Goode            20th May 2000
  58: 0002: \***      Added new fields for Dentistry project.
  59: 0002: \***
  60: 0002: \***      Version G                 Mark Goode            18th July 2000
  61: 0002: \***      Added new fields for Well-Being project.
  62: 0002: \***
  63: 0002: \***      Version I                 Amy Hoggard           13th Oct 2000
  64: 0002: \***      Added new fields for ECO project.
  65: 0002: \***
  66: 0002: \***      Version K                 Brian Greenfield      1st May 2001
  67: 0002: \***      Added new field for Wellbeing Services record 13.
  68: 0002: \***
  69: 0002: \***      Version L                 Amy Hoggard           4th Jan 2002
  70: 0002: \***      Added new field for ETOPUP project.
  71: 0002: \***
  72: 0002: \***      Version M                 Julia Stones          22nd July 2002
  73: 0002: \***      Added new fields for Deals rewrite project record 14.
  74: 0002: \***
  75: 0002: \***    Revision 4.6            ROBERT COWEY.            19 MAY 2003.
  76: 0002: \***    Modifications for All Txn Data To CDAS project.
  77: 0002: \***    Removed redundant variables ...
  78: 0002: \***      BCF.CTSL1.SERIAL.NUM$, BCF.CTSL2,SERIAL.NUM$
  79: 0002: \***    Defined new variable ...
  80: 0002: \***      BCF.MTSLQ.DAYS$, BCF.FILLER67$
  81: 0002: \***
  82: 0002: \***    Revision 4.7           Julia Stones              9th July 2003.
  83: 0002: \***    Modifications for New Lines Report project.
  84: 0002: \***    Defined new variable
  85: 0002: \***    BCF.NEWLINES.WEEKS$
  86: 0002: \***
  87: 0002: \***    Revision 4.8           Julia Stones              3rd October 2003.
  88: 0002: \***    Modifications for New Lines Report project.
  89: 0002: \***    Defined new variable
  90: 0002: \***    BCF.NEWLINES.LINES$
  91: 0002: \***
  92: 0002: \***    Version N              Jamie Thorpe             27th June 2006
  93: 0002: \***    Added BCF.DVCHR.SERIAL.NUM$
  94: 0002: \***
  95: 0002: \***    Revision 4.10          Charles Skadorwa            4th July 2011
  96: 0002: \***    CORE Heritage Stores Release 2 (Outbound) Project.
  97: 0002: \***    New variables defined: BCF.ECC.DATETIMESTAMP$
  98: 0002: \***                           BCF.IUF.DATETIMESTAMP$
  99: 0002: \***
 100: 0002: \***    Revision 4.11          Arun Sudhakaran             10th April 2013
 101: 0002: \***    Added new variables for including Supplier Number lengths
 102: 0002: \***    as part of Automatic Booking In of Chilled Food ASNs project
 103: 0002: \***
 104: 0002: \***    Revision 4.12          Charles Skadorwa            5th Sept 2013
 105: 0002: \***    F261 Gift Card Mall IIN Range Extension Project - Commented !4.12 CSk
 106: 0002: \***    Defined new variables for GCM Product Group Number and Record 22
 107: 0002: \***    lengths.
 108: 0002: \***
 109: 0002: \***    Version O              Mark Walker                  3rd Feb 2014
 110: 0002: \***    F337 Centralised View of Stock
 111: 0002: \***    - Defined variables for record 23 (stock snapshot parameters).
 112: 0002: \***    - Minor formatting changes (uncommented).
 113: 0002: \***
 114: 0002: \***    Revision O             Charles Skadorwa             25th June 2014
 115: 0002: \***    F353 Deal Limits Increase Project.
 116: 0002: \***    Renamed 3 variables in function BCF.RECORD.14.W -
 117: 0002: \***        BCF.DINF.NUM.REC$ becomes BCF.ITMDL.NUM.REC$
 118: 0002: \***        BCF.DINF.KEY.LEN$ becomes BCF.ITMDL.KEY.LEN$
 119: 0002: \***        BCF.ECC.DATETIMESTAMP$ becomes BCF.FILLER.DATETIMESTAMP$
 120: 0002: \*****************************************************************************
 121: 0002: \*****************************************************************************
 122: 0002: 
 123: 0002:     STRING GLOBAL                                                       \
 124: 0002:         BCF.FILE.NAME$
 125: 0002: 
 126: 0002:     INTEGER*2 GLOBAL                                                    \
 127: 0002:         BCF.RECL%,                                                      \   !OMW
 128: 0002:         BCF.REPORT.NUM%,                                                \
 129: 0002:         BCF.SESS.NUM%
 130: 0002: 
 131: 0002:     STRING GLOBAL                                                       \
 132: 0002:     BCF.RECORD$,          \ 80 bytes
 133: 0002:     BCF.IUF.SERIAL.NO$,   \ 5 bytes, IUF serial number
 134: 0002:     BCF.OPEN.DATE$,       \ 6 bytes, Last store opening date (YYMMDD)
 135: 0002:     BCF.FILLER.DATE$,     \ 3 bytes, filler
 136: 0002:     BCF.LABEL.DATE$,      \ 6 bytes, label print date (YYMMDD)
 137: 0002:     BCF.SALES.SERIAL.NO$ ,\ 5 bytes, sales serial number
 138: 0002:     BCF.STMVB.SERIAL.NO$, \ 5 bytes, current serial number          \
 139: 0002:                               \     of Stock Movement Backup file       \
 140: 0002:     BCF.TOF.DAYS$,        \ 2 bytes, number of days' worth of sales to \
 141: 0002:                           \       be held on the TIF at re-build       \
 142: 0002:         BCF.EPS.BATCH$,       \ 2 bytes, highest batch number to have   \
 143: 0002:                               \     been reported upon by PSE31         \
 144: 0002:     BCF.NO.EPF.COPIES$,   \ 2 bytes, no. of copies of EPS payment file \
 145: 0002:     BCF.CCMVT.SERIAL.NUM$,\ 5 bytes ASC                                ! BMJK
 146: 0002:     BCF.TXR.SERIAL.NUM$,  \ 5 bytes transaction retrieval serial number!SWM
 147: 0002:     BCF.CUSTD.SERIAL.NUM$,\ 5 bytes customer data file serial number   !SWM
 148: 0002:     BCF.PSB58.DATE$,      \ 6 bytes date of last MTSL/CUSTW cut-off    !SWM
 149: 0002:     BCF.CTSL1.SERIAL.NUM$,\ 5 bytes serial number on first MTSLQ (and  ! 4.6 RC
 150: 0002:                           \         thereore CTSL1) batch header       ! 4.6 RC
 151: 0002:     BCF.MTSLQ.DAYS$,      \ 2 byte MTSLQ data retention period (PSB14) ! 4.6 RC
 152: 0002:     BCF.FILLER67$,        \ 8 bytes filler beginning at byte 67        ! 4.6 RC
 153: 0002:         BCF.NTIUF.SERIAL.NO$,                                           \   !FMG
 154: 0002:         BCF.DENTISTRY.PSAUDIT.SERIAL.NO$,                               \   !FMG
 155: 0002:         BCF.WELL.SERIAL.NO$,                                            \   !GMG
 156: 0002:         BCF.WELL.PSAUDIT.SERIAL.NO$,                                    \   !GMG
 157: 0002:     BCF.ACSAL.SERIAL.NUM$,\ 5 bytes serial number on ACSAL             !ESDH
 158: 0002:     BCF.DENTISTRY.PRODUCT.GROUP$,                                      \FMG
 159: 0002:     BCF.WELL.PRODUCT.GROUP$,                                           \GMG
 160: 0002:     BCF.FILLER$,         \! 1 byte, filler                             !BMJK
 161: 0002:     BCF.WELL.SERV.PRODUCT.GROUP$,                                      \KBG
 162: 0002:         BCF.ETOPUP.PROD.GRP$,                                           \   !LAH
 163: 0002:         BCF.END.FILLER$,                                                \   !LAH
 164: 0002:     BCF.TBAG.BATCH.NO$,                                                \IAH
 165: 0002:     BCF.TBAG.DAYS.KEPT$,                                               \IAH
 166: 0002:     BCF.NEWLINES.WEEKS$,                                               \4.7JAS
 167: 0002:     BCF.NEWLINES.LINES$,                                               \4.8JAS
 168: 0002:     BCF.TBAG.FILLER$,                                                  \ 79 Bytes filler !IAH 70 Bytes filler 4.7JAS ! 65 Bytes fille 4.8JAS
 169: 0002:     BCF.DEALDIR.SERIAL.NUM$, \ 4 bytes serial number                   !MJAS
 170: 0002:     BCF.DIDIR.SERIAL.NUM$,   \ 4 bytes serial number                   !MJAS
 171: 0002:     BCF.DEAL.NUM.REC$,       \ 6 bytes number of records in deal file  !MJAS
 172: 0002:     BCF.ITMDL.NUM.REC$,      \ 6 bytes number of records in ITMDL file !OCS
 173: 0002:     BCF.DEAL.KEY.LEN$,       \ 3 bytes key length of deal file         !MJAS
 174: 0002:     BCF.ITMDL.KEY.LEN$,      \ 3 bytes bytes ITMDL record key length   !OCS
 175: 0002:     BCF.DVCHR.SERIAL.NUM$,   \ 4 bytes serial numbr                    !NJT !4.10CSk
 176: 0002:     BCF.FILLER.DATETIMESTAMP$,\17 bytes filler for future use          !OCS
 177: 0002:     BCF.IUF.DATETIMESTAMP$, \ !17 bytes timestamp YYYYMMDDHHMMSSsss     !4.10CSk
 178: 0002:                             \ !   Last successfully processed IUF from SAP.
 179: 0002:         BCF.ITEM.STATUS$(1),     \1 byte array, item status             \   !OMW
 180: 0002:         BCF.NEGATIVE.STOCK.FLAG$(1), \1 byte array, Flag (Y/N) whether  \   !OMW
 181: 0002:                                  \   to include items with a negative   \   !OMW
 182: 0002:                                  \   stock figure in the initial stock  \   !OMW
 183: 0002:                                  \   snapshot messages.                 \   !OMW
 184: 0002:         BCF.POSITIVE.STOCK.FLAG$(1), \1 byte array, Flag (Y/N) whether  \   !OMW
 185: 0002:                                  \   to include items with a positive   \   !OMW
 186: 0002:                                  \   stock figure in the initial stock  \   !OMW
 187: 0002:                                  \   snapshot messages.                 \   !OMW
 188: 0002:         BCF.ZERO.STOCK.FLAG$(1)  !1 byte array, Flag (Y/N) whether to   \   !OMW
 189: 0002:                                  \   include items with a zero          \   !OMW
 190: 0002:                                  \   stock figure in the initial stock  \   !OMW
 191: 0002:                                  !   snapshot messages.                     !OMW
 192: 0002:                 
 193: 0002:     INTEGER*1                                                           \
 194: 0002:         BCF.NO.CPM.COPIES%
 195: 0002: 
 196: 0002:     INTEGER*2 GLOBAL                                                    \
 197: 0002:     BCF.CC.SERIAL.NO,        \ 1 byte UPD, CC serial number
 198: 0002:         BCF.MAX.STATUS.COUNT%,        \ Maximum number of item status   \   !OMW
 199: 0002:     BCF.REC21.REC.LEN%,      \ Total Supplier number length            !4.11 AS
 200: 0002:     BCF.REC21.SUPPLIER.LEN%, \ Length of the supplier number           !4.11 AS
 201: 0002:         BCF.MAX.STOCK.INIT.MESSAGES%, \ Maximum number of initial       \   !OMW
 202: 0002:                                       \ stock snapshot message to       \   !OMW
 203: 0002:                                       \ send per day.                   \   !OMW
 204: 0002:         BCF.MAX.STOCK.INIT.ITEMS%,    \ Maximum number of items to      \   !OMW
 205: 0002:                                       \ include in a single initial     \   !OMW
 206: 0002:                                       \ stock snapshot message.         \   !OMW
 207: 0002:         BCF.NEGATIVE.DAYS%(1),        \ Number of days' movements with  \   !OMW
 208: 0002:                                       \ a negative stock figure to      \   !OMW
 209: 0002:                                       \ include in the initial stock    \   !OMW
 210: 0002:                                       \ snapshot messages.              \   !OMW
 211: 0002:         BCF.POSITIVE.DAYS%(1),        \ Number of days' movements with  \   !OMW
 212: 0002:                                       \ a positive stock figure to      \   !OMW
 213: 0002:                                       \ include in the initial stock    \   !OMW
 214: 0002:                                       \ snapshot messages.              \   !OMW
 215: 0002:         BCF.REC22.REC.LEN%,           \                                 \   !4.12 CSk
 216: 0002:         BCF.REC22.PROD.GROUP.LEN%,    \ Length of GCM Product Group No  \   !4.12 CSk
 217: 0002:         BCF.ZERO.DAYS%(1)             \ Number of days' movements with  \   !OMW
 218: 0002:                                       \ a zero stock figure to include  \   !OMW
 219: 0002:                                       \ in the initial stock snapshot   \   !OMW
 220: 0002:                                       ! messages.                           !OMW
 221: 0002: 
 222: 0002: 
 223: 0002:     INTEGER*4 GLOBAL                                                    \
 224: 0002:         BCF.REC.NO%
 225: 0002: 
 226: 0002:     %INCLUDE BEMFDEC.J86    !   BEMF file function
 227: 0002: \******************************************************************************
 228: 0002: \***
 229: 0002: \***	   %INCLUDE FOR BOOTS ERROR MESSAGE FILE - FIELD DECLARATIONS
 230: 0002: \***                                             - FILE REFERENCE PARAMETERS
 231: 0002: \***
 232: 0002: \***                         FILE TYPE : Direct
 233: 0002: \***
 234: 0002: \***                         REFERENCE : BEMFDEC
 235: 0002: \***
 236: 0002: \***	Version A               Mark Walker                  1st November 1993
 237: 0002: \***
 238: 0002: \******************************************************************************
 239: 0002: 
 240: 0002: 	STRING GLOBAL			BEMF.MESSAGE$,			\
 241: 0002: 					BEMF.FILE.NAME$
 242: 0002: 
 243: 0002: 	INTEGER*2 GLOBAL		BEMF.RECL%,			\
 244: 0002: 					BEMF.REPORT.NUM%,		\
 245: 0002: 					BEMF.SESS.NUM%
 246: 0002: 
 247: 0002: 	INTEGER*4 GLOBAL		BEMF.REC.NO%
 248: 0002:     %INCLUDE PSBF01G.J86    !   APPLICATION.LOG
 249: 0002: REM \
 250: 0002: \*******************************************************************************
 251: 0002: \*******************************************************************************
 252: 0002: \***
 253: 0002: \***       %INCLUDE FOR GLOBAL DEFINITIONS FOR FUNCTION APPLICATION.LOG
 254: 0002: \***
 255: 0002: \***                FUNCTION NUMBER    : PSBF01
 256: 0002: \***
 257: 0002: \***                REFERENCE          : PSBF01G.J86
 258: 0002: \***
 259: 0002: \***                DATE OF LAST AMENDMENT  - 27/2/86
 260: 0002: \***
 261: 0002: \***
 262: 0002: \*******************************************************************************
 263: 0002: 
 264: 0002:       INTEGER GLOBAL  F01.RETURN.CODE%
 265: 0002: 
 266: 0002: 
 267: 0002:     %INCLUDE PSBF20G.J86    !   ALLOCATE.DEALLOCATE.SESS.NUM
 268: 0002: REM\
 269: 0002: \*******************************************************************************
 270: 0002: \*******************************************************************************
 271: 0002: \***
 272: 0002: \***     %INCLUDE GLOBAL VARIABLE DEFINITIONS FOR SESS.NUM.UTILITY FUNCTION
 273: 0002: \***
 274: 0002: \***                       REFERENCE     : PSBF20G.J86
 275: 0002: \*** 
 276: 0002: \***     Version A              Bruce Scrive                   5th May 1988   
 277: 0002: \*** 
 278: 0002: \***     Version B              Robert Cowey                   7th May 1991
 279: 0002: \***     Global variable F20.INTEGER.FILE.NO% changed from one byte integer
 280: 0002: \***     to two byte integer.
 281: 0002: \***
 282: 0002: \***     Version D              Andrew Wedgeworth             1st July 1992
 283: 0002: \***     F20.RETURN.CODE% removed as it is no longer required.
 284: 0002: \***
 285: 0002: \*******************************************************************************
 286: 0002: \*******************************************************************************
 287: 0002: 
 288: 0002:       STRING    GLOBAL F20.FILE.NAME$,                                 \
 289: 0002:                        F20.STRING.FILE.NO$,                            \
 290: 0002:                        F20.TABLE.DIMENSIONED.FLAG$,                    \
 291: 0002:                        SESS.NUM.TABLE$(1)
 292: 0002: 
 293: 0002:       INTEGER*2 GLOBAL F20.INTEGER.FILE.NO%
 294: 0002: 
 295: 0002:       ! 1 line deleted from here                                       ! DAW 
 296: 0002: 
 297: 0002:     %INCLUDE PSBF39G.J86    !   Display Manager
 298: 0002: !******************************************************************************
 299: 0002: !******************************************************************************
 300: 0002: !***
 301: 0002: !***            PROGRAM         :       PSBF39G.J86
 302: 0002: !***
 303: 0002: !***            DESCRIPTION     :       DISPLAY MANAGER INTERFACE
 304: 0002: !***
 305: 0002: !***            AUTHOR          :       Stuart William McConnachie
 306: 0002: !***            DATE WRITTEN    :       September 2000
 307: 0002: !***
 308: 0002: !***        Provides a much needed and easier to use interface to
 309: 0002: !***        IBM Display Manager.
 310: 0002: !***
 311: 0002: !***        Saves the user having to set up, highlight, tab between and
 312: 0002: !***        validate fields.  Also handles the help screens and conversion
 313: 0002: !***        of date fields to external/internal format.
 314: 0002: !***
 315: 0002: !******************************************************************************
 316: 0002: !******************************************************************************
 317: 0002:     
 318: 0002:     STRING GLOBAL       MESSAGE$(1)
 319: 0002:     STRING GLOBAL       VALID$(1)
 320: 0002:     STRING GLOBAL       VISIBLE$(1)
 321: 0002:     STRING GLOBAL       FIELD$(1)
 322: 0002:     STRING GLOBAL       TITLE$
 323: 0002: 
 324: 0002:     INTEGER*2 GLOBAL    DM.SCREEN%
 325: 0002:     INTEGER*2 GLOBAL    DM.FIELD%
 326: 0002:     
 327: 0002:     INTEGER*2 GLOBAL    HOME.KEY%
 328: 0002:     INTEGER*2 GLOBAL    END.KEY%
 329: 0002:     INTEGER*2 GLOBAL    PGUP.KEY%
 330: 0002:     INTEGER*2 GLOBAL    PGDN.KEY%
 331: 0002:     INTEGER*2 GLOBAL    TAB.KEY%
 332: 0002:     INTEGER*2 GLOBAL    BTAB.KEY%
 333: 0002:     INTEGER*2 GLOBAL    UP.KEY%
 334: 0002:     INTEGER*2 GLOBAL    DOWN.KEY%
 335: 0002:     INTEGER*2 GLOBAL    ESC.KEY%
 336: 0002:     INTEGER*2 GLOBAL    ENTER.KEY%
 337: 0002:     INTEGER*2 GLOBAL    INS.KEY%
 338: 0002:     INTEGER*2 GLOBAL    PREV.KEY%
 339: 0002:     INTEGER*2 GLOBAL    NEXT.KEY%
 340: 0002:         
 341: 0002:     INTEGER*2 GLOBAL    F1.KEY%
 342: 0002:     INTEGER*2 GLOBAL    F2.KEY%
 343: 0002:     INTEGER*2 GLOBAL    F3.KEY%
 344: 0002:     INTEGER*2 GLOBAL    F4.KEY%
 345: 0002:     INTEGER*2 GLOBAL    F5.KEY%
 346: 0002:     INTEGER*2 GLOBAL    F6.KEY%
 347: 0002:     INTEGER*2 GLOBAL    F7.KEY%
 348: 0002:     INTEGER*2 GLOBAL    F8.KEY%
 349: 0002:     INTEGER*2 GLOBAL    F9.KEY%
 350: 0002:     INTEGER*2 GLOBAL    F10.KEY%
 351: 0002:                 
 352: 0002: !******************************************************************************
 353: 0002: 
 354: 0002:     %INCLUDE PSBUSEG.J86    !   Chain Function
 355: 0002: \/*********************************************************************/ PSBUSEG
 356: 0002: \/*                                                                   */ PSBUSEG
 357: 0002: \/* PSBUSEG.J86  -  Definitions for Chain/Use with PSB Screen Program */ PSBUSEG
 358: 0002: \/* ----------------------------------------------------------------- */ PSBUSEG
 359: 0002: \/*                                                                   */ PSBUSEG
 360: 0002: \/*********************************************************************/ PSBUSEG
 361: 0002:                                                                        ! PSBUSEG
 362: 0002:         STRING GLOBAL  PSBCHN.PRG,      \ Program to chain to          ! PSBUSEG
 363: 0002:                        PSBCHN.OP,       \ Operator Id                  ! PSBUSEG
 364: 0002:                        PSBCHN.APP,      \ Program chained from         ! PSBUSEG
 365: 0002:                        PSBCHN.MENCON,   \ Menu Control                 ! PSBUSEG
 366: 0002:                        PSBCHN.U1,       \ User parameter               ! PSBUSEG
 367: 0002:                        PSBCHN.U2,       \ User parameter               ! PSBUSEG
 368: 0002:                        PSBCHN.U3        ! User parameter               ! PSBUSEG
 369: 0002:                                                                        ! PSBUSEG
 370: 0002: 
 371: 0002: \******************************************************************************
 372: 0002: \******************************************************************************
 373: 0002: \***
 374: 0002: \***    Global Variable definitions
 375: 0002: \***
 376: 0002: \******************************************************************************
 377: 0002: \******************************************************************************
 378: 0002: 
 379: 0002:     STRING GLOBAL                                                       \
 380: 0002:         BATCH.SCREEN.FLAG$,                                             \ Screen flags
 381: 0002:         CHAIN.TO.PROG$,                                                 \ Chain to programs
 382: 0002:         CURRENT.CODE$,                                                  \ Current code
 383: 0002:         CURRENT.CODE.LOGGED$,                                           \
 384: 0002:         FILE.NO$,                                                       \
 385: 0002:         FILE.OPERATION$,                                                \ File operations indicator
 386: 0002:         FUNCTION.FLAG$,                                                 \
 387: 0002:         MODULE$,                                                        \
 388: 0002:         MODULE.NUMBER$,                                                 \ Module number
 389: 0002:         PASSED.STRING$,                                                 \
 390: 0002:         PROGRAM$,                                                       \
 391: 0002:         VAR.STRING.1$,                                                  \
 392: 0002:         VAR.STRING.2$                                                   !
 393: 0002: 
 394: 0002:      INTEGER*1 GLOBAL                                                   \
 395: 0002:          COMMAND.MODE,                                                  \
 396: 0002:          ERROR.COUNT%,                                                  \
 397: 0002:          FALSE,                                                         \
 398: 0002:          TRUE                                                           !
 399: 0002: 
 400: 0002:      INTEGER*2 GLOBAL                                                   \
 401: 0002:          CURRENT.REPORT.NUM%,                                           \
 402: 0002:          EVENT.NO%,                                                     \
 403: 0002:          MESSAGE.NO%,                                                   \
 404: 0002:          PASSED.INTEGER%                                                !
 405: 0002: 
 406: 0002:     INTEGER*4 GLOBAL                                                    \
 407: 0002:          RET.KEY%                                                       \
 408: 0002: 
 409: 0002: \******************************************************************************
 410: 0002: \******************************************************************************
 411: 0002: \***
 412: 0002: \***   VARIABLE DECLARATIONS
 413: 0002: \***
 414: 0002: \******************************************************************************
 415: 0002: \******************************************************************************
 416: 0002: 
 417: 0002:     STRING                                                              \
 418: 0002:         BCF.OPEN.FLAG$,                                                 \
 419: 0002:         OPERATOR.NUMBER$                                                !
 420: 0002: 
 421: 0002: 
 422: 0002:     INTEGER*1                                                           \
 423: 0002:         EXIT.NOW,                                                       \
 424: 0002:         INITIALIZED,                                                    \
 425: 0002:         PSD97.FIELD%,                                                   \
 426: 0002:         RESET                                                           !
 427: 0002: 
 428: 0002:     INTEGER*4                                                           \
 429: 0002:         RC%                                                             !
 430: 0002: 
 431: 0002: \******************************************************************************
 432: 0002: \******************************************************************************
 433: 0002: \***
 434: 0002: \***    FUNCTION DECLARATIONS
 435: 0002: \***
 436: 0002: \******************************************************************************
 437: 0002: \******************************************************************************
 438: 0002: 
 439: 0002:     %INCLUDE BASROUT.J86   ! OSShell function
 440: 0002: \*LIB   BVEJ BASROUT  J86      03/11/97 08:16:26 PIDBLD3  *    FIX
 441: 0002: \*PROM  BVEJ BASROUT  J86      03/10/97 17:18:40 PIDBLD3  MVEJ IR34352
 442: 0002: \*RTIME BVEJ BASROUT  J86      03/10/97 17:18:41 PIDBLD3  MVEJ IR34352
 443: 0002: \*LIB   MVEJ BASROUT  J86      03/05/97 10:48:46 EDJRAL   *    IR34352
 444: 0002: \*LIB   MVEJ BASROUT  J86      02/17/97 11:19:56 EDJRAL   *    REASONAR
 445: 0002: \*LIB   MVEJ BASROUT  J86      02/14/97 15:59:11 EDJRAL   *    REASONAR
 446: 0002: ! BASROUT.J86 - this file is to be included in any BASIC code which utilizes
 447: 0002: !   the BASROUT.OBJ routines.  These routines were written
 448: 0002: !  using Metaware C and are intended to provide functions which
 449: 0002: !         are either not available in 4680 CBASIC or which can be more
 450: 0002: !               efficiently handled by the C language.  Their usage is
 451: 0002: !  offered on an "AT YOUR OWN RISK" basis.
 452: 0002: !
 453: 0002: !               The insert/extract routines usefulness may not be immediately
 454: 0002: !               apparent.  Their intention is that they be used in conjunction
 455: 0002: !               with a read/write form command.  They can more efficiently
 456: 0002: !               parse a string into many different variables than can the
 457: 0002: !               read form statement.  So instead of a long list of data var's
 458: 0002: !               it may be more efficient to just read/write one long string
 459: 0002: !               and then use the insert/extract routines to parse out the
 460: 0002: !   data.
 461: 0002: 
 462: 0002: ! ******************* SUB PROCESS FUNCTIONS *********************************
 463: 0002: 
 464: 0002: function osshell(cmd.line$) external   ! routine to start
 465: 0002:        ! another program.
 466: 0002:            integer*4    osshell    ! Upon completion of
 467: 0002:            string       cmd.line$   ! program, control is
 468: 0002:        ! returned to calling
 469: 0002: end function      ! program.
 470: 0002: !
 471: 0002: ! NOTES:  Program must be a 286 type file.  This does not exclude
 472: 0002: !         the capability to execute a batch file however.  Simply pass the
 473: 0002: !         following:
 474: 0002: !              c:\adx_spgm\command.286 batfile
 475: 0002: !         where batfile is the name of the batch file to be executed.
 476: 0002: !
 477: 0002: ! IMPORTANT: When using osshell to execute a batch file as described above,
 478: 0002: !            the final command in the batch file must be "exit".  If not,
 479: 0002: !       control is never given back to the calling program.
 480: 0002: 
 481: 0002: ! ************************ MEMORY RELATED FUNCTIONS ************************
 482: 0002: 
 483: 0002: function memfree(choice) external   ! routine to que the
 484: 0002:        ! status of the
 485: 0002:  integer*4 memfree    ! machine's memory:
 486: 0002:  integer*2 choice    ! Options:
 487: 0002:        !    1 - free
 488: 0002: end function      !    2 - total
 489: 0002:        !    3 - system
 490: 0002: 
 491: 0002: ! ********************** TIMEDATE RELATED FUNCTIONS ************************
 492: 0002: 
 493: 0002: function timedate(choice) external   ! routine to que the
 494: 0002:        ! OS's timedate table
 495: 0002:  integer*4 timedate   ! Choices:
 496: 0002:  integer*2 choice    !    1 - millisec's
 497: 0002:        !        since midnight
 498: 0002: end function      !    2 - minutes from
 499: 0002:        !  UCT (timezone)
 500: 0002:        !    3 - day of week
 501: 0002:        !   0-Sunday
 502: 0002:        !  6-Saturday
 503: 0002: 
 504: 0002: function settime(msecs) external   ! routine to set the
 505: 0002:        ! time on the controller
 506: 0002:  integer*4  settime    ! msecs is the desired
 507: 0002:  integer*4 msecs    ! number of milliseconds
 508: 0002:        ! since midnight
 509: 0002: end function      ! Returns negative on
 510: 0002:        ! error
 511: 0002: ! NOTE:  This routine sets the time only on the controller.  The terminals'
 512: 0002: ! time will not be updated until 1 AM or unless a terminal is STC'd.
 513: 0002: ! At 1 AM the controller broadcasts the new time to all terminals.
 514: 0002: ! Insure this is taken into consideration when using this routine.
 515: 0002: 
 516: 0002: !******************** DISK FILE RELATED FUNCTIONS *************************
 517: 0002: 
 518: 0002: function truncate(name,length) external   ! routine to truncate
 519: 0002:        ! the specified file
 520: 0002:  integer*4 truncate   ! to a given length.
 521: 0002:  string  name
 522: 0002:  integer*4 length
 523: 0002: 
 524: 0002: end function
 525: 0002: 
 526: 0002: !******************** STRING VALUE RELATED FUNCTIONS **********************
 527: 0002: 
 528: 0002: function isalpha(bstrn) external   ! routine to identify
 529: 0002:        ! if the specified
 530: 0002:  integer*1 isalpha    ! string contains all
 531: 0002:  string  bstrn    ! alphabetic char's
 532: 0002:        ! Returns:
 533: 0002: end function      !     0 - all alpha
 534: 0002:        !     X - byte of 1st
 535: 0002:        !         non-alpha
 536: 0002:        !   char
 537: 0002: 
 538: 0002: function isdigit(bstrn) external   ! routine to identify
 539: 0002:        ! if the specified
 540: 0002:  integer*1 isdigit    ! string contains all
 541: 0002:  string  bstrn    ! numeric char's
 542: 0002:        ! Returns:
 543: 0002: end function      !     0 - all numeric
 544: 0002:        !     X - byte of 1st
 545: 0002:        !         non-numeric
 546: 0002:        !   char
 547: 0002: 
 548: 0002: function islower(bstrn) external   ! routine to identify
 549: 0002:        ! if the specified
 550: 0002:  integer*1 islower    ! string contains all
 551: 0002:  string  bstrn    ! lower case char's
 552: 0002:        ! Returns:
 553: 0002: end function      !     0 - all lowercase
 554: 0002:        !     X - byte of 1st
 555: 0002:        !         non-lowercase
 556: 0002:        !   char
 557: 0002: 
 558: 0002: function isupper(bstrn) external   ! routine to identify
 559: 0002:        ! if the specified
 560: 0002:  integer*1 isupper    ! string contains all
 561: 0002:  string  bstrn    ! upper case char's
 562: 0002:        ! Returns:
 563: 0002: end function      !     0 - all uppercase
 564: 0002:        !     X - byte of 1st
 565: 0002:        !         non-uppercase
 566: 0002:        !   char
 567: 0002: 
 568: 0002: function toalpha(bstrn) external   ! routine to convert
 569: 0002:        ! non-alpha or non-num
 570: 0002:    integer*2 toalpha    ! char's to spaces
 571: 0002:  string  bstrn    ! Returns:
 572: 0002: end function      !   x - no. of char's
 573: 0002:        !       changed
 574: 0002: 
 575: 0002: ! ********************* USER/GROUP ZERO LEVEL FUNCTIONS *********************
 576: 0002: 
 577: 0002: function idlecount(choice) external   ! routine to either
 578: 0002:        ! set to zero or queue
 579: 0002:  integer*4 idlecount   ! the value of the
 580: 0002:  integer*1 choice    ! processor's idlecount
 581: 0002:        ! Choice:
 582: 0002: end function      !     0 - set to zero
 583: 0002: !       !     1 - get value
 584: 0002: ! NEEDS USER/GROUP 0 LEVEL OF AUTHORIZATION  ! Returns:
 585: 0002: ! TO WORK - This level is not available unless  !     X - idlecount
 586: 0002: ! the file ADXCSOUF.DAT file is "patched".  This !    -X - error code
 587: 0002: ! is highly unrecommended.
 588: 0002: 
 589: 0002: function logical(actname,logname,choice) external ! routine to set a
 590: 0002:        ! a logical name.
 591: 0002:  integer*4 logical    ! parms are self
 592: 0002:         string  logname    ! explanatory except
 593: 0002:  string  actname    ! for choice:
 594: 0002:  integer*1 choice    !   0 - set process
 595: 0002:        !   1 - set system
 596: 0002: end function      !   2 - get process
 597: 0002:        !   3 - get system
 598: 0002: 
 599: 0002: ! NOTE:  Only the setting of a system level of logical name requires
 600: 0002: ! user/group zero level of authorization.  Any application may query any
 601: 0002: ! logical name.  Setting of a system logical name is only applicable until
 602: 0002: ! the system is IPL'd.  A process logical name is only active when that
 603: 0002: ! process is active.
 604: 0002: 
 605: 0002: !******************** STRING PARSING FUNCTIONS *****************************
 606: 0002: 
 607: 0002: function inserts(whole,part,offset) external  ! routine to insert a
 608: 0002:        ! string (part) into
 609: 0002:  integer*2 INSERTS    ! another string (whole)
 610: 0002:  string  whole    ! starting at specified
 611: 0002:  string  part    ! character (offset)
 612: 0002:  integer*2 offset
 613: 0002: 
 614: 0002: end function
 615: 0002: 
 616: 0002: function cinsert4(integer4,bstring,offset) external   ! routine to insert
 617: 0002:        ! a 4-byte integer into
 618: 0002:  integer*1 cinsert4   ! a string starting at
 619: 0002:  integer*4 integer4   ! byte specified by
 620: 0002:  string  bstring    ! offset (1-based)
 621: 0002:  integer*2 offset    ! Returns:
 622: 0002:        !     0 - Success
 623: 0002: end function      !    -1 - String overrun
 624: 0002: 
 625: 0002: function cinsert2(integer2,bstring,offset) external  ! routine to insert
 626: 0002:        ! a 2-byte integer into
 627: 0002:  integer*1 cinsert2   ! a string starting at
 628: 0002:  integer*2 integer2   ! byte specified by
 629: 0002:  string  bstring    ! offset (1-based)
 630: 0002:  integer*2 offset    ! Returns:
 631: 0002:        !     0 - Success
 632: 0002: end function      !    -1 - String overrun
 633: 0002: 
 634: 0002: function cinsert1(bstring,integer1,offset) external  ! routine to insert
 635: 0002:        ! a 1-byte integer into
 636: 0002:  integer*1 cinsert1   ! a string starting at
 637: 0002:  integer*1 integer1   ! byte specified by
 638: 0002:  string  bstring    ! offset (1-based)
 639: 0002:  integer*2 offset    ! Returns:
 640: 0002:        !     0 - Success
 641: 0002: end function      !    -1 - String overrun
 642: 0002: 
 643: 0002: function extracts(whole,part,offset) external  ! routine to extract a
 644: 0002:        ! string (part) from
 645: 0002:  integer*2 EXTRACTS   ! another string (whole)
 646: 0002:  string  whole    ! starting at specified
 647: 0002:  string  part    ! character (offset)
 648: 0002:  integer*2 offset
 649: 0002: 
 650: 0002: end function
 651: 0002: 
 652: 0002: function cextract4(bstring,offset) external  ! routine to extract
 653: 0002:        ! a 4-byte integer from
 654: 0002:  integer*4 cextract4   ! a string starting at
 655: 0002:                        ! byte specified by
 656: 0002:  string  bstring    ! offset (1-based)
 657: 0002:  integer*2 offset    ! Returns:
 658: 0002:        !     X - 4 byte integer
 659: 0002: end function      !    -1 - String overrun
 660: 0002: 
 661: 0002: function cextract2(bstring,offset) external  ! routine to extract
 662: 0002:        ! a 2-byte integer from
 663: 0002:  integer*2 cextract2   ! a string starting at
 664: 0002:                        ! byte specified by
 665: 0002:  string  bstring    ! offset (1-based)
 666: 0002:  integer*2 offset    ! Returns:
 667: 0002:        !     X - 2 byte integer
 668: 0002: end function      !    -1 - String overrun
 669: 0002: 
 670: 0002: function cextract1(bstring,offset) external  ! routine to extract
 671: 0002:        ! a 1-byte integer from
 672: 0002:  integer*1 cextract1   ! a string starting at
 673: 0002:                        ! byte specified by
 674: 0002:  string  bstring    ! offset (1-based)
 675: 0002:  integer*2 offset    ! Returns:
 676: 0002:        !     X - 1 byte integer
 677: 0002: end function      !    -1 - String overrun
 678: 0002: 
 679: 0002: 
 680: 0002: function srchdir (file.name$,dtbl.buffer$) external ! routine to return
 681: 0002:        ! file names and sizes
 682: 0002:        ! Return values:
 683: 0002:        !    -1  no matches
 684: 0002:        !        found on first
 685: 0002:        !        call
 686: 0002:        !    0   no matches
 687: 0002:        !        found on sub-
 688: 0002:        !        sequent calls
 689: 0002:        !    Pos Success
 690: 0002:        !    Neg OS Rtn Code
 691: 0002: ! Usage Note:  If searching for all occurences of a particular file name,
 692: 0002: ! first initialize dtbl.buffer$ to 48 Nulls (pack$("00")) and issue a call
 693: 0002: ! to srchdir.  If any matches are found, a positive value will be returned.
 694: 0002: ! To see if any more matches exist, just issue another call to srchdir without
 695: 0002: ! resetting the values of dtbl.buffer$.  If any are found, a positive value
 696: 0002: ! will be returned.  This can be repeated until a Zero is returned.  All data
 697: 0002: ! describing file will be returned in the dtbl.buffer$ after each call.  Format
 698: 0002: ! of this data is defined below.
 699: 0002: 
 700: 0002:  integer*4 srchdir
 701: 0002: 
 702: 0002:  string  file.name$   ! file name to start
 703: 0002:        ! search (18 bytes max)
 704: 0002:        ! Wild cards and logical
 705: 0002:        ! names supported.
 706: 0002: 
 707: 0002:  string  dtbl.buffer$   ! must be initialized
 708: 0002:        ! to 48 bytes.  Contains
 709: 0002:        ! all of directory info
 710: 0002:        ! Initialize to nulls
 711: 0002:        ! each time a new file
 712: 0002:        ! name is used.
 713: 0002: 
 714: 0002: ! NOTE:  Format of dtbl.buffer$ string is as follows:
 715: 0002: !
 716: 0002: ! Offs  Type                    Description Notes
 717: 0002: !  0 integer*4  key  use extract4 to access
 718: 0002: !  4  string (18 bytes) file name
 719: 0002: ! 22 integer*2  attributes use extract2 to access
 720: 0002: !      0x01 - Read Only
 721: 0002: !      0x02 - Hidden
 722: 0002: !      0x04 - System
 723: 0002: !      0x08 - Volume Label
 724: 0002: !      0x10 - Subdirectory
 725: 0002: !      0x20 - Archive (Files)
 726: 0002: !      0x40 - Security enabled
 727: 0002: !      0x80 - Reserved
 728: 0002: !      0x0000 - Local
 729: 0002: !      0x4000 - Mirrored/Update
 730: 0002: !      0xC000 - Mirrored/Close
 731: 0002: !
 732: 0002: !      0x6000 - Compound/Update
 733: 0002: !      0xE000 - Compound/Close
 734: 0002: ! 24 integer*2  record size use extract2 to access
 735: 0002: ! 26 integer*1  User ID of Owner
 736: 0002: ! 27 integer*1  Group ID of Owner
 737: 0002: ! 28 integer*2  File Security
 738: 0002: ! 30 string (6 bytes) Reserved
 739: 0002: ! 36 integer*4  File Size use extract4 to access
 740: 0002: ! 40 integer*2  Year  use extract2 to access
 741: 0002: ! 42 integer*1  Month
 742: 0002: ! 43 integer*1  Day
 743: 0002: ! 44 integer*1  Hour
 744: 0002: ! 45 integer*1  Minute
 745: 0002: ! 46 integer*1  Second
 746: 0002: ! 47 integer*1  Reserved
 747: 0002: 
 748: 0002: end function
 749: 0002: 
 750: 0002: function srchproc (proc.name$,ptbl.buffer$) external ! routine to return
 751: 0002:        ! process names and
 752: 0002:        ! status.  Handy to
 753: 0002:        ! determine if a
 754: 0002:        ! program is currently
 755: 0002:        ! running.
 756: 0002:        ! Return values:
 757: 0002:        !    -1  no matches
 758: 0002:        !        found on first
 759: 0002:        !        call
 760: 0002:        !    0   no matches
 761: 0002:        !        found on sub-
 762: 0002:        !        sequent calls
 763: 0002:        !    Pos Success
 764: 0002:        !    Neg Failure
 765: 0002:        !        OS Rtn Code
 766: 0002:        ! 80000001h - Insuff
 767: 0002:         !        ptbl buffer
 768: 0002:        !        Length
 769: 0002: ! Usage Note:  If searching for all occurences of a particular process name,
 770: 0002: ! first initialize ptbl.buffer$ to 60 Nulls (pack$("00")) and issue a call
 771: 0002: ! to srchproc.  If any matches are found, a positive value will be returned.
 772: 0002: ! To see if any more matches exist, just issue another call to srchproc without
 773: 0002: ! resetting the values of ptbl.buffer$.  If any are found, a positive value
 774: 0002: ! will be returned.  This can be repeated until a Zero is returned.  All data
 775: 0002: ! describing file will be returned in the ptbl.buffer$ after each call.  Format
 776: 0002: ! of this data is defined as follows:
 777: 0002: !
 778: 0002: !       --------------------------------------------------------
 779: 0002: !   0   |                         PID                          |
 780: 0002: !       --------------------------------------------------------
 781: 0002: !   4   |           FID             |   CID        |   VCID    |
 782: 0002: !       --------------------------------------------------------
 783: 0002: !   8   |                         NAME                         |
 784: 0002: !       --------------------------------------------------------
 785: 0002: !  12   |                         NAME cont'd                  |
 786: 0002: !       --------------------------------------------------------
 787: 0002: !  16   |       NAME cont'd         |   STATE      |  PRIOR    |
 788: 0002: !       --------------------------------------------------------
 789: 0002: !  20   |                         MAXMEM                       |
 790: 0002: !       --------------------------------------------------------
 791: 0002: !  24   |       FLAGS               |   USER        |  GROUP   |
 792: 0002: !       --------------------------------------------------------
 793: 0002: !  28   |                         PARENT                       |
 794: 0002: !       --------------------------------------------------------
 795: 0002: !  32   |                         EVENTS                       |
 796: 0002: !       --------------------------------------------------------
 797: 0002: !  36   |                         CODE                         |
 798: 0002: !       --------------------------------------------------------
 799: 0002: !  40   |                         CSIZE                        |
 800: 0002: !       --------------------------------------------------------
 801: 0002: !  44   |                         DATA                         |
 802: 0002: !       --------------------------------------------------------
 803: 0002: !  48   |                         DSIZE                        |
 804: 0002: !       --------------------------------------------------------
 805: 0002: !  52   |                         HEAP                         |
 806: 0002: !       --------------------------------------------------------
 807: 0002: !  56   |                         HSIZE                        |
 808: 0002: !       --------------------------------------------------------
 809: 0002: !
 810: 0002: !       PID   Process ID
 811: 0002: !       FID  Process's Family ID
 812: 0002: !       CID   Physical Console Device Number
 813: 0002: !       VCID  Process's Virtual Console Number
 814: 0002: !       NAME  Process Name (Application Running)
 815: 0002: ! STATE    Process State (0-Run, 1-Waiting, 2-Terminating)
 816: 0002: ! PRIOR    Priority
 817: 0002: !       MAXMEM  Maximum Memory Allowed
 818: 0002: !       FLAGS  Bit 0 (1-System Process, 0-User Process)
 819: 0002: !   Bit 1 (1-Locked in Memory, 0-Swappable)
 820: 0002: !   Bit 2 (1-Running in SWI context, 0-Running in main context)
 821: 0002: !   Bit 3 (1-Superuser Process,0-Not a Superuser Process)
 822: 0002: ! USER  User Number
 823: 0002: ! GROUP  Group Number
 824: 0002: !       PARENT   Parent Process ID
 825: 0002: !       EVENTS   Bit Map of events that have completed but not retrieved
 826: 0002: !       CODE  Start of code area in user space
 827: 0002: ! CSIZE  Size in bytes of code area
 828: 0002: !       DATA  Start of data area in user space
 829: 0002: ! DSIZE  Size in bytes of data area
 830: 0002: !       HEAP  Start of heap area in user space
 831: 0002: ! HSIZE  Size in bytes of heap area
 832: 0002: !
 833: 0002:  integer*4 srchproc
 834: 0002: 
 835: 0002:  string  proc.name$   ! process name to start
 836: 0002:        ! search (10 bytes max)
 837: 0002:        ! Wild cards and logical
 838: 0002:        ! names supported.
 839: 0002: 
 840: 0002:  string  ptbl.buffer$   ! must be initialized
 841: 0002:        ! to 60 bytes.  Contains
 842: 0002:        ! all of process info
 843: 0002:        ! Initialize to nulls
 844: 0002:        ! each time a new
 845: 0002:        ! process name is used.
 846: 0002: 
 847: 0002: end function
 848: 0002: 
 849: 0002: function cconstat(timeout) external       ! function similar
 850: 0002:                                               ! to BASIC constat%
 851: 0002:  integer*2 cconstat   ! waits for either a
 852: 0002:  integer*4 timeout    ! key being hit or
 853: 0002:        ! the timer expiring
 854: 0002:        ! before returning
 855: 0002:        ! returns:
 856: 0002:        !   -1 error
 857: 0002:        !    0 timer expired
 858: 0002:        !    x scan code of
 859: 0002:        !      key hit
 860: 0002: end function
 861: 0002: 
 862: 0002: function disksize(disk.name$) external   ! function to find
 863: 0002:        ! the total size of
 864: 0002:  integer*4 disksize   ! the specified disk
 865: 0002:  string  disk.name$   ! name (e.g. "h0:")
 866: 0002:        ! if return value is
 867: 0002:        ! negative, error
 868: 0002: end function      ! was received
 869: 0002: 
 870: 0002: 
 871: 0002:     %INCLUDE BCFEXT.J86    ! BCF File function
 872: 0002: \*****************************************************************************
 873: 0002: \*****************************************************************************
 874: 0002: \***
 875: 0002: \***         FUNCTION DEFINITIONS FOR BOOTS CONTROL FILE
 876: 0002: \***
 877: 0002: \***                    REFERENCE : BCFEXTA.J86
 878: 0002: \***
 879: 0002: \***    Version A           Steve Windsor          5th Jan 1993
 880: 0002: \***
 881: 0002: \***    Version B           Michael J. Kelsall    14th Sep 1993
 882: 0002: \***    Code incremented to maintain consistency with other included code
 883: 0002: \***    for RETURNS/AUTOMATIC CREDIT CLAIMING system.
 884: 0002: \***
 885: 0002: \***    Version C           Stuart William McConnachie 23rd Jan 1995
 886: 0002: \***    Addition of TXR serial number as part of the TRANSACTION RETRIEVAL
 887: 0002: \***    project.
 888: 0002: \***
 889: 0002: \***    Version D           Stuart William McConnachie  7th June 1995
 890: 0002: \***    Converted calls to enable more than 1 record on the BCF.
 891: 0002: \***    The second record is to be used for the No7 customer card trial.
 892: 0002: \***
 893: 0002: \***    Revision 4.6            ROBERT COWEY.            19 MAY 2003.
 894: 0002: \***    Modifications for All Txn Data To CDAS project.
 895: 0002: \***    No changes to this file.
 896: 0002: \***
 897: 0002: \***    Revision 4.7            Julia Stones              9th July 2003
 898: 0002: \***    Modifications for New Lines Report project.
 899: 0002: \***    No changes to this file.
 900: 0002: \***
 901: 0002: \*****************************************************************************
 902: 0002: \*****************************************************************************
 903: 0002: 
 904: 0002:    FUNCTION BCF.SET EXTERNAL
 905: 0002:    END FUNCTION
 906: 0002: 
 907: 0002:   FUNCTION READ.BCF EXTERNAL
 908: 0002:    INTEGER*2 READ.BCF
 909: 0002:   END FUNCTION
 910: 0002: 
 911: 0002:   FUNCTION READ.BCF.LOCK EXTERNAL
 912: 0002:    INTEGER*2 READ.BCF.LOCK
 913: 0002:   END FUNCTION
 914: 0002: 
 915: 0002:   FUNCTION WRITE.BCF EXTERNAL
 916: 0002:    INTEGER*2 WRITE.BCF
 917: 0002:   END FUNCTION
 918: 0002: 
 919: 0002:   FUNCTION WRITE.BCF.UNLOCK EXTERNAL
 920: 0002:    INTEGER*2 WRITE.BCF.UNLOCK
 921: 0002:   END FUNCTION
 922: 0002: 
 923: 0002:   FUNCTION WRITE.HOLD.BCF.UNLOCK EXTERNAL
 924: 0002:    INTEGER*2 WRITE.HOLD.BCF.UNLOCK
 925: 0002:   END FUNCTION
 926: 0002: 
 927: 0002: 
 928: 0002: \******************************************************************************
 929: 0002: \******************************************************************************
 930: 0002: \***
 931: 0002: \***    Included code defining external Boots functions
 932: 0002: \***
 933: 0002: \******************************************************************************
 934: 0002: \******************************************************************************
 935: 0002: 
 936: 0002:     %INCLUDE PSBF01E.J86   ! APPLICATION.LOG
 937: 0002: REM \
 938: 0002: \*******************************************************************************
 939: 0002: \*******************************************************************************
 940: 0002: \***
 941: 0002: \***      %INCLUDE FOR EXTERNAL DEFINITION OF FUNCTION APPLICATION.LOG
 942: 0002: \***
 943: 0002: \***                      FUNCTION NUMBER   : PSBF01
 944: 0002: \***
 945: 0002: \***                    INCLUDE REFERENCE : PSBF01E.J86
 946: 0002: \*** 
 947: 0002: \***      Version B           Andrew Wedgeworth          1st July 1992
 948: 0002: \***      Three parameters which passed to the function have been removed.
 949: 0002: \***      APPLICATION.LOG has been added as a variable name (this holds the
 950: 0002: \***      return code).
 951: 0002: \***
 952: 0002: \*******************************************************************************
 953: 0002: 
 954: 0002: 
 955: 0002:    FUNCTION APPLICATION.LOG (MESSAGE.NO%,                                     \
 956: 0002:                              VAR.STRING.1$,                                   \
 957: 0002:                              VAR.STRING.2$,                                   \
 958: 0002:                              EVENT.NO%)  EXTERNAL
 959: 0002: 
 960: 0002:       INTEGER*1 EVENT.NO%
 961: 0002: 
 962: 0002:       INTEGER*2 APPLICATION.LOG,                                       \ GAW
 963: 0002:                 MESSAGE.NO%
 964: 0002: 
 965: 0002:       STRING VAR.STRING.1$,                                            \
 966: 0002:              VAR.STRING.2$
 967: 0002: 
 968: 0002:    END FUNCTION
 969: 0002: 
 970: 0002: \*******************************************************************************
 971: 0002:     %INCLUDE PSBF20E.J86   ! ALLOCATE.DEALLOCATE.SESS.NUM
 972: 0002: REM\
 973: 0002: \*******************************************************************************
 974: 0002: \*******************************************************************************
 975: 0002: \***
 976: 0002: \***       %INCLUDE FOR EXTERNAL DEFINITION OF SESS.NUM.UTILITY
 977: 0002: \***
 978: 0002: \***                  REFERENCE     : PSBF20E.J86
 979: 0002: \***
 980: 0002: \***     VERSION C            Janet Smith                13th May 1992
 981: 0002: \***     Increased PASSED.INTEGER to 2 bytes to cater for more than
 982: 0002: \***     128 files.
 983: 0002: \***
 984: 0002: \***     VERSION D.           Andrew Wedgeworth          1st July 1992
 985: 0002: \***     Removal of redundant parameters and addition of SESS.NUM.UTILITY
 986: 0002: \***     as a variable.  This new variable contains the function's return
 987: 0002: \***     code.
 988: 0002: \***
 989: 0002: \*******************************************************************************
 990: 0002: \*******************************************************************************
 991: 0002: 
 992: 0002:    FUNCTION SESS.NUM.UTILITY (FUNCTION.FLAG$,                          \
 993: 0002:                               PASSED.INTEGER%,                         \
 994: 0002:                               PASSED.STRING$)                          \
 995: 0002:    EXTERNAL
 996: 0002: 
 997: 0002:    STRING    FUNCTION.FLAG$,                                           \
 998: 0002:              PASSED.STRING$
 999: 0002:    ! 3 variables removed from here                                     ! CAW
1000: 0002: 
1001: 0002: 
1002: 0002:    INTEGER*2 SESS.NUM.UTILITY,                                         \ CAW
1003: 0002:              PASSED.INTEGER%				               ! CJAS
1004: 0002: 
1005: 0002:    END FUNCTION
1006: 0002: 
1007: 0002:     %INCLUDE PSBF24E.J86   ! Error detected
1008: 0002: REM \
1009: 0002: \*******************************************************************************
1010: 0002: \*******************************************************************************
1011: 0002: \***
1012: 0002: \***    %INCLUDE FOR EXTERNAL DEFINITION OF STANDARD.ERROR.DETECTED FUNCTION
1013: 0002: \***
1014: 0002: \***                      REFERENCE     : PSBF24E.J86
1015: 0002: \***
1016: 0002: \***    Version A                 Janet Smith                  13th May 1992
1017: 0002: \***
1018: 0002: \*******************************************************************************
1019: 0002: \*******************************************************************************
1020: 0002: 
1021: 0002:    FUNCTION STANDARD.ERROR.DETECTED(ERRN%,                 \
1022: 0002: 				    ERRFILE%,              \
1023: 0002: 				    ERRL%,                 \
1024: 0002: 				    ERR$)        EXTERNAL
1025: 0002: 				    
1026: 0002:           STRING    ERR$
1027: 0002: 
1028: 0002:           INTEGER*2 ERRFILE%,              \
1029: 0002: 	            ERRL%,                 \
1030: 0002: 		    STANDARD.ERROR.DETECTED
1031: 0002: 		    
1032: 0002:           INTEGER*4 ERRN%
1033: 0002: 	  		    
1034: 0002:    END FUNCTION
1035: 0002: 
1036: 0002: 
1037: 0002:     %INCLUDE PSBF39E.J86   ! Display Manager
1038: 0002: !******************************************************************************
1039: 0002: !******************************************************************************
1040: 0002: !***
1041: 0002: !***            PROGRAM         :       PSBF39E.J86
1042: 0002: !***
1043: 0002: !***            DESCRIPTION     :       DISPLAY MANAGER INTERFACE
1044: 0002: !***
1045: 0002: !***            AUTHOR          :       Stuart William McConnachie
1046: 0002: !***            DATE WRITTEN    :       September 2000
1047: 0002: !***
1048: 0002: !***        Provides a much needed and easier to use interface to
1049: 0002: !***        IBM Display Manager.
1050: 0002: !***
1051: 0002: !***        Saves the user having to set up, highlight, tab between and
1052: 0002: !***        validate fields.  Also handles the help screens and conversion
1053: 0002: !***        of date fields to external/internal format.
1054: 0002: !***
1055: 0002: !******************************************************************************
1056: 0002: !******************************************************************************
1057: 0002: 
1058: 0002: !******************************************************************************
1059: 0002: !   Initialises the display manager functions.
1060: 0002: !   You should call this from your program initialisation for screen programs.
1061: 0002: !   Note that the name of the display manager file is determined from the
1062: 0002: !   global variable MODULE.NUMBER$.  For example PSB1200 uses PSBD12.dat
1063: 0002: !   where the PSB and 12 have been derived from MODULE.NUMBER$.
1064: 0002: 
1065: 0002:     FUNCTION DM.INIT EXTERNAL
1066: 0002:         INTEGER*1   DM.INIT
1067: 0002:     END FUNCTION
1068: 0002: 
1069: 0002: !******************************************************************************
1070: 0002: !   Quits the display manager program and frees resources.
1071: 0002: !   You should call this from your program termination.
1072: 0002: 
1073: 0002:     FUNCTION DM.QUIT EXTERNAL
1074: 0002:         INTEGER*1   DM.QUIT
1075: 0002:     END FUNCTION
1076: 0002: 
1077: 0002: !******************************************************************************
1078: 0002: !   Initialises a particular screen from the current display manager file
1079: 0002: !   for display.  You supply the screen number, optional title message and
1080: 0002: !   the first and last help screens associated with the display.
1081: 0002: !   Once you have SHOWN a screen, you can use the remaining functions in
1082: 0002: !   this library to set field values, and actually retrieve input from the
1083: 0002: !   screen.  Note that showing a screen just displays it on the screen,
1084: 0002: !   you need to call PROCESS.SCREEN to actually get any user input.
1085: 0002: 
1086: 0002:     FUNCTION DM.SHOW.SCREEN (SCREEN%, TITLE$, FIRST.HELP%, LAST.HELP%) EXTERNAL
1087: 0002:         INTEGER*1   DM.SHOW.SCREEN
1088: 0002:         INTEGER*2   SCREEN%
1089: 0002:         STRING      TITLE$
1090: 0002:         INTEGER*2   FIRST.HELP%
1091: 0002:         INTEGER*2   LAST.HELP%
1092: 0002:     END FUNCTION
1093: 0002: 
1094: 0002: !******************************************************************************
1095: 0002: !   Sets a function key message to visible.  Optionally sets the text on that
1096: 0002: !   key to the message string passed, if it is not null.
1097: 0002: !   Note you must have shown a screen first, and that the function key fields
1098: 0002: !   need to be defined in your display file with field IDs 241-250.
1099: 0002: 
1100: 0002:     FUNCTION DM.SHOW.FN.KEY (KEY.NUM%, MESSAGE$) EXTERNAL
1101: 0002:         INTEGER*1   DM.SHOW.FN.KEY
1102: 0002:         INTEGER*2   KEY.NUM%
1103: 0002:         STRING      MESSAGE$
1104: 0002:     END FUNCTION
1105: 0002: 
1106: 0002: !******************************************************************************
1107: 0002: !   Sets a function key message to invisible.
1108: 0002: !   Note you must have shown a screen first, and that the function key fields
1109: 0002: !   need to be defined in your display file with field IDs 241-250.
1110: 0002: 
1111: 0002:     FUNCTION DM.HIDE.FN.KEY (KEY.NUM%) EXTERNAL
1112: 0002:         INTEGER*1   DM.HIDE.FN.KEY
1113: 0002:         INTEGER*2   KEY.NUM%
1114: 0002:     END FUNCTION
1115: 0002: 
1116: 0002: !******************************************************************************
1117: 0002: !   LEGACY: Do not use in new programs, use DM.FN.VISIBLE instead which takes
1118: 0002: !   an infix notation expression, as opposed to reverse polish
1119: 0002: !   This definition has been commented out accordingly.  If you are
1120: 0002: !   recompiling an application, change to useing the new function.
1121: 0002: !
1122: 0002: !   FUNCTION DM.FN.KEY.VISIBLE (KEY.NUM%, EXPR$) EXTERNAL
1123: 0002: !       INTEGER*1   DM.FN.KEY.VISIBILITY
1124: 0002: !       INTEGER*2   KEY.NUM%
1125: 0002: !       STRING      EXPR$
1126: 0002: !   END FUNCTION
1127: 0002: 
1128: 0002: !******************************************************************************
1129: 0002: !   Sets a runtine expression to determine if a function key is visible.
1130: 0002: !   This is the new version of the above which takes an infix notation EXPR$.
1131: 0002: !   Note you must have shown a screen first, and that the function key fields
1132: 0002: !   need to be defined in your display file with field IDs 241-250.
1133: 0002: 
1134: 0002:     FUNCTION DM.FN.VISIBLE (KEY.NUM%, EXPR$) EXTERNAL
1135: 0002:         INTEGER*1   DM.FN.VISIBILITY
1136: 0002:         INTEGER*2   KEY.NUM%
1137: 0002:         STRING      EXPR$
1138: 0002:     END FUNCTION
1139: 0002: 
1140: 0002: !******************************************************************************
1141: 0002: !   Specifies that a given field contains a date.
1142: 0002: !   This means that the date will be displayed on screen in the system date
1143: 0002: !   format (e.g. DD/MM/YY or MM/DD/YY, but will be returned and set by your
1144: 0002: !   application in YYMMDD format.
1145: 0002: !   It does NOT mean that the field will be validated as a date, you must do
1146: 0002: !   that explicitly using the VALID$ string.
1147: 0002: 
1148: 0002:     FUNCTION DM.DATE.FIELD (FIELD%) EXTERNAL
1149: 0002:         INTEGER*1   DM.DATE.FIELD
1150: 0002:         INTEGER*2   FIELD%
1151: 0002:     END FUNCTION
1152: 0002: 
1153: 0002: !******************************************************************************
1154: 0002: !   Specifies that a given field will contain a time.
1155: 0002: !   This means that the time will be displayed on screen using the system time
1156: 0002: !   format.  e.g. HH:MM
1157: 0002: 
1158: 0002:     FUNCTION DM.TIME.FIELD (FIELD%) EXTERNAL                                !CSWM
1159: 0002:         INTEGER*1   DM.TIME.FIELD                                           !CSWM
1160: 0002:         INTEGER*2   FIELD%                                                  !CSWM
1161: 0002:     END FUNCTION                                                            !CSWM
1162: 0002: 
1163: 0002: !******************************************************************************
1164: 0002: !   Specifies that a given input field will be read only.
1165: 0002: !   This allows you to select an item from a list by highlighting it.
1166: 0002: 
1167: 0002:     FUNCTION DM.RO.FIELD (FIELD%) EXTERNAL                                  !ESWM
1168: 0002:         INTEGER*1   DM.RO.FIELD                                             !ESWM
1169: 0002:         INTEGER*2   FIELD%                                                  !ESWM
1170: 0002:     END FUNCTION                                                            !ESWM
1171: 0002: 
1172: 0002: !******************************************************************************
1173: 0002: !   Specifies that a given input field will be read write.
1174: 0002: !   Undoes the effect of DM.RO.FIELD.
1175: 0002: 
1176: 0002:     FUNCTION DM.RW.FIELD (FIELD%) EXTERNAL                                  !ESWM
1177: 0002:         INTEGER*1   DM.RW.FIELD                                             !ESWM
1178: 0002:         INTEGER*2   FIELD%                                                  !ESWM
1179: 0002:     END FUNCTION                                                            !ESWM
1180: 0002: 
1181: 0002: !******************************************************************************
1182: 0002: !   LEGACY: Do not use in new programs, use DM.STATUS instead which takes
1183: 0002: !   an infix notation expression, as opposed to reverse polish.
1184: 0002: !   This definition has been commented out accordingly.  If you are
1185: 0002: !   recompiling an application, change to useing the new function.
1186: 0002: !
1187: 0002: !   FUNCTION DM.DISPLAY.MESSAGE (MESSAGE$) EXTERNAL                         !DSWM
1188: 0002: !       INTEGER*1   DM.DISPLAY.MESSAGE                                      !DSWM
1189: 0002: !       STRING      MESSAGE$                                                !DSWM
1190: 0002: !   END FUNCTION                                                            !DSWM
1191: 0002: 
1192: 0002: !******************************************************************************
1193: 0002: !   Displays a message in the status line of the display.  Does not wait for
1194: 0002: !   input.  Use this function for display messages such as B251 Processing...
1195: 0002: !   You must have field 1 defined in your display manager file.
1196: 0002: !   This is the new version of the above which takes an infix notation MESSAGE$.
1197: 0002: 
1198: 0002:     FUNCTION DM.STATUS (MESSAGE$) EXTERNAL                                  !DSWM
1199: 0002:         INTEGER*1   DM.STATUS                                               !DSWM
1200: 0002:         STRING      MESSAGE$                                                !DSWM
1201: 0002:     END FUNCTION                                                            !DSWM
1202: 0002: 
1203: 0002: !******************************************************************************
1204: 0002: !   Waits for input in the invisible input field of the display.  Additionally
1205: 0002: !   displays a message prompting the user on the status line.
1206: 0002: !   You must have fields 1 and 240 defined in your display manager file.
1207: 0002: !   The message supplied should be in Reverse Polish form.
1208: 0002: !   The function returns the key value that ended the input.
1209: 0002: 
1210: 0002:     FUNCTION DM.INVISIBLE.INPUT (MESSAGE$) EXTERNAL
1211: 0002:         STRING      MESSAGE$
1212: 0002:         INTEGER*2   DM.INVISIBLE.INPUT
1213: 0002:     END FUNCTION
1214: 0002: 
1215: 0002: !******************************************************************************
1216: 0002: !   Gets the contents of the invisible field from the display.  This will
1217: 0002: !   allow you to get the Y or N answer that the user typed, for example.
1218: 0002: 
1219: 0002:     FUNCTION DM.INVISIBLE.FIELD EXTERNAL
1220: 0002:         STRING      DM.INVISIBLE.FIELD
1221: 0002:     END FUNCTION
1222: 0002: 
1223: 0002: !******************************************************************************
1224: 0002: !   Returns or sets the current field used for input on the current display.
1225: 0002: !   If NEW.FIELD% is zero, the function simply returns the current field.
1226: 0002: !   If NEW.FIELD% is non zero, the function sets the current field.
1227: 0002: 
1228: 0002:     FUNCTION DM.CURRENT.FIELD (NEW.FIELD%) EXTERNAL
1229: 0002:         INTEGER*2   DM.CURRENT.FIELD
1230: 0002:         INTEGER*2   NEW.FIELD%
1231: 0002:     END FUNCTION
1232: 0002: 
1233: 0002: !******************************************************************************
1234: 0002: !   Sets a key number as being a validation key.  When this key is used the
1235: 0002: !   function will handle the key in the same way as the ENTER key.  i.e. all
1236: 0002: !   the visible fields on in input form are check for validity, and the key
1237: 0002: !   press is only returned to the user if the form entries are valid.
1238: 0002: !   Use this function to add the PGUP.KEY% and PGDN.KEY% keys, for example.
1239: 0002: 
1240: 0002:     FUNCTION DM.VALIDATE.KEY (KEY%) EXTERNAL                                !BSWM
1241: 0002:         INTEGER*1   DM.VALIDATE.KEY                                         !BSWM
1242: 0002:         INTEGER*2   KEY%                                                    !BSWM
1243: 0002:     END FUNCTION                                                            !BSWM
1244: 0002: 
1245: 0002: !******************************************************************************
1246: 0002: !   Returns or sets the flag which says if the screen contents have been
1247: 0002: !   changed or not.  Use this function when you have multiple pages to a
1248: 0002: !   form, but want the user to be prompted to save any changes on exit.
1249: 0002: !   When called with FLAG% set 0 or -1, the function updates the current
1250: 0002: !   displays setting.  When called with any other value, the function simply
1251: 0002: !   returns the current setting and does not update it.
1252: 0002: 
1253: 0002:     FUNCTION DM.CHANGED.FLAG (FLAG%) EXTERNAL                               !BSWM
1254: 0002:         INTEGER*1   FLAG%                                                   !BSWM
1255: 0002:         INTEGER*1   DM.CHANGED.FLAG                                         !BSWM
1256: 0002:     END FUNCTION                                                            !BSWM
1257: 0002: 
1258: 0002: !******************************************************************************
1259: 0002: !   Sets the field tab order.  The tab order can be either:
1260: 0002: !   0 - The TAB order is defined by the fields position on the display,
1261: 0002: !       left to right then top to bottom of the display.
1262: 0002: !   1 - The TAB order is defined by the number order of the fields.  This is
1263: 0002: !       a new option which allows greater control over the field TAB order.
1264: 0002: !   -1  Returns the current setting without changing it.
1265: 0002: !   The default tab order is 0.  Once set, the TAB order is a global setting
1266: 0002: !   for the current and all future screens.
1267: 0002: 
1268: 0002:     FUNCTION DM.TAB.ORDER (ORDER%) EXTERNAL                                 !DSWM
1269: 0002:         INTEGER*1   ORDER%                                                  !DSWM
1270: 0002:         INTEGER*1   DM.TAB.ORDER                                            !DSWM
1271: 0002:     END FUNCTION                                                            !DSWM
1272: 0002: 
1273: 0002: !******************************************************************************
1274: 0002: !   This function actually processes user input on the currently shown form.
1275: 0002: !   The function returns when any unrecognised key terminates input in a
1276: 0002: !   field.  The keys which will do this are determined by the properties of
1277: 0002: !   the Display Manager fields on your form.  The function internally handles
1278: 0002: !   most of the form navigation keys (e.g. Tab, Back Tab, Home End) the
1279: 0002: !   rest are up to the user application.
1280: 0002: 
1281: 0002:     FUNCTION DM.PROCESS.SCREEN (FIRST.FIELD%, LAST.FIELD%, CONFIRM) EXTERNAL
1282: 0002:         INTEGER*2   DM.PROCESS.SCREEN
1283: 0002:         INTEGER*2   FIRST.FIELD%
1284: 0002:         INTEGER*2   LAST.FIELD%
1285: 0002:         INTEGER*1   CONFIRM
1286: 0002:     END FUNCTION
1287: 0002: 
1288: 0002: !******************************************************************************
1289: 0002: !   Associates a field on the current display with a given compile time
1290: 0002: !   variable.  This allows the varibale to be used in your program code
1291: 0002: !   AND be updated by the display manager fields in PROCESS.SCREEN.
1292: 0002: !
1293: 0002: !   NOTE: PLEASE BE VERY CAREFUL WITH THE THIRD PARAMETER TO THIS SUB
1294: 0002: !   Always use an absolute variable for VARIABLE$:
1295: 0002: !       CALL DM.NAME (2, "MY.VAR$", MY.VAR$)
1296: 0002: !   NEVER use a calcualted value. These forms are all ILLEGAL:
1297: 0002: !       CALL DM.NAME (2, "MY.VAR$", "1234")
1298: 0002: !       CALL DM.NAME (2, "MY.VAR$", STR$(MY.VAR%))
1299: 0002: !   Also, if you MUST pass in an array element, for example:
1300: 0002: !       CALL DM.NAME (2, "MY.VAR$", ARRAY.ELEMENT$(I%))
1301: 0002: !   then you must make sure you do not reDIM the array until you have finished
1302: 0002: !   displaying and processing the screen.
1303: 0002: 
1304: 0002:     SUB DM.NAME (FIELD%, NAME$, VARIABLE$) EXTERNAL                         !DSWM
1305: 0002:         INTEGER*2 FIELD%                                                    !DSWM
1306: 0002:         STRING NAME$                                                        !DSWM
1307: 0002:         STRING VARIABLE$                                                    !DSWM
1308: 0002:     END SUB                                                                 !DSWM
1309: 0002: 
1310: 0002: !******************************************************************************
1311: 0002: !   Returns the index of a field on the current screen, given its name.
1312: 0002: 
1313: 0002:     FUNCTION DM.INDEX (FIELD$) EXTERNAL                                     !DSWM
1314: 0002:         STRING FIELD$                                                       !DSWM
1315: 0002:         INTEGER*2 DM.INDEX                                                  !DSWM
1316: 0002:     END FUNCTION                                                            !DSWM
1317: 0002: 
1318: 0002: !******************************************************************************
1319: 0002: !   Sets the validation expression for a field on the display.  Exactly the
1320: 0002: !   same as setting the global VALID$ array yourself, except it is done
1321: 0002: !   via the fields name as assoicated via DM.NAME.FIELD and the expression
1322: 0002: !   is in standard infix notation.
1323: 0002: 
1324: 0002:     FUNCTION DM.VALID (FIELD$, VALID$) EXTERNAL                             !DSWM
1325: 0002:         STRING FIELD$                                                       !DSWM
1326: 0002:         STRING VALID$                                                       !DSWM
1327: 0002:         INTEGER*2 DM.VALID                                                  !DSWM
1328: 0002:     END FUNCTION                                                            !DSWM
1329: 0002: 
1330: 0002: !******************************************************************************
1331: 0002: !   Sets the message expression for a field on the display.  Exactly the
1332: 0002: !   same as setting the global MESSAGE$ array yourself, except it is done
1333: 0002: !   via the fields name as assoicated via DM.NAME.FIELD and the expression
1334: 0002: !   is in standard infix notation.
1335: 0002: 
1336: 0002:     FUNCTION DM.MESSAGE (FIELD$, MESSAGE$) EXTERNAL                         !DSWM
1337: 0002:         STRING FIELD$                                                       !DSWM
1338: 0002:         STRING MESSAGE$                                                     !DSWM
1339: 0002:         INTEGER*2 DM.MESSAGE                                                !DSWM
1340: 0002:     END FUNCTION                                                            !DSWM
1341: 0002: 
1342: 0002: !******************************************************************************
1343: 0002: !   Sets the field attributes for a field on the display. Exactly the
1344: 0002: !   same as using the SETF command yourself except that it is done by
1345: 0002: !   using the fields name as associated via the DM.NAME.FIELD.
1346: 0002: 
1347: 0002: SUB DM.FLD.ATT (FIELD$, VALUE$) EXTERNAL                                    !FNWB
1348: 0002:     STRING      FIELD$                                                      !FNWB
1349: 0002:     STRING      VALUE$                                                      !FNWB
1350: 0002: END SUB                                                                     !FNWB
1351: 0002: 
1352: 0002: !******************************************************************************
1353: 0002: !   Sets an input field to act as an output only field on the display. This
1354: 0002: !   allows setting input fields that contain headings etc. to be skipped by
1355: 0002: !   the cursor movement keys.
1356: 0002: 
1357: 0002: FUNCTION DM.OO.FIELD (FIELD$) EXTERNAL                                      !FNWB
1358: 0002:     INTEGER*2   DM.OO.FIELD                                                 !FNWB
1359: 0002:     STRING      FIELD$                                                      !FNWB
1360: 0002: END FUNCTION                                                                !FNWB
1361: 0002: 
1362: 0002: !******************************************************************************
1363: 0002: !   Sets an input field back to an i/o field
1364: 0002: 
1365: 0002: FUNCTION DM.IO.FIELD (FIELD$) EXTERNAL                                      !FNWB
1366: 0002:     INTEGER*2   DM.IO.FIELD                                                 !FNWB
1367: 0002:     STRING      FIELD$                                                      !FNWB
1368: 0002: END FUNCTION                                                                !FNWB
1369: 0002: 
1370: 0002: !******************************************************************************
1371: 0002: !   Sets the visibility expression for a field on the display.  Exactly the
1372: 0002: !   same as setting the global VISIBLE$ array yourself, except it is done
1373: 0002: !   via the fields name as assoicated via DM.NAME.FIELD and the expression
1374: 0002: !   is in standard infix notation.
1375: 0002: 
1376: 0002:     FUNCTION DM.VISIBLE (FIELD$, VISIBLE$) EXTERNAL                         !DSWM
1377: 0002:         STRING FIELD$                                                       !DSWM
1378: 0002:         STRING VISIBLE$                                                     !DSWM
1379: 0002:         INTEGER*2 DM.VISIBLE                                                !DSWM
1380: 0002:     END FUNCTION                                                            !DSWM
1381: 0002: 
1382: 0002: !******************************************************************************
1383: 0002: !   Sets an error message in field 1 of the display and moves the input
1384: 0002: !   focus to the offending line of the display.  Should be called from user
1385: 0002: !   validation code.  Equivalent of the following separate calls:
1386: 0002: !       CALL DM.CURRENT.FIELD%(DM.INDEX(FIELD$))
1387: 0002: !       FIELD$(1) = POLISH$(MESSAGE$)
1388: 0002: !   Can also be called with a null field name, in which case the cursor
1389: 0002: !   remains in the current input field, but the error is displayed.
1390: 0002: 
1391: 0002:     FUNCTION DM.FOCUS (FIELD$, MESSAGE$) EXTERNAL                           !DSWM
1392: 0002:         STRING FIELD$                                                       !DSWM
1393: 0002:         STRING MESSAGE$                                                     !DSWM
1394: 0002:         INTEGER*2 DM.FOCUS                                                  !DSWM
1395: 0002:     END FUNCTION                                                            !DSWM
1396: 0002: 
1397: 0002: !******************************************************************************
1398: 0002: 
1399: 0002: 
1400: 0002: \******************************************************************************
1401: 0002: \******************************************************************************
1402: 0002: \***
1403: 0002: \***    MAIN PROGRAM
1404: 0002: \***
1405: 0002: \******************************************************************************
1406: 0002: \******************************************************************************
1407: 0002: 
1408: 0002:     MAIN.PROGRAM:
1409: 0024: 
1410: 0024:         ON ERROR GOTO ERROR.DETECTED
1411: 0039:         %INCLUDE PSBUSEE.J86            ! Chaining Parameters
1412: 0039: \/*********************************************************************/ PSBUSEE
1413: 0039: \/*                                                                   */ PSBUSEE
1414: 0039: \/*      PSBUSEE.J86  -  USE in PSB Application Program               */ PSBUSEE
1415: 0039: \/*      ----------------------------------------------               */ PSBUSEE
1416: 0039: \/*                                                                   */ PSBUSEE
1417: 0039: \/*********************************************************************/ PSBUSEE
1418: 0039:                                                                        ! PSBUSEE
1419: 0039:         USE  PSBCHN.OP , PSBCHN.APP , PSBCHN.MENCON , PSBCHN.U1 ,      \ PSBUSEE
1420: 008d:              PSBCHN.U2 , PSBCHN.U3                                     ! PSBUSEE
1421: 008d:                                                                        ! PSBUSEE
1422: 008d: 
1423: 008d:     PROGRAM.CONTROL:
1424: 009d: 
1425: 009d:         GOSUB INITIALISATION
1426: 00af:         GOSUB MAIN.SCREEN
1427: 00c1:         GOSUB TERMINATION
1428: 00d3: 
1429: 00d3:     STOP
1430: 00e0: 
1431: 00e0: \******************************************************************************
1432: 00e0: \******************************************************************************
1433: 00e0: \***
1434: 00e0: \***    MAIN PROGRAM
1435: 00e0: \***
1436: 00e0: \******************************************************************************
1437: 00e0: \******************************************************************************
1438: 00e0: 
1439: 00e0:     INITIALISATION:
1440: 00f0: 
1441: 00f0: 
1442: 00f0:         BCF.OPEN.FLAG$ = "N"
1443: 0105: 
1444: 0105:         INITIALIZED = FALSE         
1445: 0117:         TRUE = -1
1446: 0127:         FALSE = 0  
1447: 0137:         BATCH.SCREEN.FLAG$ = "S"        ! Screen
1448: 014e:         CHAIN.TO.PROG$     = "PSB50"    ! PSB50 for chain
1449: 0165:         MODULE.NUMBER$     = "PSD97"    ! Current Module
1450: 017c:         RESET = FALSE
1451: 018e:         CALL DM.INIT                    ! Display Manager Initialization
1452: 019b:         EXIT.NOW = FALSE
1453: 01ad:         PSD97.FIELD% = 3                ! Default screen input field
1454: 01ba: 
1455: 01ba:         GOSUB ALLOCATE.SESSION.NUMBERS
1456: 01cc: 
1457: 01cc:         
1458: 01cc: 
1459: 01cc:     RETURN
1460: 01dc: 
1461: 01dc: \******************************************************************************
1462: 01dc: \******************************************************************************
1463: 01dc: \***
1464: 01dc: \***    ALLOCATE.SESSION.NUMBERS:
1465: 01dc: \***
1466: 01dc: \***    Use the session number utility to allocate file numbers for the
1467: 01dc: \***    files used by the program.
1468: 01dc: \***
1469: 01dc: \******************************************************************************
1470: 01dc: \******************************************************************************
1471: 01dc: 
1472: 01dc:     ALLOCATE.SESSION.NUMBERS:
1473: 01ec: 
1474: 01ec: 
1475: 01ec:         CALL BCF.SET 
1476: 0207:         FUNCTION.FLAG$ EQ "O"
1477: 021e: 
1478: 021e:         PASSED.INTEGER% EQ BCF.REPORT.NUM%
1479: 0234:         PASSED.STRING$ EQ BCF.FILE.NAME$
1480: 0252:         GOSUB CALL.F20.SESS.NUM.UTILITY
1481: 0264:         BCF.SESS.NUM% EQ F20.INTEGER.FILE.NO%
1482: 027a: 
1483: 027a:     RETURN
1484: 028a: 
1485: 028a: \******************************************************************************
1486: 028a: \******************************************************************************
1487: 028a: \***
1488: 028a: \***    CALL.F20.SESS.NUM.UTILITY:
1489: 028a: \***
1490: 028a: \******************************************************************************
1491: 028a: \******************************************************************************
1492: 028a: 
1493: 028a:     CALL.F20.SESS.NUM.UTILITY: 
1494: 029a:         
1495: 029a:         FILE.OPERATION$ = "O"
1496: 02b1:         CURRENT.REPORT.NUM% = PASSED.INTEGER%
1497: 02c7:         RC% = SESS.NUM.UTILITY (FUNCTION.FLAG$, PASSED.INTEGER%,       \
1498: 0300:                                  PASSED.STRING$)
1499: 0300:         IF RC% <> 0 THEN GOTO FILE.ERROR
1500: 031e: 
1501: 031e:     RETURN
1502: 032e: 
1503: 032e: \******************************************************************************
1504: 032e: \******************************************************************************
1505: 032e: \***
1506: 032e: \***    Screen Validation
1507: 032e: \***
1508: 032e: \******************************************************************************
1509: 032e: \******************************************************************************
1510: 032e: 
1511: 032e:     MAIN.SCREEN:
1512: 033e: 
1513: 033e:         WHILE NOT EXIT.NOW
1514: 0349: 
1515: 0349:             CALL DM.SHOW.SCREEN(1, "", 2, 2)
1516: 0363: 
1517: 0363: 
1518: 0363:             ! Reads BCF and get the current serial numbers of various deal 
1519: 0363:             ! related files and display on the screen. If the current 
1520: 0363:             ! values are already zero, user can refrain from running the
1521: 0363:             ! program
1522: 0363: 
1523: 0363:             GOSUB BCF.OPEN
1524: 0375: 
1525: 0375:             GOSUB BCF.READ
1526: 0387: 
1527: 0387:             GOSUB BCF.CURRENT.FIELD
1528: 0399: 
1529: 0399:             GOSUB CLOSE.PROCESSING
1530: 03ab: 
1531: 03ab:             ! if the values are already zero reset flag will be set. if the user
1532: 03ab:             ! tries to enter the key again B186 message will be shown on the
1533: 03ab:             ! screen
1534: 03ab: 
1535: 03ab:             IF RESET = TRUE THEN BEGIN
1536: 03c0:                   CALL DM.STATUS                                        \
1537: 03d4:             ("MESSAGE(186,'as BCF serial numbers are already initialized')")
1538: 03d4: 
1539: 03d4:             ENDIF
1540: 03dc: 
1541: 03dc:             CALL DM.CURRENT.FIELD (PSD97.FIELD%) 
1542: 03f0: 
1543: 03f0:             INITIALIZED = FALSE
1544: 0402: 
1545: 0402:             WHILE INITIALIZED <> TRUE 
1546: 040d: 
1547: 040d:                 RET.KEY% = DM.PROCESS.SCREEN(PSD97.FIELD%               \
1548: 043e:                                      , PSD97.FIELD%,FALSE)
1549: 043e: 
1550: 043e:                 IF RET.KEY% = F3.KEY%   THEN BEGIN
1551: 0469: 
1552: 0469:                     INITIALIZED = TRUE
1553: 047b:                     EXIT.NOW    = TRUE
1554: 048d:                     GOSUB CHAIN.TO.CALLER
1555: 04a2: 
1556: 04a2:                 ENDIF ELSE IF RET.KEY% = ESC.KEY%    THEN BEGIN
1557: 04cd:                     GOTO ESCAPE.PRESSED	
1558: 04db: 
1559: 04db: 
1560: 04db:                 ENDIF ELSE IF RET.KEY% = ENTER.KEY%  THEN BEGIN
1561: 0509: 
1562: 0509:                     ! Logic executes only if the 'Y' flag is been typed
1563: 0509:                     ! and enter key is pressed, if so it will be display
1564: 0509:                     ! processing message.
1565: 0509: 
1566: 0509:                     IF UCASE$(FIELD$(3)) = CHR$(89) THEN BEGIN
1567: 054c:                         CALL DM.STATUS ("MESSAGE(251,'')")
1568: 0560:                         WAIT ;500
1569: 0577: 
1570: 0577:                     ! Opens BCF file and reads 14th record, after getting
1571: 0577:                     ! the DIDIR,DVCHR AND DEALDIR serial number it sets
1572: 0577:                     ! the flag accordingly. If the values are already 
1573: 0577:                     ! zero then RESET and INITIALIZED flag will set and
1574: 0577:                     ! message B186 will be shown on the screen
1575: 0577: 
1576: 0577:                         GOSUB BCF.OPEN
1577: 0589: 
1578: 0589:                         GOSUB BCF.READ
1579: 059b: 
1580: 059b:                         GOSUB VALIDATE.BCF
1581: 05ad: 
1582: 05ad:                         GOSUB CLOSE.PROCESSING
1583: 05bf: 
1584: 05bf:                         IF RESET = TRUE THEN BEGIN
1585: 05d4: 
1586: 05d4:                             INITIALIZED = TRUE
1587: 05e8: 
1588: 05e8:                         ENDIF ELSE BEGIN
1589: 05f0: 
1590: 05f0:                     ! If serial numbers are not set to zero then main processing
1591: 05f0:                     ! subroutine will be called and the values will be set to zero
1592: 05f0: 
1593: 05f0:                             GOSUB BCF.OPEN.LOCKED            ! For writing
1594: 0602: 
1595: 0602:                             GOSUB MAIN.PROCESSING
1596: 0614: 
1597: 0614:                             CALL DM.STATUS ("MESSAGE(299,'')")
1598: 0628: 
1599: 0628:                             GOSUB BCF.CURRENT.FIELD
1600: 063a: 
1601: 063a:                         ENDIF                 
1602: 0644: 
1603: 0644:                     ENDIF ELSE BEGIN
1604: 064c: 
1605: 064c:                     ! Displays the message if the input letter is not Y
1606: 064c: 
1607: 064c:                         CALL DM.STATUS ("MESSAGE(005,'')")              
1608: 0660: 
1609: 0660:                     ENDIF
1610: 066a: 
1611: 066a:                 ENDIF ELSE BEGIN
1612: 0672:                     !Displays if the key pressed is not ESCAPE,F3 or enter 
1613: 0672:                     CALL DM.STATUS ("MESSAGE(001,'')")
1614: 0686: 
1615: 0686:                 ENDIF
1616: 068e: 
1617: 068e:             WEND
1618: 06a6: 
1619: 06a6:         WEND 
1620: 06b8: 
1621: 06b8:     RETURN
1622: 06c8: 
1623: 06c8: \******************************************************************************
1624: 06c8: \******************************************************************************
1625: 06c8: \***
1626: 06c8: \***    BCF OPEN
1627: 06c8: \***
1628: 06c8: \******************************************************************************
1629: 06c8: \******************************************************************************
1630: 06c8: 
1631: 06c8:     BCF.OPEN:
1632: 06d8: 
1633: 06d8:         FILE.OPERATION$ = "O"
1634: 06ef:         IF BCF.OPEN.FLAG$ <> "Y" THEN BEGIN
1635: 070a: 
1636: 070a:             IF END #BCF.SESS.NUM% THEN FILE.ERROR
1637: 0726:             OPEN BCF.FILE.NAME$ RECL BCF.RECL% AS BCF.SESS.NUM% 
1638: 0752:             BCF.OPEN.FLAG$ = "Y"
1639: 0767: 
1640: 0767:         ENDIF
1641: 076f: 
1642: 076f:     RETURN
1643: 077f: 
1644: 077f: \******************************************************************************
1645: 077f: \******************************************************************************
1646: 077f: \***
1647: 077f: \***    BCF OPEN
1648: 077f: \***
1649: 077f: \******************************************************************************
1650: 077f: \******************************************************************************
1651: 077f: 
1652: 077f:     BCF.OPEN.LOCKED:
1653: 078f: 
1654: 078f:         FILE.OPERATION$ = "O"
1655: 07a6:         IF BCF.OPEN.FLAG$ <> "Y" THEN BEGIN
1656: 07c1: 
1657: 07c1:             IF END #BCF.SESS.NUM% THEN FILE.ERROR
1658: 07dd:             OPEN BCF.FILE.NAME$ RECL BCF.RECL% AS BCF.SESS.NUM% LOCKED 
1659: 0809:             BCF.OPEN.FLAG$ = "Y"
1660: 081e: 
1661: 081e:         ENDIF
1662: 0826: 
1663: 0826:     RETURN
1664: 0836: \******************************************************************************
1665: 0836: \******************************************************************************
1666: 0836: \***
1667: 0836: \***    BCF READ
1668: 0836: \***
1669: 0836: \******************************************************************************
1670: 0836: \******************************************************************************
1671: 0836: 
1672: 0836:     BCF.READ:
1673: 0846: 
1674: 0846:         ! Record number in BCF , which holds deal related serial numbers
1675: 0846:         BCF.REC.NO% = 14                            
1676: 085d:         FILE.OPERATION$ = "R"
1677: 0874:         RC% = READ.BCF
1678: 088d: 
1679: 088d:         IF RC% <> 0 THEN BEGIN
1680: 08a8:             GOSUB FILE.ERROR
1681: 08ba:         ENDIF
1682: 08c2: 
1683: 08c2:     RETURN
1684: 08d2: 
1685: 08d2: \******************************************************************************
1686: 08d2: \******************************************************************************
1687: 08d2: \***
1688: 08d2: \***    VALIDATE BCF
1689: 08d2: \***
1690: 08d2: \******************************************************************************
1691: 08d2: \******************************************************************************
1692: 08d2: 
1693: 08d2:     VALIDATE.BCF:         
1694: 08e2: 
1695: 08e2:         IF  BCF.DEALDIR.SERIAL.NUM$ = "0000" AND          \          
1696: 095c:                           BCF.DIDIR.SERIAL.NUM$   = "0000" AND          \
1697: 095c:                           BCF.DVCHR.SERIAL.NUM$   = "0000" THEN BEGIN
1698: 095c: 
1699: 095c: 
1700: 095c:             RESET = TRUE
1701: 096e:         ENDIF
1702: 0976: 
1703: 0976:     RETURN
1704: 0986: 
1705: 0986: \******************************************************************************
1706: 0986: \******************************************************************************
1707: 0986: \***
1708: 0986: \***    BCF.CURRENT.FIELD
1709: 0986: \***
1710: 0986: \******************************************************************************
1711: 0986: \******************************************************************************
1712: 0986: 
1713: 0986:     BCF.CURRENT.FIELD:
1714: 0996:         ! fields to display the current values from BCF
1715: 0996: 
1716: 0996:         FIELD$(6) = BCF.DEALDIR.SERIAL.NUM$
1717: 09c0:         FIELD$(7) = BCF.DIDIR.SERIAL.NUM$
1718: 09ea:         FIELD$(8) = BCF.DVCHR.SERIAL.NUM$
1719: 0a14: 
1720: 0a14:     RETURN
1721: 0a24: 
1722: 0a24: 
1723: 0a24: \******************************************************************************
1724: 0a24: \******************************************************************************
1725: 0a24: \***
1726: 0a24: \***    MAIN PROCESSING
1727: 0a24: \***
1728: 0a24: \******************************************************************************
1729: 0a24: \******************************************************************************
1730: 0a24: 
1731: 0a24:     MAIN.PROCESSING:
1732: 0a34: 
1733: 0a34:         BCF.REC.NO% = 14
1734: 0a4b: 
1735: 0a4b:         FILE.OPERATION$ = "R"
1736: 0a62: 
1737: 0a62:         RC% = READ.BCF
1738: 0a7b: 
1739: 0a7b:         IF RC% <> 0 THEN BEGIN
1740: 0a96:             GOTO FILE.ERROR
1741: 0aa3:         ENDIF ELSE BEGIN
1742: 0aab:             GOSUB SET.SERIAL.ZERO
1743: 0abd:         ENDIF
1744: 0ac5: 
1745: 0ac5:     RETURN
1746: 0ad5: 
1747: 0ad5: \******************************************************************************
1748: 0ad5: \******************************************************************************
1749: 0ad5: \***
1750: 0ad5: \***    SET.SERIAL.ZERO
1751: 0ad5: \***
1752: 0ad5: \******************************************************************************
1753: 0ad5: \******************************************************************************
1754: 0ad5: 
1755: 0ad5:     SET.SERIAL.ZERO:
1756: 0ae5: 
1757: 0ae5:       ! Below hard coded variables will reset the serial numbers of DEALDIR
1758: 0ae5:       ! DIDIR and DVCHR. Store can have an initial deal load then
1759: 0ae5: 
1760: 0ae5:         BCF.DEALDIR.SERIAL.NUM$ = "0000"
1761: 0afc:         BCF.DIDIR.SERIAL.NUM$   = "0000"
1762: 0b13:         BCF.DVCHR.SERIAL.NUM$   = "0000"
1763: 0b2a: 
1764: 0b2a:         FILE.OPERATION$ = "W"
1765: 0b41: 
1766: 0b41:         RC% = WRITE.BCF
1767: 0b5a: 
1768: 0b5a:         IF RC% <> 0 THEN BEGIN
1769: 0b75:             GOTO FILE.ERROR
1770: 0b82:         ENDIF ELSE BEGIN  
1771: 0b8a:             RESET = TRUE
1772: 0b9c:         ENDIF 
1773: 0ba4: 
1774: 0ba4: 
1775: 0ba4:     RETURN
1776: 0bb4: 
1777: 0bb4: \******************************************************************************
1778: 0bb4: \******************************************************************************
1779: 0bb4: \***
1780: 0bb4: \***     CLOSE.PROCESSING
1781: 0bb4: \***
1782: 0bb4: \******************************************************************************
1783: 0bb4: \******************************************************************************
1784: 0bb4: 
1785: 0bb4:     CLOSE.PROCESSING:
1786: 0bc4: 
1787: 0bc4:         IF BCF.OPEN.FLAG$ <> "N" THEN BEGIN
1788: 0bdf:             CLOSE BCF.SESS.NUM%   
1789: 0bf3:             BCF.OPEN.FLAG$ = "N"
1790: 0c08:         ENDIF
1791: 0c10: 
1792: 0c10:     RETURN 
1793: 0c20: 
1794: 0c20: \******************************************************************************
1795: 0c20: \******************************************************************************
1796: 0c20: \***
1797: 0c20: \***     DEALLOCATE.SESSION.NUMBERS
1798: 0c20: \***
1799: 0c20: \******************************************************************************
1800: 0c20: \******************************************************************************
1801: 0c20: 
1802: 0c20:     DEALLOCATE.SESSION.NUMBERS:
1803: 0c30: 
1804: 0c30:         FUNCTION.FLAG$   = "C"          
1805: 0c47: 
1806: 0c47:         PASSED.INTEGER% EQ BCF.REPORT.NUM%
1807: 0c5d:         PASSED.STRING$ EQ BCF.FILE.NAME$
1808: 0c7b:         GOSUB CALL.F20.SESS.NUM.UTILITY
1809: 0c8d:         BCF.SESS.NUM% EQ F20.INTEGER.FILE.NO%
1810: 0ca3: 
1811: 0ca3:     RETURN
1812: 0cb3: 
1813: 0cb3: \******************************************************************************
1814: 0cb3: \******************************************************************************
1815: 0cb3: \***
1816: 0cb3: \***   SUBROUTINE :  ESCAPE.PRESSED
1817: 0cb3: \***
1818: 0cb3: \******************************************************************************
1819: 0cb3: \******************************************************************************
1820: 0cb3: 
1821: 0cb3:     ESCAPE.PRESSED:
1822: 0cc3: 
1823: 0cc3:         PSBCHN.MENCON = "000000"
1824: 0cda: 
1825: 0cda:     CHAIN.TO.CALLER: 
1826: 0cea: 
1827: 0cea:         IF COMMAND.MODE THEN BEGIN
1828: 0cfc:             CLEARS
1829: 0d0b:             GOSUB STOP.PROGRAM
1830: 0d1d:         ENDIF
1831: 0d25: 
1832: 0d25:         ! Processing - Please wait
1833: 0d25:         CALL DM.STATUS ("MESSAGE(405,'')")
1834: 0d39:         CALL DM.QUIT
1835: 0d46: 
1836: 0d46:         ! Current program and chaining program
1837: 0d46:         PSBCHN.APP = "C:/ADX_UPGM/PSE50.286"
1838: 0d5d:         PSBCHN.PRG = "C:/ADX_UPGM/" + CHAIN.TO.PROG$ + ".286"
1839: 0d86: 
1840: 0d86:         %INCLUDE PSBCHNE.J86          ! Include CHAIN operation
1841: 0d86: \/*********************************************************************/ PSBCHNE
1842: 0d86: \/*                                                                   */ PSBCHNE
1843: 0d86: \/*      PSBCHNE.J86  -  Chain to PSB Application Program             */ PSBCHNE
1844: 0d86: \/*      ------------------------------------------------             */ PSBCHNE
1845: 0d86: \/*                                                                   */ PSBCHNE
1846: 0d86: \/*********************************************************************/ PSBCHNE
1847: 0d86:                                                                        ! PSBCHNE
1848: 0d86:         CHAIN  PSBCHN.PRG , PSBCHN.OP , PSBCHN.APP , PSBCHN.MENCON ,   \ PSBCHNE
1849: 0e06:                             PSBCHN.U1 , PSBCHN.U2  , PSBCHN.U3         ! PSBCHNE
1850: 0e06:                                                                        ! PSBCHNE
1851: 0e06: 
1852: 0e06:         GOSUB STOP.PROGRAM
1853: 0e18: 
1854: 0e18:     RETURN
1855: 0e28: 
1856: 0e28: 
1857: 0e28: \******************************************************************************
1858: 0e28: \******************************************************************************
1859: 0e28: \***
1860: 0e28: \***   SUBROUTINE : TERMINATION
1861: 0e28: \***
1862: 0e28: \******************************************************************************
1863: 0e28: \******************************************************************************
1864: 0e28: 
1865: 0e28:      TERMINATION:
1866: 0e38: 
1867: 0e38:          GOSUB CLOSE.PROCESSING
1868: 0e4a:          GOSUB DEALLOCATE.SESSION.NUMBERS
1869: 0e5c: 
1870: 0e5c:      RETURN
1871: 0e6c: 
1872: 0e6c: \******************************************************************************
1873: 0e6c: \******************************************************************************
1874: 0e6c: \***                                                                           
1875: 0e6c: \***   ERROR ROUTINE  :  FILE.ERROR                                            
1876: 0e6c: \***                                                                           
1877: 0e6c: \***   Call APPLICATION.LOG to log an event 106 with                           
1878: 0e6c: \***   flag, current report number and current key                             
1879: 0e6c: \***                                                                           
1880: 0e6c: \***                                                                           
1881: 0e6c: \******************************************************************************
1882: 0e6c: \******************************************************************************
1883: 0e6c: 
1884: 0e6c:     FILE.ERROR:         
1885: 0e7c: 
1886: 0e7c:         EVENT.NO%     = 106
1887: 0e8d: 
1888: 0e8d:         FILE.NO$  = CHR$(SHIFT(BCF.REPORT.NUM%,8))            +         \
1889: 0ee0:                   CHR$(SHIFT(BCF.REPORT.NUM%,0))
1890: 0ee0: 
1891: 0ee0:         IF FILE.OPERATION$ = "O" THEN BEGIN  ! Open error
1892: 0efe: 
1893: 0efe:             MESSAGE.NO%   = 501    ! Message No. for open error
1894: 0f11: 
1895: 0f11:         ENDIF ELSE IF FILE.OPERATION$ = "R" THEN BEGIN  ! Read error
1896: 0f2f: 
1897: 0f2f:             MESSAGE.NO%   = 508    ! Message No. for Read error
1898: 0f42: 
1899: 0f42:         ENDIF ELSE IF FILE.OPERATION$ = "W" THEN BEGIN  ! Read error
1900: 0f60: 
1901: 0f60:             MESSAGE.NO%   = 504    ! Message No. for Write error
1902: 0f71: 
1903: 0f71:         ENDIF
1904: 0f79: 
1905: 0f79:         VAR.STRING.1$ = FILE.OPERATION$                       +         \
1906: 1003:                  CHR$(SHIFT(BCF.REPORT.NUM%, 8) AND 0FFH)     +         \
1907: 1003:                  CHR$(BCF.REPORT.NUM% AND 0FFH)               +         \
1908: 1003:                  CURRENT.CODE$
1909: 1003:         VAR.STRING.2$ = RIGHT$("000" + STR$(BCF.REPORT.NUM%),3) +       \
1910: 106b:                  UNPACK$(CURRENT.CODE$)  
1911: 106b: 
1912: 106b:         RC% = APPLICATION.LOG(MESSAGE.NO%,VAR.STRING.1$,                \
1913: 10ad:                       VAR.STRING.2$,EVENT.NO%)
1914: 10ad: 
1915: 10ad: 
1916: 10ad:         GOTO ESCAPE.PRESSED
1917: 10b8: 
1918: 10b8: \******************************************************************************
1919: 10b8: \******************************************************************************
1920: 10b8: \***
1921: 10b8: \***   SUBROUTINE : ERROR.DETECTED
1922: 10b8: \***
1923: 10b8: \******************************************************************************
1924: 10b8: \******************************************************************************
1925: 10b8: 
1926: 10b8:     ERROR.DETECTED:
1927: 10c8: 
1928: 10c8:         IF ERR = "NP" THEN BEGIN    ! Command mode run
1929: 10ee:             COMMAND.MODE = TRUE       ! Command mode is set to TRUE
1930: 1104:             RESUME PROGRAM.CONTROL
1931: 111b:         ENDIF
1932: 1123: 
1933: 1123:       
1934: 1123:         GOSUB FILE.ERROR
1935: 1135: 
1936: 1135: \******************************************************************************
1937: 1135: \******************************************************************************
1938: 1135: \***
1939: 1135: \***   SUBROUTINE : STOP.PROGRAM
1940: 1135: \***
1941: 1135: \******************************************************************************
1942: 1135: \******************************************************************************
1943: 1135: 
1944: 1135:      STOP.PROGRAM:
1945: 114a: 
1946: 114a:      END
1947: 114a: 
1948: 114a: \******************************************************************************
1949: 114a: \******************************************************************************
1950: 114a: \***
1951: 114a: \***    End of program 
1952: 114a: \***
1953: 114a: \******************************************************************************
1954: 114a: \******************************************************************************
1955: 114a:  
1956: 114a: End of Compilation
