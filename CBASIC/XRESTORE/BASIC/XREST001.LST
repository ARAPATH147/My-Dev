   1: 0000: \***********************************************************************
   2: 0000: \*
   3: 0000: \*            PROGRAM         :       XRESTORE
   4: 0000: \*            MODULE          :       XREST001
   5: 0000: \*            AUTHOR          :       Jaya Kumar Inbaraj
   6: 0000: \*            DATE WRITTEN    :       Mar 2014
   7: 0000: \*
   8: 0000: \***********************************************************************
   9: 0000: 
  10: 0000: \***********************************************************************
  11: 0000: \*
  12: 0000: \* Program: XRESTORE          Jaya Kumar Inbaraj              04/03/2014
  13: 0000: \*
  14: 0000: \* FOD260 - Enhanced Backup and Recovery
  15: 0000: \*
  16: 0000: \*       MODULE EXTRACTED FROM ORIGINAL XRESTORE.BAS (RENAMED TO
  17: 0000: \*       XREST000.BAS) AS BREACHED 64K LIMIT AND CRETAED AS XREST001.BAS
  18: 0000: \*
  19: 0000: \*
  20: 0000: \*======================================================================
  21: 0000: \*                   V E R S I O N   C O N T R O L
  22: 0000: \*======================================================================
  23: 0000: \*
  24: 0000: \*                            Dave Constable                  25/06/2014
  25: 0000: \* FOD260 - Enhanced Backup and Recovery
  26: 0000: \* Code extracted originally from single module (XRESTORE.BAS) and all
  27: 0000: \* code change markers removed.
  28: 0000: \* For maintenance and usage all included variables and includes are
  29: 0000: \* also replicated here.
  30: 0000: \*
  31: 0000: \* Version B                 Jaya Kumar Inbaraj               01/08/2014
  32: 0000: \* FOD260 - Enhanced Backup and Recovery
  33: 0000: \* QC717 and QC724 - Restoration for files in BKPFAIL has been fixed.
  34: 0000: \*
  35: 0000: \* Version C                 Jaya Kumar Inbaraj               23/08/2014
  36: 0000: \* FOD260 - Enhanced Backup and Recovery
  37: 0000: \* CR5 changes to perform the drive restore if a drive is empty.
  38: 0000: \* Also commented out few redundant labels and worked on Internal
  39: 0000: \* and APPS management review comments.
  40: 0000: \* Added an Header for easy reference on multi-modular program.
  41: 0000: \*
  42: 0000: \* Version D                 Jaya Kumar Inbaraj               03/09/2014
  43: 0000: \* FOD260 - Enhanced Backup and Recovery
  44: 0000: \* Worked on APPS management review comments.
  45: 0000: \*
  46: 0000: \* Version E                 Jaya Kumar Inbaraj               12/09/2014
  47: 0000: \* QC1145 - Updated to avoid excessive logging.
  48: 0000: \*
  49: 0000: \***********************************************************************
  50: 0000: 
  51: 0000: \***********************************************************************
  52: 0000: \*
  53: 0000: \* Included global variables
  54: 0000: \*
  55: 0000: \***********************************************************************
  56: 0000:     %INCLUDE XRESTORG.J86                                               !CJK
  57: 0000: \***********************************************************************
  58: 0000: \*
  59: 0000: \* Program: XRESTORE          Jaya Kumar Inbaraj              04/03/2014
  60: 0000: \*
  61: 0000: \* FOD260 - Enhanced Backup and Recovery
  62: 0000: \*
  63: 0000: \*           %INCLUDE for Global variables used in XRESTORE
  64: 0000: \*
  65: 0000: \*                    REFERENCE: XRESTORG.J86
  66: 0000: \*
  67: 0000: \*       MODULE EXTRACTED FROM ORIGINAL XRESTORE.BAS (RENAMED TO
  68: 0000: \*       XREST000.BAS) AS BREACHED 64K LIMIT AND CRETAED AS XREST001.BAS
  69: 0000: \*
  70: 0000: \*======================================================================
  71: 0000: \*                   V E R S I O N   C O N T R O L
  72: 0000: \*======================================================================
  73: 0000: \*
  74: 0000: \*                            Dave Constable                  25/06/2014
  75: 0000: \* FOD260 - Enhanced Backup and Recovery
  76: 0000: \* Code extracted originally from single module (XRESTORE.BAS) and all
  77: 0000: \* code change markers removed.
  78: 0000: \* For maintenance and usage all included variables and includes are
  79: 0000: \* also replicated here and included into both modules.
  80: 0000: \*
  81: 0000: \* Version B                Jaya Kumar Inbaraj                01/08/2014
  82: 0000: \* FOD260 - Enhanced Backup and Recovery
  83: 0000: \* Created a variable for BKPFAIL restore.
  84: 0000: \*
  85: 0000: \* Version C                Jaya Kumar Inbaraj                23/08/2014
  86: 0000: \* FOD260 - Enhanced Backup and Recovery
  87: 0000: \* CR5 changes to perform the drive restore if a drive is empty.
  88: 0000: \* Also updated the header block comments.
  89: 0000: \*
  90: 0000: \* Version D                Jaya Kumar Inbaraj                12/09/2014
  91: 0000: \* QC1145 - Added ADXUNZIP related variables
  92: 0000: \*
  93: 0000: \***********************************************************************
  94: 0000: 
  95: 0000: \***********************************************************************
  96: 0000: \*
  97: 0000: \* Included code defining file related global variables
  98: 0000: \*
  99: 0000: \***********************************************************************
 100: 0000:     !-----------------------------------------------------------------!
 101: 0000:     ! Changed the BKPLIST file variables prefix from BKPLIST to BKPLI !
 102: 0000:     ! and hence applied the changes in whole XRESTORE program also    !
 103: 0000:     !-----------------------------------------------------------------!
 104: 0000:     %INCLUDE BKPLIDEC.J86    ! BKPLIST file variables
 105: 0000: \***********************************************************************
 106: 0000: \***********************************************************************
 107: 0000: \*
 108: 0000: \*    BKPLIST - Backup List File
 109: 0000: \*
 110: 0000: \*    %INCLUDE FOR VARIABLE DECLARATIONS
 111: 0000: \*
 112: 0000: \*        REFERENCE   :   BKPLIDEC.J86
 113: 0000: \*
 114: 0000: \*        FILE TYPE   :   Sequential
 115: 0000: \*
 116: 0000: \* Version A              Jaya Kumar Inbaraj              04/02/2014
 117: 0000: \* Original version.
 118: 0000: \*
 119: 0000: \* Version B              Jaya Kumar Inbaraj              09/04/2014
 120: 0000: \* FOD260 - Enhanced Backup and Recovery
 121: 0000: \* Changed all the file function variables from BKPLIST prefix to
 122: 0000: \* BKPLI prefix.
 123: 0000: \*
 124: 0000: \* Version C              Jaya Kumar Inbaraj              29/04/2014
 125: 0000: \* FOD260 - Enhanced Backup and Recovery
 126: 0000: \* Commented out the unused variables
 127: 0000: \*
 128: 0000: \* Version D              Dave Constable                  05/06/2014
 129: 0000: \* changes for generic full and incremental backups rather than forced 
 130: 0000: \* Sunday
 131: 0000: \*
 132: 0000: \***********************************************************************
 133: 0000: \***********************************************************************
 134: 0000: 
 135: 0000:     ! Changed the File related variables from BKPLIST to BKPLI prefix   !BJK
 136: 0000:     STRING GLOBAL                     \
 137: 0000: \        BKPLIST.CRLF$,                \                                !CJK
 138: 0000:         BKPLI.FILE.NAME$,             \ BKPLIST file name
 139: 0000:         BKPLI.FILENAME$,              \ File present in BKPLIST
 140: 0000:         BKPLI.FULL.EXIST$,            \                                 !DDC
 141: 0000:         BKPLI.FULL.FILE.CHNG$,        \                                 !DDC
 142: 0000:         BKPLI.INCREMENTAL.EXIST$(1),  \                                 !DDC
 143: 0000:         BKPLI.INCREMENTAL.FILE.CHNG$(1), \                              !DDC
 144: 0000:         BKPLI.VALUE$                                                    !DDC        
 145: 0000: 
 146: 0000:     ! Changed the File related variables from BKPLIST to BKPLI prefix   !BJK
 147: 0000:     INTEGER*2 GLOBAL                  \
 148: 0000: \        BKPLI.RECL%,                  \                                !CJK
 149: 0000:         BKPLI.RECORD.NUM%,            \
 150: 0000:         BKPLI.REPORT.NUM%,            \
 151: 0000:         BKPLI.SESS.NUM%
 152: 0000: 
 153: 0000:     INTEGER*1 GLOBAL                  \
 154: 0000:         BKPLIST.NO.OF.FIELDS%
 155: 0000: 
 156: 0000: 
 157: 0000: 
 158: 0000: \***********************************************************************
 159: 0000: \*
 160: 0000: \* Included code defining function related global variables
 161: 0000: \*
 162: 0000: \***********************************************************************
 163: 0000:     %INCLUDE PSBF02G.J86     ! Update Date
 164: 0000: REM\
 165: 0000: \*******************************************************************************
 166: 0000: \*******************************************************************************
 167: 0000: \***
 168: 0000: \***        INCLUDE       : UPDATE.DATE globals
 169: 0000: \***
 170: 0000: \***        REFERENCE     : PSBF02G.J86
 171: 0000: \***
 172: 0000: \***        Version A     Bruce Scriver      4th March 1986
 173: 0000: \*** 
 174: 0000: \***        Version B     Andrew Wedgeworth   6th July 1992
 175: 0000: \***        Removal of return code field which no longer required.
 176: 0000: \***
 177: 0000: \*******************************************************************************
 178: 0000: \*******************************************************************************
 179: 0000: 
 180: 0000:       STRING   GLOBAL F02.DATE$
 181: 0000: 
 182: 0000:       ! 1 line deleted from here                                       ! BAW
 183: 0000: 
 184: 0000:     %INCLUDE PSBF13G.J86     ! PSDATE function
 185: 0000: REM\
 186: 0000: \*******************************************************************************
 187: 0000: \*******************************************************************************
 188: 0000: \***
 189: 0000: \***        INCLUDE       : PSDATE globals
 190: 0000: \***
 191: 0000: \***        REFERENCE     : PSBF13G.J86
 192: 0000: \***
 193: 0000: \***     VERSION A                                  Bruce Scriver  6th Mar 86             
 194: 0000: \***            
 195: 0000: \***     VERSION B                                  Janet Lawrence 17 Aug 90
 196: 0000: \***     Add global to be used to indicate whether or not the function should
 197: 0000: \***     log an event when an invalid date is passed to it.
 198: 0000: \***
 199: 0000: \***     VERSION C                               Andrew Wedgeworth 17 July 92
 200: 0000: \***     Return code removed as no longer required.
 201: 0000: \***
 202: 0000: \*******************************************************************************
 203: 0000: \*******************************************************************************
 204: 0000: 
 205: 0000:       STRING    GLOBAL F13.DAY$,			\
 206: 0000:                        F13.DISPLAY.MESSAGE$		! BJAL
 207: 0000: 
 208: 0000: 
 209: 0000:     %INCLUDE PSBF20G.J86     ! Session number Utility
 210: 0000: REM\
 211: 0000: \*******************************************************************************
 212: 0000: \*******************************************************************************
 213: 0000: \***
 214: 0000: \***     %INCLUDE GLOBAL VARIABLE DEFINITIONS FOR SESS.NUM.UTILITY FUNCTION
 215: 0000: \***
 216: 0000: \***                       REFERENCE     : PSBF20G.J86
 217: 0000: \*** 
 218: 0000: \***     Version A              Bruce Scrive                   5th May 1988   
 219: 0000: \*** 
 220: 0000: \***     Version B              Robert Cowey                   7th May 1991
 221: 0000: \***     Global variable F20.INTEGER.FILE.NO% changed from one byte integer
 222: 0000: \***     to two byte integer.
 223: 0000: \***
 224: 0000: \***     Version D              Andrew Wedgeworth             1st July 1992
 225: 0000: \***     F20.RETURN.CODE% removed as it is no longer required.
 226: 0000: \***
 227: 0000: \*******************************************************************************
 228: 0000: \*******************************************************************************
 229: 0000: 
 230: 0000:       STRING    GLOBAL F20.FILE.NAME$,                                 \
 231: 0000:                        F20.STRING.FILE.NO$,                            \
 232: 0000:                        F20.TABLE.DIMENSIONED.FLAG$,                    \
 233: 0000:                        SESS.NUM.TABLE$(1)
 234: 0000: 
 235: 0000:       INTEGER*2 GLOBAL F20.INTEGER.FILE.NO%
 236: 0000: 
 237: 0000:       ! 1 line deleted from here                                       ! DAW 
 238: 0000: 
 239: 0000:     %INCLUDE PSBF39G.J86     ! Display Manager
 240: 0000: !******************************************************************************
 241: 0000: !******************************************************************************
 242: 0000: !***
 243: 0000: !***            PROGRAM         :       PSBF39G.J86
 244: 0000: !***
 245: 0000: !***            DESCRIPTION     :       DISPLAY MANAGER INTERFACE
 246: 0000: !***
 247: 0000: !***            AUTHOR          :       Stuart William McConnachie
 248: 0000: !***            DATE WRITTEN    :       September 2000
 249: 0000: !***
 250: 0000: !***        Provides a much needed and easier to use interface to
 251: 0000: !***        IBM Display Manager.
 252: 0000: !***
 253: 0000: !***        Saves the user having to set up, highlight, tab between and
 254: 0000: !***        validate fields.  Also handles the help screens and conversion
 255: 0000: !***        of date fields to external/internal format.
 256: 0000: !***
 257: 0000: !******************************************************************************
 258: 0000: !******************************************************************************
 259: 0000:     
 260: 0000:     STRING GLOBAL       MESSAGE$(1)
 261: 0000:     STRING GLOBAL       VALID$(1)
 262: 0000:     STRING GLOBAL       VISIBLE$(1)
 263: 0000:     STRING GLOBAL       FIELD$(1)
 264: 0000:     STRING GLOBAL       TITLE$
 265: 0000: 
 266: 0000:     INTEGER*2 GLOBAL    DM.SCREEN%
 267: 0000:     INTEGER*2 GLOBAL    DM.FIELD%
 268: 0000:     
 269: 0000:     INTEGER*2 GLOBAL    HOME.KEY%
 270: 0000:     INTEGER*2 GLOBAL    END.KEY%
 271: 0000:     INTEGER*2 GLOBAL    PGUP.KEY%
 272: 0000:     INTEGER*2 GLOBAL    PGDN.KEY%
 273: 0000:     INTEGER*2 GLOBAL    TAB.KEY%
 274: 0000:     INTEGER*2 GLOBAL    BTAB.KEY%
 275: 0000:     INTEGER*2 GLOBAL    UP.KEY%
 276: 0000:     INTEGER*2 GLOBAL    DOWN.KEY%
 277: 0000:     INTEGER*2 GLOBAL    ESC.KEY%
 278: 0000:     INTEGER*2 GLOBAL    ENTER.KEY%
 279: 0000:     INTEGER*2 GLOBAL    INS.KEY%
 280: 0000:     INTEGER*2 GLOBAL    PREV.KEY%
 281: 0000:     INTEGER*2 GLOBAL    NEXT.KEY%
 282: 0000:         
 283: 0000:     INTEGER*2 GLOBAL    F1.KEY%
 284: 0000:     INTEGER*2 GLOBAL    F2.KEY%
 285: 0000:     INTEGER*2 GLOBAL    F3.KEY%
 286: 0000:     INTEGER*2 GLOBAL    F4.KEY%
 287: 0000:     INTEGER*2 GLOBAL    F5.KEY%
 288: 0000:     INTEGER*2 GLOBAL    F6.KEY%
 289: 0000:     INTEGER*2 GLOBAL    F7.KEY%
 290: 0000:     INTEGER*2 GLOBAL    F8.KEY%
 291: 0000:     INTEGER*2 GLOBAL    F9.KEY%
 292: 0000:     INTEGER*2 GLOBAL    F10.KEY%
 293: 0000:                 
 294: 0000: !******************************************************************************
 295: 0000: 
 296: 0000: 
 297: 0000:     %INCLUDE PSBUSEG.J86     ! Chain Parameters
 298: 0000: \/*********************************************************************/ PSBUSEG
 299: 0000: \/*                                                                   */ PSBUSEG
 300: 0000: \/* PSBUSEG.J86  -  Definitions for Chain/Use with PSB Screen Program */ PSBUSEG
 301: 0000: \/* ----------------------------------------------------------------- */ PSBUSEG
 302: 0000: \/*                                                                   */ PSBUSEG
 303: 0000: \/*********************************************************************/ PSBUSEG
 304: 0000:                                                                        ! PSBUSEG
 305: 0000:         STRING GLOBAL  PSBCHN.PRG,      \ Program to chain to          ! PSBUSEG
 306: 0000:                        PSBCHN.OP,       \ Operator Id                  ! PSBUSEG
 307: 0000:                        PSBCHN.APP,      \ Program chained from         ! PSBUSEG
 308: 0000:                        PSBCHN.MENCON,   \ Menu Control                 ! PSBUSEG
 309: 0000:                        PSBCHN.U1,       \ User parameter               ! PSBUSEG
 310: 0000:                        PSBCHN.U2,       \ User parameter               ! PSBUSEG
 311: 0000:                        PSBCHN.U3        ! User parameter               ! PSBUSEG
 312: 0000:                                                                        ! PSBUSEG
 313: 0000:     %INCLUDE SLPCFDEC.J86    ! Sleeper control
 314: 0000: \*****************************************************************************
 315: 0000: \*****************************************************************************
 316: 0000: \***
 317: 0000: \***             %INCLUDE FOR SLEEPER CHECK FILE - FIELD DECLARATIONS
 318: 0000: \***                                          FILE REFERENCE PARAMETERS
 319: 0000: \***
 320: 0000: \***                      FILE TYPE    :
 321: 0000: \***
 322: 0000: \***                      REFERENCE    : slpcfdeb.J86
 323: 0000: \***
 324: 0000: \***      Version A             Steve Windsor          8.2.93
 325: 0000: \***
 326: 0000: \***      Version B             Richard Foster         28.6.93
 327: 0000: \***
 328: 0000: \***      Version C             Mark Goode             6.03.00
 329: 0000: \***
 330: 0000: \***      Version D         Jaya Kumar Inbaraj               28/04/2014
 331: 0000: \***      FOD260 - Enhanced Backup and Recovery
 332: 0000: \***      Updated Filler variable usage has been explained. Added two
 333: 0000: \***      variables related to SLPCF Filler variable.
 334: 0000: \***
 335: 0000: \*****************************************************************************
 336: 0000: \*****************************************************************************
 337: 0000: 
 338: 0000: 
 339: 0000:   STRING GLOBAL          \
 340: 0000:     SLPCF.FILE.NAME$
 341: 0000: 
 342: 0000:   INTEGER*2 GLOBAL        \
 343: 0000:     SLPCF.REPORT.NUM%,    \
 344: 0000:     SLPCF.SESS.NUM%
 345: 0000: 
 346: 0000:   STRING GLOBAL              \
 347: 0000:     SLPCF.APP.NAME$,         \ 21 bytes - Application to be started
 348: 0000:     SLPCF.RUN.FREQUENCY$,    \ 1 byte   - d=daily, m=monthly              !BRCF
 349: 0000:     SLPCF.DAY.NUM$,          \ 6 bytes  - blank = evry day                !BRCF
 350: 0000:                              \            1 = sun  2 = mon                !BRCF
 351: 0000:               \            3 = tue  4 = wed                !BRCF
 352: 0000:               \            5 = thu  6 = fri                !BRCF
 353: 0000:               \            7 = sat                         !BRCF
 354: 0000:               \         OR nn = date (monthly run) up to   !BRCF
 355: 0000:               \                 3 2-digit numbers          !BRCF
 356: 0000:     SLPCF.RUN.TIME$,         \ 6 bytes  - time due to be started (HHMMSS) !BRCF
 357: 0000:     SLPCF.LAST.RUN.DATE$,    \ 6 bytes  - Date last run (YYMMDD)          !BRCF
 358: 0000:     SLPCF.FILE.PRESENT$,     \ 3 bytes  - Report number of file which must!BRCRF
 359: 0000:                              \            be present                      !BRCF
 360: 0000:     SLPCF.FILE.PRESENT.NAME$,\ 8 bytes  - Name of above file              !BRCF
 361: 0000:     SLPCF.FILE.ABSENT$,      \ 3 bytes  - Report number of file which must!BRCF
 362: 0000:                              \            not be present                  !BRCF
 363: 0000:     SLPCF.FILE.ABSENT.NAME$, \ 8 bytes  - Name of above file              !BRCF
 364: 0000:     SLPCF.NODE.ID$,          \ 2 bytes  - Node on which to run application!BRCF
 365: 0000:                              \            CE = Master only                !BRCF
 366: 0000:               \            CF = File Server only           !BRCF
 367: 0000:               \            DE = Single only                !BRCF
 368: 0000:               \            SM = Single and Master          !BRCF
 369: 0000:               \            SF = Single and File Server     !BRCF
 370: 0000:     SLPCF.SOFTS.REC$,        \ 4 bytes  - The record number on the SOFTS file !LMG
 371: 0000:     SLPCF.FILLER$,           \ 12 bytes - Format can be xYYYYYYYYY      !DJK LMG
 372: 0000:               \ where; If x is 1-9 then the first x characters of Y are !DJK
 373: 0000:               \ passed to the starting application as a start parameter !DJK
 374: 0000:               \ and a CrLf                                              !DJK
 375: 0000:     SLPCF.PARM$              ! Value Y from SLPCF.FILLER                !DJK
 376: 0000: 
 377: 0000:   INTEGER*2 GLOBAL        \
 378: 0000:     SLPCF.RECL%           ! Length of record
 379: 0000: 
 380: 0000:   INTEGER*1 GLOBAL        \                                             !DJK
 381: 0000:     SLPCF.PARM.LEN%       ! Value X from SLPCF.FILLER                   !DJK
 382: 0000: 
 383: 0000:   INTEGER*4 GLOBAL        \
 384: 0000:     SLPCF.REC.NO%         ! Record Number
 385: 0000: 
 386: 0000: 
 387: 0000: \***********************************************************************
 388: 0000: \*
 389: 0000: \* Global variable definitions
 390: 0000: \*
 391: 0000: \***********************************************************************
 392: 0000:     STRING GLOBAL                   \
 393: 0000:         BATCH.SCREEN.FLAG$,         \
 394: 0000:         CHAIN.TO.PROG$,             \
 395: 0000:         MODULE.NUMBER$
 396: 0000: 
 397: 0000:     INTEGER*4 GLOBAL                \
 398: 0000:         BKPLIST.FILE.RC%,           \
 399: 0000:         DIR.FILE.RC%,               \
 400: 0000:         XRE.FILE.RC%
 401: 0000: 
 402: 0000: \***********************************************************************
 403: 0000: \*
 404: 0000: \* Local Variables Made Global when multi-modular
 405: 0000: \*
 406: 0000: \***********************************************************************
 407: 0000:     STRING GLOBAL                   \
 408: 0000:         ADX.PARM.2$,                \
 409: 0000:         ADXCSU0L.FILE.NAME$,        \                                   !CJK
 410: 0000:         ADXUNZIP.FILE.NAME$,        \                                   !DJK
 411: 0000:         ADXZUDIR.FILE.NAME$,        \
 412: 0000:         BACKUP.DAYS$,               \
 413: 0000:         BACKUP.LONG.DAYS$,          \
 414: 0000:         BKP.DRIVE$,                 \                                   !CJK
 415: 0000:         BKP.FILENAME.ALT$,          \
 416: 0000:         BKP.FILENAME.IMG$,          \
 417: 0000:         BKP.ZIP.FILE$,              \                                   !DJK
 418: 0000:         BKPFAIL.CURR.FILE$,         \
 419: 0000:         BKPFAIL.PREFIX$,            \                                   !CJK
 420: 0000:         BKPLIST.CURR.FILE$,         \
 421: 0000:         BKPLIST.DIR.VALUE$,         \
 422: 0000:         BKPLIST.FIELD$(1),          \
 423: 0000:         BKPLIST.PREFIX.C.DRIVE$,    \                                   !CJK
 424: 0000:         BKPLIST.PREFIX.D.DRIVE$,    \                                   !CJK
 425: 0000:         BKPLIST.VALUE$,             \
 426: 0000:         BKPSCRPT.COMMAND$,          \
 427: 0000:         BKPSCRPT.DIRECTORY$,        \
 428: 0000:         BKPSCRPT.FILE.NAME$,        \
 429: 0000:         BKPSCRPT.OUT.FILE.NAME$,    \
 430: 0000:         C.BKP.ALT$,                 \
 431: 0000:         C.BKP.IMG$,                 \
 432: 0000:         CDRIVE$,                    \
 433: 0000:         CNTLR.ID$,                  \
 434: 0000:         COMMA.VALUE$,               \
 435: 0000:         CONSTANT.COLON$,            \
 436: 0000:         CONSTANT.DAY$(1),           \
 437: 0000:         CONSTANT.FRIDAY.LONG$,      \
 438: 0000:         CONSTANT.FRIDAY.SHORT$,     \
 439: 0000:         CONSTANT.LONG.DAY$(1),      \
 440: 0000:         CONSTANT.MONDAY.LONG$,      \
 441: 0000:         CONSTANT.MONDAY.SHORT$,     \
 442: 0000:         CONSTANT.SATURDAY.LONG$,    \
 443: 0000:         CONSTANT.SATURDAY.SHORT$,   \
 444: 0000:         CONSTANT.SUNDAY.LONG$,      \
 445: 0000:         CONSTANT.SUNDAY.SHORT$,     \
 446: 0000:         CONSTANT.THURSDAY.LONG$,    \
 447: 0000:         CONSTANT.THURSDAY.SHORT$,   \
 448: 0000:         CONSTANT.TUESDAY.LONG$,     \
 449: 0000:         CONSTANT.TUESDAY.SHORT$,    \
 450: 0000:         CONSTANT.WEDNESDAY.LONG$,   \
 451: 0000:         CONSTANT.WEDNESDAY.SHORT$,  \
 452: 0000:         CRLF$,                      \
 453: 0000:         D.BKP.ALT$,                 \
 454: 0000:         D.BKP.IMG$,                 \
 455: 0000:         DDRIVE$,                    \
 456: 0000:         DIR.OUT$,                   \
 457: 0000:         DIR1.OUT$,                  \   Command pipe output file        !DJK
 458: 0000:         DIR.VALUE$,                 \
 459: 0000:         DIRECT.TO.RESTORE$,         \
 460: 0000:         DRIVE$,                     \
 461: 0000:         ERROR.MSG$,                 \
 462: 0000:         EXTENSION$,                 \
 463: 0000:         FAILED.FILE$,               \
 464: 0000:         FAILED.FILE.DIST$,          \
 465: 0000:         FILENAME$,                  \
 466: 0000:         FIRST.FILE$,                \
 467: 0000:         FSEL$,                      \
 468: 0000:         FULL.DATE$,                 \
 469: 0000:         FULL.MDD.DATE$,             \
 470: 0000:         FULL.TO.MOVING.DATE$,       \
 471: 0000:         FUNC.FLAG$,                 \
 472: 0000:         MDD.DATE$,                  \
 473: 0000:         NORMAL.SLEEPER.FILE.NAME$,  \
 474: 0000:         OPT.HEADER$,                \
 475: 0000:         OPT.HEADER.1$,              \
 476: 0000:         OPT.SELECTED$,              \
 477: 0000:         OS.DESTINATION$,            \
 478: 0000:         OS.FILE$(1),                \
 479: 0000:         OS.SOURCE$,                 \
 480: 0000:         PARM.FULL$,                 \
 481: 0000: \        PARM.INCREMENTAL$,          \                                  !CJK
 482: 0000:         PASSED.STRING$,             \
 483: 0000:         RESTORE.FILENAME$,          \                                   !BJK
 484: 0000:         SCR.HEADER$,                \
 485: 0000:         SCREEN.NUM$,                \
 486: 0000:         SCREEN.TEXT.MSG$(1),        \
 487: 0000:         SECOND.FILE$,               \
 488: 0000:         SELECT.FILE.NAME$,          \
 489: 0000:         SELECTED.FILENAME$,         \
 490: 0000: \        SHELL.COMMAND$,             \  ! variable passed into OSSHELL  !CJK
 491: 0000:         SLEEPER.RECORD$,            \
 492: 0000:         STATUS.MSG$,                \
 493: 0000:         STATUS.TEXT.ERROR$(1),      \
 494: 0000:         STATUS.TEXT.MSG$(1),        \
 495: 0000:         SUPPS.SLEEPER.FILE.NAME$,   \
 496: 0000:         TEMP.DIR$,                  \
 497: 0000:         TODAY.DATE$,                \
 498: 0000:         USER.TEXT$,                 \
 499: 0000:         VERSION$,                   \                                   !CJK
 500: 0000:         WORK.DATE.MMDD$,            \
 501: 0000:         XBACK.PIPE.NAME$,           \
 502: 0000:         XRE.LOG.FILENAME$,          \
 503: 0000:         XRE.NULL$,                  \
 504: 0000:         XRE.PIPE.NAME$,             \
 505: 0000:         XRE.SPACE$
 506: 0000: 
 507: 0000:     ! Grouping Arrays
 508: 0000:     STRING GLOBAL                   \
 509: 0000:         BKP.AVAIL.ARRAY$(1),        \
 510: 0000:         BKP.DATE.ARRAY$(1),         \
 511: 0000:         BKP.FILE.MDD.ARRAY$(1),     \
 512: 0000:         BKP.FILE.MMDD.ARRAY$(1),    \
 513: 0000:         BKPSCRPT.DIRECTORIES$(1),   \
 514: 0000:         DAY.ARRAY$(1),              \
 515: 0000:         PRIMARY.ARCHIVED.NAMES$(1), \
 516: 0000:         SECONDARY.ARCHVD.NAMES$(1), \
 517: 0000:         SELECTED.DIR.ARRAY$(1)
 518: 0000: 
 519: 0000:     INTEGER*1 GLOBAL                \
 520: 0000:         ADX.FUNCTION%,              \
 521: 0000:         BKP.INDEX%,                 \
 522: 0000:         CNTLR.CONFIG%,              \
 523: 0000:         CONSTANT.LONGEST.DAY%,      \
 524: 0000:         DAY.INDEX%,                 \
 525: 0000:         DAY.SINCE.FULL%,            \
 526: 0000:         DAYS.AFTER.FULL.BAKUP%,     \
 527: 0000:         DD.MM.INDEX%,               \
 528: 0000:         DIR.INDEX%,                 \
 529: 0000:         DIR.TO.SHOW%,               \
 530: 0000:         DIRECTORY.CREATE,           \
 531: 0000:         DIRECTORY.DAY.SELECT.SCR%,  \
 532: 0000:         DIRECTORY.PROCESS.SCR%,     \
 533: 0000:         DISPLAY.MAIN.SCR%,          \
 534: 0000:         DRIVE.DAY.SELECT.SCR%,      \
 535: 0000:         DRIVE.DISK.SELECT.SCR%,     \
 536: 0000:         DRIVE.PROCESS.SCR%,         \
 537: 0000:         ERROR.COUNT%,               \
 538: 0000:         F.RECORD.COUNT%,            \ count for header lines in DIR
 539: 0000:         FILE.CONFIRMATION.SCR%,     \
 540: 0000:         FILE.DAY.SELECT.SCR%,       \
 541: 0000:         FILE.DIR.AND.DIST.SCR%,     \
 542: 0000:         FILE.PROCESS.SCR%,          \
 543: 0000:         FULL.BACKUP.NOT.FOUND%,     \
 544: 0000:         INPUT.INDEX%,               \
 545: 0000:         MASTER.AND.FILE.SERVER%,    \
 546: 0000:         OPT.SEL%,                   \
 547: 0000:         PAGE.DIV%,                  \
 548: 0000:         PAGE.NO%,                   \
 549: 0000:         RESTORE.A.DIRECTORY.SCR%,   \
 550: 0000:         RESTORE.A.FILE.SCR%,        \
 551: 0000:         SCREEN%,                    \
 552: 0000:         SCREEN.NUM%,                \
 553: 0000:         SLEEPER.DAY%,               \
 554: 0000:         SLPCF.OPEN,                 \
 555: 0000:         XRE.ZERO%
 556: 0000: 
 557: 0000:     ! Grouping Boolean variables
 558: 0000:     INTEGER*1 GLOBAL                \
 559: 0000:         BKPLIST.OPEN,               \
 560: 0000:         COMMAND.MODE,               \
 561: 0000:         DIR.OPEN,                   \
 562: 0000:         DUPLICATE.RECORD,           \                                   !CJK
 563: 0000:         ERROR.EXIST,                \
 564: 0000:         FALSE,                      \
 565: 0000:         FUNCTION.ERROR.NOT.EXIST,   \
 566: 0000: \        IN.LOG.STATUS.MSG,          \                                  !CJK
 567: 0000: \        IN.UPDATE.DATE.RC,          \                                  !CJK
 568: 0000:         NON.X.VALUES,               \
 569: 0000:         PREVIOUS.KEY,               \
 570: 0000:         RESTORE.ERR.EXIST,          \
 571: 0000:         RESTORE.HAPPENED,           \                                   !CJK
 572: 0000:         RESTORE.STATUS,             \
 573: 0000:         SUPPS.ON,                   \
 574: 0000:         TRUE,                       \
 575: 0000:         VALUE.EXISTS,               \
 576: 0000:         VALUE.PRESENT,              \
 577: 0000:         XBACK.OPEN,                 \
 578: 0000:         XRE.LOG.OPEN,               \
 579: 0000:         XRE.OPEN
 580: 0000: 
 581: 0000:     INTEGER*2 GLOBAL                \
 582: 0000:         ARRAY.LIMIT%,               \                                   !CJK
 583: 0000:         BEGIN.POS%,                 \
 584: 0000:         BEGIN.POSITION%,            \
 585: 0000:         BKP.DAYS%,                  \
 586: 0000:         BKPSCRPT.INDEX%,            \
 587: 0000:         COMMA.POSITION%,            \
 588: 0000:         DAY.LOOP%,                  \
 589: 0000:         DD.MM.LOOP%,                \
 590: 0000:         DIR.INPUT.INDEX%,           \
 591: 0000:         DIR.INPUT.LOOP%,            \
 592: 0000:         DIR.LOOP%,                  \
 593: 0000:         FUN.RC2%,                   \ function return value for check
 594: 0000:         INDEX%,                     \
 595: 0000:         INPUT.LOOP%,                \
 596: 0000:         LONG.DAY.INDEX%,            \
 597: 0000:         LOOP%,                      \
 598: 0000:         MATCH.POS%,                 \
 599: 0000:         MAX.DIRECTORIES%,           \
 600: 0000:         PASSED.INTEGER%,            \
 601: 0000:         RET.KEY%,                   \
 602: 0000:         SEL.INDEX%,                 \
 603: 0000:         SEL.INPUT.LOOP%,            \
 604: 0000:         SELECT.COUNT%,              \
 605: 0000:         SELECT.INDEX%,              \
 606: 0000:         SLASH.POSITION%,            \
 607: 0000:         VALUE.INDEX%,               \
 608: 0000:         XBACK.PIPE.REPORT.NUM%,     \
 609: 0000:         XBACK.PIPE.SESS.NUM%,       \
 610: 0000:         XRE.LOG.REPORT.NUM%,        \
 611: 0000:         XRE.LOG.SESS.NUM%,          \
 612: 0000:         XRE.PIPE.REPORT.NUM%,       \
 613: 0000:         XRE.PIPE.SESS.NUM%
 614: 0000: 
 615: 0000:     INTEGER*4 GLOBAL                \
 616: 0000:         ADXSERVE.RC%,               \
 617: 0000:         FILE.RC%
 618: 0000: 
 619: 0000: 
 620: 0000: \***********************************************************************
 621: 0000: \*
 622: 0000: \* Included external functions
 623: 0000: \*
 624: 0000: \***********************************************************************
 625: 0000:     %INCLUDE XRESTORE.J86                                               !CJK
 626: 0000: \***********************************************************************
 627: 0000: \*
 628: 0000: \* Program: XRESTORE          Jaya Kumar Inbaraj              04/03/2014
 629: 0000: \*
 630: 0000: \* FOD260 - Enhanced Backup and Recovery
 631: 0000: \*
 632: 0000: \*           %INCLUDE for External Functions in XRESTORE
 633: 0000: \*
 634: 0000: \*                    REFERENCE: XRESTORE.J86
 635: 0000: \*
 636: 0000: \*       MODULE EXTRACTED FROM ORIGINAL XRESTORE.BAS (RENAMED TO
 637: 0000: \*       XREST000.BAS) AS BREACHED 64K LIMIT AND CRETAED AS XREST001.BAS
 638: 0000: \*
 639: 0000: \*======================================================================
 640: 0000: \*                   V E R S I O N   C O N T R O L
 641: 0000: \*======================================================================
 642: 0000: \*
 643: 0000: \*                            Dave Constable                  25/06/2014
 644: 0000: \* FOD260 - Enhanced Backup and Recovery
 645: 0000: \* Code extracted originally from single module (XRESTORE.BAS) and all
 646: 0000: \* code change markers removed.
 647: 0000: \* For maintenance and usage all included externals and includes are
 648: 0000: \* also replicated here and included into both modules.
 649: 0000: \*
 650: 0000: \* Version B                Jaya Kumar Inbaraj                23/08/2014
 651: 0000: \* FOD260 - Enhanced Backup and Recovery
 652: 0000: \* Updated the Header block comments
 653: 0000: \*
 654: 0000: \* Version C                Jaya Kumar Inbaraj                04/09/2014
 655: 0000: \* FOD260 - Enhanced Backup and Recovery
 656: 0000: \* Updated the C file function names
 657: 0000: \*
 658: 0000: \***********************************************************************
 659: 0000: 
 660: 0000: \***********************************************************************
 661: 0000: \*
 662: 0000: \* Included code defining file related global variables
 663: 0000: \*
 664: 0000: \***********************************************************************
 665: 0000: 
 666: 0000: \***********************************************************************
 667: 0000: \*
 668: 0000: \* Included code defining function related external functions
 669: 0000: \*
 670: 0000: \***********************************************************************
 671: 0000:     %INCLUDE PSBF02E.J86     ! Update Date
 672: 0000: REM\
 673: 0000: \*******************************************************************************
 674: 0000: \*******************************************************************************
 675: 0000: \***
 676: 0000: \***        INCLUDE       : UPDATE.DATE external definition
 677: 0000: \***        AUTHOR        : Bruce Scriver (Basic Code)
 678: 0000: \***        DATE WRITTEN  : 4th March 1986 (Basic Code)
 679: 0000: \***
 680: 0000: \***        REFERENCE     : PSBF02E.J86
 681: 0000: \***
 682: 0000: \***        Version A     Bruce Scriver          4th March 1986
 683: 0000: \***
 684: 0000: \***        Version B     Andrew Wedgeworth       6th July 1992
 685: 0000: \***        Removal of redundant parameters, and inclusion of UPDATE.DATE as
 686: 0000: \***        a variable to hold the return code.
 687: 0000: \***
 688: 0000: \*******************************************************************************
 689: 0000: \*******************************************************************************
 690: 0000: 
 691: 0000:    FUNCTION UPDATE.DATE (INCREMENT%)                                   \
 692: 0000:    EXTERNAL
 693: 0000:    ! 3 parameters removed from here                                    ! BAW
 694: 0000: 
 695: 0000:    ! 3 lines deleted from here                                         ! BAW
 696: 0000:    
 697: 0000:       INTEGER*2 UPDATE.DATE                                            ! BAW
 698: 0000: 
 699: 0000:       INTEGER*4 INCREMENT%
 700: 0000: 
 701: 0000:    END FUNCTION
 702: 0000: 
 703: 0000:     %INCLUDE PSBF13E.J86     ! PSDATE function
 704: 0000: REM\
 705: 0000: \*******************************************************************************
 706: 0000: \*******************************************************************************
 707: 0000: \***
 708: 0000: \***        INCLUDE       : PSDATE external definition
 709: 0000: \***
 710: 0000: \***        REFERENCE     : PSBF13E.J86
 711: 0000: \***
 712: 0000: \***        Version A     Bruce Scriver                6th March 1986
 713: 0000: \*** 
 714: 0000: \***        Version B     Andrew Wedgeworth            17th July 1992  
 715: 0000: \***        Redundant parameters removed and PSDATE defined as a variable
 716: 0000: \***        to hold the return code. 
 717: 0000: \***
 718: 0000: \*******************************************************************************
 719: 0000: \*******************************************************************************
 720: 0000: 
 721: 0000:    FUNCTION PSDATE (INPUT.DATE$)                                               \
 722: 0000:    EXTERNAL
 723: 0000: 
 724: 0000:      STRING    INPUT.DATE$                                                   
 725: 0000:    
 726: 0000:      INTEGER*2 PSDATE 
 727: 0000: 
 728: 0000:    END FUNCTION
 729: 0000: 
 730: 0000:     %INCLUDE PSBF20E.J86     ! Session number utility
 731: 0000: REM\
 732: 0000: \*******************************************************************************
 733: 0000: \*******************************************************************************
 734: 0000: \***
 735: 0000: \***       %INCLUDE FOR EXTERNAL DEFINITION OF SESS.NUM.UTILITY
 736: 0000: \***
 737: 0000: \***                  REFERENCE     : PSBF20E.J86
 738: 0000: \***
 739: 0000: \***     VERSION C            Janet Smith                13th May 1992
 740: 0000: \***     Increased PASSED.INTEGER to 2 bytes to cater for more than
 741: 0000: \***     128 files.
 742: 0000: \***
 743: 0000: \***     VERSION D.           Andrew Wedgeworth          1st July 1992
 744: 0000: \***     Removal of redundant parameters and addition of SESS.NUM.UTILITY
 745: 0000: \***     as a variable.  This new variable contains the function's return
 746: 0000: \***     code.
 747: 0000: \***
 748: 0000: \*******************************************************************************
 749: 0000: \*******************************************************************************
 750: 0000: 
 751: 0000:    FUNCTION SESS.NUM.UTILITY (FUNCTION.FLAG$,                          \
 752: 0000:                               PASSED.INTEGER%,                         \
 753: 0000:                               PASSED.STRING$)                          \
 754: 0000:    EXTERNAL
 755: 0000: 
 756: 0000:    STRING    FUNCTION.FLAG$,                                           \
 757: 0000:              PASSED.STRING$
 758: 0000:    ! 3 variables removed from here                                     ! CAW
 759: 0000: 
 760: 0000: 
 761: 0000:    INTEGER*2 SESS.NUM.UTILITY,                                         \ CAW
 762: 0000:              PASSED.INTEGER%				               ! CJAS
 763: 0000: 
 764: 0000:    END FUNCTION
 765: 0000: 
 766: 0000:     %INCLUDE PSBF24E.J86     ! Standard error detected
 767: 0000: REM \
 768: 0000: \*******************************************************************************
 769: 0000: \*******************************************************************************
 770: 0000: \***
 771: 0000: \***    %INCLUDE FOR EXTERNAL DEFINITION OF STANDARD.ERROR.DETECTED FUNCTION
 772: 0000: \***
 773: 0000: \***                      REFERENCE     : PSBF24E.J86
 774: 0000: \***
 775: 0000: \***    Version A                 Janet Smith                  13th May 1992
 776: 0000: \***
 777: 0000: \*******************************************************************************
 778: 0000: \*******************************************************************************
 779: 0000: 
 780: 0000:    FUNCTION STANDARD.ERROR.DETECTED(ERRN%,                 \
 781: 0000: 				    ERRFILE%,              \
 782: 0000: 				    ERRL%,                 \
 783: 0000: 				    ERR$)        EXTERNAL
 784: 0000: 				    
 785: 0000:           STRING    ERR$
 786: 0000: 
 787: 0000:           INTEGER*2 ERRFILE%,              \
 788: 0000: 	            ERRL%,                 \
 789: 0000: 		    STANDARD.ERROR.DETECTED
 790: 0000: 		    
 791: 0000:           INTEGER*4 ERRN%
 792: 0000: 	  		    
 793: 0000:    END FUNCTION
 794: 0000: 
 795: 0000: 
 796: 0000:     %INCLUDE PSBF39E.J86     ! Display Manager
 797: 0000: !******************************************************************************
 798: 0000: !******************************************************************************
 799: 0000: !***
 800: 0000: !***            PROGRAM         :       PSBF39E.J86
 801: 0000: !***
 802: 0000: !***            DESCRIPTION     :       DISPLAY MANAGER INTERFACE
 803: 0000: !***
 804: 0000: !***            AUTHOR          :       Stuart William McConnachie
 805: 0000: !***            DATE WRITTEN    :       September 2000
 806: 0000: !***
 807: 0000: !***        Provides a much needed and easier to use interface to
 808: 0000: !***        IBM Display Manager.
 809: 0000: !***
 810: 0000: !***        Saves the user having to set up, highlight, tab between and
 811: 0000: !***        validate fields.  Also handles the help screens and conversion
 812: 0000: !***        of date fields to external/internal format.
 813: 0000: !***
 814: 0000: !******************************************************************************
 815: 0000: !******************************************************************************
 816: 0000: 
 817: 0000: !******************************************************************************
 818: 0000: !   Initialises the display manager functions.
 819: 0000: !   You should call this from your program initialisation for screen programs.
 820: 0000: !   Note that the name of the display manager file is determined from the
 821: 0000: !   global variable MODULE.NUMBER$.  For example PSB1200 uses PSBD12.dat
 822: 0000: !   where the PSB and 12 have been derived from MODULE.NUMBER$.
 823: 0000: 
 824: 0000:     FUNCTION DM.INIT EXTERNAL
 825: 0000:         INTEGER*1   DM.INIT
 826: 0000:     END FUNCTION
 827: 0000: 
 828: 0000: !******************************************************************************
 829: 0000: !   Quits the display manager program and frees resources.
 830: 0000: !   You should call this from your program termination.
 831: 0000: 
 832: 0000:     FUNCTION DM.QUIT EXTERNAL
 833: 0000:         INTEGER*1   DM.QUIT
 834: 0000:     END FUNCTION
 835: 0000: 
 836: 0000: !******************************************************************************
 837: 0000: !   Initialises a particular screen from the current display manager file
 838: 0000: !   for display.  You supply the screen number, optional title message and
 839: 0000: !   the first and last help screens associated with the display.
 840: 0000: !   Once you have SHOWN a screen, you can use the remaining functions in
 841: 0000: !   this library to set field values, and actually retrieve input from the
 842: 0000: !   screen.  Note that showing a screen just displays it on the screen,
 843: 0000: !   you need to call PROCESS.SCREEN to actually get any user input.
 844: 0000: 
 845: 0000:     FUNCTION DM.SHOW.SCREEN (SCREEN%, TITLE$, FIRST.HELP%, LAST.HELP%) EXTERNAL
 846: 0000:         INTEGER*1   DM.SHOW.SCREEN
 847: 0000:         INTEGER*2   SCREEN%
 848: 0000:         STRING      TITLE$
 849: 0000:         INTEGER*2   FIRST.HELP%
 850: 0000:         INTEGER*2   LAST.HELP%
 851: 0000:     END FUNCTION
 852: 0000: 
 853: 0000: !******************************************************************************
 854: 0000: !   Sets a function key message to visible.  Optionally sets the text on that
 855: 0000: !   key to the message string passed, if it is not null.
 856: 0000: !   Note you must have shown a screen first, and that the function key fields
 857: 0000: !   need to be defined in your display file with field IDs 241-250.
 858: 0000: 
 859: 0000:     FUNCTION DM.SHOW.FN.KEY (KEY.NUM%, MESSAGE$) EXTERNAL
 860: 0000:         INTEGER*1   DM.SHOW.FN.KEY
 861: 0000:         INTEGER*2   KEY.NUM%
 862: 0000:         STRING      MESSAGE$
 863: 0000:     END FUNCTION
 864: 0000: 
 865: 0000: !******************************************************************************
 866: 0000: !   Sets a function key message to invisible.
 867: 0000: !   Note you must have shown a screen first, and that the function key fields
 868: 0000: !   need to be defined in your display file with field IDs 241-250.
 869: 0000: 
 870: 0000:     FUNCTION DM.HIDE.FN.KEY (KEY.NUM%) EXTERNAL
 871: 0000:         INTEGER*1   DM.HIDE.FN.KEY
 872: 0000:         INTEGER*2   KEY.NUM%
 873: 0000:     END FUNCTION
 874: 0000: 
 875: 0000: !******************************************************************************
 876: 0000: !   LEGACY: Do not use in new programs, use DM.FN.VISIBLE instead which takes
 877: 0000: !   an infix notation expression, as opposed to reverse polish
 878: 0000: !   This definition has been commented out accordingly.  If you are
 879: 0000: !   recompiling an application, change to useing the new function.
 880: 0000: !
 881: 0000: !   FUNCTION DM.FN.KEY.VISIBLE (KEY.NUM%, EXPR$) EXTERNAL
 882: 0000: !       INTEGER*1   DM.FN.KEY.VISIBILITY
 883: 0000: !       INTEGER*2   KEY.NUM%
 884: 0000: !       STRING      EXPR$
 885: 0000: !   END FUNCTION
 886: 0000: 
 887: 0000: !******************************************************************************
 888: 0000: !   Sets a runtine expression to determine if a function key is visible.
 889: 0000: !   This is the new version of the above which takes an infix notation EXPR$.
 890: 0000: !   Note you must have shown a screen first, and that the function key fields
 891: 0000: !   need to be defined in your display file with field IDs 241-250.
 892: 0000: 
 893: 0000:     FUNCTION DM.FN.VISIBLE (KEY.NUM%, EXPR$) EXTERNAL
 894: 0000:         INTEGER*1   DM.FN.VISIBILITY
 895: 0000:         INTEGER*2   KEY.NUM%
 896: 0000:         STRING      EXPR$
 897: 0000:     END FUNCTION
 898: 0000: 
 899: 0000: !******************************************************************************
 900: 0000: !   Specifies that a given field contains a date.
 901: 0000: !   This means that the date will be displayed on screen in the system date
 902: 0000: !   format (e.g. DD/MM/YY or MM/DD/YY, but will be returned and set by your
 903: 0000: !   application in YYMMDD format.
 904: 0000: !   It does NOT mean that the field will be validated as a date, you must do
 905: 0000: !   that explicitly using the VALID$ string.
 906: 0000: 
 907: 0000:     FUNCTION DM.DATE.FIELD (FIELD%) EXTERNAL
 908: 0000:         INTEGER*1   DM.DATE.FIELD
 909: 0000:         INTEGER*2   FIELD%
 910: 0000:     END FUNCTION
 911: 0000: 
 912: 0000: !******************************************************************************
 913: 0000: !   Specifies that a given field will contain a time.
 914: 0000: !   This means that the time will be displayed on screen using the system time
 915: 0000: !   format.  e.g. HH:MM
 916: 0000: 
 917: 0000:     FUNCTION DM.TIME.FIELD (FIELD%) EXTERNAL                                !CSWM
 918: 0000:         INTEGER*1   DM.TIME.FIELD                                           !CSWM
 919: 0000:         INTEGER*2   FIELD%                                                  !CSWM
 920: 0000:     END FUNCTION                                                            !CSWM
 921: 0000: 
 922: 0000: !******************************************************************************
 923: 0000: !   Specifies that a given input field will be read only.
 924: 0000: !   This allows you to select an item from a list by highlighting it.
 925: 0000: 
 926: 0000:     FUNCTION DM.RO.FIELD (FIELD%) EXTERNAL                                  !ESWM
 927: 0000:         INTEGER*1   DM.RO.FIELD                                             !ESWM
 928: 0000:         INTEGER*2   FIELD%                                                  !ESWM
 929: 0000:     END FUNCTION                                                            !ESWM
 930: 0000: 
 931: 0000: !******************************************************************************
 932: 0000: !   Specifies that a given input field will be read write.
 933: 0000: !   Undoes the effect of DM.RO.FIELD.
 934: 0000: 
 935: 0000:     FUNCTION DM.RW.FIELD (FIELD%) EXTERNAL                                  !ESWM
 936: 0000:         INTEGER*1   DM.RW.FIELD                                             !ESWM
 937: 0000:         INTEGER*2   FIELD%                                                  !ESWM
 938: 0000:     END FUNCTION                                                            !ESWM
 939: 0000: 
 940: 0000: !******************************************************************************
 941: 0000: !   LEGACY: Do not use in new programs, use DM.STATUS instead which takes
 942: 0000: !   an infix notation expression, as opposed to reverse polish.
 943: 0000: !   This definition has been commented out accordingly.  If you are
 944: 0000: !   recompiling an application, change to useing the new function.
 945: 0000: !
 946: 0000: !   FUNCTION DM.DISPLAY.MESSAGE (MESSAGE$) EXTERNAL                         !DSWM
 947: 0000: !       INTEGER*1   DM.DISPLAY.MESSAGE                                      !DSWM
 948: 0000: !       STRING      MESSAGE$                                                !DSWM
 949: 0000: !   END FUNCTION                                                            !DSWM
 950: 0000: 
 951: 0000: !******************************************************************************
 952: 0000: !   Displays a message in the status line of the display.  Does not wait for
 953: 0000: !   input.  Use this function for display messages such as B251 Processing...
 954: 0000: !   You must have field 1 defined in your display manager file.
 955: 0000: !   This is the new version of the above which takes an infix notation MESSAGE$.
 956: 0000: 
 957: 0000:     FUNCTION DM.STATUS (MESSAGE$) EXTERNAL                                  !DSWM
 958: 0000:         INTEGER*1   DM.STATUS                                               !DSWM
 959: 0000:         STRING      MESSAGE$                                                !DSWM
 960: 0000:     END FUNCTION                                                            !DSWM
 961: 0000: 
 962: 0000: !******************************************************************************
 963: 0000: !   Waits for input in the invisible input field of the display.  Additionally
 964: 0000: !   displays a message prompting the user on the status line.
 965: 0000: !   You must have fields 1 and 240 defined in your display manager file.
 966: 0000: !   The message supplied should be in Reverse Polish form.
 967: 0000: !   The function returns the key value that ended the input.
 968: 0000: 
 969: 0000:     FUNCTION DM.INVISIBLE.INPUT (MESSAGE$) EXTERNAL
 970: 0000:         STRING      MESSAGE$
 971: 0000:         INTEGER*2   DM.INVISIBLE.INPUT
 972: 0000:     END FUNCTION
 973: 0000: 
 974: 0000: !******************************************************************************
 975: 0000: !   Gets the contents of the invisible field from the display.  This will
 976: 0000: !   allow you to get the Y or N answer that the user typed, for example.
 977: 0000: 
 978: 0000:     FUNCTION DM.INVISIBLE.FIELD EXTERNAL
 979: 0000:         STRING      DM.INVISIBLE.FIELD
 980: 0000:     END FUNCTION
 981: 0000: 
 982: 0000: !******************************************************************************
 983: 0000: !   Returns or sets the current field used for input on the current display.
 984: 0000: !   If NEW.FIELD% is zero, the function simply returns the current field.
 985: 0000: !   If NEW.FIELD% is non zero, the function sets the current field.
 986: 0000: 
 987: 0000:     FUNCTION DM.CURRENT.FIELD (NEW.FIELD%) EXTERNAL
 988: 0000:         INTEGER*2   DM.CURRENT.FIELD
 989: 0000:         INTEGER*2   NEW.FIELD%
 990: 0000:     END FUNCTION
 991: 0000: 
 992: 0000: !******************************************************************************
 993: 0000: !   Sets a key number as being a validation key.  When this key is used the
 994: 0000: !   function will handle the key in the same way as the ENTER key.  i.e. all
 995: 0000: !   the visible fields on in input form are check for validity, and the key
 996: 0000: !   press is only returned to the user if the form entries are valid.
 997: 0000: !   Use this function to add the PGUP.KEY% and PGDN.KEY% keys, for example.
 998: 0000: 
 999: 0000:     FUNCTION DM.VALIDATE.KEY (KEY%) EXTERNAL                                !BSWM
1000: 0000:         INTEGER*1   DM.VALIDATE.KEY                                         !BSWM
1001: 0000:         INTEGER*2   KEY%                                                    !BSWM
1002: 0000:     END FUNCTION                                                            !BSWM
1003: 0000: 
1004: 0000: !******************************************************************************
1005: 0000: !   Returns or sets the flag which says if the screen contents have been
1006: 0000: !   changed or not.  Use this function when you have multiple pages to a
1007: 0000: !   form, but want the user to be prompted to save any changes on exit.
1008: 0000: !   When called with FLAG% set 0 or -1, the function updates the current
1009: 0000: !   displays setting.  When called with any other value, the function simply
1010: 0000: !   returns the current setting and does not update it.
1011: 0000: 
1012: 0000:     FUNCTION DM.CHANGED.FLAG (FLAG%) EXTERNAL                               !BSWM
1013: 0000:         INTEGER*1   FLAG%                                                   !BSWM
1014: 0000:         INTEGER*1   DM.CHANGED.FLAG                                         !BSWM
1015: 0000:     END FUNCTION                                                            !BSWM
1016: 0000: 
1017: 0000: !******************************************************************************
1018: 0000: !   Sets the field tab order.  The tab order can be either:
1019: 0000: !   0 - The TAB order is defined by the fields position on the display,
1020: 0000: !       left to right then top to bottom of the display.
1021: 0000: !   1 - The TAB order is defined by the number order of the fields.  This is
1022: 0000: !       a new option which allows greater control over the field TAB order.
1023: 0000: !   -1  Returns the current setting without changing it.
1024: 0000: !   The default tab order is 0.  Once set, the TAB order is a global setting
1025: 0000: !   for the current and all future screens.
1026: 0000: 
1027: 0000:     FUNCTION DM.TAB.ORDER (ORDER%) EXTERNAL                                 !DSWM
1028: 0000:         INTEGER*1   ORDER%                                                  !DSWM
1029: 0000:         INTEGER*1   DM.TAB.ORDER                                            !DSWM
1030: 0000:     END FUNCTION                                                            !DSWM
1031: 0000: 
1032: 0000: !******************************************************************************
1033: 0000: !   This function actually processes user input on the currently shown form.
1034: 0000: !   The function returns when any unrecognised key terminates input in a
1035: 0000: !   field.  The keys which will do this are determined by the properties of
1036: 0000: !   the Display Manager fields on your form.  The function internally handles
1037: 0000: !   most of the form navigation keys (e.g. Tab, Back Tab, Home End) the
1038: 0000: !   rest are up to the user application.
1039: 0000: 
1040: 0000:     FUNCTION DM.PROCESS.SCREEN (FIRST.FIELD%, LAST.FIELD%, CONFIRM) EXTERNAL
1041: 0000:         INTEGER*2   DM.PROCESS.SCREEN
1042: 0000:         INTEGER*2   FIRST.FIELD%
1043: 0000:         INTEGER*2   LAST.FIELD%
1044: 0000:         INTEGER*1   CONFIRM
1045: 0000:     END FUNCTION
1046: 0000: 
1047: 0000: !******************************************************************************
1048: 0000: !   Associates a field on the current display with a given compile time
1049: 0000: !   variable.  This allows the varibale to be used in your program code
1050: 0000: !   AND be updated by the display manager fields in PROCESS.SCREEN.
1051: 0000: !
1052: 0000: !   NOTE: PLEASE BE VERY CAREFUL WITH THE THIRD PARAMETER TO THIS SUB
1053: 0000: !   Always use an absolute variable for VARIABLE$:
1054: 0000: !       CALL DM.NAME (2, "MY.VAR$", MY.VAR$)
1055: 0000: !   NEVER use a calcualted value. These forms are all ILLEGAL:
1056: 0000: !       CALL DM.NAME (2, "MY.VAR$", "1234")
1057: 0000: !       CALL DM.NAME (2, "MY.VAR$", STR$(MY.VAR%))
1058: 0000: !   Also, if you MUST pass in an array element, for example:
1059: 0000: !       CALL DM.NAME (2, "MY.VAR$", ARRAY.ELEMENT$(I%))
1060: 0000: !   then you must make sure you do not reDIM the array until you have finished
1061: 0000: !   displaying and processing the screen.
1062: 0000: 
1063: 0000:     SUB DM.NAME (FIELD%, NAME$, VARIABLE$) EXTERNAL                         !DSWM
1064: 0000:         INTEGER*2 FIELD%                                                    !DSWM
1065: 0000:         STRING NAME$                                                        !DSWM
1066: 0000:         STRING VARIABLE$                                                    !DSWM
1067: 0000:     END SUB                                                                 !DSWM
1068: 0000: 
1069: 0000: !******************************************************************************
1070: 0000: !   Returns the index of a field on the current screen, given its name.
1071: 0000: 
1072: 0000:     FUNCTION DM.INDEX (FIELD$) EXTERNAL                                     !DSWM
1073: 0000:         STRING FIELD$                                                       !DSWM
1074: 0000:         INTEGER*2 DM.INDEX                                                  !DSWM
1075: 0000:     END FUNCTION                                                            !DSWM
1076: 0000: 
1077: 0000: !******************************************************************************
1078: 0000: !   Sets the validation expression for a field on the display.  Exactly the
1079: 0000: !   same as setting the global VALID$ array yourself, except it is done
1080: 0000: !   via the fields name as assoicated via DM.NAME.FIELD and the expression
1081: 0000: !   is in standard infix notation.
1082: 0000: 
1083: 0000:     FUNCTION DM.VALID (FIELD$, VALID$) EXTERNAL                             !DSWM
1084: 0000:         STRING FIELD$                                                       !DSWM
1085: 0000:         STRING VALID$                                                       !DSWM
1086: 0000:         INTEGER*2 DM.VALID                                                  !DSWM
1087: 0000:     END FUNCTION                                                            !DSWM
1088: 0000: 
1089: 0000: !******************************************************************************
1090: 0000: !   Sets the message expression for a field on the display.  Exactly the
1091: 0000: !   same as setting the global MESSAGE$ array yourself, except it is done
1092: 0000: !   via the fields name as assoicated via DM.NAME.FIELD and the expression
1093: 0000: !   is in standard infix notation.
1094: 0000: 
1095: 0000:     FUNCTION DM.MESSAGE (FIELD$, MESSAGE$) EXTERNAL                         !DSWM
1096: 0000:         STRING FIELD$                                                       !DSWM
1097: 0000:         STRING MESSAGE$                                                     !DSWM
1098: 0000:         INTEGER*2 DM.MESSAGE                                                !DSWM
1099: 0000:     END FUNCTION                                                            !DSWM
1100: 0000: 
1101: 0000: !******************************************************************************
1102: 0000: !   Sets the field attributes for a field on the display. Exactly the
1103: 0000: !   same as using the SETF command yourself except that it is done by
1104: 0000: !   using the fields name as associated via the DM.NAME.FIELD.
1105: 0000: 
1106: 0000: SUB DM.FLD.ATT (FIELD$, VALUE$) EXTERNAL                                    !FNWB
1107: 0000:     STRING      FIELD$                                                      !FNWB
1108: 0000:     STRING      VALUE$                                                      !FNWB
1109: 0000: END SUB                                                                     !FNWB
1110: 0000: 
1111: 0000: !******************************************************************************
1112: 0000: !   Sets an input field to act as an output only field on the display. This
1113: 0000: !   allows setting input fields that contain headings etc. to be skipped by
1114: 0000: !   the cursor movement keys.
1115: 0000: 
1116: 0000: FUNCTION DM.OO.FIELD (FIELD$) EXTERNAL                                      !FNWB
1117: 0000:     INTEGER*2   DM.OO.FIELD                                                 !FNWB
1118: 0000:     STRING      FIELD$                                                      !FNWB
1119: 0000: END FUNCTION                                                                !FNWB
1120: 0000: 
1121: 0000: !******************************************************************************
1122: 0000: !   Sets an input field back to an i/o field
1123: 0000: 
1124: 0000: FUNCTION DM.IO.FIELD (FIELD$) EXTERNAL                                      !FNWB
1125: 0000:     INTEGER*2   DM.IO.FIELD                                                 !FNWB
1126: 0000:     STRING      FIELD$                                                      !FNWB
1127: 0000: END FUNCTION                                                                !FNWB
1128: 0000: 
1129: 0000: !******************************************************************************
1130: 0000: !   Sets the visibility expression for a field on the display.  Exactly the
1131: 0000: !   same as setting the global VISIBLE$ array yourself, except it is done
1132: 0000: !   via the fields name as assoicated via DM.NAME.FIELD and the expression
1133: 0000: !   is in standard infix notation.
1134: 0000: 
1135: 0000:     FUNCTION DM.VISIBLE (FIELD$, VISIBLE$) EXTERNAL                         !DSWM
1136: 0000:         STRING FIELD$                                                       !DSWM
1137: 0000:         STRING VISIBLE$                                                     !DSWM
1138: 0000:         INTEGER*2 DM.VISIBLE                                                !DSWM
1139: 0000:     END FUNCTION                                                            !DSWM
1140: 0000: 
1141: 0000: !******************************************************************************
1142: 0000: !   Sets an error message in field 1 of the display and moves the input
1143: 0000: !   focus to the offending line of the display.  Should be called from user
1144: 0000: !   validation code.  Equivalent of the following separate calls:
1145: 0000: !       CALL DM.CURRENT.FIELD%(DM.INDEX(FIELD$))
1146: 0000: !       FIELD$(1) = POLISH$(MESSAGE$)
1147: 0000: !   Can also be called with a null field name, in which case the cursor
1148: 0000: !   remains in the current input field, but the error is displayed.
1149: 0000: 
1150: 0000:     FUNCTION DM.FOCUS (FIELD$, MESSAGE$) EXTERNAL                           !DSWM
1151: 0000:         STRING FIELD$                                                       !DSWM
1152: 0000:         STRING MESSAGE$                                                     !DSWM
1153: 0000:         INTEGER*2 DM.FOCUS                                                  !DSWM
1154: 0000:     END FUNCTION                                                            !DSWM
1155: 0000: 
1156: 0000: !******************************************************************************
1157: 0000: 
1158: 0000: 
1159: 0000:     %INCLUDE DMEXTR.J86      ! IBM DISPLAY MANAGER functions
1160: 0000: \/* TIME STAMP BLOCK **************************************************
1161: 0000: \** END OF TIME STAMP BLOCK ******************************************/
1162: 0000:  REM  INCLUDE FILE FOR  DISPLAY MANAGER EXTERNAL FUNCTIONS FOR CB80  June 7/82
1163: 0000:  REM  IR91470 01 10 91  LAB G53  marked for EFT
1164: 0000:         DEF CLRSCR EXTERNAL             REM Clear screen for Display Manager
1165: 0000:         INTEGER CLRSCR
1166: 0000:         FEND
1167: 0000:         DEF CLSDIS EXTERNAL
1168: 0000:         INTEGER CLSDIS
1169: 0000:         FEND                            REM Close Display Manager
1170: 0000:         DEF DISPD(I%) EXTERNAL          REM Display a display.
1171: 0000:         INTEGER DISPD
1172: 0000:         FEND
1173: 0000:         DEF CURS(X$) EXTERNAL           REM turn on/off cursor visibility.
1174: 0000:         STRING CURS
1175: 0000:         FEND
1176: 0000:         DEF ENDF EXTERNAL               REM ENDF method of return.
1177: 0000:         INTEGER ENDF
1178: 0000:         FEND
1179: 0000:         DEF GETF EXTERNAL               REM GETF get data from a field
1180: 0000:         STRING GETF
1181: 0000:         FEND
1182: 0000:         DEF INITDM(A$) EXTERNAL         REM INITIALIZE Display Manager
1183: 0000:         INTEGER INITDM
1184: 0000:         FEND
1185: 0000:         DEF NXTF(I%)  EXTERNAL          REM NXTF Go to Next Field
1186: 0000:         INTEGER NXTF
1187: 0000:         FEND
1188: 0000:         DEF POSF(I%) EXTERNAL           REM POSTION on Field
1189: 0000:         INTEGER POSF
1190: 0000:         FEND
1191: 0000: 
1192: 0000:         DEF OPNDIS(A$) EXTERNAL         REM OPEN DISPLAY FILE
1193: 0000:         INTEGER OPNDIS
1194: 0000:         FEND
1195: 0000:         DEF PUTF(A$)  EXTERNAL          REM PUT data to Field
1196: 0000:         INTEGER PUTF
1197: 0000:         FEND
1198: 0000:         DEF RESF(I%)  EXTERNAL          REM RESUME field
1199: 0000:         STRING RESF
1200: 0000:         FEND
1201: 0000: 
1202: 0000:         DEF RETDM  EXTERNAL             REM RETURN Display Mgr Characteristics
1203: 0000:         STRING RETDM
1204: 0000:         FEND
1205: 0000:         DEF SETF(A$) EXTERNAL           REM SET Field  video attributes
1206: 0000:         STRING SETF
1207: 0000:         FEND
1208: 0000:         DEF UPDF  EXTERNAL                      REM UPDATE Field data
1209: 0000:         STRING UPDF
1210: 0000:         FEND
1211: 0000: 
1212: 0000:         DEF RETF EXTERNAL
1213: 0000:         STRING RETF
1214: 0000:         FEND
1215: 0000:    REM  END OF INCLUDE FILE FOR DISPLAY MANAGER CALLS FOR CB80
1216: 0000: 
1217: 0000: \***********************************************************************
1218: 0000: \*
1219: 0000: \* Included code defining external Boots functions
1220: 0000: \*
1221: 0000: \***********************************************************************
1222: 0000:     %INCLUDE ADXCOPY.J86     ! To copy files
1223: 0000: \******************************************************************************
1224: 0000: \******************************************************************************
1225: 0000: \***                                                                        ***
1226: 0000: \***    %INCLUDE FOR SUBROUTINE ADXCOPYF (an I.B.M. system subroutine)      ***
1227: 0000: \***                                                                        ***
1228: 0000: \***         DATE WRITTEN  :  13th May 1988                                 ***
1229: 0000: \***                                                                        ***
1230: 0000: \******************************************************************************
1231: 0000: \******************************************************************************
1232: 0000: 
1233: 0000:    SUB  ADXCOPYF (RETC, INFILE, OUTFILE, OPT0, OPT1, OPT2) EXTERNAL
1234: 0000: 
1235: 0000:       INTEGER*4   RETC
1236: 0000:       STRING      INFILE, OUTFILE
1237: 0000:       INTEGER*2   OPT0, OPT1, OPT2
1238: 0000: 
1239: 0000:    END  SUB
1240: 0000: 
1241: 0000:     %INCLUDE ADXSERVE.J86    ! ADXSERVE function
1242: 0000: \******************************************************************************
1243: 0000: \******************************************************************************
1244: 0000: \***                                                                        ***
1245: 0000: \***    %INCLUDE FOR FUNCTION ADXSERVE (an I.B.M. system function)          ***
1246: 0000: \***                                                                        ***
1247: 0000: \***         AUTHOR        :  Bruce Scriver                                 ***
1248: 0000: \***                                                                        ***
1249: 0000: \***         DATE WRITTEN  :  14th March 1986                               ***
1250: 0000: \***                                                                        ***
1251: 0000: \***         DATE OF LAST REVISION  - 14th March 1986                       ***
1252: 0000: \***                                                                        ***
1253: 0000: \***                                                                        ***
1254: 0000: \******************************************************************************
1255: 0000: \******************************************************************************
1256: 0000: 
1257: 0000:    SUB ADXSERVE (RETURN.CODE%,                                                \
1258: 0000:                  ADX.FUNCTION%,                                               \
1259: 0000:                  ADX.PARM.1%,                                                 \
1260: 0000:                  ADX.PARM.2$)                                                 \
1261: 0000:    EXTERNAL
1262: 0000:   
1263: 0000:       STRING     ADX.PARM.2$
1264: 0000: 
1265: 0000:       INTEGER*2  ADX.FUNCTION%,                                               \
1266: 0000:                  ADX.PARM.1%
1267: 0000: 
1268: 0000:       INTEGER*4  RETURN.CODE%                                                 \
1269: 0000: 
1270: 0000:    END SUB     
1271: 0000: 
1272: 0000:     %INCLUDE BASROUT.J86     ! OSShell function
1273: 0000: \*LIB   BVEJ BASROUT  J86      03/11/97 08:16:26 PIDBLD3  *    FIX
1274: 0000: \*PROM  BVEJ BASROUT  J86      03/10/97 17:18:40 PIDBLD3  MVEJ IR34352
1275: 0000: \*RTIME BVEJ BASROUT  J86      03/10/97 17:18:41 PIDBLD3  MVEJ IR34352
1276: 0000: \*LIB   MVEJ BASROUT  J86      03/05/97 10:48:46 EDJRAL   *    IR34352
1277: 0000: \*LIB   MVEJ BASROUT  J86      02/17/97 11:19:56 EDJRAL   *    REASONAR
1278: 0000: \*LIB   MVEJ BASROUT  J86      02/14/97 15:59:11 EDJRAL   *    REASONAR
1279: 0000: ! BASROUT.J86 - this file is to be included in any BASIC code which utilizes
1280: 0000: !   the BASROUT.OBJ routines.  These routines were written
1281: 0000: !  using Metaware C and are intended to provide functions which
1282: 0000: !         are either not available in 4680 CBASIC or which can be more
1283: 0000: !               efficiently handled by the C language.  Their usage is
1284: 0000: !  offered on an "AT YOUR OWN RISK" basis.
1285: 0000: !
1286: 0000: !               The insert/extract routines usefulness may not be immediately
1287: 0000: !               apparent.  Their intention is that they be used in conjunction
1288: 0000: !               with a read/write form command.  They can more efficiently
1289: 0000: !               parse a string into many different variables than can the
1290: 0000: !               read form statement.  So instead of a long list of data var's
1291: 0000: !               it may be more efficient to just read/write one long string
1292: 0000: !               and then use the insert/extract routines to parse out the
1293: 0000: !   data.
1294: 0000: 
1295: 0000: ! ******************* SUB PROCESS FUNCTIONS *********************************
1296: 0000: 
1297: 0000: function osshell(cmd.line$) external   ! routine to start
1298: 0000:        ! another program.
1299: 0000:            integer*4    osshell    ! Upon completion of
1300: 0000:            string       cmd.line$   ! program, control is
1301: 0000:        ! returned to calling
1302: 0000: end function      ! program.
1303: 0000: !
1304: 0000: ! NOTES:  Program must be a 286 type file.  This does not exclude
1305: 0000: !         the capability to execute a batch file however.  Simply pass the
1306: 0000: !         following:
1307: 0000: !              c:\adx_spgm\command.286 batfile
1308: 0000: !         where batfile is the name of the batch file to be executed.
1309: 0000: !
1310: 0000: ! IMPORTANT: When using osshell to execute a batch file as described above,
1311: 0000: !            the final command in the batch file must be "exit".  If not,
1312: 0000: !       control is never given back to the calling program.
1313: 0000: 
1314: 0000: ! ************************ MEMORY RELATED FUNCTIONS ************************
1315: 0000: 
1316: 0000: function memfree(choice) external   ! routine to que the
1317: 0000:        ! status of the
1318: 0000:  integer*4 memfree    ! machine's memory:
1319: 0000:  integer*2 choice    ! Options:
1320: 0000:        !    1 - free
1321: 0000: end function      !    2 - total
1322: 0000:        !    3 - system
1323: 0000: 
1324: 0000: ! ********************** TIMEDATE RELATED FUNCTIONS ************************
1325: 0000: 
1326: 0000: function timedate(choice) external   ! routine to que the
1327: 0000:        ! OS's timedate table
1328: 0000:  integer*4 timedate   ! Choices:
1329: 0000:  integer*2 choice    !    1 - millisec's
1330: 0000:        !        since midnight
1331: 0000: end function      !    2 - minutes from
1332: 0000:        !  UCT (timezone)
1333: 0000:        !    3 - day of week
1334: 0000:        !   0-Sunday
1335: 0000:        !  6-Saturday
1336: 0000: 
1337: 0000: function settime(msecs) external   ! routine to set the
1338: 0000:        ! time on the controller
1339: 0000:  integer*4  settime    ! msecs is the desired
1340: 0000:  integer*4 msecs    ! number of milliseconds
1341: 0000:        ! since midnight
1342: 0000: end function      ! Returns negative on
1343: 0000:        ! error
1344: 0000: ! NOTE:  This routine sets the time only on the controller.  The terminals'
1345: 0000: ! time will not be updated until 1 AM or unless a terminal is STC'd.
1346: 0000: ! At 1 AM the controller broadcasts the new time to all terminals.
1347: 0000: ! Insure this is taken into consideration when using this routine.
1348: 0000: 
1349: 0000: !******************** DISK FILE RELATED FUNCTIONS *************************
1350: 0000: 
1351: 0000: function truncate(name,length) external   ! routine to truncate
1352: 0000:        ! the specified file
1353: 0000:  integer*4 truncate   ! to a given length.
1354: 0000:  string  name
1355: 0000:  integer*4 length
1356: 0000: 
1357: 0000: end function
1358: 0000: 
1359: 0000: !******************** STRING VALUE RELATED FUNCTIONS **********************
1360: 0000: 
1361: 0000: function isalpha(bstrn) external   ! routine to identify
1362: 0000:        ! if the specified
1363: 0000:  integer*1 isalpha    ! string contains all
1364: 0000:  string  bstrn    ! alphabetic char's
1365: 0000:        ! Returns:
1366: 0000: end function      !     0 - all alpha
1367: 0000:        !     X - byte of 1st
1368: 0000:        !         non-alpha
1369: 0000:        !   char
1370: 0000: 
1371: 0000: function isdigit(bstrn) external   ! routine to identify
1372: 0000:        ! if the specified
1373: 0000:  integer*1 isdigit    ! string contains all
1374: 0000:  string  bstrn    ! numeric char's
1375: 0000:        ! Returns:
1376: 0000: end function      !     0 - all numeric
1377: 0000:        !     X - byte of 1st
1378: 0000:        !         non-numeric
1379: 0000:        !   char
1380: 0000: 
1381: 0000: function islower(bstrn) external   ! routine to identify
1382: 0000:        ! if the specified
1383: 0000:  integer*1 islower    ! string contains all
1384: 0000:  string  bstrn    ! lower case char's
1385: 0000:        ! Returns:
1386: 0000: end function      !     0 - all lowercase
1387: 0000:        !     X - byte of 1st
1388: 0000:        !         non-lowercase
1389: 0000:        !   char
1390: 0000: 
1391: 0000: function isupper(bstrn) external   ! routine to identify
1392: 0000:        ! if the specified
1393: 0000:  integer*1 isupper    ! string contains all
1394: 0000:  string  bstrn    ! upper case char's
1395: 0000:        ! Returns:
1396: 0000: end function      !     0 - all uppercase
1397: 0000:        !     X - byte of 1st
1398: 0000:        !         non-uppercase
1399: 0000:        !   char
1400: 0000: 
1401: 0000: function toalpha(bstrn) external   ! routine to convert
1402: 0000:        ! non-alpha or non-num
1403: 0000:    integer*2 toalpha    ! char's to spaces
1404: 0000:  string  bstrn    ! Returns:
1405: 0000: end function      !   x - no. of char's
1406: 0000:        !       changed
1407: 0000: 
1408: 0000: ! ********************* USER/GROUP ZERO LEVEL FUNCTIONS *********************
1409: 0000: 
1410: 0000: function idlecount(choice) external   ! routine to either
1411: 0000:        ! set to zero or queue
1412: 0000:  integer*4 idlecount   ! the value of the
1413: 0000:  integer*1 choice    ! processor's idlecount
1414: 0000:        ! Choice:
1415: 0000: end function      !     0 - set to zero
1416: 0000: !       !     1 - get value
1417: 0000: ! NEEDS USER/GROUP 0 LEVEL OF AUTHORIZATION  ! Returns:
1418: 0000: ! TO WORK - This level is not available unless  !     X - idlecount
1419: 0000: ! the file ADXCSOUF.DAT file is "patched".  This !    -X - error code
1420: 0000: ! is highly unrecommended.
1421: 0000: 
1422: 0000: function logical(actname,logname,choice) external ! routine to set a
1423: 0000:        ! a logical name.
1424: 0000:  integer*4 logical    ! parms are self
1425: 0000:         string  logname    ! explanatory except
1426: 0000:  string  actname    ! for choice:
1427: 0000:  integer*1 choice    !   0 - set process
1428: 0000:        !   1 - set system
1429: 0000: end function      !   2 - get process
1430: 0000:        !   3 - get system
1431: 0000: 
1432: 0000: ! NOTE:  Only the setting of a system level of logical name requires
1433: 0000: ! user/group zero level of authorization.  Any application may query any
1434: 0000: ! logical name.  Setting of a system logical name is only applicable until
1435: 0000: ! the system is IPL'd.  A process logical name is only active when that
1436: 0000: ! process is active.
1437: 0000: 
1438: 0000: !******************** STRING PARSING FUNCTIONS *****************************
1439: 0000: 
1440: 0000: function inserts(whole,part,offset) external  ! routine to insert a
1441: 0000:        ! string (part) into
1442: 0000:  integer*2 INSERTS    ! another string (whole)
1443: 0000:  string  whole    ! starting at specified
1444: 0000:  string  part    ! character (offset)
1445: 0000:  integer*2 offset
1446: 0000: 
1447: 0000: end function
1448: 0000: 
1449: 0000: function cinsert4(integer4,bstring,offset) external   ! routine to insert
1450: 0000:        ! a 4-byte integer into
1451: 0000:  integer*1 cinsert4   ! a string starting at
1452: 0000:  integer*4 integer4   ! byte specified by
1453: 0000:  string  bstring    ! offset (1-based)
1454: 0000:  integer*2 offset    ! Returns:
1455: 0000:        !     0 - Success
1456: 0000: end function      !    -1 - String overrun
1457: 0000: 
1458: 0000: function cinsert2(integer2,bstring,offset) external  ! routine to insert
1459: 0000:        ! a 2-byte integer into
1460: 0000:  integer*1 cinsert2   ! a string starting at
1461: 0000:  integer*2 integer2   ! byte specified by
1462: 0000:  string  bstring    ! offset (1-based)
1463: 0000:  integer*2 offset    ! Returns:
1464: 0000:        !     0 - Success
1465: 0000: end function      !    -1 - String overrun
1466: 0000: 
1467: 0000: function cinsert1(bstring,integer1,offset) external  ! routine to insert
1468: 0000:        ! a 1-byte integer into
1469: 0000:  integer*1 cinsert1   ! a string starting at
1470: 0000:  integer*1 integer1   ! byte specified by
1471: 0000:  string  bstring    ! offset (1-based)
1472: 0000:  integer*2 offset    ! Returns:
1473: 0000:        !     0 - Success
1474: 0000: end function      !    -1 - String overrun
1475: 0000: 
1476: 0000: function extracts(whole,part,offset) external  ! routine to extract a
1477: 0000:        ! string (part) from
1478: 0000:  integer*2 EXTRACTS   ! another string (whole)
1479: 0000:  string  whole    ! starting at specified
1480: 0000:  string  part    ! character (offset)
1481: 0000:  integer*2 offset
1482: 0000: 
1483: 0000: end function
1484: 0000: 
1485: 0000: function cextract4(bstring,offset) external  ! routine to extract
1486: 0000:        ! a 4-byte integer from
1487: 0000:  integer*4 cextract4   ! a string starting at
1488: 0000:                        ! byte specified by
1489: 0000:  string  bstring    ! offset (1-based)
1490: 0000:  integer*2 offset    ! Returns:
1491: 0000:        !     X - 4 byte integer
1492: 0000: end function      !    -1 - String overrun
1493: 0000: 
1494: 0000: function cextract2(bstring,offset) external  ! routine to extract
1495: 0000:        ! a 2-byte integer from
1496: 0000:  integer*2 cextract2   ! a string starting at
1497: 0000:                        ! byte specified by
1498: 0000:  string  bstring    ! offset (1-based)
1499: 0000:  integer*2 offset    ! Returns:
1500: 0000:        !     X - 2 byte integer
1501: 0000: end function      !    -1 - String overrun
1502: 0000: 
1503: 0000: function cextract1(bstring,offset) external  ! routine to extract
1504: 0000:        ! a 1-byte integer from
1505: 0000:  integer*1 cextract1   ! a string starting at
1506: 0000:                        ! byte specified by
1507: 0000:  string  bstring    ! offset (1-based)
1508: 0000:  integer*2 offset    ! Returns:
1509: 0000:        !     X - 1 byte integer
1510: 0000: end function      !    -1 - String overrun
1511: 0000: 
1512: 0000: 
1513: 0000: function srchdir (file.name$,dtbl.buffer$) external ! routine to return
1514: 0000:        ! file names and sizes
1515: 0000:        ! Return values:
1516: 0000:        !    -1  no matches
1517: 0000:        !        found on first
1518: 0000:        !        call
1519: 0000:        !    0   no matches
1520: 0000:        !        found on sub-
1521: 0000:        !        sequent calls
1522: 0000:        !    Pos Success
1523: 0000:        !    Neg OS Rtn Code
1524: 0000: ! Usage Note:  If searching for all occurences of a particular file name,
1525: 0000: ! first initialize dtbl.buffer$ to 48 Nulls (pack$("00")) and issue a call
1526: 0000: ! to srchdir.  If any matches are found, a positive value will be returned.
1527: 0000: ! To see if any more matches exist, just issue another call to srchdir without
1528: 0000: ! resetting the values of dtbl.buffer$.  If any are found, a positive value
1529: 0000: ! will be returned.  This can be repeated until a Zero is returned.  All data
1530: 0000: ! describing file will be returned in the dtbl.buffer$ after each call.  Format
1531: 0000: ! of this data is defined below.
1532: 0000: 
1533: 0000:  integer*4 srchdir
1534: 0000: 
1535: 0000:  string  file.name$   ! file name to start
1536: 0000:        ! search (18 bytes max)
1537: 0000:        ! Wild cards and logical
1538: 0000:        ! names supported.
1539: 0000: 
1540: 0000:  string  dtbl.buffer$   ! must be initialized
1541: 0000:        ! to 48 bytes.  Contains
1542: 0000:        ! all of directory info
1543: 0000:        ! Initialize to nulls
1544: 0000:        ! each time a new file
1545: 0000:        ! name is used.
1546: 0000: 
1547: 0000: ! NOTE:  Format of dtbl.buffer$ string is as follows:
1548: 0000: !
1549: 0000: ! Offs  Type                    Description Notes
1550: 0000: !  0 integer*4  key  use extract4 to access
1551: 0000: !  4  string (18 bytes) file name
1552: 0000: ! 22 integer*2  attributes use extract2 to access
1553: 0000: !      0x01 - Read Only
1554: 0000: !      0x02 - Hidden
1555: 0000: !      0x04 - System
1556: 0000: !      0x08 - Volume Label
1557: 0000: !      0x10 - Subdirectory
1558: 0000: !      0x20 - Archive (Files)
1559: 0000: !      0x40 - Security enabled
1560: 0000: !      0x80 - Reserved
1561: 0000: !      0x0000 - Local
1562: 0000: !      0x4000 - Mirrored/Update
1563: 0000: !      0xC000 - Mirrored/Close
1564: 0000: !
1565: 0000: !      0x6000 - Compound/Update
1566: 0000: !      0xE000 - Compound/Close
1567: 0000: ! 24 integer*2  record size use extract2 to access
1568: 0000: ! 26 integer*1  User ID of Owner
1569: 0000: ! 27 integer*1  Group ID of Owner
1570: 0000: ! 28 integer*2  File Security
1571: 0000: ! 30 string (6 bytes) Reserved
1572: 0000: ! 36 integer*4  File Size use extract4 to access
1573: 0000: ! 40 integer*2  Year  use extract2 to access
1574: 0000: ! 42 integer*1  Month
1575: 0000: ! 43 integer*1  Day
1576: 0000: ! 44 integer*1  Hour
1577: 0000: ! 45 integer*1  Minute
1578: 0000: ! 46 integer*1  Second
1579: 0000: ! 47 integer*1  Reserved
1580: 0000: 
1581: 0000: end function
1582: 0000: 
1583: 0000: function srchproc (proc.name$,ptbl.buffer$) external ! routine to return
1584: 0000:        ! process names and
1585: 0000:        ! status.  Handy to
1586: 0000:        ! determine if a
1587: 0000:        ! program is currently
1588: 0000:        ! running.
1589: 0000:        ! Return values:
1590: 0000:        !    -1  no matches
1591: 0000:        !        found on first
1592: 0000:        !        call
1593: 0000:        !    0   no matches
1594: 0000:        !        found on sub-
1595: 0000:        !        sequent calls
1596: 0000:        !    Pos Success
1597: 0000:        !    Neg Failure
1598: 0000:        !        OS Rtn Code
1599: 0000:        ! 80000001h - Insuff
1600: 0000:         !        ptbl buffer
1601: 0000:        !        Length
1602: 0000: ! Usage Note:  If searching for all occurences of a particular process name,
1603: 0000: ! first initialize ptbl.buffer$ to 60 Nulls (pack$("00")) and issue a call
1604: 0000: ! to srchproc.  If any matches are found, a positive value will be returned.
1605: 0000: ! To see if any more matches exist, just issue another call to srchproc without
1606: 0000: ! resetting the values of ptbl.buffer$.  If any are found, a positive value
1607: 0000: ! will be returned.  This can be repeated until a Zero is returned.  All data
1608: 0000: ! describing file will be returned in the ptbl.buffer$ after each call.  Format
1609: 0000: ! of this data is defined as follows:
1610: 0000: !
1611: 0000: !       --------------------------------------------------------
1612: 0000: !   0   |                         PID                          |
1613: 0000: !       --------------------------------------------------------
1614: 0000: !   4   |           FID             |   CID        |   VCID    |
1615: 0000: !       --------------------------------------------------------
1616: 0000: !   8   |                         NAME                         |
1617: 0000: !       --------------------------------------------------------
1618: 0000: !  12   |                         NAME cont'd                  |
1619: 0000: !       --------------------------------------------------------
1620: 0000: !  16   |       NAME cont'd         |   STATE      |  PRIOR    |
1621: 0000: !       --------------------------------------------------------
1622: 0000: !  20   |                         MAXMEM                       |
1623: 0000: !       --------------------------------------------------------
1624: 0000: !  24   |       FLAGS               |   USER        |  GROUP   |
1625: 0000: !       --------------------------------------------------------
1626: 0000: !  28   |                         PARENT                       |
1627: 0000: !       --------------------------------------------------------
1628: 0000: !  32   |                         EVENTS                       |
1629: 0000: !       --------------------------------------------------------
1630: 0000: !  36   |                         CODE                         |
1631: 0000: !       --------------------------------------------------------
1632: 0000: !  40   |                         CSIZE                        |
1633: 0000: !       --------------------------------------------------------
1634: 0000: !  44   |                         DATA                         |
1635: 0000: !       --------------------------------------------------------
1636: 0000: !  48   |                         DSIZE                        |
1637: 0000: !       --------------------------------------------------------
1638: 0000: !  52   |                         HEAP                         |
1639: 0000: !       --------------------------------------------------------
1640: 0000: !  56   |                         HSIZE                        |
1641: 0000: !       --------------------------------------------------------
1642: 0000: !
1643: 0000: !       PID   Process ID
1644: 0000: !       FID  Process's Family ID
1645: 0000: !       CID   Physical Console Device Number
1646: 0000: !       VCID  Process's Virtual Console Number
1647: 0000: !       NAME  Process Name (Application Running)
1648: 0000: ! STATE    Process State (0-Run, 1-Waiting, 2-Terminating)
1649: 0000: ! PRIOR    Priority
1650: 0000: !       MAXMEM  Maximum Memory Allowed
1651: 0000: !       FLAGS  Bit 0 (1-System Process, 0-User Process)
1652: 0000: !   Bit 1 (1-Locked in Memory, 0-Swappable)
1653: 0000: !   Bit 2 (1-Running in SWI context, 0-Running in main context)
1654: 0000: !   Bit 3 (1-Superuser Process,0-Not a Superuser Process)
1655: 0000: ! USER  User Number
1656: 0000: ! GROUP  Group Number
1657: 0000: !       PARENT   Parent Process ID
1658: 0000: !       EVENTS   Bit Map of events that have completed but not retrieved
1659: 0000: !       CODE  Start of code area in user space
1660: 0000: ! CSIZE  Size in bytes of code area
1661: 0000: !       DATA  Start of data area in user space
1662: 0000: ! DSIZE  Size in bytes of data area
1663: 0000: !       HEAP  Start of heap area in user space
1664: 0000: ! HSIZE  Size in bytes of heap area
1665: 0000: !
1666: 0000:  integer*4 srchproc
1667: 0000: 
1668: 0000:  string  proc.name$   ! process name to start
1669: 0000:        ! search (10 bytes max)
1670: 0000:        ! Wild cards and logical
1671: 0000:        ! names supported.
1672: 0000: 
1673: 0000:  string  ptbl.buffer$   ! must be initialized
1674: 0000:        ! to 60 bytes.  Contains
1675: 0000:        ! all of process info
1676: 0000:        ! Initialize to nulls
1677: 0000:        ! each time a new
1678: 0000:        ! process name is used.
1679: 0000: 
1680: 0000: end function
1681: 0000: 
1682: 0000: function cconstat(timeout) external       ! function similar
1683: 0000:                                               ! to BASIC constat%
1684: 0000:  integer*2 cconstat   ! waits for either a
1685: 0000:  integer*4 timeout    ! key being hit or
1686: 0000:        ! the timer expiring
1687: 0000:        ! before returning
1688: 0000:        ! returns:
1689: 0000:        !   -1 error
1690: 0000:        !    0 timer expired
1691: 0000:        !    x scan code of
1692: 0000:        !      key hit
1693: 0000: end function
1694: 0000: 
1695: 0000: function disksize(disk.name$) external   ! function to find
1696: 0000:        ! the total size of
1697: 0000:  integer*4 disksize   ! the specified disk
1698: 0000:  string  disk.name$   ! name (e.g. "h0:")
1699: 0000:        ! if return value is
1700: 0000:        ! negative, error
1701: 0000: end function      ! was received
1702: 0000: 
1703: 0000: 
1704: 0000:     %INCLUDE BTCSTR.J86      ! String functions
1705: 0000: !********************************************************************
1706: 0000: !***
1707: 0000: !***    INCLUDED CODE:  BTCSTR.J86
1708: 0000: !***    AUTHOR:         Stuart William McConnachie
1709: 0000: !***    DATE:           26th February 2006
1710: 0000: !***
1711: 0000: !********************************************************************
1712: 0000: !***
1713: 0000: !***    Controller CBASIC String Functions
1714: 0000: !***
1715: 0000: !********************************************************************
1716: 0000: 
1717: 0000: !Swaps to CBASIC strings
1718: 0000: SUB SWAPSTR (S1$, S2$) EXTERNAL
1719: 0000:     STRING S1$, S2$
1720: 0000: END SUB
1721: 0000: 
1722: 0000: !Left trim a string of spaces
1723: 0000: SUB LTRIM (S$) EXTERNAL
1724: 0000:     STRING S$
1725: 0000: END SUB
1726: 0000: 
1727: 0000: !Right trim a string of spaces
1728: 0000: SUB RTRIM (S$) EXTERNAL
1729: 0000:     STRING S$
1730: 0000: END SUB
1731: 0000: 
1732: 0000: !Left and right trim a string of spaces
1733: 0000: SUB TRIM (S$) EXTERNAL
1734: 0000:     STRING S$
1735: 0000: END SUB
1736: 0000: 
1737: 0000: !Left trim a string of a given ASCII character
1738: 0000: SUB LTRIMC (S$, C%) EXTERNAL
1739: 0000:     STRING S$
1740: 0000:     INTEGER*1 C%
1741: 0000: END SUB
1742: 0000: 
1743: 0000: !Right trim a string of a given ASCII character
1744: 0000: SUB RTRIMC (S$, C%) EXTERNAL
1745: 0000:     STRING S$
1746: 0000:     INTEGER*1 C%
1747: 0000: END SUB
1748: 0000: 
1749: 0000: !Left and right trim a string of a given ASCII character
1750: 0000: SUB TRIMC (S$, C%) EXTERNAL
1751: 0000:     STRING S$
1752: 0000:     INTEGER*1 C%
1753: 0000: END SUB
1754: 0000: 
1755: 0000: !Insert one string into another
1756: 0000: FUNCTION SUBSTR(S1$, O1%, S2$, O2%, L2%) EXTERNAL
1757: 0000:     STRING    S1$, S2$
1758: 0000:     INTEGER*2 O1%, O2%, L2%
1759: 0000:     INTEGER*1 SUBSTR
1760: 0000: END FUNCTION
1761: 0000:     
1762: 0000:     %INCLUDE CMPDATE.J86     ! Compare date utility
1763: 0000: !********************************************************************
1764: 0000: !***
1765: 0000: !***    INCLUDED CODE:  CMPDATE.J86
1766: 0000: !***    AUTHOR:         Stuart William McConnachie
1767: 0000: !***    DATE:           27th January 1997
1768: 0000: !***
1769: 0000: !********************************************************************
1770: 0000: !***   
1771: 0000: !***    Version B            Nik Sen                 30th March 1998
1772: 0000: !***    Changes to cope with a date of '000000' by replacing it with
1773: 0000: !***    '850101' before comparison. An all zero's date is valid in 
1774: 0000: !***    certain date fields and CMPDATE was returning the wrong result
1775: 0000: !***    when comparing with an actual date. Also change to cope with
1776: 0000: !***    dates of '999999' as some date fields are initialised to this
1777: 0000: !***    as a high value.
1778: 0000: !***
1779: 0000: !***    Version C    Stuart William McConnachie   20th December 1999
1780: 0000: !***    Improved function efficiency by changing tests for high and
1781: 0000: !***    low values, added above, to integers (rather than strings).
1782: 0000: !***    Also, using 850101 as a replacement for 000000, will not give
1783: 0000: !***    valid results after 350101 because of the 50 year wrap, so
1784: 0000: !***    corrected this.
1785: 0000: !***
1786: 0000: !***    Version D.  Stuart William McConnachie    26th February 2006
1787: 0000: !***    Place this code in it's own module in FUNLIB.  Make all
1788: 0000: !***    the functions herein EXTERNAL accordingly.
1789: 0000: !***
1790: 0000: !********************************************************************
1791: 0000: !***    
1792: 0000: !***    The following functions compare dates, checking for
1793: 0000: !***    century boundries.  Dates in the 50 years prior to the
1794: 0000: !***    compared date are less than the compared date, dates in
1795: 0000: !***    50 years after the compared date are greater than the
1796: 0000: !***    compared date.
1797: 0000: !***    Can handle dates in both packed and unpacked formats, or
1798: 0000: !***    a mixture of both.
1799: 0000: !***    In the case of a error, for example IH after detecting
1800: 0000: !***    illegal characters in VAL, the functions default to
1801: 0000: !***    comparing strings without testing for a change of century.
1802: 0000: !***
1803: 0000: !***    DATE.GT(DATE1$, DATE2$)  same as  DATE1$ >  DATE2$
1804: 0000: !***    DATE.GE(DATE1$, DATE2$)  same as  DATE1$ >= DATE2$
1805: 0000: !***    DATE.LT(DATE1$, DATE2$)  same as  DATE1$ <  DATE2$
1806: 0000: !***    DATE.LE(DATE1$, DATE2$)  same as  DATE1$ <= DATE2$
1807: 0000: !***
1808: 0000: !********************************************************************
1809: 0000: 
1810: 0000: FUNCTION DATE.GT(DATE1$, DATE2$) EXTERNAL                               !DSWM
1811: 0000:     STRING    DATE1$, DATE2$
1812: 0000:     INTEGER*1 DATE.GT
1813: 0000: END FUNCTION
1814: 0000: 
1815: 0000: 
1816: 0000: FUNCTION DATE.GE(DATE1$, DATE2$) EXTERNAL                               !DSWM
1817: 0000:     STRING    DATE1$, DATE2$
1818: 0000:     INTEGER*1 DATE.GE
1819: 0000: END FUNCTION
1820: 0000: 
1821: 0000: 
1822: 0000: FUNCTION DATE.LT(DATE1$, DATE2$) EXTERNAL                               !DSWM
1823: 0000:     STRING    DATE1$, DATE2$
1824: 0000:     INTEGER*1 DATE.LT
1825: 0000: END FUNCTION
1826: 0000: 
1827: 0000: 
1828: 0000: FUNCTION DATE.LE(DATE1$, DATE2$) EXTERNAL                               !DSWM
1829: 0000:     STRING    DATE1$, DATE2$
1830: 0000:     INTEGER*1 DATE.LE
1831: 0000: END FUNCTION
1832: 0000: 
1833: 0000:     %INCLUDE ERRNH.J86       ! Converts ERRN to 8-byte ASCII string
1834: 0000: \******************************************************************************
1835: 0000: \***
1836: 0000: \***	FUNCTION ERRNH
1837: 0000: \***
1838: 0000: \***	Convert the 4-byte error number to an 8-byte ASCII string
1839: 0000: \***
1840: 0000: \******************************************************************************
1841: 0000: 
1842: 0000: 	FUNCTION ERRNH PUBLIC
1843: 0024: 
1844: 0024: 	STRING			ERRNH,					\
1845: 0024: 				E$
1846: 0024: 
1847: 0024: 	INTEGER*2		I%
1848: 0024: 	INTEGER*4		H%
1849: 0024: 
1850: 0024: 	E$ = ""
1851: 0039: 	H% = ERRN
1852: 0053: 
1853: 0053: 	FOR I% = 28 TO 0 STEP -4
1854: 0063: 	    E$ = E$ + CHR$((SHIFT(H%,I%) AND 000FH) + 48)
1855: 00bf: 	NEXT I%
1856: 00d7: 
1857: 00d7: 	ERRNH = TRANSLATE$(E$,":;<=>?","ABCDEF")
1858: 00fe: 
1859: 00fe: 	END FUNCTION
1860: 0117:     %INCLUDE SLPCFEXT.J86    ! Sleeper control
1861: 0117: \*****************************************************************************
1862: 0117: \*****************************************************************************
1863: 0117: \***
1864: 0117: \***         FUNCTION DEFINITIONS FOR SLEEPER CHECK FILE
1865: 0117: \***
1866: 0117: \***                    REFERENCE : slpcfexa.J86
1867: 0117: \***
1868: 0117: \***    Version A           Steve Windsor          8.2.93
1869: 0117: \***
1870: 0117: \***    Version B           Richard Foster         8.7.93
1871: 0117: \***  
1872: 0117: \*****************************************************************************
1873: 0117: \*****************************************************************************
1874: 0117: 
1875: 0117:    FUNCTION SLPCF.SET EXTERNAL
1876: 0117:    END FUNCTION
1877: 0117: 
1878: 0117:   FUNCTION READ.SLPCF EXTERNAL
1879: 0117:    INTEGER*2 READ.SLPCF
1880: 0117:   END FUNCTION
1881: 0117: 
1882: 0117:   FUNCTION WRITE.SLPCF EXTERNAL
1883: 0117:    INTEGER*2 WRITE.SLPCF
1884: 0117:   END FUNCTION
1885: 0117: 
1886: 0117: 
1887: 0117: \***********************************************************************
1888: 0117: \*
1889: 0117: \* OPEN.SEQUENTIAL.FILE : External C file function helps in opening
1890: 0117: \*                        a sequential file as BASIC does not support
1891: 0117: \*                        this when running under Supplemental Mode.
1892: 0117: \*
1893: 0117: \***********************************************************************
1894: 0117: FUNCTION FUNC.OPEN.SEQUENTIAL.FILE( FILE.NAME$ ) EXTERNAL               !CJK
1895: 0117:     INTEGER*4 FUNC.OPEN.SEQUENTIAL.FILE                                 !CJK
1896: 0117:     STRING FILE.NAME$
1897: 0117: END FUNCTION
1898: 0117: 
1899: 0117: \***********************************************************************
1900: 0117: \*
1901: 0117: \* READ.SEQUENTIAL.FILE : External C file function helps in reading
1902: 0117: \*                        a sequential file as BASIC does not support
1903: 0117: \*                        this when running under Supplemental Mode.
1904: 0117: \*
1905: 0117: \***********************************************************************
1906: 0117: FUNCTION FUNC.READ.SEQUENTIAL.FILE( FILE.HANDLE% ) EXTERNAL             !CJK
1907: 0117:     STRING FUNC.READ.SEQUENTIAL.FILE                                    !CJK
1908: 0117:     INTEGER*4 FILE.HANDLE%
1909: 0117: END FUNCTION
1910: 0117: 
1911: 0117: \***********************************************************************
1912: 0117: \*
1913: 0117: \* WRITE.SEQUENTIAL.FILE : External C file function helps in writing
1914: 0117: \*                         a sequential file as BASIC does not support
1915: 0117: \*                         this when running under Supplemental Mode.
1916: 0117: \*
1917: 0117: \***********************************************************************
1918: 0117: FUNCTION FUNC.WRITE.SEQUENTIAL.FILE(FILE.HANDLE%, FILE.RECORD$) EXTERNAL!CJK
1919: 0117:     INTEGER*4 FUNC.WRITE.SEQUENTIAL.FILE                                !CJK
1920: 0117:     INTEGER*4 FILE.HANDLE%
1921: 0117:     STRING FILE.RECORD$
1922: 0117: END FUNCTION
1923: 0117: 
1924: 0117: \***********************************************************************
1925: 0117: \*
1926: 0117: \* CLOSE.FILE : External C file function helps in closing a file as
1927: 0117: \*              BASIC does not support this when running under
1928: 0117: \*              Supplemental Mode.
1929: 0117: \*
1930: 0117: \***********************************************************************
1931: 0117: FUNCTION FUNC.CLOSE.FILE ( FILE.HANDLE% ) EXTERNAL                      !CJK
1932: 0117:     INTEGER*4 FILE.HANDLE%
1933: 0117: END FUNCTION
1934: 0117: 
1935: 0117: 
1936: 0117: \***********************************************************************
1937: 0117: \*
1938: 0117: \*    FUNC.DIR.NOT.EXISTS: This function checks the existence of given
1939: 0117: \*                         directory by using CHDIR command.
1940: 0117: \*
1941: 0117: \***********************************************************************
1942: 0117: FUNCTION FUNC.DIR.NOT.EXISTS(DIRECTORY.NAME$) EXTERNAL
1943: 0117:     INTEGER*1 FUNC.DIR.NOT.EXISTS
1944: 0117:     STRING    DIRECTORY.NAME$
1945: 0117: END FUNCTION
1946: 0117: 
1947: 0117: \***********************************************************************
1948: 0117: \*
1949: 0117: \*    FUNC.FILE.EXISTS: This function checks the existence of
1950: 0117: \*                      passed file by using SIZE function.
1951: 0117: \*
1952: 0117: \***********************************************************************
1953: 0117: FUNCTION FUNC.FILE.EXISTS(FILE.NAME$) EXTERNAL
1954: 0117:     STRING    FILE.NAME$
1955: 0117:     INTEGER*1 FUNC.FILE.EXISTS
1956: 0117: END FUNCTION
1957: 0117: 
1958: 0117: \***********************************************************************
1959: 0117: \*
1960: 0117: \* PROCESS.DAY.DIR.SCREEN: This Sub-Program does all the necessary
1961: 0117: \*                         actions needed for directory restore
1962: 0117: \*                         processing including screen navigation.
1963: 0117: \*
1964: 0117: \*                         It receives the directory values as an input.
1965: 0117: \*
1966: 0117: \* As a program modularisation, Directory restore has been made as a
1967: 0117: \* Sub-program to perform all the Directory restore functionalities
1968: 0117: \* within itself. This enables quick extraction from the main module
1969: 0117: \* should breach the 64k limit
1970: 0117: \*
1971: 0117: \***********************************************************************
1972: 0117: SUB SUB.PROCESS.DAY.DIR.SCREEN(IMG.FILE$, ALT.FILE$) PUBLIC
1973: 013b: 
1974: 013b:     STRING              \
1975: 013b:         ALT.FILE$,      \
1976: 013b:         IMG.FILE$
1977: 013b: 
1978: 013b:     GOSUB SHOW.DIRECTORIES
1979: 014d: 
1980: 014d:     ! Directory restore day selection screen and status screen
1981: 014d:     WHILE SCREEN% = DIRECTORY.DAY.SELECT.SCR% OR \
1982: 0158:           SCREEN% = DIRECTORY.PROCESS.SCR%
1983: 0158: 
1984: 0158:         ! If day selection screen
1985: 0158:         IF SCREEN% = DIRECTORY.DAY.SELECT.SCR% THEN BEGIN
1986: 0173: 
1987: 0173:             ! If the screen is accessed using F3 or ESC
1988: 0173:             IF PREVIOUS.KEY THEN BEGIN
1989: 0185:                 GOSUB SHOW.DIRECTORIES
1990: 0197:                 PREVIOUS.KEY = FALSE
1991: 01ad:             ENDIF
1992: 01b5: 
1993: 01b5:             RET.KEY% = DM.PROCESS.SCREEN (2, 105, TRUE)
1994: 01d9: 
1995: 01d9:             IF (RET.KEY% = ESC.KEY%) OR (RET.KEY% = F3.KEY%) THEN BEGIN
1996: 020d: 
1997: 020d:                 SCREEN%      = RESTORE.A.DIRECTORY.SCR%
1998: 0223:                 PREVIOUS.KEY = TRUE
1999: 023c: 
2000: 023c:             ENDIF ELSE BEGIN
2001: 0244:                 IF VALUE.INDEX% = XRE.ZERO% THEN BEGIN                  !CJK
2002: 025d:                     CALL DM.FOCUS ("1", STATUS.TEXT.ERROR$(21) + \      !CJK
2003: 02ad:                                         STATUS.TEXT.MSG$(58))           !CJK
2004: 02ad:                 ENDIF ELSE BEGIN                                        !CJK
2005: 02b5:                     IF RET.KEY% = ENTER.KEY% THEN BEGIN
2006: 02cd: 
2007: 02cd:                         ! Check the entry in day selection screen
2008: 02cd:                         SCREEN.NUM% = DIRECTORY.PROCESS.SCR%
2009: 02e3:                         GOSUB CHECK.DAY.SELECTION
2010: 02f5: 
2011: 02f5:                         ! If any error in function, set same screen
2012: 02f5:                         IF NOT FUNCTION.ERROR.NOT.EXIST THEN BEGIN
2013: 0307:                             SCREEN% = DIRECTORY.DAY.SELECT.SCR%
2014: 031d:                         ENDIF
2015: 0327: 
2016: 0327:                     ENDIF ELSE BEGIN
2017: 032f:                         ! B001 Invalid key pressed
2018: 032f:                         CALL DM.FOCUS ("1", STATUS.TEXT.ERROR$(20))
2019: 035a:                     ENDIF
2020: 0362:                 ENDIF
2021: 036a:             ENDIF
2022: 0374: 
2023: 0374:         ! Directory restore status screen
2024: 0374:         ENDIF ELSE IF SCREEN% = DIRECTORY.PROCESS.SCR% THEN BEGIN
2025: 038c:             GOSUB SHOW.PROCESS.DIRECTORY
2026: 039e:         ENDIF
2027: 03a6:     WEND
2028: 03dd: 
2029: 03dd: EXIT SUB
2030: 03e8: 
2031: 03e8: \***********************************************************************
2032: 03e8: \*
2033: 03e8: \* SHOW.DIRECTORIES: This Routine displays the directories
2034: 03e8: \*
2035: 03e8: \***********************************************************************
2036: 03e8: SHOW.DIRECTORIES:
2037: 03f8: 
2038: 03f8:     ! Setting the Header and other variables used for screen display
2039: 03f8:     SCR.HEADER$   = SCREEN.TEXT.MSG$(1)
2040: 0422:     OPT.SELECTED$ = SCREEN.TEXT.MSG$(2) + SCREEN.TEXT.MSG$(3)
2041: 0466:     OPT.HEADER.1$ = SCREEN.TEXT.MSG$(4)                  + \            !CJK
2042: 04c6:                     BKPSCRPT.DIRECTORIES$(SELECT.INDEX%) + \            !CJK
2043: 04c6:                     SCREEN.TEXT.MSG$(5)
2044: 04c6:     OPT.HEADER$   = SCREEN.TEXT.MSG$(6)
2045: 04f0: 
2046: 04f0:     CALL DM.SHOW.SCREEN(2, SCR.HEADER$, 5, 5)
2047: 0511: 
2048: 0511:     ! Setting the XRE value which will be displayed in the Left corner
2049: 0511:     SCREEN.NUM$ = "06"
2050: 0528: 
2051: 0528:     ! Dimensioning array
2052: 0528:     DIM DAY.ARRAY$(ARRAY.LIMIT%)                                        !CJK
2053: 055c:     DIM BKP.AVAIL.ARRAY$(ARRAY.LIMIT%)                                  !CJK
2054: 0590: 
2055: 0590:     ! Setting the values to get the backup details                      !CJK
2056: 0590:     FIRST.FILE$  = IMG.FILE$                                            !CJK
2057: 05ad:     SECOND.FILE$ = ALT.FILE$                                            !CJK
2058: 05ca: 
2059: 05ca:     ! Defaulting to zero                                                !CJK
2060: 05ca:     FUNCTION.ERROR.NOT.EXIST = 0                                        !CJK
2061: 05da:     ! Calling the routine to get the backup value details               !CJK
2062: 05da:     GOSUB GET.BKP.DETAILS
2063: 05ec: 
2064: 05ec:     ! Setting the screen number
2065: 05ec:     CALL DM.NAME (2, "SCREEN.NUM$", SCREEN.NUM$)
2066: 062b: 
2067: 062b:     ! Initialising the output fields in the screen
2068: 062b:     ! before processing the screen
2069: 062b:     !--------------------------------------------
2070: 062b:     CALL DM.NAME (48, "OPT.HEADER.1$", OPT.HEADER.1$)
2071: 066a: 
2072: 066a:     ! If backups are available
2073: 066a:     IF VALUE.INDEX% <> XRE.ZERO% AND FUNCTION.ERROR.NOT.EXIST THEN BEGIN
2074: 0693: 
2075: 0693:         ! Enabling the DAY and DD/MM string
2076: 0693:         CALL DM.VISIBLE ("75", STATUS.TEXT.MSG$(61))
2077: 06be:         CALL DM.VISIBLE ("76", STATUS.TEXT.MSG$(61))
2078: 06e9: 
2079: 06e9:         ! Setting other relevant string
2080: 06e9:         CALL DM.NAME (49, "OPT.HEADER$",   OPT.HEADER$  )               !CJK
2081: 0728:         CALL DM.NAME (50, "OPT.SELECTED$", OPT.SELECTED$)
2082: 0767: 
2083: 0767:         ! Setting the first value of the fields before populating it
2084: 0767:         DAY.LOOP%   = DAY.INDEX%                                        !CJK
2085: 077e:         DD.MM.LOOP% = DD.MM.INDEX%                                      !CJK
2086: 0795:         INPUT.LOOP% = INPUT.INDEX%                                      !CJK
2087: 07ac: 
2088: 07ac:         ! Retrieving the values and storing in Field$
2089: 07ac:         FOR INDEX% = 1 TO VALUE.INDEX%
2090: 07c0: 
2091: 07c0:             ! DAY value and its visibility
2092: 07c0:             FIELD$(DAY.LOOP%) = DAY.ARRAY$(INDEX%)
2093: 0800:             CALL DM.VISIBLE (STR$(DAY.LOOP%), STATUS.TEXT.MSG$(61))
2094: 0844: 
2095: 0844:             ! DD/MM value
2096: 0844:             FIELD$(DD.MM.LOOP%) = RIGHT$(BKP.AVAIL.ARRAY$(INDEX%),2) + \
2097: 08c2:                                   "/"                                + \
2098: 08c2:                                   LEFT$(BKP.AVAIL.ARRAY$(INDEX%),2)
2099: 08c2: 
2100: 08c2:             ! Setting a space for input values
2101: 08c2:             FIELD$(INPUT.LOOP%) = XRE.SPACE$
2102: 08f1: 
2103: 08f1:             ! Setting the visibility for DD/MM and input
2104: 08f1:             CALL DM.VISIBLE (STR$(DD.MM.LOOP%), STATUS.TEXT.MSG$(61))
2105: 0935:             CALL DM.VISIBLE (STR$(INPUT.LOOP%), STATUS.TEXT.MSG$(61))
2106: 0979: 
2107: 0979:             ! Incrementing to move to the next field
2108: 0979:             DAY.LOOP%   = DAY.LOOP%   + 1
2109: 0988:             DD.MM.LOOP% = DD.MM.LOOP% + 1
2110: 0997:             INPUT.LOOP% = INPUT.LOOP% + 1
2111: 09a6: 
2112: 09a6:         NEXT INDEX%
2113: 09d3: 
2114: 09d3:     ENDIF ELSE BEGIN
2115: 09db:         IF FUNCTION.ERROR.NOT.EXIST THEN BEGIN                          !CJK
2116: 09ed:             FIELD$(1) = STATUS.TEXT.ERROR$(21)                          !CJK
2117: 0a25:         ENDIF ELSE BEGIN                                                !CJK
2118: 0a2d:             FIELD$(1) = SCREEN.TEXT.MSG$(7) + SCREEN.TEXT.MSG$(8)       !CJK
2119: 0a7d:         ENDIF                                                           !CJK
2120: 0a85:     ENDIF
2121: 0a8d: 
2122: 0a8d: RETURN
2123: 0a9d: 
2124: 0a9d: \***********************************************************************
2125: 0a9d: \*
2126: 0a9d: \* SHOW.PROCESS.DIRECTORY: This Routine displays the directory Restoring
2127: 0a9d: \*                         process.
2128: 0a9d: \*
2129: 0a9d: \***********************************************************************
2130: 0a9d: SHOW.PROCESS.DIRECTORY:
2131: 0aad: 
2132: 0aad:     ! Setting the Header and other variables used for screen display
2133: 0aad:     SCR.HEADER$ = SCREEN.TEXT.MSG$(9)                                   !CJK
2134: 0ad7: 
2135: 0ad7:     ! Changed the help screen to zero, as it is not needed
2136: 0ad7:     CALL DM.SHOW.SCREEN(6, SCR.HEADER$, XRE.ZERO%, XRE.ZERO%)
2137: 0b06: 
2138: 0b06:     ! Setting the Dynamic directory value
2139: 0b06:     IF POSF(7) = 7 THEN BEGIN
2140: 0b1c:         CALL PUTF(STRING$(3,XRE.SPACE$)                              + \
2141: 0b70:                   BKPSCRPT.DIRECTORIES$(SELECT.INDEX%))
2142: 0b70:     ENDIF
2143: 0b78: 
2144: 0b78:     ! Displaying the directory name in status bar
2145: 0b78:     CALL DM.STATUS ("'" + BKPSCRPT.DIRECTORIES$(SELECT.INDEX%)       + \
2146: 0bce:                     SCREEN.TEXT.MSG$(10) + "Please Wait .....")         !CJK
2147: 0bce: 
2148: 0bce:     BKP.INDEX%        = XRE.ZERO%
2149: 0be4:     RESTORE.ERR.EXIST = FALSE                                           !EJK
2150: 0bfa:     RESTORE.STATUS    = FALSE
2151: 0c10: 
2152: 0c10:     STATUS.MSG$ = BKPSCRPT.DIRECTORIES$(SELECT.INDEX%)               + \!CJK
2153: 0cac:                   SCREEN.TEXT.MSG$(11) + BKP.DATE.ARRAY$(SEL.INDEX%) + \!CJK
2154: 0cac:                   SCREEN.TEXT.MSG$(12) + DAY.ARRAY$(SEL.INDEX%)      + \!CJK
2155: 0cac:                   " is being extracted"                                 !CJK
2156: 0cac:     GOSUB LOG.STATUS.MSG
2157: 0cbe: 
2158: 0cbe:     !----------------------------------------------------------!
2159: 0cbe:     ! Setting the BKP.INDEX% and FULL.TO.MOVING.DATE$ based    !
2160: 0cbe:     ! on the selected DAY and depending on the SET values the  !
2161: 0cbe:     ! restoration process will happen                          !
2162: 0cbe:     !----------------------------------------------------------!
2163: 0cbe:     GOSUB SET.BACKUP.INDEX
2164: 0cd0: 
2165: 0cd0:     ! Match for the day and set according to the Full backup day
2166: 0cd0:     BKP.INDEX% = LONG.DAY.INDEX%
2167: 0ce6:     F02.DATE$  = BKP.DATE.ARRAY$(SEL.INDEX%)
2168: 0d15:     FUN.RC2%   = XRE.ZERO%                                              !CJK
2169: 0d2c: 
2170: 0d2c:     IF BKP.INDEX% <> 0 THEN BEGIN
2171: 0d3e:         FUN.RC2% = UPDATE.DATE( ((BKP.INDEX% - 1)* -1 ) )               !CJK
2172: 0d69:     ENDIF
2173: 0d71: 
2174: 0d71:     ! Checking the Return code
2175: 0d71:     GOSUB CHECK.UPDATE.DATE.RC
2176: 0d83:     ! Setting the respective previous Full day
2177: 0d83:     FULL.TO.MOVING.DATE$ = F02.DATE$
2178: 0da1: 
2179: 0da1:     ! If directory not exist, create it
2180: 0da1:     IF FUNC.DIR.NOT.EXISTS(BKPSCRPT.DIRECTORIES$(SELECT.INDEX%))       \
2181: 0dd4:     THEN BEGIN
2182: 0dd4: 
2183: 0dd4:         DIRECT.TO.RESTORE$ = BKPSCRPT.DIRECTORIES$(SELECT.INDEX%)
2184: 0e03: 
2185: 0e03:         ! Trim the last slash found to avoid error using MKDIR
2186: 0e03:         CALL TRIM   (DIRECT.TO.RESTORE$)
2187: 0e19:         CALL RTRIMC (DIRECT.TO.RESTORE$, ASC("/"))
2188: 0e4c:         CALL RTRIMC (DIRECT.TO.RESTORE$, ASC("\\"))
2189: 0e7f: 
2190: 0e7f:         CALL OSSHELL("MKDIR " + DIRECT.TO.RESTORE$ + " >> "          + \
2191: 0ec7:                      DIR.OUT$ + " >>* " + DIR.OUT$)
2192: 0ec7:         STATUS.MSG$ = DIRECT.TO.RESTORE$ + " directory is created"
2193: 0eec:         GOSUB LOG.STATUS.MSG
2194: 0efe: 
2195: 0efe:     ENDIF
2196: 0f06: 
2197: 0f06:     ! ZIP file extraction process
2198: 0f06:     GOSUB EXTRACT.DIRECTORIES
2199: 0f18: 
2200: 0f18:     STATUS.MSG$ = "Checking " + BKPLIST.CURR.FILE$ + " to check the" + \
2201: 0f45:                   " extracted file"
2202: 0f45:     GOSUB LOG.STATUS.MSG
2203: 0f57: 
2204: 0f57:     !---------------------------------------------------------------!
2205: 0f57:     ! Checking whether BKPLIST file exist and the requested date is !
2206: 0f57:     ! NOT Full, If true then the respective BKPLIST file will be    !
2207: 0f57:     ! checked to delete all the files which are stated as not       !
2208: 0f57:     ! exist (NULL) in BKPLIST for the selected day                  !
2209: 0f57:     !---------------------------------------------------------------!
2210: 0f57:     IF BKP.INDEX% > 1 THEN BEGIN
2211: 0f6c:         ! Checking the file existence before opening it                 !CJK
2212: 0f6c:         IF FUNC.FILE.EXISTS(BKPLIST.CURR.FILE$) THEN BEGIN
2213: 0f8e:             BKPLIST.FILE.RC% = \                                        !DJK
2214: 0fb8:                     FUNC.OPEN.SEQUENTIAL.FILE (BKPLIST.CURR.FILE$)      !DJK
2215: 0fb8:             ! If file open unsuccessful
2216: 0fb8:             IF BKPLIST.FILE.RC% <= XRE.ZERO% THEN BEGIN
2217: 0fd6:                 STATUS.MSG$ = "Error in opening BKPLIST file"
2218: 0fed:                 GOSUB LOG.STATUS.MSG
2219: 0fff:                 ! Setting NULL to avoid file read
2220: 0fff:                 BKPLIST.DIR.VALUE$ = XRE.NULL$
2221: 101f:             ENDIF ELSE BEGIN
2222: 1027:                 BKPLIST.OPEN       = TRUE
2223: 103d:                 BKPLIST.DIR.VALUE$ = XRE.SPACE$
2224: 105b:             ENDIF
2225: 1063: 
2226: 1063:             ! Read the file till the EOF or read error
2227: 1063:             WHILE LEN(BKPLIST.DIR.VALUE$) <> XRE.ZERO%
2228: 106e: 
2229: 106e:                 BKPLIST.DIR.VALUE$ = \
2230: 1091:                     FUNC.READ.SEQUENTIAL.FILE(BKPLIST.FILE.RC%)         !DJK
2231: 1091: 
2232: 1091:                 !---------------------------------------------------!
2233: 1091:                 ! Checking the directory name of BKPLIST files with !
2234: 1091:                 ! the requested directory                           !
2235: 1091:                 !---------------------------------------------------!
2236: 1091:                 IF (BKPSCRPT.DIRECTORIES$(SELECT.INDEX%)) =            \
2237: 10f7:                     LEFT$(BKPLIST.DIR.VALUE$,                          \
2238: 10f7:                     LEN(BKPSCRPT.DIRECTORIES$(SELECT.INDEX%)))         \
2239: 10f7:                 THEN BEGIN
2240: 10f7: 
2241: 10f7:                     ! Extract the individual fields using function
2242: 10f7:                     GOSUB EXTRACT.BKPLIST.FIELDS
2243: 1109: 
2244: 1109:                     IF NOT FUNCTION.ERROR.NOT.EXIST THEN BEGIN
2245: 111b:                         ! Setting the value for exception
2246: 111b:                         RESTORE.ERR.EXIST = TRUE                        !EJK
2247: 1131:                     ENDIF
2248: 1139: 
2249: 1139:                     IF BKPLI.INCREMENTAL.EXIST$(BKP.INDEX%-1) <> "Y" \
2250: 116c:                     THEN BEGIN
2251: 116c:                         GOSUB DELETE.BKPLIST.FILE
2252: 117e:                     ENDIF
2253: 1186:                 ENDIF
2254: 118e:             WEND
2255: 11b6: 
2256: 11b6:             ! Closing File
2257: 11b6:             IF BKPLIST.OPEN THEN BEGIN
2258: 11c8:                 CALL FUNC.CLOSE.FILE( BKPLIST.FILE.RC% )                !DJK
2259: 11f1:                 BKPLIST.OPEN = FALSE
2260: 1207:             ENDIF
2261: 120f:         ENDIF
2262: 1217:     ENDIF
2263: 121f: 
2264: 121f:     ! Setting the Dynamic directory value
2265: 121f:     IF POSF(238) = 238 THEN BEGIN
2266: 1236:         CALL PUTF(STRING$(10,XRE.SPACE$) + \
2267: 1272:                           "RESTORE A DIRECTORY RESTORATION STATUS")
2268: 1272:     ENDIF
2269: 127a: 
2270: 127a:     !-----------------------------------------!
2271: 127a:     ! Set the field to display the Directory  !
2272: 127a:     ! extraction process completed message    !
2273: 127a:     !-----------------------------------------!
2274: 127a:     FIELD$(6) = " The directory "                                    + \
2275: 1346:                 BKPSCRPT.DIRECTORIES$(SELECT.INDEX%) + " from "      + \
2276: 1346:                 DAY.ARRAY$(SEL.INDEX%) + ", "                        + \
2277: 1346:                 RIGHT$(BKP.DATE.ARRAY$(SEL.INDEX%),2) + "/"          + \
2278: 1346:                 MID$(BKP.DATE.ARRAY$(SEL.INDEX%),3,2)                + \
2279: 1346:                 " has been restored "
2280: 1346:     FIELD$(7) = " to " + BKPSCRPT.DIRECTORIES$(SELECT.INDEX%) +  "."
2281: 138c: 
2282: 138c:     ! Disable the visibility of other irrelevant fields
2283: 138c:     CALL DM.VISIBLE("5",STATUS.TEXT.MSG$(60))
2284: 13b7:     CALL DM.VISIBLE("8",STATUS.TEXT.MSG$(60))
2285: 13e2:     CALL DM.VISIBLE("9",STATUS.TEXT.MSG$(60))
2286: 140d: 
2287: 140d:     ! If restore without any error
2288: 140d:     IF NOT RESTORE.ERR.EXIST THEN BEGIN                                 !EJK
2289: 141f: 
2290: 141f:         CALL DM.STATUS ("'Restore completed successfully")
2291: 1433: 
2292: 1433:         STATUS.MSG$ = "Restore completed successfully"
2293: 144c: 
2294: 144c:     ! If restore with exceptions                                        !EJK
2295: 144c:     ENDIF ELSE BEGIN                                                    !EJK
2296: 1454: 
2297: 1454:         CALL DM.STATUS (SCREEN.TEXT.MSG$(26))
2298: 147b:         STATUS.MSG$ = STATUS.TEXT.MSG$(5)
2299: 14a5: 
2300: 14a5: ! Commenting out, as the logic is redundant and unused                  !EJK
2301: 14a5: !    ! If backup file not present                                       !EJK
2302: 14a5: !    ENDIF ELSE BEGIN                                                   !EJK
2303: 14a5: !        CALL DM.STATUS ("'Restore unsuccessful. Backup file not" + \   !EJK
2304: 14a5: !                        " present")                                    !EJK
2305: 14a5: !        STATUS.MSG$ = "Backup file not present"                        !EJK
2306: 14a5:     ENDIF
2307: 14ad: 
2308: 14ad:     GOSUB LOG.STATUS.MSG
2309: 14bf: 
2310: 14bf:     WHILE SCREEN% = DIRECTORY.PROCESS.SCR%
2311: 14ca:         RET.KEY% = DM.PROCESS.SCREEN (2, 9, FALSE)
2312: 14ee: 
2313: 14ee:         IF RET.KEY% = ESC.KEY% THEN BEGIN                               !CJK
2314: 1506: 
2315: 1506:             SCREEN%      = DIRECTORY.DAY.SELECT.SCR%
2316: 151c:             PREVIOUS.KEY = TRUE
2317: 1534: 
2318: 1534:         ENDIF ELSE BEGIN
2319: 153c: 
2320: 153c:             CALL DM.FOCUS ("1", SCREEN.TEXT.MSG$(13) + \                !CJK
2321: 1589:                                 SCREEN.TEXT.MSG$(29))                   !CJK
2322: 1589:         ENDIF
2323: 1591:     WEND
2324: 15ac: 
2325: 15ac: RETURN
2326: 15bc: 
2327: 15bc: \***********************************************************************
2328: 15bc: \*
2329: 15bc: \* DELETE.BKPLIST.FILE: This Routine deletes the BKPLIST file
2330: 15bc: \*                      which is set as Non-exist.
2331: 15bc: \*
2332: 15bc: \***********************************************************************
2333: 15bc: DELETE.BKPLIST.FILE:
2334: 15cc: 
2335: 15cc:     CALL OSSHELL("DEL " + BKPLI.FILENAME$ + " >> " + DIR.OUT$ + \
2336: 1614:                  " >>* " + DIR.OUT$)
2337: 1614:     STATUS.MSG$ = STATUS.TEXT.MSG$(7) + BKPLI.FILENAME$
2338: 164c:     GOSUB LOG.STATUS.MSG
2339: 165e: 
2340: 165e: RETURN
2341: 166e: 
2342: 166e: \***********************************************************************
2343: 166e: \*
2344: 166e: \* EXTRACT.DIRECTORIES: This Routine extracts the selected directories
2345: 166e: \*                      archive file.
2346: 166e: \*
2347: 166e: \***********************************************************************
2348: 166e: EXTRACT.DIRECTORIES:
2349: 167e: 
2350: 167e:     !------------------------------------------------------------------!
2351: 167e:     ! Initiating the Directory restore. Depending on the selected day, !
2352: 167e:     ! BKP.INDEX% value would have been set. For example, if WED then   !
2353: 167e:     ! BKP.INDEX% value would be 4, so that from Full archive 4 next    !
2354: 167e:     ! archive files would be extracted                                 !
2355: 167e:     !------------------------------------------------------------------!
2356: 167e:     FOR LOOP% = 1 TO BKP.INDEX%
2357: 1692: 
2358: 1692:         STATUS.MSG$ = BKPSCRPT.DIRECTORIES$(SELECT.INDEX%)        + \   !CJK
2359: 16fd:                       STATUS.TEXT.MSG$(31) + FULL.TO.MOVING.DATE$ + \
2360: 16fd:                       SCREEN.TEXT.MSG$(16)
2361: 16fd:         GOSUB LOG.STATUS.MSG
2362: 170f: 
2363: 170f:         GOSUB GET.FILE.EXTENSION
2364: 1721:         MDD.DATE$ = EXTENSION$
2365: 173f: 
2366: 173f:         ! Storing the Full MDD
2367: 173f:         IF LOOP% = 1 THEN BEGIN
2368: 1754:             FULL.MDD.DATE$ = MDD.DATE$
2369: 1772: 
2370: 1772:             IF UCASE$(LEFT$(BKPSCRPT.DIRECTORIES$(INDEX%),1)) = "C" \   !CJK
2371: 17c8:             THEN BEGIN                                                  !CJK
2372: 17c8:                 ! BKPLIST current file                                  !CJK
2373: 17c8:                 BKPLIST.CURR.FILE$ = BKPLIST.PREFIX.D.DRIVE$ + \        !CJK
2374: 17f6:                                      FULL.MDD.DATE$                     !CJK
2375: 17f6:             ENDIF ELSE BEGIN                                            !CJK
2376: 17fe:                 ! BKPLIST current file                                  !CJK
2377: 17fe:                 BKPLIST.CURR.FILE$ = BKPLIST.PREFIX.C.DRIVE$ + \        !CJK
2378: 182a:                                      FULL.MDD.DATE$                     !CJK
2379: 182a:             ENDIF                                                       !CJK
2380: 1832:         ENDIF
2381: 183a: 
2382: 183a:         ! Setting the Backup files based on the 1st field which is drive
2383: 183a:         IF LEFT$(FILENAME$,1) = "D" THEN BEGIN
2384: 1872:             ! IMG and ALT directory for C drive
2385: 1872:             BKP.FILENAME.IMG$ = C.BKP.IMG$ + FILENAME$ + "." + MDD.DATE$
2386: 18ad:             BKP.FILENAME.ALT$ = C.BKP.ALT$ + FILENAME$ + "." + MDD.DATE$
2387: 18e8: 
2388: 18e8:             BKPFAIL.PREFIX$ = C.BKP.IMG$ + "BKPFAILD."                  !CJK
2389: 1910:         ENDIF ELSE BEGIN
2390: 1918:             ! IMG and ALT directory for D drive
2391: 1918:             BKP.FILENAME.IMG$ = D.BKP.IMG$ + FILENAME$ + "." + MDD.DATE$
2392: 1953:             BKP.FILENAME.ALT$ = D.BKP.ALT$ + FILENAME$ + "." + MDD.DATE$
2393: 198e: 
2394: 198e:             BKPFAIL.PREFIX$ = D.BKP.IMG$ + "BKPFAILC."                  !CJK
2395: 19b3:         ENDIF
2396: 19bb: 
2397: 19bb:         ! Current BKPFAIL file
2398: 19bb:         BKPFAIL.CURR.FILE$ = BKPFAIL.PREFIX$ + MDD.DATE$                !CJK
2399: 19e7: 
2400: 19e7:         STATUS.MSG$ = "Checking BKPFAIL " + BKPFAIL.CURR.FILE$
2401: 1a0c:         GOSUB LOG.STATUS.MSG
2402: 1a1e: 
2403: 1a1e:         DIR.FILE.RC% = FUNC.OPEN.SEQUENTIAL.FILE( BKPFAIL.CURR.FILE$ )  !DJK
2404: 1a48: 
2405: 1a48:         ! If file open unsuccessful
2406: 1a48:         IF DIR.FILE.RC% <= XRE.ZERO% THEN BEGIN
2407: 1a66:             ! Setting NULL to avoid file read
2408: 1a66:             DIR.VALUE$ = XRE.NULL$
2409: 1a84:             DIR.OPEN   = FALSE
2410: 1a9c:         ENDIF ELSE BEGIN
2411: 1aa4:             DIR.OPEN   = TRUE
2412: 1aba:             DIR.VALUE$ = XRE.SPACE$
2413: 1ad8:         ENDIF
2414: 1ae0: 
2415: 1ae0:         !-------------------------------------------------------------!
2416: 1ae0:         ! Reading the file till the EOF file reached. C file function !
2417: 1ae0:         ! returns NULL when EOF reached or read error                 !
2418: 1ae0:         !-------------------------------------------------------------!
2419: 1ae0:         WHILE LEN(DIR.VALUE$) <> XRE.ZERO%
2420: 1aeb:             DIR.VALUE$ = FUNC.READ.SEQUENTIAL.FILE( DIR.FILE.RC% )      !DJK
2421: 1b0e: 
2422: 1b0e:             ! Checking the comma position
2423: 1b0e:             COMMA.POSITION% = MATCH(COMMA.VALUE$,DIR.VALUE$,1)
2424: 1b3a: 
2425: 1b3a:             ! If comma found
2426: 1b3a:             IF COMMA.POSITION% <> XRE.ZERO% THEN BEGIN
2427: 1b56: 
2428: 1b56:                 ! Storing the failed file and Distribution type
2429: 1b56:                 FAILED.FILE$ = LEFT$(DIR.VALUE$,(COMMA.POSITION% - 1))
2430: 1b84:                 FAILED.FILE.DIST$ = MID$(DIR.VALUE$,           \        !CJK
2431: 1bb2:                                         (COMMA.POSITION% + 1), \        !CJK
2432: 1bb2:                                         1)
2433: 1bb2: 
2434: 1bb2:                 ! If directory in BKPFAIL matches with current directory!CJK
2435: 1bb2:                 IF (BKPSCRPT.DIRECTORIES$(SELECT.INDEX%)) =    \        !CJK
2436: 1c18:                     LEFT$(FAILED.FILE$,                        \        !CJK
2437: 1c18:                     LEN(BKPSCRPT.DIRECTORIES$(SELECT.INDEX%))) \        !CJK
2438: 1c18:                 THEN BEGIN
2439: 1c18: 
2440: 1c18:                     BEGIN.POSITION% = 4         ! Setting the begin
2441: 1c29:                     SLASH.POSITION% = XRE.ZERO% ! position
2442: 1c40:                     VALUE.EXISTS    = TRUE
2443: 1c56:                     FILENAME$       = XRE.NULL$
2444: 1c74: 
2445: 1c74:                     ! Extracting the file name
2446: 1c74:                     WHILE VALUE.EXISTS
2447: 1c7f:                         SLASH.POSITION% = MATCH("\\", FAILED.FILE$,    \
2448: 1ca9:                                                  BEGIN.POSITION%)
2449: 1ca9: 
2450: 1ca9:                         IF SLASH.POSITION% > XRE.ZERO% THEN BEGIN
2451: 1cc2:                             ! Move to next position to search next field
2452: 1cc2:                             BEGIN.POSITION% = SLASH.POSITION% + 1
2453: 1cdc:                         ENDIF ELSE BEGIN
2454: 1ce4:                             FILENAME$ = MID$(FAILED.FILE$,        \     !CJK
2455: 1d28:                                              BEGIN.POSITION%,     \     !CJK
2456: 1d28:                                              (LEN(FAILED.FILE$) - \     !CJK
2457: 1d28:                                              BEGIN.POSITION% + 1))      !CJK
2458: 1d28:                             ! Storing the file name                     !CJK
2459: 1d28:                             RESTORE.FILENAME$ = FILENAME$               !BJK
2460: 1d46:                             ! File name without extension               !CJK
2461: 1d46:                             MATCH.POS% = MATCH(".", FILENAME$,1)        !BJK
2462: 1d6b: 
2463: 1d6b:                             IF MATCH.POS% <> XRE.ZERO% THEN BEGIN       !BJK
2464: 1d84:                                 RESTORE.FILENAME$ = LEFT$(FILENAME$, \  !BJK
2465: 1db2:                                                     (MATCH.POS% - 1))   !BJK
2466: 1db2:                             ENDIF                                       !BJK
2467: 1dba:                             VALUE.EXISTS = FALSE
2468: 1dd0:                         ENDIF
2469: 1dd8:                     WEND
2470: 1ded: 
2471: 1ded:                     STATUS.MSG$ = STATUS.TEXT.MSG$(9)
2472: 1e17:                     GOSUB LOG.STATUS.MSG
2473: 1e29: 
2474: 1e29:                     STATUS.MSG$ = STATUS.TEXT.MSG$(10) + FILENAME$      !CJK
2475: 1e61:                     GOSUB LOG.STATUS.MSG
2476: 1e73: 
2477: 1e73:                     ! Depending on the drive, XDISKIMG directory will   !CJK
2478: 1e73:                     ! be used in copying failed file                    !CJK
2479: 1e73:                     IF LEFT$(FILENAME$,1) = "D" THEN BEGIN              !CJK
2480: 1eab:                         ! Copying the file to respective directory      !CJK
2481: 1eab:                         CALL OSSHELL("COPY " + C.BKP.IMG$             + \CJK
2482: 1f26:                                      RESTORE.FILENAME$ + "."          + \CJK
2483: 1f26:                                      MDD.DATE$ + XRE.SPACE$           + \CJK
2484: 1f26:                                      FAILED.FILE$ + " > " + DIR.OUT$  + \CJK
2485: 1f26:                                      " >>* " + DIR.OUT$)                !CJK
2486: 1f26:                     ENDIF ELSE BEGIN                                    !CJK
2487: 1f2e:                         ! Copying the file to respective directory      !CJK
2488: 1f2e:                         CALL OSSHELL("COPY " + D.BKP.IMG$             + \CJK
2489: 1fa6:                                      RESTORE.FILENAME$ + "."          + \CJK
2490: 1fa6:                                      MDD.DATE$ + XRE.SPACE$           + \CJK
2491: 1fa6:                                      FAILED.FILE$ + " > " + DIR.OUT$  + \CJK
2492: 1fa6:                                      " >>* " + DIR.OUT$)                !CJK
2493: 1fa6:                     ENDIF
2494: 1fae:                     !---------------------------------------------!
2495: 1fae:                     ! Not distributing the file if SUPPS mode, as !
2496: 1fae:                     ! ADXCSU0L won't work under SUPPS             !
2497: 1fae:                     !---------------------------------------------!
2498: 1fae:                     IF NOT SUPPS.ON THEN BEGIN
2499: 1fc0:                         ! Setting the distribution type
2500: 1fc0:                         CALL OSSHELL(ADXCSU0L.FILE.NAME$ + " 3 "     + \!CJK
2501: 2029:                                      FAILED.FILE.DIST$ + XRE.SPACE$  + \
2502: 2029:                                      FAILED.FILE$ + " >> "           + \
2503: 2029:                                      DIR.OUT$ + " >>* " + DIR.OUT$)
2504: 2029:                     ENDIF
2505: 2031: 
2506: 2031:                     DIR.FILE.RC% = FUNC.OPEN.SEQUENTIAL.FILE( DIR.OUT$ )!DJK
2507: 205b: 
2508: 205b:                     ! If file open unsuccessful
2509: 205b:                     IF DIR.FILE.RC% <= XRE.ZERO% THEN BEGIN
2510: 2079:                         STATUS.MSG$ = STATUS.TEXT.ERROR$(2)
2511: 20a3:                         GOSUB LOG.STATUS.MSG
2512: 20b5:                         ! Setting NULL to avoid file read
2513: 20b5:                         DIR.VALUE$ = XRE.NULL$
2514: 20d3:                         DIR.OPEN   = FALSE
2515: 20eb:                     ENDIF ELSE BEGIN
2516: 20f3:                         DIR.OPEN   = TRUE
2517: 2109:                         DIR.VALUE$ = XRE.SPACE$
2518: 2127:                     ENDIF
2519: 212f: 
2520: 212f:                     ! Read the file till EOF or read error
2521: 212f:                     WHILE LEN(DIR.VALUE$) <> XRE.ZERO%
2522: 213a:                         DIR.VALUE$ = \                                  !DJK
2523: 215d:                             FUNC.READ.SEQUENTIAL.FILE(DIR.FILE.RC%)     !DJK
2524: 215d: 
2525: 215d:                        !-----------------------------------------------!
2526: 215d:                        ! If error string matches, write the error with !
2527: 215d:                        ! file name in LOG file                         !
2528: 215d:                        !-----------------------------------------------!
2529: 215d:                         IF MATCH("ERROR",UCASE$(DIR.VALUE$),1)     \    !EJK
2530: 21d9:                            <> XRE.ZERO% OR                         \    !EJK
2531: 21d9:                            MATCH("cannot be found",(DIR.VALUE$),1) \    !EJK
2532: 21d9:                            <> XRE.ZERO% THEN BEGIN                      !EJK
2533: 21d9:                             ! Copy error and distribution error
2534: 21d9:                             STATUS.MSG$ = STATUS.TEXT.ERROR$(14)
2535: 2203:                             GOSUB LOG.STATUS.MSG
2536: 2215:                             STATUS.MSG$ = DIR.VALUE$
2537: 2233:                             GOSUB LOG.STATUS.MSG
2538: 2245: 
2539: 2245:                             RESTORE.ERR.EXIST = TRUE                    !EJK
2540: 225b:                             ! To break the WHILE loop                   !EJK
2541: 225b:                             DIR.VALUE$ = XRE.NULL$                      !EJK
2542: 2279:                         ENDIF
2543: 2281:                     WEND
2544: 22a9: 
2545: 22a9:                     ! Closing File
2546: 22a9:                     IF DIR.OPEN THEN BEGIN
2547: 22bb:                         CALL FUNC.CLOSE.FILE( DIR.FILE.RC% )            !DJK
2548: 22e4:                         DIR.OPEN = FALSE
2549: 22fa:                     ENDIF
2550: 2302:                 ENDIF
2551: 230a:             ENDIF
2552: 2312:         WEND
2553: 233a: 
2554: 233a:         ! Closing File
2555: 233a:         IF DIR.OPEN THEN BEGIN
2556: 234c:             CALL FUNC.CLOSE.FILE( DIR.FILE.RC% )                        !DJK
2557: 2375:             DIR.OPEN = FALSE
2558: 238b:         ENDIF
2559: 2393: 
2560: 2393:         !--------------------------------------------------------------!
2561: 2393:         ! Checking the archive file existence before extraction. First !
2562: 2393:         ! the file will be checked in IMG location and it not present, !
2563: 2393:         ! then it will be tried in ALT location                        !
2564: 2393:         !--------------------------------------------------------------!
2565: 2393:         IF FUNC.FILE.EXISTS(BKP.FILENAME.IMG$) THEN BEGIN
2566: 23b5:             CALL OSSHELL(ADXZUDIR.FILE.NAME$ + " -x "         + \       !CJK
2567: 242f:                          BKP.FILENAME.IMG$   + XRE.SPACE$     + \       !CJK
2568: 242f:                          BKPSCRPT.DIRECTORIES$(SELECT.INDEX%) + \       !CJK
2569: 242f:                          " > " + DIR.OUT$ + " >>* " + DIR.OUT$)
2570: 242f: 
2571: 242f:             STATUS.MSG$ = BKP.FILENAME.IMG$ + STATUS.TEXT.MSG$(11) + \  !CJK
2572: 2483:                           BKPSCRPT.DIRECTORIES$(SELECT.INDEX%)
2573: 2483:             GOSUB LOG.STATUS.MSG
2574: 2495: 
2575: 2495:             ! Setting the status to check the extraction output file
2576: 2495:             RESTORE.STATUS = TRUE
2577: 24ae: 
2578: 24ae:         ENDIF ELSE BEGIN                                                !DJK
2579: 24b6:             IF FUNC.FILE.EXISTS(BKP.FILENAME.ALT$) THEN BEGIN           !DJK
2580: 24d8:                 CALL OSSHELL(ADXZUDIR.FILE.NAME$ + " -x "         + \   !CJK
2581: 2552:                              BKP.FILENAME.ALT$   + XRE.SPACE$     + \   !CJK
2582: 2552:                              BKPSCRPT.DIRECTORIES$(SELECT.INDEX%) + \   !CJK
2583: 2552:                              " > " + DIR.OUT$ + " >>* " + DIR.OUT$)
2584: 2552: 
2585: 2552:                 STATUS.MSG$ = BKP.FILENAME.ALT$ + STATUS.TEXT.MSG$(11)+ \CJK
2586: 25a6:                               BKPSCRPT.DIRECTORIES$(SELECT.INDEX%)
2587: 25a6:                 GOSUB LOG.STATUS.MSG
2588: 25b8: 
2589: 25b8:                 ! Setting the status to check the extraction output file
2590: 25b8:                 RESTORE.STATUS = TRUE
2591: 25ce:             ENDIF
2592: 25d6:         ENDIF                                                           !DJK
2593: 25de: 
2594: 25de:         ! If file extraction happened
2595: 25de:         IF RESTORE.STATUS THEN BEGIN                                    !EJK
2596: 25f3: 
2597: 25f3:             DIR.FILE.RC% = FUNC.OPEN.SEQUENTIAL.FILE( DIR.OUT$ )        !DJK
2598: 261d: 
2599: 261d:             ! If file open unsuccessful
2600: 261d:             IF DIR.FILE.RC% <= XRE.ZERO% THEN BEGIN
2601: 263b:                 DIR.OPEN    = FALSE                                     !CJK
2602: 2651:                 STATUS.MSG$ = STATUS.TEXT.ERROR$(2)
2603: 267b:                 GOSUB LOG.STATUS.MSG
2604: 268d:                 ! Setting NULL to avoid file read
2605: 268d:                 DIR.VALUE$ = XRE.NULL$
2606: 26ad:             ENDIF ELSE BEGIN
2607: 26b5:                 DIR.OPEN   = TRUE
2608: 26cb:                 DIR.VALUE$ = XRE.SPACE$
2609: 26e9:             ENDIF
2610: 26f1:             ! Read the file till EOF or read error
2611: 26f1:             WHILE LEN(DIR.VALUE$) <> XRE.ZERO%
2612: 26fc:                 DIR.VALUE$ = FUNC.READ.SEQUENTIAL.FILE( DIR.FILE.RC% )  !DJK
2613: 271f: 
2614: 271f:                 !-----------------------------------------------!
2615: 271f:                 ! If error string matches, write the error with !
2616: 271f:                 ! file name in LOG file                         !
2617: 271f:                 !-----------------------------------------------!
2618: 271f:                 IF MATCH("Error extracting file",DIR.VALUE$,1) <> \     !CJK
2619: 274d:                    XRE.ZERO% THEN BEGIN
2620: 274d: 
2621: 274d: !                    STATUS.MSG$ = STATUS.TEXT.ERROR$(12)               !EJK
2622: 274d: !                    GOSUB LOG.STATUS.MSG                               !EJK
2623: 274d: 
2624: 274d:                     ! Setting the value for extraction error
2625: 274d:                     RESTORE.ERR.EXIST = TRUE                            !EJK
2626: 2763:                     STATUS.MSG$       = DIR.VALUE$                      !EJK
2627: 2781:                     GOSUB LOG.STATUS.MSG
2628: 2793:                 ENDIF
2629: 279b:             WEND
2630: 27c3: 
2631: 27c3:             ! Closing File
2632: 27c3:             IF DIR.OPEN THEN BEGIN
2633: 27d5:                 CALL FUNC.CLOSE.FILE( DIR.FILE.RC% )                    !DJK
2634: 27fe:                 DIR.OPEN = FALSE
2635: 2814:             ENDIF
2636: 281c: 
2637: 281c:         ENDIF
2638: 2824: 
2639: 2824:         ! Starting from Full increment the date till requested date
2640: 2824:         F02.DATE$ = FULL.TO.MOVING.DATE$
2641: 2842:         FUN.RC2%  = UPDATE.DATE( 1 )                                    !CJK
2642: 2861:         ! Checking the Return code
2643: 2861:         GOSUB CHECK.UPDATE.DATE.RC
2644: 2873:         FULL.TO.MOVING.DATE$ = F02.DATE$
2645: 2891: 
2646: 2891:     NEXT LOOP%
2647: 28bc: 
2648: 28bc: RETURN
2649: 28cc: 
2650: 28cc: ! duplicated subroutine
2651: 28cc: %INCLUDE XREST00E.J86                                                   !DJK
2652: 28cc: \************************************************************************
2653: 28cc: \***                                                                    *
2654: 28cc: \***           %INCLUDE FOR REPEATED SUBROUTINES IN XRESTORE            *
2655: 28cc: \***                                                                    *
2656: 28cc: \***                    REFERENCE: XREST00E.J86                         *
2657: 28cc: \***                                                                    *
2658: 28cc: \***                                                                    *
2659: 28cc: \*** Version A              Dave Constable                   05/06/2014 *
2660: 28cc: \*** FOD260 - Enhanced Backup and Recovery                              *
2661: 28cc: \***                                                                    *
2662: 28cc: \*** Version B              Dave Constable                   25/06/2014 *
2663: 28cc: \*** FOD260 - Enhanced Backup and Recovery                              *
2664: 28cc: \*** QC775 - Incorrect file extension check changed                     *
2665: 28cc: \*** QC750 - Added OS file copy that used to be in CRESTORE batch       *
2666: 28cc: \*** Code review changes; alignment of file open status                 *
2667: 28cc: \***                                                                    *
2668: 28cc: \*** Version C                 Jaya Kumar Inbaraj            23/08/2014 *
2669: 28cc: \*** FOD260 - Enhanced Backup and Recovery                              *
2670: 28cc: \*** CR5 changes to perform the drive restore if a drive is empty.      *
2671: 28cc: \*** Also commented out few redundant labels and worked on Internal     *
2672: 28cc: \*** and APPS management review comments.                               *
2673: 28cc: \***                                                                    *
2674: 28cc: \*** Version D                 Jaya Kumar Inbaraj            04/09/2014 *
2675: 28cc: \*** FOD260 - Enhanced Backup and Recovery                              *
2676: 28cc: \*** Worked on APPS management review comments.                         *
2677: 28cc: \***                                                                    *
2678: 28cc: \************************************************************************
2679: 28cc: 
2680: 28cc: \************************************************************************
2681: 28cc: \*
2682: 28cc: \* SET.BACKUP.INDEX: Setting the BKP.INDEX% and FULL.TO.MOVING.DATE$
2683: 28cc: \*                   based on the selected DAY and depending on the SET
2684: 28cc: \*                   values the restoration process will happen
2685: 28cc: \*
2686: 28cc: \************************************************************************
2687: 28cc: SET.BACKUP.INDEX:
2688: 28dc: 
2689: 28dc:     ! Match for the long day name and set using the offset              !CJK
2690: 28dc:     LONG.DAY.INDEX% = MATCH( LEFT$(DAY.ARRAY$(SEL.INDEX%)        + \    !CJK
2691: 296d:                       STRING$(CONSTANT.LONGEST.DAY%, XRE.SPACE$),  \    !CJK
2692: 296d:                       CONSTANT.LONGEST.DAY%), BACKUP.LONG.DAYS$,1)      !CJK
2693: 296d:     ! Use the offset to calculate the index                             !CJK
2694: 296d:     LONG.DAY.INDEX% = ((LONG.DAY.INDEX%-1) / CONSTANT.LONGEST.DAY%) + 1
2695: 299a: 
2696: 299a: RETURN
2697: 29aa: 
2698: 29aa: \***********************************************************************
2699: 29aa: \*
2700: 29aa: \* GET.BKP.DETAILS: This function receives the Primary and secondary
2701: 29aa: \*                  backup file (without extension) as an input. Then
2702: 29aa: \*                  it checks the availability of archived files based
2703: 29aa: \*                  on number of BKP.DAYS and store it in arrays for
2704: 29aa: \*                  Screen to display.
2705: 29aa: \*
2706: 29aa: \***********************************************************************
2707: 29aa: GET.BKP.DETAILS:
2708: 29ba: 
2709: 29ba:     FUNCTION.ERROR.NOT.EXIST = TRUE
2710: 29d0: 
2711: 29d0:     BEGIN.POSITION% = 4        ! To Ignore the Drive being checked      !CJK
2712: 29e1:     SLASH.POSITION% = XRE.ZERO%                                         !CJK
2713: 29f8:     VALUE.EXISTS    = TRUE                                              !CJK
2714: 2a0e: 
2715: 2a0e:     DIM BKP.FILE.MDD.ARRAY$(ARRAY.LIMIT%)                               !CJK
2716: 2a42:     DIM BKP.DATE.ARRAY$(ARRAY.LIMIT%)                                   !CJK
2717: 2a76: 
2718: 2a76:     ! Extracting the archive file name
2719: 2a76:     WHILE VALUE.EXISTS
2720: 2a81:         SLASH.POSITION% = MATCH("\\", FIRST.FILE$, BEGIN.POSITION%)
2721: 2aab: 
2722: 2aab:         IF SLASH.POSITION% > XRE.ZERO% THEN BEGIN
2723: 2ac4:             ! Move to next position to search next field
2724: 2ac4:             BEGIN.POSITION% = SLASH.POSITION% + 1
2725: 2add:         ENDIF ELSE BEGIN
2726: 2ae5:             FILENAME$ = MID$(FIRST.FILE$,BEGIN.POSITION%, \
2727: 2b29:                             (LEN(FIRST.FILE$) - BEGIN.POSITION% + 1))
2728: 2b29:             VALUE.EXISTS = FALSE
2729: 2b3f:         ENDIF
2730: 2b47:     WEND
2731: 2b5c: 
2732: 2b5c:     ! Getting all the archive files from Primary backup location
2733: 2b5c:     CALL OSSHELL("DIR " + FIRST.FILE$ + ".* > " + DIR.OUT$ + " >>* " + \
2734: 2ba4:                  DIR.OUT$ )
2735: 2ba4: 
2736: 2ba4:     CALL OSSHELL("DIR " + SECOND.FILE$ + ".* >> " + DIR.OUT$     + \
2737: 2bec:                  " >>* " + DIR.OUT$ )
2738: 2bec: 
2739: 2bec:     DIR.FILE.RC% = FUNC.OPEN.SEQUENTIAL.FILE( DIR.OUT$ )                !DJK
2740: 2c16: 
2741: 2c16:     ! If file open unsuccessful
2742: 2c16:     IF DIR.FILE.RC% <= XRE.ZERO% THEN BEGIN
2743: 2c34:         STATUS.MSG$ = "Error in opening DIR output file"
2744: 2c4b:         GOSUB LOG.STATUS.MSG
2745: 2c5d:         DIR.OPEN                 = FALSE
2746: 2c73:         FUNCTION.ERROR.NOT.EXIST = FALSE
2747: 2c8b: !        RETURN                                                         !DJK
2748: 2c8b:     ENDIF ELSE BEGIN
2749: 2c93:         DIR.OPEN = TRUE
2750: 2ca9:     ENDIF
2751: 2cb1: 
2752: 2cb1:     FOR F.RECORD.COUNT% = 1 TO 4
2753: 2cc3:         ! Ignoring the first 4 lines
2754: 2cc3:         DIR.VALUE$ = FUNC.READ.SEQUENTIAL.FILE( DIR.FILE.RC% )          !DJK
2755: 2ce6:     NEXT F.RECORD.COUNT%
2756: 2d08: 
2757: 2d08:     BKP.INDEX% = XRE.ZERO%
2758: 2d1e: 
2759: 2d1e:     WHILE LEN(DIR.VALUE$) <> XRE.ZERO%
2760: 2d29:         DIR.VALUE$ = FUNC.READ.SEQUENTIAL.FILE( DIR.FILE.RC% )          !DJK
2761: 2d4c:         ! we treat an error here as end of file and drop out
2762: 2d4c:         !--------------------------------------------------------!
2763: 2d4c:         ! Checking the file name and also making sure that the   !      !BDC
2764: 2d4c:         ! extension is numeric value ending                      !      !BDC
2765: 2d4c:         !--------------------------------------------------------!      !BDC
2766: 2d4c:         IF LEFT$(DIR.VALUE$,LEN(FILENAME$)) = FILENAME$     AND     \   !CJK
2767: 2ded:            MATCH("!",MID$(DIR.VALUE$,11,2) ,1) = XRE.ZERO% THEN BEGIN   !CJK
2768: 2ded: 
2769: 2ded:             DIR.VALUE$ = MID$(DIR.VALUE$,10,3)
2770: 2e14: 
2771: 2e14:             DUPLICATE.RECORD = FALSE                                    !CJK
2772: 2e2a: 
2773: 2e2a:             ! To make sure duplicate records are not added              !CJK
2774: 2e2a:             IF BKP.INDEX% > XRE.ZERO% THEN BEGIN                        !CJK
2775: 2e45:                 FOR INDEX% = 1 TO BKP.INDEX%                            !CJK
2776: 2e58:                     IF BKP.FILE.MDD.ARRAY$(INDEX%) = DIR.VALUE$ \       !CJK
2777: 2e8e:                     THEN BEGIN                                          !CJK
2778: 2e8e:                         DUPLICATE.RECORD = TRUE                         !CJK
2779: 2ea4:                     ENDIF                                               !CJK
2780: 2eac:                 NEXT INDEX%                                             !CJK
2781: 2ed4:             ENDIF                                                       !CJK
2782: 2edc: 
2783: 2edc:             ! Checking the BKP.INDEX% to avoid out of bound error
2784: 2edc:             IF BKP.INDEX% < ARRAY.LIMIT% THEN BEGIN                     !CJK
2785: 2ef5:                 IF NOT DUPLICATE.RECORD THEN BEGIN                      !CJK
2786: 2f07:                     BKP.INDEX% = BKP.INDEX% + 1                         !CJK
2787: 2f16:                     ! Storing the MDD value in an array
2788: 2f16:                     BKP.FILE.MDD.ARRAY$(BKP.INDEX%) = DIR.VALUE$
2789: 2f47:                 ENDIF                                                   !CJK
2790: 2f52:             ENDIF ELSE BEGIN
2791: 2f5a:                 STATUS.MSG$ = "'MDD array index error"
2792: 2f71:                 GOSUB LOG.STATUS.MSG
2793: 2f83:                 DIR.VALUE$               = XRE.NULL$                    !CJK
2794: 2fa1:                 FUNCTION.ERROR.NOT.EXIST = FALSE
2795: 2fb7:                 !-----------------------------------------------------! !CJK
2796: 2fb7:                 ! As the array index overflow happened, further read  ! !CJK
2797: 2fb7:                 ! is not required and hence setting the value to NULL ! !CJK
2798: 2fb7:                 ! to exit the WHILE loop                              ! !CJK
2799: 2fb7:                 !-----------------------------------------------------! !CJK
2800: 2fb7:                 DIR.VALUE$ = XRE.NULL$                                  !CJK
2801: 2fd5:             ENDIF
2802: 2fdd:         ENDIF
2803: 2fe5:     WEND
2804: 300d: 
2805: 300d:     ! Closing File
2806: 300d:     IF DIR.OPEN THEN BEGIN
2807: 301f:         CALL FUNC.CLOSE.FILE( DIR.FILE.RC% )                            !DJK
2808: 3048:         DIR.OPEN = FALSE
2809: 305e:     ENDIF
2810: 3066: 
2811: 3066:     VALUE.INDEX% = XRE.ZERO%
2812: 307d:     TODAY.DATE$  = DATE$
2813: 3095: 
2814: 3095:     !--------------------------------------------------------!
2815: 3095:     ! As BKP.INDEX is used as an index parameter for all the !
2816: 3095:     ! arrays in below FOR loop, checking the index to avoid  !
2817: 3095:     ! out of bound error                                     !
2818: 3095:     !--------------------------------------------------------!
2819: 3095:     IF BKP.INDEX% > ARRAY.LIMIT% THEN BEGIN                             !CJK
2820: 30ae:         STATUS.MSG$ = "'BKP array index error"
2821: 30c5:         GOSUB LOG.STATUS.MSG
2822: 30d7:         FUNCTION.ERROR.NOT.EXIST = FALSE
2823: 30ed: !        RETURN                                                         !DJK
2824: 30ed:         ! Setting zero as there is an array limit breach                !DJK
2825: 30ed:         BKP.INDEX% = XRE.ZERO%                                          !DJK
2826: 3103:     ENDIF
2827: 310b: 
2828: 310b:     ! If Backup available
2829: 310b:     IF BKP.INDEX% <> XRE.ZERO% THEN BEGIN
2830: 3126:         ! Checking last 14 days
2831: 3126:         FOR LOOP% = 1 TO BKP.DAYS%
2832: 313a:             ! Storing MMDD in a variable
2833: 313a:             WORK.DATE.MMDD$ = RIGHT$(TODAY.DATE$,4)
2834: 315f:             ! Checking the available backup dates
2835: 315f:             FOR INDEX% = 1 TO BKP.INDEX%
2836: 3173: 
2837: 3173:                 ! Getting the Month and date in MDD format
2838: 3173:                 IF LEFT$(BKP.FILE.MDD.ARRAY$(INDEX%),1) = "C" THEN BEGIN!CJK
2839: 31b9:                     BKP.FILE.MMDD.ARRAY$(INDEX%) = "12"   + \           !CJK
2840: 320a:                         RIGHT$(BKP.FILE.MDD.ARRAY$(INDEX%),2)           !CJK
2841: 320a:                 ENDIF ELSE \
2842: 3212:                 IF LEFT$(BKP.FILE.MDD.ARRAY$(INDEX%),1) = "B" THEN BEGIN!CJK
2843: 3258:                     BKP.FILE.MMDD.ARRAY$(INDEX%) = "11"   + \           !CJK
2844: 32a9:                         RIGHT$(BKP.FILE.MDD.ARRAY$(INDEX%),2)           !CJK
2845: 32a9:                 ENDIF ELSE \
2846: 32b1:                 IF LEFT$(BKP.FILE.MDD.ARRAY$(INDEX%),1) = "A" THEN BEGIN!CJK
2847: 32f7:                     BKP.FILE.MMDD.ARRAY$(INDEX%) = "10"   + \           !CJK
2848: 3347:                         RIGHT$(BKP.FILE.MDD.ARRAY$(INDEX%),2)           !CJK
2849: 3347:                 ENDIF ELSE BEGIN
2850: 334f:                     BKP.FILE.MMDD.ARRAY$(INDEX%) = "0"    + \           !CJK
2851: 3396:                         BKP.FILE.MDD.ARRAY$(INDEX%)                     !CJK
2852: 3396:                 ENDIF
2853: 339e: 
2854: 339e:                 ! If the Work date is available, store it in array
2855: 339e:                 IF BKP.FILE.MMDD.ARRAY$(INDEX%) = WORK.DATE.MMDD$ \
2856: 33d7:                 THEN BEGIN
2857: 33d7: 
2858: 33d7:                     VALUE.INDEX% = VALUE.INDEX% + 1
2859: 33e6: 
2860: 33e6:                     ! Checking the VALUE.INDEX% to avoid out of bound
2861: 33e6:                     IF VALUE.INDEX% < ARRAY.LIMIT% THEN BEGIN           !CJK
2862: 3401: 
2863: 3401:                         ! Storing the date and MMDD
2864: 3401:                         BKP.DATE.ARRAY$(VALUE.INDEX%)  = TODAY.DATE$
2865: 3430:                         BKP.AVAIL.ARRAY$(VALUE.INDEX%) = WORK.DATE.MMDD$
2866: 345f: 
2867: 345f:                         FUN.RC2% = PSDATE(TODAY.DATE$)
2868: 3481: 
2869: 3481:                         ! Checking the return value
2870: 3481:                         IF FUN.RC2% <> XRE.ZERO% THEN BEGIN
2871: 349a:                             STATUS.MSG$ = "PSDATE function error"
2872: 34b1:                             GOSUB LOG.STATUS.MSG
2873: 34c3:                             DAY.ARRAY$(VALUE.INDEX%) = "Date error"
2874: 34eb:                             FUNCTION.ERROR.NOT.EXIST = FALSE
2875: 3504:                         ENDIF ELSE BEGIN
2876: 350c:                             ! Storing the DAY value
2877: 350c:                             IF F13.DAY$ = "SUN" THEN BEGIN
2878: 352a:                                 DAY.ARRAY$(VALUE.INDEX%) = "Sunday"
2879: 3555:                             ENDIF ELSE IF F13.DAY$ = "MON" THEN BEGIN
2880: 3573:                                 DAY.ARRAY$(VALUE.INDEX%) = "Monday"
2881: 359e:                             ENDIF ELSE IF F13.DAY$ = "TUE" THEN BEGIN
2882: 35bc:                                 DAY.ARRAY$(VALUE.INDEX%) = "Tuesday"
2883: 35e7:                             ENDIF ELSE IF F13.DAY$ = "WED" THEN BEGIN
2884: 3605:                                 DAY.ARRAY$(VALUE.INDEX%) = "Wednesday"
2885: 3630:                             ENDIF ELSE IF F13.DAY$ = "THU" THEN BEGIN
2886: 364e:                                 DAY.ARRAY$(VALUE.INDEX%) = "Thursday"
2887: 3679:                             ENDIF ELSE IF F13.DAY$ = "FRI" THEN BEGIN
2888: 3697:                                 DAY.ARRAY$(VALUE.INDEX%) = "Friday"
2889: 36c1:                             ENDIF ELSE IF F13.DAY$ = "SAT" THEN BEGIN
2890: 36df:                                 DAY.ARRAY$(VALUE.INDEX%) = "Saturday"
2891: 3707:                             ENDIF
2892: 370f:                         ENDIF
2893: 371a: 
2894: 371a:                     ENDIF ELSE BEGIN
2895: 3722:                         STATUS.MSG$  = "'MDD array index error"
2896: 3739:                         GOSUB LOG.STATUS.MSG
2897: 374b:                         FUNCTION.ERROR.NOT.EXIST = FALSE
2898: 3761: !                        RETURN                                         !DJK
2899: 3761:                         LOOP%  = BKP.DAYS%  + 10   ! force to exit      !CJK
2900: 377a:                         INDEX% = BKP.INDEX% + 10   ! force to exit      !CJK
2901: 3793:                     ENDIF
2902: 379b:                 ENDIF
2903: 37a3:             NEXT INDEX%
2904: 37ce: 
2905: 37ce:             IF INDEX% < (BKP.INDEX% + 10) THEN BEGIN                    !CJK
2906: 37e9:                 F02.DATE$ = TODAY.DATE$
2907: 3807:                 FUN.RC2%  = UPDATE.DATE( -1 )           ! Reduce one day!CJK
2908: 3826: 
2909: 3826:                 GOSUB CHECK.UPDATE.DATE.RC
2910: 3838: 
2911: 3838:                 TODAY.DATE$ = F02.DATE$
2912: 3856:             ENDIF
2913: 385e: 
2914: 385e:         NEXT LOOP%
2915: 3888:     ENDIF
2916: 3890: 
2917: 3890: RETURN
2918: 38a0: 
2919: 38a0: \***********************************************************************
2920: 38a0: \*
2921: 38a0: \* EXTRACT.BKPLIST.FIELDS:  This function receives the line value of
2922: 38a0: \*                          BKPLIST, process it and return the
2923: 38a0: \*                          individual BKPLIST field values for use.
2924: 38a0: \*
2925: 38a0: \***********************************************************************
2926: 38a0: EXTRACT.BKPLIST.FIELDS:
2927: 38b0: 
2928: 38b0:     FUNCTION.ERROR.NOT.EXIST = TRUE
2929: 38c6: 
2930: 38c6:     BKPLIST.VALUE$ = BKPLIST.DIR.VALUE$
2931: 38e4: 
2932: 38e4:     DIM BKPLIST.FIELD$(0)         ! Clear the array memory allocation
2933: 3913:     DIM BKPLIST.FIELD$(15)        ! To store BKPLIST values
2934: 3942: 
2935: 3942:     BEGIN.POS%    = 1           ! Begin search position                 !CJK
2936: 3953:     INDEX%        = XRE.ZERO%   ! Index for Field Array                 !CJK
2937: 396a:     VALUE.PRESENT = TRUE        ! While Boolean                         !CJK
2938: 3980: 
2939: 3980:     !----------------------------------------------------------!
2940: 3980:     ! Extracting all the variables using comma separator value !
2941: 3980:     !----------------------------------------------------------!
2942: 3980:     WHILE VALUE.PRESENT
2943: 398b:         ! Get index of next field delimiter
2944: 398b:         MATCH.POS% = MATCH(COMMA.VALUE$,BKPLIST.VALUE$,BEGIN.POS%)
2945: 39bc: 
2946: 39bc:         INDEX%     = INDEX% + 1     ! Incrementing the index            !CJK
2947: 39cb: 
2948: 39cb:         ! Checking the INDEX% to avoid out of bound error
2949: 39cb:         IF VALUE.INDEX% > ARRAY.LIMIT% THEN BEGIN                       !CJK
2950: 39e3:             STATUS.MSG$ = "'MDD array index error"
2951: 39fa:             GOSUB LOG.STATUS.MSG
2952: 3a0c:             FUNCTION.ERROR.NOT.EXIST = FALSE
2953: 3a22:             !-----------------------------------------------------!     !CJK
2954: 3a22:             ! As the array index overflow happened, further check !     !CJK
2955: 3a22:             ! is not required and hence setting the value to      !     !CJK
2956: 3a22:             ! FALSE to exit the WHILE loop                        !     !CJK
2957: 3a22:             !-----------------------------------------------------!     !CJK
2958: 3a22:             VALUE.PRESENT = FALSE                                       !CJK
2959: 3a38:         ENDIF
2960: 3a40: 
2961: 3a40:         ! If we found a field delimiter
2962: 3a40:         IF MATCH.POS% > XRE.ZERO% THEN BEGIN
2963: 3a59:             ! Get contents of field
2964: 3a59:             BKPLIST.FIELD$(INDEX%) = MID$(BKPLIST.VALUE$, BEGIN.POS%, \
2965: 3aa3:                                      (MATCH.POS% - BEGIN.POS%)  )
2966: 3aa3:             ! Move next start position past field delimiter
2967: 3aa3:             BEGIN.POS% = MATCH.POS% + 1
2968: 3abc:         ENDIF ELSE BEGIN
2969: 3ac4:             ! Else we're at the last field
2970: 3ac4:             VALUE.PRESENT = FALSE
2971: 3ada:         ENDIF
2972: 3ae2:     WEND
2973: 3af7: 
2974: 3af7:     ! Storing the values
2975: 3af7:     BKPLI.FILENAME$                 = BKPLIST.FIELD$(1)
2976: 3b21:     BKPLI.FULL.EXIST$               = BKPLIST.FIELD$(2)
2977: 3b4b:     BKPLI.FULL.FILE.CHNG$           = BKPLIST.FIELD$(3)
2978: 3b75:     BKPLI.INCREMENTAL.EXIST$(1)     = BKPLIST.FIELD$(4)
2979: 3bab:     BKPLI.INCREMENTAL.FILE.CHNG$(1) = BKPLIST.FIELD$(5)
2980: 3be1:     BKPLI.INCREMENTAL.EXIST$(2)     = BKPLIST.FIELD$(6)
2981: 3c17:     BKPLI.INCREMENTAL.FILE.CHNG$(2) = BKPLIST.FIELD$(7)
2982: 3c4d:     BKPLI.INCREMENTAL.EXIST$(3)     = BKPLIST.FIELD$(8)
2983: 3c83:     BKPLI.INCREMENTAL.FILE.CHNG$(3) = BKPLIST.FIELD$(9)
2984: 3cb9:     BKPLI.INCREMENTAL.EXIST$(4)     = BKPLIST.FIELD$(10)
2985: 3cef:     BKPLI.INCREMENTAL.FILE.CHNG$(4) = BKPLIST.FIELD$(11)
2986: 3d25:     BKPLI.INCREMENTAL.EXIST$(5)     = BKPLIST.FIELD$(12)
2987: 3d5b:     BKPLI.INCREMENTAL.FILE.CHNG$(5) = BKPLIST.FIELD$(13)
2988: 3d91:     BKPLI.INCREMENTAL.EXIST$(6)     = BKPLIST.FIELD$(14)
2989: 3dc7:     BKPLI.INCREMENTAL.FILE.CHNG$(6) = BKPLIST.FIELD$(15)
2990: 3dfd: 
2991: 3dfd: RETURN
2992: 3e0d: 
2993: 3e0d: \***********************************************************************
2994: 3e0d: \*
2995: 3e0d: \* CHECK.DAY.SELECTION: This function checks the DAY selection on
2996: 3e0d: \*                      process. If successful selection, it sets
2997: 3e0d: \*                      the passed screen number.
2998: 3e0d: \*
2999: 3e0d: \***********************************************************************
3000: 3e0d: CHECK.DAY.SELECTION:
3001: 3e1d: 
3002: 3e1d:     FUNCTION.ERROR.NOT.EXIST = TRUE
3003: 3e33: 
3004: 3e33:     INPUT.LOOP%   = INPUT.INDEX%    ! First input field value
3005: 3e4a:     SEL.INDEX%    = XRE.ZERO%
3006: 3e61:     SELECT.COUNT% = XRE.ZERO%
3007: 3e78:     NON.X.VALUES  = FALSE
3008: 3e8e: 
3009: 3e8e:     ! Checking the inputs entered
3010: 3e8e:     FOR LOOP% = 1 TO VALUE.INDEX%
3011: 3ea2: 
3012: 3ea2:         ! If field contains any value
3013: 3ea2:         IF FIELD$(INPUT.LOOP%) <> XRE.SPACE$ THEN BEGIN
3014: 3edb: 
3015: 3edb:             ! If entered value is not X
3016: 3edb:             IF UCASE$(FIELD$(INPUT.LOOP%)) <> "X" THEN BEGIN
3017: 3f1d:                 NON.X.VALUES = TRUE
3018: 3f35:             ENDIF ELSE BEGIN
3019: 3f3d:                 SEL.INDEX% = LOOP%
3020: 3f53:             ENDIF
3021: 3f5b: 
3022: 3f5b:             ! Increment the value to check the multiple selection
3023: 3f5b:             SELECT.COUNT% = SELECT.COUNT% + 1
3024: 3f6a:         ENDIF
3025: 3f72:         ! Increment to move to the next input field record
3026: 3f72:         INPUT.LOOP% = INPUT.LOOP% + 1
3027: 3f81:     NEXT LOOP%
3028: 3fab: 
3029: 3fab:     ! If multiple selections made
3030: 3fab:     IF SELECT.COUNT% > 1 THEN BEGIN
3031: 3fbd:         FIELD$(1) = "'Multiple selections not allowed"
3032: 3fe3:     ENDIF ELSE BEGIN
3033: 3feb: 
3034: 3feb:         ! If only one selection made and X value is entered
3035: 3feb:         IF SELECT.COUNT% = 1 AND NOT NON.X.VALUES THEN BEGIN
3036: 4010:             SCREEN% = SCREEN.NUM%
3037: 4028: 
3038: 4028:         ! If no selection has been made
3039: 4028:         ENDIF ELSE BEGIN
3040: 4030:             FIELD$(1) = "'No selection has been made. "              + \
3041: 405a:                         "Value entered must be ""X"" OR ""x"" "
3042: 405a:         ENDIF
3043: 4062:     ENDIF
3044: 406a: 
3045: 406a: RETURN
3046: 407a: 
3047: 407a: \***********************************************************************
3048: 407a: \*
3049: 407a: \* LOG.STATUS.MSG: Writes status message to log file
3050: 407a: \*
3051: 407a: \***********************************************************************
3052: 407a: LOG.STATUS.MSG:
3053: 408a: 
3054: 408a:     IF XRE.LOG.OPEN THEN BEGIN
3055: 409f: 
3056: 409f:         ! DD/MM/YY, HH:MM:SS, Text and a CRLF
3057: 409f:         STATUS.MSG$ = RIGHT$(DATE$,2) + "/"        + \    ! DD/         !CJK
3058: 41c5:                       MID$(DATE$,3,2) + "/"        + \    ! MM/         !CJK
3059: 41c5:                       LEFT$(DATE$,2)  + XRE.SPACE$ + \    ! YY          !CJK
3060: 41c5:                       LEFT$(TIME$,2)  + ":"        + \    ! HH:         !CJK
3061: 41c5:                       MID$(TIME$,3,2) + ":"        + \    ! MM:         !CJK
3062: 41c5:                       RIGHT$(TIME$,2) + XRE.SPACE$ + \    ! SS          !CJK
3063: 41c5:                       STATUS.MSG$                  + \    ! message     !CJK
3064: 41c5:                       CRLF$                               ! line return !CJK
3065: 41c5: 
3066: 41c5:         ! Return code is not checked here, as it is not mandatory.
3067: 41c5:         ! Checking return code is not required here, as it is a         !CJK
3068: 41c5:         ! screen program and displaying any error for logging might     !CJK
3069: 41c5:         ! confuse the user from actual restore functionality            !CJK
3070: 41c5:         FILE.RC% = FUNC.WRITE.SEQUENTIAL.FILE(XRE.FILE.RC%, STATUS.MSG$)!DJK
3071: 41fa: 
3072: 41fa:     ENDIF
3073: 4202: 
3074: 4202: RETURN
3075: 4212: 
3076: 4212: \***********************************************************************
3077: 4212: \*
3078: 4212: \* CHECK.UPDATE.DATE.RC: If FUN.RC2% is not equal to zero ... logs
3079: 4212: \*                       the error for reference.
3080: 4212: \***********************************************************************
3081: 4212: CHECK.UPDATE.DATE.RC:
3082: 4222: 
3083: 4222:     ! Checking the return value
3084: 4222:     IF FUN.RC2% <> XRE.ZERO% THEN BEGIN
3085: 423b:         STATUS.MSG$ = "UPDATE date function error in " + F02.DATE$
3086: 4260:         GOSUB LOG.STATUS.MSG
3087: 4272:     ENDIF
3088: 427a: 
3089: 427a: RETURN
3090: 428a: 
3091: 428a: \***********************************************************************
3092: 428a: \*
3093: 428a: \*   GET.FILE.EXTENSION: Calculate the extension needed based on month
3094: 428a: \*                       and day using month A/B/C for 10/11/12
3095: 428a: \*
3096: 428a: \***********************************************************************
3097: 428a: GET.FILE.EXTENSION:
3098: 429a: 
3099: 429a:     EXTENSION$ = RIGHT$(FULL.TO.MOVING.DATE$, 4)
3100: 42bf: 
3101: 42bf:     ! Storing the Month and Date in MDD format in new logic
3102: 42bf:     IF LEFT$(EXTENSION$,2) = "12" THEN BEGIN            ! If Dec(12)    !CJK
3103: 42f4:         EXTENSION$ = "C" + RIGHT$(EXTENSION$, 2)
3104: 4323:     ENDIF ELSE IF LEFT$(EXTENSION$,2) = "11" THEN BEGIN ! If Nov(11)    !CJK
3105: 4358:         EXTENSION$ = "B" + RIGHT$(EXTENSION$, 2)
3106: 4387:     ENDIF ELSE IF LEFT$(EXTENSION$,2) = "10" THEN BEGIN ! If Oct(10)    !CJK
3107: 43bc:         EXTENSION$ = "A" + RIGHT$(EXTENSION$, 2)
3108: 43ea:     ENDIF ELSE BEGIN                            ! Rest of the Month
3109: 43f2:         EXTENSION$ = RIGHT$(EXTENSION$, 3)
3110: 4417:     ENDIF
3111: 441f: 
3112: 441f: RETURN
3113: 442f: 
3114: 442f: !* START CHANGE BLOCK FOR BDC
3115: 442f: \***********************************************************************
3116: 442f: \*
3117: 442f: \* COPY.OS.BLANK.FILES: Copy the blank OS files needed that the old
3118: 442f: \*                      CRESTORE batch file used to do
3119: 442f: \*
3120: 442f: \***********************************************************************
3121: 442f: COPY.OS.BLANK.FILES:
3122: 4437: 
3123: 4437:     DIM OS.FILE$(0)
3124: 4466:     DIM OS.FILE$(8)
3125: 4495: 
3126: 4495:     ! set the required files
3127: 4495:     OS.FILE$(1) = "ADXCSOAF.DAT"
3128: 44b8:     OS.FILE$(2) = "ADXCSOBF.DAT"
3129: 44db:     OS.FILE$(3) = "ADXCSOCF.DAT"
3130: 44fe:     OS.FILE$(4) = "ADXCSODF.DAT"
3131: 4521:     OS.FILE$(5) = "ADXCSOEF.DAT"
3132: 4544:     OS.FILE$(6) = "ADXCSOFF.DAT"
3133: 4567:     OS.FILE$(7) = "ADXCSOIF.DAT"
3134: 458a:     OS.FILE$(8) = "ADXCSONF.DAT"
3135: 45ad: 
3136: 45ad:     ! set the source and destination for copy
3137: 45ad:     OS.DESTINATION$ = "C:\ADX_SDT1\"
3138: 45c4:     OS.SOURCE$      = "D:\ADX_UPGM\"
3139: 45db: 
3140: 45db:     FOR SELECT.COUNT% = 1 TO 8
3141: 45ef:         ! Copying the file from TEMP to the entered location
3142: 45ef:         CALL OSSHELL("COPY " + OS.SOURCE$ + OS.FILE$(SELECT.COUNT%) + \ !CJK
3143: 4669:                      XRE.SPACE$ + OS.DESTINATION$                   + \ !CJK
3144: 4669:                      " > " + DIR.OUT$ + " >>* " + DIR.OUT$)
3145: 4669: 
3146: 4669:         DIR.FILE.RC% = FUNC.OPEN.SEQUENTIAL.FILE( DIR.OUT$ )            !DJK
3147: 4693: 
3148: 4693:         ! If file open unsuccessful
3149: 4693:         IF DIR.FILE.RC% <= XRE.ZERO% THEN BEGIN
3150: 46b1:             DIR.OPEN    = FALSE                                         !CJK
3151: 46c7:             STATUS.MSG$ = "Error in opening DIR output file"
3152: 46de:             GOSUB LOG.STATUS.MSG
3153: 46f0:             ! Setting NULL to avoid file read
3154: 46f0:             DIR.VALUE$ = XRE.NULL$
3155: 4710:         ENDIF ELSE BEGIN
3156: 4718:             DIR.OPEN   = TRUE
3157: 472e:             DIR.VALUE$ = XRE.SPACE$
3158: 474c:         ENDIF
3159: 4754: 
3160: 4754:         ! Read the file till EOF or read error
3161: 4754:         WHILE LEN(DIR.VALUE$) <> XRE.ZERO%
3162: 475f:             DIR.VALUE$ = FUNC.READ.SEQUENTIAL.FILE( DIR.FILE.RC% )      !DJK
3163: 4782: 
3164: 4782:             !-----------------------------------------------!
3165: 4782:             ! If error string matches, write the error with !
3166: 4782:             ! file name in LOG file                         !
3167: 4782:             !-----------------------------------------------!
3168: 4782:             IF MATCH(UCASE$("Error extracting file"),   \               !CJK
3169: 47d3:                      UCASE$(DIR.VALUE$),1) <> XRE.ZERO% THEN BEGIN      !CJK
3170: 47d3:                 ! Logging copy error                                    !CJK
3171: 47d3:                 STATUS.MSG$ = "Error when copying OS file " + \
3172: 4809:                               OS.FILE$(SELECT.COUNT%)
3173: 4809:                 GOSUB LOG.STATUS.MSG
3174: 481b:                 RESTORE.STATUS = FALSE
3175: 4831:             ENDIF
3176: 4839:         WEND
3177: 4861: 
3178: 4861:         ! Closing File
3179: 4861:         IF DIR.OPEN THEN BEGIN
3180: 4873:             CALL FUNC.CLOSE.FILE( DIR.FILE.RC% )                        !DJK
3181: 489c:             DIR.OPEN = FALSE
3182: 48b2:         ENDIF
3183: 48ba:     NEXT SELECT.COUNT%
3184: 48de: RETURN
3185: 48ee: !* END CHANGE BLOCK FOR BDC
3186: 48ee: 
3187: 48ee: 
3188: 48ee: END SUB
3189: 4902: 
3190: 4902: End of Compilation
