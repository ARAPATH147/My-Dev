   1: 0003: \***********************************************************************
   2: 0003: \*
   3: 0003: \*            PROGRAM         :       XRESTORE
   4: 0003: \*            MODULE          :       XREST000
   5: 0003: \*            AUTHOR          :       Jaya Kumar Inbaraj
   6: 0003: \*            DATE WRITTEN    :       Mar 2014
   7: 0003: \*
   8: 0003: \***********************************************************************
   9: 0003: 
  10: 0003: \***********************************************************************
  11: 0003: \*
  12: 0003: \* Program: XRESTORE          Jaya Kumar Inbaraj              04/03/2014
  13: 0003: \*
  14: 0003: \* FOD260 - Enhanced Backup and Recovery
  15: 0003: \*
  16: 0003: \* This program displays user friendly screens and allows the user to
  17: 0003: \* restore both drives OR single drive OR a single directory OR a
  18: 0003: \* single file. This program will only restore on the Acting Master
  19: 0003: \* & File Server.
  20: 0003: \*
  21: 0003: \* For Drive restore, the program checks the existence of BKPFAIL and
  22: 0003: \* displays the number of available backup dates. Using available
  23: 0003: \* Backup dates, the drive restoration process will be proceeded.
  24: 0003: \*
  25: 0003: \* For Directory restore, the available directory will be shown from
  26: 0003: \* BKPSCRPT file. Then selected directory will be checked in XDISKIMG
  27: 0003: \* or XDISKALT (If C:/ADX_UPGM/ is selected, CUPGM.* will be searched)
  28: 0003: \* and all the available days will be displayed in the next screen.
  29: 0003: \* Using available backup dates, the directory restoration process
  30: 0003: \* will be proceeded.
  31: 0003: \*
  32: 0003: \* For File restore, name of the complete file will be taken as an
  33: 0003: \* input. Then the directory of the file will be checked, similar as
  34: 0003: \* above directory search. All the available dates will be displayed.
  35: 0003: \* ADXUNZIP will be used for File Restore as it has option to extract
  36: 0003: \* single file from ZIP archive.
  37: 0003: \*
  38: 0003: \* Refer BKPSCRPT.TXT for all the available directories eligible
  39: 0003: \* under restore.
  40: 0003: \*
  41: 0003: \* SCRIPT FILE
  42: 0003: \* ===========
  43: 0003: \* BKPSCRPT file would be in following record format:
  44: 0003: \*
  45: 0003: \*      COMMAND          REQUIRED VALUES FOLLOWING
  46: 0003: \*      -------          -------------------------
  47: 0003: \*      TIME RANGE       START TIME     END TIME
  48: 0003: \*      DAYS TO KEEP     NO. OF DAYS
  49: 0003: \*      BACKUP           DIRECTORY      PRIMARY     SECONDARY
  50: 0003: \*                                      ARCHIVE     ARCHIVE
  51: 0003: \*                                      DIRECTORY   DIRECTORY
  52: 0003: \*      EXCLUDE          FILE NAME
  53: 0003: \*
  54: 0003: \* PASSED PARAMTERS N/A
  55: 0003: \* ================
  56: 0003: \*
  57: 0003: \* INPUT AND OUTPUT FILES
  58: 0003: \* ======================
  59: 0003: \* Input files : BKPSCRPT.TXT  (Backup Script File)
  60: 0003: \*               BKPLIST.MDD   (Backup List File)
  61: 0003: \*               BKPFAILC.MDD  (Backup Fail File for C drive)
  62: 0003: \*               BKPFAILD.MDD  (Backup Fail File for D drive)
  63: 0003: \*               C:\XDISKIMG\*.* (D directories primary archive)
  64: 0003: \*               D:\XDISKIMG\*.* (C directories primary archive)
  65: 0003: \*               C:\XDISKALT\*.* (D directories Secondary archive)
  66: 0003: \*               D:\XDISKALT\*.* (C directories Secondary archive)
  67: 0003: \*
  68: 0003: \* Output files: XRESTORE.LOG    (XRESTORE Log File)
  69: 0003: \*               EXTRACTED FILES
  70: 0003: \*               (e.g. Files will be restored to C:\ADX_SPGM\
  71: 0003: \*                from CSPGM.* archive files)
  72: 0003: \*
  73: 0003: \*======================================================================
  74: 0003: \*                   V E R S I O N   C O N T R O L
  75: 0003: \* (Update STATUS.TEXT.MSG$(12) for Application Version. Consider
  76: 0003: \*  Version H as a Base version 1.0)
  77: 0003: \*======================================================================
  78: 0003: \*
  79: 0003: \* Version B               Jaya kumar Inbaraj                 18/04/2014
  80: 0003: \* FOD260 - Enhanced Backup and Recovery
  81: 0003: \* Updated the code with respect to the BKPLIST file function changes
  82: 0003: \*
  83: 0003: \* Version C               Jaya kumar Inbaraj                 29/04/2014
  84: 0003: \* FOD260 - Enhanced Backup and Recovery
  85: 0003: \* Updated the code with respect to Internal review comments
  86: 0003: \*
  87: 0003: \* Version D               Jaya kumar Inbaraj                 09/05/2014
  88: 0003: \* FOD260 - Enhanced Backup and Recovery
  89: 0003: \* Updated the code with respect to Application Management Team
  90: 0003: \* review comments
  91: 0003: \*
  92: 0003: \* Version E               Jaya kumar Inbaraj                 14/05/2014
  93: 0003: \* FOD260 - Enhanced Backup and Recovery
  94: 0003: \* Updated the code with respect to Application Management Team
  95: 0003: \* review comments
  96: 0003: \*
  97: 0003: \* Version F     Jaya kumar Inbaraj / Dave Constable          21/05/2014
  98: 0003: \* FOD260 - Enhanced Backup and Recovery
  99: 0003: \* Internal and Application Management Team review comments
 100: 0003: \* QC671 - adjusted max directory length to 12 (from 20)
 101: 0003: \* QC665 - added termination call to sequence to get correct message
 102: 0003: \*
 103: 0003: \* Version G               Jaya kumar Inbaraj                 04/06/2014
 104: 0003: \* FOD260 - Enhanced Backup and Recovery
 105: 0003: \* QC 653, 654, 656, 660, 662, 663, 664, 674, 675, 676
 106: 0003: \* Text on the screen / log and the logic has been updated. Also updated
 107: 0003: \* the corresponding screen files.
 108: 0003: \*
 109: 0003: \* Version H               Jaya kumar Inbaraj                 09/06/2014
 110: 0003: \* FOD260 - Enhanced Backup and Recovery
 111: 0003: \* Added a separate variable to detect the directory creation error in
 112: 0003: \* File restoration.
 113: 0003: \*
 114: 0003: \* Version I                 Dave Constable                   05/06/2014
 115: 0003: \* FOD260 - Enhanced Backup and Recovery changes to enable CR for
 116: 0003: \* configurable Full backup day and code review changes
 117: 0003: \*
 118: 0003: \* Version J                 Dave Constable                   25/06/2014
 119: 0003: \* FOD260 - Enhanced Backup and Recovery
 120: 0003: \* Code review changes; alignment of file open status
 121: 0003: \* QC824 - corrected LAN file name for slpcf to local or SUPPS fail
 122: 0003: \*
 123: 0003: \*       MODULE RENAMED TO XREST000.BAS AS BREACHED 64K LIMIT
 124: 0003: \*       ORIGINAL SUB PROGRAM MOVED INTO XREST001.BAS
 125: 0003: \*
 126: 0003: \* Version K                 Dave Constable                   10/07/2014
 127: 0003: \* FOD260 - Enhanced Backup and Recovery
 128: 0003: \* CR4 - Help screen changes
 129: 0003: \*
 130: 0003: \* Version L                 Jaya Kumar Inbaraj               01/08/2014
 131: 0003: \* FOD260 - Enhanced Backup and Recovery
 132: 0003: \* QC717 and QC724 - Restoration for files in BKPFAIL has been fixed.
 133: 0003: \*
 134: 0003: \* Version M                 Jaya Kumar Inbaraj               23/08/2014
 135: 0003: \* FOD260 - Enhanced Backup and Recovery
 136: 0003: \* CR5 changes to have configuration files in both C and D drives. Also
 137: 0003: \* BKPFAIL.MDD file has been replaced with BKPFAILC.MDD and BKPFAILD.MDD
 138: 0003: \* to have separate BKPFAIL file for C and D drive.
 139: 0003: \* Also worked on Internal and APPS management review comments.
 140: 0003: \* Added an Header for easy reference on multi-modular program.
 141: 0003: \*
 142: 0003: \* Version N                 Jaya Kumar Inbaraj               04/09/2014
 143: 0003: \* FOD260 - Enhanced Backup and Recovery
 144: 0003: \* Worked on APPS management review comments.
 145: 0003: \*
 146: 0003: \* Version O                 Jaya Kumar Inbaraj               12/09/2014
 147: 0003: \* QC1145 - Using ADXUNZIP for file restore.
 148: 0003: \*
 149: 0003: \* Version P                 Ranjith Gopalankutty             12/07/2017
 150: 0003: \* Enhancement done to XRESTORE, going forward it will not refer the
 151: 0003: \* sleepr file for identifying the full backup and incremental back
 152: 0003: \* ups. As there are no more incremental backups going forward. 
 153: 0003: \* XRESTORE will just do the backup based on the date and file 
 154: 0003: \* extension.
 155: 0003: \***********************************************************************
 156: 0003: 
 157: 0003: \***********************************************************************
 158: 0003: \*
 159: 0003: \* Included global variables                                            !KDC
 160: 0003: \*
 161: 0003: \***********************************************************************
 162: 0003:     %INCLUDE XRESTORG.J86                                               !MJK
 163: 0003: \***********************************************************************
 164: 0003: \*
 165: 0003: \* Program: XRESTORE          Jaya Kumar Inbaraj              04/03/2014
 166: 0003: \*
 167: 0003: \* FOD260 - Enhanced Backup and Recovery
 168: 0003: \*
 169: 0003: \*           %INCLUDE for Global variables used in XRESTORE
 170: 0003: \*
 171: 0003: \*                    REFERENCE: XRESTORG.J86
 172: 0003: \*
 173: 0003: \*       MODULE EXTRACTED FROM ORIGINAL XRESTORE.BAS (RENAMED TO
 174: 0003: \*       XREST000.BAS) AS BREACHED 64K LIMIT AND CRETAED AS XREST001.BAS
 175: 0003: \*
 176: 0003: \*======================================================================
 177: 0003: \*                   V E R S I O N   C O N T R O L
 178: 0003: \*======================================================================
 179: 0003: \*
 180: 0003: \*                            Dave Constable                  25/06/2014
 181: 0003: \* FOD260 - Enhanced Backup and Recovery
 182: 0003: \* Code extracted originally from single module (XRESTORE.BAS) and all
 183: 0003: \* code change markers removed.
 184: 0003: \* For maintenance and usage all included variables and includes are
 185: 0003: \* also replicated here and included into both modules.
 186: 0003: \*
 187: 0003: \* Version B                Jaya Kumar Inbaraj                01/08/2014
 188: 0003: \* FOD260 - Enhanced Backup and Recovery
 189: 0003: \* Created a variable for BKPFAIL restore.
 190: 0003: \*
 191: 0003: \* Version C                Jaya Kumar Inbaraj                23/08/2014
 192: 0003: \* FOD260 - Enhanced Backup and Recovery
 193: 0003: \* CR5 changes to perform the drive restore if a drive is empty.
 194: 0003: \* Also updated the header block comments.
 195: 0003: \*
 196: 0003: \* Version D                Jaya Kumar Inbaraj                12/09/2014
 197: 0003: \* QC1145 - Added ADXUNZIP related variables
 198: 0003: \*
 199: 0003: \***********************************************************************
 200: 0003: 
 201: 0003: \***********************************************************************
 202: 0003: \*
 203: 0003: \* Included code defining file related global variables
 204: 0003: \*
 205: 0003: \***********************************************************************
 206: 0003:     !-----------------------------------------------------------------!
 207: 0003:     ! Changed the BKPLIST file variables prefix from BKPLIST to BKPLI !
 208: 0003:     ! and hence applied the changes in whole XRESTORE program also    !
 209: 0003:     !-----------------------------------------------------------------!
 210: 0003:     %INCLUDE BKPLIDEC.J86    ! BKPLIST file variables
 211: 0003: \***********************************************************************
 212: 0003: \***********************************************************************
 213: 0003: \*
 214: 0003: \*    BKPLIST - Backup List File
 215: 0003: \*
 216: 0003: \*    %INCLUDE FOR VARIABLE DECLARATIONS
 217: 0003: \*
 218: 0003: \*        REFERENCE   :   BKPLIDEC.J86
 219: 0003: \*
 220: 0003: \*        FILE TYPE   :   Sequential
 221: 0003: \*
 222: 0003: \* Version A              Jaya Kumar Inbaraj              04/02/2014
 223: 0003: \* Original version.
 224: 0003: \*
 225: 0003: \* Version B              Jaya Kumar Inbaraj              09/04/2014
 226: 0003: \* FOD260 - Enhanced Backup and Recovery
 227: 0003: \* Changed all the file function variables from BKPLIST prefix to
 228: 0003: \* BKPLI prefix.
 229: 0003: \*
 230: 0003: \* Version C              Jaya Kumar Inbaraj              29/04/2014
 231: 0003: \* FOD260 - Enhanced Backup and Recovery
 232: 0003: \* Commented out the unused variables
 233: 0003: \*
 234: 0003: \* Version D              Dave Constable                  05/06/2014
 235: 0003: \* changes for generic full and incremental backups rather than forced 
 236: 0003: \* Sunday
 237: 0003: \*
 238: 0003: \***********************************************************************
 239: 0003: \***********************************************************************
 240: 0003: 
 241: 0003:     ! Changed the File related variables from BKPLIST to BKPLI prefix   !BJK
 242: 0003:     STRING GLOBAL                     \
 243: 0003: \        BKPLIST.CRLF$,                \                                !CJK
 244: 0003:         BKPLI.FILE.NAME$,             \ BKPLIST file name
 245: 0003:         BKPLI.FILENAME$,              \ File present in BKPLIST
 246: 0003:         BKPLI.FULL.EXIST$,            \                                 !DDC
 247: 0003:         BKPLI.FULL.FILE.CHNG$,        \                                 !DDC
 248: 0003:         BKPLI.INCREMENTAL.EXIST$(1),  \                                 !DDC
 249: 0003:         BKPLI.INCREMENTAL.FILE.CHNG$(1), \                              !DDC
 250: 0003:         BKPLI.VALUE$                                                    !DDC        
 251: 0003: 
 252: 0003:     ! Changed the File related variables from BKPLIST to BKPLI prefix   !BJK
 253: 0003:     INTEGER*2 GLOBAL                  \
 254: 0003: \        BKPLI.RECL%,                  \                                !CJK
 255: 0003:         BKPLI.RECORD.NUM%,            \
 256: 0003:         BKPLI.REPORT.NUM%,            \
 257: 0003:         BKPLI.SESS.NUM%
 258: 0003: 
 259: 0003:     INTEGER*1 GLOBAL                  \
 260: 0003:         BKPLIST.NO.OF.FIELDS%
 261: 0003: 
 262: 0003: 
 263: 0003: 
 264: 0003: \***********************************************************************
 265: 0003: \*
 266: 0003: \* Included code defining function related global variables
 267: 0003: \*
 268: 0003: \***********************************************************************
 269: 0003:     %INCLUDE PSBF02G.J86     ! Update Date
 270: 0003: REM\
 271: 0003: \*******************************************************************************
 272: 0003: \*******************************************************************************
 273: 0003: \***
 274: 0003: \***        INCLUDE       : UPDATE.DATE globals
 275: 0003: \***
 276: 0003: \***        REFERENCE     : PSBF02G.J86
 277: 0003: \***
 278: 0003: \***        Version A     Bruce Scriver      4th March 1986
 279: 0003: \*** 
 280: 0003: \***        Version B     Andrew Wedgeworth   6th July 1992
 281: 0003: \***        Removal of return code field which no longer required.
 282: 0003: \***
 283: 0003: \*******************************************************************************
 284: 0003: \*******************************************************************************
 285: 0003: 
 286: 0003:       STRING   GLOBAL F02.DATE$
 287: 0003: 
 288: 0003:       ! 1 line deleted from here                                       ! BAW
 289: 0003: 
 290: 0003:     %INCLUDE PSBF13G.J86     ! PSDATE function
 291: 0003: REM\
 292: 0003: \*******************************************************************************
 293: 0003: \*******************************************************************************
 294: 0003: \***
 295: 0003: \***        INCLUDE       : PSDATE globals
 296: 0003: \***
 297: 0003: \***        REFERENCE     : PSBF13G.J86
 298: 0003: \***
 299: 0003: \***     VERSION A                                  Bruce Scriver  6th Mar 86             
 300: 0003: \***            
 301: 0003: \***     VERSION B                                  Janet Lawrence 17 Aug 90
 302: 0003: \***     Add global to be used to indicate whether or not the function should
 303: 0003: \***     log an event when an invalid date is passed to it.
 304: 0003: \***
 305: 0003: \***     VERSION C                               Andrew Wedgeworth 17 July 92
 306: 0003: \***     Return code removed as no longer required.
 307: 0003: \***
 308: 0003: \*******************************************************************************
 309: 0003: \*******************************************************************************
 310: 0003: 
 311: 0003:       STRING    GLOBAL F13.DAY$,			\
 312: 0003:                        F13.DISPLAY.MESSAGE$		! BJAL
 313: 0003: 
 314: 0003: 
 315: 0003:     %INCLUDE PSBF20G.J86     ! Session number Utility
 316: 0003: REM\
 317: 0003: \*******************************************************************************
 318: 0003: \*******************************************************************************
 319: 0003: \***
 320: 0003: \***     %INCLUDE GLOBAL VARIABLE DEFINITIONS FOR SESS.NUM.UTILITY FUNCTION
 321: 0003: \***
 322: 0003: \***                       REFERENCE     : PSBF20G.J86
 323: 0003: \*** 
 324: 0003: \***     Version A              Bruce Scrive                   5th May 1988   
 325: 0003: \*** 
 326: 0003: \***     Version B              Robert Cowey                   7th May 1991
 327: 0003: \***     Global variable F20.INTEGER.FILE.NO% changed from one byte integer
 328: 0003: \***     to two byte integer.
 329: 0003: \***
 330: 0003: \***     Version D              Andrew Wedgeworth             1st July 1992
 331: 0003: \***     F20.RETURN.CODE% removed as it is no longer required.
 332: 0003: \***
 333: 0003: \*******************************************************************************
 334: 0003: \*******************************************************************************
 335: 0003: 
 336: 0003:       STRING    GLOBAL F20.FILE.NAME$,                                 \
 337: 0003:                        F20.STRING.FILE.NO$,                            \
 338: 0003:                        F20.TABLE.DIMENSIONED.FLAG$,                    \
 339: 0003:                        SESS.NUM.TABLE$(1)
 340: 0003: 
 341: 0003:       INTEGER*2 GLOBAL F20.INTEGER.FILE.NO%
 342: 0003: 
 343: 0003:       ! 1 line deleted from here                                       ! DAW 
 344: 0003: 
 345: 0003:     %INCLUDE PSBF39G.J86     ! Display Manager
 346: 0003: !******************************************************************************
 347: 0003: !******************************************************************************
 348: 0003: !***
 349: 0003: !***            PROGRAM         :       PSBF39G.J86
 350: 0003: !***
 351: 0003: !***            DESCRIPTION     :       DISPLAY MANAGER INTERFACE
 352: 0003: !***
 353: 0003: !***            AUTHOR          :       Stuart William McConnachie
 354: 0003: !***            DATE WRITTEN    :       September 2000
 355: 0003: !***
 356: 0003: !***        Provides a much needed and easier to use interface to
 357: 0003: !***        IBM Display Manager.
 358: 0003: !***
 359: 0003: !***        Saves the user having to set up, highlight, tab between and
 360: 0003: !***        validate fields.  Also handles the help screens and conversion
 361: 0003: !***        of date fields to external/internal format.
 362: 0003: !***
 363: 0003: !******************************************************************************
 364: 0003: !******************************************************************************
 365: 0003:     
 366: 0003:     STRING GLOBAL       MESSAGE$(1)
 367: 0003:     STRING GLOBAL       VALID$(1)
 368: 0003:     STRING GLOBAL       VISIBLE$(1)
 369: 0003:     STRING GLOBAL       FIELD$(1)
 370: 0003:     STRING GLOBAL       TITLE$
 371: 0003: 
 372: 0003:     INTEGER*2 GLOBAL    DM.SCREEN%
 373: 0003:     INTEGER*2 GLOBAL    DM.FIELD%
 374: 0003:     
 375: 0003:     INTEGER*2 GLOBAL    HOME.KEY%
 376: 0003:     INTEGER*2 GLOBAL    END.KEY%
 377: 0003:     INTEGER*2 GLOBAL    PGUP.KEY%
 378: 0003:     INTEGER*2 GLOBAL    PGDN.KEY%
 379: 0003:     INTEGER*2 GLOBAL    TAB.KEY%
 380: 0003:     INTEGER*2 GLOBAL    BTAB.KEY%
 381: 0003:     INTEGER*2 GLOBAL    UP.KEY%
 382: 0003:     INTEGER*2 GLOBAL    DOWN.KEY%
 383: 0003:     INTEGER*2 GLOBAL    ESC.KEY%
 384: 0003:     INTEGER*2 GLOBAL    ENTER.KEY%
 385: 0003:     INTEGER*2 GLOBAL    INS.KEY%
 386: 0003:     INTEGER*2 GLOBAL    PREV.KEY%
 387: 0003:     INTEGER*2 GLOBAL    NEXT.KEY%
 388: 0003:         
 389: 0003:     INTEGER*2 GLOBAL    F1.KEY%
 390: 0003:     INTEGER*2 GLOBAL    F2.KEY%
 391: 0003:     INTEGER*2 GLOBAL    F3.KEY%
 392: 0003:     INTEGER*2 GLOBAL    F4.KEY%
 393: 0003:     INTEGER*2 GLOBAL    F5.KEY%
 394: 0003:     INTEGER*2 GLOBAL    F6.KEY%
 395: 0003:     INTEGER*2 GLOBAL    F7.KEY%
 396: 0003:     INTEGER*2 GLOBAL    F8.KEY%
 397: 0003:     INTEGER*2 GLOBAL    F9.KEY%
 398: 0003:     INTEGER*2 GLOBAL    F10.KEY%
 399: 0003:                 
 400: 0003: !******************************************************************************
 401: 0003: 
 402: 0003: 
 403: 0003:     %INCLUDE PSBUSEG.J86     ! Chain Parameters
 404: 0003: \/*********************************************************************/ PSBUSEG
 405: 0003: \/*                                                                   */ PSBUSEG
 406: 0003: \/* PSBUSEG.J86  -  Definitions for Chain/Use with PSB Screen Program */ PSBUSEG
 407: 0003: \/* ----------------------------------------------------------------- */ PSBUSEG
 408: 0003: \/*                                                                   */ PSBUSEG
 409: 0003: \/*********************************************************************/ PSBUSEG
 410: 0003:                                                                        ! PSBUSEG
 411: 0003:         STRING GLOBAL  PSBCHN.PRG,      \ Program to chain to          ! PSBUSEG
 412: 0003:                        PSBCHN.OP,       \ Operator Id                  ! PSBUSEG
 413: 0003:                        PSBCHN.APP,      \ Program chained from         ! PSBUSEG
 414: 0003:                        PSBCHN.MENCON,   \ Menu Control                 ! PSBUSEG
 415: 0003:                        PSBCHN.U1,       \ User parameter               ! PSBUSEG
 416: 0003:                        PSBCHN.U2,       \ User parameter               ! PSBUSEG
 417: 0003:                        PSBCHN.U3        ! User parameter               ! PSBUSEG
 418: 0003:                                                                        ! PSBUSEG
 419: 0003:     %INCLUDE SLPCFDEC.J86    ! Sleeper control
 420: 0003: \*****************************************************************************
 421: 0003: \*****************************************************************************
 422: 0003: \***
 423: 0003: \***             %INCLUDE FOR SLEEPER CHECK FILE - FIELD DECLARATIONS
 424: 0003: \***                                          FILE REFERENCE PARAMETERS
 425: 0003: \***
 426: 0003: \***                      FILE TYPE    :
 427: 0003: \***
 428: 0003: \***                      REFERENCE    : slpcfdeb.J86
 429: 0003: \***
 430: 0003: \***      Version A             Steve Windsor          8.2.93
 431: 0003: \***
 432: 0003: \***      Version B             Richard Foster         28.6.93
 433: 0003: \***
 434: 0003: \***      Version C             Mark Goode             6.03.00
 435: 0003: \***
 436: 0003: \***      Version D         Jaya Kumar Inbaraj               28/04/2014
 437: 0003: \***      FOD260 - Enhanced Backup and Recovery
 438: 0003: \***      Updated Filler variable usage has been explained. Added two
 439: 0003: \***      variables related to SLPCF Filler variable.
 440: 0003: \***
 441: 0003: \*****************************************************************************
 442: 0003: \*****************************************************************************
 443: 0003: 
 444: 0003: 
 445: 0003:   STRING GLOBAL          \
 446: 0003:     SLPCF.FILE.NAME$
 447: 0003: 
 448: 0003:   INTEGER*2 GLOBAL        \
 449: 0003:     SLPCF.REPORT.NUM%,    \
 450: 0003:     SLPCF.SESS.NUM%
 451: 0003: 
 452: 0003:   STRING GLOBAL              \
 453: 0003:     SLPCF.APP.NAME$,         \ 21 bytes - Application to be started
 454: 0003:     SLPCF.RUN.FREQUENCY$,    \ 1 byte   - d=daily, m=monthly              !BRCF
 455: 0003:     SLPCF.DAY.NUM$,          \ 6 bytes  - blank = evry day                !BRCF
 456: 0003:                              \            1 = sun  2 = mon                !BRCF
 457: 0003:               \            3 = tue  4 = wed                !BRCF
 458: 0003:               \            5 = thu  6 = fri                !BRCF
 459: 0003:               \            7 = sat                         !BRCF
 460: 0003:               \         OR nn = date (monthly run) up to   !BRCF
 461: 0003:               \                 3 2-digit numbers          !BRCF
 462: 0003:     SLPCF.RUN.TIME$,         \ 6 bytes  - time due to be started (HHMMSS) !BRCF
 463: 0003:     SLPCF.LAST.RUN.DATE$,    \ 6 bytes  - Date last run (YYMMDD)          !BRCF
 464: 0003:     SLPCF.FILE.PRESENT$,     \ 3 bytes  - Report number of file which must!BRCRF
 465: 0003:                              \            be present                      !BRCF
 466: 0003:     SLPCF.FILE.PRESENT.NAME$,\ 8 bytes  - Name of above file              !BRCF
 467: 0003:     SLPCF.FILE.ABSENT$,      \ 3 bytes  - Report number of file which must!BRCF
 468: 0003:                              \            not be present                  !BRCF
 469: 0003:     SLPCF.FILE.ABSENT.NAME$, \ 8 bytes  - Name of above file              !BRCF
 470: 0003:     SLPCF.NODE.ID$,          \ 2 bytes  - Node on which to run application!BRCF
 471: 0003:                              \            CE = Master only                !BRCF
 472: 0003:               \            CF = File Server only           !BRCF
 473: 0003:               \            DE = Single only                !BRCF
 474: 0003:               \            SM = Single and Master          !BRCF
 475: 0003:               \            SF = Single and File Server     !BRCF
 476: 0003:     SLPCF.SOFTS.REC$,        \ 4 bytes  - The record number on the SOFTS file !LMG
 477: 0003:     SLPCF.FILLER$,           \ 12 bytes - Format can be xYYYYYYYYY      !DJK LMG
 478: 0003:               \ where; If x is 1-9 then the first x characters of Y are !DJK
 479: 0003:               \ passed to the starting application as a start parameter !DJK
 480: 0003:               \ and a CrLf                                              !DJK
 481: 0003:     SLPCF.PARM$              ! Value Y from SLPCF.FILLER                !DJK
 482: 0003: 
 483: 0003:   INTEGER*2 GLOBAL        \
 484: 0003:     SLPCF.RECL%           ! Length of record
 485: 0003: 
 486: 0003:   INTEGER*1 GLOBAL        \                                             !DJK
 487: 0003:     SLPCF.PARM.LEN%       ! Value X from SLPCF.FILLER                   !DJK
 488: 0003: 
 489: 0003:   INTEGER*4 GLOBAL        \
 490: 0003:     SLPCF.REC.NO%         ! Record Number
 491: 0003: 
 492: 0003: 
 493: 0003: \***********************************************************************
 494: 0003: \*
 495: 0003: \* Global variable definitions
 496: 0003: \*
 497: 0003: \***********************************************************************
 498: 0003:     STRING GLOBAL                   \
 499: 0003:         BATCH.SCREEN.FLAG$,         \
 500: 0003:         CHAIN.TO.PROG$,             \
 501: 0003:         MODULE.NUMBER$
 502: 0003: 
 503: 0003:     INTEGER*4 GLOBAL                \
 504: 0003:         BKPLIST.FILE.RC%,           \
 505: 0003:         DIR.FILE.RC%,               \
 506: 0003:         XRE.FILE.RC%
 507: 0003: 
 508: 0003: \***********************************************************************
 509: 0003: \*
 510: 0003: \* Local Variables Made Global when multi-modular
 511: 0003: \*
 512: 0003: \***********************************************************************
 513: 0003:     STRING GLOBAL                   \
 514: 0003:         ADX.PARM.2$,                \
 515: 0003:         ADXCSU0L.FILE.NAME$,        \                                   !CJK
 516: 0003:         ADXUNZIP.FILE.NAME$,        \                                   !DJK
 517: 0003:         ADXZUDIR.FILE.NAME$,        \
 518: 0003:         BACKUP.DAYS$,               \
 519: 0003:         BACKUP.LONG.DAYS$,          \
 520: 0003:         BKP.DRIVE$,                 \                                   !CJK
 521: 0003:         BKP.FILENAME.ALT$,          \
 522: 0003:         BKP.FILENAME.IMG$,          \
 523: 0003:         BKP.ZIP.FILE$,              \                                   !DJK
 524: 0003:         BKPFAIL.CURR.FILE$,         \
 525: 0003:         BKPFAIL.PREFIX$,            \                                   !CJK
 526: 0003:         BKPLIST.CURR.FILE$,         \
 527: 0003:         BKPLIST.DIR.VALUE$,         \
 528: 0003:         BKPLIST.FIELD$(1),          \
 529: 0003:         BKPLIST.PREFIX.C.DRIVE$,    \                                   !CJK
 530: 0003:         BKPLIST.PREFIX.D.DRIVE$,    \                                   !CJK
 531: 0003:         BKPLIST.VALUE$,             \
 532: 0003:         BKPSCRPT.COMMAND$,          \
 533: 0003:         BKPSCRPT.DIRECTORY$,        \
 534: 0003:         BKPSCRPT.FILE.NAME$,        \
 535: 0003:         BKPSCRPT.OUT.FILE.NAME$,    \
 536: 0003:         C.BKP.ALT$,                 \
 537: 0003:         C.BKP.IMG$,                 \
 538: 0003:         CDRIVE$,                    \
 539: 0003:         CNTLR.ID$,                  \
 540: 0003:         COMMA.VALUE$,               \
 541: 0003:         CONSTANT.COLON$,            \
 542: 0003:         CONSTANT.DAY$(1),           \
 543: 0003:         CONSTANT.FRIDAY.LONG$,      \
 544: 0003:         CONSTANT.FRIDAY.SHORT$,     \
 545: 0003:         CONSTANT.LONG.DAY$(1),      \
 546: 0003:         CONSTANT.MONDAY.LONG$,      \
 547: 0003:         CONSTANT.MONDAY.SHORT$,     \
 548: 0003:         CONSTANT.SATURDAY.LONG$,    \
 549: 0003:         CONSTANT.SATURDAY.SHORT$,   \
 550: 0003:         CONSTANT.SUNDAY.LONG$,      \
 551: 0003:         CONSTANT.SUNDAY.SHORT$,     \
 552: 0003:         CONSTANT.THURSDAY.LONG$,    \
 553: 0003:         CONSTANT.THURSDAY.SHORT$,   \
 554: 0003:         CONSTANT.TUESDAY.LONG$,     \
 555: 0003:         CONSTANT.TUESDAY.SHORT$,    \
 556: 0003:         CONSTANT.WEDNESDAY.LONG$,   \
 557: 0003:         CONSTANT.WEDNESDAY.SHORT$,  \
 558: 0003:         CRLF$,                      \
 559: 0003:         D.BKP.ALT$,                 \
 560: 0003:         D.BKP.IMG$,                 \
 561: 0003:         DDRIVE$,                    \
 562: 0003:         DIR.OUT$,                   \
 563: 0003:         DIR1.OUT$,                  \   Command pipe output file        !DJK
 564: 0003:         DIR.VALUE$,                 \
 565: 0003:         DIRECT.TO.RESTORE$,         \
 566: 0003:         DRIVE$,                     \
 567: 0003:         ERROR.MSG$,                 \
 568: 0003:         EXTENSION$,                 \
 569: 0003:         FAILED.FILE$,               \
 570: 0003:         FAILED.FILE.DIST$,          \
 571: 0003:         FILENAME$,                  \
 572: 0003:         FIRST.FILE$,                \
 573: 0003:         FSEL$,                      \
 574: 0003:         FULL.DATE$,                 \
 575: 0003:         FULL.MDD.DATE$,             \
 576: 0003:         FULL.TO.MOVING.DATE$,       \
 577: 0003:         FUNC.FLAG$,                 \
 578: 0003:         MDD.DATE$,                  \
 579: 0003:         NORMAL.SLEEPER.FILE.NAME$,  \
 580: 0003:         OPT.HEADER$,                \
 581: 0003:         OPT.HEADER.1$,              \
 582: 0003:         OPT.SELECTED$,              \
 583: 0003:         OS.DESTINATION$,            \
 584: 0003:         OS.FILE$(1),                \
 585: 0003:         OS.SOURCE$,                 \
 586: 0003:         PARM.FULL$,                 \
 587: 0003: \        PARM.INCREMENTAL$,          \                                  !CJK
 588: 0003:         PASSED.STRING$,             \
 589: 0003:         RESTORE.FILENAME$,          \                                   !BJK
 590: 0003:         SCR.HEADER$,                \
 591: 0003:         SCREEN.NUM$,                \
 592: 0003:         SCREEN.TEXT.MSG$(1),        \
 593: 0003:         SECOND.FILE$,               \
 594: 0003:         SELECT.FILE.NAME$,          \
 595: 0003:         SELECTED.FILENAME$,         \
 596: 0003: \        SHELL.COMMAND$,             \  ! variable passed into OSSHELL  !CJK
 597: 0003:         SLEEPER.RECORD$,            \
 598: 0003:         STATUS.MSG$,                \
 599: 0003:         STATUS.TEXT.ERROR$(1),      \
 600: 0003:         STATUS.TEXT.MSG$(1),        \
 601: 0003:         SUPPS.SLEEPER.FILE.NAME$,   \
 602: 0003:         TEMP.DIR$,                  \
 603: 0003:         TODAY.DATE$,                \
 604: 0003:         USER.TEXT$,                 \
 605: 0003:         VERSION$,                   \                                   !CJK
 606: 0003:         WORK.DATE.MMDD$,            \
 607: 0003:         XBACK.PIPE.NAME$,           \
 608: 0003:         XRE.LOG.FILENAME$,          \
 609: 0003:         XRE.NULL$,                  \
 610: 0003:         XRE.PIPE.NAME$,             \
 611: 0003:         XRE.SPACE$
 612: 0003: 
 613: 0003:     ! Grouping Arrays
 614: 0003:     STRING GLOBAL                   \
 615: 0003:         BKP.AVAIL.ARRAY$(1),        \
 616: 0003:         BKP.DATE.ARRAY$(1),         \
 617: 0003:         BKP.FILE.MDD.ARRAY$(1),     \
 618: 0003:         BKP.FILE.MMDD.ARRAY$(1),    \
 619: 0003:         BKPSCRPT.DIRECTORIES$(1),   \
 620: 0003:         DAY.ARRAY$(1),              \
 621: 0003:         PRIMARY.ARCHIVED.NAMES$(1), \
 622: 0003:         SECONDARY.ARCHVD.NAMES$(1), \
 623: 0003:         SELECTED.DIR.ARRAY$(1)
 624: 0003: 
 625: 0003:     INTEGER*1 GLOBAL                \
 626: 0003:         ADX.FUNCTION%,              \
 627: 0003:         BKP.INDEX%,                 \
 628: 0003:         CNTLR.CONFIG%,              \
 629: 0003:         CONSTANT.LONGEST.DAY%,      \
 630: 0003:         DAY.INDEX%,                 \
 631: 0003:         DAY.SINCE.FULL%,            \
 632: 0003:         DAYS.AFTER.FULL.BAKUP%,     \
 633: 0003:         DD.MM.INDEX%,               \
 634: 0003:         DIR.INDEX%,                 \
 635: 0003:         DIR.TO.SHOW%,               \
 636: 0003:         DIRECTORY.CREATE,           \
 637: 0003:         DIRECTORY.DAY.SELECT.SCR%,  \
 638: 0003:         DIRECTORY.PROCESS.SCR%,     \
 639: 0003:         DISPLAY.MAIN.SCR%,          \
 640: 0003:         DRIVE.DAY.SELECT.SCR%,      \
 641: 0003:         DRIVE.DISK.SELECT.SCR%,     \
 642: 0003:         DRIVE.PROCESS.SCR%,         \
 643: 0003:         ERROR.COUNT%,               \
 644: 0003:         F.RECORD.COUNT%,            \ count for header lines in DIR
 645: 0003:         FILE.CONFIRMATION.SCR%,     \
 646: 0003:         FILE.DAY.SELECT.SCR%,       \
 647: 0003:         FILE.DIR.AND.DIST.SCR%,     \
 648: 0003:         FILE.PROCESS.SCR%,          \
 649: 0003:         FULL.BACKUP.NOT.FOUND%,     \
 650: 0003:         INPUT.INDEX%,               \
 651: 0003:         MASTER.AND.FILE.SERVER%,    \
 652: 0003:         OPT.SEL%,                   \
 653: 0003:         PAGE.DIV%,                  \
 654: 0003:         PAGE.NO%,                   \
 655: 0003:         RESTORE.A.DIRECTORY.SCR%,   \
 656: 0003:         RESTORE.A.FILE.SCR%,        \
 657: 0003:         SCREEN%,                    \
 658: 0003:         SCREEN.NUM%,                \
 659: 0003:         SLEEPER.DAY%,               \
 660: 0003:         SLPCF.OPEN,                 \
 661: 0003:         XRE.ZERO%
 662: 0003: 
 663: 0003:     ! Grouping Boolean variables
 664: 0003:     INTEGER*1 GLOBAL                \
 665: 0003:         BKPLIST.OPEN,               \
 666: 0003:         COMMAND.MODE,               \
 667: 0003:         DIR.OPEN,                   \
 668: 0003:         DUPLICATE.RECORD,           \                                   !CJK
 669: 0003:         ERROR.EXIST,                \
 670: 0003:         FALSE,                      \
 671: 0003:         FUNCTION.ERROR.NOT.EXIST,   \
 672: 0003: \        IN.LOG.STATUS.MSG,          \                                  !CJK
 673: 0003: \        IN.UPDATE.DATE.RC,          \                                  !CJK
 674: 0003:         NON.X.VALUES,               \
 675: 0003:         PREVIOUS.KEY,               \
 676: 0003:         RESTORE.ERR.EXIST,          \
 677: 0003:         RESTORE.HAPPENED,           \                                   !CJK
 678: 0003:         RESTORE.STATUS,             \
 679: 0003:         SUPPS.ON,                   \
 680: 0003:         TRUE,                       \
 681: 0003:         VALUE.EXISTS,               \
 682: 0003:         VALUE.PRESENT,              \
 683: 0003:         XBACK.OPEN,                 \
 684: 0003:         XRE.LOG.OPEN,               \
 685: 0003:         XRE.OPEN
 686: 0003: 
 687: 0003:     INTEGER*2 GLOBAL                \
 688: 0003:         ARRAY.LIMIT%,               \                                   !CJK
 689: 0003:         BEGIN.POS%,                 \
 690: 0003:         BEGIN.POSITION%,            \
 691: 0003:         BKP.DAYS%,                  \
 692: 0003:         BKPSCRPT.INDEX%,            \
 693: 0003:         COMMA.POSITION%,            \
 694: 0003:         DAY.LOOP%,                  \
 695: 0003:         DD.MM.LOOP%,                \
 696: 0003:         DIR.INPUT.INDEX%,           \
 697: 0003:         DIR.INPUT.LOOP%,            \
 698: 0003:         DIR.LOOP%,                  \
 699: 0003:         FUN.RC2%,                   \ function return value for check
 700: 0003:         INDEX%,                     \
 701: 0003:         INPUT.LOOP%,                \
 702: 0003:         LONG.DAY.INDEX%,            \
 703: 0003:         LOOP%,                      \
 704: 0003:         MATCH.POS%,                 \
 705: 0003:         MAX.DIRECTORIES%,           \
 706: 0003:         PASSED.INTEGER%,            \
 707: 0003:         RET.KEY%,                   \
 708: 0003:         SEL.INDEX%,                 \
 709: 0003:         SEL.INPUT.LOOP%,            \
 710: 0003:         SELECT.COUNT%,              \
 711: 0003:         SELECT.INDEX%,              \
 712: 0003:         SLASH.POSITION%,            \
 713: 0003:         VALUE.INDEX%,               \
 714: 0003:         XBACK.PIPE.REPORT.NUM%,     \
 715: 0003:         XBACK.PIPE.SESS.NUM%,       \
 716: 0003:         XRE.LOG.REPORT.NUM%,        \
 717: 0003:         XRE.LOG.SESS.NUM%,          \
 718: 0003:         XRE.PIPE.REPORT.NUM%,       \
 719: 0003:         XRE.PIPE.SESS.NUM%
 720: 0003: 
 721: 0003:     INTEGER*4 GLOBAL                \
 722: 0003:         ADXSERVE.RC%,               \
 723: 0003:         FILE.RC%
 724: 0003: 
 725: 0003: 
 726: 0003: \***********************************************************************
 727: 0003: \*
 728: 0003: \* Included external functions                                          !KDC
 729: 0003: \*
 730: 0003: \***********************************************************************
 731: 0003:     %INCLUDE XRESTORE.J86                                               !MJK
 732: 0003: \***********************************************************************
 733: 0003: \*
 734: 0003: \* Program: XRESTORE          Jaya Kumar Inbaraj              04/03/2014
 735: 0003: \*
 736: 0003: \* FOD260 - Enhanced Backup and Recovery
 737: 0003: \*
 738: 0003: \*           %INCLUDE for External Functions in XRESTORE
 739: 0003: \*
 740: 0003: \*                    REFERENCE: XRESTORE.J86
 741: 0003: \*
 742: 0003: \*       MODULE EXTRACTED FROM ORIGINAL XRESTORE.BAS (RENAMED TO
 743: 0003: \*       XREST000.BAS) AS BREACHED 64K LIMIT AND CRETAED AS XREST001.BAS
 744: 0003: \*
 745: 0003: \*======================================================================
 746: 0003: \*                   V E R S I O N   C O N T R O L
 747: 0003: \*======================================================================
 748: 0003: \*
 749: 0003: \*                            Dave Constable                  25/06/2014
 750: 0003: \* FOD260 - Enhanced Backup and Recovery
 751: 0003: \* Code extracted originally from single module (XRESTORE.BAS) and all
 752: 0003: \* code change markers removed.
 753: 0003: \* For maintenance and usage all included externals and includes are
 754: 0003: \* also replicated here and included into both modules.
 755: 0003: \*
 756: 0003: \* Version B                Jaya Kumar Inbaraj                23/08/2014
 757: 0003: \* FOD260 - Enhanced Backup and Recovery
 758: 0003: \* Updated the Header block comments
 759: 0003: \*
 760: 0003: \* Version C                Jaya Kumar Inbaraj                04/09/2014
 761: 0003: \* FOD260 - Enhanced Backup and Recovery
 762: 0003: \* Updated the C file function names
 763: 0003: \*
 764: 0003: \***********************************************************************
 765: 0003: 
 766: 0003: \***********************************************************************
 767: 0003: \*
 768: 0003: \* Included code defining file related global variables
 769: 0003: \*
 770: 0003: \***********************************************************************
 771: 0003: 
 772: 0003: \***********************************************************************
 773: 0003: \*
 774: 0003: \* Included code defining function related external functions
 775: 0003: \*
 776: 0003: \***********************************************************************
 777: 0003:     %INCLUDE PSBF02E.J86     ! Update Date
 778: 0003: REM\
 779: 0003: \*******************************************************************************
 780: 0003: \*******************************************************************************
 781: 0003: \***
 782: 0003: \***        INCLUDE       : UPDATE.DATE external definition
 783: 0003: \***        AUTHOR        : Bruce Scriver (Basic Code)
 784: 0003: \***        DATE WRITTEN  : 4th March 1986 (Basic Code)
 785: 0003: \***
 786: 0003: \***        REFERENCE     : PSBF02E.J86
 787: 0003: \***
 788: 0003: \***        Version A     Bruce Scriver          4th March 1986
 789: 0003: \***
 790: 0003: \***        Version B     Andrew Wedgeworth       6th July 1992
 791: 0003: \***        Removal of redundant parameters, and inclusion of UPDATE.DATE as
 792: 0003: \***        a variable to hold the return code.
 793: 0003: \***
 794: 0003: \*******************************************************************************
 795: 0003: \*******************************************************************************
 796: 0003: 
 797: 0003:    FUNCTION UPDATE.DATE (INCREMENT%)                                   \
 798: 0003:    EXTERNAL
 799: 0003:    ! 3 parameters removed from here                                    ! BAW
 800: 0003: 
 801: 0003:    ! 3 lines deleted from here                                         ! BAW
 802: 0003:    
 803: 0003:       INTEGER*2 UPDATE.DATE                                            ! BAW
 804: 0003: 
 805: 0003:       INTEGER*4 INCREMENT%
 806: 0003: 
 807: 0003:    END FUNCTION
 808: 0003: 
 809: 0003:     %INCLUDE PSBF13E.J86     ! PSDATE function
 810: 0003: REM\
 811: 0003: \*******************************************************************************
 812: 0003: \*******************************************************************************
 813: 0003: \***
 814: 0003: \***        INCLUDE       : PSDATE external definition
 815: 0003: \***
 816: 0003: \***        REFERENCE     : PSBF13E.J86
 817: 0003: \***
 818: 0003: \***        Version A     Bruce Scriver                6th March 1986
 819: 0003: \*** 
 820: 0003: \***        Version B     Andrew Wedgeworth            17th July 1992  
 821: 0003: \***        Redundant parameters removed and PSDATE defined as a variable
 822: 0003: \***        to hold the return code. 
 823: 0003: \***
 824: 0003: \*******************************************************************************
 825: 0003: \*******************************************************************************
 826: 0003: 
 827: 0003:    FUNCTION PSDATE (INPUT.DATE$)                                               \
 828: 0003:    EXTERNAL
 829: 0003: 
 830: 0003:      STRING    INPUT.DATE$                                                   
 831: 0003:    
 832: 0003:      INTEGER*2 PSDATE 
 833: 0003: 
 834: 0003:    END FUNCTION
 835: 0003: 
 836: 0003:     %INCLUDE PSBF20E.J86     ! Session number utility
 837: 0003: REM\
 838: 0003: \*******************************************************************************
 839: 0003: \*******************************************************************************
 840: 0003: \***
 841: 0003: \***       %INCLUDE FOR EXTERNAL DEFINITION OF SESS.NUM.UTILITY
 842: 0003: \***
 843: 0003: \***                  REFERENCE     : PSBF20E.J86
 844: 0003: \***
 845: 0003: \***     VERSION C            Janet Smith                13th May 1992
 846: 0003: \***     Increased PASSED.INTEGER to 2 bytes to cater for more than
 847: 0003: \***     128 files.
 848: 0003: \***
 849: 0003: \***     VERSION D.           Andrew Wedgeworth          1st July 1992
 850: 0003: \***     Removal of redundant parameters and addition of SESS.NUM.UTILITY
 851: 0003: \***     as a variable.  This new variable contains the function's return
 852: 0003: \***     code.
 853: 0003: \***
 854: 0003: \*******************************************************************************
 855: 0003: \*******************************************************************************
 856: 0003: 
 857: 0003:    FUNCTION SESS.NUM.UTILITY (FUNCTION.FLAG$,                          \
 858: 0003:                               PASSED.INTEGER%,                         \
 859: 0003:                               PASSED.STRING$)                          \
 860: 0003:    EXTERNAL
 861: 0003: 
 862: 0003:    STRING    FUNCTION.FLAG$,                                           \
 863: 0003:              PASSED.STRING$
 864: 0003:    ! 3 variables removed from here                                     ! CAW
 865: 0003: 
 866: 0003: 
 867: 0003:    INTEGER*2 SESS.NUM.UTILITY,                                         \ CAW
 868: 0003:              PASSED.INTEGER%				               ! CJAS
 869: 0003: 
 870: 0003:    END FUNCTION
 871: 0003: 
 872: 0003:     %INCLUDE PSBF24E.J86     ! Standard error detected
 873: 0003: REM \
 874: 0003: \*******************************************************************************
 875: 0003: \*******************************************************************************
 876: 0003: \***
 877: 0003: \***    %INCLUDE FOR EXTERNAL DEFINITION OF STANDARD.ERROR.DETECTED FUNCTION
 878: 0003: \***
 879: 0003: \***                      REFERENCE     : PSBF24E.J86
 880: 0003: \***
 881: 0003: \***    Version A                 Janet Smith                  13th May 1992
 882: 0003: \***
 883: 0003: \*******************************************************************************
 884: 0003: \*******************************************************************************
 885: 0003: 
 886: 0003:    FUNCTION STANDARD.ERROR.DETECTED(ERRN%,                 \
 887: 0003: 				    ERRFILE%,              \
 888: 0003: 				    ERRL%,                 \
 889: 0003: 				    ERR$)        EXTERNAL
 890: 0003: 				    
 891: 0003:           STRING    ERR$
 892: 0003: 
 893: 0003:           INTEGER*2 ERRFILE%,              \
 894: 0003: 	            ERRL%,                 \
 895: 0003: 		    STANDARD.ERROR.DETECTED
 896: 0003: 		    
 897: 0003:           INTEGER*4 ERRN%
 898: 0003: 	  		    
 899: 0003:    END FUNCTION
 900: 0003: 
 901: 0003: 
 902: 0003:     %INCLUDE PSBF39E.J86     ! Display Manager
 903: 0003: !******************************************************************************
 904: 0003: !******************************************************************************
 905: 0003: !***
 906: 0003: !***            PROGRAM         :       PSBF39E.J86
 907: 0003: !***
 908: 0003: !***            DESCRIPTION     :       DISPLAY MANAGER INTERFACE
 909: 0003: !***
 910: 0003: !***            AUTHOR          :       Stuart William McConnachie
 911: 0003: !***            DATE WRITTEN    :       September 2000
 912: 0003: !***
 913: 0003: !***        Provides a much needed and easier to use interface to
 914: 0003: !***        IBM Display Manager.
 915: 0003: !***
 916: 0003: !***        Saves the user having to set up, highlight, tab between and
 917: 0003: !***        validate fields.  Also handles the help screens and conversion
 918: 0003: !***        of date fields to external/internal format.
 919: 0003: !***
 920: 0003: !******************************************************************************
 921: 0003: !******************************************************************************
 922: 0003: 
 923: 0003: !******************************************************************************
 924: 0003: !   Initialises the display manager functions.
 925: 0003: !   You should call this from your program initialisation for screen programs.
 926: 0003: !   Note that the name of the display manager file is determined from the
 927: 0003: !   global variable MODULE.NUMBER$.  For example PSB1200 uses PSBD12.dat
 928: 0003: !   where the PSB and 12 have been derived from MODULE.NUMBER$.
 929: 0003: 
 930: 0003:     FUNCTION DM.INIT EXTERNAL
 931: 0003:         INTEGER*1   DM.INIT
 932: 0003:     END FUNCTION
 933: 0003: 
 934: 0003: !******************************************************************************
 935: 0003: !   Quits the display manager program and frees resources.
 936: 0003: !   You should call this from your program termination.
 937: 0003: 
 938: 0003:     FUNCTION DM.QUIT EXTERNAL
 939: 0003:         INTEGER*1   DM.QUIT
 940: 0003:     END FUNCTION
 941: 0003: 
 942: 0003: !******************************************************************************
 943: 0003: !   Initialises a particular screen from the current display manager file
 944: 0003: !   for display.  You supply the screen number, optional title message and
 945: 0003: !   the first and last help screens associated with the display.
 946: 0003: !   Once you have SHOWN a screen, you can use the remaining functions in
 947: 0003: !   this library to set field values, and actually retrieve input from the
 948: 0003: !   screen.  Note that showing a screen just displays it on the screen,
 949: 0003: !   you need to call PROCESS.SCREEN to actually get any user input.
 950: 0003: 
 951: 0003:     FUNCTION DM.SHOW.SCREEN (SCREEN%, TITLE$, FIRST.HELP%, LAST.HELP%) EXTERNAL
 952: 0003:         INTEGER*1   DM.SHOW.SCREEN
 953: 0003:         INTEGER*2   SCREEN%
 954: 0003:         STRING      TITLE$
 955: 0003:         INTEGER*2   FIRST.HELP%
 956: 0003:         INTEGER*2   LAST.HELP%
 957: 0003:     END FUNCTION
 958: 0003: 
 959: 0003: !******************************************************************************
 960: 0003: !   Sets a function key message to visible.  Optionally sets the text on that
 961: 0003: !   key to the message string passed, if it is not null.
 962: 0003: !   Note you must have shown a screen first, and that the function key fields
 963: 0003: !   need to be defined in your display file with field IDs 241-250.
 964: 0003: 
 965: 0003:     FUNCTION DM.SHOW.FN.KEY (KEY.NUM%, MESSAGE$) EXTERNAL
 966: 0003:         INTEGER*1   DM.SHOW.FN.KEY
 967: 0003:         INTEGER*2   KEY.NUM%
 968: 0003:         STRING      MESSAGE$
 969: 0003:     END FUNCTION
 970: 0003: 
 971: 0003: !******************************************************************************
 972: 0003: !   Sets a function key message to invisible.
 973: 0003: !   Note you must have shown a screen first, and that the function key fields
 974: 0003: !   need to be defined in your display file with field IDs 241-250.
 975: 0003: 
 976: 0003:     FUNCTION DM.HIDE.FN.KEY (KEY.NUM%) EXTERNAL
 977: 0003:         INTEGER*1   DM.HIDE.FN.KEY
 978: 0003:         INTEGER*2   KEY.NUM%
 979: 0003:     END FUNCTION
 980: 0003: 
 981: 0003: !******************************************************************************
 982: 0003: !   LEGACY: Do not use in new programs, use DM.FN.VISIBLE instead which takes
 983: 0003: !   an infix notation expression, as opposed to reverse polish
 984: 0003: !   This definition has been commented out accordingly.  If you are
 985: 0003: !   recompiling an application, change to useing the new function.
 986: 0003: !
 987: 0003: !   FUNCTION DM.FN.KEY.VISIBLE (KEY.NUM%, EXPR$) EXTERNAL
 988: 0003: !       INTEGER*1   DM.FN.KEY.VISIBILITY
 989: 0003: !       INTEGER*2   KEY.NUM%
 990: 0003: !       STRING      EXPR$
 991: 0003: !   END FUNCTION
 992: 0003: 
 993: 0003: !******************************************************************************
 994: 0003: !   Sets a runtine expression to determine if a function key is visible.
 995: 0003: !   This is the new version of the above which takes an infix notation EXPR$.
 996: 0003: !   Note you must have shown a screen first, and that the function key fields
 997: 0003: !   need to be defined in your display file with field IDs 241-250.
 998: 0003: 
 999: 0003:     FUNCTION DM.FN.VISIBLE (KEY.NUM%, EXPR$) EXTERNAL
1000: 0003:         INTEGER*1   DM.FN.VISIBILITY
1001: 0003:         INTEGER*2   KEY.NUM%
1002: 0003:         STRING      EXPR$
1003: 0003:     END FUNCTION
1004: 0003: 
1005: 0003: !******************************************************************************
1006: 0003: !   Specifies that a given field contains a date.
1007: 0003: !   This means that the date will be displayed on screen in the system date
1008: 0003: !   format (e.g. DD/MM/YY or MM/DD/YY, but will be returned and set by your
1009: 0003: !   application in YYMMDD format.
1010: 0003: !   It does NOT mean that the field will be validated as a date, you must do
1011: 0003: !   that explicitly using the VALID$ string.
1012: 0003: 
1013: 0003:     FUNCTION DM.DATE.FIELD (FIELD%) EXTERNAL
1014: 0003:         INTEGER*1   DM.DATE.FIELD
1015: 0003:         INTEGER*2   FIELD%
1016: 0003:     END FUNCTION
1017: 0003: 
1018: 0003: !******************************************************************************
1019: 0003: !   Specifies that a given field will contain a time.
1020: 0003: !   This means that the time will be displayed on screen using the system time
1021: 0003: !   format.  e.g. HH:MM
1022: 0003: 
1023: 0003:     FUNCTION DM.TIME.FIELD (FIELD%) EXTERNAL                                !CSWM
1024: 0003:         INTEGER*1   DM.TIME.FIELD                                           !CSWM
1025: 0003:         INTEGER*2   FIELD%                                                  !CSWM
1026: 0003:     END FUNCTION                                                            !CSWM
1027: 0003: 
1028: 0003: !******************************************************************************
1029: 0003: !   Specifies that a given input field will be read only.
1030: 0003: !   This allows you to select an item from a list by highlighting it.
1031: 0003: 
1032: 0003:     FUNCTION DM.RO.FIELD (FIELD%) EXTERNAL                                  !ESWM
1033: 0003:         INTEGER*1   DM.RO.FIELD                                             !ESWM
1034: 0003:         INTEGER*2   FIELD%                                                  !ESWM
1035: 0003:     END FUNCTION                                                            !ESWM
1036: 0003: 
1037: 0003: !******************************************************************************
1038: 0003: !   Specifies that a given input field will be read write.
1039: 0003: !   Undoes the effect of DM.RO.FIELD.
1040: 0003: 
1041: 0003:     FUNCTION DM.RW.FIELD (FIELD%) EXTERNAL                                  !ESWM
1042: 0003:         INTEGER*1   DM.RW.FIELD                                             !ESWM
1043: 0003:         INTEGER*2   FIELD%                                                  !ESWM
1044: 0003:     END FUNCTION                                                            !ESWM
1045: 0003: 
1046: 0003: !******************************************************************************
1047: 0003: !   LEGACY: Do not use in new programs, use DM.STATUS instead which takes
1048: 0003: !   an infix notation expression, as opposed to reverse polish.
1049: 0003: !   This definition has been commented out accordingly.  If you are
1050: 0003: !   recompiling an application, change to useing the new function.
1051: 0003: !
1052: 0003: !   FUNCTION DM.DISPLAY.MESSAGE (MESSAGE$) EXTERNAL                         !DSWM
1053: 0003: !       INTEGER*1   DM.DISPLAY.MESSAGE                                      !DSWM
1054: 0003: !       STRING      MESSAGE$                                                !DSWM
1055: 0003: !   END FUNCTION                                                            !DSWM
1056: 0003: 
1057: 0003: !******************************************************************************
1058: 0003: !   Displays a message in the status line of the display.  Does not wait for
1059: 0003: !   input.  Use this function for display messages such as B251 Processing...
1060: 0003: !   You must have field 1 defined in your display manager file.
1061: 0003: !   This is the new version of the above which takes an infix notation MESSAGE$.
1062: 0003: 
1063: 0003:     FUNCTION DM.STATUS (MESSAGE$) EXTERNAL                                  !DSWM
1064: 0003:         INTEGER*1   DM.STATUS                                               !DSWM
1065: 0003:         STRING      MESSAGE$                                                !DSWM
1066: 0003:     END FUNCTION                                                            !DSWM
1067: 0003: 
1068: 0003: !******************************************************************************
1069: 0003: !   Waits for input in the invisible input field of the display.  Additionally
1070: 0003: !   displays a message prompting the user on the status line.
1071: 0003: !   You must have fields 1 and 240 defined in your display manager file.
1072: 0003: !   The message supplied should be in Reverse Polish form.
1073: 0003: !   The function returns the key value that ended the input.
1074: 0003: 
1075: 0003:     FUNCTION DM.INVISIBLE.INPUT (MESSAGE$) EXTERNAL
1076: 0003:         STRING      MESSAGE$
1077: 0003:         INTEGER*2   DM.INVISIBLE.INPUT
1078: 0003:     END FUNCTION
1079: 0003: 
1080: 0003: !******************************************************************************
1081: 0003: !   Gets the contents of the invisible field from the display.  This will
1082: 0003: !   allow you to get the Y or N answer that the user typed, for example.
1083: 0003: 
1084: 0003:     FUNCTION DM.INVISIBLE.FIELD EXTERNAL
1085: 0003:         STRING      DM.INVISIBLE.FIELD
1086: 0003:     END FUNCTION
1087: 0003: 
1088: 0003: !******************************************************************************
1089: 0003: !   Returns or sets the current field used for input on the current display.
1090: 0003: !   If NEW.FIELD% is zero, the function simply returns the current field.
1091: 0003: !   If NEW.FIELD% is non zero, the function sets the current field.
1092: 0003: 
1093: 0003:     FUNCTION DM.CURRENT.FIELD (NEW.FIELD%) EXTERNAL
1094: 0003:         INTEGER*2   DM.CURRENT.FIELD
1095: 0003:         INTEGER*2   NEW.FIELD%
1096: 0003:     END FUNCTION
1097: 0003: 
1098: 0003: !******************************************************************************
1099: 0003: !   Sets a key number as being a validation key.  When this key is used the
1100: 0003: !   function will handle the key in the same way as the ENTER key.  i.e. all
1101: 0003: !   the visible fields on in input form are check for validity, and the key
1102: 0003: !   press is only returned to the user if the form entries are valid.
1103: 0003: !   Use this function to add the PGUP.KEY% and PGDN.KEY% keys, for example.
1104: 0003: 
1105: 0003:     FUNCTION DM.VALIDATE.KEY (KEY%) EXTERNAL                                !BSWM
1106: 0003:         INTEGER*1   DM.VALIDATE.KEY                                         !BSWM
1107: 0003:         INTEGER*2   KEY%                                                    !BSWM
1108: 0003:     END FUNCTION                                                            !BSWM
1109: 0003: 
1110: 0003: !******************************************************************************
1111: 0003: !   Returns or sets the flag which says if the screen contents have been
1112: 0003: !   changed or not.  Use this function when you have multiple pages to a
1113: 0003: !   form, but want the user to be prompted to save any changes on exit.
1114: 0003: !   When called with FLAG% set 0 or -1, the function updates the current
1115: 0003: !   displays setting.  When called with any other value, the function simply
1116: 0003: !   returns the current setting and does not update it.
1117: 0003: 
1118: 0003:     FUNCTION DM.CHANGED.FLAG (FLAG%) EXTERNAL                               !BSWM
1119: 0003:         INTEGER*1   FLAG%                                                   !BSWM
1120: 0003:         INTEGER*1   DM.CHANGED.FLAG                                         !BSWM
1121: 0003:     END FUNCTION                                                            !BSWM
1122: 0003: 
1123: 0003: !******************************************************************************
1124: 0003: !   Sets the field tab order.  The tab order can be either:
1125: 0003: !   0 - The TAB order is defined by the fields position on the display,
1126: 0003: !       left to right then top to bottom of the display.
1127: 0003: !   1 - The TAB order is defined by the number order of the fields.  This is
1128: 0003: !       a new option which allows greater control over the field TAB order.
1129: 0003: !   -1  Returns the current setting without changing it.
1130: 0003: !   The default tab order is 0.  Once set, the TAB order is a global setting
1131: 0003: !   for the current and all future screens.
1132: 0003: 
1133: 0003:     FUNCTION DM.TAB.ORDER (ORDER%) EXTERNAL                                 !DSWM
1134: 0003:         INTEGER*1   ORDER%                                                  !DSWM
1135: 0003:         INTEGER*1   DM.TAB.ORDER                                            !DSWM
1136: 0003:     END FUNCTION                                                            !DSWM
1137: 0003: 
1138: 0003: !******************************************************************************
1139: 0003: !   This function actually processes user input on the currently shown form.
1140: 0003: !   The function returns when any unrecognised key terminates input in a
1141: 0003: !   field.  The keys which will do this are determined by the properties of
1142: 0003: !   the Display Manager fields on your form.  The function internally handles
1143: 0003: !   most of the form navigation keys (e.g. Tab, Back Tab, Home End) the
1144: 0003: !   rest are up to the user application.
1145: 0003: 
1146: 0003:     FUNCTION DM.PROCESS.SCREEN (FIRST.FIELD%, LAST.FIELD%, CONFIRM) EXTERNAL
1147: 0003:         INTEGER*2   DM.PROCESS.SCREEN
1148: 0003:         INTEGER*2   FIRST.FIELD%
1149: 0003:         INTEGER*2   LAST.FIELD%
1150: 0003:         INTEGER*1   CONFIRM
1151: 0003:     END FUNCTION
1152: 0003: 
1153: 0003: !******************************************************************************
1154: 0003: !   Associates a field on the current display with a given compile time
1155: 0003: !   variable.  This allows the varibale to be used in your program code
1156: 0003: !   AND be updated by the display manager fields in PROCESS.SCREEN.
1157: 0003: !
1158: 0003: !   NOTE: PLEASE BE VERY CAREFUL WITH THE THIRD PARAMETER TO THIS SUB
1159: 0003: !   Always use an absolute variable for VARIABLE$:
1160: 0003: !       CALL DM.NAME (2, "MY.VAR$", MY.VAR$)
1161: 0003: !   NEVER use a calcualted value. These forms are all ILLEGAL:
1162: 0003: !       CALL DM.NAME (2, "MY.VAR$", "1234")
1163: 0003: !       CALL DM.NAME (2, "MY.VAR$", STR$(MY.VAR%))
1164: 0003: !   Also, if you MUST pass in an array element, for example:
1165: 0003: !       CALL DM.NAME (2, "MY.VAR$", ARRAY.ELEMENT$(I%))
1166: 0003: !   then you must make sure you do not reDIM the array until you have finished
1167: 0003: !   displaying and processing the screen.
1168: 0003: 
1169: 0003:     SUB DM.NAME (FIELD%, NAME$, VARIABLE$) EXTERNAL                         !DSWM
1170: 0003:         INTEGER*2 FIELD%                                                    !DSWM
1171: 0003:         STRING NAME$                                                        !DSWM
1172: 0003:         STRING VARIABLE$                                                    !DSWM
1173: 0003:     END SUB                                                                 !DSWM
1174: 0003: 
1175: 0003: !******************************************************************************
1176: 0003: !   Returns the index of a field on the current screen, given its name.
1177: 0003: 
1178: 0003:     FUNCTION DM.INDEX (FIELD$) EXTERNAL                                     !DSWM
1179: 0003:         STRING FIELD$                                                       !DSWM
1180: 0003:         INTEGER*2 DM.INDEX                                                  !DSWM
1181: 0003:     END FUNCTION                                                            !DSWM
1182: 0003: 
1183: 0003: !******************************************************************************
1184: 0003: !   Sets the validation expression for a field on the display.  Exactly the
1185: 0003: !   same as setting the global VALID$ array yourself, except it is done
1186: 0003: !   via the fields name as assoicated via DM.NAME.FIELD and the expression
1187: 0003: !   is in standard infix notation.
1188: 0003: 
1189: 0003:     FUNCTION DM.VALID (FIELD$, VALID$) EXTERNAL                             !DSWM
1190: 0003:         STRING FIELD$                                                       !DSWM
1191: 0003:         STRING VALID$                                                       !DSWM
1192: 0003:         INTEGER*2 DM.VALID                                                  !DSWM
1193: 0003:     END FUNCTION                                                            !DSWM
1194: 0003: 
1195: 0003: !******************************************************************************
1196: 0003: !   Sets the message expression for a field on the display.  Exactly the
1197: 0003: !   same as setting the global MESSAGE$ array yourself, except it is done
1198: 0003: !   via the fields name as assoicated via DM.NAME.FIELD and the expression
1199: 0003: !   is in standard infix notation.
1200: 0003: 
1201: 0003:     FUNCTION DM.MESSAGE (FIELD$, MESSAGE$) EXTERNAL                         !DSWM
1202: 0003:         STRING FIELD$                                                       !DSWM
1203: 0003:         STRING MESSAGE$                                                     !DSWM
1204: 0003:         INTEGER*2 DM.MESSAGE                                                !DSWM
1205: 0003:     END FUNCTION                                                            !DSWM
1206: 0003: 
1207: 0003: !******************************************************************************
1208: 0003: !   Sets the field attributes for a field on the display. Exactly the
1209: 0003: !   same as using the SETF command yourself except that it is done by
1210: 0003: !   using the fields name as associated via the DM.NAME.FIELD.
1211: 0003: 
1212: 0003: SUB DM.FLD.ATT (FIELD$, VALUE$) EXTERNAL                                    !FNWB
1213: 0003:     STRING      FIELD$                                                      !FNWB
1214: 0003:     STRING      VALUE$                                                      !FNWB
1215: 0003: END SUB                                                                     !FNWB
1216: 0003: 
1217: 0003: !******************************************************************************
1218: 0003: !   Sets an input field to act as an output only field on the display. This
1219: 0003: !   allows setting input fields that contain headings etc. to be skipped by
1220: 0003: !   the cursor movement keys.
1221: 0003: 
1222: 0003: FUNCTION DM.OO.FIELD (FIELD$) EXTERNAL                                      !FNWB
1223: 0003:     INTEGER*2   DM.OO.FIELD                                                 !FNWB
1224: 0003:     STRING      FIELD$                                                      !FNWB
1225: 0003: END FUNCTION                                                                !FNWB
1226: 0003: 
1227: 0003: !******************************************************************************
1228: 0003: !   Sets an input field back to an i/o field
1229: 0003: 
1230: 0003: FUNCTION DM.IO.FIELD (FIELD$) EXTERNAL                                      !FNWB
1231: 0003:     INTEGER*2   DM.IO.FIELD                                                 !FNWB
1232: 0003:     STRING      FIELD$                                                      !FNWB
1233: 0003: END FUNCTION                                                                !FNWB
1234: 0003: 
1235: 0003: !******************************************************************************
1236: 0003: !   Sets the visibility expression for a field on the display.  Exactly the
1237: 0003: !   same as setting the global VISIBLE$ array yourself, except it is done
1238: 0003: !   via the fields name as assoicated via DM.NAME.FIELD and the expression
1239: 0003: !   is in standard infix notation.
1240: 0003: 
1241: 0003:     FUNCTION DM.VISIBLE (FIELD$, VISIBLE$) EXTERNAL                         !DSWM
1242: 0003:         STRING FIELD$                                                       !DSWM
1243: 0003:         STRING VISIBLE$                                                     !DSWM
1244: 0003:         INTEGER*2 DM.VISIBLE                                                !DSWM
1245: 0003:     END FUNCTION                                                            !DSWM
1246: 0003: 
1247: 0003: !******************************************************************************
1248: 0003: !   Sets an error message in field 1 of the display and moves the input
1249: 0003: !   focus to the offending line of the display.  Should be called from user
1250: 0003: !   validation code.  Equivalent of the following separate calls:
1251: 0003: !       CALL DM.CURRENT.FIELD%(DM.INDEX(FIELD$))
1252: 0003: !       FIELD$(1) = POLISH$(MESSAGE$)
1253: 0003: !   Can also be called with a null field name, in which case the cursor
1254: 0003: !   remains in the current input field, but the error is displayed.
1255: 0003: 
1256: 0003:     FUNCTION DM.FOCUS (FIELD$, MESSAGE$) EXTERNAL                           !DSWM
1257: 0003:         STRING FIELD$                                                       !DSWM
1258: 0003:         STRING MESSAGE$                                                     !DSWM
1259: 0003:         INTEGER*2 DM.FOCUS                                                  !DSWM
1260: 0003:     END FUNCTION                                                            !DSWM
1261: 0003: 
1262: 0003: !******************************************************************************
1263: 0003: 
1264: 0003: 
1265: 0003:     %INCLUDE DMEXTR.J86      ! IBM DISPLAY MANAGER functions
1266: 0003: \/* TIME STAMP BLOCK **************************************************
1267: 0003: \** END OF TIME STAMP BLOCK ******************************************/
1268: 0003:  REM  INCLUDE FILE FOR  DISPLAY MANAGER EXTERNAL FUNCTIONS FOR CB80  June 7/82
1269: 0003:  REM  IR91470 01 10 91  LAB G53  marked for EFT
1270: 0003:         DEF CLRSCR EXTERNAL             REM Clear screen for Display Manager
1271: 0003:         INTEGER CLRSCR
1272: 0003:         FEND
1273: 0003:         DEF CLSDIS EXTERNAL
1274: 0003:         INTEGER CLSDIS
1275: 0003:         FEND                            REM Close Display Manager
1276: 0003:         DEF DISPD(I%) EXTERNAL          REM Display a display.
1277: 0003:         INTEGER DISPD
1278: 0003:         FEND
1279: 0003:         DEF CURS(X$) EXTERNAL           REM turn on/off cursor visibility.
1280: 0003:         STRING CURS
1281: 0003:         FEND
1282: 0003:         DEF ENDF EXTERNAL               REM ENDF method of return.
1283: 0003:         INTEGER ENDF
1284: 0003:         FEND
1285: 0003:         DEF GETF EXTERNAL               REM GETF get data from a field
1286: 0003:         STRING GETF
1287: 0003:         FEND
1288: 0003:         DEF INITDM(A$) EXTERNAL         REM INITIALIZE Display Manager
1289: 0003:         INTEGER INITDM
1290: 0003:         FEND
1291: 0003:         DEF NXTF(I%)  EXTERNAL          REM NXTF Go to Next Field
1292: 0003:         INTEGER NXTF
1293: 0003:         FEND
1294: 0003:         DEF POSF(I%) EXTERNAL           REM POSTION on Field
1295: 0003:         INTEGER POSF
1296: 0003:         FEND
1297: 0003: 
1298: 0003:         DEF OPNDIS(A$) EXTERNAL         REM OPEN DISPLAY FILE
1299: 0003:         INTEGER OPNDIS
1300: 0003:         FEND
1301: 0003:         DEF PUTF(A$)  EXTERNAL          REM PUT data to Field
1302: 0003:         INTEGER PUTF
1303: 0003:         FEND
1304: 0003:         DEF RESF(I%)  EXTERNAL          REM RESUME field
1305: 0003:         STRING RESF
1306: 0003:         FEND
1307: 0003: 
1308: 0003:         DEF RETDM  EXTERNAL             REM RETURN Display Mgr Characteristics
1309: 0003:         STRING RETDM
1310: 0003:         FEND
1311: 0003:         DEF SETF(A$) EXTERNAL           REM SET Field  video attributes
1312: 0003:         STRING SETF
1313: 0003:         FEND
1314: 0003:         DEF UPDF  EXTERNAL                      REM UPDATE Field data
1315: 0003:         STRING UPDF
1316: 0003:         FEND
1317: 0003: 
1318: 0003:         DEF RETF EXTERNAL
1319: 0003:         STRING RETF
1320: 0003:         FEND
1321: 0003:    REM  END OF INCLUDE FILE FOR DISPLAY MANAGER CALLS FOR CB80
1322: 0003: 
1323: 0003: \***********************************************************************
1324: 0003: \*
1325: 0003: \* Included code defining external Boots functions
1326: 0003: \*
1327: 0003: \***********************************************************************
1328: 0003:     %INCLUDE ADXCOPY.J86     ! To copy files
1329: 0003: \******************************************************************************
1330: 0003: \******************************************************************************
1331: 0003: \***                                                                        ***
1332: 0003: \***    %INCLUDE FOR SUBROUTINE ADXCOPYF (an I.B.M. system subroutine)      ***
1333: 0003: \***                                                                        ***
1334: 0003: \***         DATE WRITTEN  :  13th May 1988                                 ***
1335: 0003: \***                                                                        ***
1336: 0003: \******************************************************************************
1337: 0003: \******************************************************************************
1338: 0003: 
1339: 0003:    SUB  ADXCOPYF (RETC, INFILE, OUTFILE, OPT0, OPT1, OPT2) EXTERNAL
1340: 0003: 
1341: 0003:       INTEGER*4   RETC
1342: 0003:       STRING      INFILE, OUTFILE
1343: 0003:       INTEGER*2   OPT0, OPT1, OPT2
1344: 0003: 
1345: 0003:    END  SUB
1346: 0003: 
1347: 0003:     %INCLUDE ADXSERVE.J86    ! ADXSERVE function
1348: 0003: \******************************************************************************
1349: 0003: \******************************************************************************
1350: 0003: \***                                                                        ***
1351: 0003: \***    %INCLUDE FOR FUNCTION ADXSERVE (an I.B.M. system function)          ***
1352: 0003: \***                                                                        ***
1353: 0003: \***         AUTHOR        :  Bruce Scriver                                 ***
1354: 0003: \***                                                                        ***
1355: 0003: \***         DATE WRITTEN  :  14th March 1986                               ***
1356: 0003: \***                                                                        ***
1357: 0003: \***         DATE OF LAST REVISION  - 14th March 1986                       ***
1358: 0003: \***                                                                        ***
1359: 0003: \***                                                                        ***
1360: 0003: \******************************************************************************
1361: 0003: \******************************************************************************
1362: 0003: 
1363: 0003:    SUB ADXSERVE (RETURN.CODE%,                                                \
1364: 0003:                  ADX.FUNCTION%,                                               \
1365: 0003:                  ADX.PARM.1%,                                                 \
1366: 0003:                  ADX.PARM.2$)                                                 \
1367: 0003:    EXTERNAL
1368: 0003:   
1369: 0003:       STRING     ADX.PARM.2$
1370: 0003: 
1371: 0003:       INTEGER*2  ADX.FUNCTION%,                                               \
1372: 0003:                  ADX.PARM.1%
1373: 0003: 
1374: 0003:       INTEGER*4  RETURN.CODE%                                                 \
1375: 0003: 
1376: 0003:    END SUB     
1377: 0003: 
1378: 0003:     %INCLUDE BASROUT.J86     ! OSShell function
1379: 0003: \*LIB   BVEJ BASROUT  J86      03/11/97 08:16:26 PIDBLD3  *    FIX
1380: 0003: \*PROM  BVEJ BASROUT  J86      03/10/97 17:18:40 PIDBLD3  MVEJ IR34352
1381: 0003: \*RTIME BVEJ BASROUT  J86      03/10/97 17:18:41 PIDBLD3  MVEJ IR34352
1382: 0003: \*LIB   MVEJ BASROUT  J86      03/05/97 10:48:46 EDJRAL   *    IR34352
1383: 0003: \*LIB   MVEJ BASROUT  J86      02/17/97 11:19:56 EDJRAL   *    REASONAR
1384: 0003: \*LIB   MVEJ BASROUT  J86      02/14/97 15:59:11 EDJRAL   *    REASONAR
1385: 0003: ! BASROUT.J86 - this file is to be included in any BASIC code which utilizes
1386: 0003: !   the BASROUT.OBJ routines.  These routines were written
1387: 0003: !  using Metaware C and are intended to provide functions which
1388: 0003: !         are either not available in 4680 CBASIC or which can be more
1389: 0003: !               efficiently handled by the C language.  Their usage is
1390: 0003: !  offered on an "AT YOUR OWN RISK" basis.
1391: 0003: !
1392: 0003: !               The insert/extract routines usefulness may not be immediately
1393: 0003: !               apparent.  Their intention is that they be used in conjunction
1394: 0003: !               with a read/write form command.  They can more efficiently
1395: 0003: !               parse a string into many different variables than can the
1396: 0003: !               read form statement.  So instead of a long list of data var's
1397: 0003: !               it may be more efficient to just read/write one long string
1398: 0003: !               and then use the insert/extract routines to parse out the
1399: 0003: !   data.
1400: 0003: 
1401: 0003: ! ******************* SUB PROCESS FUNCTIONS *********************************
1402: 0003: 
1403: 0003: function osshell(cmd.line$) external   ! routine to start
1404: 0003:        ! another program.
1405: 0003:            integer*4    osshell    ! Upon completion of
1406: 0003:            string       cmd.line$   ! program, control is
1407: 0003:        ! returned to calling
1408: 0003: end function      ! program.
1409: 0003: !
1410: 0003: ! NOTES:  Program must be a 286 type file.  This does not exclude
1411: 0003: !         the capability to execute a batch file however.  Simply pass the
1412: 0003: !         following:
1413: 0003: !              c:\adx_spgm\command.286 batfile
1414: 0003: !         where batfile is the name of the batch file to be executed.
1415: 0003: !
1416: 0003: ! IMPORTANT: When using osshell to execute a batch file as described above,
1417: 0003: !            the final command in the batch file must be "exit".  If not,
1418: 0003: !       control is never given back to the calling program.
1419: 0003: 
1420: 0003: ! ************************ MEMORY RELATED FUNCTIONS ************************
1421: 0003: 
1422: 0003: function memfree(choice) external   ! routine to que the
1423: 0003:        ! status of the
1424: 0003:  integer*4 memfree    ! machine's memory:
1425: 0003:  integer*2 choice    ! Options:
1426: 0003:        !    1 - free
1427: 0003: end function      !    2 - total
1428: 0003:        !    3 - system
1429: 0003: 
1430: 0003: ! ********************** TIMEDATE RELATED FUNCTIONS ************************
1431: 0003: 
1432: 0003: function timedate(choice) external   ! routine to que the
1433: 0003:        ! OS's timedate table
1434: 0003:  integer*4 timedate   ! Choices:
1435: 0003:  integer*2 choice    !    1 - millisec's
1436: 0003:        !        since midnight
1437: 0003: end function      !    2 - minutes from
1438: 0003:        !  UCT (timezone)
1439: 0003:        !    3 - day of week
1440: 0003:        !   0-Sunday
1441: 0003:        !  6-Saturday
1442: 0003: 
1443: 0003: function settime(msecs) external   ! routine to set the
1444: 0003:        ! time on the controller
1445: 0003:  integer*4  settime    ! msecs is the desired
1446: 0003:  integer*4 msecs    ! number of milliseconds
1447: 0003:        ! since midnight
1448: 0003: end function      ! Returns negative on
1449: 0003:        ! error
1450: 0003: ! NOTE:  This routine sets the time only on the controller.  The terminals'
1451: 0003: ! time will not be updated until 1 AM or unless a terminal is STC'd.
1452: 0003: ! At 1 AM the controller broadcasts the new time to all terminals.
1453: 0003: ! Insure this is taken into consideration when using this routine.
1454: 0003: 
1455: 0003: !******************** DISK FILE RELATED FUNCTIONS *************************
1456: 0003: 
1457: 0003: function truncate(name,length) external   ! routine to truncate
1458: 0003:        ! the specified file
1459: 0003:  integer*4 truncate   ! to a given length.
1460: 0003:  string  name
1461: 0003:  integer*4 length
1462: 0003: 
1463: 0003: end function
1464: 0003: 
1465: 0003: !******************** STRING VALUE RELATED FUNCTIONS **********************
1466: 0003: 
1467: 0003: function isalpha(bstrn) external   ! routine to identify
1468: 0003:        ! if the specified
1469: 0003:  integer*1 isalpha    ! string contains all
1470: 0003:  string  bstrn    ! alphabetic char's
1471: 0003:        ! Returns:
1472: 0003: end function      !     0 - all alpha
1473: 0003:        !     X - byte of 1st
1474: 0003:        !         non-alpha
1475: 0003:        !   char
1476: 0003: 
1477: 0003: function isdigit(bstrn) external   ! routine to identify
1478: 0003:        ! if the specified
1479: 0003:  integer*1 isdigit    ! string contains all
1480: 0003:  string  bstrn    ! numeric char's
1481: 0003:        ! Returns:
1482: 0003: end function      !     0 - all numeric
1483: 0003:        !     X - byte of 1st
1484: 0003:        !         non-numeric
1485: 0003:        !   char
1486: 0003: 
1487: 0003: function islower(bstrn) external   ! routine to identify
1488: 0003:        ! if the specified
1489: 0003:  integer*1 islower    ! string contains all
1490: 0003:  string  bstrn    ! lower case char's
1491: 0003:        ! Returns:
1492: 0003: end function      !     0 - all lowercase
1493: 0003:        !     X - byte of 1st
1494: 0003:        !         non-lowercase
1495: 0003:        !   char
1496: 0003: 
1497: 0003: function isupper(bstrn) external   ! routine to identify
1498: 0003:        ! if the specified
1499: 0003:  integer*1 isupper    ! string contains all
1500: 0003:  string  bstrn    ! upper case char's
1501: 0003:        ! Returns:
1502: 0003: end function      !     0 - all uppercase
1503: 0003:        !     X - byte of 1st
1504: 0003:        !         non-uppercase
1505: 0003:        !   char
1506: 0003: 
1507: 0003: function toalpha(bstrn) external   ! routine to convert
1508: 0003:        ! non-alpha or non-num
1509: 0003:    integer*2 toalpha    ! char's to spaces
1510: 0003:  string  bstrn    ! Returns:
1511: 0003: end function      !   x - no. of char's
1512: 0003:        !       changed
1513: 0003: 
1514: 0003: ! ********************* USER/GROUP ZERO LEVEL FUNCTIONS *********************
1515: 0003: 
1516: 0003: function idlecount(choice) external   ! routine to either
1517: 0003:        ! set to zero or queue
1518: 0003:  integer*4 idlecount   ! the value of the
1519: 0003:  integer*1 choice    ! processor's idlecount
1520: 0003:        ! Choice:
1521: 0003: end function      !     0 - set to zero
1522: 0003: !       !     1 - get value
1523: 0003: ! NEEDS USER/GROUP 0 LEVEL OF AUTHORIZATION  ! Returns:
1524: 0003: ! TO WORK - This level is not available unless  !     X - idlecount
1525: 0003: ! the file ADXCSOUF.DAT file is "patched".  This !    -X - error code
1526: 0003: ! is highly unrecommended.
1527: 0003: 
1528: 0003: function logical(actname,logname,choice) external ! routine to set a
1529: 0003:        ! a logical name.
1530: 0003:  integer*4 logical    ! parms are self
1531: 0003:         string  logname    ! explanatory except
1532: 0003:  string  actname    ! for choice:
1533: 0003:  integer*1 choice    !   0 - set process
1534: 0003:        !   1 - set system
1535: 0003: end function      !   2 - get process
1536: 0003:        !   3 - get system
1537: 0003: 
1538: 0003: ! NOTE:  Only the setting of a system level of logical name requires
1539: 0003: ! user/group zero level of authorization.  Any application may query any
1540: 0003: ! logical name.  Setting of a system logical name is only applicable until
1541: 0003: ! the system is IPL'd.  A process logical name is only active when that
1542: 0003: ! process is active.
1543: 0003: 
1544: 0003: !******************** STRING PARSING FUNCTIONS *****************************
1545: 0003: 
1546: 0003: function inserts(whole,part,offset) external  ! routine to insert a
1547: 0003:        ! string (part) into
1548: 0003:  integer*2 INSERTS    ! another string (whole)
1549: 0003:  string  whole    ! starting at specified
1550: 0003:  string  part    ! character (offset)
1551: 0003:  integer*2 offset
1552: 0003: 
1553: 0003: end function
1554: 0003: 
1555: 0003: function cinsert4(integer4,bstring,offset) external   ! routine to insert
1556: 0003:        ! a 4-byte integer into
1557: 0003:  integer*1 cinsert4   ! a string starting at
1558: 0003:  integer*4 integer4   ! byte specified by
1559: 0003:  string  bstring    ! offset (1-based)
1560: 0003:  integer*2 offset    ! Returns:
1561: 0003:        !     0 - Success
1562: 0003: end function      !    -1 - String overrun
1563: 0003: 
1564: 0003: function cinsert2(integer2,bstring,offset) external  ! routine to insert
1565: 0003:        ! a 2-byte integer into
1566: 0003:  integer*1 cinsert2   ! a string starting at
1567: 0003:  integer*2 integer2   ! byte specified by
1568: 0003:  string  bstring    ! offset (1-based)
1569: 0003:  integer*2 offset    ! Returns:
1570: 0003:        !     0 - Success
1571: 0003: end function      !    -1 - String overrun
1572: 0003: 
1573: 0003: function cinsert1(bstring,integer1,offset) external  ! routine to insert
1574: 0003:        ! a 1-byte integer into
1575: 0003:  integer*1 cinsert1   ! a string starting at
1576: 0003:  integer*1 integer1   ! byte specified by
1577: 0003:  string  bstring    ! offset (1-based)
1578: 0003:  integer*2 offset    ! Returns:
1579: 0003:        !     0 - Success
1580: 0003: end function      !    -1 - String overrun
1581: 0003: 
1582: 0003: function extracts(whole,part,offset) external  ! routine to extract a
1583: 0003:        ! string (part) from
1584: 0003:  integer*2 EXTRACTS   ! another string (whole)
1585: 0003:  string  whole    ! starting at specified
1586: 0003:  string  part    ! character (offset)
1587: 0003:  integer*2 offset
1588: 0003: 
1589: 0003: end function
1590: 0003: 
1591: 0003: function cextract4(bstring,offset) external  ! routine to extract
1592: 0003:        ! a 4-byte integer from
1593: 0003:  integer*4 cextract4   ! a string starting at
1594: 0003:                        ! byte specified by
1595: 0003:  string  bstring    ! offset (1-based)
1596: 0003:  integer*2 offset    ! Returns:
1597: 0003:        !     X - 4 byte integer
1598: 0003: end function      !    -1 - String overrun
1599: 0003: 
1600: 0003: function cextract2(bstring,offset) external  ! routine to extract
1601: 0003:        ! a 2-byte integer from
1602: 0003:  integer*2 cextract2   ! a string starting at
1603: 0003:                        ! byte specified by
1604: 0003:  string  bstring    ! offset (1-based)
1605: 0003:  integer*2 offset    ! Returns:
1606: 0003:        !     X - 2 byte integer
1607: 0003: end function      !    -1 - String overrun
1608: 0003: 
1609: 0003: function cextract1(bstring,offset) external  ! routine to extract
1610: 0003:        ! a 1-byte integer from
1611: 0003:  integer*1 cextract1   ! a string starting at
1612: 0003:                        ! byte specified by
1613: 0003:  string  bstring    ! offset (1-based)
1614: 0003:  integer*2 offset    ! Returns:
1615: 0003:        !     X - 1 byte integer
1616: 0003: end function      !    -1 - String overrun
1617: 0003: 
1618: 0003: 
1619: 0003: function srchdir (file.name$,dtbl.buffer$) external ! routine to return
1620: 0003:        ! file names and sizes
1621: 0003:        ! Return values:
1622: 0003:        !    -1  no matches
1623: 0003:        !        found on first
1624: 0003:        !        call
1625: 0003:        !    0   no matches
1626: 0003:        !        found on sub-
1627: 0003:        !        sequent calls
1628: 0003:        !    Pos Success
1629: 0003:        !    Neg OS Rtn Code
1630: 0003: ! Usage Note:  If searching for all occurences of a particular file name,
1631: 0003: ! first initialize dtbl.buffer$ to 48 Nulls (pack$("00")) and issue a call
1632: 0003: ! to srchdir.  If any matches are found, a positive value will be returned.
1633: 0003: ! To see if any more matches exist, just issue another call to srchdir without
1634: 0003: ! resetting the values of dtbl.buffer$.  If any are found, a positive value
1635: 0003: ! will be returned.  This can be repeated until a Zero is returned.  All data
1636: 0003: ! describing file will be returned in the dtbl.buffer$ after each call.  Format
1637: 0003: ! of this data is defined below.
1638: 0003: 
1639: 0003:  integer*4 srchdir
1640: 0003: 
1641: 0003:  string  file.name$   ! file name to start
1642: 0003:        ! search (18 bytes max)
1643: 0003:        ! Wild cards and logical
1644: 0003:        ! names supported.
1645: 0003: 
1646: 0003:  string  dtbl.buffer$   ! must be initialized
1647: 0003:        ! to 48 bytes.  Contains
1648: 0003:        ! all of directory info
1649: 0003:        ! Initialize to nulls
1650: 0003:        ! each time a new file
1651: 0003:        ! name is used.
1652: 0003: 
1653: 0003: ! NOTE:  Format of dtbl.buffer$ string is as follows:
1654: 0003: !
1655: 0003: ! Offs  Type                    Description Notes
1656: 0003: !  0 integer*4  key  use extract4 to access
1657: 0003: !  4  string (18 bytes) file name
1658: 0003: ! 22 integer*2  attributes use extract2 to access
1659: 0003: !      0x01 - Read Only
1660: 0003: !      0x02 - Hidden
1661: 0003: !      0x04 - System
1662: 0003: !      0x08 - Volume Label
1663: 0003: !      0x10 - Subdirectory
1664: 0003: !      0x20 - Archive (Files)
1665: 0003: !      0x40 - Security enabled
1666: 0003: !      0x80 - Reserved
1667: 0003: !      0x0000 - Local
1668: 0003: !      0x4000 - Mirrored/Update
1669: 0003: !      0xC000 - Mirrored/Close
1670: 0003: !
1671: 0003: !      0x6000 - Compound/Update
1672: 0003: !      0xE000 - Compound/Close
1673: 0003: ! 24 integer*2  record size use extract2 to access
1674: 0003: ! 26 integer*1  User ID of Owner
1675: 0003: ! 27 integer*1  Group ID of Owner
1676: 0003: ! 28 integer*2  File Security
1677: 0003: ! 30 string (6 bytes) Reserved
1678: 0003: ! 36 integer*4  File Size use extract4 to access
1679: 0003: ! 40 integer*2  Year  use extract2 to access
1680: 0003: ! 42 integer*1  Month
1681: 0003: ! 43 integer*1  Day
1682: 0003: ! 44 integer*1  Hour
1683: 0003: ! 45 integer*1  Minute
1684: 0003: ! 46 integer*1  Second
1685: 0003: ! 47 integer*1  Reserved
1686: 0003: 
1687: 0003: end function
1688: 0003: 
1689: 0003: function srchproc (proc.name$,ptbl.buffer$) external ! routine to return
1690: 0003:        ! process names and
1691: 0003:        ! status.  Handy to
1692: 0003:        ! determine if a
1693: 0003:        ! program is currently
1694: 0003:        ! running.
1695: 0003:        ! Return values:
1696: 0003:        !    -1  no matches
1697: 0003:        !        found on first
1698: 0003:        !        call
1699: 0003:        !    0   no matches
1700: 0003:        !        found on sub-
1701: 0003:        !        sequent calls
1702: 0003:        !    Pos Success
1703: 0003:        !    Neg Failure
1704: 0003:        !        OS Rtn Code
1705: 0003:        ! 80000001h - Insuff
1706: 0003:         !        ptbl buffer
1707: 0003:        !        Length
1708: 0003: ! Usage Note:  If searching for all occurences of a particular process name,
1709: 0003: ! first initialize ptbl.buffer$ to 60 Nulls (pack$("00")) and issue a call
1710: 0003: ! to srchproc.  If any matches are found, a positive value will be returned.
1711: 0003: ! To see if any more matches exist, just issue another call to srchproc without
1712: 0003: ! resetting the values of ptbl.buffer$.  If any are found, a positive value
1713: 0003: ! will be returned.  This can be repeated until a Zero is returned.  All data
1714: 0003: ! describing file will be returned in the ptbl.buffer$ after each call.  Format
1715: 0003: ! of this data is defined as follows:
1716: 0003: !
1717: 0003: !       --------------------------------------------------------
1718: 0003: !   0   |                         PID                          |
1719: 0003: !       --------------------------------------------------------
1720: 0003: !   4   |           FID             |   CID        |   VCID    |
1721: 0003: !       --------------------------------------------------------
1722: 0003: !   8   |                         NAME                         |
1723: 0003: !       --------------------------------------------------------
1724: 0003: !  12   |                         NAME cont'd                  |
1725: 0003: !       --------------------------------------------------------
1726: 0003: !  16   |       NAME cont'd         |   STATE      |  PRIOR    |
1727: 0003: !       --------------------------------------------------------
1728: 0003: !  20   |                         MAXMEM                       |
1729: 0003: !       --------------------------------------------------------
1730: 0003: !  24   |       FLAGS               |   USER        |  GROUP   |
1731: 0003: !       --------------------------------------------------------
1732: 0003: !  28   |                         PARENT                       |
1733: 0003: !       --------------------------------------------------------
1734: 0003: !  32   |                         EVENTS                       |
1735: 0003: !       --------------------------------------------------------
1736: 0003: !  36   |                         CODE                         |
1737: 0003: !       --------------------------------------------------------
1738: 0003: !  40   |                         CSIZE                        |
1739: 0003: !       --------------------------------------------------------
1740: 0003: !  44   |                         DATA                         |
1741: 0003: !       --------------------------------------------------------
1742: 0003: !  48   |                         DSIZE                        |
1743: 0003: !       --------------------------------------------------------
1744: 0003: !  52   |                         HEAP                         |
1745: 0003: !       --------------------------------------------------------
1746: 0003: !  56   |                         HSIZE                        |
1747: 0003: !       --------------------------------------------------------
1748: 0003: !
1749: 0003: !       PID   Process ID
1750: 0003: !       FID  Process's Family ID
1751: 0003: !       CID   Physical Console Device Number
1752: 0003: !       VCID  Process's Virtual Console Number
1753: 0003: !       NAME  Process Name (Application Running)
1754: 0003: ! STATE    Process State (0-Run, 1-Waiting, 2-Terminating)
1755: 0003: ! PRIOR    Priority
1756: 0003: !       MAXMEM  Maximum Memory Allowed
1757: 0003: !       FLAGS  Bit 0 (1-System Process, 0-User Process)
1758: 0003: !   Bit 1 (1-Locked in Memory, 0-Swappable)
1759: 0003: !   Bit 2 (1-Running in SWI context, 0-Running in main context)
1760: 0003: !   Bit 3 (1-Superuser Process,0-Not a Superuser Process)
1761: 0003: ! USER  User Number
1762: 0003: ! GROUP  Group Number
1763: 0003: !       PARENT   Parent Process ID
1764: 0003: !       EVENTS   Bit Map of events that have completed but not retrieved
1765: 0003: !       CODE  Start of code area in user space
1766: 0003: ! CSIZE  Size in bytes of code area
1767: 0003: !       DATA  Start of data area in user space
1768: 0003: ! DSIZE  Size in bytes of data area
1769: 0003: !       HEAP  Start of heap area in user space
1770: 0003: ! HSIZE  Size in bytes of heap area
1771: 0003: !
1772: 0003:  integer*4 srchproc
1773: 0003: 
1774: 0003:  string  proc.name$   ! process name to start
1775: 0003:        ! search (10 bytes max)
1776: 0003:        ! Wild cards and logical
1777: 0003:        ! names supported.
1778: 0003: 
1779: 0003:  string  ptbl.buffer$   ! must be initialized
1780: 0003:        ! to 60 bytes.  Contains
1781: 0003:        ! all of process info
1782: 0003:        ! Initialize to nulls
1783: 0003:        ! each time a new
1784: 0003:        ! process name is used.
1785: 0003: 
1786: 0003: end function
1787: 0003: 
1788: 0003: function cconstat(timeout) external       ! function similar
1789: 0003:                                               ! to BASIC constat%
1790: 0003:  integer*2 cconstat   ! waits for either a
1791: 0003:  integer*4 timeout    ! key being hit or
1792: 0003:        ! the timer expiring
1793: 0003:        ! before returning
1794: 0003:        ! returns:
1795: 0003:        !   -1 error
1796: 0003:        !    0 timer expired
1797: 0003:        !    x scan code of
1798: 0003:        !      key hit
1799: 0003: end function
1800: 0003: 
1801: 0003: function disksize(disk.name$) external   ! function to find
1802: 0003:        ! the total size of
1803: 0003:  integer*4 disksize   ! the specified disk
1804: 0003:  string  disk.name$   ! name (e.g. "h0:")
1805: 0003:        ! if return value is
1806: 0003:        ! negative, error
1807: 0003: end function      ! was received
1808: 0003: 
1809: 0003: 
1810: 0003:     %INCLUDE BTCSTR.J86      ! String functions
1811: 0003: !********************************************************************
1812: 0003: !***
1813: 0003: !***    INCLUDED CODE:  BTCSTR.J86
1814: 0003: !***    AUTHOR:         Stuart William McConnachie
1815: 0003: !***    DATE:           26th February 2006
1816: 0003: !***
1817: 0003: !********************************************************************
1818: 0003: !***
1819: 0003: !***    Controller CBASIC String Functions
1820: 0003: !***
1821: 0003: !********************************************************************
1822: 0003: 
1823: 0003: !Swaps to CBASIC strings
1824: 0003: SUB SWAPSTR (S1$, S2$) EXTERNAL
1825: 0003:     STRING S1$, S2$
1826: 0003: END SUB
1827: 0003: 
1828: 0003: !Left trim a string of spaces
1829: 0003: SUB LTRIM (S$) EXTERNAL
1830: 0003:     STRING S$
1831: 0003: END SUB
1832: 0003: 
1833: 0003: !Right trim a string of spaces
1834: 0003: SUB RTRIM (S$) EXTERNAL
1835: 0003:     STRING S$
1836: 0003: END SUB
1837: 0003: 
1838: 0003: !Left and right trim a string of spaces
1839: 0003: SUB TRIM (S$) EXTERNAL
1840: 0003:     STRING S$
1841: 0003: END SUB
1842: 0003: 
1843: 0003: !Left trim a string of a given ASCII character
1844: 0003: SUB LTRIMC (S$, C%) EXTERNAL
1845: 0003:     STRING S$
1846: 0003:     INTEGER*1 C%
1847: 0003: END SUB
1848: 0003: 
1849: 0003: !Right trim a string of a given ASCII character
1850: 0003: SUB RTRIMC (S$, C%) EXTERNAL
1851: 0003:     STRING S$
1852: 0003:     INTEGER*1 C%
1853: 0003: END SUB
1854: 0003: 
1855: 0003: !Left and right trim a string of a given ASCII character
1856: 0003: SUB TRIMC (S$, C%) EXTERNAL
1857: 0003:     STRING S$
1858: 0003:     INTEGER*1 C%
1859: 0003: END SUB
1860: 0003: 
1861: 0003: !Insert one string into another
1862: 0003: FUNCTION SUBSTR(S1$, O1%, S2$, O2%, L2%) EXTERNAL
1863: 0003:     STRING    S1$, S2$
1864: 0003:     INTEGER*2 O1%, O2%, L2%
1865: 0003:     INTEGER*1 SUBSTR
1866: 0003: END FUNCTION
1867: 0003:     
1868: 0003:     %INCLUDE CMPDATE.J86     ! Compare date utility
1869: 0003: !********************************************************************
1870: 0003: !***
1871: 0003: !***    INCLUDED CODE:  CMPDATE.J86
1872: 0003: !***    AUTHOR:         Stuart William McConnachie
1873: 0003: !***    DATE:           27th January 1997
1874: 0003: !***
1875: 0003: !********************************************************************
1876: 0003: !***   
1877: 0003: !***    Version B            Nik Sen                 30th March 1998
1878: 0003: !***    Changes to cope with a date of '000000' by replacing it with
1879: 0003: !***    '850101' before comparison. An all zero's date is valid in 
1880: 0003: !***    certain date fields and CMPDATE was returning the wrong result
1881: 0003: !***    when comparing with an actual date. Also change to cope with
1882: 0003: !***    dates of '999999' as some date fields are initialised to this
1883: 0003: !***    as a high value.
1884: 0003: !***
1885: 0003: !***    Version C    Stuart William McConnachie   20th December 1999
1886: 0003: !***    Improved function efficiency by changing tests for high and
1887: 0003: !***    low values, added above, to integers (rather than strings).
1888: 0003: !***    Also, using 850101 as a replacement for 000000, will not give
1889: 0003: !***    valid results after 350101 because of the 50 year wrap, so
1890: 0003: !***    corrected this.
1891: 0003: !***
1892: 0003: !***    Version D.  Stuart William McConnachie    26th February 2006
1893: 0003: !***    Place this code in it's own module in FUNLIB.  Make all
1894: 0003: !***    the functions herein EXTERNAL accordingly.
1895: 0003: !***
1896: 0003: !********************************************************************
1897: 0003: !***    
1898: 0003: !***    The following functions compare dates, checking for
1899: 0003: !***    century boundries.  Dates in the 50 years prior to the
1900: 0003: !***    compared date are less than the compared date, dates in
1901: 0003: !***    50 years after the compared date are greater than the
1902: 0003: !***    compared date.
1903: 0003: !***    Can handle dates in both packed and unpacked formats, or
1904: 0003: !***    a mixture of both.
1905: 0003: !***    In the case of a error, for example IH after detecting
1906: 0003: !***    illegal characters in VAL, the functions default to
1907: 0003: !***    comparing strings without testing for a change of century.
1908: 0003: !***
1909: 0003: !***    DATE.GT(DATE1$, DATE2$)  same as  DATE1$ >  DATE2$
1910: 0003: !***    DATE.GE(DATE1$, DATE2$)  same as  DATE1$ >= DATE2$
1911: 0003: !***    DATE.LT(DATE1$, DATE2$)  same as  DATE1$ <  DATE2$
1912: 0003: !***    DATE.LE(DATE1$, DATE2$)  same as  DATE1$ <= DATE2$
1913: 0003: !***
1914: 0003: !********************************************************************
1915: 0003: 
1916: 0003: FUNCTION DATE.GT(DATE1$, DATE2$) EXTERNAL                               !DSWM
1917: 0003:     STRING    DATE1$, DATE2$
1918: 0003:     INTEGER*1 DATE.GT
1919: 0003: END FUNCTION
1920: 0003: 
1921: 0003: 
1922: 0003: FUNCTION DATE.GE(DATE1$, DATE2$) EXTERNAL                               !DSWM
1923: 0003:     STRING    DATE1$, DATE2$
1924: 0003:     INTEGER*1 DATE.GE
1925: 0003: END FUNCTION
1926: 0003: 
1927: 0003: 
1928: 0003: FUNCTION DATE.LT(DATE1$, DATE2$) EXTERNAL                               !DSWM
1929: 0003:     STRING    DATE1$, DATE2$
1930: 0003:     INTEGER*1 DATE.LT
1931: 0003: END FUNCTION
1932: 0003: 
1933: 0003: 
1934: 0003: FUNCTION DATE.LE(DATE1$, DATE2$) EXTERNAL                               !DSWM
1935: 0003:     STRING    DATE1$, DATE2$
1936: 0003:     INTEGER*1 DATE.LE
1937: 0003: END FUNCTION
1938: 0003: 
1939: 0003:     %INCLUDE ERRNH.J86       ! Converts ERRN to 8-byte ASCII string
1940: 0003: \******************************************************************************
1941: 0003: \***
1942: 0003: \***	FUNCTION ERRNH
1943: 0003: \***
1944: 0003: \***	Convert the 4-byte error number to an 8-byte ASCII string
1945: 0003: \***
1946: 0003: \******************************************************************************
1947: 0003: 
1948: 0003: 	FUNCTION ERRNH PUBLIC
1949: 0027: 
1950: 0027: 	STRING			ERRNH,					\
1951: 0027: 				E$
1952: 0027: 
1953: 0027: 	INTEGER*2		I%
1954: 0027: 	INTEGER*4		H%
1955: 0027: 
1956: 0027: 	E$ = ""
1957: 003c: 	H% = ERRN
1958: 0056: 
1959: 0056: 	FOR I% = 28 TO 0 STEP -4
1960: 0066: 	    E$ = E$ + CHR$((SHIFT(H%,I%) AND 000FH) + 48)
1961: 00c2: 	NEXT I%
1962: 00da: 
1963: 00da: 	ERRNH = TRANSLATE$(E$,":;<=>?","ABCDEF")
1964: 0101: 
1965: 0101: 	END FUNCTION
1966: 011a:     %INCLUDE SLPCFEXT.J86    ! Sleeper control
1967: 011a: \*****************************************************************************
1968: 011a: \*****************************************************************************
1969: 011a: \***
1970: 011a: \***         FUNCTION DEFINITIONS FOR SLEEPER CHECK FILE
1971: 011a: \***
1972: 011a: \***                    REFERENCE : slpcfexa.J86
1973: 011a: \***
1974: 011a: \***    Version A           Steve Windsor          8.2.93
1975: 011a: \***
1976: 011a: \***    Version B           Richard Foster         8.7.93
1977: 011a: \***  
1978: 011a: \*****************************************************************************
1979: 011a: \*****************************************************************************
1980: 011a: 
1981: 011a:    FUNCTION SLPCF.SET EXTERNAL
1982: 011a:    END FUNCTION
1983: 011a: 
1984: 011a:   FUNCTION READ.SLPCF EXTERNAL
1985: 011a:    INTEGER*2 READ.SLPCF
1986: 011a:   END FUNCTION
1987: 011a: 
1988: 011a:   FUNCTION WRITE.SLPCF EXTERNAL
1989: 011a:    INTEGER*2 WRITE.SLPCF
1990: 011a:   END FUNCTION
1991: 011a: 
1992: 011a: 
1993: 011a: \***********************************************************************
1994: 011a: \*
1995: 011a: \* OPEN.SEQUENTIAL.FILE : External C file function helps in opening
1996: 011a: \*                        a sequential file as BASIC does not support
1997: 011a: \*                        this when running under Supplemental Mode.
1998: 011a: \*
1999: 011a: \***********************************************************************
2000: 011a: FUNCTION FUNC.OPEN.SEQUENTIAL.FILE( FILE.NAME$ ) EXTERNAL               !CJK
2001: 011a:     INTEGER*4 FUNC.OPEN.SEQUENTIAL.FILE                                 !CJK
2002: 011a:     STRING FILE.NAME$
2003: 011a: END FUNCTION
2004: 011a: 
2005: 011a: \***********************************************************************
2006: 011a: \*
2007: 011a: \* READ.SEQUENTIAL.FILE : External C file function helps in reading
2008: 011a: \*                        a sequential file as BASIC does not support
2009: 011a: \*                        this when running under Supplemental Mode.
2010: 011a: \*
2011: 011a: \***********************************************************************
2012: 011a: FUNCTION FUNC.READ.SEQUENTIAL.FILE( FILE.HANDLE% ) EXTERNAL             !CJK
2013: 011a:     STRING FUNC.READ.SEQUENTIAL.FILE                                    !CJK
2014: 011a:     INTEGER*4 FILE.HANDLE%
2015: 011a: END FUNCTION
2016: 011a: 
2017: 011a: \***********************************************************************
2018: 011a: \*
2019: 011a: \* WRITE.SEQUENTIAL.FILE : External C file function helps in writing
2020: 011a: \*                         a sequential file as BASIC does not support
2021: 011a: \*                         this when running under Supplemental Mode.
2022: 011a: \*
2023: 011a: \***********************************************************************
2024: 011a: FUNCTION FUNC.WRITE.SEQUENTIAL.FILE(FILE.HANDLE%, FILE.RECORD$) EXTERNAL!CJK
2025: 011a:     INTEGER*4 FUNC.WRITE.SEQUENTIAL.FILE                                !CJK
2026: 011a:     INTEGER*4 FILE.HANDLE%
2027: 011a:     STRING FILE.RECORD$
2028: 011a: END FUNCTION
2029: 011a: 
2030: 011a: \***********************************************************************
2031: 011a: \*
2032: 011a: \* CLOSE.FILE : External C file function helps in closing a file as
2033: 011a: \*              BASIC does not support this when running under
2034: 011a: \*              Supplemental Mode.
2035: 011a: \*
2036: 011a: \***********************************************************************
2037: 011a: FUNCTION FUNC.CLOSE.FILE ( FILE.HANDLE% ) EXTERNAL                      !CJK
2038: 011a:     INTEGER*4 FILE.HANDLE%
2039: 011a: END FUNCTION
2040: 011a: 
2041: 011a: 
2042: 011a: \***********************************************************************
2043: 011a: \*
2044: 011a: \* SUB.PROCESS.DAY.DIR.SCREEN: This Sub-Program does all the necessary  !MJK
2045: 011a: \*                             actions needed for directory restore     !MJK
2046: 011a: \*                             processing including screen navigation.  !MJK
2047: 011a: \*
2048: 011a: \*                             It receives the directory values as an   !MJK
2049: 011a: \*                             input.                                   !MJK
2050: 011a: \*
2051: 011a: \* As a program modularisation, Directory restore has been made as a
2052: 011a: \* Sub-program to perform all the Directory restore functionalities
2053: 011a: \* within itself. This enables quick extraction from the main module
2054: 011a: \* should breach the 64k limit
2055: 011a: \*
2056: 011a: \***********************************************************************
2057: 011a: SUB SUB.PROCESS.DAY.DIR.SCREEN(IMG.FILE$, ALT.FILE$) EXTERNAL           !KDC
2058: 011a:     STRING              \
2059: 011a:         ALT.FILE$,      \
2060: 011a:         IMG.FILE$
2061: 011a: END SUB
2062: 011a: 
2063: 011a: \***********************************************************************
2064: 011a: \*
2065: 011a: \*    FUNC.DIR.NOT.EXISTS: This function checks the existence of given
2066: 011a: \*                         directory by using CHDIR command.
2067: 011a: \*
2068: 011a: \***********************************************************************
2069: 011a: FUNCTION FUNC.DIR.NOT.EXISTS(DIRECTORY.NAME$) PUBLIC                    !KDC
2070: 0143: 
2071: 0143:     INTEGER*1 FUNC.DIR.NOT.EXISTS
2072: 0143:     STRING    DIRECTORY.NAME$
2073: 0143: 
2074: 0143: ON ERROR GOTO DIR.NOT.EXISTS.ERR                                        !CJK
2075: 0158: 
2076: 0158:     FUNC.DIR.NOT.EXISTS = TRUE
2077: 016a: 
2078: 016a:     ! Trim the last slash found to avoid error using CHDIR
2079: 016a:     CALL TRIM   (DIRECTORY.NAME$)
2080: 017f:     CALL RTRIMC (DIRECTORY.NAME$, ASC("/"))
2081: 01b1:     CALL RTRIMC (DIRECTORY.NAME$, ASC("\\"))
2082: 01e3: 
2083: 01e3:     CHDIR DIRECTORY.NAME$
2084: 01f6:     FUNC.DIR.NOT.EXISTS = FALSE
2085: 0208: 
2086: 0208: DIR.NOT.EXISTS.ERR:
2087: 0218: 
2088: 0218: END FUNCTION
2089: 0234: 
2090: 0234: \***********************************************************************
2091: 0234: \*
2092: 0234: \*    FUNC.FILE.EXISTS: This function checks the existence of
2093: 0234: \*                      passed file by using SIZE function.
2094: 0234: \*
2095: 0234: \***********************************************************************
2096: 0234: FUNCTION FUNC.FILE.EXISTS(FILE.NAME$) PUBLIC                            !KDC
2097: 025d: 
2098: 025d:     STRING    FILE.NAME$
2099: 025d:     INTEGER*1 FUNC.FILE.EXISTS
2100: 025d: 
2101: 025d:     ON ERROR GOTO FILE.DOES.NOT.EXIST                                   !CJK
2102: 0272: 
2103: 0272:     CALL TRIM(FILE.NAME$)
2104: 0287: 
2105: 0287:     FUNC.FILE.EXISTS = TRUE
2106: 0299: 
2107: 0299:     FUN.RC2% = SIZE(FILE.NAME$)                                         !MJK
2108: 02b5: 
2109: 02b5:     EXIT FUNCTION
2110: 02bf: 
2111: 02bf: FILE.DOES.NOT.EXIST:
2112: 02cf:     FUNC.FILE.EXISTS = FALSE
2113: 02e1: 
2114: 02e1: END FUNCTION
2115: 02fd: 
2116: 02fd: \***********************************************************************
2117: 02fd: \*
2118: 02fd: \* Generic Comments: For all the screens, FIELD$(1) (status line) value
2119: 02fd: \*                   is hard-coded instead of using "Message no.". This
2120: 02fd: \*                   is because "Message No." is not accessible from
2121: 02fd: \*                   SUPPS mode, as BEMF.BIN file is not accessible.
2122: 02fd: \*
2123: 02fd: \***********************************************************************
2124: 02fd: 
2125: 02fd: \***********************************************************************
2126: 02fd: \***********************************************************************
2127: 02fd: \***********************************************************************
2128: 02fd: \*                                                                     *
2129: 02fd: \*          S T A R T   O F   M A I N L I N E   C O D E                *
2130: 02fd: \*                                                                     *
2131: 02fd: \***********************************************************************
2132: 02fd: \***********************************************************************
2133: 02fd: \***********************************************************************
2134: 02fd: 
2135: 02fd: ON ERROR GOTO ERROR.DETECTED
2136: 032c: 
2137: 032c:     !----------------------------------------------------------!
2138: 032c:     ! Executes USE statement. Throws 'NP' error when initiated !
2139: 032c:     ! directly. As only two modes are defined, this error is   !
2140: 032c:     ! utilized to differentiate the modes.                     !
2141: 032c:     !----------------------------------------------------------!
2142: 032c:     %INCLUDE PSBUSEE.J86
2143: 032c: \/*********************************************************************/ PSBUSEE
2144: 032c: \/*                                                                   */ PSBUSEE
2145: 032c: \/*      PSBUSEE.J86  -  USE in PSB Application Program               */ PSBUSEE
2146: 032c: \/*      ----------------------------------------------               */ PSBUSEE
2147: 032c: \/*                                                                   */ PSBUSEE
2148: 032c: \/*********************************************************************/ PSBUSEE
2149: 032c:                                                                        ! PSBUSEE
2150: 032c:         USE  PSBCHN.OP , PSBCHN.APP , PSBCHN.MENCON , PSBCHN.U1 ,      \ PSBUSEE
2151: 0380:              PSBCHN.U2 , PSBCHN.U3                                     ! PSBUSEE
2152: 0380:                                                                        ! PSBUSEE
2153: 0380: 
2154: 0380: START.OF.PROGRAM:
2155: 0390:     ! XRESTORE started
2156: 0390: 
2157: 0390:     GOSUB INITIALISATION
2158: 03a2:     GOSUB MAIN.PROCESSING
2159: 03b4:     GOSUB TERMINATION
2160: 03c6: 
2161: 03c6:     ! XRESTORE completed
2162: 03c6: 
2163: 03c6: ! Called during abnormal run
2164: 03c6: STOP.PROGRAM:
2165: 03d6:     STOP
2166: 03e3: 
2167: 03e3: \***********************************************************************
2168: 03e3: \*
2169: 03e3: \* INITIALISATION : This Sub-routine does all the initial processing
2170: 03e3: \*                     before starting the main process
2171: 03e3: \*
2172: 03e3: \***********************************************************************
2173: 03e3: INITIALISATION:
2174: 03f3: 
2175: 03f3:     GOSUB INITIALISE.VARIABLES
2176: 0405:     GOSUB ALLOCATE.SESSION.NUMBERS
2177: 0417:     GOSUB CREATE.DIRECTORIES                                            !MJK
2178: 0429:     GOSUB CREATE.XRESTORE.LOG
2179: 043b:     GOSUB CHECK.XBACKUP.RUN
2180: 044d:     GOSUB CREATE.RUN.PIPE
2181: 045f:     GOSUB CONTROLLER.CONFIG.CHECK
2182: 0471:     ! Below sub routine is commented as no need to refer to sleeper     !PRG
2183: 0471:     ! as it was done for understanding the full backups and calcula-    !PRG
2184: 0471:     ! -ting the incrementals.As incrementals are turned off.            !PRG
2185: 0471: 
2186: 0471:  !  GOSUB GET.SLEEPER.CONFIGURATION                                     !PRG IDC
2187: 0471:     GOSUB DRIVE.FAT32.CHECK
2188: 0483:     GOSUB INITIATE.DISP.MNGR
2189: 0495: 
2190: 0495: RETURN
2191: 04a5: 
2192: 04a5: \***********************************************************************
2193: 04a5: \*
2194: 04a5: \* MAIN.PROCESSING : This Sub-routine does the main processing for
2195: 04a5: \*                      creating the Backup.
2196: 04a5: \*
2197: 04a5: \***********************************************************************
2198: 04a5: MAIN.PROCESSING:
2199: 04b5: 
2200: 04b5:     GOSUB PROCESS.BKPSCRPT
2201: 04c7:     GOSUB SCREEN.NAVIGATION
2202: 04d9: 
2203: 04d9: RETURN
2204: 04e9: 
2205: 04e9: \***********************************************************************
2206: 04e9: \*
2207: 04e9: \* TERMINATION: Termination Sub-routine will be called before
2208: 04e9: \*                 program closure.
2209: 04e9: \*
2210: 04e9: \***********************************************************************
2211: 04e9: TERMINATION:
2212: 04f9: 
2213: 04f9:     GOSUB CLOSE.AND.DEALLOC.SESSIONS
2214: 050b: 
2215: 050b: RETURN
2216: 051b: 
2217: 051b: \**********************************************************************\
2218: 051b: \**********************************************************************\
2219: 051b: \*                                                                    *\
2220: 051b: \*                 INITIALISATION SPECIFIC ROUTINES                   *\
2221: 051b: \*                                                                    *\
2222: 051b: \**********************************************************************\
2223: 051b: \**********************************************************************\
2224: 051b: 
2225: 051b: \***********************************************************************
2226: 051b: \*
2227: 051b: \* INITIALISE.VARIABLES : This Sub-routine Initialize all the
2228: 051b: \*                        necessary variables which will be used
2229: 051b: \*                        in this program.
2230: 051b: \*
2231: 051b: \***********************************************************************
2232: 051b: INITIALISE.VARIABLES:
2233: 052b: 
2234: 052b:     ! set messages first in case of usage
2235: 052b:     GOSUB INITALISE.MESSAGES
2236: 053d: 
2237: 053d:     ! Program variables
2238: 053d:     BATCH.SCREEN.FLAG$ = "S"            ! Screen
2239: 0554: 
2240: 0554:     CHAIN.TO.PROG$     = "PSB50"        ! PSB50 for chain
2241: 056b:     MODULE.NUMBER$     = "XRESTORE"     ! Current Module
2242: 0582: 
2243: 0582:     ! Screen related variables
2244: 0582:     DAY.INDEX%   = 77                   ! Screen 2's Day                !MJK
2245: 0592:     DD.MM.INDEX% = 3                    !            DD/MM              !MJK
2246: 05a2:     INPUT.INDEX% = 92                   !            Input              !MJK
2247: 05b2:     SCREEN%      = 1                    ! variables
2248: 05c2: 
2249: 05c2:     ! Screen number variables
2250: 05c2:     DIRECTORY.DAY.SELECT.SCR%    = 6    ! Directory day selection       !CJK
2251: 05d2:     DIRECTORY.PROCESS.SCR%       = 61   ! Directory restore process     !CJK
2252: 05e2:     DISPLAY.MAIN.SCR%            = 1    ! Restore main screen           !CJK
2253: 05f2:     DRIVE.DAY.SELECT.SCR%        = 2    ! Drive day selection           !CJK
2254: 0602:     DRIVE.DISK.SELECT.SCR%       = 3    ! Drive Disk selection          !CJK
2255: 0612:     DRIVE.PROCESS.SCR%           = 4    ! Drive restore process         !CJK
2256: 0622:     FILE.CONFIRMATION.SCR%       = 10   ! File restore confirmation     !CJK
2257: 0632:     FILE.DAY.SELECT.SCR%         = 8    ! File restore day selection    !CJK
2258: 0642:     FILE.DIR.AND.DIST.SCR%       = 9    ! File directory & distribution !CJK
2259: 0652:     FILE.PROCESS.SCR%            = 11   ! File restore process          !CJK
2260: 0662:     RESTORE.A.DIRECTORY.SCR%     = 5    ! Directory display             !CJK
2261: 0672:     RESTORE.A.FILE.SCR%          = 7    ! File name entry screen        !CJK
2262: 0682: 
2263: 0682:     ! Constant variables
2264: 0682:     ARRAY.LIMIT%     = 200                 ! Setting the Array Index%   !MJK
2265: 0693:     COMMA.VALUE$     = ","                 ! Comma value                !MJK
2266: 06aa:     CONSTANT.COLON$  = ":"                 ! Colon value                !MJK
2267: 06c1:     CRLF$            = CHR$(13) + CHR$(10) ! Assigning CR/LF            !MJK
2268: 06f0:     DIR.TO.SHOW%     = 23                  ! No. of directories/screen  !MJK
2269: 0700:     FALSE            = 0                   ! False = 0                  !MJK
2270: 0710:     TRUE             = -1                  ! True  = -1                 !MJK
2271: 0720:     XRE.NULL$        = ""                  ! NULL value                 !MJK
2272: 0737:     XRE.SPACE$       = " "                 ! Single space               !MJK
2273: 074e:     XRE.ZERO%        = 0                   ! zero use                   !MJK
2274: 075e: 
2275: 075e:     ! Array variables
2276: 075e:     BKP.INDEX% = XRE.ZERO%
2277: 0774: 
2278: 0774:     ! Controller variables
2279: 0774:     MASTER.AND.FILE.SERVER% = 21        ! Master/File server value
2280: 0784: 
2281: 0784:     BKP.DAYS%   = 14                    ! Number of available backups
2282: 0795: 
2283: 0795:     ! File related variables
2284: 0795:     C.BKP.ALT$  = "C:\XDISKALT\"        ! Alternate C BACKUP
2285: 07ac:     C.BKP.IMG$  = "C:\XDISKIMG\"        ! Primary C Backup
2286: 07c3:     D.BKP.ALT$  = "D:\XDISKALT\"        ! Alternate D BACKUP
2287: 07da:     D.BKP.IMG$  = "D:\XDISKIMG\"        ! Primary D BACKUP
2288: 07f1:     DIR.OUT$    = "C:\DIR.OUT"          ! Directory listing             !MJK
2289: 0808:     DIR1.OUT$   = "C:\DIR1.OUT"         ! STDOUT file                   !OJK
2290: 081f:     TEMP.DIR$   = "C:\TEMP\"            ! Temp directory
2291: 0836: 
2292: 0836:     XBACK.PIPE.NAME$       = "pi:XBACKUP"               ! XBACKUP pipe
2293: 084d:     XBACK.PIPE.REPORT.NUM% = 426                        ! Temporary num
2294: 085e:     XRE.LOG.FILENAME$      = "D:/ADX_UDT1/XRESTORE.LOG" ! Log file name
2295: 0875:     XRE.LOG.REPORT.NUM%    = 428                        ! Temporary num
2296: 0886:     XRE.PIPE.NAME$         = "pi:XRESTORE"              ! Run pipe
2297: 089d:     XRE.PIPE.REPORT.NUM%   = 427                        ! Temporary num
2298: 08ae: 
2299: 08ae:     ! It is arranged in weekly order                                    !MJK
2300: 08ae:     ! set day constants to avoid mistakes and repeats                   !IDC
2301: 08ae:     CONSTANT.SUNDAY.SHORT$    = "SUN"                                   !IDC
2302: 08c5:     CONSTANT.MONDAY.SHORT$    = "MON"                                   !IDC
2303: 08dc:     CONSTANT.TUESDAY.SHORT$   = "TUE"                                   !IDC
2304: 08f3:     CONSTANT.WEDNESDAY.SHORT$ = "WED"                                   !IDC
2305: 090a:     CONSTANT.THURSDAY.SHORT$  = "THU"                                   !IDC
2306: 0921:     CONSTANT.FRIDAY.SHORT$    = "FRI"                                   !IDC
2307: 0938:     CONSTANT.SATURDAY.SHORT$  = "SAT"                                   !IDC
2308: 094f:     ! It is arranged in weekly order                                    !MJK
2309: 094f:     CONSTANT.SUNDAY.LONG$     = "Sunday"                                !IDC
2310: 0966:     CONSTANT.MONDAY.LONG$     = "Monday"                                !IDC
2311: 097d:     CONSTANT.TUESDAY.LONG$    = "Tuesday"                               !IDC
2312: 0994:     CONSTANT.WEDNESDAY.LONG$  = "Wednesday"                             !IDC
2313: 09ab:     ! set this to the longest named day if the day identifiers change   !IDC
2314: 09ab:     ! at all so that later matching and extracting works ok             !IDC
2315: 09ab:     CONSTANT.LONGEST.DAY%     = LEN(CONSTANT.WEDNESDAY.LONG$)           !IDC
2316: 09cb:     CONSTANT.THURSDAY.LONG$   = "Thursday"                              !IDC
2317: 09e2:     CONSTANT.FRIDAY.LONG$     = "Friday"                                !IDC
2318: 09f9:     CONSTANT.SATURDAY.LONG$   = "Saturday"                              !IDC
2319: 0a10: 
2320: 0a10:     PARM.FULL$          = "F"                                           !IDC
2321: 0a27: 
2322: 0a27:     CALL SLPCF.SET
2323: 0a42: 
2324: 0a42:     ! Initialize variables before actual use
2325: 0a42:     ERROR.EXIST = FALSE
2326: 0a58:     SUPPS.ON    = FALSE                                                 !CJK
2327: 0a6e: 
2328: 0a6e:     ! File not opened yet, hence defaulting to false                    !MJK
2329: 0a6e:     BKPLIST.OPEN = FALSE                                                !MJK
2330: 0a84:     DIR.OPEN     = FALSE                                                !MJK
2331: 0a9a:     SLPCF.OPEN   = FALSE                                                !MJK
2332: 0ab0:     XBACK.OPEN   = FALSE                                                !MJK
2333: 0ac6:     XRE.LOG.OPEN = FALSE                                                !MJK
2334: 0adc:     XRE.OPEN     = FALSE                                                !MJK
2335: 0af2: 
2336: 0af2:     ! Incremental file flag for existing and changed                    !IDC
2337: 0af2:     DIM BKPLI.INCREMENTAL.EXIST$(6)                                     !IDC
2338: 0b21:     DIM BKPLI.INCREMENTAL.FILE.CHNG$(6)                                 !IDC
2339: 0b50: 
2340: 0b50:     ! Dimensioning array
2341: 0b50:     DIM BKP.FILE.MDD.ARRAY$(ARRAY.LIMIT%)                               !MJK
2342: 0b84:     DIM BKP.FILE.MMDD.ARRAY$(ARRAY.LIMIT%)                              !MJK
2343: 0bb8:     DIM BKPSCRPT.DIRECTORIES$(ARRAY.LIMIT%)                             !MJK
2344: 0bec:     DIM PRIMARY.ARCHIVED.NAMES$(ARRAY.LIMIT%)                           !MJK
2345: 0c20:     DIM SECONDARY.ARCHVD.NAMES$(ARRAY.LIMIT%)                           !MJK
2346: 0c54: 
2347: 0c54:     GOSUB SET.FILE.NAMES                                                !MJK
2348: 0c66: 
2349: 0c66: RETURN
2350: 0c76: 
2351: 0c76: ! IDC START BLOCK
2352: 0c76: \***********************************************************************
2353: 0c76: \*
2354: 0c76: \*    INITALISE.MESSAGES:This Sub-routine Initialize all the messages
2355: 0c76: \*                       used for status update and errors
2356: 0c76: \*
2357: 0c76: \***********************************************************************
2358: 0c76: INITALISE.MESSAGES:
2359: 0c86: 
2360: 0c86:     VERSION$ = "### XRESTORE.286 - Version M - 23/08/2014 ###"          !MJK
2361: 0c9d: 
2362: 0c9d:     DIM STATUS.TEXT.MSG$(63)                                            !JDC
2363: 0ccc:     DIM STATUS.TEXT.ERROR$(22)                                          !JDC
2364: 0cfb:     DIM SCREEN.TEXT.MSG$(31)                                            !JDC
2365: 0d2a: 
2366: 0d2a:     !******************************************************************
2367: 0d2a:     ! Status update messages
2368: 0d2a:     !******************************************************************
2369: 0d2a:     STATUS.TEXT.MSG$(1)  = " directory is created"
2370: 0d4d:     STATUS.TEXT.MSG$(2)  = "Checking "
2371: 0d70:     STATUS.TEXT.MSG$(3)  = " to check the"
2372: 0d93:     STATUS.TEXT.MSG$(4)  = "Restore completed successfully"
2373: 0db6:     STATUS.TEXT.MSG$(5)  = "Restore completed with exception"
2374: 0dd9:     STATUS.TEXT.MSG$(6)  = "Backup file not present"
2375: 0dfc:     STATUS.TEXT.MSG$(7)  = "Deleting file "
2376: 0e1f:     STATUS.TEXT.MSG$(8)  = "Checking BKPFAIL "
2377: 0e42:     STATUS.TEXT.MSG$(9)  = "File found in BKPFAIL file"
2378: 0e65:     STATUS.TEXT.MSG$(10) = "Copying and distributing "
2379: 0e88:     STATUS.TEXT.MSG$(11) = " is extracted to "
2380: 0eab:     STATUS.TEXT.MSG$(12) = "Restore application started Version ""M"""  !MJK
2381: 0ece:     STATUS.TEXT.MSG$(13) = "Checking Controller configuration"
2382: 0ef1:     STATUS.TEXT.MSG$(14) = "Controller status not obtainable"
2383: 0f14:     STATUS.TEXT.MSG$(15) = "This Controller is not configured "
2384: 0f37:     STATUS.TEXT.MSG$(16) = "SLPCF Full backup day is "
2385: 0f5a:     STATUS.TEXT.MSG$(17) = "SLPCF Full backup configuration not found"
2386: 0f7d:     STATUS.TEXT.MSG$(18) = "Checking the DRIVE format"
2387: 0fa0:     STATUS.TEXT.MSG$(19) = "C drive is not in FAT32 format"
2388: 0fc3:     STATUS.TEXT.MSG$(20) = "D drive is not in FAT32 format"
2389: 0fe6:     STATUS.TEXT.MSG$(21) = "Initializing the display manager"
2390: 1009:     STATUS.TEXT.MSG$(22) = "Checking the Backup script file"
2391: 102c:     STATUS.TEXT.MSG$(23) = "'BKPSCRPT array index error"
2392: 104f:     STATUS.TEXT.MSG$(24) = " day is selected"
2393: 1072:     STATUS.TEXT.MSG$(25) = "C Drive restoration process started"
2394: 1095:     STATUS.TEXT.MSG$(26) = "D Drive restoration process started"
2395: 10b8:     STATUS.TEXT.MSG$(27) = ""           ! duplicate                     !JDC
2396: 10db:     STATUS.TEXT.MSG$(28) = "Restore completed successfully"
2397: 10fe:     STATUS.TEXT.MSG$(29) = " restoration "
2398: 1121:     STATUS.TEXT.MSG$(30) = " directory is created"
2399: 1144:     STATUS.TEXT.MSG$(31) = " dated "
2400: 1167:     STATUS.TEXT.MSG$(32) = "Checking BKPFAIL "
2401: 118a:     STATUS.TEXT.MSG$(33) = ""           ! duplicate                     !JDC
2402: 11ad:     STATUS.TEXT.MSG$(34) = ""           ! duplicate                     !JDC
2403: 11d0:     STATUS.TEXT.MSG$(35) = " is extracted to "
2404: 11f3:     STATUS.TEXT.MSG$(36) = "Checking "
2405: 1216:     STATUS.TEXT.MSG$(37) = " to check the"
2406: 1239:     STATUS.TEXT.MSG$(38) = ""           ! duplicate                     !JDC
2407: 125c:     STATUS.TEXT.MSG$(39) = " file is entered "
2408: 127f:     STATUS.TEXT.MSG$(40) = ""           ! duplicate                     !JDC
2409: 12a2:     STATUS.TEXT.MSG$(41) = "File doesn't exist in the selected day "
2410: 12c5:     STATUS.TEXT.MSG$(42) = "Checking the archive file "
2411: 12e8:     STATUS.TEXT.MSG$(43) = " directory is selected "
2412: 130b:     STATUS.TEXT.MSG$(44) = " directory is created"
2413: 132e:     STATUS.TEXT.MSG$(45) = " directory is created"
2414: 1351:     STATUS.TEXT.MSG$(46) = " is extracted "                             !OJK
2415: 1374:     STATUS.TEXT.MSG$(47) = "File is being extracted from BKPFAIL file"
2416: 1397:     STATUS.TEXT.MSG$(48) = "File is extracted to "
2417: 13ba:     STATUS.TEXT.MSG$(49) = "Copying and Restoring the file"
2418: 13dd:     STATUS.TEXT.MSG$(50) = "File restoration successful"
2419: 1400:     STATUS.TEXT.MSG$(51) = "File restored with an exception"
2420: 1423:     STATUS.TEXT.MSG$(52) = "Ended: Error while opening "
2421: 1446:     STATUS.TEXT.MSG$(53) = "RESTORE not allowed when XBACKUP is active"
2422: 1469:     STATUS.TEXT.MSG$(54) = "XRESTORE is already active somewhere"
2423: 148c:     STATUS.TEXT.MSG$(55) = "archive file"
2424: 14af:     STATUS.TEXT.MSG$(56) = \                                            !JDC
2425: 14d2:           "'File doesn't exist in the selected archive file."           !JDC
2426: 14d2:     STATUS.TEXT.MSG$(57) = \                                            !JDC
2427: 14f5:           "'File doesn't exist in the selected date archive file. "     !JDC
2428: 14f5:     STATUS.TEXT.MSG$(58) = "Press F3 or ESC"
2429: 1518:     STATUS.TEXT.MSG$(59) = \                                            !JDC
2430: 153b:           "'Checking the restored file - Please wait..."                !JDC
2431: 153b:     STATUS.TEXT.MSG$(60) = "FALSE"
2432: 155e:     STATUS.TEXT.MSG$(61) = "TRUE"
2433: 1581:     STATUS.TEXT.MSG$(62) = \                                            !JDC
2434: 15a4:           "All directories and files have been restored to the "        !JDC
2435: 15a4:     STATUS.TEXT.MSG$(63) = " for restore"                               !JDC
2436: 15c7: 
2437: 15c7:     !******************************************************************
2438: 15c7:     ! Error messages
2439: 15c7:     !******************************************************************
2440: 15c7:     STATUS.TEXT.ERROR$(1)  = "UPDATE date function error in "
2441: 15ea:     STATUS.TEXT.ERROR$(2)  = "Error in opening DIR output file"
2442: 160d:     STATUS.TEXT.ERROR$(3)  = "Error in reading DIR header output file"
2443: 1630:     STATUS.TEXT.ERROR$(4)  = "'MDD array index error"
2444: 1653:     STATUS.TEXT.ERROR$(5)  = "'BKP array index error"
2445: 1676:     STATUS.TEXT.ERROR$(6)  = "PSDATE function error"
2446: 1699:     STATUS.TEXT.ERROR$(7)  = "'MDD array index error"
2447: 16bc:     STATUS.TEXT.ERROR$(8)  = "'MDD array index error"
2448: 16df:     STATUS.TEXT.ERROR$(9)  = "Error in opening BKPLIST file"
2449: 1702:     STATUS.TEXT.ERROR$(10) = ""                 ! duplication           !JDC
2450: 1725:     STATUS.TEXT.ERROR$(11) = ""                 ! duplication           !JDC
2451: 1748:     STATUS.TEXT.ERROR$(12) = "Error found in extracting files"
2452: 176b:     STATUS.TEXT.ERROR$(13) = "Error in opening BKPSCRPT file"
2453: 178e:     STATUS.TEXT.ERROR$(14) = "Error when copying/distributing file"
2454: 17b1:     STATUS.TEXT.ERROR$(15) = "Error while extracting files"             !OJK
2455: 17d4:     STATUS.TEXT.ERROR$(16) = "Error while distributing the file"        !OJK
2456: 17f7:     STATUS.TEXT.ERROR$(17) = "Error in opening BKPFAIL file"
2457: 181a:     STATUS.TEXT.ERROR$(18) = "Error in opening BKPLIST file"
2458: 183d:     STATUS.TEXT.ERROR$(19) = "Error while creating directory"
2459: 1860:     STATUS.TEXT.ERROR$(20) = "'Invalid key pressed"
2460: 1883:     STATUS.TEXT.ERROR$(21) = "'No Backups available. "                  !MJK
2461: 18a6:     STATUS.TEXT.ERROR$(22) = "Error in opening Sleeper file"            !JDC
2462: 18c9: 
2463: 18c9:     !****************************************************************** !JDC
2464: 18c9:     ! Screen messages                                                   !JDC
2465: 18c9:     !****************************************************************** !JDC
2466: 18c9:     SCREEN.TEXT.MSG$(1)  = "RESTORE A DIRECTORY DAY SELECTION"          !JDC
2467: 18ec:     SCREEN.TEXT.MSG$(2)  = "Place an X in the box next to the day to "  !JDC
2468: 190f:     SCREEN.TEXT.MSG$(3)  = "restore, then press ENTER"                  !JDC
2469: 1932:     SCREEN.TEXT.MSG$(4)  = "You have chosen to restore the "            !JDC
2470: 1955:     SCREEN.TEXT.MSG$(5)  = " directory."                                !JDC
2471: 1978:     SCREEN.TEXT.MSG$(6)  = \                                            !JDC
2472: 199b:           "Please choose which day you would like to restore:"          !JDC
2473: 199b:     SCREEN.TEXT.MSG$(7)  = "'Error in Backup details retrieval."        !JDC
2474: 19be:     SCREEN.TEXT.MSG$(8)  = " Refer XRESTORE log"                        !JDC
2475: 19e1:     SCREEN.TEXT.MSG$(9)  = "RESTORE A DIRECTORY STATUS"                 !JDC
2476: 1a04:     SCREEN.TEXT.MSG$(10) = " directory restoration in process - "       !JDC
2477: 1a27:     SCREEN.TEXT.MSG$(11) = " Directory of "                             !JDC
2478: 1a4a:     SCREEN.TEXT.MSG$(12) = " date "                                     !JDC
2479: 1a6d:     SCREEN.TEXT.MSG$(13) = "'Press ESC to go back to "                  !MJK
2480: 1a90:     SCREEN.TEXT.MSG$(14) = ""           ! duplicate                     !JDC
2481: 1ab3:     SCREEN.TEXT.MSG$(15) = ""           ! duplicate                     !JDC
2482: 1ad6:     SCREEN.TEXT.MSG$(16) = " are being extracted"                       !JDC
2483: 1af9:     SCREEN.TEXT.MSG$(17) = "RESTORE A DRIVE OR DRIVES"                  !JDC
2484: 1b1c:     SCREEN.TEXT.MSG$(18) = ""           ! duplicate                     !JDC
2485: 1b3f:     SCREEN.TEXT.MSG$(19) = ""           ! duplicate                     !JDC
2486: 1b62:     SCREEN.TEXT.MSG$(20) = "Please choose one of the following days:"   !JDC
2487: 1b85:     SCREEN.TEXT.MSG$(21) = "'No selection has been made. " + \          !JDC
2488: 1baf:                            "Value entered must be ""X"" OR ""x"" "      !JDC
2489: 1baf:     SCREEN.TEXT.MSG$(22) = ""           ! duplicate                     !JDC
2490: 1bd2:     SCREEN.TEXT.MSG$(23) = "D: drive"                                   !JDC
2491: 1bf5:     SCREEN.TEXT.MSG$(24) = "C: drive"                                   !JDC
2492: 1c18:     SCREEN.TEXT.MSG$(25) = "C: and D: drives"                           !JDC
2493: 1c3b:     SCREEN.TEXT.MSG$(26) = "'Restore completed with exception." + \     !JDC
2494: 1c65:                            " Check XRESTORE log for more details"       !OJK
2495: 1c65:     SCREEN.TEXT.MSG$(27) = ""           ! duplicate                     !JDC
2496: 1c88:     SCREEN.TEXT.MSG$(28) = ""           ! duplicate                     !JDC
2497: 1cab:     SCREEN.TEXT.MSG$(29) = "previous screen"                            !JDC
2498: 1cce:     SCREEN.TEXT.MSG$(30) = "'No directories available to restore." + \  !MJK
2499: 1cf8:                            " Press any key to exit screen"              !MJK
2500: 1cf8:     SCREEN.TEXT.MSG$(31) = "'Data will be lost"                         !JDC
2501: 1d1b: 
2502: 1d1b: RETURN
2503: 1d2b: ! IDC END BLOCK
2504: 1d2b: 
2505: 1d2b: \***********************************************************************!MJK
2506: 1d2b: \*                                                                      !MJK
2507: 1d2b: \* SET.FILE.NAMES: This Sub-routine initialize the file names based     !MJK
2508: 1d2b: \*                 on its presence                                      !MJK
2509: 1d2b: \*                                                                      !MJK
2510: 1d2b: \***********************************************************************!MJK
2511: 1d2b: SET.FILE.NAMES:                                                         !MJK
2512: 1d3b: 
2513: 1d3b:     ADXZUDIR.FILE.NAME$ = "C:\ADX_SPGM\ADXZUDIR.386" ! ADXZUDIR         !MJK
2514: 1d52:     ADXUNZIP.FILE.NAME$ = "C:\ADX_SPGM\ADXUNZIP.386" ! ADXUNZIP         !OJK
2515: 1d69:     ADXCSU0L.FILE.NAME$ = "C:\ADX_SPGM\ADXCSU0L.286" ! ADXCSU0L         !MJK
2516: 1d80: 
2517: 1d80:     IF NOT FUNC.FILE.EXISTS(ADXZUDIR.FILE.NAME$) THEN BEGIN             !MJK
2518: 1d9e:         ADXZUDIR.FILE.NAME$ = "D:\ADX_SPGM\ADXZUDIR.386" ! ADXZUDIR     !MJK
2519: 1db5:     ENDIF                                                               !MJK
2520: 1dbd: 
2521: 1dbd:     IF NOT FUNC.FILE.EXISTS(ADXUNZIP.FILE.NAME$) THEN BEGIN             !OJK
2522: 1ddb:         ADXUNZIP.FILE.NAME$ = "D:\ADX_SPGM\ADXUNZIP.386" ! ADXUNZIP     !OJK
2523: 1df2:     ENDIF                                                               !OJK
2524: 1dfa: 
2525: 1dfa:     IF NOT FUNC.FILE.EXISTS(ADXCSU0L.FILE.NAME$) THEN BEGIN             !MJK
2526: 1e18:         ADXCSU0L.FILE.NAME$ = "D:\ADX_SPGM\ADXCSU0L.286" ! ADXCSU0L     !MJK
2527: 1e2f:     ENDIF                                                               !MJK
2528: 1e37: 
2529: 1e37:     ! Set local drive for sleeper in supps mode                         !MJK
2530: 1e37:     SUPPS.SLEEPER.FILE.NAME$ = "D:\ADX_UDT1\SLPCF.BIN"                  !MJK
2531: 1e4e: 
2532: 1e4e:     IF NOT FUNC.FILE.EXISTS(SUPPS.SLEEPER.FILE.NAME$) THEN BEGIN        !MJK
2533: 1e6c:         SUPPS.SLEEPER.FILE.NAME$  = "C:\ADX_UDT1\SLPCF.BIN"             !MJK
2534: 1e83:     ENDIF                                                               !MJK
2535: 1e8b: 
2536: 1e8b:     ! Set full path for sleeper in normal runs                          !MJK
2537: 1e8b:     NORMAL.SLEEPER.FILE.NAME$ = "ADXLXACN::" + SUPPS.SLEEPER.FILE.NAME$ !MJK
2538: 1eb0:                                                                         !MJK
2539: 1eb0:     BKPLIST.PREFIX.D.DRIVE$ = "D:\ADX_UDT1\" + "BKPLIST."               !MJK
2540: 1ece:     BKPLIST.PREFIX.C.DRIVE$ = "C:\ADX_UDT1\" + "BKPLIST."               !MJK
2541: 1eec: 
2542: 1eec: RETURN                                                                  !MJK
2543: 1efc: 
2544: 1efc: \***********************************************************************
2545: 1efc: \*
2546: 1efc: \* ALLOCATE.SESSION.NUMBERS: This Sub-routine uses variables of FILE
2547: 1efc: \*                           functions and calls SESS.NUM.UTILITY to
2548: 1efc: \*                           allocate session numbers.
2549: 1efc: \*
2550: 1efc: \***********************************************************************
2551: 1efc: ALLOCATE.SESSION.NUMBERS:
2552: 1f0c: 
2553: 1f0c:     FUNC.FLAG$ = "O"   ! Setting the file operation
2554: 1f23: 
2555: 1f23:     ! XBACKUP pipe
2556: 1f23:     PASSED.INTEGER% = XBACK.PIPE.REPORT.NUM%
2557: 1f39:     PASSED.STRING$  = XBACK.PIPE.NAME$
2558: 1f57:     GOSUB GET.SESSION.NUMBER                                            !IDC
2559: 1f69:     XBACK.PIPE.SESS.NUM% = F20.INTEGER.FILE.NO%
2560: 1f7f: 
2561: 1f7f:     ! XRESTORE pipe
2562: 1f7f:     PASSED.INTEGER% = XRE.PIPE.REPORT.NUM%
2563: 1f95:     PASSED.STRING$  = XRE.PIPE.NAME$
2564: 1fb3:     GOSUB GET.SESSION.NUMBER                                            !IDC
2565: 1fc5:     XRE.PIPE.SESS.NUM% = F20.INTEGER.FILE.NO%
2566: 1fdb: 
2567: 1fdb:     ! XRESTORE log
2568: 1fdb:     PASSED.INTEGER% = XRE.LOG.REPORT.NUM%
2569: 1ff1:     PASSED.STRING$  = XRE.LOG.FILENAME$
2570: 200f:     GOSUB GET.SESSION.NUMBER                                            !IDC
2571: 2021:     XRE.LOG.SESS.NUM% = F20.INTEGER.FILE.NO%
2572: 2037: 
2573: 2037:     ! Sleeper Control file                                              !IDC
2574: 2037:     PASSED.INTEGER% = SLPCF.REPORT.NUM%                                 !IDC
2575: 204d:     PASSED.STRING$  = NORMAL.SLEEPER.FILE.NAME$                         !JDC
2576: 206b:     GOSUB GET.SESSION.NUMBER                                            !IDC
2577: 207d:     SLPCF.SESS.NUM% = F20.INTEGER.FILE.NO%                              !IDC
2578: 2093: 
2579: 2093: RETURN
2580: 20a3: 
2581: 20a3: \***********************************************************************!MJK
2582: 20a3: \*                                                                      !MJK
2583: 20a3: \* CREATE.DIRECTORIES : This Sub-routine creates the C:/XDISKIMG        !MJK
2584: 20a3: \*                      and C:/TEMP directory if missing.               !MJK
2585: 20a3: \*                                                                      !MJK
2586: 20a3: \***********************************************************************!MJK
2587: 20a3: CREATE.DIRECTORIES:                                                     !MJK
2588: 20b3:                                                                         !MJK
2589: 20b3:     IF FUNC.DIR.NOT.EXISTS(C.BKP.IMG$) THEN BEGIN                       !MJK
2590: 20d4:         CALL RTRIMC (C.BKP.IMG$, ASC("/"))                              !MJK
2591: 2107:         CALL RTRIMC (C.BKP.IMG$, ASC("\\"))                             !MJK
2592: 213a:         CALL OSSHELL("MKDIR " + C.BKP.IMG$ + " > " + "XRE.TMP" + \      !MJK
2593: 2174:                      " >>* " + "XRE.TMP")                               !MJK
2594: 2174:     ENDIF                                                               !MJK
2595: 217c:                                                                         !MJK
2596: 217c:     IF FUNC.DIR.NOT.EXISTS(TEMP.DIR$) THEN BEGIN                        !MJK
2597: 219d:         CALL RTRIMC (TEMP.DIR$, ASC("/"))                               !MJK
2598: 21d0:         CALL RTRIMC (TEMP.DIR$, ASC("\\"))                              !MJK
2599: 2203:         CALL OSSHELL("MKDIR " + TEMP.DIR$ + " > " + "XRE.TMP" + \       !MJK
2600: 223d:                      " >>* " + "XRE.TMP")                               !MJK
2601: 223d:     ENDIF                                                               !MJK
2602: 2245:                                                                         !MJK
2603: 2245: RETURN                                                                  !MJK
2604: 2255: 
2605: 2255: \***********************************************************************
2606: 2255: \*
2607: 2255: \* GET.SESSION.NUMBER: This Sub-routine calls SESS.NUM.UTILITY to
2608: 2255: \*                     allocate session numbers.
2609: 2255: \*
2610: 2255: \***********************************************************************
2611: 2255: GET.SESSION.NUMBER:
2612: 2265: 
2613: 2265:     FUN.RC2% = SESS.NUM.UTILITY(FUNC.FLAG$, PASSED.INTEGER%, \          !IDC
2614: 2299:                                 PASSED.STRING$)                         !MJK
2615: 2299:     GOSUB CHECK.FUN.RC2                                                 !IDC
2616: 22ab: 
2617: 22ab: RETURN
2618: 22bb: 
2619: 22bb: \***********************************************************************
2620: 22bb: \*
2621: 22bb: \* CREATE.XRESTORE.LOG : This Sub-routine creates the XRESTORE log.
2622: 22bb: \*
2623: 22bb: \***********************************************************************
2624: 22bb: CREATE.XRESTORE.LOG:
2625: 22cb: 
2626: 22cb:     CREATE XRE.LOG.FILENAME$ AS XRE.LOG.SESS.NUM%
2627: 22f2:     XRE.LOG.OPEN = TRUE                                                 !MJK
2628: 2308: 
2629: 2308: XRE.LOG.CREATE.ERROR:                                                   !MJK
2630: 2318: 
2631: 2318:     !---------------------------------------------!
2632: 2318:     ! CLOSE session and deallocate the number as  !
2633: 2318:     ! file write will be done by C File functions !
2634: 2318:     !---------------------------------------------!
2635: 2318:     IF XRE.LOG.OPEN THEN BEGIN
2636: 232a:         XRE.LOG.OPEN = FALSE                                            !JDC
2637: 2340:         CLOSE  XRE.LOG.SESS.NUM%
2638: 2354:         CALL SESS.NUM.UTILITY ("C",XRE.LOG.SESS.NUM%,XRE.NULL$)         !MJK
2639: 237a:     ENDIF
2640: 2382: 
2641: 2382:     XRE.FILE.RC% = FUNC.OPEN.SEQUENTIAL.FILE( XRE.LOG.FILENAME$ )       !NJK
2642: 23ac:     ! if return is not a failure                                        !JDC
2643: 23ac:     IF XRE.FILE.RC% > XRE.ZERO% THEN BEGIN
2644: 23ca:         XRE.LOG.OPEN = TRUE
2645: 23e0:     ENDIF
2646: 23e8: 
2647: 23e8:     STATUS.MSG$ = STATUS.TEXT.MSG$(12)                                  !JDC
2648: 2412:     GOSUB LOG.STATUS.MSG
2649: 2424: 
2650: 2424: RETURN
2651: 2434: 
2652: 2434: \***********************************************************************
2653: 2434: \*
2654: 2434: \* CHECK.XBACKUP.RUN : This Sub-routine stops the program if the        !MJK
2655: 2434: \*                     XBACKUP program is running
2656: 2434: \*
2657: 2434: \***********************************************************************
2658: 2434: CHECK.XBACKUP.RUN:
2659: 2444: 
2660: 2444:     CREATE XBACK.PIPE.NAME$ AS XBACK.PIPE.SESS.NUM% BUFFSIZE XRE.ZERO%
2661: 2472:     XBACK.OPEN = TRUE                                                   !MJK
2662: 2488: 
2663: 2488: XBACK.PIPE.CREATE.ERROR:                                                !MJK
2664: 2498: 
2665: 2498:     ! Closing the session only if the pipe creation is successful
2666: 2498:     IF XBACK.OPEN THEN BEGIN                                            !MJK
2667: 24aa:         CLOSE XBACK.PIPE.SESS.NUM%
2668: 24be:         XBACK.OPEN = FALSE                                              !JDC
2669: 24d4:         CALL SESS.NUM.UTILITY ("C",XBACK.PIPE.SESS.NUM%,XRE.NULL$)      !MJK
2670: 24fa:     ENDIF
2671: 2502: 
2672: 2502: RETURN
2673: 2512: 
2674: 2512: \***********************************************************************
2675: 2512: \*
2676: 2512: \* CREATE.RUN.PIPE: This Sub-routine creates pipe for current module
2677: 2512: \*                  to avoid any duplicate run.
2678: 2512: \*
2679: 2512: \***********************************************************************
2680: 2512: CREATE.RUN.PIPE:
2681: 2522: 
2682: 2522:     CREATE XRE.PIPE.NAME$ AS XRE.PIPE.SESS.NUM% BUFFSIZE XRE.ZERO%
2683: 2550:     XRE.OPEN = TRUE                                                     !MJK
2684: 2566: 
2685: 2566: XRE.PIPE.CREATE.ERROR:                                                  !MJK
2686: 2576: 
2687: 2576: RETURN
2688: 2586: 
2689: 2586: \***********************************************************************
2690: 2586: \*
2691: 2586: \* CONTROLLER.CONFIG.CHECK: This Sub-routine uses ADXSERVE function
2692: 2586: \*                          and check whether the controller is
2693: 2586: \*                          Master and File server.If not, program
2694: 2586: \*                          should end, logging an appropriate error.
2695: 2586: \*
2696: 2586: \***********************************************************************
2697: 2586: CONTROLLER.CONFIG.CHECK:
2698: 2596: 
2699: 2596:     STATUS.MSG$ = STATUS.TEXT.MSG$(13)                                  !JDC
2700: 25c0:     GOSUB LOG.STATUS.MSG
2701: 25d2: 
2702: 25d2:     ! Using Function 4 to get the Controller details
2703: 25d2:     ADX.FUNCTION% = 4              ! Adxserve function 4
2704: 25e2:     ADXSERVE.RC%  = 1              ! Initiate with non zero value
2705: 25f9: 
2706: 25f9:     CALL ADXSERVE (ADXSERVE.RC%,ADX.FUNCTION%,XRE.ZERO%,ADX.PARM.2$)
2707: 2641: 
2708: 2641:     IF ADXSERVE.RC% <> XRE.ZERO% THEN BEGIN    ! If return code non zero
2709: 266d:         STATUS.MSG$ = STATUS.TEXT.MSG$(13)                              !JDC
2710: 2697:         ERROR.MSG$  = STATUS.MSG$
2711: 26b5:         GOSUB LOG.STATUS.MSG
2712: 26c7:         ERROR.EXIST = TRUE
2713: 26dd:     ENDIF
2714: 26e5: 
2715: 26e5:     CNTLR.CONFIG% = VAL(MID$(ADX.PARM.2$, 25, 2)) ! Controller config
2716: 2712:     CNTLR.ID$     = MID$(ADX.PARM.2$, 14, 2)      ! Master Controller ID
2717: 2739: 
2718: 2739:     !-------------------------------------------!
2719: 2739:     ! If controller is not a Master/File server !
2720: 2739:     ! OR not in SUPPS mode                      !
2721: 2739:     !-------------------------------------------!
2722: 2739: 
2723: 2739:     ! Set the flag if controller is in SUPPS mode
2724: 2739:     IF CNTLR.ID$ = "CC" THEN BEGIN
2725: 2757:         SUPPS.ON = TRUE
2726: 276d:     ENDIF
2727: 2775: 
2728: 2775:     IF NOT (CNTLR.CONFIG% = MASTER.AND.FILE.SERVER% OR                 \
2729: 27bb:             CNTLR.ID$     = "CC" ) THEN BEGIN
2730: 27bb:         STATUS.MSG$ = STATUS.TEXT.MSG$(15) + "to run this program"      !JDC
2731: 27ec:         ERROR.MSG$  = STATUS.MSG$
2732: 280a:         GOSUB LOG.STATUS.MSG
2733: 281c:         ERROR.EXIST = TRUE
2734: 2832:     ENDIF
2735: 283a: 
2736: 283a: RETURN
2737: 284a: 
2738: 284a: \***********************************************************************!KDC
2739: 284a: \*                                                                      !IDC
2740: 284a: \*    GET.SLEEPER.CONFIGURATION:This Sub-routine looks through the      !IDC
2741: 284a: \*                              Sleeper control file in order to see    !IDC
2742: 284a: \*                              what the current setting for the Full   !IDC
2743: 284a: \*                              backup is. It then assumes all are      !IDC
2744: 284a: \*                              Incremental based upon this day         !IDC
2745: 284a: \*                                                                      !IDC
2746: 284a: \***********************************************************************!IDC
2747: 284a: GET.SLEEPER.CONFIGURATION:                                              !IDC
2748: 2852: 
2749: 2852:     SLEEPER.DAY% = 0                                                    !JDC
2750: 2862: 
2751: 2862:     IF SUPPS.ON THEN BEGIN                                              !JDC
2752: 2877: 
2753: 2877:         DIR.FILE.RC% = \                                                !NJK
2754: 28a1:                 FUNC.OPEN.SEQUENTIAL.FILE(SUPPS.SLEEPER.FILE.NAME$)     !NJK
2755: 28a1: 
2756: 28a1:         ! If file open unsuccessful                                     !JDC
2757: 28a1:         IF DIR.FILE.RC% <= XRE.ZERO% THEN BEGIN                         !JDC
2758: 28bf:             SLPCF.OPEN  = FALSE                                         !MJK
2759: 28d5:             STATUS.MSG$ = STATUS.TEXT.MSG$(22)                          !JDC
2760: 28ff:             GOSUB LOG.STATUS.MSG                                        !JDC
2761: 2913:         ENDIF ELSE BEGIN                                                !JDC
2762: 291b:             SLPCF.OPEN  = TRUE                                          !MJK
2763: 2931:         ENDIF
2764: 2939: 
2765: 2939:         SLEEPER.RECORD$ = "X"                                           !JDC
2766: 2950:         ! Read the file till EOF/read error                             !JDC
2767: 2950:         WHILE LEN(SLEEPER.RECORD$) <> XRE.ZERO%                         !JDC
2768: 295a:             SLEEPER.RECORD$ = FUNC.READ.SEQUENTIAL.FILE( DIR.FILE.RC% ) !NJK
2769: 297d:             IF LEN(SLEEPER.RECORD$) <> XRE.ZERO% THEN BEGIN             !JDC
2770: 29a2:                 GOSUB GET.SUPPS.SLEEPER.INFO                            !JDC
2771: 29b4:             ENDIF                                                       !JDC
2772: 29bc:         WEND                                                            !JDC
2773: 29e4: 
2774: 29e4:         ! Closing File                                                  !JDC
2775: 29e4:         IF SLPCF.OPEN THEN BEGIN                                        !JDC
2776: 29f6:             CALL FUNC.CLOSE.FILE( DIR.FILE.RC% )                        !NJK
2777: 2a1f:             SLPCF.OPEN = FALSE                                          !JDC
2778: 2a35:         ENDIF                                                           !JDC
2779: 2a40: 
2780: 2a40:     ENDIF ELSE BEGIN                                                    !JDC
2781: 2a48: 
2782: 2a48:         !***************************************************************!JDC
2783: 2a48:         ! first find the full backup day configured in sleeper          !JDC
2784: 2a48:         !***************************************************************!JDC
2785: 2a48:         IF END #SLPCF.SESS.NUM% THEN SLPCF.NOT.FOUND
2786: 2a64: 
2787: 2a64:         OPEN NORMAL.SLEEPER.FILE.NAME$ DIRECT RECL SLPCF.RECL% \        !JDC
2788: 2a91:              AS SLPCF.SESS.NUM% NOWRITE NODEL
2789: 2a91: 
2790: 2a91:         SLPCF.OPEN             = TRUE
2791: 2aa7:         SLPCF.REC.NO%          = 0
2792: 2abe:         FULL.BACKUP.NOT.FOUND% = 0
2793: 2ace: 
2794: 2ace:         WHILE FULL.BACKUP.NOT.FOUND% = 0
2795: 2ad9:             SLPCF.REC.NO% = SLPCF.REC.NO% + 1
2796: 2af2:             IF READ.SLPCF = 0 THEN BEGIN
2797: 2b07:                 IF SLPCF.APP.NAME$ = "ADX_UPGM:XBACKUP.286" THEN BEGIN
2798: 2b28:                     IF SLPCF.PARM$ = PARM.FULL$ THEN BEGIN
2799: 2b4d:                         FULL.BACKUP.NOT.FOUND% = 1          !found
2800: 2b5d:                         !extract single day for full build
2801: 2b5d:                         SLEEPER.DAY% = VAL(SLPCF.DAY.NUM$)
2802: 2b7e:                         STATUS.MSG$  = STATUS.TEXT.MSG$(16) + \         !MJK
2803: 2bb6:                                        SLPCF.DAY.NUM$                   !MJK
2804: 2bb6:                     ENDIF
2805: 2bbe:                 ENDIF
2806: 2bc6:             ENDIF
2807: 2bce:         WEND
2808: 2be3: 
2809: 2be3: SLPCF.NOT.FOUND:                                                        !JDC
2810: 2bf3:         IF SLPCF.OPEN THEN BEGIN                                        !IDC
2811: 2c05:             CLOSE SLPCF.SESS.NUM%                                       !IDC
2812: 2c19:             SLPCF.OPEN = FALSE                                          !JDC
2813: 2c2f:             CALL SESS.NUM.UTILITY ("C",SLPCF.SESS.NUM%,XRE.NULL$)       !MJK
2814: 2c57:         ENDIF ELSE BEGIN
2815: 2c5f:             STATUS.MSG$ = STATUS.TEXT.ERROR$(22)                        !JDC
2816: 2c89:             GOSUB LOG.STATUS.MSG                                        !JDC
2817: 2c9b:         ENDIF                                                           !IDC
2818: 2ca3: 
2819: 2ca3:     ENDIF                                                               !JDC
2820: 2cab: 
2821: 2cab:     ! needed so end if not found                                        !JDC
2822: 2cab:     IF SLEEPER.DAY% = 0 THEN BEGIN                                      !JDC
2823: 2cbd:         STATUS.MSG$ = STATUS.TEXT.MSG$(17)                              !JDC
2824: 2ce7:         GOSUB LOG.STATUS.MSG                                            !JDC
2825: 2cf9:         GOSUB STOP.PROGRAM                                              !JDC
2826: 2d0d:     ENDIF ELSE BEGIN                                                    !JDC
2827: 2d15:         GOSUB LOG.STATUS.MSG                                            !JDC
2828: 2d27:     ENDIF                                                               !JDC
2829: 2d2f: 
2830: 2d2f:     !*******************************************************************!IDC
2831: 2d2f:     !then set the data we will build from - note that the array elements!IDC
2832: 2d2f:     !must match the sleeper settings (ie 1=Sunday) to work correctly    !IDC
2833: 2d2f:     !*******************************************************************!IDC
2834: 2d2f:     DIM CONSTANT.DAY$(7)                                                !IDC
2835: 2d5e:     CONSTANT.DAY$(1) = CONSTANT.SUNDAY.SHORT$                           !IDC
2836: 2d88:     CONSTANT.DAY$(2) = CONSTANT.MONDAY.SHORT$                           !IDC
2837: 2db2:     CONSTANT.DAY$(3) = CONSTANT.TUESDAY.SHORT$                          !IDC
2838: 2ddc:     CONSTANT.DAY$(4) = CONSTANT.WEDNESDAY.SHORT$                        !IDC
2839: 2e06:     CONSTANT.DAY$(5) = CONSTANT.THURSDAY.SHORT$                         !IDC
2840: 2e30:     CONSTANT.DAY$(6) = CONSTANT.FRIDAY.SHORT$                           !IDC
2841: 2e5a:     CONSTANT.DAY$(7) = CONSTANT.SATURDAY.SHORT$                         !IDC
2842: 2e84: 
2843: 2e84:     !*******************************************************************!IDC
2844: 2e84:     !and now the same for the longer names we display so all match, so  !IDC
2845: 2e84:     !we make them all the same length for our matching process later    !IDC
2846: 2e84:     !*******************************************************************!IDC
2847: 2e84:     DIM CONSTANT.LONG.DAY$(7)
2848: 2eb3:     CONSTANT.LONG.DAY$(1) = LEFT$(CONSTANT.SUNDAY.LONG$              + \!MJK
2849: 2f23:                             STRING$(CONSTANT.LONGEST.DAY%, XRE.SPACE$) \!MJK
2850: 2f23:                             , CONSTANT.LONGEST.DAY%)
2851: 2f23: 
2852: 2f23:     CONSTANT.LONG.DAY$(2) = LEFT$(CONSTANT.MONDAY.LONG$              + \!MJK
2853: 2f93:                             STRING$(CONSTANT.LONGEST.DAY%, XRE.SPACE$) \!MJK
2854: 2f93:                             , CONSTANT.LONGEST.DAY%)
2855: 2f93: 
2856: 2f93:     CONSTANT.LONG.DAY$(3) = LEFT$(CONSTANT.TUESDAY.LONG$             + \!MJK
2857: 3003:                             STRING$(CONSTANT.LONGEST.DAY%, XRE.SPACE$) \!MJK
2858: 3003:                             , CONSTANT.LONGEST.DAY%)
2859: 3003: 
2860: 3003:     CONSTANT.LONG.DAY$(4) = LEFT$(CONSTANT.WEDNESDAY.LONG$           + \!MJK
2861: 3073:                             STRING$(CONSTANT.LONGEST.DAY%, XRE.SPACE$) \!MJK
2862: 3073:                             , CONSTANT.LONGEST.DAY%)
2863: 3073: 
2864: 3073:     CONSTANT.LONG.DAY$(5) = LEFT$(CONSTANT.THURSDAY.LONG$            + \!MJK
2865: 30e3:                             STRING$(CONSTANT.LONGEST.DAY%, XRE.SPACE$) \!MJK
2866: 30e3:                             , CONSTANT.LONGEST.DAY%)
2867: 30e3: 
2868: 30e3:     CONSTANT.LONG.DAY$(6) = LEFT$(CONSTANT.FRIDAY.LONG$              + \!MJK
2869: 3153:                             STRING$(CONSTANT.LONGEST.DAY%, XRE.SPACE$) \!MJK
2870: 3153:                             , CONSTANT.LONGEST.DAY%)
2871: 3153: 
2872: 3153:     CONSTANT.LONG.DAY$(7) = LEFT$(CONSTANT.SATURDAY.LONG$            + \!MJK
2873: 31c3:                             STRING$(CONSTANT.LONGEST.DAY%, XRE.SPACE$) \!MJK
2874: 31c3:                             , CONSTANT.LONGEST.DAY%)
2875: 31c3: 
2876: 31c3:     !*******************************************************************!IDC
2877: 31c3:     !Build up the string with all the days, starting with the full      !IDC
2878: 31c3:     !backup day so it can be matched to any time to find the Full and   !IDC
2879: 31c3:     !Incremental days adding the : prevents mismatching characters that !IDC
2880: 31c3:     !might overlap on the short day name. for example if Sunday is the  !IDC
2881: 31c3:     !full configured day the string would be;                           !IDC
2882: 31c3:     !  ":SUN:MON:TUE:WED:THU:FRI:SAT"                                   !IDC
2883: 31c3:     !and the longer names would be;                                     !IDC
2884: 31c3:     !  "Monday   Tuesday  WednesdayThursday Friday   Saturday Sunday   "!IDC
2885: 31c3:     !*******************************************************************!IDC
2886: 31c3:     BACKUP.DAYS$      = CONSTANT.DAY$(SLEEPER.DAY%)                     !IDC
2887: 31f4:     BACKUP.LONG.DAYS$ = CONSTANT.LONG.DAY$(SLEEPER.DAY%)                !IDC
2888: 3225:                                                                         !IDC
2889: 3225:     FOR DAY.SINCE.FULL% = 2 TO 7                                        !IDC
2890: 3238:                                                                         !IDC
2891: 3238:         IF SLEEPER.DAY% = 7 THEN BEGIN              !if Saturday        !IDC
2892: 324a:             SLEEPER.DAY% = 1                        !set to Sunday      !IDC
2893: 325c:         ENDIF ELSE BEGIN                                                !IDC
2894: 3264:             SLEEPER.DAY% = SLEEPER.DAY% + 1         !next day           !IDC
2895: 3273:         ENDIF                                                           !IDC
2896: 327b:                                                                         !IDC
2897: 327b:         BACKUP.DAYS$      = BACKUP.DAYS$ + CONSTANT.COLON$ + \          !IDC
2898: 32c5:                             CONSTANT.DAY$(SLEEPER.DAY%)                 !IDC
2899: 32c5:                                                                         !IDC
2900: 32c5:         BACKUP.LONG.DAYS$ = BACKUP.LONG.DAYS$ + \                       !IDC
2901: 3304:                             CONSTANT.LONG.DAY$(SLEEPER.DAY%)            !IDC
2902: 3304:     NEXT DAY.SINCE.FULL%                                                !IDC
2903: 3329:                                                                         !IDC
2904: 3329:     DIM CONSTANT.DAY$(0)                                                !IDC
2905: 3358:     DIM CONSTANT.LONG.DAY$(0)                                           !IDC
2906: 3387:                                                                         !IDC
2907: 3387: RETURN                                                                  !IDC
2908: 3397: 
2909: 3397: \***********************************************************************!JDC
2910: 3397: \*                                                                      !JDC
2911: 3397: \* GET.SUPPS.SLEEPER.INFO : This Sub-routine extracts the record from   !JDC
2912: 3397: \*                          the sleeper file in supps mode so must use  !JDC
2913: 3397: \*                          the whole record and extract each element   !JDC
2914: 3397: \*                          looking for the Full run setting            !JDC
2915: 3397: \*                                                                      !JDC
2916: 3397: \***********************************************************************!JDC
2917: 3397: GET.SUPPS.SLEEPER.INFO:                                                 !JDC
2918: 33a7: 
2919: 33a7:     IF LEFT$(SLEEPER.RECORD$, 20) = "ADX_UPGM:XBACKUP.286" THEN BEGIN   !MJK
2920: 33df:         ! Checking whether the 1st letter of the filler                 !JDC
2921: 33df:         ! variable is numeric                                           !JDC
2922: 33df:         IF MATCH("#",MID$(SLEEPER.RECORD$, 69, 1) ,1) <> 0 THEN BEGIN   !JDC
2923: 341c:             SLPCF.PARM.LEN% = VAL(MID$(SLEEPER.RECORD$, 69, 1))         !JDC
2924: 3449:             ! If SLPCF Filler parameter length is greater than zero     !JDC
2925: 3449:             IF SLPCF.PARM.LEN% > 0 THEN BEGIN                           !JDC
2926: 345e:                 ! Storing the SLPCF Filler parameter                    !JDC
2927: 345e:                 SLPCF.PARM$ = MID$(SLEEPER.RECORD$, 70, SLPCF.PARM.LEN%)!MJK
2928: 348c:                 IF SLPCF.PARM$ = PARM.FULL$ THEN BEGIN                  !JDC
2929: 34b4:                     !extract single day for full build                  !JDC
2930: 34b4:                     SLPCF.DAY.NUM$ = MID$(SLEEPER.RECORD$, 23, 6)       !JDC
2931: 34db:                     SLEEPER.DAY%   = VAL(SLPCF.DAY.NUM$)                !MJK
2932: 34fc: 
2933: 34fc:                     STATUS.MSG$ = STATUS.TEXT.MSG$(16) + SLPCF.DAY.NUM$ !JDC
2934: 3534: 
2935: 3534:                     SLEEPER.RECORD$ = ""          !found                !JDC
2936: 354b:                 ENDIF                                                   !JDC
2937: 3553:             ENDIF                                                       !JDC
2938: 355b:         ENDIF                                                           !JDC
2939: 3563:     ENDIF                                                               !JDC
2940: 356b:                                                                         !JDC
2941: 356b: RETURN                                                                  !JDC
2942: 357b: 
2943: 357b: \***********************************************************************
2944: 357b: \*
2945: 357b: \* DRIVE.FAT32.CHECK : This Sub-routine checks the format of C and D
2946: 357b: \*                     drive to make sure it is in FAT32 format.
2947: 357b: \*
2948: 357b: \***********************************************************************
2949: 357b: DRIVE.FAT32.CHECK:
2950: 358b: 
2951: 358b:     STATUS.MSG$ = STATUS.TEXT.MSG$(18)                                  !JDC
2952: 35b5:     GOSUB LOG.STATUS.MSG
2953: 35c7: 
2954: 35c7:     ! Storing the random DIR output and check C32 text in 2nd line
2955: 35c7:     CALL OSSHELL("DIR C:/DRIVE.CHK > " + DIR.OUT$ )                     !MJK
2956: 35f1: 
2957: 35f1:     DIR.FILE.RC% = FUNC.OPEN.SEQUENTIAL.FILE( DIR.OUT$ )                !NJK
2958: 361b: 
2959: 361b:     IF DIR.FILE.RC% > XRE.ZERO% THEN BEGIN
2960: 3639:         DIR.OPEN   = TRUE
2961: 364f:         !ignore return check for EOF or read error as will error in     !FDC
2962: 364f:         !FAT32 check and fail correctly                                 !FDC
2963: 364f:         DIR.VALUE$ = FUNC.READ.SEQUENTIAL.FILE( DIR.FILE.RC% )          !NJK
2964: 3672:         DIR.VALUE$ = FUNC.READ.SEQUENTIAL.FILE( DIR.FILE.RC% )          !NJK
2965: 3697:     ENDIF ELSE BEGIN
2966: 369f:         DIR.OPEN    = FALSE                                             !MJK
2967: 36b5:         STATUS.MSG$ = STATUS.TEXT.ERROR$(2)                             !JDC
2968: 36df:         GOSUB LOG.STATUS.MSG                                            !IDC
2969: 36f1:     ENDIF
2970: 36f9: 
2971: 36f9:     ! C drive FAT32 check
2972: 36f9:     IF RIGHT$(DIR.VALUE$,3) <> "C32" THEN BEGIN
2973: 372c:         ERROR.EXIST = TRUE
2974: 3742:         STATUS.MSG$ = STATUS.TEXT.MSG$(19)                              !JDC
2975: 376c:         ERROR.MSG$  = STATUS.MSG$
2976: 378a:         GOSUB LOG.STATUS.MSG
2977: 379c:     ENDIF
2978: 37a4: 
2979: 37a4:     ! Closing File
2980: 37a4:     IF DIR.OPEN THEN BEGIN
2981: 37b6:         CALL FUNC.CLOSE.FILE( DIR.FILE.RC% )                            !NJK
2982: 37df:         DIR.OPEN = FALSE
2983: 37f5:     ENDIF
2984: 37fd: 
2985: 37fd:     ! Storing the random DIR output and the check D32 text in 2nd line
2986: 37fd:     CALL OSSHELL("DIR D:/DRIVE.CHK > " + DIR.OUT$ )                     !MJK
2987: 3827: 
2988: 3827:     DIR.FILE.RC% = FUNC.OPEN.SEQUENTIAL.FILE( DIR.OUT$ )                !NJK
2989: 3851: 
2990: 3851:     IF DIR.FILE.RC% > XRE.ZERO% THEN BEGIN
2991: 386f:         DIR.OPEN   = TRUE
2992: 3885:         !ignore return check for EOF or read error as will error in     !FDC
2993: 3885:         !FAT32 check and fail correctly                                 !FDC
2994: 3885:         DIR.VALUE$ = FUNC.READ.SEQUENTIAL.FILE( DIR.FILE.RC% )          !NJK
2995: 38a8:         DIR.VALUE$ = FUNC.READ.SEQUENTIAL.FILE( DIR.FILE.RC% )          !NJK
2996: 38cd:     ENDIF ELSE BEGIN
2997: 38d5:         DIR.OPEN    = FALSE                                             !MJK
2998: 38eb:         STATUS.MSG$ = STATUS.TEXT.ERROR$(2)                             !JDC
2999: 3915:         GOSUB LOG.STATUS.MSG
3000: 3927:     ENDIF
3001: 392f: 
3002: 392f:     ! D drive FAT32 check
3003: 392f:     IF RIGHT$(DIR.VALUE$,3) <> "D32" THEN BEGIN
3004: 3962:         ERROR.EXIST = TRUE
3005: 3978:         STATUS.MSG$ = STATUS.TEXT.MSG$(20)                              !MJK
3006: 39a2:         ERROR.MSG$  = STATUS.MSG$
3007: 39c0:         GOSUB LOG.STATUS.MSG
3008: 39d2:     ENDIF
3009: 39da: 
3010: 39da:     ! Closing File
3011: 39da:     IF DIR.OPEN THEN BEGIN
3012: 39ec:         CALL FUNC.CLOSE.FILE( DIR.FILE.RC% )                            !NJK
3013: 3a15:         DIR.OPEN = FALSE
3014: 3a2b:     ENDIF
3015: 3a33: 
3016: 3a33: RETURN
3017: 3a43: 
3018: 3a43: \***********************************************************************
3019: 3a43: \*
3020: 3a43: \* INITIATE.DISP.MNGR : This Sub-routine initiates the display manager.
3021: 3a43: \*
3022: 3a43: \***********************************************************************
3023: 3a43: INITIATE.DISP.MNGR:
3024: 3a53: 
3025: 3a53:     STATUS.MSG$ = STATUS.TEXT.MSG$(21)                                  !JDC
3026: 3a7d:     GOSUB LOG.STATUS.MSG
3027: 3a8f: 
3028: 3a8f:     CALL DM.INIT                      ! Display Manager Initialisation
3029: 3a9c: 
3030: 3a9c: RETURN
3031: 3aac: 
3032: 3aac:                 !   INITIALISATION SPECIFIC ROUTINES ENDS   !
3033: 3aac:                 !...........................................!
3034: 3aac: 
3035: 3aac: \**********************************************************************\
3036: 3aac: \**********************************************************************\
3037: 3aac: \*                                                                    *\
3038: 3aac: \*                 MAIN.PROCESSING SPECIFIC ROUTINES                  *\
3039: 3aac: \*                                                                    *\
3040: 3aac: \**********************************************************************\
3041: 3aac: \**********************************************************************\
3042: 3aac: 
3043: 3aac: \***********************************************************************
3044: 3aac: \*
3045: 3aac: \* PROCESS.BKPSCRPT: This Subroutine process the BKPSCRPT file and store
3046: 3aac: \*                   all the BACKUP and EXCLUDE details in an array.
3047: 3aac: \*
3048: 3aac: \***********************************************************************
3049: 3aac: PROCESS.BKPSCRPT:
3050: 3abc: 
3051: 3abc:     STATUS.MSG$ = STATUS.TEXT.MSG$(22)                                  !JDC
3052: 3ae6:     GOSUB LOG.STATUS.MSG
3053: 3af8: 
3054: 3af8:     BKPSCRPT.FILE.NAME$ = "D:/ADX_UDT1/BKPSCRPT.TXT"    ! Backup script
3055: 3b0f: 
3056: 3b0f:     IF NOT FUNC.FILE.EXISTS(BKPSCRPT.FILE.NAME$) THEN BEGIN             !MJK
3057: 3b2d:         BKPSCRPT.FILE.NAME$ = "C:/ADX_UDT1/BKPSCRPT.TXT"                !MJK
3058: 3b44:     ENDIF                                                               !MJK
3059: 3b4c: 
3060: 3b4c:     DIR.FILE.RC% = FUNC.OPEN.SEQUENTIAL.FILE(BKPSCRPT.FILE.NAME$)       !NJK
3061: 3b76: 
3062: 3b76:     ! If the open successful, set the VALUE.EXISTS equals TRUE
3063: 3b76:     IF DIR.FILE.RC% > XRE.ZERO% THEN BEGIN
3064: 3b94:         DIR.OPEN     = TRUE
3065: 3baa:         VALUE.EXISTS = TRUE
3066: 3bc2:     ENDIF ELSE BEGIN
3067: 3bca:         VALUE.EXISTS = FALSE
3068: 3be0:         DIR.OPEN     = FALSE                                            !CJK
3069: 3bf6:         STATUS.MSG$  = "Error in opening BKPSCRPT file"
3070: 3c0d:         GOSUB LOG.STATUS.MSG
3071: 3c1f:     ENDIF
3072: 3c27: 
3073: 3c27:     BKPSCRPT.INDEX% = XRE.ZERO%
3074: 3c3e: 
3075: 3c3e:     !-----------------------------------------------------------------!
3076: 3c3e:     ! Extracting EXCLUDE and BACKUP and performing respective process !
3077: 3c3e:     !-----------------------------------------------------------------!
3078: 3c3e:     WHILE VALUE.EXISTS
3079: 3c49: 
3080: 3c49:         DIR.VALUE$ = FUNC.READ.SEQUENTIAL.FILE( DIR.FILE.RC% )          !NJK
3081: 3c6c: 
3082: 3c6c:         COMMA.POSITION% = MATCH(COMMA.VALUE$,DIR.VALUE$,1)
3083: 3c98: 
3084: 3c98:         ! If comma found
3085: 3c98:         IF COMMA.POSITION% <> XRE.ZERO% THEN BEGIN
3086: 3cb4: 
3087: 3cb4:             ! Extracting Backup script command
3088: 3cb4:             BKPSCRPT.COMMAND$ = LEFT$(DIR.VALUE$,(COMMA.POSITION% - 1)) !CJK
3089: 3ce2:             CALL TRIM(BKPSCRPT.COMMAND$)
3090: 3cf8: 
3091: 3cf8:             ! Remaining Backup script value
3092: 3cf8:             DIR.VALUE$ = MID$(DIR.VALUE$,(COMMA.POSITION% + 1),        \!CJK
3093: 3d36:                               LEN(DIR.VALUE$))
3094: 3d36:             !-----------------------!
3095: 3d36:             ! If command is Backup  !
3096: 3d36:             !-----------------------!
3097: 3d36:             IF BKPSCRPT.COMMAND$ = "BACKUP" THEN BEGIN
3098: 3d57: 
3099: 3d57:                 BKPSCRPT.INDEX% = BKPSCRPT.INDEX% + 1
3100: 3d66: 
3101: 3d66:                 IF BKPSCRPT.INDEX% > ARRAY.LIMIT% THEN BEGIN            !MJK
3102: 3d7e:                     STATUS.MSG$ = STATUS.TEXT.MSG$(23)                  !JDC
3103: 3da8:                     GOSUB PROGRAM.EXIT
3104: 3dba:                 ENDIF
3105: 3dc2: 
3106: 3dc2:                 !------------------------------------------!
3107: 3dc2:                 ! Extracting Backup script directory value !
3108: 3dc2:                 !------------------------------------------!
3109: 3dc2: 
3110: 3dc2:                 ! Comma position
3111: 3dc2:                 COMMA.POSITION%      = MATCH(COMMA.VALUE$,DIR.VALUE$,1) !CJK
3112: 3dee:                 ! Backup directory
3113: 3dee:                 BKPSCRPT.DIRECTORY$  = LEFT$(DIR.VALUE$,               \
3114: 3e1c:                                              (COMMA.POSITION% - 1))
3115: 3e1c: 
3116: 3e1c:                 CALL TRIM(BKPSCRPT.DIRECTORY$)
3117: 3e32: 
3118: 3e32:                 BKPSCRPT.DIRECTORIES$(BKPSCRPT.INDEX%) =               \
3119: 3e61:                                                 BKPSCRPT.DIRECTORY$
3120: 3e61: 
3121: 3e61:                 ! Remaining Backup script value
3122: 3e61:                 DIR.VALUE$ = MID$(DIR.VALUE$,(COMMA.POSITION% + 1),    \!CJK
3123: 3e9f:                                   LEN(DIR.VALUE$))
3124: 3e9f: 
3125: 3e9f:                 !-------------------------------------------------!
3126: 3e9f:                 ! Extracting Backup script output directory value !
3127: 3e9f:                 !-------------------------------------------------!
3128: 3e9f: 
3129: 3e9f:                 ! Comma position
3130: 3e9f:                 COMMA.POSITION% = MATCH(COMMA.VALUE$,DIR.VALUE$,1)      !CJK
3131: 3ecb: 
3132: 3ecb:                 ! Output directory
3133: 3ecb:                 BKPSCRPT.OUT.FILE.NAME$ = LEFT$(DIR.VALUE$,            \!CJK
3134: 3ef9:                                                (COMMA.POSITION% - 1))
3135: 3ef9:                 CALL TRIM(BKPSCRPT.OUT.FILE.NAME$)
3136: 3f0f: 
3137: 3f0f:                 PRIMARY.ARCHIVED.NAMES$(BKPSCRPT.INDEX%) =             \
3138: 3f3e:                                             BKPSCRPT.OUT.FILE.NAME$
3139: 3f3e: 
3140: 3f3e:                 ! Remaining Backup script value
3141: 3f3e:                 DIR.VALUE$ = MID$(DIR.VALUE$,(COMMA.POSITION% + 1),    \!CJK
3142: 3f7c:                                   LEN(DIR.VALUE$))
3143: 3f7c: 
3144: 3f7c:                 BKPSCRPT.OUT.FILE.NAME$ = DIR.VALUE$
3145: 3f9a:                 CALL TRIM(BKPSCRPT.OUT.FILE.NAME$)
3146: 3fb0: 
3147: 3fb0:                 SECONDARY.ARCHVD.NAMES$(BKPSCRPT.INDEX%) =             \
3148: 3fdf:                                             BKPSCRPT.OUT.FILE.NAME$
3149: 3fdf: 
3150: 3fdf:             ENDIF
3151: 3fe7:         ENDIF
3152: 3fef: 
3153: 3fef:         ! If the read reaches EOF
3154: 3fef:         IF LEN(DIR.VALUE$) = XRE.ZERO% THEN BEGIN
3155: 4014:             VALUE.EXISTS = FALSE
3156: 402a:         ENDIF
3157: 4032:     WEND
3158: 4047: 
3159: 4047:     ! Closing File
3160: 4047:     IF DIR.OPEN THEN BEGIN
3161: 4059:         CALL FUNC.CLOSE.FILE( DIR.FILE.RC% )                            !NJK
3162: 4082:         DIR.OPEN = FALSE
3163: 4098:     ENDIF
3164: 40a0: 
3165: 40a0: RETURN
3166: 40b0: 
3167: 40b0: \***********************************************************************
3168: 40b0: \*
3169: 40b0: \* SCREEN.NAVIGATION: This Subroutine navigates the screen based on
3170: 40b0: \*                    the user input.
3171: 40b0: \*
3172: 40b0: \***********************************************************************
3173: 40b0: SCREEN.NAVIGATION:
3174: 40c0: 
3175: 40c0:     ! Based on screen selection, display and process the screen
3176: 40c0:     WHILE SCREEN% <> XRE.ZERO%
3177: 40cb:         IF SCREEN% = DISPLAY.MAIN.SCR% THEN BEGIN                       !CJK
3178: 40e3: 
3179: 40e3:             ! Display Main Menu
3180: 40e3:             GOSUB DISPLAY.MAIN.SCREEN
3181: 40f5: 
3182: 40f5:             ! Process Main Menu
3183: 40f5:             GOSUB PROCESS.MAIN.SCREEN
3184: 410a: 
3185: 410a:         ENDIF ELSE BEGIN
3186: 4112:             IF SCREEN% = DRIVE.DISK.SELECT.SCR% THEN BEGIN              !MJK
3187: 412a: 
3188: 412a:                 ! Display and process Drive selection screen
3189: 412a:                 GOSUB DISPLAY.PROCESS.DRIVES                            !MJK
3190: 413c: 
3191: 413c:                 ! Display and process Drive restore screen
3192: 413c:                 GOSUB PROCESS.DRIVE.DAY.SCREEN                          !MJK
3193: 4151: 
3194: 4151:             ENDIF ELSE BEGIN
3195: 4159:                 IF SCREEN% = RESTORE.A.DIRECTORY.SCR% THEN BEGIN        !CJK
3196: 4171: 
3197: 4171:                     ! Display directory screen                          !MJK
3198: 4171:                     GOSUB DISPLAY.DIRECT.SCREEN
3199: 4183: 
3200: 4183:                     ! Process Directory screen
3201: 4183:                     GOSUB PROCESS.DIRECT.SCREEN                         !MJK
3202: 4197: 
3203: 4197:                 ENDIF ELSE BEGIN
3204: 419f: 
3205: 419f:                     ! Display file screen
3206: 419f:                     CALL DM.SHOW.SCREEN (7, XRE.NULL$, 6, 6)
3207: 41c0: 
3208: 41c0:                     ! Process file screen
3209: 41c0:                     GOSUB PROCESS.FILE.SCREEN
3210: 41d2: 
3211: 41d2:                 ENDIF
3212: 41da:             ENDIF
3213: 41e2:         ENDIF
3214: 41ea:     WEND
3215: 4205: 
3216: 4205:     !-------------------------------------------------!
3217: 4205:     ! If screen mode, chain back the program to PSB50 !
3218: 4205:     ! else clears the screen and stop the program     !
3219: 4205:     !-------------------------------------------------!
3220: 4205:     IF SCREEN% = XRE.ZERO% THEN BEGIN                                   !CJK
3221: 421d:         GOSUB CHAIN.TO.CALLER
3222: 422f:     ENDIF
3223: 4237: 
3224: 4237: RETURN
3225: 4247: 
3226: 4247: \***********************************************************************
3227: 4247: \*
3228: 4247: \* DISPLAY.MAIN.SCREEN: This Subroutine displays the Main screen
3229: 4247: \*                      for XRESTORE.
3230: 4247: \*
3231: 4247: \***********************************************************************
3232: 4247: DISPLAY.MAIN.SCREEN:
3233: 4257: 
3234: 4257:     ! selection Input is stored in FSEL$
3235: 4257:     !----------------------------------------
3236: 4257:     FSEL$ = ""
3237: 426e: 
3238: 426e:     CALL DM.SHOW.SCREEN (1, XRE.NULL$, 1, 1)
3239: 428f: 
3240: 428f:     ! Initialising the output fields in the screen
3241: 428f:     ! before processing the screen
3242: 428f:     !--------------------------------------------
3243: 428f:     CALL DM.NAME (2, "FSEL$", FSEL$)
3244: 42ce: 
3245: 42ce:     ! Validation the Menu selection is between 1 and 3
3246: 42ce:     !-------------------------------------------------
3247: 42ce:     CALL DM.VALID ("FSEL$", "FSEL$ >= 1 AND FSEL$ <= 3")
3248: 42e6:     !B003 Invalid selection number
3249: 42e6:     CALL DM.MESSAGE ("FSEL$", "'Invalid selection number")
3250: 42fe: 
3251: 42fe: RETURN
3252: 430e: 
3253: 430e: \***********************************************************************
3254: 430e: \*
3255: 430e: \* PROCESS.MAIN.SCREEN: This Subroutine processes the Main screen
3256: 430e: \*                      for XRESTORE.
3257: 430e: \*
3258: 430e: \***********************************************************************
3259: 430e: PROCESS.MAIN.SCREEN:
3260: 431e: 
3261: 431e:     ! Processing Main Menu screen
3262: 431e:     !-------------------------------------
3263: 431e:     WHILE SCREEN% = DISPLAY.MAIN.SCR%                                   !CJK
3264: 4329: 
3265: 4329:         RET.KEY% = DM.PROCESS.SCREEN (2, 2, XRE.ZERO%)
3266: 434d: 
3267: 434d:         IF (RET.KEY% = ESC.KEY%) OR (RET.KEY% = F3.KEY%) THEN BEGIN     !CJK
3268: 4381: 
3269: 4381:             ! Program exit
3270: 4381:             SCREEN% = XRE.ZERO%
3271: 439a: 
3272: 439a:         ENDIF ELSE BEGIN
3273: 43a2: 
3274: 43a2:             ! If Enter key is pressed and no Error exist
3275: 43a2:             IF RET.KEY% = ENTER.KEY% AND NOT ERROR.EXIST THEN BEGIN
3276: 43ce: 
3277: 43ce:                 ! Storing the option in a variable
3278: 43ce:                 OPT.SEL% = VAL(FSEL$)
3279: 43ef: 
3280: 43ef:                 IF OPT.SEL% = 1 THEN BEGIN
3281: 4401: 
3282: 4401:                     !------------------------------------------!
3283: 4401:                     ! Before moving to Drive restore screen    !
3284: 4401:                     ! need to make sure that controller is in  !
3285: 4401:                     ! SUPPS mode                               !
3286: 4401:                     !------------------------------------------!
3287: 4401:                     IF NOT SUPPS.ON THEN BEGIN
3288: 4413:                         CALL DM.FOCUS("11", "'This functionality "  + \
3289: 443c:                                       "is only available under SUPPS")
3290: 443c:                     ENDIF ELSE BEGIN
3291: 4444:                     ! Drive restore screen
3292: 4444:                         SCREEN% = DRIVE.DISK.SELECT.SCR%                !MJK
3293: 445a:                     ENDIF
3294: 4464: 
3295: 4464:                 ENDIF ELSE IF OPT.SEL% = 2 THEN BEGIN
3296: 4476:                     ! Directory restore screen
3297: 4476:                     SCREEN% = RESTORE.A.DIRECTORY.SCR%                  !CJK
3298: 448e:                 ENDIF ELSE BEGIN
3299: 4496:                     ! File restore screen
3300: 4496:                     SCREEN% = RESTORE.A.FILE.SCR%                       !CJK
3301: 44ac:                 ENDIF
3302: 44b7:             ENDIF ELSE BEGIN                                            !NJK
3303: 44bf:                 IF ERROR.EXIST THEN BEGIN                               !NJK
3304: 44d1:                     CALL DM.FOCUS("101", "'" + ERROR.MSG$)
3305: 4501:                 ENDIF ELSE BEGIN
3306: 4509:                     ! B001 Invalid key pressed
3307: 4509:                     CALL DM.FOCUS ("1", STATUS.TEXT.ERROR$(20))         !IDC
3308: 4534:                 ENDIF
3309: 453c:             ENDIF                                                       !NJK
3310: 4544:         ENDIF
3311: 454c: 
3312: 454c:     WEND
3313: 4567: 
3314: 4567: RETURN
3315: 4577: 
3316: 4577: ! Sub-routine DISPLAY.PROCESS.DRIVES, CHECK.DRIVE.SELECTION has been    !MJK
3317: 4577: ! moved up with respect to the changes in the screen execution in CR5.  !MJK
3318: 4577: \***********************************************************************
3319: 4577: \*
3320: 4577: \* DISPLAY.PROCESS.DRIVES: This Subroutine display and processes
3321: 4577: \*                         the C and D drives.
3322: 4577: \*
3323: 4577: \***********************************************************************
3324: 4577: DISPLAY.PROCESS.DRIVES:
3325: 4587: 
3326: 4587:     CALL DM.SHOW.SCREEN (3, XRE.NULL$, 3, 3)
3327: 45a8: 
3328: 45a8:     ! Processing Drive display screen
3329: 45a8:     WHILE SCREEN% = DRIVE.DISK.SELECT.SCR%                              !MJK
3330: 45b3: 
3331: 45b3:         RET.KEY% = DM.PROCESS.SCREEN (3, 4, TRUE)
3332: 45d7: 
3333: 45d7:         IF (RET.KEY% = ESC.KEY%) OR (RET.KEY% = F3.KEY%) THEN BEGIN     !CJK
3334: 460b:             ! Return back to the Drive DAY screen
3335: 460b:             SCREEN%      = DISPLAY.MAIN.SCR%                            !MJK
3336: 4623: 
3337: 4623:         ENDIF ELSE BEGIN
3338: 462b:             IF RET.KEY% = ENTER.KEY% THEN BEGIN
3339: 4643: 
3340: 4643:                 ! Checks the Drive selection input
3341: 4643:                 GOSUB CHECK.DRIVE.SELECTION
3342: 4657: 
3343: 4657:             ENDIF ELSE BEGIN
3344: 465f:                 ! B001 Invalid key pressed
3345: 465f:                 CALL DM.FOCUS ("1", STATUS.TEXT.ERROR$(20))             !IDC
3346: 468a:             ENDIF
3347: 4692:         ENDIF
3348: 469a:     WEND
3349: 46b5: 
3350: 46b5: RETURN
3351: 46c5: 
3352: 46c5: \***********************************************************************
3353: 46c5: \*
3354: 46c5: \* CHECK.DRIVE.SELECTION: This Subroutine checks the input of Drive
3355: 46c5: \*                        Display screen
3356: 46c5: \*
3357: 46c5: \***********************************************************************
3358: 46c5: CHECK.DRIVE.SELECTION:
3359: 46d5: 
3360: 46d5:     ! Storing the C drive and D drive field
3361: 46d5:     CDRIVE$ = UCASE$(FIELD$(3))
3362: 4704:     DDRIVE$ = UCASE$(FIELD$(4))
3363: 4733: 
3364: 4733:     CALL TRIM(CDRIVE$)                                                  !MJK
3365: 4749:     CALL TRIM(DDRIVE$)                                                  !MJK
3366: 475f: 
3367: 475f:     ! If at least one of the value is X
3368: 475f:     IF (CDRIVE$ = "X" AND LEN(DDRIVE$) = XRE.ZERO%) OR \                !MJK
3369: 47ff:        (DDRIVE$ = "X" AND LEN(CDRIVE$) = XRE.ZERO%) THEN BEGIN          !MJK
3370: 47ff: 
3371: 47ff:         SCREEN% = DRIVE.DAY.SELECT.SCR%                                 !MJK
3372: 4818: 
3373: 4818:     ENDIF ELSE BEGIN                                                    !NJK
3374: 4820:         IF LEN(DDRIVE$) <> XRE.ZERO% OR \                               !NJK
3375: 4874:            LEN(CDRIVE$) <> XRE.ZERO% THEN BEGIN                         !MJK
3376: 4874:             FIELD$(1) = "'Value entered must be ""X"" OR ""x"". Only" + \MJK
3377: 48a0:                         " one drive is allowed"                         !MJK
3378: 48a0:         ENDIF ELSE BEGIN
3379: 48a8:             FIELD$(1) = SCREEN.TEXT.MSG$(21)                            !JDC
3380: 48de:         ENDIF
3381: 48e6:     ENDIF                                                               !NJK
3382: 48ee: 
3383: 48ee: RETURN
3384: 48fe: 
3385: 48fe: \***********************************************************************!MJK
3386: 48fe: \*                                                                      !MJK
3387: 48fe: \* PROCESS.DRIVE.DAY.SCREEN: This Subroutine process the drive restore  !MJK
3388: 48fe: \*                           screen for XRESTORE.                       !MJK
3389: 48fe: \*                                                                      !MJK
3390: 48fe: \***********************************************************************!MJK
3391: 48fe: PROCESS.DRIVE.DAY.SCREEN:                                               !MJK
3392: 490e:                                                                         !MJK
3393: 490e:     WHILE SCREEN% = DRIVE.DAY.SELECT.SCR%                               !MJK
3394: 4918:                                                                         !MJK
3395: 4918:         GOSUB DISPLAY.DRIVE.SCREEN                                      !MJK
3396: 492a:         GOSUB PROCESS.DRIVE.SCREEN                                      !MJK
3397: 493c:                                                                         !MJK
3398: 493c:     WEND                                                                !MJK
3399: 4954:                                                                         !MJK
3400: 4954: RETURN                                                                  !MJK
3401: 4964: 
3402: 4964: \***********************************************************************
3403: 4964: \*
3404: 4964: \* DISPLAY.DRIVE.SCREEN: This Subroutine displays the drive restore
3405: 4964: \*                       screen for XRESTORE.
3406: 4964: \*
3407: 4964: \***********************************************************************
3408: 4964: DISPLAY.DRIVE.SCREEN:
3409: 4974: 
3410: 4974:     ! Setting the Header and other variables used for screen display
3411: 4974:     SCR.HEADER$   = SCREEN.TEXT.MSG$(17)                                !MJK
3412: 499e:     OPT.SELECTED$ = SCREEN.TEXT.MSG$(2) + SCREEN.TEXT.MSG$(3)           !JDC
3413: 49e2: 
3414: 49e2:     OPT.HEADER$   = SCREEN.TEXT.MSG$(20)                                !JDC
3415: 4a0c: 
3416: 4a0c:     IF CDRIVE$ = "X" THEN BEGIN                                         !MJK
3417: 4a2a:         OPT.HEADER.1$ = "You have chosen to restore the C drive."       !MJK
3418: 4a43:     ENDIF ELSE BEGIN                                                    !MJK
3419: 4a4b:         OPT.HEADER.1$ = "You have chosen to restore the D drive."       !MJK
3420: 4a62:     ENDIF                                                               !MJK
3421: 4a6a: 
3422: 4a6a:     CALL DM.SHOW.SCREEN (2, SCR.HEADER$, 2, 2)
3423: 4a8b: 
3424: 4a8b:     ! Setting the XRE value which will be displayed in the Left corner
3425: 4a8b:     SCREEN.NUM$ = "03"
3426: 4aa2: 
3427: 4aa2:     ! Dimensioning array
3428: 4aa2:     DIM DAY.ARRAY$(ARRAY.LIMIT%)                                        !MJK
3429: 4ad6:     DIM BKP.AVAIL.ARRAY$(ARRAY.LIMIT%)                                  !MJK
3430: 4b0a: 
3431: 4b0a:     ! Setting the screen number
3432: 4b0a:     CALL DM.NAME (2, "SCREEN.NUM$", SCREEN.NUM$)
3433: 4b49: 
3434: 4b49:     ! Calling function to get the array of input values                 !IDC
3435: 4b49:     FUNCTION.ERROR.NOT.EXIST = 0                                        !IDC
3436: 4b59:     SECOND.FILE$ = XRE.NULL$                                            !MJK
3437: 4b77: 
3438: 4b77:     IF CDRIVE$ = "X" THEN BEGIN                                         !MJK
3439: 4b95:         FIRST.FILE$  = D.BKP.IMG$ + "BKPFAILC"                          !MJK
3440: 4bbc:     ENDIF ELSE BEGIN                                                    !MJK
3441: 4bc4:         FIRST.FILE$  = C.BKP.IMG$ + "BKPFAILD"                          !MJK
3442: 4be9:     ENDIF                                                               !MJK
3443: 4bf1: 
3444: 4bf1:     GOSUB GET.BKP.DETAILS                                               !IDC
3445: 4c03: 
3446: 4c03:     ! Initialising the output fields in the screen
3447: 4c03:     ! before processing the screen
3448: 4c03:     !--------------------------------------------
3449: 4c03:     CALL DM.NAME (48, "OPT.HEADER.1$", OPT.HEADER.1$)                   !MJK
3450: 4c42: 
3451: 4c42:     ! If backups are available
3452: 4c42:     IF VALUE.INDEX% <> XRE.ZERO% AND FUNCTION.ERROR.NOT.EXIST THEN BEGIN!EJK
3453: 4c6b: 
3454: 4c6b:         ! Initialising the output fields in the screen
3455: 4c6b:         ! before processing the screen
3456: 4c6b:         !--------------------------------------------
3457: 4c6b:         CALL DM.NAME (49, "OPT.HEADER$",   OPT.HEADER$)                 !MJK
3458: 4caa:         CALL DM.NAME (50, "OPT.SELECTED$", OPT.SELECTED$)
3459: 4ce9: 
3460: 4ce9:         ! Enabling the DAY and DD/MM string
3461: 4ce9:         CALL DM.VISIBLE ("75", STATUS.TEXT.MSG$(61))                    !IDC
3462: 4d14:         CALL DM.VISIBLE ("76", STATUS.TEXT.MSG$(61))                    !IDC
3463: 4d3f: 
3464: 4d3f:         ! Setting the first value of the fields before populating it
3465: 4d3f:         DAY.LOOP%   = DAY.INDEX%
3466: 4d56:         DD.MM.LOOP% = DD.MM.INDEX%
3467: 4d6d:         INPUT.LOOP% = INPUT.INDEX%
3468: 4d84: 
3469: 4d84:         ! Retrieving the values and storing in Field$
3470: 4d84:         FOR INDEX% = 1 TO VALUE.INDEX%
3471: 4d98: 
3472: 4d98:             ! DAY value and its visibility
3473: 4d98:             FIELD$(DAY.LOOP%) = DAY.ARRAY$(INDEX%)
3474: 4dd8:             CALL DM.VISIBLE (STR$(DAY.LOOP%), STATUS.TEXT.MSG$(61))     !IDC
3475: 4e1c: 
3476: 4e1c:             ! DD/MM value
3477: 4e1c:             FIELD$(DD.MM.LOOP%) = RIGHT$(BKP.AVAIL.ARRAY$(INDEX%),2) + \!GJK
3478: 4e9a:                                   "/"                                + \
3479: 4e9a:                                   LEFT$(BKP.AVAIL.ARRAY$(INDEX%),2)     !GJK
3480: 4e9a: 
3481: 4e9a:             ! Setting a space for input values
3482: 4e9a:             FIELD$(INPUT.LOOP%) = XRE.SPACE$
3483: 4ec9: 
3484: 4ec9:             ! Setting the visibility for DD/MM and input
3485: 4ec9:             CALL DM.VISIBLE (STR$(DD.MM.LOOP%), STATUS.TEXT.MSG$(61))   !IDC
3486: 4f0d:             CALL DM.VISIBLE (STR$(INPUT.LOOP%), STATUS.TEXT.MSG$(61))   !IDC
3487: 4f51: 
3488: 4f51:             ! Incrementing to move to the next field
3489: 4f51:             DAY.LOOP%   = DAY.LOOP%   + 1
3490: 4f60:             DD.MM.LOOP% = DD.MM.LOOP% + 1
3491: 4f6f:             INPUT.LOOP% = INPUT.LOOP% + 1
3492: 4f7e:         NEXT INDEX%
3493: 4fab: 
3494: 4fab:     ENDIF ELSE BEGIN                                                    !NJK
3495: 4fb3:         IF FUNCTION.ERROR.NOT.EXIST THEN BEGIN                          !NJK
3496: 4fc5:             FIELD$(1) = STATUS.TEXT.ERROR$(21)                          !IDC
3497: 4ffd:         ENDIF ELSE BEGIN                                                !EJK
3498: 5005:             FIELD$(1) = SCREEN.TEXT.MSG$(7) + SCREEN.TEXT.MSG$(8)       !MJK
3499: 5055:         ENDIF
3500: 505d:     ENDIF                                                               !NJK
3501: 5065: 
3502: 5065: RETURN
3503: 5075: 
3504: 5075: \***********************************************************************
3505: 5075: \*
3506: 5075: \* PROCESS.DRIVE.SCREEN: This Subroutine processes the Drive screen
3507: 5075: \*                       for XRESTORE.
3508: 5075: \*
3509: 5075: \***********************************************************************
3510: 5075: PROCESS.DRIVE.SCREEN:
3511: 5085: 
3512: 5085:     ! Processing Drive screen
3513: 5085:     !-------------------------------------
3514: 5085:     WHILE SCREEN% = DRIVE.DAY.SELECT.SCR% OR \                          !MJK
3515: 5090:           SCREEN% = DRIVE.PROCESS.SCR%                                  !MJK
3516: 5090: 
3517: 5090:         ! Drive restore day screen
3518: 5090:         IF SCREEN% = DRIVE.DAY.SELECT.SCR% THEN BEGIN                   !MJK
3519: 50ab: 
3520: 50ab:             ! If the screen is accessed using F3 or ESC
3521: 50ab:             IF PREVIOUS.KEY THEN BEGIN
3522: 50bd:                 GOSUB DISPLAY.DRIVE.SCREEN
3523: 50cf:                 PREVIOUS.KEY = FALSE
3524: 50e5:             ENDIF
3525: 50ed: 
3526: 50ed:             RET.KEY% = DM.PROCESS.SCREEN (2, 105, TRUE)
3527: 5111: 
3528: 5111:             IF (RET.KEY% = ESC.KEY%) OR (RET.KEY% = F3.KEY%) THEN BEGIN !CJK
3529: 5145: 
3530: 5145:                 ! Navigate to Drive disk selection screen
3531: 5145:                 SCREEN% = DRIVE.DISK.SELECT.SCR%                        !MJK
3532: 515e: 
3533: 515e:             ENDIF ELSE BEGIN                                            !MJK
3534: 5166:                 IF VALUE.INDEX% = XRE.ZERO% THEN BEGIN                  !MJK
3535: 517f:                     CALL DM.FOCUS ("1", STATUS.TEXT.ERROR$(21) + \      !IDC
3536: 51cf:                                    STATUS.TEXT.MSG$(58))                !IDC
3537: 51cf:                 ENDIF ELSE BEGIN
3538: 51d7:                     IF RET.KEY% = ENTER.KEY% THEN BEGIN
3539: 51ef: 
3540: 51ef:                         ! Check the entry in day selection screen
3541: 51ef:                         SCREEN.NUM% = DRIVE.PROCESS.SCR%                !MJK
3542: 5205:                         GOSUB CHECK.DAY.SELECTION                       !IDC
3543: 5217: 
3544: 5217:                         ! If any error in function, set same screen
3545: 5217:                         IF NOT FUNCTION.ERROR.NOT.EXIST THEN BEGIN      !EJK
3546: 5229:                             SCREEN% = DRIVE.DAY.SELECT.SCR%             !EJK
3547: 523f:                         ENDIF                                           !EJK
3548: 5249: 
3549: 5249:                     ENDIF ELSE BEGIN
3550: 5251:                         ! B001 Invalid key pressed
3551: 5251:                         CALL DM.FOCUS ("1", STATUS.TEXT.ERROR$(20))     !IDC
3552: 527c:                     ENDIF
3553: 5284:                 ENDIF                                                   !MJK
3554: 528c:             ENDIF
3555: 5296:         ENDIF ELSE IF SCREEN% = DRIVE.PROCESS.SCR% THEN BEGIN           !MJK
3556: 52ae:             ! Display and Process Drives                                !MJK
3557: 52ae:             GOSUB PROCESS.DRIVE.RESTORE                                 !MJK
3558: 52c0:         ENDIF
3559: 52c8: 
3560: 52c8:     WEND
3561: 52ff: 
3562: 52ff: RETURN
3563: 530f: 
3564: 530f: \***********************************************************************
3565: 530f: \*
3566: 530f: \* PROCESS.DRIVE.RESTORE: This Subroutine uses the values entered in
3567: 530f: \*                        previous pages and starts the restoration
3568: 530f: \*                        process for DRIVE(S).
3569: 530f: \*
3570: 530f: \***********************************************************************
3571: 530f: PROCESS.DRIVE.RESTORE:
3572: 531f: 
3573: 531f:     ! Changed the help screen to zero, as it is not needed
3574: 531f:     CALL DM.SHOW.SCREEN(4, XRE.NULL$, XRE.ZERO%, XRE.ZERO%)             !GJK
3575: 534e: 
3576: 534e:     BKP.INDEX%        = XRE.ZERO%
3577: 5364:     RESTORE.ERR.EXIST = FALSE
3578: 537a: 
3579: 537a:     STATUS.MSG$ = BKP.DATE.ARRAY$(SEL.INDEX%) + STATUS.TEXT.MSG$(24) + \!JDC
3580: 53da:                   STATUS.TEXT.MSG$(63)
3581: 53da:     GOSUB LOG.STATUS.MSG
3582: 53ec: 
3583: 53ec:     !----------------------------------------------------------!
3584: 53ec:     ! Setting the BKP.INDEX% and FULL.TO.MOVING.DATE$ based    !        !IDC
3585: 53ec:     ! on the selected DAY and depending on the SET values the  !
3586: 53ec:     ! restoration process will happen                          !
3587: 53ec:     !----------------------------------------------------------!
3588: 53ec: 
3589: 53ec:     GOSUB SET.BACKUP.INDEX                                              !IDC
3590: 53fe: 
3591: 53fe:     ! match for the day and set according to the Full backup day        !IDC
3592: 53fe:     BKP.INDEX% = LONG.DAY.INDEX%                                        !IDC
3593: 5414:     F02.DATE$  = BKP.DATE.ARRAY$(SEL.INDEX%)                            !IDC
3594: 5443:     FUN.RC2%   = XRE.ZERO%                                              !MJK
3595: 545a: 
3596: 545a:     IF BKP.INDEX% <> 0 THEN BEGIN                                       !IDC
3597: 546c:         FUN.RC2% = UPDATE.DATE( ((BKP.INDEX% - 1)* -1 ) )               !MJK
3598: 5497:     ENDIF                                                               !IDC
3599: 549f: 
3600: 549f:     ! Checking the Return code
3601: 549f:     GOSUB CHECK.UPDATE.DATE.RC                                          !IDC
3602: 54b1:     FULL.TO.MOVING.DATE$ = F02.DATE$                                    !IDC
3603: 54cf: 
3604: 54cf:     ! Storing the Full date                                             !JDC
3605: 54cf:     FULL.DATE$ = FULL.TO.MOVING.DATE$                                   !IDC
3606: 54ed: 
3607: 54ed:     ! If C drive is selected
3608: 54ed:     IF CDRIVE$ = "X" THEN BEGIN
3609: 550e: 
3610: 550e:         STATUS.MSG$ = STATUS.TEXT.MSG$(25)                              !JDC
3611: 5538:         GOSUB LOG.STATUS.MSG
3612: 554a: 
3613: 554a:         ! Setting the drive value as "C"
3614: 554a:         DRIVE$ = "C"
3615: 5561: 
3616: 5561:         ! Reading the BACKUP directories using index
3617: 5561:         FOR INDEX% = 1 TO BKPSCRPT.INDEX%
3618: 5575:             ! Checking the C directory alone
3619: 5575:             IF UCASE$(LEFT$(BKPSCRPT.DIRECTORIES$(INDEX%),1)) = DRIVE$ \
3620: 55d5:             THEN BEGIN
3621: 55d5:                 ! Setting the Dynamic directory value                   !GJK
3622: 55d5:                 IF POSF(5) = 5 THEN BEGIN                               !GJK
3623: 55eb:                     CALL PUTF(BKPSCRPT.DIRECTORIES$(INDEX%))            !GJK
3624: 5617:                 ENDIF                                                   !GJK
3625: 561f:                 ! Setting the file name based on selected drive
3626: 561f:                 BKPFAIL.PREFIX$    = D.BKP.IMG$ + "BKPFAILC."           !MJK
3627: 5644:                 BKPLIST.CURR.FILE$ = BKPLIST.PREFIX.D.DRIVE$            !MJK
3628: 5662:                 ! Perform the C drive backup process
3629: 5662:                 GOSUB PERFORM.BACKUP.DRIVE
3630: 5674:             ENDIF
3631: 567c:         NEXT INDEX%
3632: 56a6: 
3633: 56a6:         CALL DM.STATUS (STATUS.TEXT.MSG$(59))                           !IDC
3634: 56cd:         !-------------------------------------!
3635: 56cd:         ! Check the BKPLIST file to make sure !
3636: 56cd:         ! relevant files alone present        !
3637: 56cd:         !-------------------------------------!
3638: 56cd:         GOSUB PROCESS.BKPLIST.FILE
3639: 56df:         ! Backing up configuration files. e.g. BKPLIST.MDD              !MJK
3640: 56df:         GOSUB BACKUP.CONFIG.FILES                                       !MJK
3641: 56f1: 
3642: 56f1:     ENDIF
3643: 56f9: 
3644: 56f9:     ! If D drive is selected
3645: 56f9:     IF DDRIVE$ = "X" THEN BEGIN
3646: 571a: 
3647: 571a:         STATUS.MSG$ = STATUS.TEXT.MSG$(26)                              !JDC
3648: 5744:         GOSUB LOG.STATUS.MSG
3649: 5756: 
3650: 5756:         ! Setting the drive value as "D"
3651: 5756:         DRIVE$ = "D"
3652: 576d: 
3653: 576d:         ! Reading the BACKUP directories using index
3654: 576d:         FOR INDEX% = 1 TO BKPSCRPT.INDEX%
3655: 5781:             ! Checking the D directory alone
3656: 5781:             IF UCASE$(LEFT$(BKPSCRPT.DIRECTORIES$(INDEX%),1)) = DRIVE$ \
3657: 57e1:             THEN BEGIN
3658: 57e1:                 ! Setting the Dynamic directory value                   !GJK
3659: 57e1:                 IF POSF(5) = 5 THEN BEGIN                               !GJK
3660: 57f7:                     CALL PUTF(BKPSCRPT.DIRECTORIES$(INDEX%))            !GJK
3661: 5823:                 ENDIF                                                   !GJK
3662: 582b:                 ! Setting the file name based on selected drive
3663: 582b:                 BKPFAIL.PREFIX$    = C.BKP.IMG$ + "BKPFAILD."           !MJK
3664: 5850:                 BKPLIST.CURR.FILE$ = BKPLIST.PREFIX.C.DRIVE$            !MJK
3665: 586e:                 ! Perform the D drive backup process
3666: 586e:                 GOSUB PERFORM.BACKUP.DRIVE
3667: 5880:             ENDIF
3668: 5888:         NEXT INDEX%
3669: 58b2: 
3670: 58b2:         CALL DM.STATUS (STATUS.TEXT.MSG$(59))                           !IDC
3671: 58d9:         !-------------------------------------!
3672: 58d9:         ! Check the BKPLIST file to make sure !
3673: 58d9:         ! relevant files alone present        !
3674: 58d9:         !-------------------------------------!
3675: 58d9:         GOSUB PROCESS.BKPLIST.FILE
3676: 58eb:         ! Backing up configuration files. e.g. BKPLIST.MDD              !MJK
3677: 58eb:         GOSUB BACKUP.CONFIG.FILES                                       !MJK
3678: 58fd: 
3679: 58fd:     ENDIF
3680: 5905: 
3681: 5905:     ! Set the visibility OFF for unrelated fields
3682: 5905:     CALL DM.VISIBLE ("3", STATUS.TEXT.MSG$(60))                         !IDC
3683: 5930:     CALL DM.VISIBLE ("5", STATUS.TEXT.MSG$(60))                         !IDC
3684: 595b:     CALL DM.VISIBLE ("6", STATUS.TEXT.MSG$(60))                         !IDC
3685: 5986:     CALL DM.VISIBLE ("7", STATUS.TEXT.MSG$(60))                         !IDC
3686: 59b1: 
3687: 59b1:     FIELD$(3) = XRE.SPACE$
3688: 59db:     FIELD$(5) = XRE.SPACE$
3689: 5a05:     FIELD$(6) = XRE.SPACE$
3690: 5a2f:     FIELD$(7) = XRE.SPACE$
3691: 5a59: 
3692: 5a59:     ! Depending on the drive selection, the field value gets displayed
3693: 5a59:     IF CDRIVE$ = "X" AND DDRIVE$ <> "X" THEN BEGIN
3694: 5aab:         FIELD$(4) = STATUS.TEXT.MSG$(62) + SCREEN.TEXT.MSG$(24)         !MJK
3695: 5afe:     ENDIF ELSE BEGIN                                                    !NJK
3696: 5b06:         IF DDRIVE$ = "X" AND CDRIVE$ <> "X" THEN BEGIN                  !NJK
3697: 5b58:             FIELD$(4) = STATUS.TEXT.MSG$(62) + SCREEN.TEXT.MSG$(23)     !MJK
3698: 5baa:         ENDIF ELSE BEGIN
3699: 5bb2:             FIELD$(4) = STATUS.TEXT.MSG$(62) + SCREEN.TEXT.MSG$(25)     !MJK
3700: 5c02:         ENDIF
3701: 5c0a:     ENDIF                                                               !NJK
3702: 5c12: 
3703: 5c12:     GOSUB COPY.OS.BLANK.FILES                                           !JDC
3704: 5c24: 
3705: 5c24:     ! If any error occurs in extraction process
3706: 5c24:     IF RESTORE.ERR.EXIST THEN BEGIN
3707: 5c36: 
3708: 5c36:         CALL DM.STATUS (SCREEN.TEXT.MSG$(26))                           !JDC
3709: 5c5d:         STATUS.MSG$ = STATUS.TEXT.MSG$(5)                               !JDC
3710: 5c87:         GOSUB LOG.STATUS.MSG
3711: 5c9b: 
3712: 5c9b:     ENDIF ELSE BEGIN
3713: 5ca3:     ! If no errors found
3714: 5ca3: 
3715: 5ca3:         CALL DM.STATUS ("'Restore completed successfully")
3716: 5cb7:         STATUS.MSG$ = "Restore completed successfully"
3717: 5cce:         GOSUB LOG.STATUS.MSG
3718: 5ce0: 
3719: 5ce0:     ENDIF
3720: 5ce8: 
3721: 5ce8:     WHILE SCREEN% = DRIVE.PROCESS.SCR%                                  !CJK
3722: 5cf3:         RET.KEY% = DM.PROCESS.SCREEN (3, 7, FALSE)
3723: 5d17: 
3724: 5d17:         IF RET.KEY% = ESC.KEY% THEN BEGIN                               !MJK
3725: 5d2f:             ! Set the Drive screen
3726: 5d2f:             SCREEN%      = DRIVE.DAY.SELECT.SCR%                        !MJK
3727: 5d45:             PREVIOUS.KEY = TRUE
3728: 5d5d: 
3729: 5d5d:         ENDIF ELSE BEGIN
3730: 5d65: 
3731: 5d65:             CALL DM.FOCUS ("1", SCREEN.TEXT.MSG$(13) + \                !JDC
3732: 5db2:                                 SCREEN.TEXT.MSG$(29))                   !MJK
3733: 5db2:         ENDIF
3734: 5dba: 
3735: 5dba:     WEND
3736: 5dd5: 
3737: 5dd5: RETURN
3738: 5de5: 
3739: 5de5: ! duplicated subroutine
3740: 5de5: %INCLUDE XREST00E.J86                                                   !NJK
3741: 5de5: \************************************************************************
3742: 5de5: \***                                                                    *
3743: 5de5: \***           %INCLUDE FOR REPEATED SUBROUTINES IN XRESTORE            *
3744: 5de5: \***                                                                    *
3745: 5de5: \***                    REFERENCE: XREST00E.J86                         *
3746: 5de5: \***                                                                    *
3747: 5de5: \***                                                                    *
3748: 5de5: \*** Version A              Dave Constable                   05/06/2014 *
3749: 5de5: \*** FOD260 - Enhanced Backup and Recovery                              *
3750: 5de5: \***                                                                    *
3751: 5de5: \*** Version B              Dave Constable                   25/06/2014 *
3752: 5de5: \*** FOD260 - Enhanced Backup and Recovery                              *
3753: 5de5: \*** QC775 - Incorrect file extension check changed                     *
3754: 5de5: \*** QC750 - Added OS file copy that used to be in CRESTORE batch       *
3755: 5de5: \*** Code review changes; alignment of file open status                 *
3756: 5de5: \***                                                                    *
3757: 5de5: \*** Version C                 Jaya Kumar Inbaraj            23/08/2014 *
3758: 5de5: \*** FOD260 - Enhanced Backup and Recovery                              *
3759: 5de5: \*** CR5 changes to perform the drive restore if a drive is empty.      *
3760: 5de5: \*** Also commented out few redundant labels and worked on Internal     *
3761: 5de5: \*** and APPS management review comments.                               *
3762: 5de5: \***                                                                    *
3763: 5de5: \*** Version D                 Jaya Kumar Inbaraj            04/09/2014 *
3764: 5de5: \*** FOD260 - Enhanced Backup and Recovery                              *
3765: 5de5: \*** Worked on APPS management review comments.                         *
3766: 5de5: \***                                                                    *
3767: 5de5: \************************************************************************
3768: 5de5: 
3769: 5de5: \************************************************************************
3770: 5de5: \*
3771: 5de5: \* SET.BACKUP.INDEX: Setting the BKP.INDEX% and FULL.TO.MOVING.DATE$
3772: 5de5: \*                   based on the selected DAY and depending on the SET
3773: 5de5: \*                   values the restoration process will happen
3774: 5de5: \*
3775: 5de5: \************************************************************************
3776: 5de5: SET.BACKUP.INDEX:
3777: 5df5: 
3778: 5df5:     ! Match for the long day name and set using the offset              !CJK
3779: 5df5:     LONG.DAY.INDEX% = MATCH( LEFT$(DAY.ARRAY$(SEL.INDEX%)        + \    !CJK
3780: 5e86:                       STRING$(CONSTANT.LONGEST.DAY%, XRE.SPACE$),  \    !CJK
3781: 5e86:                       CONSTANT.LONGEST.DAY%), BACKUP.LONG.DAYS$,1)      !CJK
3782: 5e86:     ! Use the offset to calculate the index                             !CJK
3783: 5e86:     LONG.DAY.INDEX% = ((LONG.DAY.INDEX%-1) / CONSTANT.LONGEST.DAY%) + 1
3784: 5eb3: 
3785: 5eb3: RETURN
3786: 5ec3: 
3787: 5ec3: \***********************************************************************
3788: 5ec3: \*
3789: 5ec3: \* GET.BKP.DETAILS: This function receives the Primary and secondary
3790: 5ec3: \*                  backup file (without extension) as an input. Then
3791: 5ec3: \*                  it checks the availability of archived files based
3792: 5ec3: \*                  on number of BKP.DAYS and store it in arrays for
3793: 5ec3: \*                  Screen to display.
3794: 5ec3: \*
3795: 5ec3: \***********************************************************************
3796: 5ec3: GET.BKP.DETAILS:
3797: 5ed3: 
3798: 5ed3:     FUNCTION.ERROR.NOT.EXIST = TRUE
3799: 5ee9: 
3800: 5ee9:     BEGIN.POSITION% = 4        ! To Ignore the Drive being checked      !CJK
3801: 5efa:     SLASH.POSITION% = XRE.ZERO%                                         !CJK
3802: 5f11:     VALUE.EXISTS    = TRUE                                              !CJK
3803: 5f27: 
3804: 5f27:     DIM BKP.FILE.MDD.ARRAY$(ARRAY.LIMIT%)                               !CJK
3805: 5f5b:     DIM BKP.DATE.ARRAY$(ARRAY.LIMIT%)                                   !CJK
3806: 5f8f: 
3807: 5f8f:     ! Extracting the archive file name
3808: 5f8f:     WHILE VALUE.EXISTS
3809: 5f9a:         SLASH.POSITION% = MATCH("\\", FIRST.FILE$, BEGIN.POSITION%)
3810: 5fc4: 
3811: 5fc4:         IF SLASH.POSITION% > XRE.ZERO% THEN BEGIN
3812: 5fdd:             ! Move to next position to search next field
3813: 5fdd:             BEGIN.POSITION% = SLASH.POSITION% + 1
3814: 5ff6:         ENDIF ELSE BEGIN
3815: 5ffe:             FILENAME$ = MID$(FIRST.FILE$,BEGIN.POSITION%, \
3816: 6042:                             (LEN(FIRST.FILE$) - BEGIN.POSITION% + 1))
3817: 6042:             VALUE.EXISTS = FALSE
3818: 6058:         ENDIF
3819: 6060:     WEND
3820: 6075: 
3821: 6075:     ! Getting all the archive files from Primary backup location
3822: 6075:     CALL OSSHELL("DIR " + FIRST.FILE$ + ".* > " + DIR.OUT$ + " >>* " + \
3823: 60bd:                  DIR.OUT$ )
3824: 60bd: 
3825: 60bd:     CALL OSSHELL("DIR " + SECOND.FILE$ + ".* >> " + DIR.OUT$     + \
3826: 6105:                  " >>* " + DIR.OUT$ )
3827: 6105: 
3828: 6105:     DIR.FILE.RC% = FUNC.OPEN.SEQUENTIAL.FILE( DIR.OUT$ )                !DJK
3829: 612f: 
3830: 612f:     ! If file open unsuccessful
3831: 612f:     IF DIR.FILE.RC% <= XRE.ZERO% THEN BEGIN
3832: 614d:         STATUS.MSG$ = "Error in opening DIR output file"
3833: 6164:         GOSUB LOG.STATUS.MSG
3834: 6176:         DIR.OPEN                 = FALSE
3835: 618c:         FUNCTION.ERROR.NOT.EXIST = FALSE
3836: 61a4: !        RETURN                                                         !DJK
3837: 61a4:     ENDIF ELSE BEGIN
3838: 61ac:         DIR.OPEN = TRUE
3839: 61c2:     ENDIF
3840: 61ca: 
3841: 61ca:     FOR F.RECORD.COUNT% = 1 TO 4
3842: 61dc:         ! Ignoring the first 4 lines
3843: 61dc:         DIR.VALUE$ = FUNC.READ.SEQUENTIAL.FILE( DIR.FILE.RC% )          !DJK
3844: 61ff:     NEXT F.RECORD.COUNT%
3845: 6221: 
3846: 6221:     BKP.INDEX% = XRE.ZERO%
3847: 6237: 
3848: 6237:     WHILE LEN(DIR.VALUE$) <> XRE.ZERO%
3849: 6242:         DIR.VALUE$ = FUNC.READ.SEQUENTIAL.FILE( DIR.FILE.RC% )          !DJK
3850: 6265:         ! we treat an error here as end of file and drop out
3851: 6265:         !--------------------------------------------------------!
3852: 6265:         ! Checking the file name and also making sure that the   !      !BDC
3853: 6265:         ! extension is numeric value ending                      !      !BDC
3854: 6265:         !--------------------------------------------------------!      !BDC
3855: 6265:         IF LEFT$(DIR.VALUE$,LEN(FILENAME$)) = FILENAME$     AND     \   !CJK
3856: 6306:            MATCH("!",MID$(DIR.VALUE$,11,2) ,1) = XRE.ZERO% THEN BEGIN   !CJK
3857: 6306: 
3858: 6306:             DIR.VALUE$ = MID$(DIR.VALUE$,10,3)
3859: 632d: 
3860: 632d:             DUPLICATE.RECORD = FALSE                                    !CJK
3861: 6343: 
3862: 6343:             ! To make sure duplicate records are not added              !CJK
3863: 6343:             IF BKP.INDEX% > XRE.ZERO% THEN BEGIN                        !CJK
3864: 635e:                 FOR INDEX% = 1 TO BKP.INDEX%                            !CJK
3865: 6371:                     IF BKP.FILE.MDD.ARRAY$(INDEX%) = DIR.VALUE$ \       !CJK
3866: 63a7:                     THEN BEGIN                                          !CJK
3867: 63a7:                         DUPLICATE.RECORD = TRUE                         !CJK
3868: 63bd:                     ENDIF                                               !CJK
3869: 63c5:                 NEXT INDEX%                                             !CJK
3870: 63ed:             ENDIF                                                       !CJK
3871: 63f5: 
3872: 63f5:             ! Checking the BKP.INDEX% to avoid out of bound error
3873: 63f5:             IF BKP.INDEX% < ARRAY.LIMIT% THEN BEGIN                     !CJK
3874: 640e:                 IF NOT DUPLICATE.RECORD THEN BEGIN                      !CJK
3875: 6420:                     BKP.INDEX% = BKP.INDEX% + 1                         !CJK
3876: 642f:                     ! Storing the MDD value in an array
3877: 642f:                     BKP.FILE.MDD.ARRAY$(BKP.INDEX%) = DIR.VALUE$
3878: 6460:                 ENDIF                                                   !CJK
3879: 646b:             ENDIF ELSE BEGIN
3880: 6473:                 STATUS.MSG$ = "'MDD array index error"
3881: 648a:                 GOSUB LOG.STATUS.MSG
3882: 649c:                 DIR.VALUE$               = XRE.NULL$                    !CJK
3883: 64ba:                 FUNCTION.ERROR.NOT.EXIST = FALSE
3884: 64d0:                 !-----------------------------------------------------! !CJK
3885: 64d0:                 ! As the array index overflow happened, further read  ! !CJK
3886: 64d0:                 ! is not required and hence setting the value to NULL ! !CJK
3887: 64d0:                 ! to exit the WHILE loop                              ! !CJK
3888: 64d0:                 !-----------------------------------------------------! !CJK
3889: 64d0:                 DIR.VALUE$ = XRE.NULL$                                  !CJK
3890: 64ee:             ENDIF
3891: 64f6:         ENDIF
3892: 64fe:     WEND
3893: 6526: 
3894: 6526:     ! Closing File
3895: 6526:     IF DIR.OPEN THEN BEGIN
3896: 6538:         CALL FUNC.CLOSE.FILE( DIR.FILE.RC% )                            !DJK
3897: 6561:         DIR.OPEN = FALSE
3898: 6577:     ENDIF
3899: 657f: 
3900: 657f:     VALUE.INDEX% = XRE.ZERO%
3901: 6596:     TODAY.DATE$  = DATE$
3902: 65ae: 
3903: 65ae:     !--------------------------------------------------------!
3904: 65ae:     ! As BKP.INDEX is used as an index parameter for all the !
3905: 65ae:     ! arrays in below FOR loop, checking the index to avoid  !
3906: 65ae:     ! out of bound error                                     !
3907: 65ae:     !--------------------------------------------------------!
3908: 65ae:     IF BKP.INDEX% > ARRAY.LIMIT% THEN BEGIN                             !CJK
3909: 65c7:         STATUS.MSG$ = "'BKP array index error"
3910: 65de:         GOSUB LOG.STATUS.MSG
3911: 65f0:         FUNCTION.ERROR.NOT.EXIST = FALSE
3912: 6606: !        RETURN                                                         !DJK
3913: 6606:         ! Setting zero as there is an array limit breach                !DJK
3914: 6606:         BKP.INDEX% = XRE.ZERO%                                          !DJK
3915: 661c:     ENDIF
3916: 6624: 
3917: 6624:     ! If Backup available
3918: 6624:     IF BKP.INDEX% <> XRE.ZERO% THEN BEGIN
3919: 663f:         ! Checking last 14 days
3920: 663f:         FOR LOOP% = 1 TO BKP.DAYS%
3921: 6653:             ! Storing MMDD in a variable
3922: 6653:             WORK.DATE.MMDD$ = RIGHT$(TODAY.DATE$,4)
3923: 6678:             ! Checking the available backup dates
3924: 6678:             FOR INDEX% = 1 TO BKP.INDEX%
3925: 668c: 
3926: 668c:                 ! Getting the Month and date in MDD format
3927: 668c:                 IF LEFT$(BKP.FILE.MDD.ARRAY$(INDEX%),1) = "C" THEN BEGIN!CJK
3928: 66d2:                     BKP.FILE.MMDD.ARRAY$(INDEX%) = "12"   + \           !CJK
3929: 6723:                         RIGHT$(BKP.FILE.MDD.ARRAY$(INDEX%),2)           !CJK
3930: 6723:                 ENDIF ELSE \
3931: 672b:                 IF LEFT$(BKP.FILE.MDD.ARRAY$(INDEX%),1) = "B" THEN BEGIN!CJK
3932: 6771:                     BKP.FILE.MMDD.ARRAY$(INDEX%) = "11"   + \           !CJK
3933: 67c2:                         RIGHT$(BKP.FILE.MDD.ARRAY$(INDEX%),2)           !CJK
3934: 67c2:                 ENDIF ELSE \
3935: 67ca:                 IF LEFT$(BKP.FILE.MDD.ARRAY$(INDEX%),1) = "A" THEN BEGIN!CJK
3936: 6810:                     BKP.FILE.MMDD.ARRAY$(INDEX%) = "10"   + \           !CJK
3937: 6860:                         RIGHT$(BKP.FILE.MDD.ARRAY$(INDEX%),2)           !CJK
3938: 6860:                 ENDIF ELSE BEGIN
3939: 6868:                     BKP.FILE.MMDD.ARRAY$(INDEX%) = "0"    + \           !CJK
3940: 68af:                         BKP.FILE.MDD.ARRAY$(INDEX%)                     !CJK
3941: 68af:                 ENDIF
3942: 68b7: 
3943: 68b7:                 ! If the Work date is available, store it in array
3944: 68b7:                 IF BKP.FILE.MMDD.ARRAY$(INDEX%) = WORK.DATE.MMDD$ \
3945: 68f0:                 THEN BEGIN
3946: 68f0: 
3947: 68f0:                     VALUE.INDEX% = VALUE.INDEX% + 1
3948: 68ff: 
3949: 68ff:                     ! Checking the VALUE.INDEX% to avoid out of bound
3950: 68ff:                     IF VALUE.INDEX% < ARRAY.LIMIT% THEN BEGIN           !CJK
3951: 691a: 
3952: 691a:                         ! Storing the date and MMDD
3953: 691a:                         BKP.DATE.ARRAY$(VALUE.INDEX%)  = TODAY.DATE$
3954: 6949:                         BKP.AVAIL.ARRAY$(VALUE.INDEX%) = WORK.DATE.MMDD$
3955: 6978: 
3956: 6978:                         FUN.RC2% = PSDATE(TODAY.DATE$)
3957: 699a: 
3958: 699a:                         ! Checking the return value
3959: 699a:                         IF FUN.RC2% <> XRE.ZERO% THEN BEGIN
3960: 69b3:                             STATUS.MSG$ = "PSDATE function error"
3961: 69ca:                             GOSUB LOG.STATUS.MSG
3962: 69dc:                             DAY.ARRAY$(VALUE.INDEX%) = "Date error"
3963: 6a04:                             FUNCTION.ERROR.NOT.EXIST = FALSE
3964: 6a1d:                         ENDIF ELSE BEGIN
3965: 6a25:                             ! Storing the DAY value
3966: 6a25:                             IF F13.DAY$ = "SUN" THEN BEGIN
3967: 6a43:                                 DAY.ARRAY$(VALUE.INDEX%) = "Sunday"
3968: 6a6e:                             ENDIF ELSE IF F13.DAY$ = "MON" THEN BEGIN
3969: 6a8c:                                 DAY.ARRAY$(VALUE.INDEX%) = "Monday"
3970: 6ab7:                             ENDIF ELSE IF F13.DAY$ = "TUE" THEN BEGIN
3971: 6ad5:                                 DAY.ARRAY$(VALUE.INDEX%) = "Tuesday"
3972: 6b00:                             ENDIF ELSE IF F13.DAY$ = "WED" THEN BEGIN
3973: 6b1e:                                 DAY.ARRAY$(VALUE.INDEX%) = "Wednesday"
3974: 6b49:                             ENDIF ELSE IF F13.DAY$ = "THU" THEN BEGIN
3975: 6b67:                                 DAY.ARRAY$(VALUE.INDEX%) = "Thursday"
3976: 6b92:                             ENDIF ELSE IF F13.DAY$ = "FRI" THEN BEGIN
3977: 6bb0:                                 DAY.ARRAY$(VALUE.INDEX%) = "Friday"
3978: 6bda:                             ENDIF ELSE IF F13.DAY$ = "SAT" THEN BEGIN
3979: 6bf8:                                 DAY.ARRAY$(VALUE.INDEX%) = "Saturday"
3980: 6c20:                             ENDIF
3981: 6c28:                         ENDIF
3982: 6c33: 
3983: 6c33:                     ENDIF ELSE BEGIN
3984: 6c3b:                         STATUS.MSG$  = "'MDD array index error"
3985: 6c52:                         GOSUB LOG.STATUS.MSG
3986: 6c64:                         FUNCTION.ERROR.NOT.EXIST = FALSE
3987: 6c7a: !                        RETURN                                         !DJK
3988: 6c7a:                         LOOP%  = BKP.DAYS%  + 10   ! force to exit      !CJK
3989: 6c93:                         INDEX% = BKP.INDEX% + 10   ! force to exit      !CJK
3990: 6cac:                     ENDIF
3991: 6cb4:                 ENDIF
3992: 6cbc:             NEXT INDEX%
3993: 6ce7: 
3994: 6ce7:             IF INDEX% < (BKP.INDEX% + 10) THEN BEGIN                    !CJK
3995: 6d02:                 F02.DATE$ = TODAY.DATE$
3996: 6d20:                 FUN.RC2%  = UPDATE.DATE( -1 )           ! Reduce one day!CJK
3997: 6d3f: 
3998: 6d3f:                 GOSUB CHECK.UPDATE.DATE.RC
3999: 6d51: 
4000: 6d51:                 TODAY.DATE$ = F02.DATE$
4001: 6d6f:             ENDIF
4002: 6d77: 
4003: 6d77:         NEXT LOOP%
4004: 6da1:     ENDIF
4005: 6da9: 
4006: 6da9: RETURN
4007: 6db9: 
4008: 6db9: \***********************************************************************
4009: 6db9: \*
4010: 6db9: \* EXTRACT.BKPLIST.FIELDS:  This function receives the line value of
4011: 6db9: \*                          BKPLIST, process it and return the
4012: 6db9: \*                          individual BKPLIST field values for use.
4013: 6db9: \*
4014: 6db9: \***********************************************************************
4015: 6db9: EXTRACT.BKPLIST.FIELDS:
4016: 6dc9: 
4017: 6dc9:     FUNCTION.ERROR.NOT.EXIST = TRUE
4018: 6ddf: 
4019: 6ddf:     BKPLIST.VALUE$ = BKPLIST.DIR.VALUE$
4020: 6dfd: 
4021: 6dfd:     DIM BKPLIST.FIELD$(0)         ! Clear the array memory allocation
4022: 6e2c:     DIM BKPLIST.FIELD$(15)        ! To store BKPLIST values
4023: 6e5b: 
4024: 6e5b:     BEGIN.POS%    = 1           ! Begin search position                 !CJK
4025: 6e6c:     INDEX%        = XRE.ZERO%   ! Index for Field Array                 !CJK
4026: 6e83:     VALUE.PRESENT = TRUE        ! While Boolean                         !CJK
4027: 6e99: 
4028: 6e99:     !----------------------------------------------------------!
4029: 6e99:     ! Extracting all the variables using comma separator value !
4030: 6e99:     !----------------------------------------------------------!
4031: 6e99:     WHILE VALUE.PRESENT
4032: 6ea4:         ! Get index of next field delimiter
4033: 6ea4:         MATCH.POS% = MATCH(COMMA.VALUE$,BKPLIST.VALUE$,BEGIN.POS%)
4034: 6ed5: 
4035: 6ed5:         INDEX%     = INDEX% + 1     ! Incrementing the index            !CJK
4036: 6ee4: 
4037: 6ee4:         ! Checking the INDEX% to avoid out of bound error
4038: 6ee4:         IF VALUE.INDEX% > ARRAY.LIMIT% THEN BEGIN                       !CJK
4039: 6efc:             STATUS.MSG$ = "'MDD array index error"
4040: 6f13:             GOSUB LOG.STATUS.MSG
4041: 6f25:             FUNCTION.ERROR.NOT.EXIST = FALSE
4042: 6f3b:             !-----------------------------------------------------!     !CJK
4043: 6f3b:             ! As the array index overflow happened, further check !     !CJK
4044: 6f3b:             ! is not required and hence setting the value to      !     !CJK
4045: 6f3b:             ! FALSE to exit the WHILE loop                        !     !CJK
4046: 6f3b:             !-----------------------------------------------------!     !CJK
4047: 6f3b:             VALUE.PRESENT = FALSE                                       !CJK
4048: 6f51:         ENDIF
4049: 6f59: 
4050: 6f59:         ! If we found a field delimiter
4051: 6f59:         IF MATCH.POS% > XRE.ZERO% THEN BEGIN
4052: 6f72:             ! Get contents of field
4053: 6f72:             BKPLIST.FIELD$(INDEX%) = MID$(BKPLIST.VALUE$, BEGIN.POS%, \
4054: 6fbc:                                      (MATCH.POS% - BEGIN.POS%)  )
4055: 6fbc:             ! Move next start position past field delimiter
4056: 6fbc:             BEGIN.POS% = MATCH.POS% + 1
4057: 6fd5:         ENDIF ELSE BEGIN
4058: 6fdd:             ! Else we're at the last field
4059: 6fdd:             VALUE.PRESENT = FALSE
4060: 6ff3:         ENDIF
4061: 6ffb:     WEND
4062: 7010: 
4063: 7010:     ! Storing the values
4064: 7010:     BKPLI.FILENAME$                 = BKPLIST.FIELD$(1)
4065: 703a:     BKPLI.FULL.EXIST$               = BKPLIST.FIELD$(2)
4066: 7064:     BKPLI.FULL.FILE.CHNG$           = BKPLIST.FIELD$(3)
4067: 708e:     BKPLI.INCREMENTAL.EXIST$(1)     = BKPLIST.FIELD$(4)
4068: 70c4:     BKPLI.INCREMENTAL.FILE.CHNG$(1) = BKPLIST.FIELD$(5)
4069: 70fa:     BKPLI.INCREMENTAL.EXIST$(2)     = BKPLIST.FIELD$(6)
4070: 7130:     BKPLI.INCREMENTAL.FILE.CHNG$(2) = BKPLIST.FIELD$(7)
4071: 7166:     BKPLI.INCREMENTAL.EXIST$(3)     = BKPLIST.FIELD$(8)
4072: 719c:     BKPLI.INCREMENTAL.FILE.CHNG$(3) = BKPLIST.FIELD$(9)
4073: 71d2:     BKPLI.INCREMENTAL.EXIST$(4)     = BKPLIST.FIELD$(10)
4074: 7208:     BKPLI.INCREMENTAL.FILE.CHNG$(4) = BKPLIST.FIELD$(11)
4075: 723e:     BKPLI.INCREMENTAL.EXIST$(5)     = BKPLIST.FIELD$(12)
4076: 7274:     BKPLI.INCREMENTAL.FILE.CHNG$(5) = BKPLIST.FIELD$(13)
4077: 72aa:     BKPLI.INCREMENTAL.EXIST$(6)     = BKPLIST.FIELD$(14)
4078: 72e0:     BKPLI.INCREMENTAL.FILE.CHNG$(6) = BKPLIST.FIELD$(15)
4079: 7316: 
4080: 7316: RETURN
4081: 7326: 
4082: 7326: \***********************************************************************
4083: 7326: \*
4084: 7326: \* CHECK.DAY.SELECTION: This function checks the DAY selection on
4085: 7326: \*                      process. If successful selection, it sets
4086: 7326: \*                      the passed screen number.
4087: 7326: \*
4088: 7326: \***********************************************************************
4089: 7326: CHECK.DAY.SELECTION:
4090: 7336: 
4091: 7336:     FUNCTION.ERROR.NOT.EXIST = TRUE
4092: 734c: 
4093: 734c:     INPUT.LOOP%   = INPUT.INDEX%    ! First input field value
4094: 7363:     SEL.INDEX%    = XRE.ZERO%
4095: 737a:     SELECT.COUNT% = XRE.ZERO%
4096: 7391:     NON.X.VALUES  = FALSE
4097: 73a7: 
4098: 73a7:     ! Checking the inputs entered
4099: 73a7:     FOR LOOP% = 1 TO VALUE.INDEX%
4100: 73bb: 
4101: 73bb:         ! If field contains any value
4102: 73bb:         IF FIELD$(INPUT.LOOP%) <> XRE.SPACE$ THEN BEGIN
4103: 73f4: 
4104: 73f4:             ! If entered value is not X
4105: 73f4:             IF UCASE$(FIELD$(INPUT.LOOP%)) <> "X" THEN BEGIN
4106: 7436:                 NON.X.VALUES = TRUE
4107: 744e:             ENDIF ELSE BEGIN
4108: 7456:                 SEL.INDEX% = LOOP%
4109: 746c:             ENDIF
4110: 7474: 
4111: 7474:             ! Increment the value to check the multiple selection
4112: 7474:             SELECT.COUNT% = SELECT.COUNT% + 1
4113: 7483:         ENDIF
4114: 748b:         ! Increment to move to the next input field record
4115: 748b:         INPUT.LOOP% = INPUT.LOOP% + 1
4116: 749a:     NEXT LOOP%
4117: 74c4: 
4118: 74c4:     ! If multiple selections made
4119: 74c4:     IF SELECT.COUNT% > 1 THEN BEGIN
4120: 74d6:         FIELD$(1) = "'Multiple selections not allowed"
4121: 74fc:     ENDIF ELSE BEGIN
4122: 7504: 
4123: 7504:         ! If only one selection made and X value is entered
4124: 7504:         IF SELECT.COUNT% = 1 AND NOT NON.X.VALUES THEN BEGIN
4125: 7529:             SCREEN% = SCREEN.NUM%
4126: 7541: 
4127: 7541:         ! If no selection has been made
4128: 7541:         ENDIF ELSE BEGIN
4129: 7549:             FIELD$(1) = "'No selection has been made. "              + \
4130: 7573:                         "Value entered must be ""X"" OR ""x"" "
4131: 7573:         ENDIF
4132: 757b:     ENDIF
4133: 7583: 
4134: 7583: RETURN
4135: 7593: 
4136: 7593: \***********************************************************************
4137: 7593: \*
4138: 7593: \* LOG.STATUS.MSG: Writes status message to log file
4139: 7593: \*
4140: 7593: \***********************************************************************
4141: 7593: LOG.STATUS.MSG:
4142: 75a3: 
4143: 75a3:     IF XRE.LOG.OPEN THEN BEGIN
4144: 75b8: 
4145: 75b8:         ! DD/MM/YY, HH:MM:SS, Text and a CRLF
4146: 75b8:         STATUS.MSG$ = RIGHT$(DATE$,2) + "/"        + \    ! DD/         !CJK
4147: 76de:                       MID$(DATE$,3,2) + "/"        + \    ! MM/         !CJK
4148: 76de:                       LEFT$(DATE$,2)  + XRE.SPACE$ + \    ! YY          !CJK
4149: 76de:                       LEFT$(TIME$,2)  + ":"        + \    ! HH:         !CJK
4150: 76de:                       MID$(TIME$,3,2) + ":"        + \    ! MM:         !CJK
4151: 76de:                       RIGHT$(TIME$,2) + XRE.SPACE$ + \    ! SS          !CJK
4152: 76de:                       STATUS.MSG$                  + \    ! message     !CJK
4153: 76de:                       CRLF$                               ! line return !CJK
4154: 76de: 
4155: 76de:         ! Return code is not checked here, as it is not mandatory.
4156: 76de:         ! Checking return code is not required here, as it is a         !CJK
4157: 76de:         ! screen program and displaying any error for logging might     !CJK
4158: 76de:         ! confuse the user from actual restore functionality            !CJK
4159: 76de:         FILE.RC% = FUNC.WRITE.SEQUENTIAL.FILE(XRE.FILE.RC%, STATUS.MSG$)!DJK
4160: 7713: 
4161: 7713:     ENDIF
4162: 771b: 
4163: 771b: RETURN
4164: 772b: 
4165: 772b: \***********************************************************************
4166: 772b: \*
4167: 772b: \* CHECK.UPDATE.DATE.RC: If FUN.RC2% is not equal to zero ... logs
4168: 772b: \*                       the error for reference.
4169: 772b: \***********************************************************************
4170: 772b: CHECK.UPDATE.DATE.RC:
4171: 773b: 
4172: 773b:     ! Checking the return value
4173: 773b:     IF FUN.RC2% <> XRE.ZERO% THEN BEGIN
4174: 7754:         STATUS.MSG$ = "UPDATE date function error in " + F02.DATE$
4175: 7779:         GOSUB LOG.STATUS.MSG
4176: 778b:     ENDIF
4177: 7793: 
4178: 7793: RETURN
4179: 77a3: 
4180: 77a3: \***********************************************************************
4181: 77a3: \*
4182: 77a3: \*   GET.FILE.EXTENSION: Calculate the extension needed based on month
4183: 77a3: \*                       and day using month A/B/C for 10/11/12
4184: 77a3: \*
4185: 77a3: \***********************************************************************
4186: 77a3: GET.FILE.EXTENSION:
4187: 77b3: 
4188: 77b3:     EXTENSION$ = RIGHT$(FULL.TO.MOVING.DATE$, 4)
4189: 77d8: 
4190: 77d8:     ! Storing the Month and Date in MDD format in new logic
4191: 77d8:     IF LEFT$(EXTENSION$,2) = "12" THEN BEGIN            ! If Dec(12)    !CJK
4192: 780d:         EXTENSION$ = "C" + RIGHT$(EXTENSION$, 2)
4193: 783c:     ENDIF ELSE IF LEFT$(EXTENSION$,2) = "11" THEN BEGIN ! If Nov(11)    !CJK
4194: 7871:         EXTENSION$ = "B" + RIGHT$(EXTENSION$, 2)
4195: 78a0:     ENDIF ELSE IF LEFT$(EXTENSION$,2) = "10" THEN BEGIN ! If Oct(10)    !CJK
4196: 78d5:         EXTENSION$ = "A" + RIGHT$(EXTENSION$, 2)
4197: 7903:     ENDIF ELSE BEGIN                            ! Rest of the Month
4198: 790b:         EXTENSION$ = RIGHT$(EXTENSION$, 3)
4199: 7930:     ENDIF
4200: 7938: 
4201: 7938: RETURN
4202: 7948: 
4203: 7948: !* START CHANGE BLOCK FOR BDC
4204: 7948: \***********************************************************************
4205: 7948: \*
4206: 7948: \* COPY.OS.BLANK.FILES: Copy the blank OS files needed that the old
4207: 7948: \*                      CRESTORE batch file used to do
4208: 7948: \*
4209: 7948: \***********************************************************************
4210: 7948: COPY.OS.BLANK.FILES:
4211: 7958: 
4212: 7958:     DIM OS.FILE$(0)
4213: 7987:     DIM OS.FILE$(8)
4214: 79b6: 
4215: 79b6:     ! set the required files
4216: 79b6:     OS.FILE$(1) = "ADXCSOAF.DAT"
4217: 79d9:     OS.FILE$(2) = "ADXCSOBF.DAT"
4218: 79fc:     OS.FILE$(3) = "ADXCSOCF.DAT"
4219: 7a1f:     OS.FILE$(4) = "ADXCSODF.DAT"
4220: 7a42:     OS.FILE$(5) = "ADXCSOEF.DAT"
4221: 7a65:     OS.FILE$(6) = "ADXCSOFF.DAT"
4222: 7a88:     OS.FILE$(7) = "ADXCSOIF.DAT"
4223: 7aab:     OS.FILE$(8) = "ADXCSONF.DAT"
4224: 7ace: 
4225: 7ace:     ! set the source and destination for copy
4226: 7ace:     OS.DESTINATION$ = "C:\ADX_SDT1\"
4227: 7ae5:     OS.SOURCE$      = "D:\ADX_UPGM\"
4228: 7afc: 
4229: 7afc:     FOR SELECT.COUNT% = 1 TO 8
4230: 7b10:         ! Copying the file from TEMP to the entered location
4231: 7b10:         CALL OSSHELL("COPY " + OS.SOURCE$ + OS.FILE$(SELECT.COUNT%) + \ !CJK
4232: 7b8a:                      XRE.SPACE$ + OS.DESTINATION$                   + \ !CJK
4233: 7b8a:                      " > " + DIR.OUT$ + " >>* " + DIR.OUT$)
4234: 7b8a: 
4235: 7b8a:         DIR.FILE.RC% = FUNC.OPEN.SEQUENTIAL.FILE( DIR.OUT$ )            !DJK
4236: 7bb4: 
4237: 7bb4:         ! If file open unsuccessful
4238: 7bb4:         IF DIR.FILE.RC% <= XRE.ZERO% THEN BEGIN
4239: 7bd2:             DIR.OPEN    = FALSE                                         !CJK
4240: 7be8:             STATUS.MSG$ = "Error in opening DIR output file"
4241: 7bff:             GOSUB LOG.STATUS.MSG
4242: 7c11:             ! Setting NULL to avoid file read
4243: 7c11:             DIR.VALUE$ = XRE.NULL$
4244: 7c31:         ENDIF ELSE BEGIN
4245: 7c39:             DIR.OPEN   = TRUE
4246: 7c4f:             DIR.VALUE$ = XRE.SPACE$
4247: 7c6d:         ENDIF
4248: 7c75: 
4249: 7c75:         ! Read the file till EOF or read error
4250: 7c75:         WHILE LEN(DIR.VALUE$) <> XRE.ZERO%
4251: 7c80:             DIR.VALUE$ = FUNC.READ.SEQUENTIAL.FILE( DIR.FILE.RC% )      !DJK
4252: 7ca3: 
4253: 7ca3:             !-----------------------------------------------!
4254: 7ca3:             ! If error string matches, write the error with !
4255: 7ca3:             ! file name in LOG file                         !
4256: 7ca3:             !-----------------------------------------------!
4257: 7ca3:             IF MATCH(UCASE$("Error extracting file"),   \               !CJK
4258: 7cf4:                      UCASE$(DIR.VALUE$),1) <> XRE.ZERO% THEN BEGIN      !CJK
4259: 7cf4:                 ! Logging copy error                                    !CJK
4260: 7cf4:                 STATUS.MSG$ = "Error when copying OS file " + \
4261: 7d2a:                               OS.FILE$(SELECT.COUNT%)
4262: 7d2a:                 GOSUB LOG.STATUS.MSG
4263: 7d3c:                 RESTORE.STATUS = FALSE
4264: 7d52:             ENDIF
4265: 7d5a:         WEND
4266: 7d82: 
4267: 7d82:         ! Closing File
4268: 7d82:         IF DIR.OPEN THEN BEGIN
4269: 7d94:             CALL FUNC.CLOSE.FILE( DIR.FILE.RC% )                        !DJK
4270: 7dbd:             DIR.OPEN = FALSE
4271: 7dd3:         ENDIF
4272: 7ddb:     NEXT SELECT.COUNT%
4273: 7dff: RETURN
4274: 7e0f: !* END CHANGE BLOCK FOR BDC
4275: 7e0f: 
4276: 7e0f: 
4277: 7e0f: ! Commenting out unused Sub-routine                                     !OJK
4278: 7e0f: \***********************************************************************!OJK
4279: 7e0f: \*                                                                      !OJK
4280: 7e0f: \*    HOW.MANY.DAYS.SINCE.FULL: This Subroutine matches the day set     !OJK
4281: 7e0f: \*                              in F13.DAY and sets the number of days  !OJK
4282: 7e0f: \*                              since the Full backup was taken for     !OJK
4283: 7e0f: \*                              this day                                !OJK
4284: 7e0f: \*                                                                      !OJK
4285: 7e0f: \***********************************************************************!OJK
4286: 7e0f: !HOW.MANY.DAYS.SINCE.FULL:                                              !OJK
4287: 7e0f:                                                                         !OJK
4288: 7e0f: !    ! match for the day and set using the offset as days before        !OJK
4289: 7e0f: !    DAYS.AFTER.FULL.BAKUP% = MATCH(":"+F13.DAY$, BACKUP.DAYS$,1)       !OJK
4290: 7e0f: !    DAYS.AFTER.FULL.BAKUP% = (DAYS.AFTER.FULL.BAKUP%-1)/4              !OJK
4291: 7e0f:                                                                         !OJK
4292: 7e0f: !RETURN                                                                 !OJK
4293: 7e0f: 
4294: 7e0f: \***********************************************************************
4295: 7e0f: \*
4296: 7e0f: \* PERFORM.BACKUP.DRIVE: This Subroutine performs the Drive backup
4297: 7e0f: \*                       process.
4298: 7e0f: \*
4299: 7e0f: \***********************************************************************
4300: 7e0f: PERFORM.BACKUP.DRIVE:
4301: 7e1f: 
4302: 7e1f:     CALL DM.STATUS ("'" + BKPSCRPT.DIRECTORIES$(INDEX%)              + \
4303: 7e75:                     SCREEN.TEXT.MSG$(10) + "Please Wait .....")         !MJK
4304: 7e75: 
4305: 7e75:     STATUS.MSG$ = BKPSCRPT.DIRECTORIES$(INDEX%) + " restoration "    + \
4306: 7eaf:                   "in progress"
4307: 7eaf:     GOSUB LOG.STATUS.MSG
4308: 7ec1: 
4309: 7ec1:     ! If directory not present create it
4310: 7ec1:     IF FUNC.DIR.NOT.EXISTS(BKPSCRPT.DIRECTORIES$(INDEX%)) THEN BEGIN
4311: 7ef3: 
4312: 7ef3:         DIRECT.TO.RESTORE$ = BKPSCRPT.DIRECTORIES$(INDEX%)
4313: 7f22: 
4314: 7f22:         ! Trim the last slash found to avoid error using MKDIR
4315: 7f22:         CALL TRIM   (DIRECT.TO.RESTORE$)
4316: 7f38:         CALL RTRIMC (DIRECT.TO.RESTORE$, ASC("/"))
4317: 7f6b:         CALL RTRIMC (DIRECT.TO.RESTORE$, ASC("\\"))
4318: 7f9e: 
4319: 7f9e:         CALL OSSHELL("MKDIR " + DIRECT.TO.RESTORE$ + " >> "          + \
4320: 7fe6:                      DIR.OUT$ + " >>* "  + DIR.OUT$)
4321: 7fe6:         STATUS.MSG$ = DIRECT.TO.RESTORE$ + " directory is created"
4322: 800b:         GOSUB LOG.STATUS.MSG
4323: 801d: 
4324: 801d:     ENDIF
4325: 8025: 
4326: 8025:     ! Store Full day moving date before processing each directory       !JDC
4327: 8025:     FULL.TO.MOVING.DATE$ = FULL.DATE$                                   !IDC
4328: 8043: 
4329: 8043:     ! Initiating the Directory restore
4330: 8043:     FOR LOOP% = 1 TO BKP.INDEX%
4331: 8057: 
4332: 8057:         RESTORE.STATUS = FALSE
4333: 806d: 
4334: 806d:         STATUS.MSG$ = BKPSCRPT.DIRECTORIES$(INDEX%)               + \   !MJK
4335: 80d8:                       STATUS.TEXT.MSG$(31) + FULL.TO.MOVING.DATE$ + \   !MJK
4336: 80d8:                       SCREEN.TEXT.MSG$(16)                              !MJK
4337: 80d8:         GOSUB LOG.STATUS.MSG
4338: 80ea: 
4339: 80ea:         GOSUB GET.FILE.EXTENSION                                        !IDC
4340: 80fc:         MDD.DATE$ = EXTENSION$                                          !IDC
4341: 811a: 
4342: 811a:         ! Storing the Full MDD                                          !JDC
4343: 811a:         IF LOOP% = 1 THEN BEGIN
4344: 812c:             FULL.MDD.DATE$ = MDD.DATE$                                  !IDC
4345: 814a: 
4346: 814a:             ! BKPLIST current file                                      !MJK
4347: 814a:             BKPLIST.CURR.FILE$ = BKPLIST.CURR.FILE$ + FULL.MDD.DATE$    !MJK
4348: 8176: 
4349: 8176:         ENDIF
4350: 817e: 
4351: 817e:         ! Setting the Backup files based on the 1st field which is drive
4352: 817e:         BKP.FILENAME.IMG$ = PRIMARY.ARCHIVED.NAMES$(INDEX%)          + \
4353: 81bf:                             "." + MDD.DATE$
4354: 81bf:         BKP.FILENAME.ALT$ = SECONDARY.ARCHVD.NAMES$(INDEX%)          + \
4355: 8200:                             "." + MDD.DATE$
4356: 8200: 
4357: 8200:         ! Current BKPFAIL file
4358: 8200:         BKPFAIL.CURR.FILE$ = BKPFAIL.PREFIX$ + MDD.DATE$                !MJK
4359: 822c: 
4360: 822c:         STATUS.MSG$ = "Checking BKPFAIL " + BKPFAIL.CURR.FILE$
4361: 8251:         GOSUB LOG.STATUS.MSG
4362: 8263: 
4363: 8263:         DIR.FILE.RC% = FUNC.OPEN.SEQUENTIAL.FILE( BKPFAIL.CURR.FILE$ )  !NJK
4364: 828d: 
4365: 828d:         ! If file open unsuccessful
4366: 828d:         IF DIR.FILE.RC% <= XRE.ZERO% THEN BEGIN
4367: 82ab:             ! Setting NULL to avoid file read
4368: 82ab:             DIR.VALUE$ = XRE.NULL$
4369: 82c9:             DIR.OPEN   = FALSE                                          !CJK
4370: 82e1:         ENDIF ELSE BEGIN
4371: 82e9:             DIR.OPEN   = TRUE
4372: 82ff:             DIR.VALUE$ = XRE.SPACE$
4373: 831d:         ENDIF
4374: 8325:         !-------------------------------------------------------------!
4375: 8325:         ! Reading the file till the EOF file reached. C file function !
4376: 8325:         ! returns NULL when EOF reached or error                      !FDC
4377: 8325:         !-------------------------------------------------------------!
4378: 8325:         WHILE LEN(DIR.VALUE$) <> XRE.ZERO%
4379: 8330:             DIR.VALUE$ = FUNC.READ.SEQUENTIAL.FILE( DIR.FILE.RC% )      !NJK
4380: 8353: 
4381: 8353:             ! Checking the comma position
4382: 8353:             COMMA.POSITION% = MATCH(COMMA.VALUE$,DIR.VALUE$,1)
4383: 837f: 
4384: 837f:             ! If comma found and drive matches
4385: 837f:             IF COMMA.POSITION% <> XRE.ZERO% THEN BEGIN                  !GJK
4386: 839b: 
4387: 839b:                 ! Storing the failed file                               !MJK
4388: 839b:                 FAILED.FILE$ = LEFT$(DIR.VALUE$,(COMMA.POSITION% - 1))
4389: 83c9:                 ! Storing the Distribution type                         !MJK
4390: 83c9:                 FAILED.FILE.DIST$ = MID$(DIR.VALUE$,            \       !MJK
4391: 83f7:                                         (COMMA.POSITION% + 1),1)        !MJK
4392: 83f7:                 ! If directory in BKPFAIL matches with current directory!GJK
4393: 83f7:                 IF (BKPSCRPT.DIRECTORIES$(INDEX%)) =                   \!GJK
4394: 845d:                     LEFT$(FAILED.FILE$,                                \!GJK
4395: 845d:                     LEN(BKPSCRPT.DIRECTORIES$(INDEX%))) THEN BEGIN      !MJK
4396: 845d: 
4397: 845d:                     BEGIN.POSITION% = 4         ! Setting the begin position
4398: 846e:                     SLASH.POSITION% = XRE.ZERO%
4399: 8485:                     VALUE.EXISTS    = TRUE
4400: 849b:                     FILENAME$       = XRE.NULL$
4401: 84b9: 
4402: 84b9:                     WHILE VALUE.EXISTS
4403: 84c4:                         SLASH.POSITION% = MATCH("\\", FAILED.FILE$, \   !MJK
4404: 84ee:                                                  BEGIN.POSITION%)
4405: 84ee: 
4406: 84ee:                         IF SLASH.POSITION% > XRE.ZERO% THEN BEGIN
4407: 8507:                             ! Move to next position to search next field
4408: 8507:                             BEGIN.POSITION% = SLASH.POSITION% + 1
4409: 8521:                         ENDIF ELSE BEGIN
4410: 8529:                             FILENAME$ = MID$(FAILED.FILE$,          \   !MJK
4411: 856d:                                              BEGIN.POSITION%,       \   !MJK
4412: 856d:                                              (LEN(FAILED.FILE$) -   \   !MJK
4413: 856d:                                               BEGIN.POSITION% + 1))     !MJK
4414: 856d:                             ! Storing the file name
4415: 856d:                             RESTORE.FILENAME$ = FILENAME$               !LJK
4416: 858b:                             ! Checking the dot position                 !MJK
4417: 858b:                             MATCH.POS% = MATCH(".", FILENAME$,1)        !LJK
4418: 85b0:                             IF MATCH.POS% <> XRE.ZERO% THEN BEGIN       !LJK
4419: 85c9:                                 RESTORE.FILENAME$ = LEFT$(FILENAME$, \  !LJK
4420: 85f7:                                                     (MATCH.POS% - 1))   !LJK
4421: 85f7:                             ENDIF                                       !LJK
4422: 85ff:                             VALUE.EXISTS = FALSE
4423: 8615:                         ENDIF
4424: 861d:                     WEND
4425: 8632: 
4426: 8632:                     STATUS.MSG$ = STATUS.TEXT.MSG$(9)                   !JDC
4427: 865c:                     GOSUB LOG.STATUS.MSG
4428: 866e: 
4429: 866e:                     STATUS.MSG$ = STATUS.TEXT.MSG$(10) + FILENAME$      !MJK
4430: 86a6:                     GOSUB LOG.STATUS.MSG
4431: 86b8: 
4432: 86b8:                     ! Depending on the drive, XDISKIMG directory will
4433: 86b8:                     ! be used in copying failed file
4434: 86b8:                     IF DRIVE$ = "D" THEN BEGIN                          !MJK
4435: 86d9:                         ! Copying the file to respective directory      !MJK
4436: 86d9:                         CALL OSSHELL("COPY " + C.BKP.IMG$       + \     !MJK
4437: 8754:                                      RESTORE.FILENAME$ + "."    + \     !MJK
4438: 8754:                                      MDD.DATE$ + XRE.SPACE$     + \     !MJK
4439: 8754:                                      FAILED.FILE$ + " >> "      + \     !MJK
4440: 8754:                                      DIR.OUT$ + " >>* " + DIR.OUT$)     !MJK
4441: 8754:                     ENDIF ELSE BEGIN                                    !MJK
4442: 875c:                         ! Copying the file to respective directory      !MJK
4443: 875c:                         CALL OSSHELL("COPY " + D.BKP.IMG$       + \     !MJK
4444: 87d4:                                      RESTORE.FILENAME$ + "."    + \     !MJK
4445: 87d4:                                      MDD.DATE$ + XRE.SPACE$     + \     !MJK
4446: 87d4:                                      FAILED.FILE$ + " >> "      + \     !MJK
4447: 87d4:                                      DIR.OUT$ + " >>* " + DIR.OUT$)     !MJK
4448: 87d4:                     ENDIF                                               !MJK
4449: 87dc: 
4450: 87dc:                     !---------------------------------------------!
4451: 87dc:                     ! Not distributing the file if SUPPS mode, as !
4452: 87dc:                     ! ADXCSU0L won't work under SUPPS             !
4453: 87dc:                     !---------------------------------------------!
4454: 87dc:                     IF NOT SUPPS.ON THEN BEGIN
4455: 87ee:                         ! Setting the distribution type
4456: 87ee:                         CALL OSSHELL(ADXCSU0L.FILE.NAME$ + " 3 "    + \ !MJK
4457: 8857:                                      FAILED.FILE.DIST$ + XRE.SPACE$ + \ !GJK
4458: 8857:                                      FAILED.FILE$ + " >> "          + \ !MJK
4459: 8857:                                      DIR.OUT$ + " >>* " + DIR.OUT$ )    !GJK
4460: 8857:                     ENDIF
4461: 885f: 
4462: 885f:                     DIR.FILE.RC% = FUNC.OPEN.SEQUENTIAL.FILE( DIR.OUT$ )!NJK
4463: 8889: 
4464: 8889:                     ! If file open unsuccessful
4465: 8889:                     IF DIR.FILE.RC% <= XRE.ZERO% THEN BEGIN
4466: 88a7:                         DIR.OPEN    = FALSE                             !MJK
4467: 88bd:                         STATUS.MSG$ = STATUS.TEXT.ERROR$(2)             !JDC
4468: 88e7:                         GOSUB LOG.STATUS.MSG
4469: 88f9:                         ! Setting NULL to avoid file read
4470: 88f9:                         DIR.VALUE$ = XRE.NULL$
4471: 8919:                     ENDIF ELSE BEGIN
4472: 8921:                         DIR.OPEN   = TRUE
4473: 8937:                         DIR.VALUE$ = XRE.SPACE$
4474: 8955:                     ENDIF
4475: 895d: 
4476: 895d:                     ! Read the file till EOF or read error              !GJK
4477: 895d:                     WHILE LEN(DIR.VALUE$) <> XRE.ZERO%
4478: 8968:                         DIR.VALUE$ = \                                  !NJK
4479: 898b:                             FUNC.READ.SEQUENTIAL.FILE(DIR.FILE.RC%)     !NJK
4480: 898b: 
4481: 898b:                         !-----------------------------------------------!
4482: 898b:                         ! If error string matches, write the error with !
4483: 898b:                         ! file name in LOG file                         !
4484: 898b:                         !-----------------------------------------------!
4485: 898b:                         IF MATCH("ERROR",UCASE$(DIR.VALUE$),1)        \ !OJK
4486: 8a07:                            <> XRE.ZERO%                            OR \ !OJK
4487: 8a07:                            MATCH("cannot be found",(DIR.VALUE$),1) <> \ !OJK
4488: 8a07:                            XRE.ZERO% THEN BEGIN                         !OJK
4489: 8a07:                             ! Logging the copy / distribution error
4490: 8a07:                             STATUS.MSG$ = STATUS.TEXT.ERROR$(14)        !JDC
4491: 8a31:                             GOSUB LOG.STATUS.MSG
4492: 8a43:                             STATUS.MSG$ = DIR.VALUE$
4493: 8a61:                             GOSUB LOG.STATUS.MSG
4494: 8a73: 
4495: 8a73:                             RESTORE.ERR.EXIST = TRUE                    !OJK
4496: 8a89:                             ! To break the WHILE loop                   !OJK
4497: 8a89:                             DIR.VALUE$ = XRE.NULL$                      !OJK
4498: 8aa7:                         ENDIF
4499: 8aaf:                     WEND
4500: 8ad7: 
4501: 8ad7:                     ! Closing File
4502: 8ad7:                     IF DIR.OPEN THEN BEGIN
4503: 8ae9:                         CALL FUNC.CLOSE.FILE( DIR.FILE.RC% )            !NJK
4504: 8b12:                         DIR.OPEN = FALSE
4505: 8b28:                     ENDIF
4506: 8b30:                 ENDIF                                                   !GJK
4507: 8b38:             ENDIF
4508: 8b40:         WEND
4509: 8b68: 
4510: 8b68:         ! Closing File
4511: 8b68:         IF DIR.OPEN THEN BEGIN
4512: 8b7a:             CALL FUNC.CLOSE.FILE( DIR.FILE.RC% )                        !NJK
4513: 8ba3:             DIR.OPEN = FALSE
4514: 8bb9:         ENDIF
4515: 8bc1: 
4516: 8bc1:         !--------------------------------------------------------------!
4517: 8bc1:         ! Checking the archive file existence before extraction. First !
4518: 8bc1:         ! the file will be checked in IMG location and it not present, !
4519: 8bc1:         ! then it will be tried in ALT location                        !
4520: 8bc1:         !--------------------------------------------------------------!
4521: 8bc1:         IF FUNC.FILE.EXISTS(BKP.FILENAME.IMG$) THEN BEGIN
4522: 8be2: 
4523: 8be2:             CALL OSSHELL(ADXZUDIR.FILE.NAME$ + " -x "                + \
4524: 8c5c:                          BKP.FILENAME.IMG$   + XRE.SPACE$            + \
4525: 8c5c:                          BKPSCRPT.DIRECTORIES$(INDEX%)               + \
4526: 8c5c:                          " > " + DIR.OUT$ + " >>* " + DIR.OUT$)
4527: 8c5c: 
4528: 8c5c:             STATUS.MSG$ = BKP.FILENAME.IMG$ + STATUS.TEXT.MSG$(11)   + \!JDC
4529: 8cb0:                           BKPSCRPT.DIRECTORIES$(INDEX%)
4530: 8cb0:             GOSUB LOG.STATUS.MSG
4531: 8cc2: 
4532: 8cc2:             ! Setting the status to check the extraction output file
4533: 8cc2:             RESTORE.STATUS = TRUE
4534: 8cdb: 
4535: 8cdb:         ENDIF ELSE BEGIN                                                !NJK
4536: 8ce3:             IF FUNC.FILE.EXISTS(BKP.FILENAME.ALT$) THEN BEGIN           !NJK
4537: 8d04: 
4538: 8d04:                 CALL OSSHELL(ADXZUDIR.FILE.NAME$ + " -x "            + \
4539: 8d7e:                              BKP.FILENAME.ALT$   + XRE.SPACE$        + \
4540: 8d7e:                              BKPSCRPT.DIRECTORIES$(INDEX%)           + \
4541: 8d7e:                              " > " + DIR.OUT$ + " >>* " + DIR.OUT$)
4542: 8d7e: 
4543: 8d7e:                 STATUS.MSG$ = BKP.FILENAME.ALT$ + STATUS.TEXT.MSG$(11)+ \JDC
4544: 8dd2:                               BKPSCRPT.DIRECTORIES$(INDEX%)
4545: 8dd2:                 GOSUB LOG.STATUS.MSG
4546: 8de4: 
4547: 8de4:                 ! Setting the status to check the extraction output file
4548: 8de4:                 RESTORE.STATUS = TRUE
4549: 8dfa: 
4550: 8dfa:             ENDIF
4551: 8e02:         ENDIF                                                           !NJK
4552: 8e0a: 
4553: 8e0a:         ! Initializing to FALSE
4554: 8e0a:         RESTORE.HAPPENED = FALSE                                        !MJK
4555: 8e20: 
4556: 8e20:         ! If file extraction happened
4557: 8e20:         IF RESTORE.STATUS THEN BEGIN                                    !MJK
4558: 8e35: 
4559: 8e35:             ! Setting TRUE for successful extraction
4560: 8e35:             RESTORE.HAPPENED = TRUE                                     !MJK
4561: 8e4b:             ! Open file                                                 !MJK
4562: 8e4b:             DIR.FILE.RC% = FUNC.OPEN.SEQUENTIAL.FILE( DIR.OUT$ )        !NJK
4563: 8e75: 
4564: 8e75:             ! If file open unsuccessful
4565: 8e75:             IF DIR.FILE.RC% <= XRE.ZERO% THEN BEGIN
4566: 8e93:                 DIR.OPEN    = FALSE                                     !MJK
4567: 8ea9:                 STATUS.MSG$ = STATUS.TEXT.ERROR$(2)                     !JDC
4568: 8ed3:                 GOSUB LOG.STATUS.MSG
4569: 8ee5:                 ! Setting NULL to avoid file read
4570: 8ee5:                 DIR.VALUE$ = XRE.NULL$
4571: 8f05:             ENDIF ELSE BEGIN
4572: 8f0d:                 DIR.OPEN   = TRUE
4573: 8f23:                 DIR.VALUE$ = XRE.SPACE$
4574: 8f41:             ENDIF
4575: 8f49: 
4576: 8f49:             ! Read the file till EOF or read error                      !FDC
4577: 8f49:             WHILE LEN(DIR.VALUE$) <> XRE.ZERO%
4578: 8f54:                 DIR.VALUE$ = FUNC.READ.SEQUENTIAL.FILE( DIR.FILE.RC% )  !NJK
4579: 8f77: 
4580: 8f77:                 !-----------------------------------------------!
4581: 8f77:                 ! If error string matches, write the error with !
4582: 8f77:                 ! file name in LOG file                         !
4583: 8f77:                 !-----------------------------------------------!
4584: 8f77:                 IF MATCH("Error extracting file",DIR.VALUE$,1) <>      \
4585: 8fa5:                    XRE.ZERO% THEN BEGIN
4586: 8fa5: 
4587: 8fa5: !                    STATUS.MSG$ = STATUS.TEXT.ERROR$(12)               !OJK
4588: 8fa5: !                    GOSUB LOG.STATUS.MSG                               !OJK
4589: 8fa5: 
4590: 8fa5:                     ! Setting the flag for extraction error
4591: 8fa5:                     RESTORE.ERR.EXIST = TRUE
4592: 8fbb:                     STATUS.MSG$       = DIR.VALUE$
4593: 8fd9:                     GOSUB LOG.STATUS.MSG
4594: 8feb:                 ENDIF
4595: 8ff3:             WEND
4596: 901b: 
4597: 901b:             ! Closing File
4598: 901b:             IF DIR.OPEN THEN BEGIN
4599: 902d:                 CALL FUNC.CLOSE.FILE( DIR.FILE.RC% )                    !NJK
4600: 9056:                 DIR.OPEN = FALSE
4601: 906c:             ENDIF
4602: 9074: 
4603: 9074:         ENDIF
4604: 907c:         ! Starting from Full day increment the date till requested date !JDC
4605: 907c:         F02.DATE$ = FULL.TO.MOVING.DATE$
4606: 909a:         FUN.RC2%  = UPDATE.DATE( 1 )                                    !MJK
4607: 90b9:         ! Checking the Return code
4608: 90b9:         GOSUB CHECK.UPDATE.DATE.RC                                      !IDC
4609: 90cb:         FULL.TO.MOVING.DATE$ = F02.DATE$
4610: 90e9: 
4611: 90e9:     NEXT LOOP%
4612: 9114: 
4613: 9114: RETURN
4614: 9124: 
4615: 9124: \***********************************************************************
4616: 9124: \*
4617: 9124: \* PROCESS.BKPLIST.FILE: This Subroutine reads the BKPLIST file and
4618: 9124: \*                       removes the file, if any file has NOT EXIST
4619: 9124: \*                       option enabled.
4620: 9124: \*
4621: 9124: \***********************************************************************
4622: 9124: PROCESS.BKPLIST.FILE:
4623: 9134: 
4624: 9134:     STATUS.MSG$ = "Checking " + BKPLIST.CURR.FILE$ + " to check the" + \
4625: 9161:                   " extracted file"
4626: 9161:     GOSUB LOG.STATUS.MSG
4627: 9173: 
4628: 9173:     !--------------------------------------------------------!
4629: 9173:     ! Checking whether BKPLIST file exist and the extraction !
4630: 9173:     ! happened and also requested date is NOT Full           !          !JDC
4631: 9173:     !--------------------------------------------------------!
4632: 9173:     IF RESTORE.HAPPENED AND BKP.INDEX% > 1 THEN BEGIN                   !MJK
4633: 9198:         ! only check the file when this far                             !JDC
4634: 9198:         IF FUNC.FILE.EXISTS(BKPLIST.CURR.FILE$) THEN BEGIN              !JDC
4635: 91b9:             ! Opening the BKPLIST file                                  !MJK
4636: 91b9:             BKPLIST.FILE.RC% = \                                        !NJK
4637: 91e3:                     FUNC.OPEN.SEQUENTIAL.FILE (BKPLIST.CURR.FILE$)      !NJK
4638: 91e3:             ! If file open unsuccessful
4639: 91e3:             IF BKPLIST.FILE.RC% <= XRE.ZERO% THEN BEGIN
4640: 9201:                 BKPLIST.OPEN = FALSE                                    !MJK
4641: 9217:                 STATUS.MSG$  = "Error in opening BKPLIST file"          !MJK
4642: 922e:                 GOSUB LOG.STATUS.MSG
4643: 9240:                 ! Setting NULL to avoid file read
4644: 9240:                 BKPLIST.DIR.VALUE$ = XRE.NULL$
4645: 9260:             ENDIF ELSE BEGIN
4646: 9268:                 BKPLIST.OPEN       = TRUE
4647: 927e:                 BKPLIST.DIR.VALUE$ = XRE.SPACE$
4648: 929c:             ENDIF
4649: 92a4: 
4650: 92a4:             ! Read the file till the EOF
4651: 92a4:             WHILE LEN(BKPLIST.DIR.VALUE$) <> XRE.ZERO%
4652: 92af:                 BKPLIST.DIR.VALUE$ = \                                  !JDC
4653: 92d2:                     FUNC.READ.SEQUENTIAL.FILE(BKPLIST.FILE.RC%)         !NJK
4654: 92d2: 
4655: 92d2:                 !---------------------------------------------------!
4656: 92d2:                 ! Checking the directory name of BKPLIST files with !
4657: 92d2:                 ! the requested drive                               !
4658: 92d2:                 !---------------------------------------------------!
4659: 92d2:                 IF UCASE$(LEFT$(BKPLIST.DIR.VALUE$,1)) = DRIVE$ \       !JDC
4660: 9321:                 THEN BEGIN                                              !JDC
4661: 9321: 
4662: 9321:                     ! Extract the individual fields using function
4663: 9321:                     GOSUB EXTRACT.BKPLIST.FIELDS                        !IDC
4664: 9333: 
4665: 9333:                     IF NOT FUNCTION.ERROR.NOT.EXIST THEN BEGIN          !EJK
4666: 9345:                         ! Setting the value for exception
4667: 9345:                         RESTORE.ERR.EXIST = TRUE                        !EJK
4668: 935b:                     ENDIF                                               !EJK
4669: 9363: 
4670: 9363:                     IF BKPLI.INCREMENTAL.EXIST$(BKP.INDEX% - 1) <> "Y" \!MJK
4671: 9396:                     THEN BEGIN                                          !IDC
4672: 9396:                         GOSUB DEL.BKPLIST.FILE                          !IDC
4673: 93a8:                     ENDIF                                               !IDC
4674: 93b0:                 ENDIF
4675: 93b8:             WEND
4676: 93e0: 
4677: 93e0:             ! Closing File
4678: 93e0:             IF BKPLIST.OPEN THEN BEGIN
4679: 93f2:                 CALL FUNC.CLOSE.FILE( BKPLIST.FILE.RC% )                !NJK
4680: 941b:                 BKPLIST.OPEN = FALSE
4681: 9431:             ENDIF
4682: 9439:         ENDIF                                                           !JDC
4683: 9441:     ENDIF
4684: 9449: 
4685: 9449: RETURN
4686: 9459: 
4687: 9459: \***********************************************************************!EJK
4688: 9459: \*                                                                      !EJK
4689: 9459: \*  DEL.BKPLIST.FILE: This Sub-Routine deletes the BKPLIST file         !EJK
4690: 9459: \*                    which is set as Non-exist.                        !EJK
4691: 9459: \*                                                                      !EJK
4692: 9459: \***********************************************************************!EJK
4693: 9459: DEL.BKPLIST.FILE:
4694: 9469: 
4695: 9469:     CALL OSSHELL("DEL " + BKPLI.FILENAME$ + " >> " + DIR.OUT$ + \       !JDC
4696: 94b1:                  " >>* " + DIR.OUT$)
4697: 94b1:     STATUS.MSG$ = STATUS.TEXT.MSG$(7) + BKPLI.FILENAME$                 !JDC
4698: 94e9:     GOSUB LOG.STATUS.MSG
4699: 94fb: 
4700: 94fb: RETURN
4701: 950b: 
4702: 950b: \***********************************************************************!MJK
4703: 950b: \*                                                                      !MJK
4704: 950b: \* BACKUP.CONFIG.FILES: This Sub-Routine backs up the configuration     !MJK
4705: 950b: \*                      files at the end of restore                     !MJK
4706: 950b: \*                                                                      !MJK
4707: 950b: \***********************************************************************!MJK
4708: 950b: BACKUP.CONFIG.FILES:
4709: 951b: 
4710: 951b:     IF DRIVE$ = "C" THEN BEGIN
4711: 9539:         BKP.DRIVE$ = "D"
4712: 9552:     ENDIF ELSE BEGIN
4713: 955a:         BKP.DRIVE$ = "C"
4714: 9571:     ENDIF
4715: 9579: 
4716: 9579:     CALL OSSHELL("COPY " + BKP.DRIVE$ + ":\ADX_UDT1\BKPLIST.* " + \
4717: 95d4:                  DRIVE$ + ":\ADX_UDT1\" + " > " + DIR.OUT$      + \
4718: 95d4:                  " >>* " + DIR.OUT$)
4719: 95d4: 
4720: 95d4:     DIR.FILE.RC% = FUNC.OPEN.SEQUENTIAL.FILE( DIR.OUT$ )                !NJK
4721: 95fe: 
4722: 95fe:     ! If file open unsuccessful
4723: 95fe:     IF DIR.FILE.RC% <= XRE.ZERO% THEN BEGIN
4724: 961c:         DIR.OPEN    = FALSE
4725: 9632:         STATUS.MSG$ = "Error in opening DIR output file"
4726: 9649:         GOSUB LOG.STATUS.MSG
4727: 965b:         ! Setting NULL to avoid file read
4728: 965b:         DIR.VALUE$ = XRE.NULL$
4729: 967b:     ENDIF ELSE BEGIN
4730: 9683:         DIR.OPEN   = TRUE
4731: 9699:         DIR.VALUE$ = XRE.SPACE$
4732: 96b7:     ENDIF
4733: 96bf: 
4734: 96bf:     ! Read the file till EOF or read error
4735: 96bf:     WHILE LEN(DIR.VALUE$) <> XRE.ZERO%
4736: 96ca:         DIR.VALUE$ = FUNC.READ.SEQUENTIAL.FILE( DIR.FILE.RC% )          !NJK
4737: 96ed: 
4738: 96ed:         !-----------------------------------------------!
4739: 96ed:         ! If error string matches, write the error      !
4740: 96ed:         !-----------------------------------------------!
4741: 96ed:         IF MATCH(UCASE$("Error"),UCASE$(DIR.VALUE$),1) <> XRE.ZERO% \
4742: 973e:         THEN BEGIN
4743: 973e:             ! Logging the error
4744: 973e:             STATUS.MSG$ = "Error when backing up BKPLIST files"
4745: 9755:             GOSUB LOG.STATUS.MSG
4746: 9767:             DIR.VALUE$        = XRE.NULL$
4747: 9785:             RESTORE.ERR.EXIST = TRUE                                    !OJK
4748: 979b:         ENDIF
4749: 97a3:     WEND
4750: 97cb: 
4751: 97cb:     ! Closing File
4752: 97cb:     IF DIR.OPEN THEN BEGIN
4753: 97dd:         CALL FUNC.CLOSE.FILE( DIR.FILE.RC% )                            !NJK
4754: 9806:         DIR.OPEN = FALSE
4755: 981c:     ENDIF
4756: 9824: 
4757: 9824: RETURN
4758: 9834: 
4759: 9834: \***********************************************************************
4760: 9834: \*
4761: 9834: \* DISPLAY.DIRECT.SCREEN: This Subroutine displays the DIRECTORY
4762: 9834: \*                        screen for XRESTORE.
4763: 9834: \*
4764: 9834: \***********************************************************************
4765: 9834: DISPLAY.DIRECT.SCREEN:
4766: 9844: 
4767: 9844:     ! Screen constant variables
4768: 9844:     DIR.INDEX%       = 30               ! Directory name
4769: 9854:     DIR.INPUT.INDEX% = 100              ! Input value
4770: 9865: 
4771: 9865:     PAGE.NO%         = 1                ! Setting the page number
4772: 9875:     MAX.DIRECTORIES% = DIR.TO.SHOW%     ! Setting the number of entries
4773: 988c: 
4774: 988c:     ! Dimensioning the array
4775: 988c:     DIM SELECTED.DIR.ARRAY$(ARRAY.LIMIT%)                               !MJK
4776: 98c0: 
4777: 98c0:     ! Initiating an array with spaces for input values
4778: 98c0:     FOR LOOP% = 1 TO BKPSCRPT.INDEX%
4779: 98d3:         !----------------------------------------------------!
4780: 98d3:         ! BKPSCRPT.INDEX% array index check has been already !
4781: 98d3:         ! handled when BKPSCRPT array has been added         !
4782: 98d3:         !----------------------------------------------------!
4783: 98d3:         SELECTED.DIR.ARRAY$(LOOP%) = XRE.SPACE$
4784: 9902:     NEXT LOOP%
4785: 9929: 
4786: 9929:     ! Setting the variables to process
4787: 9929:     DIR.LOOP%        = DIR.INDEX%
4788: 9940:     DIR.INPUT.LOOP%  = DIR.INPUT.INDEX%
4789: 9956: 
4790: 9956:     CALL DM.SHOW.SCREEN (5, XRE.NULL$, 4, 4)
4791: 9977: 
4792: 9977:     ! Setting the variable for screen continuation text
4793: 9977:     CALL DM.NAME (53, "USER.TEXT$", USER.TEXT$)
4794: 99b6:     USER.TEXT$ = "Continued...."
4795: 99cd: 
4796: 99cd:     ! Checking the Index for Backups
4797: 99cd:     IF BKPSCRPT.INDEX% > XRE.ZERO% THEN BEGIN
4798: 99e9:         ! Storing the page number
4799: 99e9:         PAGE.DIV% = BKPSCRPT.INDEX%/MAX.DIRECTORIES%
4800: 9a07: 
4801: 9a07:         IF MOD(BKPSCRPT.INDEX%,MAX.DIRECTORIES%) THEN BEGIN
4802: 9a2c:             ! Incrementing by 1 if MOD value is greater than zero
4803: 9a2c:             PAGE.DIV% = PAGE.DIV% + 1
4804: 9a3b:         ENDIF
4805: 9a43: 
4806: 9a43:         ! Setting the total page number
4807: 9a43:         FIELD$(4) = STR$(PAGE.DIV%)
4808: 9a75: 
4809: 9a75:         GOSUB DISPLAY.DIR.PAGE
4810: 9a8a: 
4811: 9a8a:     ENDIF ELSE BEGIN
4812: 9a92:         FIELD$(3) = "1"
4813: 9ab5:         FIELD$(4) = "1"
4814: 9ad8:         FIELD$(1) = SCREEN.TEXT.MSG$(30)                                !JDC
4815: 9b0e:     ENDIF
4816: 9b16: 
4817: 9b16: RETURN
4818: 9b26: 
4819: 9b26: \***********************************************************************
4820: 9b26: \*
4821: 9b26: \* PROCESS.DIRECT.SCREEN: This Subroutine displays the DIRECTORY
4822: 9b26: \*                        screen for XRESTORE.
4823: 9b26: \*
4824: 9b26: \***********************************************************************
4825: 9b26: PROCESS.DIRECT.SCREEN:
4826: 9b36: 
4827: 9b36:     WHILE SCREEN% = RESTORE.A.DIRECTORY.SCR% OR \                       !CJK
4828: 9b41:           SCREEN% = DIRECTORY.DAY.SELECT.SCR%                           !CJK
4829: 9b41: 
4830: 9b41:         IF SCREEN% = RESTORE.A.DIRECTORY.SCR% THEN BEGIN                !CJK
4831: 9b59:             ! If the screen is accessed using F3 or ESC
4832: 9b59:             IF PREVIOUS.KEY THEN BEGIN
4833: 9b6b:                 GOSUB DISPLAY.DIRECT.SCREEN
4834: 9b7d:                 PREVIOUS.KEY = FALSE
4835: 9b93:             ENDIF
4836: 9b9b: 
4837: 9b9b:             ! Process multi page directory screen
4838: 9b9b:             GOSUB PROCESS.MULTI.DIR.SCREEN
4839: 9baf:         ENDIF ELSE IF SCREEN% = DIRECTORY.DAY.SELECT.SCR% THEN BEGIN    !CJK
4840: 9bc7: 
4841: 9bc7:             !------------------------------------------------------!
4842: 9bc7:             ! Complete Directory restore process will be carried   !
4843: 9bc7:             ! out by this Sub-program. This has been created as a  !
4844: 9bc7:             ! Sub-program to overcome the foreseen 64K issue       !
4845: 9bc7:             !------------------------------------------------------!
4846: 9bc7:             CALL SUB.PROCESS.DAY.DIR.SCREEN                            \
4847: 9c05:                     (PRIMARY.ARCHIVED.NAMES$(SELECT.INDEX%),           \
4848: 9c05:                      SECONDARY.ARCHVD.NAMES$(SELECT.INDEX%))
4849: 9c05:         ENDIF
4850: 9c0d:     WEND
4851: 9c44: 
4852: 9c44: RETURN
4853: 9c54: 
4854: 9c54: \***********************************************************************
4855: 9c54: \*
4856: 9c54: \* PROCESS.MULTI.DIR.SCREEN: This Subroutine displays the MULTI
4857: 9c54: \*                           DIRECTORY screen for XRESTORE.
4858: 9c54: \*
4859: 9c54: \***********************************************************************
4860: 9c54: PROCESS.MULTI.DIR.SCREEN:
4861: 9c64: 
4862: 9c64:     RET.KEY% = DM.PROCESS.SCREEN (2, 123, TRUE)
4863: 9c88: 
4864: 9c88:     ! ESC or F3 press or No Backup directories
4865: 9c88:     IF (RET.KEY% = ESC.KEY%) OR (RET.KEY% = F3.KEY%) OR \
4866: 9cd3:        BKPSCRPT.INDEX% = XRE.ZERO% THEN BEGIN
4867: 9cd3: 
4868: 9cd3:         CALL DM.FOCUS("10",SCREEN.TEXT.MSG$(31))                        !JDC
4869: 9cfe: 
4870: 9cfe:         ! Main screen
4871: 9cfe:         SCREEN% = DISPLAY.MAIN.SCR%                                     !CJK
4872: 9d17: 
4873: 9d17:     ENDIF ELSE IF RET.KEY% = F8.KEY% OR RET.KEY% = PGDN.KEY% THEN BEGIN
4874: 9d4e:         ! When F8 or Page down key pressed
4875: 9d4e: 
4876: 9d4e:         ! If Page no. is lesser than the MAX page
4877: 9d4e:         IF PAGE.NO% < PAGE.DIV% THEN BEGIN
4878: 9d66:             ! Save the fields first before moving to next page
4879: 9d66:             GOSUB SAVE.DIR.FIELD
4880: 9d78: 
4881: 9d78:             ! Increment the page
4882: 9d78:             PAGE.NO% = PAGE.NO% + 1
4883: 9d87: 
4884: 9d87:             ! Display the next page
4885: 9d87:             GOSUB DISPLAY.DIR.PAGE
4886: 9d9b:         ENDIF ELSE BEGIN
4887: 9da3:             ! If invalid key press
4888: 9da3:             FIELD$(1) = "'There are no more pages to display"
4889: 9dc6:         ENDIF
4890: 9dd1:     ENDIF ELSE IF RET.KEY% = F7.KEY% OR RET.KEY% = PGUP.KEY% THEN BEGIN
4891: 9e08:         ! When F7 or Page up key pressed
4892: 9e08: 
4893: 9e08:         ! If Page no. is greater than 1
4894: 9e08:         IF PAGE.NO% > 1 THEN BEGIN
4895: 9e1a:             ! Save the fields first before moving to next page
4896: 9e1a:             GOSUB SAVE.DIR.FIELD
4897: 9e2c: 
4898: 9e2c:             ! Decrement the page
4899: 9e2c:             PAGE.NO% = PAGE.NO% - 1
4900: 9e3b: 
4901: 9e3b:             ! Display the previous page
4902: 9e3b:             GOSUB DISPLAY.DIR.PAGE
4903: 9e4f:         ENDIF ELSE BEGIN
4904: 9e57:             ! If invalid key press
4905: 9e57:             FIELD$(1) = "'There is no previous page to display"
4906: 9e7a:         ENDIF
4907: 9e84:     ENDIF ELSE IF RET.KEY% = ENTER.KEY% THEN BEGIN
4908: 9e9c:         ! Save the field
4909: 9e9c:         GOSUB SAVE.DIR.FIELD
4910: 9eae: 
4911: 9eae:         ! Process the input values
4912: 9eae:         GOSUB PROCESS.DIR.INPUT
4913: 9ec2:     ENDIF ELSE BEGIN
4914: 9eca:         ! B001 Invalid key pressed
4915: 9eca:         CALL DM.FOCUS ("1", STATUS.TEXT.ERROR$(20))                     !IDC
4916: 9ef5:     ENDIF
4917: 9efd: 
4918: 9efd: RETURN
4919: 9f0d: 
4920: 9f0d: \***********************************************************************
4921: 9f0d: \*
4922: 9f0d: \* DISPLAY.DIR.PAGE: This Subroutine the display the available
4923: 9f0d: \*                   directories based on the page number value.
4924: 9f0d: \*
4925: 9f0d: \***********************************************************************
4926: 9f0d: DISPLAY.DIR.PAGE:
4927: 9f1d: 
4928: 9f1d:     !---------------------------------------------------------!
4929: 9f1d:     ! Index values are used as constant variables for screens !
4930: 9f1d:     ! Loop values are used for populating the values in field !
4931: 9f1d:     !---------------------------------------------------------!
4932: 9f1d:     DIR.LOOP%        = DIR.INDEX%
4933: 9f34:     DIR.INPUT.LOOP%  = DIR.INPUT.INDEX%
4934: 9f4a:     MAX.DIRECTORIES% = DIR.TO.SHOW%
4935: 9f61: 
4936: 9f61:     ! Setting the Page numbers
4937: 9f61:     FIELD$(3) = STR$(PAGE.NO%)
4938: 9f93:     FIELD$(4) = STR$(PAGE.DIV%)
4939: 9fc5: 
4940: 9fc5:     ! Setting the Current field
4941: 9fc5:     CALL DM.CURRENT.FIELD(DIR.INPUT.INDEX%)
4942: 9fdb: 
4943: 9fdb:     !--------------------------------------------------------------!
4944: 9fdb:     ! Checking whether total available directories is greater than !
4945: 9fdb:     ! current screen values. If not, the condition will go to the  !
4946: 9fdb:     ! Else loop which will show the last page.                     !
4947: 9fdb:     !--------------------------------------------------------------!
4948: 9fdb:     IF BKPSCRPT.INDEX% > (MAX.DIRECTORIES% * PAGE.NO%) THEN BEGIN
4949: 9ffe: 
4950: 9ffe:         ! If Page num 1, Page up disabled
4951: 9ffe:         IF PAGE.NO% = 1 THEN BEGIN
4952: a010:             CALL DM.HIDE.FN.KEY (7)
4953: a021:             CALL DM.SHOW.FN.KEY (8, "PGDN")
4954: a039: 
4955: a039:         ENDIF ELSE BEGIN
4956: a041:             CALL DM.SHOW.FN.KEY (7, "PGUP")
4957: a057:             CALL DM.SHOW.FN.KEY (8, "PGDN")
4958: a06d:         ENDIF
4959: a075: 
4960: a075:         ! Setting the visibility of the "Continued" text
4961: a075:         CALL DM.VISIBLE (STR$(53), STATUS.TEXT.MSG$(61))                !IDC
4962: a0ba: 
4963: a0ba:     ENDIF ELSE BEGIN
4964: a0c2:         ! Setting the max directories based on the available values
4965: a0c2:         MAX.DIRECTORIES% = BKPSCRPT.INDEX% - (MAX.DIRECTORIES% * \
4966: a0f1:                                              (PAGE.NO% - 1))
4967: a0f1:         ! As this is the last page, Hide the Page down key
4968: a0f1:         CALL DM.HIDE.FN.KEY (8)
4969: a102: 
4970: a102:         ! If only one page, hide both page up and page down keys
4971: a102:         IF PAGE.NO% = 1 THEN BEGIN
4972: a114:             CALL DM.HIDE.FN.KEY (7)
4973: a125:         ENDIF
4974: a12d: 
4975: a12d:         ! Disable the "Continued" text
4976: a12d:         CALL DM.VISIBLE (STR$(53), STATUS.TEXT.MSG$(60))                !IDC
4977: a16f: 
4978: a16f:     ENDIF
4979: a177: 
4980: a177:     ! Looping to display the directories in selected page
4981: a177:     FOR LOOP% = 1 TO MAX.DIRECTORIES%
4982: a18b: 
4983: a18b:         ! Directory name
4984: a18b:         FIELD$(DIR.LOOP%) = BKPSCRPT.DIRECTORIES$(                 \    !MJK
4985: a1df:                             LOOP% + ((PAGE.NO% - 1) * DIR.TO.SHOW%))    !MJK
4986: a1df:         ! Setting spaces for input value
4987: a1df:         FIELD$(DIR.INPUT.LOOP%) = SELECTED.DIR.ARRAY$(LOOP%          + \!MJK
4988: a233:                                        ((PAGE.NO% - 1) * DIR.TO.SHOW%)) !MJK
4989: a233:         ! Setting the visibility
4990: a233:         CALL DM.VISIBLE (STR$(DIR.LOOP%)      , STATUS.TEXT.MSG$(61))   !MJK
4991: a277:         CALL DM.VISIBLE (STR$(DIR.INPUT.LOOP%), STATUS.TEXT.MSG$(61))   !IDC
4992: a2bb: 
4993: a2bb:         ! Incrementing to the next field
4994: a2bb:         DIR.LOOP%       = DIR.LOOP% + 1
4995: a2ca:         DIR.INPUT.LOOP% = DIR.INPUT.LOOP% + 1
4996: a2d9: 
4997: a2d9:     NEXT LOOP%
4998: a303: 
4999: a303:     !---------------------------------------!
5000: a303:     ! If last page, disable the remaining   !
5001: a303:     ! directory field and input field       !
5002: a303:     !---------------------------------------!
5003: a303:     IF MAX.DIRECTORIES% < DIR.TO.SHOW% THEN BEGIN
5004: a31f: 
5005: a31f:         ! Looping from above finished value till the MAX value in a page
5006: a31f:         FOR LOOP% = MAX.DIRECTORIES% + 1 TO DIR.TO.SHOW%
5007: a339:             CALL DM.VISIBLE (STR$(DIR.LOOP%), STATUS.TEXT.MSG$(60))     !IDC
5008: a37d:             CALL DM.VISIBLE (STR$(DIR.INPUT.LOOP%),STATUS.TEXT.MSG$(60))!MJK
5009: a3c1: 
5010: a3c1:             DIR.LOOP%       = DIR.LOOP% + 1
5011: a3d0:             DIR.INPUT.LOOP% = DIR.INPUT.LOOP% + 1
5012: a3df: 
5013: a3df:         NEXT LOOP%
5014: a40a:     ENDIF
5015: a412: 
5016: a412: RETURN
5017: a422: 
5018: a422: \***********************************************************************
5019: a422: \*
5020: a422: \* SAVE.DIR.FIELD: This Subroutine will be used by Directory page when
5021: a422: \*                 Page up/down, F7/F8 or Enter key has been pressed.
5022: a422: \*                 It will help in saving the value of current page.
5023: a422: \*
5024: a422: \***********************************************************************
5025: a422: SAVE.DIR.FIELD:
5026: a432: 
5027: a432:     ! First input field
5028: a432:     DIR.INPUT.LOOP%  = DIR.INPUT.INDEX%
5029: a448:     SEL.INPUT.LOOP%  = 1        ! Initiating to 1 before use
5030: a459: 
5031: a459: 
5032: a459:     FOR LOOP% = 1 TO MAX.DIRECTORIES%
5033: a46d: 
5034: a46d:         ! Set depending on the current page
5035: a46d:         SEL.INPUT.LOOP% = ((PAGE.NO% - 1) * DIR.TO.SHOW%) + LOOP%
5036: a494: 
5037: a494:         !----------------------------------------------------------!
5038: a494:         ! Stored the field value using the index value created by  !
5039: a494:         ! the current page number                                  !
5040: a494:         !----------------------------------------------------------!
5041: a494:         SELECTED.DIR.ARRAY$(SEL.INPUT.LOOP%) = FIELD$(DIR.INPUT.LOOP%)
5042: a4d4: 
5043: a4d4:         ! Incrementing the input field index
5044: a4d4:         DIR.INPUT.LOOP% = DIR.INPUT.LOOP% + 1
5045: a4e3: 
5046: a4e3:     NEXT LOOP%
5047: a50d: 
5048: a50d: RETURN
5049: a51d: 
5050: a51d: \***********************************************************************
5051: a51d: \*
5052: a51d: \* PROCESS.DIR.INPUT: This Subroutine processes the directory input
5053: a51d: \*                    values.
5054: a51d: \*
5055: a51d: \***********************************************************************
5056: a51d: PROCESS.DIR.INPUT:
5057: a52d: 
5058: a52d:     ! Initiating the variables before use
5059: a52d:     SELECT.COUNT% = XRE.ZERO%
5060: a544:     NON.X.VALUES  = FALSE
5061: a55a: 
5062: a55a:     ! Checking all the input fields using array index
5063: a55a:     FOR LOOP% = 1 TO BKPSCRPT.INDEX%
5064: a56e: 
5065: a56e:         ! If input value is not equal to space
5066: a56e:         IF SELECTED.DIR.ARRAY$(LOOP%) <> XRE.SPACE$ THEN BEGIN
5067: a5a7:             ! If non X values are entered
5068: a5a7:             IF UCASE$(SELECTED.DIR.ARRAY$(LOOP%)) <> "X" THEN BEGIN
5069: a5e9:                 NON.X.VALUES = TRUE
5070: a601:             ENDIF ELSE BEGIN
5071: a609:                 ! Storing the X selection
5072: a609:                 SELECT.INDEX% = LOOP%
5073: a61f:             ENDIF
5074: a627:             ! Incrementing to check the Multiple selection
5075: a627:             SELECT.COUNT% = SELECT.COUNT% + 1
5076: a636:         ENDIF
5077: a63e:     NEXT LOOP%
5078: a668: 
5079: a668:     ! If more than 1 input is selected
5080: a668:     IF SELECT.COUNT% > 1 THEN BEGIN
5081: a67a:         FIELD$(1) = "'Multiple selections not allowed"
5082: a6a0:     ENDIF ELSE BEGIN
5083: a6a8:         ! If only one value is selected and no Non X values present
5084: a6a8:         IF SELECT.COUNT% = 1 AND NOT NON.X.VALUES THEN BEGIN            !MJK
5085: a6cd: 
5086: a6cd:             STATUS.MSG$ = BKPSCRPT.DIRECTORIES$(SELECT.INDEX%)       + \
5087: a703:                           " directory is selected for restore"
5088: a703:             GOSUB LOG.STATUS.MSG
5089: a715: 
5090: a715:             ! Setting screen number to display available days
5091: a715:             SCREEN% = DIRECTORY.DAY.SELECT.SCR%                         !CJK
5092: a72d: 
5093: a72d:         ENDIF ELSE BEGIN
5094: a735:             ! If error
5095: a735:             FIELD$(1) = SCREEN.TEXT.MSG$(21)                            !JDC
5096: a76b:         ENDIF
5097: a773:     ENDIF
5098: a77b: 
5099: a77b: RETURN
5100: a78b: 
5101: a78b: \***********************************************************************
5102: a78b: \*
5103: a78b: \* PROCESS.FILE.SCREEN: This Subroutine displays the FILE screen
5104: a78b: \*                      for XRESTORE.
5105: a78b: \*
5106: a78b: \***********************************************************************
5107: a78b: PROCESS.FILE.SCREEN:
5108: a79b: 
5109: a79b:     ! If File enter screen or day availability screen
5110: a79b:     WHILE SCREEN% = RESTORE.A.FILE.SCR% OR \                            !CJK
5111: a7a6:           SCREEN% = FILE.DAY.SELECT.SCR%                                !CJK
5112: a7a6: 
5113: a7a6:         IF SCREEN% = RESTORE.A.FILE.SCR% THEN BEGIN                     !CJK
5114: a7c1:             ! If screen is accessed using F3 or ESC
5115: a7c1:             IF PREVIOUS.KEY THEN BEGIN
5116: a7d3:                 CALL DM.SHOW.SCREEN (7, XRE.NULL$, 6, 6)
5117: a7f4:                 PREVIOUS.KEY = FALSE
5118: a80a:             ENDIF
5119: a812: 
5120: a812:             RET.KEY% = DM.PROCESS.SCREEN (2, 2, TRUE)
5121: a836: 
5122: a836:             IF (RET.KEY% = ESC.KEY%) OR (RET.KEY% = F3.KEY%) THEN BEGIN !CJK
5123: a86a: 
5124: a86a:                 ! Main screen
5125: a86a:                 SCREEN%      = DISPLAY.MAIN.SCR%                        !CJK
5126: a880:                 PREVIOUS.KEY = FALSE
5127: a898: 
5128: a898:             ENDIF ELSE BEGIN
5129: a8a0:                 IF RET.KEY% = ENTER.KEY% THEN BEGIN
5130: a8b8:                     ! Checks the entered file
5131: a8b8:                     GOSUB CHECK.ENTERED.FILE
5132: a8cc: 
5133: a8cc:                 ENDIF ELSE BEGIN
5134: a8d4:                     ! B001 Invalid key pressed
5135: a8d4:                     CALL DM.FOCUS ("1", STATUS.TEXT.ERROR$(20))         !IDC
5136: a8ff:                 ENDIF
5137: a907:             ENDIF
5138: a90f: 
5139: a90f:         ENDIF
5140: a917: 
5141: a917:         ! Checks the available restore days and display it
5142: a917:         IF SCREEN% = FILE.DAY.SELECT.SCR% THEN BEGIN                    !CJK
5143: a92f:             GOSUB CHECK.PROCESSED.FILE
5144: a941:         ENDIF
5145: a949:     WEND
5146: a980: 
5147: a980: RETURN
5148: a990: 
5149: a990: \***********************************************************************
5150: a990: \*
5151: a990: \* CHECK.ENTERED.FILE: This Subroutine checks the FILE input entered
5152: a990: \*                     in Restore File screen
5153: a990: \*
5154: a990: \***********************************************************************
5155: a990: CHECK.ENTERED.FILE:
5156: a9a0: 
5157: a9a0:     ! Storing the File name
5158: a9a0:     SELECT.FILE.NAME$ = FIELD$(2)
5159: a9ca: 
5160: a9ca:     ! Trim it
5161: a9ca:     CALL TRIM(SELECT.FILE.NAME$)
5162: a9e0: 
5163: a9e0:     ! Setting the initial values
5164: a9e0:     SLASH.POSITION% = XRE.ZERO%
5165: a9f7:     BEGIN.POSITION% = 1
5166: aa08:     SELECT.INDEX%   = XRE.ZERO%
5167: aa1f:     VALUE.EXISTS    = TRUE                                              !MJK
5168: aa35: 
5169: aa35:     !-------------------------------------------------------------!     !MJK
5170: aa35:     ! BKPSCRPT has directory values with backward slashes. Hence  !     !MJK
5171: aa35:     ! converting the forward slashes entered by USER to backward  !     !MJK
5172: aa35:     ! slashes for easiness of string comparison                   !     !MJK
5173: aa35:     !-------------------------------------------------------------!     !MJK
5174: aa35: 
5175: aa35:     ! To convert all forward slashes to backward slashes                !MJK
5176: aa35:     WHILE VALUE.EXISTS                                                  !MJK
5177: aa40:         ! Checks the forward slash position                             !MJK
5178: aa40:         SLASH.POSITION% = MATCH("/",SELECT.FILE.NAME$,BEGIN.POSITION%)  !MJK
5179: aa6a: 
5180: aa6a:         IF SLASH.POSITION% > XRE.ZERO% THEN BEGIN                       !MJK
5181: aa86:             SELECT.FILE.NAME$ = LEFT$(SELECT.FILE.NAME$,             \  !MJK
5182: aaef:                                       (SLASH.POSITION% - 1)) + "\" + \  !MJK
5183: aaef:                                 RIGHT$(SELECT.FILE.NAME$,            \  !MJK
5184: aaef:                                       (LEN(SELECT.FILE.NAME$) -      \  !MJK
5185: aaef:                                        SLASH.POSITION%))                !MJK
5186: aaef:             ! Move to next position to search next field                !MJK
5187: aaef:             BEGIN.POSITION% = SLASH.POSITION% + 1                       !MJK
5188: ab08:         ENDIF ELSE BEGIN                                                !MJK
5189: ab10:             VALUE.EXISTS = FALSE                                        !MJK
5190: ab26:         ENDIF                                                           !MJK
5191: ab2e:     WEND                                                                !MJK
5192: ab43: 
5193: ab43:     ! Reset the values
5194: ab43:     BEGIN.POSITION% = 1
5195: ab54:     SLASH.POSITION% = XRE.ZERO%
5196: ab6b:     VALUE.EXISTS    = TRUE
5197: ab81: 
5198: ab81:     ! Loop continues till last backward slash found
5199: ab81:     WHILE VALUE.EXISTS
5200: ab8c:         ! Checks the backward slash position
5201: ab8c:         SLASH.POSITION% = MATCH("\\",SELECT.FILE.NAME$,BEGIN.POSITION%) !MJK
5202: abb6: 
5203: abb6:         IF SLASH.POSITION% > XRE.ZERO% THEN BEGIN
5204: abcf:             ! Move to next position to search next field
5205: abcf:             BEGIN.POSITION% = SLASH.POSITION% + 1
5206: abe8:         ENDIF ELSE BEGIN
5207: abf0:             VALUE.EXISTS = FALSE
5208: ac06:         ENDIF
5209: ac0e:     WEND
5210: ac23: 
5211: ac23:     !--------------------------------------------------!
5212: ac23:     ! Checking the BKPSCRPT directories to see if the  !
5213: ac23:     ! entered file matches                             !
5214: ac23:     !--------------------------------------------------!
5215: ac23:     FOR INDEX% = 1 TO BKPSCRPT.INDEX%
5216: ac37:         IF BKPSCRPT.DIRECTORIES$(INDEX%) = UCASE$(MID$(            \
5217: ac85:                                            SELECT.FILE.NAME$,1,    \
5218: ac85:                                            (BEGIN.POSITION% - 1))) \
5219: ac85:         THEN BEGIN
5220: ac85:             SELECT.INDEX% = INDEX%
5221: ac9b:         ENDIF
5222: aca3:     NEXT INDEX%
5223: accd: 
5224: accd:     ! Storing the File name
5225: accd:     SELECTED.FILENAME$ = MID$(SELECT.FILE.NAME$,BEGIN.POSITION%,   \
5226: ad11:                              (LEN(SELECT.FILE.NAME$) -             \
5227: ad11:                               BEGIN.POSITION% + 1))
5228: ad11:     ! Trim spaces
5229: ad11:     CALL TRIM(SELECT.FILE.NAME$)
5230: ad27: 
5231: ad27:     ! If no matches found
5232: ad27:     IF SELECT.INDEX% = XRE.ZERO% THEN BEGIN
5233: ad40:         CALL DM.FOCUS ("3", "'Please enter a valid directory name")
5234: ad5b: 
5235: ad5b:     ! If no file name entered after the directory
5236: ad5b:     ENDIF ELSE BEGIN                                                    !NJK
5237: ad63:         IF (BEGIN.POSITION% - 1)   = LEN(SELECT.FILE.NAME$) OR  \       !NJK
5238: adb4:            LEN(SELECTED.FILENAME$) > 12 THEN BEGIN                      !NJK
5239: adb4:             SELECT.INDEX% = XRE.ZERO%
5240: adcb:             CALL DM.FOCUS ("3", "'Please enter a valid file name")
5241: ade5:         ENDIF ELSE BEGIN
5242: aded:         ! Valid Directory entered
5243: aded: 
5244: aded:             STATUS.MSG$ = UCASE$(SELECT.FILE.NAME$)           + \       !OJK
5245: ae22:                           " file is entered for restoration"            !OJK
5246: ae22:             GOSUB LOG.STATUS.MSG
5247: ae34:             ! Setting the screen to move to next screen
5248: ae34:             SCREEN% = FILE.DAY.SELECT.SCR%                              !CJK
5249: ae4a:         ENDIF
5250: ae52:     ENDIF                                                               !NJK
5251: ae5a: 
5252: ae5a: RETURN
5253: ae6a: 
5254: ae6a: \***********************************************************************
5255: ae6a: \*
5256: ae6a: \* CHECK.PROCESSED.FILE: This Subroutine displays the available days
5257: ae6a: \*                       for selected file backup. Also processes the
5258: ae6a: \*                       field for all key strokes.
5259: ae6a: \*
5260: ae6a: \***********************************************************************
5261: ae6a: CHECK.PROCESSED.FILE:
5262: ae7a: 
5263: ae7a:     GOSUB SHOW.FILE.RESTORE.DAYS
5264: ae8c: 
5265: ae8c:     GOSUB PROCESS.FILE.RESTORE
5266: ae9e: 
5267: ae9e: RETURN
5268: aeae: 
5269: aeae: \***********************************************************************
5270: aeae: \*
5271: aeae: \* SHOW.FILE.RESTORE.DAYS: This Subroutine display the available backup
5272: aeae: \*                         days for Entered file name
5273: aeae: \*
5274: aeae: \***********************************************************************
5275: aeae: SHOW.FILE.RESTORE.DAYS:
5276: aebe: 
5277: aebe:     ! Setting the Header and other variables used for screen display
5278: aebe:     SCR.HEADER$   = "RESTORE A FILE PROCESSING"                         !MJK
5279: aed5:     OPT.SELECTED$ = SCREEN.TEXT.MSG$(2) + SCREEN.TEXT.MSG$(3)           !JDC
5280: af19:     OPT.HEADER.1$ = "Please choose which day to restore the " + \
5281: af42:                     "file: " + SELECT.FILE.NAME$
5282: af42: 
5283: af42:     ! Display screen
5284: af42:     CALL DM.SHOW.SCREEN(2, SCR.HEADER$, 7, 7)
5285: af63: 
5286: af63:     ! Setting the XRE value which will be displayed in the Left corner
5287: af63:     SCREEN.NUM$ = "08"
5288: af7a: 
5289: af7a:     ! Dimensioning the array
5290: af7a:     DIM DAY.ARRAY$(ARRAY.LIMIT%)                                        !MJK
5291: afae:     DIM BKP.AVAIL.ARRAY$(ARRAY.LIMIT%)                                  !MJK
5292: afe2: 
5293: afe2:     ! Setting the default value before calling the Sub-routine          !MJK
5294: afe2:     FUNCTION.ERROR.NOT.EXIST = 0                                        !IDC
5295: aff2: 
5296: aff2:     FIRST.FILE$  = PRIMARY.ARCHIVED.NAMES$(SELECT.INDEX%)               !MJK
5297: b021:     SECOND.FILE$ = SECONDARY.ARCHVD.NAMES$(SELECT.INDEX%)               !IDC
5298: b050:     GOSUB GET.BKP.DETAILS                                               !IDC
5299: b062: 
5300: b062:     ! Setting the screen number
5301: b062:     CALL DM.NAME (2, "SCREEN.NUM$", SCREEN.NUM$)
5302: b0a1: 
5303: b0a1:     ! Initialising the output fields in the screen
5304: b0a1:     ! before processing the screen
5305: b0a1:     !--------------------------------------------
5306: b0a1:     CALL DM.NAME (48, "OPT.HEADER.1$", OPT.HEADER.1$)
5307: b0e0: 
5308: b0e0:     ! If backups are available
5309: b0e0:     IF VALUE.INDEX% <> XRE.ZERO% AND FUNCTION.ERROR.NOT.EXIST THEN BEGIN!EJK
5310: b109: 
5311: b109:         ! Enabling the DAY and DD/MM string
5312: b109:         CALL DM.VISIBLE ("75", STATUS.TEXT.MSG$(61))                    !IDC
5313: b134:         CALL DM.VISIBLE ("76", STATUS.TEXT.MSG$(61))                    !IDC
5314: b15f: 
5315: b15f:         ! Setting other relevant string
5316: b15f:         CALL DM.NAME (50, "OPT.SELECTED$", OPT.SELECTED$)
5317: b19e: 
5318: b19e:         ! Setting the first value of the fields before populating it
5319: b19e:         DAY.LOOP%   = DAY.INDEX%                                        !MJK
5320: b1b5:         DD.MM.LOOP% = DD.MM.INDEX%                                      !MJK
5321: b1cc:         INPUT.LOOP% = INPUT.INDEX%                                      !MJK
5322: b1e3: 
5323: b1e3:         ! Retrieving the values and storing in Field$
5324: b1e3:         FOR INDEX% = 1 TO VALUE.INDEX%
5325: b1f7: 
5326: b1f7:             ! DAY value and its visibility
5327: b1f7:             FIELD$(DAY.LOOP%) = DAY.ARRAY$(INDEX%)
5328: b237:             CALL DM.VISIBLE (STR$(DAY.LOOP%), STATUS.TEXT.MSG$(61))     !IDC
5329: b27b: 
5330: b27b:             ! DD/MM value
5331: b27b:             FIELD$(DD.MM.LOOP%) = RIGHT$(BKP.AVAIL.ARRAY$(INDEX%),2) + \!GJK
5332: b2f9:                                   "/"                                + \
5333: b2f9:                                   LEFT$(BKP.AVAIL.ARRAY$(INDEX%),2)     !GJK
5334: b2f9: 
5335: b2f9:             ! Setting a space for input values
5336: b2f9:             FIELD$(INPUT.LOOP%) = XRE.SPACE$
5337: b328: 
5338: b328:             ! Setting the visibility for DD/MM and input
5339: b328:             CALL DM.VISIBLE (STR$(DD.MM.LOOP%), STATUS.TEXT.MSG$(61))   !IDC
5340: b36c:             CALL DM.VISIBLE (STR$(INPUT.LOOP%), STATUS.TEXT.MSG$(61))   !IDC
5341: b3b0: 
5342: b3b0:             ! Incrementing to move to the next field
5343: b3b0:             DAY.LOOP%   = DAY.LOOP%   + 1
5344: b3bf:             DD.MM.LOOP% = DD.MM.LOOP% + 1
5345: b3ce:             INPUT.LOOP% = INPUT.LOOP% + 1
5346: b3dd: 
5347: b3dd:         NEXT INDEX%
5348: b40a: 
5349: b40a:     ENDIF ELSE BEGIN                                                    !NJK
5350: b412:         IF FUNCTION.ERROR.NOT.EXIST THEN BEGIN                          !NJK
5351: b424:             FIELD$(1) = STATUS.TEXT.ERROR$(21)                          !IDC
5352: b45c:         ENDIF ELSE BEGIN                                                !EJK
5353: b464:             FIELD$(1) = SCREEN.TEXT.MSG$(7) + SCREEN.TEXT.MSG$(8)       !MJK
5354: b4b4:         ENDIF
5355: b4bc:     ENDIF                                                               !NJK
5356: b4c4: 
5357: b4c4: RETURN
5358: b4d4: 
5359: b4d4: \***********************************************************************
5360: b4d4: \*
5361: b4d4: \* PROCESS.FILE.RESTORE: This Subroutine helps in processing the input
5362: b4d4: \*                       values entered in File restore day selection
5363: b4d4: \*                       screen.
5364: b4d4: \*
5365: b4d4: \***********************************************************************
5366: b4d4: PROCESS.FILE.RESTORE:
5367: b4e4: 
5368: b4e4:     ! Handles restore day selection and confirmation screen
5369: b4e4:     WHILE SCREEN% = FILE.DAY.SELECT.SCR% OR \                           !CJK
5370: b4ef:           SCREEN% = FILE.DIR.AND.DIST.SCR%                              !CJK
5371: b4ef: 
5372: b4ef:         IF SCREEN% = FILE.DAY.SELECT.SCR% THEN BEGIN                    !CJK
5373: b50a:             ! If screen is accessed using F3 or ESC
5374: b50a:             IF PREVIOUS.KEY THEN BEGIN
5375: b51c:                 GOSUB SHOW.FILE.RESTORE.DAYS
5376: b52e:                 PREVIOUS.KEY = FALSE
5377: b544:             ENDIF
5378: b54c: 
5379: b54c:             RET.KEY% = DM.PROCESS.SCREEN (2, 105, TRUE)
5380: b570: 
5381: b570:             IF (RET.KEY% = ESC.KEY%) OR (RET.KEY% = F3.KEY%) THEN BEGIN !CJK
5382: b5a4: 
5383: b5a4:                 ! Setting the screen number and previous key
5384: b5a4:                 PREVIOUS.KEY = TRUE
5385: b5ba:                 SCREEN% = RESTORE.A.FILE.SCR%                           !CJK
5386: b5d3:             ENDIF ELSE BEGIN                                            !MJK
5387: b5db:                 IF VALUE.INDEX% = XRE.ZERO% THEN BEGIN                  !MJK
5388: b5f4:                     CALL DM.FOCUS ("1", STATUS.TEXT.ERROR$(21) + \      !IDC
5389: b644:                                    STATUS.TEXT.MSG$(58))                !IDC
5390: b644:                 ENDIF ELSE BEGIN
5391: b64c:                     IF RET.KEY% = ENTER.KEY% THEN BEGIN
5392: b664: 
5393: b664:                         ! Check the entry in day selection screen
5394: b664:                         SCREEN.NUM% = FILE.DIR.AND.DIST.SCR%            !IDC
5395: b67a:                         GOSUB CHECK.DAY.SELECTION                       !IDC
5396: b68c: 
5397: b68c:                         ! If any error in function, set same screen
5398: b68c:                         IF NOT FUNCTION.ERROR.NOT.EXIST THEN BEGIN      !EJK
5399: b69e:                             SCREEN% = FILE.DAY.SELECT.SCR%              !EJK
5400: b6b4:                         ENDIF                                           !EJK
5401: b6be: 
5402: b6be:                     ENDIF ELSE BEGIN
5403: b6c6:                         ! B001 Invalid key pressed
5404: b6c6:                         CALL DM.FOCUS ("1", STATUS.TEXT.ERROR$(20))     !IDC
5405: b6f1:                     ENDIF
5406: b6f9:                 ENDIF                                                   !MJK
5407: b701:             ENDIF
5408: b709: 
5409: b709:         ENDIF
5410: b711: 
5411: b711:         ! Confirmation screen
5412: b711:         IF SCREEN% = FILE.DIR.AND.DIST.SCR% THEN BEGIN                  !CJK
5413: b729: 
5414: b729:             ! Setting the Distribution type 3 as default
5415: b729:             FSEL$ = "3"
5416: b740:             ! Display the screen and process it
5417: b740:             GOSUB CHECK.AND.DISPLAY.FILE
5418: b752: 
5419: b752:         ENDIF
5420: b75a:     WEND
5421: b791: 
5422: b791: RETURN
5423: b7a1: 
5424: b7a1: \***********************************************************************
5425: b7a1: \*
5426: b7a1: \* CHECK.AND.DISPLAY.FILE: This Subroutine checks the archived file for
5427: b7a1: \*                         for the selected day. If file exist in the
5428: b7a1: \*                         archive file, the screen will be processed
5429: b7a1: \*                         for confirmation, else an error message will
5430: b7a1: \*                         be presented.
5431: b7a1: \*
5432: b7a1: \***********************************************************************
5433: b7a1: CHECK.AND.DISPLAY.FILE:
5434: b7b1: 
5435: b7b1:     STATUS.MSG$ = BKP.DATE.ARRAY$(SEL.INDEX%) + STATUS.TEXT.MSG$(24) + \!JDC
5436: b7fe:                   " for restoration"
5437: b7fe:     GOSUB LOG.STATUS.MSG
5438: b810: 
5439: b810:     ! Display the confirmation screen
5440: b810:     CALL DM.SHOW.SCREEN(8, XRE.NULL$, 9, 9)                             !KDC
5441: b831: 
5442: b831:     ! Set the field for distribution type
5443: b831:     CALL DM.NAME (4, "FSEL$", FSEL$)
5444: b870: 
5445: b870:     ! Validation the selection is between 1 and 5
5446: b870:     !-------------------------------------------------
5447: b870:     CALL DM.VALID   ("FSEL$", "FSEL$ >= 1 AND FSEL$ <= 5")              !MJK
5448: b888:     CALL DM.MESSAGE ("FSEL$", "'Invalid Distribution type")
5449: b8a0: 
5450: b8a0:     ! Display the status when the file check is going to happen
5451: b8a0:     CALL DM.STATUS ("'Processing - Please wait...")
5452: b8b4: 
5453: b8b4:     ! Populating the File name and the directory
5454: b8b4:     FIELD$(2) = UCASE$(SELECTED.FILENAME$)
5455: b8e3:     FIELD$(3) = BKPSCRPT.DIRECTORIES$(SELECT.INDEX%)
5456: b91e: 
5457: b91e:     RESTORE.STATUS = FALSE
5458: b934: 
5459: b934:     ! Checking the file presence in the selected archive file
5460: b934:     GOSUB CHECK.THE.FILE.PRESENCE
5461: b946: 
5462: b946:     ! This field will be notified if file present
5463: b946:     FIELD$(1) = "'Please verify and confirm for restore"
5464: b969: 
5465: b969:         ! If file not exist
5466: b969:         IF NOT RESTORE.STATUS THEN BEGIN
5467: b97e: 
5468: b97e:             ! Making the input filed as Read only
5469: b97e:             CALL DM.RO.FIELD(3)
5470: b98f:             CALL DM.RO.FIELD(4)
5471: b9a0: 
5472: b9a0:             ! Setting the error to display
5473: b9a0:             FIELD$(1) = STATUS.TEXT.MSG$(56)                            !IDC
5474: b9d6: 
5475: b9d6:             STATUS.MSG$ = STATUS.TEXT.MSG$(41) + STATUS.TEXT.MSG$(55)   !MJK
5476: ba1a:             GOSUB LOG.STATUS.MSG
5477: ba2c: 
5478: ba2c:         ENDIF
5479: ba34: 
5480: ba34:     ! Handles the confirmation and restoration screen
5481: ba34:     WHILE SCREEN% = FILE.DIR.AND.DIST.SCR% OR \                         !CJK
5482: ba3f:           SCREEN% = FILE.CONFIRMATION.SCR%                              !CJK
5483: ba3f: 
5484: ba3f:         IF SCREEN% = FILE.DIR.AND.DIST.SCR% THEN BEGIN                  !CJK
5485: ba5a: 
5486: ba5a:             ! If screen is accessed by F3 or ESC
5487: ba5a:             IF PREVIOUS.KEY THEN BEGIN
5488: ba6f: 
5489: ba6f:                 ! Display screen
5490: ba6f:                 CALL DM.SHOW.SCREEN(8, XRE.NULL$, 9, 9)                 !KDC
5491: ba90: 
5492: ba90:                 ! Setting the distribution type 3 as default            !MJK
5493: ba90:                 FSEL$ = "3"
5494: baa7:                 CALL DM.NAME (4, "FSEL$", FSEL$)
5495: bae6: 
5496: bae6:                 ! Validation the selection is between 1 and 5
5497: bae6:                 !-------------------------------------------------
5498: bae6:                 CALL DM.VALID ("FSEL$", "FSEL$ >= 1 AND FSEL$ <= 5")
5499: bafe:                 CALL DM.MESSAGE ("FSEL$", "'Invalid Distribution type")
5500: bb16: 
5501: bb16:                 ! Setting the File and directory value in field
5502: bb16:                 FIELD$(2) = UCASE$(SELECTED.FILENAME$)
5503: bb45:                 FIELD$(3) = DIRECT.TO.RESTORE$
5504: bb6f: 
5505: bb6f:                 ! Setting space for status
5506: bb6f:                 FIELD$(1) = XRE.SPACE$
5507: bb99: 
5508: bb99:                 ! Reset the previous key
5509: bb99:                 PREVIOUS.KEY = FALSE
5510: bbaf: 
5511: bbaf:             ENDIF
5512: bbb7: 
5513: bbb7:             RET.KEY% = DM.PROCESS.SCREEN (3, 4, TRUE)
5514: bbdb: 
5515: bbdb:             IF (RET.KEY% = ESC.KEY%) OR  (RET.KEY% = F3.KEY%) THEN BEGIN
5516: bc0f: 
5517: bc0f:                 ! Setting the screen number for F3 or ESC
5518: bc0f:                 SCREEN%      = FILE.DAY.SELECT.SCR%                     !CJK
5519: bc25:                 PREVIOUS.KEY = TRUE
5520: bc3e: 
5521: bc3e:             ENDIF ELSE BEGIN                                            !MJK
5522: bc46:                 IF NOT RESTORE.STATUS THEN BEGIN                        !MJK
5523: bc58:                     ! If selected file not exist in the archive
5524: bc58:                     FIELD$(1) = STATUS.TEXT.MSG$(57)                    !OJK
5525: bc90:                 ENDIF ELSE BEGIN                                        !MJK
5526: bc98:                     IF RET.KEY% = ENTER.KEY% THEN BEGIN                 !MJK
5527: bcb0:                     !--------------------------------------------------!
5528: bcb0:                     ! Checks the entered value again before proceeding !
5529: bcb0:                     ! with the file restore                            !
5530: bcb0:                     !--------------------------------------------------!
5531: bcb0:                         GOSUB RECHECK.DIRECTORY
5532: bcc4:                     ENDIF ELSE BEGIN
5533: bccc:                         CALL DM.FOCUS ("1", STATUS.TEXT.ERROR$(20))     !IDC
5534: bcf7:                     ENDIF                                               !MJK
5535: bcff:                 ENDIF                                                   !MJK
5536: bd07:             ENDIF
5537: bd0f:         ENDIF
5538: bd17: 
5539: bd17:         ! File restoration screen
5540: bd17:         IF SCREEN% = FILE.CONFIRMATION.SCR% THEN BEGIN                  !CJK
5541: bd2f:             GOSUB CONFIRM.AND.RESTORE.FILE
5542: bd41:         ENDIF
5543: bd49:     WEND
5544: bd80: 
5545: bd80: RETURN
5546: bd90: 
5547: bd90: \***********************************************************************
5548: bd90: \*
5549: bd90: \* CHECK.THE.FILE.PRESENCE: This Subroutine checks the selected file
5550: bd90: \*                          presence in the archive file.
5551: bd90: \*
5552: bd90: \***********************************************************************
5553: bd90: CHECK.THE.FILE.PRESENCE:
5554: bda0: 
5555: bda0:     ! Date to restore
5556: bda0:     FULL.TO.MOVING.DATE$ = BKP.DATE.ARRAY$(SEL.INDEX%)                  !IDC
5557: bdcf: 
5558: bdcf:     GOSUB GET.FILE.EXTENSION                                            !IDC
5559: bde1:     MDD.DATE$ = EXTENSION$                                              !IDC
5560: bdff: 
5561: bdff:     ! Setting the Backup files based on the 1st field which is drive
5562: bdff:     IF LEFT$(FILENAME$,1) = "D" THEN BEGIN
5563: be37:         ! IMG and ALT directory for C drive
5564: be37:         BKP.FILENAME.IMG$ = C.BKP.IMG$ + FILENAME$ + "." + MDD.DATE$    !MJK
5565: be72:         BKP.FILENAME.ALT$ = C.BKP.ALT$ + FILENAME$ + "." + MDD.DATE$    !MJK
5566: bead:         ! BKPFAIL prefix                                                !MJK
5567: bead:         BKPFAIL.PREFIX$   = C.BKP.IMG$ + "BKPFAILD."                    !MJK
5568: bed5:     ENDIF ELSE BEGIN
5569: bedd:         ! IMG and ALT directory for D drive
5570: bedd:         BKP.FILENAME.IMG$ = D.BKP.IMG$ + FILENAME$ + "." + MDD.DATE$    !MJK
5571: bf18:         BKP.FILENAME.ALT$ = D.BKP.ALT$ + FILENAME$ + "." + MDD.DATE$    !MJK
5572: bf53:         ! BKPFAIL prefix                                                !MJK
5573: bf53:         BKPFAIL.PREFIX$   = D.BKP.IMG$ + "BKPFAILC."                    !MJK
5574: bf78:     ENDIF
5575: bf80: 
5576: bf80:     ! Current BKPFAIL file
5577: bf80:     BKPFAIL.CURR.FILE$ = BKPFAIL.PREFIX$ + MDD.DATE$                    !MJK
5578: bfac: 
5579: bfac:     VALUE.EXISTS   = FALSE
5580: bfc2:     RESTORE.STATUS = FALSE
5581: bfd8: 
5582: bfd8:     ! Getting the file details of the Directory archive
5583: bfd8:     IF FUNC.FILE.EXISTS(BKP.FILENAME.IMG$) THEN BEGIN
5584: bff9:         CALL OSSHELL(ADXZUDIR.FILE.NAME$ + " -l "                    + \
5585: c04c:                      BKP.FILENAME.IMG$ + " > " + DIR.OUT$            + \
5586: c04c:                      " >>* " + DIR.OUT$ )
5587: c04c:         VALUE.EXISTS = 1
5588: c05c:         STATUS.MSG$  = "Checking the archive file " + BKP.FILENAME.IMG$ !MJK
5589: c084:     ENDIF ELSE BEGIN                                                    !NJK
5590: c08c:         IF FUNC.FILE.EXISTS(BKP.FILENAME.ALT$) THEN BEGIN               !NJK
5591: c0ad:             CALL OSSHELL(ADXZUDIR.FILE.NAME$ + " -l "                + \
5592: c100:                          BKP.FILENAME.ALT$ + " > " + DIR.OUT$        + \
5593: c100:                          " >>* " + DIR.OUT$)
5594: c100:             VALUE.EXISTS = 2
5595: c110:             STATUS.MSG$  = "Checking the archive file " + \             !NJK
5596: c135:                             BKP.FILENAME.ALT$                           !NJK
5597: c135:         ENDIF
5598: c13d:     ENDIF                                                               !NJK
5599: c145: 
5600: c145:     GOSUB LOG.STATUS.MSG
5601: c157: 
5602: c157:     !------------------------------------------!
5603: c157:     ! If BKPFAIL file present, check to see if !
5604: c157:     ! that has the selected file record in it  !
5605: c157:     !------------------------------------------!
5606: c157:     IF FUNC.FILE.EXISTS(BKPFAIL.CURR.FILE$) THEN BEGIN
5607: c178: 
5608: c178:         DIR.FILE.RC% = FUNC.OPEN.SEQUENTIAL.FILE( BKPFAIL.CURR.FILE$ )  !NJK
5609: c1a2: 
5610: c1a2:         ! If file open unsuccessful
5611: c1a2:         IF DIR.FILE.RC% <= XRE.ZERO% THEN BEGIN
5612: c1c0:             ! Setting NULL to avoid file read
5613: c1c0:             DIR.VALUE$ = XRE.NULL$
5614: c1de:             DIR.OPEN   = FALSE
5615: c1f6:         ENDIF ELSE BEGIN
5616: c1fe:             DIR.OPEN   = TRUE
5617: c214:             DIR.VALUE$ = XRE.SPACE$
5618: c232:         ENDIF
5619: c23a: 
5620: c23a:         !-------------------------------------------------------------!
5621: c23a:         ! Reading the file till the EOF file reached. C file function !
5622: c23a:         ! returns NULL when EOF reached or read error                 ! !FDC
5623: c23a:         !-------------------------------------------------------------!
5624: c23a:         WHILE LEN(DIR.VALUE$) <> XRE.ZERO%
5625: c245:             DIR.VALUE$ = FUNC.READ.SEQUENTIAL.FILE( DIR.FILE.RC% )      !NJK
5626: c268: 
5627: c268:             ! Checking the comma position
5628: c268:             COMMA.POSITION% = MATCH(COMMA.VALUE$,DIR.VALUE$,1)
5629: c294: 
5630: c294:             ! If comma found
5631: c294:             IF COMMA.POSITION% <> XRE.ZERO% THEN BEGIN
5632: c2b0: 
5633: c2b0:                 ! Storing the failed file
5634: c2b0:                 FAILED.FILE$ = LEFT$(DIR.VALUE$,(COMMA.POSITION% - 1))
5635: c2de: 
5636: c2de:                 ! If BKPFAIL file matches with current file
5637: c2de:                 IF UCASE$(FAILED.FILE$) = UCASE$(SELECT.FILE.NAME$) \
5638: c31b:                 THEN BEGIN
5639: c31b:                     VALUE.EXISTS   = 3
5640: c32b:                     RESTORE.STATUS = TRUE
5641: c341:                 ENDIF
5642: c349:             ENDIF
5643: c351:         WEND
5644: c379: 
5645: c379:         ! Closing File
5646: c379:         IF DIR.OPEN THEN BEGIN
5647: c38b:             CALL FUNC.CLOSE.FILE( DIR.FILE.RC% )                        !NJK
5648: c3b4:             DIR.OPEN = FALSE
5649: c3ca:         ENDIF
5650: c3d2: 
5651: c3d2:     ENDIF
5652: c3da: 
5653: c3da:     ! If archive file details are STDOUT to DIR.OUT file
5654: c3da:     IF VALUE.EXISTS = 1 OR VALUE.EXISTS = 2 THEN BEGIN
5655: c407: 
5656: c407:         DIR.FILE.RC% = FUNC.OPEN.SEQUENTIAL.FILE( DIR.OUT$ )            !NJK
5657: c431: 
5658: c431:         ! If file open unsuccessful
5659: c431:         IF DIR.FILE.RC% <= XRE.ZERO% THEN BEGIN
5660: c44f:             DIR.OPEN    = FALSE                                         !MJK
5661: c465:             STATUS.MSG$ = STATUS.TEXT.ERROR$(2)                         !JDC
5662: c48f:             GOSUB LOG.STATUS.MSG
5663: c4a1:             ! Setting NULL to avoid file read
5664: c4a1:             DIR.VALUE$ = XRE.NULL$
5665: c4c1:         ENDIF ELSE BEGIN
5666: c4c9:             DIR.OPEN   = TRUE
5667: c4df:             DIR.VALUE$ = XRE.SPACE$
5668: c4fd:         ENDIF
5669: c505: 
5670: c505:         ! Reading the file till it reached the EOF or read error        !FDC
5671: c505:         WHILE LEN(DIR.VALUE$) <> XRE.ZERO%
5672: c510:             DIR.VALUE$ = FUNC.READ.SEQUENTIAL.FILE( DIR.FILE.RC% )      !NJK
5673: c533: 
5674: c533:             ! Compare the file names from DIR.OUT with Restore file
5675: c533:             IF LEN(DIR.VALUE$) > 29 THEN BEGIN ! If length is > 29
5676: c554:                 IF MID$(DIR.VALUE$,30,(LEN(DIR.VALUE$) - 29)) = \
5677: c5a8:                    UCASE$(SELECTED.FILENAME$) THEN BEGIN
5678: c5a8:                     ! If file found enable the flag
5679: c5a8:                     RESTORE.STATUS = TRUE
5680: c5be:                     ! To break the WHILE loop                           !OJK
5681: c5be:                     DIR.VALUE$     = XRE.NULL$                          !OJK
5682: c5dc:                 ENDIF
5683: c5e4:             ENDIF
5684: c5ec:         WEND
5685: c614: 
5686: c614:         ! Closing File
5687: c614:         IF DIR.OPEN THEN BEGIN
5688: c626:             CALL FUNC.CLOSE.FILE( DIR.FILE.RC% )                        !NJK
5689: c64f:             DIR.OPEN = FALSE
5690: c665:         ENDIF
5691: c66d:     ENDIF
5692: c675: 
5693: c675: RETURN
5694: c685: 
5695: c685: \***********************************************************************
5696: c685: \*
5697: c685: \* RECHECK.DIRECTORY: This Subroutine checks the value entered in the
5698: c685: \*                    confirmation screen.
5699: c685: \*
5700: c685: \***********************************************************************
5701: c685: RECHECK.DIRECTORY:
5702: c695: 
5703: c695:     ! Storing the Directory value
5704: c695:     DIRECT.TO.RESTORE$ = FIELD$(3)
5705: c6bf: 
5706: c6bf:     ! Trim it
5707: c6bf:     CALL TRIM(DIRECT.TO.RESTORE$)
5708: c6d5: 
5709: c6d5:     ! Checking whether the Directory is under C or D drive
5710: c6d5:     IF UCASE$(LEFT$(DIRECT.TO.RESTORE$,3)) <> "C:\" AND \
5711: c772:        UCASE$(LEFT$(DIRECT.TO.RESTORE$,3)) <> "D:\" THEN BEGIN
5712: c772: 
5713: c772:         CALL DM.STATUS ("'Incorrect directory value. Please use " + \
5714: c798:                         "C/D drive. Use backward slash (\)")
5715: c798: 
5716: c798:     ENDIF ELSE BEGIN                                                    !NJK
5717: c7a0:         ! Maximum allowed length for a directory value                  !OJK
5718: c7a0:         IF LEN(DIRECT.TO.RESTORE$) > 12 THEN BEGIN                      !OJK
5719: c7be:             CALL DM.STATUS ("'Directory length is too high")            !OJK
5720: c7d5:         ! Checking whether any empty spaces in directory name           !OJK
5721: c7d5:         ENDIF ELSE IF MATCH(" ",DIRECT.TO.RESTORE$,1)  THEN BEGIN       !OJK
5722: c7f7:             CALL DM.STATUS ("'Directory name should not contain" + \    !OJK
5723: c81d:                             " any spaces in between")                   !OJK
5724: c81d:         ! Making sure that invalid characters are not allowed           !OJK
5725: c81d:         ENDIF ELSE IF MATCH("""",DIRECT.TO.RESTORE$,1) OR \             !OJK
5726: c969:                       MATCH("\!",DIRECT.TO.RESTORE$,1) OR \             !OJK
5727: c969:                       MATCH("*",DIRECT.TO.RESTORE$,1)  OR \             !OJK
5728: c969:                       MATCH(".",DIRECT.TO.RESTORE$,1)  OR \             !OJK
5729: c969:                       MATCH("+",DIRECT.TO.RESTORE$,1)  OR \             !OJK
5730: c969:                       MATCH(",",DIRECT.TO.RESTORE$,1)  OR \             !OJK
5731: c969:                       MATCH("<",DIRECT.TO.RESTORE$,1)  OR \             !OJK
5732: c969:                       MATCH(">",DIRECT.TO.RESTORE$,1)  OR \             !OJK
5733: c969:                       MATCH("[",DIRECT.TO.RESTORE$,1)  OR \             !OJK
5734: c969:                       MATCH("]",DIRECT.TO.RESTORE$,1)  OR \             !OJK
5735: c969:                       MATCH("\?",DIRECT.TO.RESTORE$,1) THEN BEGIN       !OJK
5736: c969:             CALL DM.STATUS ("'Special/Operational characters are not" + \OJK
5737: c98e:                             " recommended in Directory name")           !OJK
5738: c98e:         ENDIF ELSE BEGIN
5739: c996: 
5740: c996:         ! If all the fields are fine, proceed to the restoration
5741: c996:             SCREEN% = FILE.CONFIRMATION.SCR%                            !CJK
5742: c9ac:             STATUS.MSG$ = DIRECT.TO.RESTORE$                         + \!NJK
5743: c9d5:                           " directory is selected " + "for file restore"!NJK
5744: c9d5:             GOSUB LOG.STATUS.MSG
5745: c9e7:         ENDIF
5746: c9ef:     ENDIF                                                               !NJK
5747: c9f7: 
5748: c9f7: RETURN
5749: ca07: 
5750: ca07: \***********************************************************************
5751: ca07: \*
5752: ca07: \* CONFIRM.AND.RESTORE.FILE: This Subroutine display the file restore
5753: ca07: \*                           confirmation screen and then process it
5754: ca07: \*
5755: ca07: \***********************************************************************
5756: ca07: CONFIRM.AND.RESTORE.FILE:
5757: ca17: 
5758: ca17:     ! Display the screen
5759: ca17:     GOSUB DISPLAY.FILE.CONFIRMATION
5760: ca29: 
5761: ca29:     ! For Confirmation screen and final restoration screen
5762: ca29:     WHILE SCREEN% = FILE.CONFIRMATION.SCR% OR \                         !CJK
5763: ca34:           SCREEN% = FILE.PROCESS.SCR%                                   !CJK
5764: ca34: 
5765: ca34:         IF SCREEN% = FILE.CONFIRMATION.SCR% THEN BEGIN                  !CJK
5766: ca4f:             ! If screen accessed using F3 or ESC
5767: ca4f:             IF PREVIOUS.KEY THEN BEGIN
5768: ca61:                 GOSUB DISPLAY.FILE.CONFIRMATION
5769: ca73:                 PREVIOUS.KEY = FALSE
5770: ca89:             ENDIF
5771: ca91: 
5772: ca91:             RET.KEY% = DM.PROCESS.SCREEN (5, 5, FALSE)
5773: cab5: 
5774: cab5:             IF (RET.KEY% = ESC.KEY%) OR (RET.KEY% = F3.KEY%) THEN BEGIN !CJK
5775: cae9: 
5776: cae9:                 ! Previous screen
5777: cae9:                 SCREEN%      = FILE.DIR.AND.DIST.SCR%                   !CJK
5778: caff:                 PREVIOUS.KEY = TRUE
5779: cb18: 
5780: cb18:             ENDIF ELSE IF RET.KEY% = ENTER.KEY% THEN BEGIN
5781: cb33:                 ! If the input is N, go back to the previous screen
5782: cb33:                 IF UCASE$(FIELD$(5)) = "N" THEN BEGIN
5783: cb70:                     SCREEN%      = FILE.DIR.AND.DIST.SCR%               !CJK
5784: cb86:                     PREVIOUS.KEY = TRUE
5785: cb9f:                 ! If Y is entered
5786: cb9f:                 ENDIF ELSE IF UCASE$(FIELD$(5)) = "Y" THEN BEGIN
5787: cbdc:                     ! Setting the screen number for restoration
5788: cbdc:                     SCREEN% = FILE.PROCESS.SCR%                         !CJK
5789: cbf4:                 ENDIF ELSE BEGIN
5790: cbfc:                     ! Invalid entry
5791: cbfc:                     CALL DM.STATUS ("'Incorrect value entered. " + \
5792: cc1f:                                    "Enter Y or N ")
5793: cc1f:                 ENDIF
5794: cc29: 
5795: cc29:             ENDIF ELSE BEGIN
5796: cc31:                 CALL DM.FOCUS ("1", STATUS.TEXT.ERROR$(20))             !IDC
5797: cc5c:             ENDIF
5798: cc64:         ENDIF
5799: cc6c: 
5800: cc6c:         ! File restoration screen
5801: cc6c:         IF SCREEN% = FILE.PROCESS.SCR% THEN BEGIN                       !CJK
5802: cc84:             GOSUB FILE.RESTORATION
5803: cc96:         ENDIF
5804: cc9e:     WEND
5805: ccd5: 
5806: ccd5: RETURN
5807: cce5: 
5808: cce5: \***********************************************************************
5809: cce5: \*
5810: cce5: \* DISPLAY.FILE.CONFIRMATION: This Subroutine displays the confirmation
5811: cce5: \*                            screen for file restoration.
5812: cce5: \*
5813: cce5: \***********************************************************************
5814: cce5: DISPLAY.FILE.CONFIRMATION:
5815: ccf5: 
5816: ccf5:     CALL DM.SHOW.SCREEN(9, XRE.NULL$, 10, 10)                           !KDC
5817: cd16: 
5818: cd16:     ! Setting the required fields to display
5819: cd16:     FIELD$(3) = "You are about to restore "                          + \
5820: cd7a:                 UCASE$(SELECTED.FILENAME$) + " to "                  + \
5821: cd7a:                 UCASE$(DIRECT.TO.RESTORE$) + " with the"
5822: cd7a: 
5823: cd7a:     FIELD$(4) = "distribution type of " + FSEL$
5824: cdab: 
5825: cdab: RETURN
5826: cdbb: 
5827: cdbb: \***********************************************************************
5828: cdbb: \*
5829: cdbb: \* FILE.RESTORATION: This Subroutine does the restoration of the file.
5830: cdbb: \*                   It uses ADXUNZIP to extract the file. If there is  !OJK
5831: cdbb: \*                   any extraction error then file will be extracted   !OJK
5832: cdbb: \*                   to C:/TEMP.                                        !OJK
5833: cdbb: \*
5834: cdbb: \***********************************************************************
5835: cdbb: FILE.RESTORATION:
5836: cdcb: 
5837: cdcb:     CALL DM.SHOW.SCREEN(10, XRE.NULL$, XRE.ZERO%, XRE.ZERO%)            !GJK
5838: cdfa: 
5839: cdfa:     !------------------------------------------!
5840: cdfa:     ! Display the processing notification, as  !
5841: cdfa:     ! the restore might take longer duration   !
5842: cdfa:     !------------------------------------------!
5843: cdfa:     CALL DM.STATUS ("'Processing - Please wait...")
5844: ce0e:     DIRECTORY.CREATE = TRUE                                             !HJK
5845: ce24: 
5846: ce24:     ! If the directory not exists, create it
5847: ce24:     IF FUNC.DIR.NOT.EXISTS(DIRECT.TO.RESTORE$) THEN BEGIN
5848: ce45: 
5849: ce45:         ! Trim the last slash found to avoid error using MKDIR
5850: ce45:         CALL TRIM   (DIRECT.TO.RESTORE$)
5851: ce5b:         CALL RTRIMC (DIRECT.TO.RESTORE$, ASC("/"))
5852: ce8e:         CALL RTRIMC (DIRECT.TO.RESTORE$, ASC("\\"))
5853: cec1: 
5854: cec1:         CALL OSSHELL("MKDIR " + DIRECT.TO.RESTORE$ + " >  " + \         !HJK
5855: cf09:                      DIR.OUT$ + " >>* "  + DIR.OUT$ )
5856: cf09:         STATUS.MSG$ = DIRECT.TO.RESTORE$ + " directory is created"
5857: cf2e: ! HJK Starting block                                                    !HJK
5858: cf2e:         DIR.FILE.RC% = FUNC.OPEN.SEQUENTIAL.FILE( DIR.OUT$ )            !NJK
5859: cf58: 
5860: cf58:         ! If file open unsuccessful
5861: cf58:         IF DIR.FILE.RC% <= XRE.ZERO% THEN BEGIN
5862: cf76:             DIR.OPEN    = FALSE                                         !MJK
5863: cf8c:             STATUS.MSG$ = STATUS.TEXT.ERROR$(2)                         !JDC
5864: cfb6:             GOSUB LOG.STATUS.MSG
5865: cfc8:             ! Setting NULL to avoid file read
5866: cfc8:             DIR.VALUE$ = XRE.NULL$
5867: cfe8:         ENDIF ELSE BEGIN
5868: cff0:             DIR.OPEN   = TRUE
5869: d006:             DIR.VALUE$ = XRE.SPACE$
5870: d024:         ENDIF
5871: d02c: 
5872: d02c:         ! Read the file till EOF or read error                          !FDC
5873: d02c:         WHILE LEN(DIR.VALUE$) <> XRE.ZERO%
5874: d037:             DIR.VALUE$ = FUNC.READ.SEQUENTIAL.FILE( DIR.FILE.RC% )      !NJK
5875: d05a: 
5876: d05a:             !----------------------------------------!                  !OJK
5877: d05a:             ! If error string matches, log the error !                  !OJK
5878: d05a:             !----------------------------------------!                  !OJK
5879: d05a:             IF MATCH("MKDIR",UCASE$(DIR.VALUE$),1) <> \                 !OJK
5880: d09b:                XRE.ZERO% THEN BEGIN
5881: d09b:                 ! Error in creating directory
5882: d09b:                 STATUS.MSG$ = DIR.VALUE$                                !OJK
5883: d0b9:                 GOSUB LOG.STATUS.MSG
5884: d0cb:                 DIRECTORY.CREATE = FALSE
5885: d0e1:             ENDIF
5886: d0e9:         WEND
5887: d111: 
5888: d111:         IF DIRECTORY.CREATE THEN BEGIN
5889: d123:             STATUS.MSG$ = DIRECT.TO.RESTORE$ + " directory is created"
5890: d148:             GOSUB LOG.STATUS.MSG
5891: d15c:         ENDIF ELSE BEGIN
5892: d164:             STATUS.MSG$ = DIRECT.TO.RESTORE$        + \
5893: d189:                           " directory is not created"
5894: d189:             GOSUB LOG.STATUS.MSG
5895: d19b:         ENDIF
5896: d1a3: 
5897: d1a3:         ! Closing File
5898: d1a3:         IF DIR.OPEN THEN BEGIN
5899: d1b5:             CALL FUNC.CLOSE.FILE( DIR.FILE.RC% )                        !NJK
5900: d1de:             DIR.OPEN = FALSE
5901: d1f4:         ENDIF
5902: d1fc: ! HJK Ending block                                                      !HJK
5903: d1fc:     ENDIF
5904: d204: 
5905: d204:     ! Default value                                                     !OJK
5906: d204:     BKP.ZIP.FILE$     = XRE.NULL$                                       !OJK
5907: d222:     RESTORE.ERR.EXIST = FALSE                                           !OJK
5908: d238: 
5909: d238:     IF DIRECTORY.CREATE THEN BEGIN                                      !HJK
5910: d24d: 
5911: d24d:         IF RIGHT$(DIRECT.TO.RESTORE$,1) <> "\" THEN BEGIN
5912: d280:             !--------------------------------------------------!
5913: d280:             ! Adding slash for further processing if directory !
5914: d280:             ! value is not ending with slash                   !
5915: d280:             !--------------------------------------------------!
5916: d280:             DIRECT.TO.RESTORE$ = DIRECT.TO.RESTORE$ + "\"
5917: d2a5:         ENDIF
5918: d2ad: 
5919: d2ad:         ! If file present in IMG directory
5920: d2ad:         IF VALUE.EXISTS = 1 THEN BEGIN
5921: d2c2: 
5922: d2c2: ! Commenting out the logic, as it is no longer needed                   !OJK
5923: d2c2: !            ! Extracting the archive file to C:/TEMP                   !OJK
5924: d2c2: !           CALL OSSHELL(ADXZUDIR.FILE.NAME$ + " -x "                + \!OJK
5925: d2c2: !                        BKP.FILENAME.IMG$ + XRE.SPACE$ + TEMP.DIR$  + \!OJK
5926: d2c2: !                        " > " + DIR.OUT$ + " >>* " + DIR.OUT$ )        !OJK
5927: d2c2: 
5928: d2c2:             ! Extracting the file using ADXUNZIP                        !OJK
5929: d2c2:             CALL OSSHELL(ADXUNZIP.FILE.NAME$ + " -C -o "       + \      !OJK
5930: d33a:                          BKP.FILENAME.IMG$ + XRE.SPACE$        + \      !OJK
5931: d33a:                          SELECTED.FILENAME$ + " -d "           + \      !OJK
5932: d33a:                          DIRECT.TO.RESTORE$ + " > " + DIR.OUT$ + \      !OJK
5933: d33a:                          " >>* " + DIR.OUT$ )                           !OJK
5934: d33a: 
5935: d33a:             STATUS.MSG$ = BKP.FILENAME.IMG$ + STATUS.TEXT.MSG$(46) + \  !JDC
5936: d376:                           "to get the file"
5937: d376:             GOSUB LOG.STATUS.MSG
5938: d388: 
5939: d388:             BKP.ZIP.FILE$ = BKP.FILENAME.IMG$                           !OJK
5940: d3a9: 
5941: d3a9:         ! If file present in ALT directory
5942: d3a9:         ENDIF ELSE IF VALUE.EXISTS = 2 THEN BEGIN
5943: d3be: 
5944: d3be:             ! Extracting the file using ADXUNZIP                        !OJK
5945: d3be:             CALL OSSHELL(ADXUNZIP.FILE.NAME$ + " -C -o "       + \      !OJK
5946: d436:                          BKP.FILENAME.ALT$ + XRE.SPACE$        + \      !OJK
5947: d436:                          SELECTED.FILENAME$ + " -d "           + \      !OJK
5948: d436:                          DIRECT.TO.RESTORE$ + " > " + DIR.OUT$ + \      !OJK
5949: d436:                          " >>* " + DIR.OUT$ )                           !OJK
5950: d436: 
5951: d436:             STATUS.MSG$ = BKP.FILENAME.ALT$ + STATUS.TEXT.MSG$(46) + \  !JDC
5952: d472:                           "to get the file"
5953: d472:             GOSUB LOG.STATUS.MSG
5954: d484: 
5955: d484:             BKP.ZIP.FILE$ = BKP.FILENAME.ALT$                           !OJK
5956: d4a5: 
5957: d4a5:         ! If the file present in BKPFAIL
5958: d4a5:         ENDIF ELSE IF VALUE.EXISTS = 3 THEN BEGIN
5959: d4ba:             RESTORE.FILENAME$ = SELECTED.FILENAME$                      !LJK
5960: d4d8:             MATCH.POS% = MATCH(".", SELECTED.FILENAME$,1)               !LJK
5961: d4fd:             IF MATCH.POS% <> XRE.ZERO% THEN BEGIN                       !LJK
5962: d516:                 RESTORE.FILENAME$ = \                                   !LJK
5963: d544:                             LEFT$(SELECTED.FILENAME$,(MATCH.POS% - 1))  !LJK
5964: d544:             ENDIF                                                       !LJK
5965: d54c: 
5966: d54c:             ! Selecting the XDISKIMG directory location based on the    !MJK
5967: d54c:             ! given file for restore                                    !MJK
5968: d54c:             IF LEFT$(UCASE$(SELECT.FILE.NAME$),1) = "D" THEN BEGIN
5969: d594:                 ! Copying the file to respective directory
5970: d594:                 CALL OSSHELL("COPY " + C.BKP.IMG$ + RESTORE.FILENAME$ + \LJK
5971: d61a:                              "." + MDD.DATE$ + XRE.SPACE$             + \LJK
5972: d61a:                              DIRECT.TO.RESTORE$ + SELECTED.FILENAME$  + \LJK
5973: d61a:                              " > " + DIR.OUT$ + " >>* " + DIR.OUT$)
5974: d61a:             ENDIF ELSE BEGIN                                            !MJK
5975: d622:                 ! Copying the file to respective directory
5976: d622:                 CALL OSSHELL("COPY " + D.BKP.IMG$ + RESTORE.FILENAME$ + \MJK
5977: d6a5:                              "." + MDD.DATE$ + XRE.SPACE$             + \MJK
5978: d6a5:                              DIRECT.TO.RESTORE$ + SELECTED.FILENAME$  + \MJK
5979: d6a5:                              " > " + DIR.OUT$ + " >>* " + DIR.OUT$)     !MJK
5980: d6a5:             ENDIF
5981: d6ad:             !---------------------------------------------!
5982: d6ad:             ! Not distributing the file if SUPPS mode, as !
5983: d6ad:             ! ADXCSU0L won't work under SUPPS             !
5984: d6ad:             !---------------------------------------------!
5985: d6ad:             IF NOT SUPPS.ON THEN BEGIN
5986: d6bf:                 ! Setting the distribution type
5987: d6bf:                 CALL OSSHELL(ADXCSU0L.FILE.NAME$ + " 3 " + FSEL$     + \!MJK
5988: d733:                              XRE.SPACE$ + DIRECT.TO.RESTORE$         + \
5989: d733:                              SELECTED.FILENAME$ + " >> " + DIR.OUT$  + \
5990: d733:                              " >>* " + DIR.OUT$)
5991: d733:             ENDIF
5992: d73b: 
5993: d73b:             STATUS.MSG$ = "File is being extracted from BKPFAIL file"
5994: d752:             GOSUB LOG.STATUS.MSG
5995: d764: 
5996: d764:         ENDIF
5997: d76c: 
5998: d76c:         ! If valid restore
5999: d76c:         IF VALUE.EXISTS > XRE.ZERO% THEN BEGIN
6000: d787: 
6001: d787:             ! Opening the STDOUT file to check for any error
6002: d787:             DIR.FILE.RC% = FUNC.OPEN.SEQUENTIAL.FILE( DIR.OUT$ )        !NJK
6003: d7b1: 
6004: d7b1:             ! If file open unsuccessful
6005: d7b1:             IF DIR.FILE.RC% <= XRE.ZERO% THEN BEGIN
6006: d7cf:                 DIR.OPEN    = FALSE                                     !MJK
6007: d7e5:                 STATUS.MSG$ = STATUS.TEXT.ERROR$(2)                     !JDC
6008: d80f:                 GOSUB LOG.STATUS.MSG
6009: d821:                 ! Setting NULL to avoid file read
6010: d821:                 DIR.VALUE$ = XRE.NULL$
6011: d841:             ENDIF ELSE BEGIN
6012: d849:                 DIR.OPEN   = TRUE
6013: d85f:                 DIR.VALUE$ = XRE.SPACE$
6014: d87d:             ENDIF
6015: d885: 
6016: d885:             ! Read the file till EOF or read error                      !FDC
6017: d885:             WHILE LEN(DIR.VALUE$) <> XRE.ZERO%
6018: d890:                 DIR.VALUE$ = FUNC.READ.SEQUENTIAL.FILE( DIR.FILE.RC% )  !NJK
6019: d8b3: 
6020: d8b3:                 !-----------------------------------------------!
6021: d8b3:                 ! If error string matches, write the error with !
6022: d8b3:                 ! file name in LOG file                         !
6023: d8b3:                 !-----------------------------------------------!
6024: d8b3:                 IF MATCH("ERROR",UCASE$(DIR.VALUE$),1) <> XRE.ZERO% OR  \OJK
6025: d92f:                    MATCH("cannot be found",(DIR.VALUE$),1)  <>          \OJK
6026: d92f:                    XRE.ZERO% THEN BEGIN
6027: d92f:                     ! Logging the extraction error OR copy error
6028: d92f:                     STATUS.MSG$ = DIR.VALUE$
6029: d94d:                     GOSUB LOG.STATUS.MSG
6030: d95f:                     ! Setting the status to show the notification
6031: d95f:                     RESTORE.ERR.EXIST = TRUE                            !OJK
6032: d975: 
6033: d975:                     ! If BKPFAIL run
6034: d975:                     IF VALUE.EXISTS = 3 THEN BEGIN
6035: d987:                         STATUS.MSG$ = STATUS.TEXT.ERROR$(14)            !JDC
6036: d9b1:                         GOSUB LOG.STATUS.MSG
6037: d9c6:                     ENDIF ELSE BEGIN                                    !OJK
6038: d9ce:                         STATUS.MSG$ = STATUS.TEXT.ERROR$(15)            !OJK
6039: d9f8:                         GOSUB LOG.STATUS.MSG                            !OJK
6040: da0a:                         ! Extracting the file using ADXUNZIP to C:/TEMP !OJK
6041: da0a:                         CALL OSSHELL(ADXUNZIP.FILE.NAME$ + " -C -o "  + \OJK
6042: da82:                                      BKP.ZIP.FILE$ + XRE.SPACE$       + \OJK
6043: da82:                                      SELECTED.FILENAME$ + " -d "      + \OJK
6044: da82:                                      TEMP.DIR$ + " > " + DIR1.OUT$    + \OJK
6045: da82:                                      " >>* " + DIR1.OUT$ )              !OJK
6046: da82:                         STATUS.MSG$ = STATUS.TEXT.MSG$(48) + \          !OJK
6047: dabe:                                       TEMP.DIR$ + " directory"          !OJK
6048: dabe:                         GOSUB LOG.STATUS.MSG                            !OJK
6049: dad0:                     ENDIF
6050: dad8:                     ! To break the WHILE loop                           !OJK
6051: dad8:                     DIR.VALUE$ = XRE.NULL$                              !OJK
6052: daf6:                 ENDIF
6053: dafe:             WEND
6054: db26: 
6055: db26:             ! Closing File
6056: db26:             IF DIR.OPEN THEN BEGIN
6057: db38:                 CALL FUNC.CLOSE.FILE( DIR.FILE.RC% )                    !NJK
6058: db61:                 DIR.OPEN = FALSE
6059: db77:             ENDIF
6060: db7f: 
6061: db7f:         ENDIF
6062: db87: 
6063: db87:         ! If IMG or ALT directory run
6064: db87:         IF VALUE.EXISTS = 1 OR VALUE.EXISTS = 2 THEN BEGIN
6065: dbb4: 
6066: dbb4:             !------------------------------------------------!
6067: dbb4:             ! Not distributing the file if SUPPS mode, as    !
6068: dbb4:             ! ADXCSU0L won't work under SUPPS. Also make     !          !OJK
6069: dbb4:             ! sure no error has happened in file extraction  !          !OJK
6070: dbb4:             !------------------------------------------------!          !OJK
6071: dbb4:             IF NOT SUPPS.ON AND NOT RESTORE.ERR.EXIST THEN BEGIN        !OJK
6072: dbd5:                 ! Setting the distribution type
6073: dbd5:                 CALL OSSHELL(ADXCSU0L.FILE.NAME$ + " 3 " + FSEL$    + \ !MJK
6074: dc49:                              XRE.SPACE$ + DIRECT.TO.RESTORE$        + \
6075: dc49:                              SELECTED.FILENAME$ + " >  " + DIR.OUT$ + \ !OJK
6076: dc49:                              " >>* " + DIR.OUT$)
6077: dc49: !            ENDIF                                                      !OJK
6078: dc49: 
6079: dc49:                 DIR.FILE.RC% = FUNC.OPEN.SEQUENTIAL.FILE( DIR.OUT$ )    !NJK
6080: dc73: 
6081: dc73:                 ! If file open unsuccessful
6082: dc73:                 IF DIR.FILE.RC% <= XRE.ZERO% THEN BEGIN
6083: dc91:                     DIR.OPEN    = FALSE                                 !MJK
6084: dca7:                     STATUS.MSG$ = STATUS.TEXT.ERROR$(2)                 !JDC
6085: dcd1:                     GOSUB LOG.STATUS.MSG
6086: dce3:                     ! Setting NULL to avoid file read
6087: dce3:                     DIR.VALUE$ = XRE.NULL$
6088: dd03:                 ENDIF ELSE BEGIN
6089: dd0b:                     DIR.OPEN   = TRUE
6090: dd21:                     DIR.VALUE$ = XRE.SPACE$
6091: dd3f:                 ENDIF
6092: dd47: 
6093: dd47:                 ! Read the file till EOF or read error                  !FDC
6094: dd47:                 WHILE LEN(DIR.VALUE$) <> XRE.ZERO%
6095: dd52:                     DIR.VALUE$ = FUNC.READ.SEQUENTIAL.FILE(DIR.FILE.RC%)!NJK
6096: dd75: 
6097: dd75:                     !-----------------------------------------------!
6098: dd75:                     ! If error string matches, write the error with !
6099: dd75:                     ! file name in LOG file                         !
6100: dd75:                     !-----------------------------------------------!
6101: dd75:                     IF MATCH("ERROR",UCASE$(DIR.VALUE$),1) <> \         !OJK
6102: ddb9:                        XRE.ZERO% THEN BEGIN
6103: ddb9:                         ! Logging the distribution error                !OJK
6104: ddb9:                         STATUS.MSG$ = STATUS.TEXT.ERROR$(16)            !OJK
6105: dde3:                         GOSUB LOG.STATUS.MSG
6106: ddf5:                         STATUS.MSG$ = DIR.VALUE$
6107: de13:                         GOSUB LOG.STATUS.MSG
6108: de25: 
6109: de25:                         RESTORE.ERR.EXIST = TRUE                        !OJK
6110: de3b:                         ! To break the WHILE loop                       !OJK
6111: de3b:                         DIR.VALUE$ = XRE.NULL$                          !OJK
6112: de59:                     ENDIF
6113: de61:                 WEND
6114: de89: 
6115: de89:                 ! Closing File
6116: de89:                 IF DIR.OPEN THEN BEGIN
6117: de9b:                     CALL FUNC.CLOSE.FILE( DIR.FILE.RC% )                !NJK
6118: dec4:                     DIR.OPEN = FALSE
6119: deda:                 ENDIF
6120: dee2:             ENDIF                                                       !OJK
6121: deea:         ENDIF
6122: def2:     ENDIF                                                               !HJK
6123: defa: 
6124: defa:     ! Setting the notification based on the restore status flag
6125: defa:     IF NOT RESTORE.ERR.EXIST AND DIRECTORY.CREATE THEN BEGIN            !OJK
6126: df17:         FIELD$(1) = "'File restoration process successful"
6127: df3a: 
6128: df3a:         STATUS.MSG$ = "File restoration successful"
6129: df51: 
6130: df51:         ! Restore complete message
6131: df51:         FIELD$(3) = "The file " + UCASE$(SELECTED.FILENAME$)         + \
6132: e03c:                     " has been restored from "                       + \
6133: e03c:                     UCASE$(DAY.ARRAY$(SEL.INDEX%)) + ", "            + \
6134: e03c:                     RIGHT$(BKP.DATE.ARRAY$(SEL.INDEX%),2) + "/"      + \
6135: e03c:                     MID$(BKP.DATE.ARRAY$(SEL.INDEX%),3,2) + " to "   + \!HJK
6136: e03c:                     UCASE$(DIRECT.TO.RESTORE$)                          !HJK
6137: e03c:         FIELD$(4) = "This file has been distributed as a type " + FSEL$ !GJK
6138: e070: 
6139: e070:     ENDIF ELSE BEGIN
6140: e078:         IF DIRECTORY.CREATE THEN BEGIN                                  !HJK
6141: e08d:             FIELD$(1) = "'Unable to restore this file because it " + \  !GJK
6142: e0b7:                         "is currently locked by another program"
6143: e0b7:             STATUS.MSG$ = "File restored with an exception"             !OJK
6144: e0ce:             ! Restore complete message
6145: e0ce:             FIELD$(3) = "The file " + UCASE$(SELECTED.FILENAME$) + \    !OJK
6146: e113:                         " has been restored with an exception from "    !OJK
6147: e113: 
6148: e113:             FIELD$(4) = UCASE$(DAY.ARRAY$(SEL.INDEX%)) + ", "       + \ !OJK
6149: e1ed:                         RIGHT$(BKP.DATE.ARRAY$(SEL.INDEX%),2) + "/" + \ !OJK
6150: e1ed:                         MID$(BKP.DATE.ARRAY$(SEL.INDEX%),3,2)       + \ !OJK
6151: e1ed:                         " to " + UCASE$(DIRECT.TO.RESTORE$) + "."       !OJK
6152: e1ed:         ENDIF ELSE BEGIN                                                !HJK
6153: e1f5:             FIELD$(1) = "'Error in creating directory"                  !HJK
6154: e218: 
6155: e218:             STATUS.MSG$ = "File restore unsuccessful"                   !OJK
6156: e22f: 
6157: e22f:             ! Restore unsuccessful message                              !OJK
6158: e22f:             FIELD$(3) = "The file " + UCASE$(SELECTED.FILENAME$) + \    !OJK
6159: e284:                         " is not restored to "                   + \    !OJK
6160: e284:                         UCASE$(DIRECT.TO.RESTORE$)                      !OJK
6161: e284: 
6162: e284:             FIELD$(4) = "Please re-enter the directory and try again."  !OJK
6163: e2a7:         ENDIF
6164: e2af: 
6165: e2af:     ENDIF
6166: e2b7: 
6167: e2b7:     GOSUB LOG.STATUS.MSG                                                !GJK
6168: e2c9: 
6169: e2c9:     FIELD$(2) = "File restoration complete"                             !MJK
6170: e2ec: 
6171: e2ec:     ! Setting the visibility
6172: e2ec:     CALL DM.VISIBLE ("5", STATUS.TEXT.MSG$(60))                         !IDC
6173: e317: 
6174: e317:     ! To Make sure no error occurs when F3 or ESC pressed
6175: e317:     RESTORE.STATUS = TRUE
6176: e32d: 
6177: e32d:     ! Handles the final restore screen
6178: e32d:     WHILE SCREEN% = FILE.PROCESS.SCR%                                   !CJK
6179: e338:         IF SCREEN% = FILE.PROCESS.SCR% THEN BEGIN                       !CJK
6180: e353:             RET.KEY% = DM.PROCESS.SCREEN (5, 5, FALSE)
6181: e377: 
6182: e377:             IF RET.KEY% = ESC.KEY% THEN BEGIN                           !MJK
6183: e38f: 
6184: e38f:                 ! Previous screen
6185: e38f:                 SCREEN%      = FILE.CONFIRMATION.SCR%                   !CJK
6186: e3a5:                 PREVIOUS.KEY = TRUE
6187: e3bd: 
6188: e3bd:             ENDIF ELSE BEGIN
6189: e3c5:                 CALL DM.FOCUS ("1", SCREEN.TEXT.MSG$(13) + \            !MJK
6190: e3ff:                                     "previous screen")                  !MJK
6191: e3ff:             ENDIF
6192: e407:         ENDIF
6193: e40f:     WEND
6194: e42a: 
6195: e42a: RETURN
6196: e43a: 
6197: e43a:                 !   MAIN.PROCESSING SPECIFIC ROUTINES ENDS   !
6198: e43a:                 !............................................!
6199: e43a: 
6200: e43a: \**********************************************************************\
6201: e43a: \**********************************************************************\
6202: e43a: \*                                                                    *\
6203: e43a: \*                       GENERIC ROUTINES                             *\
6204: e43a: \*                                                                    *\
6205: e43a: \**********************************************************************\
6206: e43a: \**********************************************************************\
6207: e43a: 
6208: e43a: \***********************************************************************
6209: e43a: \*
6210: e43a: \* CHECK.FUN.RC2: If FUN.RC2% is zero, By-passes rest of                !MJK
6211: e43a: \*                 procedure. Stops program.
6212: e43a: \*
6213: e43a: \***********************************************************************
6214: e43a: CHECK.FUN.RC2:                                                          !IDC
6215: e44a: 
6216: e44a:     IF FUN.RC2% = XRE.ZERO% THEN RETURN  ! No error                     !IDC
6217: e46b: 
6218: e46b:     STATUS.MSG$  = "Ended: Error while opening " + PASSED.STRING$
6219: e490: 
6220: e490:     GOSUB PROGRAM.EXIT
6221: e4a2: 
6222: e4a2: RETURN
6223: e4b2: 
6224: e4b2:                         !   GENERIC ROUTINES ENDS   !
6225: e4b2:                         !...........................!
6226: e4b2: 
6227: e4b2: \**********************************************************************\
6228: e4b2: \**********************************************************************\
6229: e4b2: \*                                                                    *\
6230: e4b2: \*                 TERMINATION SPECIFIC ROUTINES                      *\
6231: e4b2: \*                                                                    *\
6232: e4b2: \**********************************************************************\
6233: e4b2: \**********************************************************************\
6234: e4b2: 
6235: e4b2: \***********************************************************************
6236: e4b2: \*
6237: e4b2: \*    CLOSE.AND.DEALLOC.SESSIONS: This Sub-routine closes the active
6238: e4b2: \*                                sessions and De-allocates the session
6239: e4b2: \*                                numbers.
6240: e4b2: \*
6241: e4b2: \***********************************************************************
6242: e4b2: CLOSE.AND.DEALLOC.SESSIONS:
6243: e4c2: 
6244: e4c2:     ! Closing the pipe and deallocating the session if OPEN
6245: e4c2:     IF XBACK.OPEN THEN BEGIN                                            !MJK
6246: e4d4:         CLOSE XBACK.PIPE.SESS.NUM%
6247: e4e8:         XBACK.OPEN = FALSE                                              !JDC
6248: e4fe:         CALL SESS.NUM.UTILITY("C",XBACK.PIPE.SESS.NUM%,XRE.NULL$)       !MJK
6249: e524:     ENDIF
6250: e52c: 
6251: e52c:     ! Closing the Log if OPEN
6252: e52c:     IF XRE.LOG.OPEN THEN BEGIN                                          !MJK
6253: e53e:         CALL FUNC.CLOSE.FILE(XRE.FILE.RC%)                              !NJK
6254: e567:         XRE.LOG.OPEN = FALSE
6255: e57d:     ENDIF
6256: e585: 
6257: e585:     ! Closing the pipe and deallocating the session if OPEN
6258: e585:     IF XRE.OPEN THEN BEGIN                                              !MJK
6259: e597:         CLOSE XRE.PIPE.SESS.NUM%
6260: e5ab:         XRE.OPEN = FALSE                                                !JDC
6261: e5c1:         CALL SESS.NUM.UTILITY("C",XRE.PIPE.SESS.NUM%,XRE.NULL$)         !MJK
6262: e5e7:     ENDIF
6263: e5ef: 
6264: e5ef:     ! Closing BKPLIST File if OPEN
6265: e5ef:     IF BKPLIST.OPEN THEN BEGIN
6266: e601:         CALL FUNC.CLOSE.FILE( BKPLIST.FILE.RC% )                        !NJK
6267: e62a:         BKPLIST.OPEN = FALSE
6268: e640:     ENDIF
6269: e648: 
6270: e648:     ! Closing DIR File if OPEN
6271: e648:     IF DIR.OPEN THEN BEGIN
6272: e65a:         CALL FUNC.CLOSE.FILE( DIR.FILE.RC% )                            !NJK
6273: e683:         DIR.OPEN = FALSE
6274: e699:     ENDIF
6275: e6a1: 
6276: e6a1:     ! Closing SLPCF File if OPEN                                        !IDC
6277: e6a1:     IF SLPCF.OPEN THEN BEGIN                                            !IDC
6278: e6b3:         CALL FUNC.CLOSE.FILE(SLPCF.SESS.NUM% )                          !NJK
6279: e6db:         SLPCF.OPEN = FALSE                                              !IDC
6280: e6f1:     ENDIF                                                               !IDC
6281: e6f9: 
6282: e6f9: RETURN
6283: e709: 
6284: e709: \***********************************************************************
6285: e709: \*
6286: e709: \* CHAIN.TO.CALLER: Chain to Application or Program
6287: e709: \*
6288: e709: \***********************************************************************
6289: e709: CHAIN.TO.CALLER:
6290: e719: 
6291: e719:     ! Terminate if any active session present                           !FDC
6292: e719:     GOSUB TERMINATION                                                   !FDC
6293: e72b: 
6294: e72b:     ! If command mode, clears and stop the program
6295: e72b:     IF COMMAND.MODE THEN BEGIN
6296: e73d:         CLEARS
6297: e74c:         GOSUB STOP.PROGRAM
6298: e75e:     ENDIF
6299: e766: 
6300: e766:     CALL DM.STATUS ("'Processing - Please Wait .....")
6301: e77a:     CALL DM.QUIT
6302: e787: 
6303: e787:     ! Current program and chaining program
6304: e787:     PSBCHN.APP = "C:/ADX_UPGM/XRESTORE.286"                             !MJK
6305: e79e:     PSBCHN.PRG = "C:/ADX_UPGM/" + CHAIN.TO.PROG$ + ".286"               !MJK
6306: e7c7: 
6307: e7c7:     %INCLUDE PSBCHNE.J86          ! Include CHAIN operation
6308: e7c7: \/*********************************************************************/ PSBCHNE
6309: e7c7: \/*                                                                   */ PSBCHNE
6310: e7c7: \/*      PSBCHNE.J86  -  Chain to PSB Application Program             */ PSBCHNE
6311: e7c7: \/*      ------------------------------------------------             */ PSBCHNE
6312: e7c7: \/*                                                                   */ PSBCHNE
6313: e7c7: \/*********************************************************************/ PSBCHNE
6314: e7c7:                                                                        ! PSBCHNE
6315: e7c7:         CHAIN  PSBCHN.PRG , PSBCHN.OP , PSBCHN.APP , PSBCHN.MENCON ,   \ PSBCHNE
6316: e847:                             PSBCHN.U1 , PSBCHN.U2  , PSBCHN.U3         ! PSBCHNE
6317: e847:                                                                        ! PSBCHNE
6318: e847: 
6319: e847:     GOSUB STOP.PROGRAM
6320: e859: 
6321: e859: RETURN
6322: e869: 
6323: e869: \***********************************************************************
6324: e869: \*
6325: e869: \* PROGRAM.EXIT: Log the error, Deallocate the session and then chain
6326: e869: \*               back to the caller.
6327: e869: \*
6328: e869: \***********************************************************************
6329: e869: PROGRAM.EXIT:
6330: e879: 
6331: e879:     GOSUB LOG.STATUS.MSG
6332: e88b:     GOSUB CHAIN.TO.CALLER
6333: e89d: 
6334: e89d: RETURN
6335: e8ad:                 !   TERMINATION SPECIFIC ROUTINES ENDS   !
6336: e8ad:                 !........................................!
6337: e8ad: 
6338: e8ad: \***********************************************************************
6339: e8ad: \*
6340: e8ad: \* ERROR.DETECTED:    Main Error Handling Routine. Starts with the
6341: e8ad: \*                    resume error conditions following ERROR.COUNT%
6342: e8ad: \*                    check to avoid error loop. Also References
6343: e8ad: \*                    STANDARD.ERROR.DETECTED to log Event 101.
6344: e8ad: \*
6345: e8ad: \***********************************************************************
6346: e8ad: ERROR.DETECTED:
6347: e8bd: 
6348: e8bd:     IF ERR = "CU" OR ERR = "DU" THEN RESUME     ! Close and delete
6349: e92b:                                                 ! session errors
6350: e92b:     ! Incrementing the error count
6351: e92b:     ERROR.COUNT% = ERROR.COUNT% + 1
6352: e93a: 
6353: e93a:     ! Handling infinite loop
6354: e93a:     IF ERROR.COUNT% > 1 THEN BEGIN
6355: e94c:         RESUME STOP.PROGRAM
6356: e963:     ENDIF
6357: e96b: 
6358: e96b:     ! When program runs in command, this error catch will be used
6359: e96b:     IF ERR = "NP" THEN BEGIN
6360: e991:         COMMAND.MODE = -1                   ! TRUE
6361: e9a1:         ERROR.COUNT% = ERROR.COUNT% - 1     ! Non Fatal error
6362: e9b0:         RESUME START.OF.PROGRAM
6363: e9c7:     ENDIF
6364: e9cf: 
6365: e9cf:     ! Error creating XBACKUP pipe or XRESTORE pipe
6366: e9cf:     IF ERR = "ME" THEN BEGIN
6367: e9f8: 
6368: e9f8:         IF ERRF% = XBACK.PIPE.SESS.NUM% THEN BEGIN
6369: ea17:             XBACK.OPEN  = FALSE                                         !JDC
6370: ea2d:             STATUS.MSG$ = "RESTORE not allowed when XBACKUP is active"
6371: ea44:             ERROR.MSG$  = STATUS.MSG$
6372: ea62:             GOSUB LOG.STATUS.MSG
6373: ea74:             ERROR.EXIST  = TRUE                                         !MJK
6374: ea8a:             ERROR.COUNT% = ERROR.COUNT% - 1  ! Non Fatal error
6375: ea99:             RESUME XBACK.PIPE.CREATE.ERROR                              !MJK
6376: eab3:         ENDIF ELSE IF ERRF% = XRE.PIPE.SESS.NUM% THEN BEGIN             !MJK
6377: ead2:             XRE.OPEN    = FALSE                                         !MJK
6378: eae8:             STATUS.MSG$ = "XRESTORE is already active somewhere"
6379: eaff:             ERROR.MSG$  = STATUS.MSG$
6380: eb1d:             GOSUB LOG.STATUS.MSG
6381: eb2f:             ERROR.EXIST  = TRUE
6382: eb45:             ERROR.COUNT% = ERROR.COUNT% - 1  ! Non Fatal error
6383: eb54:             RESUME XRE.PIPE.CREATE.ERROR                                !MJK
6384: eb6e:         ENDIF ELSE IF ERRF% = XRE.LOG.SESS.NUM% THEN BEGIN              !MJK
6385: eb8d:             XRE.LOG.OPEN = FALSE                                        !MJK
6386: eba3:             STATUS.MSG$  = "Unable to create XRESTORE log"              !MJK
6387: ebba:             ERROR.MSG$   = STATUS.MSG$                                  !MJK
6388: ebd8:             GOSUB LOG.STATUS.MSG                                        !MJK
6389: ebea:             ERROR.EXIST  = TRUE                                         !MJK
6390: ec00:             ERROR.COUNT% = ERROR.COUNT% - 1  ! Non Fatal error          !MJK
6391: ec0f:             RESUME XRE.LOG.CREATE.ERROR                                 !MJK
6392: ec26:         ENDIF                                                           !MJK
6393: ec2e: 
6394: ec2e:     ENDIF
6395: ec36: 
6396: ec36:     STATUS.MSG$ = "Ended: " + ERR + " " + ERRNH + " ERRL "  + \
6397: eca0:                   STR$(ERRL) + " ERRF% " + STR$(ERRF%)
6398: eca0:     IF SUPPS.ON THEN BEGIN                                              !JDC
6399: ecb2:         CLEARS                                                          !MJK
6400: ecc1:         PRINT STATUS.MSG$                                               !JDC
6401: ecdb:     ENDIF ELSE BEGIN                                                    !JDC
6402: ece3:         ! Log event 102
6403: ece3:         CALL STANDARD.ERROR.DETECTED(ERRN, ERRF%, ERRL, ERR)            !DJK
6404: ed10:     ENDIF                                                               !JDC
6405: ed18:     ! Error message to log
6406: ed18:     GOSUB PROGRAM.EXIT ! updates LOG and Program ends
6407: ed2f: END
6408: ed2f: 
6409: ed2f: \***********************************************************************
6410: ed2f: \***********************************************************************
6411: ed2f: \*
6412: ed2f: \*    End of program XRESTORE
6413: ed2f: \*
6414: ed2f: \***********************************************************************
6415: ed2f: \***********************************************************************
6416: ed2f: 
6417: ed2f: End of Compilation
