   1: 0000: !******************************************************************************
   2: 0000: !******************************************************************************
   3: 0000: !***                S U P P L E M E N T A L   V E R S I O N
   4: 0000: !***            PROGRAM         :       PSBF39U.BAS
   5: 0000: !***                (Based on PSBF39.BAS Version G)
   6: 0000: !***
   7: 0000: !***            DESCRIPTION     :       DISPLAY MANAGER INTERFACE
   8: 0000: !***
   9: 0000: !***
  10: 0000: !***        Provides IBM Display Manager interface under supplementals
  11: 0000: !***        This allows non-ULN usage etc and forced namings
  12: 0000: !***
  13: 0000: !***    VERSION A           Jaya Kumar Inbaraj                12/04/2014
  14: 0000: !***    FOD260 - Enhanced Backup and Recovery
  15: 0000: !***    Following changes has been done for SUPPS mode
  16: 0000: !***    - Replaced the User logical name usage with real value
  17: 0000: !***    - Updated the Field$(1) with Hardcoded value, as BEMF file is
  18: 0000: !***      not accessible from SUPPS mode.
  19: 0000: !***
  20: 0000: !***    VERSION B           Jaya Kumar Inbaraj                08/07/2014
  21: 0000: !***    FOD260 - Enhanced Backup and Recovery
  22: 0000: !***    Display file changes and CR5 changes has been done.
  23: 0000: !***
  24: 0000: !******************************************************************************
  25: 0000: !******************************************************************************
  26: 0000: 
  27: 0000: !******************************************************************************
  28: 0000: !***
  29: 0000: !***                    FOR SUPPLEMENTAL PROGRAM USE ONLY
  30: 0000: !***
  31: 0000: !******************************************************************************
  32: 0000: 
  33: 0000: !******************************************************************************
  34: 0000: !***
  35: 0000: !***    LOCAL VARIABLES
  36: 0000: !***
  37: 0000: 
  38: 0000: STRING              DISPLAY.FILE$
  39: 0000: STRING              HELP.FILE$
  40: 0000: STRING              VALUE$
  41: 0000: STRING              PREV.VALUE$
  42: 0000: STRING              TEMP$
  43: 0000: STRING              STATE$
  44: 0000: STRING              ATTRIB$
  45: 0000: STRING              CURRENT.TITLE$
  46: 0000: !E  STRING              DATE.FIELDS$
  47: 0000: !E  STRING              TIME.FIELDS$                                        !CSWM
  48: 0000: STRING              CHAR.DATE$                                              !CSWM
  49: 0000: STRING              CHAR.TIME$                                              !CSWM
  50: 0000: STRING              INVISIBLE.FIELD$
  51: 0000: STRING              FN.VISIBLE$(1)                                          !ASWM
  52: 0000: STRING              VALIDATE.KEYS$                                          !BSWM
  53: 0000: 
  54: 0000: INTEGER*1           TRUE
  55: 0000: INTEGER*1           FALSE
  56: 0000: INTEGER*1           VISIBLE
  57: 0000: INTEGER*1           CURRENT.STATE
  58: 0000: INTEGER*1           EXIT.FLAG
  59: 0000: INTEGER*1           VALID
  60: 0000: INTEGER*1           UPDATE
  61: 0000: INTEGER*1           RESUME.INPUT
  62: 0000: INTEGER*1           FIELDS.CHANGED
  63: 0000: INTEGER*1           FIELD.TAB.ORDER                                         !DSWM
  64: 0000: INTEGER*1           DISPLAY.ORDER                                           !DSWM
  65: 0000: INTEGER*1           NUMBER.ORDER                                            !DSWM
  66: 0000: 
  67: 0000: INTEGER*2           CURRENT.SCREEN%
  68: 0000: !DSWMINTEGER*2      CURRENT.FIELD%
  69: 0000: INTEGER*2           FIRST.HELP.SCREEN%
  70: 0000: INTEGER*2           LAST.HELP.SCREEN%
  71: 0000: INTEGER*2           PAGE%
  72: 0000: INTEGER*2           PAGE.COUNT%
  73: 0000: 
  74: 0000: INTEGER*2           RC%
  75: 0000: INTEGER*2           FIELD.COUNT%
  76: 0000: INTEGER*2           KEY%
  77: 0000: INTEGER*2           CONFIRM.KEY%
  78: 0000: INTEGER*2           LEN%
  79: 0000: 
  80: 0000: INTEGER*2           DATE.FORMAT%
  81: 0000: INTEGER*2           TIME.FORMAT%                                            !CSWM
  82: 0000: 
  83: 0000: INTEGER*2           FIELD.FLAGS%(1)                                         !ESWM
  84: 0000: INTEGER*2           DATE.FLAG%                                              !ESWM
  85: 0000: INTEGER*2           TIME.FLAG%                                              !ESWM
  86: 0000: INTEGER*2           RO.FLAG%                                                !ESWM
  87: 0000: INTEGER*2           OUT.FLAG%                                               !FNWB
  88: 0000: 
  89: 0000: INTEGER*2           MESSAGE.FIELD%
  90: 0000: INTEGER*2           TITLE.FIELD%
  91: 0000: INTEGER*2           DATE.FIELD%
  92: 0000: INTEGER*2           INVISIBLE.FIELD%
  93: 0000: INTEGER*2           F.FIELD%
  94: 0000: INTEGER*2           F1.FIELD%
  95: 0000: INTEGER*2           F2.FIELD%
  96: 0000: INTEGER*2           F3.FIELD%
  97: 0000: INTEGER*2           F4.FIELD%
  98: 0000: INTEGER*2           F5.FIELD%
  99: 0000: INTEGER*2           F6.FIELD%
 100: 0000: INTEGER*2           F7.FIELD%
 101: 0000: INTEGER*2           F8.FIELD%
 102: 0000: INTEGER*2           F9.FIELD%
 103: 0000: INTEGER*2           F10.FIELD%
 104: 0000: 
 105: 0000: INTEGER*4           ADX.RC%
 106: 0000: 
 107: 0000: STRING              NAME$(1)                                                !DSWM
 108: 0000: STRING              SAVED.FUNC.KEY$(1)                                      !GCSK
 109: 0000: 
 110: 0000: INTEGER*2           F%                                                      !DSWM
 111: 0000: INTEGER*2           LAST.INPUT%                                             !DSWM
 112: 0000: INTEGER*2           NEXT.INPUT%(1)                                          !DSWM
 113: 0000: INTEGER*2           PREV.INPUT%(1)                                          !DSWM
 114: 0000: 
 115: 0000: !******************************************************************************
 116: 0000: !***
 117: 0000: !***    GLOBAL VARIBALES
 118: 0000: !***
 119: 0000: 
 120: 0000: !These two globals are shared with PSBF38, but "hidden" (i.e. not included in
 121: 0000: !PSBF39G so as not to be visible to other routines.  The reason for doing this
 122: 0000: !is so that PSBF38 can be linked to modules without the need to link in F39
 123: 0000: !as well (which would be the case if a function call to F39 were used).
 124: 0000: !Note we use PSBF38 from PSBF44 (SEL printing) which will be linked with
 125: 0000: !batch programs, so we do not want the overhead of all the DM stuff as well.
 126: 0000: INTEGER*2 GLOBAL    ?F39.CF%                                                !DSWM
 127: 0000: STRING GLOBAL       ?F39.CF$                                                !DSWM
 128: 0000: 
 129: 0000: STRING GLOBAL       MODULE.NUMBER$
 130: 0000: 
 131: 0000: %INCLUDE PSBF38G.J86
 132: 0000: !******************************************************************************
 133: 0000: !******************************************************************************
 134: 0000: !***
 135: 0000: !***            PROGRAM         :       PSBF38G.BAS
 136: 0000: !***
 137: 0000: !***            DESCRIPTION     :       RUNTIME EXPRESSION EVALUATOR
 138: 0000: !***
 139: 0000: !***            AUTHOR          :       Stuart William McConnachie
 140: 0000: !***            DATE WRITTEN    :       September 2000
 141: 0000: !***
 142: 0000: !***        Reverse polish expression evaluator for 4690 BASIC.
 143: 0000: !***        Provides support for PSBF39 and IBM Display Manager.
 144: 0000: !***        Provides support for PSBF44 and Shelf Edge Label Programs.
 145: 0000: !***
 146: 0000: !******************************************************************************
 147: 0000: !******************************************************************************
 148: 0000:     
 149: 0000: !Result of searching for a variable name:
 150: 0000: !EVAL.SET.VARIABLE:
 151: 0000: !   TRUE if the variable has been redefined, FALSE if first definition
 152: 0000: !EVAL.DELETE.VARIABLE:
 153: 0000: !   TRUE if the variable was deleted, FALSE if it did not exist
 154: 0000: !EVAL.GET.VARIABLE$:
 155: 0000: !   TRUE if the variable was found, FALSE if undefined
 156: 0000: INTEGER*1 GLOBAL F38.VAR.DEFINED
 157: 0000: 
 158: 0000: !Error returned from expression evaluator
 159: 0000: STRING GLOBAL F38.EVAL.ERROR$
 160: 0000: 
 161: 0000: !Last runtime expression handled
 162: 0000: STRING GLOBAL F38.LAST.EXPR$
 163: 0000: 
 164: 0000: %INCLUDE PSBF39G.J86
 165: 0000: !******************************************************************************
 166: 0000: !******************************************************************************
 167: 0000: !***
 168: 0000: !***            PROGRAM         :       PSBF39G.J86
 169: 0000: !***
 170: 0000: !***            DESCRIPTION     :       DISPLAY MANAGER INTERFACE
 171: 0000: !***
 172: 0000: !***            AUTHOR          :       Stuart William McConnachie
 173: 0000: !***            DATE WRITTEN    :       September 2000
 174: 0000: !***
 175: 0000: !***        Provides a much needed and easier to use interface to
 176: 0000: !***        IBM Display Manager.
 177: 0000: !***
 178: 0000: !***        Saves the user having to set up, highlight, tab between and
 179: 0000: !***        validate fields.  Also handles the help screens and conversion
 180: 0000: !***        of date fields to external/internal format.
 181: 0000: !***
 182: 0000: !******************************************************************************
 183: 0000: !******************************************************************************
 184: 0000:     
 185: 0000:     STRING GLOBAL       MESSAGE$(1)
 186: 0000:     STRING GLOBAL       VALID$(1)
 187: 0000:     STRING GLOBAL       VISIBLE$(1)
 188: 0000:     STRING GLOBAL       FIELD$(1)
 189: 0000:     STRING GLOBAL       TITLE$
 190: 0000: 
 191: 0000:     INTEGER*2 GLOBAL    DM.SCREEN%
 192: 0000:     INTEGER*2 GLOBAL    DM.FIELD%
 193: 0000:     
 194: 0000:     INTEGER*2 GLOBAL    HOME.KEY%
 195: 0000:     INTEGER*2 GLOBAL    END.KEY%
 196: 0000:     INTEGER*2 GLOBAL    PGUP.KEY%
 197: 0000:     INTEGER*2 GLOBAL    PGDN.KEY%
 198: 0000:     INTEGER*2 GLOBAL    TAB.KEY%
 199: 0000:     INTEGER*2 GLOBAL    BTAB.KEY%
 200: 0000:     INTEGER*2 GLOBAL    UP.KEY%
 201: 0000:     INTEGER*2 GLOBAL    DOWN.KEY%
 202: 0000:     INTEGER*2 GLOBAL    ESC.KEY%
 203: 0000:     INTEGER*2 GLOBAL    ENTER.KEY%
 204: 0000:     INTEGER*2 GLOBAL    INS.KEY%
 205: 0000:     INTEGER*2 GLOBAL    PREV.KEY%
 206: 0000:     INTEGER*2 GLOBAL    NEXT.KEY%
 207: 0000:         
 208: 0000:     INTEGER*2 GLOBAL    F1.KEY%
 209: 0000:     INTEGER*2 GLOBAL    F2.KEY%
 210: 0000:     INTEGER*2 GLOBAL    F3.KEY%
 211: 0000:     INTEGER*2 GLOBAL    F4.KEY%
 212: 0000:     INTEGER*2 GLOBAL    F5.KEY%
 213: 0000:     INTEGER*2 GLOBAL    F6.KEY%
 214: 0000:     INTEGER*2 GLOBAL    F7.KEY%
 215: 0000:     INTEGER*2 GLOBAL    F8.KEY%
 216: 0000:     INTEGER*2 GLOBAL    F9.KEY%
 217: 0000:     INTEGER*2 GLOBAL    F10.KEY%
 218: 0000:                 
 219: 0000: !******************************************************************************
 220: 0000: 
 221: 0000: %INCLUDE PSBF49G.J86                                                    !BJK
 222: 0000: \******************************************************************************
 223: 0000: \******************************************************************************
 224: 0000: \***
 225: 0000: \***            PROGRAM         :       PSBF49
 226: 0000: \***            MODULE          :       PSBF49G (Global declarations)
 227: 0000: \***            AUTHOR          :       Tittoo Thomas
 228: 0000: \***            DATE WRITTEN    :       October 2013
 229: 0000: \***
 230: 0000: \******************************************************************************
 231: 0000: \***
 232: 0000: \***   Global definitions if any for the re-usable functions included in
 233: 0000: \***   PSBF49
 234: 0000: \***
 235: 0000: \******************************************************************************
 236: 0000: \******************************************************************************
 237: 0000: \***
 238: 0000: \***   VERSION A                    Tittoo Thomas                    7 Oct 2013
 239: 0000: \***   Initial version.
 240: 0000: \***
 241: 0000: \******************************************************************************
 242: 0000: \******************************************************************************
 243: 0000: 
 244: 0000: INTEGER*1 GLOBAL  ADDITIONAL.ELEMENTS%   ! Overflow of elements in delimited
 245: 0000:                                          ! string
 246: 0000: STRING    GLOBAL  DELIM.STR.ELEMENTS$(1) ! Holds data from parsed delim strngs
 247: 0000: 
 248: 0000: 
 249: 0000: !******************************************************************************
 250: 0000: !***
 251: 0000: !***    EXTERNAL FUNCTIONS
 252: 0000: !***
 253: 0000: 
 254: 0000: %INCLUDE PSBF38E.J86
 255: 0000: !******************************************************************************
 256: 0000: !******************************************************************************
 257: 0000: !***
 258: 0000: !***            PROGRAM         :       PSBF38E.BAS
 259: 0000: !***
 260: 0000: !***            DESCRIPTION     :       RUNTIME EXPRESSION EVALUATOR
 261: 0000: !***
 262: 0000: !***            AUTHOR          :       Stuart William McConnachie
 263: 0000: !***            DATE WRITTEN    :       September 2000
 264: 0000: !***
 265: 0000: !***        Reverse polish expression evaluator for 4690 BASIC.
 266: 0000: !***        Provides support for PSBF39 and IBM Display Manager.
 267: 0000: !***
 268: 0000: !******************************************************************************
 269: 0000: !******************************************************************************
 270: 0000:     
 271: 0000:     FUNCTION TOKENISE$ (EXPR$) EXTERNAL
 272: 0000:         STRING      EXPR$
 273: 0000:         STRING      TOKENISE$
 274: 0000:     END FUNCTION
 275: 0000: 
 276: 0000: !******************************************************************************
 277: 0000:  
 278: 0000:     FUNCTION EVAL% (EXPR$) EXTERNAL
 279: 0000:         STRING      EXPR$
 280: 0000:         INTEGER*4   EVAL%
 281: 0000:     END FUNCTION
 282: 0000:     
 283: 0000: !******************************************************************************
 284: 0000: 
 285: 0000:     FUNCTION EVAL$ (EXPR$) EXTERNAL
 286: 0000:         STRING      EXPR$
 287: 0000:         STRING      EVAL$
 288: 0000:     END FUNCTION
 289: 0000:     
 290: 0000: !******************************************************************************
 291: 0000: 
 292: 0000:     FUNCTION EVAL (EXPR$) EXTERNAL
 293: 0000:         STRING      EXPR$
 294: 0000:         REAL        EVAL
 295: 0000:     END FUNCTION
 296: 0000:     
 297: 0000: !******************************************************************************
 298: 0000: 
 299: 0000:     FUNCTION POLISH$ (EXPR$) EXTERNAL
 300: 0000:         STRING      EXPR$
 301: 0000:         STRING      POLISH$
 302: 0000:     END FUNCTION
 303: 0000:     
 304: 0000: !******************************************************************************
 305: 0000: 
 306: 0000:     FUNCTION DETOKENISE$ (EXPR$) EXTERNAL
 307: 0000:         STRING      EXPR$
 308: 0000:         STRING      DETOKENISE$
 309: 0000:     END FUNCTION
 310: 0000: 
 311: 0000: !******************************************************************************
 312: 0000: 
 313: 0000:     SUB EVAL.CLEAR.ALL.VARIABLES EXTERNAL
 314: 0000:     END SUB
 315: 0000: 
 316: 0000: !******************************************************************************
 317: 0000: 
 318: 0000:     SUB EVAL.SET.VARIABLE (NAME$, VALUE$) EXTERNAL
 319: 0000:         STRING NAME$
 320: 0000:         STRING VALUE$
 321: 0000:     END SUB
 322: 0000:     
 323: 0000: !******************************************************************************
 324: 0000: !   NOTE: PLEASE BE VERY CAREFUL WITH THE SECOND PARAMETER TO THIS SUB
 325: 0000: !   Always use an absolute variable for VALUE$:
 326: 0000: !       CALL EVAL.SET.UPDATABLE ("MY.VAR$", MY.VAR$)
 327: 0000: !   NEVER use a calcualted value. These forms are all ILLEGAL:
 328: 0000: !       CALL EVAL.SET.UPDATABLE ("MY.VAR$", "1234")
 329: 0000: !       CALL EVAL.SET.UPDATABLE ("MY.VAR$", STR$(MY.VAR%))
 330: 0000: !   Also, if you MUST pass in an array element, for example:
 331: 0000: !       CALL EVAL.SET.UPDATABLE ("MY.VAR$", ARRAY.ELEMENT$(I%))
 332: 0000: !   then you must make sure you do not reDIM the array until the expression
 333: 0000: !   evaluator has finished using the variable.
 334: 0000: 
 335: 0000:     SUB EVAL.SET.UPDATABLE (NAME$, VALUE$) EXTERNAL
 336: 0000:         STRING NAME$
 337: 0000:         STRING VALUE$
 338: 0000:     END SUB
 339: 0000:     
 340: 0000: !******************************************************************************
 341: 0000: 
 342: 0000:     SUB EVAL.DELETE.VARIABLE (NAME$) EXTERNAL
 343: 0000:         STRING NAME$
 344: 0000:     END SUB
 345: 0000: 
 346: 0000: !******************************************************************************
 347: 0000: 
 348: 0000:     FUNCTION EVAL.GET.VARIABLE$ (NAME$) EXTERNAL
 349: 0000:         STRING NAME$
 350: 0000:         STRING EVAL.GET.VARIABLE$
 351: 0000:     END FUNCTION
 352: 0000: 
 353: 0000: !******************************************************************************
 354: 0000:     
 355: 0000: %INCLUDE PSBF49E.J86                                                    !BJK
 356: 0000: \******************************************************************************
 357: 0000: \******************************************************************************
 358: 0000: \***
 359: 0000: \***            PROGRAM         :       PSBF49
 360: 0000: \***            MODULE          :       PSBF49E (External declarations)
 361: 0000: \***            AUTHOR          :       Tittoo Thomas
 362: 0000: \***            DATE WRITTEN    :       October 2013
 363: 0000: \***
 364: 0000: \******************************************************************************
 365: 0000: \***
 366: 0000: \***   External function declarations for the re-usable functions included
 367: 0000: \***   in PSBF49
 368: 0000: \***
 369: 0000: \******************************************************************************
 370: 0000: \******************************************************************************
 371: 0000: \***
 372: 0000: \***   VERSION A                    Tittoo Thomas                    7 Oct 2013
 373: 0000: \***   Initial version.
 374: 0000: \***
 375: 0000: \******************************************************************************
 376: 0000: \******************************************************************************
 377: 0000: 
 378: 0000: 
 379: 0000: \******************************************************************************
 380: 0000: \***
 381: 0000: \***    FUNC.PROC.DELIM.STR%
 382: 0000: \***    Process an input string (INPUT$) delimited by an ASCII string (DELIM$).
 383: 0000: \***    Each chanracter sequence between the delimiter string is broken down to
 384: 0000: \***    tokens and stored as a global array (DELIM.STR.ELEMENTS$) elements.
 385: 0000: \***
 386: 0000: \***    The arguments RANGE.START% and ELEMENT.LIMIT% determine a range of
 387: 0000: \***    positions in the global array to hold the processed tokens. The first
 388: 0000: \***    position in the defined range will have the count of delimited tokens
 389: 0000: \***    successfully processed. The tokens themselves will be stored in the
 390: 0000: \***    following positions.
 391: 0000: \***
 392: 0000: \***    If there exists more elements in the string than what could be stored
 393: 0000: \***    in the range (i.e. postn [RANGE.START%+1] to postn ELEMENT.LIMIT%),
 394: 0000: \***    the ADDITIONAL.ELEMENTS% flag will be set to -1, and the remaining
 395: 0000: \***    elements discarded.
 396: 0000: \***
 397: 0000: \***    If the STRIP.SPACES% variable is set to -1, the spaces any leading
 398: 0000: \***    or trailing spaces are stripped off before storing into the array.
 399: 0000: \***
 400: 0000: \***    The DELIM.STR.ELEMENTS$ array should be dimensioned to hold a minimum
 401: 0000: \***    of ELEMENT.LIMIT% elements.
 402: 0000: \***
 403: 0000: \***    In case of an error the function will return a non-zero value
 404: 0000: \***
 405: 0000: \******************************************************************************
 406: 0000: 
 407: 0000: FUNCTION FUNC.PROC.DELIM.STR%( INPUT$, DELIM$, RANGE.START%,            \
 408: 0000:                                ELEMENT.LIMIT%, STRIP.SPACES%) EXTERNAL
 409: 0000:     STRING    INPUT$,                                                   \
 410: 0000:               DELIM$
 411: 0000: 
 412: 0000:     INTEGER*1 STRIP.SPACES%
 413: 0000: 
 414: 0000:     INTEGER*2 ELEMENT.LIMIT%,                                           \
 415: 0000:               FUNC.PROC.DELIM.STR%,                                     \
 416: 0000:               RANGE.START%
 417: 0000: 
 418: 0000: END FUNCTION
 419: 0000: 
 420: 0000: 
 421: 0000: \******************************************************************************
 422: 0000: \***
 423: 0000: \***    FUNC.CHECK.FILE.SIZE%
 424: 0000: \***    Check if the filename specified exists
 425: 0000: \***    If the file exists it returns the file size, else a negative value
 426: 0000: \***
 427: 0000: \******************************************************************************
 428: 0000: 
 429: 0000: FUNCTION FUNC.CHECK.FILE.SIZE%(CHECK.FILEPATH$) EXTERNAL
 430: 0000: 
 431: 0000:     INTEGER*4 FUNC.CHECK.FILE.SIZE%
 432: 0000:     STRING    CHECK.FILEPATH$
 433: 0000: 
 434: 0000: END FUNCTION
 435: 0000: %INCLUDE DMEXTR.J86       ! I.B.M. DISPLAY MANAGER ext functions
 436: 0000: \/* TIME STAMP BLOCK **************************************************
 437: 0000: \** END OF TIME STAMP BLOCK ******************************************/
 438: 0000:  REM  INCLUDE FILE FOR  DISPLAY MANAGER EXTERNAL FUNCTIONS FOR CB80  June 7/82
 439: 0000:  REM  IR91470 01 10 91  LAB G53  marked for EFT
 440: 0000:         DEF CLRSCR EXTERNAL             REM Clear screen for Display Manager
 441: 0000:         INTEGER CLRSCR
 442: 0000:         FEND
 443: 0000:         DEF CLSDIS EXTERNAL
 444: 0000:         INTEGER CLSDIS
 445: 0000:         FEND                            REM Close Display Manager
 446: 0000:         DEF DISPD(I%) EXTERNAL          REM Display a display.
 447: 0000:         INTEGER DISPD
 448: 0000:         FEND
 449: 0000:         DEF CURS(X$) EXTERNAL           REM turn on/off cursor visibility.
 450: 0000:         STRING CURS
 451: 0000:         FEND
 452: 0000:         DEF ENDF EXTERNAL               REM ENDF method of return.
 453: 0000:         INTEGER ENDF
 454: 0000:         FEND
 455: 0000:         DEF GETF EXTERNAL               REM GETF get data from a field
 456: 0000:         STRING GETF
 457: 0000:         FEND
 458: 0000:         DEF INITDM(A$) EXTERNAL         REM INITIALIZE Display Manager
 459: 0000:         INTEGER INITDM
 460: 0000:         FEND
 461: 0000:         DEF NXTF(I%)  EXTERNAL          REM NXTF Go to Next Field
 462: 0000:         INTEGER NXTF
 463: 0000:         FEND
 464: 0000:         DEF POSF(I%) EXTERNAL           REM POSTION on Field
 465: 0000:         INTEGER POSF
 466: 0000:         FEND
 467: 0000: 
 468: 0000:         DEF OPNDIS(A$) EXTERNAL         REM OPEN DISPLAY FILE
 469: 0000:         INTEGER OPNDIS
 470: 0000:         FEND
 471: 0000:         DEF PUTF(A$)  EXTERNAL          REM PUT data to Field
 472: 0000:         INTEGER PUTF
 473: 0000:         FEND
 474: 0000:         DEF RESF(I%)  EXTERNAL          REM RESUME field
 475: 0000:         STRING RESF
 476: 0000:         FEND
 477: 0000: 
 478: 0000:         DEF RETDM  EXTERNAL             REM RETURN Display Mgr Characteristics
 479: 0000:         STRING RETDM
 480: 0000:         FEND
 481: 0000:         DEF SETF(A$) EXTERNAL           REM SET Field  video attributes
 482: 0000:         STRING SETF
 483: 0000:         FEND
 484: 0000:         DEF UPDF  EXTERNAL                      REM UPDATE Field data
 485: 0000:         STRING UPDF
 486: 0000:         FEND
 487: 0000: 
 488: 0000:         DEF RETF EXTERNAL
 489: 0000:         STRING RETF
 490: 0000:         FEND
 491: 0000:    REM  END OF INCLUDE FILE FOR DISPLAY MANAGER CALLS FOR CB80
 492: 0000: %INCLUDE ADXEXT.J86
 493: 0000: 
 494: 0000: !****************************************************************************
 495: 0000: !***
 496: 0000: !***    DEFINITIONS OF VARIOUS ADX FUNCTIONS
 497: 0000: !***
 498: 0000: !****************************************************************************
 499: 0000: 
 500: 0000: FUNCTION ADXERROR (TERM, MSGGRP, MSGNUM, SEVERITY, EVENT, UNIQUE) EXTERNAL
 501: 0000: INTEGER*2 TERM, MSGNUM, ADXERROR
 502: 0000: INTEGER*1 SEVERITY, MSGGRP, EVENT
 503: 0000: STRING UNIQUE
 504: 0000: END FUNCTION
 505: 0000: 
 506: 0000: SUB ADXSERVE (RET, FUNC, PARM1, PARM2) EXTERNAL
 507: 0000: INTEGER*4 RET
 508: 0000: INTEGER*2 FUNC, PARM1
 509: 0000: STRING PARM2
 510: 0000: END SUB
 511: 0000: 
 512: 0000: SUB ADXSERCL EXTERNAL
 513: 0000: END SUB
 514: 0000: 
 515: 0000: 
 516: 0000: !******************************************************************************
 517: 0000: !***
 518: 0000: !***    DM.FIELD.CHANGED
 519: 0000: !***    A user exit which is called each time a field on the screen is updated
 520: 0000: !***
 521: 0000: 
 522: 0000: SUB DM.FIELD.CHANGED (SCREEN%, FIELD%, VALUE$, VALID, UPDATE) EXTERNAL
 523: 0000: 
 524: 0000:     INTEGER*2   SCREEN%     !Current screen number
 525: 0000:     INTEGER*2   FIELD%      !Field modifed
 526: 0000:     STRING      VALUE$      !New value for field (can be modified)
 527: 0000:     INTEGER*1   VALID       !Return FALSE if field is invalid
 528: 0000:     INTEGER*1   UPDATE      !Return TRUE if fields changed
 529: 0000: 
 530: 0000: END SUB
 531: 0000: 
 532: 0000: 
 533: 0000: !******************************************************************************
 534: 0000: !***
 535: 0000: !***    DM.CHECK.ERROR
 536: 0000: !***    Checks for an error after a call to the runtime expression evaluator
 537: 0000: !***
 538: 0000: 
 539: 0000: SUB DM.CHECK.ERROR                                                          !CSWM
 540: 0014: 
 541: 0014:     IF LEN(F38.EVAL.ERROR$) THEN BEGIN                                      !CSWM
 542: 0029: 
 543: 0029:         CLEARS                                                              !CSWM
 544: 0030:         PRINT "PSBF39 ENHANCED DISPLAY MANAGER API"                         !CSWM
 545: 0039:         PRINT                                                               !CSWM
 546: 003e:         PRINT "Detected error from runtime expression evaluator:"           !CSWM
 547: 0047:         PRINT F38.EVAL.ERROR$                                               !CSWM
 548: 0057:         PRINT                                                               !CSWM
 549: 005c:         PRINT "Last runtime expression:"                                    !CSWM
 550: 0065:         PRINT DETOKENISE$(F38.LAST.EXPR$)                                   !CSWM
 551: 007d:         PRINT                                                               !CSWM
 552: 0082:         PRINT "Press Ctrl+C to exit"                                        !CSWM
 553: 008b: 
 554: 008b:         WHILE 1                                                             !CSWM
 555: 008d:             WAIT ;1000                                                      !CSWM
 556: 009c:         WEND                                                                !CSWM
 557: 009e: 
 558: 009e:     ENDIF                                                                   !CSWM
 559: 009e: 
 560: 009e: END SUB                                                                     !CSWM
 561: 00aa: 
 562: 00aa: 
 563: 00aa: !******************************************************************************
 564: 00aa: !***
 565: 00aa: !***    SET.CF
 566: 00aa: !***    Updates the current field, adjusting ?39.CF$ at the same time
 567: 00aa: !***
 568: 00aa: 
 569: 00aa: FUNCTION SET.CF (FIELD%)                                                    !DSWM
 570: 00be: 
 571: 00be:     INTEGER*2 FIELD%                                                        !DSWM
 572: 00be:     INTEGER*2 SET.CF                                                        !DSWM
 573: 00be: 
 574: 00be:     ?F39.CF% = FIELD%                                                       !DSWM
 575: 00c8:     IF FIELD% >= 2 AND FIELD% <= FIELD.COUNT% THEN BEGIN                    !DSWM
 576: 00e2:         ?F39.CF$ = NAME$(FIELD%)                                            !DSWM
 577: 0104:     ENDIF ELSE BEGIN                                                        !DSWM
 578: 0104:         ?F39.CF$ = ""                                                       !DSWM
 579: 0113:     ENDIF                                                                   !DSWM
 580: 0113:     SET.CF = ?F39.CF%                                                       !DSWM
 581: 011d: 
 582: 011d: END FUNCTION                                                                !DSWM
 583: 012c: 
 584: 012c: 
 585: 012c: !******************************************************************************
 586: 012c: !***
 587: 012c: !***    IS.VISIBLE.FIELD
 588: 012c: !***    Returns true if the currently selected DM field is visible
 589: 012c: !***
 590: 012c: 
 591: 012c: FUNCTION IS.VISIBLE.FIELD
 592: 0140: 
 593: 0140:     INTEGER*1   IS.VISIBLE.FIELD
 594: 0140: 
 595: 0140:     STATE$ = SETF("")
 596: 0152:     IS.VISIBLE.FIELD = LEFT$(STATE$, 1) = "0"
 597: 0189: 
 598: 0189: END FUNCTION
 599: 0198: 
 600: 0198: 
 601: 0198: !******************************************************************************
 602: 0198: !***
 603: 0198: !***    IS.INFUT.FIELD
 604: 0198: !***    Returns true if the currently selected DM field is an input field
 605: 0198: !***
 606: 0198: 
 607: 0198: FUNCTION IS.INPUT.FIELD
 608: 01ac: 
 609: 01ac:     INTEGER*1   IS.INPUT.FIELD
 610: 01ac: 
 611: 01ac:     STATE$ = RETF
 612: 01ba:     IS.INPUT.FIELD = MID$(STATE$, 8, 1) = "I"
 613: 01f1: 
 614: 01f1: END FUNCTION
 615: 0200: 
 616: 0200: 
 617: 0200: !******************************************************************************
 618: 0200: !***
 619: 0200: !***    IS.OUTPUT.FIELD
 620: 0200: !***    Returns true if the currently selected DM field is an output field
 621: 0200: !***
 622: 0200: 
 623: 0200: FUNCTION IS.OUTPUT.FIELD
 624: 0214: 
 625: 0214:     INTEGER*1   IS.OUTPUT.FIELD
 626: 0214: 
 627: 0214:     STATE$ = RETF
 628: 0222:     IS.OUTPUT.FIELD = MID$(STATE$, 8, 1) = "O"
 629: 0259: 
 630: 0259: END FUNCTION
 631: 0268: 
 632: 0268: 
 633: 0268: !******************************************************************************
 634: 0268: !***
 635: 0268: !***    IS.DATE.FIELD
 636: 0268: !***    Returns true if the field given is defined as a date field
 637: 0268: !***
 638: 0268: 
 639: 0268: FUNCTION IS.DATE.FIELD (FIELD%)
 640: 027c: 
 641: 027c:     INTEGER*2   FIELD%
 642: 027c:     INTEGER*1   IS.DATE.FIELD
 643: 027c: 
 644: 027c: \E  IS.DATE.FIELD = MATCH("\"+CHR$(FIELD%), DATE.FIELDS$, 1) <> 0
 645: 027c:     IS.DATE.FIELD = (FIELD.FLAGS%(FIELD%) AND DATE.FLAG%) <> 0              !ESWM
 646: 029d: 
 647: 029d: END FUNCTION
 648: 02ac: 
 649: 02ac: 
 650: 02ac: !******************************************************************************
 651: 02ac: !***
 652: 02ac: !***    IS.TIME.FIELD
 653: 02ac: !***    Returns true if the field given is defined as a time field
 654: 02ac: !***
 655: 02ac: 
 656: 02ac: FUNCTION IS.TIME.FIELD (FIELD%)
 657: 02c0: 
 658: 02c0:     INTEGER*2   FIELD%
 659: 02c0:     INTEGER*1   IS.TIME.FIELD
 660: 02c0: 
 661: 02c0: \E  IS.TIME.FIELD = MATCH("\"+CHR$(FIELD%), TIME.FIELDS$, 1) <> 0
 662: 02c0: \   IS.DATE.FIELD = (FIELD.FLAGS%(FIELD%) AND TIME.FLAG%) <> 0              !ESWM
 663: 02c0:     IS.TIME.FIELD = (FIELD.FLAGS%(FIELD%) AND TIME.FLAG%) <> 0              !FNWB ESWM
 664: 02e1: 
 665: 02e1: END FUNCTION
 666: 02f0: 
 667: 02f0: 
 668: 02f0: !******************************************************************************
 669: 02f0: !***
 670: 02f0: !***    IS.RO.FIELD
 671: 02f0: !***    Returns true if the field given is defined as a read only field
 672: 02f0: !***
 673: 02f0: 
 674: 02f0: FUNCTION IS.RO.FIELD (FIELD%)                                               !ESWM
 675: 0304: 
 676: 0304:     INTEGER*2   FIELD%                                                      !ESWM
 677: 0304:     INTEGER*1   IS.RO.FIELD                                                 !ESWM
 678: 0304: 
 679: 0304:     IS.RO.FIELD = (FIELD.FLAGS%(FIELD%) AND RO.FLAG%) <> 0                  !ESWM
 680: 0325: 
 681: 0325: END FUNCTION                                                                !ESWM
 682: 0334: 
 683: 0334: 
 684: 0334: !******************************************************************************
 685: 0334: !***
 686: 0334: !***    IS.OO.FIELD
 687: 0334: !***    Returns true if the field given is defined as a read only field
 688: 0334: !***
 689: 0334: 
 690: 0334: FUNCTION IS.OO.FIELD (FIELD%)                                               !FNWB
 691: 0348: 
 692: 0348:     INTEGER*2   FIELD%                                                      !FNWB
 693: 0348:     INTEGER*1   IS.OO.FIELD                                                 !FNWB
 694: 0348: 
 695: 0348:     IS.OO.FIELD = (FIELD.FLAGS%(FIELD%) AND OUT.FLAG%) <> 0                 !FNWB
 696: 0369: 
 697: 0369: END FUNCTION                                                                !FNWB
 698: 0378: 
 699: 0378: 
 700: 0378: !******************************************************************************
 701: 0378: !***
 702: 0378: !***    GET.FIELD.ROW
 703: 0378: !***    Returns the row of the current DM field
 704: 0378: !***
 705: 0378: 
 706: 0378: FUNCTION GET.FIELD.ROW
 707: 038c: 
 708: 038c:     INTEGER*2   GET.FIELD.ROW
 709: 038c: 
 710: 038c:     STATE$ = RETF
 711: 039a:     GET.FIELD.ROW = ASC(MID$(STATE$, 1, 1))
 712: 03b6: 
 713: 03b6: END FUNCTION
 714: 03c5: 
 715: 03c5: 
 716: 03c5: !******************************************************************************
 717: 03c5: !***
 718: 03c5: !***    GET.FIELD.COL
 719: 03c5: !***    Returns the column of the current DM field
 720: 03c5: !***
 721: 03c5: 
 722: 03c5: FUNCTION GET.FIELD.COL
 723: 03d9: 
 724: 03d9:     INTEGER*2   GET.FIELD.COL
 725: 03d9: 
 726: 03d9:     STATE$ = RETF
 727: 03e7:     GET.FIELD.COL = ASC(MID$(STATE$, 3, 1))
 728: 0403: 
 729: 0403: END FUNCTION
 730: 0412: 
 731: 0412: 
 732: 0412: !******************************************************************************
 733: 0412: !***
 734: 0412: !***    GET.FIELD.LEN
 735: 0412: !***    Returns the length of the current DM field
 736: 0412: !***
 737: 0412: 
 738: 0412: FUNCTION GET.FIELD.LEN
 739: 0426: 
 740: 0426:     INTEGER*2   GET.FIELD.LEN
 741: 0426: 
 742: 0426:     STATE$ = RETF
 743: 0434:     GET.FIELD.LEN = ASC(MID$(STATE$, 5, 1))
 744: 0450: 
 745: 0450: END FUNCTION
 746: 045f: 
 747: 045f: 
 748: 045f: !******************************************************************************
 749: 045f: !***
 750: 045f: !***    EXT.DATE$
 751: 045f: !***    Converts a date from internal (YYMMDD) format to external format
 752: 045f: !***    according to the system date format (i.e. DDMMYY or MMDDYY).
 753: 045f: !***
 754: 045f: 
 755: 045f: FUNCTION EXT.DATE$ (IN.DATE$)
 756: 0478: 
 757: 0478:     STRING      IN.DATE$
 758: 0478:     STRING      EXT.DATE$
 759: 0478: 
 760: 0478:     IF IN.DATE$ = "" THEN BEGIN
 761: 0489:         EXT.DATE$ = "      "
 762: 0497:         EXIT FUNCTION
 763: 049a:     ENDIF
 764: 049a: 
 765: 049a:     !Internal date is YYMMDD format
 766: 049a:     IN.DATE$ = RIGHT$("000000" + IN.DATE$, 6)
 767: 04c7: 
 768: 04c7:     IF DATE.FORMAT% = 2 OR DATE.FORMAT% = 4 THEN BEGIN
 769: 04e0:         !External date is DDMMYY format
 770: 04e0:         EXT.DATE$ = RIGHT$(IN.DATE$, 2) + MID$(IN.DATE$, 3, 2) +            \
 771: 0530:                     LEFT$(IN.DATE$, 2)
 772: 0530:     ENDIF ELSE BEGIN
 773: 0530:         !External date is MMDDYY format
 774: 0530:         EXT.DATE$ = MID$(IN.DATE$, 3, 2) + RIGHT$(IN.DATE$, 2) +            \
 775: 057e:                     LEFT$(IN.DATE$, 2)
 776: 057e:     ENDIF
 777: 057e: 
 778: 057e: END FUNCTION
 779: 0594: 
 780: 0594: 
 781: 0594: !******************************************************************************
 782: 0594: !***
 783: 0594: !***    INT.DATE$
 784: 0594: !***    Converts a date from external (i.e. DDMMYY or MMDDYY) format to
 785: 0594: !***    internal (YYMMDD) format according to the system date format.
 786: 0594: !***
 787: 0594: 
 788: 0594: FUNCTION INT.DATE$ (EX.DATE$)
 789: 05ad: 
 790: 05ad:     STRING      EX.DATE$
 791: 05ad:     STRING      INT.DATE$
 792: 05ad: 
 793: 05ad:     IF EX.DATE$ = "" THEN BEGIN
 794: 05be:         INT.DATE$ = "      "
 795: 05cc:         EXIT FUNCTION
 796: 05cf:     ENDIF
 797: 05cf: 
 798: 05cf:     !Pad external date
 799: 05cf:     EX.DATE$ = LEFT$(EX.DATE$ + "000000", 6)
 800: 05fe: 
 801: 05fe:     IF DATE.FORMAT% = 2 OR DATE.FORMAT% = 4 THEN BEGIN
 802: 0617:         !External date is DDMMYY format
 803: 0617:         INT.DATE$ = RIGHT$(EX.DATE$, 2) + MID$(EX.DATE$, 3, 2) +            \
 804: 0667:                     LEFT$(EX.DATE$, 2)
 805: 0667:     ENDIF ELSE BEGIN
 806: 0667:         !External date is MMDDYY format
 807: 0667:         INT.DATE$ = RIGHT$(EX.DATE$, 2) + LEFT$(EX.DATE$, 2) +              \
 808: 06b5:                     MID$(EX.DATE$, 3, 2)
 809: 06b5:     ENDIF
 810: 06b5: 
 811: 06b5: END FUNCTION
 812: 06cb: 
 813: 06cb: 
 814: 06cb: !******************************************************************************
 815: 06cb: !***
 816: 06cb: !***    SEP.DATE$
 817: 06cb: !***    Adds date seperators to the supplied date.
 818: 06cb: !***
 819: 06cb: 
 820: 06cb: FUNCTION SEP.DATE$ (IN.DATE$)                                               !CSWM
 821: 06e4: 
 822: 06e4:     STRING SEP.DATE$                                                        !CSWM
 823: 06e4:     STRING IN.DATE$                                                         !CSWM
 824: 06e4: 
 825: 06e4:     SEP.DATE$ = MID$(IN.DATE$,1,2) + CHAR.DATE$ +                           \CSWM
 826: 0744:                 MID$(IN.DATE$,3,2) + CHAR.DATE$ +                           \CSWM
 827: 0744:                 MID$(IN.DATE$,5,2)                                          !CSWM
 828: 0744: 
 829: 0744: END FUNCTION                                                                !CSWM
 830: 075a: 
 831: 075a: 
 832: 075a: !******************************************************************************
 833: 075a: !***
 834: 075a: !***    EXT.TIME$
 835: 075a: !***    Converts a time to internal format (either HHMM or HHMMSS) to external
 836: 075a: !***    HHMMSS format.
 837: 075a: !***
 838: 075a: 
 839: 075a: FUNCTION EXT.TIME$ (IN.TIME$)                                               !CSWM
 840: 0773: 
 841: 0773:     STRING      IN.TIME$                                                    !CSWM
 842: 0773:     STRING      EXT.TIME$                                                   !CSWM
 843: 0773: 
 844: 0773:     IF GET.FIELD.LEN <= 5 THEN BEGIN                                        !CSWM
 845: 077c:         IF IN.TIME$ = "" THEN BEGIN                                         !CSWM
 846: 078d:             EXT.TIME$ = "    "                                              !CSWM
 847: 079d:         ENDIF ELSE BEGIN                                                    !CSWM
 848: 079d:             !Internal time is HHMM format                                   !CSWM
 849: 079d:             EXT.TIME$ = RIGHT$("0000" + IN.TIME$, 4)                        !CSWM
 850: 07ca:         ENDIF                                                               !CSWM
 851: 07cc:     ENDIF ELSE BEGIN                                                        !CSWM
 852: 07cc:         IF IN.TIME$ = "" THEN BEGIN                                         !CSWM
 853: 07dd:             EXT.TIME$ = "      "                                            !CSWM
 854: 07ed:         ENDIF ELSE BEGIN                                                    !CSWM
 855: 07ed:             !Internal time is HHMMSS format                                 !CSWM
 856: 07ed:             EXT.TIME$ = RIGHT$("000000" + IN.TIME$, 6)                      !CSWM
 857: 081a:         ENDIF                                                               !CSWM
 858: 081a:     ENDIF                                                                   !CSWM
 859: 081a: 
 860: 081a: END FUNCTION                                                                !CSWM
 861: 0830: 
 862: 0830: 
 863: 0830: !******************************************************************************
 864: 0830: !***
 865: 0830: !***    INT.TIME$
 866: 0830: !***    Converts a time to external format (HHMMSS) from internal displayed
 867: 0830: !***    format, which could be either HHMM or HHMMSS.
 868: 0830: !***
 869: 0830: 
 870: 0830: FUNCTION INT.TIME$ (EX.TIME$)                                               !CSWM
 871: 0849: 
 872: 0849:     STRING      EX.TIME$                                                    !CSWM
 873: 0849:     STRING      INT.TIME$                                                   !CSWM
 874: 0849: 
 875: 0849:     IF GET.FIELD.LEN <= 5 THEN BEGIN                                        !CSWM
 876: 0852:         IF EX.TIME$ = "" THEN BEGIN                                         !CSWM
 877: 0863:             INT.TIME$ = "    "                                              !CSWM
 878: 0873:         ENDIF ELSE BEGIN                                                    !CSWM
 879: 0873:             INT.TIME$ = LEFT$(EX.TIME$ + "0000", 4)                         !CSWM
 880: 08a2:         ENDIF                                                               !CSWM
 881: 08a4:     ENDIF ELSE BEGIN                                                        !CSWM
 882: 08a4:         IF EX.TIME$ = "" THEN BEGIN                                         !CSWM
 883: 08b5:             INT.TIME$ = "      "                                            !CSWM
 884: 08c5:         ENDIF ELSE BEGIN                                                    !CSWM
 885: 08c5:             INT.TIME$ = LEFT$(EX.TIME$ + "000000", 6)                       !CSWM
 886: 08f4:         ENDIF                                                               !CSWM
 887: 08f4:     ENDIF                                                                   !CSWM
 888: 08f4: 
 889: 08f4: END FUNCTION                                                                !CSWM
 890: 090a: 
 891: 090a: 
 892: 090a: !******************************************************************************
 893: 090a: !***
 894: 090a: !***    SEP.TIME$
 895: 090a: !***    Adds time separators to the supplied time.
 896: 090a: !***
 897: 090a: 
 898: 090a: FUNCTION SEP.TIME$ (IN.TIME$)                                               !CSWM
 899: 0923: 
 900: 0923:     STRING SEP.TIME$                                                        !CSWM
 901: 0923:     STRING IN.TIME$                                                         !CSWM
 902: 0923: 
 903: 0923:     IF LEN(IN.TIME$) <= 4 THEN BEGIN                                        !CSWM
 904: 0934:         SEP.TIME$ = MID$(IN.TIME$,1,2) + CHAR.TIME$ +                       \CSWM
 905: 0974:                     MID$(IN.TIME$,3,2)                                      !CSWM
 906: 0974:     ENDIF ELSE BEGIN                                                        !CSWM
 907: 0974:         SEP.TIME$ = MID$(IN.TIME$,1,2) + CHAR.TIME$ +                       \CSWM
 908: 09d4:                     MID$(IN.TIME$,3,2) + CHAR.TIME$ +                       \CSWM
 909: 09d4:                     MID$(IN.TIME$,5,2)                                      !CSWM
 910: 09d4:     ENDIF                                                                   !CSWM
 911: 09d4: 
 912: 09d4: END FUNCTION                                                                !CSWM
 913: 09ea: 
 914: 09ea: 
 915: 09ea: !******************************************************************************
 916: 09ea: !***
 917: 09ea: !***    FORMAT.DATE$
 918: 09ea: !***    Formats a supplied date to DD MMM YYYY format.
 919: 09ea: !***
 920: 09ea: 
 921: 09ea: FUNCTION FORMAT.DATE$ (IN.DATE$)
 922: 0a03: 
 923: 0a03:     STRING      IN.DATE$
 924: 0a03:     STRING      FORMAT.DATE$
 925: 0a03:     STRING      MONTH$
 926: 0a03:     INTEGER*2   YEAR%
 927: 0a03:     INTEGER*2   MONTH%
 928: 0a03:     INTEGER*2   DAY%
 929: 0a03: 
 930: 0a03:     YEAR% = VAL(LEFT$(IN.DATE$, 2))
 931: 0a1f:     MONTH% = VAL(MID$(IN.DATE$, 3, 2))
 932: 0a3b:     DAY% = VAL(RIGHT$(IN.DATE$, 2))
 933: 0a55: 
 934: 0a55:     IF YEAR% >= 90 THEN BEGIN
 935: 0a5c:         YEAR% = YEAR% + 1900
 936: 0a64:     ENDIF ELSE BEGIN
 937: 0a64:         YEAR% = YEAR% + 2000
 938: 0a6a:     ENDIF
 939: 0a6a: 
 940: 0a6a:     MONTH$ = "   JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC"
 941: 0a77:     FORMAT.DATE$ = STR$(DAY%) + " " + MID$(MONTH$, MONTH%*3+1, 3) +     \
 942: 0ace:                    " " + STR$(YEAR%)
 943: 0ace: 
 944: 0ace: END FUNCTION
 945: 0ae4: 
 946: 0ae4: 
 947: 0ae4: !******************************************************************************
 948: 0ae4: !***
 949: 0ae4: !***    DISPLAY.TITLE.AND.DATE
 950: 0ae4: !***    Displays the screen title and date
 951: 0ae4: !***
 952: 0ae4: 
 953: 0ae4: SUB DISPLAY.TITLE.AND.DATE
 954: 0af8: 
 955: 0af8:     IF CURRENT.TITLE$ <> "" THEN BEGIN
 956: 0b0e: 
 957: 0b0e:         DM.FIELD% = POSF(TITLE.FIELD%)
 958: 0b20:         LEN% = GET.FIELD.LEN
 959: 0b27: 
 960: 0b27:         IF LEN% <= LEN(CURRENT.TITLE$) THEN BEGIN
 961: 0b3b:             TEMP$ = LEFT$(CURRENT.TITLE$, LEN%)
 962: 0b59:         ENDIF ELSE BEGIN
 963: 0b59:             LEN% = LEN% - LEN(CURRENT.TITLE$)
 964: 0b6b:             TEMP$ = STRING$(LEN% / 2, " ") + CURRENT.TITLE$
 965: 0b9d:         ENDIF
 966: 0b9d: 
 967: 0b9d:         RC% = PUTF(TEMP$)
 968: 0bb0: 
 969: 0bb0:     ENDIF
 970: 0bb0: 
 971: 0bb0:     DM.FIELD% = POSF(DATE.FIELD%)
 972: 0bc2:     TEMP$ = FORMAT.DATE$ (DATE$)
 973: 0bd4:     RC% = PUTF(TEMP$)
 974: 0be7: 
 975: 0be7: END SUB
 976: 0bf3: 
 977: 0bf3: 
 978: 0bf3: !******************************************************************************
 979: 0bf3: !***
 980: 0bf3: !***    DM.INIT
 981: 0bf3: !***    Initialises PSBF39 display manager functions for use
 982: 0bf3: !***
 983: 0bf3: 
 984: 0bf3: FUNCTION DM.INIT PUBLIC
 985: 0c07: 
 986: 0c07:     INTEGER*1   DM.INIT
 987: 0c07: 
 988: 0c07:     DM.INIT = 1
 989: 0c0b: 
 990: 0c0b:     TRUE = -1
 991: 0c10:     FALSE = 0
 992: 0c15: 
 993: 0c15:     DISPLAY.ORDER = 0                                                       !DSWM
 994: 0c1a:     NUMBER.ORDER = 1                                                        !DSWM
 995: 0c1f:     FIELD.TAB.ORDER = DISPLAY.ORDER                                         !DSWM
 996: 0c25: 
 997: 0c25:     HOME.KEY% = 327
 998: 0c2e:     END.KEY%  = 335
 999: 0c37:     PGUP.KEY% = 329
1000: 0c40:     PGDN.KEY% = 337
1001: 0c49: 
1002: 0c49:     TAB.KEY%  = 9
1003: 0c52:     BTAB.KEY% = 8217
1004: 0c5b:     ESC.KEY%  = 27
1005: 0c64:     ENTER.KEY%= 0
1006: 0c6d: 
1007: 0c6d:     UP.KEY%   = 16                                                          !CSWM
1008: 0c76:     DOWN.KEY% = 17                                                          !CSWM
1009: 0c7f:     INS.KEY%  = 8201                                                        !DSWM
1010: 0c88:     NEXT.KEY% = 07FFEH                                                      !DSWM
1011: 0c91:     PREV.KEY% = 07FFFH                                                      !DSWM
1012: 0c9a: 
1013: 0c9a:     F1.KEY%   = -1
1014: 0ca3:     F2.KEY%   = -2
1015: 0cac:     F3.KEY%   = -3
1016: 0cb5:     F4.KEY%   = -4
1017: 0cbe:     F5.KEY%   = -5
1018: 0cc7:     F6.KEY%   = -6
1019: 0cd0:     F7.KEY%   = -7
1020: 0cd9:     F8.KEY%   = -8
1021: 0ce2:     F9.KEY%   = -9
1022: 0ceb:     F10.KEY%  = -10
1023: 0cf4: 
1024: 0cf4:     MESSAGE.FIELD% = 1
1025: 0cfa:     TITLE.FIELD% = 238
1026: 0d00:     DATE.FIELD% = 239
1027: 0d06:     INVISIBLE.FIELD% = 240
1028: 0d0c:     F.FIELD% = 240
1029: 0d12:     F1.FIELD% = 241
1030: 0d18:     F2.FIELD% = 242
1031: 0d1e:     F3.FIELD% = 243
1032: 0d24:     F4.FIELD% = 244
1033: 0d2a:     F5.FIELD% = 245
1034: 0d30:     F6.FIELD% = 246
1035: 0d36:     F7.FIELD% = 247
1036: 0d3c:     F8.FIELD% = 248
1037: 0d42:     F9.FIELD% = 249
1038: 0d48:     F10.FIELD%= 250
1039: 0d4e: 
1040: 0d4e:     DIM FN.VISIBLE$(10)                                                     !ASWM
1041: 0d6f:     DIM SAVED.FUNC.KEY$(10)                                                 !GCSK
1042: 0d90: 
1043: 0d90:     DATE.FLAG% = 1                                                          !ESWM
1044: 0d96:     TIME.FLAG% = 2                                                          !ESWM
1045: 0d9c:     RO.FLAG% = 4                                                            !ESWM
1046: 0da2:     OUT.FLAG% = 8                                                           !FNWB
1047: 0da8: 
1048: 0da8:     CALL ADXSERVE(ADX.RC%, 4, 0, TEMP$)
1049: 0dd8:     IF ADX.RC% = 0 THEN BEGIN
1050: 0deb:         DATE.FORMAT% = VAL(MID$(TEMP$, 5, 1))
1051: 0e09:         TIME.FORMAT% = VAL(MID$(TEMP$, 6, 1))                               !CSWM
1052: 0e29:     ENDIF ELSE BEGIN
1053: 0e29:         DATE.FORMAT% = 2
1054: 0e2f:         TIME.FORMAT% = 1                                                    !CSWM
1055: 0e35:     ENDIF
1056: 0e35: 
1057: 0e35:     IF DATE.FORMAT% = 1 OR DATE.FORMAT% = 2 THEN BEGIN                      !CSWM
1058: 0e4e:         CHAR.DATE$ = "/"                                                    !CSWM
1059: 0e5d:     ENDIF ELSE BEGIN                                                        !CSWM
1060: 0e5d:         CHAR.DATE$ = "."                                                    !CSWM
1061: 0e6a:     ENDIF                                                                   !CSWM
1062: 0e6a: 
1063: 0e6a:     IF TIME.FORMAT% = 1 THEN BEGIN                                          !CSWM
1064: 0e71:         CHAR.TIME$ = ":"                                                    !CSWM
1065: 0e80:     ENDIF ELSE BEGIN                                                        !CSWM
1066: 0e80:         CHAR.TIME$ = "."                                                    !CSWM
1067: 0e8d:     ENDIF                                                                   !CSWM
1068: 0e8d: 
1069: 0e8d:     RC% = INITDM ("AAAA")
1070: 0e9c: 
1071: 0e9c:     ! Display File                                                      !BJK
1072: 0e9c:     DISPLAY.FILE$ = "C:/ADX_UPGM/" + LEFT$(MODULE.NUMBER$, 8) + ".DAT"  !BJK
1073: 0ecf: 
1074: 0ecf:     ! Help File                                                         !BJK
1075: 0ecf:     HELP.FILE$ = "C:/ADX_UPGM/" + LEFT$(MODULE.NUMBER$, 7) + "H.DAT"    !BJK
1076: 0f02: 
1077: 0f02:     ! Setting the D disk Display file if the default file doesn't exist
1078: 0f02:     IF FUNC.CHECK.FILE.SIZE%(DISPLAY.FILE$) = -1 THEN BEGIN             !BJK
1079: 0f20:         DISPLAY.FILE$ = "D:/ADX_UPGM/" + LEFT$(MODULE.NUMBER$, 8) + \   !BJK
1080: 0f53:                         ".DAT"                                          !BJK
1081: 0f53:     ENDIF                                                               !BJK
1082: 0f53:     ! Setting the D disk Help file if the default file doesn't exist
1083: 0f53:     IF FUNC.CHECK.FILE.SIZE%(HELP.FILE$) = -1 THEN BEGIN                !BJK
1084: 0f71:         HELP.FILE$ = "D:/ADX_UPGM/" + LEFT$(MODULE.NUMBER$, 7) + "H.DAT"!BJK
1085: 0fa4:     ENDIF                                                               !BJK
1086: 0fa4: 
1087: 0fa4:     RC% = OPNDIS (DISPLAY.FILE$)
1088: 0fb7: 
1089: 0fb7:     DM.INIT = 0
1090: 0fbb: 
1091: 0fbb: END FUNCTION
1092: 0fca: 
1093: 0fca: 
1094: 0fca: !******************************************************************************
1095: 0fca: !***
1096: 0fca: !***    DM.QUIT
1097: 0fca: !***    Frees resources allocated by DM.INIT
1098: 0fca: !***
1099: 0fca: 
1100: 0fca: FUNCTION DM.QUIT PUBLIC
1101: 0fde: 
1102: 0fde:     INTEGER*1   DM.QUIT
1103: 0fde: 
1104: 0fde:     DM.QUIT = 1
1105: 0fe2: 
1106: 0fe2:     RC% = CLSDIS
1107: 0fea: 
1108: 0fea:     CURRENT.SCREEN% = 0
1109: 0ff0:     ?F39.CF% = 0                                                            !DSWM
1110: 0ff9:     ?F39.CF$ = ""                                                           !DSWM
1111: 1008:     FIELD.COUNT% = 0
1112: 100e:     FIRST.HELP.SCREEN% = 0
1113: 1014:     LAST.HELP.SCREEN% = 0
1114: 101a: 
1115: 101a:     DIM MESSAGE$(FIELD.COUNT%)
1116: 1043:     DIM VALID$(FIELD.COUNT%)
1117: 106c:     DIM VISIBLE$(FIELD.COUNT%)
1118: 1095:     DIM FIELD$(FIELD.COUNT%)
1119: 10be:     DIM NAME$(FIELD.COUNT%)                                                 !DSWM
1120: 10e1:     DIM NEXT.INPUT%(FIELD.COUNT%)                                           !DSWM
1121: 1104:     DIM PREV.INPUT%(FIELD.COUNT%)                                           !DSWM
1122: 1127: 
1123: 1127:     DIM FN.VISIBLE$(0)                                                      !ESWM
1124: 1148:     DIM FIELD.FLAGS%(0)                                                     !ESWM
1125: 1169:     DIM SAVED.FUNC.KEY$(0)                                                  !GCSK
1126: 118a: 
1127: 118a:     DISPLAY.FILE$ = ""
1128: 1197:     HELP.FILE$ = ""
1129: 11a4: 
1130: 11a4:     DM.QUIT = 0
1131: 11a8: 
1132: 11a8: END FUNCTION
1133: 11b7: 
1134: 11b7: 
1135: 11b7: !******************************************************************************
1136: 11b7: !***
1137: 11b7: !***    DM.SHOW.FN.KEY
1138: 11b7: !***    Makes a function key name visible with optional message
1139: 11b7: !***
1140: 11b7: 
1141: 11b7: FUNCTION DM.SHOW.FN.KEY (KEY.NUM%, MESSAGE$) PUBLIC
1142: 11d0: 
1143: 11d0:     INTEGER*1   DM.SHOW.FN.KEY
1144: 11d0:     INTEGER*2   KEY.NUM%
1145: 11d0:     STRING      MESSAGE$
1146: 11d0: 
1147: 11d0:     DM.SHOW.FN.KEY = 1
1148: 11d4: 
1149: 11d4:     !Move cursor to field
1150: 11d4:     RC% = POSF(F.FIELD% + KEY.NUM%)
1151: 11e5: 
1152: 11e5:     !Populate with optional message (otherwise use default)
1153: 11e5:     IF MESSAGE$ <> "" THEN BEGIN
1154: 11f6:         RC% = PUTF(MESSAGE$)
1155: 1207:     ENDIF
1156: 1207: 
1157: 1207:     !Make field visible
1158: 1207:     FN.VISIBLE$(KEY.NUM%) = TOKENISE$("TRUE")                               !ASWM
1159: 1225:     CALL DM.CHECK.ERROR                                                     !DSWM
1160: 1229:     TEMP$ = SETF("0")
1161: 123b: 
1162: 123b:     DM.SHOW.FN.KEY = 0
1163: 123f: 
1164: 123f: END FUNCTION
1165: 1253: 
1166: 1253: 
1167: 1253: !******************************************************************************
1168: 1253: !***
1169: 1253: !***    DM.HIDE.FN.KEY
1170: 1253: !***    Makes a function key invisible
1171: 1253: !***
1172: 1253: 
1173: 1253: FUNCTION DM.HIDE.FN.KEY (KEY.NUM%) PUBLIC
1174: 1267: 
1175: 1267:     INTEGER*1   DM.HIDE.FN.KEY
1176: 1267:     INTEGER*2   KEY.NUM%
1177: 1267: 
1178: 1267:     DM.HIDE.FN.KEY = 1
1179: 126b: 
1180: 126b:     !Move cursor to field
1181: 126b:     RC% = POSF(F.FIELD% + KEY.NUM%)
1182: 127c: 
1183: 127c:     !Make field invisible
1184: 127c:     FN.VISIBLE$(KEY.NUM%) = TOKENISE$("FALSE")                              !ASWM
1185: 129a:     CALL DM.CHECK.ERROR                                                     !DSWM
1186: 129e:     TEMP$ = SETF("1")
1187: 12b0: 
1188: 12b0:     DM.HIDE.FN.KEY = 0
1189: 12b4: 
1190: 12b4: END FUNCTION
1191: 12c3: 
1192: 12c3: 
1193: 12c3: !******************************************************************************
1194: 12c3: !***
1195: 12c3: !***    DM.FN.KEY.VISIBLE
1196: 12c3: !***    Sets the visibility expression for a function key
1197: 12c3: !***    This is the legacy function which takes a reverse polish expression
1198: 12c3: !***
1199: 12c3: 
1200: 12c3: FUNCTION DM.FN.KEY.VISIBLE (KEY.NUM%, EXPR$) PUBLIC                         !ASWM
1201: 12dc: 
1202: 12dc:     INTEGER*1   DM.FN.KEY.VISIBILITY                                        !ASWM
1203: 12dc:     INTEGER*2   KEY.NUM%                                                    !ASWM
1204: 12dc:     STRING      EXPR$                                                       !ASWM
1205: 12dc: 
1206: 12dc:     DM.FN.KEY.VISIBILITY = 1                                                !ASWM
1207: 12e1: 
1208: 12e1:     FN.VISIBLE$(KEY.NUM%) = TOKENISE$(EXPR$)                                !ASWM
1209: 1301:     CALL DM.CHECK.ERROR                                                     !DSWM
1210: 1305: 
1211: 1305:     DM.FN.KEY.VISIBILITY = 0                                                !ASWM
1212: 130a: 
1213: 130a: END FUNCTION                                                                !ASWM
1214: 131b: 
1215: 131b: 
1216: 131b: !******************************************************************************
1217: 131b: !***
1218: 131b: !***    DM.FN.VISIBLE
1219: 131b: !***    Sets the visibility expression for a function key
1220: 131b: !***    This is the new version which takes a infix notation expression
1221: 131b: !***
1222: 131b: 
1223: 131b: FUNCTION DM.FN.VISIBLE (KEY.NUM%, EXPR$) PUBLIC                             !DSWM
1224: 1334: 
1225: 1334:     INTEGER*1   DM.FN.VISIBILITY                                            !DSWM
1226: 1334:     INTEGER*2   KEY.NUM%                                                    !DSWM
1227: 1334:     STRING      EXPR$                                                       !DSWM
1228: 1334: 
1229: 1334:     DM.FN.VISIBILITY = 1                                                    !DSWM
1230: 1339:     EXPR$ = POLISH$(EXPR$)                                                  !DSWM
1231: 134e:     CALL DM.CHECK.ERROR                                                     !DSWM
1232: 1352:     DM.FN.VISIBILITY = DM.FN.KEY.VISIBLE (KEY.NUM%, EXPR$)                  !DSWM
1233: 136f: 
1234: 136f: END FUNCTION                                                                !DSWM
1235: 1380: 
1236: 1380: 
1237: 1380: !******************************************************************************
1238: 1380: !***
1239: 1380: !***    DM.SHOW.SCREEN
1240: 1380: !***    Displays a screen prior to accepting input
1241: 1380: !***
1242: 1380: 
1243: 1380: FUNCTION DM.SHOW.SCREEN (SCREEN%, TITLE$, FIRST.HELP%, LAST.HELP%) PUBLIC
1244: 1399: 
1245: 1399:     INTEGER*1   DM.SHOW.SCREEN
1246: 1399:     INTEGER*2   SCREEN%
1247: 1399:     STRING      TITLE$
1248: 1399:     INTEGER*2   FIRST.HELP%
1249: 1399:     INTEGER*2   LAST.HELP%
1250: 1399: 
1251: 1399:     DM.SHOW.SCREEN = 1
1252: 139d: 
1253: 139d:     !Save current screen number, title and help screen range
1254: 139d:     CURRENT.SCREEN% = SCREEN%
1255: 13a3:     CURRENT.TITLE$ = TITLE$
1256: 13b2:     FIRST.HELP.SCREEN% = FIRST.HELP%
1257: 13b8:     LAST.HELP.SCREEN% = LAST.HELP%
1258: 13bf: !E  DATE.FIELDS$ = ""
1259: 13bf: !E  TIME.FIELDS$ = ""                                                       !CSWM
1260: 13bf: 
1261: 13bf:     FIELDS.CHANGED = FALSE
1262: 13c7: 
1263: 13c7:     RC% = DISPD(CURRENT.SCREEN%)
1264: 13d5: 
1265: 13d5:     !Cursor off
1266: 13d5:     TEMP$ = CURS("1")
1267: 13e7: 
1268: 13e7:     CALL DISPLAY.TITLE.AND.DATE
1269: 13eb: 
1270: 13eb:     FIELD.COUNT% = 0
1271: 13f1:     RC% = NXTF(-10)
1272: 13fd:     WHILE RC% > 0
1273: 13ff:         IF RC% > FIELD.COUNT% AND RC% < 230 THEN BEGIN
1274: 1419:             FIELD.COUNT% = RC%
1275: 141f:         ENDIF
1276: 141f:         RC% = NXTF(1)
1277: 142b:     WEND
1278: 1432: 
1279: 1432:     CALL EVAL.CLEAR.ALL.VARIABLES                                           !DSWM
1280: 1437:     DIM MESSAGE$(FIELD.COUNT%)
1281: 1460:     DIM VALID$(FIELD.COUNT%)
1282: 1489:     DIM VISIBLE$(FIELD.COUNT%)
1283: 14b2:     DIM FIELD$(FIELD.COUNT%)
1284: 14db:     DIM NAME$(FIELD.COUNT%)                                                 !DSWM
1285: 14fe:     DIM NEXT.INPUT%(FIELD.COUNT%)                                           !DSWM
1286: 1521:     DIM PREV.INPUT%(FIELD.COUNT%)                                           !DSWM
1287: 1544: 
1288: 1544:     DIM FN.VISIBLE$(10)                                                     !ASWM
1289: 1565:     DIM FIELD.FLAGS%(255)                                                   !ESWM
1290: 1587: 
1291: 1587:     VALIDATE.KEYS$ = ":" + STR$(ENTER.KEY%) + ":"                           !BSWM
1292: 15b5: 
1293: 15b5:     IF FIELD.TAB.ORDER = DISPLAY.ORDER THEN BEGIN                           !DSWM
1294: 15be:         CALL SET.CF(NXTF(-20))                                              !DSWM
1295: 15d0:     ENDIF ELSE BEGIN                                                        !DSWM
1296: 15d0:         CALL SET.CF(2)                                                      !DSWM
1297: 15d8:     ENDIF                                                                   !DSWM
1298: 15d8: 
1299: 15d8:     DM.SHOW.SCREEN = 0
1300: 15dc: 
1301: 15dc: END FUNCTION
1302: 15f0: 
1303: 15f0: 
1304: 15f0: !******************************************************************************
1305: 15f0: !***
1306: 15f0: !***    DM.DATE.FIELD
1307: 15f0: !***    Defines a field as containing a date
1308: 15f0: !***
1309: 15f0: 
1310: 15f0: FUNCTION DM.DATE.FIELD (FIELD%) PUBLIC
1311: 1604: 
1312: 1604:     INTEGER*1   DM.DATE.FIELD
1313: 1604:     INTEGER*2   FIELD%
1314: 1604: 
1315: 1604:     DM.DATE.FIELD = 1
1316: 1608: 
1317: 1608: !E  DATE.FIELDS$ = DATE.FIELDS$ + CHR$(FIELD%)
1318: 1608:     FIELD.FLAGS%(FIELD%) = FIELD.FLAGS%(FIELD%) OR DATE.FLAG%               !ESWM
1319: 1634: 
1320: 1634:     DM.DATE.FIELD = 0
1321: 1638: 
1322: 1638: END FUNCTION
1323: 1647: 
1324: 1647: 
1325: 1647: !******************************************************************************
1326: 1647: !***
1327: 1647: !***    DM.TIME.FIELD
1328: 1647: !***    Defines a field as containing a time
1329: 1647: !***
1330: 1647: 
1331: 1647: FUNCTION DM.TIME.FIELD (FIELD%) PUBLIC                                      !CSWM
1332: 165b: 
1333: 165b:     INTEGER*1   DM.TIME.FIELD                                               !CSWM
1334: 165b:     INTEGER*2   FIELD%                                                      !CSWM
1335: 165b: 
1336: 165b:     DM.TIME.FIELD = 1                                                       !CSWM
1337: 165f: 
1338: 165f: !E  TIME.FIELDS$ = TIME.FIELDS$ + CHR$(FIELD%)                              !CSWM
1339: 165f:     FIELD.FLAGS%(FIELD%) = FIELD.FLAGS%(FIELD%) OR TIME.FLAG%               !ESWM
1340: 168b: 
1341: 168b:     DM.TIME.FIELD = 0                                                       !CSWM
1342: 168f: 
1343: 168f: END FUNCTION                                                                !CSWM
1344: 169e: 
1345: 169e: 
1346: 169e: !******************************************************************************
1347: 169e: !***
1348: 169e: !***    DM.RO.FIELD
1349: 169e: !***    Defines an input field as read only
1350: 169e: !***
1351: 169e: 
1352: 169e: FUNCTION DM.RO.FIELD (FIELD%) PUBLIC                                        !ESWM
1353: 16b2: 
1354: 16b2:     INTEGER*1   DM.RO.FIELD                                                 !ESWM
1355: 16b2:     INTEGER*2   FIELD%                                                      !ESWM
1356: 16b2: 
1357: 16b2:     DM.RO.FIELD = 1                                                         !ESWM
1358: 16b6: 
1359: 16b6:     FIELD.FLAGS%(FIELD%) = FIELD.FLAGS%(FIELD%) OR RO.FLAG%                 !ESWM
1360: 16e2: 
1361: 16e2:     DM.RO.FIELD = 0                                                         !ESWM
1362: 16e6: 
1363: 16e6: END FUNCTION                                                                !ESWM
1364: 16f5: 
1365: 16f5: 
1366: 16f5: !******************************************************************************
1367: 16f5: !***
1368: 16f5: !***    DM.RW.FIELD
1369: 16f5: !***    Defines an input field as read write
1370: 16f5: !***
1371: 16f5: 
1372: 16f5: FUNCTION DM.RW.FIELD (FIELD%) PUBLIC                                        !ESWM
1373: 1709: 
1374: 1709:     INTEGER*1   DM.RW.FIELD                                                 !ESWM
1375: 1709:     INTEGER*2   FIELD%                                                      !ESWM
1376: 1709: 
1377: 1709:     DM.RW.FIELD = 1                                                         !ESWM
1378: 170d: 
1379: 170d:     FIELD.FLAGS%(FIELD%) = FIELD.FLAGS%(FIELD%) AND NOT RO.FLAG%            !ESWM
1380: 173d: 
1381: 173d:     DM.RW.FIELD = 0                                                         !ESWM
1382: 1741: 
1383: 1741: END FUNCTION                                                                !ESWM
1384: 1750: 
1385: 1750: 
1386: 1750: !******************************************************************************
1387: 1750: !***
1388: 1750: !***    DM.DISPLAY.MESSAGE
1389: 1750: !***    Displays a message imediately on the status line (field 1)
1390: 1750: !***    This is the legacy function which takes a reverse polish expression
1391: 1750: !***
1392: 1750: 
1393: 1750: FUNCTION DM.DISPLAY.MESSAGE (MESSAGE$) PUBLIC
1394: 1769: 
1395: 1769:     INTEGER*1   DM.DISPLAY.MESSAGE
1396: 1769:     STRING      MESSAGE$
1397: 1769: 
1398: 1769:     DM.FIELD% = MESSAGE.FIELD%
1399: 1773:     RC% = POSF(DM.FIELD%)
1400: 1784:     TEMP$ = EVAL$(MESSAGE$)
1401: 1798:     CALL DM.CHECK.ERROR                                                     !DSWM
1402: 179c:     RC% = PUTF(TEMP$)
1403: 17af: 
1404: 17af: END FUNCTION
1405: 17c3: 
1406: 17c3: 
1407: 17c3: !******************************************************************************
1408: 17c3: !***
1409: 17c3: !***    DM.STATUS
1410: 17c3: !***    Displays a message imediately on the status line (field 1)
1411: 17c3: !***    This is the new function which takes a infix expression
1412: 17c3: !***
1413: 17c3: 
1414: 17c3: FUNCTION DM.STATUS (MESSAGE$) PUBLIC                                        !DSWM
1415: 17dc: 
1416: 17dc:     INTEGER*1   DM.STATUS                                                   !DSWM
1417: 17dc:     STRING      MESSAGE$                                                    !DSWM
1418: 17dc: 
1419: 17dc:     MESSAGE$ = POLISH$(MESSAGE$)                                            !DSWM
1420: 17f1:     CALL DM.CHECK.ERROR                                                     !DSWM
1421: 17f5:     DM.STATUS = DM.DISPLAY.MESSAGE(MESSAGE$)                                !DSWM
1422: 1805: 
1423: 1805: END FUNCTION                                                                !DSWM
1424: 1819: 
1425: 1819: 
1426: 1819: !******************************************************************************
1427: 1819: !***
1428: 1819: !***    DM.VALIDATE.KEY
1429: 1819: !***    Defines a key as being a validation key
1430: 1819: !***
1431: 1819: 
1432: 1819: FUNCTION DM.VALIDATE.KEY (KEY%) PUBLIC                                      !BSWM
1433: 182d: 
1434: 182d:     INTEGER*1   DM.VALIDATE.KEY                                             !BSWM
1435: 182d:     INTEGER*2   KEY%                                                        !BSWM
1436: 182d: 
1437: 182d:     DM.VALIDATE.KEY = 1                                                     !BSWM
1438: 1831:     VALIDATE.KEYS$ = VALIDATE.KEYS$ + STR$(KEY%) + ":"                      !BSWM
1439: 185f:     DM.VALIDATE.KEY = 0                                                     !BSWM
1440: 1863: 
1441: 1863: END FUNCTION                                                                !BSWM
1442: 1872: 
1443: 1872: 
1444: 1872: !******************************************************************************
1445: 1872: !***
1446: 1872: !***    DM.INVISBLE.INPUT
1447: 1872: !***    Gets an input key from the invisible input field
1448: 1872: !***
1449: 1872: 
1450: 1872: FUNCTION DM.INVISIBLE.INPUT (MESSAGE$) PUBLIC
1451: 188b: 
1452: 188b:     STRING      MESSAGE$
1453: 188b:     INTEGER*2   DM.INVISIBLE.INPUT
1454: 188b: 
1455: 188b:     !Turn cursor off
1456: 188b:     TEMP$ = CURS("1")
1457: 189d: 
1458: 189d:     !Show required message
1459: 189d:     CALL DM.DISPLAY.MESSAGE (MESSAGE$)
1460: 18aa: 
1461: 18aa:     !Position cursor and wait for input
1462: 18aa:     DM.FIELD% = INVISIBLE.FIELD%
1463: 18b4:     RC% = POSF(DM.FIELD%)
1464: 18c5:     RC% = PUTF("")
1465: 18d4:     INVISIBLE.FIELD$ = UPDF
1466: 18e2: 
1467: 18e2:     DM.INVISIBLE.INPUT = ENDF
1468: 18ea: 
1469: 18ea: END FUNCTION
1470: 18fe: 
1471: 18fe: 
1472: 18fe: !******************************************************************************
1473: 18fe: !***
1474: 18fe: !***    DM.INVISBLE.FIELD
1475: 18fe: !***    Gets the last contents of the invisible input field
1476: 18fe: !***
1477: 18fe: 
1478: 18fe: FUNCTION DM.INVISIBLE.FIELD PUBLIC
1479: 1912: 
1480: 1912:     STRING DM.INVISIBLE.FIELD
1481: 1912: 
1482: 1912:     DM.INVISIBLE.FIELD = INVISIBLE.FIELD$
1483: 1924: 
1484: 1924: END FUNCTION
1485: 1935: 
1486: 1935: 
1487: 1935: !******************************************************************************
1488: 1935: !***
1489: 1935: !***    DM.INVISBLE.FIELD
1490: 1935: !***    Gets or sets the current input field on the display
1491: 1935: !***
1492: 1935: 
1493: 1935: FUNCTION DM.CURRENT.FIELD (NEW.FIELD%) PUBLIC
1494: 1949: 
1495: 1949:     INTEGER*2   DM.CURRENT.FIELD
1496: 1949:     INTEGER*2   NEW.FIELD%
1497: 1949: 
1498: 1949:     IF NEW.FIELD% > 0 THEN BEGIN
1499: 194f:         CALL SET.CF(NEW.FIELD%)                                             !DSWM
1500: 1958:     ENDIF
1501: 1958: 
1502: 1958:     DM.CURRENT.FIELD = ?F39.CF%                                             !DSWM
1503: 1962: 
1504: 1962: END FUNCTION
1505: 1971: 
1506: 1971: 
1507: 1971: !******************************************************************************
1508: 1971: !***
1509: 1971: !***    DM.INVISBLE.FIELD
1510: 1971: !***    Gets or sets the current flag indicating if the screen contents
1511: 1971: !***    have been modified.
1512: 1971: !***
1513: 1971: 
1514: 1971: FUNCTION DM.CHANGED.FLAG (FLAG%) PUBLIC                                     !BSWM
1515: 1985: 
1516: 1985:     INTEGER*1   FLAG%                                                       !BSWM
1517: 1985:     INTEGER*1   DM.CHANGED.FLAG                                             !BSWM
1518: 1985: 
1519: 1985:     IF FLAG% = TRUE OR FLAG% = FALSE THEN BEGIN                             !BSWM
1520: 19a0:         FIELDS.CHANGED = FLAG%                                              !BSWM
1521: 19a6:     ENDIF                                                                   !BSWM
1522: 19a6: 
1523: 19a6:     DM.CHANGED.FLAG = FIELDS.CHANGED                                        !BSWM
1524: 19ac: 
1525: 19ac: END FUNCTION                                                                !BSWM
1526: 19bb: 
1527: 19bb: 
1528: 19bb: !******************************************************************************
1529: 19bb: !***
1530: 19bb: !***    DM.TAB.ORDER
1531: 19bb: !***    Gets or sets the active tab ordering for fields
1532: 19bb: !***
1533: 19bb: 
1534: 19bb: FUNCTION DM.TAB.ORDER (ORDER%) PUBLIC                                       !DSWM
1535: 19cf: 
1536: 19cf:     INTEGER*1   ORDER%                                                      !DSWM
1537: 19cf:     INTEGER*1   DM.TAB.ORDER                                                !DSWM
1538: 19cf: 
1539: 19cf:     IF ORDER% = DISPLAY.ORDER OR ORDER% = NUMBER.ORDER THEN BEGIN           !DSWM
1540: 19ea:          FIELD.TAB.ORDER = ORDER%                                           !DSWM
1541: 19f0:     ENDIF                                                                   !DSWM
1542: 19f0: 
1543: 19f0:     DM.TAB.ORDER = FIELD.TAB.ORDER                                          !DSWM
1544: 19f6: 
1545: 19f6: END FUNCTION                                                                !DSWM
1546: 1a05: 
1547: 1a05: 
1548: 1a05: !******************************************************************************
1549: 1a05: !***
1550: 1a05: !***    DM.PROCESS.SCREEN
1551: 1a05: !***    Performs the bulk of the processing on the screen
1552: 1a05: !***
1553: 1a05: 
1554: 1a05: FUNCTION DM.PROCESS.SCREEN (FIRST.FIELD%, LAST.FIELD%, CONFIRM) PUBLIC
1555: 1a19: 
1556: 1a19:     INTEGER*2   DM.PROCESS.SCREEN
1557: 1a19:     INTEGER*2   FIRST.FIELD%
1558: 1a19:     INTEGER*2   LAST.FIELD%
1559: 1a19:     INTEGER*2   PREV.FIELD%
1560: 1a19:     INTEGER*1   CONFIRM
1561: 1a19:     INTEGER*1   READ.ONLY                                                   !ESWM
1562: 1a19: 
1563: 1a19:     !Turn cursor off
1564: 1a19:     TEMP$ = CURS("1")
1565: 1a2b: 
1566: 1a2b:     !Validate passed field indecies are within range
1567: 1a2b:     !This allows defaults to be used (0,0) for the whole screen
1568: 1a2b:     IF FIRST.FIELD% < 2 OR FIRST.FIELD% > FIELD.COUNT% THEN BEGIN           !DSWM
1569: 1a45:         FIRST.FIELD% = 2                                                    !DSWM
1570: 1a4a:     ENDIF                                                                   !DSWM
1571: 1a4a:     IF LAST.FIELD% < 2 OR LAST.FIELD% > FIELD.COUNT% THEN BEGIN             !DSWM
1572: 1a64:         LAST.FIELD% = FIELD.COUNT%                                          !DSWM
1573: 1a6a:     ENDIF                                                                   !DSWM
1574: 1a6a: 
1575: 1a6a:     !Set visibility of fields on display
1576: 1a6a:     GOSUB SET.VISIBILITY.AND.FIELDS
1577: 1a74: 
1578: 1a74:     !Move to first visible input field
1579: 1a74:     DM.FIELD% = ?F39.CF%                                                    !DSWM
1580: 1a82:     GOSUB MOVE.FORWARD.VISIBLE
1581: 1a8c:     !But if we are now past the last displayed field, move back
1582: 1a8c:     GOSUB MOVE.BACKWARD.VISIBLE                                             !DSWM
1583: 1a96: 
1584: 1a96:     KEY% = 0
1585: 1a9c:     RESUME.INPUT = FALSE
1586: 1aa2:     EXIT.FLAG = FALSE
1587: 1aa8: 
1588: 1aa8:     WHILE NOT EXIT.FLAG
1589: 1aab: 
1590: 1aab:         IF FIELD$(1) <> "" THEN BEGIN
1591: 1acd:             CALL DM.DISPLAY.MESSAGE(FIELD$(MESSAGE.FIELD%))
1592: 1aed:         ENDIF
1593: 1aed: 
1594: 1aed:         READ.ONLY = IS.RO.FIELD(?F39.CF%)                                   !ESWM
1595: 1afd: 
1596: 1afd:         !Put cursor in current field
1597: 1afd:         RC% = POSF(?F39.CF%)                                                !DSWM
1598: 1b0e: 
1599: 1b0e:         IF ?F39.CF% <> INVISIBLE.FIELD% THEN BEGIN                          !DSWM
1600: 1b1b: 
1601: 1b1b:             !Cursor on for input
1602: 1b1b:             IF NOT READ.ONLY THEN TEMP$ = CURS("0")                         !ESWM
1603: 1b34: 
1604: 1b34:             !Set attributes for input field
1605: 1b34:             ATTRIB$ = SETF("")
1606: 1b46:             TEMP$ = SETF("3113333333311333")
1607: 1b58:             PREV.VALUE$ = FIELD$(?F39.CF%)                                  !DSWM
1608: 1b7d: 
1609: 1b7d:         ENDIF
1610: 1b7d: 
1611: 1b7d:         !For read-only fields, we must take input from the invisible field
1612: 1b7d:         IF READ.ONLY THEN BEGIN                                             !ESWM
1613: 1b84:             RC% = POSF(INVISIBLE.FIELD%)                                    !ESWM
1614: 1b92:         ENDIF                                                               !ESWM
1615: 1b92: 
1616: 1b92:         IF RESUME.INPUT THEN BEGIN
1617: 1b99:             VALUE$ = RESF(0)
1618: 1ba9:             RESUME.INPUT = FALSE
1619: 1bb1:         ENDIF ELSE BEGIN
1620: 1bb1:             VALUE$ = UPDF
1621: 1bbf:         ENDIF
1622: 1bbf: 
1623: 1bbf:         !For read-only fields, we must restore current field from invisible
1624: 1bbf:         IF READ.ONLY THEN BEGIN                                             !ESWM
1625: 1bc6:             RC% = POSF(?F39.CF%)                                            !ESWM
1626: 1bd7:             VALUE$ = PREV.VALUE$                                            !ESWM
1627: 1be8:         ENDIF                                                               !ESWM
1628: 1be8: 
1629: 1be8:         IF ?F39.CF% <> INVISIBLE.FIELD% THEN BEGIN                          !DSWM
1630: 1bf5: 
1631: 1bf5:             !Restore field atributes
1632: 1bf5:             TEMP$ = SETF(ATTRIB$)
1633: 1c0b: 
1634: 1c0b:             !Cursor off after input
1635: 1c0b:             TEMP$ = CURS("1")
1636: 1c1d: 
1637: 1c1d:         ENDIF
1638: 1c1d: 
1639: 1c1d:         !Input date/time field needs conversion?
1640: 1c1d:         IF IS.DATE.FIELD(?F39.CF%) THEN BEGIN                               !DSWM
1641: 1c2e:             VALUE$ = INT.DATE$ (VALUE$)
1642: 1c45:         ENDIF ELSE IF IS.TIME.FIELD(?F39.CF%) THEN BEGIN                    !DSWM
1643: 1c56:             VALUE$ = INT.TIME$ (VALUE$)                                     !CSWM
1644: 1c6b:         ENDIF                                                               !CSWM
1645: 1c6b: 
1646: 1c6b:         GOSUB UPDATE.FIELD.VALUE                                            !DSWM
1647: 1c75: 
1648: 1c75:         !Get key which terminated entry
1649: 1c75:         CONFIRM.KEY% = KEY%
1650: 1c7b:         KEY% = ENDF
1651: 1c83: 
1652: 1c83:         !Confirmation is invalid if changed field
1653: 1c83:         IF VALUE$ <> PREV.VALUE$ AND ?F39.CF% <> INVISIBLE.FIELD% THEN BEGIN!DSWM
1654: 1cbd:             FIELDS.CHANGED = TRUE
1655: 1cc3:             CONFIRM.KEY% = 0
1656: 1cc9:         ENDIF
1657: 1cc9: 
1658: 1cc9:         !Remove any previously visible error
1659: 1cc9:         IF FIELD$(1) <> "" THEN BEGIN
1660: 1ceb:             RC% = POSF(MESSAGE.FIELD%)
1661: 1cf9:             RC% = PUTF("")
1662: 1d08:             FIELD$(1) = ""
1663: 1d23:         ENDIF
1664: 1d23: 
1665: 1d23:         !Validate input
1666: 1d23:         VALID = TRUE
1667: 1d29: 
1668: 1d29:         IF ?F39.CF% <> INVISIBLE.FIELD% THEN BEGIN                          !DSWM
1669: 1d39: 
1670: 1d39:             IF LEN(VALID$(?F39.CF%)) THEN BEGIN                             !DSWM
1671: 1d5f:                 DM.FIELD% = ?F39.CF%                                        !DSWM
1672: 1d6d:                 VALID = EVAL%(VALID$(DM.FIELD%))
1673: 1d96:                 CALL DM.CHECK.ERROR
1674: 1d9a:             ENDIF
1675: 1d9a: 
1676: 1d9a:             !Call user exit
1677: 1d9a:             DM.FIELD% = ?F39.CF%                                            !DSWM
1678: 1da8:             DM.SCREEN% = CURRENT.SCREEN%
1679: 1db2:             UPDATE = FALSE
1680: 1db8:             CALL DM.FIELD.CHANGED (DM.SCREEN%, DM.FIELD%, VALUE$, VALID, UPDATE)
1681: 1dd8: 
1682: 1dd8: 
1683: 1dd8:             !If fields updated by user exit
1684: 1dd8:             IF UPDATE THEN BEGIN
1685: 1ddf:                 GOSUB REFRESH.FIELDS
1686: 1de9:             ENDIF
1687: 1de9: 
1688: 1de9:         ENDIF
1689: 1de9: 
1690: 1de9:         IF KEY% = ESC.KEY% THEN BEGIN
1691: 1df6: 
1692: 1df6:             !If confirmation required
1693: 1df6:             IF CONFIRM AND KEY% <> CONFIRM.KEY% AND FIELDS.CHANGED THEN BEGIN
1694: 1e0e: 
1695: 1e0e:                 !B182 Data already keyed will be lost -
1696: 1e0e:                 !Press ESC to QUIT or ENTER to continue
1697: 1e0e:                 FIELD$(1) = "'Data already keyed will be lost - "    + \!AJK
1698: 1e30:                             "Press ESC to QUIT or ENTER to continue"    !AJK
1699: 1e30:                 RESUME.INPUT = TRUE
1700: 1e38: 
1701: 1e38:             ENDIF ELSE BEGIN
1702: 1e38: 
1703: 1e38:                 GOSUB UPDATE.FIELD.VALUE                                    !DSWM
1704: 1e42:                 EXIT.FLAG = TRUE
1705: 1e48: 
1706: 1e48:             ENDIF
1707: 1e4b: 
1708: 1e4b:         ENDIF ELSE IF KEY% = F3.KEY% THEN BEGIN
1709: 1e58: 
1710: 1e58:             !If confirmation required
1711: 1e58:             IF CONFIRM AND KEY% <> CONFIRM.KEY% AND FIELDS.CHANGED THEN BEGIN
1712: 1e70: 
1713: 1e70:                 !B183 Data already keyed will be lost -
1714: 1e70:                 !Press F3 to QUIT or ENTER to continue
1715: 1e70:                 FIELD$(1) = "'Data already keyed will be lost - "    + \!AJK
1716: 1e92:                             "Press F3 to QUIT or ENTER to continue"     !AJK
1717: 1e92:                 RESUME.INPUT = TRUE
1718: 1e9a: 
1719: 1e9a:             ENDIF ELSE BEGIN
1720: 1e9a: 
1721: 1e9a:                 GOSUB UPDATE.FIELD.VALUE                                    !DSWM
1722: 1ea4:                 EXIT.FLAG = TRUE
1723: 1eaa: 
1724: 1eaa:             ENDIF
1725: 1ead: 
1726: 1ead:         ENDIF ELSE IF KEY% = F1.KEY% THEN BEGIN
1727: 1eba: 
1728: 1eba:             ! If valid screen value is passed
1729: 1eba:             IF FIRST.HELP.SCREEN% <> 0 AND LAST.HELP.SCREEN% <> 0      \!AJK
1730: 1ed7:             THEN BEGIN                                                  !AJK
1731: 1ed7:             !Display help screen
1732: 1ed7:                 GOSUB DISPLAY.HELP
1733: 1ee3:             ! If screen number is zero
1734: 1ee3:             ENDIF ELSE BEGIN                                            !AJK
1735: 1ee3:                 FIELD$(1) = "'Help screen not available"                !AJK
1736: 1efe:             ENDIF                                                       !AJK
1737: 1f01: 
1738: 1f01:         ENDIF ELSE BEGIN !Any other key
1739: 1f01: 
1740: 1f01:             !Field is valid, or blank
1741: 1f01:             IF VALID OR VALUE$ = "" THEN BEGIN
1742: 1f29: 
1743: 1f29: !BSWM               !Adjust visibiliity of all fields on display
1744: 1f29: !BSWM               GOSUB REFRESH.VISIBILITY
1745: 1f29: REPARSE.KEY:                                                                !DSWM
1746: 1f29:                 IF KEY% = HOME.KEY% THEN BEGIN
1747: 1f36: 
1748: 1f36:                     !Move forward to first visible input field
1749: 1f36:                     DM.FIELD% = FIRST.FIELD%
1750: 1f40:                     IF FIELD.TAB.ORDER = DISPLAY.ORDER THEN BEGIN           !DSWM
1751: 1f49:                         DM.FIELD% = NXTF(-20)   !First input field          !DSWM
1752: 1f59:                     ENDIF                                                   !DSWM
1753: 1f59:                     GOSUB MOVE.FORWARD.VISIBLE
1754: 1f66: 
1755: 1f66:                 ENDIF ELSE IF KEY% = END.KEY% THEN BEGIN
1756: 1f73: 
1757: 1f73:                     !Move backward to last visible input field
1758: 1f73:                     DM.FIELD% = LAST.FIELD%
1759: 1f7d:                     IF FIELD.TAB.ORDER = DISPLAY.ORDER THEN BEGIN           !DSWM
1760: 1f86:                         DM.FIELD% = NXTF(20)    !Last input field           !DSWM
1761: 1f96:                     ENDIF                                                   !DSWM
1762: 1f96:                     GOSUB MOVE.BACKWARD.VISIBLE
1763: 1fa3: 
1764: 1fa3:                 ENDIF ELSE IF KEY% = BTAB.KEY% OR KEY% = UP.KEY% THEN BEGIN !CSWM
1765: 1fc9: 
1766: 1fc9:                     !Move backward to prev visible input field
1767: 1fc9:                     DM.FIELD% = ?F39.CF%                                    !DSWM
1768: 1fd7:                     PREV.FIELD% = ?F39.CF%                                  !DSWM
1769: 1fe1:                     GOSUB MOVE.BACKWARD.FIELD
1770: 1feb:                     IF ?F39.CF% = PREV.FIELD% THEN BEGIN                    !DSWM
1771: 1ff8:                         KEY% = PREV.KEY%                                    !DSWM
1772: 2002:                         GOTO REPARSE.KEY                                    !DSWM
1773: 2005:                     ENDIF                                                   !DSWM
1774: 2008: 
1775: 2008:                 ENDIF ELSE IF KEY% = TAB.KEY% OR KEY% = DOWN.KEY% THEN BEGIN!CSWM
1776: 202e: 
1777: 202e:                     !Move forward to next visible input field
1778: 202e:                     DM.FIELD% = ?F39.CF%                                    !DSWM
1779: 203c:                     PREV.FIELD% = ?F39.CF%                                  !DSWM
1780: 2046:                     GOSUB MOVE.FORWARD.FIELD
1781: 2050:                     IF ?F39.CF% = PREV.FIELD% THEN BEGIN                    !DSWM
1782: 205d:                         KEY% = NEXT.KEY%                                    !DSWM
1783: 2067:                         GOTO REPARSE.KEY                                    !DSWM
1784: 206a:                     ENDIF                                                   !DSWM
1785: 206d: 
1786: 206d:                 ENDIF ELSE IF MATCH(":"+STR$(KEY%)+":", VALIDATE.KEYS$, 1) THEN BEGIN
1787: 20b6: 
1788: 20b6:                     GOSUB VALIDATE.INPUT.FIELDS
1789: 20c0: 
1790: 20c0:                     IF VALID THEN BEGIN
1791: 20c7:                         EXIT.FLAG = TRUE
1792: 20d0:                     ENDIF ELSE BEGIN
1793: 20d0:                         CALL SET.CF(DM.FIELD%)                              !DSWM
1794: 20dd:                         IF MESSAGE$(?F39.CF%) = "" THEN BEGIN               !DSWM
1795: 2104:                             !B166 Some fields have invalid data
1796: 2104:                             FIELD$(1) = "'Some fields have invalid data"!AJK
1797: 2121:                         ENDIF ELSE BEGIN
1798: 2121:                             FIELD$(1) = MESSAGE$(?F39.CF%)                  !DSWM
1799: 2154:                         ENDIF
1800: 2154:                     ENDIF
1801: 2156: 
1802: 2156: 
1803: 2156:                 ENDIF ELSE BEGIN
1804: 2156: 
1805: 2156:                     EXIT.FLAG = TRUE
1806: 215c: 
1807: 215c:                 ENDIF
1808: 215c: 
1809: 215c:                 !Adjust visibiliity of all fields on display                !BSWM
1810: 215c:                 GOSUB REFRESH.VISIBILITY                                    !BSWM
1811: 2166:                 GOSUB REFRESH.FN.KEY.VISIBILITY                             !ASWM
1812: 2173: 
1813: 2173:             !Else invalid field, so if no message set up in user exit
1814: 2173:             ENDIF ELSE IF FIELD$(1) = "" THEN BEGIN
1815: 2195: 
1816: 2195:                 IF MESSAGE$(?F39.CF%) = "" THEN BEGIN                       !DSWM
1817: 21bc:                     !B166 Some fields have invalid data
1818: 21bc:                     FIELD$(1) = "'Some fields have invalid data"        !AJK
1819: 21d9:                 ENDIF ELSE BEGIN
1820: 21d9:                     FIELD$(1) = MESSAGE$(?F39.CF%)                          !DSWM
1821: 220c:                 ENDIF
1822: 220c: 
1823: 220c:             ENDIF
1824: 220c: 
1825: 220c:         ENDIF
1826: 220c: 
1827: 220c:     WEND
1828: 2216: 
1829: 2216:     DM.PROCESS.SCREEN = KEY%
1830: 221c: 
1831: 221c: EXIT FUNCTION
1832: 221f: 
1833: 221f: 
1834: 221f: MOVE.FORWARD.VISIBLE:
1835: 221f: 
1836: 221f:     DM.FIELD% = POSF(DM.FIELD%)
1837: 2234:     IF IS.INPUT.FIELD THEN GOTO FORWARD.FIELD
1838: 223e: 
1839: 223e: MOVE.FORWARD.FIELD:
1840: 223e: 
1841: 223e:     DM.FIELD% = POSF(DM.FIELD%)
1842: 2253:     IF FIELD.TAB.ORDER = DISPLAY.ORDER THEN BEGIN                           !DSWM
1843: 225c:         DM.FIELD% = NXTF(2)                                                 !DSWM
1844: 226e:     ENDIF ELSE BEGIN                                                        !DSWM
1845: 226e:         DM.FIELD% = NEXT.INPUT%(DM.FIELD%)                                  !DSWM
1846: 228a:     ENDIF                                                                   !DSWM
1847: 228a: 
1848: 228a: FORWARD.FIELD:
1849: 228a:     IF DM.FIELD% <= 0 THEN RETURN
1850: 229c:     IF DM.FIELD% > LAST.FIELD% THEN RETURN
1851: 22b0:     IF DM.FIELD% < FIRST.FIELD% THEN GOTO MOVE.FORWARD.FIELD
1852: 22be: 
1853: 22be:     IF IS.OO.FIELD(DM.FIELD%) THEN GOTO MOVE.FORWARD.FIELD                  !FNWB
1854: 22d2: 
1855: 22d2:     IF LEN(VISIBLE$(DM.FIELD%)) THEN BEGIN                                  !BSWM
1856: 22f8:         RC% = EVAL%(VISIBLE$(DM.FIELD%))                                    !DSWM
1857: 2321:         CALL DM.CHECK.ERROR                                                 !DSWM
1858: 2325:         IF NOT RC% THEN GOTO MOVE.FORWARD.FIELD                             !DSWM
1859: 2332:     ENDIF ELSE BEGIN                                                        !BSWM
1860: 2332:         IF NOT IS.VISIBLE.FIELD THEN GOTO MOVE.FORWARD.FIELD
1861: 233d:     ENDIF                                                                   !BSWM
1862: 233d: 
1863: 233d:     CALL SET.CF(DM.FIELD%)                                                  !DSWM
1864: 234a: 
1865: 234a: RETURN
1866: 2352: 
1867: 2352: 
1868: 2352: MOVE.BACKWARD.VISIBLE:
1869: 2352: 
1870: 2352:     DM.FIELD% = POSF(DM.FIELD%)
1871: 2367:     IF IS.INPUT.FIELD THEN GOTO BACKWARD.FIELD
1872: 2371: 
1873: 2371: MOVE.BACKWARD.FIELD:
1874: 2371: 
1875: 2371:     DM.FIELD% = POSF(DM.FIELD%)
1876: 2386:     IF FIELD.TAB.ORDER = DISPLAY.ORDER THEN BEGIN                           !DSWM
1877: 238f:         DM.FIELD% = NXTF(-2)                                                !DSWM
1878: 23a1:     ENDIF ELSE BEGIN                                                        !DSWM
1879: 23a1:         DM.FIELD% = PREV.INPUT%(DM.FIELD%)                                  !DSWM
1880: 23bd:     ENDIF                                                                   !DSWM
1881: 23bd: 
1882: 23bd: BACKWARD.FIELD:
1883: 23bd:     IF DM.FIELD% <= 0 THEN RETURN
1884: 23cf:     IF DM.FIELD% < FIRST.FIELD% THEN RETURN
1885: 23e3:     IF DM.FIELD% > LAST.FIELD% THEN GOTO MOVE.BACKWARD.FIELD
1886: 23f1: 
1887: 23f1:     IF IS.OO.FIELD(DM.FIELD%) THEN GOTO MOVE.BACKWARD.FIELD                 !FNWB
1888: 2405: 
1889: 2405:     IF LEN(VISIBLE$(DM.FIELD%)) THEN BEGIN                                  !BSWM
1890: 242b:         RC% = EVAL%(VISIBLE$(DM.FIELD%))                                    !DSWM
1891: 2454:         CALL DM.CHECK.ERROR                                                 !DSWM
1892: 2458:         IF NOT RC% THEN GOTO MOVE.BACKWARD.FIELD                            !DSWM
1893: 2465:     ENDIF ELSE BEGIN                                                        !BSWM
1894: 2465:         IF NOT IS.VISIBLE.FIELD THEN GOTO MOVE.BACKWARD.FIELD
1895: 2470:     ENDIF
1896: 2470: 
1897: 2470:     CALL SET.CF(DM.FIELD%)                                                  !DSWM
1898: 247d: 
1899: 247d: RETURN
1900: 2485: 
1901: 2485: 
1902: 2485: SET.VISIBILITY.AND.FIELDS:
1903: 2485: 
1904: 2485:     !We have not found an input field yet
1905: 2485:     LAST.INPUT% = -1                                                        !DSWM
1906: 248b: 
1907: 248b:     FOR DM.FIELD% = 2 TO FIELD.COUNT%
1908: 2497: 
1909: 2497:         IF LEN(NAME$(DM.FIELD%)) THEN BEGIN                                 !DSWM
1910: 24ba:             FIELD$(DM.FIELD%) = EVAL.GET.VARIABLE$(NAME$(DM.FIELD%))        !DSWM
1911: 24f4:             CALL DM.CHECK.ERROR                                             !DSWM
1912: 24f8:         ENDIF                                                               !DSWM
1913: 24f8: 
1914: 24f8:         RC% = POSF(DM.FIELD%)
1915: 2509:         !Set the previous input field pointer
1916: 2509:         PREV.INPUT%(DM.FIELD%) = LAST.INPUT%                                !DSWM
1917: 2521:         !If this is an input field
1918: 2521: \       IF IS.INPUT.FIELD THEN BEGIN                                        !DSWM
1919: 2521:         IF IS.INPUT.FIELD                                                   \FNWB
1920: 253c:        AND NOT IS.OO.FIELD(DM.FIELD%) THEN BEGIN                            !FNWB
1921: 253c:             !Set the forward pointer for all fields from the last input
1922: 253c:             IF LAST.INPUT% = -1 THEN LAST.INPUT% = 2                        !DSWM
1923: 2549:             FOR F% = LAST.INPUT% TO DM.FIELD% - 1                           !DSWM
1924: 2551:                 NEXT.INPUT%(F%) = DM.FIELD%                                 !DSWM
1925: 2570:             NEXT F%                                                         !DSWM
1926: 2585:             !The current field is the last input field found
1927: 2585:             LAST.INPUT% = DM.FIELD%                                         !DSWM
1928: 258f:         ENDIF                                                               !DSWM
1929: 258f: 
1930: 258f: !BSWM       VISIBLE = TRUE
1931: 258f:         IF LEN(VISIBLE$(DM.FIELD%)) THEN BEGIN
1932: 25b8: 
1933: 25b8:             VISIBLE$(DM.FIELD%) = TOKENISE$(VISIBLE$(DM.FIELD%))
1934: 25f5:             VISIBLE = EVAL%(VISIBLE$(DM.FIELD%))
1935: 261e:             CALL DM.CHECK.ERROR                                             !DSWM
1936: 2622:             CURRENT.STATE = IS.VISIBLE.FIELD
1937: 2629:             IF VISIBLE <> CURRENT.STATE THEN BEGIN
1938: 2632:                 IF DM.FIELD% >= FIRST.FIELD% AND DM.FIELD% <=LAST.FIELD% THEN BEGIN
1939: 2656:                     TEMP$ = SETF("2")
1940: 2668:                 ENDIF
1941: 2668:             ENDIF
1942: 2668: 
1943: 2668:         ENDIF                                                               !BSWM
1944: 2668: 
1945: 2668:         IF LEN(VALID$(DM.FIELD%)) THEN BEGIN
1946: 268e:             VALID$(DM.FIELD%) = TOKENISE$(VALID$(DM.FIELD%))
1947: 26cb:         ENDIF
1948: 26cb: 
1949: 26cb:         TEMP$ = FIELD$(DM.FIELD%)
1950: 26f0:         IF LEN(TEMP$) THEN BEGIN
1951: 2705:             IF IS.DATE.FIELD(DM.FIELD%) THEN BEGIN
1952: 2716:                 TEMP$ = EXT.DATE$ (TEMP$)
1953: 272b:                 IF IS.OUTPUT.FIELD THEN BEGIN
1954: 2733:                     TEMP$ = SEP.DATE$ (TEMP$)                               !CSWM
1955: 2748:                 ENDIF
1956: 274a:             ENDIF ELSE IF IS.TIME.FIELD(DM.FIELD%) THEN BEGIN               !CSWM
1957: 275b:                 TEMP$ = EXT.TIME$ (TEMP$)                                   !CSWM
1958: 2770:                 IF IS.OUTPUT.FIELD THEN BEGIN                               !CSWM
1959: 2778:                     TEMP$ = SEP.TIME$ (TEMP$)                               !CSWM
1960: 278d:                 ENDIF                                                       !CSWM
1961: 278d:             ENDIF
1962: 278d:             RC% = PUTF(TEMP$)
1963: 27a3:         ENDIF ELSE IF IS.OUTPUT.FIELD THEN BEGIN
1964: 27ae:             TEMP$ = GETF
1965: 27bc:             IF IS.DATE.FIELD(DM.FIELD%) THEN BEGIN
1966: 27cd:                 TEMP$ = MID$(TEMP$, 1, 2) +                                 \
1967: 2822:                         MID$(TEMP$, 4, 2) +                                 \
1968: 2822:                         MID$(TEMP$, 7, 2)
1969: 2822:                 TEMP$ = INT.DATE$ (TEMP$)
1970: 2839:             ENDIF ELSE IF IS.TIME.FIELD(DM.FIELD%) THEN BEGIN               !CSWM
1971: 284a:                 TEMP$ = MID$(TEMP$, 1, 2) +                                 \CSWM
1972: 289f:                         MID$(TEMP$, 4, 2) +                                 \CSWM
1973: 289f:                         MID$(TEMP$, 7, 2)                                   !CSWM
1974: 289f:                 TEMP$ = INT.TIME$ (TEMP$)                                   !CSWM
1975: 28b4:             ENDIF
1976: 28b4:             FIELD$(DM.FIELD%) = TEMP$
1977: 28d8:             IF LEN(NAME$(DM.FIELD%)) THEN BEGIN                             !DSWM
1978: 28fb:                 CALL EVAL.SET.VARIABLE (NAME$(DM.FIELD%), TEMP$)            !DSWM
1979: 291b:                 CALL DM.CHECK.ERROR                                         !DSWM
1980: 291f:             ENDIF                                                           !DSWM
1981: 291f: 
1982: 291f:         ENDIF
1983: 291f: 
1984: 291f:     NEXT DM.FIELD%
1985: 293e: 
1986: 293e:     !Finally set the next input field pointer for all remaining fields
1987: 293e:     IF LAST.INPUT% = -1 THEN LAST.INPUT% = 2                                !DSWM
1988: 294b:     FOR F% = LAST.INPUT% TO FIELD.COUNT%                                    !DSWM
1989: 2953:         NEXT.INPUT%(F%) = -1                                                !DSWM
1990: 2967:     NEXT F%                                                                 !DSWM
1991: 2977: 
1992: 2977:     GOSUB REFRESH.FN.KEY.VISIBILITY                                         !ASWM
1993: 2981: 
1994: 2981: RETURN
1995: 2989: 
1996: 2989: 
1997: 2989: REFRESH.FIELDS:
1998: 2989: 
1999: 2989:     FOR DM.FIELD% = FIRST.FIELD% TO LAST.FIELD%
2000: 2996: 
2001: 2996:         IF LEN(NAME$(DM.FIELD%)) THEN BEGIN                                 !DSWM
2002: 29b9:             FIELD$(DM.FIELD%) = EVAL.GET.VARIABLE$(NAME$(DM.FIELD%))        !DSWM
2003: 29f3:             CALL DM.CHECK.ERROR                                             !DSWM
2004: 29f7:         ENDIF                                                               !DSWM
2005: 29f7: 
2006: 29f7:         RC% = POSF(DM.FIELD%)
2007: 2a08: 
2008: 2a08:         TEMP$ = FIELD$(DM.FIELD%)
2009: 2a2d:         IF LEN(TEMP$) THEN BEGIN
2010: 2a42:             IF IS.DATE.FIELD(DM.FIELD%) THEN BEGIN
2011: 2a53:                 TEMP$ = EXT.DATE$(TEMP$)
2012: 2a68:                 IF IS.OUTPUT.FIELD THEN BEGIN
2013: 2a70:                     TEMP$ = SEP.DATE$(TEMP$)                                !CSWM
2014: 2a85:                 ENDIF
2015: 2a87:             ENDIF ELSE IF IS.TIME.FIELD(DM.FIELD%) THEN BEGIN               !CSWM
2016: 2a98:                 TEMP$ = INT.TIME$(TEMP$)                                    !CSWM
2017: 2aad:                 IF IS.OUTPUT.FIELD THEN BEGIN                               !CSWM
2018: 2ab5:                     TEMP$ = SEP.TIME$(TEMP$)                                !CSWM
2019: 2aca:                 ENDIF                                                       !CSWM
2020: 2aca:             ENDIF
2021: 2aca:             RC% = PUTF(TEMP$)
2022: 2add:         ENDIF
2023: 2add: 
2024: 2add:     NEXT DM.FIELD%
2025: 2afb: 
2026: 2afb: RETURN
2027: 2b03: 
2028: 2b03: 
2029: 2b03: REFRESH.VISIBILITY:
2030: 2b03: 
2031: 2b03:     FOR DM.FIELD% = FIRST.FIELD% TO LAST.FIELD%
2032: 2b10: 
2033: 2b10:         RC% = POSF(DM.FIELD%)
2034: 2b21: 
2035: 2b21: !BSWM       VISIBLE = TRUE
2036: 2b21:         IF LEN(VISIBLE$(DM.FIELD%)) THEN BEGIN
2037: 2b47: 
2038: 2b47:             VISIBLE = EVAL%(VISIBLE$(DM.FIELD%))
2039: 2b70:             CALL DM.CHECK.ERROR
2040: 2b74:             CURRENT.STATE = IS.VISIBLE.FIELD
2041: 2b7b:             IF VISIBLE <> CURRENT.STATE THEN BEGIN
2042: 2b84:                 TEMP$ =  SETF("2")
2043: 2b96:             ENDIF
2044: 2b96: 
2045: 2b96:         ENDIF                                                               !BSWM
2046: 2b96: 
2047: 2b96:     NEXT DM.FIELD%
2048: 2bb4: 
2049: 2bb4: RETURN
2050: 2bbc: 
2051: 2bbc: 
2052: 2bbc: REFRESH.FN.KEY.VISIBILITY:                                                  !ASWM
2053: 2bbc: 
2054: 2bbc:     FOR DM.FIELD% = 1 TO 10                                                 !ASWM
2055: 2bc8: 
2056: 2bc8:         RC% = POSF(F.FIELD% + DM.FIELD%)                                    !ASWM
2057: 2be0: 
2058: 2be0:         IF RC% = F.FIELD% + DM.FIELD% THEN BEGIN                            !ASWM
2059: 2bf1:             IF LEN(FN.VISIBLE$(DM.FIELD%)) THEN BEGIN                       !ASWM
2060: 2c14:                 VISIBLE = EVAL%(FN.VISIBLE$(DM.FIELD%))                     !ASWM
2061: 2c3a:                 CALL DM.CHECK.ERROR                                         !DSWM
2062: 2c3e:                 CURRENT.STATE = IS.VISIBLE.FIELD                            !ASWM
2063: 2c45:                 IF VISIBLE <> CURRENT.STATE THEN BEGIN                      !ASWM
2064: 2c4e:                     TEMP$ = SETF("2")                                       !ASWM
2065: 2c60:                 ENDIF                                                       !ASWM
2066: 2c60:             ENDIF                                                           !ASWM
2067: 2c60:         ENDIF                                                               !ASWM
2068: 2c60: 
2069: 2c60:     NEXT DM.FIELD%                                                          !ASWM
2070: 2c7c: 
2071: 2c7c: RETURN                                                                      !ASWM
2072: 2c84: 
2073: 2c84: 
2074: 2c84: VALIDATE.INPUT.FIELDS:
2075: 2c84: 
2076: 2c84:     VALID = TRUE
2077: 2c8a:     DM.FIELD% = 1
2078: 2c93: 
2079: 2c93:     WHILE DM.FIELD% < FIELD.COUNT% AND VALID
2080: 2c96: 
2081: 2c96:         DM.FIELD% = DM.FIELD% + 1
2082: 2c9d: 
2083: 2c9d:         RC% = POSF(DM.FIELD%)
2084: 2cae: 
2085: 2cae:         IF LEN(VISIBLE$(DM.FIELD%)) THEN BEGIN                              !BSWM
2086: 2cd4:             VISIBLE = EVAL%(VISIBLE$(DM.FIELD%))                            !BSWM
2087: 2cfd:             CALL DM.CHECK.ERROR                                             !DSWM
2088: 2d03:         ENDIF ELSE BEGIN                                                    !BSWM
2089: 2d03:             VISIBLE = IS.VISIBLE.FIELD                                      !BSWM
2090: 2d0a:         ENDIF                                                               !BSWM
2091: 2d0a: 
2092: 2d0a:         IF VISIBLE THEN BEGIN                                               !BSWM
2093: 2d11:             IF IS.INPUT.FIELD THEN BEGIN
2094: 2d19:                 IF LEN(VALID$(DM.FIELD%)) THEN BEGIN
2095: 2d3f:                     VALID = EVAL%(VALID$(DM.FIELD%))
2096: 2d68:                     CALL DM.CHECK.ERROR                                     !DSWM
2097: 2d6c:                 ENDIF
2098: 2d6c:             ENDIF
2099: 2d6f:         ENDIF ELSE BEGIN
2100: 2d6f:             IF IS.INPUT.FIELD THEN BEGIN
2101: 2d77:                 IF LEN(VALID$(DM.FIELD%)) THEN BEGIN
2102: 2d9d:                     RC% = EVAL%(VALID$(DM.FIELD%))                          !DSWM
2103: 2dc6:                     CALL DM.CHECK.ERROR                                     !DSWM
2104: 2dca:                     IF NOT RC% THEN BEGIN                                   !DSWM
2105: 2dd2:                         GOSUB UPDATE.BLANK.FIELD                            !DSWM
2106: 2ddc:                         RC% = PUTF("")
2107: 2deb:                     ENDIF
2108: 2deb:                 ENDIF
2109: 2deb:             ENDIF
2110: 2deb:         ENDIF
2111: 2deb: 
2112: 2deb:     WEND
2113: 2e05: 
2114: 2e05: RETURN
2115: 2e0d: 
2116: 2e0d: 
2117: 2e0d: DISPLAY.HELP:
2118: 2e0d: 
2119: 2e0d:     ! Save Function Key field attributes so that                            !GCSk
2120: 2e0d:     ! they can be re-instated correctly later                               !GCSk
2121: 2e0d:     FOR KEY% = 0 TO 9                                                       !GCSk
2122: 2e15:          RC% = POSF(F1.FIELD% + KEY%)                                       !GCSk
2123: 2e27:          SAVED.FUNC.KEY$(KEY%) = GETF                                       !GCSk
2124: 2e42:     NEXT KEY%                                                               !GCSk
2125: 2e50: 
2126: 2e50:     RC% = CLSDIS
2127: 2e58:     RC% = OPNDIS(HELP.FILE$)
2128: 2e6b: 
2129: 2e6b:     !Turn cursor off
2130: 2e6b:     TEMP$ = CURS("1")
2131: 2e7d: 
2132: 2e7d:     DM.SCREEN% = FIRST.HELP.SCREEN% - 1
2133: 2e88:     PAGE% = 1
2134: 2e8e:     PAGE.COUNT% = LAST.HELP.SCREEN% - DM.SCREEN%
2135: 2e9b: 
2136: 2e9b:     KEY% = 0
2137: 2ea1:     WHILE KEY% <> F1.KEY%
2138: 2ea4: 
2139: 2ea4:         RC% = DISPD(DM.SCREEN% + PAGE%)
2140: 2eba:         CALL DISPLAY.TITLE.AND.DATE
2141: 2ebe: 
2142: 2ebe:         IF PAGE.COUNT% <> 1 THEN BEGIN
2143: 2ec8: 
2144: 2ec8:             !Page count replaces date on multi-page help screen
2145: 2ec8:             RC% = POSF(DATE.FIELD%)
2146: 2ed6:             TEMP$ = "Page "+STR$(PAGE%)+" of "+STR$(PAGE.COUNT%)
2147: 2f0b:             RC% = PUTF(TEMP$)
2148: 2f1e: 
2149: 2f1e:             IF PAGE% > 1 THEN BEGIN
2150: 2f25:                 CALL DM.SHOW.FN.KEY (7, "")
2151: 2f32:             ENDIF
2152: 2f32: 
2153: 2f32:             IF PAGE% < PAGE.COUNT% THEN BEGIN
2154: 2f3b:                 CALL DM.SHOW.FN.KEY (8, "")
2155: 2f48:             ENDIF
2156: 2f48: 
2157: 2f48:         ENDIF
2158: 2f48: 
2159: 2f48:         UPDATE = FALSE
2160: 2f4e:         WHILE NOT UPDATE
2161: 2f51: 
2162: 2f51:             RC% = POSF(INVISIBLE.FIELD%)
2163: 2f5f:             TEMP$ = UPDF
2164: 2f6d:             KEY% = ENDF
2165: 2f75: 
2166: 2f75:             IF KEY% = PGUP.KEY% OR KEY% = F7.KEY% THEN BEGIN
2167: 2f97: 
2168: 2f97:                 IF PAGE% > 1 THEN BEGIN
2169: 2f9e:                     PAGE% = PAGE% - 1
2170: 2fa2:                     UPDATE = TRUE
2171: 2fa8:                 ENDIF
2172: 2faa: 
2173: 2faa:             ENDIF ELSE IF KEY% = PGDN.KEY% OR KEY% = F8.KEY% THEN BEGIN
2174: 2fd0: 
2175: 2fd0:                 IF PAGE% < PAGE.COUNT% THEN BEGIN
2176: 2fd9:                     PAGE% = PAGE% + 1
2177: 2fdd:                     UPDATE = TRUE
2178: 2fe3:                 ENDIF
2179: 2fe5: 
2180: 2fe5:             ENDIF ELSE IF KEY% = F1.KEY% THEN BEGIN
2181: 2ff2: 
2182: 2ff2:                 UPDATE = TRUE
2183: 2ff8: 
2184: 2ff8:             ENDIF
2185: 2ff8: 
2186: 2ff8:         WEND
2187: 3002: 
2188: 3002:     WEND
2189: 3012: 
2190: 3012:     RC% = CLSDIS
2191: 301a:     RC% = OPNDIS(DISPLAY.FILE$)
2192: 302d: 
2193: 302d:     !Display current screen
2194: 302d:     RC% = DISPD(CURRENT.SCREEN%)
2195: 303b: 
2196: 303b:     !Cursor off
2197: 303b:     TEMP$ = CURS("1")
2198: 304d: 
2199: 304d:     ! Re-instate Function Key field attributes                              !GCSk
2200: 304d:     ! that were saved earlier                                               !GCSk
2201: 304d:     FOR KEY% = 0 TO 9                                                       !GCSk
2202: 3055:          RC% = POSF(F1.FIELD% + KEY%)                                       !GCSk
2203: 3067:          RC% = PUTF(SAVED.FUNC.KEY$(KEY%))                                  !GCSk
2204: 3088:     NEXT KEY%                                                               !GCSk
2205: 3098: 
2206: 3098:     CALL DISPLAY.TITLE.AND.DATE
2207: 309c: 
2208: 309c:     GOSUB SET.VISIBILITY.AND.FIELDS
2209: 30a6: 
2210: 30a6: RETURN
2211: 30ae: 
2212: 30ae: 
2213: 30ae: UPDATE.FIELD.VALUE:                                                         !DSWM
2214: 30ae: 
2215: 30ae:     IF ?F39.CF% <> INVISIBLE.FIELD% THEN BEGIN                              !DSWM
2216: 30bb: 
2217: 30bb:         !Save updated field
2218: 30bb:         FIELD$(?F39.CF%) = VALUE$                                           !DSWM
2219: 30df:         IF LEN(NAME$(?F39.CF%)) THEN BEGIN                                  !DSWM
2220: 3102:             CALL EVAL.SET.VARIABLE (NAME$(?F39.CF%), VALUE$)                !DSWM
2221: 3122:             CALL DM.CHECK.ERROR                                             !DSWM
2222: 3126:         ENDIF                                                               !DSWM
2223: 3126: 
2224: 3126:     ENDIF                                                                   !DSWM
2225: 3126: 
2226: 3126: RETURN                                                                      !DSWM
2227: 312e: 
2228: 312e: 
2229: 312e: UPDATE.BLANK.FIELD:                                                         !DSWM
2230: 312e: 
2231: 312e:     FIELD$(DM.FIELD%) = ""                                                  !DSWM
2232: 314e:     CALL EVAL.SET.VARIABLE(NAME$(DM.FIELD%), "")                            !DSWM
2233: 3189:     CALL DM.CHECK.ERROR                                                     !DSWM
2234: 318d: 
2235: 318d: RETURN                                                                      !DSWM
2236: 3195: 
2237: 3195: END FUNCTION
2238: 31a4: 
2239: 31a4: 
2240: 31a4: !******************************************************************************
2241: 31a4: !***
2242: 31a4: !***    DM.NAME
2243: 31a4: !***    Supplies a name for a field and associates with a variable
2244: 31a4: !***
2245: 31a4: 
2246: 31a4: SUB DM.NAME (FIELD%, VAR$, VALUE$) PUBLIC                                   !DSWM
2247: 31b8: 
2248: 31b8:     INTEGER*2 FIELD%                                                        !DSWM
2249: 31b8:     STRING VAR$                                                             !DSWM
2250: 31b8:     STRING VALUE$                                                           !DSWM
2251: 31b8: 
2252: 31b8:     VAR$ = UCASE$(VAR$)                                                     !DSWM
2253: 31d1:     NAME$(FIELD%) = VAR$                                                    !DSWM
2254: 31f3:     CALL EVAL.SET.UPDATABLE (VAR$, VALUE$)                                  !DSWM
2255: 3205:     CALL SET.CF(?F39.CF%)                                                   !DSWM
2256: 3212:     CALL DM.CHECK.ERROR                                                     !DSWM
2257: 3216: 
2258: 3216: END SUB                                                                     !DSWM
2259: 3222: 
2260: 3222: 
2261: 3222: !******************************************************************************
2262: 3222: !***
2263: 3222: !***    DM.INDEX
2264: 3222: !***    Returns the index number of a field, given its name
2265: 3222: !***
2266: 3222: 
2267: 3222: FUNCTION DM.INDEX (FIELD$) PUBLIC                                           !DSWM
2268: 323b: 
2269: 323b:     STRING FIELD$                                                           !DSWM
2270: 323b:     INTEGER*2 DM.INDEX                                                      !DSWM
2271: 323b: 
2272: 323b:     DM.INDEX = 0                                                            !DSWM
2273: 3240:     FIELD$ = UCASE$(FIELD$)                                                 !DSWM
2274: 3255:     !Field name is a numeric offset?
2275: 3255:     IF LEFT$(FIELD$,1) >= "0" AND LEFT$(FIELD$,1) <= "9" THEN BEGIN         !DSWM
2276: 32c0:         F% = VAL(FIELD$)                                                    !DSWM
2277: 32d0:         IF F% < 2 OR F% > FIELD.COUNT% THEN F% = 0                          !DSWM
2278: 32ed:         DM.INDEX = F%                                                       !DSWM
2279: 32f5:     !Otherwise search for name of field
2280: 32f5:     ENDIF ELSE BEGIN                                                        !DSWM
2281: 32f5:         FOR F% = 2 TO FIELD.COUNT%                                          !DSWM
2282: 32fd:             IF NAME$(F%) = FIELD$ THEN BEGIN                                !DSWM
2283: 3320:                 DM.INDEX = F%                                               !DSWM
2284: 3326:                 EXIT FUNCTION                                               !DSWM
2285: 3328:             ENDIF                                                           !DSWM
2286: 3328:         NEXT F%                                                             !DSWM
2287: 3338:     ENDIF                                                                   !DSWM
2288: 3338: 
2289: 3338: END FUNCTION                                                                !DSWM
2290: 334c: 
2291: 334c: 
2292: 334c: !******************************************************************************
2293: 334c: !***
2294: 334c: !***    DM.VALID
2295: 334c: !***    Sets the validation expression for a field in infix notation
2296: 334c: !***
2297: 334c: 
2298: 334c: FUNCTION DM.VALID (FIELD$, VALUE$) PUBLIC                                   !DSWM
2299: 336a: 
2300: 336a:     STRING FIELD$                                                           !DSWM
2301: 336a:     STRING VALUE$                                                           !DSWM
2302: 336a:     INTEGER*2 DM.VALID                                                      !DSWM
2303: 336a: 
2304: 336a:     DM.VALID = 0                                                            !DSWM
2305: 336f:     F% = DM.INDEX (FIELD$)                                                  !DSWM
2306: 337f:     IF F% THEN BEGIN                                                        !DSWM
2307: 3383:         VALID$(F%) = POLISH$(VALUE$)                                        !DSWM
2308: 33a7:         CALL DM.CHECK.ERROR                                                 !DSWM
2309: 33ab:         DM.VALID = F%                                                       !DSWM
2310: 33b1:     ENDIF                                                                   !DSWM
2311: 33b1: 
2312: 33b1: END FUNCTION                                                                !DSWM
2313: 33ca: 
2314: 33ca: 
2315: 33ca: !******************************************************************************
2316: 33ca: !***
2317: 33ca: !***    DM.MESSAGE
2318: 33ca: !***    Sets the message expression for a field in infix notation
2319: 33ca: !***
2320: 33ca: 
2321: 33ca: FUNCTION DM.MESSAGE (FIELD$, VALUE$) PUBLIC                                 !DSWM
2322: 33e8: 
2323: 33e8:     STRING FIELD$                                                           !DSWM
2324: 33e8:     STRING VALUE$                                                           !DSWM
2325: 33e8:     INTEGER*2 DM.MESSAGE                                                    !DSWM
2326: 33e8: 
2327: 33e8:     DM.MESSAGE = 0                                                          !DSWM
2328: 33ed:     F% = DM.INDEX (FIELD$)                                                  !DSWM
2329: 33fd:     IF F% THEN BEGIN                                                        !DSWM
2330: 3401:         MESSAGE$(F%) = POLISH$(VALUE$)                                      !DSWM
2331: 3425:         CALL DM.CHECK.ERROR                                                 !DSWM
2332: 3429:         DM.MESSAGE = F%                                                     !DSWM
2333: 342f:     ENDIF                                                                   !DSWM
2334: 342f: 
2335: 342f: END FUNCTION                                                                !DSWM
2336: 3448: 
2337: 3448: 
2338: 3448: !******************************************************************************
2339: 3448: !***
2340: 3448: !***    DM.FLD.ATT
2341: 3448: !***    Sets field attributes
2342: 3448: !***
2343: 3448: 
2344: 3448: SUB DM.FLD.ATT (FIELD$, VALUE$) PUBLIC                                      !FNWB
2345: 345c: 
2346: 345c:     STRING      FIELD$                                                      !FNWB
2347: 345c:     STRING      VALUE$                                                      !FNWB
2348: 345c: 
2349: 345c:     F% = DM.INDEX (FIELD$)                                                  !FNWB
2350: 3470:     IF F% THEN BEGIN                                                        !FNWB
2351: 3474:         RC% = POSF(F%)                                                      !FNWB
2352: 3482:         TEMP$ = SETF(VALUE$)                                                !FNWB
2353: 349a:         VALUE$ = TEMP$                                                      !FNWB
2354: 34ac:     ENDIF                                                                   !FNWB
2355: 34ac: 
2356: 34ac: END SUB                                                                     !FNWB
2357: 34b8: 
2358: 34b8: 
2359: 34b8: !******************************************************************************
2360: 34b8: !***
2361: 34b8: !***    DM.OO.FIELD
2362: 34b8: !***    Defines a field to be treated as an output only field
2363: 34b8: !***
2364: 34b8: 
2365: 34b8: FUNCTION DM.OO.FIELD (FIELD$) PUBLIC                                        !FNWB
2366: 34d1: 
2367: 34d1:     INTEGER*1   DM.OO.FIELD                                                 !FNWB
2368: 34d1:     STRING      FIELD$                                                      !FNWB
2369: 34d1: 
2370: 34d1:     DM.OO.FIELD = 1                                                         !FNWB
2371: 34d5: 
2372: 34d5:     F% = DM.INDEX (FIELD$)                                                  !FNWB
2373: 34e5:     IF F% THEN BEGIN                                                        !FNWB
2374: 34e9:         FIELD.FLAGS%(F%) = FIELD.FLAGS%(F%) OR OUT.FLAG%                    !FNWB
2375: 3517:     ENDIF                                                                   !FNWB
2376: 3517: 
2377: 3517: END FUNCTION                                                                !FNWB
2378: 352b: 
2379: 352b: 
2380: 352b: !******************************************************************************
2381: 352b: !***
2382: 352b: !***    DM.IO.FIELD
2383: 352b: !***    Turns off the DM.OO.FIELD setting
2384: 352b: !***
2385: 352b: 
2386: 352b: FUNCTION DM.IO.FIELD (FIELD$) PUBLIC                                        !FNWB
2387: 3544: 
2388: 3544:     INTEGER*1   DM.IO.FIELD                                                 !FNWB
2389: 3544:     STRING      FIELD$                                                      !FNWB
2390: 3544: 
2391: 3544:     DM.IO.FIELD = 1                                                         !FNWB
2392: 3548: 
2393: 3548:     F% = DM.INDEX (FIELD$)                                                  !FNWB
2394: 3558:     IF F% THEN BEGIN                                                        !FNWB
2395: 355c:         FIELD.FLAGS%(F%) = FIELD.FLAGS%(F%) AND NOT OUT.FLAG%               !FNWB
2396: 358e:     ENDIF                                                                   !FNWB
2397: 358e: 
2398: 358e: END FUNCTION                                                                !FNWB
2399: 35a2: 
2400: 35a2: 
2401: 35a2: !******************************************************************************
2402: 35a2: !***
2403: 35a2: !***    DM.VISIBLE
2404: 35a2: !***    Sets the visibility expression for a field in infix notation
2405: 35a2: !***
2406: 35a2: 
2407: 35a2: FUNCTION DM.VISIBLE (FIELD$, VALUE$) PUBLIC                                 !DSWM
2408: 35c0: 
2409: 35c0:     STRING FIELD$                                                           !DSWM
2410: 35c0:     STRING VALUE$                                                           !DSWM
2411: 35c0:     INTEGER*2 DM.VISIBLE                                                    !DSWM
2412: 35c0: 
2413: 35c0:     DM.VISIBLE = 0                                                          !DSWM
2414: 35c5:     F% = DM.INDEX (FIELD$)                                                  !DSWM
2415: 35d5:     IF F% THEN BEGIN                                                        !DSWM
2416: 35d9:         VISIBLE$(F%) = POLISH$(VALUE$)                                      !DSWM
2417: 35fd:         CALL DM.CHECK.ERROR                                                 !DSWM
2418: 3601:         DM.VISIBLE = F%                                                     !DSWM
2419: 3607:     ENDIF                                                                   !DSWM
2420: 3607: 
2421: 3607: END FUNCTION                                                                !DSWM
2422: 3620: 
2423: 3620: 
2424: 3620: !******************************************************************************
2425: 3620: !***
2426: 3620: !***    DM.VISIBLE
2427: 3620: !***    Changes the input focus to the specified field, optionally sets
2428: 3620: !***    a status message for display in field 1.
2429: 3620: !***
2430: 3620: 
2431: 3620: FUNCTION DM.FOCUS (FLD$, VALUE$) PUBLIC                                     !DSWM
2432: 363e: 
2433: 363e:     STRING FLD$                                                             !DSWM
2434: 363e:     STRING VALUE$                                                           !DSWM
2435: 363e:     INTEGER*2 DM.FOCUS                                                      !DSWM
2436: 363e: 
2437: 363e:     DM.FOCUS = 0                                                            !DSWM
2438: 3643:     IF LEN(FLD$) THEN BEGIN                                                 !DSWM
2439: 3653:         F% = DM.INDEX (FLD$)                                                !DSWM
2440: 3663:         IF F% THEN CALL DM.CURRENT.FIELD(F%)                                !DSWM
2441: 3673:     ENDIF ELSE BEGIN                                                        !DSWM
2442: 3673:         F% = ?F39.CF%                                                       !DSWM
2443: 367d:     ENDIF                                                                   !DSWM
2444: 367d: 
2445: 367d:     IF LEN(VALUE$) THEN BEGIN                                               !DSWM
2446: 368d:         FIELD$(1) = POLISH$(VALUE$)                                         !DSWM
2447: 36af:         CALL DM.CHECK.ERROR                                                 !DSWM
2448: 36b3:     ENDIF                                                                   !DSWM
2449: 36b3: 
2450: 36b3: END FUNCTION                                                                !DSWM
2451: 36cc: 
2452: 36cc: 
2453: 36cc: !******************************************************************************
2454: 36cc: 
2455: 36cc: 
2456: 36cc: End of Compilation
