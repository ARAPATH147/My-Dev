   1: 0000: \************************************************************************
   2: 0000: \***
   3: 0000: \***    PHKEEP            Ranjith Gopalankutty          05/04/2017  
   4: 0000: \***                                                                
   5: 0000: \***    There was a defect with program SRP10. It supposed to house 
   6: 0000: \***    keep the expired planner records from SRPOG,SRMOD,SRSXF     
   7: 0000: \***    and SRPDF files. SRPOG is the master planner file SRMOD     
   8: 0000: \***    is module,SRSXF is notch data and SRPDF is the planner      
   9: 0000: \***    descriptor file.  SRMOD,SRPDF and SRSXF files depends on    
  10: 0000: \***    the master planner file SRPOG to build the keys for them.   
  11: 0000: \***                                                                
  12: 0000: \***    The defect was that, SRP10 program was housekeeping only    
  13: 0000: \***    records from SRPOG and leaving behind other 3 files.Over    
  14: 0000: \***    time. Records will be housekept from SRPOG and untouching   
  15: 0000: \***    other files. Records will get piled up and causing file     
  16: 0000: \***    full issues. This resulted in new planner update not        
  17: 0000: \***    able to add in to planner files.Defect has been found       
  18: 0000: \***    and fixed by AppsMgmt. change is live in all stores,but     
  19: 0000: \***    one issue found afterwards that program was not able to     
  20: 0000: \***    delete the historical expired  records from planner files.  
  21: 0000: \***                                                                
  22: 0000: \***    This program will housekeep the data from 3 planner files   
  23: 0000: \***    SRMOD,SRSXF and SRPDF and will recreate the planner files   
  24: 0000: \***    fresh using only live records.                              
  25: 0000: \***                                                                
  26: 0000: \***    Program can be executed via command prompt using NFM or     
  27: 0000: \***    in a package.
  28: 0000: \***  
  29: 0000: \***    A                RANJITH GOPALANKUTTY               12-07-2017
  30: 0000: \***    After the meeting with Inctactix it came to our notice that   
  31: 0000: \***    there is a big mis match between the number of planners in    
  32: 0000: \***    in inctactix and controller. The reason for that is in the    
  33: 0000: \***    difference between the housekeeping logic, inctactis never    
  34: 0000: \***    considers a planner (POGID) as deactive and set the maximum   
  35: 0000: \***    end date (2199 year)instead it creates new fragments(POGDB)   
  36: 0000: \***    planner(POGID)and creates end date for it, which is mostly    
  37: 0000: \***    2 weeks. but in SRPOG file we have end date only for POGID    
  38: 0000: \***    and not POGDB, so when housekeeping logic runs, its never     
  39: 0000: \***    able to delete the expired records, so amended the code that  
  40: 0000: \***    instead of SRPOG, application takes SRMAP as the master file  
  41: 0000: \***    and started towards deletion to all4 files SRPOG,SRMOD,SRSXF  
  42: 0000: \***    and SRPDF.        
  43: 0000: \***    
  44: 0000: \***    B                RANJITH GOPALANKUTTY               23-11-2017
  45: 0000: \***    During AppsMgmt testing found that certain stores have more 
  46: 0000: \***    10000 records in SRMOD files and array would not handle it 
  47: 0000: \***    so increasing the array count from current 10000 to maximum
  48: 0000: \***    Also relinked the code with 17D file functions.
  49: 0000: \***   
  50: 0000: \***    C                RANJITH GOPALANKUTTY               26-04-2018
  51: 0000: \***    Moved all W:/ reference to C: due to the risk of losing the run
  52: 0000: \***    status if a controller is getting restarted after deploment
  53: 0000: \***********************************************************************
  54: 0000: \***
  55: 0000: \***    Function globals
  56: 0000: \***
  57: 0000: \***********************************************************************
  58: 0000: 
  59: 0000: 
  60: 0000: %INCLUDE BEMFDEC.J86  
  61: 0000: \******************************************************************************
  62: 0000: \***
  63: 0000: \***	   %INCLUDE FOR BOOTS ERROR MESSAGE FILE - FIELD DECLARATIONS
  64: 0000: \***                                             - FILE REFERENCE PARAMETERS
  65: 0000: \***
  66: 0000: \***                         FILE TYPE : Direct
  67: 0000: \***
  68: 0000: \***                         REFERENCE : BEMFDEC
  69: 0000: \***
  70: 0000: \***	Version A               Mark Walker                  1st November 1993
  71: 0000: \***
  72: 0000: \******************************************************************************
  73: 0000: 
  74: 0000: 	STRING GLOBAL			BEMF.MESSAGE$,			\
  75: 0000: 					BEMF.FILE.NAME$
  76: 0000: 
  77: 0000: 	INTEGER*2 GLOBAL		BEMF.RECL%,			\
  78: 0000: 					BEMF.REPORT.NUM%,		\
  79: 0000: 					BEMF.SESS.NUM%
  80: 0000: 
  81: 0000: 	INTEGER*4 GLOBAL		BEMF.REC.NO%
  82: 0000: %INCLUDE BOOTSDEC.J86 
  83: 0000: \******************************************************************************
  84: 0000: \******************************************************************************
  85: 0000: \***
  86: 0000: \***
  87: 0000: \***
  88: 0000: \******************************************************************************
  89: 0000: 
  90: 0000: 
  91: 0000: %INCLUDE POGDEDEC.J86 
  92: 0000: \********************************************************************
  93: 0000: \***      EXTERNAL FUNCTION DECLARATIONS FOR THE POGDE FILE
  94: 0000: \***      REFERENCE : POGOKDEC.J86
  95: 0000: \***      Version A           Neil Bennett            6th June 2006
  96: 0000: \***
  97: 0000: \********************************************************************
  98: 0000: 
  99: 0000:   INTEGER*2 GLOBAL                \
 100: 0000:     POGDE.SESS.NUM%,              \
 101: 0000:     POGDE.REPORT.NUM%             !
 102: 0000: 
 103: 0000:   STRING GLOBAL                   \
 104: 0000:     POGDE.COPY.NAME$,             \
 105: 0000:     POGDE.FILE.NAME$,             \
 106: 0000:     POGDE.RCD$                    !
 107: 0000: %INCLUDE POGOKDEC.J86 
 108: 0000: \********************************************************************
 109: 0000: \***      EXTERNAL FUNCTION DECLARATIONS FOR THE POGOK FILE
 110: 0000: \***      REFERENCE : POGOKDEC.J86
 111: 0000: \***      Version A           Neil Bennett            6th June 2006
 112: 0000: \***
 113: 0000: \********************************************************************
 114: 0000: 
 115: 0000:   INTEGER*1 GLOBAL                \
 116: 0000:     POGOK.PE10.RETCODE%,          \
 117: 0000:     POGOK.PE5.RETCODE%,           \
 118: 0000:     POGOK.PE6.RETCODE%,           \
 119: 0000:     POGOK.PE7.RETCODE%,           \
 120: 0000:     POGOK.PE4.RETCODE%,           \
 121: 0000:     POGOK.PE19.RETCODE%           !
 122: 0000: 
 123: 0000:   INTEGER*2 GLOBAL                \
 124: 0000:     POGOK.DAYS.TO.RETAIN%,        \
 125: 0000:     POGOK.SESS.NUM%,              \
 126: 0000:     POGOK.REPORT.NUM%,            \
 127: 0000:     POGOK.RECL%                   !
 128: 0000: 
 129: 0000:   INTEGER*4 GLOBAL                \
 130: 0000:     POGOK.SRD.REC.COUNT%,         \
 131: 0000:     POGOK.SRM.REC.COUNT%
 132: 0000: 
 133: 0000:   STRING GLOBAL                   \
 134: 0000:     POGOK.FILE.NAME$,             \
 135: 0000:     POGOK.SRD.SER.NO$,            \
 136: 0000:     POGOK.SRM.SER.NO$,            \
 137: 0000:     POGOK.SRD.DATE$,              \
 138: 0000:     POGOK.SRM.DATE$,              \
 139: 0000:     POGOK.RELOAD$,                \
 140: 0000:     POGOK.PE10.RUNFLAG$,          \
 141: 0000:     POGOK.PE5.RUNFLAG$,           \
 142: 0000:     POGOK.PE6.RUNFLAG$,           \
 143: 0000:     POGOK.PE7.RUNFLAG$,           \
 144: 0000:     POGOK.PE4.RUNFLAG$,           \
 145: 0000:     POGOK.FAILED.SRD.SER.NO$,     \
 146: 0000:     POGOK.FAILED.SRD.DATE$,       \
 147: 0000:     POGOK.FAILED.SRM.SER.NO$,     \
 148: 0000:     POGOK.FAILED.SRM.DATE$,       \
 149: 0000:     POGOK.PE10.RUNDATE$,          \
 150: 0000:     POGOK.PE5.RUNDATE$,           \
 151: 0000:     POGOK.PE6.RUNDATE$,           \
 152: 0000:     POGOK.PE7.RUNDATE$,           \
 153: 0000:     POGOK.PE4.RUNDATE$,           \
 154: 0000:     POGOK.PE19.RUNFLAG$,          \
 155: 0000:     POGOK.PE19.RUNDATE$,          \
 156: 0000:     POGOK.FILLER$                 !
 157: 0000: %INCLUDE PSBF01G.J86  
 158: 0000: REM \
 159: 0000: \*******************************************************************************
 160: 0000: \*******************************************************************************
 161: 0000: \***
 162: 0000: \***       %INCLUDE FOR GLOBAL DEFINITIONS FOR FUNCTION APPLICATION.LOG
 163: 0000: \***
 164: 0000: \***                FUNCTION NUMBER    : PSBF01
 165: 0000: \***
 166: 0000: \***                REFERENCE          : PSBF01G.J86
 167: 0000: \***
 168: 0000: \***                DATE OF LAST AMENDMENT  - 27/2/86
 169: 0000: \***
 170: 0000: \***
 171: 0000: \*******************************************************************************
 172: 0000: 
 173: 0000:       INTEGER GLOBAL  F01.RETURN.CODE%
 174: 0000: 
 175: 0000: 
 176: 0000: %INCLUDE PSBF20G.J86 
 177: 0000: REM\
 178: 0000: \*******************************************************************************
 179: 0000: \*******************************************************************************
 180: 0000: \***
 181: 0000: \***     %INCLUDE GLOBAL VARIABLE DEFINITIONS FOR SESS.NUM.UTILITY FUNCTION
 182: 0000: \***
 183: 0000: \***                       REFERENCE     : PSBF20G.J86
 184: 0000: \*** 
 185: 0000: \***     Version A              Bruce Scrive                   5th May 1988   
 186: 0000: \*** 
 187: 0000: \***     Version B              Robert Cowey                   7th May 1991
 188: 0000: \***     Global variable F20.INTEGER.FILE.NO% changed from one byte integer
 189: 0000: \***     to two byte integer.
 190: 0000: \***
 191: 0000: \***     Version D              Andrew Wedgeworth             1st July 1992
 192: 0000: \***     F20.RETURN.CODE% removed as it is no longer required.
 193: 0000: \***
 194: 0000: \*******************************************************************************
 195: 0000: \*******************************************************************************
 196: 0000: 
 197: 0000:       STRING    GLOBAL F20.FILE.NAME$,                                 \
 198: 0000:                        F20.STRING.FILE.NO$,                            \
 199: 0000:                        F20.TABLE.DIMENSIONED.FLAG$,                    \
 200: 0000:                        SESS.NUM.TABLE$(1)
 201: 0000: 
 202: 0000:       INTEGER*2 GLOBAL F20.INTEGER.FILE.NO%
 203: 0000: 
 204: 0000:       ! 1 line deleted from here                                       ! DAW 
 205: 0000: 
 206: 0000: %INCLUDE SRMODDEC.J86 
 207: 0000: \********************************************************************
 208: 0000: \***      EXTERNAL FUNCTION DECLARATIONS FOR THE SRMOD FILE
 209: 0000: \***      REFERENCE : SRMODDEC.J86
 210: 0000: \***      Version A           Neil Bennett            5th June 2006
 211: 0000: \***
 212: 0000: \********************************************************************
 213: 0000: 
 214: 0000:   INTEGER*1 GLOBAL             \
 215: 0000:     SRMOD.FACINGS%(1),         \
 216: 0000:     SRMOD.MODULE.SEQ%,         \
 217: 0000:     SRMOD.RECORD.CHAIN%,       \
 218: 0000:     SRMOD.SHELF.NUM%(1)
 219: 0000: 
 220: 0000:   INTEGER*2 GLOBAL             \
 221: 0000:     SRMOD.ITEM.COUNT%,         \
 222: 0000:     SRMOD.MAX.ITEMS%,          \
 223: 0000:     SRMOD.MDQ%(1),             \
 224: 0000:     SRMOD.PSC%(1),             \
 225: 0000:     SRMOD.RECL%,               \
 226: 0000:     SRMOD.REPORT.NUM%,         \
 227: 0000:     SRMOD.SHELF.COUNT%,        \
 228: 0000:     SRMOD.SESS.NUM%
 229: 0000: 
 230: 0000:   INTEGER*4 GLOBAL             \
 231: 0000:     SRMOD.POGDB%
 232: 0000: 
 233: 0000:   STRING GLOBAL                \
 234: 0000:     SRMOD.ARRAY$,              \
 235: 0000:     SRMOD.COPY.NAME$,          \
 236: 0000:     SRMOD.DESCRIPTOR$,         \
 237: 0000:     SRMOD.FILE.NAME$,          \
 238: 0000:     SRMOD.ITEM.CODE$(1),       \
 239: 0000:     SRMOD.FILLER$
 240: 0000: %INCLUDE SRPDFDEC.J86 
 241: 0000: \********************************************************************
 242: 0000: \***      EXTERNAL FUNCTION DECLARATIONS FOR THE SRPDF FILE
 243: 0000: \***      REFERENCE : SRPDFDEC.J86
 244: 0000: \***      Version A           Neil Bennett          7th August 2006
 245: 0000: \***
 246: 0000: \********************************************************************
 247: 0000: 
 248: 0000:   INTEGER*2 GLOBAL        \
 249: 0000:     SRPDF.SESS.NUM%,      \
 250: 0000:     SRPDF.REPORT.NUM%,    \
 251: 0000:     SRPDF.RECL%           !
 252: 0000: 
 253: 0000:   INTEGER*4 GLOBAL        \
 254: 0000:     SRPDF.POGDB%          ! Unique POG Database key
 255: 0000: 
 256: 0000:   STRING GLOBAL           \
 257: 0000:     SRPDF.FILE.NAME$,     \ File name
 258: 0000:     SRPDF.SHRT.DESC$,     \ Medium descriptor (50)
 259: 0000:     SRPDF.FULL.DESC$,     \ Full descriptor (100)
 260: 0000:     SRPDF.FILLER$         !
 261: 0000: 
 262: 0000: 
 263: 0000: %INCLUDE SRPOGDEC.J86 
 264: 0000: \********************************************************************
 265: 0000: \***      EXTERNAL FUNCTION DECLARATIONS FOR THE SRPOG FILE
 266: 0000: \***      REFERENCE : SRPOGDEC.J86
 267: 0000: \***      Version A           Neil Bennett            5th June 2006
 268: 0000: \***
 269: 0000: \********************************************************************
 270: 0000: 
 271: 0000:   INTEGER*1 GLOBAL        \
 272: 0000:     SRPOG.MODULE.COUNT%,  \ Number of modules comprising POG
 273: 0000:     SRPOG.KEY.LEVEL%,     \ Family hierarchy key level
 274: 0000:     SRPOG.LIVE.RPT.CNT%,  \ Computed Live repeat count (Unset -1)
 275: 0000:     SRPOG.PEND.RPT.CNT%   ! Computed pending repeat count (Unset -1)
 276: 0000: 
 277: 0000:   INTEGER*2 GLOBAL        \
 278: 0000:     SRPOG.SESS.NUM%,      \
 279: 0000:     SRPOG.REPORT.NUM%,    \
 280: 0000:     SRPOG.RECL%           !
 281: 0000: 
 282: 0000:   INTEGER*4 GLOBAL        \
 283: 0000:     SRPOG.POGDB%,         \ Unique POG Database key
 284: 0000:     SRPOG.CAT.DBKEY%,     \ Family hierarchy key
 285: 0000:     SRPOG.CAT1.ID%,       \ hierarchy key
 286: 0000:     SRPOG.CAT2.ID%,       \ hierarchy key
 287: 0000:     SRPOG.CAT3.ID%,       \ hierarchy key
 288: 0000:     SRPOG.POGID%          ! POG Identifier
 289: 0000: 
 290: 0000:   STRING GLOBAL           \
 291: 0000:     SRPOG.FILE.NAME$,     \ File name
 292: 0000:     SRPOG.COPY.NAME$,     \ File name
 293: 0000:     SRPOG.ACT.DATE$,      \ Activation Date YYYY MM DD
 294: 0000:     SRPOG.DEACT.DATE$,    \ Deactivation Date YYYY MM DD
 295: 0000:     SRPOG.DESCRIPTION$,   \ Truncated POG description (30)
 296: 0000:     SRPOG.PLANNER.FAMILY$,\ Truncated Planner Family description (30)
 297: 0000:     SRPOG.DATE.RPT.CNT$,  \ Date repeat count is valid YYYY MM DD
 298: 0000:     SRPOG.FILLER$         !
 299: 0000: 
 300: 0000: 
 301: 0000: %INCLUDE SRSXFDEC.J86
 302: 0000: \********************************************************************
 303: 0000: \***      EXTERNAL FUNCTION DECLARATIONS FOR THE SRSXF FILE
 304: 0000: \***      REFERENCE : SRSXFDEC.J86
 305: 0000: \***      Version A           Neil Bennett          7th August 2006
 306: 0000: \***
 307: 0000: \********************************************************************
 308: 0000: 
 309: 0000:   INTEGER*1 GLOBAL        \
 310: 0000:     SRSXF.MODULE.SEQ%,    \
 311: 0000:     SRSXF.SHELF.NO%,      \
 312: 0000:     SRSXF.NOTCH.NO%       !
 313: 0000: 
 314: 0000:   INTEGER*2 GLOBAL        \
 315: 0000:     SRSXF.SESS.NUM%,      \
 316: 0000:     SRSXF.REPORT.NUM%,    \
 317: 0000:     SRSXF.RECL%           !
 318: 0000: 
 319: 0000:   INTEGER*4 GLOBAL        \
 320: 0000:     SRSXF.POGDB%,         \
 321: 0000:     SRSXF.SHELF.KEY%      !
 322: 0000: 
 323: 0000:   STRING GLOBAL           \
 324: 0000:     SRSXF.FILE.NAME$,     \ File name
 325: 0000:     SRSXF.SHELF.DESC$,    \
 326: 0000:     SRSXF.FILLER$         !
 327: 0000: 
 328: 0000: 
 329: 0000: %INCLUDE SRMAPDEC.J86                                                   !ARG
 330: 0000: \********************************************************************
 331: 0000: \***      EXTERNAL FUNCTION DECLARATIONS FOR THE SRMAP FILE
 332: 0000: \***      REFERENCE : SRMAPDEC.J86
 333: 0000: \***      Version A           Neil Bennett           14th June 2006
 334: 0000: \***
 335: 0000: \********************************************************************
 336: 0000: 
 337: 0000:   INTEGER*1 GLOBAL             \
 338: 0000:     SRMAP.CHAIN.SEQ%,          \
 339: 0000:     SRMAP.REPEAT.CNT%          !
 340: 0000: 
 341: 0000:   INTEGER*2 GLOBAL             \
 342: 0000:     SRMAP.SESS.NUM%,           \
 343: 0000:     SRMAP.REPORT.NUM%,         \
 344: 0000:     SRMAP.RECL%                !
 345: 0000: 
 346: 0000:   INTEGER*4 GLOBAL             \
 347: 0000:     SRMAP.POGDB%               !
 348: 0000: 
 349: 0000:   STRING GLOBAL                \
 350: 0000:     SRMAP.FILE.NAME$,          \
 351: 0000:     SRMAP.COPY.NAME$,          \
 352: 0000:     SRMAP.FRAG.SDATE$,         \
 353: 0000:     SRMAP.FRAG.EDATE$,         \
 354: 0000:     SRMAP.FILLER$              !
 355: 0000: 
 356: 0000: 
 357: 0000: 
 358: 0000: \***********************************************************************
 359: 0000: \*
 360: 0000: \*    Global variable definitions
 361: 0000: \*
 362: 0000: \***********************************************************************
 363: 0000: 
 364: 0000: STRING     GLOBAL        \
 365: 0000:      FILE.OPERATION$,    \
 366: 0000:      PINFO.TABLE$,       \
 367: 0000:      PASSED.STRING$,     \
 368: 0000:      SVC.PARAM$          
 369: 0000: 
 370: 0000: INTEGER*4  GLOBAL        \
 371: 0000:    ADX.FUNCTION%,        \
 372: 0000:    ADX.PARAM%,           \
 373: 0000:    CURRENT.REPORT.NUM%,  \
 374: 0000:    EVENT.NO%,            \
 375: 0000:    PASSED.INTEGER%,      \
 376: 0000:    RC%
 377: 0000:    
 378: 0000: \***********************************************************************
 379: 0000: \*
 380: 0000: \*    Local Variables
 381: 0000: \*
 382: 0000: \***********************************************************************
 383: 0000: 
 384: 0000: STRING                    \
 385: 0000:      ADX.COMMAND$,        \
 386: 0000:      COMM.TAIL$,          \
 387: 0000:      CURRENT.CODE$,       \
 388: 0000:      FLAG$,               \
 389: 0000:      FUNCTION.FLAG$,      \
 390: 0000:      OK.STRING$,          \
 391: 0000:      PROG.NAME$,          \
 392: 0000:      PHKEEP.OK.NAME$,     \
 393: 0000:      PHKEEP.LOG.NAME$,    \
 394: 0000:      RCD$,                \
 395: 0000:      SEC$,                \
 396: 0000:      SPACE$,              \
 397: 0000:      SRMAP.ARRAY$(1),     \
 398: 0000:      SRMOD.ARR$(1),       \
 399: 0000:      SRMAP.FLAG$,         \
 400: 0000:      SRMAP.STRING$,       \
 401: 0000:      SRMOD.DIR.NAME$,     \
 402: 0000:      SRMOD.NEW.FILE$,     \
 403: 0000:      SRPDF.ARRAY$(1),     \
 404: 0000:      SRPDF.DIR.NAME$,     \
 405: 0000:      SRPDF.KEY.NAME$,     \
 406: 0000:      SRMOD.KEY.NAME$,     \
 407: 0000:      SRPOG.ARRAY$(1),     \
 408: 0000:      SRPOG.DIR.NAME$,     \
 409: 0000:      SRPOG.FLAG$,         \
 410: 0000:      SRPOG.KEY.NAME$,     \
 411: 0000:      SRPOG.TEMP.NAME$,    \
 412: 0000:      SRSXF.FLAG$,         \
 413: 0000:      SRPOG.STRING$,       \
 414: 0000:      SRMOD.STRING$,       \
 415: 0000:      SRMOD.FLAG$,         \
 416: 0000:      SRSXF.STRING$,       \
 417: 0000:      SRSXF.DIR.NAME$,     \
 418: 0000:      SRSXF.KEY.NAME$,     \
 419: 0000:      SRPDF.STRING$,       \
 420: 0000:      SRPDF.FLAG$,         \
 421: 0000:      TEMP.FORM$,          \
 422: 0000:      VAR.STRING.1$,       \
 423: 0000:      VAR.STRING.2$
 424: 0000:                            
 425: 0000: INTEGER*4                 \
 426: 0000:      ADX.INTEGER%,        \
 427: 0000:      ARR.COUNT%,          \
 428: 0000:      I%,                  \
 429: 0000:      EOF%,                \
 430: 0000:      ERROR.CNT%,          \
 431: 0000:      K%,                  \
 432: 0000:      FOUND%,              \
 433: 0000:      FOUND1%,             \
 434: 0000:      J%,                  \
 435: 0000:      MESSAGE.NO%,         \
 436: 0000:      NOFILE.SRMOD.COUNT%, \
 437: 0000:      NOFILE.SRPDF.COUNT%, \
 438: 0000:      NOFILE.SRSXF.COUNT%, \
 439: 0000:      P%,                  \
 440: 0000:      PHKEEP.OK.SESS%,     \
 441: 0000:      PHKEEP.SESS.NUM%,    \
 442: 0000:      POGDB%,              \
 443: 0000:      RPS%,                \
 444: 0000:      RC1%,                \
 445: 0000:      SRMAP%,              \
 446: 0000:      SRMOD%,              \
 447: 0000:      SRMOD.DIR.SESS%,     \
 448: 0000:      SRPDF%,              \
 449: 0000:      SRPOG%,              \
 450: 0000:      SRSXF%,              \
 451: 0000:      SRPOG.COUNT%,        \
 452: 0000:      SRPDF.DIR.SESS%,     \
 453: 0000:      SRPOG.DIR.SESS%,     \
 454: 0000:      SRMOD.COUNT%,        \
 455: 0000:      SRPDF.COUNT%,        \
 456: 0000:      SRSXF.COUNT%,        \
 457: 0000:      SRSXF.DIR.SESS%,     \
 458: 0000:      TEMP.ARR%(1),         \
 459: 0000:      TEMP.COUNT%  
 460: 0000: 
 461: 0000: 
 462: 0000: 
 463: 0000: \***********************************************************************
 464: 0000: \*
 465: 0000: \*    Included code defining external Boots functions
 466: 0000: \*
 467: 0000: \***********************************************************************
 468: 0000:     
 469: 0000: %INCLUDE BEMFEXT.J86
 470: 0000: \******************************************************************************
 471: 0000: \***
 472: 0000: \***        EXTERNAL FUNCTION DEFINITIONS FOR THE ITEM REFERENCE FILE
 473: 0000: \***                                                            
 474: 0000: \***                        REFERENCE : BEMFEXT
 475: 0000: \***
 476: 0000: \***    Version A               Mark Walker                   1st November 1993
 477: 0000: \***
 478: 0000: \***    Version B       Stuart William McConnachie          25th September 2000
 479: 0000: \***    READ.BEMF function has got lost!
 480: 0000: \***
 481: 0000: \******************************************************************************
 482: 0000: 
 483: 0000:     FUNCTION BEMF.SET EXTERNAL
 484: 0000:     END FUNCTION
 485: 0000:     
 486: 0000:     FUNCTION READ.BEMF EXTERNAL
 487: 0000:     INTEGER*1 READ.BEMF
 488: 0000:     END FUNCTION
 489: 0000:     
 490: 0000:     
 491: 0000: %INCLUDE BASROUT.J86
 492: 0000: \*LIB   BVEJ BASROUT  J86      03/11/97 08:16:26 PIDBLD3  *    FIX
 493: 0000: \*PROM  BVEJ BASROUT  J86      03/10/97 17:18:40 PIDBLD3  MVEJ IR34352
 494: 0000: \*RTIME BVEJ BASROUT  J86      03/10/97 17:18:41 PIDBLD3  MVEJ IR34352
 495: 0000: \*LIB   MVEJ BASROUT  J86      03/05/97 10:48:46 EDJRAL   *    IR34352
 496: 0000: \*LIB   MVEJ BASROUT  J86      02/17/97 11:19:56 EDJRAL   *    REASONAR
 497: 0000: \*LIB   MVEJ BASROUT  J86      02/14/97 15:59:11 EDJRAL   *    REASONAR
 498: 0000: ! BASROUT.J86 - this file is to be included in any BASIC code which utilizes
 499: 0000: !   the BASROUT.OBJ routines.  These routines were written
 500: 0000: !  using Metaware C and are intended to provide functions which
 501: 0000: !         are either not available in 4680 CBASIC or which can be more
 502: 0000: !               efficiently handled by the C language.  Their usage is
 503: 0000: !  offered on an "AT YOUR OWN RISK" basis.
 504: 0000: !
 505: 0000: !               The insert/extract routines usefulness may not be immediately
 506: 0000: !               apparent.  Their intention is that they be used in conjunction
 507: 0000: !               with a read/write form command.  They can more efficiently
 508: 0000: !               parse a string into many different variables than can the
 509: 0000: !               read form statement.  So instead of a long list of data var's
 510: 0000: !               it may be more efficient to just read/write one long string
 511: 0000: !               and then use the insert/extract routines to parse out the
 512: 0000: !   data.
 513: 0000: 
 514: 0000: ! ******************* SUB PROCESS FUNCTIONS *********************************
 515: 0000: 
 516: 0000: function osshell(cmd.line$) external   ! routine to start
 517: 0000:        ! another program.
 518: 0000:            integer*4    osshell    ! Upon completion of
 519: 0000:            string       cmd.line$   ! program, control is
 520: 0000:        ! returned to calling
 521: 0000: end function      ! program.
 522: 0000: !
 523: 0000: ! NOTES:  Program must be a 286 type file.  This does not exclude
 524: 0000: !         the capability to execute a batch file however.  Simply pass the
 525: 0000: !         following:
 526: 0000: !              c:\adx_spgm\command.286 batfile
 527: 0000: !         where batfile is the name of the batch file to be executed.
 528: 0000: !
 529: 0000: ! IMPORTANT: When using osshell to execute a batch file as described above,
 530: 0000: !            the final command in the batch file must be "exit".  If not,
 531: 0000: !       control is never given back to the calling program.
 532: 0000: 
 533: 0000: ! ************************ MEMORY RELATED FUNCTIONS ************************
 534: 0000: 
 535: 0000: function memfree(choice) external   ! routine to que the
 536: 0000:        ! status of the
 537: 0000:  integer*4 memfree    ! machine's memory:
 538: 0000:  integer*2 choice    ! Options:
 539: 0000:        !    1 - free
 540: 0000: end function      !    2 - total
 541: 0000:        !    3 - system
 542: 0000: 
 543: 0000: ! ********************** TIMEDATE RELATED FUNCTIONS ************************
 544: 0000: 
 545: 0000: function timedate(choice) external   ! routine to que the
 546: 0000:        ! OS's timedate table
 547: 0000:  integer*4 timedate   ! Choices:
 548: 0000:  integer*2 choice    !    1 - millisec's
 549: 0000:        !        since midnight
 550: 0000: end function      !    2 - minutes from
 551: 0000:        !  UCT (timezone)
 552: 0000:        !    3 - day of week
 553: 0000:        !   0-Sunday
 554: 0000:        !  6-Saturday
 555: 0000: 
 556: 0000: function settime(msecs) external   ! routine to set the
 557: 0000:        ! time on the controller
 558: 0000:  integer*4  settime    ! msecs is the desired
 559: 0000:  integer*4 msecs    ! number of milliseconds
 560: 0000:        ! since midnight
 561: 0000: end function      ! Returns negative on
 562: 0000:        ! error
 563: 0000: ! NOTE:  This routine sets the time only on the controller.  The terminals'
 564: 0000: ! time will not be updated until 1 AM or unless a terminal is STC'd.
 565: 0000: ! At 1 AM the controller broadcasts the new time to all terminals.
 566: 0000: ! Insure this is taken into consideration when using this routine.
 567: 0000: 
 568: 0000: !******************** DISK FILE RELATED FUNCTIONS *************************
 569: 0000: 
 570: 0000: function truncate(name,length) external   ! routine to truncate
 571: 0000:        ! the specified file
 572: 0000:  integer*4 truncate   ! to a given length.
 573: 0000:  string  name
 574: 0000:  integer*4 length
 575: 0000: 
 576: 0000: end function
 577: 0000: 
 578: 0000: !******************** STRING VALUE RELATED FUNCTIONS **********************
 579: 0000: 
 580: 0000: function isalpha(bstrn) external   ! routine to identify
 581: 0000:        ! if the specified
 582: 0000:  integer*1 isalpha    ! string contains all
 583: 0000:  string  bstrn    ! alphabetic char's
 584: 0000:        ! Returns:
 585: 0000: end function      !     0 - all alpha
 586: 0000:        !     X - byte of 1st
 587: 0000:        !         non-alpha
 588: 0000:        !   char
 589: 0000: 
 590: 0000: function isdigit(bstrn) external   ! routine to identify
 591: 0000:        ! if the specified
 592: 0000:  integer*1 isdigit    ! string contains all
 593: 0000:  string  bstrn    ! numeric char's
 594: 0000:        ! Returns:
 595: 0000: end function      !     0 - all numeric
 596: 0000:        !     X - byte of 1st
 597: 0000:        !         non-numeric
 598: 0000:        !   char
 599: 0000: 
 600: 0000: function islower(bstrn) external   ! routine to identify
 601: 0000:        ! if the specified
 602: 0000:  integer*1 islower    ! string contains all
 603: 0000:  string  bstrn    ! lower case char's
 604: 0000:        ! Returns:
 605: 0000: end function      !     0 - all lowercase
 606: 0000:        !     X - byte of 1st
 607: 0000:        !         non-lowercase
 608: 0000:        !   char
 609: 0000: 
 610: 0000: function isupper(bstrn) external   ! routine to identify
 611: 0000:        ! if the specified
 612: 0000:  integer*1 isupper    ! string contains all
 613: 0000:  string  bstrn    ! upper case char's
 614: 0000:        ! Returns:
 615: 0000: end function      !     0 - all uppercase
 616: 0000:        !     X - byte of 1st
 617: 0000:        !         non-uppercase
 618: 0000:        !   char
 619: 0000: 
 620: 0000: function toalpha(bstrn) external   ! routine to convert
 621: 0000:        ! non-alpha or non-num
 622: 0000:    integer*2 toalpha    ! char's to spaces
 623: 0000:  string  bstrn    ! Returns:
 624: 0000: end function      !   x - no. of char's
 625: 0000:        !       changed
 626: 0000: 
 627: 0000: ! ********************* USER/GROUP ZERO LEVEL FUNCTIONS *********************
 628: 0000: 
 629: 0000: function idlecount(choice) external   ! routine to either
 630: 0000:        ! set to zero or queue
 631: 0000:  integer*4 idlecount   ! the value of the
 632: 0000:  integer*1 choice    ! processor's idlecount
 633: 0000:        ! Choice:
 634: 0000: end function      !     0 - set to zero
 635: 0000: !       !     1 - get value
 636: 0000: ! NEEDS USER/GROUP 0 LEVEL OF AUTHORIZATION  ! Returns:
 637: 0000: ! TO WORK - This level is not available unless  !     X - idlecount
 638: 0000: ! the file ADXCSOUF.DAT file is "patched".  This !    -X - error code
 639: 0000: ! is highly unrecommended.
 640: 0000: 
 641: 0000: function logical(actname,logname,choice) external ! routine to set a
 642: 0000:        ! a logical name.
 643: 0000:  integer*4 logical    ! parms are self
 644: 0000:         string  logname    ! explanatory except
 645: 0000:  string  actname    ! for choice:
 646: 0000:  integer*1 choice    !   0 - set process
 647: 0000:        !   1 - set system
 648: 0000: end function      !   2 - get process
 649: 0000:        !   3 - get system
 650: 0000: 
 651: 0000: ! NOTE:  Only the setting of a system level of logical name requires
 652: 0000: ! user/group zero level of authorization.  Any application may query any
 653: 0000: ! logical name.  Setting of a system logical name is only applicable until
 654: 0000: ! the system is IPL'd.  A process logical name is only active when that
 655: 0000: ! process is active.
 656: 0000: 
 657: 0000: !******************** STRING PARSING FUNCTIONS *****************************
 658: 0000: 
 659: 0000: function inserts(whole,part,offset) external  ! routine to insert a
 660: 0000:        ! string (part) into
 661: 0000:  integer*2 INSERTS    ! another string (whole)
 662: 0000:  string  whole    ! starting at specified
 663: 0000:  string  part    ! character (offset)
 664: 0000:  integer*2 offset
 665: 0000: 
 666: 0000: end function
 667: 0000: 
 668: 0000: function cinsert4(integer4,bstring,offset) external   ! routine to insert
 669: 0000:        ! a 4-byte integer into
 670: 0000:  integer*1 cinsert4   ! a string starting at
 671: 0000:  integer*4 integer4   ! byte specified by
 672: 0000:  string  bstring    ! offset (1-based)
 673: 0000:  integer*2 offset    ! Returns:
 674: 0000:        !     0 - Success
 675: 0000: end function      !    -1 - String overrun
 676: 0000: 
 677: 0000: function cinsert2(integer2,bstring,offset) external  ! routine to insert
 678: 0000:        ! a 2-byte integer into
 679: 0000:  integer*1 cinsert2   ! a string starting at
 680: 0000:  integer*2 integer2   ! byte specified by
 681: 0000:  string  bstring    ! offset (1-based)
 682: 0000:  integer*2 offset    ! Returns:
 683: 0000:        !     0 - Success
 684: 0000: end function      !    -1 - String overrun
 685: 0000: 
 686: 0000: function cinsert1(bstring,integer1,offset) external  ! routine to insert
 687: 0000:        ! a 1-byte integer into
 688: 0000:  integer*1 cinsert1   ! a string starting at
 689: 0000:  integer*1 integer1   ! byte specified by
 690: 0000:  string  bstring    ! offset (1-based)
 691: 0000:  integer*2 offset    ! Returns:
 692: 0000:        !     0 - Success
 693: 0000: end function      !    -1 - String overrun
 694: 0000: 
 695: 0000: function extracts(whole,part,offset) external  ! routine to extract a
 696: 0000:        ! string (part) from
 697: 0000:  integer*2 EXTRACTS   ! another string (whole)
 698: 0000:  string  whole    ! starting at specified
 699: 0000:  string  part    ! character (offset)
 700: 0000:  integer*2 offset
 701: 0000: 
 702: 0000: end function
 703: 0000: 
 704: 0000: function cextract4(bstring,offset) external  ! routine to extract
 705: 0000:        ! a 4-byte integer from
 706: 0000:  integer*4 cextract4   ! a string starting at
 707: 0000:                        ! byte specified by
 708: 0000:  string  bstring    ! offset (1-based)
 709: 0000:  integer*2 offset    ! Returns:
 710: 0000:        !     X - 4 byte integer
 711: 0000: end function      !    -1 - String overrun
 712: 0000: 
 713: 0000: function cextract2(bstring,offset) external  ! routine to extract
 714: 0000:        ! a 2-byte integer from
 715: 0000:  integer*2 cextract2   ! a string starting at
 716: 0000:                        ! byte specified by
 717: 0000:  string  bstring    ! offset (1-based)
 718: 0000:  integer*2 offset    ! Returns:
 719: 0000:        !     X - 2 byte integer
 720: 0000: end function      !    -1 - String overrun
 721: 0000: 
 722: 0000: function cextract1(bstring,offset) external  ! routine to extract
 723: 0000:        ! a 1-byte integer from
 724: 0000:  integer*1 cextract1   ! a string starting at
 725: 0000:                        ! byte specified by
 726: 0000:  string  bstring    ! offset (1-based)
 727: 0000:  integer*2 offset    ! Returns:
 728: 0000:        !     X - 1 byte integer
 729: 0000: end function      !    -1 - String overrun
 730: 0000: 
 731: 0000: 
 732: 0000: function srchdir (file.name$,dtbl.buffer$) external ! routine to return
 733: 0000:        ! file names and sizes
 734: 0000:        ! Return values:
 735: 0000:        !    -1  no matches
 736: 0000:        !        found on first
 737: 0000:        !        call
 738: 0000:        !    0   no matches
 739: 0000:        !        found on sub-
 740: 0000:        !        sequent calls
 741: 0000:        !    Pos Success
 742: 0000:        !    Neg OS Rtn Code
 743: 0000: ! Usage Note:  If searching for all occurences of a particular file name,
 744: 0000: ! first initialize dtbl.buffer$ to 48 Nulls (pack$("00")) and issue a call
 745: 0000: ! to srchdir.  If any matches are found, a positive value will be returned.
 746: 0000: ! To see if any more matches exist, just issue another call to srchdir without
 747: 0000: ! resetting the values of dtbl.buffer$.  If any are found, a positive value
 748: 0000: ! will be returned.  This can be repeated until a Zero is returned.  All data
 749: 0000: ! describing file will be returned in the dtbl.buffer$ after each call.  Format
 750: 0000: ! of this data is defined below.
 751: 0000: 
 752: 0000:  integer*4 srchdir
 753: 0000: 
 754: 0000:  string  file.name$   ! file name to start
 755: 0000:        ! search (18 bytes max)
 756: 0000:        ! Wild cards and logical
 757: 0000:        ! names supported.
 758: 0000: 
 759: 0000:  string  dtbl.buffer$   ! must be initialized
 760: 0000:        ! to 48 bytes.  Contains
 761: 0000:        ! all of directory info
 762: 0000:        ! Initialize to nulls
 763: 0000:        ! each time a new file
 764: 0000:        ! name is used.
 765: 0000: 
 766: 0000: ! NOTE:  Format of dtbl.buffer$ string is as follows:
 767: 0000: !
 768: 0000: ! Offs  Type                    Description Notes
 769: 0000: !  0 integer*4  key  use extract4 to access
 770: 0000: !  4  string (18 bytes) file name
 771: 0000: ! 22 integer*2  attributes use extract2 to access
 772: 0000: !      0x01 - Read Only
 773: 0000: !      0x02 - Hidden
 774: 0000: !      0x04 - System
 775: 0000: !      0x08 - Volume Label
 776: 0000: !      0x10 - Subdirectory
 777: 0000: !      0x20 - Archive (Files)
 778: 0000: !      0x40 - Security enabled
 779: 0000: !      0x80 - Reserved
 780: 0000: !      0x0000 - Local
 781: 0000: !      0x4000 - Mirrored/Update
 782: 0000: !      0xC000 - Mirrored/Close
 783: 0000: !
 784: 0000: !      0x6000 - Compound/Update
 785: 0000: !      0xE000 - Compound/Close
 786: 0000: ! 24 integer*2  record size use extract2 to access
 787: 0000: ! 26 integer*1  User ID of Owner
 788: 0000: ! 27 integer*1  Group ID of Owner
 789: 0000: ! 28 integer*2  File Security
 790: 0000: ! 30 string (6 bytes) Reserved
 791: 0000: ! 36 integer*4  File Size use extract4 to access
 792: 0000: ! 40 integer*2  Year  use extract2 to access
 793: 0000: ! 42 integer*1  Month
 794: 0000: ! 43 integer*1  Day
 795: 0000: ! 44 integer*1  Hour
 796: 0000: ! 45 integer*1  Minute
 797: 0000: ! 46 integer*1  Second
 798: 0000: ! 47 integer*1  Reserved
 799: 0000: 
 800: 0000: end function
 801: 0000: 
 802: 0000: function srchproc (proc.name$,ptbl.buffer$) external ! routine to return
 803: 0000:        ! process names and
 804: 0000:        ! status.  Handy to
 805: 0000:        ! determine if a
 806: 0000:        ! program is currently
 807: 0000:        ! running.
 808: 0000:        ! Return values:
 809: 0000:        !    -1  no matches
 810: 0000:        !        found on first
 811: 0000:        !        call
 812: 0000:        !    0   no matches
 813: 0000:        !        found on sub-
 814: 0000:        !        sequent calls
 815: 0000:        !    Pos Success
 816: 0000:        !    Neg Failure
 817: 0000:        !        OS Rtn Code
 818: 0000:        ! 80000001h - Insuff
 819: 0000:         !        ptbl buffer
 820: 0000:        !        Length
 821: 0000: ! Usage Note:  If searching for all occurences of a particular process name,
 822: 0000: ! first initialize ptbl.buffer$ to 60 Nulls (pack$("00")) and issue a call
 823: 0000: ! to srchproc.  If any matches are found, a positive value will be returned.
 824: 0000: ! To see if any more matches exist, just issue another call to srchproc without
 825: 0000: ! resetting the values of ptbl.buffer$.  If any are found, a positive value
 826: 0000: ! will be returned.  This can be repeated until a Zero is returned.  All data
 827: 0000: ! describing file will be returned in the ptbl.buffer$ after each call.  Format
 828: 0000: ! of this data is defined as follows:
 829: 0000: !
 830: 0000: !       --------------------------------------------------------
 831: 0000: !   0   |                         PID                          |
 832: 0000: !       --------------------------------------------------------
 833: 0000: !   4   |           FID             |   CID        |   VCID    |
 834: 0000: !       --------------------------------------------------------
 835: 0000: !   8   |                         NAME                         |
 836: 0000: !       --------------------------------------------------------
 837: 0000: !  12   |                         NAME cont'd                  |
 838: 0000: !       --------------------------------------------------------
 839: 0000: !  16   |       NAME cont'd         |   STATE      |  PRIOR    |
 840: 0000: !       --------------------------------------------------------
 841: 0000: !  20   |                         MAXMEM                       |
 842: 0000: !       --------------------------------------------------------
 843: 0000: !  24   |       FLAGS               |   USER        |  GROUP   |
 844: 0000: !       --------------------------------------------------------
 845: 0000: !  28   |                         PARENT                       |
 846: 0000: !       --------------------------------------------------------
 847: 0000: !  32   |                         EVENTS                       |
 848: 0000: !       --------------------------------------------------------
 849: 0000: !  36   |                         CODE                         |
 850: 0000: !       --------------------------------------------------------
 851: 0000: !  40   |                         CSIZE                        |
 852: 0000: !       --------------------------------------------------------
 853: 0000: !  44   |                         DATA                         |
 854: 0000: !       --------------------------------------------------------
 855: 0000: !  48   |                         DSIZE                        |
 856: 0000: !       --------------------------------------------------------
 857: 0000: !  52   |                         HEAP                         |
 858: 0000: !       --------------------------------------------------------
 859: 0000: !  56   |                         HSIZE                        |
 860: 0000: !       --------------------------------------------------------
 861: 0000: !
 862: 0000: !       PID   Process ID
 863: 0000: !       FID  Process's Family ID
 864: 0000: !       CID   Physical Console Device Number
 865: 0000: !       VCID  Process's Virtual Console Number
 866: 0000: !       NAME  Process Name (Application Running)
 867: 0000: ! STATE    Process State (0-Run, 1-Waiting, 2-Terminating)
 868: 0000: ! PRIOR    Priority
 869: 0000: !       MAXMEM  Maximum Memory Allowed
 870: 0000: !       FLAGS  Bit 0 (1-System Process, 0-User Process)
 871: 0000: !   Bit 1 (1-Locked in Memory, 0-Swappable)
 872: 0000: !   Bit 2 (1-Running in SWI context, 0-Running in main context)
 873: 0000: !   Bit 3 (1-Superuser Process,0-Not a Superuser Process)
 874: 0000: ! USER  User Number
 875: 0000: ! GROUP  Group Number
 876: 0000: !       PARENT   Parent Process ID
 877: 0000: !       EVENTS   Bit Map of events that have completed but not retrieved
 878: 0000: !       CODE  Start of code area in user space
 879: 0000: ! CSIZE  Size in bytes of code area
 880: 0000: !       DATA  Start of data area in user space
 881: 0000: ! DSIZE  Size in bytes of data area
 882: 0000: !       HEAP  Start of heap area in user space
 883: 0000: ! HSIZE  Size in bytes of heap area
 884: 0000: !
 885: 0000:  integer*4 srchproc
 886: 0000: 
 887: 0000:  string  proc.name$   ! process name to start
 888: 0000:        ! search (10 bytes max)
 889: 0000:        ! Wild cards and logical
 890: 0000:        ! names supported.
 891: 0000: 
 892: 0000:  string  ptbl.buffer$   ! must be initialized
 893: 0000:        ! to 60 bytes.  Contains
 894: 0000:        ! all of process info
 895: 0000:        ! Initialize to nulls
 896: 0000:        ! each time a new
 897: 0000:        ! process name is used.
 898: 0000: 
 899: 0000: end function
 900: 0000: 
 901: 0000: function cconstat(timeout) external       ! function similar
 902: 0000:                                               ! to BASIC constat%
 903: 0000:  integer*2 cconstat   ! waits for either a
 904: 0000:  integer*4 timeout    ! key being hit or
 905: 0000:        ! the timer expiring
 906: 0000:        ! before returning
 907: 0000:        ! returns:
 908: 0000:        !   -1 error
 909: 0000:        !    0 timer expired
 910: 0000:        !    x scan code of
 911: 0000:        !      key hit
 912: 0000: end function
 913: 0000: 
 914: 0000: function disksize(disk.name$) external   ! function to find
 915: 0000:        ! the total size of
 916: 0000:  integer*4 disksize   ! the specified disk
 917: 0000:  string  disk.name$   ! name (e.g. "h0:")
 918: 0000:        ! if return value is
 919: 0000:        ! negative, error
 920: 0000: end function      ! was received
 921: 0000: 
 922: 0000: 
 923: 0000: %INCLUDE BOOTSEXT.J86
 924: 0000: \******************************************************************************
 925: 0000: \******************************************************************************
 926: 0000: SUB LOG.ERROR(F.1$) EXTERNAL
 927: 0000:     STRING  F.1$
 928: 0000: END SUB
 929: 0000: 
 930: 0000: \******************************************************************************
 931: 0000: \******************************************************************************
 932: 0000: FUNCTION FORCE.CASE$(DATA$,TYPE%) EXTERNAL
 933: 0000:     STRING      FORCE.CASE$
 934: 0000:     STRING      DATA$
 935: 0000:     INTEGER*2   TYPE%
 936: 0000:     STRING      IN$, OUT$
 937: 0000:     STRING      LWR$, UPR$
 938: 0000: END FUNCTION
 939: 0000: 
 940: 0000: \******************************************************************************
 941: 0000: \******************************************************************************
 942: 0000: FUNCTION REMOVE.CHARACTER$(DATA$,F.CHR$) EXTERNAL
 943: 0000:     STRING      DATA$
 944: 0000:     STRING      F.CHR$
 945: 0000:     STRING      REMOVE.CHARACTER$
 946: 0000:     INTEGER*2   START%
 947: 0000:     INTEGER*2   END%
 948: 0000:     INTEGER*2   POS%
 949: 0000:     INTEGER*2   F.LEN%
 950: 0000: END FUNCTION
 951: 0000: 
 952: 0000: \******************************************************************************
 953: 0000: \******************************************************************************
 954: 0000: FUNCTION REMOVE.SPACES$(DATA$) EXTERNAL
 955: 0000:     STRING      DATA$
 956: 0000:     STRING      REMOVE.SPACES$
 957: 0000:     INTEGER*2   START%
 958: 0000:     INTEGER*2   END%
 959: 0000:     INTEGER*2   POS%
 960: 0000: END FUNCTION
 961: 0000: 
 962: 0000: \*******************************************************************************
 963: 0000: \***
 964: 0000: \***    FUNCTION     :    TIME.STAMP$
 965: 0000: \***    
 966: 0000: \***    Returns a string with formatted date and/or time detail
 967: 0000: \***                 Passed values are 1 = Date, 2 = Time
 968: 0000: \*******************************************************************************
 969: 0000: FUNCTION TIME.STAMP$(F.TYPE%) EXTERNAL
 970: 0000:     STRING      TIME.STAMP$
 971: 0000:     INTEGER*2   F.TYPE%
 972: 0000:     STRING      F.DT$
 973: 0000:     STRING      F.RET$
 974: 0000: END FUNCTION
 975: 0000: \*******************************************************************************
 976: 0000: 
 977: 0000: 
 978: 0000: \*******************************************************************************
 979: 0000: \*******************************************************************************
 980: 0000: FUNCTION PRINT.MSG$(MSG$,F%,L%) EXTERNAL
 981: 0000: STRING      PRINT.MSG$
 982: 0000: STRING      MSG$
 983: 0000: INTEGER*2   F%
 984: 0000: INTEGER*2   L%
 985: 0000: STRING      IN$
 986: 0000: STRING      F.FORM$
 987: 0000: END FUNCTION
 988: 0000: \*******************************************************************************
 989: 0000: 
 990: 0000: \*******************************************************************************
 991: 0000: \***
 992: 0000: \***    SUBROUTINE     :    BACKGROUND.MSG(B.MSG$)
 993: 0000: \***    
 994: 0000: \***    Displays passed message to the background message.
 995: 0000: \*******************************************************************************
 996: 0000: SUB BACKGROUND.MSG(B.MSG$) EXTERNAL
 997: 0000:     STRING      B.MSG$
 998: 0000:     INTEGER*4   B.RET%
 999: 0000: END SUB
1000: 0000: \*******************************************************************************
1001: 0000: 
1002: 0000: !*****************************************************************************!
1003: 0000: !***                                                                          !
1004: 0000: !*** SUBROUTINE :   NO.OPEN.FILE                                              !
1005: 0000: !***                    F.REPORT%       - Passed report number for logging    !
1006: 0000: !***                    F.OPEN.FLAG$    - Returned flag for not-opened        !
1007: 0000: !***                                                                          !
1008: 0000: !*** This subroutine logs an application 106 error with the passed report     !
1009: 0000: !*** number. It also sets a return variable to "N" to flag that the file is   !
1010: 0000: !*** not Open because of the failure.                                         !
1011: 0000: !***                                                                          !
1012: 0000: !*****************************************************************************!
1013: 0000: SUB NO.OPEN.FILE(F.REPORT%,F.OPEN.FLAG$) EXTERNAL                                      
1014: 0000:     INTEGER*2   F.REPORT%                                                         
1015: 0000:     STRING      F.OPEN.FLAG$                                                      
1016: 0000:     STRING      F.1$, F.2$
1017: 0000:     INTEGER*2   F.EVENT%
1018: 0000: END SUB                                                                       
1019: 0000: !*****************************************************************************!
1020: 0000: 
1021: 0000: 
1022: 0000: FUNCTION NUMBER.OF.DAYS%(START$,END$) EXTERNAL
1023: 0000: INTEGER*2   NUMBER.OF.DAYS%
1024: 0000: STRING      START$
1025: 0000: STRING      END$
1026: 0000: INTEGER*2   F.DAYS%
1027: 0000: INTEGER*4   S.DAYS%
1028: 0000: INTEGER*4   E.DAYS%
1029: 0000: END FUNCTION
1030: 0000: 
1031: 0000: FUNCTION HEX.FORMAT$(F.DATA$) EXTERNAL
1032: 0000: STRING  HEX.FORMAT$
1033: 0000: STRING  F.DATA$
1034: 0000: STRING      F.RET$
1035: 0000: INTEGER*2   F.LEN%
1036: 0000: STRING      F.TMP$(2)
1037: 0000: STRING      F.FORM$
1038: 0000: STRING      F.ASCII$
1039: 0000: STRING      F.ASC$
1040: 0000: STRING      F.HEX$
1041: 0000: STRING      F.WORK$, F.W2$
1042: 0000: INTEGER*2   F.LOOP%, F.L2%
1043: 0000: END FUNCTION
1044: 0000: 
1045: 0000: FUNCTION FORMAT.NUMBER$(F.NUM$,F.DEC%) EXTERNAL
1046: 0000: STRING      FORMAT.NUMBER$
1047: 0000: STRING      F.NUM$
1048: 0000: INTEGER*2   F.DEC%
1049: 0000: INTEGER*4   F.NUM%
1050: 0000: END FUNCTION
1051: 0000: 
1052: 0000: \*******************************************************************************
1053: 0000: FUNCTION FORMAT.BOOTS.CODE$(F.CODE$) EXTERNAL
1054: 0000: STRING  FORMAT.BOOTS.CODE$
1055: 0000: STRING  F.CODE$
1056: 0000: END FUNCTION
1057: 0000: 
1058: 0000: FUNCTION FORMAT.STRING$(F.STRING$,F.L%,F.P$,F.J%) EXTERNAL
1059: 0000: STRING    FORMAT.STRING$
1060: 0000: STRING    F.STRING$
1061: 0000: INTEGER*2 F.L%
1062: 0000: STRING    F.P$
1063: 0000: INTEGER*2 F.J%
1064: 0000: END FUNCTION
1065: 0000: 
1066: 0000: SUB GET.BLOCK.SIZE(F.BLOCK.SIZE%,F.FILENAME$,F.SIZE%) EXTERNAL
1067: 0000: INTEGER*4   F.BLOCK.SIZE%
1068: 0000: STRING      F.FILENAME$
1069: 0000: INTEGER*4   F.SIZE%
1070: 0000: INTEGER*4   F.BLOCK%
1071: 0000: INTEGER*2   F.SECTOR%
1072: 0000: INTEGER*2   F.LOOP%
1073: 0000: STRING      F.BLOCK.LENGTH$
1074: 0000: END SUB
1075: 0000: %INCLUDE BTCMEM.J86
1076: 0000: !********************************************************************
1077: 0000: !***
1078: 0000: !***    INCLUDED CODE:  BTCMEM.J86
1079: 0000: !***    AUTHOR:         Stuart William McConnachie
1080: 0000: !***    DATE:           26th February 2006
1081: 0000: !***
1082: 0000: !********************************************************************
1083: 0000: !***
1084: 0000: !***    Controller CBASIC Memory Functions
1085: 0000: !***
1086: 0000: !********************************************************************
1087: 0000: 
1088: 0000: !Get a single byte integer from a string offset
1089: 0000: FUNCTION GETN1 (S$, P%) EXTERNAL
1090: 0000:     STRING S$
1091: 0000:     INTEGER*2 P%
1092: 0000:     INTEGER*2 GETN1
1093: 0000: END FUNCTION
1094: 0000: 
1095: 0000: !Get a two byte integer from a string offset
1096: 0000: FUNCTION GETN2 (S$, P%) EXTERNAL
1097: 0000:     STRING S$
1098: 0000:     INTEGER*2 P%
1099: 0000:     INTEGER*2 GETN2
1100: 0000: END FUNCTION
1101: 0000: 
1102: 0000: !Get a four byte integer from a string offset
1103: 0000: FUNCTION GETN4 (S$, P%) EXTERNAL
1104: 0000:     STRING S$
1105: 0000:     INTEGER*2 P%
1106: 0000:     INTEGER*4 GETN4
1107: 0000: END FUNCTION
1108: 0000: 
1109: 0000: !Get a 10 byte CBASIC real from a string offset
1110: 0000: FUNCTION GETR10 (S$, P%) EXTERNAL
1111: 0000:     STRING S$
1112: 0000:     INTEGER*2 P%
1113: 0000:     REAL GETR10
1114: 0000: END FUNCTION
1115: 0000: 
1116: 0000: !Put a single byte integer into a string at offset
1117: 0000: FUNCTION PUTN1 (S$, P%, N%) EXTERNAL
1118: 0000:     STRING S$
1119: 0000:     INTEGER*2 P%
1120: 0000:     INTEGER*1 N%
1121: 0000:     INTEGER*1 PUTN1
1122: 0000: END FUNCTION
1123: 0000: 
1124: 0000: !Put a two byte integer into a string at offset
1125: 0000: FUNCTION PUTN2 (S$, P%, N%) EXTERNAL
1126: 0000:     STRING S$
1127: 0000:     INTEGER*2 P%
1128: 0000:     INTEGER*2 N%
1129: 0000:     INTEGER*1 PUTN2
1130: 0000: END FUNCTION
1131: 0000: 
1132: 0000: !Put a four byte integer into a string at offset
1133: 0000: FUNCTION PUTN4 (S$, P%, N%) EXTERNAL
1134: 0000:     STRING S$
1135: 0000:     INTEGER*2 P%
1136: 0000:     INTEGER*4 N%
1137: 0000:     INTEGER*1 PUTN4
1138: 0000: END FUNCTION
1139: 0000: 
1140: 0000: !Put a 10 byte CBASIC real into a string at offset
1141: 0000: FUNCTION PUTR10 (S$, P%, R) EXTERNAL
1142: 0000:     STRING S$
1143: 0000:     INTEGER*2 P%
1144: 0000:     REAL R
1145: 0000:     INTEGER*1 PUTR10
1146: 0000: END FUNCTION
1147: 0000: 
1148: 0000: !Peek a two byte integer from a memory address
1149: 0000: FUNCTION PEEKN2 (A%) EXTERNAL
1150: 0000:     INTEGER*4 A%
1151: 0000:     INTEGER*2 PEEKN2
1152: 0000: END FUNCTION
1153: 0000: 
1154: 0000: !Peek a four byte integer from a memory address
1155: 0000: FUNCTION PEEKN4 (A%) EXTERNAL
1156: 0000:     INTEGER*4 A%
1157: 0000:     INTEGER*4 PEEKN4
1158: 0000: END FUNCTION
1159: 0000: 
1160: 0000: !Peek a 10 byte CBASIC real from a memory address
1161: 0000: FUNCTION PEEKR10 (A%) EXTERNAL
1162: 0000:     INTEGER*4 A%
1163: 0000:     REAL PEEKR10
1164: 0000: END FUNCTION
1165: 0000: 
1166: 0000: !Poke a two byte integer to a memory address
1167: 0000: FUNCTION POKEN2 (A%, N%) EXTERNAL
1168: 0000:     INTEGER*4 A%
1169: 0000:     INTEGER*2 N%
1170: 0000:     INTEGER*1 POKEN2
1171: 0000: END FUNCTION
1172: 0000: 
1173: 0000: !Poke a four byte integer to a memory address
1174: 0000: FUNCTION POKEN4 (A%, N%) EXTERNAL
1175: 0000:     INTEGER*4 A%
1176: 0000:     INTEGER*4 N%
1177: 0000:     INTEGER*1 POKEN4
1178: 0000: END FUNCTION
1179: 0000: 
1180: 0000: !Poke a 10 byte CBASIC real to a memory address
1181: 0000: FUNCTION POKER10 (A%, R) EXTERNAL
1182: 0000:     INTEGER*4 A%
1183: 0000:     REAL R
1184: 0000:     INTEGER*1 POKER10
1185: 0000: END FUNCTION
1186: 0000: 
1187: 0000: %INCLUDE POGDEEXT.J86
1188: 0000: \********************************************************************
1189: 0000: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE POGDE FILE
1190: 0000: \***      REFERENCE : POGDEEXT.J86
1191: 0000: \***      Version A           Neil Bennett            8th June 2006
1192: 0000: \***
1193: 0000: \********************************************************************
1194: 0000: 
1195: 0000:        FUNCTION POGDE.SET EXTERNAL
1196: 0000:        END FUNCTION
1197: 0000: 
1198: 0000:        FUNCTION READ.POGDE EXTERNAL
1199: 0000:           INTEGER*2 READ.POGDE
1200: 0000:        END FUNCTION
1201: 0000: %INCLUDE POGOKEXT.J86
1202: 0000: \********************************************************************
1203: 0000: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE POGOK FILE
1204: 0000: \***      REFERENCE : POGOKEXT.J86
1205: 0000: \***      Version A           Neil Bennett            6th June 2006
1206: 0000: \***
1207: 0000: \********************************************************************
1208: 0000: 
1209: 0000:        FUNCTION POGOK.SET EXTERNAL
1210: 0000:        END FUNCTION
1211: 0000: 
1212: 0000:        FUNCTION READ.POGOK EXTERNAL
1213: 0000:           INTEGER*2 READ.POGOK
1214: 0000:        END FUNCTION
1215: 0000: 
1216: 0000:        FUNCTION READ.POGOK.LOCK EXTERNAL
1217: 0000:           INTEGER*2 READ.POGOK.LOCK
1218: 0000:        END FUNCTION
1219: 0000: 
1220: 0000:        FUNCTION WRITE.POGOK EXTERNAL
1221: 0000:           INTEGER*2 WRITE.POGOK
1222: 0000:        END FUNCTION
1223: 0000: 
1224: 0000:        FUNCTION WRITE.POGOK.UNLOCK EXTERNAL
1225: 0000:           INTEGER*2 WRITE.POGOK.UNLOCK
1226: 0000:        END FUNCTION
1227: 0000: 
1228: 0000:        FUNCTION CREATE.POGOK EXTERNAL
1229: 0000:           INTEGER*2 CREATE.POGOK
1230: 0000:        END FUNCTION
1231: 0000: %INCLUDE PSBF01E.J86 
1232: 0000: REM \
1233: 0000: \*******************************************************************************
1234: 0000: \*******************************************************************************
1235: 0000: \***
1236: 0000: \***      %INCLUDE FOR EXTERNAL DEFINITION OF FUNCTION APPLICATION.LOG
1237: 0000: \***
1238: 0000: \***                      FUNCTION NUMBER   : PSBF01
1239: 0000: \***
1240: 0000: \***                    INCLUDE REFERENCE : PSBF01E.J86
1241: 0000: \*** 
1242: 0000: \***      Version B           Andrew Wedgeworth          1st July 1992
1243: 0000: \***      Three parameters which passed to the function have been removed.
1244: 0000: \***      APPLICATION.LOG has been added as a variable name (this holds the
1245: 0000: \***      return code).
1246: 0000: \***
1247: 0000: \*******************************************************************************
1248: 0000: 
1249: 0000: 
1250: 0000:    FUNCTION APPLICATION.LOG (MESSAGE.NO%,                                     \
1251: 0000:                              VAR.STRING.1$,                                   \
1252: 0000:                              VAR.STRING.2$,                                   \
1253: 0000:                              EVENT.NO%)  EXTERNAL
1254: 0000: 
1255: 0000:       INTEGER*1 EVENT.NO%
1256: 0000: 
1257: 0000:       INTEGER*2 APPLICATION.LOG,                                       \ GAW
1258: 0000:                 MESSAGE.NO%
1259: 0000: 
1260: 0000:       STRING VAR.STRING.1$,                                            \
1261: 0000:              VAR.STRING.2$
1262: 0000: 
1263: 0000:    END FUNCTION
1264: 0000: 
1265: 0000: \*******************************************************************************
1266: 0000: %INCLUDE PSBF20E.J86 
1267: 0000: REM\
1268: 0000: \*******************************************************************************
1269: 0000: \*******************************************************************************
1270: 0000: \***
1271: 0000: \***       %INCLUDE FOR EXTERNAL DEFINITION OF SESS.NUM.UTILITY
1272: 0000: \***
1273: 0000: \***                  REFERENCE     : PSBF20E.J86
1274: 0000: \***
1275: 0000: \***     VERSION C            Janet Smith                13th May 1992
1276: 0000: \***     Increased PASSED.INTEGER to 2 bytes to cater for more than
1277: 0000: \***     128 files.
1278: 0000: \***
1279: 0000: \***     VERSION D.           Andrew Wedgeworth          1st July 1992
1280: 0000: \***     Removal of redundant parameters and addition of SESS.NUM.UTILITY
1281: 0000: \***     as a variable.  This new variable contains the function's return
1282: 0000: \***     code.
1283: 0000: \***
1284: 0000: \*******************************************************************************
1285: 0000: \*******************************************************************************
1286: 0000: 
1287: 0000:    FUNCTION SESS.NUM.UTILITY (FUNCTION.FLAG$,                          \
1288: 0000:                               PASSED.INTEGER%,                         \
1289: 0000:                               PASSED.STRING$)                          \
1290: 0000:    EXTERNAL
1291: 0000: 
1292: 0000:    STRING    FUNCTION.FLAG$,                                           \
1293: 0000:              PASSED.STRING$
1294: 0000:    ! 3 variables removed from here                                     ! CAW
1295: 0000: 
1296: 0000: 
1297: 0000:    INTEGER*2 SESS.NUM.UTILITY,                                         \ CAW
1298: 0000:              PASSED.INTEGER%				               ! CJAS
1299: 0000: 
1300: 0000:    END FUNCTION
1301: 0000: 
1302: 0000: %INCLUDE PSBF24E.J86
1303: 0000: REM \
1304: 0000: \*******************************************************************************
1305: 0000: \*******************************************************************************
1306: 0000: \***
1307: 0000: \***    %INCLUDE FOR EXTERNAL DEFINITION OF STANDARD.ERROR.DETECTED FUNCTION
1308: 0000: \***
1309: 0000: \***                      REFERENCE     : PSBF24E.J86
1310: 0000: \***
1311: 0000: \***    Version A                 Janet Smith                  13th May 1992
1312: 0000: \***
1313: 0000: \*******************************************************************************
1314: 0000: \*******************************************************************************
1315: 0000: 
1316: 0000:    FUNCTION STANDARD.ERROR.DETECTED(ERRN%,                 \
1317: 0000: 				    ERRFILE%,              \
1318: 0000: 				    ERRL%,                 \
1319: 0000: 				    ERR$)        EXTERNAL
1320: 0000: 				    
1321: 0000:           STRING    ERR$
1322: 0000: 
1323: 0000:           INTEGER*2 ERRFILE%,              \
1324: 0000: 	            ERRL%,                 \
1325: 0000: 		    STANDARD.ERROR.DETECTED
1326: 0000: 		    
1327: 0000:           INTEGER*4 ERRN%
1328: 0000: 	  		    
1329: 0000:    END FUNCTION
1330: 0000: 
1331: 0000: 
1332: 0000: %INCLUDE SRPEXT.J86
1333: 0000: \********************************************************************
1334: 0000: \***      Space and Range Planner Common Functions  (SRPFUN)
1335: 0000: \***      Version A           Neil Bennett          24.08.2006
1336: 0000: \***
1337: 0000: \....................................................................
1338: 0000: \***
1339: 0000: \***    GET.CATID Construct a 4 byte integer Category ID from 3
1340: 0000: \***              hierarchical (I4) keys supplied.
1341: 0000: \***
1342: 0000: \********************************************************************
1343: 0000: 
1344: 0000:    FUNCTION GET.CATID%(lev1%,lev2%,lev3%) EXTERNAL
1345: 0000: 
1346: 0000:     INTEGER*4 GET.CATID%
1347: 0000:     INTEGER*4 lev1%, lev2%, lev3%
1348: 0000: 
1349: 0000:    END FUNCTION
1350: 0000: 
1351: 0000: \********************************************************************
1352: 0000: %INCLUDE SRPDFEXT.J86
1353: 0000: \********************************************************************
1354: 0000: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE SRPDF FILE
1355: 0000: \***      REFERENCE : SRPDFEXT.J86
1356: 0000: \***      Version A           Neil Bennett          7th August 2006
1357: 0000: \***
1358: 0000: \********************************************************************
1359: 0000: 
1360: 0000:        FUNCTION SRPDF.SET EXTERNAL
1361: 0000:        END FUNCTION
1362: 0000: 
1363: 0000:        FUNCTION READ.SRPDF EXTERNAL
1364: 0000:           INTEGER*2 READ.SRPDF
1365: 0000:        END FUNCTION
1366: 0000: 
1367: 0000:        FUNCTION WRITE.SRPDF EXTERNAL
1368: 0000:           INTEGER*2 WRITE.SRPDF
1369: 0000:        END FUNCTION
1370: 0000: 
1371: 0000:        FUNCTION DELREC.SRPDF EXTERNAL
1372: 0000:           INTEGER*2 DELREC.SRPDF
1373: 0000:        END FUNCTION
1374: 0000: %INCLUDE SRPOGEXT.J86
1375: 0000: \********************************************************************
1376: 0000: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE SRPOG FILE
1377: 0000: \***      REFERENCE : SRPOGEXT.J86
1378: 0000: \***      Version A           Neil Bennett            5th June 2006
1379: 0000: \***
1380: 0000: \********************************************************************
1381: 0000: 
1382: 0000:        FUNCTION SRPOG.SET EXTERNAL
1383: 0000:        END FUNCTION
1384: 0000: 
1385: 0000:        FUNCTION READ.SRPOG EXTERNAL
1386: 0000:           INTEGER*2 READ.SRPOG
1387: 0000:        END FUNCTION
1388: 0000: 
1389: 0000:        FUNCTION WRITE.SRPOG EXTERNAL
1390: 0000:           INTEGER*2 WRITE.SRPOG
1391: 0000:        END FUNCTION
1392: 0000: 
1393: 0000:        FUNCTION DELREC.SRPOG EXTERNAL
1394: 0000:           INTEGER*2 DELREC.SRPOG
1395: 0000:        END FUNCTION
1396: 0000: %INCLUDE SRMODEXT.J86
1397: 0000: \********************************************************************
1398: 0000: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE SRMOD FILE
1399: 0000: \***      REFERENCE : SRMODEXT.J86
1400: 0000: \***      Version A           Neil Bennett            5th June 2006
1401: 0000: \***
1402: 0000: \********************************************************************
1403: 0000: 
1404: 0000:        FUNCTION SRMOD.SET EXTERNAL
1405: 0000:        END FUNCTION
1406: 0000: 
1407: 0000:        FUNCTION READ.SRMOD EXTERNAL
1408: 0000:           INTEGER*2 READ.SRMOD
1409: 0000:        END FUNCTION
1410: 0000: 
1411: 0000:        FUNCTION WRITE.SRMOD EXTERNAL
1412: 0000:           INTEGER*2 WRITE.SRMOD
1413: 0000:        END FUNCTION
1414: 0000: 
1415: 0000:        FUNCTION DELREC.SRMOD EXTERNAL
1416: 0000:           INTEGER*2 DELREC.SRMOD
1417: 0000:        END FUNCTION
1418: 0000: 
1419: 0000:        SUB SRMOD.SPLIT.SHELF.ITEM EXTERNAL
1420: 0000:        END SUB
1421: 0000: %INCLUDE SRSXFEXT.J86
1422: 0000: \********************************************************************
1423: 0000: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE SRSXF FILE
1424: 0000: \***      REFERENCE : SRSXFEXT.J86
1425: 0000: \***      Version A           Neil Bennett          7th August 2006
1426: 0000: \***
1427: 0000: \********************************************************************
1428: 0000: 
1429: 0000:        FUNCTION SRSXF.SET EXTERNAL
1430: 0000:        END FUNCTION
1431: 0000: 
1432: 0000:        FUNCTION READ.SRSXF EXTERNAL
1433: 0000:           INTEGER*2 READ.SRSXF
1434: 0000:        END FUNCTION
1435: 0000: 
1436: 0000:        FUNCTION WRITE.SRSXF EXTERNAL
1437: 0000:           INTEGER*2 WRITE.SRSXF
1438: 0000:        END FUNCTION
1439: 0000: 
1440: 0000:        FUNCTION DELREC.SRSXF EXTERNAL
1441: 0000:           INTEGER*2 DELREC.SRSXF
1442: 0000:        END FUNCTION
1443: 0000: %INCLUDE SRMAPEXT.J86                                                   !ARG
1444: 0000: \********************************************************************
1445: 0000: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE SRMAP FILE
1446: 0000: \***      REFERENCE : SRMAPEXT.J86
1447: 0000: \***      Version A           Neil Bennett           14th June 2006
1448: 0000: \***
1449: 0000: \********************************************************************
1450: 0000: 
1451: 0000:        FUNCTION SRMAP.SET EXTERNAL
1452: 0000:        END FUNCTION
1453: 0000: 
1454: 0000:        FUNCTION READ.SRMAP EXTERNAL
1455: 0000:           INTEGER*2 READ.SRMAP
1456: 0000:        END FUNCTION
1457: 0000: 
1458: 0000:        FUNCTION WRITE.SRMAP EXTERNAL
1459: 0000:           INTEGER*2 WRITE.SRMAP
1460: 0000:        END FUNCTION
1461: 0000: 
1462: 0000: \***********************************************************************
1463: 0000: \*
1464: 0000: \*    INITIALISATION : This Sub-routine does all the initial processing
1465: 0000: \*                     before starting the main process
1466: 0000: \*
1467: 0000: \***********************************************************************
1468: 0000: 
1469: 0000: FUNCTION FLEXOSSVC(COMMAND%, PARAM$) EXTERNAL                           
1470: 0000:                                                                         
1471: 0000:       STRING PARAM$                                                     
1472: 0000:       INTEGER*2 COMMAND%, FLEXOSSVC                                     
1473: 0000:                                                                         
1474: 0000: END FUNCTION                                                            
1475: 0000: 
1476: 0000: \**********************************************************************
1477: 0000: \***
1478: 0000: \***    ADXSERVE
1479: 0000: \***    IBM routine to request Application Services.
1480: 0000: \***
1481: 0000: \**********************************************************************
1482: 0000: 
1483: 0000: SUB ADXSERVE (RET, FUNC, PARM1, PARM2$) EXTERNAL
1484: 0000: 
1485: 0000:     INTEGER*4  RET
1486: 0000:     INTEGER*2  FUNC,PARM1
1487: 0000:     STRING     PARM2$
1488: 0000: 
1489: 0000: END SUB
1490: 0000: 
1491: 0000: \**********************************************************************
1492: 0000: \***
1493: 0000: \***    ADXCOPYF
1494: 0000: \***    IBM routine to request Application Services.
1495: 0000: \***
1496: 0000: \**********************************************************************
1497: 0000: 
1498: 0000: SUB ADXCOPYF (RETC,INFILE,OUTFILE,OPT0,OPT1) EXTERNAL
1499: 0000: 
1500: 0000:     INTEGER*4 RETC
1501: 0000:     STRING    INFILE,OUTFILE
1502: 0000:     INTEGER*2 OPT0,OPT1
1503: 0000: 
1504: 0000: END SUB 
1505: 0000: 
1506: 0000: \***********************************************************************
1507: 0000: \*                                                                     *
1508: 0000: \*          S T A R T   O F   M A I N L I N E   C O D E                *
1509: 0000: \*                                                                     *
1510: 0000: \***********************************************************************
1511: 0000: \***********************************************************************
1512: 0000: 
1513: 0000: ON ERROR GOTO ERROR.DETECTED
1514: 002f: 
1515: 002f:     PRINT  TIME.STAMP$(2)  + "-Program started"         
1516: 005d: 
1517: 005d:     GOSUB INITIALISATION
1518: 006f: 
1519: 006f:     PRINT #PHKEEP.SESS.NUM% ; TIME.STAMP$(2)  + "-Program started" 
1520: 00ac:     GOSUB MAIN.PROCESSING
1521: 00be:     GOSUB TERMINATION
1522: 00d0:  
1523: 00d0: STOP.PROGRAM:
1524: 00d8:     STOP
1525: 00e5: 
1526: 00e5: \***********************************************************************
1527: 00e5: \*
1528: 00e5: \*    INITIALISATION : This Sub-routine does all the initial processing
1529: 00e5: \*                     before starting the main process
1530: 00e5: \*
1531: 00e5: \***********************************************************************
1532: 00e5: INITIALISATION:
1533: 00f5: 
1534: 00f5:     GOSUB INITIAL.CHECKS          
1535: 0107:     GOSUB INITIALISE.VARIABLES    
1536: 0119:     GOSUB ALLOCATE.SESSION.NUMBERS
1537: 012b:     GOSUB OPEN.FILES              
1538: 013d:     GOSUB CREATE.FILES            
1539: 014f: 
1540: 014f: RETURN
1541: 015f: 
1542: 015f: \***********************************************************************
1543: 015f: \*
1544: 015f: \*    INITIALISE.VARIABLES :   
1545: 015f: \*                
1546: 015f: \*
1547: 015f: \***********************************************************************
1548: 015f: INITIALISE.VARIABLES:
1549: 016f: 
1550: 016f:    CALL SRMAP.SET                                                       !ARG
1551: 018a:    CALL SRPOG.SET
1552: 01a5:    CALL SRMOD.SET
1553: 01c0:    CALL SRMAP.SET
1554: 01db:    CALL SRPDF.SET
1555: 01f6:    CALL SRSXF.SET
1556: 0211:    
1557: 0211:    ERROR.CNT% = 0
1558: 0226:    
1559: 0226:    !ARR.COUNT% = 10000                                                  !BRG
1560: 0226:     ARR.COUNT% = 16000                                                  !BRG
1561: 023b:    
1562: 023b:    DIM SRMAP.ARRAY$(ARR.COUNT%)                                         !ARG
1563: 026a:    
1564: 026a:    DIM SRPOG.ARRAY$(ARR.COUNT%) 
1565: 0299:     
1566: 0299:    DIM SRMOD.ARR$(ARR.COUNT%)      
1567: 02c8: 
1568: 02c8:    DIM SRPDF.ARRAY$(ARR.COUNT%)  
1569: 02f7:    
1570: 02f7:    DIM TEMP.ARR%(ARR.COUNT%)
1571: 0326:    
1572: 0326:      
1573: 0326:    FOUND% = 0
1574: 033b:    
1575: 033b:    PHKEEP.LOG.NAME$ = "ADXLXACN::C:/PHKEEP.LOG"
1576: 0350:    PHKEEP.SESS.NUM% = 456
1577: 0365:    
1578: 0365:    PHKEEP.OK.NAME$  = "ADXLXACN::C:/PHKEEP.ERR"
1579: 037a:    PHKEEP.OK.SESS%  = 457   
1580: 038f:    
1581: 038f:    SRPOG.DIR.NAME$  = "ADXLXACN::C:\SRPOG.DIR"
1582: 03a4:    SRPOG.KEY.NAME$  = "ADXLXACN::C:\SRPOG.KEY"
1583: 03b9:    SRMOD.DIR.NAME$  = "ADXLXACN::C:\SRMOD.DIR"
1584: 03ce:    SRMOD.KEY.NAME$  = "ADXLXACN::C:\SRMOD.KEY"
1585: 03e3:    SRPDF.DIR.NAME$  = "ADXLXACN::C:\SRPDF.DIR"
1586: 03f8:    SRPDF.KEY.NAME$  = "ADXLXACN::C:\SRPDF.KEY"
1587: 040d:    SRSXF.DIR.NAME$  = "ADXLXACN::C:\SRSXF.DIR"
1588: 0422:    SRSXF.KEY.NAME$  = "ADXLXACN::C:\SRSXF.KEY"
1589: 0437:    
1590: 0437:    SPACE$ = " "   
1591: 044c:    
1592: 044c:    CREATE PHKEEP.LOG.NAME$ AS PHKEEP.SESS.NUM%   
1593: 0471:    
1594: 0471:    CREATE PHKEEP.OK.NAME$ AS PHKEEP.OK.SESS%
1595: 0496:     
1596: 0496:    SRMAP.FLAG$ = ""
1597: 04ab:    SRPOG.FLAG$ = ""
1598: 04c0:    SRMOD.FLAG$ = ""
1599: 04d5:    SRSXF.FLAG$ = ""
1600: 04ea:    SRPDF.FLAG$ = ""
1601: 04ff:    
1602: 04ff: RETURN 
1603: 050f: 
1604: 050f: \***********************************************************************
1605: 050f: \*
1606: 050f: \*    ALLOCATE.SESSION.NUMBERS:   
1607: 050f: \*                
1608: 050f: \*
1609: 050f: \***********************************************************************
1610: 050f: ALLOCATE.SESSION.NUMBERS:
1611: 051f: 
1612: 051f:     FUNCTION.FLAG$ = "O"  
1613: 0534: 
1614: 0534:     PASSED.INTEGER% = SRMAP.REPORT.NUM%                                 !ARG
1615: 0551:     PASSED.STRING$  = SRMAP.FILE.NAME$                                  !ARG
1616: 056f:     GOSUB CALL.F20.SESS.NUM.UTILITY                                     !ARG
1617: 0581:     SRMAP.SESS.NUM% = F20.INTEGER.FILE.NO% 	                            !ARG
1618: 0597:     
1619: 0597:     PASSED.INTEGER% = SRPOG.REPORT.NUM%                                 
1620: 05b4:     PASSED.STRING$  = SRPOG.FILE.NAME$                                  
1621: 05d2:     GOSUB CALL.F20.SESS.NUM.UTILITY                                     
1622: 05e4:     SRPOG.SESS.NUM% = F20.INTEGER.FILE.NO%                              
1623: 05fa: 
1624: 05fa:     PASSED.INTEGER% = SRMOD.REPORT.NUM%                                 
1625: 0617:     PASSED.STRING$  = SRMOD.FILE.NAME$                                  
1626: 0635:     GOSUB CALL.F20.SESS.NUM.UTILITY                                     
1627: 0647:     SRMOD.SESS.NUM% = F20.INTEGER.FILE.NO%   
1628: 065d: 
1629: 065d:     PASSED.INTEGER% = SRSXF.REPORT.NUM%                                 
1630: 067a:     PASSED.STRING$  = SRSXF.FILE.NAME$                                  
1631: 0698:     GOSUB CALL.F20.SESS.NUM.UTILITY                                     
1632: 06aa:     SRSXF.SESS.NUM% = F20.INTEGER.FILE.NO%                              
1633: 06c0: 
1634: 06c0:     PASSED.INTEGER% = SRPDF.REPORT.NUM%                                 
1635: 06dd:     PASSED.STRING$  = SRPDF.FILE.NAME$                                  
1636: 06fb:     GOSUB CALL.F20.SESS.NUM.UTILITY                                     
1637: 070d:     SRPDF.SESS.NUM% = F20.INTEGER.FILE.NO%                              
1638: 0723: 
1639: 0723:     PASSED.INTEGER% = PHKEEP.SESS.NUM%                                  
1640: 073a:     PASSED.STRING$  = PHKEEP.LOG.NAME$                                  
1641: 0755:     GOSUB CALL.F20.SESS.NUM.UTILITY                                     
1642: 0767:     PHKEEP.SESS.NUM% = F20.INTEGER.FILE.NO%                             
1643: 0782: 
1644: 0782:     PASSED.INTEGER% = PHKEEP.OK.SESS%                                   
1645: 0799:     PASSED.STRING$  = PHKEEP.OK.NAME$                                   
1646: 07b4:     GOSUB CALL.F20.SESS.NUM.UTILITY                                     
1647: 07c6:     PHKEEP.OK.SESS% = F20.INTEGER.FILE.NO% 
1648: 07e1: 
1649: 07e1:     PASSED.INTEGER% = 457                                               
1650: 07f8:     PASSED.STRING$  = SRPOG.DIR.NAME$                                   
1651: 0813:     GOSUB CALL.F20.SESS.NUM.UTILITY                                     
1652: 0825:     SRPOG.DIR.SESS% = F20.INTEGER.FILE.NO% 	
1653: 0840: 
1654: 0840:     PASSED.INTEGER% = 458                                               
1655: 0857:     PASSED.STRING$  = SRMOD.DIR.NAME$                                   
1656: 0872:     GOSUB CALL.F20.SESS.NUM.UTILITY                                     
1657: 0884:     SRMOD.DIR.SESS% = F20.INTEGER.FILE.NO%                              
1658: 089f: 
1659: 089f:     PASSED.INTEGER% = 459                                               
1660: 08b6:     PASSED.STRING$  = SRPDF.DIR.NAME$                                   
1661: 08d1:     GOSUB CALL.F20.SESS.NUM.UTILITY                                     
1662: 08e3:     SRPDF.DIR.SESS% = F20.INTEGER.FILE.NO%                              
1663: 08fe: 
1664: 08fe:     PASSED.INTEGER% = 460                                               
1665: 0915:     PASSED.STRING$  = SRSXF.DIR.NAME$                                   
1666: 0930:     GOSUB CALL.F20.SESS.NUM.UTILITY                                     
1667: 0942:     SRSXF.DIR.SESS% = F20.INTEGER.FILE.NO%                              
1668: 095d: 
1669: 095d: RETURN
1670: 096d: 
1671: 096d: \***********************************************************************
1672: 096d: \*
1673: 096d: \*    CALL.F20.SESS.NUM.UTILITY:  
1674: 096d: \*                
1675: 096d: \*
1676: 096d: \***********************************************************************
1677: 096d: CALL.F20.SESS.NUM.UTILITY: 
1678: 097d:         
1679: 097d:    FILE.OPERATION$ = FUNCTION.FLAG$
1680: 0998:    CURRENT.REPORT.NUM% = PASSED.INTEGER%
1681: 09b1:    RC% = SESS.NUM.UTILITY (FUNCTION.FLAG$, PASSED.INTEGER%,       \
1682: 09ee:                                  PASSED.STRING$)
1683: 09ee:    IF RC% <> 0 THEN GOTO ERROR.DETECTED
1684: 0a10: 
1685: 0a10: RETURN
1686: 0a20: 
1687: 0a20: \***********************************************************************
1688: 0a20: \*
1689: 0a20: \*    CREATE.FILES:  
1690: 0a20: \*             
1691: 0a20: \***********************************************************************
1692: 0a20: CREATE.FILES:
1693: 0a30: 
1694: 0a30:    PRINT  TIME.STAMP$(2)  + "-Creating Direct And Log Files" 
1695: 0a5e:     
1696: 0a5e:    
1697: 0a5e:    CREATE POSFILE SRMOD.DIR.NAME$ AS SRMOD.DIR.SESS% BUFFSIZE 32256 
1698: 0a83: 
1699: 0a83:    CREATE POSFILE SRPDF.DIR.NAME$ AS SRPDF.DIR.SESS% BUFFSIZE 32256 
1700: 0aa8: 
1701: 0aa8:    CREATE POSFILE SRSXF.DIR.NAME$ AS SRSXF.DIR.SESS% BUFFSIZE 32256 
1702: 0acd: 
1703: 0acd: RETURN
1704: 0add: 
1705: 0add: \***********************************************************************
1706: 0add: \*
1707: 0add: \*    OPEN.FILES:  
1708: 0add: \*              
1709: 0add: \*
1710: 0add: \***********************************************************************
1711: 0add: OPEN.FILES:
1712: 0aed: 
1713: 0aed:    IF END #PHKEEP.SESS.NUM% THEN PHKEEP.END
1714: 0b0a:    OPEN PHKEEP.LOG.NAME$ AS PHKEEP.SESS.NUM% APPEND    
1715: 0b2f: 
1716: 0b2f: RETURN
1717: 0b3f: 
1718: 0b3f: PHKEEP.END:
1719: 0b4f:     
1720: 0b4f:    PRINT  TIME.STAMP$(2)  + "- No PHKEEP Log File"  
1721: 0b7d: STOP 
1722: 0b8a:  
1723: 0b8a: \***********************************************************************
1724: 0b8a: \*
1725: 0b8a: \*    MAIN.PROCESSING
1726: 0b8a: \*
1727: 0b8a: \***********************************************************************
1728: 0b8a: MAIN.PROCESSING:   
1729: 0b9a: 
1730: 0b9a: 
1731: 0b9a:    GOSUB STOP.BACKGROUNDS
1732: 0bac:    GOSUB SEQUENTIAL.READ.SRPOG
1733: 0bbe:    GOSUB HOUSEKEEP.SRPOG
1734: 0bd0: 
1735: 0bd0:    GOSUB SEQUENTIAL.READ.SRMOD
1736: 0be2:   
1737: 0be2:    GOSUB SEQUENTIAL.READ.SRSXF
1738: 0bf4:   
1739: 0bf4:    GOSUB SEQUENTIAL.READ.SRPDF 
1740: 0c06:   
1741: 0c06:    GOSUB COMPARE.SRMOD
1742: 0c18:    GOSUB COMPARE.SRPDF    
1743: 0c2a:    GOSUB CREATE.SRMOD.KEY
1744: 0c3c:    GOSUB CREATE.SRSXF.KEY
1745: 0c4e:    GOSUB CREATE.SRPDF.KEY
1746: 0c60:   
1747: 0c60:    
1748: 0c60:    GOSUB BACKUP.ORIGINAL 
1749: 0c72:    GOSUB DELETE.EXISTING 
1750: 0c84:    GOSUB COPY.NEW        
1751: 0c96:    GOSUB START.BACKGROUNDS   
1752: 0ca8: 
1753: 0ca8: RETURN
1754: 0cb8: 
1755: 0cb8: \***********************************************************************
1756: 0cb8: \*
1757: 0cb8: \*    INITIAL.CHECKS:  
1758: 0cb8: \*               
1759: 0cb8: \*
1760: 0cb8: \***********************************************************************
1761: 0cb8: INITIAL.CHECKS:
1762: 0cc8: 
1763: 0cc8:    PRINT  TIME.STAMP$(2)  + "-Checking the existence of Files"    
1764: 0cf6:    
1765: 0cf6:    CALL OSSHELL ("IF EXIST C:/SRPOG.DIR DEL C:/SRPOG.DIR")
1766: 0d0a:    CALL OSSHELL ("IF EXIST C:/SRMOD.DIR DEL C:/SRMOD.DIR")
1767: 0d1e:    CALL OSSHELL ("IF EXIST C:/SRSXF.DIR DEL C:/SRSXF.DIR")
1768: 0d32:    CALL OSSHELL ("IF EXIST C:/SRPDF.DIR DEL C:/SRPDF.DIR")
1769: 0d46:    CALL OSSHELL ("IF EXIST C:/SRPOG.KEY DEL C:/SRPOG.KEY")
1770: 0d5a:    CALL OSSHELL ("IF EXIST C:/SRMOD.KEY DEL C:/SRMOD.KEY")
1771: 0d6e:    CALL OSSHELL ("IF EXIST C:/SRSXF.KEY DEL C:/SRSXF.KEY")
1772: 0d82:    CALL OSSHELL ("IF EXIST C:/SRPDF.KEY DEL C:/SRPDF.KEY")
1773: 0d96:    CALL OSSHELL ("IF EXIST C:/PHKEEP.OK DEL C:/PHKEEP.OK")
1774: 0daa:    CALL OSSHELL ("IF EXIST C:/PHKEEP.ERR DEL C:/PHKEEP.ERR")
1775: 0dbe:    CALL OSSHELL ("IF EXIST C:/PHKEEP.LOG DEL C:/PHKEEP.LOG")
1776: 0dd2:    
1777: 0dd2:    PRINT  TIME.STAMP$(2)  + "-Checking the existence of D: drive SR files"
1778: 0e00:       
1779: 0e00:    CALL OSSHELL ("IF EXIST D:/SRPOG.DAT DEL D:/SRPOG.DAT")
1780: 0e14:    CALL OSSHELL ("IF EXIST D:/SRMOD.DAT DEL D:/SRMOD.DAT")
1781: 0e28:    CALL OSSHELL ("IF EXIST D:/SRSXF.DAT DEL D:/SRSXF.DAT")
1782: 0e3c:    CALL OSSHELL ("IF EXIST D:/SRPDF.DAT DEL D:/SRPDF.DAT")
1783: 0e50:     
1784: 0e50:   RETURN       
1785: 0e60: 
1786: 0e60: \***********************************************************************
1787: 0e60: \*
1788: 0e60: \*   SEQUENTIAL.READ.SRPOG 
1789: 0e60: \*               
1790: 0e60: \*
1791: 0e60: \***********************************************************************
1792: 0e60: SEQUENTIAL.READ.SRPOG:
1793: 0e70: 
1794: 0e70:    PRINT  TIME.STAMP$(2)  + "-Sequential Reading SRPOG"
1795: 0e9e:    PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)  + "-Sequential Reading SRPOG"
1796: 0edb:    
1797: 0edb:    FILE.OPERATION$ = "O"     
1798: 0ef2:    OPEN SRPOG.FILE.NAME$ DIRECT RECL 512 AS SRPOG.SESS.NUM% NOWRITE NODEL     
1799: 0f1b:    OPEN SRMAP.FILE.NAME$ KEYED RECL SRMAP.RECL% AS SRMAP.SESS.NUM%      !ARG  
1800: 0f47:    
1801: 0f47:    
1802: 0f47:    EOF%   = 0
1803: 0f5c:    I%     = 0
1804: 0f71:    J%     = 1
1805: 0f86:    SRPOG% = 0
1806: 0f9b:    P%     = 0
1807: 0fb0:    ! RPS indicates record per sector, as it is block read, will filtering
1808: 0fb0:    ! the number of records per each sector. same is obtained using the 
1809: 0fb0:    ! record size against total block size.
1810: 0fb0: 
1811: 0fb0:    RPS%   = 4                   
1812: 0fc5: 
1813: 0fc5:    SRPOG.FLAG$ = "S" 
1814: 0fda:    SRPOG.COUNT% = 0   
1815: 0fef:    
1816: 0fef:      WHILE NOT EOF%
1817: 0ffa:    
1818: 0ffa:          I% = I% +1 
1819: 1013:          IF END #SRPOG.SESS.NUM% THEN SRPOG.END 
1820: 102f:          READ FORM "T5,C508"; #SRPOG.SESS.NUM%,I%; SEC$      
1821: 1064: 
1822: 1064:          FOR J% = 1 TO RPS%
1823: 107c: 
1824: 107c:              SRPOG.STRING$ = MID$(SEC$, ((J%-1)* SRPOG.RECL%) +1,      \
1825: 10cb:              SRPOG.RECL%)
1826: 10cb: 
1827: 10cb:              IF GETN4(SRPOG.STRING$,0) <> 0 THEN BEGIN
1828: 10f6: 
1829: 10f6:                  SRPOG% = SRPOG% + 1
1830: 110f:                  SRPOG.POGDB% = GETN4(SRPOG.STRING$,0)
1831: 1138:                  SRMAP.POGDB% = SRPOG.POGDB%                            !ARG
1832: 1151:                  SRMAP.CHAIN.SEQ% = 0                                   !ARG
1833: 1161: 
1834: 1161:              ! Check if there is a proper match in SRMAP file as its    !ARG
1835: 1161:              ! been proved that, everday SRMAP file is read to create   !ARG
1836: 1161:              ! SRITEMP/SRITEML files so if any POGDB is missing from    !ARG
1837: 1161:              ! SRMAP, the planer wont be visible from next day after    !ARG
1838: 1161:              ! POGOK run. So any POGDB not present in SRMAP ignore it   !ARG
1839: 1161:              ! while writing to SRPOG.DIR file.
1840: 1161: 
1841: 1161:                  RC% = READ.SRMAP                                       !ARG
1842: 117c: 
1843: 117c:                  IF RC% = 0 THEN BEGIN                                  !ARG
1844: 119b:                      SRPOG.COUNT% = SRPOG.COUNT% + 1                    !ARG
1845: 11b4:                      SRPOG.ARRAY$(SRPOG.COUNT%) = SRPOG.STRING$         !ARG
1846: 11e0:                  ENDIF ELSE BEGIN 
1847: 11e8:                       P% = P% + 1
1848: 1201:                       TEMP.ARR%(P%) = SRPOG.POGDB%
1849: 1229:                  ENDIF     
1850: 1233:                  
1851: 1233:              ENDIF ELSE BEGIN
1852: 123b: 
1853: 123b:                  J% = RPS%
1854: 1250:              ENDIF
1855: 1258: 
1856: 1258:          NEXT J%
1857: 1285: 
1858: 1285:      WEND
1859: 129b: 
1860: 129b: SRPOG.END: 
1861: 12ab:     
1862: 12ab:    
1863: 12ab:    EOF% = -1
1864: 12c0:    CLOSE SRPOG.SESS.NUM%
1865: 12d4: 
1866: 12d4: RETURN
1867: 12e4: 
1868: 12e4: \***********************************************************************
1869: 12e4: \*
1870: 12e4: \*   HOUSEKEEP.SRPOG
1871: 12e4: \*               
1872: 12e4: \*
1873: 12e4: \***********************************************************************
1874: 12e4: HOUSEKEEP.SRPOG:
1875: 12f4: 
1876: 12f4:    PRINT  TIME.STAMP$(2)  + "-Housekeeping SRPOG by checking the existence of planner in SRMAP"
1877: 1322:    PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)  + "-Housekeeping SRPOG by checking against SRMAP"
1878: 135f:    
1879: 135f:    FILE.OPERATION$ = "O"  
1880: 1376:    OPEN SRPOG.FILE.NAME$ KEYED RECL SRPOG.RECL% AS SRPOG.SESS.NUM%
1881: 13a2:    I% = 1 
1882: 13b7: 
1883: 13b7:     
1884: 13b7:    FOR I% = 1 TO P%
1885: 13cf:    
1886: 13cf:    
1887: 13cf:     SRPOG.POGDB% = TEMP.ARR%(I%)
1888: 13f7:     RC% = READ.SRPOG
1889: 1412:     IF RC% = 0 THEN BEGIN
1890: 1431:         RC% = DELREC.SRPOG
1891: 144c:     ENDIF
1892: 1454: 
1893: 1454:    NEXT I%
1894: 1481:    
1895: 1481:    CLOSE SRPOG.SESS.NUM%
1896: 1495:  RETURN
1897: 14a5: 
1898: 14a5: \***********************************************************************
1899: 14a5: \*
1900: 14a5: \*    SEQUENTIAL.READ.SRMOD
1901: 14a5: \*                
1902: 14a5: \*
1903: 14a5: \***********************************************************************
1904: 14a5: SEQUENTIAL.READ.SRMOD:                                                  
1905: 14b5: 
1906: 14b5:    PRINT  TIME.STAMP$(2)  + "-Sequential Reading SRMOD"               
1907: 14e3:    PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)  +                         \
1908: 1520:    "-Sequential Reading SRMOD"             
1909: 1520:   
1910: 1520: 
1911: 1520:    FILE.OPERATION$ = "O"  
1912: 1537:    OPEN SRMOD.FILE.NAME$ DIRECT RECL 512 AS SRMOD.SESS.NUM% BUFFSIZE    \
1913: 1561:                                                  32767 NOWRITE NODEL  
1914: 1561:     
1915: 1561:    I%          = 0
1916: 1576:    J%          = 1
1917: 158b:    RPS%        = 1                        
1918: 15a0:    EOF%        = 0 
1919: 15b5:    SRMOD%      = 0
1920: 15ca:    SRMOD.FLAG$ = "S"
1921: 15df:    
1922: 15df:    WHILE NOT EOF%
1923: 15ea:    
1924: 15ea:       I% = I% +1
1925: 1603:       IF END #SRMOD.SESS.NUM% THEN SRMOD.END
1926: 161f:       READ FORM "T5,C508"; #SRMOD.SESS.NUM%,I%; SEC$
1927: 1654:                                                                         
1928: 1654:       FOR J% = 1 TO RPS%                                                
1929: 166c:          SRMOD.STRING$ = SEC$                                           
1930: 1685:          SRMOD.STRING$ = MID$(SEC$, 1,508)                              
1931: 16a8:          IF GETN4(SRMOD.STRING$,0) <> 0 THEN BEGIN                      
1932: 16d0:             SRMOD% = SRMOD% + 1                                         
1933: 16e9:             SRMOD.ARR$(SRMOD%) = SRMOD.STRING$                          
1934: 1715:                                                                         
1935: 1715:          ENDIF ELSE BEGIN
1936: 171d: 
1937: 171d:              J% = RPS%
1938: 1732: 
1939: 1732:          ENDIF
1940: 173a: 
1941: 173a:       NEXT J%
1942: 1767:    WEND
1943: 177d: 
1944: 177d: SRMOD.END:    
1945: 178d:   
1946: 178d:    EOF% = -1
1947: 17a2:    CLOSE SRMOD.SESS.NUM%
1948: 17b6: 
1949: 17b6: RETURN
1950: 17c6: 
1951: 17c6: \***********************************************************************
1952: 17c6: \*
1953: 17c6: \*    SEQUENTIAL.READ.SRSXF 
1954: 17c6: \*                
1955: 17c6: \*
1956: 17c6: \***********************************************************************
1957: 17c6: SEQUENTIAL.READ.SRSXF:   
1958: 17d6: 
1959: 17d6:    PRINT  TIME.STAMP$(2)  +                                             \
1960: 1804:    "-Sequential Reading SRSXF and filtering with SRPOG"
1961: 1804:    PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2) +                           \
1962: 1841:                "-Sequential Reading SRSXF and filtering with SRPOG"
1963: 1841: 
1964: 1841:    FILE.OPERATION$ = "O"  
1965: 1858:    OPEN SRSXF.FILE.NAME$ DIRECT RECL 512 AS SRSXF.SESS.NUM% BUFFSIZE    \
1966: 1882:                                                  32767 NOWRITE NODEL 
1967: 1882:     
1968: 1882:    I%          = 0
1969: 1897:    J%          = 1
1970: 18ac:    RPS%        = 8                        
1971: 18c1:    EOF%        = 0 
1972: 18d6:    SRSXF%      = 0
1973: 18eb:    
1974: 18eb:    SRSXF.FLAG$ = "S"
1975: 1900:    
1976: 1900:    WHILE NOT EOF%
1977: 190b:    
1978: 190b:       I% = I% +1
1979: 1924:       IF END #SRSXF.SESS.NUM% THEN SRSXF.END
1980: 1940:       READ FORM "T5,C508"; #SRSXF.SESS.NUM%,I%; SEC$
1981: 1975:       
1982: 1975:       FOR J% = 1 TO RPS%
1983: 198d: 
1984: 198d:          SRSXF.STRING$ = MID$(SEC$, ((J%-1)* SRSXF.RECL%) +1,          \
1985: 19dc:                                              SRSXF.RECL%) 
1986: 19dc:          IF GETN4(SRSXF.STRING$,0) <> 0 THEN BEGIN                       
1987: 1a07: 
1988: 1a07:             SRSXF% = SRSXF% + 1
1989: 1a20: 
1990: 1a20:          ! AS SRSXF file will generally have anything between 10000 to 
1991: 1a20:          ! 90000 records based on the number of planners. It is 
1992: 1a20:          ! impossible to do an array sort so filtering the records
1993: 1a20:          ! and writing it individually to the SRSXF file
1994: 1a20: 
1995: 1a20:             K% = 1
1996: 1a35: 
1997: 1a35:              WHILE K% <= SRPOG%
1998: 1a40: 
1999: 1a40:                  IF STR$(GETN4(SRSXF.STRING$,0)) =                       \
2000: 1aa5:                                 STR$(GETN4(SRPOG.ARRAY$(K%),0)) THEN     \
2001: 1aa5:                                                          BEGIN
2002: 1aa5: 
2003: 1aa5:                      SRSXF.COUNT% = SRSXF.COUNT% + 1
2004: 1abe: 
2005: 1abe:                      GOSUB CREATE.SRSXF.DIR
2006: 1ad0: 
2007: 1ad0:                  ENDIF
2008: 1ad8: 
2009: 1ad8:                      K% = K% + 1
2010: 1af1:              WEND
2011: 1b0f: 
2012: 1b0f:          ENDIF ELSE BEGIN 
2013: 1b17: 
2014: 1b17:              J% = RPS%
2015: 1b2c: 
2016: 1b2c:          ENDIF
2017: 1b34: 
2018: 1b34:       NEXT J%
2019: 1b61: 
2020: 1b61:    WEND
2021: 1b77: 
2022: 1b77: SRSXF.END:      
2023: 1b87:     
2024: 1b87:    EOF% = -1
2025: 1b9c:    CLOSE SRSXF.SESS.NUM%
2026: 1bb0: 
2027: 1bb0: RETURN 
2028: 1bc0: 
2029: 1bc0: \***********************************************************************
2030: 1bc0: \*
2031: 1bc0: \*    SEQUENTIAL.READ.SRPDF 
2032: 1bc0: \*              
2033: 1bc0: \*
2034: 1bc0: \***********************************************************************
2035: 1bc0: SEQUENTIAL.READ.SRPDF:   
2036: 1bd0: 
2037: 1bd0:    PRINT  TIME.STAMP$(2)  + "-Sequential Reading SRPDF"
2038: 1bfe:    PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)  + "-Sequential Reading SRPDF"
2039: 1c3b: 
2040: 1c3b:    FILE.OPERATION$ = "O" 
2041: 1c52:    OPEN SRPDF.FILE.NAME$ DIRECT RECL 512 AS SRPDF.SESS.NUM% NOWRITE NODEL
2042: 1c7b:     
2043: 1c7b:    I%     = 0
2044: 1c90:    J%     = 1
2045: 1ca5:    RPS%   = 3                        
2046: 1cba:    EOF%   = 0 
2047: 1ccf:    SRPDF% = 0
2048: 1ce4:    
2049: 1ce4:    SRPDF.FLAG$ = "S"
2050: 1cf9:    
2051: 1cf9:    WHILE NOT EOF%
2052: 1d04:    
2053: 1d04:       I% = I% +1
2054: 1d1d:       IF END #SRPDF.SESS.NUM% THEN SRPDF.END
2055: 1d39:       READ FORM "T5,C508"; #SRPDF.SESS.NUM%,I%; SEC$
2056: 1d6e:       
2057: 1d6e:       FOR J% = 1 TO RPS%
2058: 1d86: 
2059: 1d86:          SRPDF.STRING$ = SEC$
2060: 1d9f:          SRPDF.STRING$ = MID$(SEC$, ((J%-1)* SRPDF.RECL%) +1, SRPDF.RECL%)
2061: 1dee: 
2062: 1dee:          IF GETN4(SRPDF.STRING$,0) <> 0 THEN BEGIN 
2063: 1e16: 
2064: 1e16:             SRPDF% = SRPDF% + 1
2065: 1e2f:             SRPDF.ARRAY$(SRPDF%) = SRPDF.STRING$
2066: 1e5b: 
2067: 1e5b:          ENDIF  ELSE J% = RPS%
2068: 1e70: 
2069: 1e70:       NEXT J%
2070: 1e9d: 
2071: 1e9d:    WEND
2072: 1eb3: 
2073: 1eb3: SRPDF.END:     
2074: 1ec3: 
2075: 1ec3:    EOF% = -1
2076: 1ed8:    CLOSE SRPDF.SESS.NUM%
2077: 1eec: 
2078: 1eec: RETURN 
2079: 1efc: 
2080: 1efc: \***********************************************************************
2081: 1efc: \*
2082: 1efc: \*    WRITE.PHKEEP.OK  
2083: 1efc: \*                
2084: 1efc: \*
2085: 1efc: \***********************************************************************
2086: 1efc: WRITE.PHKEEP.OK:
2087: 1f0c:     
2088: 1f0c:    OPEN PHKEEP.OK.NAME$ AS PHKEEP.OK.SESS% APPEND
2089: 1f31: 
2090: 1f31:    OK.STRING$ = SRPOG.FLAG$ + SRMOD.FLAG$ + SRSXF.FLAG$ + SRSXF.FLAG$
2091: 1f65: 
2092: 1f65:    WRITE #PHKEEP.OK.SESS% ; OK.STRING$
2093: 1f89:    
2094: 1f89:    CLOSE PHKEEP.OK.SESS%
2095: 1f9e: 
2096: 1f9e: RETURN
2097: 1fae: 
2098: 1fae: 
2099: 1fae: \***********************************************************************
2100: 1fae: \*
2101: 1fae: \*    COMPARE.SRMOD   
2102: 1fae: \*                
2103: 1fae: \*
2104: 1fae: \***********************************************************************
2105: 1fae: COMPARE.SRMOD:
2106: 1fbe: 
2107: 1fbe:      PRINT  TIME.STAMP$(2)  + "-Comparing SRMOD records against SRPOG"
2108: 1fec:      PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)  +                       \
2109: 2029:                            "-Comparing SRMOD records against SRPOG"
2110: 2029:     
2111: 2029:      I%           = 1
2112: 203e:      J%           = 1 
2113: 2053:      TEMP.COUNT%  = 0
2114: 2068:      SRMOD.COUNT% = 0      
2115: 207d: 
2116: 207d:      FOR J% = 1 TO SRMOD% 
2117: 2095: 
2118: 2095:          FOUND% = 0        
2119: 20aa:          I% = 1
2120: 20bf:  
2121: 20bf:          WHILE FOUND% = 0 AND I% <= SRPOG.COUNT% 
2122: 20ca: 
2123: 20ca:              IF STR$(GETN4(SRMOD.ARR$(J%),0))                           \
2124: 2141:               = STR$(GETN4(SRPOG.ARRAY$(I%),0)) THEN BEGIN
2125: 2141: 
2126: 2141:                  SRMOD.COUNT% = SRMOD.COUNT% +1
2127: 215a: 
2128: 215a:                  GOSUB CREATE.SRMOD.DIR 
2129: 216c: 
2130: 216c:                  FOUND% = -1
2131: 2181: 
2132: 2181:                  I% = SRPOG%
2133: 2196: 
2134: 2196:              ENDIF
2135: 219e: 
2136: 219e:                  I% = I% + 1
2137: 21b7:          WEND
2138: 21f2: 
2139: 21f2:      NEXT J%     
2140: 221f: 
2141: 221f: RETURN 
2142: 222f: 
2143: 222f: \***********************************************************************
2144: 222f: \*
2145: 222f: \*    COMPARE.SRPDF  
2146: 222f: \*                
2147: 222f: \*
2148: 222f: \***********************************************************************
2149: 222f: COMPARE.SRPDF:    
2150: 223f: 
2151: 223f:    PRINT  TIME.STAMP$(2)  + "-Comparing SRPDF records against SRPOG"
2152: 226d:    PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)                             \
2153: 22aa:                         + "-Comparing SRPDF records against SRPOG"
2154: 22aa: 
2155: 22aa:    I% = 1
2156: 22bf:    J% = 1    
2157: 22d4:    SRPDF.COUNT% = 0
2158: 22e9: 
2159: 22e9:    FOR J% = 1 TO SRPDF%        
2160: 2301: 
2161: 2301:         FOUND% = 0        
2162: 2316:         I% = 1
2163: 232b: 
2164: 232b:         WHILE FOUND% = 0 AND I% <= SRPOG.COUNT%
2165: 2336: 
2166: 2336:             IF STR$(GETN4(SRPDF.ARRAY$(J%),0))                          \
2167: 23ad:             = STR$(GETN4(SRPOG.ARRAY$(I%),0)) THEN BEGIN
2168: 23ad: 
2169: 23ad:                 SRPDF.COUNT%  =  SRPDF.COUNT% + 1
2170: 23c6: 
2171: 23c6:                 GOSUB CREATE.SRPDF.DIR
2172: 23d8:                 FOUND% = -1 
2173: 23ed: 
2174: 23ed:                 I% = SRPOG%
2175: 2402: 
2176: 2402:             ENDIF    
2177: 240a: 
2178: 240a:                 I% = I% + 1
2179: 2423:         WEND
2180: 245e: 
2181: 245e:    NEXT J%  
2182: 248b: 
2183: 248b: RETURN
2184: 249b:  
2185: 249b: 
2186: 249b: \***********************************************************************
2187: 249b: \*
2188: 249b: \*    CREATE.SRMOD.DIR  
2189: 249b: \*                
2190: 249b: \*
2191: 249b: \***********************************************************************
2192: 249b: CREATE.SRMOD.DIR: 
2193: 24ab: 
2194: 24ab:    WRITE FORM "C508" ;#SRMOD.DIR.SESS% ; SRMOD.ARR$(J%)  
2195: 24e5:    
2196: 24e5: RETURN
2197: 24f5: 
2198: 24f5: \***********************************************************************
2199: 24f5: \*
2200: 24f5: \*    CREATE.SRSXF.DIR
2201: 24f5: \*                
2202: 24f5: \*
2203: 24f5: \***********************************************************************
2204: 24f5: CREATE.SRSXF.DIR:
2205: 2505: 
2206: 2505:     WRITE FORM "C63" ;#SRSXF.DIR.SESS% ; SRSXF.STRING$	
2207: 252d: 
2208: 252d: RETURN  
2209: 253d: 
2210: 253d: \***********************************************************************
2211: 253d: \*
2212: 253d: \*    CREATE.SRPDF.DIR  
2213: 253d: \*               
2214: 253d: \*
2215: 253d: \***********************************************************************
2216: 253d: CREATE.SRPDF.DIR:  
2217: 254d: 
2218: 254d:     WRITE FORM "C169" ;#SRPDF.DIR.SESS% ; SRPDF.ARRAY$(J%)   
2219: 2587: 
2220: 2587: RETURN
2221: 2597: 
2222: 2597: \***********************************************************************
2223: 2597: \*
2224: 2597: \*    REKEY.SRPOG  
2225: 2597: \*               
2226: 2597: \*
2227: 2597: \***********************************************************************
2228: 2597:   
2229: 2597:   REKEY.SRPOG:   
2230: 25a7:       
2231: 25a7:     
2232: 25a7:     SRPOG.TEMP.NAME$ = "ADXLXACN::D:\ADX_UDT3\SRPOG.TST"
2233: 25bc: 
2234: 25bc:     PROG.NAME$ = "C:\ADX_SPGM\COMMAND.286"
2235: 25d1:     COMM.TAIL$ = "-C TURBO.286 REKEY"     + " "                         \
2236: 2668:                    +  SRPOG.FILE.NAME$    + " "                         \
2237: 2668:                    +  SRPOG.TEMP.NAME$    + " "                         \
2238: 2668:                    + "-R:" + STR$(6000)   + " "                         \
2239: 2668:                    +  SPACE$ +                                          \
2240: 2668:                    + "-O"  +  " "         + " "                         \
2241: 2668:                    + "-Z"  +  " "         + " "                         \
2242: 2668:                    + "-D:" + STR$(3)      + " "                         !
2243: 2668: 
2244: 2668:     SVC.PARAM$   = STRING$(28,"0")
2245: 2686:     GOSUB EXECUTE.SVC
2246: 2698: 
2247: 2698:     SRPOG.FLAG$ = "E"
2248: 26ad: 
2249: 26ad: RETURN
2250: 26bd: 
2251: 26bd: 
2252: 26bd: RETURN
2253: 26cd: 
2254: 26cd: \***********************************************************************
2255: 26cd: \*
2256: 26cd: \*    CREATE.SRMOD.KEY  
2257: 26cd: \*               
2258: 26cd: \*
2259: 26cd: \***********************************************************************
2260: 26cd: CREATE.SRMOD.KEY:
2261: 26dd: 
2262: 26dd:      PRINT  TIME.STAMP$(2)  + "-Creating SRMOD Key file from direct file"
2263: 270b:      PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)                            \
2264: 2748:                      + "-Creating SRMOD Key file from direct file"   
2265: 2748:      
2266: 2748:      CLOSE SRMOD.DIR.SESS%
2267: 275d: 
2268: 275d:      PROG.NAME$ = "C:\ADX_SPGM\COMMAND.286"
2269: 2772:      COMM.TAIL$ = "-C TURBO.286 KEYUP"     + " "                         \
2270: 2832:                    +  SRMOD.DIR.NAME$     + " "                         \
2271: 2832:                    +  SRMOD.KEY.NAME$     + " "                         \
2272: 2832:                    + "-k:" + STR$(6)      + " "                         \
2273: 2832:                    + "-l:" + STR$(508)    + " "                         \
2274: 2832:                    + "-r:" + STR$(8000)   + " "                         \
2275: 2832:                    + "-o"  +  " "         + " "                         \
2276: 2832:                    + "-d:" + STR$(3)      + " "                         !
2277: 2832: 
2278: 2832:      SVC.PARAM$   = STRING$(28,"0")
2279: 2850:      GOSUB EXECUTE.SVC
2280: 2862: 
2281: 2862: 
2282: 2862: RETURN
2283: 2872: \***********************************************************************
2284: 2872: \*                
2285: 2872: \*    CREATE.SRSXF.KEY  
2286: 2872: \*                
2287: 2872: \*
2288: 2872: \***********************************************************************
2289: 2872: CREATE.SRSXF.KEY:
2290: 2882: 
2291: 2882:      PRINT  TIME.STAMP$(2)  + "-Creating SRSXF Key file from direct file"
2292: 28b0:      PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)                           \
2293: 28ed:                   + "-Creating SRSXF Key file from direct file" 
2294: 28ed: 
2295: 28ed:      CLOSE SRSXF.DIR.SESS%
2296: 2902: 
2297: 2902:      PROG.NAME$ = "C:\ADX_SPGM\COMMAND.286"
2298: 2917:      COMM.TAIL$ = "-C TURBO.286 KEYUP"     + " "                        \
2299: 29d7:                    +  SRSXF.DIR.NAME$     + " "                         \
2300: 29d7:                    +  SRSXF.KEY.NAME$     + " "                         \
2301: 29d7:                    + "-k:" + STR$(6)      + " "                         \
2302: 29d7:                    + "-l:" + STR$(63)     + " "                         \
2303: 29d7:                    + "-r:" + STR$(60000)  + " "                         \
2304: 29d7:                    + "-o"  +  " "         + " "                         \
2305: 29d7:                    + "-d:" + STR$(3)      + " "                         !
2306: 29d7: 
2307: 29d7:      SVC.PARAM$   = STRING$(28,"0")
2308: 29f5:      GOSUB EXECUTE.SVC
2309: 2a07: 
2310: 2a07: RETURN
2311: 2a17: 
2312: 2a17: \***********************************************************************
2313: 2a17: \*
2314: 2a17: \*    CREATE.SRPDF.KEY 
2315: 2a17: \*               
2316: 2a17: \*
2317: 2a17: \***********************************************************************
2318: 2a17: CREATE.SRPDF.KEY:
2319: 2a27: 
2320: 2a27:      PRINT  TIME.STAMP$(2)  + "-Creating SRPDF Key file from direct file"
2321: 2a55:      PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)                           \
2322: 2a92:                + "-Creating SRPDF Key file from direct file"
2323: 2a92:      
2324: 2a92:      CLOSE SRPDF.DIR.SESS%
2325: 2aa7: 
2326: 2aa7:      PROG.NAME$ = "C:\ADX_SPGM\COMMAND.286"
2327: 2abc:      COMM.TAIL$ = "-C TURBO.286 KEYUP"     + " "                        \
2328: 2b7c:                    +  SRPDF.DIR.NAME$    + " "                          \
2329: 2b7c:                    +  SRPDF.KEY.NAME$    + " "                          \
2330: 2b7c:                    + "-k:" + STR$(4)     + " "                          \
2331: 2b7c:                    + "-l:" + STR$(169)   + " "                          \
2332: 2b7c:                    + "-r:" + STR$(6000)  + " "                          \
2333: 2b7c:                    + "-o"  +  " "        + " "                          \
2334: 2b7c:                    + "-d:" + STR$(3)     + " "                          !
2335: 2b7c: 
2336: 2b7c:      SVC.PARAM$   = STRING$(28,"0")
2337: 2b9a:      GOSUB EXECUTE.SVC
2338: 2bac:     
2339: 2bac: RETURN
2340: 2bbc: 
2341: 2bbc: \*****************************************************************************
2342: 2bbc: \***    SUBROUTINE : EXECUTE.SVC                                             *
2343: 2bbc: \***    DETAILS    : EXECUTES APPLICATION ASYNC                              *
2344: 2bbc: \*****************************************************************************
2345: 2bbc: 
2346: 2bbc: EXECUTE.SVC:
2347: 2bcc: 
2348: 2bcc:      PINFO.TABLE$  = "DURATION  " + CHR$(200) + STRING$(9,CHR$(00))
2349: 2c07:      PROG.NAME$   = PROG.NAME$ + CHR$(00)
2350: 2c2a:      COMM.TAIL$   = COMM.TAIL$ + CHR$(00)
2351: 2c4d:      CALL PUTN4(SVC.PARAM$,  0, 00000000H)
2352: 2c72:      CALL PUTN4(SVC.PARAM$,  4, 00000000H)
2353: 2c97:      CALL PUTN4(SVC.PARAM$,  8, SADD(PROG.NAME$) + 2)
2354: 2cc9:      CALL PUTN4(SVC.PARAM$, 12, SADD(COMM.TAIL$) + 2)
2355: 2cfb:      CALL PUTN4(SVC.PARAM$, 16, LEN(COMM.TAIL$) - 1)
2356: 2d2c:      CALL PUTN4(SVC.PARAM$, 20, SADD(PINFO.TABLE$) + 2)
2357: 2d61:      CALL PUTN4(SVC.PARAM$, 24, 00000000H)
2358: 2d86:      CALL FLEXOSSVC(38, SVC.PARAM$)
2359: 2da3: 
2360: 2da3: RETURN
2361: 2db3: \***********************************************************************
2362: 2db3: \*
2363: 2db3: \*    STOP.BACKGROUNDS 
2364: 2db3: \*                
2365: 2db3: \*
2366: 2db3: \***********************************************************************
2367: 2db3: STOP.BACKGROUNDS:
2368: 2dc3:  
2369: 2dc3:      PRINT  TIME.STAMP$(2)  + "-Stopping BGMON Application"
2370: 2df1:      PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)                             \
2371: 2e2e:                                + "-Stopping BGMON Application"   
2372: 2e2e:    
2373: 2e2e:      CALL OSSHELL("C:\ADX_UPGM\BGSTOP" + SPACE$ + "ADX_UPGM:BGMON.286")   
2374: 2e59:    
2375: 2e59:      PRINT  TIME.STAMP$(2)  + "-Stopping TRANSACT Application"
2376: 2e87:      PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)                            \
2377: 2ec4:                        + "-Stopping TRANSACT Application" 
2378: 2ec4:    
2379: 2ec4:      CALL OSSHELL("C:\ADX_UPGM\BGSTOP" + SPACE$ + "ADX_UPGM:TRANSACT.286")  
2380: 2eef:  
2381: 2eef: RETURN
2382: 2eff: 
2383: 2eff: \***********************************************************************
2384: 2eff: \*
2385: 2eff: \*    BACKUP.ORIGINAL
2386: 2eff: \*                
2387: 2eff: \*
2388: 2eff: \***********************************************************************
2389: 2eff: BACKUP.ORIGINAL:
2390: 2f0f: 
2391: 2f0f:    PRINT  TIME.STAMP$(2)  + "-Creating backups"
2392: 2f3d:    PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)  + "-Creating backups"    
2393: 2f7a: 
2394: 2f7a:    CALL ADXCOPYF(RC%,"ADXLXACN::D:\ADX_UDT3\SRPOG.DAT",                 \
2395: 2fd6:                      "ADXLXACN::D:\SRPOG.DAT",0,0)   
2396: 2fd6: 
2397: 2fd6:    IF RC% = 0 THEN BEGIN
2398: 2ff5: 
2399: 2ff5:        PRINT  TIME.STAMP$(2)  + "-Backing up of SRPOG Successful"
2400: 3023:        PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)                         \
2401: 3060:                      + "-Backing up of SRPOG Successful"
2402: 3060: 
2403: 3060:    ENDIF
2404: 3068: 
2405: 3068:    CALL ADXCOPYF(RC%,"ADXLXACN::D:\ADX_UDT3\SRMOD.DAT",                 \
2406: 30c4:                      "ADXLXACN::D:\SRMOD.DAT",0,0)
2407: 30c4: 
2408: 30c4:    IF RC% = 0 THEN BEGIN
2409: 30e3: 
2410: 30e3:        PRINT  TIME.STAMP$(2)  + "-Backing up of SRMOD Successful"
2411: 3111:        PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)                         \
2412: 314e:              + "-Backing up of SRMOD Successful"
2413: 314e: 
2414: 314e:    ENDIF   
2415: 3156: 
2416: 3156: 
2417: 3156:    CALL ADXCOPYF(RC%,"ADXLXACN::D:\ADX_UDT3\SRSXF.DAT",                 \
2418: 31b2:                      "ADXLXACN::D:\SRSXF.DAT",0,0) 
2419: 31b2: 
2420: 31b2:    IF RC% = 0 THEN BEGIN
2421: 31d1: 
2422: 31d1:        PRINT  TIME.STAMP$(2)  + "-Backing up of SRSXF Successful"
2423: 31ff:        PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)                         \
2424: 323c:                               + "-Backing up of SRSXF Successful"
2425: 323c: 
2426: 323c:    ENDIF
2427: 3244: 
2428: 3244:    CALL ADXCOPYF(RC%,"ADXLXACN::D:\ADX_UDT3\SRPDF.DAT",                 \
2429: 32a0:                      "ADXLXACN::D:\SRPDF.DAT",0,0)   
2430: 32a0: 
2431: 32a0:    IF RC% = 0 THEN BEGIN
2432: 32bf: 
2433: 32bf:        PRINT  TIME.STAMP$(2)  + "-Backing up of SRPDF Successful"
2434: 32ed:        PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)                         \
2435: 332a:                         + "-Backing up of SRPDF Successful"
2436: 332a: 
2437: 332a:    ENDIF
2438: 3332: 
2439: 3332: RETURN
2440: 3342: 
2441: 3342: \***********************************************************************
2442: 3342: \*
2443: 3342: \*    DELETE.EXISTING 
2444: 3342: \*              
2445: 3342: \*
2446: 3342: \***********************************************************************
2447: 3342: DELETE.EXISTING:    
2448: 3352: 
2449: 3352:    PRINT  TIME.STAMP$(2)  + "-Deleting SRMOD original"
2450: 3380:    PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)                            \
2451: 33bd:                                      + "-Deleting SRMOD original"    
2452: 33bd:   
2453: 33bd:    OPEN SRMOD.FILE.NAME$ AS SRMOD.SESS.NUM%
2454: 33e4: 
2455: 33e4:    DELETE SRMOD.SESS.NUM%
2456: 33f8:    
2457: 33f8:    PRINT  TIME.STAMP$(2)  + "-Deleting SRPDF original"
2458: 3426:    PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)  +                         \
2459: 3463:                                          "-Deleting SRPDF original"    
2460: 3463:   
2461: 3463:    OPEN SRPDF.FILE.NAME$ AS SRPDF.SESS.NUM%
2462: 348a: 
2463: 348a:    DELETE SRPDF.SESS.NUM%
2464: 349e:    
2465: 349e:    PRINT  TIME.STAMP$(2)  + "-Deleting SRSXF original"
2466: 34cc:    PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)  +                          \
2467: 3509:                                      "-Deleting SRSXF original"    
2468: 3509:   
2469: 3509:    OPEN SRSXF.FILE.NAME$ AS SRSXF.SESS.NUM%
2470: 3530: 
2471: 3530:    DELETE SRSXF.SESS.NUM%  
2472: 3544: 
2473: 3544: RETURN
2474: 3554: 
2475: 3554: \***********************************************************************
2476: 3554: \*
2477: 3554: \*    COPY.NEW 
2478: 3554: \*             
2479: 3554: \*
2480: 3554: \***********************************************************************
2481: 3554: COPY.NEW:    
2482: 3564: 
2483: 3564:    PRINT  TIME.STAMP$(2)  + "-Rekeying SRPOG"
2484: 3592:    PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)  + "-Rekeying SRPOG"    
2485: 35cf:    
2486: 35cf:    GOSUB REKEY.SRPOG                                                    ! ARG
2487: 35e1: 
2488: 35e1:    CALL ADXCOPYF(RC%,"ADXLXACN::C:\SRMOD.KEY",                         \
2489: 363d:                      "ADXLXACN::D:\ADX_UDT3\SRMOD.DAT",0,0)   
2490: 363d: 
2491: 363d:    IF RC% = 0 THEN BEGIN
2492: 365f: 
2493: 365f:        PRINT  TIME.STAMP$(2)  + "- New SRMOD has been copied successfuly"
2494: 368d:        PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)                         \
2495: 36ca:                 + "-New SRMOD has been copied successfuly"
2496: 36ca:        SRMOD.FLAG$ = "E"
2497: 36df: 
2498: 36df:    ENDIF
2499: 36e7:    
2500: 36e7:    CALL ADXCOPYF(RC%,"ADXLXACN::C:\SRSXF.KEY",                          \
2501: 3743:                      "ADXLXACN::D:\ADX_UDT3\SRSXF.DAT",0,0)   
2502: 3743: 
2503: 3743:    IF RC% = 0 THEN BEGIN
2504: 3765: 
2505: 3765:        PRINT  TIME.STAMP$(2)  + "- New SRSXF has been copied successfuly"
2506: 3793:        PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)                         \
2507: 37d0:                       + "-New SRSXF has been copied successfuly"
2508: 37d0:        SRSXF.FLAG$ = "E"
2509: 37e5: 
2510: 37e5:    ENDIF   
2511: 37ed: 
2512: 37ed:    CALL ADXCOPYF(RC%,"ADXLXACN::C:\SRPDF.KEY",                          \
2513: 3849:                      "ADXLXACN::D:\ADX_UDT3\SRPDF.DAT",0,0) 
2514: 3849: 
2515: 3849:    IF RC% = 0 THEN BEGIN
2516: 386b:    
2517: 386b:        PRINT  TIME.STAMP$(2)  + "- New SRPDF has been copied successfuly"
2518: 3899:        PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)                         \
2519: 38d6:                       + "-New SRPDF has been copied successfuly"
2520: 38d6: 
2521: 38d6:        SRPDF.FLAG$ = "E"
2522: 38eb: 
2523: 38eb:    ENDIF
2524: 38f3: 
2525: 38f3: 
2526: 38f3: RETURN
2527: 3903: 
2528: 3903: 
2529: 3903: \***********************************************************************
2530: 3903: \*
2531: 3903: \*    START.BACKGROUNDS 
2532: 3903: \*                
2533: 3903: \*
2534: 3903: \***********************************************************************
2535: 3903: START.BACKGROUNDS:
2536: 3913:  
2537: 3913:    PRINT  TIME.STAMP$(2)  + "-Starting BGMON Application"
2538: 3941:    PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)                             \
2539: 397e:                                + "-Starting BGMON Application"   
2540: 397e:    
2541: 397e:    CALL OSSHELL("C:\ADX_UPGM\BGSTART" + SPACE$ + "ADX_UPGM:BGMON.286")   
2542: 39a9:    
2543: 39a9:    PRINT  TIME.STAMP$(2)  + "-Starting TRANSACT Application"
2544: 39d7:    PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)                             \
2545: 3a14:                                    + "-Starting TRANSACT Application"    
2546: 3a14:    
2547: 3a14:    CALL OSSHELL("C:\ADX_UPGM\BGSTART" + SPACE$                          \
2548: 3a3f:                                            + "ADX_UPGM:TRANSACT.286")    
2549: 3a3f:  
2550: 3a3f: RETURN
2551: 3a4f: 
2552: 3a4f: \***********************************************************************
2553: 3a4f: \*
2554: 3a4f: \*    TERMINATION   
2555: 3a4f: \*               
2556: 3a4f: \*
2557: 3a4f: \***********************************************************************
2558: 3a4f: TERMINATION:
2559: 3a5f: 
2560: 3a5f:    GOSUB WRITE.PHKEEP.OK     
2561: 3a71:    
2562: 3a71:    IF ERROR.CNT% = 0 THEN BEGIN  
2563: 3a8f: 
2564: 3a8f:        PRINT  TIME.STAMP$(2)  + "-Renaming error file to OK file"
2565: 3abd:        PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)                         \
2566: 3afa:         + "-Renaming error file to OK file"    
2567: 3afa: 
2568: 3afa:        RC% = RENAME("C:/PHKEEP.OK","C:/PHKEEP.ERR")
2569: 3b1d: 
2570: 3b1d:  
2571: 3b1d:        PRINT  TIME.STAMP$(2)  + "-Read " +  STR$(SRPOG%) +              \
2572: 3b87:                           " SRPOG records"  + \
2573: 3b87:                           + " Written " + STR$(SRPOG.COUNT%) +          \
2574: 3b87:                             " In to New file"
2575: 3b87: 
2576: 3b87:        PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)  + "-Read " +           \
2577: 3c00:                                                   STR$(SRPOG%)      +   \
2578: 3c00:          " SRPOG records" + " Written " + STR$(SRPOG.COUNT%)            \
2579: 3c00:                                         + " In to New file"
2580: 3c00: 
2581: 3c00: 
2582: 3c00:        PRINT  TIME.STAMP$(2)  + "-Read " +  STR$(SRMOD%) +              \
2583: 3c6a:                           " SRMOD records"  + \
2584: 3c6a:                           + " Written " + STR$(SRMOD.COUNT%) +          \
2585: 3c6a:                             " In to New file"
2586: 3c6a: 
2587: 3c6a:        PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)  + "-Read " +           \
2588: 3ce3:                                                   STR$(SRMOD%)      +   \
2589: 3ce3:          " SRMOD records" + " Written " + STR$(SRMOD.COUNT%)            \
2590: 3ce3:                                         + " In to New file"
2591: 3ce3: 
2592: 3ce3:        PRINT  TIME.STAMP$(2)  + "-Read " +  STR$(SRSXF%)                \
2593: 3d4d:                                         +  " SRSXF records"  +          \
2594: 3d4d:                          + " Written " + STR$(SRSXF.COUNT%)             \
2595: 3d4d:                          + " In to New file"
2596: 3d4d: 
2597: 3d4d:        PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)  + "-Read "             \
2598: 3dc6:                                               +  STR$(SRSXF%) +         \
2599: 3dc6:         " SRSXF records" + " Written " + STR$(SRSXF.COUNT%)             \
2600: 3dc6:                                     + " In to New file"
2601: 3dc6: 
2602: 3dc6:        PRINT  TIME.STAMP$(2)  + "-Read " +  STR$(SRPDF%)                \
2603: 3e30:                         + " SRPDF records"  + \
2604: 3e30:                         + " Written " + STR$(SRPDF.COUNT%)              \
2605: 3e30:                         + " In to New file"
2606: 3e30: 
2607: 3e30:        PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)  + "-Read " +           \
2608: 3ea9:                          STR$(SRPDF%) +  \
2609: 3ea9:        " SRPDF records" + " Written " + STR$(SRPDF.COUNT%)              \
2610: 3ea9:        + " In to New file"
2611: 3ea9: 
2612: 3ea9:        PRINT  TIME.STAMP$(2)  + "- Program completed successfully"
2613: 3ed7:        PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)                         \
2614: 3f14:               + "- Program completed successfuly"
2615: 3f14: 
2616: 3f14:    ENDIF
2617: 3f1c: 
2618: 3f1c: 
2619: 3f1c:    GOSUB CLOSE.FILES
2620: 3f2e:    GOSUB HOUSEKEEP.WDRIVE
2621: 3f40:    GOSUB DEALLOCATE.SESS.NUM
2622: 3f52:      
2623: 3f52: 
2624: 3f52: RETURN
2625: 3f62: 
2626: 3f62: \***********************************************************************
2627: 3f62: \*
2628: 3f62: \*    HOUSEKEEP.WDRIVE  
2629: 3f62: \*               
2630: 3f62: \*
2631: 3f62: \*********************************************************************** 
2632: 3f62: HOUSEKEEP.WDRIVE:
2633: 3f72: 
2634: 3f72:    CALL OSSHELL ("IF EXIST C:/SRPOG.DIR DEL C:/SRPOG.DIR")
2635: 3f86:    CALL OSSHELL ("IF EXIST C:/SRMOD.DIR DEL C:/SRMOD.DIR")
2636: 3f9a:    CALL OSSHELL ("IF EXIST C:/SRSXF.DIR DEL C:/SRSXF.DIR")
2637: 3fae:    CALL OSSHELL ("IF EXIST C:/SRPDF.DIR DEL C:/SRPDF.DIR")
2638: 3fc2:    CALL OSSHELL ("IF EXIST C:/SRPOG.KEY DEL C:/SRPOG.KEY")
2639: 3fd6:    CALL OSSHELL ("IF EXIST C:/SRMOD.KEY DEL C:/SRMOD.KEY")
2640: 3fea:    CALL OSSHELL ("IF EXIST C:/SRSXF.KEY DEL C:/SRSXF.KEY")
2641: 3ffe:    CALL OSSHELL ("IF EXIST C:/SRPDF.KEY DEL C:/SRPDF.KEY")
2642: 4012: 
2643: 4012: 
2644: 4012: RETURN
2645: 4022: 
2646: 4022: \***********************************************************************
2647: 4022: \*
2648: 4022: \*    ERROR.LOG  
2649: 4022: \*               
2650: 4022: \*
2651: 4022: \***********************************************************************
2652: 4022: ERROR.LOG: 
2653: 4032:         
2654: 4032:          VAR.STRING.1$ = FILE.OPERATION$                     +          \
2655: 40c8:                 CHR$(SHIFT(CURRENT.REPORT.NUM%, 8) AND 0FFH) +          \
2656: 40c8:                 CHR$(CURRENT.REPORT.NUM% AND 0FFH)           +          \
2657: 40c8:                 CURRENT.CODE$
2658: 40c8:          VAR.STRING.2$ = "PHKEEP"
2659: 40dd:          MESSAGE.NO%   = 0
2660: 40f2:          EVENT.NO%     = 106
2661: 4109: 
2662: 4109:          RC% = APPLICATION.LOG(MESSAGE.NO%,VAR.STRING.1$,               \
2663: 414c:                       VAR.STRING.2$,EVENT.NO%)
2664: 414c: 
2665: 414c:          GOSUB WRITE.PHKEEP.OK
2666: 415e: 
2667: 415e:          GOTO END.PROGRAM
2668: 4169: 
2669: 4169: RETURN
2670: 4179: 
2671: 4179: \***********************************************************************
2672: 4179: \*
2673: 4179: \*    CLOSE.FILES:
2674: 4179: \*                
2675: 4179: \*
2676: 4179: \***********************************************************************
2677: 4179: 
2678: 4179: CLOSE.FILES:
2679: 4189:    
2680: 4189:    CLOSE PHKEEP.SESS.NUM%
2681: 419e:    
2682: 419e: RETURN  
2683: 41ae: \***********************************************************************
2684: 41ae: \*
2685: 41ae: \*    DEALLOCATE.SESS.NUM  
2686: 41ae: \*                
2687: 41ae: \*
2688: 41ae: \***********************************************************************
2689: 41ae: DEALLOCATE.SESS.NUM: 
2690: 41be: 
2691: 41be:     FUNCTION.FLAG$ = "C"   
2692: 41d3:     
2693: 41d3:     PASSED.INTEGER% = SRPOG.REPORT.NUM%                                
2694: 41f0:     PASSED.STRING$  = SRPOG.FILE.NAME$                                 
2695: 420e:     GOSUB CALL.F20.SESS.NUM.UTILITY                                    
2696: 4220:     SRPOG.SESS.NUM% = F20.INTEGER.FILE.NO%                             
2697: 4236: 
2698: 4236:     PASSED.INTEGER% = SRMOD.REPORT.NUM%                                
2699: 4253:     PASSED.STRING$  = SRMOD.FILE.NAME$                                 
2700: 4271:     GOSUB CALL.F20.SESS.NUM.UTILITY                                    
2701: 4283:     SRMOD.SESS.NUM% = F20.INTEGER.FILE.NO%                             
2702: 4299: 
2703: 4299:     PASSED.INTEGER% = SRSXF.REPORT.NUM%                                
2704: 42b6:     PASSED.STRING$  = SRSXF.FILE.NAME$                                 
2705: 42d4:     GOSUB CALL.F20.SESS.NUM.UTILITY                                    
2706: 42e6:     SRSXF.SESS.NUM% = F20.INTEGER.FILE.NO%                             
2707: 42fc: 
2708: 42fc:     PASSED.INTEGER% = SRPDF.REPORT.NUM%                                
2709: 4319:     PASSED.STRING$  = SRPDF.FILE.NAME$                                 
2710: 4337:     GOSUB CALL.F20.SESS.NUM.UTILITY                                    
2711: 4349:     SRPDF.SESS.NUM% = F20.INTEGER.FILE.NO%                             
2712: 435f: 
2713: 435f:     PASSED.INTEGER% = PHKEEP.SESS.NUM%                                 
2714: 4376:     PASSED.STRING$  = PHKEEP.LOG.NAME$                                 
2715: 4391:     GOSUB CALL.F20.SESS.NUM.UTILITY                                    
2716: 43a3:     PHKEEP.SESS.NUM% = F20.INTEGER.FILE.NO%                            
2717: 43be: 
2718: 43be:     PASSED.INTEGER% = PHKEEP.OK.SESS%                                  
2719: 43d5:     PASSED.STRING$  = PHKEEP.OK.NAME$                                  
2720: 43f0:     GOSUB CALL.F20.SESS.NUM.UTILITY                                    
2721: 4402:     PHKEEP.OK.SESS% = F20.INTEGER.FILE.NO%                             
2722: 441d: 
2723: 441d:     PASSED.INTEGER% = 458                                              
2724: 4434:     PASSED.STRING$  = SRMOD.DIR.NAME$                                  
2725: 444f:     GOSUB CALL.F20.SESS.NUM.UTILITY                                    
2726: 4461:     SRMOD.DIR.SESS% = F20.INTEGER.FILE.NO%                             
2727: 447c: 
2728: 447c:     PASSED.INTEGER% = 459                                              
2729: 4493:     PASSED.STRING$  = SRPDF.DIR.NAME$                                  
2730: 44ae:     GOSUB CALL.F20.SESS.NUM.UTILITY                                    
2731: 44c0:     SRPDF.DIR.SESS% = F20.INTEGER.FILE.NO%                             
2732: 44db: 
2733: 44db:     PASSED.INTEGER% = 460                                              
2734: 44f2:     PASSED.STRING$  = SRSXF.DIR.NAME$                                  
2735: 450d:     GOSUB CALL.F20.SESS.NUM.UTILITY                                    
2736: 451f:     SRSXF.DIR.SESS% = F20.INTEGER.FILE.NO%                             
2737: 453a: 
2738: 453a: 
2739: 453a: RETURN
2740: 454a: 
2741: 454a: \***********************************************************************
2742: 454a: \*
2743: 454a: \*    ERROR.DETECTED  
2744: 454a: \*              
2745: 454a: \*
2746: 454a: \***********************************************************************
2747: 454a: ERROR.DETECTED:     
2748: 455a:    
2749: 455a: 
2750: 455a:      ERROR.CNT% = ERROR.CNT% + 1
2751: 4573: 	 
2752: 4573: 	 IF ERR = "OE" AND ERRF% = SRMAP.SESS.NUM% THEN BEGIN
2753: 45c6:          PRINT  TIME.STAMP$(2)  + "-NO SRMAP File" +                    \
2754: 45f8:                                         " program can't be continued"
2755: 45f8:          PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)                       \
2756: 4635:                 + "-NO SRMAP File, program can't be continued"
2757: 4635:          SRMAP.FLAG$ = "X" 
2758: 464a:          GOSUB ERROR.LOG
2759: 465c:      ENDIF
2760: 4664: 
2761: 4664:      IF ERR = "OE" AND ERRF% = SRPOG.SESS.NUM% THEN BEGIN
2762: 46b7:          PRINT  TIME.STAMP$(2)  + "-NO SRPOG File" +                    \
2763: 46e9:                                         " program can't be continued"
2764: 46e9:          PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)                       \
2765: 4726:                 + "-NO SRPOG File, program can't be continued"
2766: 4726:          SRPOG.FLAG$ = "X" 
2767: 473b:          GOSUB ERROR.LOG
2768: 474d:      ENDIF
2769: 4755:    
2770: 4755:      IF ERR = "OE" AND ERRF% = SRMOD.SESS.NUM% THEN BEGIN
2771: 47a8:          PRINT  TIME.STAMP$(2)  + "-NO SRMOD File" +                    \
2772: 47da:                                     ",program can't be continued"
2773: 47da:          PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)                       \
2774: 4817:                 + "-NO SRMOD File, program can't be continued"
2775: 4817:          SRMOD.FLAG$ = "X" 
2776: 482c:          GOSUB ERROR.LOG
2777: 483e:      ENDIF
2778: 4846:    
2779: 4846:      IF ERR = "OE" AND ERRF% = SRSXF.SESS.NUM% THEN BEGIN
2780: 4899:          PRINT  TIME.STAMP$(2)  + "-NO SRSXF File," +                   \
2781: 48cb:                                        "program can't be continued"
2782: 48cb:          PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)                       \
2783: 4908:               + "-NO SRSXF File, program can't be continued"
2784: 4908:          SRSXF.FLAG$ = "X" 
2785: 491d:          GOSUB ERROR.LOG
2786: 492f:      ENDIF
2787: 4937:    
2788: 4937:      IF ERR = "OE" AND ERRF% = SRPDF.SESS.NUM% THEN BEGIN
2789: 498a:          PRINT  TIME.STAMP$(2)  + "-NO SRPDF File," +                   \
2790: 49bc:                                         "program can't be continued"
2791: 49bc:          PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)                       \
2792: 49f9:                + "-NO SRPDF File, program can't be continued"
2793: 49f9:          SRPDF.FLAG$ = "X" 
2794: 4a0e:          GOSUB ERROR.LOG
2795: 4a20:      ENDIF    
2796: 4a28:    
2797: 4a28:      GOSUB ERROR.LOG
2798: 4a3a:    
2799: 4a3a: RETURN  
2800: 4a4a: 
2801: 4a4a: \***********************************************************************
2802: 4a4a: \*
2803: 4a4a: \*    END.PROGRAM 
2804: 4a4a: \*              
2805: 4a4a: \*
2806: 4a4a: \***********************************************************************
2807: 4a4a: 
2808: 4a4a:    END.PROGRAM:
2809: 4a5f: 
2810: 4a5f:    END 
2811: 4a5f:        
2812: 4a5f: 
2813: 4a5f: End of Compilation
