   1: 0003: \********************************************************************
   2: 0003: \********************************************************************
   3: 0003: \***
   4: 0003: \***
   5: 0003: \***            PROGRAM         :       PSD85
   6: 0003: \***            MODULE          :       PSD8500
   7: 0003: \***            AUTHOR          :       Neil Bennett
   8: 0003: \***            DATE WRITTEN    :       May 2010
   9: 0003: \***
  10: 0003: \********************************************************************
  11: 0003: \***
  12: 0003: \***    VERSION A.            NEIL BENNETT.              17 May 2010.
  13: 0003: \***    Initial version.
  14: 0003: \***
  15: 0003: \***    VERSION B.            Stuart Highley.            17 June 2010.
  16: 0003: \***    Do not display Status Updated if F3 pressed to quit update.
  17: 0003: \***
  18: 0003: \***    VERSION C.            Stuart Highley.            29 June 2010.
  19: 0003: \***    CR1: Change padding of parcel number to match till app.
  20: 0003: \***
  21: 0003: \***    VERSION D.            Denesh Manoharan             05/09/2014
  22: 0003: \***    FOD399 - Boots.com Enhancements
  23: 0003: \***    The following changes are done as part of this project:
  24: 0003: \***      -  Subroutine:PROCESS.SCREEN1 - trap F9.KEY%
  25: 0003: \***         and execute PSD96.286 in background with BEMF message call.
  26: 0003: \***      -  Subroutine:CHANGE.SCREEN1 - ensure F9PRINT option is always
  27: 0003: \***         visible.
  28: 0003: \***      -  Subroutine:INITIALISATION - Read days uncollected value
  29: 0003: \***         from record 60 of SOFTS file.
  30: 0003: \***      -  Function:disp$ - Display 'UNCOLLECTED - RETURN TO W/H?'
  31: 0003: \***         for parcels with difference b/w current date and delivery
  32: 0003: \***         date greater than days uncollected value.
  33: 0003: \***
  34: 0003: \***    VERSION E.            Christopher Kitto            16/09/2014
  35: 0003: \***    FOD399 - Boots.com Enhancements
  36: 0003: \***    Addressing the changes of CR02:
  37: 0003: \***      -  Commented out the PSBCHN.* lines in ERR.DETECTED.
  38: 0003: \***      -  Avoided the unnecessary opening of the BDCP file. BDCP file
  39: 0003: \***         opened only when needed and closed after the need.
  40: 0003: \***
  41: 0003: \***    VERSION F.             Muthu Mariappan             24/09/2014
  42: 0003: \***    FOD399 - Boots.com Enhancements
  43: 0003: \***    Fixed Defect 1170 (Qc):
  44: 0003: \***      -  The information message 'B388 Report Generation and
  45: 0003: \***         printing initiated' is displayed only when there is a
  46: 0003: \***         report to be printed
  47: 0003: \***    Fixed Defect 1171 (Qc):
  48: 0003: \***      -  The status of the parcels displayed in the controller
  49: 0003: \***         screen is sorted
  50: 0003: \***
  51: 0003: \***    VERSION G.             Christopher Kitto           30/09/2014
  52: 0003: \***    FOD399 - Boots.com Enhancements
  53: 0003: \***    Fixed Defect 1189 (Qc):
  54: 0003: \***      -  'In ROI stores, the Parcel management SCREEN TITLE is not
  55: 0003: \***         displayed as BOOTS.IE'
  56: 0003: \***
  57: 0003: \***    VERSION H.             Dave Constable              07/03/2016
  58: 0003: \***    PRJ1361- Order & Collect Parcel Management
  59: 0003: \***    User Story PMLA-17 & PMLA-58
  60: 0003: \***
  61: 0003: \***    VERSION I.             Dave Constable              11/03/2016
  62: 0003: \***    PRJ1361- Order & Collect Parcel Management
  63: 0003: \***    Corrected SONAR Critical errors for missing FUNC. and usage
  64: 0003: \***    of the Standard Error Detected on 'on error'
  65: 0003: \***    Changes for PMLA-20 and PMLA-18.
  66: 0003: \***
  67: 0003: \***    VERSION J.             Dave Constable              18/03/2016
  68: 0003: \***    PRJ1361- Order & Collect Parcel Management
  69: 0003: \***    Corrected Function buttons at screen load.
  70: 0003: \***    Added message function to remove duplication of code.
  71: 0003: \***    Changed screen titles to match screens.
  72: 0003: \***
  73: 0003: \***    VERSION K.             Dave Constable              08/04/2016
  74: 0003: \***    PRJ1361- Order & Collect Parcel Management
  75: 0003: \***    Corrected variable ordering from code review.
  76: 0003: \***
  77: 0003: \***    VERSION L.             Lino Jacob                  11/04/2016
  78: 0003: \***    PRJ1361- Order & Collect Parcel Management
  79: 0003: \***    - User Story PMLA-16 : To disallow the deactivation of locations
  80: 0003: \***      if there are parcels available at that location
  81: 0003: \***    - Incorporated review comments from sprint 1
  82: 0003: \***    - Removed previously commented code
  83: 0003: \***
  84: 0003: \***    VERSION M.             Lino Jacob                  18/04/2016
  85: 0003: \***    PRJ1361- Order & Collect Parcel Management
  86: 0003: \***    - User Stories PMLA-85,15 : Various data validations on screen
  87: 0003: \***        - Do not allow user to edit the default location (#1)
  88: 0003: \***        - Data validations on Short and Long description fields
  89: 0003: \***    - Removed previously commented code
  90: 0003: \***
  91: 0003: \***    VERSION N.             Lino Jacob                  22/04/2016
  92: 0003: \***    PRJ1361- Order & Collect Parcel Management
  93: 0003: \***    - User Stories PMLA-85,15 : Changes to confirmation on F3
  94: 0003: \***        - The confirmation prompt on F3 is changed to use display
  95: 0003: \***          function DM.PROCESS.SCREEN parameter, this would help in
  96: 0003: \***          validating the screen before file update.
  97: 0003: \***
  98: 0003: \***    VERSION O.             Lino Jacob                  28/04/2016
  99: 0003: \***    PRJ1361- Order & Collect Parcel Management
 100: 0003: \***    - User Stories PMLA-15 : Validation for F6 activation           !XLJ
 101: 0003: \***        - The description fields need to be validated while changing
 102: 0003: \***          the status of a location from inactive to active
 103: 0003: \***    - Removed previously commented code
 104: 0003: \***
 105: 0003: \***    VERSION P.             Lino Jacob                  20/05/2016
 106: 0003: \***    PRJ1361- Order & Collect Parcel Management
 107: 0003: \***    - User Story PMLA-98 : Storage location 1
 108: 0003: \***        - Location 1 cannot be chosen/edited from the controller
 109: 0003: \***
 110: 0003: \***    VERSION Q.             Christopher Kitto           27/06/2016
 111: 0003: \***    PRJ1361- Order & Collect Parcel Management
 112: 0003: \***    - User story PMLA-132 : Incorporated review comments
 113: 0003: \***      Commented out codes in previous version has been removed.
 114: 0003: \***
 115: 0003: \***    VERSION R.             Lino Jacob                  27/07/2016
 116: 0003: \***    PRJ1361- Order & Collect Parcel Management
 117: 0003: \***    - User story PMLA-213,214 - Location management screen          !XLJ
 118: 0003: \***      Changed display to show only long name
 119: 0003: \***      Added page up and page down functionality
 120: 0003: \***    - User story PMLA-252 - 3 digit location display
 121: 0003: \***
 122: 0003: \***    VERSION S.             Arun Haridas                27/07/2016   !XLJ
 123: 0003: \***    PRJ1361- Order & Collect Parcel Management
 124: 0003: \***    - User story PMLA-228 : Changed all Boots ".com" and ".ie"
 125: 0003: \***      titles to "Order & Collect".
 126: 0003: \***    - User story PMLA-218 : Changes in the location management
 127: 0003: \***      screen: The system shows a B463 message when same character
 128: 0003: \***      is entered 3 or more times in the location description field.
 129: 0003: \***      And, the system shows a B462 message when null or spaces are
 130: 0003: \***      entered in the location description field.
 131: 0003: \***    - User Story PMLA-197 : Storage location 1
 132: 0003: \***      Display an error message while editing default location(1)
 133: 0003: \***    - User Story PMLA-212 : After completing the data entry of one
 134: 0003: \***      location, when we move to create another location
 135: 0003: \***      description, a new B465 message is shown which prompts the
 136: 0003: \***      user to activate the location. And if F6 is pressed, the
 137: 0003: \***      location is activated and if we are ignoring it, i.e, if it
 138: 0003: \***      is not activated, the location description field will be
 139: 0003: \***      cleared.
 140: 0003: \***
 141: 0003: \***    VERSION T.             Arun Haridas                16/08/2016
 142: 0003: \***    PRJ1361- Order & Collect Parcel Management
 143: 0003: \***    - QC Defect 2243: In the location management screen, the value
 144: 0003: \***      of F6 key is "INACT" for inactive locations and "ACTIV" for
 145: 0003: \***      active locations. But, expected value is "ACTIV" for inactive
 146: 0003: \***      locations and "INACT" for active locations. Made the
 147: 0003: \***      necessary changes.
 148: 0003: \***    - Added a "HELP" value to the F1 key, in the location
 149: 0003: \***      management screen.
 150: 0003: \***
 151: 0003: \***    VERSION U.             Christopher Kitto           18/08/2016
 152: 0003: \***    PRJ1361- Order & Collect Parcel Management
 153: 0003: \***    - QC Defect 2558: Information was not correctly saved in the
 154: 0003: \***      exact inactive location. Fixed the issue.
 155: 0003: \***
 156: 0003: \***    VERSION V.             Christopher Kitto           26/08/2016
 157: 0003: \***    PRJ1361- Order & Collect Parcel Management
 158: 0003: \***    - QC Defect 2571: It should not be possible to make the
 159: 0003: \***      location 001 - 'Booked In at Till' Inactive. Fixed the issue.
 160: 0003: \***
 161: 0003: \***    VERSION W.             Christopher Kitto           01/09/2016
 162: 0003: \***    PRJ1361- Order & Collect Parcel Management
 163: 0003: \***    - QC Defect 2595: It was possible to enter same character
 164: 0003: \***      sequentially 3 or more times with the combination of Upper
 165: 0003: \***      and Lower cases in location description field, which should
 166: 0003: \***      not be allowed. Fixed the issue.
 167: 0003: \***
 168: 0003: \***    VERSION X.             Lino Jacob                  06/09/2016
 169: 0003: \***    PRJ1361- Order & Collect Parcel Management
 170: 0003: \***    User story PMLA-132 - Code review comments
 171: 0003: \***    - Corrected version dates and some words in the version history
 172: 0003: \***    - Updated the version tag (OLJ) for arranging the variables in
 173: 0003: \***      in alphabetical order
 174: 0003: \***    - Corrected the indentation of DM.FIELD.CHANGED subprogram
 175: 0003: \***    - Removed previously commented code
 176: 0003: \***
 177: 0003: \***    VERSION Y.             Dave Consstable             13/09/2016
 178: 0003: \***    PRJ1361- Order & Collect Parcel Management
 179: 0003: \***    Fix for status description spacing and used descriptors
 180: 0003: \***
 181: 0003: \***    VERSION Z.             Christopher Kitto           16/09/2016
 182: 0003: \***    PRJ1361- Order & Collect Parcel Management
 183: 0003: \***    - QC Defect 2594: When pressed 'Tab' key after modifying long
 184: 0003: \***      description of location, the data was getting saved. Fixed
 185: 0003: \***      issue. When pressed 'Tab' after modification, now system asks
 186: 0003: \***      to save/not.
 187: 0003: \***
 188: 0003: \***    VERSION AA.            Christopher Kitto           20/09/2016
 189: 0003: \***    PRJ1361- Order & Collect Parcel Management
 190: 0003: \***    - QC Defect 2638: Inactive locations in the controller not
 191: 0003: \***      clearing the description. Fixed the issue. Now the active
 192: 0003: \***      locations when made Inactive by pressing F6 will have null
 193: 0003: \***      description.
 194: 0003: \***
 195: 0003: \***    VERSION AB.            Dave Constable              26/09/2016
 196: 0003: \***    PRJ1361- Order & Collect Parcel Management
 197: 0003: \***    - Changed BEMF B459 message to use B466 as conflict with 16B
 198: 0003: \***
 199: 0003: \***    VERSION AC             Andrew Paron                05/10/2016
 200: 0003: \***    PRJ1361- Order & Collect Parcel Management
 201: 0003: \***    - changed UPDATE.PARCEL.COUNT subroutine to handle if the
 202: 0003: \***    location is blank(2020).
 203: 0003: \***
 204: 0003: \***    VERSION AD.            Christopher Kitto           07/10/2016
 205: 0003: \***    PRJ1361- Order & Collect Parcel Management
 206: 0003: \***    Fixed defects QC 2669 & 2673
 207: 0003: \***    - QC defect 2669: Duplicate descriptions are accepted on a
 208: 0003: \***      different location management screen instead of showing error
 209: 0003: \***    - QC defect 2673: Inactivating an active location clears
 210: 0003: \***      description without asking for confirmation F3 or ENTER.
 211: 0003: \***
 212: 0003: \***    VERSION AE.            Charles Skadorwa            19/10/2016
 213: 0003: \***    PRJ1361- Order & Collect Parcel Management
 214: 0003: \***    Fixed defect caused by fixing QC 2669 & 2673. Parcel Mgt screen
 215: 0003: \***    displayed Subscript out of bounds error when you pressed any
 216: 0003: \***    key.
 217: 0003: \***       - modified display manager user exit subroutine
 218: 0003: \***         SUB DM.FIELD.CHANGED().
 219: 0003: \***       - removed commented out code.
 220: 0003: \***
 221: 0003: \***    VERSION AF.     Charles Skadorwa/Kiran Krishnan       13/06/2017
 222: 0003: \***    PRJ2002- Order & Collect Parcel Management Phase 2
 223: 0003: \***    PMLA-310: In Location screen, description is blanked out when
 224: 0003: \***              you fail to make a location inactive. Also resolved
 225: 0003: \***              incorrect toggling of F6INACT button and repeat
 226: 0003: \***              request to save change again when tabbing to next
 227: 0003: \***              field.
 228: 0003: \***
 229: 0003: \***    VERSION AG.     Charles Skadorwa                      23/06/2017
 230: 0003: \***    PRJ2002- Order & Collect Parcel Management Phase 2
 231: 0003: \***    PMLA-331: Introduce Book In functionality in O&C Parcel
 232: 0003: \***              Management screen.
 233: 0003: \***              F4 key will toggle to BOOKIN when a parcel with status
 234: 0003: \***              Late Delivery or Expected Delivery is highlighted.
 235: 0003: \***              When the parcel is booked in, F4 will change to CLLCT.
 236: 0003: \***
 237: 0003: \***    VERSION AH.     Charles Skadorwa                      28/06/2017
 238: 0003: \***    PRJ2002- Order & Collect Parcel Management Phase 2
 239: 0003: \***    PMLA-331: Introduce Book In functionality in O&C Parcel
 240: 0003: \***              Management screen.
 241: 0003: \***              Additional logic to ensure that if the update to the
 242: 0003: \***              CARTON file fails, then the BDCP Parcel record update
 243: 0003: \***              is rolled back ie. write original record back and
 244: 0003: \***              display message informing user to try again.
 245: 0003: \***
 246: 0003: \***    VERSION AI.     Charles Skadorwa                      17/08/2017
 247: 0003: \***    PRJ2002- Order & Collect Parcel Management Phase 2
 248: 0003: \***    PMLA-407: Introduce near real-time Book In functionality.
 249: 0003: \***              Added logic to add a record to the PSUTQ:
 250: 0003: \***                 Type 1, Operation "B" - for F4 BOOKIN
 251: 0003: \***                 Type 1, Operation "M" - for F10 LOCation
 252: 0003: \***                 Type 5 - for F5 RETRN
 253: 0003: \***              A file access message is displayed if the file cannot
 254: 0003: \***              be updated for any reason (therefore no reason to
 255: 0003: \***              read PSUCF file to check PSD86 status).
 256: 0003: \***
 257: 0003: \***    VERSION AJ.     Charles Skadorwa                      17/08/2017
 258: 0003: \***    PRJ2002- Order & Collect Parcel Management Phase 2
 259: 0003: \***             Fix to set up PSUTQ Type 5 record as Order & Parcel
 260: 0003: \***             numbers not set. PSUTQ record format changed.
 261: 0003: \***
 262: 0003: \***    VERSION AK      Kiran Krishnan                       07/09/2017
 263: 0003: \***    PRJ2002- Order & Collect Parcel Management Phase 2
 264: 0003: \***            Changes to make the data in PSUTQ ASCII and comma 
 265: 0003: \***            seperated
 266: 0003: \***
 267: 0003: \********************************************************************
 268: 0003: \********************************************************************
 269: 0003: 
 270: 0003: \********************************************************************
 271: 0003: \********************************************************************
 272: 0003: \***
 273: 0003: \***    Module Overview
 274: 0003: \***    ---------------
 275: 0003: \***
 276: 0003: \***      Boots.com Parcel Management Screen
 277: 0003: \***
 278: 0003: \***      Screen program to display all parcels in the BDCP file with
 279: 0003: \***      their curren status. Program allows modification of parcel
 280: 0003: \***      status from InStore to either collected/lost/returned.
 281: 0003: \***
 282: 0003: \***      A parcel with a 'Lost' status can be modified back to
 283: 0003: \***      InStore with a found date/time.
 284: 0003: \***
 285: 0003: \***      If a parcel status has been modified externally (till?)
 286: 0003: \***      then the program will NOT change the record but redisplay
 287: 0003: \***      the new status with an information message.
 288: 0003: \***
 289: 0003: \********************************************************************
 290: 0003: \********************************************************************
 291: 0003: 
 292: 0003: \********************************************************************
 293: 0003: \***
 294: 0003: \***    Function globals
 295: 0003: \***
 296: 0003: \********************************************************************
 297: 0003: 
 298: 0003:    %INCLUDE PSBF01G.J86         ! Application Logging
 299: 0003: REM \
 300: 0003: \*******************************************************************************
 301: 0003: \*******************************************************************************
 302: 0003: \***
 303: 0003: \***       %INCLUDE FOR GLOBAL DEFINITIONS FOR FUNCTION APPLICATION.LOG
 304: 0003: \***
 305: 0003: \***                FUNCTION NUMBER    : PSBF01
 306: 0003: \***
 307: 0003: \***                REFERENCE          : PSBF01G.J86
 308: 0003: \***
 309: 0003: \***                DATE OF LAST AMENDMENT  - 27/2/86
 310: 0003: \***
 311: 0003: \***
 312: 0003: \*******************************************************************************
 313: 0003: 
 314: 0003:       INTEGER GLOBAL  F01.RETURN.CODE%
 315: 0003: 
 316: 0003: 
 317: 0003:    %INCLUDE PSBF02G.J86         ! Reusable Function (UPDATE.DATE)       !DDM
 318: 0003: REM\
 319: 0003: \*******************************************************************************
 320: 0003: \*******************************************************************************
 321: 0003: \***
 322: 0003: \***        INCLUDE       : UPDATE.DATE globals
 323: 0003: \***
 324: 0003: \***        REFERENCE     : PSBF02G.J86
 325: 0003: \***
 326: 0003: \***        Version A     Bruce Scriver      4th March 1986
 327: 0003: \*** 
 328: 0003: \***        Version B     Andrew Wedgeworth   6th July 1992
 329: 0003: \***        Removal of return code field which no longer required.
 330: 0003: \***
 331: 0003: \*******************************************************************************
 332: 0003: \*******************************************************************************
 333: 0003: 
 334: 0003:       STRING   GLOBAL F02.DATE$
 335: 0003: 
 336: 0003:       ! 1 line deleted from here                                       ! BAW
 337: 0003: 
 338: 0003:    %INCLUDE PSBF20G.J86         ! Sess Num Utility
 339: 0003: REM\
 340: 0003: \*******************************************************************************
 341: 0003: \*******************************************************************************
 342: 0003: \***
 343: 0003: \***     %INCLUDE GLOBAL VARIABLE DEFINITIONS FOR SESS.NUM.UTILITY FUNCTION
 344: 0003: \***
 345: 0003: \***                       REFERENCE     : PSBF20G.J86
 346: 0003: \*** 
 347: 0003: \***     Version A              Bruce Scrive                   5th May 1988   
 348: 0003: \*** 
 349: 0003: \***     Version B              Robert Cowey                   7th May 1991
 350: 0003: \***     Global variable F20.INTEGER.FILE.NO% changed from one byte integer
 351: 0003: \***     to two byte integer.
 352: 0003: \***
 353: 0003: \***     Version D              Andrew Wedgeworth             1st July 1992
 354: 0003: \***     F20.RETURN.CODE% removed as it is no longer required.
 355: 0003: \***
 356: 0003: \*******************************************************************************
 357: 0003: \*******************************************************************************
 358: 0003: 
 359: 0003:       STRING    GLOBAL F20.FILE.NAME$,                                 \
 360: 0003:                        F20.STRING.FILE.NO$,                            \
 361: 0003:                        F20.TABLE.DIMENSIONED.FLAG$,                    \
 362: 0003:                        SESS.NUM.TABLE$(1)
 363: 0003: 
 364: 0003:       INTEGER*2 GLOBAL F20.INTEGER.FILE.NO%
 365: 0003: 
 366: 0003:       ! 1 line deleted from here                                       ! DAW 
 367: 0003: 
 368: 0003:    %INCLUDE PSBF39G.J86         ! New DM Functions
 369: 0003: !******************************************************************************
 370: 0003: !******************************************************************************
 371: 0003: !***
 372: 0003: !***            PROGRAM         :       PSBF39G.J86
 373: 0003: !***
 374: 0003: !***            DESCRIPTION     :       DISPLAY MANAGER INTERFACE
 375: 0003: !***
 376: 0003: !***            AUTHOR          :       Stuart William McConnachie
 377: 0003: !***            DATE WRITTEN    :       September 2000
 378: 0003: !***
 379: 0003: !***        Provides a much needed and easier to use interface to
 380: 0003: !***        IBM Display Manager.
 381: 0003: !***
 382: 0003: !***        Saves the user having to set up, highlight, tab between and
 383: 0003: !***        validate fields.  Also handles the help screens and conversion
 384: 0003: !***        of date fields to external/internal format.
 385: 0003: !***
 386: 0003: !******************************************************************************
 387: 0003: !******************************************************************************
 388: 0003:     
 389: 0003:     STRING GLOBAL       MESSAGE$(1)
 390: 0003:     STRING GLOBAL       VALID$(1)
 391: 0003:     STRING GLOBAL       VISIBLE$(1)
 392: 0003:     STRING GLOBAL       FIELD$(1)
 393: 0003:     STRING GLOBAL       TITLE$
 394: 0003: 
 395: 0003:     INTEGER*2 GLOBAL    DM.SCREEN%
 396: 0003:     INTEGER*2 GLOBAL    DM.FIELD%
 397: 0003:     
 398: 0003:     INTEGER*2 GLOBAL    HOME.KEY%
 399: 0003:     INTEGER*2 GLOBAL    END.KEY%
 400: 0003:     INTEGER*2 GLOBAL    PGUP.KEY%
 401: 0003:     INTEGER*2 GLOBAL    PGDN.KEY%
 402: 0003:     INTEGER*2 GLOBAL    TAB.KEY%
 403: 0003:     INTEGER*2 GLOBAL    BTAB.KEY%
 404: 0003:     INTEGER*2 GLOBAL    UP.KEY%
 405: 0003:     INTEGER*2 GLOBAL    DOWN.KEY%
 406: 0003:     INTEGER*2 GLOBAL    ESC.KEY%
 407: 0003:     INTEGER*2 GLOBAL    ENTER.KEY%
 408: 0003:     INTEGER*2 GLOBAL    INS.KEY%
 409: 0003:     INTEGER*2 GLOBAL    PREV.KEY%
 410: 0003:     INTEGER*2 GLOBAL    NEXT.KEY%
 411: 0003:         
 412: 0003:     INTEGER*2 GLOBAL    F1.KEY%
 413: 0003:     INTEGER*2 GLOBAL    F2.KEY%
 414: 0003:     INTEGER*2 GLOBAL    F3.KEY%
 415: 0003:     INTEGER*2 GLOBAL    F4.KEY%
 416: 0003:     INTEGER*2 GLOBAL    F5.KEY%
 417: 0003:     INTEGER*2 GLOBAL    F6.KEY%
 418: 0003:     INTEGER*2 GLOBAL    F7.KEY%
 419: 0003:     INTEGER*2 GLOBAL    F8.KEY%
 420: 0003:     INTEGER*2 GLOBAL    F9.KEY%
 421: 0003:     INTEGER*2 GLOBAL    F10.KEY%
 422: 0003:                 
 423: 0003: !******************************************************************************
 424: 0003: 
 425: 0003:    %INCLUDE PSBUSEG.J86         ! Chain parameters
 426: 0003: \/*********************************************************************/ PSBUSEG
 427: 0003: \/*                                                                   */ PSBUSEG
 428: 0003: \/* PSBUSEG.J86  -  Definitions for Chain/Use with PSB Screen Program */ PSBUSEG
 429: 0003: \/* ----------------------------------------------------------------- */ PSBUSEG
 430: 0003: \/*                                                                   */ PSBUSEG
 431: 0003: \/*********************************************************************/ PSBUSEG
 432: 0003:                                                                        ! PSBUSEG
 433: 0003:         STRING GLOBAL  PSBCHN.PRG,      \ Program to chain to          ! PSBUSEG
 434: 0003:                        PSBCHN.OP,       \ Operator Id                  ! PSBUSEG
 435: 0003:                        PSBCHN.APP,      \ Program chained from         ! PSBUSEG
 436: 0003:                        PSBCHN.MENCON,   \ Menu Control                 ! PSBUSEG
 437: 0003:                        PSBCHN.U1,       \ User parameter               ! PSBUSEG
 438: 0003:                        PSBCHN.U2,       \ User parameter               ! PSBUSEG
 439: 0003:                        PSBCHN.U3        ! User parameter               ! PSBUSEG
 440: 0003:                                                                        ! PSBUSEG
 441: 0003: 
 442: 0003:    %INCLUDE BDCPDEC.J86         ! Boots.com Parcel File
 443: 0003: \******************************************************************************
 444: 0003: \******************************************************************************
 445: 0003: \***
 446: 0003: \***           FILE DECLARATIONS Boots.com Parcel File (BDCP)
 447: 0003: \***
 448: 0003: \***           REFERENCE:   BDCPDEC.J86
 449: 0003: \***
 450: 0003: \***           VERSION A         Neil Bennett          19th May 2010
 451: 0003: \***
 452: 0003: \***           VERSION B         Dave Constable        7th March 2016
 453: 0003: \***           PRJ1361- Order & Collect Parcel Management
 454: 0003: \***           Initial version for User Story PMLA-17 & PMLA-58 to allow
 455: 0003: \***           Location access for Parcels by controller and till for
 456: 0003: \***           Boots.com/ie order parcels.
 457: 0003: \***
 458: 0003: \***           VERSION C         Lino Jacob            8th April 2016
 459: 0003: \***           PRJ1361- Order & Collect Parcel Management
 460: 0003: \***           Incorporated Code review comments of Sprint 1
 461: 0003: \***
 462: 0003: \***           VERSION D         Christopher Kitto     28th June 2016
 463: 0003: \***           PRJ1361- Order & Collect Parcel Management
 464: 0003: \***           User story PMLA-146 - Incorporated review comments
 465: 0003: \***               - Removed commented out line of codes
 466: 0003: \***
 467: 0003: \***           VERSION E         Kiran Krishnan         21st July 2017
 468: 0003: \***           PRJ2002 - Order & Collect Phase 2
 469: 0003: \***           User story PMLA 341 - Added variables for new returns 
 470: 0003: \***           list ID,file function form variables and file open flag
 471: 0003: \***
 472: 0003: \*******************************************************************************
 473: 0003: \*******************************************************************************
 474: 0003: 
 475: 0003: STRING GLOBAL                          \
 476: 0003:        BDCP.CARTON$,                   \  4 bytes ASC 8 digit consignment number
 477: 0003:        BDCP.COL.DATETIME$,             \  6 bytes UPD Collected date/time
 478: 0003:        BDCP.COL.EXPORTED$,             \  1 bytes ASC Y/N
 479: 0003:        BDCP.DEL.DATETIME$,             \  6 bytes UPD Delivery date/time
 480: 0003:        BDCP.DEL.EXPORTED$,             \  1 bytes ASC Y/N
 481: 0003:        BDCP.EXPECT.DATE$,              \  3 bytes UPD Expected Delivery Date
 482: 0003:        BDCP.FILE.NAME$,                \
 483: 0003:        BDCP.FILLER$,                   \  42 bytes filler
 484: 0003:        BDCP.FND.DATETIME$,             \  6 bytes UPD Found date/time
 485: 0003:        BDCP.FND.EXPORTED$,             \  1 bytes ASC Y/N
 486: 0003:        BDCP.KEY$,                      \  7 bytes UPD Supp + Carton     !CLJ
 487: 0003:        BDCP.LST.DATETIME$,             \  6 bytes UPD Lost date/time
 488: 0003:        BDCP.LST.EXPORTED$,             \  1 bytes ASC Y/N
 489: 0003:        BDCP.ORDER$,                    \  5 bytes UPD Boots.com order number
 490: 0003:        BDCP.READ.FORM$,                \  Format for reading BDCP data  !EKK
 491: 0003:        BDCP.RET.DATETIME$,             \  6 bytes UPD Returned date/time
 492: 0003:        BDCP.RET.EXPORTED$,             \  1 bytes ASC Y/N
 493: 0003:        BDCP.RETURNS.LISTID$,           \  3 bytes Returns listID        !EKK
 494: 0003:        BDCP.STATUS$,                   \  1 bytes ASC Current status
 495: 0003:        BDCP.SUPPLIER$,                 \  3 bytes UPD Supplier Number   !EKK
 496: 0003:        BDCP.WRITE.FORM$                !  Format for writing BDCP data  !EKK
 497: 0003: 
 498: 0003: INTEGER*1 GLOBAL                       \
 499: 0003:        BDCP.COL.RC%,                   \  1 byte  INT 0 - Till, 
 500: 0003:                                        \  1 - Controller                !EKK
 501: 0003:        BDCP.OPEN                       ! Flag for file open tracking    !EKK
 502: 0003: INTEGER*2 GLOBAL                       \
 503: 0003:        BDCP.KEYL%,                     \
 504: 0003:        BDCP.LOC.CURRENT%,              \  2 byte INT current location # !CLJ
 505: 0003:        BDCP.LOC.STATUS%,               \  2 byte INT loc change status  !CLJ
 506: 0003:        BDCP.RECL%,                     \
 507: 0003:        BDCP.REPORT.NUM%,               \
 508: 0003:        BDCP.SESS.NUM%                  !
 509: 0003: 
 510: 0003: 
 511: 0003:    %INCLUDE CRTNDEC.J86         ! Directs Carton File                   !AGCS
 512: 0003: \/******************************************************************/
 513: 0003: \/*                                                                */
 514: 0003: \/* CARTON FILE GLOBAL VARIABLE DECLARATIONS                       */
 515: 0003: \/*                                                                */
 516: 0003: \/* REFERENCE   : CRTNDEC.J86                                      */
 517: 0003: \/*                                                                */
 518: 0003: \/* VERSION A.          Neil Bennett.           12 DECEMBER 2006   */
 519: 0003: \/*                                                                */
 520: 0003: \/* VERSION B.          Arun Sudhakaran.        10 APRIL 2013      */
 521: 0003: \/* Added new variables for including CRTN field positions and     */
 522: 0003: \/* lengths as part of Automatic Booking In of Chilled Food        */
 523: 0003: \/* ASNs project                                                   */
 524: 0003: \/*                                                                */
 525: 0003: \/* Version C.          Ramya Rajendran.        10/06/2016         */
 526: 0003: \/* SC106  - Retail Stock 6                                        */
 527: 0003: \/* Added new variable 'SAP order number'                          */
 528: 0003: \/*                                                                */
 529: 0003: \/******************************************************************/
 530: 0003: 
 531: 0003:    STRING GLOBAL                \
 532: 0003:       CRTN.ASN.CODE$,           \ ASC 35
 533: 0003:       CRTN.BUS.CNTR$,           \ ASC  1
 534: 0003:       CRTN.DEL.DTTM$,           \ ASC 12 (CCYYMMDDHHmm)
 535: 0003:       CRTN.FILE.NAME$,          \
 536: 0003:       CRTN.FILLER$,             \ ASC 22                            !CRR
 537: 0003:       CRTN.ITEM.CNT$,           \ ASC  3
 538: 0003:       CRTN.ITEM.CODE$(1),       \ PD 3
 539: 0003:       CRTN.NO$,                 \ PD 4
 540: 0003:       CRTN.ORD.NO$,             \ ASC  5
 541: 0003:       CRTN.ORD.SUFFIX$,         \ ASC  1
 542: 0003:       CRTN.SAP.ORDER.NUM$,      \ ASC 10                            !CRR
 543: 0003:       CRTN.STATUS$,             \ ASC 1
 544: 0003:       CRTN.SUPPLIER$            ! PD 3                              !CRR
 545: 0003: 
 546: 0003:    INTEGER*2 GLOBAL             \
 547: 0003:       CHAIN.OFFSET%,            \ CHAIN% field offset               !BAS
 548: 0003:       CRTN.DESP.QTY%(1),        \
 549: 0003:       CRTN.IN.QTY%(1),          \
 550: 0003:       CRTN.NO.KEY.LEN%,         \ CARTON.NO$ field length           !BAS
 551: 0003:       CRTN.NO.KEY.OFFSET%,      \ CARTON.NO$ field offset           !BAS
 552: 0003:       CRTN.RECL%,               \
 553: 0003:       CRTN.REPORT.NUM%,         \
 554: 0003:       CRTN.SESS.NUM%,           \
 555: 0003:       DELIVERY.DATE.LEN%,       \ Length of delivery date           !BAS
 556: 0003:       DELIVERY.DATE.OFFSET%,    \ Offset of delivery date           !BAS
 557: 0003:       STATUS.LEN%,              \ STATUS$ field length              !BAS
 558: 0003:       STATUS.OFFSET%,           \ STATUS$ field offset              !BAS
 559: 0003:       SUPPLIER.NUMBER.LEN%,     \ SUPPLIER$ field length            !BAS
 560: 0003:       SUPPLIER.NUMBER.OFFSET%   ! SUPPLIER$ field offset            !BAS
 561: 0003: 
 562: 0003:    INTEGER*1 GLOBAL             \
 563: 0003:       CRTN.CHAIN%               !
 564: 0003: 
 565: 0003: \/******************************************************************/
 566: 0003: 
 567: 0003:    %INCLUDE PSUTQDEC.J86        ! Parcel Status Update Transaction File !AICS
 568: 0003: \******************************************************************************
 569: 0003: \******************************************************************************
 570: 0003: \***
 571: 0003: \***      FILE DECLARATION FOR PARCEL STATUS UPDATE TRANSACTION 
 572: 0003: \***      QUEUE FILE
 573: 0003: \***
 574: 0003: \***               FILE TYPE    : Sequential
 575: 0003: \***
 576: 0003: \***               REFERENCE    : PSUTQDEC.J86
 577: 0003: \***
 578: 0003: \***         VERSION A         Kiran Krishnan        27th July 2017
 579: 0003: \***         PRJ2002- Order & Collect Parcel Management - Phase 2
 580: 0003: \***         Initial version for User Story PMLA-377 
 581: 0003: \***
 582: 0003: \******************************************************************************
 583: 0003: \*******************************************************************************
 584: 0003: \***
 585: 0003: \***  The length of the records on this file vary depending on the record
 586: 0003: \***  transaction type, but they all comprise combinations of the fields
 587: 0003: \***  defined below.
 588: 0003: \***
 589: 0003: \***  Transaction type 5 - 
 590: 0003: \***
 591: 0003: \******************************************************************************
 592: 0003: 
 593: 0003:     STRING GLOBAL               \
 594: 0003:       PSUTQ.FILE.NAME$,         \ PSUTQ File Name
 595: 0003:       PSUTQ.RECORD$,            \ Used to store the whole PSUTQ record
 596: 0003:       PSUTQ.RECORD.DELIMITER$,  \ 1 byte ASCII set to " (CHR$(34))
 597: 0003:       PSUTQ.TRANS.TYPE$,        \ 1 byte UPD. 05 = Parcel return
 598: 0003:       PSUTQ.FIELD.DELIMITER$    \ 1 byte ASCII set to ; (CHR$(59))
 599: 0003:       
 600: 0003:     INTEGER*1 GLOBAL           \
 601: 0003:        PSUTQ.OPEN
 602: 0003:                                                                           
 603: 0003:     INTEGER*2 GLOBAL            \
 604: 0003:        PSUTQ.REPORT.NUM%,       \
 605: 0003:        PSUTQ.SESS.NUM%          
 606: 0003:        
 607: 0003:     
 608: 0003:        
 609: 0003: 
 610: 0003:    %INCLUDE SOFTSDEC.J86        ! Software Status File                  !DDM
 611: 0003: REM \
 612: 0003: \******************************************************************************
 613: 0003: \******************************************************************************
 614: 0003: \***
 615: 0003: \***                 %INCLUDE FOR THE SOFTWARE STATUS FILE
 616: 0003: \***   
 617: 0003: \***                      FILE TYPE  :   Direct
 618: 0003: \***
 619: 0003: \***                      REFERENCE  :   SOFTSDEC.J86
 620: 0003: \***
 621: 0003: \***	Version A	       Andrew Wedgeworth	      24th June 1992
 622: 0003: \***
 623: 0003: \******************************************************************************
 624: 0003: \*******************************************************************************
 625: 0003: 
 626: 0003:   STRING GLOBAL           \
 627: 0003:     SOFTS.RECORD$,        \           
 628: 0003:     SOFTS.SPACE$,         \           
 629: 0003:     SOFTS.FILE.NAME$    
 630: 0003:     
 631: 0003:   INTEGER*2 GLOBAL        \
 632: 0003:     SOFTS.RECL%,          \            
 633: 0003:     SOFTS.REPORT.NUM%,	  \      
 634: 0003:     SOFTS.SESS.NUM%
 635: 0003: 
 636: 0003:   INTEGER*4 GLOBAL        \
 637: 0003:     SOFTS.REC.NUM% 	         
 638: 0003: 
 639: 0003: \********************************************************************
 640: 0003: \***
 641: 0003: \***    PSD8500 variables
 642: 0003: \***
 643: 0003: \********************************************************************
 644: 0003: 
 645: 0003:    INTEGER*2 GLOBAL CURRENT.REPORT.NUM%
 646: 0003:    INTEGER*2 GLOBAL SB.FILE.REP.NUM%
 647: 0003:    INTEGER*2 GLOBAL SB.FILE.SESS.NUM%
 648: 0003:    INTEGER*2 GLOBAL SB.INTEGER%
 649: 0003: 
 650: 0003:    STRING    GLOBAL BATCH.SCREEN.FLAG$
 651: 0003:    STRING    GLOBAL CURRENT.CODE$
 652: 0003:    STRING    GLOBAL FILE.OPERATION$
 653: 0003:    STRING    GLOBAL MODULE.NUMBER$
 654: 0003:    STRING    GLOBAL OPERATOR.NUMBER$
 655: 0003:    STRING    GLOBAL SB.ACTION$
 656: 0003:    STRING    GLOBAL SB.FILE.NAME$
 657: 0003:    STRING    GLOBAL SB.STRING$
 658: 0003: 
 659: 0003:    INTEGER*1 CARTON.FILE.ERROR    ! TRUE if CARTON file error           !AHCS
 660: 0003:    INTEGER*1 FALSE                ! Flag for SOFTS value check          !DDM
 661: 0003:    INTEGER*1 LOC.STATUS.CHANGED   ! Boolean                             !LLJ
 662: 0003:    INTEGER*1 PRINT.KEY            ! Flag for Print key Check            !FMM
 663: 0003:    INTEGER*1 PSUTQ.FILE.ERROR     ! TRUE if PSUTQ file error            !AICS
 664: 0003: 
 665: 0003:    INTEGER*1 SCREEN.COMPLETE
 666: 0003:    INTEGER*1 SOFTS.LIMIT.VAL.FOUND! Flag variable                       !DDM
 667: 0003:    INTEGER*1 SOFTS.OPEN           ! Boolean                             !DDM
 668: 0003:    INTEGER*1 TRUE                 ! Flag for SOFTS value check          !DDM
 669: 0003: 
 670: 0003:    INTEGER*1 bdcp.open%
 671: 0003:    INTEGER*1 CRTN.OPEN                                                  !AGCS
 672: 0003:    INTEGER*1 f.key%
 673: 0003:    INTEGER*1 file.loaded%
 674: 0003:    INTEGER*1 mismatch%
 675: 0003: 
 676: 0003:    INTEGER*2 DAYS.UNCOLLECTED%    ! No. of uncollected days             !DDM
 677: 0003:    INTEGER*2 EVENT.NUMBER%
 678: 0003:    INTEGER*2 LIMIT.LENGTH%        ! Length of the extracted days value  !DDM
 679: 0003:    INTEGER*2 MATCH.POS%           ! To find the position                !DDM
 680: 0003:    INTEGER*2 MESSAGE.NUMBER%
 681: 0003:    INTEGER*2 RET.KEY%
 682: 0003:    INTEGER*2 TEMP.REPORT.NUM%     ! Temporary report number for message !AICS
 683: 0003: 
 684: 0003:    INTEGER*2 blk.size%
 685: 0003:    INTEGER*2 i%
 686: 0003:    INTEGER*2 indx%
 687: 0003:    INTEGER*2 j%
 688: 0003:    INTEGER*2 k%
 689: 0003:    INTEGER*2 last.blk%
 690: 0003:    INTEGER*2 lpp1%
 691: 0003:    INTEGER*2 max.scrn1%
 692: 0003:    INTEGER*2 num.blks%
 693: 0003:    INTEGER*2 num.recs%
 694: 0003:    INTEGER*2 num.sect%
 695: 0003:    INTEGER*2 p.cnt%
 696: 0003:    INTEGER*2 rc%
 697: 0003:    INTEGER*2 scrn1%
 698: 0003: 
 699: 0003:    STRING    ADX.MESSAGE$         ! Parameter Message                   !DDM
 700: 0003:    STRING    ADX.NAME$            ! Program name                        !DDM
 701: 0003:    STRING    ADX.PARM$            ! Parameter value                     !DDM
 702: 0003:    STRING    BLANK.MSG$           ! To clear the status message field   !MLJ
 703: 0003:    STRING    COMMA$               ! Comma as field delimiter            !AKKK
 704: 0003:    STRING    CHAINING.TO.PROG$
 705: 0003:    STRING    CURRENT.DATE$        ! Stores current date                 !DDM
 706: 0003:    STRING    FILE.NO$
 707: 0003:    STRING    LIMIT.STR$           ! To parse days uncollected value     !DDM
 708: 0003: 
 709: 0003:    STRING    PSUTQ.CURROP$        ! Holds PSUTQ Current Operation       !AICS
 710: 0003:    STRING    PSUTQ.CURR.LOCON$    ! Holds current  parcel location      !AICS
 711: 0003:    STRING    PSUTQ.PREV.LOCON$    ! Holds previous parcel location      !AICS
 712: 0003:    STRING    RETURN.BY.DATE$      ! Delivery/found date+Uncollected days!DDM
 713: 0003:    STRING    SAVED.ARRAY$         ! Saved array element for rollback    !AHCS
 714: 0003:    STRING    SAVED.BDCP.STATUS$   ! Saved BDCP fields for rollback      !AHCS
 715: 0003:    STRING    SAVED.BDCP.DEL.DATETIME$                                   !AHCS
 716: 0003:    STRING    SAVED.BDCP.DEL.EXPORTED$                                   !AHCS
 717: 0003: 
 718: 0003:    STRING    SCREEN.TITLE$        ! To store the screen title           !GCK
 719: 0003:    STRING    SCREEN2.TITLE$       ! To store the locations screen title !HDC
 720: 0003:    STRING    SOFTS.REC.LABEL$     ! To store the ROI store label(EIRE)  !GCK
 721: 0003:    STRING    STATUS.SORT.ORDER$   ! To store the sort order for status  !FMM
 722: 0003:    STRING    VAR.STRING.1$
 723: 0003:    STRING    VAR.STRING.2$
 724: 0003:    STRING    WORK.SOFTS.RECORD$   ! Holds extracted string              !DDM
 725: 0003: 
 726: 0003:    STRING    blk$
 727: 0003:    STRING    d.dt$
 728: 0003:    STRING    form$
 729: 0003:    STRING    p.arr$(1)
 730: 0003:    STRING    p1$
 731: 0003:    STRING    p2$
 732: 0003:    STRING    p3$
 733: 0003:    STRING    p4$
 734: 0003:    STRING    p5$
 735: 0003:    STRING    p6$
 736: 0003:    STRING    page$
 737: 0003:    STRING    rcd$
 738: 0003:    STRING    sect$
 739: 0003:    STRING    wk$
 740: 0003:    STRING    x.dt$
 741: 0003: 
 742: 0003: \***********************************************************************!HDC
 743: 0003: \***                                                                    !HDC
 744: 0003: \***    Variables added for location management                         !HDC
 745: 0003: \***                                                                    !HDC
 746: 0003: \***********************************************************************!HDC
 747: 0003:     STRING      F10.MESSAGE$                                            !RLJ
 748: 0003:     STRING      LOCATION.ARRAY$(1)                                      !HDC
 749: 0003:     STRING      ORDERS.OFFSET$                                          !HDC
 750: 0003:     STRING      P7$, P8$                                                !HDC
 751: 0003:     STRING      PAGE2$                                                  !HDC
 752: 0003:     STRING      PROMPT.MESSAGE$                                         !JDC
 753: 0003:     STRING      TITLE.END1$                                             !KDC
 754: 0003:     STRING      TITLE.END2$                                             !KDC
 755: 0003:     STRING      TITLE.START$                                            !JDC
 756: 0003: 
 757: 0003:     ! litterals for function key text                                   !IDC
 758: 0003:     STRING      ACTIVATE.FN.TEXT$                                       !IDC
 759: 0003:     STRING      DEACTIVATE.FN.TEXT$                                     !IDC
 760: 0003:     STRING      LOCATION.FN.TEXT$                                       !IDC
 761: 0003:     STRING      LOCATION1.DESC$                                         !RLJ
 762: 0003:                                                                         !IDC
 763: 0003:     INTEGER*1   ACTIVE.TO.BE.SAVED                                      !OLJ
 764: 0003:     INTEGER*1   ANY.CHANGES.DONE                                        !RLJ
 765: 0003:     INTEGER*1   BDCO.OPEN%                                              !HDC
 766: 0003:     INTEGER*1   CHANGE.ACCEPTED      ! Checks if field change accepted  !ZCK
 767: 0003:     INTEGER*1   CONFIRM.PROMPT                                          !NLJ
 768: 0003:     INTEGER*1   ERROR.ON.LOCATION    ! Flag to check if there is error  !TAH
 769: 0003:     INTEGER*1   F10.NOT.ALLOWED                                         !IDC
 770: 0003:     INTEGER*1   INITIAL.FIELD.INDEX% ! Default location field index     !TAH
 771: 0003:     INTEGER*1   KEY.ACTION%          ! 1 - F6, 2 - BTab/Up, 3 - Tab/Down!ADCK
 772: 0003:     INTEGER*1   MANAGE.LOCATION                                         !HDC
 773: 0003:     INTEGER*1   NOT.DEFAULT.LOCATION ! To check if default location     !TAH
 774: 0003:     INTEGER*1   RC.INT1%                                                !OLJ
 775: 0003:     INTEGER*1   SCREEN.CHANGED       ! Flag to check if screen changed  !TAH
 776: 0003:     INTEGER*1   SCREEN.COMPLETE2                                        !HDC
 777: 0003:     INTEGER*1   VALID.CHANGE                                            !RLJ
 778: 0003: 
 779: 0003:     INTEGER*2   CURRENT.INDEX%       ! Current location index of field  !UCK
 780: 0003:     INTEGER*2   CURRENT.LOCATION%    ! To check current location field  !TAH
 781: 0003:     INTEGER*2   CURRENT.ORDER.I%                                        !HDC
 782: 0003:     INTEGER*2   CURRENT.ORDER.INDX%                                     !HDC
 783: 0003:     INTEGER*2   CURRENT.SCREEN%                                         !IDC
 784: 0003:     INTEGER*2   INACTIVE.CHECK%                                         !SAH
 785: 0003:     INTEGER*2   LPP2%                                                   !HDC
 786: 0003:     INTEGER*2   LOC.ARRAY.LIMIT%                                        !HDC
 787: 0003:     INTEGER*2   LOC.FIELDS.PER.LINE%                                    !HDC
 788: 0003:     INTEGER*2   LOC.FIELDS.START%                                       !HDC
 789: 0003:     INTEGER*2   LOC.RECORDS.ON.PAGE%                                    !RLJ
 790: 0003:     INTEGER*2   LOCATION.NEW%                                           !HDC
 791: 0003:     INTEGER*2   LOCATION.STATUS.NEW%                                    !IDC
 792: 0003:     INTEGER*2   MAX.PARCELS%                                            !HDC
 793: 0003:     INTEGER*2   MAX.SCRN2%                                              !HDC
 794: 0003:     INTEGER*2   ORDERS.OFFSET%                                          !HDC
 795: 0003:     INTEGER*2   ORDER.PARCELS%(2)                                       !HDC
 796: 0003:     INTEGER*2   P.CNT2%                                                 !HDC
 797: 0003:     INTEGER*2   P.FULL%                                                 !HDC
 798: 0003:     INTEGER*2   PARCEL.COUNT%                                           !LLJ
 799: 0003:     INTEGER*2   SCRN2%                                                  !HDC
 800: 0003:     INTEGER*2   TMP.LOCATION%                                           !HDC
 801: 0003: 
 802: 0003: 
 803: 0003: \********************************************************************   !HDC
 804: 0003: \***                                                                    !HDC
 805: 0003: \***    Variables added for loaction file                               !HDC
 806: 0003: \***                                                                    !HDC
 807: 0003: \********************************************************************   !HDC
 808: 0003: %INCLUDE BDCLODEC.J86                                                   !HDC
 809: 0003: \******************************************************************************
 810: 0003: \******************************************************************************
 811: 0003: \***
 812: 0003: \***           FILE DECLARATIONS Boots.com Location File (BDCLOCON)
 813: 0003: \***
 814: 0003: \***           REFERENCE:   BDCLODEC.J86
 815: 0003: \***
 816: 0003: \***           VERSION A         Dave Constable        7th March 2016
 817: 0003: \***           PRJ1361- Order & Collect Parcel Management
 818: 0003: \***           Initial version for User Story PMLA-17 & PMLA-58 to allow
 819: 0003: \***           Location access for Parcels by controller and till for
 820: 0003: \***           Boots.com/ie order parcels.
 821: 0003: \***
 822: 0003: \***           VERSION B         Lino Jacob           11th April 2016
 823: 0003: \***           PRJ1361- Order & Collect Parcel Management
 824: 0003: \***           - User Story PMLA-16 : To disallow the deactivation of
 825: 0003: \***             locations if there are parcels available at that
 826: 0003: \***             location - Added a new field to hold count of parcels
 827: 0003: \***
 828: 0003: \*******************************************************************************
 829: 0003: \*******************************************************************************
 830: 0003: 
 831: 0003: \********************************************************************
 832: 0003: \*** file variables
 833: 0003: \********************************************************************
 834: 0003:     INTEGER*1   GLOBAL  BDCLOCON.OPEN
 835: 0003: 
 836: 0003:     INTEGER*2   GLOBAL  BDCLOCON.RECL%
 837: 0003:     INTEGER*2   GLOBAL  BDCLOCON.REPORT.NUM%
 838: 0003:     INTEGER*2   GLOBAL  BDCLOCON.SESS.NUM%
 839: 0003: 
 840: 0003:     INTEGER*4   GLOBAL  BDCLOCON.TOTAL.RECORDS%
 841: 0003: 
 842: 0003:     STRING      GLOBAL  BDCLOCON.FILE.NAME$
 843: 0003:     STRING      GLOBAL  BDCLOCON.FILLER$
 844: 0003:     STRING      GLOBAL  BDCLOCON.FORM$
 845: 0003:     STRING      GLOBAL  BDCLOCON.LAST$
 846: 0003:     STRING      GLOBAL  BDCLOCON.TEXT$
 847: 0003: \********************************************************************
 848: 0003: \*** record variables listed in field order
 849: 0003: \********************************************************************
 850: 0003:     INTEGER*2   GLOBAL  BDCLOCON.RECORD.NUM%    ! record number
 851: 0003:     STRING      GLOBAL  BDCLOCON.LONG.NAME$     ! long location name
 852: 0003:     STRING      GLOBAL  BDCLOCON.SHORT.NAME$    ! short location name
 853: 0003:     STRING      GLOBAL  BDCLOCON.STATUS$        ! active or not
 854: 0003:     INTEGER*2   GLOBAL  BDCLOCON.PARCEL.COUNT%  ! parcel count          !BLJ
 855: 0003: 
 856: 0003: 
 857: 0003: %INCLUDE BDCODEC.J86                                                    !HDC
 858: 0003: \******************************************************************************
 859: 0003: \******************************************************************************
 860: 0003: \***
 861: 0003: \***           FILE DECLARATIONS Boots.com Orders File (BDCO)
 862: 0003: \***
 863: 0003: \***           REFERENCE:   BDCODEC.J86
 864: 0003: \***
 865: 0003: \***           VERSION A         Neil Bennett          19th May 2010
 866: 0003: \***
 867: 0003: \***           VERSION B         Dave Constable        7th March 2016
 868: 0003: \***           PRJ1361- Order & Collect Parcel Management
 869: 0003: \***           Initial version for User Story PMLA-17 & PMLA-58 to allow 
 870: 0003: \***           Location access for Parcels by controller and till for 
 871: 0003: \***           Boots.com/ie order parcels.
 872: 0003: 
 873: 0003: \***    
 874: 0003: \*******************************************************************************
 875: 0003: \*******************************************************************************
 876: 0003: 
 877: 0003: STRING GLOBAL                          \
 878: 0003:        BDCO.FILE.NAME$,                \
 879: 0003:        BDCO.KEY$,                      \                                !BDC
 880: 0003:        BDCO.SUPPLIER$,                 \  3 bytes UPD Supplier Number
 881: 0003:        BDCO.ORDER$,                    \  5 bytes UPD Boots.com order number
 882: 0003:        BDCO.CARTON$(1),                \  4 bytes UPD consignment number (1-55)
 883: 0003:        BDCO.FILLER$                    ! 26 bytes filler
 884: 0003: 
 885: 0003: INTEGER*2 GLOBAL                       \
 886: 0003:        BDCO.NUM.CARTONS%               !  2 bytes count of cartons in rcd max 55
 887: 0003: 
 888: 0003: INTEGER*2 GLOBAL                       \
 889: 0003:        BDCO.KEYL%,                     \
 890: 0003:        BDCO.RECL%,                     \
 891: 0003:        BDCO.SESS.NUM%,                 \
 892: 0003:        BDCO.REPORT.NUM%                !
 893: 0003: 
 894: 0003: \********************************************************************
 895: 0003: \***
 896: 0003: \***    External functions
 897: 0003: \***
 898: 0003: \********************************************************************
 899: 0003: 
 900: 0003:    %INCLUDE PSBF01E.J86        ! APPLICATION LOG
 901: 0003: REM \
 902: 0003: \*******************************************************************************
 903: 0003: \*******************************************************************************
 904: 0003: \***
 905: 0003: \***      %INCLUDE FOR EXTERNAL DEFINITION OF FUNCTION APPLICATION.LOG
 906: 0003: \***
 907: 0003: \***                      FUNCTION NUMBER   : PSBF01
 908: 0003: \***
 909: 0003: \***                    INCLUDE REFERENCE : PSBF01E.J86
 910: 0003: \*** 
 911: 0003: \***      Version B           Andrew Wedgeworth          1st July 1992
 912: 0003: \***      Three parameters which passed to the function have been removed.
 913: 0003: \***      APPLICATION.LOG has been added as a variable name (this holds the
 914: 0003: \***      return code).
 915: 0003: \***
 916: 0003: \*******************************************************************************
 917: 0003: 
 918: 0003: 
 919: 0003:    FUNCTION APPLICATION.LOG (MESSAGE.NO%,                                     \
 920: 0003:                              VAR.STRING.1$,                                   \
 921: 0003:                              VAR.STRING.2$,                                   \
 922: 0003:                              EVENT.NO%)  EXTERNAL
 923: 0003: 
 924: 0003:       INTEGER*1 EVENT.NO%
 925: 0003: 
 926: 0003:       INTEGER*2 APPLICATION.LOG,                                       \ GAW
 927: 0003:                 MESSAGE.NO%
 928: 0003: 
 929: 0003:       STRING VAR.STRING.1$,                                            \
 930: 0003:              VAR.STRING.2$
 931: 0003: 
 932: 0003:    END FUNCTION
 933: 0003: 
 934: 0003: \*******************************************************************************
 935: 0003:    %INCLUDE PSBF02E.J86        ! Reusable function (UPDATE.DATE)        !DDM
 936: 0003: REM\
 937: 0003: \*******************************************************************************
 938: 0003: \*******************************************************************************
 939: 0003: \***
 940: 0003: \***        INCLUDE       : UPDATE.DATE external definition
 941: 0003: \***        AUTHOR        : Bruce Scriver (Basic Code)
 942: 0003: \***        DATE WRITTEN  : 4th March 1986 (Basic Code)
 943: 0003: \***
 944: 0003: \***        REFERENCE     : PSBF02E.J86
 945: 0003: \***
 946: 0003: \***        Version A     Bruce Scriver          4th March 1986
 947: 0003: \***
 948: 0003: \***        Version B     Andrew Wedgeworth       6th July 1992
 949: 0003: \***        Removal of redundant parameters, and inclusion of UPDATE.DATE as
 950: 0003: \***        a variable to hold the return code.
 951: 0003: \***
 952: 0003: \*******************************************************************************
 953: 0003: \*******************************************************************************
 954: 0003: 
 955: 0003:    FUNCTION UPDATE.DATE (INCREMENT%)                                   \
 956: 0003:    EXTERNAL
 957: 0003:    ! 3 parameters removed from here                                    ! BAW
 958: 0003: 
 959: 0003:    ! 3 lines deleted from here                                         ! BAW
 960: 0003:    
 961: 0003:       INTEGER*2 UPDATE.DATE                                            ! BAW
 962: 0003: 
 963: 0003:       INTEGER*4 INCREMENT%
 964: 0003: 
 965: 0003:    END FUNCTION
 966: 0003: 
 967: 0003:    %INCLUDE PSBF20E.J86        ! SESSION NUMBER UTILITY
 968: 0003: REM\
 969: 0003: \*******************************************************************************
 970: 0003: \*******************************************************************************
 971: 0003: \***
 972: 0003: \***       %INCLUDE FOR EXTERNAL DEFINITION OF SESS.NUM.UTILITY
 973: 0003: \***
 974: 0003: \***                  REFERENCE     : PSBF20E.J86
 975: 0003: \***
 976: 0003: \***     VERSION C            Janet Smith                13th May 1992
 977: 0003: \***     Increased PASSED.INTEGER to 2 bytes to cater for more than
 978: 0003: \***     128 files.
 979: 0003: \***
 980: 0003: \***     VERSION D.           Andrew Wedgeworth          1st July 1992
 981: 0003: \***     Removal of redundant parameters and addition of SESS.NUM.UTILITY
 982: 0003: \***     as a variable.  This new variable contains the function's return
 983: 0003: \***     code.
 984: 0003: \***
 985: 0003: \*******************************************************************************
 986: 0003: \*******************************************************************************
 987: 0003: 
 988: 0003:    FUNCTION SESS.NUM.UTILITY (FUNCTION.FLAG$,                          \
 989: 0003:                               PASSED.INTEGER%,                         \
 990: 0003:                               PASSED.STRING$)                          \
 991: 0003:    EXTERNAL
 992: 0003: 
 993: 0003:    STRING    FUNCTION.FLAG$,                                           \
 994: 0003:              PASSED.STRING$
 995: 0003:    ! 3 variables removed from here                                     ! CAW
 996: 0003: 
 997: 0003: 
 998: 0003:    INTEGER*2 SESS.NUM.UTILITY,                                         \ CAW
 999: 0003:              PASSED.INTEGER%				               ! CJAS
1000: 0003: 
1001: 0003:    END FUNCTION
1002: 0003: 
1003: 0003:    %INCLUDE PSBF24E.J86        ! STANDARD ERROR DETECTED
1004: 0003: REM \
1005: 0003: \*******************************************************************************
1006: 0003: \*******************************************************************************
1007: 0003: \***
1008: 0003: \***    %INCLUDE FOR EXTERNAL DEFINITION OF STANDARD.ERROR.DETECTED FUNCTION
1009: 0003: \***
1010: 0003: \***                      REFERENCE     : PSBF24E.J86
1011: 0003: \***
1012: 0003: \***    Version A                 Janet Smith                  13th May 1992
1013: 0003: \***
1014: 0003: \*******************************************************************************
1015: 0003: \*******************************************************************************
1016: 0003: 
1017: 0003:    FUNCTION STANDARD.ERROR.DETECTED(ERRN%,                 \
1018: 0003: 				    ERRFILE%,              \
1019: 0003: 				    ERRL%,                 \
1020: 0003: 				    ERR$)        EXTERNAL
1021: 0003: 				    
1022: 0003:           STRING    ERR$
1023: 0003: 
1024: 0003:           INTEGER*2 ERRFILE%,              \
1025: 0003: 	            ERRL%,                 \
1026: 0003: 		    STANDARD.ERROR.DETECTED
1027: 0003: 		    
1028: 0003:           INTEGER*4 ERRN%
1029: 0003: 	  		    
1030: 0003:    END FUNCTION
1031: 0003: 
1032: 0003: 
1033: 0003:    %INCLUDE PSBF39E.J86        ! Display Manager
1034: 0003: !******************************************************************************
1035: 0003: !******************************************************************************
1036: 0003: !***
1037: 0003: !***            PROGRAM         :       PSBF39E.J86
1038: 0003: !***
1039: 0003: !***            DESCRIPTION     :       DISPLAY MANAGER INTERFACE
1040: 0003: !***
1041: 0003: !***            AUTHOR          :       Stuart William McConnachie
1042: 0003: !***            DATE WRITTEN    :       September 2000
1043: 0003: !***
1044: 0003: !***        Provides a much needed and easier to use interface to
1045: 0003: !***        IBM Display Manager.
1046: 0003: !***
1047: 0003: !***        Saves the user having to set up, highlight, tab between and
1048: 0003: !***        validate fields.  Also handles the help screens and conversion
1049: 0003: !***        of date fields to external/internal format.
1050: 0003: !***
1051: 0003: !******************************************************************************
1052: 0003: !******************************************************************************
1053: 0003: 
1054: 0003: !******************************************************************************
1055: 0003: !   Initialises the display manager functions.
1056: 0003: !   You should call this from your program initialisation for screen programs.
1057: 0003: !   Note that the name of the display manager file is determined from the
1058: 0003: !   global variable MODULE.NUMBER$.  For example PSB1200 uses PSBD12.dat
1059: 0003: !   where the PSB and 12 have been derived from MODULE.NUMBER$.
1060: 0003: 
1061: 0003:     FUNCTION DM.INIT EXTERNAL
1062: 0003:         INTEGER*1   DM.INIT
1063: 0003:     END FUNCTION
1064: 0003: 
1065: 0003: !******************************************************************************
1066: 0003: !   Quits the display manager program and frees resources.
1067: 0003: !   You should call this from your program termination.
1068: 0003: 
1069: 0003:     FUNCTION DM.QUIT EXTERNAL
1070: 0003:         INTEGER*1   DM.QUIT
1071: 0003:     END FUNCTION
1072: 0003: 
1073: 0003: !******************************************************************************
1074: 0003: !   Initialises a particular screen from the current display manager file
1075: 0003: !   for display.  You supply the screen number, optional title message and
1076: 0003: !   the first and last help screens associated with the display.
1077: 0003: !   Once you have SHOWN a screen, you can use the remaining functions in
1078: 0003: !   this library to set field values, and actually retrieve input from the
1079: 0003: !   screen.  Note that showing a screen just displays it on the screen,
1080: 0003: !   you need to call PROCESS.SCREEN to actually get any user input.
1081: 0003: 
1082: 0003:     FUNCTION DM.SHOW.SCREEN (SCREEN%, TITLE$, FIRST.HELP%, LAST.HELP%) EXTERNAL
1083: 0003:         INTEGER*1   DM.SHOW.SCREEN
1084: 0003:         INTEGER*2   SCREEN%
1085: 0003:         STRING      TITLE$
1086: 0003:         INTEGER*2   FIRST.HELP%
1087: 0003:         INTEGER*2   LAST.HELP%
1088: 0003:     END FUNCTION
1089: 0003: 
1090: 0003: !******************************************************************************
1091: 0003: !   Sets a function key message to visible.  Optionally sets the text on that
1092: 0003: !   key to the message string passed, if it is not null.
1093: 0003: !   Note you must have shown a screen first, and that the function key fields
1094: 0003: !   need to be defined in your display file with field IDs 241-250.
1095: 0003: 
1096: 0003:     FUNCTION DM.SHOW.FN.KEY (KEY.NUM%, MESSAGE$) EXTERNAL
1097: 0003:         INTEGER*1   DM.SHOW.FN.KEY
1098: 0003:         INTEGER*2   KEY.NUM%
1099: 0003:         STRING      MESSAGE$
1100: 0003:     END FUNCTION
1101: 0003: 
1102: 0003: !******************************************************************************
1103: 0003: !   Sets a function key message to invisible.
1104: 0003: !   Note you must have shown a screen first, and that the function key fields
1105: 0003: !   need to be defined in your display file with field IDs 241-250.
1106: 0003: 
1107: 0003:     FUNCTION DM.HIDE.FN.KEY (KEY.NUM%) EXTERNAL
1108: 0003:         INTEGER*1   DM.HIDE.FN.KEY
1109: 0003:         INTEGER*2   KEY.NUM%
1110: 0003:     END FUNCTION
1111: 0003: 
1112: 0003: !******************************************************************************
1113: 0003: !   LEGACY: Do not use in new programs, use DM.FN.VISIBLE instead which takes
1114: 0003: !   an infix notation expression, as opposed to reverse polish
1115: 0003: !   This definition has been commented out accordingly.  If you are
1116: 0003: !   recompiling an application, change to useing the new function.
1117: 0003: !
1118: 0003: !   FUNCTION DM.FN.KEY.VISIBLE (KEY.NUM%, EXPR$) EXTERNAL
1119: 0003: !       INTEGER*1   DM.FN.KEY.VISIBILITY
1120: 0003: !       INTEGER*2   KEY.NUM%
1121: 0003: !       STRING      EXPR$
1122: 0003: !   END FUNCTION
1123: 0003: 
1124: 0003: !******************************************************************************
1125: 0003: !   Sets a runtine expression to determine if a function key is visible.
1126: 0003: !   This is the new version of the above which takes an infix notation EXPR$.
1127: 0003: !   Note you must have shown a screen first, and that the function key fields
1128: 0003: !   need to be defined in your display file with field IDs 241-250.
1129: 0003: 
1130: 0003:     FUNCTION DM.FN.VISIBLE (KEY.NUM%, EXPR$) EXTERNAL
1131: 0003:         INTEGER*1   DM.FN.VISIBILITY
1132: 0003:         INTEGER*2   KEY.NUM%
1133: 0003:         STRING      EXPR$
1134: 0003:     END FUNCTION
1135: 0003: 
1136: 0003: !******************************************************************************
1137: 0003: !   Specifies that a given field contains a date.
1138: 0003: !   This means that the date will be displayed on screen in the system date
1139: 0003: !   format (e.g. DD/MM/YY or MM/DD/YY, but will be returned and set by your
1140: 0003: !   application in YYMMDD format.
1141: 0003: !   It does NOT mean that the field will be validated as a date, you must do
1142: 0003: !   that explicitly using the VALID$ string.
1143: 0003: 
1144: 0003:     FUNCTION DM.DATE.FIELD (FIELD%) EXTERNAL
1145: 0003:         INTEGER*1   DM.DATE.FIELD
1146: 0003:         INTEGER*2   FIELD%
1147: 0003:     END FUNCTION
1148: 0003: 
1149: 0003: !******************************************************************************
1150: 0003: !   Specifies that a given field will contain a time.
1151: 0003: !   This means that the time will be displayed on screen using the system time
1152: 0003: !   format.  e.g. HH:MM
1153: 0003: 
1154: 0003:     FUNCTION DM.TIME.FIELD (FIELD%) EXTERNAL                                !CSWM
1155: 0003:         INTEGER*1   DM.TIME.FIELD                                           !CSWM
1156: 0003:         INTEGER*2   FIELD%                                                  !CSWM
1157: 0003:     END FUNCTION                                                            !CSWM
1158: 0003: 
1159: 0003: !******************************************************************************
1160: 0003: !   Specifies that a given input field will be read only.
1161: 0003: !   This allows you to select an item from a list by highlighting it.
1162: 0003: 
1163: 0003:     FUNCTION DM.RO.FIELD (FIELD%) EXTERNAL                                  !ESWM
1164: 0003:         INTEGER*1   DM.RO.FIELD                                             !ESWM
1165: 0003:         INTEGER*2   FIELD%                                                  !ESWM
1166: 0003:     END FUNCTION                                                            !ESWM
1167: 0003: 
1168: 0003: !******************************************************************************
1169: 0003: !   Specifies that a given input field will be read write.
1170: 0003: !   Undoes the effect of DM.RO.FIELD.
1171: 0003: 
1172: 0003:     FUNCTION DM.RW.FIELD (FIELD%) EXTERNAL                                  !ESWM
1173: 0003:         INTEGER*1   DM.RW.FIELD                                             !ESWM
1174: 0003:         INTEGER*2   FIELD%                                                  !ESWM
1175: 0003:     END FUNCTION                                                            !ESWM
1176: 0003: 
1177: 0003: !******************************************************************************
1178: 0003: !   LEGACY: Do not use in new programs, use DM.STATUS instead which takes
1179: 0003: !   an infix notation expression, as opposed to reverse polish.
1180: 0003: !   This definition has been commented out accordingly.  If you are
1181: 0003: !   recompiling an application, change to useing the new function.
1182: 0003: !
1183: 0003: !   FUNCTION DM.DISPLAY.MESSAGE (MESSAGE$) EXTERNAL                         !DSWM
1184: 0003: !       INTEGER*1   DM.DISPLAY.MESSAGE                                      !DSWM
1185: 0003: !       STRING      MESSAGE$                                                !DSWM
1186: 0003: !   END FUNCTION                                                            !DSWM
1187: 0003: 
1188: 0003: !******************************************************************************
1189: 0003: !   Displays a message in the status line of the display.  Does not wait for
1190: 0003: !   input.  Use this function for display messages such as B251 Processing...
1191: 0003: !   You must have field 1 defined in your display manager file.
1192: 0003: !   This is the new version of the above which takes an infix notation MESSAGE$.
1193: 0003: 
1194: 0003:     FUNCTION DM.STATUS (MESSAGE$) EXTERNAL                                  !DSWM
1195: 0003:         INTEGER*1   DM.STATUS                                               !DSWM
1196: 0003:         STRING      MESSAGE$                                                !DSWM
1197: 0003:     END FUNCTION                                                            !DSWM
1198: 0003: 
1199: 0003: !******************************************************************************
1200: 0003: !   Waits for input in the invisible input field of the display.  Additionally
1201: 0003: !   displays a message prompting the user on the status line.
1202: 0003: !   You must have fields 1 and 240 defined in your display manager file.
1203: 0003: !   The message supplied should be in Reverse Polish form.
1204: 0003: !   The function returns the key value that ended the input.
1205: 0003: 
1206: 0003:     FUNCTION DM.INVISIBLE.INPUT (MESSAGE$) EXTERNAL
1207: 0003:         STRING      MESSAGE$
1208: 0003:         INTEGER*2   DM.INVISIBLE.INPUT
1209: 0003:     END FUNCTION
1210: 0003: 
1211: 0003: !******************************************************************************
1212: 0003: !   Gets the contents of the invisible field from the display.  This will
1213: 0003: !   allow you to get the Y or N answer that the user typed, for example.
1214: 0003: 
1215: 0003:     FUNCTION DM.INVISIBLE.FIELD EXTERNAL
1216: 0003:         STRING      DM.INVISIBLE.FIELD
1217: 0003:     END FUNCTION
1218: 0003: 
1219: 0003: !******************************************************************************
1220: 0003: !   Returns or sets the current field used for input on the current display.
1221: 0003: !   If NEW.FIELD% is zero, the function simply returns the current field.
1222: 0003: !   If NEW.FIELD% is non zero, the function sets the current field.
1223: 0003: 
1224: 0003:     FUNCTION DM.CURRENT.FIELD (NEW.FIELD%) EXTERNAL
1225: 0003:         INTEGER*2   DM.CURRENT.FIELD
1226: 0003:         INTEGER*2   NEW.FIELD%
1227: 0003:     END FUNCTION
1228: 0003: 
1229: 0003: !******************************************************************************
1230: 0003: !   Sets a key number as being a validation key.  When this key is used the
1231: 0003: !   function will handle the key in the same way as the ENTER key.  i.e. all
1232: 0003: !   the visible fields on in input form are check for validity, and the key
1233: 0003: !   press is only returned to the user if the form entries are valid.
1234: 0003: !   Use this function to add the PGUP.KEY% and PGDN.KEY% keys, for example.
1235: 0003: 
1236: 0003:     FUNCTION DM.VALIDATE.KEY (KEY%) EXTERNAL                                !BSWM
1237: 0003:         INTEGER*1   DM.VALIDATE.KEY                                         !BSWM
1238: 0003:         INTEGER*2   KEY%                                                    !BSWM
1239: 0003:     END FUNCTION                                                            !BSWM
1240: 0003: 
1241: 0003: !******************************************************************************
1242: 0003: !   Returns or sets the flag which says if the screen contents have been
1243: 0003: !   changed or not.  Use this function when you have multiple pages to a
1244: 0003: !   form, but want the user to be prompted to save any changes on exit.
1245: 0003: !   When called with FLAG% set 0 or -1, the function updates the current
1246: 0003: !   displays setting.  When called with any other value, the function simply
1247: 0003: !   returns the current setting and does not update it.
1248: 0003: 
1249: 0003:     FUNCTION DM.CHANGED.FLAG (FLAG%) EXTERNAL                               !BSWM
1250: 0003:         INTEGER*1   FLAG%                                                   !BSWM
1251: 0003:         INTEGER*1   DM.CHANGED.FLAG                                         !BSWM
1252: 0003:     END FUNCTION                                                            !BSWM
1253: 0003: 
1254: 0003: !******************************************************************************
1255: 0003: !   Sets the field tab order.  The tab order can be either:
1256: 0003: !   0 - The TAB order is defined by the fields position on the display,
1257: 0003: !       left to right then top to bottom of the display.
1258: 0003: !   1 - The TAB order is defined by the number order of the fields.  This is
1259: 0003: !       a new option which allows greater control over the field TAB order.
1260: 0003: !   -1  Returns the current setting without changing it.
1261: 0003: !   The default tab order is 0.  Once set, the TAB order is a global setting
1262: 0003: !   for the current and all future screens.
1263: 0003: 
1264: 0003:     FUNCTION DM.TAB.ORDER (ORDER%) EXTERNAL                                 !DSWM
1265: 0003:         INTEGER*1   ORDER%                                                  !DSWM
1266: 0003:         INTEGER*1   DM.TAB.ORDER                                            !DSWM
1267: 0003:     END FUNCTION                                                            !DSWM
1268: 0003: 
1269: 0003: !******************************************************************************
1270: 0003: !   This function actually processes user input on the currently shown form.
1271: 0003: !   The function returns when any unrecognised key terminates input in a
1272: 0003: !   field.  The keys which will do this are determined by the properties of
1273: 0003: !   the Display Manager fields on your form.  The function internally handles
1274: 0003: !   most of the form navigation keys (e.g. Tab, Back Tab, Home End) the
1275: 0003: !   rest are up to the user application.
1276: 0003: 
1277: 0003:     FUNCTION DM.PROCESS.SCREEN (FIRST.FIELD%, LAST.FIELD%, CONFIRM) EXTERNAL
1278: 0003:         INTEGER*2   DM.PROCESS.SCREEN
1279: 0003:         INTEGER*2   FIRST.FIELD%
1280: 0003:         INTEGER*2   LAST.FIELD%
1281: 0003:         INTEGER*1   CONFIRM
1282: 0003:     END FUNCTION
1283: 0003: 
1284: 0003: !******************************************************************************
1285: 0003: !   Associates a field on the current display with a given compile time
1286: 0003: !   variable.  This allows the varibale to be used in your program code
1287: 0003: !   AND be updated by the display manager fields in PROCESS.SCREEN.
1288: 0003: !
1289: 0003: !   NOTE: PLEASE BE VERY CAREFUL WITH THE THIRD PARAMETER TO THIS SUB
1290: 0003: !   Always use an absolute variable for VARIABLE$:
1291: 0003: !       CALL DM.NAME (2, "MY.VAR$", MY.VAR$)
1292: 0003: !   NEVER use a calcualted value. These forms are all ILLEGAL:
1293: 0003: !       CALL DM.NAME (2, "MY.VAR$", "1234")
1294: 0003: !       CALL DM.NAME (2, "MY.VAR$", STR$(MY.VAR%))
1295: 0003: !   Also, if you MUST pass in an array element, for example:
1296: 0003: !       CALL DM.NAME (2, "MY.VAR$", ARRAY.ELEMENT$(I%))
1297: 0003: !   then you must make sure you do not reDIM the array until you have finished
1298: 0003: !   displaying and processing the screen.
1299: 0003: 
1300: 0003:     SUB DM.NAME (FIELD%, NAME$, VARIABLE$) EXTERNAL                         !DSWM
1301: 0003:         INTEGER*2 FIELD%                                                    !DSWM
1302: 0003:         STRING NAME$                                                        !DSWM
1303: 0003:         STRING VARIABLE$                                                    !DSWM
1304: 0003:     END SUB                                                                 !DSWM
1305: 0003: 
1306: 0003: !******************************************************************************
1307: 0003: !   Returns the index of a field on the current screen, given its name.
1308: 0003: 
1309: 0003:     FUNCTION DM.INDEX (FIELD$) EXTERNAL                                     !DSWM
1310: 0003:         STRING FIELD$                                                       !DSWM
1311: 0003:         INTEGER*2 DM.INDEX                                                  !DSWM
1312: 0003:     END FUNCTION                                                            !DSWM
1313: 0003: 
1314: 0003: !******************************************************************************
1315: 0003: !   Sets the validation expression for a field on the display.  Exactly the
1316: 0003: !   same as setting the global VALID$ array yourself, except it is done
1317: 0003: !   via the fields name as assoicated via DM.NAME.FIELD and the expression
1318: 0003: !   is in standard infix notation.
1319: 0003: 
1320: 0003:     FUNCTION DM.VALID (FIELD$, VALID$) EXTERNAL                             !DSWM
1321: 0003:         STRING FIELD$                                                       !DSWM
1322: 0003:         STRING VALID$                                                       !DSWM
1323: 0003:         INTEGER*2 DM.VALID                                                  !DSWM
1324: 0003:     END FUNCTION                                                            !DSWM
1325: 0003: 
1326: 0003: !******************************************************************************
1327: 0003: !   Sets the message expression for a field on the display.  Exactly the
1328: 0003: !   same as setting the global MESSAGE$ array yourself, except it is done
1329: 0003: !   via the fields name as assoicated via DM.NAME.FIELD and the expression
1330: 0003: !   is in standard infix notation.
1331: 0003: 
1332: 0003:     FUNCTION DM.MESSAGE (FIELD$, MESSAGE$) EXTERNAL                         !DSWM
1333: 0003:         STRING FIELD$                                                       !DSWM
1334: 0003:         STRING MESSAGE$                                                     !DSWM
1335: 0003:         INTEGER*2 DM.MESSAGE                                                !DSWM
1336: 0003:     END FUNCTION                                                            !DSWM
1337: 0003: 
1338: 0003: !******************************************************************************
1339: 0003: !   Sets the field attributes for a field on the display. Exactly the
1340: 0003: !   same as using the SETF command yourself except that it is done by
1341: 0003: !   using the fields name as associated via the DM.NAME.FIELD.
1342: 0003: 
1343: 0003: SUB DM.FLD.ATT (FIELD$, VALUE$) EXTERNAL                                    !FNWB
1344: 0003:     STRING      FIELD$                                                      !FNWB
1345: 0003:     STRING      VALUE$                                                      !FNWB
1346: 0003: END SUB                                                                     !FNWB
1347: 0003: 
1348: 0003: !******************************************************************************
1349: 0003: !   Sets an input field to act as an output only field on the display. This
1350: 0003: !   allows setting input fields that contain headings etc. to be skipped by
1351: 0003: !   the cursor movement keys.
1352: 0003: 
1353: 0003: FUNCTION DM.OO.FIELD (FIELD$) EXTERNAL                                      !FNWB
1354: 0003:     INTEGER*2   DM.OO.FIELD                                                 !FNWB
1355: 0003:     STRING      FIELD$                                                      !FNWB
1356: 0003: END FUNCTION                                                                !FNWB
1357: 0003: 
1358: 0003: !******************************************************************************
1359: 0003: !   Sets an input field back to an i/o field
1360: 0003: 
1361: 0003: FUNCTION DM.IO.FIELD (FIELD$) EXTERNAL                                      !FNWB
1362: 0003:     INTEGER*2   DM.IO.FIELD                                                 !FNWB
1363: 0003:     STRING      FIELD$                                                      !FNWB
1364: 0003: END FUNCTION                                                                !FNWB
1365: 0003: 
1366: 0003: !******************************************************************************
1367: 0003: !   Sets the visibility expression for a field on the display.  Exactly the
1368: 0003: !   same as setting the global VISIBLE$ array yourself, except it is done
1369: 0003: !   via the fields name as assoicated via DM.NAME.FIELD and the expression
1370: 0003: !   is in standard infix notation.
1371: 0003: 
1372: 0003:     FUNCTION DM.VISIBLE (FIELD$, VISIBLE$) EXTERNAL                         !DSWM
1373: 0003:         STRING FIELD$                                                       !DSWM
1374: 0003:         STRING VISIBLE$                                                     !DSWM
1375: 0003:         INTEGER*2 DM.VISIBLE                                                !DSWM
1376: 0003:     END FUNCTION                                                            !DSWM
1377: 0003: 
1378: 0003: !******************************************************************************
1379: 0003: !   Sets an error message in field 1 of the display and moves the input
1380: 0003: !   focus to the offending line of the display.  Should be called from user
1381: 0003: !   validation code.  Equivalent of the following separate calls:
1382: 0003: !       CALL DM.CURRENT.FIELD%(DM.INDEX(FIELD$))
1383: 0003: !       FIELD$(1) = POLISH$(MESSAGE$)
1384: 0003: !   Can also be called with a null field name, in which case the cursor
1385: 0003: !   remains in the current input field, but the error is displayed.
1386: 0003: 
1387: 0003:     FUNCTION DM.FOCUS (FIELD$, MESSAGE$) EXTERNAL                           !DSWM
1388: 0003:         STRING FIELD$                                                       !DSWM
1389: 0003:         STRING MESSAGE$                                                     !DSWM
1390: 0003:         INTEGER*2 DM.FOCUS                                                  !DSWM
1391: 0003:     END FUNCTION                                                            !DSWM
1392: 0003: 
1393: 0003: !******************************************************************************
1394: 0003: 
1395: 0003: 
1396: 0003:    %INCLUDE CSORTDEC.J86       ! Assembler csort
1397: 0003: FUNCTION CSORT(ARPTR%, ELEMENTS%) EXTERNAL
1398: 0003:     INTEGER*4 ARPTR%, ELEMENTS%, CSORT
1399: 0003: END FUNCTION
1400: 0003: 
1401: 0003:    %INCLUDE ADXSTART.J86       ! To start background applications       !DDM
1402: 0003: \******************************************************************************
1403: 0003: \******************************************************************************
1404: 0003: \***                                                                        ***
1405: 0003: \***    %INCLUDE FOR FUNCTION ADXSTART (an I.B.M. system function)          ***
1406: 0003: \***                                                                        ***
1407: 0003: \***         AUTHOR        :  Barbara Holbrook                              ***
1408: 0003: \***                                                                        ***
1409: 0003: \***         DATE WRITTEN  :  26th June 1987                                ***
1410: 0003: \***                                                                        ***
1411: 0003: \***         DATE OF LAST REVISION  - 19th November 1987                    ***
1412: 0003: \***                                                                        ***
1413: 0003: \***                                                                        ***
1414: 0003: \******************************************************************************
1415: 0003: \******************************************************************************
1416: 0003: 
1417: 0003:    FUNCTION ADXSTART (ADX.NAME$,                                       \
1418: 0003:                       ADX.PARM$,                                       \
1419: 0003:                       ADX.MESS$)                                       \
1420: 0003:    EXTERNAL
1421: 0003: 
1422: 0003:       STRING     ADX.NAME$,                                            \
1423: 0003:                  ADX.PARM$,                                            \
1424: 0003:                  ADX.MESS$
1425: 0003: 
1426: 0003:       INTEGER*2  ADXSTART
1427: 0003: 
1428: 0003:    END FUNCTION
1429: 0003: 
1430: 0003:    %INCLUDE BTCSTR.J86         ! String functions                       !MLJ
1431: 0003: !********************************************************************
1432: 0003: !***
1433: 0003: !***    INCLUDED CODE:  BTCSTR.J86
1434: 0003: !***    AUTHOR:         Stuart William McConnachie
1435: 0003: !***    DATE:           26th February 2006
1436: 0003: !***
1437: 0003: !********************************************************************
1438: 0003: !***
1439: 0003: !***    Controller CBASIC String Functions
1440: 0003: !***
1441: 0003: !********************************************************************
1442: 0003: 
1443: 0003: !Swaps to CBASIC strings
1444: 0003: SUB SWAPSTR (S1$, S2$) EXTERNAL
1445: 0003:     STRING S1$, S2$
1446: 0003: END SUB
1447: 0003: 
1448: 0003: !Left trim a string of spaces
1449: 0003: SUB LTRIM (S$) EXTERNAL
1450: 0003:     STRING S$
1451: 0003: END SUB
1452: 0003: 
1453: 0003: !Right trim a string of spaces
1454: 0003: SUB RTRIM (S$) EXTERNAL
1455: 0003:     STRING S$
1456: 0003: END SUB
1457: 0003: 
1458: 0003: !Left and right trim a string of spaces
1459: 0003: SUB TRIM (S$) EXTERNAL
1460: 0003:     STRING S$
1461: 0003: END SUB
1462: 0003: 
1463: 0003: !Left trim a string of a given ASCII character
1464: 0003: SUB LTRIMC (S$, C%) EXTERNAL
1465: 0003:     STRING S$
1466: 0003:     INTEGER*1 C%
1467: 0003: END SUB
1468: 0003: 
1469: 0003: !Right trim a string of a given ASCII character
1470: 0003: SUB RTRIMC (S$, C%) EXTERNAL
1471: 0003:     STRING S$
1472: 0003:     INTEGER*1 C%
1473: 0003: END SUB
1474: 0003: 
1475: 0003: !Left and right trim a string of a given ASCII character
1476: 0003: SUB TRIMC (S$, C%) EXTERNAL
1477: 0003:     STRING S$
1478: 0003:     INTEGER*1 C%
1479: 0003: END SUB
1480: 0003: 
1481: 0003: !Insert one string into another
1482: 0003: FUNCTION SUBSTR(S1$, O1%, S2$, O2%, L2%) EXTERNAL
1483: 0003:     STRING    S1$, S2$
1484: 0003:     INTEGER*2 O1%, O2%, L2%
1485: 0003:     INTEGER*1 SUBSTR
1486: 0003: END FUNCTION
1487: 0003:     
1488: 0003:    %INCLUDE CMPDATE.J86        ! Compare dates                          !DDM
1489: 0003: !********************************************************************
1490: 0003: !***
1491: 0003: !***    INCLUDED CODE:  CMPDATE.J86
1492: 0003: !***    AUTHOR:         Stuart William McConnachie
1493: 0003: !***    DATE:           27th January 1997
1494: 0003: !***
1495: 0003: !********************************************************************
1496: 0003: !***   
1497: 0003: !***    Version B            Nik Sen                 30th March 1998
1498: 0003: !***    Changes to cope with a date of '000000' by replacing it with
1499: 0003: !***    '850101' before comparison. An all zero's date is valid in 
1500: 0003: !***    certain date fields and CMPDATE was returning the wrong result
1501: 0003: !***    when comparing with an actual date. Also change to cope with
1502: 0003: !***    dates of '999999' as some date fields are initialised to this
1503: 0003: !***    as a high value.
1504: 0003: !***
1505: 0003: !***    Version C    Stuart William McConnachie   20th December 1999
1506: 0003: !***    Improved function efficiency by changing tests for high and
1507: 0003: !***    low values, added above, to integers (rather than strings).
1508: 0003: !***    Also, using 850101 as a replacement for 000000, will not give
1509: 0003: !***    valid results after 350101 because of the 50 year wrap, so
1510: 0003: !***    corrected this.
1511: 0003: !***
1512: 0003: !***    Version D.  Stuart William McConnachie    26th February 2006
1513: 0003: !***    Place this code in it's own module in FUNLIB.  Make all
1514: 0003: !***    the functions herein EXTERNAL accordingly.
1515: 0003: !***
1516: 0003: !********************************************************************
1517: 0003: !***    
1518: 0003: !***    The following functions compare dates, checking for
1519: 0003: !***    century boundries.  Dates in the 50 years prior to the
1520: 0003: !***    compared date are less than the compared date, dates in
1521: 0003: !***    50 years after the compared date are greater than the
1522: 0003: !***    compared date.
1523: 0003: !***    Can handle dates in both packed and unpacked formats, or
1524: 0003: !***    a mixture of both.
1525: 0003: !***    In the case of a error, for example IH after detecting
1526: 0003: !***    illegal characters in VAL, the functions default to
1527: 0003: !***    comparing strings without testing for a change of century.
1528: 0003: !***
1529: 0003: !***    DATE.GT(DATE1$, DATE2$)  same as  DATE1$ >  DATE2$
1530: 0003: !***    DATE.GE(DATE1$, DATE2$)  same as  DATE1$ >= DATE2$
1531: 0003: !***    DATE.LT(DATE1$, DATE2$)  same as  DATE1$ <  DATE2$
1532: 0003: !***    DATE.LE(DATE1$, DATE2$)  same as  DATE1$ <= DATE2$
1533: 0003: !***
1534: 0003: !********************************************************************
1535: 0003: 
1536: 0003: FUNCTION DATE.GT(DATE1$, DATE2$) EXTERNAL                               !DSWM
1537: 0003:     STRING    DATE1$, DATE2$
1538: 0003:     INTEGER*1 DATE.GT
1539: 0003: END FUNCTION
1540: 0003: 
1541: 0003: 
1542: 0003: FUNCTION DATE.GE(DATE1$, DATE2$) EXTERNAL                               !DSWM
1543: 0003:     STRING    DATE1$, DATE2$
1544: 0003:     INTEGER*1 DATE.GE
1545: 0003: END FUNCTION
1546: 0003: 
1547: 0003: 
1548: 0003: FUNCTION DATE.LT(DATE1$, DATE2$) EXTERNAL                               !DSWM
1549: 0003:     STRING    DATE1$, DATE2$
1550: 0003:     INTEGER*1 DATE.LT
1551: 0003: END FUNCTION
1552: 0003: 
1553: 0003: 
1554: 0003: FUNCTION DATE.LE(DATE1$, DATE2$) EXTERNAL                               !DSWM
1555: 0003:     STRING    DATE1$, DATE2$
1556: 0003:     INTEGER*1 DATE.LE
1557: 0003: END FUNCTION
1558: 0003: 
1559: 0003: 
1560: 0003:    %INCLUDE BDCPEXT.J86        ! Boots.com Parcel File
1561: 0003: \******************************************************************************
1562: 0003: \******************************************************************************
1563: 0003: \***
1564: 0003: \***           FUNCTION DEFINITIONS Boots.com Parcel File (BDCP)
1565: 0003: \***
1566: 0003: \***           REFERENCE:   BDCPEXT.J86
1567: 0003: \***
1568: 0003: \***           VERSION A         Neil Bennett          19th May 2010
1569: 0003: \***
1570: 0003: \***
1571: 0003: \*******************************************************************************
1572: 0003: \*******************************************************************************
1573: 0003: 
1574: 0003: 
1575: 0003:    FUNCTION BDCP.SET EXTERNAL
1576: 0003:    END FUNCTION
1577: 0003: 
1578: 0003:    FUNCTION READ.BDCP EXTERNAL
1579: 0003:       INTEGER*2 READ.BDCP
1580: 0003:    END FUNCTION
1581: 0003: 
1582: 0003:    FUNCTION WRITE.BDCP EXTERNAL
1583: 0003:       INTEGER*2 WRITE.BDCP
1584: 0003:    END FUNCTION
1585: 0003: 
1586: 0003:    FUNCTION READ.BDCP.LOCK EXTERNAL
1587: 0003:       INTEGER*2 READ.BDCP.LOCK
1588: 0003:    END FUNCTION
1589: 0003: 
1590: 0003:    FUNCTION WRITE.BDCP.UNLOCK EXTERNAL
1591: 0003:       INTEGER*2 WRITE.BDCP.UNLOCK
1592: 0003:    END FUNCTION
1593: 0003:    
1594: 0003:    FUNCTION DELETE.BDCP EXTERNAL
1595: 0003:       INTEGER*2 DELETE.BDCP
1596: 0003:    END FUNCTION
1597: 0003:    
1598: 0003:    %INCLUDE CRTNEXT.J86        ! Directs Carton File                    !AGCS
1599: 0003: \/******************************************************************/
1600: 0003: \/*                                                                */
1601: 0003: \/* CARTON FILE EXTERNAL FUNCTION DEFNS                            */
1602: 0003: \/*                                                                */
1603: 0003: \/* REFERENCE   : CRTNEXT.J86                                      */
1604: 0003: \/*                                                                */
1605: 0003: \/* VERSION A.          Neil Bennett.           12 DECEMBER 2006   */
1606: 0003: \/*                                                                */
1607: 0003: \/******************************************************************/
1608: 0003: 
1609: 0003:    FUNCTION CRTN.SET EXTERNAL
1610: 0003:       INTEGER*1 CRTN.SET
1611: 0003:    END FUNCTION
1612: 0003: 
1613: 0003:    FUNCTION READ.CRTN EXTERNAL
1614: 0003:       INTEGER*2 READ.CRTN
1615: 0003:    END FUNCTION
1616: 0003: 
1617: 0003:    FUNCTION WRITE.CRTN EXTERNAL
1618: 0003:       INTEGER*2 WRITE.CRTN
1619: 0003:    END FUNCTION
1620: 0003:    
1621: 0003:     FUNCTION DELETE.CRTN EXTERNAL
1622: 0003:       INTEGER*2 DELETE.CRTN
1623: 0003:    END FUNCTION
1624: 0003: 
1625: 0003: 
1626: 0003: \/******************************************************************/
1627: 0003:    %INCLUDE PSUTQEXT.J86       ! Parcel Status Update Transaction File  !AICS
1628: 0003: \*****************************************************************************
1629: 0003: \*****************************************************************************
1630: 0003: \***
1631: 0003: \***      EXTERNAL FUNCTION DEFINITIONS FOR PARCEL STATUS UPDATE 
1632: 0003: \***      TRANSACTION QUEUE FILE
1633: 0003: \***
1634: 0003: \***                      REFERENCE: PSUTQEXT.J86
1635: 0003: \***
1636: 0003: \***         VERSION A         Kiran Krishnan        27th July 2017
1637: 0003: \***         PRJ2002- Order & Collect Parcel Management - Phase 2
1638: 0003: \***         Initial version for User Story PMLA-377 
1639: 0003: \***
1640: 0003: \*******************************************************************************
1641: 0003: \*******************************************************************************
1642: 0003: 
1643: 0003:      FUNCTION PSUTQ.SET EXTERNAL
1644: 0003:      END FUNCTION
1645: 0003:      
1646: 0003:      FUNCTION READ.PSUTQ EXTERNAL
1647: 0003:         INTEGER*2 READ.PSUTQ
1648: 0003:      END FUNCTION
1649: 0003:      
1650: 0003:      FUNCTION WRITE.PSUTQ EXTERNAL
1651: 0003:         INTEGER*2 WRITE.PSUTQ
1652: 0003:      END FUNCTION
1653: 0003:      
1654: 0003:      
1655: 0003:      
1656: 0003:    %INCLUDE SOFTSEXT.J86       ! Software Status File                   !DDM
1657: 0003: \*******************************************************************************
1658: 0003: \***                                                                         ***
1659: 0003: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE SOFTWARE STATUS FILE         ***
1660: 0003: \***                                                                         ***
1661: 0003: \***                     REFERENCE : SOFTSEXT.J86                            ***
1662: 0003: \***                                                                         ***
1663: 0003: \***      Version A         Andrew Wedgeworth          1st July 1992         ***
1664: 0003: \***
1665: 0003: \***   Version B
1666: 0003: \***                                                                      ***
1667: 0003: \***      Version C         Steve Wright               3rd May 1996          ***
1668: 0003: \***      Synchronise with function source.                                  ***
1669: 0003: \*******************************************************************************
1670: 0003: 
1671: 0003:       FUNCTION SOFTS.SET EXTERNAL 
1672: 0003:       END FUNCTION
1673: 0003:       
1674: 0003:       FUNCTION READ.SOFTS EXTERNAL
1675: 0003:           INTEGER*2 I%, READ.SOFTS
1676: 0003:       END FUNCTION	                   
1677: 0003: 
1678: 0003:       FUNCTION WRITE.SOFTS EXTERNAL
1679: 0003:           INTEGER*2 I%, WRITE.SOFTS
1680: 0003:       END FUNCTION
1681: 0003: 
1682: 0003: 
1683: 0003: \********************************************************************   !HDC
1684: 0003: \***                                                                    !HDC
1685: 0003: \***    Variables added for loaction file                               !HDC
1686: 0003: \***                                                                    !HDC
1687: 0003: \********************************************************************   !HDC
1688: 0003: %INCLUDE BDCLOEXT.J86                                                   !HDC
1689: 0003: \******************************************************************************
1690: 0003: \******************************************************************************
1691: 0003: \***
1692: 0003: \***           FILE FUNCTIONS Boots.com Location File (BDCLOOCON)
1693: 0003: \***
1694: 0003: \***           REFERENCE:   BDCLOEXT.J86
1695: 0003: \***
1696: 0003: \***           VERSION A         Dave Constable        7th March 2016
1697: 0003: \***           PRJ1361- Order & Collect Parcel Management
1698: 0003: \***           Initial version for User Story PMLA-17 & PMLA-58 to allow 
1699: 0003: \***           Location access for Parcels by controller and till for 
1700: 0003: \***           Boots.com/ie order parcels.
1701: 0003: \***    
1702: 0003: \***
1703: 0003: \*******************************************************************************
1704: 0003: \*******************************************************************************
1705: 0003: 
1706: 0003:     FUNCTION BDCLOCON.SET EXTERNAL
1707: 0003:     
1708: 0003:     END FUNCTION
1709: 0003: 
1710: 0003:     FUNCTION READ.BDCLOCON EXTERNAL
1711: 0003:         INTEGER*2   READ.BDCLOCON
1712: 0003:         STRING      F.CRLF$
1713: 0003:     END FUNCTION
1714: 0003: 
1715: 0003:     FUNCTION WRITE.BDCLOCON EXTERNAL
1716: 0003:         INTEGER*2   WRITE.BDCLOCON
1717: 0003:         STRING      F.CRLF$
1718: 0003:     END FUNCTION
1719: 0003: 
1720: 0003: 
1721: 0003: %INCLUDE BDCOEXT.J86                                                    !HDC
1722: 0003: \******************************************************************************
1723: 0003: \******************************************************************************
1724: 0003: \***
1725: 0003: \***           FUNCTION DEFINITIONS Boots.com Orders File (BDCO)
1726: 0003: \***
1727: 0003: \***           REFERENCE:   BDCOEXT.J86
1728: 0003: \***
1729: 0003: \***           VERSION A         Neil Bennett          19th May 2010
1730: 0003: \***
1731: 0003: \***
1732: 0003: \*******************************************************************************
1733: 0003: \*******************************************************************************
1734: 0003: 
1735: 0003: 
1736: 0003:    FUNCTION BDCO.SET EXTERNAL
1737: 0003:    END FUNCTION
1738: 0003: 
1739: 0003:    FUNCTION READ.BDCO EXTERNAL
1740: 0003:       INTEGER*2 READ.BDCO
1741: 0003:    END FUNCTION
1742: 0003: 
1743: 0003:    FUNCTION WRITE.BDCO EXTERNAL
1744: 0003:       INTEGER*2 WRITE.BDCO
1745: 0003:    END FUNCTION
1746: 0003: 
1747: 0003:    FUNCTION READ.BDCO.LOCK EXTERNAL
1748: 0003:       INTEGER*2 READ.BDCO.LOCK
1749: 0003:    END FUNCTION
1750: 0003: 
1751: 0003:    FUNCTION WRITE.BDCO.UNLOCK EXTERNAL
1752: 0003:       INTEGER*2 WRITE.BDCO.UNLOCK
1753: 0003:    END FUNCTION
1754: 0003:    
1755: 0003:    FUNCTION DELETE.BDCO EXTERNAL
1756: 0003:       INTEGER*2 DELETE.BDCO
1757: 0003:    END FUNCTION
1758: 0003:    
1759: 0003: \********************************************************************
1760: 0003: \***
1761: 0003: \***    PSD8500 functions
1762: 0003: \***
1763: 0003: \********************************************************************
1764: 0003: 
1765: 0003: \********************************************************************
1766: 0003: \***
1767: 0003: \***    FUNCTION        ENDF
1768: 0003: \***
1769: 0003: \***    DM ENDF Function
1770: 0003: \***
1771: 0003: \********************************************************************
1772: 0003: 
1773: 0003:    DEF ENDF EXTERNAL               REM ENDF method of return.
1774: 0003:       INTEGER ENDF
1775: 0003:    FEND
1776: 0003: 
1777: 0003: 
1778: 0003: 
1779: 0003: \********************************************************************   !HDC
1780: 0003: \***                                                                    !HDC
1781: 0003: \***    Functions added for location management                         !HDC
1782: 0003: \***                                                                    !HDC
1783: 0003: \********************************************************************   !HDC
1784: 0003: FUNCTION GETN2(P1$,P2) EXTERNAL                                         !HDC
1785: 0003:  INTEGER*2 GETN2                                                        !HDC
1786: 0003:  STRING P1$                                                             !HDC
1787: 0003:  INTEGER*2 P2                                                           !HDC
1788: 0003: END FUNCTION                                                            !HDC
1789: 0003:                                                                         !HDC
1790: 0003: !*********************************************************************  !HDC
1791: 0003: !                                                                       !HDC
1792: 0003: ! PUTN2                                                                 !HDC
1793: 0003: !                                                                       !HDC
1794: 0003: ! This routine inserts a two byte integer into a string.                !HDC
1795: 0003: ! P2 is the offset within the string and P3 is the source integer       !HDC
1796: 0003: !                                                                       !HDC
1797: 0003: !*********************************************************************  !HDC
1798: 0003:  FUNCTION PUTN2(P1$,P2,P3) EXTERNAL                                     !HDC
1799: 0003:  INTEGER*1 PUTN2                                                        !IDC
1800: 0003:  STRING P1$                                                             !HDC
1801: 0003:  INTEGER*2 P2,P3                                                        !HDC
1802: 0003:  END FUNCTION                                                           !HDC
1803: 0003: 
1804: 0003: !***********************************************************************!IDC
1805: 0003: !***                                                                    !IDC
1806: 0003: !***    FUNCTION        FUNC.GET.LOCATION$(F.RECORD%,F.NAME%)           !IDC
1807: 0003: !***                                                                    !IDC
1808: 0003: !***    Returns the location information; status, description (short or !IDC
1809: 0003: !***    long) based on F.DETAIL;                                        !IDC
1810: 0003: !***    0=Status, 1=Short, 2=Long                                       !IDC
1811: 0003: !***    and the passed location number in F.RECORD%.                    !IDC
1812: 0003: !***                                                                    !IDC
1813: 0003: !***    Hard coded defaults in case a parcel has no value set.          !IDC
1814: 0003: !***                                                                    !IDC
1815: 0003: !***********************************************************************!IDC
1816: 0003: FUNCTION FUNC.GET.LOCATION$(F.RECORD%,F.DETAIL%) PUBLIC                 !IDC
1817: 0027:     STRING      FUNC.GET.LOCATION$                                      !IDC
1818: 0027:     INTEGER*2   F.DETAIL%                                               !IDC
1819: 0027:     INTEGER*2   F.RECORD%                                               !IDC
1820: 0027:     STRING      F.LOCATION$                                             !IDC
1821: 0027: 
1822: 0027:                                                                         !IDC
1823: 0027:     F.LOCATION$ = ""                                                    !IDC
1824: 003c:     IF F.RECORD% = 0 THEN BEGIN           ! nothing set yet             !IDC
1825: 004a:         ! litterals hard-coded here as fallback if file error           !IDC
1826: 004a:         !                       12345678901234567890                    !IDC
1827: 004a:         BDCLOCON.SHORT.NAME$ = "NOT SET   "                             !IDC
1828: 0061:         BDCLOCON.LONG.NAME$  = "NO LOCATION ON FILE "                   !IDC
1829: 0078:         BDCLOCON.STATUS$     = "I"                                      !IDC
1830: 0092:     ENDIF ELSE BEGIN                                                    !IDC
1831: 009a:         BDCLOCON.RECORD.NUM% = F.RECORD%                                !IDC
1832: 00ac: 
1833: 00ac:         ! Opening BDCLOCON file for reading                             !QCK
1834: 00ac:         IF NOT BDCLOCON.OPEN THEN BEGIN                                 !QCK
1835: 00be:             CURRENT.REPORT.NUM% = BDCLOCON.REPORT.NUM%                  !QCK
1836: 00d4:             FILE.OPERATION$     = "O"  ! Open                           !QCK
1837: 00eb:                                                                         !QCK
1838: 00eb:             ! Open BDCLOCON file                                        !QCK
1839: 00eb:             OPEN BDCLOCON.FILE.NAME$ DIRECT RECL BDCLOCON.RECL% AS \    !QCK
1840: 0117:             BDCLOCON.SESS.NUM%                                          !QCK
1841: 0117:                                                                         !QCK
1842: 0117:             ! Set the open flag                                         !QCK
1843: 0117:             BDCLOCON.OPEN = TRUE                                        !QCK
1844: 0129:         ENDIF                                                           !QCK
1845: 0131: 
1846: 0131:         CALL READ.BDCLOCON                                              !IDC
1847: 013e: 
1848: 013e:         ! Closing BDCLOCON file                                         !QCK
1849: 013e:         IF BDCLOCON.OPEN THEN BEGIN                                     !QCK
1850: 0150:             CLOSE BDCLOCON.SESS.NUM%                                    !QCK
1851: 0164:                                                                         !QCK
1852: 0164:             ! Reset the flag                                            !QCK
1853: 0164:             BDCLOCON.OPEN = FALSE                                       !QCK
1854: 0176:         ENDIF                                                           !QCK
1855: 017e: 
1856: 017e:     ENDIF                                                               !IDC
1857: 0186:                                                                         !IDC
1858: 0186:                                                                         !IDC
1859: 0186:     IF F.DETAIL% = 0 THEN BEGIN                                         !IDC
1860: 0194:         F.LOCATION$ = BDCLOCON.STATUS$                                  !IDC
1861: 01b2:     ENDIF ELSE \                                                        !IDC
1862: 01ba:     IF F.DETAIL% = 1 THEN BEGIN                                         !IDC
1863: 01c8:         F.LOCATION$ = BDCLOCON.SHORT.NAME$                              !IDC
1864: 01e6:     ENDIF ELSE \                                                        !IDC
1865: 01ee:     IF F.DETAIL% = 2 THEN BEGIN                                         !IDC
1866: 01fc:         F.LOCATION$ = BDCLOCON.LONG.NAME$                               !IDC
1867: 0218:     ENDIF                                                               !IDC
1868: 0220:                                                                         !IDC
1869: 0220:     FUNC.GET.LOCATION$ = F.LOCATION$                                    !IDC
1870: 023a:                                                                         !IDC
1871: 023a: 
1872: 023a: END FUNCTION                                                            !IDC
1873: 0253: 
1874: 0253: !***********************************************************************!JDC
1875: 0253: !***                                                                    !JDC
1876: 0253: !***    FUNCTION        FUNC.PROMPT.FOR.RESPONSE%(F.MESSAGE$)           !JDC
1877: 0253: !***                                                                    !JDC
1878: 0253: !***    Displays the passsed message and passes back the response key.  !JDC
1879: 0253: !***    F.MESSAGE$ is the prompt to dispay                              !JDC
1880: 0253: !***    This function will only accept F3 or ENETER as valid key press. !JDC
1881: 0253: !***    Uses ENTER.KEY% and F3.KEY% globals                             !JDC
1882: 0253: !***                                                                    !JDC
1883: 0253: !***********************************************************************!JDC
1884: 0253: FUNCTION FUNC.PROMPT.FOR.RESPONSE%(F.MESSAGE$)                          !JDC
1885: 027c:     INTEGER*2   FUNC.PROMPT.FOR.RESPONSE%                               !JDC
1886: 027c:     STRING      F.MESSAGE$                                              !JDC
1887: 027c:     INTEGER*2   F.KEY.PRESS%                                            !JDC
1888: 027c:                                                                         !JDC
1889: 027c:     F.KEY.PRESS% = 99               ! set as invalid key                !JDC
1890: 028a:     WHILE F.KEY.PRESS% <> ENTER.KEY%                \                   !JDC
1891: 0294:     AND F.KEY.PRESS% <> F3.KEY%                                         !JDC
1892: 0294:         F.KEY.PRESS% = DM.INVISIBLE.INPUT("221 "    \                   !JDC
1893: 02c8:                              + "'"+F.MESSAGE$+"' "  \                   !JDC
1894: 02c8:                              + "MESSAGE")                               !JDC
1895: 02c8:     WEND                                                                !JDC
1896: 02f6:     FUNC.PROMPT.FOR.RESPONSE% = F.KEY.PRESS%                            !JDC
1897: 0304:                                                                         !JDC
1898: 0304: END FUNCTION                                                            !JDC
1899: 0320: \***********************************************************************!MLJ
1900: 0320: \* FUNC.IS.ALPHANUMERIC:                                                !MLJ
1901: 0320: \* This function checks if the data is alphanumeric or not              !MLJ
1902: 0320: \*    - returns -1 if alphanumeric, 0 if not alphanumeric               !MLJ
1903: 0320: \*                                                                      !MLJ
1904: 0320: \***********************************************************************!MLJ
1905: 0320: FUNCTION FUNC.IS.ALPHANUMERIC (DATA$)                                   !MLJ
1906: 0349:                                                                         !MLJ
1907: 0349:     INTEGER*2   FUNC.IS.ALPHANUMERIC                                    !MLJ
1908: 0349:     STRING      DATA$                                                   !MLJ
1909: 0349:     STRING      TEST$                                                   !MLJ
1910: 0349:                                                                         !MLJ
1911: 0349:     DATA$ = UCASE$(DATA$)                                               !MLJ
1912: 0366:     DATA$ = TRANSLATE$(DATA$, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ #", \MLJ
1913: 038b:                               "#####################################_") !MLJ
1914: 038b:     TEST$ = STRING$(LEN(DATA$), "#")                                    !MLJ
1915: 03b2:     FUNC.IS.ALPHANUMERIC = DATA$ = TEST$                                !MLJ
1916: 03dd:                                                                         !MLJ
1917: 03dd: END FUNCTION                                                            !MLJ
1918: 03f9: \***********************************************************************!MLJ
1919: 03f9: \* FUNC.IS.SAME.SEQ:                                                    !MLJ
1920: 03f9: \* This function checks if the data has sequentially same characters    !MLJ
1921: 03f9: \*    - returns 0 if the same character repeats 3 times                 !MLJ
1922: 03f9: \*                                                                      !MLJ
1923: 03f9: \***********************************************************************!MLJ
1924: 03f9: FUNCTION FUNC.IS.SAME.SEQ(DATA$)                                        !MLJ
1925: 0422:                                                                         !MLJ
1926: 0422:     INTEGER*2   COUNTER%                                                !MLJ
1927: 0422:     INTEGER*2   FIND.POS%                                               !MLJ
1928: 0422:     INTEGER*2   FUNC.IS.SAME.SEQ                                        !MLJ
1929: 0422:     STRING      DATA$                                                   !MLJ
1930: 0422:                                                                         !MLJ
1931: 0422:     FIND.POS% = 0                !Initialise position                   !MLJ
1932: 0430:     COUNTER%  = 1                !Initialise counter                    !MLJ
1933: 043e:     WHILE (FIND.POS% = 0) AND (COUNTER% < LEN(DATA$))                   !MLJ
1934: 0449:         IF MID$(DATA$,COUNTER%,1) <> " " THEN BEGIN                     !MLJ
1935: 047b:             FIND.POS% = MATCH(STRING$(3,UCASE$(MID$(DATA$,COUNTER%,1))),\WCK
1936: 04e4:                               UCASE$(DATA$),1)                          !WCK
1937: 04e4:         ENDIF                                                           !MLJ
1938: 04ec:         COUNTER% = COUNTER% + 1                                         !MLJ
1939: 04f8:     WEND                                                                !MLJ
1940: 052a:                                                                         !MLJ
1941: 052a:     FUNC.IS.SAME.SEQ = FIND.POS% = 0                                    !MLJ
1942: 0544:                                                                         !MLJ
1943: 0544: END FUNCTION                                                            !MLJ
1944: 0560: \***********************************************************************!MLJ
1945: 0560: \* FUNC.IS.SAME.NAME:                                                   !MLJ
1946: 0560: \* This function checks if same data is already there on other fields   !MLJ
1947: 0560: \*    - returns 0 if the same data is already there                     !MLJ
1948: 0560: \*                                                                      !MLJ
1949: 0560: \***********************************************************************!MLJ
1950: 0560: FUNCTION FUNC.IS.SAME.NAME(DATA$)                                       !MLJ
1951: 0589:                                                                         !MLJ
1952: 0589:     INTEGER*1   EXIT.LOOP         !BOOLEAN                              !MLJ
1953: 0589: !   INTEGER*1   START.POS.SET     !BOOLEAN                              !ADCK
1954: 0589:                                                                         !ADCK
1955: 0589:     INTEGER*2   COUNTER%                                                !MLJ
1956: 0589:     INTEGER*2   CURR.INDEX%       !Current index on screen              !ADCK
1957: 0589:     INTEGER*2   CURR.RECORD%      !Current record for the field         !ADCK
1958: 0589:     INTEGER*2   FUNC.IS.SAME.NAME                                       !MLJ
1959: 0589:                                                                         !MLJ
1960: 0589:     STRING      BLANK.DATA$  !BLANK DATA                                !ADCK
1961: 0589:     STRING      COMP.FIELD$                                             !MLJ
1962: 0589:     STRING      CURR.FIELD$                                             !MLJ
1963: 0589:     STRING      DATA$                                                   !MLJ
1964: 0589:                                                                         !MLJ
1965: 0589:     ! Initialise the flag                                               !ADCK
1966: 0589:     FUNC.IS.SAME.NAME = TRUE                                            !ADCK
1967: 0598:     BLANK.DATA$ =  STRING$(LEN(DATA$)," ")                              !ADCK
1968: 05bf:     ! If the field description value is null then exit function         !ADCK
1969: 05bf:     IF (DATA$ = "" OR DATA$ = BLANK.DATA$) THEN BEGIN                   !ADCK
1970: 060b:         EXIT FUNCTION                                                   !ADCK
1971: 0616:     ENDIF                                                               !ADCK
1972: 061e:                                                                         !ADCK
1973: 061e:     ! Opening BDCLOCON file                                             !ADCK
1974: 061e:     IF NOT BDCLOCON.OPEN THEN BEGIN                                     !ADCK
1975: 0630:         CURRENT.REPORT.NUM% = BDCLOCON.REPORT.NUM%                      !ADCK
1976: 0646:         FILE.OPERATION$     = "O"   ! Open                              !ADCK
1977: 065d:                                                                         !ADCK
1978: 065d:         ! Open the file BDCLOCON                                        !ADCK
1979: 065d:         ! Open error is captured in ON ERROR subroutine ERR.DETECTED    !ADCK
1980: 065d:         OPEN BDCLOCON.FILE.NAME$ DIRECT RECL BDCLOCON.RECL% AS \        !ADCK
1981: 0689:         BDCLOCON.SESS.NUM%                                              !ADCK
1982: 0689:                                                                         !ADCK
1983: 0689:         ! Set the open flag                                             !ADCK
1984: 0689:         BDCLOCON.OPEN = TRUE                                            !ADCK
1985: 069b:     ENDIF                                                               !ADCK
1986: 06a3:                                                                         !ADCK
1987: 06a3:     COUNTER%    = 1                         ! Initialise counter        !ADCK
1988: 06b1:     CURR.FIELD$ = UCASE$(FIELD$(DM.FIELD%)) ! Current field in U.Case   !ADCK
1989: 06e3:     EXIT.LOOP   = FALSE                     ! Initialising flag         !ADCK
1990: 06f1:                                                                         !ADCK
1991: 06f1:     CALL TRIM(CURR.FIELD$)                  !Trim the spaces            !ADCK
1992: 0705:                                                                         !ADCK
1993: 0705:     ! Finding the current record no.                                    !ADCK
1994: 0705:     CURR.INDEX%  = DM.FIELD% + \                                        !ADCK
1995: 0729:                    ((SCRN2% - 1) * (LPP2% - LOC.FIELDS.START% + 1))     !ADCK
1996: 0729:     CURR.RECORD% = CURR.INDEX%/LOC.FIELDS.PER.LINE%                     !ADCK
1997: 073c:                                                                         !ADCK
1998: 073c:     ! Compare the current field with location desc. of every record     !ADCK
1999: 073c:     WHILE ((COUNTER% <= BDCLOCON.TOTAL.RECORDS%) AND (NOT EXIT.LOOP))   !ADCK
2000: 0747:         BDCLOCON.RECORD.NUM% = COUNTER%                                 !ADCK
2001: 0759:         IF BDCLOCON.RECORD.NUM% <> CURR.RECORD% THEN BEGIN              !ADCK
2002: 0771:                                                                         !ADCK
2003: 0771:             ! Read from BDCLOCON and if read was success                !ADCK
2004: 0771:             IF NOT READ.BDCLOCON THEN BEGIN                             !ADCK
2005: 0785:                 COMP.FIELD$ = UCASE$(BDCLOCON.LONG.NAME$)               !ADCK
2006: 07a6:                 CALL TRIM(COMP.FIELD$)     !Trim the spaces             !ADCK
2007: 07ba:                 ! If current field value is equal to that of the record !ADCK
2008: 07ba:                 IF CURR.FIELD$ = COMP.FIELD$                  AND    \  !ADCK
2009: 0820:                    BDCLOCON.LONG.NAME$ <> STRING$(LEN(DATA$)," ")    \  !ADCK
2010: 0820:                                                               THEN BEGIN!ADCK
2011: 0820:                     EXIT.LOOP         = TRUE   ! To exit the while loop !ADCK
2012: 082e:                     FUNC.IS.SAME.NAME = FALSE  ! Set the flag           !ADCK
2013: 083d:                 ENDIF                                                   !ADCK
2014: 0848:             ENDIF ELSE BEGIN                                            !ADCK
2015: 0850:                 ! If reading BDCLOCON was failure                       !ADCK
2016: 0850:                 EXIT.LOOP = TRUE                                        !ADCK
2017: 085e:                 ! Prompt screen if error on updating                    !ADCK
2018: 085e:                 CALL DM.HIDE.FN.KEY(10)                                 !ADCK
2019: 086f:                                                                         !ADCK
2020: 086f:                 EVENT.NUMBER%   = 106                                   !ADCK
2021: 087d:                 MESSAGE.NUMBER% = 221                                   !ADCK
2022: 088b:                 VAR.STRING.1$   = STR$(BDCLOCON.REPORT.NUM%) +         \!ADCK
2023: 08be:                                   ERR                                   !ADCK
2024: 08be:                 VAR.STRING.2$   = "Unable to read location file "  +   \!ADCK
2025: 08da:                                   "BDCLOCON. Press ESC."                !ADCK
2026: 08da:                                                                         !ADCK
2027: 08da:                 CALL APPLICATION.LOG( MESSAGE.NUMBER%,                 \!ADCK
2028: 0903:                                       VAR.STRING.1$, VAR.STRING.2$,    \!ADCK
2029: 0903:                                       EVENT.NUMBER% )                   !ADCK
2030: 0903:                 ! Set the counter to exit the while loop                !ADCK
2031: 0903:                 COUNTER% = BDCLOCON.TOTAL.RECORDS% + 1                  !ADCK
2032: 091d:             ENDIF                                                       !ADCK
2033: 0925:                                                                         !ADCK
2034: 0925:         ENDIF                                                           !ADCK
2035: 092d:         COUNTER% = COUNTER% + 1                                         !ADCK
2036: 0939:     WEND                                                                !ADCK
2037: 096e:     ! Closing BDCLOCON file                                             !ADCK
2038: 096e:     IF BDCLOCON.OPEN THEN BEGIN                                         !ADCK
2039: 0980:         CLOSE BDCLOCON.SESS.NUM%                                        !ADCK
2040: 0994:                                                                         !ADCK
2041: 0994:         ! Reset the flag                                                !ADCK
2042: 0994:         BDCLOCON.OPEN = FALSE                                           !ADCK
2043: 09a6:     ENDIF                                                               !ADCK
2044: 09ae:                                                                         !ADCK
2045: 09ae: END FUNCTION                                                            !ADCK
2046: 09ca: \********************************************************************
2047: 09ca: \***
2048: 09ca: \***    FUNCTION        SET.F.KEYS
2049: 09ca: \***
2050: 09ca: \***    Set F Key visability according to status of passed index
2051: 09ca: \***
2052: 09ca: \********************************************************************
2053: 09ca: 
2054: 09ca: FUNCTION SET.F.KEYS(index%)
2055: 09ee: 
2056: 09ee:     INTEGER*2 index%
2057: 09ee:     INTEGER*1 f.key%
2058: 09ee:     INTEGER*2 F.LOCATION%                                               !IDC
2059: 09ee:     INTEGER*2 KEY%          ! Stores key entered                        !TAH
2060: 09ee:     STRING    F.STATUS$                                                 !IDC
2061: 09ee: 
2062: 09ee:     KEY% = ENDF             ! Get the key entered                       !TAH
2063: 09fe:     IF CURRENT.SCREEN% = 1 THEN BEGIN                                   !IDC
2064: 0a10:         ! The variable f.key% is updated as 2 for the statuses          !IDC
2065: 0a10:         ! "Uncollected-Return to W/H?", "Instore-Awaiting collection"   !IDC
2066: 0a10:         ! and "Instore-Found". f.key% is updated as 1 for the status    !IDC
2067: 0a10:         ! "Lost"                                                        !IDC
2068: 0a10:         F.STATUS$ = LEFT$(P.ARR$(INDEX%),1)                             !LLJ
2069: 0a3f:         IF F.STATUS$ = "3"  \ Uncollected - return to W/H?              !IDC
2070: 0ab0:         OR F.STATUS$ = "4"  \ Instore-Awaiting collection               !IDC
2071: 0ab0:         OR F.STATUS$ = "5"  \ Instore-Found                             !IDC
2072: 0ab0:         THEN BEGIN                                                      !IDC
2073: 0ab0:             F.KEY% = 2                                                  !LLJ
2074: 0abf:         ENDIF ELSE \                                                    !IDC
2075: 0ac7:         IF F.STATUS$ = "8" \  Lost                                      !IDC
2076: 0ae2:         THEN BEGIN                                                      !IDC
2077: 0ae2:             f.key% = 1                                                  !FMM
2078: 0af1:         ENDIF ELSE BEGIN                                                !FMM
2079: 0af9:             f.key% = 0                                                  !FMM
2080: 0b06:         ENDIF                                                           !FMM
2081: 0b0e: 
2082: 0b0e:         IF f.key% > 0 THEN BEGIN
2083: 0b20:             IF f.key% = 1 THEN BEGIN
2084: 0b2f:                 CALL DM.SHOW.FN.KEY( 6, "FOUND")
2085: 0b45:                 CALL DM.HIDE.FN.KEY( 5)
2086: 0b56:                 CALL DM.HIDE.FN.KEY( 4)
2087: 0b69:             ENDIF ELSE IF f.key% = 2 THEN BEGIN
2088: 0b78:                 CALL DM.SHOW.FN.KEY( 6, "LOST ")
2089: 0b8e:                 CALL DM.SHOW.FN.KEY( 5, "")
2090: 0ba4:                 CALL DM.SHOW.FN.KEY( 4, "CLLCT ")                       !AGCS
2091: 0bba:             ENDIF
2092: 0bc5:         ENDIF ELSE BEGIN
2093: 0bcd:             IF F.STATUS$ < "3"  THEN BEGIN ! Expected or Late Delivery  !AGCS
2094: 0be8:                 CALL DM.SHOW.FN.KEY( 4, "BOOKIN")                       !AGCS
2095: 0c00:             ENDIF ELSE BEGIN                                            !AGCS
2096: 0c08:                 CALL DM.HIDE.FN.KEY( 4)
2097: 0c19:             ENDIF                                                       !AGCS
2098: 0c21: 
2099: 0c21:             CALL DM.HIDE.FN.KEY( 6)
2100: 0c32:             CALL DM.HIDE.FN.KEY( 5)
2101: 0c43:         ENDIF
2102: 0c4b: 
2103: 0c4b:         ! if Location Status does not allows Location allocation        !IDC
2104: 0c4b:         F10.NOT.ALLOWED = GETN2(RIGHT$(P.ARR$(INDX%),2),0)              !IDC
2105: 0c8b:         IF F10.NOT.ALLOWED THEN BEGIN                                   !IDC
2106: 0c9a:             ! supress the F10 for locations not allowed                 !IDC
2107: 0c9a:             CALL DM.HIDE.FN.KEY(10)                                     !IDC
2108: 0cad:         ENDIF ELSE BEGIN                                                !IDC
2109: 0cb5:             CALL DM.SHOW.FN.KEY(10, LOCATION.FN.TEXT$)                  !IDC
2110: 0ccf:         ENDIF                                                           !IDC
2111: 0cda:                                                                         !IDC
2112: 0cda:     ENDIF ELSE \                                                        !IDC
2113: 0ce2:     IF CURRENT.SCREEN% = 2 \                                            !IDC
2114: 0cf4:     THEN BEGIN                                                          !IDC
2115: 0cf4:         !Displaying the help value in the help button - F1 key.         !TAH
2116: 0cf4:         CALL DM.SHOW.FN.KEY(1,"HELP")                                   !TAH
2117: 0d0a:         F.LOCATION% = (INDEX%)/LOC.FIELDS.PER.LINE%                     !TAH
2118: 0d1d: 
2119: 0d1d:         !Checking whether we are traversing backward                    !TAH
2120: 0d1d:         !Modified - traversing backward only if field change is accepted!ZCK
2121: 0d1d:         !Since the value of KEY% may get changed adding usage of key    !ADCK
2122: 0d1d:         !action                                                         !ADCK
2123: 0d1d:         IF (KEY% = BTAB.KEY% OR KEY% = UP.KEY% OR KEY.ACTION% = 2) AND \!ADCK
2124: 0d5c:             CHANGE.ACCEPTED THEN BEGIN                                  !ZCK
2125: 0d5c:             F.LOCATION% = CURRENT.LOCATION%                             !TAH
2126: 0d6a:             !If screen has not changed, location field is not 1st and   !TAH
2127: 0d6a:             !there is no error on location, decrement location field    !TAH
2128: 0d6a:             IF SCREEN.CHANGED = FALSE    AND                       \    !TAH
2129: 0da0:                F.LOCATION% > 1           AND                       \    !TAH
2130: 0da0:                ERROR.ON.LOCATION = FALSE THEN BEGIN                     !TAH
2131: 0da0:                 !Traversing backward                                    !TAH
2132: 0da0:                 F.LOCATION% = F.LOCATION% - 1                           !TAH
2133: 0dac:             ENDIF                                                       !TAH
2134: 0db7:         !Since the value of KEY% may get changed adding usage of key    !ADCK
2135: 0db7:         !action                                                         !ADCK
2136: 0db7:         ENDIF ELSE IF (KEY% = TAB.KEY%    OR                       \    !ADCK
2137: 0df6:                        KEY% = DOWN.KEY%   OR                       \    !ADCK
2138: 0df6:                        KEY.ACTION% = 3)   AND                      \    !ADCK
2139: 0df6:                       CHANGE.ACCEPTED THEN BEGIN                        !ZCK
2140: 0df6:             !Checking whether we are traversing forward if field change !ZCK
2141: 0df6:             !accepted                                                   !ZCK
2142: 0df6:             F.LOCATION% = CURRENT.LOCATION%                             !TAH
2143: 0e04:             !If screen has not changed, location field is not last one  !TAH
2144: 0e04:             !and there is no error on location, increment location field!TAH
2145: 0e04:             IF SCREEN.CHANGED = FALSE      AND                     \    !TAH
2146: 0e3b:                F.LOCATION% < 180           AND                     \    !TAH
2147: 0e3b:                ERROR.ON.LOCATION = FALSE   THEN BEGIN                   !TAH
2148: 0e3b:                 !Traversing forward                                     !TAH
2149: 0e3b:                 F.LOCATION% = F.LOCATION% + 1                           !TAH
2150: 0e47:             ENDIF                                                       !TAH
2151: 0e52:         ENDIF ELSE IF KEY% = HOME.KEY% THEN BEGIN                       !TAH
2152: 0e67:             !If HOME key is pressed, get the location field of first    !TAH
2153: 0e67:             !record on the existing screen                              !TAH
2154: 0e67:             CURRENT.INDEX% =  INITIAL.FIELD.INDEX%  +              \    !TAH
2155: 0e8b:                               ((SCRN2% - 1)         *              \    !TAH
2156: 0e8b:                                (LPP2% - LOC.FIELDS.START% + 1))         !TAH
2157: 0e8b:             F.LOCATION%    = (CURRENT.INDEX%)/LOC.FIELDS.PER.LINE%      !TAH
2158: 0ea0:         ENDIF ELSE IF KEY% = END.KEY% THEN BEGIN                        !TAH
2159: 0eb5:             !If END key is pressed, get the location field of last      !TAH
2160: 0eb5:             !record on the existing screen                              !TAH
2161: 0eb5:             CURRENT.INDEX% = LPP2%         +                       \    !TAH
2162: 0ed6:                              ((SCRN2% - 1) *                       \    !TAH
2163: 0ed6:                               (LPP2% - LOC.FIELDS.START% + 1))          !TAH
2164: 0ed6:             F.LOCATION%    = (CURRENT.INDEX%)/LOC.FIELDS.PER.LINE%      !TAH
2165: 0eeb:         ENDIF ELSE BEGIN                                                !TAH
2166: 0ef3:             F.LOCATION% = (INDEX%)/LOC.FIELDS.PER.LINE%                 !TAH
2167: 0f06:         ENDIF                                                           !TAH
2168: 0f0e: 
2169: 0f0e:         ! If status of the location is "A" (active)                     !TAH
2170: 0f0e:         IF FUNC.GET.LOCATION$(F.LOCATION%,0) = "A" THEN BEGIN           !IDC
2171: 0f3c:             ! if active location                                        !IDC
2172: 0f3c:             IF MANAGE.LOCATION THEN BEGIN                               !IDC
2173: 0f4e:                 IF FUNC.GET.LOCATION$(F.LOCATION%,2) =             \    !TAH
2174: 0f79:                    "Booked in at Till" THEN BEGIN                       !TAH
2175: 0f79:                     CALL DM.HIDE.FN.KEY(6)                              !TAH
2176: 0f8a:                     NOT.DEFAULT.LOCATION = FALSE                        !TAH
2177: 0f9b:                 ENDIF ELSE BEGIN                                        !TAH
2178: 0fa3:                     ! If the key entered is F6 swap, status change      !AFCS
2179: 0fa3:                     ! is accepted and the parcel count in location      !AFCS
2180: 0fa3:                     ! is <= 0 then change F6 key value to 'ACTIV'       !AFCS
2181: 0fa3:                     ! Since the value of KEY% may get changed adding    !ADCK
2182: 0fa3:                     ! usage of key action                               !ADCK
2183: 0fa3:                     IF (KEY% = F6.KEY% OR KEY.ACTION% = 1)    AND   \   !ADCK
2184: 0fed:                        (CHANGE.ACCEPTED = TRUE)               AND   \   !AFCS
2185: 0fed:                        (BDCLOCON.PARCEL.COUNT% <= 0)          THEN BEGIN!AFCS
2186: 0fed:                         CALL DM.SHOW.FN.KEY(6, ACTIVATE.FN.TEXT$)       !TAH
2187: 1009:                     ENDIF ELSE IF KEY% <> F6.KEY% THEN BEGIN            !ADCK
2188: 101e:                         ! If key pressed is not F6, show F6 as 'INACT'  !ADCK
2189: 101e:                         CALL DM.SHOW.FN.KEY(6, DEACTIVATE.FN.TEXT$)     !TAH
2190: 1038:                     ENDIF                                               !TAH
2191: 1040:                 ENDIF                                                   !TAH
2192: 104a:             ENDIF ELSE BEGIN                                            !IDC
2193: 1052:                 F10.NOT.ALLOWED = 0                                     !IDC
2194: 105f:                 CALL DM.SHOW.FN.KEY(10, LOCATION.FN.TEXT$)              !IDC
2195: 1079:             ENDIF                                                       !IDC
2196: 1084:         ENDIF ELSE BEGIN                                                !IDC
2197: 108c:             ! if inactive location                                      !IDC
2198: 108c:             IF MANAGE.LOCATION THEN BEGIN                               !IDC
2199: 109e:                 ! If the key entered is F6, and status change is        !ADCK
2200: 109e:                 ! accepted then change F6 key value to 'INACT'          !ADCK
2201: 109e:                 ! Since the value of KEY% may get changed adding        !ADCK
2202: 109e:                 ! usage of key action                                   !ADCK
2203: 109e:                 IF (KEY% = F6.KEY% OR KEY.ACTION% = 1)        AND   \   !ADCK
2204: 10d6:                    (CHANGE.ACCEPTED = TRUE)                   THEN BEGIN!ADCK
2205: 10d6:                     CALL DM.SHOW.FN.KEY(6, DEACTIVATE.FN.TEXT$)         !TAH
2206: 10f2:                 ENDIF ELSE IF KEY% <> F6.KEY% THEN BEGIN                !ADCK
2207: 1107:                     ! If key pressed is not F6, show F6 as 'ACTIV'      !ADCK
2208: 1107:                     CALL DM.SHOW.FN.KEY(6, ACTIVATE.FN.TEXT$)           !IDC
2209: 1121:                 ENDIF                                                   !TAH
2210: 112b:             ENDIF ELSE BEGIN                                            !IDC
2211: 1133:                 ! hide selection and don't allow F10                    !IDC
2212: 1133:                 F10.NOT.ALLOWED = 1                                     !IDC
2213: 1140:                 CALL DM.HIDE.FN.KEY(10)                                 !IDC
2214: 1151:             ENDIF                                                       !IDC
2215: 1159:         ENDIF                                                           !IDC
2216: 1161: 
2217: 1161:         ! If default location (1st location field), hide F6 button      !TAH
2218: 1161:         IF NOT NOT.DEFAULT.LOCATION THEN BEGIN                          !TAH
2219: 1170:             !If the flag is false, it means that the current location   !TAH
2220: 1170:             !is the default location. So the F6 key is kept hidden.     !TAH
2221: 1170:             CALL DM.HIDE.FN.KEY(6)                                      !TAH
2222: 1181:         ENDIF                                                           !TAH
2223: 1189:         CURRENT.LOCATION% = F.LOCATION%                                 !TAH
2224: 1197:         !Reset the location error check flag to false                   !TAH
2225: 1197:         ERROR.ON.LOCATION = FALSE                                       !TAH
2226: 11a5: 
2227: 11a5:         IF SCRN2% < MAX.SCRN2% THEN BEGIN                               !LLJ
2228: 11b6:             CALL DM.SHOW.FN.KEY(8 , "")                                 !JDC
2229: 11ce:         ENDIF ELSE BEGIN                                                !JDC
2230: 11d6:             CALL DM.HIDE.FN.KEY( 8)                                     !JDC
2231: 11e7:         ENDIF                                                           !JDC
2232: 11ef:         IF SCRN2% > 1 THEN BEGIN                                        !LLJ
2233: 11fe:             CALL DM.SHOW.FN.KEY( 7, "")                                 !JDC
2234: 1216:         ENDIF ELSE BEGIN                                                !JDC
2235: 121e:             CALL DM.HIDE.FN.KEY( 7)                                     !JDC
2236: 122f:         ENDIF                                                           !JDC
2237: 1237: 
2238: 1237:         CALL DM.HIDE.FN.KEY( 9)                                         !JDC
2239: 1248:         IF MANAGE.LOCATION THEN BEGIN                                   !JDC
2240: 1257:             CALL DM.HIDE.FN.KEY(10)                                     !JDC
2241: 126a:         ENDIF ELSE BEGIN                                                !JDC
2242: 1272:             CALL DM.SHOW.FN.KEY(10, "")                                 !JDC
2243: 1288:         ENDIF                                                           !JDC
2244: 1290: 
2245: 1290:         !Reset the screen changed flag                                  !TAH
2246: 1290:         IF SCREEN.CHANGED = TRUE THEN BEGIN                             !TAH
2247: 12a1:             SCREEN.CHANGED = FALSE                                      !TAH
2248: 12af:         ENDIF                                                           !TAH
2249: 12b7:     ENDIF                                                               !IDC
2250: 12bf: 
2251: 12bf: END FUNCTION
2252: 12d3: 
2253: 12d3: !***********************************************************************
2254: 12d3: !***
2255: 12d3: !***    FUNCTION        FUNC.UPDATE.ALL.LOCATION.RECORDS%               !IDC
2256: 12d3: !***
2257: 12d3: !***    Updates all of the Location records from the display array
2258: 12d3: !***    LOCATION.ARRAY$ and returns 0 for OK or the number of the failing
2259: 12d3: !***    record otherwise.
2260: 12d3: !***
2261: 12d3: !***    Calculation by field on the logic below;
2262: 12d3: !***    Position in DMED array  1XX 2XX 3XX 4XX    5XX 6XX 7XX 8XX
2263: 12d3: !***    Position on DMED screen 4XX 5XX 6XX 7XX    8XX 9XX 10X 11X
2264: 12d3: !***    Record in file              1                  2
2265: 12d3: !***    File field position     1   R   2   3      1   R   2   3
2266: 12d3: !***
2267: 12d3: !***********************************************************************
2268: 12d3:     FUNCTION FUNC.UPDATE.ALL.LOCATION.RECORDS%                          !QCK
2269: 12f7:         INTEGER*2 COUNTER%                                              !SAH
2270: 12f7:         INTEGER*2 FUNC.UPDATE.ALL.LOCATION.RECORDS%                     !QCK
2271: 12f7:         INTEGER*2 F.RECORD%                                             !QCK
2272: 12f7:         INTEGER*2 F.FIELD%                                              !QCK
2273: 12f7:         INTEGER*2 F.ERR%                                                !QCK
2274: 12f7: 
2275: 12f7:         ! default as OK                                                 !QCK
2276: 12f7:         F.ERR% = 0                                                      !QCK
2277: 1305: 
2278: 1305:         ! Opening BDCLOCON file                                         !QCK
2279: 1305:         IF NOT BDCLOCON.OPEN THEN BEGIN                                 !QCK
2280: 1317:             CURRENT.REPORT.NUM% = BDCLOCON.REPORT.NUM%                  !QCK
2281: 132d:             FILE.OPERATION$     = "O"   ! Open                          !QCK
2282: 1344:                                                                         !QCK
2283: 1344:             ! Open the file BDCLOCON                                    !QCK
2284: 1344:             ! Open error is captured in ON ERROR subroutine ERR.DETECTED!QCK
2285: 1344:             OPEN BDCLOCON.FILE.NAME$ DIRECT RECL BDCLOCON.RECL% AS \    !QCK
2286: 1370:             BDCLOCON.SESS.NUM%                                          !QCK
2287: 1370:                                                                         !QCK
2288: 1370:             ! Set the open flag                                         !QCK
2289: 1370:             BDCLOCON.OPEN = TRUE                                        !QCK
2290: 1382:         ENDIF                                                           !QCK
2291: 138a:                                                                         !RLJ
2292: 138a:         COUNTER% = LOC.FIELDS.START%                                    !SAH
2293: 1398:         ! On all screen fields                                          !RLJ
2294: 1398:         WHILE COUNTER% <=  LPP2%                                        !SAH
2295: 13a3: 
2296: 13a3:             INDX% = COUNTER% + \                                        !SAH
2297: 13c4:                    ((SCRN2% - 1) * (LPP2% - LOC.FIELDS.START% + 1))     !RLJ
2298: 13c4:             ! For valid indexes                                         !RLJ
2299: 13c4:             IF INDX% <= P.CNT2% AND COUNTER% <= LPP2% THEN BEGIN        !SAH
2300: 13ee:                 ! For each BDCLOCON record                              !RLJ
2301: 13ee:                 IF MOD(INDX%,LOC.FIELDS.PER.LINE%) = 0 THEN BEGIN       !RLJ
2302: 1416:                                                                         !RLJ
2303: 1416:                     BDCLOCON.RECORD.NUM% = (INDX%)/LOC.FIELDS.PER.LINE% !RLJ
2304: 142d:                     ! If exceeded the file                              !RLJ
2305: 142d:                     IF BDCLOCON.RECORD.NUM% > BDCLOCON.TOTAL.RECORDS%  \!RLJ
2306: 1456:                                                               THEN BEGIN!RLJ
2307: 1456:                         COUNTER% = LPP2% + 1      !Exit loop            !SAH
2308: 1468:                                                                         !RLJ
2309: 1468:                     ENDIF ELSE BEGIN                                    !RLJ
2310: 1470:                         ! Read error on BDCLOCON                        !RLJ
2311: 1470:                         IF READ.BDCLOCON THEN BEGIN                     !RLJ
2312: 1481:                             COUNTER% = LPP2% + 1   !Exit loop           !SAH
2313: 1493:                         ENDIF ELSE BEGIN                                !RLJ
2314: 149b:                             BDCLOCON.STATUS$    =                      \!SAH
2315: 14c4:                             LOCATION.ARRAY$(COUNTER%)                   !SAH
2316: 14c4:                             BDCLOCON.LONG.NAME$ =                      \!SAH
2317: 14f0:                             LOCATION.ARRAY$(COUNTER% + 2)               !SAH
2318: 14f0:                                                                         !RLJ
2319: 14f0:                             ! If write error                            !RLJ
2320: 14f0:                             IF WRITE.BDCLOCON THEN BEGIN                !RLJ
2321: 1501:                                 F.ERR%   = BDCLOCON.RECORD.NUM%         !RLJ
2322: 1513:                                 COUNTER% = LPP2% + 1   !Exit loop       !SAH
2323: 1522:                             ENDIF                                       !RLJ
2324: 152a:                                                                         !RLJ
2325: 152a:                         ENDIF                                           !RLJ
2326: 1532:                     ENDIF                                               !RLJ
2327: 153a:                 ENDIF                                                   !RLJ
2328: 1542:             ENDIF                                                       !RLJ
2329: 154a:                                                                         !RLJ
2330: 154a:             COUNTER% = COUNTER% + 1        !Increment the sccreen field !SAH
2331: 1556:                                                                         !RLJ
2332: 1556:        WEND                                                             !RLJ
2333: 156a: 
2334: 156a:         ! Closing BDCLOCON file                                         !QCK
2335: 156a:         IF BDCLOCON.OPEN THEN BEGIN                                     !QCK
2336: 157c:             CLOSE BDCLOCON.SESS.NUM%                                    !QCK
2337: 1590:                                                                         !QCK
2338: 1590:             ! Reset the flag                                            !QCK
2339: 1590:             BDCLOCON.OPEN = FALSE                                       !QCK
2340: 15a2:         ENDIF                                                           !QCK
2341: 15aa: 
2342: 15aa:         FUNC.UPDATE.ALL.LOCATION.RECORDS% = F.ERR%                      !QCK
2343: 15b8: 
2344: 15b8:     END FUNCTION                                                        !QCK
2345: 15cf: 
2346: 15cf: \***********************************************************************!ADCK
2347: 15cf: \***                                                                    !ADCK
2348: 15cf: \***    SUB        :       SUB.UPDATE.LOCATIONS                         !ADCK
2349: 15cf: \***                                                                    !ADCK
2350: 15cf: \***    # Prompts to the confirm the change                             !ADCK
2351: 15cf: \***    # If pressed 'ENTER',                                           !ADCK
2352: 15cf: \***        - If the key action was F6 (ACTION% = 1), then clear the    !ADCK
2353: 15cf: \***          field and update in the BDCLOCON file                     !ADCK
2354: 15cf: \***        - If the key action was ARROW/TAB (ACTION% = 2) or DOWN/BTAB!ADCK
2355: 15cf: \***          then just update the new field value in BDCLOCON file     !ADCK
2356: 15cf: \***    # If pressed 'F3'                                               !ADCK
2357: 15cf: \***        - Display the previous value of the field                   !ADCK
2358: 15cf: \***                                                                    !ADCK
2359: 15cf: \***********************************************************************!ADCK
2360: 15cf: SUB SUB.UPDATE.LOCATIONS(ACTION%, DM.FIELD%, VALUE$, VALID, UPDATE)     !ADCK
2361: 15f3:                                                                         !ADCK
2362: 15f3:     INTEGER*1 ACTION%    ! 1 if F6 key press, 2 for ARROW/TAB key press !ADCK
2363: 15f3:     INTEGER*1 UPDATE     !Return TRUE if updated output fields          !ADCK
2364: 15f3:     INTEGER*1 VALID      !Return FALSE if field invalid                 !ADCK
2365: 15f3:                                                                         !ADCK
2366: 15f3:     INTEGER*2 DM.FIELD%  !Field modified                                !ADCK
2367: 15f3:                                                                         !ADCK
2368: 15f3:     STRING    VALUE$     !New value for field (can be modified)         !ADCK
2369: 15f3:                                                                         !ADCK
2370: 15f3:     ! Calculate the correct index of the field                          !ADCK
2371: 15f3:     INDX% = CURRENT.INDEX% +                                           \!ADCK
2372: 1614:             ((SCRN2% - 1) * (LPP2% - LOC.FIELDS.START% + 1))            !ADCK
2373: 1614:                                                                         !ADCK
2374: 1614:     ! Set the message for BEMF 221                                      !ADCK
2375: 1614:     PROMPT.MESSAGE$ = "Update all changes on screen? " +               \!ADCK
2376: 1630:                       "ENTER to confirm or F3 to cancel."               !ADCK
2377: 1630:     RET.KEY% = FUNC.PROMPT.FOR.RESPONSE%(PROMPT.MESSAGE$)               !ADCK
2378: 164a:     ! If 'ENTER' pressed                                                !ADCK
2379: 164a:     IF RET.KEY% = ENTER.KEY% THEN BEGIN                                 !ADCK
2380: 1662:         IF ACTION% = 1 THEN BEGIN                                       !ADCK
2381: 1673:             !Commenting below code as part of US310 O&C Phase2 project  !AFKK
2382: 1673:             !This was blanking the location name incorrectly            !AFKK
2383: 1673: !           LOCATION.ARRAY$(CURRENT.INDEX%) = " "                       !AFKK
2384: 1673:             VALID  = TRUE                                               !AACK
2385: 1684:             UPDATE = TRUE                                               !AACK
2386: 1695:         ENDIF                                                           !ADCK
2387: 169d:         IF MANAGE.LOCATION THEN BEGIN                                   !ADCK
2388: 16af:             ! Set the flag - Accept the field change                    !ADCK
2389: 16af:             CHANGE.ACCEPTED = TRUE                                      !ADCK
2390: 16bd:             ! Update all records                                        !ADCK
2391: 16bd:             LOCATION.NEW% = FUNC.UPDATE.ALL.LOCATION.RECORDS%           !ADCK
2392: 16cc:                                                                         !ADCK
2393: 16cc:             IF LOCATION.NEW% > 0 THEN BEGIN                             !ADCK
2394: 16de:                 ! Prompt screen if error on updating                    !ADCK
2395: 16de:                 CALL DM.HIDE.FN.KEY(10)                                 !ADCK
2396: 16ef:                 EVENT.NUMBER%   = 106                                   !ADCK
2397: 16fd:                 MESSAGE.NUMBER% = 221                                   !ADCK
2398: 170b:                 VAR.STRING.1$   = STR$(LOCATION.NEW%)           +    \  !ADCK
2399: 173a:                                   ERR                                   !ADCK
2400: 173a:                 VAR.STRING.2$   = "Unable to complete update, " +    \  !ADCK
2401: 1774:                                   "fail at location "           +    \  !ADCK
2402: 1774:                                   STR$(LOCATION.NEW%)           +    \  !ADCK
2403: 1774:                                   ". " + "Press ESC."                   !ADCK
2404: 1774:                                                                         !ADCK
2405: 1774:                 CALL APPLICATION.LOG( MESSAGE.NUMBER%, VAR.STRING.1$,\  !ADCK
2406: 179d:                                       VAR.STRING.2$, EVENT.NUMBER% )    !ADCK
2407: 179d:                                                                         !ADCK
2408: 179d:             ENDIF                                                       !ADCK
2409: 17a5:         ENDIF                                                           !ADCK
2410: 17b0:     ENDIF ELSE IF RET.KEY% = F3.KEY% THEN BEGIN                         !ADCK
2411: 17c8:         ! If 'F3' pressed                                               !ADCK
2412: 17c8:         ! Set back the previous description to display                  !ADCK
2413: 17c8:         LOCATION.ARRAY$(CURRENT.INDEX%) =                            \  !ADCK
2414: 17f5:                         FUNC.GET.LOCATION$(INDX%/LOC.FIELDS.PER.LINE%,2)!ADCK
2415: 17f5:         ! Setting the flags as input is not valid and                   !ADCK
2416: 17f5:         ! field change happened                                         !ADCK
2417: 17f5:         VALID = FALSE                                                   !ADCK
2418: 1806:         UPDATE = TRUE                                                   !ADCK
2419: 1817:         ! Field change is not accepted                                  !ADCK
2420: 1817:         CHANGE.ACCEPTED = FALSE                                         !ADCK
2421: 1825:         ! To avoid any error message being displayed                    !ADCK
2422: 1825:         CALL DM.MESSAGE(STR$(CURRENT.INDEX%),BLANK.MSG$)                !ADCK
2423: 1856:     ENDIF                                                               !ADCK
2424: 185e:     ! Clear status message                                              !ADCK
2425: 185e:     CALL DM.STATUS(BLANK.MSG$)                                          !ADCK
2426: 1876:                                                                         !ADCK
2427: 1876: END SUB                                                                 !ADCK
2428: 188a: 
2429: 188a: \********************************************************************
2430: 188a: \***
2431: 188a: \***    SUB        :       DM.FIELD.CHANGED                             !AECS
2432: 188a: \***
2433: 188a: \***    PERFORMS TASKS WHEN CERTAIN FIELDS HAVE BEEN ALTERED
2434: 188a: \***
2435: 188a: \********************************************************************
2436: 188a: 
2437: 188a:     SUB DM.FIELD.CHANGED (DM.SCREEN%,                                \
2438: 188a:                           DM.FIELD%,                                 \
2439: 188a:                           VALUE$,                                    \
2440: 188a:                           VALID,                                     \
2441: 188a:                           UPDATE) PUBLIC
2442: 18ae: 
2443: 18ae:         INTEGER*1 UPDATE     !RETURN TRUE IF UPDATED OUTPUT FIELDS      !OLJ
2444: 18ae:         INTEGER*1 VALID      !RETURN FALSE IF FIELD INVALID             !OLJ
2445: 18ae: 
2446: 18ae:         INTEGER*2 DM.FIELD%  !FIELD MODIFIED                            !OLJ
2447: 18ae:         INTEGER*2 DM.SCREEN% !CURRENT SCREEN NUMBER                     !OLJ
2448: 18ae:         INTEGER*2 KEY%                                                  !OLJ
2449: 18ae:         ! for Locations we need to move by field for editing but by     !IDC
2450: 18ae:         ! record for selection so this manages the next position        !IDC
2451: 18ae:         INTEGER*2 S.FIELD.MOVE%                                         !IDC
2452: 18ae:         INTEGER*2 S.LOCATION%                                           !IDC
2453: 18ae: 
2454: 18ae:         STRING    BLANK.DATA$!BLANK DATA                                !OLJ
2455: 18ae:         STRING    VALUE$     !NEW VALUE FOR FIELD (CAN BE MODIFIED)
2456: 18ae: 
2457: 18ae: 
2458: 18ae:         KEY% = ENDF                                                     !JDC
2459: 18be:         IF DM.SCREEN% = 1 THEN BEGIN
2460: 18d2:             indx% = ((scrn1% -1) *lpp1%) + (DM.FIELD% -1)
2461: 18ee:             IF KEY% = TAB.KEY%                                         \
2462: 1944:             OR ((KEY% = NEXT.KEY%                                      \
2463: 1944:                   OR KEY% = DOWN.KEY% ) AND DM.FIELD% < (lpp1% +1))    \
2464: 1944:                                                          THEN BEGIN
2465: 1944:                 IF indx% < p.cnt% THEN                                 \
2466: 1955:                     indx% = indx% +1
2467: 1964:             ENDIF ELSE IF KEY% = BTAB.KEY%                             \
2468: 19b6:                 OR ((KEY% = PREV.KEY%                                  \
2469: 19b6:                     OR KEY% = UP.KEY%) AND DM.FIELD% > 2) THEN BEGIN
2470: 19b6:                 indx% = indx% -1
2471: 19c5:             ENDIF ELSE IF KEY% = HOME.KEY% THEN BEGIN
2472: 19da:                 indx% = ((scrn1% -1) *lpp1%) +1
2473: 19f0:             ENDIF ELSE IF KEY% = END.KEY%  THEN BEGIN
2474: 1a05:                 indx% = ((scrn1% -1) *lpp1%) + lpp1%
2475: 1a1c:                 IF indx% > p.cnt% THEN indx% = p.cnt%
2476: 1a33:             ENDIF
2477: 1a3e: 
2478: 1a3e:         ENDIF ELSE IF DM.SCREEN% = 2 THEN BEGIN                         !IDC
2479: 1a52:             !Set the default location check flag to true                !TAH
2480: 1a52:             NOT.DEFAULT.LOCATION = TRUE                                 !TAH
2481: 1a60: 
2482: 1a60:             !Reset the field change accept flag to true                 !ZCK
2483: 1a60:             CHANGE.ACCEPTED = TRUE                                      !ZCK
2484: 1a6e: 
2485: 1a6e:             !Reset the key action                                       !ADCK
2486: 1a6e:             KEY.ACTION% = 0                                             !ADCK
2487: 1a7b: 
2488: 1a7b:             INDX% = DM.FIELD% + \                                       !RLJ
2489: 1a9e:                   ((SCRN2% - 1) * (LPP2% - LOC.FIELDS.START% + 1))      !RLJ
2490: 1a9e:             S.LOCATION% = INDX%/LOC.FIELDS.PER.LINE%                    !MLJ
2491: 1ab1: 
2492: 1ab1:             ! Store the current field on screen for future use          !ADCK
2493: 1ab1:             CURRENT.INDEX% = DM.FIELD%                                  !ADCK
2494: 1ac2: 
2495: 1ac2:             !If location management and default location                !SAH
2496: 1ac2:             IF MANAGE.LOCATION AND S.LOCATION% = 1 AND KEY% <> F3.KEY% \!SAH
2497: 1b11:               AND DM.CHANGED.FLAG(2) = TRUE           THEN BEGIN        !SAH
2498: 1b11:                 ! Keep the original data                                !SAH
2499: 1b11:                 LOCATION.ARRAY$(DM.FIELD%) = LOCATION1.DESC$            !SAH
2500: 1b39:                 !Reset the changed flag                                 !SAH
2501: 1b39:                 RC.INT1% = DM.CHANGED.FLAG(0)                           !SAH
2502: 1b4f:                 FIELD$(1) = "464 MESSAGE"                               !SAH
2503: 1b72:                 VALID  = FALSE                                          !SAH
2504: 1b83:                 UPDATE = TRUE                                           !SAH
2505: 1b94:                 !Set the location error check flag to true              !TAH
2506: 1b94:                 ERROR.ON.LOCATION = TRUE                                !TAH
2507: 1ba5:                                                                         !SAH
2508: 1ba5:             !If location management and not default location            !MLJ
2509: 1ba5:             ENDIF ELSE IF MANAGE.LOCATION AND S.LOCATION% <> 1 AND     \!SAH
2510: 1bd7:               KEY% <> F3.KEY% THEN BEGIN                                !PLJ
2511: 1bd7:                 BLANK.DATA$ =  STRING$(LEN(VALUE$)," ")                 !OLJ
2512: 1c02: 
2513: 1c02:                 !If not alphanumeric                                    !SAH
2514: 1c02:                 IF NOT FUNC.IS.ALPHANUMERIC(VALUE$) THEN BEGIN          !SAH
2515: 1c22:                     !Set the field as blanks                            !MLJ
2516: 1c22:                     LOCATION.ARRAY$(DM.FIELD%) = " "                    !MLJ
2517: 1c46:                     !Set the error message                              !MLJ
2518: 1c46:                     FIELD$(1) = "461 MESSAGE"                           !MLJ
2519: 1c69:                                                                         !MLJ
2520: 1c69:                     VALID  = FALSE                                      !MLJ
2521: 1c7a:                     UPDATE = TRUE                                       !MLJ
2522: 1c8b:                     !Field change is not accepted                       !AFKK
2523: 1c8b:                     CHANGE.ACCEPTED = FALSE                             !AFKK
2524: 1c99:                     !Set the location error check flag to true          !TAH
2525: 1c99:                     ERROR.ON.LOCATION = TRUE                            !TAH
2526: 1caa: 
2527: 1caa:                 !If same characters are coming sequentially 3 or        !SAH
2528: 1caa:                 !more times                                             !SAH
2529: 1caa:                 ENDIF ELSE IF NOT FUNC.IS.SAME.SEQ(VALUE$) THEN BEGIN   !SAH
2530: 1cca:                     !Set the field as balnks                            !SAH
2531: 1cca:                     LOCATION.ARRAY$(DM.FIELD%) = " "                    !SAH
2532: 1cee:                     !Setting the new error message                      !SAH
2533: 1cee:                     FIELD$(1) = "463 MESSAGE"                           !SAH
2534: 1d11:                     VALID = FALSE                                       !SAH
2535: 1d22:                     UPDATE = TRUE                                       !SAH
2536: 1d33:                     !Field change is not accepted                       !AFKK
2537: 1d33:                     CHANGE.ACCEPTED = FALSE                             !AFKK
2538: 1d41:                     !Set the location error check flag to true          !TAH
2539: 1d41:                     ERROR.ON.LOCATION = TRUE                            !TAH
2540: 1d52:                                                                         !MLJ
2541: 1d52:                 !Description uniqueness check if there is field change  !AACK
2542: 1d52:                 ENDIF ELSE IF (FUNC.GET.LOCATION$(S.LOCATION%,2) <>    \!ADCK
2543: 1dae:                                VALUE$)                           AND   \!ADCK
2544: 1dae:                               (NOT FUNC.IS.SAME.NAME(VALUE$)) THEN BEGIN!ADCK
2545: 1dae:                     !Set the field as blanks                            !MLJ
2546: 1dae:                     LOCATION.ARRAY$(DM.FIELD%) = " "                    !MLJ
2547: 1dd2:                     !Set the error message                              !MLJ
2548: 1dd2:                     FIELD$(1) = "460 MESSAGE"                           !MLJ
2549: 1df5:                                                                         !MLJ
2550: 1df5:                     VALID  = FALSE                                      !MLJ
2551: 1e06:                     UPDATE = TRUE                                       !MLJ
2552: 1e17:                     !Field change is not accepted                       !AFKK
2553: 1e17:                     CHANGE.ACCEPTED = FALSE                             !AFKK
2554: 1e25:                     !Set the location error check flag to true          !TAH
2555: 1e25:                     ERROR.ON.LOCATION = TRUE                            !TAH
2556: 1e36:                 !If Active location                                     !AACK
2557: 1e36:                 ENDIF ELSE IF FUNC.GET.LOCATION$(S.LOCATION%,0) = "A"  \!AACK
2558: 1e64:                                                               THEN BEGIN!AACK
2559: 1e64:                     ! If the values are null and key pressed is not F6  !AACK
2560: 1e64:                     IF (VALUE$ = "" OR VALUE$ = BLANK.DATA$) AND       \!AACK
2561: 1ece:                                              KEY% <> F6.KEY% THEN BEGIN !AACK
2562: 1ece:                         VALUE$ = STRING$(LEN(VALUE$),"*")               !MLJ
2563: 1efa:                         !Set the field as blanks                        !MLJ
2564: 1efa:                         LOCATION.ARRAY$(DM.FIELD%) = " "                !MLJ
2565: 1f1e:                         !Set the error message                          !MLJ
2566: 1f1e:                         FIELD$(1) = "462 MESSAGE"                       !MLJ
2567: 1f41:                                                                         !MLJ
2568: 1f41:                         VALID  = FALSE                                  !MLJ
2569: 1f52:                         UPDATE = TRUE                                   !MLJ
2570: 1f63:                         !Set the location error check flag to true      !TAH
2571: 1f63:                         ERROR.ON.LOCATION = TRUE                        !TAH
2572: 1f73:                     ! If the key pressed is F6                          !ADCK
2573: 1f73:                     ENDIF ELSE IF KEY% = F6.KEY% THEN BEGIN             !AACK
2574: 1f88:                         ! Set key action to 1 as key pressed is F6      !ADCK
2575: 1f88:                         KEY.ACTION% = 1                                 !ADCK
2576: 1f95:                         CALL SUB.UPDATE.LOCATIONS(KEY.ACTION%,         \!ADCK
2577: 1fbc:                                        DM.FIELD%, VALUE$, VALID, UPDATE)!ADCK
2578: 1fbc:                     ENDIF                                               !AACK
2579: 1fc7: 
2580: 1fc7:                 !If changing the status from I to A                     !OLJ
2581: 1fc7:                 ENDIF ELSE IF KEY% = F6.KEY% AND                       \!OLJ
2582: 201a:                             FUNC.GET.LOCATION$(S.LOCATION%,0) = "I"    \!OLJ
2583: 201a:                             THEN BEGIN                                  !OLJ
2584: 201a: !                   !If short and long description are blanks           !RLJ
2585: 201a:                     IF LOCATION.ARRAY$(DM.FIELD%) =  BLANK.DATA$       \!RLJ
2586: 204c:                                                             THEN BEGIN  !RLJ
2587: 204c:                         VALUE$ = STRING$(LEN(VALUE$),"*")               !OLJ
2588: 2078:                         !Set the error message                          !OLJ
2589: 2078:                         FIELD$(1) = "462 MESSAGE"                       !OLJ
2590: 209b:                                                                         !OLJ
2591: 209b:                         VALID  = FALSE                                  !OLJ
2592: 20ac:                         UPDATE = TRUE                                   !OLJ
2593: 20bd:                         ! Field change is not accepted                  !AFKK
2594: 20bd:                         CHANGE.ACCEPTED = FALSE                         !AFKK
2595: 20cb:                         !Set the location error check flag to true      !TAH
2596: 20cb:                         ERROR.ON.LOCATION = TRUE                        !TAH
2597: 20db:                     ENDIF ELSE BEGIN                                    !OLJ
2598: 20e3:                         ! Save the key action as 1 (since F6 pressed)   !ADCK
2599: 20e3:                         KEY.ACTION% = 1                                 !ADCK
2600: 20f0:                         !Set the flag for confirmation                  !OLJ
2601: 20f0:                         ACTIVE.TO.BE.SAVED = DM.CHANGED.FLAG(2)         !OLJ
2602: 2106:                         !Reset the changed flag                         !OLJ
2603: 2106:                         RC.INT1% = DM.CHANGED.FLAG(0)                   !OLJ
2604: 211c:                         !Reset the inactive checking flag               !SAH
2605: 211c:                         INACTIVE.CHECK% = 0                             !SAH
2606: 212a:                     ENDIF                                               !OLJ
2607: 2135:                 !Code for checking whether the location is INACTIVE and !SAH
2608: 2135:                 !that the location is edited.                           !SAH
2609: 2135:                 ENDIF ELSE IF FUNC.GET.LOCATION$(S.LOCATION%,0) = "I"  \!SAH
2610: 21ec:                     AND LOCATION.ARRAY$(DM.FIELD%) <>  BLANK.DATA$ AND \!SAH
2611: 21ec:                     FUNC.GET.LOCATION$(S.LOCATION%,2) <>               \!SAH
2612: 21ec:                     LOCATION.ARRAY$(DM.FIELD%) THEN BEGIN               !SAH
2613: 21ec:                     !Checking whether any other key other than F6 is    !SAH
2614: 21ec:                     !pressed and whether the location is inactive.      !SAH
2615: 21ec:                     IF KEY% <> F6.KEY% AND INACTIVE.CHECK% = 1         \!XLJ
2616: 2215:                                                              THEN BEGIN !SAH
2617: 2215:                         !Clearing the location description field        !SAH
2618: 2215:                         LOCATION.ARRAY$(DM.FIELD%) = " "                !SAH
2619: 2239:                         VALID  = TRUE                                   !SAH
2620: 224a:                         UPDATE = TRUE                                   !SAH
2621: 225b:                         !Reset the inactive checking flag               !SAH
2622: 225b:                         INACTIVE.CHECK% = 0                             !SAH
2623: 226b:                     ENDIF ELSE BEGIN                                    !SAH
2624: 2273:                     !Sets the new prompt message                        !SAH
2625: 2273:                         FIELD$(1) = "465 MESSAGE"                       !SAH
2626: 2296:                         VALID  = FALSE                                  !SAH
2627: 22a7:                         UPDATE = TRUE                                   !SAH
2628: 22b8:                         !Set the location error check flag to true      !TAH
2629: 22b8:                         ERROR.ON.LOCATION = TRUE                        !TAH
2630: 22c6:                         !Set the inactive checking flag                 !SAH
2631: 22c6:                         INACTIVE.CHECK% = 1                             !SAH
2632: 22d4:                     ENDIF                                               !SAH
2633: 22dc:                 ENDIF                                                   !SAH
2634: 22e4:                 VALID.CHANGE = VALID                                    !RLJ
2635: 22f5:                 ! Check if the change is valid                          !RLJ
2636: 22f5:                 IF VALID.CHANGE = TRUE AND DM.CHANGED.FLAG(2) = TRUE   \!RLJ
2637: 2323:                                                               THEN BEGIN!RLJ
2638: 2323:                     ANY.CHANGES.DONE = TRUE       !Data change happened !RLJ
2639: 2331:                 ENDIF                                                   !RLJ
2640: 2339:             ENDIF                                                       !MLJ
2641: 2341: 
2642: 2341:             !Don't change anything if Function or ENTER Key             !JDC
2643: 2341:             IF KEY% <> ENTER.KEY% \                                     !JDC
2644: 236d:             AND KEY% > 0 \                                              !JDC
2645: 236d:             THEN BEGIN                                                  !JDC
2646: 236d:                 ! Set the key action                                    !ADCK
2647: 236d:                 ! If the key pressed is F6 then set key action as 1     !ADCK
2648: 236d:                 IF KEY% = F6.KEY% THEN BEGIN                            !ADCK
2649: 2382:                     KEY.ACTION% = 1                                     !ADCK
2650: 238f:                 ENDIF                                                   !ADCK
2651: 2397:                 ! If the key pressed is BackTab/Up Key then set key     !ADCK
2652: 2397:                 ! action as 2                                           !ADCK
2653: 2397:                 IF (KEY% = BTAB.KEY% OR KEY% = UP.KEY%) THEN BEGIN      !ADCK
2654: 23c5:                     KEY.ACTION% = 2                                     !ADCK
2655: 23d2:                 ENDIF                                                   !ADCK
2656: 23da:                 ! If the key pressed is Tab/Down Key then set key       !ADCK
2657: 23da:                 ! action as 3                                           !ADCK
2658: 23da:                 IF (KEY% = BTAB.KEY% OR KEY% = UP.KEY%) THEN BEGIN      !ADCK
2659: 2408:                     KEY.ACTION% = 3                                     !ADCK
2660: 2415:                 ENDIF                                                   !ADCK
2661: 241d: 
2662: 241d:                 IF (KEY% = BTAB.KEY% OR KEY% = UP.KEY%    OR            \ZCK
2663: 24c3:                     KEY% = TAB.KEY%  OR KEY% = DOWN.KEY%) AND           \ZCK
2664: 24c3:                    VALID = TRUE                           AND           \ZCK
2665: 24c3:                    FUNC.GET.LOCATION$(INDX%/LOC.FIELDS.PER.LINE%, 2) <> \ZCK
2666: 24c3:                                                        VALUE$ THEN BEGIN!ZCK
2667: 24c3:                                                                         !AACK
2668: 24c3:                                                                         !ADCK
2669: 24c3:                     CALL SUB.UPDATE.LOCATIONS(KEY.ACTION%, DM.FIELD%,  \!ADCK
2670: 24ea:                                                   VALUE$, VALID, UPDATE)!ADCK
2671: 24ea:                 ENDIF                                                   !ZCK
2672: 24f2:             ENDIF                                                       !JDC
2673: 24fa: 
2674: 24fa:             INDX% = CURRENT.INDEX% + \                                  !AECS
2675: 251b:                         ((SCRN2% - 1) * (LPP2% - LOC.FIELDS.START% + 1))!AECS
2676: 251b:         ENDIF
2677: 2523:         CALL SET.F.KEYS(INDX%)                                          !LLJ
2678: 2543:         ! Reset SCREEN.CHANGED flag screen                              !TAH
2679: 2543:         IF SCREEN.CHANGED = TRUE THEN BEGIN                             !TAH
2680: 2554:             SCREEN.CHANGED = FALSE                                      !TAH
2681: 2562:         ENDIF                                                           !TAH
2682: 256a:     END SUB
2683: 257e: 
2684: 257e: \********************************************************************
2685: 257e: \***
2686: 257e: \***    FUNCTION        fmt.dt$
2687: 257e: \***
2688: 257e: \***    Pass Packed Date (and time)
2689: 257e: \***    - Return formatted date (and time) dd/mm/yy( HH:MM)
2690: 257e: \***
2691: 257e: \********************************************************************
2692: 257e: 
2693: 257e:    FUNCTION fmt.dt$(dt$)
2694: 25a7:       STRING fmt.dt$
2695: 25a7:       STRING dt$
2696: 25a7:       STRING tmp$
2697: 25a7: 
2698: 25a7:    IF LEN(dt$) < 3 THEN BEGIN
2699: 25c0:       tmp$ = "Invalid."
2700: 25d8:    ENDIF ELSE IF LEFT$(dt$,3) = STRING$(3,CHR$(0)) THEN BEGIN
2701: 2612:       tmp$ = "        "
2702: 262a:    ENDIF ELSE BEGIN
2703: 2632:       tmp$ = UNPACK$(MID$(dt$, 3, 1)) + "/"                         \
2704: 26b6:            + UNPACK$(MID$(dt$, 2, 1)) + "/"                         \
2705: 26b6:            + UNPACK$(MID$(dt$, 1, 1))
2706: 26b6:    ENDIF
2707: 26be: 
2708: 26be:    IF LEN(dt$) > 3 THEN BEGIN
2709: 26da:       IF LEN(dt$) = 5                                               \
2710: 2716:       OR LEN(dt$) = 6 THEN BEGIN
2711: 2716:          tmp$ = tmp$ + " "                                          \
2712: 2778:               + UNPACK$(MID$(dt$, 4, 1)) + ":"                      \
2713: 2778:               + UNPACK$(MID$(dt$, 5, 1))
2714: 2778:       ENDIF
2715: 2780:    ENDIF
2716: 2788: 
2717: 2788:    fmt.dt$ = tmp$
2718: 27a2:    tmp$ = ""
2719: 27b7: 
2720: 27b7:    END FUNCTION
2721: 27d5: 
2722: 27d5: !***********************************************************************!HDC
2723: 27d5: !* Code change H block marker - START                                   !HDC
2724: 27d5: !***********************************************************************!HDC
2725: 27d5: !***********************************************************************
2726: 27d5: !***
2727: 27d5: !***    FUNCTION        FUNC.GET.FIELD.DISPLAY2$(F.INDEX%)              !IDC
2728: 27d5: !***
2729: 27d5: !***    character diplay field
2730: 27d5: !***    F.INP% is the current index from the display (starting at 0)
2731: 27d5: !***
2732: 27d5: !***********************************************************************
2733: 27d5:     FUNCTION FUNC.GET.FIELD.DISPLAY2$(F.INDEX%)                         !IDC
2734: 27f9:         STRING    FUNC.GET.FIELD.DISPLAY2$                              !IDC
2735: 27f9:         INTEGER*2 F.INDEX%      ! input field number
2736: 27f9:         INTEGER*2 F.POS%        ! calculated postion of record data
2737: 27f9: 
2738: 27f9:         IF F.INDEX% >= LOC.FIELDS.START% THEN BEGIN
2739: 280d:             F.POS% = MOD(F.INDEX%+LOC.FIELDS.PER.LINE%, \               !IDC
2740: 2838:                          LOC.FIELDS.PER.LINE%) + 1                      !IDC
2741: 2838: 
2742: 2838:             IF F.POS% = 1 THEN BEGIN
2743: 2847:                 ! Status
2744: 2847:                 FUNC.GET.FIELD.DISPLAY2$ = BDCLOCON.STATUS$             !IDC
2745: 2867:             ENDIF ELSE \
2746: 286f:             IF F.POS% = 2 THEN BEGIN
2747: 287e:                 ! record number
2748: 287e:                 FUNC.GET.FIELD.DISPLAY2$ = \                            !IDC
2749: 28c9:                  RIGHT$("000"+STR$(BDCLOCON.RECORD.NUM%),3)             !RLJ
2750: 28c9:             ENDIF ELSE \
2751: 28d1:             IF F.POS% = 3 THEN BEGIN                                    !RLJ
2752: 28e0:                 ! long location name
2753: 28e0:                 FUNC.GET.FIELD.DISPLAY2$ = BDCLOCON.LONG.NAME$          !IDC
2754: 28fd:             ENDIF
2755: 2905:         ENDIF
2756: 290d: 
2757: 290d:     END FUNCTION
2758: 2926: 
2759: 2926: !***********************************************************************!HDC
2760: 2926: !* Code change H block marker - END                                     !HDC
2761: 2926: !***********************************************************************!HDC
2762: 2926: 
2763: 2926: 
2764: 2926: \********************************************************************
2765: 2926: \***
2766: 2926: \***    FUNCTION        disp$(inp%)
2767: 2926: \***
2768: 2926: \***    Return 78 character diplay line
2769: 2926: \***
2770: 2926: \********************************************************************
2771: 2926: 
2772: 2926:    FUNCTION disp$(inp%)
2773: 294a:       STRING    disp$
2774: 294a:       INTEGER*2 inp%
2775: 294a: 
2776: 294a:       STRING    tmp$
2777: 294a:       STRING    tm1$
2778: 294a:       STRING    tm2$                                                    !CSH
2779: 294a: 
2780: 294a:       \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
2781: 294a:       \* extract status and status date to work variables
2782: 294a:       \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
2783: 294a:       ! set off until status check allows it                            !IDC
2784: 294a:       LOCATION.STATUS.NEW% = 1                                          !IDC
2785: 2958:       tm1$  = TRANSLATE$(LEFT$(p.arr$(inp%),1), "12345678", "OORRRCUL") !FMM
2786: 299f:       x.dt$ = MID$(p.arr$(inp%), 14, 6)
2787: 29ce: 
2788: 29ce:       \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
2789: 29ce:       \* Mark all zero order numbers as UNKNOWN
2790: 29ce:       \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
2791: 29ce:       IF MID$(p.arr$(inp%), 2, 5) = STRING$(5, CHR$(0FFh)) THEN     \
2792: 2a18:          tmp$ = "UNKNOWN   " + " "                                  \
2793: 2a36:       ELSE                                                          \
2794: 2a3e:          tmp$ = UNPACK$(MID$(p.arr$(inp%), 2, 5)) + " "             !
2795: 2a8f: 
2796: 2a8f:       \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
2797: 2a8f:       \* Add the parcel number and the formatted delivery date
2798: 2a8f:       \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
2799: 2a8f:       tm2$ = UNPACK$(MID$(p.arr$(inp%), 7, 4))                          !CSH
2800: 2ac3:       IF LEFT$(tm2$, 1) = "0" THEN BEGIN                                !CSH
2801: 2af5:           tm2$ = RIGHT$(tm2$, 7) + " "                                  !CSH
2802: 2b27:       ENDIF                                                             !CSH
2803: 2b2f: 
2804: 2b2f:       tmp$ = tmp$ + \                                                   !CSH
2805: 2b93:              tm2$ + " " + \                                             !CSH
2806: 2b93:              fmt.dt$(MID$(p.arr$(inp%),11, 3)) + " "                    !CSH
2807: 2b93: 
2808: 2b93:     !*******************************************************************!HDC
2809: 2b93:     !* Get the location in case we need it later and check if nothing   !HDC
2810: 2b93:     !* or empty (spaces/PD 2020) in the record and force as 0           !HDC
2811: 2b93:     !*******************************************************************!HDC
2812: 2b93: 
2813: 2b93:       BDCP.LOC.CURRENT% = GETN2(P.ARR$(INP%),22)                        !LLJ
2814: 2bc1:       TMP.LOCATION% = BDCP.LOC.CURRENT%                                 !HDC
2815: 2bd3:       IF TMP.LOCATION% = 0  \       ! either set to nothing             !HDC
2816: 2bf4:       OR TMP.LOCATION% > 999\       ! or out of range                   !RLJ
2817: 2bf4:       THEN BEGIN                                                        !HDC
2818: 2bf4:           TMP.LOCATION% = 0         !                                   !HDC
2819: 2c02:           BDCP.LOC.CURRENT% = 0     !                                   !HDC
2820: 2c13:       ENDIF                                                             !HDC
2821: 2c1b: 
2822: 2c1b:       BDCP.LOC.STATUS% = GETN2(P.ARR$(INP%),24)                         !LLJ
2823: 2c49:       BDCP.LOC.STATUS% = 0      ! set as allowed as default             !IDC
2824: 2c5a: 
2825: 2c5a:       ! as long as it has arrived show it's last location recorded      !IDC
2826: 2c5a:       IF TM1$ <> "O" THEN BEGIN                                         !LLJ
2827: 2c78:           ! Get the shortname for default location                      !RLJ
2828: 2c78:           IF TMP.LOCATION% = 1 THEN BEGIN                               !RLJ
2829: 2c8a:               TMP$ = TMP$ +                                            \!RLJ
2830: 2d1c:                    LEFT$(FUNC.GET.LOCATION$(TMP.LOCATION%,1),10) + " " \!RLJ
2831: 2d1c:                       + RIGHT$("000"+STR$(BDCP.LOC.CURRENT%),3)+ " "    !RLJ
2832: 2d1c:           ENDIF ELSE BEGIN                                              !RLJ
2833: 2d24:               TMP$ = TMP$ +                                            \!RLJ
2834: 2db3:                    LEFT$(FUNC.GET.LOCATION$(TMP.LOCATION%,2),10) + " " \!RLJ
2835: 2db3:                       + RIGHT$("000"+STR$(BDCP.LOC.CURRENT%),3)+ " "    !RLJ
2836: 2db3:           ENDIF                                                         !RLJ
2837: 2dbd:       ENDIF ELSE BEGIN                                                  !IDC
2838: 2dc5:           TMP$ = TMP$ + STRING$(15," ")                                 !YDC
2839: 2dec:       ENDIF                                                             !IDC
2840: 2df4:     !*******************************************************************!HDC
2841: 2df4: 
2842: 2df4:       \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
2843: 2df4:       \* Add the status and the required message/date/time
2844: 2df4:       \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
2845: 2df4:       IF tm1$ = "O" THEN BEGIN
2846: 2e12:          IF DATE$ > UNPACK$(LEFT$(x.dt$,3)) THEN                    \
2847: 2e4a:             tmp$ = tmp$ + "Late "                                       !YDC
2848: 2e6a: 
2849: 2e6a:             tmp$ = tmp$ + "Delivery Expected on "                   \   !YDC
2850: 2ea2:                  + fmt.dt$(LEFT$(x.dt$,3))                              !YDC
2851: 2ea2:       ENDIF ELSE IF tm1$ = "R" THEN BEGIN
2852: 2ec0:          LOCATION.STATUS.NEW% = 0                                       !IDC
2853: 2ece:          ! Used for status 'R' Ready in store. If status date [X.DT$]   !DDM
2854: 2ece:          ! is 0's then update global variable F02.DATE$ with delivery   !DDM
2855: 2ece:          ! date else update with found date.                            !DDM
2856: 2ece:          IF X.DT$ = STRING$(6,CHR$(0)) THEN BEGIN                       !DDM
2857: 2ef6:              ! Assigning delivery date to global variable               !DDM
2858: 2ef6:              F02.DATE$ = UNPACK$(MID$(P.ARR$(INP%), 11, 3))             !DDM
2859: 2f2e:          ENDIF ELSE BEGIN                                               !DDM
2860: 2f36:              ! Assigning found date to global variable                  !DDM
2861: 2f36:              F02.DATE$ = UNPACK$(MID$(X.DT$,1,3))                       !DDM
2862: 2f5f:          ENDIF                                                          !DDM
2863: 2f67: 
2864: 2f67:          ! For status 'R': Check difference between today's date and    !DDM
2865: 2f67:          ! delivery date/found date. If difference is greater than      !DDM
2866: 2f67:          ! Uncollected days value then display the status as            !DDM
2867: 2f67:          ! 'UNCOLLECTED - RETURN TO W/H?'.
2868: 2f67: 
2869: 2f67:          ! Calculating return by date                                   !DDM
2870: 2f67:          CALL UPDATE.DATE(DAYS.UNCOLLECTED%)                            !DDM
2871: 2f7d:          RETURN.BY.DATE$ = F02.DATE$                                    !DDM
2872: 2f99: 
2873: 2f99:          ! If Return by date is lesser than today's date                !DDM
2874: 2f99:          IF DATE.LT(RETURN.BY.DATE$, CURRENT.DATE$) THEN BEGIN          !DDM
2875: 2fbd:             TMP$ = TMP$ + "Uncollected - Return to W/H?"                !DDM
2876: 2fe0:          ENDIF ELSE BEGIN                                               !DDM
2877: 2fe8:             tmp$ = tmp$ + "In Store "
2878: 3008:            IF x.dt$ = STRING$(6,CHR$(0)) THEN BEGIN
2879: 3032:             ENDIF ELSE BEGIN
2880: 303a:                  tmp$ = tmp$ + "Found on " + fmt.dt$(x.dt$)
2881: 3066:             ENDIF
2882: 306e:          ENDIF                                                          !DDM
2883: 3079: 
2884: 3079:       ! text length reduced to allow space for location                 !HDC
2885: 3079:       ENDIF ELSE IF tm1$ = "C" THEN BEGIN
2886: 3094:             TMP$ = TMP$ + "Collected "                           \      !LLJ
2887: 30c7:                  + "On " + fmt.dt$(x.dt$)
2888: 30c7:       ENDIF ELSE IF tm1$ = "L" THEN BEGIN
2889: 30e2:             TMP$ = TMP$ + "Lost "                                \      !LLJ
2890: 3114:                  + "On " + fmt.dt$(x.dt$)
2891: 3114:       ENDIF ELSE IF tm1$ = "U" THEN BEGIN
2892: 312f:             TMP$ = TMP$ +                                        \      !YDC
2893: 315b:                  + "Returned to W/H on " + fmt.dt$(x.dt$)
2894: 315b:       ENDIF
2895: 3163: 
2896: 3163:       \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
2897: 3163:       \* Set output for return
2898: 3163:       \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
2899: 3163: 
2900: 3163:       disp$ = LEFT$(tmp$ + STRING$(78," "), 78)
2901: 31ae: 
2902: 31ae:       tm1$ = ""
2903: 31c3:       tmp$ = ""
2904: 31d8:       CALL PUTN2(P.ARR$(INP%),24,LOCATION.STATUS.NEW%)                  !LLJ
2905: 3203: 
2906: 3203:    END FUNCTION
2907: 321c: 
2908: 321c: 
2909: 321c: \********************************************************************
2910: 321c: \***
2911: 321c: \***    Start of Mainline
2912: 321c: \***
2913: 321c: \********************************************************************
2914: 321c: 
2915: 321c:    ON ERROR GOTO ERR.DETECTED
2916: 324b: 
2917: 324b:    CHAINING.TO.PROG$ = "B50  "      ! for B553 msg (default=PSB50)
2918: 3260: 
2919: 3260:    %INCLUDE PSBUSEE.J86
2920: 3260: \/*********************************************************************/ PSBUSEE
2921: 3260: \/*                                                                   */ PSBUSEE
2922: 3260: \/*      PSBUSEE.J86  -  USE in PSB Application Program               */ PSBUSEE
2923: 3260: \/*      ----------------------------------------------               */ PSBUSEE
2924: 3260: \/*                                                                   */ PSBUSEE
2925: 3260: \/*********************************************************************/ PSBUSEE
2926: 3260:                                                                        ! PSBUSEE
2927: 3260:         USE  PSBCHN.OP , PSBCHN.APP , PSBCHN.MENCON , PSBCHN.U1 ,      \ PSBUSEE
2928: 32b4:              PSBCHN.U2 , PSBCHN.U3                                     ! PSBUSEE
2929: 32b4:                                                                        ! PSBUSEE
2930: 32b4: 
2931: 32b4: START.PROGRAM:
2932: 32c4: 
2933: 32c4:    PSBCHN.APP = "ADX_UPGM:PSD85.286"
2934: 32db: 
2935: 32db:    OPERATOR.NUMBER$   = PSBCHN.OP
2936: 32f9:    MODULE.NUMBER$     = "PSD8500"
2937: 3310: 
2938: 3310:    MANAGE.LOCATION = 0          ! default off                           !HDC
2939: 331d:    ! Menu sequence 4/6/4/2                                              !IDC
2940: 331d:    IF MID$(PSBCHN.MENCON,4,1) = "2" THEN BEGIN                          !IDC
2941: 3352:        MANAGE.LOCATION = -1     ! set location management only          !HDC
2942: 335f:    ENDIF                                                                !HDC
2943: 3367: 
2944: 3367:    GOSUB INITIALISATION
2945: 3379:    BATCH.SCREEN.FLAG$ = "S"                                             !ECK
2946: 3390:    CALL DM.INIT
2947: 339d:    RET.KEY% = ENTER.KEY%
2948: 33af: 
2949: 33af:    WHILE RET.KEY% <> F3.KEY%                                        \
2950: 33b9:      AND RET.KEY% <> ESC.KEY%
2951: 33b9: 
2952: 33b9:       IF MANAGE.LOCATION THEN BEGIN                                     !HDC
2953: 33c8:           GOSUB DISPLAY.SCREEN2                                         !HDC
2954: 33da:           GOSUB PROCESS.SCREEN2                                         !HDC
2955: 33ee:       ENDIF ELSE BEGIN                                                  !HDC
2956: 33f6:           GOSUB DISPLAY.SCREEN1                                         !HDC
2957: 3408:           GOSUB PROCESS.SCREEN1                                         !HDC
2958: 341a:       ENDIF                                                             !HDC
2959: 3422: 
2960: 3422:    WEND
2961: 3453: 
2962: 3453: END.PROGRAM:
2963: 3463: 
2964: 3463:    GOSUB TERMINATE
2965: 3475: 
2966: 3475:    CALL DM.QUIT
2967: 3482: 
2968: 3482:    CHAINING.TO.PROG$ = "B50  "     ! for B553 msg
2969: 3497:    PSBCHN.PRG = "ADX_UPGM:PSB50.286"
2970: 34ae:    %INCLUDE PSBCHNE.J86
2971: 34ae: \/*********************************************************************/ PSBCHNE
2972: 34ae: \/*                                                                   */ PSBCHNE
2973: 34ae: \/*      PSBCHNE.J86  -  Chain to PSB Application Program             */ PSBCHNE
2974: 34ae: \/*      ------------------------------------------------             */ PSBCHNE
2975: 34ae: \/*                                                                   */ PSBCHNE
2976: 34ae: \/*********************************************************************/ PSBCHNE
2977: 34ae:                                                                        ! PSBCHNE
2978: 34ae:         CHAIN  PSBCHN.PRG , PSBCHN.OP , PSBCHN.APP , PSBCHN.MENCON ,   \ PSBCHNE
2979: 352e:                             PSBCHN.U1 , PSBCHN.U2  , PSBCHN.U3         ! PSBCHNE
2980: 352e:                                                                        ! PSBCHNE
2981: 352e: 
2982: 352e:    STOP
2983: 353b: 
2984: 353b: \********************************************************************
2985: 353b: \***
2986: 353b: \***    Subroutines
2987: 353b: \***
2988: 353b: \********************************************************************
2989: 353b: \***
2990: 353b: \***    SUBROUTINE      :      DISPLAY.SCREEN1
2991: 353b: \***
2992: 353b: \*** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
2993: 353b: 
2994: 353b: DISPLAY.SCREEN1:
2995: 354b: 
2996: 354b:    file.loaded% = 0
2997: 3558: 
2998: 3558: REFRESH:
2999: 3568: 
3000: 3568:    scrn1%     = 1
3001: 3576:    max.scrn1% = INT%((p.cnt% +lpp1% -1) / lpp1%)
3002: 359f: 
3003: 359f:    ! Screen title displayed as per the store (UK/ROI)                   !GCK
3004: 359f:    CALL DM.SHOW.SCREEN (1, SCREEN.TITLE$, 11, 11)                       !GCK
3005: 35bd:    CURRENT.SCREEN% = 1                                                  !IDC
3006: 35cb:    CALL DM.NAME (16, "page$", page$)
3007: 3608: 
3008: 3608:    ! If Limit is not found in SOFTS 60th record then hide the function  !DDM
3009: 3608:    ! keys F3 and F9 and display BEMF 221 message. Call APPLICATION.LOG  !DDM
3010: 3608:    ! to log the event 117 and close the program on pressing 'ESC'       !DDM
3011: 3608:    IF NOT SOFTS.LIMIT.VAL.FOUND THEN BEGIN                              !DDM
3012: 361a:        CALL DM.HIDE.FN.KEY(3)                                           !DDM
3013: 362b:        CALL DM.HIDE.FN.KEY(9)                                           !DDM
3014: 363c:        WK$ = "221 'Limit could not be fetched from SOFTS file" + \      !DDM
3015: 3658:              " Press F3 to EXIT.' MESSAGE"                              !DDM
3016: 3658:        ! Setting the Key value                                          !DDM
3017: 3658:        RET.KEY% = ESC.KEY%                                              !DDM
3018: 366a: 
3019: 366a:        EVENT.NUMBER%   = 117                                            !DDM
3020: 3678:        MESSAGE.NUMBER% = 221                                            !DDM
3021: 3686:        VAR.STRING.1$   = STR$(SOFTS.REPORT.NUM%) + "N "                 !DDM
3022: 36b8:        VAR.STRING.2$   = "Limit could not be fetched from SOFTS file" + \DDM
3023: 36d4:                          " Press ESC to EXIT."                          !DDM
3024: 36d4: 
3025: 36d4:        CALL APPLICATION.LOG ( MESSAGE.NUMBER%, VAR.STRING.1$,           \DDM
3026: 36fd:                               VAR.STRING.2$, EVENT.NUMBER% )            !DDM
3027: 36fd: 
3028: 36fd:        GOSUB END.PROGRAM                                                !DDM
3029: 370f:    ENDIF                                                                !DDM
3030: 3717: 
3031: 3717:     IF NOT file.loaded% THEN BEGIN
3032: 3726: 
3033: 3726:         GOSUB LOAD.PARCELS
3034: 3738:         GOTO REFRESH
3035: 3743:     ENDIF
3036: 374b: 
3037: 374b:    IF p.cnt% = 0 THEN BEGIN
3038: 375d:       IF NOT bdcp.open% THEN BEGIN
3039: 376c:          wk$ = "221 'No Boots.com Parcel file found."            \
3040: 378a:              + " Press F3 to EXIT.' MESSAGE"
3041: 378a:       ENDIF ELSE BEGIN
3042: 3792:          wk$ = "221 'No Parcels found."                          \
3043: 37ae:              + " Press F3 to EXIT.' MESSAGE"
3044: 37ae:       ENDIF
3045: 37b6:       RET.KEY% = ESC.KEY%
3046: 37c8:       WHILE RET.KEY% <> F3.KEY%
3047: 37d2:          RET.KEY% = DM.INVISIBLE.INPUT(wk$)
3048: 37ed:       WEND
3049: 3802:       GOTO END.PROGRAM
3050: 380d:    ENDIF
3051: 3815: 
3052: 3815:    GOSUB CHANGE.SCREEN1
3053: 3827: 
3054: 3827: RETURN
3055: 3837: 
3056: 3837: 
3057: 3837: \********************************************************************
3058: 3837: \***
3059: 3837: \***    SUBROUTINE      :      CHANGE.SCREEN1
3060: 3837: \***
3061: 3837: \*** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
3062: 3837: 
3063: 3837: CHANGE.SCREEN1:
3064: 3847: 
3065: 3847: 
3066: 3847:    wk$ = "Page " + STR$(scrn1%)                                     \
3067: 3884:        + " of "  + STR$(max.scrn1%)
3068: 3884: 
3069: 3884:    page$ = RIGHT$(STRING$(15," ") + wk$, 15)
3070: 38cc: 
3071: 38cc:    FOR i% = 2 TO lpp1% +1
3072: 38dd: 
3073: 38dd:       indx% = ((scrn1% -1) *lpp1%) + (i% - 1)
3074: 38f7: 
3075: 38f7:       IF indx% <= p.cnt% THEN BEGIN
3076: 390b:          CALL DM.NAME(i%,"f"+STR$(i%)+"$",disp$(indx%))
3077: 3972:          CALL DM.VISIBLE (STR$(i%), "TRUE")
3078: 399f:          CALL DM.RO.FIELD(i%)
3079: 39b4:       ENDIF ELSE BEGIN
3080: 39bc:          CALL DM.VISIBLE (STR$(i%), "FALSE")
3081: 39e9:       ENDIF
3082: 39f1: 
3083: 39f1:    NEXT i%
3084: 3a0d: 
3085: 3a0d:    IF scrn1% < max.scrn1% THEN BEGIN
3086: 3a1e:       CALL DM.SHOW.FN.KEY( 8, "")
3087: 3a36:    ENDIF ELSE BEGIN
3088: 3a3e:       CALL DM.HIDE.FN.KEY( 8)
3089: 3a4f:    ENDIF
3090: 3a57:    IF scrn1% > 1 THEN BEGIN
3091: 3a66:       CALL DM.SHOW.FN.KEY( 7, "")
3092: 3a7e:    ENDIF ELSE BEGIN
3093: 3a86:       CALL DM.HIDE.FN.KEY( 7)
3094: 3a97:    ENDIF
3095: 3a9f:    CALL DM.SHOW.FN.KEY( 3, "")
3096: 3ab5:    CALL DM.SHOW.FN.KEY( 1, "")
3097: 3acb:    ! blank out location by default
3098: 3acb:    CALL DM.HIDE.FN.KEY(10)                                              !IDC
3099: 3adc: 
3100: 3adc: 
3101: 3adc:    IF PRINT.KEY THEN BEGIN                                              !FMM
3102: 3aeb:        ! Make F9PRINT option visible                                    !FMM
3103: 3aeb:        CALL DM.SHOW.FN.KEY( 9, "")                                      !FMM
3104: 3b03:    ENDIF ELSE BEGIN                                                     !FMM
3105: 3b0b:        CALL DM.HIDE.FN.KEY( 9)                                          !FMM
3106: 3b1c:    ENDIF                                                                !FMM
3107: 3b24: 
3108: 3b24:    i% = DM.CURRENT.FIELD(0)
3109: 3b38:    indx% = ((scrn1% -1) * lpp1%) + (i% -1)
3110: 3b52:    CALL SET.F.KEYS(indx%)
3111: 3b72: 
3112: 3b72: RETURN
3113: 3b82: 
3114: 3b82: \********************************************************************
3115: 3b82: \***
3116: 3b82: \***    SUBROUTINE      :      PROCESS.SCREEN1
3117: 3b82: \***
3118: 3b82: \*** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
3119: 3b82: 
3120: 3b82: PROCESS.SCREEN1:
3121: 3b92: 
3122: 3b92:    SCREEN.COMPLETE = 0
3123: 3b9f: 
3124: 3b9f:    WHILE NOT SCREEN.COMPLETE
3125: 3baa: 
3126: 3baa:       RET.KEY% = DM.PROCESS.SCREEN (1, lpp1% +1, 0)
3127: 3bc8: 
3128: 3bc8:       CARTON.FILE.ERROR = FALSE                                         !AHCS
3129: 3bd6:       PSUTQ.FILE.ERROR  = FALSE                                         !AICS
3130: 3be4: 
3131: 3be4:       i% = DM.CURRENT.FIELD(0)
3132: 3bf8:       indx% = ((scrn1% -1) * lpp1%) + (i% -1)
3133: 3c12: 
3134: 3c12:       \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
3135: 3c12:       \* Escape Key pressed
3136: 3c12:       \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
3137: 3c12:       IF RET.KEY% = ESC.KEY% THEN BEGIN
3138: 3c27:          SCREEN.COMPLETE = -1
3139: 3c37:       \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
3140: 3c37:       \*     F3 Key pressed
3141: 3c37:       \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
3142: 3c37:       ENDIF ELSE IF RET.KEY% = F3.KEY% THEN BEGIN
3143: 3c4c:          SCREEN.COMPLETE = -1
3144: 3c5c:       \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
3145: 3c5c:       \*     F4 Key(Collect) pressed and status is either of the        !FMM
3146: 3c5c:       \*     following:                                                 !FMM
3147: 3c5c:       \*        - Uncollected - Return to W/H?                          !FMM
3148: 3c5c:       \*        - Instore - Awaiting collection                         !FMM
3149: 3c5c:       \*        - Instore - Found                                       !FMM
3150: 3c5c:       \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
3151: 3c5c:       ENDIF ELSE IF RET.KEY% = F4.KEY% AND            \                 !FMM
3152: 3d4c:                   ((LEFT$(p.arr$(indx%),1) = "3") OR  \    Uncollected  !FMM
3153: 3d4c:                    (LEFT$(p.arr$(indx%),1) = "4") OR  \       Awaiting  !FMM
3154: 3d4c:                    (LEFT$(p.arr$(indx%),1) = "5")) THEN BEGIN   !Found  !FMM
3155: 3d4c: 
3156: 3d4c:          WHILE RET.KEY% <> ENTER.KEY%                               \
3157: 3d56:            AND RET.KEY% <> F3.KEY%
3158: 3d56:             RET.KEY% = DM.INVISIBLE.INPUT("221 "                    \
3159: 3d88:                              + "'Marking as Collected cannot be "   \     CSH
3160: 3d88:                              + "undone. "                           \     CSH
3161: 3d88:                              + "ENTER to confirm or F3 to cancel.' "\
3162: 3d88:                              + "MESSAGE")
3163: 3d88:          WEND
3164: 3db6: 
3165: 3db6:          IF RET.KEY% = ENTER.KEY% THEN BEGIN                            ! BSH
3166: 3dce:             GOSUB COLLECT.PARCEL
3167: 3de0:             GOSUB CHANGE.SCREEN1
3168: 3df2:             IF mismatch% THEN BEGIN
3169: 3e01:                CALL DM.FOCUS("", "MESSAGE(221,"                         \
3170: 3e2a:                              + "'Change NOT implemented - recheck details.')")
3171: 3e2a:             ENDIF ELSE BEGIN
3172: 3e32:                CALL DM.FOCUS("", "MESSAGE(221,"                         \
3173: 3e59:                              + "'Status has been updated.')")
3174: 3e59:             ENDIF
3175: 3e63:          ENDIF ELSE BEGIN                                               ! BSH
3176: 3e6b:             CALL DM.FOCUS("", "MESSAGE(221,"                            \ BSH
3177: 3e92:                           + "'Change cancelled.')")                     ! BSH
3178: 3e92:          ENDIF                                                          ! BSH
3179: 3e9d: 
3180: 3e9d:       \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -    !AGCS
3181: 3e9d:       \*     F4 Key(Book In) pressed and status is either of the        !AGCS
3182: 3e9d:       \*     following:                                                 !AGCS
3183: 3e9d:       \*        - Late Delivery                                         !AGCS
3184: 3e9d:       \*        - Expected Delivery                                     !AGCS
3185: 3e9d:       \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -    !AGCS
3186: 3e9d:       ENDIF ELSE IF RET.KEY% = F4.KEY% AND            \                 !AGCS
3187: 3f46:                   ((LEFT$(p.arr$(indx%),1) = "1") OR  \       ! Late    !AGCS
3188: 3f46:                    (LEFT$(p.arr$(indx%),1) = "2")) THEN BEGIN ! Expected!AGCS
3189: 3f46:                                                                         !AGCS
3190: 3f46:          WHILE RET.KEY% <> ENTER.KEY%                               \   !AGCS
3191: 3f50:            AND RET.KEY% <> F3.KEY%                                      !AGCS
3192: 3f50:             RET.KEY% = DM.INVISIBLE.INPUT("221 "                    \   !AGCS
3193: 3f82:                              + "'Marking as Booked-in cannot be "   \   !AGCS
3194: 3f82:                              + "undone. "                           \   !AGCS
3195: 3f82:                              + "ENTER to confirm or F3 to cancel.' "\   !AGCS
3196: 3f82:                              + "MESSAGE")                               !AGCS
3197: 3f82:          WEND                                                           !AGCS
3198: 3fb0:                                                                         !AGCS
3199: 3fb0:          IF RET.KEY% = ENTER.KEY% THEN BEGIN                            !AGCS
3200: 3fc8:             GOSUB BOOKIN.PARCEL                                         !AGCS
3201: 3fda:             GOSUB CHANGE.SCREEN1                                        !AGCS
3202: 3fec:             IF mismatch% THEN BEGIN                                     !AGCS
3203: 3ffe:                                                                         !AICS
3204: 3ffe:                 IF CARTON.FILE.ERROR OR                                \!AICS
3205: 4012:                     PSUTQ.FILE.ERROR THEN BEGIN                         !AICS
3206: 4012:                                                                         !AICS
3207: 4012:                     IF CARTON.FILE.ERROR THEN BEGIN                     !AICS
3208: 4021:                         TEMP.REPORT.NUM% = CRTN.REPORT.NUM%             !AICS
3209: 4035:                     ENDIF ELSE BEGIN                                    !AICS
3210: 403d:                         TEMP.REPORT.NUM% = PSUTQ.REPORT.NUM%            !AICS
3211: 404f:                     ENDIF                                               !AICS
3212: 4057:                                                                         !AICS
3213: 4057:                     CALL DM.FOCUS("", "MESSAGE(514,'"                + \!AHCS
3214: 40be:                        RIGHT$("000" + STR$(TEMP.REPORT.NUM%), 3)     + \!AICS
3215: 40be:                               "update - press ESCAPE to continue')")    !AHCS
3216: 40be:                 ENDIF ELSE BEGIN                                        !AHCS
3217: 40c6: 
3218: 40c6:                     CALL DM.FOCUS("", "MESSAGE(221,"                   \!AGCS
3219: 40ed:                        + "'Change NOT implemented - recheck details.')")!AGCS
3220: 40ed:                 ENDIF                                                   !AHCS
3221: 40f7:             ENDIF ELSE BEGIN                                            !AGCS
3222: 40ff:                CALL DM.FOCUS("", "MESSAGE(221,"                        \!AGCS
3223: 4126:                        + "'Status has been updated.')")                 !AGCS
3224: 4126:             ENDIF                                                       !AGCS
3225: 4130:          ENDIF ELSE BEGIN                                               !AGCS
3226: 4138:             CALL DM.FOCUS("", "MESSAGE(221,"                           \!AGCS
3227: 415f:                        + "'Change cancelled.')")                        !AGCS
3228: 415f:          ENDIF                                                          !AGCS
3229: 416a: 
3230: 416a:       \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
3231: 416a:       \*     F5 Key(Return) pressed and status is either of the         !FMM
3232: 416a:       \*     following:                                                 !FMM
3233: 416a:       \*        - Uncollected - Return to W/H?                          !FMM
3234: 416a:       \*        - Instore - Awaiting collection                         !FMM
3235: 416a:       \*        - Instore - Found                                       !FMM
3236: 416a:       \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
3237: 416a:       ENDIF ELSE IF RET.KEY% = F5.KEY% AND            \                 !FMM
3238: 425a:                   ((LEFT$(p.arr$(indx%),1) = "3") OR  \    Uncollected  !FMM
3239: 425a:                    (LEFT$(p.arr$(indx%),1) = "4") OR  \       Awaiting  !FMM
3240: 425a:                    (LEFT$(p.arr$(indx%),1) = "5")) THEN BEGIN   !Found  !FMM
3241: 425a: 
3242: 425a:          WHILE RET.KEY% <> ENTER.KEY%                               \
3243: 4264:            AND RET.KEY% <> F3.KEY%
3244: 4264:             RET.KEY% = DM.INVISIBLE.INPUT("221 "                    \
3245: 4296:                              + "'Marking as Returned cannot be "    \ CSH
3246: 4296:                              + "undone. "                           \ CSH
3247: 4296:                              + "ENTER to confirm or F3 to cancel.' "\
3248: 4296:                              + "MESSAGE")
3249: 4296:          WEND
3250: 42c4: 
3251: 42c4:          IF RET.KEY% = ENTER.KEY% THEN BEGIN                            ! BSH
3252: 42dc:             GOSUB RETURN.PARCEL
3253: 42ee:             GOSUB CHANGE.SCREEN1
3254: 4300:             IF mismatch% THEN BEGIN
3255: 430f:                CALL DM.FOCUS("", "MESSAGE(221,"                         \
3256: 4338:                              + "'Change NOT implemented - recheck details.')")
3257: 4338:             ENDIF ELSE BEGIN
3258: 4340:                CALL DM.FOCUS("", "MESSAGE(221,"                         \
3259: 4367:                              + "'Status has been updated.')")
3260: 4367:             ENDIF
3261: 4371:          ENDIF ELSE BEGIN                                               ! BSH
3262: 4379:             CALL DM.FOCUS("", "MESSAGE(221,"                            \ BSH
3263: 43a0:                           + "'Change cancelled.')")                     ! BSH
3264: 43a0:          ENDIF                                                          ! BSH
3265: 43ab:       \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
3266: 43ab:       \*     F6 Key(Lost/Found) pressed and status is either of the     !FMM
3267: 43ab:       \*     following:                                                 !FMM
3268: 43ab:       \*        - Uncollected - Return to W/H?                          !FMM
3269: 43ab:       \*        - Instore - Awaiting collection                         !FMM
3270: 43ab:       \*        - Instore - Found                                       !FMM
3271: 43ab:       \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
3272: 43ab:       ENDIF ELSE IF RET.KEY% = F6.KEY% AND            \                 !FMM
3273: 449b:                   ((LEFT$(p.arr$(indx%),1) = "3") OR  \    Uncollected  !FMM
3274: 449b:                    (LEFT$(p.arr$(indx%),1) = "4") OR  \       Awaiting  !FMM
3275: 449b:                    (LEFT$(p.arr$(indx%),1) = "5")) THEN BEGIN   !Found  !FMM
3276: 449b: 
3277: 449b:          WHILE RET.KEY% <> ENTER.KEY%                               \
3278: 44a5:            AND RET.KEY% <> F3.KEY%
3279: 44a5:             RET.KEY% = DM.INVISIBLE.INPUT("221 "                    \
3280: 44d3:                           + "'Do you wish to mark Lost? "           \
3281: 44d3:                           + "ENTER to confirm or F3 to cancel.' "   \
3282: 44d3:                           + "MESSAGE")
3283: 44d3:          WEND
3284: 4501: 
3285: 4501:          IF RET.KEY% = ENTER.KEY% THEN BEGIN                            ! BSH
3286: 4519:             GOSUB LOST.PARCEL
3287: 452b:             GOSUB CHANGE.SCREEN1
3288: 453d:             IF mismatch% THEN BEGIN
3289: 454c:                CALL DM.FOCUS("", "MESSAGE(221,"                         \
3290: 4575:                              + "'Change NOT implemented - recheck details.')")
3291: 4575:             ENDIF ELSE BEGIN
3292: 457d:                CALL DM.FOCUS("", "MESSAGE(221,"                         \
3293: 45a4:                              + "'Status has been updated.')")
3294: 45a4:             ENDIF
3295: 45ae:          ENDIF ELSE BEGIN                                               ! BSH
3296: 45b6:             CALL DM.FOCUS("", "MESSAGE(221,"                            \ BSH
3297: 45dd:                           + "'Change cancelled.')")                     ! BSH
3298: 45dd:          ENDIF                                                          ! BSH
3299: 45e8:       \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
3300: 45e8:       \*     F6 Key(Lost/Found) pressed and status = Lost               !FMM
3301: 45e8:       \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
3302: 45e8:       ENDIF ELSE IF RET.KEY% = F6.KEY% AND \                            !FMM
3303: 464a:                     LEFT$(p.arr$(indx%),1) = "8" THEN BEGIN      !Lost  !FMM
3304: 464a: 
3305: 464a:          WHILE RET.KEY% <> ENTER.KEY%                               \
3306: 4654:            AND RET.KEY% <> F3.KEY%
3307: 4654:             RET.KEY% = DM.INVISIBLE.INPUT("221 "                    \
3308: 4682:                           + "'Do you wish to mark Found? "          \
3309: 4682:                           + "ENTER to confirm or F3 to cancel.' "   \
3310: 4682:                           + "MESSAGE")
3311: 4682:          WEND
3312: 46b0: 
3313: 46b0:          IF RET.KEY% = ENTER.KEY% THEN BEGIN                            ! BSH
3314: 46c8:             GOSUB FOUND.PARCEL
3315: 46da:             GOSUB CHANGE.SCREEN1
3316: 46ec:             IF mismatch% THEN BEGIN
3317: 46fb:                CALL DM.FOCUS("", "MESSAGE(221,"                         \
3318: 4724:                               + "'Change NOT implemented - recheck details.')")
3319: 4724:             ENDIF ELSE BEGIN
3320: 472c:                CALL DM.FOCUS("", "MESSAGE(221,"                         \
3321: 4753:                                       + "'Status has been updated.')")
3322: 4753:             ENDIF
3323: 475d:          ENDIF ELSE BEGIN                                               ! BSH
3324: 4765:             CALL DM.FOCUS("", "MESSAGE(221,"                            \ BSH
3325: 478c:                           + "'Change cancelled.')")                     ! BSH
3326: 478c:          ENDIF                                                          ! BSH
3327: 4797: 
3328: 4797:       \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
3329: 4797:       \*     PgUp/F7/Prev Key and NOT on page 1
3330: 4797:       \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
3331: 4797:       ENDIF ELSE IF ( RET.KEY% = F7.KEY%                            \
3332: 47e6:                    OR RET.KEY% = PGUP.KEY%                          \
3333: 47e6:                    OR RET.KEY% = PREV.KEY%)                         \
3334: 47e6:                 AND (scrn1% > 1) THEN BEGIN
3335: 47e6:          scrn1% = scrn1% -1
3336: 47f2:          IF RET.KEY% = PREV.KEY% THEN BEGIN
3337: 4807:             CALL DM.CURRENT.FIELD(lpp1% +1)
3338: 481d:          ENDIF ELSE BEGIN
3339: 4825:             CALL DM.CURRENT.FIELD(1 +1)
3340: 4836:          ENDIF
3341: 483e:          GOSUB CHANGE.SCREEN1
3342: 4853:       \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
3343: 4853:       \*     PgDn/F8/Next Key and NOT on last page
3344: 4853:       \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
3345: 4853:       ENDIF ELSE IF ( RET.KEY% = F8.KEY%                            \
3346: 48a3:                    OR RET.KEY% = PGDN.KEY%                          \
3347: 48a3:                    OR RET.KEY% = NEXT.KEY%)                         \
3348: 48a3:                 AND (scrn1% < max.scrn1%) THEN BEGIN
3349: 48a3:          scrn1% = scrn1% +1
3350: 48af:          CALL DM.CURRENT.FIELD(1 +1)
3351: 48c0:          GOSUB CHANGE.SCREEN1
3352: 48d5:       \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
3353: 48d5:       \*     PgDn and on last page
3354: 48d5:       \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
3355: 48d5:       ENDIF ELSE IF ( RET.KEY% = PGDN.KEY%                          \
3356: 48ff:                 AND   scrn1% = max.scrn1% ) THEN BEGIN
3357: 48ff:          CALL DM.FOCUS ("", "MESSAGE(075,'')")
3358: 491a:       \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
3359: 491a:       \*     PgUp and on page 1
3360: 491a:       \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
3361: 491a:       ENDIF ELSE IF ( RET.KEY% = PGUP.KEY%                          \
3362: 4943:                 AND   scrn1% = 1          ) THEN BEGIN
3363: 4943:          CALL DM.FOCUS ("", "MESSAGE(074,'')")
3364: 495e: 
3365: 495e:       ! If F9 key is pressed                                            !DDM
3366: 495e:       ENDIF ELSE IF ( RET.KEY% = F9.KEY%) AND PRINT.KEY = TRUE  \       !FMM
3367: 4988:                                                              THEN BEGIN !FMM
3368: 4988:          GOSUB PRINT.BDCRPT                                             !DDM
3369: 499d: 
3370: 499d:       ENDIF ELSE IF (RET.KEY% = F10.KEY%) THEN BEGIN                    !HDC
3371: 49b2:       ! If F10 key is pressed                                           !HDC
3372: 49b2:           IF F10.NOT.ALLOWED THEN BEGIN                                 !IDC
3373: 49c3:           ENDIF ELSE BEGIN                                              !IDC
3374: 49cb:               GOSUB DISPLAY.SCREEN2                                     !HDC
3375: 49dd:               GOSUB PROCESS.SCREEN2                                     !HDC
3376: 49ef:               SCREEN.COMPLETE = -1                                      !HDC
3377: 49fc:               RET.KEY% = ENTER.KEY% ! set as special case to reload     !HDC
3378: 4a0e:           ENDIF                                                         !IDC
3379: 4a18:       \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
3380: 4a18:       \*     Anything else
3381: 4a18:       \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
3382: 4a18:       ENDIF ELSE BEGIN
3383: 4a20:          ! B001 Invalid key pressed
3384: 4a20:          CALL DM.FOCUS ("", "MESSAGE(1,'')")
3385: 4a38:       ENDIF
3386: 4a40: 
3387: 4a40:    WEND
3388: 4a52: 
3389: 4a52: RETURN
3390: 4a62: 
3391: 4a62: 
3392: 4a62: !***********************************************************************!HDC
3393: 4a62: !* Code change H block marker - START                                   !HDC
3394: 4a62: !***********************************************************************!HDC
3395: 4a62: !***********************************************************************
3396: 4a62: \***
3397: 4a62: \***    SUBROUTINE      :      DISPLAY.SCREEN2
3398: 4a62: \***
3399: 4a62: !***********************************************************************
3400: 4a62: 
3401: 4a62: DISPLAY.SCREEN2:
3402: 4a72: 
3403: 4a72:    IF MANAGE.LOCATION THEN FILE.LOADED% = 0                             !LLJ
3404: 4a86: 
3405: 4a86:    SCRN2%     = 1                                                       !LLJ
3406: 4a94:    MAX.SCRN2% = 1                                                       !LLJ
3407: 4aa2: 
3408: 4aa2:    ! Get the number of screens required                                 !RLJ
3409: 4aa2:    MAX.SCRN2% = BDCLOCON.TOTAL.RECORDS% / LOC.RECORDS.ON.PAGE%          !RLJ
3410: 4abe:    ! If the number of records are not multiple of LOC.RECORDS.ON.PAGE%  !RLJ
3411: 4abe:    IF MOD(BDCLOCON.TOTAL.RECORDS%,LOC.RECORDS.ON.PAGE%) > 0 THEN BEGIN  !RLJ
3412: 4aec:        MAX.SCRN2% = MAX.SCRN2% + 1                                      !RLJ
3413: 4af8:    ENDIF                                                                !RLJ
3414: 4b00:                                                                         !RLJ
3415: 4b00:    P.CNT2% = BDCLOCON.TOTAL.RECORDS% * LOC.FIELDS.PER.LINE% +          \!RLJ
3416: 4b2a:              ( LOC.FIELDS.START% - 1 )                                  !RLJ
3417: 4b2a: 
3418: 4b2a:    CURRENT.ORDER.INDX% = DM.CURRENT.FIELD(0)
3419: 4b3e:    CURRENT.ORDER.I%    = ((SCRN1% -1) * LPP1%) + (I% -1)                !LLJ
3420: 4b58: 
3421: 4b58:    ! Screen title displayed as per the store (UK/ROI)
3422: 4b58:    IF MANAGE.LOCATION THEN BEGIN                                        !IDC
3423: 4b67:        ! onluy show new help if managing locations                      !IDC
3424: 4b67:        CALL DM.SHOW.SCREEN (2, SCREEN2.TITLE$, 21, 21)                  !IDC
3425: 4b87:    ENDIF ELSE BEGIN                                                     !IDC
3426: 4b8f:        CALL DM.SHOW.SCREEN (2, SCREEN2.TITLE$, 11, 11)                  !IDC
3427: 4bad:    ENDIF                                                                !IDC
3428: 4bb5:    CURRENT.SCREEN% = 2                                                  !IDC
3429: 4bc3:    CALL DM.NAME (160, "page2$", PAGE2$)                                 !LLJ
3430: 4c00: !  ! Suppress the page number as we have only one page                  !RLJ
3431: 4c00:                                                                         !RLJ
3432: 4c00:    CALL DM.NAME (145, "F10.MESSAGE$", F10.MESSAGE$)                     !RLJ
3433: 4c3d:                                                                         !RLJ
3434: 4c3d:    GOSUB CHANGE.SCREEN2
3435: 4c4f: 
3436: 4c4f: RETURN
3437: 4c5f: 
3438: 4c5f: 
3439: 4c5f: !***********************************************************************
3440: 4c5f: \***
3441: 4c5f: \***    SUBROUTINE      :      CHANGE.SCREEN2
3442: 4c5f: \***
3443: 4c5f: !***********************************************************************
3444: 4c5f: 
3445: 4c5f: CHANGE.SCREEN2:
3446: 4c6f: 
3447: 4c6f: 
3448: 4c6f:     WK$ = "Page " + STR$(SCRN2%)                                     \  !LLJ
3449: 4cac:         + " of "  + STR$(MAX.SCRN2%)                                    !LLJ
3450: 4cac: 
3451: 4cac:     PAGE2$ = RIGHT$(STRING$(15," ") + WK$, 15)                          !LLJ
3452: 4cf4:     ! If location management then do not display F10 message            !RLJ
3453: 4cf4:     IF MANAGE.LOCATION THEN BEGIN                                       !RLJ
3454: 4d03:         F10.MESSAGE$ = STRING$(74," ")                                  !RLJ
3455: 4d21:     ENDIF ELSE BEGIN                                                    !RLJ
3456: 4d29:         F10.MESSAGE$ = "Highlight the location you wish to update " +  \!RLJ
3457: 4d45:                        "and then press F10 to complete."                !RLJ
3458: 4d45:     ENDIF                                                               !RLJ
3459: 4d4d: 
3460: 4d4d:     ! I% is the field number used, with LPP2% being the maximum output  !LLJ
3461: 4d4d:     ! fields per page
3462: 4d4d:     ! Set the end of possible record in this screen variable
3463: 4d4d:     P.FULL% = 0
3464: 4d5b: 
3465: 4d5b:     FOR I% = LOC.FIELDS.START% TO LPP2% +1                              !LLJ
3466: 4d6c: 
3467: 4d6c:         INDX% =  I% + ((SCRN2% - 1) * (LPP2% - LOC.FIELDS.START% + 1))  !RLJ
3468: 4d8d:                                                                         !RLJ
3469: 4d8d:         IF INDX% <= P.CNT2% AND I% <= LPP2% THEN BEGIN                  !RLJ
3470: 4db7: 
3471: 4db7:             IF MOD(INDX%,LOC.FIELDS.PER.LINE%) = 0 THEN BEGIN
3472: 4ddf: 
3473: 4ddf:                 BDCLOCON.RECORD.NUM% = (INDX%)/LOC.FIELDS.PER.LINE%     !RLJ
3474: 4df6:                 IF BDCLOCON.RECORD.NUM% > BDCLOCON.TOTAL.RECORDS%      \!RLJ
3475: 4e1f:                                                             THEN BEGIN  !RLJ
3476: 4e1f:                     P.CNT2% = INDX%                                     !LLJ
3477: 4e2d:                     ! set as full now as there are no more records
3478: 4e2d:                     P.FULL% = 1
3479: 4e3e:                 ENDIF ELSE \
3480: 4e46:                 BEGIN
3481: 4e46: 
3482: 4e46:                     ! Open BDCLOCON file                                !QCK
3483: 4e46:                     GOSUB OPEN.BDCLOCON                                 !QCK
3484: 4e58: 
3485: 4e58:                     IF READ.BDCLOCON THEN BEGIN
3486: 4e69:                         P.CNT2% = INDX%                                 !LLJ
3487: 4e77:                         ! set as full now as cannot continue read
3488: 4e77:                         ! this should be unexpected as we know the
3489: 4e77:                         ! total records (above), so will only be due
3490: 4e77:                         ! to an error
3491: 4e77:                         P.FULL% = 1
3492: 4e87:                     ENDIF ELSE BEGIN                                    !RLJ
3493: 4e8f:                         !Save the description to use during validation  !RLJ
3494: 4e8f:                         IF BDCLOCON.RECORD.NUM% = 1 THEN BEGIN          !RLJ
3495: 4ea1:                             LOCATION1.DESC$ = BDCLOCON.LONG.NAME$       !RLJ
3496: 4ebd:                         ENDIF                                           !RLJ
3497: 4ec5:                     ENDIF                                               !RLJ
3498: 4ecd: 
3499: 4ecd:                     ! Closing BDCLOCON file                             !QCK
3500: 4ecd:                     IF BDCLOCON.OPEN THEN BEGIN                         !QCK
3501: 4edf:                         CLOSE BDCLOCON.SESS.NUM%                        !QCK
3502: 4ef3:                                                                         !QCK
3503: 4ef3:                         ! Reset the flag                                !QCK
3504: 4ef3:                         BDCLOCON.OPEN = FALSE                           !QCK
3505: 4f05:                     ENDIF                                               !QCK
3506: 4f0d: 
3507: 4f0d:                 ENDIF
3508: 4f15:             ENDIF
3509: 4f1d: 
3510: 4f1d:         ! only store if we have more to do
3511: 4f1d:             IF P.FULL% <> 1 THEN BEGIN
3512: 4f2f:                 LOCATION.ARRAY$(I%) = FUNC.GET.FIELD.DISPLAY2$(INDX%)   !LLJ
3513: 4f55: 
3514: 4f55:                 CALL DM.NAME(I%,"f"+STR$(I%)+"$",LOCATION.ARRAY$(I%))   !LLJ
3515: 4fb6:                 CALL DM.VISIBLE (STR$(I%), "TRUE")                      !LLJ
3516: 4fe3: 
3517: 4fe3:                 IF MANAGE.LOCATION THEN BEGIN
3518: 4ff4:                     ! allow update except the first record              !MLJ
3519: 4ff4:                 ENDIF ELSE BEGIN
3520: 4ffc:                     CALL DM.RO.FIELD(I%)                                !LLJ
3521: 500f:                 ENDIF
3522: 5017:                 IF P.CNT2% = INDX% THEN BEGIN                           !LLJ
3523: 5028:                     I% = LPP2%+1                                        !LLJ
3524: 5037:                 ENDIF
3525: 503f:             ENDIF
3526: 5047:         ENDIF
3527: 504f: 
3528: 504f:    NEXT I%                                                              !LLJ
3529: 506b: 
3530: 506b:    I%    = DM.CURRENT.FIELD(0)                                          !LLJ
3531: 507f:    INDX% =  I% + ((SCRN2% - 1) * (LPP2% - LOC.FIELDS.START% + 1))       !RLJ
3532: 50a0: 
3533: 50a0:    !Checking the index value to update the default location flag.       !TAH
3534: 50a0:    !The default location is present only in the first screen.           !TAH
3535: 50a0:    IF INDX% = INITIAL.FIELD.INDEX% THEN BEGIN                           !TAH
3536: 50b2:        NOT.DEFAULT.LOCATION = FALSE                                     !TAH
3537: 50c2:    ENDIF ELSE BEGIN                                                     !TAH
3538: 50ca:        NOT.DEFAULT.LOCATION = TRUE                                      !TAH
3539: 50d8:    ENDIF                                                                !TAH
3540: 50e0:    ! Set the screen changed flag                                        !TAH
3541: 50e0:    SCREEN.CHANGED = TRUE                                                !TAH
3542: 50ee:    CALL SET.F.KEYS(INDX%)                                               !LLJ
3543: 510e: 
3544: 510e: RETURN
3545: 511e: 
3546: 511e: !***********************************************************************
3547: 511e: \***
3548: 511e: \***    SUBROUTINE      :      PROCESS.SCREEN2
3549: 511e: \***
3550: 511e: !***********************************************************************
3551: 511e: 
3552: 511e: PROCESS.SCREEN2:
3553: 512e: 
3554: 512e:    !If Location management then use default confirmation prompt         !NLJ
3555: 512e:    IF MANAGE.LOCATION THEN BEGIN                                        !NLJ
3556: 513d:        CONFIRM.PROMPT = TRUE                                            !NLJ
3557: 514d:    ENDIF ELSE BEGIN                                                     !NLJ
3558: 5155:        CONFIRM.PROMPT = FALSE                                           !NLJ
3559: 5163:    ENDIF                                                                !NLJ
3560: 516b:                                                                         !NLJ
3561: 516b:    SCREEN.COMPLETE2 = 0
3562: 5178: 
3563: 5178:    WHILE NOT SCREEN.COMPLETE2
3564: 5183: 
3565: 5183:       RET.KEY% = DM.PROCESS.SCREEN (2, LPP2% +1, CONFIRM.PROMPT)        !NLJ
3566: 51a2: 
3567: 51a2:       I% = DM.CURRENT.FIELD(0)                                          !LLJ
3568: 51b6:       INDX% = I% + ((SCRN2% - 1) * (LPP2% - LOC.FIELDS.START% + 1))     !RLJ
3569: 51d7: 
3570: 51d7:       \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
3571: 51d7:       \*     F3 Key pressed
3572: 51d7:       \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
3573: 51d7:       IF RET.KEY% = F3.KEY% THEN BEGIN
3574: 51ef:          SCREEN.COMPLETE2 = -1
3575: 51fc:           IF MANAGE.LOCATION THEN BEGIN                                 !JDC
3576: 520e:           ENDIF ELSE BEGIN                                              !JDC
3577: 5216:               PROMPT.MESSAGE$ = "Exit without saving Location? " +  \   !JDC
3578: 5232:                                 "F3 to Exit or ENTER Continue."         !JDC
3579: 5232:               RET.KEY% = FUNC.PROMPT.FOR.RESPONSE%(PROMPT.MESSAGE$)     !JDC
3580: 524c:               IF RET.KEY% = ENTER.KEY% THEN BEGIN                       !JDC
3581: 5261:                   CALL DM.FOCUS("", "MESSAGE(221,"  \                   !JDC
3582: 5288:                               + "'Change cancelled.')")                 !JDC
3583: 5288:                   SCREEN.COMPLETE2 = 0                                  !JDC
3584: 5295:               ENDIF                                                     !JDC
3585: 529d:            ENDIF
3586: 52a8:       ENDIF ELSE \
3587: 52b0:       IF RET.KEY% = F10.KEY% \
3588: 52d5:       AND NOT MANAGE.LOCATION \
3589: 52d5:       THEN BEGIN
3590: 52d5:           IF F10.NOT.ALLOWED THEN BEGIN                                 !IDC
3591: 52e4:              PROMPT.MESSAGE$ = "Location cannot be used as "          \ !JDC
3592: 5300:                              + "currently INACTIVE. F3 to continue."    !JDC
3593: 5300:              WHILE RET.KEY% <> F3.KEY%                                  !IDC
3594: 530a:                   RET.KEY% = FUNC.PROMPT.FOR.RESPONSE%(PROMPT.MESSAGE$) !JDC
3595: 5324:              WEND                                                       !IDC
3596: 533b:           ENDIF ELSE IF ((INDX%)/LOC.FIELDS.PER.LINE% = 1) THEN BEGIN   !RLJ
3597: 5350:              CALL DM.FOCUS ("", "MESSAGE(336,'')")                      !PLJ
3598: 536a:           ENDIF ELSE BEGIN                                              !IDC
3599: 5372:              GOSUB UPDATE.LOCATION                                      !IDC
3600: 5384:              SCREEN.COMPLETE2 = -1                                      !IDC
3601: 5391:           ENDIF
3602: 539c:       ENDIF ELSE \
3603: 53a4:       IF ((RET.KEY% = ENTER.KEY% OR ACTIVE.TO.BE.SAVED) AND            \!OLJ
3604: 53c7:             MANAGE.LOCATION) THEN BEGIN                                 !OLJ
3605: 53c7:             GOSUB SAVE.BDCLOCON.DATA                                    !RLJ
3606: 53dc:             ! Moved the code to SAVE.BDCLOCON.DATA: subroutine          !RLJ
3607: 53dc:       \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
3608: 53dc:       \*     PgUp/F7/Prev Key and NOT on page 1
3609: 53dc:       \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
3610: 53dc:       ENDIF ELSE IF ( RET.KEY% = F7.KEY%                            \
3611: 542e:                    OR RET.KEY% = PGUP.KEY%                          \
3612: 542e:                    OR RET.KEY% = PREV.KEY%)                         \
3613: 542e:                 AND (SCRN2% > 1) THEN BEGIN                             !LLJ
3614: 542e:          ! If there are any changes to be saved                         !RLJ
3615: 542e:          IF ANY.CHANGES.DONE THEN BEGIN                                 !RLJ
3616: 543d:             GOSUB SAVE.BDCLOCON.DATA                                    !RLJ
3617: 544f:          ENDIF                                                          !RLJ
3618: 5457:          SCRN2% = SCRN2% -1                                             !LLJ
3619: 5463:          IF RET.KEY% = PREV.KEY% THEN BEGIN
3620: 5478:             CALL DM.CURRENT.FIELD(LPP2% +1)                             !LLJ
3621: 548e:          ENDIF ELSE BEGIN
3622: 5496:             CALL DM.CURRENT.FIELD(5)                                    !RLJ
3623: 54a7:          ENDIF
3624: 54af: 
3625: 54af:          GOSUB CHANGE.SCREEN2                                           !RLJ
3626: 54c4:       \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
3627: 54c4:       \*     PgDn/F8/Next Key and NOT on last page
3628: 54c4:       \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
3629: 54c4:       ENDIF ELSE IF ( RET.KEY% = F8.KEY%                            \
3630: 5514:                    OR RET.KEY% = PGDN.KEY%                          \
3631: 5514:                    OR RET.KEY% = NEXT.KEY%)                         \
3632: 5514:                 AND (SCRN2% < MAX.SCRN2%) THEN BEGIN                    !LLJ
3633: 5514:          ! If there are any changes to be saved                         !RLJ
3634: 5514:          IF ANY.CHANGES.DONE THEN BEGIN                                 !RLJ
3635: 5523:             GOSUB SAVE.BDCLOCON.DATA                                    !RLJ
3636: 5535:          ENDIF                                                          !RLJ
3637: 553d: 
3638: 553d:          SCRN2% = SCRN2% +1                                             !LLJ
3639: 5549:          CALL DM.CURRENT.FIELD(5)                                       !RLJ
3640: 555a:          GOSUB CHANGE.SCREEN2                                           !RLJ
3641: 556f:       \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
3642: 556f:       \*     PgDn and on last page
3643: 556f:       \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
3644: 556f:       ENDIF ELSE IF ( RET.KEY% = PGDN.KEY%                          \
3645: 5599:                 AND   SCRN2% = MAX.SCRN2% ) THEN BEGIN                  !LLJ
3646: 5599:          CALL DM.FOCUS ("", "MESSAGE(075,'')")
3647: 55b4:       \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
3648: 55b4:       \*     PgUp and on page 1
3649: 55b4:       \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
3650: 55b4:       ENDIF ELSE IF ( RET.KEY% = PGUP.KEY%                          \
3651: 55dd:                 AND   SCRN2% = 1          ) THEN BEGIN                  !LLJ
3652: 55dd:          CALL DM.FOCUS ("", "MESSAGE(074,'')")
3653: 55f8: 
3654: 55f8:       ENDIF ELSE \              !                                       !IDC
3655: 5600:       IF RET.KEY% = F6.KEY% \   ! if Activating or Deactivating         !IDC
3656: 5622:       AND MANAGE.LOCATION \     !                                       !IDC
3657: 5622:       THEN BEGIN
3658: 5622: 
3659: 5622:           ! If F6 key pressed on any other location other than 001 and
3660: 5622:           ! the change is accepted (keyed ENTER on confirmation prompt)
3661: 5622:           IF INDX% <> INITIAL.FIELD.INDEX% AND    \                     !ADCK
3662: 5641:              CHANGE.ACCEPTED               THEN BEGIN                   !ADCK
3663: 5641:               BDCLOCON.RECORD.NUM% = (INDX%)/LOC.FIELDS.PER.LINE%       !RLJ
3664: 5658: 
3665: 5658:               ! Open BDCLOCON file                                      !QCK
3666: 5658:               GOSUB OPEN.BDCLOCON                                       !QCK
3667: 566a: 
3668: 566a:               CALL READ.BDCLOCON
3669: 5677:               LOC.STATUS.CHANGED = FALSE                                !LLJ
3670: 5685:               IF BDCLOCON.STATUS$ = "A" THEN BEGIN
3671: 56a6:                   !Deactivate only if there are no parcels at this      !LLJ
3672: 56a6:                   !location                                             !VCK
3673: 56a6:                   IF BDCLOCON.PARCEL.COUNT% <= 0 THEN BEGIN             !LLJ
3674: 56b8:                       BDCLOCON.STATUS$    = "I"    ! Inactive           !LLJ
3675: 56cf:                       !Deactivating an active location makes the        !AFCS
3676: 56cf:                       !description null                                 !AFCS
3677: 56cf:                       LOCATION.ARRAY$(CURRENT.INDEX%) = " "             !AFCS
3678: 56f1:                       LOC.STATUS.CHANGED = TRUE                         !LLJ
3679: 56ff:                       !Reset the inactive checking flag                 !SAH
3680: 56ff:                       INACTIVE.CHECK%    = 0                            !SAH
3681: 570f:                   ENDIF ELSE BEGIN                                      !LLJ
3682: 5717:                       !Setting below flag to false as no status change  !AFCS
3683: 5717:                       LOC.STATUS.CHANGED = FALSE                        !AFCS
3684: 5725:                       !Display error message                            !LLJ
3685: 5725:                       CALL DM.FOCUS ("", "MESSAGE(466,'')")             !ABDC
3686: 573d:                   ENDIF                                                 !LLJ
3687: 5747:               ENDIF ELSE BEGIN
3688: 574f:                   BDCLOCON.STATUS$   = "A"        ! Active              !LLJ
3689: 5766:                   LOC.STATUS.CHANGED = TRUE                             !LLJ
3690: 5774:               ENDIF
3691: 577c:               !Update BDCLOCON only if the status is changed            !LLJ
3692: 577c:               IF LOC.STATUS.CHANGED THEN BEGIN                          !LLJ
3693: 578b:                   LOCATION.ARRAY$(I% - 2) = BDCLOCON.STATUS$            !RLJ
3694: 57b7:                   !Location name is updated as location status changed  !AFCS
3695: 57b7:                   BDCLOCON.LONG.NAME$ = LOCATION.ARRAY$(CURRENT.INDEX%) !AFCS
3696: 57e0:                   CALL WRITE.BDCLOCON
3697: 57ed:               ENDIF                                                     !LLJ
3698: 57f5: 
3699: 57f5:               ! Closing BDCLOCON file                                   !QCK
3700: 57f5:               IF BDCLOCON.OPEN THEN BEGIN                               !QCK
3701: 5807:                   CLOSE BDCLOCON.SESS.NUM%                              !QCK
3702: 581b:                                                                         !QCK
3703: 581b:                   ! Reset the flag                                      !QCK
3704: 581b:                   BDCLOCON.OPEN = FALSE                                 !QCK
3705: 582d:               ENDIF                                                     !QCK
3706: 5837: 
3707: 5837:           ENDIF ELSE IF INDX% = INITIAL.FIELD.INDEX% THEN BEGIN         !ADCK
3708: 5849:               ! If F6 key was pressed on location 001- booked in at till!VCK
3709: 5849:               ! BEMF message 464 is displayed                           !VCK
3710: 5849:               CALL DM.FOCUS ("", "MESSAGE(464,'')")                     !VCK
3711: 5861:           ENDIF                                                         !VCK
3712: 5869: 
3713: 5869:           ! Reset the flag                                              !ADCK
3714: 5869:           CHANGE.ACCEPTED = TRUE                                        !ADCK
3715: 5879: 
3716: 5879:       ENDIF ELSE BEGIN
3717: 5881:           ! B001 Invalid key pressed
3718: 5881:           CALL DM.FOCUS ("", "MESSAGE(1,'')")
3719: 5899:       ENDIF
3720: 58a1: 
3721: 58a1:       ! Reset the variable                                              !ADCK
3722: 58a1:       KEY.ACTION% = 0                                                   !ADCK
3723: 58ae: 
3724: 58ae:    WEND
3725: 58c0: 
3726: 58c0: RETURN
3727: 58d0: 
3728: 58d0: !***********************************************************************
3729: 58d0: 
3730: 58d0: !***********************************************************************
3731: 58d0: UPDATE.LOCATION:
3732: 58e0: 
3733: 58e0:     IF MANAGE.LOCATION THEN BEGIN
3734: 58f2: 
3735: 58f2:         ! update all records since we don't know whats changing
3736: 58f2:         LOCATION.NEW% = FUNC.UPDATE.ALL.LOCATION.RECORDS%               !IDC
3737: 5901: 
3738: 5901:         IF LOCATION.NEW% > 0 THEN BEGIN
3739: 5913:             ! prompt screen if error on updating
3740: 5913:             CALL DM.HIDE.FN.KEY(10)
3741: 5924: 
3742: 5924:             EVENT.NUMBER%   = 106
3743: 5932:             MESSAGE.NUMBER% = 221
3744: 5940:             VAR.STRING.1$   = STR$(LOCATION.NEW%)+ERR
3745: 596f:             VAR.STRING.2$   = \
3746: 59a5:              "Unable to complete update, fail at location " + \
3747: 59a5:               STR$(LOCATION.NEW%) + ". " + \
3748: 59a5:               "Press ESC."
3749: 59a5: 
3750: 59a5:            CALL APPLICATION.LOG ( MESSAGE.NUMBER%, VAR.STRING.1$,           \
3751: 59ce:                                   VAR.STRING.2$, EVENT.NUMBER% )
3752: 59ce: 
3753: 59ce:         ENDIF
3754: 59d8:     ENDIF ELSE BEGIN
3755: 59e0:         !IF THIS IS THE CHANGE OPTION FROM SCREEN 1
3756: 59e0:         SCREEN.COMPLETE2 = -1
3757: 59ed:         LOCATION.NEW% = (INDX%)/LOC.FIELDS.PER.LINE%                    !RLJ
3758: 5a00:         GOSUB LOCATION.CHANGE
3759: 5a12:     ENDIF
3760: 5a1a: 
3761: 5a1a: RETURN
3762: 5a2a: 
3763: 5a2a: !***********************************************************************
3764: 5a2a: \***
3765: 5a2a: \***    SUBROUTINE      :      LOCATION.CHANGE
3766: 5a2a: \***
3767: 5a2a: !***********************************************************************
3768: 5a2a: 
3769: 5a2a: LOCATION.CHANGE:
3770: 5a3a: 
3771: 5a3a:     ! Close BDCP file if it is opened and reopen for keyed access
3772: 5a3a:     ! (with update)
3773: 5a3a: 
3774: 5a3a:     IF BDCP.OPEN% THEN BEGIN
3775: 5a49:         CLOSE BDCP.SESS.NUM%
3776: 5a5d:         BDCP.OPEN% = 0
3777: 5a6a:     ENDIF
3778: 5a72: 
3779: 5a72:     CURRENT.REPORT.NUM% = BDCP.REPORT.NUM%
3780: 5a88: 
3781: 5a88:     IF END #BDCP.SESS.NUM% THEN OPEN.ERROR
3782: 5aa4:     OPEN BDCP.FILE.NAME$ KEYED RECL BDCP.RECL% AS BDCP.SESS.NUM% NODEL
3783: 5ad1:     BDCP.OPEN% = 1
3784: 5ade: 
3785: 5ade:     INDX% = CURRENT.ORDER.I%     ! not sure why these swap but may need !LLJ
3786: 5aec:     I%    = CURRENT.ORDER.INDX%  ! to have screen 2 own versions        !LLJ
3787: 5afa: 
3788: 5afa:     GOSUB READ.RECORD.LOCK
3789: 5b0c: 
3790: 5b0c:     IF NOT MISMATCH% THEN BEGIN                                         !LLJ
3791: 5b1e: 
3792: 5b1e:         ! Save old and new locations for use later (3-byte ASCII)       !AICS
3793: 5b1e:         PSUTQ.PREV.LOCON$ = RIGHT$("000" + STR$(BDCP.LOC.CURRENT%), 3)  !AICS
3794: 5b66:         PSUTQ.CURR.LOCON$ = RIGHT$("000" + STR$(LOCATION.NEW%), 3)      !AICS
3795: 5baa: 
3796: 5baa:         !Avoid spaces incase it is a new record having filler spaces    !LLJ
3797: 5baa:         IF CHR$(BDCP.LOC.CURRENT%) = "  " THEN BEGIN                    !LLJ
3798: 5bd7:             BDCP.LOC.CURRENT% = 0                                       !LLJ
3799: 5be8:         ENDIF                                                           !LLJ
3800: 5bf0: !AICS        !Decrease the count by one for old locaiton                     !LLJ
3801: 5bf0: !AICS        BDCLOCON.RECORD.NUM% = BDCP.LOC.CURRENT%                        !LLJ
3802: 5bf0: !AICS        PARCEL.COUNT%        = -1        !Decrement by 1                !LLJ
3803: 5bf0: !AICS        GOSUB UPDATE.PARCEL.COUNT                                       !LLJ
3804: 5bf0: 
3805: 5bf0:         BDCP.LOC.CURRENT% = LOCATION.NEW%
3806: 5c02: 
3807: 5c02: !AICS        !Increase the count by one for new locaiton                     !LLJ
3808: 5c02: !AICS        BDCLOCON.RECORD.NUM% = BDCP.LOC.CURRENT%                        !LLJ
3809: 5c02: !AICS        PARCEL.COUNT%        = 1         !Increment by 1                !LLJ
3810: 5c02: !AICS        GOSUB UPDATE.PARCEL.COUNT                                       !LLJ
3811: 5c02: 
3812: 5c02:     ENDIF
3813: 5c0a:     ! force reset as can be updated outside of this screen
3814: 5c0a:     BDCP.LOC.STATUS% = 0                                                !IDC
3815: 5c1b: 
3816: 5c1b:     GOSUB WRITE.RECORD.UNLOCK
3817: 5c2d: 
3818: 5c2d:     ! Closing BDCP file
3819: 5c2d: 
3820: 5c2d:     IF BDCP.OPEN% THEN BEGIN
3821: 5c3c:         CLOSE BDCP.SESS.NUM%
3822: 5c50:         BDCP.OPEN% = 0
3823: 5c5d:     ENDIF
3824: 5c65: 
3825: 5c65:     PSUTQ.TRANS.TYPE$ = "1"                                             !AICS
3826: 5c7c:     PSUTQ.CURROP$     = "M"                                             !AICS
3827: 5c91:     GOSUB ADD.RECORD.TO.END.OF.PSUTQ.FILE                               !AICS
3828: 5ca3: 
3829: 5ca3:     ! Reset location                                                    !LLJ
3830: 5ca3:     LOCATION.NEW% = 0                                                   !LLJ
3831: 5cb1: 
3832: 5cb1: RETURN
3833: 5cc1: !***********************************************************************!HDC
3834: 5cc1: !* Code change H block marker - END                                     !HDC
3835: 5cc1: !***********************************************************************!HDC
3836: 5cc1: 
3837: 5cc1: \***********************************************************************!RLJ
3838: 5cc1: \* SAVE.BDCLOCON.DATA:                                                  !RLJ
3839: 5cc1: \* To update the changes on the screen to BDCLOCON file                 !RLJ
3840: 5cc1: \*                                                                      !RLJ
3841: 5cc1: \***********************************************************************!RLJ
3842: 5cc1: SAVE.BDCLOCON.DATA:                                                     !RLJ
3843: 5cd1: 
3844: 5cd1:     PROMPT.MESSAGE$ = "Update all changes on screen? "  + \             !RLJ
3845: 5ced:                       "ENTER to confirm or F3 to cancel."               !RLJ
3846: 5ced:     RET.KEY% = FUNC.PROMPT.FOR.RESPONSE%(PROMPT.MESSAGE$)               !RLJ
3847: 5d07:                                                                         !RLJ
3848: 5d07:     IF RET.KEY% = ENTER.KEY% THEN BEGIN                                 !RLJ
3849: 5d1f:         GOSUB UPDATE.LOCATION                                           !RLJ
3850: 5d31:         ! Save status also                                              !RLJ
3851: 5d31:         IF ACTIVE.TO.BE.SAVED THEN BEGIN                                !RLJ
3852: 5d43:             ! Get the actual index                                      !UCK
3853: 5d43:             CURRENT.INDEX% =  I%           +              \             !UCK
3854: 5d64:                              ((SCRN2% - 1) *              \             !UCK
3855: 5d64:                               (LPP2% - LOC.FIELDS.START% + 1))          !UCK
3856: 5d64:             ! Modified to get correct record number                     !UCK
3857: 5d64:             BDCLOCON.RECORD.NUM% = (CURRENT.INDEX%)/LOC.FIELDS.PER.LINE%!UCK
3858: 5d7b:                                                                         !RLJ
3859: 5d7b:             ! Open BDCLOCON file                                        !RLJ
3860: 5d7b:             GOSUB OPEN.BDCLOCON                                         !RLJ
3861: 5d8d:                                                                         !RLJ
3862: 5d8d:             CALL READ.BDCLOCON                                          !RLJ
3863: 5d9a:             BDCLOCON.STATUS$ = "A"                                      !RLJ
3864: 5db1:             CALL WRITE.BDCLOCON                                         !RLJ
3865: 5dbe:                                                                         !RLJ
3866: 5dbe:             ! Closing BDCLOCON file                                     !RLJ
3867: 5dbe:             IF BDCLOCON.OPEN THEN BEGIN                                 !RLJ
3868: 5dd0:                 CLOSE BDCLOCON.SESS.NUM%                                !RLJ
3869: 5de4:                                                                         !RLJ
3870: 5de4:                 ! Reset the flag                                        !RLJ
3871: 5de4:                 BDCLOCON.OPEN = FALSE                                   !RLJ
3872: 5df6:             ENDIF                                                       !RLJ
3873: 5dfe:                                                                         !RLJ
3874: 5dfe:             ! Updating the status in array using correct parameter      !UCK
3875: 5dfe:             LOCATION.ARRAY$(I% - 2) = BDCLOCON.STATUS$                  !UCK
3876: 5e2a:         ENDIF                                                           !RLJ
3877: 5e34:     ! If F3 pressed                                                     !ADCK
3878: 5e34:     ENDIF ELSE BEGIN                                                    !RLJ
3879: 5e3c:         ! If the main key pressed was F6, show F6 function text as      !ADCK
3880: 5e3c:         ! 'ACTIV' since the status is now 'I' as F3 is pressed.         !ADCK
3881: 5e3c:         IF KEY.ACTION% = 1 THEN BEGIN                                   !ADCK
3882: 5e4b:             CALL DM.SHOW.FN.KEY(6, ACTIVATE.FN.TEXT$)                   !ADCK
3883: 5e65:         ENDIF                                                           !ADCK
3884: 5e6d:     ENDIF                                                               !ADCK
3885: 5e75:     ACTIVE.TO.BE.SAVED = FALSE                                          !RLJ
3886: 5e83:     ANY.CHANGES.DONE   = FALSE                                          !RLJ
3887: 5e91:     !Reset the Flag changed                                             !RLJ
3888: 5e91:     RC.INT1% = DM.CHANGED.FLAG(0)                                       !RLJ
3889: 5ea7:     ! Clear status message                                              !RLJ
3890: 5ea7:     CALL DM.STATUS(BLANK.MSG$)                                          !RLJ
3891: 5ebf: RETURN                                                                  !RLJ
3892: 5ecf:                                                                         !RLJ
3893: 5ecf: 
3894: 5ecf: 
3895: 5ecf: \***********************************************************************!AHCS
3896: 5ecf: \***                                                                    !AHCS
3897: 5ecf: \***    SUBROUTINE      :      ROLLBACK.PARCEL.RECORD                   !AHCS
3898: 5ecf: \***                                                                    !AHCS
3899: 5ecf: \***********************************************************************!AHCS
3900: 5ecf:                                                                         !AHCS
3901: 5ecf: ROLLBACK.PARCEL.RECORD:                                                 !AHCS
3902: 5edf:                                                                         !AHCS
3903: 5edf:     ! Close BDCP file if it is opened and reopen for keyed access       !AHCS
3904: 5edf:     ! (with update)                                                     !AHCS
3905: 5edf:                                                                         !AHCS
3906: 5edf:     IF BDCP.OPEN% THEN BEGIN                                            !AHCS
3907: 5eee:         CLOSE BDCP.SESS.NUM%                                            !AHCS
3908: 5f02:         BDCP.OPEN% = FALSE                                              !AHCS
3909: 5f10:     ENDIF                                                               !AHCS
3910: 5f18:                                                                         !AHCS
3911: 5f18:     CURRENT.REPORT.NUM% = BDCP.REPORT.NUM%                              !AHCS
3912: 5f2e:                                                                         !AHCS
3913: 5f2e:     IF END #BDCP.SESS.NUM% THEN OPEN.ERROR                              !AHCS
3914: 5f4a:     OPEN BDCP.FILE.NAME$ KEYED RECL BDCP.RECL% AS BDCP.SESS.NUM% NODEL  !AHCS
3915: 5f77:     BDCP.OPEN% = TRUE                                                   !AHCS
3916: 5f85:                                                                         !AHCS
3917: 5f85:     GOSUB READ.RECORD.LOCK                                              !AHCS
3918: 5f97:                                                                         !AHCS
3919: 5f97:     ! Reinstate record details as we're rolling back the BDCP change    !AHCS
3920: 5f97:     p.arr$(indx%)      = SAVED.ARRAY$                                   !AHCS
3921: 5fbd:     BDCP.STATUS$       = SAVED.BDCP.STATUS$                             !AHCS
3922: 5fd8:     BDCP.DEL.DATETIME$ = SAVED.BDCP.DEL.DATETIME$                       !AHCS
3923: 5ff3:     BDCP.DEL.EXPORTED$ = SAVED.BDCP.DEL.EXPORTED$                       !AHCS
3924: 600e:                                                                         !AHCS
3925: 600e:     GOSUB WRITE.RECORD.UNLOCK                                           !AHCS
3926: 6020:                                                                         !AHCS
3927: 6020:     ! Close BDCP file                                                   !AHCS
3928: 6020:     IF BDCP.OPEN% THEN BEGIN                                            !AHCS
3929: 602f:         CLOSE BDCP.SESS.NUM%                                            !AHCS
3930: 6043:         BDCP.OPEN% = FALSE                                              !AHCS
3931: 6051:     ENDIF                                                               !AHCS
3932: 6059:                                                                         !AHCS
3933: 6059:     MISMATCH%         = TRUE                                            !AHCS
3934: 6067:     CARTON.FILE.ERROR = TRUE                                            !AHCS
3935: 6075:                                                                         !AHCS
3936: 6075: RETURN                                                                  !AHCS
3937: 6085: 
3938: 6085: 
3939: 6085: \***********************************************************************!AGCS
3940: 6085: \***                                                                    !AGCS
3941: 6085: \***        SUBROUTINE      :      UPDATE.CARTON.FILE                   !AGCS
3942: 6085: \***                                                                    !AGCS
3943: 6085: \***    Update the carton file (if necessary)                           !AGCS
3944: 6085: \***                                                                    !AGCS
3945: 6085: \***********************************************************************!AGCS
3946: 6085:                                                                         !AGCS
3947: 6085: UPDATE.CARTON.FILE:                                                     !AGCS
3948: 6095:                                                                         !AHCS
3949: 6095:     CARTON.FILE.ERROR = FALSE                                           !AHCS
3950: 60a3:                                                                         !AGCS
3951: 60a3:     IF CRTN.OPEN THEN BEGIN                                             !AGCS
3952: 60b2:         CLOSE CRTN.SESS.NUM%                                            !AGCS
3953: 60c6:         CRTN.OPEN = FALSE                                               !AGCS
3954: 60d4:     ENDIF                                                               !AGCS
3955: 60dc:                                                                         !AGCS
3956: 60dc:     CURRENT.REPORT.NUM% = CRTN.REPORT.NUM%                              !AGCS
3957: 60f2:                                                                         !AGCS
3958: 60f2:     ! Read Carton record                                                !AGCS
3959: 60f2:     IF END # CRTN.SESS.NUM% THEN DO.ROLLBACK                            !AGCS
3960: 610e:     OPEN CRTN.FILE.NAME$ KEYED RECL CRTN.RECL% AS CRTN.SESS.NUM% NODEL  !AGCS
3961: 613b:     CRTN.OPEN = TRUE                                                    !AGCS
3962: 6149:                                                                         !AGCS
3963: 6149:     ! Build Carton key                                                  !AGCS
3964: 6149:     CRTN.SUPPLIER$ = BDCP.SUPPLIER$                                     !AGCS
3965: 6167:     CRTN.NO$       = BDCP.CARTON$                                       !AGCS
3966: 6185:     CRTN.CHAIN%    = 0                                                  !AGCS
3967: 6195:                                                                         !AGCS
3968: 6195:     RC% = READ.CRTN                                                     !AGCS
3969: 61a5:                                                                         !AGCS
3970: 61a5:     ! If Carton record is found in Carton file                          !AGCS
3971: 61a5:     IF RC% = 0 THEN BEGIN                                               !AGCS
3972: 61b7:                                                                         !AGCS
3973: 61b7:         ! Only update if If Carton Unbooked                             !AGCS
3974: 61b7:         IF CRTN.STATUS$ = "U" THEN BEGIN                                !AGCS
3975: 61d5:                                                                         !AGCS
3976: 61d5:             ! Update status to 'Booked Normally'                        !AGCS
3977: 61d5:             CRTN.STATUS$ = "N"                                          !AGCS
3978: 61ec:                                                                         !AGCS
3979: 61ec:             ! Update CARTON file                                        !AGCS
3980: 61ec:             RC% = WRITE.CRTN                                            !AGCS
3981: 61fc:                                                                         !AGCS
3982: 61fc:             ! If update fails                                           !AGCS
3983: 61fc:             IF RC% <> 0 THEN BEGIN                                      !AGCS
3984: 620b:                 GOSUB ROLLBACK.PARCEL.RECORD                            !AHCS
3985: 621d:             ENDIF                                                       !AGCS
3986: 6225:         ENDIF                                                           !AGCS
3987: 622f:                                                                         !AGCS
3988: 622f:     ENDIF ELSE BEGIN                                                    !AGCS
3989: 6237:         GOSUB ROLLBACK.PARCEL.RECORD                                    !AHCS
3990: 6249:     ENDIF                                                               !AGCS
3991: 6251:                                                                         !AGCS
3992: 6251:     IF CRTN.OPEN THEN BEGIN                                             !AGCS
3993: 6260:         CLOSE CRTN.SESS.NUM%                                            !AGCS
3994: 6274:         CRTN.OPEN = FALSE                                               !AGCS
3995: 6282:     ENDIF                                                               !AGCS
3996: 628a:                                                                         !AGCS
3997: 628a: RETURN                                                                  !AGCS
3998: 629a:                                                                         !AGCS
3999: 629a:                                                                         !AGCS
4000: 629a: DO.ROLLBACK:                                                            !AGCS
4001: 62aa: !----------                                                             !AGCS
4002: 62aa:     GOSUB ROLLBACK.PARCEL.RECORD                                        !AGCS
4003: 62bc:                                                                         !AGCS
4004: 62bc: RETURN                                                                  !AGCS
4005: 62cc: 
4006: 62cc: 
4007: 62cc: 
4008: 62cc: 
4009: 62cc: \********************************************************************   !AICS
4010: 62cc: \***                                                                    !AICS
4011: 62cc: \***    SUBROUTINE      :      ADD.RECORD.TO.END.OF.PSUTQ.FILE          !AICS
4012: 62cc: \***                                                                    !AICS
4013: 62cc: \*** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -    !AICS
4014: 62cc:                                                                         !AICS
4015: 62cc: ADD.RECORD.TO.END.OF.PSUTQ.FILE:                                        !AICS
4016: 62dc:                                                                         !AICS
4017: 62dc:     ! Open PSUTQ and write a Type 1 Bookin Record to end of file        !AICS
4018: 62dc:     IF PSUTQ.OPEN THEN BEGIN                                            !AICS
4019: 62ee:         CLOSE PSUTQ.SESS.NUM%                                           !AICS
4020: 6302:         PSUTQ.OPEN = FALSE                                              !AICS
4021: 6314:     ENDIF                                                               !AICS
4022: 631c:                                                                         !AICS
4023: 631c:     CURRENT.REPORT.NUM% = PSUTQ.REPORT.NUM%                             !AICS
4024: 6332:                                                                         !AICS
4025: 6332:     IF END # PSUTQ.SESS.NUM% THEN OPEN.ERROR                            !AICS
4026: 634e:     OPEN PSUTQ.FILE.NAME$ AS PSUTQ.SESS.NUM% NODEL APPEND               !AICS
4027: 6376:     PSUTQ.OPEN = TRUE                                                   !AICS
4028: 6388:                                                                         !AKKK
4029: 6388: !    IF PSUTQ.TRANS.TYPE$ = "1" THEN BEGIN   ! Book In & Put Away       !AKKK
4030: 6388: !        PSUTQ.RECORD$ =           \                                    !AKKK
4031: 6388: !              PACK$("01")       + \ ! TRANSACTION TYPE                 !AKKK
4032: 6388: !              ";"               + \ ! FIELD DELIMITER                  !AKKK
4033: 6388: !              PSUTQ.CURROP$     + \ ! CURRENT OPERATION                !AKKK
4034: 6388: !              BDCP.SUPPLIER$    + \ ! SUPPLIER NUMBER (packed)         !AKKK
4035: 6388: !              BDCP.ORDER$       + \ ! ORDER NUMBER    (packed)         !AKKK
4036: 6388: !              BDCP.CARTON$      + \ ! PARCEL NUMBER   (packed)         !AKKK
4037: 6388: !              PSUTQ.CURR.LOCON$ + \ ! CURRENT LOCATION NUMBER          !AKKK
4038: 6388: !              PSUTQ.PREV.LOCON$ + \ ! PREVIOUS LOCATION NUMBER         !AKKK
4039: 6388: !              PACK$(DATE$)      + \ ! BOOK IN SCAN DATE YYMMDD         !AKKK
4040: 6388: !              PACK$(TIME$)          ! BOOK IN SCAN TIME HHMMSS         !AKKK
4041: 6388: 
4042: 6388:                                                                         
4043: 6388: !    ENDIF ELSE BEGIN  ! PSUTQ.TRANS.TYPE$ = 5  Parcel Returns          !AKKK
4044: 6388: !        PSUTQ.RECORD$ =         \                                      !AKKK
4045: 6388: !              PACK$("05")    + \ ! TRANSACTION TYPE                    !AKKK
4046: 6388: !              ";"            + \ ! FIELD DELIMITER                     !AKKK
4047: 6388: !              BDCP.SUPPLIER$ + \ ! SUPPLIER NUMBER (packed)            !AKKK
4048: 6388: !              BDCP.ORDER$    + \ ! ORDER NUMBER    (packed)            !AKKK
4049: 6388: !              BDCP.CARTON$   + \ ! PARCEL NUMBER   (packed)            !AKKK
4050: 6388: !             "000"           + \ ! RETURN LIST ID                      !AKKK
4051: 6388: !             "000"           + \ ! RETURN LIST SEQUENCE                !AKKK
4052: 6388: !                               \ ! LOCATION NUMBER                     !AKKK
4053: 6388: !             RIGHT$("000" + STR$(BDCP.LOC.CURRENT%), 3) + \            !AKKK
4054: 6388: !             PACK$(DATE$)    + \ ! BOOK IN SCAN DATE YYMMDD            !AKKK
4055: 6388: !             PACK$(TIME$)        ! BOOK IN SCAN TIME HHMMSS            !AKKK
4056: 6388: 
4057: 6388: !    ENDIF                                                              !AKKK
4058: 6388: 
4059: 6388:     IF PSUTQ.TRANS.TYPE$ = "1" THEN BEGIN   ! Book In & Put Away        !AKKK
4060: 63a9:         PSUTQ.RECORD$ =                    \                            !AKKK
4061: 6484:               "01"                       + \ ! TRANSACTION TYPE         !AKKK
4062: 6484:               COMMA$                     + \ ! FIELD DELIMITER          !AKKK
4063: 6484:               PSUTQ.CURROP$              + \ ! CURRENT OPERATION        !AKKK
4064: 6484:               COMMA$                     + \ ! FIELD DELIMITER          !AKKK
4065: 6484:               UNPACK$(BDCP.SUPPLIER$)    + \ ! SUPPLIER NUMBER          !AKKK
4066: 6484:               COMMA$                     + \ ! FIELD DELIMITER          !AKKK
4067: 6484:               UNPACK$(BDCP.ORDER$)       + \ ! ORDER NUMBER             !AKKK
4068: 6484:               COMMA$                     + \ ! FIELD DELIMITER          !AKKK
4069: 6484:               UNPACK$(BDCP.CARTON$)      + \ ! PARCEL NUMBER            !AKKK
4070: 6484:               COMMA$                     + \ ! FIELD DELIMITER          !AKKK
4071: 6484:               PSUTQ.CURR.LOCON$          + \ ! CURRENT LOCATION NUMBER  !AKKK
4072: 6484:               COMMA$                     + \ ! FIELD DELIMITER          !AKKK
4073: 6484:               PSUTQ.PREV.LOCON$          + \ ! PREVIOUS LOCATION NUMBER !AKKK
4074: 6484:               COMMA$                     + \ ! FIELD DELIMITER          !AKKK
4075: 6484:               DATE$                      + \ ! BOOK IN SCAN DATE YYMMDD !AKKK
4076: 6484:               COMMA$                     + \ ! FIELD DELIMITER          !AKKK
4077: 6484:               TIME$                          ! BOOK IN SCAN TIME HHMMSS !AKKK
4078: 6484: 
4079: 6484:                                                                         
4080: 6484:     ENDIF ELSE BEGIN  ! PSUTQ.TRANS.TYPE$ = 5  Parcel Returns           !AKKK
4081: 648c:         PSUTQ.RECORD$ =         \                                       !AKKK
4082: 6596:               "05"                       + \ ! TRANSACTION TYPE         !AKKK
4083: 6596:               COMMA$                     + \ ! FIELD DELIMITER          !AKKK
4084: 6596:               UNPACK$(BDCP.SUPPLIER$)    + \ ! SUPPLIER NUMBER          !AKKK
4085: 6596:               COMMA$                     + \ ! FIELD DELIMITER          !AKKK
4086: 6596:               UNPACK$(BDCP.ORDER$)       + \ ! ORDER NUMBER             !AKKK
4087: 6596:               COMMA$                     + \ ! FIELD DELIMITER          !AKKK
4088: 6596:               UNPACK$(BDCP.CARTON$)      + \ ! PARCEL NUMBER            !AKKK
4089: 6596:               COMMA$                     + \ ! FIELD DELIMITER          !AKKK
4090: 6596:               "000"                      + \ ! RETURN LIST ID           !AKKK
4091: 6596:               COMMA$                     + \ ! FIELD DELIMITER          !AKKK   
4092: 6596:               "000"                      + \ ! RETURN LIST SEQUENCE     !AKKK
4093: 6596:               COMMA$                     + \ ! FIELD DELIMITER          !AKKK
4094: 6596:                                            \ ! LOCATION NUMBER          !AKKK
4095: 6596:               RIGHT$("000" + STR$(BDCP.LOC.CURRENT%), 3) + \            !AKKK
4096: 6596:               COMMA$                     + \ ! FIELD DELIMITER          !AKKK
4097: 6596:               DATE$                      + \ ! BOOK IN SCAN DATE YYMMDD !AKKK
4098: 6596:               COMMA$                     + \ ! FIELD DELIMITER          !AKKK
4099: 6596:               TIME$                          ! BOOK IN SCAN TIME HHMMSS !AKKK
4100: 6596: 
4101: 6596:     ENDIF                                                               !AKKK
4102: 659e:                                                                         !AICS
4103: 659e:     RC% = WRITE.PSUTQ                                                   !AICS
4104: 65ae:                                                                         !AICS
4105: 65ae:     IF PSUTQ.OPEN THEN BEGIN                                            !AICS
4106: 65c0:         CLOSE PSUTQ.SESS.NUM%                                           !AICS
4107: 65d4:         PSUTQ.OPEN = FALSE                                              !AICS
4108: 65e6:     ENDIF                                                               !AICS
4109: 65ee:                                                                         !AICS
4110: 65ee:     IF RC% <> 0 THEN BEGIN                                              !AICS
4111: 65fd:         ! Write failed - no need to read PSUCF to see if PSD86 cut-off  !AICS
4112: 65fd:         ! in progress since we don't need to display specic errors to   !AICS
4113: 65fd:         ! the user.                                                     !AICS
4114: 65fd:         PSUTQ.FILE.ERROR = TRUE                                         !AICS
4115: 660b:     ENDIF                                                               !AICS
4116: 6613:                                                                         !AICS
4117: 6613: RETURN                                                                  !AICS
4118: 6623: 
4119: 6623: 
4120: 6623: 
4121: 6623: 
4122: 6623: \********************************************************************   !AGCS
4123: 6623: \***                                                                    !AGCS
4124: 6623: \***    SUBROUTINE      :      BOOKIN.PARCEL                            !AGCS
4125: 6623: \***                                                                    !AGCS
4126: 6623: \*** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -    !AGCS
4127: 6623:                                                                         !AGCS
4128: 6623: BOOKIN.PARCEL:                                                          !AGCS
4129: 6633:                                                                         !AGCS
4130: 6633:     ! Close BDCP file if it is opened and reopen for keyed access       !AGCS
4131: 6633:     ! (with update)                                                     !AGCS
4132: 6633:                                                                         !AGCS
4133: 6633:     IF BDCP.OPEN% THEN BEGIN                                            !AGCS
4134: 6642:         CLOSE BDCP.SESS.NUM%                                            !AGCS
4135: 6656:         BDCP.OPEN% = FALSE                                              !AGCS
4136: 6664:     ENDIF                                                               !AGCS
4137: 666c:                                                                         !AGCS
4138: 666c:     CURRENT.REPORT.NUM% = BDCP.REPORT.NUM%                              !AGCS
4139: 6682:                                                                         !AGCS
4140: 6682:     IF END #BDCP.SESS.NUM% THEN OPEN.ERROR                              !AGCS
4141: 669e:     OPEN BDCP.FILE.NAME$ KEYED RECL BDCP.RECL% AS BDCP.SESS.NUM% NODEL  !AGCS
4142: 66cb:     BDCP.OPEN% = TRUE                                                   !AGCS
4143: 66d9:                                                                         !AGCS
4144: 66d9:     GOSUB READ.RECORD.LOCK                                              !AGCS
4145: 66eb:                                                                         !AGCS
4146: 66eb:     ! Save record details in case we need to rollback the change        !AHCS
4147: 66eb:     SAVED.ARRAY$             = p.arr$(indx%)                            !AHCS
4148: 6712:     SAVED.BDCP.STATUS$       = BDCP.STATUS$                             !AHCS
4149: 672e:     SAVED.BDCP.DEL.DATETIME$ = BDCP.DEL.DATETIME$                       !AHCS
4150: 674a:     SAVED.BDCP.DEL.EXPORTED$ = BDCP.DEL.EXPORTED$                       !AHCS
4151: 6766:                                                                         !AGCS
4152: 6766:     IF NOT mismatch% THEN BEGIN                                         !AGCS
4153: 6775:         BDCP.STATUS$       = "R" ! In Store Ready for collection        !AGCS
4154: 678c:         BDCP.DEL.DATETIME$ = PACK$(DATE$ + TIME$)                       !AGCS
4155: 67c1:         BDCP.DEL.EXPORTED$ = "Y"                                        !AJCS
4156: 67d8:     ENDIF                                                               !AGCS
4157: 67e0:                                                                         !AGCS
4158: 67e0:     ! Set date parcel received in store to today. This is achieved by   !AGCS
4159: 67e0:     ! overwriting the current blank date that is held in bytes 11 - 13  !AGCS
4160: 67e0:     ! in current array index.                                           !AGCS
4161: 67e0:     P.ARR$(INDX%) = LEFT$(P.ARR$(INDX%), 10)                         + \!AGCS
4162: 6886:                     PACK$(DATE$)                                     + \!AGCS
4163: 6886:                     RIGHT$(P.ARR$(INDX%), LEN(P.ARR$(INDX%)) - 13)      !AGCS
4164: 6886:                                                                         !AGCS
4165: 6886:     GOSUB UPDATE.ARRAY                                                  !AGCS
4166: 6898:                                                                         !AGCS
4167: 6898:     GOSUB WRITE.RECORD.UNLOCK                                           !AGCS
4168: 68aa:                                                                         !AGCS
4169: 68aa:     ! Closing BDCP file                                                 !AGCS
4170: 68aa:                                                                         !AGCS
4171: 68aa:     IF BDCP.OPEN% THEN BEGIN                                            !AGCS
4172: 68b9:         CLOSE BDCP.SESS.NUM%                                            !AGCS
4173: 68cd:         BDCP.OPEN% = FALSE                                              !AGCS
4174: 68db:     ENDIF                                                               !AGCS
4175: 68e3:                                                                         !AGCS
4176: 68e3:     GOSUB UPDATE.CARTON.FILE                                            !AGCS
4177: 68f5: 
4178: 68f5:     IF NOT CARTON.FILE.ERROR THEN BEGIN                                 !AICS
4179: 6904:         ! Update to BDCP and CARTON file successful ie. No rollback.    !AICS
4180: 6904:         ! Add Type 1 record to end of Parcel Status Update Transaction  !AICS
4181: 6904:         ! Queue file.                                                   !AICS
4182: 6904:         PSUTQ.TRANS.TYPE$ = "1"                                         !AICS
4183: 691b:         PSUTQ.CURROP$     = "B"                                         !AICS
4184: 6930:         PSUTQ.CURR.LOCON$ = "000"                                       !AICS
4185: 6945:         PSUTQ.PREV.LOCON$ = "000"                                       !AICS
4186: 695a:         GOSUB ADD.RECORD.TO.END.OF.PSUTQ.FILE                           !AICS
4187: 696c:     ENDIF                                                               !AICS
4188: 6974:                                                                         !AGCS
4189: 6974: RETURN                                                                  !AGCS
4190: 6984: 
4191: 6984: 
4192: 6984: 
4193: 6984: \********************************************************************
4194: 6984: \***
4195: 6984: \***    SUBROUTINE      :      COLLECT.PARCEL
4196: 6984: \***
4197: 6984: \*** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
4198: 6984: 
4199: 6984: COLLECT.PARCEL:
4200: 6994: 
4201: 6994:     ! Close BDCP file if it is opened and reopen for keyed access       !ECK
4202: 6994:     ! (with update)                                                     !ECK
4203: 6994: 
4204: 6994:     IF BDCP.OPEN% THEN BEGIN                                            !ECK
4205: 69a3:         CLOSE BDCP.SESS.NUM%                                            !ECK
4206: 69b7:         BDCP.OPEN% = 0                                                  !ECK
4207: 69c4:     ENDIF                                                               !ECK
4208: 69cc: 
4209: 69cc:     CURRENT.REPORT.NUM% = BDCP.REPORT.NUM%                              !ECK
4210: 69e2: 
4211: 69e2:     IF END #BDCP.SESS.NUM% THEN OPEN.ERROR                              !ECK
4212: 69fe:     OPEN BDCP.FILE.NAME$ KEYED RECL BDCP.RECL% AS BDCP.SESS.NUM% NODEL  !ECK
4213: 6a2b:     BDCP.OPEN% = -1                                                     !ECK
4214: 6a38: 
4215: 6a38:     GOSUB READ.RECORD.LOCK
4216: 6a4a: 
4217: 6a4a:     IF NOT mismatch% THEN BEGIN
4218: 6a5c:         BDCP.STATUS$       = "C"
4219: 6a73:         BDCP.COL.DATETIME$ = PACK$(DATE$ + TIME$)
4220: 6aa8:         BDCP.COL.RC%       = 1
4221: 6ab8:         BDCP.COL.EXPORTED$ = "N"
4222: 6acf: 
4223: 6acf:         !Decrease the count by one for old locaiton                     !LLJ
4224: 6acf:         BDCLOCON.RECORD.NUM% = BDCP.LOC.CURRENT%                        !LLJ
4225: 6ae5:         PARCEL.COUNT%        = -1        !Decrement by 1                !LLJ
4226: 6af3:         GOSUB UPDATE.PARCEL.COUNT                                       !LLJ
4227: 6b05: 
4228: 6b05:     ENDIF
4229: 6b0d: 
4230: 6b0d:     GOSUB UPDATE.ARRAY
4231: 6b1f: 
4232: 6b1f:     GOSUB WRITE.RECORD.UNLOCK
4233: 6b31: 
4234: 6b31:     ! Closing BDCP file                                                 !ECK
4235: 6b31: 
4236: 6b31:     IF BDCP.OPEN% THEN BEGIN                                            !ECK
4237: 6b40:         CLOSE BDCP.SESS.NUM%                                            !ECK
4238: 6b54:         BDCP.OPEN% = 0                                                  !ECK
4239: 6b61:     ENDIF                                                               !ECK
4240: 6b69: 
4241: 6b69: RETURN
4242: 6b79: 
4243: 6b79: \********************************************************************
4244: 6b79: \***
4245: 6b79: \***    SUBROUTINE      :      RETURN.PARCEL
4246: 6b79: \***
4247: 6b79: \*** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
4248: 6b79: 
4249: 6b79: RETURN.PARCEL:
4250: 6b89: 
4251: 6b89: !AICS    ! Close BDCP file if it is opened and reopen for keyed access       !ECK
4252: 6b89: !AICS    ! (with update)                                                     !ECK
4253: 6b89: !AICS
4254: 6b89: !AICS    IF BDCP.OPEN% THEN BEGIN                                            !ECK
4255: 6b89: !AICS        CLOSE BDCP.SESS.NUM%                                            !ECK
4256: 6b89: !AICS        BDCP.OPEN% = 0                                                  !ECK
4257: 6b89: !AICS    ENDIF                                                               !ECK
4258: 6b89: !AICS
4259: 6b89: !AICS    CURRENT.REPORT.NUM% = BDCP.REPORT.NUM%                              !ECK
4260: 6b89: !AICS
4261: 6b89: !AICS    IF END #BDCP.SESS.NUM% THEN OPEN.ERROR                              !ECK
4262: 6b89: !AICS    OPEN BDCP.FILE.NAME$ KEYED RECL BDCP.RECL% AS BDCP.SESS.NUM% NODEL  !ECK
4263: 6b89: !AICS    BDCP.OPEN% = 1                                                      !ECK
4264: 6b89: !AICS
4265: 6b89: !AICS    GOSUB READ.RECORD.LOCK
4266: 6b89: !AICS
4267: 6b89: !AICS    IF NOT mismatch% THEN BEGIN
4268: 6b89: !AICS        BDCP.STATUS$       = "U"
4269: 6b89: !AICS        BDCP.RET.DATETIME$ = PACK$(DATE$ + TIME$)
4270: 6b89: !AICS        BDCP.RET.EXPORTED$ = "N"
4271: 6b89: !AICS
4272: 6b89: !AICS        !Decrease the count by one for old locaiton                     !LLJ
4273: 6b89: !AICS        BDCLOCON.RECORD.NUM% = BDCP.LOC.CURRENT%                        !LLJ
4274: 6b89: !AICS        PARCEL.COUNT%        = -1        !Decrement by 1                !LLJ
4275: 6b89: !AICS        GOSUB UPDATE.PARCEL.COUNT                                       !LLJ
4276: 6b89: !AICS
4277: 6b89: !AICS    ENDIF
4278: 6b89: !AICS
4279: 6b89: !AICS    GOSUB UPDATE.ARRAY
4280: 6b89: !AICS
4281: 6b89: !AICS    GOSUB WRITE.RECORD.UNLOCK
4282: 6b89: !AICS
4283: 6b89: !AICS    ! Closing BDCP file                                                 !ECK
4284: 6b89: !AICS
4285: 6b89: !AICS    IF BDCP.OPEN% THEN BEGIN                                            !ECK
4286: 6b89: !AICS        CLOSE BDCP.SESS.NUM%                                            !ECK
4287: 6b89: !AICS        BDCP.OPEN% = 0                                                  !ECK
4288: 6b89: !AICS    ENDIF                                                               !ECK
4289: 6b89: 
4290: 6b89:    !********************************************************************!AJCS
4291: 6b89:    ! Array layout                                                       !AJCS
4292: 6b89:    ! 12222233334445555556667777                                         !AJCS
4293: 6b89:    ! 1 = Status sort Order (ASCII)   1, 1                               !AJCS
4294: 6b89:    ! 2 = Order Number(PD)            2, 5                               !AJCS
4295: 6b89:    ! 3 = Parcel number (PD)          7, 4                               !AJCS
4296: 6b89:    ! 4 = Date received (PD)         11, 3                               !AJCS
4297: 6b89:    ! 5 = Date for Status Msg (PD)   14, 3                               !AJCS
4298: 6b89:    !     Time for Status Msg (PD)   17, 3                               !AJCS
4299: 6b89:    ! 6 = Supplier Number (PD)       20, 3                               !AJCS
4300: 6b89:    ! 7 = 2x INT2 - Current Location + Location Status                   !AJCS
4301: 6b89:    !********************************************************************!AJCS
4302: 6b89:     BDCP.RET.DATETIME$ = PACK$(DATE$ + TIME$)                           !AJCS
4303: 6bbe:     BDCP.SUPPLIER$     = MID$(p.arr$(indx%),20,3)                       !AJCS
4304: 6bf0:     BDCP.ORDER$        = MID$(p.arr$(indx%), 2,5)                       !AJCS
4305: 6c22:     BDCP.CARTON$       = MID$(p.arr$(indx%), 7,4)                       !AJCS
4306: 6c54: 
4307: 6c54:     PSUTQ.TRANS.TYPE$ = "5"                                             !AICS
4308: 6c6b:     GOSUB ADD.RECORD.TO.END.OF.PSUTQ.FILE                               !AICS
4309: 6c7d: 
4310: 6c7d:     BDCP.STATUS$ = "U"                                                  !AJCS
4311: 6c94:     GOSUB UPDATE.ARRAY                                                  !AJCS
4312: 6ca6: RETURN
4313: 6cb6: 
4314: 6cb6: \********************************************************************
4315: 6cb6: \***
4316: 6cb6: \***    SUBROUTINE      :      LOST.PARCEL
4317: 6cb6: \***
4318: 6cb6: \*** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
4319: 6cb6: 
4320: 6cb6: LOST.PARCEL:
4321: 6cc6: 
4322: 6cc6:     ! Close BDCP file if it is opened and reopen for keyed access       !ECK
4323: 6cc6:     ! (with update)                                                     !ECK
4324: 6cc6: 
4325: 6cc6:     IF BDCP.OPEN% THEN BEGIN                                            !ECK
4326: 6cd5:         CLOSE BDCP.SESS.NUM%                                            !ECK
4327: 6ce9:         BDCP.OPEN% = 0                                                  !ECK
4328: 6cf6:     ENDIF                                                               !ECK
4329: 6cfe: 
4330: 6cfe:     CURRENT.REPORT.NUM% = BDCP.REPORT.NUM%                              !ECK
4331: 6d14: 
4332: 6d14:     IF END #BDCP.SESS.NUM% THEN OPEN.ERROR                              !ECK
4333: 6d30:     OPEN BDCP.FILE.NAME$ KEYED RECL BDCP.RECL% AS BDCP.SESS.NUM% NODEL  !ECK
4334: 6d5d:     BDCP.OPEN% = -1                                                     !ECK
4335: 6d6a: 
4336: 6d6a:     GOSUB READ.RECORD.LOCK
4337: 6d7c: 
4338: 6d7c:     IF NOT mismatch% THEN BEGIN
4339: 6d8e:         BDCP.STATUS$       = "L"
4340: 6da5:         BDCP.LST.DATETIME$ = PACK$(DATE$ + TIME$)
4341: 6dda:         BDCP.LST.EXPORTED$ = "N"
4342: 6df1: 
4343: 6df1:         !Decrease the count by one for old locaiton                     !LLJ
4344: 6df1:         BDCLOCON.RECORD.NUM% = BDCP.LOC.CURRENT%                        !LLJ
4345: 6e07:         PARCEL.COUNT%        = -1        !Decrement by 1                !LLJ
4346: 6e15:         GOSUB UPDATE.PARCEL.COUNT                                       !LLJ
4347: 6e27: 
4348: 6e27:     ENDIF
4349: 6e2f: 
4350: 6e2f:     GOSUB UPDATE.ARRAY
4351: 6e41: 
4352: 6e41:     GOSUB WRITE.RECORD.UNLOCK
4353: 6e53: 
4354: 6e53:     ! Closing BDCP file                                                 !ECK
4355: 6e53: 
4356: 6e53:     IF BDCP.OPEN% THEN BEGIN                                            !ECK
4357: 6e62:         CLOSE BDCP.SESS.NUM%                                            !ECK
4358: 6e76:         BDCP.OPEN% = 0                                                  !ECK
4359: 6e83:     ENDIF                                                               !ECK
4360: 6e8b: 
4361: 6e8b: RETURN
4362: 6e9b: 
4363: 6e9b: \********************************************************************
4364: 6e9b: \***
4365: 6e9b: \***    SUBROUTINE      :      FOUND.PARCEL
4366: 6e9b: \***
4367: 6e9b: \*** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
4368: 6e9b: 
4369: 6e9b: FOUND.PARCEL:
4370: 6eab: 
4371: 6eab:     ! Close BDCP file if it is opened and reopen for keyed access       !ECK
4372: 6eab:     ! (with update)                                                     !ECK
4373: 6eab: 
4374: 6eab:     IF BDCP.OPEN% THEN BEGIN                                            !ECK
4375: 6eba:         CLOSE BDCP.SESS.NUM%                                            !ECK
4376: 6ece:         BDCP.OPEN% = 0                                                  !ECK
4377: 6edb:     ENDIF                                                               !ECK
4378: 6ee3: 
4379: 6ee3:     CURRENT.REPORT.NUM% = BDCP.REPORT.NUM%                              !ECK
4380: 6ef9: 
4381: 6ef9:     IF END #BDCP.SESS.NUM% THEN OPEN.ERROR                              !ECK
4382: 6f15:     OPEN BDCP.FILE.NAME$ KEYED RECL BDCP.RECL% AS BDCP.SESS.NUM% NODEL  !ECK
4383: 6f42:     BDCP.OPEN% = -1                                                     !ECK
4384: 6f4f: 
4385: 6f4f:     GOSUB READ.RECORD.LOCK
4386: 6f61: 
4387: 6f61:     IF NOT mismatch% THEN BEGIN
4388: 6f73:         BDCP.STATUS$       = "R"
4389: 6f8a:         BDCP.FND.DATETIME$ = PACK$(DATE$ + TIME$)
4390: 6fbf:         BDCP.FND.EXPORTED$ = "N"
4391: 6fd6: 
4392: 6fd6:         !Increase the count by one for old locaiton                     !LLJ
4393: 6fd6:         BDCLOCON.RECORD.NUM% = BDCP.LOC.CURRENT%                        !LLJ
4394: 6fec:         PARCEL.COUNT%        = 1         !Increment by 1                !LLJ
4395: 6ffa:         GOSUB UPDATE.PARCEL.COUNT                                       !LLJ
4396: 700c:     ENDIF
4397: 7014: 
4398: 7014:     GOSUB UPDATE.ARRAY
4399: 7026: 
4400: 7026:     GOSUB WRITE.RECORD.UNLOCK
4401: 7038: 
4402: 7038:     ! Closing BDCP file                                                 !ECK
4403: 7038: 
4404: 7038:     IF BDCP.OPEN% THEN BEGIN                                            !ECK
4405: 7047:         CLOSE BDCP.SESS.NUM%                                            !ECK
4406: 705b:         BDCP.OPEN% = 0                                                  !ECK
4407: 7068:     ENDIF                                                               !ECK
4408: 7070: 
4409: 7070: RETURN
4410: 7080: 
4411: 7080: \********************************************************************
4412: 7080: \***
4413: 7080: \***    SUBROUTINE      :      UPDATE.ARRAY
4414: 7080: \***
4415: 7080: \*** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
4416: 7080: 
4417: 7080: UPDATE.ARRAY:
4418: 7090: 
4419: 7090:     wk$ = p.arr$(indx%)
4420: 70b7: 
4421: 70b7:     IF      BDCP.STATUS$ = "O" THEN x.dt$ = BDCP.EXPECT.DATE$        \
4422: 70ec:     ELSE IF BDCP.STATUS$ = "R" THEN x.dt$ = BDCP.FND.DATETIME$       \
4423: 7121:     ELSE IF BDCP.STATUS$ = "C" THEN x.dt$ = BDCP.COL.DATETIME$       \
4424: 7155:     ELSE IF BDCP.STATUS$ = "L" THEN x.dt$ = BDCP.LST.DATETIME$       \
4425: 7189:     ELSE IF BDCP.STATUS$ = "U" THEN x.dt$ = BDCP.RET.DATETIME$       !
4426: 71bb: 
4427: 71bb:     IF LEN(x.dt$) = 3 THEN                                           \
4428: 71d6:         x.dt$ = x.dt$ + PACK$("000000")                               !
4429: 71fb: 
4430: 71fb:     ! FOR INVESTIGATION                                                 !HDC
4431: 71fb:     ! why is this here - should it be PD or ASCII surely?               !HDC
4432: 71fb:     ! check logic before Release 1 Sprint 1 delivery                    !HDC
4433: 71fb: 
4434: 71fb:     ! Set required sort order for status                                !FMM
4435: 71fb: 
4436: 71fb:     IF BDCP.STATUS$ = "O" THEN BEGIN                                    !FMM
4437: 721c: 
4438: 721c:         IF DATE$ > UNPACK$(LEFT$(X.DT$,3)) THEN BEGIN                   !FMM
4439: 7254:             ! Update STATUS.SORT.ORDER$ as "1" for the parcel status    !FMM
4440: 7254:             ! "LATE".                                                   !FMM
4441: 7254:             STATUS.SORT.ORDER$ = "1"                                    !FMM
4442: 726b:         ENDIF ELSE BEGIN                                                !FMM
4443: 7273:             ! Update STATUS.SORT.ORDER$ as "2" for the parcel status    !FMM
4444: 7273:             ! "EXPECTED".                                               !FMM
4445: 7273:             STATUS.SORT.ORDER$ = "2"                                    !FMM
4446: 7288:         ENDIF                                                           !FMM
4447: 7293: 
4448: 7293:     ENDIF ELSE IF BDCP.STATUS$ = "R" THEN BEGIN                         !FMM
4449: 72b4:         ! set parcel as in arrived in store so allow Location           !IDC
4450: 72b4:         LOCATION.STATUS.NEW% = 0                                        !IDC
4451: 72c2: 
4452: 72c2:         ! If status date [X.DT$] is 0's then update global variable     !FMM
4453: 72c2:         ! F02.DATE$ with delivery date else update with found date.     !FMM
4454: 72c2:         IF X.DT$ = STRING$(6,CHR$(0)) THEN BEGIN                        !FMM
4455: 72ea:             ! Assigning delivery date to global variable                !FMM
4456: 72ea:             F02.DATE$ = UNPACK$(MID$(WK$,11,3))    !BUG FIX was 10,3    !AGCS
4457: 7315:         ENDIF ELSE BEGIN                                                !FMM
4458: 731d:             ! Assigning found date to global variable                   !FMM
4459: 731d:             F02.DATE$ = UNPACK$(MID$(X.DT$,1,3))                        !FMM
4460: 7346:         ENDIF                                                           !FMM
4461: 734e: 
4462: 734e:         ! For status 'R': Check difference between today's date and     !FMM
4463: 734e:         ! delivery date/found date. For the order status "UNCOLLECTED"  !FMM
4464: 734e:         ! the difference is greater than Uncollected days value. For    !FMM
4465: 734e:         ! status "IN STORE" the difference is lesser than Uncollected   !FMM
4466: 734e:         ! days value.                                                   !FMM
4467: 734e: 
4468: 734e:         ! Calculating return by date. DAYS.UNCOLLECTED% is retrieving   !FMM
4469: 734e:         ! value from SOFTS file. If days uncollected value is not found !FMM
4470: 734e:         ! the program will exit logging the event. Therefore, return    !FMM
4471: 734e:         ! code is not checked here for UPDATE.DATE function             !FMM
4472: 734e:         CALL UPDATE.DATE(DAYS.UNCOLLECTED%)                             !FMM
4473: 7364:         RETURN.BY.DATE$ = F02.DATE$                                     !FMM
4474: 7380: 
4475: 7380:         IF DATE.LT(RETURN.BY.DATE$,CURRENT.DATE$) THEN BEGIN            !FMM
4476: 73a4:             ! Update STATUS.SORT.ORDER$ as "3" for the parcel status    !FMM
4477: 73a4:             ! "UNCOLLECTED RETURN TO W/H?".                             !FMM
4478: 73a4:             STATUS.SORT.ORDER$ = "3"                                    !FMM
4479: 73bb:         ENDIF ELSE BEGIN                                                !FMM
4480: 73c3:             IF X.DT$ = STRING$(6,CHR$(0)) THEN BEGIN                    !FMM
4481: 73eb:                 ! Update STATUS.SORT.ORDER$ as "4" for the parcel status!FMM
4482: 73eb:                 ! "IN STORE - AWAITING COLLECTION".                     !FMM
4483: 73eb:                 STATUS.SORT.ORDER$ = "4"                                !FMM
4484: 7402:             ENDIF ELSE BEGIN                                            !FMM
4485: 740a:                 ! Update STATUS.SORT.ORDER$ as "5" for the parcel status!FMM
4486: 740a:                 ! "IN STORE - FOUND".                                   !FMM
4487: 740a:                 STATUS.SORT.ORDER$ = "5"                                !FMM
4488: 741f:             ENDIF                                                       !FMM
4489: 7427:         ENDIF                                                           !FMM
4490: 7432: 
4491: 7432:     ENDIF ELSE IF BDCP.STATUS$ = "C" THEN BEGIN                         !FMM
4492: 7450:         ! Update STATUS.SORT.ORDER$ as "6" for the parcel status        !FMM
4493: 7450:         ! "COLLECTED".                                                  !FMM
4494: 7450:         STATUS.SORT.ORDER$ = "6"                                        !FMM
4495: 7467:     ENDIF ELSE IF BDCP.STATUS$ = "U" THEN BEGIN                         !FMM
4496: 7485:         ! Update STATUS.SORT.ORDER$ as "7" for the parcel status        !FMM
4497: 7485:         ! "RETURNED".                                                   !FMM
4498: 7485:         STATUS.SORT.ORDER$ = "7"                                        !FMM
4499: 749c: 
4500: 749c:     ENDIF ELSE IF BDCP.STATUS$ = "L" THEN BEGIN                         !FMM
4501: 74ba:         ! Update STATUS.SORT.ORDER$ as "8" for the parcel status        !FMM
4502: 74ba:         ! "RETURNED".                                                   !FMM
4503: 74ba:         STATUS.SORT.ORDER$ = "8"                                        !FMM
4504: 74cf:     ENDIF                                                               !FMM
4505: 74d7: 
4506: 74d7:     ! add location information to the end of the main screen array      !HDC
4507: 74d7:     P.ARR$(INDX%) = STATUS.SORT.ORDER$                               \  !FMM
4508: 7551:                   + MID$(wk$, 2, 12)                                 \  !FMM
4509: 7551:                   + x.dt$                                            \  !FMM
4510: 7551:                   + MID$(WK$, 20, 3)                                 \  !LLJ
4511: 7551:                   + MID$(WK$, 23, 4)    ! add location data back        !LLJ
4512: 7551: 
4513: 7551:     ! add location and extract any update                               !HDC
4514: 7551:     CALL PUTN2(P.ARR$(INDX%),22,LOCATION.NEW%)                          !IDC
4515: 757d: 
4516: 757d:     BDCP.LOC.CURRENT% = LOCATION.NEW%                                   !HDC
4517: 758f:     ! Reset location                                                    !LLJ
4518: 758f:     LOCATION.NEW% = 0                                                   !LLJ
4519: 759d:     ! status holds indicator if Parcel allows Location setting          !IDC
4520: 759d:     CALL PUTN2(P.ARR$(INDX%),24,LOCATION.STATUS.NEW%)                   !IDC
4521: 75c9: 
4522: 75c9:     wk$   = ""
4523: 75de:     x.dt$ = ""
4524: 75f3:     STATUS.SORT.ORDER$ = ""                                             !FMM
4525: 7608: 
4526: 7608: RETURN
4527: 7618: 
4528: 7618: \********************************************************************
4529: 7618: \***
4530: 7618: \***    SUBROUTINE      :      READ.RECORD.LOCKED
4531: 7618: \***
4532: 7618: \*** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
4533: 7618: 
4534: 7618: READ.RECORD.LOCK:
4535: 7628: 
4536: 7628:    mismatch% = 0
4537: 7635: 
4538: 7635:    BDCP.SUPPLIER$ = MID$(p.arr$(indx%),20,3)
4539: 7667:    BDCP.CARTON$   = MID$(p.arr$(indx%), 7,4)
4540: 7699: 
4541: 7699:    IF READ.BDCP.LOCK <> 0 THEN GOTO READ.ERROR
4542: 76ae: 
4543: 76ae:    ! Adding new sort orders and storing corresponding statuses.         !FMM
4544: 76ae:    wk$ = TRANSLATE$(LEFT$(p.arr$(indx%),1), "12345678", "OORRRCUL")     !FMM
4545: 76f6:    IF BDCP.STATUS$ <> wk$ THEN mismatch% = -1
4546: 771d: 
4547: 771d: RETURN
4548: 772d: 
4549: 772d: \********************************************************************
4550: 772d: \***
4551: 772d: \***    SUBROUTINE      :      WRITE.RECORD.UNLOCKED
4552: 772d: \***
4553: 772d: \*** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
4554: 772d: 
4555: 772d: WRITE.RECORD.UNLOCK:
4556: 773d: 
4557: 773d:    IF WRITE.BDCP.UNLOCK <> 0 THEN GOTO WRITE.ERROR
4558: 7752: 
4559: 7752: RETURN
4560: 7762: 
4561: 7762: \********************************************************************
4562: 7762: \***
4563: 7762: \***    SUBROUTINE      :      INITIALISATION
4564: 7762: \***
4565: 7762: \*** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
4566: 7762: 
4567: 7762: INITIALISATION:
4568: 7772: 
4569: 7772:    ! Setting Boolean flag value                                         !DDM
4570: 7772:    FALSE = 0                                                            !DDM
4571: 777f:    TRUE  = -1                                                           !DDM
4572: 778c: 
4573: 778c:    ! Initialising String variables                                      !DDM
4574: 778c:    ADX.MESSAGE$       = ""                                              !DDM
4575: 77a1:    ADX.NAME$          = ""                                              !DDM
4576: 77b6:    ADX.PARM$          = ""                                              !DDM
4577: 77cb:    BLANK.MSG$         = "'" + STRING$(78, " ") ! Used to clear screen   !MLJ
4578: 77ee:                                                ! message                !MLJ
4579: 77ee:    COMMA$             = ","                                             !AKKK
4580: 7803:    CURRENT.DATE$      = DATE$                                           !DDM
4581: 7819:    LIMIT.STR$         = "LIMIT="                                        !DDM
4582: 782e:    RETURN.BY.DATE$    = ""                                              !DDM
4583: 7843:    SCREEN.TITLE$      = ""                                              !GCK
4584: 7858:    SCREEN2.TITLE$     = ""                                              !HDC
4585: 786d:    SOFTS.REC.LABEL$   = "EIRE"                                          !GCK
4586: 7882:    STATUS.SORT.ORDER$ = ""                                              !FMM
4587: 7897:    WORK.SOFTS.RECORD$ = ""                                              !DDM
4588: 78ac: 
4589: 78ac:    ! location variables for function key descriptions                   !IDC
4590: 78ac:     ACTIVATE.FN.TEXT$    = "ACTIV"                                      !IDC
4591: 78c1:     DEACTIVATE.FN.TEXT$  = "INACT"                                      !IDC
4592: 78d6:     LOCATION.FN.TEXT$    = "LOCN"                                       !IDC
4593: 78eb: 
4594: 78eb:    ! Initialising Integer variables                                     !DDM
4595: 78eb:    ACTIVE.TO.BE.SAVED    = FALSE                                        !OLJ
4596: 78f9:    CHANGE.ACCEPTED       = TRUE         ! Field change accepted flag    !ZCK
4597: 7907:    DAYS.UNCOLLECTED%     = 0                                            !DDM
4598: 7915:    ERROR.ON.LOCATION     = FALSE                                        !TAH
4599: 7923:    INACTIVE.CHECK%       = 0                                            !SAH
4600: 7931:    INITIAL.FIELD.INDEX%  = 5            ! Default location field index  !TAH
4601: 793e:    LIMIT.LENGTH%         = 2                                            !DDM
4602: 794c:    MATCH.POS%            = 0                                            !DDM
4603: 795a:    NOT.DEFAULT.LOCATION  = TRUE                                         !TAH
4604: 7968:    PRINT.KEY             = FALSE                                        !FMM
4605: 7976:    CRTN.OPEN             = FALSE                                        !AGCS
4606: 7984:    SOFTS.OPEN            = FALSE                                        !DDM
4607: 7992: 
4608: 7992:    bdcp.open% = 0
4609: 799f:    lpp1%      = 14
4610: 79ad: 
4611: 79ad:    ! page length by number, of fields                                   !HDC
4612: 79ad:    ! 15 x 4 per column, 2 columns, equals 120                           !HDC
4613: 79ad:    ! Lines Per Page set as total fields from start field number         !HDC
4614: 79ad:    LOC.FIELDS.PER.LINE% = 3             ! Max field per record          !RLJ
4615: 79bb:    LOC.FIELDS.START%    = 3             ! First user field              !RLJ
4616: 79c9:    LOC.RECORDS.ON.PAGE% = 45            ! Total records in a page       !RLJ
4617: 79d7:    LPP2%                = 137           ! Max user fields               !RLJ
4618: 79e5: 
4619: 79e5:    SB.ACTION$ = "O"
4620: 79fc: 
4621: 79fc:    ! Setup file constants                                               !DDM
4622: 79fc:    CALL BDCP.SET
4623: 7a17:    CALL CRTN.SET                                                        !AGCS
4624: 7a24:    CALL PSUTQ.SET                                                       !AICS
4625: 7a3f:    CALL SOFTS.SET                                                       !DDM
4626: 7a5a:    ! Setup for locations and Orders
4627: 7a5a:    CALL BDCLOCON.SET                                                    !HDC
4628: 7a75:    CALL BDCO.SET                                                        !HDC
4629: 7a90: 
4630: 7a90:    SB.INTEGER%  = BDCP.REPORT.NUM%
4631: 7aa6:    SB.STRING$   = BDCP.FILE.NAME$
4632: 7ac4:    GOSUB SB.FILE.UTILS
4633: 7ad6:    BDCP.SESS.NUM% = SB.FILE.SESS.NUM%
4634: 7aec: 
4635: 7aec:    SB.INTEGER%  = CRTN.REPORT.NUM%                                      !AGCS
4636: 7b02:    SB.STRING$   = CRTN.FILE.NAME$                                       !AGCS
4637: 7b20:    GOSUB SB.FILE.UTILS                                                  !AGCS
4638: 7b32:    CRTN.SESS.NUM% = SB.FILE.SESS.NUM%                                   !AGCS
4639: 7b48: 
4640: 7b48:    SB.INTEGER%  = PSUTQ.REPORT.NUM%                                     !AICS
4641: 7b5e:    SB.STRING$   = PSUTQ.FILE.NAME$                                      !AICS
4642: 7b7c:    GOSUB SB.FILE.UTILS                                                  !AICS
4643: 7b8e:    PSUTQ.SESS.NUM% = SB.FILE.SESS.NUM%                                  !AICS
4644: 7ba4: 
4645: 7ba4:    ! Allocate session number for file SOFTS                             !DDM
4646: 7ba4:    SB.INTEGER%  = SOFTS.REPORT.NUM%                                     !DDM
4647: 7bba:    SB.STRING$   = SOFTS.FILE.NAME$                                      !DDM
4648: 7bd8:    GOSUB SB.FILE.UTILS                                                  !DDM
4649: 7bea:    SOFTS.SESS.NUM% = SB.FILE.SESS.NUM%                                  !DDM
4650: 7c00: 
4651: 7c00:    ! Opening SOFTS file                                                 !DDM
4652: 7c00:    CURRENT.REPORT.NUM% = SOFTS.REPORT.NUM%                              !DDM
4653: 7c16:    IF END # SOFTS.SESS.NUM% THEN OPEN.ERROR                             !DDM
4654: 7c32:    OPEN SOFTS.FILE.NAME$ DIRECT RECL SOFTS.RECL% AS SOFTS.SESS.NUM%     !DDM
4655: 7c5e:    SOFTS.OPEN = TRUE                                                    !DDM
4656: 7c6c: 
4657: 7c6c:    ! Allocate session number for file BDCO                              !HDC
4658: 7c6c:    SB.INTEGER%  = BDCO.REPORT.NUM%                                      !HDC
4659: 7c82:    SB.STRING$   = BDCO.FILE.NAME$                                       !HDC
4660: 7ca0:    GOSUB SB.FILE.UTILS                                                  !HDC
4661: 7cb2:    BDCO.SESS.NUM% = SB.FILE.SESS.NUM%                                   !HDC
4662: 7cc8: 
4663: 7cc8:    ! Allocate session number for file BDCLOCON                          !HDC
4664: 7cc8:    SB.INTEGER%  = BDCLOCON.REPORT.NUM%                                  !HDC
4665: 7cde:    SB.STRING$   = BDCLOCON.FILE.NAME$                                   !HDC
4666: 7cfc:    GOSUB SB.FILE.UTILS                                                  !HDC
4667: 7d0e:    BDCLOCON.SESS.NUM% = SB.FILE.SESS.NUM%                               !HDC
4668: 7d24: 
4669: 7d24:    ! Setting BDCLOCON related variables                                 !QCK
4670: 7d24:    BDCLOCON.TOTAL.RECORDS% = SIZE(BDCLOCON.FILE.NAME$)                  !HDC
4671: 7d4b:    BDCLOCON.TOTAL.RECORDS% = BDCLOCON.TOTAL.RECORDS% / BDCLOCON.RECL%   !HDC
4672: 7d6e:    ! allow for number of fields per record, plus 1 as field position    !HDC
4673: 7d6e:    ! starts at 2 plus one more for each record to hold the status       !HDC
4674: 7d6e:    LOC.ARRAY.LIMIT% = (BDCLOCON.TOTAL.RECORDS%*LOC.FIELDS.PER.LINE%) + \!HDC
4675: 7da2:                       1 + BDCLOCON.TOTAL.RECORDS%                       !HDC
4676: 7da2:    DIM LOCATION.ARRAY$(LOC.ARRAY.LIMIT%)                                !HDC
4677: 7dcd: 
4678: 7dcd:    ! the parcel order limit is based upon existing file constraints     !HDC
4679: 7dcd:    ! referenced in the existing program                                 !HDC
4680: 7dcd:    DIM ORDER.PARCELS%(3000,1)                                           !HDC
4681: 7df9: 
4682: 7df9:    ! To check whether the store is UK or ROI                            !GCK
4683: 7df9:    GOSUB CHECK.STORE                                                    !GCK
4684: 7e0b: 
4685: 7e0b:    ! To parse the uncollected days value from SOFTS 60th record         !DDM
4686: 7e0b:    GOSUB PARSE.UNCOLLECTED.DAYS                                         !DDM
4687: 7e1d: 
4688: 7e1d: RETURN
4689: 7e2d: 
4690: 7e2d: \***********************************************************************!GCK
4691: 7e2d: \*                                                                      !GCK
4692: 7e2d: \* CHECK.STORE:                                                         !GCK
4693: 7e2d: \* Reads and checks whether the store is configured as ROI OR UK from   !GCK
4694: 7e2d: \* SOFTS 19th record.                                                   !GCK
4695: 7e2d: \*                                                                      !GCK
4696: 7e2d: \***********************************************************************!GCK
4697: 7e2d: 
4698: 7e2d: CHECK.STORE:                                                            !GCK
4699: 7e3d: 
4700: 7e3d:     ! Read SOFTS 19th record                                            !GCK
4701: 7e3d:     SOFTS.REC.NUM% = 19                                                 !GCK
4702: 7e54:     IF READ.SOFTS THEN GOSUB READ.ERROR                                 !GCK
4703: 7e6f: 
4704: 7e6f:     ! Update the SCREEN.TITLE$ as "ORDER & COLLECT PARCEL MANAGEMENT    !SAH
4705: 7e6f:     ! SCREEN" or "ORDER & COLLECT LOCATIONS MANAGEMENT SCREEN"          !SAH
4706: 7e6f:     ! irrespective of it's store location (UK or ROI store).            !SAH
4707: 7e6f: 
4708: 7e6f:     TITLE.START$ = "ORDER & COLLECT "                                   !SAH
4709: 7e84:     TITLE.END1$ = "PARCEL MANAGEMENT SCREEN"                            !JDC
4710: 7e99:     SCREEN.TITLE$  = TITLE.START$ + TITLE.END1$                         !JDC
4711: 7ebd: 
4712: 7ebd:     IF MANAGE.LOCATION THEN BEGIN                                       !JDC
4713: 7ecc:         TITLE.END2$ = "LOCATIONS MANAGEMENT SCREEN"                     !JDC
4714: 7ee3:     ENDIF ELSE BEGIN                                                    !JDC
4715: 7eeb:         TITLE.END2$ = "LOCATION SELECTION SCREEN"                       !JDC
4716: 7f00:     ENDIF                                                               !JDC
4717: 7f08:     SCREEN2.TITLE$ = TITLE.START$ + TITLE.END2$                         !JDC
4718: 7f2c: 
4719: 7f2c: RETURN                                                                  !GCK
4720: 7f3c: 
4721: 7f3c: 
4722: 7f3c: \***********************************************************************!DDM
4723: 7f3c: \*                                                                      !DDM
4724: 7f3c: \* PARSE.UNCOLLECTED.DAYS:                                              !DDM
4725: 7f3c: \* Reads and parses the uncollected days value from SOFTS 60th record   !DDM
4726: 7f3c: \*                                                                      !DDM
4727: 7f3c: \***********************************************************************!DDM
4728: 7f3c: 
4729: 7f3c: PARSE.UNCOLLECTED.DAYS:                                                 !DDM
4730: 7f4c: 
4731: 7f4c:     ! Read SOFTS 60th record                                            !DDM
4732: 7f4c:     SOFTS.REC.NUM% = 60                                                 !DDM
4733: 7f63:     IF READ.SOFTS THEN GOSUB READ.ERROR                                 !DDM
4734: 7f7e: 
4735: 7f7e:     ! Initialising to FALSE                                             !DDM
4736: 7f7e:     SOFTS.LIMIT.VAL.FOUND = FALSE                                       !DDM
4737: 7f8c: 
4738: 7f8c:     ! Parse uncollected days value. If the match is not found then      !DDM
4739: 7f8c:     ! sets SOFTS.LIMIT.VAL.FOUND to FALSE                               !DDM
4740: 7f8c:     MATCH.POS% = MATCH(LIMIT.STR$, SOFTS.RECORD$, 1)                    !DDM
4741: 7fb1: 
4742: 7fb1:     IF MATCH.POS% > 0 THEN BEGIN                                        !DDM
4743: 7fc0:         ! Setting to TRUE as match found                                !DDM
4744: 7fc0:         SOFTS.LIMIT.VAL.FOUND = TRUE                                    !DDM
4745: 7fce:         ! Storing the SOFTS record                                      !DDM
4746: 7fce:         WORK.SOFTS.RECORD$ = \                                          !DDM
4747: 7ffa:                 MID$(SOFTS.RECORD$, MATCH.POS% + 6, LIMIT.LENGTH%)      !DDM
4748: 7ffa:         ! Storing the uncollected days                                  !DDM
4749: 7ffa:         DAYS.UNCOLLECTED% = VAL(WORK.SOFTS.RECORD$)                     !DDM
4750: 8016:     ENDIF ELSE BEGIN                                                    !DDM
4751: 801e:         SOFTS.LIMIT.VAL.FOUND = FALSE                                   !DDM
4752: 802c:     ENDIF                                                               !DDM
4753: 8034: 
4754: 8034:     ! De-allocate SOFTS session                                         !DDM
4755: 8034:     SB.INTEGER% = SOFTS.SESS.NUM%                                       !DDM
4756: 804a:     SB.STRING$  = ""                                                    !DDM
4757: 8061:     CLOSE SB.INTEGER%                                                   !DDM
4758: 8075:     SOFTS.OPEN  = FALSE                                                 !DDM
4759: 8083:     GOSUB SB.FILE.UTILS                                                 !DDM
4760: 8095: 
4761: 8095: RETURN                                                                  !DDM
4762: 80a5: 
4763: 80a5: \***********************************************************************!DDM
4764: 80a5: \*                                                                      !DDM
4765: 80a5: \* PRINT.BDCRPT:                                                        !DDM
4766: 80a5: \* Invokes PSD96.286 program at background and Prints BDCRPT            !DDM
4767: 80a5: \* (report file)                                                        !DDM
4768: 80a5: \*                                                                      !DDM
4769: 80a5: \***********************************************************************!DDM
4770: 80a5: 
4771: 80a5: PRINT.BDCRPT:                                                           !DDM
4772: 80b5: 
4773: 80b5:     ! Setting the values to the parameter variables                     !DDM
4774: 80b5:     ADX.MESSAGE$ = "Started by PSD85 BDC Parcel Mgt Screen."            !DDM
4775: 80ca:     ADX.NAME$    = "ADX_UPGM:PSD96.286"                                 !DDM
4776: 80df:     ADX.PARM$    = "ONDEMAND"                                           !DDM
4777: 80f4: 
4778: 80f4:     ! Initiate PSD96.286 at background                                  !DDM
4779: 80f4:     RC% = ADXSTART(ADX.NAME$,ADX.PARM$,ADX.MESSAGE$)                    !DDM
4780: 811f: 
4781: 811f:     ! If success then display BEMF '388' message else log the event 42. !ECK
4782: 811f:     IF RC% = 0 THEN BEGIN                                               !DDM
4783: 812e:         CALL DM.FOCUS ("", "MESSAGE(388,'')")                           !ECK
4784: 8149:     ENDIF ELSE BEGIN                                                    !DDM
4785: 8151:         ! Logging ADXSTART error                                        !DDM
4786: 8151:         MESSAGE.NUMBER% = 0                                             !DDM
4787: 815f:         EVENT.NUMBER%   = 42                                            !DDM
4788: 816d:         VAR.STRING.1$   = ADX.NAME$                                     !DDM
4789: 8186:         VAR.STRING.2$   = ADX.PARM$                                     !DDM
4790: 819f:         CALL APPLICATION.LOG(MESSAGE.NUMBER%,VAR.STRING.1$, \           !DDM
4791: 81c8:                              VAR.STRING.2$,EVENT.NUMBER%)               !DDM
4792: 81c8:         CALL DM.FOCUS ("", "MESSAGE(313,'')")                           !DDM
4793: 81e0:     ENDIF                                                               !DDM
4794: 81e8: 
4795: 81e8: RETURN                                                                  !DDM
4796: 81f8: 
4797: 81f8: \*********************************************************************
4798: 81f8: \***
4799: 81f8: \***    SUBROUTINE      :      LOAD.PARCELS
4800: 81f8: \***
4801: 81f8: \*** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
4802: 81f8: 
4803: 81f8: LOAD.PARCELS:
4804: 8208: 
4805: 8208:    file.loaded% = -1
4806: 8215:    p.cnt%       = 0
4807: 8223: 
4808: 8223:    \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
4809: 8223:    \* Open Boots.com Parcel file
4810: 8223:    \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
4811: 8223:    IF bdcp.open% THEN CLOSE BDCP.SESS.NUM%
4812: 823e:    bdcp.open% = 0
4813: 824b: 
4814: 824b:    ! Modifying the below line. CURRENT.REPORT.NUM% is updated with      !ECK
4815: 824b:    ! BDCP.REPORT.NUM%                                                   !ECK
4816: 824b:    CURRENT.REPORT.NUM% = BDCP.REPORT.NUM%                               !ECK
4817: 8261: 
4818: 8261:    ! If error occurs while opening BDCP file go to the subroutine       !ECK
4819: 8261:    ! OPEN.ERROR                                                         !ECK
4820: 8261: 
4821: 8261:    IF END #BDCP.SESS.NUM% THEN OPEN.ERROR                               !ECK
4822: 827d:    OPEN BDCP.FILE.NAME$ AS BDCP.SESS.NUM% BUFFSIZE 32768              \
4823: 82a6:                                                        NOWRITE NODEL
4824: 82a6:    bdcp.open% = -1
4825: 82b3: 
4826: 82b3:     IF BDCO.OPEN% = 0 THEN BEGIN                                        !HDC
4827: 82c2:         IF END #BDCO.SESS.NUM% THEN OPEN.ERROR                          !HDC
4828: 82de:         OPEN BDCO.FILE.NAME$ KEYED RECL BDCO.RECL% AS BDCO.SESS.NUM% \  !HDC
4829: 830b:          NOWRITE NODEL                                                  !HDC
4830: 830b:         BDCO.OPEN% = 1                                                  !HDC
4831: 8318:     ENDIF                                                               !HDC
4832: 8320: 
4833: 8320: no.bdcp.file:
4834: 8330: 
4835: 8330:    \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
4836: 8330:    \* Set initial values
4837: 8330:    \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
4838: 8330: 
4839: 8330:    p1$       = ""
4840: 8345:    p2$       = ""
4841: 835a:    p3$       = ""
4842: 836f:    p4$       = ""
4843: 8384:    p5$       = ""
4844: 8399:    p6$       = ""
4845: 83ae:    P7$       = ""                                                       !LLJ
4846: 83c3:    P8$       = ""                                                       !LLJ
4847: 83d8: 
4848: 83d8:    blk.size% = 32256
4849: 83e6:    num.blks% = (SIZE(BDCP.FILE.NAME$) / blk.size%) +1
4850: 841b:    last.blk% = MOD(SIZE(BDCP.FILE.NAME$),  blk.size%)
4851: 8445:    num.sect% = 63
4852: 8453:    num.recs% = 508 / BDCP.RECL%
4853: 846f: 
4854: 846f:    \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
4855: 846f:    \* Extract records from Boots.com parcel file
4856: 846f:    \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
4857: 846f:    IF END #BDCP.SESS.NUM% THEN READ.ERROR
4858: 848b:    FOR i% = 1 TO num.blks%
4859: 849c:       CALL DM.STATUS("MESSAGE(221,'Processing .. >"                    \
4860: 8520:                      + STRING$(      (i%*50)/num.blks% , CHR$(178))    \
4861: 8520:                      + STRING$(50 - ((i%*50)/num.blks%), CHR$(176))    \
4862: 8520:                      + "<')")
4863: 8520:       IF i% = num.blks% THEN BEGIN
4864: 8531:          form$ = "C" + STR$(last.blk%)
4865: 8554:          num.sect% = last.blk% / 512
4866: 856a:       ENDIF ELSE BEGIN
4867: 8572:          form$ = "C" + STR$(blk.size%)
4868: 8595:       ENDIF
4869: 859d: 
4870: 859d:       ! added missing error settings
4871: 859d:       CURRENT.REPORT.NUM% = BDCP.REPORT.NUM%                            !HDC
4872: 85b3:       FILE.OPERATION$ = "R"                                             !HDC
4873: 85ca:       READ FORM form$; # BDCP.SESS.NUM%; blk$
4874: 85f6: 
4875: 85f6:       FOR j% = 1 TO num.sect%
4876: 8607:          IF i% = 1 AND j% = 1 THEN j% = 2    ! Skip stats
4877: 8632:          sect$ = MID$(blk$, ((j% -1) *512) +5, 508)
4878: 865e:          IF MID$(sect$,1,7) <> STRING$(7, CHR$(0)) THEN BEGIN
4879: 869d:             FOR k% = 1 TO num.recs%
4880: 86ae:                rcd$ = MID$(sect$, ((k% -1)* BDCP.RECL%) +1, BDCP.RECL%)
4881: 86e0:                IF MID$(rcd$,1,7) <> STRING$(7, CHR$(0)) THEN BEGIN
4882: 871f: 
4883: 871f:                   p.cnt% = p.cnt% +1          ! Increment counter
4884: 872b: 
4885: 872b:                   wk$ = MID$(rcd$,16,1)
4886: 874d:                   \* - - - - - - - - - - - - - - - - - - - - - - - - - -
4887: 874d:                   \* Extract required date/time for status message
4888: 874d:                   \* - - - - - - - - - - - - - - - - - - - - - - - - - -
4889: 874d:                   IF      wk$ = "O" THEN x.dt$ = MID$(rcd$,13,3)       \
4890: 8785:                   ELSE IF wk$ = "R" THEN x.dt$ = MID$(rcd$,46,6)       \
4891: 87bd:                   ELSE IF wk$ = "C" THEN x.dt$ = MID$(rcd$,24,6)       \
4892: 87f4:                   ELSE IF wk$ = "L" THEN x.dt$ = MID$(rcd$,39,6)       \
4893: 882b:                   ELSE IF wk$ = "U" THEN x.dt$ = MID$(rcd$,32,6)       !
4894: 8860:                   IF LEN(x.dt$) = 3 THEN                               \
4895: 887b:                      x.dt$ = x.dt$ + PACK$("000000")
4896: 88a0: 
4897: 88a0:                   ! Checks the parcel status to Enable the 'F9' key     !FMM
4898: 88a0:                   IF wk$ = "O" OR wk$ = "R" OR wk$ = "L" THEN \         !FMM
4899: 8911:                       PRINT.KEY = TRUE                                  !FMM
4900: 891f: 
4901: 891f:                   \* - - - - - - - - - - - - - - - - - - - - - - - - - -
4902: 891f:                   \* Extract delivery date (not time)
4903: 891f:                   \* - - - - - - - - - - - - - - - - - - - - - - - - - -
4904: 891f:                   d.dt$ = MID$(rcd$,17,3)
4905: 8941: 
4906: 8941:                   \* - - - - - - - - - - - - - - - - - - - - - - - - - -
4907: 8941:                   \* Set required sort order for status       1 byte
4908: 8941:                   \* - - - - - - - - - - - - - - - - - - - - - - - - - -
4909: 8941: 
4910: 8941:                   IF WK$ = "O" THEN BEGIN                               !FMM
4911: 895f: 
4912: 895f:                      IF DATE$ > UNPACK$(LEFT$(X.DT$,3)) THEN BEGIN      !FMM
4913: 8997:                         ! Update STATUS.SORT.ORDER$ as "1" for parcel   !FMM
4914: 8997:                         ! status "LATE".                                !FMM
4915: 8997:                         STATUS.SORT.ORDER$ = "1"                        !FMM
4916: 89ae:                      ENDIF ELSE BEGIN                                   !FMM
4917: 89b6:                         ! Update STATUS.SORT.ORDER$ as "2" for parcel   !FMM
4918: 89b6:                         ! status "EXPECTED".                            !FMM
4919: 89b6:                         STATUS.SORT.ORDER$ = "2"                        !FMM
4920: 89cb:                      ENDIF                                              !FMM
4921: 89d6: 
4922: 89d6:                   ENDIF ELSE IF WK$ = "R" THEN BEGIN                    !FMM
4923: 89f4: 
4924: 89f4:                      ! If status date [X.DT$] is 0's then update global !FMM
4925: 89f4:                      ! variable F02.DATE$ with delivery date else update!FMM
4926: 89f4:                      ! with found date.                                 !FMM
4927: 89f4:                      IF X.DT$ = STRING$(6,CHR$(0)) THEN BEGIN           !FMM
4928: 8a1c:                         ! Assigning delivery date to global variable    !FMM
4929: 8a1c:                         F02.DATE$ = UNPACK$(D.DT$)                      !FMM
4930: 8a3e:                      ENDIF ELSE BEGIN                                   !FMM
4931: 8a46:                         ! Assigning found date to global variable       !FMM
4932: 8a46:                         F02.DATE$ = UNPACK$(MID$(X.DT$,1,3))            !FMM
4933: 8a6f:                      ENDIF                                              !FMM
4934: 8a77: 
4935: 8a77:                      ! For status 'R': Check difference between today's !FMM
4936: 8a77:                      ! date and delivery date/found date. For the order !FMM
4937: 8a77:                      ! status "UNCOLLECTED" the difference is greater   !FMM
4938: 8a77:                      ! than Uncollected days value. For status          !FMM
4939: 8a77:                      ! "IN STORE" the difference is lesser than         !FMM
4940: 8a77:                      ! Uncollected days value.                          !FMM
4941: 8a77: 
4942: 8a77:                      ! Calculating return by date. DAYS.UNCOLLECTED% is !FMM
4943: 8a77:                      ! retrieving value from SOFTS file. If days        !FMM
4944: 8a77:                      ! uncollected value is not found the program will  !FMM
4945: 8a77:                      ! exit logging the event. Therefore, return code is!FMM
4946: 8a77:                      ! not checked here for UPDATE.DATE function        !FMM
4947: 8a77:                      CALL UPDATE.DATE(DAYS.UNCOLLECTED%)                !FMM
4948: 8a8d:                      RETURN.BY.DATE$ = F02.DATE$                        !FMM
4949: 8aa9: 
4950: 8aa9:                      IF DATE.LT(RETURN.BY.DATE$,CURRENT.DATE$)          \FMM
4951: 8acd:                                                   THEN BEGIN            !FMM
4952: 8acd:                         ! Update STATUS.SORT.ORDER$ as "3" for parcel   !FMM
4953: 8acd:                         ! status "UNCOLLECTED RETURN TO W/H?" and update!FMM
4954: 8acd:                         ! the P1$ string.                               !FMM
4955: 8acd:                         STATUS.SORT.ORDER$ = "3"                        !FMM
4956: 8ae4:                      ENDIF ELSE BEGIN                                   !FMM
4957: 8aec:                         IF X.DT$ = STRING$(6,CHR$(0)) THEN BEGIN        !FMM
4958: 8b14:                            ! Update STATUS.SORT.ORDER$ as "4" for parcel!FMM
4959: 8b14:                            ! status "IN STORE - AWAITING COLLECTION"    !FMM
4960: 8b14:                            STATUS.SORT.ORDER$ = "4"                     !FMM
4961: 8b2b:                         ENDIF ELSE BEGIN                                !FMM
4962: 8b33:                            ! Update STATUS.SORT.ORDER$ as "5" for parcel!FMM
4963: 8b33:                            ! status "IN STORE - FOUND".                 !FMM
4964: 8b33:                            STATUS.SORT.ORDER$ = "5"                     !FMM
4965: 8b48:                         ENDIF                                           !FMM
4966: 8b50:                      ENDIF                                              !FMM
4967: 8b5b: 
4968: 8b5b:                   ENDIF ELSE IF WK$ = "C" THEN BEGIN                    !FMM
4969: 8b76:                      ! Update STATUS.SORT.ORDER$ as "6" for parcel      !FMM
4970: 8b76:                      ! status "COLLECTED".                              !FMM
4971: 8b76:                      STATUS.SORT.ORDER$ = "6"                           !FMM
4972: 8b8d:                   ENDIF ELSE IF WK$ = "U" THEN BEGIN                    !FMM
4973: 8ba8:                      ! Update STATUS.SORT.ORDER$ as "7" for parcel      !FMM
4974: 8ba8:                      ! status "RETURNED".                               !FMM
4975: 8ba8:                      STATUS.SORT.ORDER$ = "7"                           !FMM
4976: 8bbf:                   ENDIF ELSE IF WK$ = "L" THEN BEGIN                    !FMM
4977: 8bda:                      ! Update STATUS.SORT.ORDER$ as "8" for parcel      !FMM
4978: 8bda:                      ! status "RETURNED".                               !FMM
4979: 8bda:                      STATUS.SORT.ORDER$ = "8"                           !FMM
4980: 8bef:                   ENDIF                                                 !FMM
4981: 8bf7: 
4982: 8bf7:                   ! Append the string P1$ with STATUS.SORT.ORDER$       !FMM
4983: 8bf7:                   p1$ = p1$ + STATUS.SORT.ORDER$                        !FMM
4984: 8c1b: 
4985: 8c1b:                   \* - - - - - - - - - - - - - - - - - - - - - - - - - -
4986: 8c1b:                   \* Order Number                             5 bytes
4987: 8c1b:                   \* if Order number is zeros then set to F's
4988: 8c1b:                   \* - - - - - - - - - - - - - - - - - - - - - - - - - -
4989: 8c1b:                   IF MID$(rcd$,8,5) = STRING$(5,CHR$(0)) THEN          \
4990: 8c57:                      p2$ = p2$ + STRING$(5,CHR$(0FFh))                 \
4991: 8c84:                   ELSE                                                 \
4992: 8c8c:                      p2$ = p2$ + MID$(rcd$,8,5)
4993: 8cb9: 
4994: 8cb9:                   \* - - - - - - - - - - - - - - - - - - - - - - - - - -
4995: 8cb9:                   \* Parcel Number                            4 bytes
4996: 8cb9:                   \* Date Received                            3 bytes
4997: 8cb9:                   \* Date needed for status msg               6 bytes
4998: 8cb9:                   \* Append supplier number for key           3 bytes
4999: 8cb9:                   \*                                         ________
5000: 8cb9:                   \* Total                                   22 bytes
5001: 8cb9:                   \* - - - - - - - - - - - - - - - - - - - - - - - - - -
5002: 8cb9:                   p3$ = p3$ + MID$(rcd$,4,4)
5003: 8ce6:                   p4$ = p4$ + d.dt$
5004: 8d0a:                   p5$ = p5$ + x.dt$
5005: 8d2e:                   p6$ = p6$ + MID$(rcd$,1,3)
5006: 8d5b: 
5007: 8d5b:                   !*****************************************************!HDC
5008: 8d5b:                   !* Code change H block marker - START                 !HDC
5009: 8d5b:                   !*****************************************************!HDC
5010: 8d5b:                   ! check the number or current Parcels for the order
5011: 8d5b:                   ! and mark the staus into the main array for the order
5012: 8d5b:                   ! so we can use it later
5013: 8d5b:                   BDCO.ORDER$ = UNPACK$(MID$(RCD$,8,5))                 !LLJ
5014: 8d84:                   ORDERS.OFFSET% = \
5015: 8dc2:                    MATCH(":"+BDCO.ORDER$,ORDERS.OFFSET$,1)
5016: 8dc2:                   IF ORDERS.OFFSET% = 0 THEN BEGIN
5017: 8dd4:                       MAX.PARCELS% = 0
5018: 8de2:                       IF END #BDCO.SESS.NUM% THEN READ.ERROR
5019: 8dfe: 
5020: 8dfe:                       BDCO.KEY$ = MID$(RCD$,8,5)                        !LLJ
5021: 8e22: 
5022: 8e22:                       IF BDCO.KEY$ <> PACK$(STRING$(10,"0")) \
5023: 8e8d:                       AND BDCO.KEY$ <> STRING$(5," ") \
5024: 8e8d:                       THEN BEGIN
5025: 8e8d:                           CURRENT.REPORT.NUM% = BDCO.REPORT.NUM%
5026: 8ea3:                           FILE.OPERATION$ = "R"
5027: 8eba: 
5028: 8eba:                           READ FORM "T9,C246" ; #BDCO.SESS.NUM% \
5029: 8f1f:                           KEY MID$(RCD$,1,3) + MID$(RCD$,8,5); P8$      !LLJ
5030: 8f1f:                           ! look to the end of the parcel list, which
5031: 8f1f:                           ! will always have 0s since it can only be
5032: 8f1f:                           ! up to 55 per order (file limit)
5033: 8f1f:                           MAX.PARCELS% = MATCH(STRING$(8,"0"),         \!LLJ
5034: 8f62:                                          UNPACK$(P8$),1)                !LLJ
5035: 8f62:                           IF MAX.PARCELS% > 0 THEN BEGIN
5036: 8f71:                               MAX.PARCELS% = ((MAX.PARCELS%-1)/4)+1
5037: 8f89:                           ENDIF ELSE BEGIN
5038: 8f91:                               MAX.PARCELS% = 55
5039: 8f9f:                           ENDIF
5040: 8fa7:                       ENDIF
5041: 8faf:                       P8$ = RIGHT$("00"+STR$(MAX.PARCELS%),2)
5042: 8ff3: 
5043: 8ff3:                       ! add the order to the index and put parcel total
5044: 8ff3:                       ! in element 0 for reference
5045: 8ff3:                       ORDERS.OFFSET$ = ORDERS.OFFSET$ + ":" +          \!LLJ
5046: 901e:                                         BDCO.ORDER$                     !LLJ
5047: 901e:                       ORDERS.OFFSET% = ((LEN(ORDERS.OFFSET$)-1)/11)
5048: 9040:                       ORDER.PARCELS%(ORDERS.OFFSET%,0) = MAX.PARCELS%
5049: 9061:                   ENDIF ELSE BEGIN
5050: 9069:                       ORDERS.OFFSET% = ((ORDERS.OFFSET%-1)/11)+1
5051: 907f:                       P8$ = STR$(ORDER.PARCELS%(ORDERS.OFFSET%,0))
5052: 90ac:                   ENDIF
5053: 90b4:                   P7$ = P7$ + MID$(RCD$,53,4)                           !LLJ
5054: 90e1: 
5055: 90e1:                   ! update if the parcel is ready or not for the
5056: 90e1:                   ! overall order staus
5057: 90e1:                   IF MID$(RCD$,16,1) = "R" THEN BEGIN                   !LLJ
5058: 9113:                       ORDER.PARCELS%(ORDERS.OFFSET%,1) = \
5059: 912f:                        ORDER.PARCELS%(ORDERS.OFFSET%,1) + 1
5060: 912f:                   ENDIF
5061: 9139:                   !*****************************************************!HDC
5062: 9139:                   !* Code change H block marker - END                   !HDC
5063: 9139:                   !*****************************************************!HDC
5064: 9139:                ENDIF ELSE BEGIN
5065: 9141:                   k% = num.recs%
5066: 914f:                ENDIF    ! record populated
5067: 9157:             NEXT k%     ! records per sector
5068: 9172:          ENDIF          ! sector populated
5069: 917a:       NEXT j%           ! sectors per block
5070: 9195:    NEXT i%              ! blocks per file
5071: 91b0: 
5072: 91b0:    \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
5073: 91b0:    \* Populate array
5074: 91b0:    \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
5075: 91b0: 
5076: 91b0:    DIM p.arr$(p.cnt%)
5077: 91db:    !********************************************************************!HDC
5078: 91db:    ! Array layout                                                       !HDC
5079: 91db:    ! 12222233334445555556667777                                         !HDC
5080: 91db:    ! 1 = Status sort Order (ASCII)                                      !HDC
5081: 91db:    ! 2 = Order Number(PD)                                               !HDC
5082: 91db:    ! 3 = Parcel number (PD)                                             !HDC
5083: 91db:    ! 4 = Date received (PD)                                             !HDC
5084: 91db:    ! 5 = Date for Status Msg (PD)                                       !HDC
5085: 91db:    ! 6 = Supplier Number (PD)                                           !HDC
5086: 91db:    ! 7 = 2x INT2 - Current Location + Location Status                   !HDC
5087: 91db:    !********************************************************************!HDC
5088: 91db:    FOR i% = 1 TO p.cnt%
5089: 91ec:       p.arr$(i%) = MID$(p1$,((i% -1) * 1) +1, 1)                       \
5090: 92f4:                  + MID$(p2$,((i% -1) * 5) +1, 5)                       \
5091: 92f4:                  + MID$(p3$,((i% -1) * 4) +1, 4)                       \
5092: 92f4:                  + MID$(p4$,((i% -1) * 3) +1, 3)                       \
5093: 92f4:                  + MID$(p5$,((i% -1) * 6) +1, 6)                       \
5094: 92f4:                  + MID$(p6$,((i% -1) * 3) +1, 3)                       \
5095: 92f4:                  + MID$(P7$,((I% -1) * 4) +1, 4)                        !LLJ
5096: 92f4:    NEXT i%
5097: 930f: 
5098: 930f:    \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
5099: 930f:    \* Sort the array
5100: 930f:    \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
5101: 930f: 
5102: 930f:    CALL DM.STATUS("MESSAGE(221,'Sorting List.')")
5103: 9323:    IF p.cnt% > 0 THEN BEGIN
5104: 9332:       RC% = CSORT(VARPTR(p.arr$(0)), p.cnt%)
5105: 9360:    ENDIF
5106: 9368:    CALL DM.STATUS("MESSAGE(221,'Sort Complete.')")
5107: 937c: 
5108: 937c:    \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
5109: 937c:    \* Close file and reopen for keyed access (with update)
5110: 937c:    \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
5111: 937c:    CLOSE BDCP.SESS.NUM%
5112: 9390:    bdcp.open% =  0
5113: 939d: 
5114: 939d:    IF BDCO.OPEN% THEN CLOSE BDCO.SESS.NUM%                              !HDC
5115: 93b8: 
5116: 93b8:    \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
5117: 93b8:    \* Tidy up
5118: 93b8:    \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
5119: 93b8: 
5120: 93b8:    blk$  = ""
5121: 93cd:    rcd$  = ""
5122: 93e2:    sect$ = ""
5123: 93f7:    wk$   = ""
5124: 940c:    p1$   = ""
5125: 9421:    p2$   = ""
5126: 9436:    p3$   = ""
5127: 944b:    p4$   = ""
5128: 9460:    p5$   = ""
5129: 9475:    p6$   = ""
5130: 948a:    STATUS.SORT.ORDER$ = ""                                              !FMM
5131: 949f: 
5132: 949f: RETURN
5133: 94af: 
5134: 94af: \***********************************************************************!QCK
5135: 94af: \*                                                                      !QCK
5136: 94af: \* OPEN.BDCLOCON:                                                       !QCK
5137: 94af: \*                                                                      !QCK
5138: 94af: \* Opens the file BDCLOCON                                              !QCK
5139: 94af: \*                                                                      !QCK
5140: 94af: \***********************************************************************!QCK
5141: 94af: OPEN.BDCLOCON:                                                          !QCK
5142: 94bf:                                                                         !QCK
5143: 94bf:     ! Opening BDCLOCON file                                             !QCK
5144: 94bf:     IF NOT BDCLOCON.OPEN THEN BEGIN                                     !QCK
5145: 94d1:         CURRENT.REPORT.NUM% = BDCLOCON.REPORT.NUM%                      !QCK
5146: 94e7:         FILE.OPERATION$     = "O"   ! Open                              !QCK
5147: 94fe:                                                                         !QCK
5148: 94fe:         ! Open BDCLOCON file                                            !QCK
5149: 94fe:         ! IF END# statement is not used here so that all open errors for!QCK
5150: 94fe:         ! BDCLOCON is captured in ERR.DETECETED, including the open     !QCK
5151: 94fe:         ! error from the functions FUNC.GET.LOCATION$ and               !QCK
5152: 94fe:         ! FUNC.UPDATE.ALL.LOCATION.RECORDS%                             !QCK
5153: 94fe:         OPEN BDCLOCON.FILE.NAME$ DIRECT RECL BDCLOCON.RECL% AS \        !QCK
5154: 952a:         BDCLOCON.SESS.NUM%                                              !QCK
5155: 952a:                                                                         !QCK
5156: 952a:         ! Set the open flag                                             !QCK
5157: 952a:         BDCLOCON.OPEN = TRUE                                            !QCK
5158: 953c:     ENDIF                                                               !QCK
5159: 9544:                                                                         !QCK
5160: 9544: RETURN                                                                  !QCK
5161: 9554:                                                                         !QCK
5162: 9554: \********************************************************************
5163: 9554: \***
5164: 9554: \***    SUBROUTINE      :      FILE.ERROR
5165: 9554: \***
5166: 9554: \*** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
5167: 9554: 
5168: 9554: FILE.ERROR:
5169: 9564: 
5170: 9564:     ! Hide the function keys F3 and F9 if BATCH.SCREEN.FLAG$ is "S"     !ECK
5171: 9564: 
5172: 9564:     IF BATCH.SCREEN.FLAG$ = "S" THEN BEGIN                              !ECK
5173: 9582:         CALL DM.HIDE.FN.KEY(3)                                          !ECK
5174: 9593:         CALL DM.HIDE.FN.KEY(9)                                          !ECK
5175: 95a4:     ENDIF                                                               !ECK
5176: 95ac: 
5177: 95ac:     IF SB.ACTION$ = "C" THEN RETURN             ! Ignore close errs
5178: 95d2: 
5179: 95d2:     EVENT.NUMBER%   = 106
5180: 95e0: 
5181: 95e0:     MESSAGE.NUMBER% = 0
5182: 95ee: 
5183: 95ee:     FILE.NO$ = CHR$(SHIFT(CURRENT.REPORT.NUM%,8)) +                  \
5184: 963f:                CHR$(SHIFT(CURRENT.REPORT.NUM%,0))
5185: 963f: 
5186: 963f:     VAR.STRING.2$ = RIGHT$("000" + STR$(CURRENT.REPORT.NUM%),3)
5187: 9687: 
5188: 9687: 
5189: 9687:     ! Updating the variables MESSAGE.NUMBER% and VAR.STRING.2$ as per   !ECK
5190: 9687:     ! the file operation, as part of CR02 changes.                      !ECK
5191: 9687: 
5192: 9687:     IF FILE.OPERATION$ = "O" THEN BEGIN                                 !ECK
5193: 96a5:         MESSAGE.NUMBER% = 501                                           !ECK
5194: 96b6:     ENDIF ELSE BEGIN                                                    !ECK
5195: 96be: 
5196: 96be:         IF FILE.OPERATION$ = "R" THEN BEGIN                             !ECK
5197: 96dc:             MESSAGE.NUMBER% = 508                                       !ECK
5198: 96ea:             VAR.STRING.2$ = RIGHT$("000" + STR$(CURRENT.REPORT.NUM%),3) \ECK
5199: 974e:                             + CURRENT.CODE$                             !ECK
5200: 974e:         ENDIF ELSE BEGIN                                                !ECK
5201: 9756:             MESSAGE.NUMBER% = 509                                       !ECK
5202: 9764: 
5203: 9764:             IF FILE.OPERATION$ = "W" THEN BEGIN                         !ECK
5204: 9782:                 VAR.STRING.2$ = RIGHT$("000" +                          \ECK
5205: 97ca:                                        STR$(CURRENT.REPORT.NUM%), 3)    !ECK
5206: 97ca:             ENDIF                                                       !ECK
5207: 97d2: 
5208: 97d2:         ENDIF                                                           !ECK
5209: 97da: 
5210: 97da:     ENDIF                                                               !ECK
5211: 97e2: 
5212: 97e2:     VAR.STRING.1$ = FILE.OPERATION$ +                                \
5213: 9819:                     FILE.NO$ +                                       \
5214: 9819:                     PACK$(STRING$(12,"0"))
5215: 9819: 
5216: 9819:     ! If BATCH.SCREEN.FLAG$ is not "S" update MESSAGE.NUMBER% with 0.   !ECK
5217: 9819: 
5218: 9819:     IF BATCH.SCREEN.FLAG$ <> "S" THEN BEGIN                             !ECK
5219: 9837:         MESSAGE.NUMBER% = 0                                             !ECK
5220: 9845:     ENDIF                                                               !ECK
5221: 984d: 
5222: 984d:     CALL APPLICATION.LOG(MESSAGE.NUMBER%,                            \
5223: 9876:                          VAR.STRING.1$,                              \
5224: 9876:                          VAR.STRING.2$,                              \
5225: 9876:                          EVENT.NUMBER%)
5226: 9876: 
5227: 9876: RETURN
5228: 9886: 
5229: 9886: \********************************************************************
5230: 9886: \***
5231: 9886: \***    SUBROUTINE      :      TERMINATE
5232: 9886: \***
5233: 9886: \*** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
5234: 9886: 
5235: 9886: TERMINATE:
5236: 9896: 
5237: 9896:       SB.ACTION$ = "C"
5238: 98ad: 
5239: 98ad:       IF bdcp.open% THEN BEGIN
5240: 98bc:          SB.INTEGER% = BDCP.SESS.NUM%
5241: 98d2:          SB.STRING$ = ""
5242: 98e9:          CLOSE SB.INTEGER%
5243: 98fd:          GOSUB SB.FILE.UTILS
5244: 990f:          bdcp.open% = 0
5245: 991c:       ENDIF
5246: 9924: 
5247: 9924:       IF SOFTS.OPEN THEN BEGIN                                          !DDM
5248: 9933:          ! De-allocate session number for SOFTS file                    !DDM
5249: 9933:          SB.INTEGER% = SOFTS.SESS.NUM%                                  !DDM
5250: 9949:          SB.STRING$  = ""                                               !DDM
5251: 9960:          CLOSE SB.INTEGER%                                              !DDM
5252: 9974:          SOFTS.OPEN  = FALSE                                            !DDM
5253: 9982:          GOSUB SB.FILE.UTILS                                            !DDM
5254: 9994:       ENDIF                                                             !DDM
5255: 999c: 
5256: 999c:       IF BDCLOCON.OPEN THEN BEGIN                                       !HDC
5257: 99ae:          ! De-allocate session number for LOCATION file                 !HDC
5258: 99ae:          SB.INTEGER% = BDCLOCON.SESS.NUM%                               !HDC
5259: 99c4:          SB.STRING$  = ""                                               !HDC
5260: 99db:          CLOSE SB.INTEGER%                                              !HDC
5261: 99ef:          BDCLOCON.OPEN  = FALSE                                         !HDC
5262: 9a01:          GOSUB SB.FILE.UTILS                                            !HDC
5263: 9a13:       ENDIF                                                             !HDC
5264: 9a1b:                                                                         !HDC
5265: 9a1b: RETURN
5266: 9a2b: 
5267: 9a2b: \********************************************************************
5268: 9a2b: \***
5269: 9a2b: \***    SUBROUTINE      :       SB.FILE.UTILS
5270: 9a2b: \***
5271: 9a2b: \********************************************************************
5272: 9a2b: \***
5273: 9a2b: \***      Allocate/report/de-allocate a file session number
5274: 9a2b: \***
5275: 9a2b: \********************************************************************
5276: 9a2b: \***
5277: 9a2b: \***      Parameters : 2 or 3 (depending on action)
5278: 9a2b: \***
5279: 9a2b: \***         SB.ACTION$  = "O" for allocate file session number
5280: 9a2b: \***                       "R" for report file session number
5281: 9a2b: \***                       "C" for de-allocate file session number
5282: 9a2b: \***
5283: 9a2b: \***         SB.INTEGER% = file reporting number for action "O" or
5284: 9a2b: \***                       file session number for actions "R" or "C"
5285: 9a2b: \***
5286: 9a2b: \***         SB.STRING$  = logical file name for action "O" or
5287: 9a2b: \***                       null ("") for action "R" and "C"
5288: 9a2b: \***
5289: 9a2b: \***      Output : 1 or 2 (depending on action)
5290: 9a2b: \***
5291: 9a2b: \***         SB.FILE.NAME$     = logical file name for action "R"
5292: 9a2b: \***
5293: 9a2b: \***         SB.FILE.SESS.NUM% = file session number for action "O"
5294: 9a2b: \***                             or undefined for action "C"
5295: 9a2b: \***         OR
5296: 9a2b: \***         SB.FILE.REP.NUM%  = file reporting number for action "R"
5297: 9a2b: \***                             or undefined for action "C"
5298: 9a2b: \***
5299: 9a2b: \*** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
5300: 9a2b: 
5301: 9a2b: SB.FILE.UTILS:
5302: 9a3b: 
5303: 9a3b:    CALL SESS.NUM.UTILITY(SB.ACTION$, SB.INTEGER%, SB.STRING$)
5304: 9a68: 
5305: 9a68:    IF SB.ACTION$ = "O" THEN BEGIN
5306: 9a86: 
5307: 9a86:        SB.FILE.SESS.NUM% = F20.INTEGER.FILE.NO%
5308: 9a9e: 
5309: 9a9e:    ENDIF ELSE IF SB.ACTION$ = "R" THEN BEGIN
5310: 9abc: 
5311: 9abc:        SB.FILE.REP.NUM% = F20.INTEGER.FILE.NO%
5312: 9ad2:        SB.FILE.NAME$ = F20.FILE.NAME$
5313: 9af0: 
5314: 9af0:    ENDIF
5315: 9af8: 
5316: 9af8: RETURN
5317: 9b08: \***********************************************************************!LLJ
5318: 9b08: \* UPDATE.PARCEL.COUNT:                                                 !LLJ
5319: 9b08: \* This subroutine will update the BDCLOCON.PARCEL.COUNT%               !LLJ
5320: 9b08: \*                                                                      !LLJ
5321: 9b08: \***********************************************************************!LLJ
5322: 9b08: UPDATE.PARCEL.COUNT:                                                    !LLJ
5323: 9b18:                                                                         !LLJ
5324: 9b18:     !Update only if the location has value                              !LLJ
5325: 9b18:     IF BDCLOCON.RECORD.NUM% > 0 AND BDCLOCON.RECORD.NUM% < 999         \!
5326: 9b47:                                                              THEN BEGIN !LLJ
5327: 9b47: 
5328: 9b47:         ! Open BDCLOCON file                                            !QCK
5329: 9b47:         GOSUB OPEN.BDCLOCON                                             !QCK
5330: 9b59: 
5331: 9b59:         !If there is read error then error out                          !LLJ
5332: 9b59:         IF READ.BDCLOCON THEN BEGIN                                     !LLJ
5333: 9b6a:             GOSUB READ.ERROR                                            !LLJ
5334: 9b7c:         ENDIF                                                           !LLJ
5335: 9b84:                                                                         !LLJ
5336: 9b84:         !Increment new location parcel count                            !LLJ
5337: 9b84:         BDCLOCON.PARCEL.COUNT% = BDCLOCON.PARCEL.COUNT% + PARCEL.COUNT% !LLJ
5338: 9b96:                                                                         !LLJ
5339: 9b96:         !If there is write error then error out                         !LLJ
5340: 9b96:         IF WRITE.BDCLOCON THEN BEGIN                                    !LLJ
5341: 9ba7:             GOSUB WRITE.ERROR                                           !LLJ
5342: 9bb9:         ENDIF                                                           !LLJ
5343: 9bc1: 
5344: 9bc1:         ! Closing BDCLOCON file                                         !QCK
5345: 9bc1:         IF BDCLOCON.OPEN THEN BEGIN                                     !QCK
5346: 9bd3:             CLOSE BDCLOCON.SESS.NUM%                                    !QCK
5347: 9be7:                                                                         !QCK
5348: 9be7:             ! Reset the flag                                            !QCK
5349: 9be7:             BDCLOCON.OPEN = FALSE                                       !QCK
5350: 9bf9:         ENDIF                                                           !QCK
5351: 9c01: 
5352: 9c01:     ENDIF                                                               !LLJ
5353: 9c09:                                                                         !LLJ
5354: 9c09: RETURN                                                                  !LLJ
5355: 9c19: \********************************************************************
5356: 9c19: \***
5357: 9c19: \***    Error Routines
5358: 9c19: \***
5359: 9c19: \********************************************************************
5360: 9c19: \***
5361: 9c19: \***    OPEN Error
5362: 9c19: \***
5363: 9c19: \********************************************************************
5364: 9c19: 
5365: 9c19: OPEN.ERROR:
5366: 9c29: 
5367: 9c29:    FILE.OPERATION$ = "O"
5368: 9c40:    GOSUB FILE.ERROR
5369: 9c52:    GOTO END.PROGRAM
5370: 9c5d: 
5371: 9c5d: RETURN
5372: 9c6d: 
5373: 9c6d: \********************************************************************
5374: 9c6d: \***
5375: 9c6d: \***    READ Error
5376: 9c6d: \***
5377: 9c6d: \********************************************************************
5378: 9c6d: 
5379: 9c6d: READ.ERROR:
5380: 9c7d: 
5381: 9c7d:    FILE.OPERATION$ = "R"
5382: 9c94:    GOSUB FILE.ERROR
5383: 9ca6:    GOTO END.PROGRAM
5384: 9cb1: 
5385: 9cb1: RETURN
5386: 9cc1: 
5387: 9cc1: \********************************************************************
5388: 9cc1: \***
5389: 9cc1: \***    WRITE Error
5390: 9cc1: \***
5391: 9cc1: \********************************************************************
5392: 9cc1: 
5393: 9cc1: WRITE.ERROR:
5394: 9cd1: 
5395: 9cd1:    FILE.OPERATION$ = "W"
5396: 9ce8:    GOSUB FILE.ERROR
5397: 9cfa:    GOTO END.PROGRAM
5398: 9d05: 
5399: 9d05: RETURN
5400: 9d15: 
5401: 9d15: \********************************************************************
5402: 9d15: \***
5403: 9d15: \***    General Error
5404: 9d15: \***
5405: 9d15: \********************************************************************
5406: 9d15: 
5407: 9d15: ERR.DETECTED:
5408: 9d25: 
5409: 9d25:    ! Ignore Close errors                                                !ECK
5410: 9d25: 
5411: 9d25:    IF ERR = "CU" THEN RESUME                                            !ECK
5412: 9d5a: 
5413: 9d5a:    IF ERR = "CM"                                                    \
5414: 9dbc:    OR ERR = "CT" THEN BEGIN
5415: 9dbc:       MESSAGE.NUMBER% = 553
5416: 9dca:       VAR.STRING.1$   = "B5000" + CHAINING.TO.PROG$
5417: 9dea:       VAR.STRING.2$   = "PS"    + CHAINING.TO.PROG$
5418: 9e0a:       EVENT.NUMBER%   = 18
5419: 9e18:       rc% = APPLICATION.LOG (MESSAGE.NUMBER%,                       \
5420: 9e44:                              VAR.STRING.1$,                         \
5421: 9e44:                              VAR.STRING.2$,                         \
5422: 9e44:                              EVENT.NUMBER%)
5423: 9e44:    ENDIF
5424: 9e4c: 
5425: 9e4c:     ! If BDCLOCON access fails                                          !QCK
5426: 9e4c:     IF ERRF% = BDCLOCON.SESS.NUM% THEN BEGIN                            !QCK
5427: 9e68:         ! If operation is Open                                          !QCK
5428: 9e68:         IF FILE.OPERATION$ = "O" THEN BEGIN                             !QCK
5429: 9e86:             GOSUB OPEN.ERROR                                            !QCK
5430: 9e9a:         ENDIF ELSE IF FILE.OPERATION$ = "R" THEN BEGIN                  !QCK
5431: 9eb8:             ! If operation is Read                                      !QCK
5432: 9eb8:             GOSUB READ.ERROR                                            !QCK
5433: 9eca:         ENDIF                                                           !QCK
5434: 9ed2:     ENDIF                                                               !QCK
5435: 9eda: 
5436: 9eda:    IF (ERRN AND 0000FFFFH) = 400CH THEN BEGIN   ! File access conflict  !DDM
5437: 9f14: 
5438: 9f14:        IF ERRF% = CRTN.SESS.NUM% THEN BEGIN                             !AHCS
5439: 9f30:           RESUME DO.ROLLBACK ! Rollback BDCP parcel record update       !AHCS
5440: 9f49:        ENDIF ELSE BEGIN                                                 !AHCS
5441: 9f51:           RESUME OPEN.ERROR                                             !DDM
5442: 9f68:       ENDIF                                                             !AHCS
5443: 9f70:    ENDIF                                                                !DDM
5444: 9f78: 
5445: 9f78:    !  *** any other system error ***
5446: 9f78: 
5447: 9f78:    CALL STANDARD.ERROR.DETECTED(ERRN,                               \
5448: 9fa5:                                 ERRF%,                              \
5449: 9fa5:                                 ERRL,                               \
5450: 9fa5:                                 ERR)
5451: 9fa5: 
5452: 9fa5:    RESUME END.PROGRAM
5453: 9fc1: 
5454: 9fc1: 
5455: 9fc1: END
5456: 9fc1: 
5457: 9fc1: 
5458: 9fc1: 
5459: 9fc1: 
5460: 9fc1: 
5461: 9fc1: 
5462: 9fc1: 
5463: 9fc1: 
5464: 9fc1: End of Compilation
