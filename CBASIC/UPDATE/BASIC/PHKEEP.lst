   1: 0000: \************************************************************************
   2: 0000: \***
   3: 0000: \***    PHKEEP            Ranjith Gopalankutty          05/04/2017  
   4: 0000: \***                                                                
   5: 0000: \***    There was a defect with program SRP10. It supposed to house 
   6: 0000: \***    keep the expired planner records from SRPOG,SRMOD,SRSXF     
   7: 0000: \***    and SRPDF files. SRPOG is the master planner file SRMOD     
   8: 0000: \***    is module,SRSXF is notch data and SRPDF is the planner      
   9: 0000: \***    descriptor file.  SRMOD,SRPDF and SRSXF files depends on    
  10: 0000: \***    the master planner file SRPOG to build the keys for them.   
  11: 0000: \***                                                                
  12: 0000: \***    The defect was that, SRP10 program was housekeeping only    
  13: 0000: \***    records from SRPOG and leaving behind other 3 files.Over    
  14: 0000: \***    time. Records will be housekept from SRPOG and untouching   
  15: 0000: \***    other files. Records will get piled up and causing file     
  16: 0000: \***    full issues. This resulted in new planner update not        
  17: 0000: \***    able to add in to planner files.Defect has been found       
  18: 0000: \***    and fixed by AppsMgmt. change is live in all stores,but     
  19: 0000: \***    one issue found afterwards that program was not able to     
  20: 0000: \***    delete the historical expired  records from planner files.  
  21: 0000: \***                                                                
  22: 0000: \***    This program will housekeep the data from 3 planner files   
  23: 0000: \***    SRMOD,SRSXF and SRPDF and will recreate the planner files   
  24: 0000: \***    fresh using only live records.                              
  25: 0000: \***                                                                
  26: 0000: \***    Program can be executed via command prompt using NFM or     
  27: 0000: \***    in a package.
  28: 0000: \***  
  29: 0000: \***    A                RANJITH GOPALANKUTTY               12-07-2017
  30: 0000: \***    After the meeting with Inctactix it came to our notice that   
  31: 0000: \***    there is a big mis match between the number of planners in    
  32: 0000: \***    in inctactix and controller. The reason for that is in the    
  33: 0000: \***    difference between the housekeeping logic, inctactis never    
  34: 0000: \***    considers a planner (POGID) as deactive and set the maximum   
  35: 0000: \***    end date (2199 year)instead it creates new fragments(POGDB)   
  36: 0000: \***    planner(POGID)and creates end date for it, which is mostly    
  37: 0000: \***    2 weeks. but in SRPOG file we have end date only for POGID    
  38: 0000: \***    and not POGDB, so when housekeeping logic runs, its never     
  39: 0000: \***    able to delete the expired records, so amended the code that  
  40: 0000: \***    instead of SRPOG, application takes SRMAP as the master file  
  41: 0000: \***    and started towards deletion to all4 files SRPOG,SRMOD,SRSXF  
  42: 0000: \***    and SRPDF.        
  43: 0000: \***    
  44: 0000: \***    B                RANJITH GOPALANKUTTY               23-11-2017
  45: 0000: \***    During AppsMgmt testing found that certain stores have more 
  46: 0000: \***    10000 records in SRMOD files and array would not handle it 
  47: 0000: \***    so increasing the array count from current 10000 to maximum
  48: 0000: \***    Also relinked the code with 17D file functions.
  49: 0000: \***                                            
  50: 0000: \***********************************************************************
  51: 0000: \***
  52: 0000: \***    Function globals
  53: 0000: \***
  54: 0000: \***********************************************************************
  55: 0000: 
  56: 0000: 
  57: 0000: %INCLUDE BEMFDEC.J86  
  58: 0000: \******************************************************************************
  59: 0000: \***
  60: 0000: \***	   %INCLUDE FOR BOOTS ERROR MESSAGE FILE - FIELD DECLARATIONS
  61: 0000: \***                                             - FILE REFERENCE PARAMETERS
  62: 0000: \***
  63: 0000: \***                         FILE TYPE : Direct
  64: 0000: \***
  65: 0000: \***                         REFERENCE : BEMFDEC
  66: 0000: \***
  67: 0000: \***	Version A               Mark Walker                  1st November 1993
  68: 0000: \***
  69: 0000: \******************************************************************************
  70: 0000: 
  71: 0000: 	STRING GLOBAL			BEMF.MESSAGE$,			\
  72: 0000: 					BEMF.FILE.NAME$
  73: 0000: 
  74: 0000: 	INTEGER*2 GLOBAL		BEMF.RECL%,			\
  75: 0000: 					BEMF.REPORT.NUM%,		\
  76: 0000: 					BEMF.SESS.NUM%
  77: 0000: 
  78: 0000: 	INTEGER*4 GLOBAL		BEMF.REC.NO%
  79: 0000: %INCLUDE BOOTSDEC.J86 
  80: 0000: \******************************************************************************
  81: 0000: \******************************************************************************
  82: 0000: \***
  83: 0000: \***
  84: 0000: \***
  85: 0000: \******************************************************************************
  86: 0000: 
  87: 0000: 
  88: 0000: %INCLUDE POGDEDEC.J86 
  89: 0000: \********************************************************************
  90: 0000: \***      EXTERNAL FUNCTION DECLARATIONS FOR THE POGDE FILE
  91: 0000: \***      REFERENCE : POGOKDEC.J86
  92: 0000: \***      Version A           Neil Bennett            6th June 2006
  93: 0000: \***
  94: 0000: \********************************************************************
  95: 0000: 
  96: 0000:   INTEGER*2 GLOBAL                \
  97: 0000:     POGDE.SESS.NUM%,              \
  98: 0000:     POGDE.REPORT.NUM%             !
  99: 0000: 
 100: 0000:   STRING GLOBAL                   \
 101: 0000:     POGDE.COPY.NAME$,             \
 102: 0000:     POGDE.FILE.NAME$,             \
 103: 0000:     POGDE.RCD$                    !
 104: 0000: %INCLUDE POGOKDEC.J86 
 105: 0000: \********************************************************************
 106: 0000: \***      EXTERNAL FUNCTION DECLARATIONS FOR THE POGOK FILE
 107: 0000: \***      REFERENCE : POGOKDEC.J86
 108: 0000: \***      Version A           Neil Bennett            6th June 2006
 109: 0000: \***
 110: 0000: \********************************************************************
 111: 0000: 
 112: 0000:   INTEGER*1 GLOBAL                \
 113: 0000:     POGOK.PE10.RETCODE%,          \
 114: 0000:     POGOK.PE5.RETCODE%,           \
 115: 0000:     POGOK.PE6.RETCODE%,           \
 116: 0000:     POGOK.PE7.RETCODE%,           \
 117: 0000:     POGOK.PE4.RETCODE%,           \
 118: 0000:     POGOK.PE19.RETCODE%           !
 119: 0000: 
 120: 0000:   INTEGER*2 GLOBAL                \
 121: 0000:     POGOK.DAYS.TO.RETAIN%,        \
 122: 0000:     POGOK.SESS.NUM%,              \
 123: 0000:     POGOK.REPORT.NUM%,            \
 124: 0000:     POGOK.RECL%                   !
 125: 0000: 
 126: 0000:   INTEGER*4 GLOBAL                \
 127: 0000:     POGOK.SRD.REC.COUNT%,         \
 128: 0000:     POGOK.SRM.REC.COUNT%
 129: 0000: 
 130: 0000:   STRING GLOBAL                   \
 131: 0000:     POGOK.FILE.NAME$,             \
 132: 0000:     POGOK.SRD.SER.NO$,            \
 133: 0000:     POGOK.SRM.SER.NO$,            \
 134: 0000:     POGOK.SRD.DATE$,              \
 135: 0000:     POGOK.SRM.DATE$,              \
 136: 0000:     POGOK.RELOAD$,                \
 137: 0000:     POGOK.PE10.RUNFLAG$,          \
 138: 0000:     POGOK.PE5.RUNFLAG$,           \
 139: 0000:     POGOK.PE6.RUNFLAG$,           \
 140: 0000:     POGOK.PE7.RUNFLAG$,           \
 141: 0000:     POGOK.PE4.RUNFLAG$,           \
 142: 0000:     POGOK.FAILED.SRD.SER.NO$,     \
 143: 0000:     POGOK.FAILED.SRD.DATE$,       \
 144: 0000:     POGOK.FAILED.SRM.SER.NO$,     \
 145: 0000:     POGOK.FAILED.SRM.DATE$,       \
 146: 0000:     POGOK.PE10.RUNDATE$,          \
 147: 0000:     POGOK.PE5.RUNDATE$,           \
 148: 0000:     POGOK.PE6.RUNDATE$,           \
 149: 0000:     POGOK.PE7.RUNDATE$,           \
 150: 0000:     POGOK.PE4.RUNDATE$,           \
 151: 0000:     POGOK.PE19.RUNFLAG$,          \
 152: 0000:     POGOK.PE19.RUNDATE$,          \
 153: 0000:     POGOK.FILLER$                 !
 154: 0000: %INCLUDE PSBF01G.J86  
 155: 0000: REM \
 156: 0000: \*******************************************************************************
 157: 0000: \*******************************************************************************
 158: 0000: \***
 159: 0000: \***       %INCLUDE FOR GLOBAL DEFINITIONS FOR FUNCTION APPLICATION.LOG
 160: 0000: \***
 161: 0000: \***                FUNCTION NUMBER    : PSBF01
 162: 0000: \***
 163: 0000: \***                REFERENCE          : PSBF01G.J86
 164: 0000: \***
 165: 0000: \***                DATE OF LAST AMENDMENT  - 27/2/86
 166: 0000: \***
 167: 0000: \***
 168: 0000: \*******************************************************************************
 169: 0000: 
 170: 0000:       INTEGER GLOBAL  F01.RETURN.CODE%
 171: 0000: 
 172: 0000: 
 173: 0000: %INCLUDE PSBF20G.J86 
 174: 0000: REM\
 175: 0000: \*******************************************************************************
 176: 0000: \*******************************************************************************
 177: 0000: \***
 178: 0000: \***     %INCLUDE GLOBAL VARIABLE DEFINITIONS FOR SESS.NUM.UTILITY FUNCTION
 179: 0000: \***
 180: 0000: \***                       REFERENCE     : PSBF20G.J86
 181: 0000: \*** 
 182: 0000: \***     Version A              Bruce Scrive                   5th May 1988   
 183: 0000: \*** 
 184: 0000: \***     Version B              Robert Cowey                   7th May 1991
 185: 0000: \***     Global variable F20.INTEGER.FILE.NO% changed from one byte integer
 186: 0000: \***     to two byte integer.
 187: 0000: \***
 188: 0000: \***     Version D              Andrew Wedgeworth             1st July 1992
 189: 0000: \***     F20.RETURN.CODE% removed as it is no longer required.
 190: 0000: \***
 191: 0000: \*******************************************************************************
 192: 0000: \*******************************************************************************
 193: 0000: 
 194: 0000:       STRING    GLOBAL F20.FILE.NAME$,                                 \
 195: 0000:                        F20.STRING.FILE.NO$,                            \
 196: 0000:                        F20.TABLE.DIMENSIONED.FLAG$,                    \
 197: 0000:                        SESS.NUM.TABLE$(1)
 198: 0000: 
 199: 0000:       INTEGER*2 GLOBAL F20.INTEGER.FILE.NO%
 200: 0000: 
 201: 0000:       ! 1 line deleted from here                                       ! DAW 
 202: 0000: 
 203: 0000: %INCLUDE SRMODDEC.J86 
 204: 0000: \********************************************************************
 205: 0000: \***      EXTERNAL FUNCTION DECLARATIONS FOR THE SRMOD FILE
 206: 0000: \***      REFERENCE : SRMODDEC.J86
 207: 0000: \***      Version A           Neil Bennett            5th June 2006
 208: 0000: \***
 209: 0000: \********************************************************************
 210: 0000: 
 211: 0000:   INTEGER*1 GLOBAL             \
 212: 0000:     SRMOD.FACINGS%(1),         \
 213: 0000:     SRMOD.MODULE.SEQ%,         \
 214: 0000:     SRMOD.RECORD.CHAIN%,       \
 215: 0000:     SRMOD.SHELF.NUM%(1)
 216: 0000: 
 217: 0000:   INTEGER*2 GLOBAL             \
 218: 0000:     SRMOD.ITEM.COUNT%,         \
 219: 0000:     SRMOD.MAX.ITEMS%,          \
 220: 0000:     SRMOD.MDQ%(1),             \
 221: 0000:     SRMOD.PSC%(1),             \
 222: 0000:     SRMOD.RECL%,               \
 223: 0000:     SRMOD.REPORT.NUM%,         \
 224: 0000:     SRMOD.SHELF.COUNT%,        \
 225: 0000:     SRMOD.SESS.NUM%
 226: 0000: 
 227: 0000:   INTEGER*4 GLOBAL             \
 228: 0000:     SRMOD.POGDB%
 229: 0000: 
 230: 0000:   STRING GLOBAL                \
 231: 0000:     SRMOD.ARRAY$,              \
 232: 0000:     SRMOD.COPY.NAME$,          \
 233: 0000:     SRMOD.DESCRIPTOR$,         \
 234: 0000:     SRMOD.FILE.NAME$,          \
 235: 0000:     SRMOD.ITEM.CODE$(1),       \
 236: 0000:     SRMOD.FILLER$
 237: 0000: %INCLUDE SRPDFDEC.J86 
 238: 0000: \********************************************************************
 239: 0000: \***      EXTERNAL FUNCTION DECLARATIONS FOR THE SRPDF FILE
 240: 0000: \***      REFERENCE : SRPDFDEC.J86
 241: 0000: \***      Version A           Neil Bennett          7th August 2006
 242: 0000: \***
 243: 0000: \********************************************************************
 244: 0000: 
 245: 0000:   INTEGER*2 GLOBAL        \
 246: 0000:     SRPDF.SESS.NUM%,      \
 247: 0000:     SRPDF.REPORT.NUM%,    \
 248: 0000:     SRPDF.RECL%           !
 249: 0000: 
 250: 0000:   INTEGER*4 GLOBAL        \
 251: 0000:     SRPDF.POGDB%          ! Unique POG Database key
 252: 0000: 
 253: 0000:   STRING GLOBAL           \
 254: 0000:     SRPDF.FILE.NAME$,     \ File name
 255: 0000:     SRPDF.SHRT.DESC$,     \ Medium descriptor (50)
 256: 0000:     SRPDF.FULL.DESC$,     \ Full descriptor (100)
 257: 0000:     SRPDF.FILLER$         !
 258: 0000: 
 259: 0000: 
 260: 0000: %INCLUDE SRPOGDEC.J86 
 261: 0000: \********************************************************************
 262: 0000: \***      EXTERNAL FUNCTION DECLARATIONS FOR THE SRPOG FILE
 263: 0000: \***      REFERENCE : SRPOGDEC.J86
 264: 0000: \***      Version A           Neil Bennett            5th June 2006
 265: 0000: \***
 266: 0000: \********************************************************************
 267: 0000: 
 268: 0000:   INTEGER*1 GLOBAL        \
 269: 0000:     SRPOG.MODULE.COUNT%,  \ Number of modules comprising POG
 270: 0000:     SRPOG.KEY.LEVEL%,     \ Family hierarchy key level
 271: 0000:     SRPOG.LIVE.RPT.CNT%,  \ Computed Live repeat count (Unset -1)
 272: 0000:     SRPOG.PEND.RPT.CNT%   ! Computed pending repeat count (Unset -1)
 273: 0000: 
 274: 0000:   INTEGER*2 GLOBAL        \
 275: 0000:     SRPOG.SESS.NUM%,      \
 276: 0000:     SRPOG.REPORT.NUM%,    \
 277: 0000:     SRPOG.RECL%           !
 278: 0000: 
 279: 0000:   INTEGER*4 GLOBAL        \
 280: 0000:     SRPOG.POGDB%,         \ Unique POG Database key
 281: 0000:     SRPOG.CAT.DBKEY%,     \ Family hierarchy key
 282: 0000:     SRPOG.CAT1.ID%,       \ hierarchy key
 283: 0000:     SRPOG.CAT2.ID%,       \ hierarchy key
 284: 0000:     SRPOG.CAT3.ID%,       \ hierarchy key
 285: 0000:     SRPOG.POGID%          ! POG Identifier
 286: 0000: 
 287: 0000:   STRING GLOBAL           \
 288: 0000:     SRPOG.FILE.NAME$,     \ File name
 289: 0000:     SRPOG.COPY.NAME$,     \ File name
 290: 0000:     SRPOG.ACT.DATE$,      \ Activation Date YYYY MM DD
 291: 0000:     SRPOG.DEACT.DATE$,    \ Deactivation Date YYYY MM DD
 292: 0000:     SRPOG.DESCRIPTION$,   \ Truncated POG description (30)
 293: 0000:     SRPOG.PLANNER.FAMILY$,\ Truncated Planner Family description (30)
 294: 0000:     SRPOG.DATE.RPT.CNT$,  \ Date repeat count is valid YYYY MM DD
 295: 0000:     SRPOG.FILLER$         !
 296: 0000: 
 297: 0000: 
 298: 0000: %INCLUDE SRSXFDEC.J86
 299: 0000: \********************************************************************
 300: 0000: \***      EXTERNAL FUNCTION DECLARATIONS FOR THE SRSXF FILE
 301: 0000: \***      REFERENCE : SRSXFDEC.J86
 302: 0000: \***      Version A           Neil Bennett          7th August 2006
 303: 0000: \***
 304: 0000: \********************************************************************
 305: 0000: 
 306: 0000:   INTEGER*1 GLOBAL        \
 307: 0000:     SRSXF.MODULE.SEQ%,    \
 308: 0000:     SRSXF.SHELF.NO%,      \
 309: 0000:     SRSXF.NOTCH.NO%       !
 310: 0000: 
 311: 0000:   INTEGER*2 GLOBAL        \
 312: 0000:     SRSXF.SESS.NUM%,      \
 313: 0000:     SRSXF.REPORT.NUM%,    \
 314: 0000:     SRSXF.RECL%           !
 315: 0000: 
 316: 0000:   INTEGER*4 GLOBAL        \
 317: 0000:     SRSXF.POGDB%,         \
 318: 0000:     SRSXF.SHELF.KEY%      !
 319: 0000: 
 320: 0000:   STRING GLOBAL           \
 321: 0000:     SRSXF.FILE.NAME$,     \ File name
 322: 0000:     SRSXF.SHELF.DESC$,    \
 323: 0000:     SRSXF.FILLER$         !
 324: 0000: 
 325: 0000: 
 326: 0000: %INCLUDE SRMAPDEC.J86                                                   !ARG
 327: 0000: \********************************************************************
 328: 0000: \***      EXTERNAL FUNCTION DECLARATIONS FOR THE SRMAP FILE
 329: 0000: \***      REFERENCE : SRMAPDEC.J86
 330: 0000: \***      Version A           Neil Bennett           14th June 2006
 331: 0000: \***
 332: 0000: \********************************************************************
 333: 0000: 
 334: 0000:   INTEGER*1 GLOBAL             \
 335: 0000:     SRMAP.CHAIN.SEQ%,          \
 336: 0000:     SRMAP.REPEAT.CNT%          !
 337: 0000: 
 338: 0000:   INTEGER*2 GLOBAL             \
 339: 0000:     SRMAP.SESS.NUM%,           \
 340: 0000:     SRMAP.REPORT.NUM%,         \
 341: 0000:     SRMAP.RECL%                !
 342: 0000: 
 343: 0000:   INTEGER*4 GLOBAL             \
 344: 0000:     SRMAP.POGDB%               !
 345: 0000: 
 346: 0000:   STRING GLOBAL                \
 347: 0000:     SRMAP.FILE.NAME$,          \
 348: 0000:     SRMAP.COPY.NAME$,          \
 349: 0000:     SRMAP.FRAG.SDATE$,         \
 350: 0000:     SRMAP.FRAG.EDATE$,         \
 351: 0000:     SRMAP.FILLER$              !
 352: 0000: 
 353: 0000: 
 354: 0000: 
 355: 0000: \***********************************************************************
 356: 0000: \*
 357: 0000: \*    Global variable definitions
 358: 0000: \*
 359: 0000: \***********************************************************************
 360: 0000: 
 361: 0000: STRING     GLOBAL        \
 362: 0000:      FILE.OPERATION$,    \
 363: 0000:      PINFO.TABLE$,       \
 364: 0000:      PASSED.STRING$,     \
 365: 0000:      SVC.PARAM$          
 366: 0000: 
 367: 0000: INTEGER*4  GLOBAL        \
 368: 0000:    ADX.FUNCTION%,        \
 369: 0000:    ADX.PARAM%,           \
 370: 0000:    CURRENT.REPORT.NUM%,  \
 371: 0000:    EVENT.NO%,            \
 372: 0000:    PASSED.INTEGER%,      \
 373: 0000:    RC%
 374: 0000:    
 375: 0000: \***********************************************************************
 376: 0000: \*
 377: 0000: \*    Local Variables
 378: 0000: \*
 379: 0000: \***********************************************************************
 380: 0000: 
 381: 0000: STRING                    \
 382: 0000:      ADX.COMMAND$,        \
 383: 0000:      COMM.TAIL$,          \
 384: 0000:      CURRENT.CODE$,       \
 385: 0000:      FLAG$,               \
 386: 0000:      FUNCTION.FLAG$,      \
 387: 0000:      OK.STRING$,          \
 388: 0000:      PROG.NAME$,          \
 389: 0000:      PHKEEP.OK.NAME$,     \
 390: 0000:      PHKEEP.LOG.NAME$,    \
 391: 0000:      RCD$,                \
 392: 0000:      SEC$,                \
 393: 0000:      SPACE$,              \
 394: 0000:      SRMAP.ARRAY$(1),     \
 395: 0000:      SRMOD.ARR$(1),       \
 396: 0000:      SRMAP.FLAG$,         \
 397: 0000:      SRMAP.STRING$,       \
 398: 0000:      SRMOD.DIR.NAME$,     \
 399: 0000:      SRMOD.NEW.FILE$,     \
 400: 0000:      SRPDF.ARRAY$(1),     \
 401: 0000:      SRPDF.DIR.NAME$,     \
 402: 0000:      SRPDF.KEY.NAME$,     \
 403: 0000:      SRMOD.KEY.NAME$,     \
 404: 0000:      SRPOG.ARRAY$(1),     \
 405: 0000:      SRPOG.DIR.NAME$,     \
 406: 0000:      SRPOG.FLAG$,         \
 407: 0000:      SRPOG.KEY.NAME$,     \
 408: 0000:      SRPOG.TEMP.NAME$,    \
 409: 0000:      SRSXF.FLAG$,         \
 410: 0000:      SRPOG.STRING$,       \
 411: 0000:      SRMOD.STRING$,       \
 412: 0000:      SRMOD.FLAG$,         \
 413: 0000:      SRSXF.STRING$,       \
 414: 0000:      SRSXF.DIR.NAME$,     \
 415: 0000:      SRSXF.KEY.NAME$,     \
 416: 0000:      SRPDF.STRING$,       \
 417: 0000:      SRPDF.FLAG$,         \
 418: 0000:      TEMP.FORM$,          \
 419: 0000:      VAR.STRING.1$,       \
 420: 0000:      VAR.STRING.2$
 421: 0000:                            
 422: 0000: INTEGER*4                 \
 423: 0000:      ADX.INTEGER%,        \
 424: 0000:      ARR.COUNT%,          \
 425: 0000:      I%,                  \
 426: 0000:      EOF%,                \
 427: 0000:      ERROR.CNT%,          \
 428: 0000:      K%,                  \
 429: 0000:      FOUND%,              \
 430: 0000:      FOUND1%,             \
 431: 0000:      J%,                  \
 432: 0000:      MESSAGE.NO%,         \
 433: 0000:      NOFILE.SRMOD.COUNT%, \
 434: 0000:      NOFILE.SRPDF.COUNT%, \
 435: 0000:      NOFILE.SRSXF.COUNT%, \
 436: 0000:      P%,                  \
 437: 0000:      PHKEEP.OK.SESS%,     \
 438: 0000:      PHKEEP.SESS.NUM%,    \
 439: 0000:      POGDB%,              \
 440: 0000:      RPS%,                \
 441: 0000:      RC1%,                \
 442: 0000:      SRMAP%,              \
 443: 0000:      SRMOD%,              \
 444: 0000:      SRMOD.DIR.SESS%,     \
 445: 0000:      SRPDF%,              \
 446: 0000:      SRPOG%,              \
 447: 0000:      SRSXF%,              \
 448: 0000:      SRPOG.COUNT%,        \
 449: 0000:      SRPDF.DIR.SESS%,     \
 450: 0000:      SRPOG.DIR.SESS%,     \
 451: 0000:      SRMOD.COUNT%,        \
 452: 0000:      SRPDF.COUNT%,        \
 453: 0000:      SRSXF.COUNT%,        \
 454: 0000:      SRSXF.DIR.SESS%,     \
 455: 0000:      TEMP.ARR%(1),         \
 456: 0000:      TEMP.COUNT%  
 457: 0000: 
 458: 0000: 
 459: 0000: 
 460: 0000: \***********************************************************************
 461: 0000: \*
 462: 0000: \*    Included code defining external Boots functions
 463: 0000: \*
 464: 0000: \***********************************************************************
 465: 0000:     
 466: 0000: %INCLUDE BEMFEXT.J86
 467: 0000: \******************************************************************************
 468: 0000: \***
 469: 0000: \***        EXTERNAL FUNCTION DEFINITIONS FOR THE ITEM REFERENCE FILE
 470: 0000: \***                                                            
 471: 0000: \***                        REFERENCE : BEMFEXT
 472: 0000: \***
 473: 0000: \***    Version A               Mark Walker                   1st November 1993
 474: 0000: \***
 475: 0000: \***    Version B       Stuart William McConnachie          25th September 2000
 476: 0000: \***    READ.BEMF function has got lost!
 477: 0000: \***
 478: 0000: \******************************************************************************
 479: 0000: 
 480: 0000:     FUNCTION BEMF.SET EXTERNAL
 481: 0000:     END FUNCTION
 482: 0000:     
 483: 0000:     FUNCTION READ.BEMF EXTERNAL
 484: 0000:     INTEGER*1 READ.BEMF
 485: 0000:     END FUNCTION
 486: 0000:     
 487: 0000:     
 488: 0000: %INCLUDE BASROUT.J86
 489: 0000: \*LIB   BVEJ BASROUT  J86      03/11/97 08:16:26 PIDBLD3  *    FIX
 490: 0000: \*PROM  BVEJ BASROUT  J86      03/10/97 17:18:40 PIDBLD3  MVEJ IR34352
 491: 0000: \*RTIME BVEJ BASROUT  J86      03/10/97 17:18:41 PIDBLD3  MVEJ IR34352
 492: 0000: \*LIB   MVEJ BASROUT  J86      03/05/97 10:48:46 EDJRAL   *    IR34352
 493: 0000: \*LIB   MVEJ BASROUT  J86      02/17/97 11:19:56 EDJRAL   *    REASONAR
 494: 0000: \*LIB   MVEJ BASROUT  J86      02/14/97 15:59:11 EDJRAL   *    REASONAR
 495: 0000: ! BASROUT.J86 - this file is to be included in any BASIC code which utilizes
 496: 0000: !   the BASROUT.OBJ routines.  These routines were written
 497: 0000: !  using Metaware C and are intended to provide functions which
 498: 0000: !         are either not available in 4680 CBASIC or which can be more
 499: 0000: !               efficiently handled by the C language.  Their usage is
 500: 0000: !  offered on an "AT YOUR OWN RISK" basis.
 501: 0000: !
 502: 0000: !               The insert/extract routines usefulness may not be immediately
 503: 0000: !               apparent.  Their intention is that they be used in conjunction
 504: 0000: !               with a read/write form command.  They can more efficiently
 505: 0000: !               parse a string into many different variables than can the
 506: 0000: !               read form statement.  So instead of a long list of data var's
 507: 0000: !               it may be more efficient to just read/write one long string
 508: 0000: !               and then use the insert/extract routines to parse out the
 509: 0000: !   data.
 510: 0000: 
 511: 0000: ! ******************* SUB PROCESS FUNCTIONS *********************************
 512: 0000: 
 513: 0000: function osshell(cmd.line$) external   ! routine to start
 514: 0000:        ! another program.
 515: 0000:            integer*4    osshell    ! Upon completion of
 516: 0000:            string       cmd.line$   ! program, control is
 517: 0000:        ! returned to calling
 518: 0000: end function      ! program.
 519: 0000: !
 520: 0000: ! NOTES:  Program must be a 286 type file.  This does not exclude
 521: 0000: !         the capability to execute a batch file however.  Simply pass the
 522: 0000: !         following:
 523: 0000: !              c:\adx_spgm\command.286 batfile
 524: 0000: !         where batfile is the name of the batch file to be executed.
 525: 0000: !
 526: 0000: ! IMPORTANT: When using osshell to execute a batch file as described above,
 527: 0000: !            the final command in the batch file must be "exit".  If not,
 528: 0000: !       control is never given back to the calling program.
 529: 0000: 
 530: 0000: ! ************************ MEMORY RELATED FUNCTIONS ************************
 531: 0000: 
 532: 0000: function memfree(choice) external   ! routine to que the
 533: 0000:        ! status of the
 534: 0000:  integer*4 memfree    ! machine's memory:
 535: 0000:  integer*2 choice    ! Options:
 536: 0000:        !    1 - free
 537: 0000: end function      !    2 - total
 538: 0000:        !    3 - system
 539: 0000: 
 540: 0000: ! ********************** TIMEDATE RELATED FUNCTIONS ************************
 541: 0000: 
 542: 0000: function timedate(choice) external   ! routine to que the
 543: 0000:        ! OS's timedate table
 544: 0000:  integer*4 timedate   ! Choices:
 545: 0000:  integer*2 choice    !    1 - millisec's
 546: 0000:        !        since midnight
 547: 0000: end function      !    2 - minutes from
 548: 0000:        !  UCT (timezone)
 549: 0000:        !    3 - day of week
 550: 0000:        !   0-Sunday
 551: 0000:        !  6-Saturday
 552: 0000: 
 553: 0000: function settime(msecs) external   ! routine to set the
 554: 0000:        ! time on the controller
 555: 0000:  integer*4  settime    ! msecs is the desired
 556: 0000:  integer*4 msecs    ! number of milliseconds
 557: 0000:        ! since midnight
 558: 0000: end function      ! Returns negative on
 559: 0000:        ! error
 560: 0000: ! NOTE:  This routine sets the time only on the controller.  The terminals'
 561: 0000: ! time will not be updated until 1 AM or unless a terminal is STC'd.
 562: 0000: ! At 1 AM the controller broadcasts the new time to all terminals.
 563: 0000: ! Insure this is taken into consideration when using this routine.
 564: 0000: 
 565: 0000: !******************** DISK FILE RELATED FUNCTIONS *************************
 566: 0000: 
 567: 0000: function truncate(name,length) external   ! routine to truncate
 568: 0000:        ! the specified file
 569: 0000:  integer*4 truncate   ! to a given length.
 570: 0000:  string  name
 571: 0000:  integer*4 length
 572: 0000: 
 573: 0000: end function
 574: 0000: 
 575: 0000: !******************** STRING VALUE RELATED FUNCTIONS **********************
 576: 0000: 
 577: 0000: function isalpha(bstrn) external   ! routine to identify
 578: 0000:        ! if the specified
 579: 0000:  integer*1 isalpha    ! string contains all
 580: 0000:  string  bstrn    ! alphabetic char's
 581: 0000:        ! Returns:
 582: 0000: end function      !     0 - all alpha
 583: 0000:        !     X - byte of 1st
 584: 0000:        !         non-alpha
 585: 0000:        !   char
 586: 0000: 
 587: 0000: function isdigit(bstrn) external   ! routine to identify
 588: 0000:        ! if the specified
 589: 0000:  integer*1 isdigit    ! string contains all
 590: 0000:  string  bstrn    ! numeric char's
 591: 0000:        ! Returns:
 592: 0000: end function      !     0 - all numeric
 593: 0000:        !     X - byte of 1st
 594: 0000:        !         non-numeric
 595: 0000:        !   char
 596: 0000: 
 597: 0000: function islower(bstrn) external   ! routine to identify
 598: 0000:        ! if the specified
 599: 0000:  integer*1 islower    ! string contains all
 600: 0000:  string  bstrn    ! lower case char's
 601: 0000:        ! Returns:
 602: 0000: end function      !     0 - all lowercase
 603: 0000:        !     X - byte of 1st
 604: 0000:        !         non-lowercase
 605: 0000:        !   char
 606: 0000: 
 607: 0000: function isupper(bstrn) external   ! routine to identify
 608: 0000:        ! if the specified
 609: 0000:  integer*1 isupper    ! string contains all
 610: 0000:  string  bstrn    ! upper case char's
 611: 0000:        ! Returns:
 612: 0000: end function      !     0 - all uppercase
 613: 0000:        !     X - byte of 1st
 614: 0000:        !         non-uppercase
 615: 0000:        !   char
 616: 0000: 
 617: 0000: function toalpha(bstrn) external   ! routine to convert
 618: 0000:        ! non-alpha or non-num
 619: 0000:    integer*2 toalpha    ! char's to spaces
 620: 0000:  string  bstrn    ! Returns:
 621: 0000: end function      !   x - no. of char's
 622: 0000:        !       changed
 623: 0000: 
 624: 0000: ! ********************* USER/GROUP ZERO LEVEL FUNCTIONS *********************
 625: 0000: 
 626: 0000: function idlecount(choice) external   ! routine to either
 627: 0000:        ! set to zero or queue
 628: 0000:  integer*4 idlecount   ! the value of the
 629: 0000:  integer*1 choice    ! processor's idlecount
 630: 0000:        ! Choice:
 631: 0000: end function      !     0 - set to zero
 632: 0000: !       !     1 - get value
 633: 0000: ! NEEDS USER/GROUP 0 LEVEL OF AUTHORIZATION  ! Returns:
 634: 0000: ! TO WORK - This level is not available unless  !     X - idlecount
 635: 0000: ! the file ADXCSOUF.DAT file is "patched".  This !    -X - error code
 636: 0000: ! is highly unrecommended.
 637: 0000: 
 638: 0000: function logical(actname,logname,choice) external ! routine to set a
 639: 0000:        ! a logical name.
 640: 0000:  integer*4 logical    ! parms are self
 641: 0000:         string  logname    ! explanatory except
 642: 0000:  string  actname    ! for choice:
 643: 0000:  integer*1 choice    !   0 - set process
 644: 0000:        !   1 - set system
 645: 0000: end function      !   2 - get process
 646: 0000:        !   3 - get system
 647: 0000: 
 648: 0000: ! NOTE:  Only the setting of a system level of logical name requires
 649: 0000: ! user/group zero level of authorization.  Any application may query any
 650: 0000: ! logical name.  Setting of a system logical name is only applicable until
 651: 0000: ! the system is IPL'd.  A process logical name is only active when that
 652: 0000: ! process is active.
 653: 0000: 
 654: 0000: !******************** STRING PARSING FUNCTIONS *****************************
 655: 0000: 
 656: 0000: function inserts(whole,part,offset) external  ! routine to insert a
 657: 0000:        ! string (part) into
 658: 0000:  integer*2 INSERTS    ! another string (whole)
 659: 0000:  string  whole    ! starting at specified
 660: 0000:  string  part    ! character (offset)
 661: 0000:  integer*2 offset
 662: 0000: 
 663: 0000: end function
 664: 0000: 
 665: 0000: function cinsert4(integer4,bstring,offset) external   ! routine to insert
 666: 0000:        ! a 4-byte integer into
 667: 0000:  integer*1 cinsert4   ! a string starting at
 668: 0000:  integer*4 integer4   ! byte specified by
 669: 0000:  string  bstring    ! offset (1-based)
 670: 0000:  integer*2 offset    ! Returns:
 671: 0000:        !     0 - Success
 672: 0000: end function      !    -1 - String overrun
 673: 0000: 
 674: 0000: function cinsert2(integer2,bstring,offset) external  ! routine to insert
 675: 0000:        ! a 2-byte integer into
 676: 0000:  integer*1 cinsert2   ! a string starting at
 677: 0000:  integer*2 integer2   ! byte specified by
 678: 0000:  string  bstring    ! offset (1-based)
 679: 0000:  integer*2 offset    ! Returns:
 680: 0000:        !     0 - Success
 681: 0000: end function      !    -1 - String overrun
 682: 0000: 
 683: 0000: function cinsert1(bstring,integer1,offset) external  ! routine to insert
 684: 0000:        ! a 1-byte integer into
 685: 0000:  integer*1 cinsert1   ! a string starting at
 686: 0000:  integer*1 integer1   ! byte specified by
 687: 0000:  string  bstring    ! offset (1-based)
 688: 0000:  integer*2 offset    ! Returns:
 689: 0000:        !     0 - Success
 690: 0000: end function      !    -1 - String overrun
 691: 0000: 
 692: 0000: function extracts(whole,part,offset) external  ! routine to extract a
 693: 0000:        ! string (part) from
 694: 0000:  integer*2 EXTRACTS   ! another string (whole)
 695: 0000:  string  whole    ! starting at specified
 696: 0000:  string  part    ! character (offset)
 697: 0000:  integer*2 offset
 698: 0000: 
 699: 0000: end function
 700: 0000: 
 701: 0000: function cextract4(bstring,offset) external  ! routine to extract
 702: 0000:        ! a 4-byte integer from
 703: 0000:  integer*4 cextract4   ! a string starting at
 704: 0000:                        ! byte specified by
 705: 0000:  string  bstring    ! offset (1-based)
 706: 0000:  integer*2 offset    ! Returns:
 707: 0000:        !     X - 4 byte integer
 708: 0000: end function      !    -1 - String overrun
 709: 0000: 
 710: 0000: function cextract2(bstring,offset) external  ! routine to extract
 711: 0000:        ! a 2-byte integer from
 712: 0000:  integer*2 cextract2   ! a string starting at
 713: 0000:                        ! byte specified by
 714: 0000:  string  bstring    ! offset (1-based)
 715: 0000:  integer*2 offset    ! Returns:
 716: 0000:        !     X - 2 byte integer
 717: 0000: end function      !    -1 - String overrun
 718: 0000: 
 719: 0000: function cextract1(bstring,offset) external  ! routine to extract
 720: 0000:        ! a 1-byte integer from
 721: 0000:  integer*1 cextract1   ! a string starting at
 722: 0000:                        ! byte specified by
 723: 0000:  string  bstring    ! offset (1-based)
 724: 0000:  integer*2 offset    ! Returns:
 725: 0000:        !     X - 1 byte integer
 726: 0000: end function      !    -1 - String overrun
 727: 0000: 
 728: 0000: 
 729: 0000: function srchdir (file.name$,dtbl.buffer$) external ! routine to return
 730: 0000:        ! file names and sizes
 731: 0000:        ! Return values:
 732: 0000:        !    -1  no matches
 733: 0000:        !        found on first
 734: 0000:        !        call
 735: 0000:        !    0   no matches
 736: 0000:        !        found on sub-
 737: 0000:        !        sequent calls
 738: 0000:        !    Pos Success
 739: 0000:        !    Neg OS Rtn Code
 740: 0000: ! Usage Note:  If searching for all occurences of a particular file name,
 741: 0000: ! first initialize dtbl.buffer$ to 48 Nulls (pack$("00")) and issue a call
 742: 0000: ! to srchdir.  If any matches are found, a positive value will be returned.
 743: 0000: ! To see if any more matches exist, just issue another call to srchdir without
 744: 0000: ! resetting the values of dtbl.buffer$.  If any are found, a positive value
 745: 0000: ! will be returned.  This can be repeated until a Zero is returned.  All data
 746: 0000: ! describing file will be returned in the dtbl.buffer$ after each call.  Format
 747: 0000: ! of this data is defined below.
 748: 0000: 
 749: 0000:  integer*4 srchdir
 750: 0000: 
 751: 0000:  string  file.name$   ! file name to start
 752: 0000:        ! search (18 bytes max)
 753: 0000:        ! Wild cards and logical
 754: 0000:        ! names supported.
 755: 0000: 
 756: 0000:  string  dtbl.buffer$   ! must be initialized
 757: 0000:        ! to 48 bytes.  Contains
 758: 0000:        ! all of directory info
 759: 0000:        ! Initialize to nulls
 760: 0000:        ! each time a new file
 761: 0000:        ! name is used.
 762: 0000: 
 763: 0000: ! NOTE:  Format of dtbl.buffer$ string is as follows:
 764: 0000: !
 765: 0000: ! Offs  Type                    Description Notes
 766: 0000: !  0 integer*4  key  use extract4 to access
 767: 0000: !  4  string (18 bytes) file name
 768: 0000: ! 22 integer*2  attributes use extract2 to access
 769: 0000: !      0x01 - Read Only
 770: 0000: !      0x02 - Hidden
 771: 0000: !      0x04 - System
 772: 0000: !      0x08 - Volume Label
 773: 0000: !      0x10 - Subdirectory
 774: 0000: !      0x20 - Archive (Files)
 775: 0000: !      0x40 - Security enabled
 776: 0000: !      0x80 - Reserved
 777: 0000: !      0x0000 - Local
 778: 0000: !      0x4000 - Mirrored/Update
 779: 0000: !      0xC000 - Mirrored/Close
 780: 0000: !
 781: 0000: !      0x6000 - Compound/Update
 782: 0000: !      0xE000 - Compound/Close
 783: 0000: ! 24 integer*2  record size use extract2 to access
 784: 0000: ! 26 integer*1  User ID of Owner
 785: 0000: ! 27 integer*1  Group ID of Owner
 786: 0000: ! 28 integer*2  File Security
 787: 0000: ! 30 string (6 bytes) Reserved
 788: 0000: ! 36 integer*4  File Size use extract4 to access
 789: 0000: ! 40 integer*2  Year  use extract2 to access
 790: 0000: ! 42 integer*1  Month
 791: 0000: ! 43 integer*1  Day
 792: 0000: ! 44 integer*1  Hour
 793: 0000: ! 45 integer*1  Minute
 794: 0000: ! 46 integer*1  Second
 795: 0000: ! 47 integer*1  Reserved
 796: 0000: 
 797: 0000: end function
 798: 0000: 
 799: 0000: function srchproc (proc.name$,ptbl.buffer$) external ! routine to return
 800: 0000:        ! process names and
 801: 0000:        ! status.  Handy to
 802: 0000:        ! determine if a
 803: 0000:        ! program is currently
 804: 0000:        ! running.
 805: 0000:        ! Return values:
 806: 0000:        !    -1  no matches
 807: 0000:        !        found on first
 808: 0000:        !        call
 809: 0000:        !    0   no matches
 810: 0000:        !        found on sub-
 811: 0000:        !        sequent calls
 812: 0000:        !    Pos Success
 813: 0000:        !    Neg Failure
 814: 0000:        !        OS Rtn Code
 815: 0000:        ! 80000001h - Insuff
 816: 0000:         !        ptbl buffer
 817: 0000:        !        Length
 818: 0000: ! Usage Note:  If searching for all occurences of a particular process name,
 819: 0000: ! first initialize ptbl.buffer$ to 60 Nulls (pack$("00")) and issue a call
 820: 0000: ! to srchproc.  If any matches are found, a positive value will be returned.
 821: 0000: ! To see if any more matches exist, just issue another call to srchproc without
 822: 0000: ! resetting the values of ptbl.buffer$.  If any are found, a positive value
 823: 0000: ! will be returned.  This can be repeated until a Zero is returned.  All data
 824: 0000: ! describing file will be returned in the ptbl.buffer$ after each call.  Format
 825: 0000: ! of this data is defined as follows:
 826: 0000: !
 827: 0000: !       --------------------------------------------------------
 828: 0000: !   0   |                         PID                          |
 829: 0000: !       --------------------------------------------------------
 830: 0000: !   4   |           FID             |   CID        |   VCID    |
 831: 0000: !       --------------------------------------------------------
 832: 0000: !   8   |                         NAME                         |
 833: 0000: !       --------------------------------------------------------
 834: 0000: !  12   |                         NAME cont'd                  |
 835: 0000: !       --------------------------------------------------------
 836: 0000: !  16   |       NAME cont'd         |   STATE      |  PRIOR    |
 837: 0000: !       --------------------------------------------------------
 838: 0000: !  20   |                         MAXMEM                       |
 839: 0000: !       --------------------------------------------------------
 840: 0000: !  24   |       FLAGS               |   USER        |  GROUP   |
 841: 0000: !       --------------------------------------------------------
 842: 0000: !  28   |                         PARENT                       |
 843: 0000: !       --------------------------------------------------------
 844: 0000: !  32   |                         EVENTS                       |
 845: 0000: !       --------------------------------------------------------
 846: 0000: !  36   |                         CODE                         |
 847: 0000: !       --------------------------------------------------------
 848: 0000: !  40   |                         CSIZE                        |
 849: 0000: !       --------------------------------------------------------
 850: 0000: !  44   |                         DATA                         |
 851: 0000: !       --------------------------------------------------------
 852: 0000: !  48   |                         DSIZE                        |
 853: 0000: !       --------------------------------------------------------
 854: 0000: !  52   |                         HEAP                         |
 855: 0000: !       --------------------------------------------------------
 856: 0000: !  56   |                         HSIZE                        |
 857: 0000: !       --------------------------------------------------------
 858: 0000: !
 859: 0000: !       PID   Process ID
 860: 0000: !       FID  Process's Family ID
 861: 0000: !       CID   Physical Console Device Number
 862: 0000: !       VCID  Process's Virtual Console Number
 863: 0000: !       NAME  Process Name (Application Running)
 864: 0000: ! STATE    Process State (0-Run, 1-Waiting, 2-Terminating)
 865: 0000: ! PRIOR    Priority
 866: 0000: !       MAXMEM  Maximum Memory Allowed
 867: 0000: !       FLAGS  Bit 0 (1-System Process, 0-User Process)
 868: 0000: !   Bit 1 (1-Locked in Memory, 0-Swappable)
 869: 0000: !   Bit 2 (1-Running in SWI context, 0-Running in main context)
 870: 0000: !   Bit 3 (1-Superuser Process,0-Not a Superuser Process)
 871: 0000: ! USER  User Number
 872: 0000: ! GROUP  Group Number
 873: 0000: !       PARENT   Parent Process ID
 874: 0000: !       EVENTS   Bit Map of events that have completed but not retrieved
 875: 0000: !       CODE  Start of code area in user space
 876: 0000: ! CSIZE  Size in bytes of code area
 877: 0000: !       DATA  Start of data area in user space
 878: 0000: ! DSIZE  Size in bytes of data area
 879: 0000: !       HEAP  Start of heap area in user space
 880: 0000: ! HSIZE  Size in bytes of heap area
 881: 0000: !
 882: 0000:  integer*4 srchproc
 883: 0000: 
 884: 0000:  string  proc.name$   ! process name to start
 885: 0000:        ! search (10 bytes max)
 886: 0000:        ! Wild cards and logical
 887: 0000:        ! names supported.
 888: 0000: 
 889: 0000:  string  ptbl.buffer$   ! must be initialized
 890: 0000:        ! to 60 bytes.  Contains
 891: 0000:        ! all of process info
 892: 0000:        ! Initialize to nulls
 893: 0000:        ! each time a new
 894: 0000:        ! process name is used.
 895: 0000: 
 896: 0000: end function
 897: 0000: 
 898: 0000: function cconstat(timeout) external       ! function similar
 899: 0000:                                               ! to BASIC constat%
 900: 0000:  integer*2 cconstat   ! waits for either a
 901: 0000:  integer*4 timeout    ! key being hit or
 902: 0000:        ! the timer expiring
 903: 0000:        ! before returning
 904: 0000:        ! returns:
 905: 0000:        !   -1 error
 906: 0000:        !    0 timer expired
 907: 0000:        !    x scan code of
 908: 0000:        !      key hit
 909: 0000: end function
 910: 0000: 
 911: 0000: function disksize(disk.name$) external   ! function to find
 912: 0000:        ! the total size of
 913: 0000:  integer*4 disksize   ! the specified disk
 914: 0000:  string  disk.name$   ! name (e.g. "h0:")
 915: 0000:        ! if return value is
 916: 0000:        ! negative, error
 917: 0000: end function      ! was received
 918: 0000: 
 919: 0000: 
 920: 0000: %INCLUDE BOOTSEXT.J86
 921: 0000: \******************************************************************************
 922: 0000: \******************************************************************************
 923: 0000: SUB LOG.ERROR(F.1$) EXTERNAL
 924: 0000:     STRING  F.1$
 925: 0000: END SUB
 926: 0000: 
 927: 0000: \******************************************************************************
 928: 0000: \******************************************************************************
 929: 0000: FUNCTION FORCE.CASE$(DATA$,TYPE%) EXTERNAL
 930: 0000:     STRING      FORCE.CASE$
 931: 0000:     STRING      DATA$
 932: 0000:     INTEGER*2   TYPE%
 933: 0000:     STRING      IN$, OUT$
 934: 0000:     STRING      LWR$, UPR$
 935: 0000: END FUNCTION
 936: 0000: 
 937: 0000: \******************************************************************************
 938: 0000: \******************************************************************************
 939: 0000: FUNCTION REMOVE.CHARACTER$(DATA$,F.CHR$) EXTERNAL
 940: 0000:     STRING      DATA$
 941: 0000:     STRING      F.CHR$
 942: 0000:     STRING      REMOVE.CHARACTER$
 943: 0000:     INTEGER*2   START%
 944: 0000:     INTEGER*2   END%
 945: 0000:     INTEGER*2   POS%
 946: 0000:     INTEGER*2   F.LEN%
 947: 0000: END FUNCTION
 948: 0000: 
 949: 0000: \******************************************************************************
 950: 0000: \******************************************************************************
 951: 0000: FUNCTION REMOVE.SPACES$(DATA$) EXTERNAL
 952: 0000:     STRING      DATA$
 953: 0000:     STRING      REMOVE.SPACES$
 954: 0000:     INTEGER*2   START%
 955: 0000:     INTEGER*2   END%
 956: 0000:     INTEGER*2   POS%
 957: 0000: END FUNCTION
 958: 0000: 
 959: 0000: \*******************************************************************************
 960: 0000: \***
 961: 0000: \***    FUNCTION     :    TIME.STAMP$
 962: 0000: \***    
 963: 0000: \***    Returns a string with formatted date and/or time detail
 964: 0000: \***                 Passed values are 1 = Date, 2 = Time
 965: 0000: \*******************************************************************************
 966: 0000: FUNCTION TIME.STAMP$(F.TYPE%) EXTERNAL
 967: 0000:     STRING      TIME.STAMP$
 968: 0000:     INTEGER*2   F.TYPE%
 969: 0000:     STRING      F.DT$
 970: 0000:     STRING      F.RET$
 971: 0000: END FUNCTION
 972: 0000: \*******************************************************************************
 973: 0000: 
 974: 0000: 
 975: 0000: \*******************************************************************************
 976: 0000: \*******************************************************************************
 977: 0000: FUNCTION PRINT.MSG$(MSG$,F%,L%) EXTERNAL
 978: 0000: STRING      PRINT.MSG$
 979: 0000: STRING      MSG$
 980: 0000: INTEGER*2   F%
 981: 0000: INTEGER*2   L%
 982: 0000: STRING      IN$
 983: 0000: STRING      F.FORM$
 984: 0000: END FUNCTION
 985: 0000: \*******************************************************************************
 986: 0000: 
 987: 0000: \*******************************************************************************
 988: 0000: \***
 989: 0000: \***    SUBROUTINE     :    BACKGROUND.MSG(B.MSG$)
 990: 0000: \***    
 991: 0000: \***    Displays passed message to the background message.
 992: 0000: \*******************************************************************************
 993: 0000: SUB BACKGROUND.MSG(B.MSG$) EXTERNAL
 994: 0000:     STRING      B.MSG$
 995: 0000:     INTEGER*4   B.RET%
 996: 0000: END SUB
 997: 0000: \*******************************************************************************
 998: 0000: 
 999: 0000: !*****************************************************************************!
1000: 0000: !***                                                                          !
1001: 0000: !*** SUBROUTINE :   NO.OPEN.FILE                                              !
1002: 0000: !***                    F.REPORT%       - Passed report number for logging    !
1003: 0000: !***                    F.OPEN.FLAG$    - Returned flag for not-opened        !
1004: 0000: !***                                                                          !
1005: 0000: !*** This subroutine logs an application 106 error with the passed report     !
1006: 0000: !*** number. It also sets a return variable to "N" to flag that the file is   !
1007: 0000: !*** not Open because of the failure.                                         !
1008: 0000: !***                                                                          !
1009: 0000: !*****************************************************************************!
1010: 0000: SUB NO.OPEN.FILE(F.REPORT%,F.OPEN.FLAG$) EXTERNAL                                      
1011: 0000:     INTEGER*2   F.REPORT%                                                         
1012: 0000:     STRING      F.OPEN.FLAG$                                                      
1013: 0000:     STRING      F.1$, F.2$
1014: 0000:     INTEGER*2   F.EVENT%
1015: 0000: END SUB                                                                       
1016: 0000: !*****************************************************************************!
1017: 0000: 
1018: 0000: 
1019: 0000: FUNCTION NUMBER.OF.DAYS%(START$,END$) EXTERNAL
1020: 0000: INTEGER*2   NUMBER.OF.DAYS%
1021: 0000: STRING      START$
1022: 0000: STRING      END$
1023: 0000: INTEGER*2   F.DAYS%
1024: 0000: INTEGER*4   S.DAYS%
1025: 0000: INTEGER*4   E.DAYS%
1026: 0000: END FUNCTION
1027: 0000: 
1028: 0000: FUNCTION HEX.FORMAT$(F.DATA$) EXTERNAL
1029: 0000: STRING  HEX.FORMAT$
1030: 0000: STRING  F.DATA$
1031: 0000: STRING      F.RET$
1032: 0000: INTEGER*2   F.LEN%
1033: 0000: STRING      F.TMP$(2)
1034: 0000: STRING      F.FORM$
1035: 0000: STRING      F.ASCII$
1036: 0000: STRING      F.ASC$
1037: 0000: STRING      F.HEX$
1038: 0000: STRING      F.WORK$, F.W2$
1039: 0000: INTEGER*2   F.LOOP%, F.L2%
1040: 0000: END FUNCTION
1041: 0000: 
1042: 0000: FUNCTION FORMAT.NUMBER$(F.NUM$,F.DEC%) EXTERNAL
1043: 0000: STRING      FORMAT.NUMBER$
1044: 0000: STRING      F.NUM$
1045: 0000: INTEGER*2   F.DEC%
1046: 0000: INTEGER*4   F.NUM%
1047: 0000: END FUNCTION
1048: 0000: 
1049: 0000: \*******************************************************************************
1050: 0000: FUNCTION FORMAT.BOOTS.CODE$(F.CODE$) EXTERNAL
1051: 0000: STRING  FORMAT.BOOTS.CODE$
1052: 0000: STRING  F.CODE$
1053: 0000: END FUNCTION
1054: 0000: 
1055: 0000: FUNCTION FORMAT.STRING$(F.STRING$,F.L%,F.P$,F.J%) EXTERNAL
1056: 0000: STRING    FORMAT.STRING$
1057: 0000: STRING    F.STRING$
1058: 0000: INTEGER*2 F.L%
1059: 0000: STRING    F.P$
1060: 0000: INTEGER*2 F.J%
1061: 0000: END FUNCTION
1062: 0000: 
1063: 0000: SUB GET.BLOCK.SIZE(F.BLOCK.SIZE%,F.FILENAME$,F.SIZE%) EXTERNAL
1064: 0000: INTEGER*4   F.BLOCK.SIZE%
1065: 0000: STRING      F.FILENAME$
1066: 0000: INTEGER*4   F.SIZE%
1067: 0000: INTEGER*4   F.BLOCK%
1068: 0000: INTEGER*2   F.SECTOR%
1069: 0000: INTEGER*2   F.LOOP%
1070: 0000: STRING      F.BLOCK.LENGTH$
1071: 0000: END SUB
1072: 0000: %INCLUDE BTCMEM.J86
1073: 0000: !********************************************************************
1074: 0000: !***
1075: 0000: !***    INCLUDED CODE:  BTCMEM.J86
1076: 0000: !***    AUTHOR:         Stuart William McConnachie
1077: 0000: !***    DATE:           26th February 2006
1078: 0000: !***
1079: 0000: !********************************************************************
1080: 0000: !***
1081: 0000: !***    Controller CBASIC Memory Functions
1082: 0000: !***
1083: 0000: !********************************************************************
1084: 0000: 
1085: 0000: !Get a single byte integer from a string offset
1086: 0000: FUNCTION GETN1 (S$, P%) EXTERNAL
1087: 0000:     STRING S$
1088: 0000:     INTEGER*2 P%
1089: 0000:     INTEGER*2 GETN1
1090: 0000: END FUNCTION
1091: 0000: 
1092: 0000: !Get a two byte integer from a string offset
1093: 0000: FUNCTION GETN2 (S$, P%) EXTERNAL
1094: 0000:     STRING S$
1095: 0000:     INTEGER*2 P%
1096: 0000:     INTEGER*2 GETN2
1097: 0000: END FUNCTION
1098: 0000: 
1099: 0000: !Get a four byte integer from a string offset
1100: 0000: FUNCTION GETN4 (S$, P%) EXTERNAL
1101: 0000:     STRING S$
1102: 0000:     INTEGER*2 P%
1103: 0000:     INTEGER*4 GETN4
1104: 0000: END FUNCTION
1105: 0000: 
1106: 0000: !Get a 10 byte CBASIC real from a string offset
1107: 0000: FUNCTION GETR10 (S$, P%) EXTERNAL
1108: 0000:     STRING S$
1109: 0000:     INTEGER*2 P%
1110: 0000:     REAL GETR10
1111: 0000: END FUNCTION
1112: 0000: 
1113: 0000: !Put a single byte integer into a string at offset
1114: 0000: FUNCTION PUTN1 (S$, P%, N%) EXTERNAL
1115: 0000:     STRING S$
1116: 0000:     INTEGER*2 P%
1117: 0000:     INTEGER*1 N%
1118: 0000:     INTEGER*1 PUTN1
1119: 0000: END FUNCTION
1120: 0000: 
1121: 0000: !Put a two byte integer into a string at offset
1122: 0000: FUNCTION PUTN2 (S$, P%, N%) EXTERNAL
1123: 0000:     STRING S$
1124: 0000:     INTEGER*2 P%
1125: 0000:     INTEGER*2 N%
1126: 0000:     INTEGER*1 PUTN2
1127: 0000: END FUNCTION
1128: 0000: 
1129: 0000: !Put a four byte integer into a string at offset
1130: 0000: FUNCTION PUTN4 (S$, P%, N%) EXTERNAL
1131: 0000:     STRING S$
1132: 0000:     INTEGER*2 P%
1133: 0000:     INTEGER*4 N%
1134: 0000:     INTEGER*1 PUTN4
1135: 0000: END FUNCTION
1136: 0000: 
1137: 0000: !Put a 10 byte CBASIC real into a string at offset
1138: 0000: FUNCTION PUTR10 (S$, P%, R) EXTERNAL
1139: 0000:     STRING S$
1140: 0000:     INTEGER*2 P%
1141: 0000:     REAL R
1142: 0000:     INTEGER*1 PUTR10
1143: 0000: END FUNCTION
1144: 0000: 
1145: 0000: !Peek a two byte integer from a memory address
1146: 0000: FUNCTION PEEKN2 (A%) EXTERNAL
1147: 0000:     INTEGER*4 A%
1148: 0000:     INTEGER*2 PEEKN2
1149: 0000: END FUNCTION
1150: 0000: 
1151: 0000: !Peek a four byte integer from a memory address
1152: 0000: FUNCTION PEEKN4 (A%) EXTERNAL
1153: 0000:     INTEGER*4 A%
1154: 0000:     INTEGER*4 PEEKN4
1155: 0000: END FUNCTION
1156: 0000: 
1157: 0000: !Peek a 10 byte CBASIC real from a memory address
1158: 0000: FUNCTION PEEKR10 (A%) EXTERNAL
1159: 0000:     INTEGER*4 A%
1160: 0000:     REAL PEEKR10
1161: 0000: END FUNCTION
1162: 0000: 
1163: 0000: !Poke a two byte integer to a memory address
1164: 0000: FUNCTION POKEN2 (A%, N%) EXTERNAL
1165: 0000:     INTEGER*4 A%
1166: 0000:     INTEGER*2 N%
1167: 0000:     INTEGER*1 POKEN2
1168: 0000: END FUNCTION
1169: 0000: 
1170: 0000: !Poke a four byte integer to a memory address
1171: 0000: FUNCTION POKEN4 (A%, N%) EXTERNAL
1172: 0000:     INTEGER*4 A%
1173: 0000:     INTEGER*4 N%
1174: 0000:     INTEGER*1 POKEN4
1175: 0000: END FUNCTION
1176: 0000: 
1177: 0000: !Poke a 10 byte CBASIC real to a memory address
1178: 0000: FUNCTION POKER10 (A%, R) EXTERNAL
1179: 0000:     INTEGER*4 A%
1180: 0000:     REAL R
1181: 0000:     INTEGER*1 POKER10
1182: 0000: END FUNCTION
1183: 0000: 
1184: 0000: %INCLUDE POGDEEXT.J86
1185: 0000: \********************************************************************
1186: 0000: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE POGDE FILE
1187: 0000: \***      REFERENCE : POGDEEXT.J86
1188: 0000: \***      Version A           Neil Bennett            8th June 2006
1189: 0000: \***
1190: 0000: \********************************************************************
1191: 0000: 
1192: 0000:        FUNCTION POGDE.SET EXTERNAL
1193: 0000:        END FUNCTION
1194: 0000: 
1195: 0000:        FUNCTION READ.POGDE EXTERNAL
1196: 0000:           INTEGER*2 READ.POGDE
1197: 0000:        END FUNCTION
1198: 0000: %INCLUDE POGOKEXT.J86
1199: 0000: \********************************************************************
1200: 0000: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE POGOK FILE
1201: 0000: \***      REFERENCE : POGOKEXT.J86
1202: 0000: \***      Version A           Neil Bennett            6th June 2006
1203: 0000: \***
1204: 0000: \********************************************************************
1205: 0000: 
1206: 0000:        FUNCTION POGOK.SET EXTERNAL
1207: 0000:        END FUNCTION
1208: 0000: 
1209: 0000:        FUNCTION READ.POGOK EXTERNAL
1210: 0000:           INTEGER*2 READ.POGOK
1211: 0000:        END FUNCTION
1212: 0000: 
1213: 0000:        FUNCTION READ.POGOK.LOCK EXTERNAL
1214: 0000:           INTEGER*2 READ.POGOK.LOCK
1215: 0000:        END FUNCTION
1216: 0000: 
1217: 0000:        FUNCTION WRITE.POGOK EXTERNAL
1218: 0000:           INTEGER*2 WRITE.POGOK
1219: 0000:        END FUNCTION
1220: 0000: 
1221: 0000:        FUNCTION WRITE.POGOK.UNLOCK EXTERNAL
1222: 0000:           INTEGER*2 WRITE.POGOK.UNLOCK
1223: 0000:        END FUNCTION
1224: 0000: 
1225: 0000:        FUNCTION CREATE.POGOK EXTERNAL
1226: 0000:           INTEGER*2 CREATE.POGOK
1227: 0000:        END FUNCTION
1228: 0000: %INCLUDE PSBF01E.J86 
1229: 0000: REM \
1230: 0000: \*******************************************************************************
1231: 0000: \*******************************************************************************
1232: 0000: \***
1233: 0000: \***      %INCLUDE FOR EXTERNAL DEFINITION OF FUNCTION APPLICATION.LOG
1234: 0000: \***
1235: 0000: \***                      FUNCTION NUMBER   : PSBF01
1236: 0000: \***
1237: 0000: \***                    INCLUDE REFERENCE : PSBF01E.J86
1238: 0000: \*** 
1239: 0000: \***      Version B           Andrew Wedgeworth          1st July 1992
1240: 0000: \***      Three parameters which passed to the function have been removed.
1241: 0000: \***      APPLICATION.LOG has been added as a variable name (this holds the
1242: 0000: \***      return code).
1243: 0000: \***
1244: 0000: \*******************************************************************************
1245: 0000: 
1246: 0000: 
1247: 0000:    FUNCTION APPLICATION.LOG (MESSAGE.NO%,                                     \
1248: 0000:                              VAR.STRING.1$,                                   \
1249: 0000:                              VAR.STRING.2$,                                   \
1250: 0000:                              EVENT.NO%)  EXTERNAL
1251: 0000: 
1252: 0000:       INTEGER*1 EVENT.NO%
1253: 0000: 
1254: 0000:       INTEGER*2 APPLICATION.LOG,                                       \ GAW
1255: 0000:                 MESSAGE.NO%
1256: 0000: 
1257: 0000:       STRING VAR.STRING.1$,                                            \
1258: 0000:              VAR.STRING.2$
1259: 0000: 
1260: 0000:    END FUNCTION
1261: 0000: 
1262: 0000: \*******************************************************************************
1263: 0000: %INCLUDE PSBF20E.J86 
1264: 0000: REM\
1265: 0000: \*******************************************************************************
1266: 0000: \*******************************************************************************
1267: 0000: \***
1268: 0000: \***       %INCLUDE FOR EXTERNAL DEFINITION OF SESS.NUM.UTILITY
1269: 0000: \***
1270: 0000: \***                  REFERENCE     : PSBF20E.J86
1271: 0000: \***
1272: 0000: \***     VERSION C            Janet Smith                13th May 1992
1273: 0000: \***     Increased PASSED.INTEGER to 2 bytes to cater for more than
1274: 0000: \***     128 files.
1275: 0000: \***
1276: 0000: \***     VERSION D.           Andrew Wedgeworth          1st July 1992
1277: 0000: \***     Removal of redundant parameters and addition of SESS.NUM.UTILITY
1278: 0000: \***     as a variable.  This new variable contains the function's return
1279: 0000: \***     code.
1280: 0000: \***
1281: 0000: \*******************************************************************************
1282: 0000: \*******************************************************************************
1283: 0000: 
1284: 0000:    FUNCTION SESS.NUM.UTILITY (FUNCTION.FLAG$,                          \
1285: 0000:                               PASSED.INTEGER%,                         \
1286: 0000:                               PASSED.STRING$)                          \
1287: 0000:    EXTERNAL
1288: 0000: 
1289: 0000:    STRING    FUNCTION.FLAG$,                                           \
1290: 0000:              PASSED.STRING$
1291: 0000:    ! 3 variables removed from here                                     ! CAW
1292: 0000: 
1293: 0000: 
1294: 0000:    INTEGER*2 SESS.NUM.UTILITY,                                         \ CAW
1295: 0000:              PASSED.INTEGER%				               ! CJAS
1296: 0000: 
1297: 0000:    END FUNCTION
1298: 0000: 
1299: 0000: %INCLUDE PSBF24E.J86
1300: 0000: REM \
1301: 0000: \*******************************************************************************
1302: 0000: \*******************************************************************************
1303: 0000: \***
1304: 0000: \***    %INCLUDE FOR EXTERNAL DEFINITION OF STANDARD.ERROR.DETECTED FUNCTION
1305: 0000: \***
1306: 0000: \***                      REFERENCE     : PSBF24E.J86
1307: 0000: \***
1308: 0000: \***    Version A                 Janet Smith                  13th May 1992
1309: 0000: \***
1310: 0000: \*******************************************************************************
1311: 0000: \*******************************************************************************
1312: 0000: 
1313: 0000:    FUNCTION STANDARD.ERROR.DETECTED(ERRN%,                 \
1314: 0000: 				    ERRFILE%,              \
1315: 0000: 				    ERRL%,                 \
1316: 0000: 				    ERR$)        EXTERNAL
1317: 0000: 				    
1318: 0000:           STRING    ERR$
1319: 0000: 
1320: 0000:           INTEGER*2 ERRFILE%,              \
1321: 0000: 	            ERRL%,                 \
1322: 0000: 		    STANDARD.ERROR.DETECTED
1323: 0000: 		    
1324: 0000:           INTEGER*4 ERRN%
1325: 0000: 	  		    
1326: 0000:    END FUNCTION
1327: 0000: 
1328: 0000: 
1329: 0000: %INCLUDE SRPEXT.J86
1330: 0000: \********************************************************************
1331: 0000: \***      Space and Range Planner Common Functions  (SRPFUN)
1332: 0000: \***      Version A           Neil Bennett          24.08.2006
1333: 0000: \***
1334: 0000: \....................................................................
1335: 0000: \***
1336: 0000: \***    GET.CATID Construct a 4 byte integer Category ID from 3
1337: 0000: \***              hierarchical (I4) keys supplied.
1338: 0000: \***
1339: 0000: \********************************************************************
1340: 0000: 
1341: 0000:    FUNCTION GET.CATID%(lev1%,lev2%,lev3%) EXTERNAL
1342: 0000: 
1343: 0000:     INTEGER*4 GET.CATID%
1344: 0000:     INTEGER*4 lev1%, lev2%, lev3%
1345: 0000: 
1346: 0000:    END FUNCTION
1347: 0000: 
1348: 0000: \********************************************************************
1349: 0000: %INCLUDE SRPDFEXT.J86
1350: 0000: \********************************************************************
1351: 0000: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE SRPDF FILE
1352: 0000: \***      REFERENCE : SRPDFEXT.J86
1353: 0000: \***      Version A           Neil Bennett          7th August 2006
1354: 0000: \***
1355: 0000: \********************************************************************
1356: 0000: 
1357: 0000:        FUNCTION SRPDF.SET EXTERNAL
1358: 0000:        END FUNCTION
1359: 0000: 
1360: 0000:        FUNCTION READ.SRPDF EXTERNAL
1361: 0000:           INTEGER*2 READ.SRPDF
1362: 0000:        END FUNCTION
1363: 0000: 
1364: 0000:        FUNCTION WRITE.SRPDF EXTERNAL
1365: 0000:           INTEGER*2 WRITE.SRPDF
1366: 0000:        END FUNCTION
1367: 0000: 
1368: 0000:        FUNCTION DELREC.SRPDF EXTERNAL
1369: 0000:           INTEGER*2 DELREC.SRPDF
1370: 0000:        END FUNCTION
1371: 0000: %INCLUDE SRPOGEXT.J86
1372: 0000: \********************************************************************
1373: 0000: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE SRPOG FILE
1374: 0000: \***      REFERENCE : SRPOGEXT.J86
1375: 0000: \***      Version A           Neil Bennett            5th June 2006
1376: 0000: \***
1377: 0000: \********************************************************************
1378: 0000: 
1379: 0000:        FUNCTION SRPOG.SET EXTERNAL
1380: 0000:        END FUNCTION
1381: 0000: 
1382: 0000:        FUNCTION READ.SRPOG EXTERNAL
1383: 0000:           INTEGER*2 READ.SRPOG
1384: 0000:        END FUNCTION
1385: 0000: 
1386: 0000:        FUNCTION WRITE.SRPOG EXTERNAL
1387: 0000:           INTEGER*2 WRITE.SRPOG
1388: 0000:        END FUNCTION
1389: 0000: 
1390: 0000:        FUNCTION DELREC.SRPOG EXTERNAL
1391: 0000:           INTEGER*2 DELREC.SRPOG
1392: 0000:        END FUNCTION
1393: 0000: %INCLUDE SRMODEXT.J86
1394: 0000: \********************************************************************
1395: 0000: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE SRMOD FILE
1396: 0000: \***      REFERENCE : SRMODEXT.J86
1397: 0000: \***      Version A           Neil Bennett            5th June 2006
1398: 0000: \***
1399: 0000: \********************************************************************
1400: 0000: 
1401: 0000:        FUNCTION SRMOD.SET EXTERNAL
1402: 0000:        END FUNCTION
1403: 0000: 
1404: 0000:        FUNCTION READ.SRMOD EXTERNAL
1405: 0000:           INTEGER*2 READ.SRMOD
1406: 0000:        END FUNCTION
1407: 0000: 
1408: 0000:        FUNCTION WRITE.SRMOD EXTERNAL
1409: 0000:           INTEGER*2 WRITE.SRMOD
1410: 0000:        END FUNCTION
1411: 0000: 
1412: 0000:        FUNCTION DELREC.SRMOD EXTERNAL
1413: 0000:           INTEGER*2 DELREC.SRMOD
1414: 0000:        END FUNCTION
1415: 0000: 
1416: 0000:        SUB SRMOD.SPLIT.SHELF.ITEM EXTERNAL
1417: 0000:        END SUB
1418: 0000: %INCLUDE SRSXFEXT.J86
1419: 0000: \********************************************************************
1420: 0000: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE SRSXF FILE
1421: 0000: \***      REFERENCE : SRSXFEXT.J86
1422: 0000: \***      Version A           Neil Bennett          7th August 2006
1423: 0000: \***
1424: 0000: \********************************************************************
1425: 0000: 
1426: 0000:        FUNCTION SRSXF.SET EXTERNAL
1427: 0000:        END FUNCTION
1428: 0000: 
1429: 0000:        FUNCTION READ.SRSXF EXTERNAL
1430: 0000:           INTEGER*2 READ.SRSXF
1431: 0000:        END FUNCTION
1432: 0000: 
1433: 0000:        FUNCTION WRITE.SRSXF EXTERNAL
1434: 0000:           INTEGER*2 WRITE.SRSXF
1435: 0000:        END FUNCTION
1436: 0000: 
1437: 0000:        FUNCTION DELREC.SRSXF EXTERNAL
1438: 0000:           INTEGER*2 DELREC.SRSXF
1439: 0000:        END FUNCTION
1440: 0000: %INCLUDE SRMAPEXT.J86                                                   !ARG
1441: 0000: \********************************************************************
1442: 0000: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE SRMAP FILE
1443: 0000: \***      REFERENCE : SRMAPEXT.J86
1444: 0000: \***      Version A           Neil Bennett           14th June 2006
1445: 0000: \***
1446: 0000: \********************************************************************
1447: 0000: 
1448: 0000:        FUNCTION SRMAP.SET EXTERNAL
1449: 0000:        END FUNCTION
1450: 0000: 
1451: 0000:        FUNCTION READ.SRMAP EXTERNAL
1452: 0000:           INTEGER*2 READ.SRMAP
1453: 0000:        END FUNCTION
1454: 0000: 
1455: 0000:        FUNCTION WRITE.SRMAP EXTERNAL
1456: 0000:           INTEGER*2 WRITE.SRMAP
1457: 0000:        END FUNCTION
1458: 0000: 
1459: 0000: \***********************************************************************
1460: 0000: \*
1461: 0000: \*    INITIALISATION : This Sub-routine does all the initial processing
1462: 0000: \*                     before starting the main process
1463: 0000: \*
1464: 0000: \***********************************************************************
1465: 0000: 
1466: 0000: FUNCTION FLEXOSSVC(COMMAND%, PARAM$) EXTERNAL                           
1467: 0000:                                                                         
1468: 0000:       STRING PARAM$                                                     
1469: 0000:       INTEGER*2 COMMAND%, FLEXOSSVC                                     
1470: 0000:                                                                         
1471: 0000: END FUNCTION                                                            
1472: 0000: 
1473: 0000: \**********************************************************************
1474: 0000: \***
1475: 0000: \***    ADXSERVE
1476: 0000: \***    IBM routine to request Application Services.
1477: 0000: \***
1478: 0000: \**********************************************************************
1479: 0000: 
1480: 0000: SUB ADXSERVE (RET, FUNC, PARM1, PARM2$) EXTERNAL
1481: 0000: 
1482: 0000:     INTEGER*4  RET
1483: 0000:     INTEGER*2  FUNC,PARM1
1484: 0000:     STRING     PARM2$
1485: 0000: 
1486: 0000: END SUB
1487: 0000: 
1488: 0000: \**********************************************************************
1489: 0000: \***
1490: 0000: \***    ADXCOPYF
1491: 0000: \***    IBM routine to request Application Services.
1492: 0000: \***
1493: 0000: \**********************************************************************
1494: 0000: 
1495: 0000: SUB ADXCOPYF (RETC,INFILE,OUTFILE,OPT0,OPT1) EXTERNAL
1496: 0000: 
1497: 0000:     INTEGER*4 RETC
1498: 0000:     STRING    INFILE,OUTFILE
1499: 0000:     INTEGER*2 OPT0,OPT1
1500: 0000: 
1501: 0000: END SUB 
1502: 0000: 
1503: 0000: \***********************************************************************
1504: 0000: \*                                                                     *
1505: 0000: \*          S T A R T   O F   M A I N L I N E   C O D E                *
1506: 0000: \*                                                                     *
1507: 0000: \***********************************************************************
1508: 0000: \***********************************************************************
1509: 0000: 
1510: 0000: ON ERROR GOTO ERROR.DETECTED
1511: 002f: 
1512: 002f:     PRINT  TIME.STAMP$(2)  + "-Program started"         
1513: 005d: 
1514: 005d:     GOSUB INITIALISATION
1515: 006f: 
1516: 006f:     PRINT #PHKEEP.SESS.NUM% ; TIME.STAMP$(2)  + "-Program started" 
1517: 00ac:     GOSUB MAIN.PROCESSING
1518: 00be:     GOSUB TERMINATION
1519: 00d0:  
1520: 00d0: STOP.PROGRAM:
1521: 00d8:     STOP
1522: 00e5: 
1523: 00e5: \***********************************************************************
1524: 00e5: \*
1525: 00e5: \*    INITIALISATION : This Sub-routine does all the initial processing
1526: 00e5: \*                     before starting the main process
1527: 00e5: \*
1528: 00e5: \***********************************************************************
1529: 00e5: INITIALISATION:
1530: 00f5: 
1531: 00f5:     GOSUB INITIAL.CHECKS          
1532: 0107:     GOSUB INITIALISE.VARIABLES    
1533: 0119:     GOSUB ALLOCATE.SESSION.NUMBERS
1534: 012b:     GOSUB OPEN.FILES              
1535: 013d:     GOSUB CREATE.FILES            
1536: 014f: 
1537: 014f: RETURN
1538: 015f: 
1539: 015f: \***********************************************************************
1540: 015f: \*
1541: 015f: \*    INITIALISE.VARIABLES :   
1542: 015f: \*                
1543: 015f: \*
1544: 015f: \***********************************************************************
1545: 015f: INITIALISE.VARIABLES:
1546: 016f: 
1547: 016f:    CALL SRMAP.SET                                                       !ARG
1548: 018a:    CALL SRPOG.SET
1549: 01a5:    CALL SRMOD.SET
1550: 01c0:    CALL SRMAP.SET
1551: 01db:    CALL SRPDF.SET
1552: 01f6:    CALL SRSXF.SET
1553: 0211:    
1554: 0211:    ERROR.CNT% = 0
1555: 0226:    
1556: 0226:    !ARR.COUNT% = 10000                                                  !BRG
1557: 0226:     ARR.COUNT% = 16000                                                  !BRG
1558: 023b:    
1559: 023b:    DIM SRMAP.ARRAY$(ARR.COUNT%)                                         !ARG
1560: 026a:    
1561: 026a:    DIM SRPOG.ARRAY$(ARR.COUNT%) 
1562: 0299:     
1563: 0299:    DIM SRMOD.ARR$(ARR.COUNT%)      
1564: 02c8: 
1565: 02c8:    DIM SRPDF.ARRAY$(ARR.COUNT%)  
1566: 02f7:    
1567: 02f7:    DIM TEMP.ARR%(ARR.COUNT%)
1568: 0326:    
1569: 0326:      
1570: 0326:    FOUND% = 0
1571: 033b:    
1572: 033b:    PHKEEP.LOG.NAME$ = "ADXLXACN::W:/PHKEEP.LOG"
1573: 0350:    PHKEEP.SESS.NUM% = 456
1574: 0365:    
1575: 0365:    PHKEEP.OK.NAME$  = "ADXLXACN::W:/PHKEEP.ERR"
1576: 037a:    PHKEEP.OK.SESS%  = 457   
1577: 038f:    
1578: 038f:    SRPOG.DIR.NAME$  = "ADXLXACN::W:\SRPOG.DIR"
1579: 03a4:    SRPOG.KEY.NAME$  = "ADXLXACN::W:\SRPOG.KEY"
1580: 03b9:    SRMOD.DIR.NAME$  = "ADXLXACN::W:\SRMOD.DIR"
1581: 03ce:    SRMOD.KEY.NAME$  = "ADXLXACN::W:\SRMOD.KEY"
1582: 03e3:    SRPDF.DIR.NAME$  = "ADXLXACN::W:\SRPDF.DIR"
1583: 03f8:    SRPDF.KEY.NAME$  = "ADXLXACN::W:\SRPDF.KEY"
1584: 040d:    SRSXF.DIR.NAME$  = "ADXLXACN::W:\SRSXF.DIR"
1585: 0422:    SRSXF.KEY.NAME$  = "ADXLXACN::W:\SRSXF.KEY"
1586: 0437:    
1587: 0437:    SPACE$ = " "   
1588: 044c:    
1589: 044c:    CREATE PHKEEP.LOG.NAME$ AS PHKEEP.SESS.NUM%   
1590: 0471:    
1591: 0471:    CREATE PHKEEP.OK.NAME$ AS PHKEEP.OK.SESS%
1592: 0496:     
1593: 0496:    SRMAP.FLAG$ = ""
1594: 04ab:    SRPOG.FLAG$ = ""
1595: 04c0:    SRMOD.FLAG$ = ""
1596: 04d5:    SRSXF.FLAG$ = ""
1597: 04ea:    SRPDF.FLAG$ = ""
1598: 04ff:    
1599: 04ff: RETURN 
1600: 050f: 
1601: 050f: \***********************************************************************
1602: 050f: \*
1603: 050f: \*    ALLOCATE.SESSION.NUMBERS:   
1604: 050f: \*                
1605: 050f: \*
1606: 050f: \***********************************************************************
1607: 050f: ALLOCATE.SESSION.NUMBERS:
1608: 051f: 
1609: 051f:     FUNCTION.FLAG$ = "O"  
1610: 0534: 
1611: 0534:     PASSED.INTEGER% = SRMAP.REPORT.NUM%                                 !ARG
1612: 0551:     PASSED.STRING$  = SRMAP.FILE.NAME$                                  !ARG
1613: 056f:     GOSUB CALL.F20.SESS.NUM.UTILITY                                     !ARG
1614: 0581:     SRMAP.SESS.NUM% = F20.INTEGER.FILE.NO% 	                            !ARG
1615: 0597:     
1616: 0597:     PASSED.INTEGER% = SRPOG.REPORT.NUM%                                 
1617: 05b4:     PASSED.STRING$  = SRPOG.FILE.NAME$                                  
1618: 05d2:     GOSUB CALL.F20.SESS.NUM.UTILITY                                     
1619: 05e4:     SRPOG.SESS.NUM% = F20.INTEGER.FILE.NO%                              
1620: 05fa: 
1621: 05fa:     PASSED.INTEGER% = SRMOD.REPORT.NUM%                                 
1622: 0617:     PASSED.STRING$  = SRMOD.FILE.NAME$                                  
1623: 0635:     GOSUB CALL.F20.SESS.NUM.UTILITY                                     
1624: 0647:     SRMOD.SESS.NUM% = F20.INTEGER.FILE.NO%   
1625: 065d: 
1626: 065d:     PASSED.INTEGER% = SRSXF.REPORT.NUM%                                 
1627: 067a:     PASSED.STRING$  = SRSXF.FILE.NAME$                                  
1628: 0698:     GOSUB CALL.F20.SESS.NUM.UTILITY                                     
1629: 06aa:     SRSXF.SESS.NUM% = F20.INTEGER.FILE.NO%                              
1630: 06c0: 
1631: 06c0:     PASSED.INTEGER% = SRPDF.REPORT.NUM%                                 
1632: 06dd:     PASSED.STRING$  = SRPDF.FILE.NAME$                                  
1633: 06fb:     GOSUB CALL.F20.SESS.NUM.UTILITY                                     
1634: 070d:     SRPDF.SESS.NUM% = F20.INTEGER.FILE.NO%                              
1635: 0723: 
1636: 0723:     PASSED.INTEGER% = PHKEEP.SESS.NUM%                                  
1637: 073a:     PASSED.STRING$  = PHKEEP.LOG.NAME$                                  
1638: 0755:     GOSUB CALL.F20.SESS.NUM.UTILITY                                     
1639: 0767:     PHKEEP.SESS.NUM% = F20.INTEGER.FILE.NO%                             
1640: 0782: 
1641: 0782:     PASSED.INTEGER% = PHKEEP.OK.SESS%                                   
1642: 0799:     PASSED.STRING$  = PHKEEP.OK.NAME$                                   
1643: 07b4:     GOSUB CALL.F20.SESS.NUM.UTILITY                                     
1644: 07c6:     PHKEEP.OK.SESS% = F20.INTEGER.FILE.NO% 
1645: 07e1: 
1646: 07e1:     PASSED.INTEGER% = 457                                               
1647: 07f8:     PASSED.STRING$  = SRPOG.DIR.NAME$                                   
1648: 0813:     GOSUB CALL.F20.SESS.NUM.UTILITY                                     
1649: 0825:     SRPOG.DIR.SESS% = F20.INTEGER.FILE.NO% 	
1650: 0840: 
1651: 0840:     PASSED.INTEGER% = 458                                               
1652: 0857:     PASSED.STRING$  = SRMOD.DIR.NAME$                                   
1653: 0872:     GOSUB CALL.F20.SESS.NUM.UTILITY                                     
1654: 0884:     SRMOD.DIR.SESS% = F20.INTEGER.FILE.NO%                              
1655: 089f: 
1656: 089f:     PASSED.INTEGER% = 459                                               
1657: 08b6:     PASSED.STRING$  = SRPDF.DIR.NAME$                                   
1658: 08d1:     GOSUB CALL.F20.SESS.NUM.UTILITY                                     
1659: 08e3:     SRPDF.DIR.SESS% = F20.INTEGER.FILE.NO%                              
1660: 08fe: 
1661: 08fe:     PASSED.INTEGER% = 460                                               
1662: 0915:     PASSED.STRING$  = SRSXF.DIR.NAME$                                   
1663: 0930:     GOSUB CALL.F20.SESS.NUM.UTILITY                                     
1664: 0942:     SRSXF.DIR.SESS% = F20.INTEGER.FILE.NO%                              
1665: 095d: 
1666: 095d: RETURN
1667: 096d: 
1668: 096d: \***********************************************************************
1669: 096d: \*
1670: 096d: \*    CALL.F20.SESS.NUM.UTILITY:  
1671: 096d: \*                
1672: 096d: \*
1673: 096d: \***********************************************************************
1674: 096d: CALL.F20.SESS.NUM.UTILITY: 
1675: 097d:         
1676: 097d:    FILE.OPERATION$ = FUNCTION.FLAG$
1677: 0998:    CURRENT.REPORT.NUM% = PASSED.INTEGER%
1678: 09b1:    RC% = SESS.NUM.UTILITY (FUNCTION.FLAG$, PASSED.INTEGER%,       \
1679: 09ee:                                  PASSED.STRING$)
1680: 09ee:    IF RC% <> 0 THEN GOTO ERROR.DETECTED
1681: 0a10: 
1682: 0a10: RETURN
1683: 0a20: 
1684: 0a20: \***********************************************************************
1685: 0a20: \*
1686: 0a20: \*    CREATE.FILES:  
1687: 0a20: \*             
1688: 0a20: \***********************************************************************
1689: 0a20: CREATE.FILES:
1690: 0a30: 
1691: 0a30:    PRINT  TIME.STAMP$(2)  + "-Creating Direct And Log Files" 
1692: 0a5e:     
1693: 0a5e:    
1694: 0a5e:    CREATE POSFILE SRMOD.DIR.NAME$ AS SRMOD.DIR.SESS% BUFFSIZE 32256 
1695: 0a83: 
1696: 0a83:    CREATE POSFILE SRPDF.DIR.NAME$ AS SRPDF.DIR.SESS% BUFFSIZE 32256 
1697: 0aa8: 
1698: 0aa8:    CREATE POSFILE SRSXF.DIR.NAME$ AS SRSXF.DIR.SESS% BUFFSIZE 32256 
1699: 0acd: 
1700: 0acd: RETURN
1701: 0add: 
1702: 0add: \***********************************************************************
1703: 0add: \*
1704: 0add: \*    OPEN.FILES:  
1705: 0add: \*              
1706: 0add: \*
1707: 0add: \***********************************************************************
1708: 0add: OPEN.FILES:
1709: 0aed: 
1710: 0aed:    IF END #PHKEEP.SESS.NUM% THEN PHKEEP.END
1711: 0b0a:    OPEN PHKEEP.LOG.NAME$ AS PHKEEP.SESS.NUM% APPEND    
1712: 0b2f: 
1713: 0b2f: RETURN
1714: 0b3f: 
1715: 0b3f: PHKEEP.END:
1716: 0b4f:     
1717: 0b4f:    PRINT  TIME.STAMP$(2)  + "- No PHKEEP Log File"  
1718: 0b7d: STOP 
1719: 0b8a:  
1720: 0b8a: \***********************************************************************
1721: 0b8a: \*
1722: 0b8a: \*    MAIN.PROCESSING
1723: 0b8a: \*
1724: 0b8a: \***********************************************************************
1725: 0b8a: MAIN.PROCESSING:   
1726: 0b9a: 
1727: 0b9a:    GOSUB SEQUENTIAL.READ.SRPOG
1728: 0bac:    GOSUB HOUSEKEEP.SRPOG
1729: 0bbe: 
1730: 0bbe:    GOSUB SEQUENTIAL.READ.SRMOD
1731: 0bd0:   
1732: 0bd0:    GOSUB SEQUENTIAL.READ.SRSXF
1733: 0be2:   
1734: 0be2:    GOSUB SEQUENTIAL.READ.SRPDF 
1735: 0bf4:   
1736: 0bf4:    GOSUB COMPARE.SRMOD
1737: 0c06:    GOSUB COMPARE.SRPDF    
1738: 0c18:    GOSUB CREATE.SRMOD.KEY
1739: 0c2a:    GOSUB CREATE.SRSXF.KEY
1740: 0c3c:    GOSUB CREATE.SRPDF.KEY
1741: 0c4e:   
1742: 0c4e:    GOSUB STOP.BACKGROUNDS
1743: 0c60:    GOSUB BACKUP.ORIGINAL 
1744: 0c72:    GOSUB DELETE.EXISTING 
1745: 0c84:    GOSUB COPY.NEW        
1746: 0c96:    GOSUB START.BACKGROUNDS   
1747: 0ca8: 
1748: 0ca8: RETURN
1749: 0cb8: 
1750: 0cb8: \***********************************************************************
1751: 0cb8: \*
1752: 0cb8: \*    INITIAL.CHECKS:  
1753: 0cb8: \*               
1754: 0cb8: \*
1755: 0cb8: \***********************************************************************
1756: 0cb8: INITIAL.CHECKS:
1757: 0cc8: 
1758: 0cc8:    PRINT  TIME.STAMP$(2)  + "-Checking the existence of Files"    
1759: 0cf6:    
1760: 0cf6:    CALL OSSHELL ("IF EXIST W:/SRPOG.DIR DEL W:/SRPOG.DIR")
1761: 0d0a:    CALL OSSHELL ("IF EXIST W:/SRMOD.DIR DEL W:/SRMOD.DIR")
1762: 0d1e:    CALL OSSHELL ("IF EXIST W:/SRSXF.DIR DEL W:/SRSXF.DIR")
1763: 0d32:    CALL OSSHELL ("IF EXIST W:/SRPDF.DIR DEL W:/SRPDF.DIR")
1764: 0d46:    CALL OSSHELL ("IF EXIST W:/SRPOG.KEY DEL W:/SRPOG.KEY")
1765: 0d5a:    CALL OSSHELL ("IF EXIST W:/SRMOD.KEY DEL W:/SRMOD.KEY")
1766: 0d6e:    CALL OSSHELL ("IF EXIST W:/SRSXF.KEY DEL W:/SRSXF.KEY")
1767: 0d82:    CALL OSSHELL ("IF EXIST W:/SRPDF.KEY DEL W:/SRPDF.KEY")
1768: 0d96:    CALL OSSHELL ("IF EXIST W:/PHKEEP.OK DEL W:/PHKEEP.OK")
1769: 0daa:    CALL OSSHELL ("IF EXIST W:/PHKEEP.ERR DEL W:/PHKEEP.ERR")
1770: 0dbe:    CALL OSSHELL ("IF EXIST W:/PHKEEP.LOG DEL W:/PHKEEP.LOG")
1771: 0dd2:    
1772: 0dd2:    PRINT  TIME.STAMP$(2)  + "-Checking the existence of D: drive SR files"
1773: 0e00:       
1774: 0e00:    CALL OSSHELL ("IF EXIST D:/SRPOG.DAT DEL D:/SRPOG.DAT")
1775: 0e14:    CALL OSSHELL ("IF EXIST D:/SRMOD.DAT DEL D:/SRMOD.DAT")
1776: 0e28:    CALL OSSHELL ("IF EXIST D:/SRSXF.DAT DEL D:/SRSXF.DAT")
1777: 0e3c:    CALL OSSHELL ("IF EXIST D:/SRPDF.DAT DEL D:/SRPDF.DAT")
1778: 0e50:     
1779: 0e50:   RETURN       
1780: 0e60: 
1781: 0e60: \***********************************************************************
1782: 0e60: \*
1783: 0e60: \*   SEQUENTIAL.READ.SRPOG 
1784: 0e60: \*               
1785: 0e60: \*
1786: 0e60: \***********************************************************************
1787: 0e60: SEQUENTIAL.READ.SRPOG:
1788: 0e70: 
1789: 0e70:    PRINT  TIME.STAMP$(2)  + "-Sequential Reading SRPOG"
1790: 0e9e:    PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)  + "-Sequential Reading SRPOG"
1791: 0edb:    
1792: 0edb:    FILE.OPERATION$ = "O"     
1793: 0ef2:    OPEN SRPOG.FILE.NAME$ DIRECT RECL 512 AS SRPOG.SESS.NUM% NOWRITE NODEL     
1794: 0f1b:    OPEN SRMAP.FILE.NAME$ KEYED RECL SRMAP.RECL% AS SRMAP.SESS.NUM%      !ARG  
1795: 0f47:    
1796: 0f47:    
1797: 0f47:    EOF%   = 0
1798: 0f5c:    I%     = 0
1799: 0f71:    J%     = 1
1800: 0f86:    SRPOG% = 0
1801: 0f9b:    P%     = 0
1802: 0fb0:    ! RPS indicates record per sector, as it is block read, will filtering
1803: 0fb0:    ! the number of records per each sector. same is obtained using the 
1804: 0fb0:    ! record size against total block size.
1805: 0fb0: 
1806: 0fb0:    RPS%   = 4                   
1807: 0fc5: 
1808: 0fc5:    SRPOG.FLAG$ = "S" 
1809: 0fda:    SRPOG.COUNT% = 0   
1810: 0fef:    
1811: 0fef:      WHILE NOT EOF%
1812: 0ffa:    
1813: 0ffa:          I% = I% +1 
1814: 1013:          IF END #SRPOG.SESS.NUM% THEN SRPOG.END 
1815: 102f:          READ FORM "T5,C508"; #SRPOG.SESS.NUM%,I%; SEC$      
1816: 1064: 
1817: 1064:          FOR J% = 1 TO RPS%
1818: 107c: 
1819: 107c:              SRPOG.STRING$ = MID$(SEC$, ((J%-1)* SRPOG.RECL%) +1,      \
1820: 10cb:              SRPOG.RECL%)
1821: 10cb: 
1822: 10cb:              IF GETN4(SRPOG.STRING$,0) <> 0 THEN BEGIN
1823: 10f6: 
1824: 10f6:                  SRPOG% = SRPOG% + 1
1825: 110f:                  SRPOG.POGDB% = GETN4(SRPOG.STRING$,0)
1826: 1138:                  SRMAP.POGDB% = SRPOG.POGDB%                            !ARG
1827: 1151:                  SRMAP.CHAIN.SEQ% = 0                                   !ARG
1828: 1161: 
1829: 1161:              ! Check if there is a proper match in SRMAP file as its    !ARG
1830: 1161:              ! been proved that, everday SRMAP file is read to create   !ARG
1831: 1161:              ! SRITEMP/SRITEML files so if any POGDB is missing from    !ARG
1832: 1161:              ! SRMAP, the planer wont be visible from next day after    !ARG
1833: 1161:              ! POGOK run. So any POGDB not present in SRMAP ignore it   !ARG
1834: 1161:              ! while writing to SRPOG.DIR file.
1835: 1161: 
1836: 1161:                  RC% = READ.SRMAP                                       !ARG
1837: 117c: 
1838: 117c:                  IF RC% = 0 THEN BEGIN                                  !ARG
1839: 119b:                      SRPOG.COUNT% = SRPOG.COUNT% + 1                    !ARG
1840: 11b4:                      SRPOG.ARRAY$(SRPOG.COUNT%) = SRPOG.STRING$         !ARG
1841: 11e0:                  ENDIF ELSE BEGIN 
1842: 11e8:                       P% = P% + 1
1843: 1201:                       TEMP.ARR%(P%) = SRPOG.POGDB%
1844: 1229:                  ENDIF     
1845: 1233:                  
1846: 1233:              ENDIF ELSE BEGIN
1847: 123b: 
1848: 123b:                  J% = RPS%
1849: 1250:              ENDIF
1850: 1258: 
1851: 1258:          NEXT J%
1852: 1285: 
1853: 1285:      WEND
1854: 129b: 
1855: 129b: SRPOG.END: 
1856: 12ab:     
1857: 12ab:    
1858: 12ab:    EOF% = -1
1859: 12c0:    CLOSE SRPOG.SESS.NUM%
1860: 12d4: 
1861: 12d4: RETURN
1862: 12e4: 
1863: 12e4: \***********************************************************************
1864: 12e4: \*
1865: 12e4: \*   HOUSEKEEP.SRPOG
1866: 12e4: \*               
1867: 12e4: \*
1868: 12e4: \***********************************************************************
1869: 12e4: HOUSEKEEP.SRPOG:
1870: 12f4: 
1871: 12f4:    PRINT  TIME.STAMP$(2)  + "-Housekeeping SRPOG by checking the existence of planner in SRMAP"
1872: 1322:    PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)  + "-Housekeeping SRPOG by checking against SRMAP"
1873: 135f:    
1874: 135f:    FILE.OPERATION$ = "O"  
1875: 1376:    OPEN SRPOG.FILE.NAME$ KEYED RECL SRPOG.RECL% AS SRPOG.SESS.NUM%
1876: 13a2:    I% = 1 
1877: 13b7: 
1878: 13b7:     
1879: 13b7:    FOR I% = 1 TO P%
1880: 13cf:    
1881: 13cf:    
1882: 13cf:     SRPOG.POGDB% = TEMP.ARR%(I%)
1883: 13f7:     RC% = READ.SRPOG
1884: 1412:     IF RC% = 0 THEN BEGIN
1885: 1431:         RC% = DELREC.SRPOG
1886: 144c:     ENDIF
1887: 1454: 
1888: 1454:    NEXT I%
1889: 1481:    
1890: 1481:    CLOSE SRPOG.SESS.NUM%
1891: 1495:  RETURN
1892: 14a5: 
1893: 14a5: \***********************************************************************
1894: 14a5: \*
1895: 14a5: \*    SEQUENTIAL.READ.SRMOD
1896: 14a5: \*                
1897: 14a5: \*
1898: 14a5: \***********************************************************************
1899: 14a5: SEQUENTIAL.READ.SRMOD:                                                  
1900: 14b5: 
1901: 14b5:    PRINT  TIME.STAMP$(2)  + "-Sequential Reading SRMOD"               
1902: 14e3:    PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)  +                         \
1903: 1520:    "-Sequential Reading SRMOD"             
1904: 1520:   
1905: 1520: 
1906: 1520:    FILE.OPERATION$ = "O"  
1907: 1537:    OPEN SRMOD.FILE.NAME$ DIRECT RECL 512 AS SRMOD.SESS.NUM% BUFFSIZE    \
1908: 1561:                                                  32767 NOWRITE NODEL  
1909: 1561:     
1910: 1561:    I%          = 0
1911: 1576:    J%          = 1
1912: 158b:    RPS%        = 1                        
1913: 15a0:    EOF%        = 0 
1914: 15b5:    SRMOD%      = 0
1915: 15ca:    SRMOD.FLAG$ = "S"
1916: 15df:    
1917: 15df:    WHILE NOT EOF%
1918: 15ea:    
1919: 15ea:       I% = I% +1
1920: 1603:       IF END #SRMOD.SESS.NUM% THEN SRMOD.END
1921: 161f:       READ FORM "T5,C508"; #SRMOD.SESS.NUM%,I%; SEC$
1922: 1654:                                                                         
1923: 1654:       FOR J% = 1 TO RPS%                                                
1924: 166c:          SRMOD.STRING$ = SEC$                                           
1925: 1685:          SRMOD.STRING$ = MID$(SEC$, 1,508)                              
1926: 16a8:          IF GETN4(SRMOD.STRING$,0) <> 0 THEN BEGIN                      
1927: 16d0:             SRMOD% = SRMOD% + 1                                         
1928: 16e9:             SRMOD.ARR$(SRMOD%) = SRMOD.STRING$                          
1929: 1715:                                                                         
1930: 1715:          ENDIF ELSE BEGIN
1931: 171d: 
1932: 171d:              J% = RPS%
1933: 1732: 
1934: 1732:          ENDIF
1935: 173a: 
1936: 173a:       NEXT J%
1937: 1767:    WEND
1938: 177d: 
1939: 177d: SRMOD.END:    
1940: 178d:   
1941: 178d:    EOF% = -1
1942: 17a2:    CLOSE SRMOD.SESS.NUM%
1943: 17b6: 
1944: 17b6: RETURN
1945: 17c6: 
1946: 17c6: \***********************************************************************
1947: 17c6: \*
1948: 17c6: \*    SEQUENTIAL.READ.SRSXF 
1949: 17c6: \*                
1950: 17c6: \*
1951: 17c6: \***********************************************************************
1952: 17c6: SEQUENTIAL.READ.SRSXF:   
1953: 17d6: 
1954: 17d6:    PRINT  TIME.STAMP$(2)  +                                             \
1955: 1804:    "-Sequential Reading SRSXF and filtering with SRPOG"
1956: 1804:    PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2) +                           \
1957: 1841:                "-Sequential Reading SRSXF and filtering with SRPOG"
1958: 1841: 
1959: 1841:    FILE.OPERATION$ = "O"  
1960: 1858:    OPEN SRSXF.FILE.NAME$ DIRECT RECL 512 AS SRSXF.SESS.NUM% BUFFSIZE    \
1961: 1882:                                                  32767 NOWRITE NODEL 
1962: 1882:     
1963: 1882:    I%          = 0
1964: 1897:    J%          = 1
1965: 18ac:    RPS%        = 8                        
1966: 18c1:    EOF%        = 0 
1967: 18d6:    SRSXF%      = 0
1968: 18eb:    
1969: 18eb:    SRSXF.FLAG$ = "S"
1970: 1900:    
1971: 1900:    WHILE NOT EOF%
1972: 190b:    
1973: 190b:       I% = I% +1
1974: 1924:       IF END #SRSXF.SESS.NUM% THEN SRSXF.END
1975: 1940:       READ FORM "T5,C508"; #SRSXF.SESS.NUM%,I%; SEC$
1976: 1975:       
1977: 1975:       FOR J% = 1 TO RPS%
1978: 198d: 
1979: 198d:          SRSXF.STRING$ = MID$(SEC$, ((J%-1)* SRSXF.RECL%) +1,          \
1980: 19dc:                                              SRSXF.RECL%) 
1981: 19dc:          IF GETN4(SRSXF.STRING$,0) <> 0 THEN BEGIN                       
1982: 1a07: 
1983: 1a07:             SRSXF% = SRSXF% + 1
1984: 1a20: 
1985: 1a20:          ! AS SRSXF file will generally have anything between 10000 to 
1986: 1a20:          ! 90000 records based on the number of planners. It is 
1987: 1a20:          ! impossible to do an array sort so filtering the records
1988: 1a20:          ! and writing it individually to the SRSXF file
1989: 1a20: 
1990: 1a20:             K% = 1
1991: 1a35: 
1992: 1a35:              WHILE K% <= SRPOG%
1993: 1a40: 
1994: 1a40:                  IF STR$(GETN4(SRSXF.STRING$,0)) =                       \
1995: 1aa5:                                 STR$(GETN4(SRPOG.ARRAY$(K%),0)) THEN     \
1996: 1aa5:                                                          BEGIN
1997: 1aa5: 
1998: 1aa5:                      SRSXF.COUNT% = SRSXF.COUNT% + 1
1999: 1abe: 
2000: 1abe:                      GOSUB CREATE.SRSXF.DIR
2001: 1ad0: 
2002: 1ad0:                  ENDIF
2003: 1ad8: 
2004: 1ad8:                      K% = K% + 1
2005: 1af1:              WEND
2006: 1b0f: 
2007: 1b0f:          ENDIF ELSE BEGIN 
2008: 1b17: 
2009: 1b17:              J% = RPS%
2010: 1b2c: 
2011: 1b2c:          ENDIF
2012: 1b34: 
2013: 1b34:       NEXT J%
2014: 1b61: 
2015: 1b61:    WEND
2016: 1b77: 
2017: 1b77: SRSXF.END:      
2018: 1b87:     
2019: 1b87:    EOF% = -1
2020: 1b9c:    CLOSE SRSXF.SESS.NUM%
2021: 1bb0: 
2022: 1bb0: RETURN 
2023: 1bc0: 
2024: 1bc0: \***********************************************************************
2025: 1bc0: \*
2026: 1bc0: \*    SEQUENTIAL.READ.SRPDF 
2027: 1bc0: \*              
2028: 1bc0: \*
2029: 1bc0: \***********************************************************************
2030: 1bc0: SEQUENTIAL.READ.SRPDF:   
2031: 1bd0: 
2032: 1bd0:    PRINT  TIME.STAMP$(2)  + "-Sequential Reading SRPDF"
2033: 1bfe:    PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)  + "-Sequential Reading SRPDF"
2034: 1c3b: 
2035: 1c3b:    FILE.OPERATION$ = "O" 
2036: 1c52:    OPEN SRPDF.FILE.NAME$ DIRECT RECL 512 AS SRPDF.SESS.NUM% NOWRITE NODEL
2037: 1c7b:     
2038: 1c7b:    I%     = 0
2039: 1c90:    J%     = 1
2040: 1ca5:    RPS%   = 3                        
2041: 1cba:    EOF%   = 0 
2042: 1ccf:    SRPDF% = 0
2043: 1ce4:    
2044: 1ce4:    SRPDF.FLAG$ = "S"
2045: 1cf9:    
2046: 1cf9:    WHILE NOT EOF%
2047: 1d04:    
2048: 1d04:       I% = I% +1
2049: 1d1d:       IF END #SRPDF.SESS.NUM% THEN SRPDF.END
2050: 1d39:       READ FORM "T5,C508"; #SRPDF.SESS.NUM%,I%; SEC$
2051: 1d6e:       
2052: 1d6e:       FOR J% = 1 TO RPS%
2053: 1d86: 
2054: 1d86:          SRPDF.STRING$ = SEC$
2055: 1d9f:          SRPDF.STRING$ = MID$(SEC$, ((J%-1)* SRPDF.RECL%) +1, SRPDF.RECL%)
2056: 1dee: 
2057: 1dee:          IF GETN4(SRPDF.STRING$,0) <> 0 THEN BEGIN 
2058: 1e16: 
2059: 1e16:             SRPDF% = SRPDF% + 1
2060: 1e2f:             SRPDF.ARRAY$(SRPDF%) = SRPDF.STRING$
2061: 1e5b: 
2062: 1e5b:          ENDIF  ELSE J% = RPS%
2063: 1e70: 
2064: 1e70:       NEXT J%
2065: 1e9d: 
2066: 1e9d:    WEND
2067: 1eb3: 
2068: 1eb3: SRPDF.END:     
2069: 1ec3: 
2070: 1ec3:    EOF% = -1
2071: 1ed8:    CLOSE SRPDF.SESS.NUM%
2072: 1eec: 
2073: 1eec: RETURN 
2074: 1efc: 
2075: 1efc: \***********************************************************************
2076: 1efc: \*
2077: 1efc: \*    WRITE.PHKEEP.OK  
2078: 1efc: \*                
2079: 1efc: \*
2080: 1efc: \***********************************************************************
2081: 1efc: WRITE.PHKEEP.OK:
2082: 1f0c:     
2083: 1f0c:    OPEN PHKEEP.OK.NAME$ AS PHKEEP.OK.SESS% APPEND
2084: 1f31: 
2085: 1f31:    OK.STRING$ = SRPOG.FLAG$ + SRMOD.FLAG$ + SRSXF.FLAG$ + SRSXF.FLAG$
2086: 1f65: 
2087: 1f65:    WRITE #PHKEEP.OK.SESS% ; OK.STRING$
2088: 1f89:    
2089: 1f89:    CLOSE PHKEEP.OK.SESS%
2090: 1f9e: 
2091: 1f9e: RETURN
2092: 1fae: 
2093: 1fae: 
2094: 1fae: \***********************************************************************
2095: 1fae: \*
2096: 1fae: \*    COMPARE.SRMOD   
2097: 1fae: \*                
2098: 1fae: \*
2099: 1fae: \***********************************************************************
2100: 1fae: COMPARE.SRMOD:
2101: 1fbe: 
2102: 1fbe:      PRINT  TIME.STAMP$(2)  + "-Comparing SRMOD records against SRPOG"
2103: 1fec:      PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)  +                       \
2104: 2029:                            "-Comparing SRMOD records against SRPOG"
2105: 2029:     
2106: 2029:      I%           = 1
2107: 203e:      J%           = 1 
2108: 2053:      TEMP.COUNT%  = 0
2109: 2068:      SRMOD.COUNT% = 0      
2110: 207d: 
2111: 207d:      FOR J% = 1 TO SRMOD% 
2112: 2095: 
2113: 2095:          FOUND% = 0        
2114: 20aa:          I% = 1
2115: 20bf:  
2116: 20bf:          WHILE FOUND% = 0 AND I% <= SRPOG.COUNT% 
2117: 20ca: 
2118: 20ca:              IF STR$(GETN4(SRMOD.ARR$(J%),0))                           \
2119: 2141:               = STR$(GETN4(SRPOG.ARRAY$(I%),0)) THEN BEGIN
2120: 2141: 
2121: 2141:                  SRMOD.COUNT% = SRMOD.COUNT% +1
2122: 215a: 
2123: 215a:                  GOSUB CREATE.SRMOD.DIR 
2124: 216c: 
2125: 216c:                  FOUND% = -1
2126: 2181: 
2127: 2181:                  I% = SRPOG%
2128: 2196: 
2129: 2196:              ENDIF
2130: 219e: 
2131: 219e:                  I% = I% + 1
2132: 21b7:          WEND
2133: 21f2: 
2134: 21f2:      NEXT J%     
2135: 221f: 
2136: 221f: RETURN 
2137: 222f: 
2138: 222f: \***********************************************************************
2139: 222f: \*
2140: 222f: \*    COMPARE.SRPDF  
2141: 222f: \*                
2142: 222f: \*
2143: 222f: \***********************************************************************
2144: 222f: COMPARE.SRPDF:    
2145: 223f: 
2146: 223f:    PRINT  TIME.STAMP$(2)  + "-Comparing SRPDF records against SRPOG"
2147: 226d:    PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)                             \
2148: 22aa:                         + "-Comparing SRPDF records against SRPOG"
2149: 22aa: 
2150: 22aa:    I% = 1
2151: 22bf:    J% = 1    
2152: 22d4:    SRPDF.COUNT% = 0
2153: 22e9: 
2154: 22e9:    FOR J% = 1 TO SRPDF%        
2155: 2301: 
2156: 2301:         FOUND% = 0        
2157: 2316:         I% = 1
2158: 232b: 
2159: 232b:         WHILE FOUND% = 0 AND I% <= SRPOG.COUNT%
2160: 2336: 
2161: 2336:             IF STR$(GETN4(SRPDF.ARRAY$(J%),0))                          \
2162: 23ad:             = STR$(GETN4(SRPOG.ARRAY$(I%),0)) THEN BEGIN
2163: 23ad: 
2164: 23ad:                 SRPDF.COUNT%  =  SRPDF.COUNT% + 1
2165: 23c6: 
2166: 23c6:                 GOSUB CREATE.SRPDF.DIR
2167: 23d8:                 FOUND% = -1 
2168: 23ed: 
2169: 23ed:                 I% = SRPOG%
2170: 2402: 
2171: 2402:             ENDIF    
2172: 240a: 
2173: 240a:                 I% = I% + 1
2174: 2423:         WEND
2175: 245e: 
2176: 245e:    NEXT J%  
2177: 248b: 
2178: 248b: RETURN
2179: 249b:  
2180: 249b: 
2181: 249b: \***********************************************************************
2182: 249b: \*
2183: 249b: \*    CREATE.SRMOD.DIR  
2184: 249b: \*                
2185: 249b: \*
2186: 249b: \***********************************************************************
2187: 249b: CREATE.SRMOD.DIR: 
2188: 24ab: 
2189: 24ab:    WRITE FORM "C508" ;#SRMOD.DIR.SESS% ; SRMOD.ARR$(J%)  
2190: 24e5:    
2191: 24e5: RETURN
2192: 24f5: 
2193: 24f5: \***********************************************************************
2194: 24f5: \*
2195: 24f5: \*    CREATE.SRSXF.DIR
2196: 24f5: \*                
2197: 24f5: \*
2198: 24f5: \***********************************************************************
2199: 24f5: CREATE.SRSXF.DIR:
2200: 2505: 
2201: 2505:     WRITE FORM "C63" ;#SRSXF.DIR.SESS% ; SRSXF.STRING$	
2202: 252d: 
2203: 252d: RETURN  
2204: 253d: 
2205: 253d: \***********************************************************************
2206: 253d: \*
2207: 253d: \*    CREATE.SRPDF.DIR  
2208: 253d: \*               
2209: 253d: \*
2210: 253d: \***********************************************************************
2211: 253d: CREATE.SRPDF.DIR:  
2212: 254d: 
2213: 254d:     WRITE FORM "C169" ;#SRPDF.DIR.SESS% ; SRPDF.ARRAY$(J%)   
2214: 2587: 
2215: 2587: RETURN
2216: 2597: 
2217: 2597: \***********************************************************************
2218: 2597: \*
2219: 2597: \*    REKEY.SRPOG  
2220: 2597: \*               
2221: 2597: \*
2222: 2597: \***********************************************************************
2223: 2597:   
2224: 2597:   REKEY.SRPOG:   
2225: 25a7:       
2226: 25a7:     
2227: 25a7:     SRPOG.TEMP.NAME$ = "ADXLXACN::D:\ADX_UDT3\SRPOG.TST"
2228: 25bc: 
2229: 25bc:     PROG.NAME$ = "C:\ADX_SPGM\COMMAND.286"
2230: 25d1:     COMM.TAIL$ = "-C TURBO.286 REKEY"     + " "                         \
2231: 2668:                    +  SRPOG.FILE.NAME$    + " "                         \
2232: 2668:                    +  SRPOG.TEMP.NAME$    + " "                         \
2233: 2668:                    + "-R:" + STR$(6000)   + " "                         \
2234: 2668:                    +  SPACE$ +                                          \
2235: 2668:                    + "-O"  +  " "         + " "                         \
2236: 2668:                    + "-Z"  +  " "         + " "                         \
2237: 2668:                    + "-D:" + STR$(3)      + " "                         !
2238: 2668: 
2239: 2668:     SVC.PARAM$   = STRING$(28,"0")
2240: 2686:     GOSUB EXECUTE.SVC
2241: 2698: 
2242: 2698:     SRPOG.FLAG$ = "E"
2243: 26ad: 
2244: 26ad: RETURN
2245: 26bd: 
2246: 26bd: 
2247: 26bd: RETURN
2248: 26cd: 
2249: 26cd: \***********************************************************************
2250: 26cd: \*
2251: 26cd: \*    CREATE.SRMOD.KEY  
2252: 26cd: \*               
2253: 26cd: \*
2254: 26cd: \***********************************************************************
2255: 26cd: CREATE.SRMOD.KEY:
2256: 26dd: 
2257: 26dd:      PRINT  TIME.STAMP$(2)  + "-Creating SRMOD Key file from direct file"
2258: 270b:      PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)                            \
2259: 2748:                      + "-Creating SRMOD Key file from direct file"   
2260: 2748:      
2261: 2748:      CLOSE SRMOD.DIR.SESS%
2262: 275d: 
2263: 275d:      PROG.NAME$ = "C:\ADX_SPGM\COMMAND.286"
2264: 2772:      COMM.TAIL$ = "-C TURBO.286 KEYUP"     + " "                         \
2265: 2832:                    +  SRMOD.DIR.NAME$     + " "                         \
2266: 2832:                    +  SRMOD.KEY.NAME$     + " "                         \
2267: 2832:                    + "-k:" + STR$(6)      + " "                         \
2268: 2832:                    + "-l:" + STR$(508)    + " "                         \
2269: 2832:                    + "-r:" + STR$(8000)   + " "                         \
2270: 2832:                    + "-o"  +  " "         + " "                         \
2271: 2832:                    + "-d:" + STR$(3)      + " "                         !
2272: 2832: 
2273: 2832:      SVC.PARAM$   = STRING$(28,"0")
2274: 2850:      GOSUB EXECUTE.SVC
2275: 2862: 
2276: 2862: 
2277: 2862: RETURN
2278: 2872: \***********************************************************************
2279: 2872: \*                
2280: 2872: \*    CREATE.SRSXF.KEY  
2281: 2872: \*                
2282: 2872: \*
2283: 2872: \***********************************************************************
2284: 2872: CREATE.SRSXF.KEY:
2285: 2882: 
2286: 2882:      PRINT  TIME.STAMP$(2)  + "-Creating SRSXF Key file from direct file"
2287: 28b0:      PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)                           \
2288: 28ed:                   + "-Creating SRSXF Key file from direct file" 
2289: 28ed: 
2290: 28ed:      CLOSE SRSXF.DIR.SESS%
2291: 2902: 
2292: 2902:      PROG.NAME$ = "C:\ADX_SPGM\COMMAND.286"
2293: 2917:      COMM.TAIL$ = "-C TURBO.286 KEYUP"     + " "                        \
2294: 29d7:                    +  SRSXF.DIR.NAME$     + " "                         \
2295: 29d7:                    +  SRSXF.KEY.NAME$     + " "                         \
2296: 29d7:                    + "-k:" + STR$(6)      + " "                         \
2297: 29d7:                    + "-l:" + STR$(63)     + " "                         \
2298: 29d7:                    + "-r:" + STR$(60000)  + " "                         \
2299: 29d7:                    + "-o"  +  " "         + " "                         \
2300: 29d7:                    + "-d:" + STR$(3)      + " "                         !
2301: 29d7: 
2302: 29d7:      SVC.PARAM$   = STRING$(28,"0")
2303: 29f5:      GOSUB EXECUTE.SVC
2304: 2a07: 
2305: 2a07: RETURN
2306: 2a17: 
2307: 2a17: \***********************************************************************
2308: 2a17: \*
2309: 2a17: \*    CREATE.SRPDF.KEY 
2310: 2a17: \*               
2311: 2a17: \*
2312: 2a17: \***********************************************************************
2313: 2a17: CREATE.SRPDF.KEY:
2314: 2a27: 
2315: 2a27:      PRINT  TIME.STAMP$(2)  + "-Creating SRPDF Key file from direct file"
2316: 2a55:      PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)                           \
2317: 2a92:                + "-Creating SRPDF Key file from direct file"
2318: 2a92:      
2319: 2a92:      CLOSE SRPDF.DIR.SESS%
2320: 2aa7: 
2321: 2aa7:      PROG.NAME$ = "C:\ADX_SPGM\COMMAND.286"
2322: 2abc:      COMM.TAIL$ = "-C TURBO.286 KEYUP"     + " "                        \
2323: 2b7c:                    +  SRPDF.DIR.NAME$    + " "                          \
2324: 2b7c:                    +  SRPDF.KEY.NAME$    + " "                          \
2325: 2b7c:                    + "-k:" + STR$(4)     + " "                          \
2326: 2b7c:                    + "-l:" + STR$(169)   + " "                          \
2327: 2b7c:                    + "-r:" + STR$(6000)  + " "                          \
2328: 2b7c:                    + "-o"  +  " "        + " "                          \
2329: 2b7c:                    + "-d:" + STR$(3)     + " "                          !
2330: 2b7c: 
2331: 2b7c:      SVC.PARAM$   = STRING$(28,"0")
2332: 2b9a:      GOSUB EXECUTE.SVC
2333: 2bac:     
2334: 2bac: RETURN
2335: 2bbc: 
2336: 2bbc: \*****************************************************************************
2337: 2bbc: \***    SUBROUTINE : EXECUTE.SVC                                             *
2338: 2bbc: \***    DETAILS    : EXECUTES APPLICATION ASYNC                              *
2339: 2bbc: \*****************************************************************************
2340: 2bbc: 
2341: 2bbc: EXECUTE.SVC:
2342: 2bcc: 
2343: 2bcc:      PINFO.TABLE$  = "DURATION  " + CHR$(200) + STRING$(9,CHR$(00))
2344: 2c07:      PROG.NAME$   = PROG.NAME$ + CHR$(00)
2345: 2c2a:      COMM.TAIL$   = COMM.TAIL$ + CHR$(00)
2346: 2c4d:      CALL PUTN4(SVC.PARAM$,  0, 00000000H)
2347: 2c72:      CALL PUTN4(SVC.PARAM$,  4, 00000000H)
2348: 2c97:      CALL PUTN4(SVC.PARAM$,  8, SADD(PROG.NAME$) + 2)
2349: 2cc9:      CALL PUTN4(SVC.PARAM$, 12, SADD(COMM.TAIL$) + 2)
2350: 2cfb:      CALL PUTN4(SVC.PARAM$, 16, LEN(COMM.TAIL$) - 1)
2351: 2d2c:      CALL PUTN4(SVC.PARAM$, 20, SADD(PINFO.TABLE$) + 2)
2352: 2d61:      CALL PUTN4(SVC.PARAM$, 24, 00000000H)
2353: 2d86:      CALL FLEXOSSVC(38, SVC.PARAM$)
2354: 2da3: 
2355: 2da3: RETURN
2356: 2db3: \***********************************************************************
2357: 2db3: \*
2358: 2db3: \*    STOP.BACKGROUNDS 
2359: 2db3: \*                
2360: 2db3: \*
2361: 2db3: \***********************************************************************
2362: 2db3: STOP.BACKGROUNDS:
2363: 2dc3:  
2364: 2dc3:      PRINT  TIME.STAMP$(2)  + "-Stopping BGMON Application"
2365: 2df1:      PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)                             \
2366: 2e2e:                                + "-Stopping BGMON Application"   
2367: 2e2e:    
2368: 2e2e:      CALL OSSHELL("C:\ADX_UPGM\BGSTOP" + SPACE$ + "ADX_UPGM:BGMON.286")   
2369: 2e59:    
2370: 2e59:      PRINT  TIME.STAMP$(2)  + "-Stopping TRANSACT Application"
2371: 2e87:      PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)                            \
2372: 2ec4:                        + "-Stopping TRANSACT Application" 
2373: 2ec4:    
2374: 2ec4:      CALL OSSHELL("C:\ADX_UPGM\BGSTOP" + SPACE$ + "ADX_UPGM:TRANSACT.286")  
2375: 2eef:  
2376: 2eef: RETURN
2377: 2eff: 
2378: 2eff: \***********************************************************************
2379: 2eff: \*
2380: 2eff: \*    BACKUP.ORIGINAL
2381: 2eff: \*                
2382: 2eff: \*
2383: 2eff: \***********************************************************************
2384: 2eff: BACKUP.ORIGINAL:
2385: 2f0f: 
2386: 2f0f:    PRINT  TIME.STAMP$(2)  + "-Creating backups"
2387: 2f3d:    PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)  + "-Creating backups"    
2388: 2f7a: 
2389: 2f7a:    CALL ADXCOPYF(RC%,"ADXLXACN::D:\ADX_UDT3\SRPOG.DAT",                 \
2390: 2fd6:                      "ADXLXACN::D:\SRPOG.DAT",0,0)   
2391: 2fd6: 
2392: 2fd6:    IF RC% = 0 THEN BEGIN
2393: 2ff5: 
2394: 2ff5:        PRINT  TIME.STAMP$(2)  + "-Backing up of SRPOG Successful"
2395: 3023:        PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)                         \
2396: 3060:                      + "-Backing up of SRPOG Successful"
2397: 3060: 
2398: 3060:    ENDIF
2399: 3068: 
2400: 3068:    CALL ADXCOPYF(RC%,"ADXLXACN::D:\ADX_UDT3\SRMOD.DAT",                 \
2401: 30c4:                      "ADXLXACN::D:\SRMOD.DAT",0,0)
2402: 30c4: 
2403: 30c4:    IF RC% = 0 THEN BEGIN
2404: 30e3: 
2405: 30e3:        PRINT  TIME.STAMP$(2)  + "-Backing up of SRMOD Successful"
2406: 3111:        PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)                         \
2407: 314e:              + "-Backing up of SRMOD Successful"
2408: 314e: 
2409: 314e:    ENDIF   
2410: 3156: 
2411: 3156: 
2412: 3156:    CALL ADXCOPYF(RC%,"ADXLXACN::D:\ADX_UDT3\SRSXF.DAT",                 \
2413: 31b2:                      "ADXLXACN::D:\SRSXF.DAT",0,0) 
2414: 31b2: 
2415: 31b2:    IF RC% = 0 THEN BEGIN
2416: 31d1: 
2417: 31d1:        PRINT  TIME.STAMP$(2)  + "-Backing up of SRSXF Successful"
2418: 31ff:        PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)                         \
2419: 323c:                               + "-Backing up of SRSXF Successful"
2420: 323c: 
2421: 323c:    ENDIF
2422: 3244: 
2423: 3244:    CALL ADXCOPYF(RC%,"ADXLXACN::D:\ADX_UDT3\SRPDF.DAT",                 \
2424: 32a0:                      "ADXLXACN::D:\SRPDF.DAT",0,0)   
2425: 32a0: 
2426: 32a0:    IF RC% = 0 THEN BEGIN
2427: 32bf: 
2428: 32bf:        PRINT  TIME.STAMP$(2)  + "-Backing up of SRPDF Successful"
2429: 32ed:        PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)                         \
2430: 332a:                         + "-Backing up of SRPDF Successful"
2431: 332a: 
2432: 332a:    ENDIF
2433: 3332: 
2434: 3332: RETURN
2435: 3342: 
2436: 3342: \***********************************************************************
2437: 3342: \*
2438: 3342: \*    DELETE.EXISTING 
2439: 3342: \*              
2440: 3342: \*
2441: 3342: \***********************************************************************
2442: 3342: DELETE.EXISTING:    
2443: 3352: 
2444: 3352:    PRINT  TIME.STAMP$(2)  + "-Deleting SRMOD original"
2445: 3380:    PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)                            \
2446: 33bd:                                      + "-Deleting SRMOD original"    
2447: 33bd:   
2448: 33bd:    OPEN SRMOD.FILE.NAME$ AS SRMOD.SESS.NUM%
2449: 33e4: 
2450: 33e4:    DELETE SRMOD.SESS.NUM%
2451: 33f8:    
2452: 33f8:    PRINT  TIME.STAMP$(2)  + "-Deleting SRPDF original"
2453: 3426:    PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)  +                         \
2454: 3463:                                          "-Deleting SRPDF original"    
2455: 3463:   
2456: 3463:    OPEN SRPDF.FILE.NAME$ AS SRPDF.SESS.NUM%
2457: 348a: 
2458: 348a:    DELETE SRPDF.SESS.NUM%
2459: 349e:    
2460: 349e:    PRINT  TIME.STAMP$(2)  + "-Deleting SRSXF original"
2461: 34cc:    PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)  +                          \
2462: 3509:                                      "-Deleting SRSXF original"    
2463: 3509:   
2464: 3509:    OPEN SRSXF.FILE.NAME$ AS SRSXF.SESS.NUM%
2465: 3530: 
2466: 3530:    DELETE SRSXF.SESS.NUM%  
2467: 3544: 
2468: 3544: RETURN
2469: 3554: 
2470: 3554: \***********************************************************************
2471: 3554: \*
2472: 3554: \*    COPY.NEW 
2473: 3554: \*             
2474: 3554: \*
2475: 3554: \***********************************************************************
2476: 3554: COPY.NEW:    
2477: 3564: 
2478: 3564:    PRINT  TIME.STAMP$(2)  + "-Rekeying SRPOG"
2479: 3592:    PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)  + "-Rekeying SRPOG"    
2480: 35cf:    
2481: 35cf:    GOSUB REKEY.SRPOG                                                    ! ARG
2482: 35e1: 
2483: 35e1:    CALL ADXCOPYF(RC%,"ADXLXACN::W:\SRMOD.KEY",                         \
2484: 363d:                      "ADXLXACN::D:\ADX_UDT3\SRMOD.DAT",0,0)   
2485: 363d: 
2486: 363d:    IF RC% = 0 THEN BEGIN
2487: 365f: 
2488: 365f:        PRINT  TIME.STAMP$(2)  + "- New SRMOD has been copied successfuly"
2489: 368d:        PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)                         \
2490: 36ca:                 + "-New SRMOD has been copied successfuly"
2491: 36ca:        SRMOD.FLAG$ = "E"
2492: 36df: 
2493: 36df:    ENDIF
2494: 36e7:    
2495: 36e7:    CALL ADXCOPYF(RC%,"ADXLXACN::W:\SRSXF.KEY",                          \
2496: 3743:                      "ADXLXACN::D:\ADX_UDT3\SRSXF.DAT",0,0)   
2497: 3743: 
2498: 3743:    IF RC% = 0 THEN BEGIN
2499: 3765: 
2500: 3765:        PRINT  TIME.STAMP$(2)  + "- New SRSXF has been copied successfuly"
2501: 3793:        PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)                         \
2502: 37d0:                       + "-New SRSXF has been copied successfuly"
2503: 37d0:        SRSXF.FLAG$ = "E"
2504: 37e5: 
2505: 37e5:    ENDIF   
2506: 37ed: 
2507: 37ed:    CALL ADXCOPYF(RC%,"ADXLXACN::W:\SRPDF.KEY",                          \
2508: 3849:                      "ADXLXACN::D:\ADX_UDT3\SRPDF.DAT",0,0) 
2509: 3849: 
2510: 3849:    IF RC% = 0 THEN BEGIN
2511: 386b:    
2512: 386b:        PRINT  TIME.STAMP$(2)  + "- New SRPDF has been copied successfuly"
2513: 3899:        PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)                         \
2514: 38d6:                       + "-New SRPDF has been copied successfuly"
2515: 38d6: 
2516: 38d6:        SRPDF.FLAG$ = "E"
2517: 38eb: 
2518: 38eb:    ENDIF
2519: 38f3: 
2520: 38f3: 
2521: 38f3: RETURN
2522: 3903: 
2523: 3903: 
2524: 3903: \***********************************************************************
2525: 3903: \*
2526: 3903: \*    START.BACKGROUNDS 
2527: 3903: \*                
2528: 3903: \*
2529: 3903: \***********************************************************************
2530: 3903: START.BACKGROUNDS:
2531: 3913:  
2532: 3913:    PRINT  TIME.STAMP$(2)  + "-Starting BGMON Application"
2533: 3941:    PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)                             \
2534: 397e:                                + "-Starting BGMON Application"   
2535: 397e:    
2536: 397e:    CALL OSSHELL("C:\ADX_UPGM\BGSTART" + SPACE$ + "ADX_UPGM:BGMON.286")   
2537: 39a9:    
2538: 39a9:    PRINT  TIME.STAMP$(2)  + "-Starting TRANSACT Application"
2539: 39d7:    PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)                             \
2540: 3a14:                                    + "-Starting TRANSACT Application"    
2541: 3a14:    
2542: 3a14:    CALL OSSHELL("C:\ADX_UPGM\BGSTART" + SPACE$                          \
2543: 3a3f:                                            + "ADX_UPGM:TRANSACT.286")    
2544: 3a3f:  
2545: 3a3f: RETURN
2546: 3a4f: 
2547: 3a4f: \***********************************************************************
2548: 3a4f: \*
2549: 3a4f: \*    TERMINATION   
2550: 3a4f: \*               
2551: 3a4f: \*
2552: 3a4f: \***********************************************************************
2553: 3a4f: TERMINATION:
2554: 3a5f: 
2555: 3a5f:    GOSUB WRITE.PHKEEP.OK     
2556: 3a71:    
2557: 3a71:    IF ERROR.CNT% = 0 THEN BEGIN  
2558: 3a8f: 
2559: 3a8f:        PRINT  TIME.STAMP$(2)  + "-Renaming error file to OK file"
2560: 3abd:        PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)                         \
2561: 3afa:         + "-Renaming error file to OK file"    
2562: 3afa: 
2563: 3afa:        RC% = RENAME("W:/PHKEEP.OK","W:/PHKEEP.ERR")
2564: 3b1d: 
2565: 3b1d:  
2566: 3b1d:        PRINT  TIME.STAMP$(2)  + "-Read " +  STR$(SRPOG%) +              \
2567: 3b87:                           " SRPOG records"  + \
2568: 3b87:                           + " Written " + STR$(SRPOG.COUNT%) +          \
2569: 3b87:                             " In to New file"
2570: 3b87: 
2571: 3b87:        PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)  + "-Read " +           \
2572: 3c00:                                                   STR$(SRPOG%)      +   \
2573: 3c00:          " SRPOG records" + " Written " + STR$(SRPOG.COUNT%)            \
2574: 3c00:                                         + " In to New file"
2575: 3c00: 
2576: 3c00: 
2577: 3c00:        PRINT  TIME.STAMP$(2)  + "-Read " +  STR$(SRMOD%) +              \
2578: 3c6a:                           " SRMOD records"  + \
2579: 3c6a:                           + " Written " + STR$(SRMOD.COUNT%) +          \
2580: 3c6a:                             " In to New file"
2581: 3c6a: 
2582: 3c6a:        PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)  + "-Read " +           \
2583: 3ce3:                                                   STR$(SRMOD%)      +   \
2584: 3ce3:          " SRMOD records" + " Written " + STR$(SRMOD.COUNT%)            \
2585: 3ce3:                                         + " In to New file"
2586: 3ce3: 
2587: 3ce3:        PRINT  TIME.STAMP$(2)  + "-Read " +  STR$(SRSXF%)                \
2588: 3d4d:                                         +  " SRSXF records"  +          \
2589: 3d4d:                          + " Written " + STR$(SRSXF.COUNT%)             \
2590: 3d4d:                          + " In to New file"
2591: 3d4d: 
2592: 3d4d:        PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)  + "-Read "             \
2593: 3dc6:                                               +  STR$(SRSXF%) +         \
2594: 3dc6:         " SRSXF records" + " Written " + STR$(SRSXF.COUNT%)             \
2595: 3dc6:                                     + " In to New file"
2596: 3dc6: 
2597: 3dc6:        PRINT  TIME.STAMP$(2)  + "-Read " +  STR$(SRPDF%)                \
2598: 3e30:                         + " SRPDF records"  + \
2599: 3e30:                         + " Written " + STR$(SRPDF.COUNT%)              \
2600: 3e30:                         + " In to New file"
2601: 3e30: 
2602: 3e30:        PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)  + "-Read " +           \
2603: 3ea9:                          STR$(SRPDF%) +  \
2604: 3ea9:        " SRPDF records" + " Written " + STR$(SRPDF.COUNT%)              \
2605: 3ea9:        + " In to New file"
2606: 3ea9: 
2607: 3ea9:        PRINT  TIME.STAMP$(2)  + "- Program completed successfully"
2608: 3ed7:        PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)                         \
2609: 3f14:               + "- Program completed successfuly"
2610: 3f14: 
2611: 3f14:    ENDIF
2612: 3f1c: 
2613: 3f1c: 
2614: 3f1c:    GOSUB CLOSE.FILES
2615: 3f2e:    GOSUB HOUSEKEEP.WDRIVE
2616: 3f40:    GOSUB DEALLOCATE.SESS.NUM
2617: 3f52:      
2618: 3f52: 
2619: 3f52: RETURN
2620: 3f62: 
2621: 3f62: \***********************************************************************
2622: 3f62: \*
2623: 3f62: \*    HOUSEKEEP.WDRIVE  
2624: 3f62: \*               
2625: 3f62: \*
2626: 3f62: \*********************************************************************** 
2627: 3f62: HOUSEKEEP.WDRIVE:
2628: 3f72: 
2629: 3f72:    CALL OSSHELL ("IF EXIST W:/SRPOG.DIR DEL W:/SRPOG.DIR")
2630: 3f86:    CALL OSSHELL ("IF EXIST W:/SRMOD.DIR DEL W:/SRMOD.DIR")
2631: 3f9a:    CALL OSSHELL ("IF EXIST W:/SRSXF.DIR DEL W:/SRSXF.DIR")
2632: 3fae:    CALL OSSHELL ("IF EXIST W:/SRPDF.DIR DEL W:/SRPDF.DIR")
2633: 3fc2:    CALL OSSHELL ("IF EXIST W:/SRPOG.KEY DEL W:/SRPOG.KEY")
2634: 3fd6:    CALL OSSHELL ("IF EXIST W:/SRMOD.KEY DEL W:/SRMOD.KEY")
2635: 3fea:    CALL OSSHELL ("IF EXIST W:/SRSXF.KEY DEL W:/SRSXF.KEY")
2636: 3ffe:    CALL OSSHELL ("IF EXIST W:/SRPDF.KEY DEL W:/SRPDF.KEY")
2637: 4012: 
2638: 4012: 
2639: 4012: RETURN
2640: 4022: 
2641: 4022: \***********************************************************************
2642: 4022: \*
2643: 4022: \*    ERROR.LOG  
2644: 4022: \*               
2645: 4022: \*
2646: 4022: \***********************************************************************
2647: 4022: ERROR.LOG: 
2648: 4032:         
2649: 4032:          VAR.STRING.1$ = FILE.OPERATION$                     +          \
2650: 40c8:                 CHR$(SHIFT(CURRENT.REPORT.NUM%, 8) AND 0FFH) +          \
2651: 40c8:                 CHR$(CURRENT.REPORT.NUM% AND 0FFH)           +          \
2652: 40c8:                 CURRENT.CODE$
2653: 40c8:          VAR.STRING.2$ = "PHKEEP"
2654: 40dd:          MESSAGE.NO%   = 0
2655: 40f2:          EVENT.NO%     = 106
2656: 4109: 
2657: 4109:          RC% = APPLICATION.LOG(MESSAGE.NO%,VAR.STRING.1$,               \
2658: 414c:                       VAR.STRING.2$,EVENT.NO%)
2659: 414c: 
2660: 414c:          GOSUB WRITE.PHKEEP.OK
2661: 415e: 
2662: 415e:          GOTO END.PROGRAM
2663: 4169: 
2664: 4169: RETURN
2665: 4179: 
2666: 4179: \***********************************************************************
2667: 4179: \*
2668: 4179: \*    CLOSE.FILES:
2669: 4179: \*                
2670: 4179: \*
2671: 4179: \***********************************************************************
2672: 4179: 
2673: 4179: CLOSE.FILES:
2674: 4189:    
2675: 4189:    CLOSE PHKEEP.SESS.NUM%
2676: 419e:    
2677: 419e: RETURN  
2678: 41ae: \***********************************************************************
2679: 41ae: \*
2680: 41ae: \*    DEALLOCATE.SESS.NUM  
2681: 41ae: \*                
2682: 41ae: \*
2683: 41ae: \***********************************************************************
2684: 41ae: DEALLOCATE.SESS.NUM: 
2685: 41be: 
2686: 41be:     FUNCTION.FLAG$ = "C"   
2687: 41d3:     
2688: 41d3:     PASSED.INTEGER% = SRPOG.REPORT.NUM%                                
2689: 41f0:     PASSED.STRING$  = SRPOG.FILE.NAME$                                 
2690: 420e:     GOSUB CALL.F20.SESS.NUM.UTILITY                                    
2691: 4220:     SRPOG.SESS.NUM% = F20.INTEGER.FILE.NO%                             
2692: 4236: 
2693: 4236:     PASSED.INTEGER% = SRMOD.REPORT.NUM%                                
2694: 4253:     PASSED.STRING$  = SRMOD.FILE.NAME$                                 
2695: 4271:     GOSUB CALL.F20.SESS.NUM.UTILITY                                    
2696: 4283:     SRMOD.SESS.NUM% = F20.INTEGER.FILE.NO%                             
2697: 4299: 
2698: 4299:     PASSED.INTEGER% = SRSXF.REPORT.NUM%                                
2699: 42b6:     PASSED.STRING$  = SRSXF.FILE.NAME$                                 
2700: 42d4:     GOSUB CALL.F20.SESS.NUM.UTILITY                                    
2701: 42e6:     SRSXF.SESS.NUM% = F20.INTEGER.FILE.NO%                             
2702: 42fc: 
2703: 42fc:     PASSED.INTEGER% = SRPDF.REPORT.NUM%                                
2704: 4319:     PASSED.STRING$  = SRPDF.FILE.NAME$                                 
2705: 4337:     GOSUB CALL.F20.SESS.NUM.UTILITY                                    
2706: 4349:     SRPDF.SESS.NUM% = F20.INTEGER.FILE.NO%                             
2707: 435f: 
2708: 435f:     PASSED.INTEGER% = PHKEEP.SESS.NUM%                                 
2709: 4376:     PASSED.STRING$  = PHKEEP.LOG.NAME$                                 
2710: 4391:     GOSUB CALL.F20.SESS.NUM.UTILITY                                    
2711: 43a3:     PHKEEP.SESS.NUM% = F20.INTEGER.FILE.NO%                            
2712: 43be: 
2713: 43be:     PASSED.INTEGER% = PHKEEP.OK.SESS%                                  
2714: 43d5:     PASSED.STRING$  = PHKEEP.OK.NAME$                                  
2715: 43f0:     GOSUB CALL.F20.SESS.NUM.UTILITY                                    
2716: 4402:     PHKEEP.OK.SESS% = F20.INTEGER.FILE.NO%                             
2717: 441d: 
2718: 441d:     PASSED.INTEGER% = 458                                              
2719: 4434:     PASSED.STRING$  = SRMOD.DIR.NAME$                                  
2720: 444f:     GOSUB CALL.F20.SESS.NUM.UTILITY                                    
2721: 4461:     SRMOD.DIR.SESS% = F20.INTEGER.FILE.NO%                             
2722: 447c: 
2723: 447c:     PASSED.INTEGER% = 459                                              
2724: 4493:     PASSED.STRING$  = SRPDF.DIR.NAME$                                  
2725: 44ae:     GOSUB CALL.F20.SESS.NUM.UTILITY                                    
2726: 44c0:     SRPDF.DIR.SESS% = F20.INTEGER.FILE.NO%                             
2727: 44db: 
2728: 44db:     PASSED.INTEGER% = 460                                              
2729: 44f2:     PASSED.STRING$  = SRSXF.DIR.NAME$                                  
2730: 450d:     GOSUB CALL.F20.SESS.NUM.UTILITY                                    
2731: 451f:     SRSXF.DIR.SESS% = F20.INTEGER.FILE.NO%                             
2732: 453a: 
2733: 453a: 
2734: 453a: RETURN
2735: 454a: 
2736: 454a: \***********************************************************************
2737: 454a: \*
2738: 454a: \*    ERROR.DETECTED  
2739: 454a: \*              
2740: 454a: \*
2741: 454a: \***********************************************************************
2742: 454a: ERROR.DETECTED:     
2743: 455a:    
2744: 455a: 
2745: 455a:      ERROR.CNT% = ERROR.CNT% + 1
2746: 4573: 	 
2747: 4573: 	 IF ERR = "OE" AND ERRF% = SRMAP.SESS.NUM% THEN BEGIN
2748: 45c6:          PRINT  TIME.STAMP$(2)  + "-NO SRMAP File" +                    \
2749: 45f8:                                         " program can't be continued"
2750: 45f8:          PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)                       \
2751: 4635:                 + "-NO SRMAP File, program can't be continued"
2752: 4635:          SRMAP.FLAG$ = "X" 
2753: 464a:          GOSUB ERROR.LOG
2754: 465c:      ENDIF
2755: 4664: 
2756: 4664:      IF ERR = "OE" AND ERRF% = SRPOG.SESS.NUM% THEN BEGIN
2757: 46b7:          PRINT  TIME.STAMP$(2)  + "-NO SRPOG File" +                    \
2758: 46e9:                                         " program can't be continued"
2759: 46e9:          PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)                       \
2760: 4726:                 + "-NO SRPOG File, program can't be continued"
2761: 4726:          SRPOG.FLAG$ = "X" 
2762: 473b:          GOSUB ERROR.LOG
2763: 474d:      ENDIF
2764: 4755:    
2765: 4755:      IF ERR = "OE" AND ERRF% = SRMOD.SESS.NUM% THEN BEGIN
2766: 47a8:          PRINT  TIME.STAMP$(2)  + "-NO SRMOD File" +                    \
2767: 47da:                                     ",program can't be continued"
2768: 47da:          PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)                       \
2769: 4817:                 + "-NO SRMOD File, program can't be continued"
2770: 4817:          SRMOD.FLAG$ = "X" 
2771: 482c:          GOSUB ERROR.LOG
2772: 483e:      ENDIF
2773: 4846:    
2774: 4846:      IF ERR = "OE" AND ERRF% = SRSXF.SESS.NUM% THEN BEGIN
2775: 4899:          PRINT  TIME.STAMP$(2)  + "-NO SRSXF File," +                   \
2776: 48cb:                                        "program can't be continued"
2777: 48cb:          PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)                       \
2778: 4908:               + "-NO SRSXF File, program can't be continued"
2779: 4908:          SRSXF.FLAG$ = "X" 
2780: 491d:          GOSUB ERROR.LOG
2781: 492f:      ENDIF
2782: 4937:    
2783: 4937:      IF ERR = "OE" AND ERRF% = SRPDF.SESS.NUM% THEN BEGIN
2784: 498a:          PRINT  TIME.STAMP$(2)  + "-NO SRPDF File," +                   \
2785: 49bc:                                         "program can't be continued"
2786: 49bc:          PRINT  #PHKEEP.SESS.NUM%; TIME.STAMP$(2)                       \
2787: 49f9:                + "-NO SRPDF File, program can't be continued"
2788: 49f9:          SRPDF.FLAG$ = "X" 
2789: 4a0e:          GOSUB ERROR.LOG
2790: 4a20:      ENDIF    
2791: 4a28:    
2792: 4a28:      GOSUB ERROR.LOG
2793: 4a3a:    
2794: 4a3a: RETURN  
2795: 4a4a: 
2796: 4a4a: \***********************************************************************
2797: 4a4a: \*
2798: 4a4a: \*    END.PROGRAM 
2799: 4a4a: \*              
2800: 4a4a: \*
2801: 4a4a: \***********************************************************************
2802: 4a4a: 
2803: 4a4a:    END.PROGRAM:
2804: 4a5f: 
2805: 4a5f:    END 
2806: 4a5f:        
2807: 4a5f: 
2808: 4a5f: End of Compilation
