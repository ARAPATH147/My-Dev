    1: 	    %INCLUDE PSBF01G.J86
    2=a	    REM \
    3=a	    \*******************************************************************
>************
    4=a	    \*******************************************************************
>************
    5=a	    \***
    6=a	    \***       %INCLUDE FOR GLOBAL DEFINITIONS FOR FUNCTION APPLICATION.
>LOG
    7=a	    \***
    8=a	    \***                FUNCTION NUMBER    : PSBF01
    9=a	    \***
   10=a	    \***                REFERENCE          : PSBF01G.J86
   11=a	    \***
   12=a	    \***                DATE OF LAST AMENDMENT  - 27/2/86
   13=a	    \***
   14=a	    \***
   15=a	    \*******************************************************************
>************
   16=a	    
   17=a	          INTEGER GLOBAL  F01.RETURN.CODE%
   18=a	    
   19=a	    
   20: 	    %INCLUDE PSBF20G.J86
   21=a	    REM\
   22=a	    \*******************************************************************
>************
   23=a	    \*******************************************************************
>************
   24=a	    \***
   25=a	    \***     %INCLUDE GLOBAL VARIABLE DEFINITIONS FOR SESS.NUM.UTILITY F
>UNCTION
   26=a	    \***
   27=a	    \***                       REFERENCE     : PSBF20G.J86
   28=a	    \*** 
   29=a	    \***     Version A              Bruce Scrive                   5th M
>ay 1988   
   30=a	    \*** 
   31=a	    \***     Version B              Robert Cowey                   7th M
>ay 1991
   32=a	    \***     Global variable F20.INTEGER.FILE.NO% changed from one byte 
>integer
   33=a	    \***     to two byte integer.
   34=a	    \***
   35=a	    \***     Version D              Andrew Wedgeworth             1st Ju
>ly 1992
   36=a	    \***     F20.RETURN.CODE% removed as it is no longer required.
   37=a	    \***
   38=a	    \*******************************************************************
>************
   39=a	    \*******************************************************************
>************
   40=a	    
   41=a	          STRING    GLOBAL F20.FILE.NAME$,                              
>   \
   42=a	                           F20.STRING.FILE.NO$,                         
>   \
   43=a	                           F20.TABLE.DIMENSIONED.FLAG$,                 
>   \
   44=a	                           SESS.NUM.TABLE$(1)
   45=a	    
   46=a	          INTEGER*2 GLOBAL F20.INTEGER.FILE.NO%
   47=a	    
   48=a	          ! 1 line deleted from here                                    
>   ! DAW 
   49=a	    
   50: 	    %INCLUDE IRFDEC.J86 
   51=a	    
   52=a	    \*******************************************************************
>***************
   53=a	    \***
   54=a	    \***       %INCLUDE FOR ITEM RECORD FILE - FIELD DECLARATIONS
   55=a	    \***                                     - FILE REFERENCE PARAMETERS
   56=a	    \***
   57=a	    \***                      FILE TYPE    : Keyed
   58=a	    \***
   59=a	    \***                      REFERENCE    : IRFDEC.J86
   60=a	    \***
   61=a	    \***     Version A               Andrew Wedgeworth            29th J
>une 1992
   62=a	    \***
   63=a	    \***     Version B               Andrew Wedgeworth        14th Decem
>ber 1992
   64=a	    \***     Version letter incremented to match other IRF code.
   65=a	    \***
   66=a	    \***     Version C             Steve Windsor          12.02.93
   67=a	    \***     Version letter incremented to match other IRF code.
   68=a	    \***
   69=a	    \***     Version D             Steve Windsor          12.05.93
   70=a	    \***     Version letter incremented to match other IRF code.
   71=a	    \***
   72=a	    \***     Version E           Steve Perkins       20th September 1993
   73=a	    \***     Deals project : Handling of Converted/Unconverted records
   74=a	    \***     ++   Anything with 'Delete' after initials should be   ++
   75=a	    \***     ++   deleted once the IRF has been converted in all    ++
   76=a	    \***     ++   stores.                                           ++
   77=a	    \***
   78=a	    \***     Version F           Mark Walker            5th January 1994
   79=a	    \***     Version letter incremented to match other IRF code.
   80=a	    \***
   81=a	    \***     Version 96A         Mark Walker               22nd May 1995
   82=a	    \***     Definition for IRF.POINTS% added.
   83=a	    \***
   84=a	    \***                     Stuart McConnachie           12th June 1995
   85=a	    \***     INDICAT3% comments added for discount/loyalty flags.
   86=a	    \***
   87=a	    \***     Version for 96C  Andrew Wedgeworth            22nd May 1996
   88=a	    \***     Removed IRF.FILLER$ field, as this is now redundant.
   89=a	    \***
   90=a	    \***     Version G     Stuart William McConnachie      11th February
> 2000
   91=a	    \***     Converted IRF.INDICAT2$ to integer flag byte.
   92=a	    \***
   93=a	    \***     REVISION 1.6.               ROBERT COWEY.               9 J
>UL 2002.
   94=a	    \***     Major changes for 2002 Deals Rewrite project.
   95=a	    \***     Incorporated up to date record layout to assist development
> work
   96=a	    \***     (placed in the IRFDEC.J86 to make it visible from ...LST fi
>les).
   97=a	    \***     Moved various comments against variables to record layout.
   98=a	    \***     Relisted variables in alphabetical order.
   99=a	    \***     Deleted redundant variables associated with the old deals s
>ystem ...
  100=a	    \***     DEAL.NUM$, DEAL.SAVING$
  101=a	    \***     Retained variables that are otherwise redundant (to be set 
>to null X'00'
  102=a	    \***     within file functions) ...
  103=a	    \***     INDICAT2%, INDICAT4%, SALEQUAN$, POINTS%
  104=a	    \***     Defined variables to hold interpreted deals data for new de
>als system ...
  105=a	    \***     DEAL.NUM$(n) and LIST.ID%(n) (where 'n' represents entry 0,
> 1 and 2).
  106=a	    \***     These two variables are interpretations of DEAL.DATA% which
> is defined
  107=a	    \***     locally within IRFFUN.BAS to keep underlying data invisible
> to programs.
  108=a	    \***
  109=a	    \***     REVISION 1.7                ROBERT COWEY.               5 A
>UG 2002.
  110=a	    \***     Further changes for 2002 Deals Rewrite project (PSBF19 rela
>ted).
  111=a	    \***     Defined NEW.IRF.DATA$ as a global variable for use with new
> functions
  112=a	    \***     CONCAT.NEW.IRF.DATA$ and SPLIT.NEW.IRF.DATA$.
  113=a	    \***
  114=a	    \***     REVISION 1.8                ROBERT COWEY.              15 J
>UL 2003.
  115=a	    \***     Usage of INDICAT0% bit-3 X'08' changed to Item Contains Alc
>ohol.
  116=a	    \***     No changes to this file other than description.
  117=a	    \***     No changes to IRF file functions.
  118=a	    \***
  119=a	    \***     REVISION 1.9.      STUART WILLIAM MCCONNACHIE           22 
>OCT 2003.
  120=a	    \***     Changes to remove limit of 3 deals per item.
  121=a	    \***     Declaration of new variables for IRF Deal Extension file (I
>RFDEX).
  122=a	    \***
  123=a	    \***     REVISION 2.0.            ALAN CARR                       9 
>FEB 2006.
  124=a	    \***     Add new IRF.INDICAT8% 1 byte, amend IRF.UNUSED$ from 3 to 2
> bytes.
  125=a	    \***
  126=a	    \***     REVISION 2.1              TITTOO THOMAS                  01
> July 2011
  127=a	    \***     The IRF.UNUSED field is disintegrated to 2 new indicator fi
>elds
  128=a	    \***                      IRF.INDICAT9%   1 INT
  129=a	    \***                      IRF.INDICAT10%  1 INT
  130=a	    \***................................................................
>...............
  131=a	    
  132=a	    
  133=a	    \*******************************************************************
>***************
  134=a	    \***
  135=a	    \***    IRF RECORD LAYOUT - REVISION 1.7 - CORRECT FOR 2011 CORE Sto
>res PROJECT
  136=a	    \***
  137=a	    \***     1 11  UPD  BAR.CODE$   Without check digit - File KEY
  138=a	    \***    12  1  INT  INDICAT0%
  139=a	    \***                    X"01" - Contains statins                    
>       ! 2.2 TT
  140=a	    \***                    X"02" - Item not priced (giveaway)
  141=a	    \***                    X"04" - Item not returnable
  142=a	    \***                    X"08" - Item contains alcohol
  143=a	    \***                    X"10" - Blocked from sale                   
>       ! 2.2 TT
  144=a	    \***                    X"20" - Enforced price entry
  145=a	    \***                    X"40" - Enforced quantity entry
  146=a	    \***                    X"80" - Movement kept
  147=a	    \***    13  1  INT  INDICAT1%
  148=a	    \***                    X"01" - Asprin
  149=a	    \***                    X"02" - Paracetamol
  150=a	    \***                    X"04" - TPLU inclusion flag
  151=a	    \***                    X"08" - Giftcard item                       
>       ! 2.2 TT
  152=a	    \***                    X"10" - Withdrawn Block from sale           
>       ! 2.2 TT
  153=a	    \***                    X"20" - Non-solid dose painkiller           
>       ! 2.2 TT
  154=a	    \***                    X"40" - Insurance policy item               
>       ! 2.2 TT
  155=a	    \***                    X"80" - Ibuprofen
  156=a	    \***    14  2  INT  DEAL.DATA%(0)   Interpreted into sub-variables .
>..
  157=a	    \***                    X'3F' - into DEAL.NUM$(0) "0000" to "9999" (
>2 byte UPD)
  158=a	    \***                    X'C0' - into LIST.ID%(0) X'00' X
  159=a	    \***                                             X'01' A
  160=a	    \***                                             X'10' B
  161=a	    \***                                             X'11' C            
>       ! 1.9 RC
  162=a	    \***    16  1  INT  INDICAT8%                                       
>       ! 2.0 AJC
  163=a	    \***                    X"01" - Chlamydia NHS test kit              
>       ! 2.2 TT
  164=a	    \***                    X"02" - Chlamydia open sell test kit        
>       ! 2.2 TT
  165=a	    \***                    X"04" - Unrestricted group code             
>       ! 2.2 TT
  166=a	    \***                    X"08" - Nightingale Till prompt             
>       ! 2.2 TT
  167=a	    \***                    X"10" - Contains Ephedrine                  
>       ! 2.2 TT
  168=a	    \***                    X"60" -  X'00' - If also Blocked From Sale R
>ecall, ! 2.2 TT
  169=a	    \***                                        Emergency               
>       ! 2.2 TT
  170=a	    \***                             X'00' - If NOT Blocked From Sale Re
>call,  ! 2.2 TT
  171=a	    \***                                        No recall               
>       ! 2.2 TT
  172=a	    \***                             X'20' 100% returns                 
>       ! 2.2 TT
  173=a	    \***                             X'40' Withdrawn recall             
>       ! 2.2 TT
  174=a	    \***                             X'60' Reverse Logistics            
>       ! 2.2 TT
  175=a	    \***                    X"80" - WEEE item flag                      
>       ! 2.0 AJC
  176=a	    \***    17  1  INT  INDICAT9%
  177=a	    \***                    X'3F' - Disposal special instruction (0-63)
  178=a	    \***                    X"40" - Resaleable Indicator
  179=a	    \***                    X"80" - Boots.com Extended Indicator
  180=a	    \***    18  1  INT  INDICAT10%
  181=a	    \***                    X'07' - Age restrictions
  182=a	    \***                             X'00' - No Age restriction
  183=a	    \***                             X'01' - Age 12 or over
  184=a	    \***                             X'02' - Age 15 or over
  185=a	    \***                             X'03' - Age 16 or over
  186=a	    \***                             X'04' - Age 18 or over
  187=a	    \***                             X'05' - Age 21 or over
  188=a	    \***                             X'06' - Reserved
  189=a	    \***                             X'07' - Reserved
  190=a	    \***                    X'38' - Ethical classification
  191=a	    \***                             X'00' - No ethical classification
  192=a	    \***                             X'08' - Pharmacy medicine (P)
  193=a	    \***                             X'10' - General Sale License (GSL)
  194=a	    \***                             X'18' - Prescription Only Medicine 
>(POM)
  195=a	    \***                             X'20' - Reserved
  196=a	    \***                             X'28' - Reserved
  197=a	    \***                             X'30' - Reserved
  198=a	    \***                             X'38' - Reserved
  199=a	    \***                    X'C0' - Returns route
  200=a	    \***                             X'00' - Not Returnable (Destroy)
  201=a	    \***                             X'40' - Returns & Recovery
  202=a	    \***                             X'80' - Direct
  203=a	    \***                             X'C0' - Semi-centralised
  204=a	    \***    19  5  UPD  SALEPRIC$   Current price in pence
  205=a	    \***    24  1  INT  INDICAT5%   Guarantee duration
  206=a	    \***                    X'3F' - Lowest 6 bits indicate duration (1-6
>3)
  207=a	    \***                    X'40' - Contains Pseudoephedrine            
>       ! 2.2 TT
  208=a	    \***                    X'80' - Guarantee Duration Type             
>       ! 2.2 TT
  209=a	    \***                              (1 = Months, 0 = Years)           
>       ! 2.2 TT
  210=a	    \***    25 18  ASC  ITEMNAME$   Description used by till
  211=a	    \***    43  3  UPD  BOOTS.CODE$ Without check digit
  212=a	    \***    46  2  INT  DEAL.DATA%(1)   Similar structure to DEAL.DATA%(
>0)
  213=a	    \***    48  2  INT  DEAL.DATA%(2)   Similar structure to DEAL.DATA%(
>0)
  214=a	    \***    50  1  INT  INDICAT3%
  215=a	    \***                    X"01" - Discountexempt (item exempt from dis
>count)
  216=a	    \***                    X"02" - Boots brand item
  217=a	    \***                    X"04" - Item redeemable for loyalty
  218=a	    \***                    X"08" - Loyalty exempt (item exempt from loy
>alty)
  219=a	    \***                    X"10" - **Redundant                         
>       ! 2.2 TT
  220=a	    \***                    X"20" - Local Price active
  221=a	    \***                    X"40" - Stock system item
  222=a	    \***                    X"80" - **Redundant                         
>       ! 2.2 TT
  223=a	    \***
  224=a	    \***    Record Length 50
  225=a	    \***
  226=a	    \***
  227=a	    \***    IRF DEAL EXTENSION RECORD LAYOUT ! 1.9 RC
  228=a	    \***
  229=a	    \***     1  3  UPD  BOOTS.CODE$
  230=a	    \***     4  2  INT  IRF.DEAL.DATA%(3)   Similar structure to DEAL.DA
>TA%(0)
  231=a	    \***     6  2  INT  IRF.DEAL.DATA%(4)   Similar structure to DEAL.DA
>TA%(0)
  232=a	    \***     8  2  INT  IRF.DEAL.DATA%(5)   Similar structure to DEAL.DA
>TA%(0)
  233=a	    \***    10  2  INT  IRF.DEAL.DATA%(6)   Similar structure to DEAL.DA
>TA%(0)
  234=a	    \***    12  2  INT  IRF.DEAL.DATA%(7)   Similar structure to DEAL.DA
>TA%(0)
  235=a	    \***    14  2  INT  IRF.DEAL.DATA%(8)   Similar structure to DEAL.DA
>TA%(0)
  236=a	    \***    16  2  INT  IRF.DEAL.DATA%(9)   Similar structure to DEAL.DA
>TA%(0)
  237=a	    \***
  238=a	    \***    Record Length 17
  239=a	    \***
  240=a	    \*******************************************************************
>***************
  241=a	    
  242=a	    
  243=a	        STRING GLOBAL            \
  244=a	            IRF.ALT.FILE.NAME$,  \
  245=a	            IRF.BAR.CODE$,       \
  246=a	            IRF.BOOTS.CODE$,     \
  247=a	            IRF.DEAL.SAVING$,    \ 2 byte - deal saving amount (0 - œ99.
>99) ! ESP
  248=a	            IRF.DEPARTME$,       \ 3 byte UPD. Department number        
>  ! ESP Delete
  249=a	            IRF.FILE.NAME$,      \
  250=a	            IRF.HOLDING.PRICE$,  \ 4 byte UPD. Current H.O. price in pen
>ce if a local
  251=a	                                 \ price is in effect, zero otherwise.  
>   ! ESP Delete
  252=a	            IRF.ITEMNAME$,       \
  253=a	    \       IRF.MPGROUP$,        \ Removed SBH 31/1/96
  254=a	            IRF.RECORD$,         \                                      
>   ! ESP Delete
  255=a	            IRF.SALEPRIC$,       \
  256=a	            IRF.SALEQUAN$,       \ Redundant (set to null within functio
>ns)    ! 1.6 RC
  257=a	            IRF.UNUSED$,         \                                      
>                  ! 1.6 RC
  258=a	            NEW.IRF.DATA$        !                                      
>       ! 1.7 RC
  259=a	    
  260=a	        STRING GLOBAL            \                                      
>       ! 1.6 RC
  261=a	            IRF.DEAL.NUM$(1)                                            
>       ! 1.6 RC
  262=a	    
  263=a	        INTEGER*1 GLOBAL         \
  264=a	            IRF.DD.SUB%,         \ IRF.DEAL.DATA% subscript             
>       ! 1.6 RC
  265=a	            IRF.INDICAT0%,       \
  266=a	            IRF.INDICAT1%,       \
  267=a	            IRF.INDICAT2%,       \ Redundant (set to null within functio
>ns)    ! 1.6 RC
  268=a	            IRF.INDICAT3%,       \
  269=a	            IRF.INDICAT4%,       \ Redundant (set to null within functio
>ns)    ! 1.6 RC
  270=a	            IRF.INDICAT5%,       \                                      
>       ! 2.0 AJC
  271=a	            IRF.INDICAT8%,       \                                      
>       ! 2.0 AJC
  272=a	            IRF.INDICAT9%,       \                                      
>       ! 2.2 TT
  273=a	            IRF.INDICAT10%                                              
>       ! 2.2 TT
  274=a	    
  275=a	        INTEGER*1 GLOBAL         \                                      
>       ! 1.6 RC
  276=a	            IRF.LIST.ID%(1)                                             
>       ! 1.6 RC
  277=a	    
  278=a	        INTEGER*2 GLOBAL         \
  279=a	            IRF.ALT.REPORT.NUM%, \
  280=a	            IRF.ALT.SESS.NUM%,   \
  281=a	            IRF.POINTS%,         \ Redundant (set to null within functio
>ns)    ! 1.6 RC
  282=a	            IRF.RECL%,           \
  283=a	            IRF.REPORT.NUM%,     \
  284=a	            IRF.SESS.NUM%,       \
  285=a	            IRF.MAX.DEALS%       !                                      
>       ! 1.9 SM
  286=a	    
  287=a	        STRING GLOBAL IRFDEX.FILE.NAME$                                 
>       ! 1.9 SM
  288=a	    
  289=a	        INTEGER*2 GLOBAL IRFDEX.SESS.NUM%                               
>       ! 1.9 SM
  290=a	        INTEGER*2 GLOBAL IRFDEX.REPORT.NUM%                             
>       ! 1.9 SM
  291=a	        INTEGER*2 GLOBAL IRFDEX.RECL%                                   
>       ! 1.9 SM
  292=a	    
  293=a	    
  294=a	    !   INTEGER*2 GLOBAL      \ IRF.DEAL.DATA%(n) variables are defined 
>locally  1.6 RC
  295=a	    !       IRF.DEAL.DATA%(1) \ within IRFFUN.BAS to keep invisible to p
>rograms  1.6 RC
  296=a	    
  297: 	    %INCLUDE IDFDEC.J86
  298=a	    REM \
  299=a	    \*******************************************************************
>***********
  300=a	    \*******************************************************************
>***********
  301=a	    \***
  302=a	    \***         %INCLUDE FOR ITEM DATA FILE - FIELD DECLARATIONS
  303=a	    \***                                       FILE REFERENCE PARAMETERS
  304=a	    \***
  305=a	    \***                  FILE TYPE    : Keyed
  306=a	    \***
  307=a	    \***                  REFERENCE    : IDFDEC.J86
  308=a	    \***
  309=a	    \***         VERSION A : Andrew Wedgeworth  29th June 1992    
  310=a	    \***
  311=a	    \***    VERSION C.              Robert Cowey.                       
>25 AUG 1993.
  312=a	    \***    Replaced un-used RANK$ with BSNS.CNTR$ and FILLER$.
  313=a	    \***
  314=a	    \***    VERSION D.              Andrew Wedgeworth               15th
> March 1995
  315=a	    \***    Comments updated to reflect the fact that some bits on the f
>ile are
  316=a	    \***    no longer used.
  317=a	    \***
  318=a	    \*******************************************************************
>************
  319=a	    \*******************************************************************
>************
  320=a	    
  321=a	      STRING GLOBAL           \
  322=a	        IDF.FILE.NAME$,       \  
  323=a	        IDF.BOOTS.CODE$,      \ 4 byte UPD with check digit (key)
  324=a	        IDF.FIRST.BAR.CODE$,  \ 6 byte UPD without check digit
  325=a	        IDF.SECOND.BAR.CODE$, \ 6 byte UPD without check digit
  326=a	        IDF.NO.OF.BAR.CODES$, \ 2 byte UPD. Total number of bar codes fo
>r this item
  327=a	        IDF.PRODUCT.GRP$,     \ 3 byte UPD. The first two digits are the
> concept
  328=a	                              \ group and the last four the concept sequ
>ence
  329=a	        IDF.STNDRD.DESC$,     \ 24 bytes
  330=a	        IDF.STATUS.1$,        \ 1 byte, values B,C,D,P,X,Z and blank
  331=a	        IDF.INTRO.DATE$,      \ 3 byte UPD YYMMDD. Date first added to t
>his file
  332=a	        IDF.BSNS.CNTR$,       \ 1 byte ASC. Business Centre ID letter   
>   ! CRC
  333=a	        IDF.FILLER$,          \ 1 byte un-used                          
>   ! CRC
  334=a	        IDF.PARENT.CODE$,     \ 4 byte UPD with check digit ; may be zer
>o if no
  335=a	                              \ flashpacks, current IDF.BOOTS.CODE$ if p
>arent line
  336=a	                              \ or Boots Code of parent line if a flashp
>ack.
  337=a	        IDF.DATE.OF.LAST.SALE$! 3 byte UPD. Date of last sale.
  338=a	    
  339=a	      INTEGER*1 GLOBAL        \
  340=a	        IDF.BIT.FLAGS.1%,     \ 1 byte - bit values
  341=a	                              \ X"80"  - Group code flag
  342=a	                              \ X"40"  - Keylines flag
  343=a	                              \ X"20"  - Markdown flag
  344=a	                              \ X"10"  - Warehouse flag
  345=a	                              \ X"08"  - CSR flag
  346=a	                              \ X"04"  - Directs A flag
  347=a	                              \ X"02"  - Directs B flag
  348=a	                              \ X"01"  - Directs C flag
  349=a	        IDF.BIT.FLAGS.2%      \ 1 byte - bit values
  350=a	                              \ X"80"  - Own brand line flag
  351=a	                              \ X"40"  - Exclusive line flag
  352=a	                              \ X"20"  - Unused 
  353=a	                              \ X"10"  - Unused
  354=a	                              \ X"08"  - Stock system flag
  355=a	                              \ X"04"  - Pending count flag
  356=a	                              \ X"02"  - Reserved
  357=a	                              ! X"01"  - Reserved
  358=a	    
  359=a	      INTEGER*2 GLOBAL        \
  360=a	        IDF.RECL%,            \  
  361=a	        IDF.REPORT.NUM%,      \ 
  362=a	        IDF.SESS.NUM%
  363: 	    %INCLUDE KFASMEXT.J86 ! Keyed file assembler functions              
>!HMW
  364=a	    \*******************************************************************
>************
  365=a	    \*******************************************************************
>************
  366=a	    \***
  367=a	    \***   EXTERNAL FUNCTION DEFINITIONS FOR KEYED FILE ASSEMBLER FUNCTI
>ONS
  368=a	    \***
  369=a	    \*******************************************************************
>************
  370=a	    \*******************************************************************
>************
  371=a	    
  372=a	    \*******************************************************************
>************
  373=a	    \*******************************************************************
>************
  374=a	    \***
  375=a	    \***    Version A.              Mark Walker                      5th
> Feb 1998
  376=a	    \***    Initial version.
  377=a	    \***
  378=a	    \***    Version B.              Mark Walker                     30th
> Jan 2014
  379=a	    \***    Added new WRITEKF routine.
  380=a	    \***
  381=a	    \***    Version C.              Mark Walker                     21st
> May 2014
  382=a	    \***    Extended READKF interface to include a mode flag.
  383=a	    \***
  384=a	    \***    Version D.              Mark Walker                      9th
> Jan 2017
  385=a	    \***    Added new RECLKF routine.
  386=a	    \***
  387=a	    \*******************************************************************
>************
  388=a	    \*******************************************************************
>************
  389=a	    
  390=a	    \*******************************************************************
>************
  391=a	    \***
  392=a	    \***    FUNCTION        :       INITKF
  393=a	    \***
  394=a	    \*******************************************************************
>************ 
  395=a	    \***
  396=a	    \***    Assembler function that initialises a keyed file for process
>ing
  397=a	    \***
  398=a	    \*******************************************************************
>************ 
  399=a	    
  400=a	        FUNCTION INITKF(FILE.NAME$,OPTIONS%) EXTERNAL
  401=a	        INTEGER*2       OPTIONS%
  402=a	        INTEGER*4       INITKF
  403=a	        STRING          FILE.NAME$
  404=a	        END FUNCTION      
  405=a	    
  406=a	    \*******************************************************************
>************
  407=a	    \***
  408=a	    \***    FUNCTION        :       TERMKF
  409=a	    \***
  410=a	    \*******************************************************************
>************ 
  411=a	    \***
  412=a	    \***    Assembler function that closes a file
  413=a	    \***
  414=a	    \*******************************************************************
>************ 
  415=a	    
  416=a	        FUNCTION TERMKF(FID%) EXTERNAL
  417=a	        INTEGER*4       TERMKF
  418=a	        INTEGER*4       FID%
  419=a	        END FUNCTION      
  420=a	    
  421=a	    \*******************************************************************
>************
  422=a	    \***
  423=a	    \***    FUNCTION        :       READKF
  424=a	    \***
  425=a	    \*******************************************************************
>************ 
  426=a	    \***
  427=a	    \***    Assembler function that reads records from a keyed file that
> contain
  428=a	    \***    a pattern string at a specified offset within the record
  429=a	    \***
  430=a	    \*******************************************************************
>************ 
  431=a	    
  432=a	        FUNCTION READKF(RECORD$,PATTERN$,OFFSET%,MODE%) EXTERNAL        
>    !CMW
  433=a	        INTEGER*2       MODE%                                           
>    !CMW
  434=a	        INTEGER*4       OFFSET%
  435=a	        INTEGER*4       READKF
  436=a	        STRING          RECORD$
  437=a	        STRING          PATTERN$
  438=a	        END FUNCTION       
  439=a	    
  440=a	    \*******************************************************************
>****!BMW
  441=a	    \***                                                                
>    !BMW
  442=a	    \***    FUNCTION        :       WRITEKF                             
>    !BMW
  443=a	    \***                                                                
>    !BMW
  444=a	    \*******************************************************************
>****!BMW
  445=a	    \***                                                                
>    !BMW
  446=a	    \***    Assembler function that updates records in a keyed file.    
>    !BMW
  447=a	    \***                                                                
>    !BMW
  448=a	    \*******************************************************************
>****!BMW
  449=a	                                                                        
>    !BMW
  450=a	        FUNCTION WRITEKF(RECORD$) EXTERNAL                              
>    !BMW
  451=a	        INTEGER*4       WRITEKF                                         
>    !BMW
  452=a	        STRING          RECORD$                                         
>    !BMW
  453=a	        END FUNCTION                                                    
>    !BMW
  454=a	    
  455=a	    \*******************************************************************
>****!DMW
  456=a	    \***                                                                
>    !DMW
  457=a	    \***   FUNCTION        :       RECLKF                               
>    !DMW
  458=a	    \***                                                                
>    !DMW
  459=a	    \*******************************************************************
>****!DMW
  460=a	    \***                                                                
>    !DMW
  461=a	    \***   Assembler function that returns record length of a keyed file
>.   !DMW
  462=a	    \***                                                                
>    !DMW
  463=a	    \*******************************************************************
>****!DMW
  464=a	                                                                        
>    !DMW
  465=a	        FUNCTION RECLKF(FILE.NAME$) EXTERNAL                            
>    !DMW
  466=a	        INTEGER*2 RECLKF                                                
>    !DMW
  467=a	        STRING FILE.NAME$                                               
>    !DMW
  468=a	        END FUNCTION                                                    
>    !DMW
  469=a	    
  470: 	        %INCLUDE EALHSASC.J86 
  471=a	    \/* TIME STAMP BLOCK **********************************************
  472=a	    \** END OF TIME STAMP BLOCK **************************************/
  473=a	    !! THIS MODULE WAS CREATED BY APAR IR70269
  474=a	    !*******************************************************************
>**
  475=a	    !
  476=a	    ! ASSEMBLER SUBROUTNE DEFINITIONS
  477=a	    !
  478=a	    ! These definitions should be copied by any routine which wishes to
  479=a	    ! use the performanced enhanced assembler routines.
  480=a	    !
  481=a	    !*******************************************************************
>**
  482=a	     
  483=a	    !*******************************************************************
>**
  484=a	    !
  485=a	    ! SUBSTR
  486=a	    !
  487=a	    ! This routine performs a merge of two strings. String P3$, offset P
>4
  488=a	    ! is merged into string P1$ offset P2 for a length of P5 bytes
  489=a	    !
  490=a	    ! CAUTION: P1$ must be long enough to totally contain P3$
  491=a	    !
  492=a	    ! NOTE: THE OFFSETS PASSED TO THIS ROUTINE ARE ZERO INDEXED
  493=a	    !
  494=a	    !*******************************************************************
>**
  495=a	     
  496=a	     FUNCTION SUBSTR (P1$,P2,P3$,P4,P5) EXTERNAL
  497=a	     STRING P1$,P3$
  498=a	     INTEGER*2 P2,P4,P5
  499=a	     END FUNCTION
  500=a	     
  501=a	    !*******************************************************************
>**
  502=a	    !
  503=a	    ! GETN2/GETN4
  504=a	    !
  505=a	    ! These routines extract a two/four byte integer from a string.
  506=a	    ! P2 is the offset within the string
  507=a	    !
  508=a	    ! NOTE: THE OFFSET PASSED TO THIS ROUTINE IS ZERO INDEXED
  509=a	    !
  510=a	    !*******************************************************************
>**
  511=a	     
  512=a	     FUNCTION GETN2(P1$,P2) EXTERNAL
  513=a	     INTEGER*2 GETN2
  514=a	     STRING P1$
  515=a	     INTEGER*2 P2
  516=a	     END FUNCTION
  517=a	     
  518=a	     FUNCTION GETN4(P1$,P2) EXTERNAL
  519=a	     INTEGER*4 GETN4
  520=a	     STRING P1$
  521=a	     INTEGER*2 P2
  522=a	     END FUNCTION
  523=a	     
  524=a	    !*******************************************************************
>**
  525=a	    !
  526=a	    ! PUTN2/PUTN4
  527=a	    !
  528=a	    ! These routines insert a two/four byte integer into a string.
  529=a	    ! P2 is the offset within the string and P3 is the source integer
  530=a	    !
  531=a	    ! NOTE: THE OFFSET PASSED TO THIS ROUTINE IS ZERO INDEXED
  532=a	    !
  533=a	    !*******************************************************************
>**
  534=a	     
  535=a	     FUNCTION PUTN2(P1$,P2,P3) EXTERNAL
  536=a	     STRING P1$
  537=a	     INTEGER*2 P2,P3
  538=a	     END FUNCTION
  539=a	     
  540=a	     FUNCTION PUTN4(P1$,P2,P3) EXTERNAL
  541=a	     STRING P1$
  542=a	     INTEGER*2 P2
  543=a	     INTEGER*4 P3
  544=a	     END FUNCTION
  545=a	     
  546=a	    !*******************************************************************
>**
  547=a	    !
  548=a	    ! PACKBIN2/4
  549=a	    !
  550=a	    ! These routines take a packed decimal string and convert to integer
  551=a	    ! (The equivalent of CBASIC INT%(VAL(UNPACK$())) )
  552=a	    ! P1 is the source string, P2 the string offset and P3 the length
  553=a	    !
  554=a	    ! NOTE: THE OFFSET PASSED TO THIS ROUTINE IS ZERO INDEXED
  555=a	    !
  556=a	    !*******************************************************************
>**
  557=a	     
  558=a	     FUNCTION PACKBIN2(P1$,P2,P3) EXTERNAL
  559=a	     INTEGER*2 PACKBIN2
  560=a	     STRING P1$
  561=a	     INTEGER*2 P2,P3
  562=a	     END FUNCTION
  563=a	     
  564=a	     FUNCTION PACKBIN4(P1$,P2,P3) EXTERNAL
  565=a	     INTEGER*4 PACKBIN4
  566=a	     STRING P1$
  567=a	     INTEGER*2 P2,P3
  568=a	     END FUNCTION
  569=a	     
  570=a	    !*******************************************************************
>**
  571=a	    !
  572=a	    ! ADDIN2/4
  573=a	    !
  574=a	    ! These routines add an integer into an integer which is imbedded wi
>thin
  575=a	    ! a string.  P1$ is the string containing at offset P2 the integer t
>o be
  576=a	    ! updated.  P3 is the integer to be added into P1$.
  577=a	    !
  578=a	    ! NOTE: THE OFFSET PASSED TO THIS ROUTINE IS ZERO INDEXED
  579=a	    !
  580=a	    !*******************************************************************
>**
  581=a	     
  582=a	     FUNCTION ADDIN4(P1$,P2,P3) EXTERNAL
  583=a	     INTEGER*4 ADDIN4
  584=a	     STRING P1$
  585=a	     INTEGER*2 P2
  586=a	     INTEGER*4 P3
  587=a	     END FUNCTION
  588=a	     
  589=a	     FUNCTION ADDIN2(P1$,P2,P3) EXTERNAL
  590=a	     INTEGER*2 ADDIN2
  591=a	     STRING P1$
  592=a	     INTEGER*2 P2,P3
  593=a	     END FUNCTION
  594=a	     
  595=a	    !*******************************************************************
>**
  596=a	    !
  597=a	    ! MATCHB
  598=a	    !
  599=a	    ! This routine performs a fast match function when the string being
  600=a	    ! searched for contains only a single character.  As with the MATCH
  601=a	    ! function, P1$ is the character to be found, P2$ is the string to b
>e
  602=a	    ! searched, and P3 the offst at which to start the search.
  603=a	    !
  604=a	    !*******************************************************************
>**
  605=a	     
  606=a	     FUNCTION MATCHB(P1$,P2$,P3) EXTERNAL
  607=a	     INTEGER*2 MATCHB
  608=a	     STRING P1$
  609=a	     STRING P2$
  610=a	     INTEGER*2 P3
  611=a	     END FUNCTION
  612=a	     
  613=a	    \ REM!! ************************************************************
>*!!
  614=a	    \ REM!! PROCEDURE - CONVERT A PACKED DECIMAL DATA STRING TO A       
> !!
  615=a	    \ REM!! 4 BYTE BINARY INTEGER REPRESENTED AS A STRING.              
> !!
  616=a	    \ REM!! STRING "OUT$" MUST BE INITIALIZED BEFORE CALLING THE ROUTINE
>.!!
  617=a	    \ REM!! ************************************************************
>*!!
  618=a	     
  619=a	    SUB UPDBIN4 (IN$,OUT$) EXTERNAL
  620=a	    STRING IN$,OUT$
  621=a	    END SUB
  622=a	     
  623=a	    \ REM!! ************************************************************
>*!!
  624=a	    \ REM!! PROCEDURE - CONVERT A PACKED DECIMAL DATA STRING TO A       
> !!
  625=a	    \ REM!! 3 BYTE BINARY INTEGER REPRESENTED AS A STRING.              
> !!
  626=a	    \ REM!! STRING "OUT$" MUST BE INITIALIZED BEFORE CALLING THE ROUTINE
>.!!
  627=a	    \ REM!! ************************************************************
>*!!
  628=a	     
  629=a	    SUB UPDBIN3 (IN$,OUT$) EXTERNAL
  630=a	    STRING IN$,OUT$
  631=a	    END SUB
  632=a	     
  633=a	    \ REM!! ************************************************************
>*!!
  634=a	    \ REM!! PROCEDURE - CONVERT A PACKED DECIMAL DATA STRING TO A       
> !!
  635=a	    \ REM!! 2 BYTE BINARY INTEGER REPRESENTED AS A STRING.              
> !!
  636=a	    \ REM!! STRING "OUT$" MUST BE INITIALIZED BEFORE CALLING THE ROUTINE
>.!!
  637=a	    \ REM!! ************************************************************
>*!!
  638=a	     
  639=a	    SUB UPDBIN2 (IN$,OUT$) EXTERNAL
  640=a	    STRING IN$,OUT$
  641=a	    END SUB
  642=a	     
  643=a	    \ REM!! ************************************************************
>*!!
  644=a	    \ REM!! PROCEDURE - CONVERT A PACKED DECIMAL DATA STRING TO A       
> !!
  645=a	    \ REM!! 1 BYTE BINARY INTEGER REPRESENTED AS A STRING.              
> !!
  646=a	    \ REM!! STRING "OUT$" MUST BE INITIALIZED BEFORE CALLING THE ROUTINE
>.!!
  647=a	    \ REM!! ************************************************************
>*!!
  648=a	     
  649=a	    SUB UPDBIN1 (IN$,OUT$) EXTERNAL
  650=a	    STRING IN$,OUT$
  651=a	    END SUB
  652=a	     
  653=a	    \ REM!! ************************************************************
>*!!
  654=a	    \ REM!! PROCEDURE - CONVERT A PACKED DECIMAL DATA STRING TO A       
> !!
  655=a	    \ REM!! 4 BYTE HEX REPRESENTATION OF A 2-BYTE INTEGER               
> !!
  656=a	    \ REM!! STRING "OUT$" MUST BE INITIALIZED BEFORE CALLING THE ROUTINE
>.!!
  657=a	    \ REM!! ************************************************************
>*!!
  658=a	     
  659=a	    SUB UPDHEX2 (IN$,OUT$) EXTERNAL
  660=a	    STRING IN$,OUT$
  661=a	    END SUB
  662=a	     
  663=a	    \ REM!! ************************************************************
>*!!
  664=a	    \ REM!! PROCEDURE - CONVERT A PACKED DECIMAL DATA STRING TO A       
> !!
  665=a	    \ REM!! 2 BYTE HEX REPRESENTATION OF A 1-BYTE INTEGER               
> !!
  666=a	    \ REM!! STRING "OUT$" MUST BE INITIALIZED BEFORE CALLING THE ROUTINE
>.!!
  667=a	    \ REM!! ************************************************************
>*!!
  668=a	     
  669=a	    SUB UPDHEX1 (IN$,OUT$) EXTERNAL
  670=a	    STRING IN$,OUT$
  671=a	    END SUB
  672=a	     
  673=a	    \ REM!! ************************************************************
>*!!
  674=a	    \ REM!! PROCEDURE - CONVERT AN INPUT 4 BYTE INTEGER REPRESENTED AS A
> !!
  675=a	    \ REM!! STRING TO A 2 BYTE BINARY INTEGER REPRESENTED AS A STRING   
> !!
  676=a	    \ REM!! WHERE BOTH THE INPUT AND OUTPUT MAY BE IMBEDDED WITHIN THE  
> !!
  677=a	    \ REM!! GIVEN STRING AT THE GIVEN OFFSET.                           
> !!
  678=a	    \ REM!! STRING "OUT$" MUST BE INITIALIZED BEFORE CALLING THE ROUTINE
>.!!
  679=a	    \ REM!!
  680=a	    \ REM!! NOTE: THE OFFSETS PASSED TO THIS ROUTINE ARE UNIT INDEXED
  681=a	    \ REM!! ************************************************************
>*!!
  682=a	     
  683=a	    SUB INTBIN2 (IN$,IN%,OUT$,OUT%) EXTERNAL
  684=a	    STRING IN$,OUT$
  685=a	    INTEGER IN%,OUT%
  686=a	    END SUB
  687=a	     
  688=a	    \ REM!! ************************************************************
>*!!
  689=a	    \ REM!! PROCEDURE - CONVERT AN INPUT 4 BYTE INTEGER REPRESENTED AS A
> !!
  690=a	    \ REM!! STRING TO A 3 BYTE BINARY INTEGER REPRESENTED AS A STRING   
> !!
  691=a	    \ REM!! WHERE BOTH THE INPUT AND OUTPUT MAY BE IMBEDDED WITHIN THE  
> !!
  692=a	    \ REM!! GIVEN STRING AT THE GIVEN OFFSET.                           
> !!
  693=a	    \ REM!! STRING "OUT$" MUST BE INITIALIZED BEFORE CALLING THE ROUTINE
>.!!
  694=a	    \ REM!!
  695=a	    \ REM!! NOTE: THE OFFSETS PASSED TO THIS ROUTINE ARE UNIT INDEXED
  696=a	    \ REM!! ************************************************************
>*!!
  697=a	     
  698=a	    SUB INTBIN3 (IN$,IN%,OUT$,OUT%) EXTERNAL
  699=a	    STRING IN$,OUT$
  700=a	    INTEGER IN%,OUT%
  701=a	    END SUB
  702=a	     
  703=a	    \ REM!! ************************************************************
>*!!
  704=a	    \ REM!! PROCEDURE - CONVERT AN INPUT 4 BYTE INTEGER REPRESENTED AS A
> !!
  705=a	    \ REM!! STRING TO A 4 BYTE BINARY INTEGER REPRESENTED AS A STRING   
> !!
  706=a	    \ REM!! WHERE BOTH THE INPUT AND OUTPUT MAY BE IMBEDDED WITHIN THE  
> !!
  707=a	    \ REM!! GIVEN STRING AT THE GIVEN OFFSET.                           
> !!
  708=a	    \ REM!! STRING "OUT$" MUST BE INITIALIZED BEFORE CALLING THE ROUTINE
>.!!
  709=a	    \ REM!!
  710=a	    \ REM!! NOTE: THE OFFSETS PASSED TO THIS ROUTINE ARE UNIT INDEXED
  711=a	    \ REM!! ************************************************************
>*!!
  712=a	     
  713=a	    SUB INTBIN4 (IN$,IN%,OUT$,OUT%) EXTERNAL
  714=a	    STRING IN$,OUT$
  715=a	    INTEGER IN%,OUT%
  716=a	    END SUB
  717=a	     
  718: 	     
  719: 	    
  720: 	    
  721: 	    
  722: 	    %INCLUDE PSBF01E.J86                                                
>   !HSMG
  723=a	    REM \
  724=a	    \*******************************************************************
>************
  725=a	    \*******************************************************************
>************
  726=a	    \***
  727=a	    \***      %INCLUDE FOR EXTERNAL DEFINITION OF FUNCTION APPLICATION.L
>OG
  728=a	    \***
  729=a	    \***                      FUNCTION NUMBER   : PSBF01
  730=a	    \***
  731=a	    \***                    INCLUDE REFERENCE : PSBF01E.J86
  732=a	    \*** 
  733=a	    \***      Version B           Andrew Wedgeworth          1st July 19
>92
  734=a	    \***      Three parameters which passed to the function have been re
>moved.
  735=a	    \***      APPLICATION.LOG has been added as a variable name (this ho
>lds the
  736=a	    \***      return code).
  737=a	    \***
  738=a	    \*******************************************************************
>************
  739=a	    
  740=a	    
  741=a	       FUNCTION APPLICATION.LOG (MESSAGE.NO%,                           
>          \
  742=a	                                 VAR.STRING.1$,                         
>          \
  743=a	                                 VAR.STRING.2$,                         
>          \
  744=a	                                 EVENT.NO%)  EXTERNAL
  745=a	    
  746=a	          INTEGER*1 EVENT.NO%
  747=a	    
  748=a	          INTEGER*2 APPLICATION.LOG,                                    
>   \ GAW
  749=a	                    MESSAGE.NO%
  750=a	    
  751=a	          STRING VAR.STRING.1$,                                         
>   \
  752=a	                 VAR.STRING.2$
  753=a	    
  754=a	       END FUNCTION
  755=a	    
  756=a	    \*******************************************************************
>************
  757: 	    %INCLUDE IRFEXT.J86                                                 
>   !BMJK                                                   
  758=a	    \*******************************************************************
>**************
  759=a	    \***
  760=a	    \***      EXTERNAL FUNCTION DEFINITIONS FOR THE ITEM REFERENCE FILE
  761=a	    \***
  762=a	    \***                    REFERENCE : IRFEXT.J86
  763=a	    \***
  764=a	    \***      Version A          Andrew Wedgeworth        9th July 1992
  765=a	    \***
  766=a	    \***      Version B          Andrew Wedgeworth        14th December 
>1992
  767=a	    \***      Version letter incremented to match other IRF code.
  768=a	    \***
  769=a	    \***      Version C           Steve Windsor        12.02.93
  770=a	    \***      Added external reference to read the alternate IRF.
  771=a	    \***
  772=a	    \***      Version D           Steve Windsor        12.05.93
  773=a	    \***      Added all external references that wre in the original FNS
>.
  774=a	    \***
  775=a	    \***      Version E           Steve Perkins        21.09.93
  776=a	    \***      Deals project: Fields changed for new deals project
  777=a	    \*** 
  778=a	    \***      Version F           Mark Walker          5th January 1994
  779=a	    \***      Version letter incremented to match other IRF code.       
>    
  780=a	    \***                                                                
>    
  781=a	    \***      Version G     Stuart William McConnachie      11th Februar
>y 2000
  782=a	    \***      Converted IRF.INDICAT2$ to integer flag byte.
  783=a	    \***
  784=a	    \***      REVISION 1.6.               ROBERT COWEY.               9 
>JUL 2002.
  785=a	    \***      Major changes to IRF layout for 2002 Deals Rewrite project
>.
  786=a	    \***      No changes to this particular file for this revision.
  787=a	    \***
  788=a	    \***      REVISION 1.7.               ROBERT COWEY.               5 
>AUG 2002.
  789=a	    \***      Further changes for 2002 Deals Rewrite project (PSBF19 rel
>ated).
  790=a	    \***      Defined new functions CONCAT.NEW.IRF.DATA$ and SPLIT.NEW.I
>RF.DATA$.
  791=a	    \***
  792=a	    \***      REVISION 1.8                ROBERT COWEY.              15 
>JUL 2003.
  793=a	    \***      Usage of INDICAT0% bit-3 X'08' changed to Item Contains Al
>cohol.
  794=a	    \***      No changes to this file other than description.
  795=a	    \***      No changes to IRF file functions.
  796=a	    \***
  797=a	    \***      REVISION 1.9.      STUART WILLIAM MCCONNACHIE           22
> OCT 2003.
  798=a	    \***      Changes to remove limit of 3 deals per item.
  799=a	    \***      No changes to this file.
  800=a	    \***
  801=a	    \***      REVISION 2.0.             ALAN CARR                      9
> FEB 2006.
  802=a	    \***      Add new IRF.INDICAT8% 1 byte, amend IRF.UNUSED$ from 3 to 
>2 bytes.
  803=a	    \***      No changes to this file.
  804=a	    \***
  805=a	    \***................................................................
>..............
  806=a	       
  807=a	       FUNCTION IRF.SET EXTERNAL
  808=a	       END FUNCTION
  809=a	    
  810=a	      FUNCTION CONCAT.NEW.IRF.DATA$ EXTERNAL                            
>      ! 1.7 RC
  811=a	      END FUNCTION                                                      
>      ! 1.7 RC
  812=a	    
  813=a	      FUNCTION SPLIT.NEW.IRF.DATA$ EXTERNAL                             
>      ! 1.7 RC
  814=a	      END FUNCTION                                                      
>      ! 1.7 RC
  815=a	      
  816=a	      FUNCTION READ.IRF EXTERNAL
  817=a	       INTEGER*2 READ.IRF
  818=a	      END FUNCTION
  819=a	    
  820=a	      FUNCTION READ.IRF.ALT EXTERNAL
  821=a	       INTEGER*2 READ.IRF.ALT
  822=a	      END FUNCTION
  823=a	    
  824=a	      FUNCTION READ.IRF.LOCK EXTERNAL
  825=a	       INTEGER*2 READ.IRF.LOCK
  826=a	      END FUNCTION
  827=a	    
  828=a	      FUNCTION WRITE.IRF EXTERNAL
  829=a	       INTEGER*2 WRITE.IRF
  830=a	      END FUNCTION
  831=a	    
  832=a	      FUNCTION WRITE.IRF.UNLOCK EXTERNAL
  833=a	       INTEGER*2 WRITE.IRF.UNLOCK
  834=a	      END FUNCTION
  835=a	    
  836=a	      FUNCTION WRITE.IRF.HOLD EXTERNAL
  837=a	       INTEGER*2 WRITE.IRF.HOLD
  838=a	      END FUNCTION
  839=a	    
  840=a	      FUNCTION WRITE.IRF.HOLD.UNLOCK EXTERNAL
  841=a	       INTEGER*2 WRITE.IRF.HOLD.UNLOCK
  842=a	      END FUNCTION
  843=a	    
  844=a	      
  845: 	    %INCLUDE PSBF20E.J86
  846=a	    REM\
  847=a	    \*******************************************************************
>************
  848=a	    \*******************************************************************
>************
  849=a	    \***
  850=a	    \***       %INCLUDE FOR EXTERNAL DEFINITION OF SESS.NUM.UTILITY
  851=a	    \***
  852=a	    \***                  REFERENCE     : PSBF20E.J86
  853=a	    \***
  854=a	    \***     VERSION C            Janet Smith                13th May 19
>92
  855=a	    \***     Increased PASSED.INTEGER to 2 bytes to cater for more than
  856=a	    \***     128 files.
  857=a	    \***
  858=a	    \***     VERSION D.           Andrew Wedgeworth          1st July 19
>92
  859=a	    \***     Removal of redundant parameters and addition of SESS.NUM.UT
>ILITY
  860=a	    \***     as a variable.  This new variable contains the function's r
>eturn
  861=a	    \***     code.
  862=a	    \***
  863=a	    \*******************************************************************
>************
  864=a	    \*******************************************************************
>************
  865=a	    
  866=a	       FUNCTION SESS.NUM.UTILITY (FUNCTION.FLAG$,                       
>   \
  867=a	                                  PASSED.INTEGER%,                      
>   \
  868=a	                                  PASSED.STRING$)                       
>   \
  869=a	       EXTERNAL
  870=a	    
  871=a	       STRING    FUNCTION.FLAG$,                                        
>   \
  872=a	                 PASSED.STRING$
  873=a	       ! 3 variables removed from here                                  
>   ! CAW
  874=a	    
  875=a	    
  876=a	       INTEGER*2 SESS.NUM.UTILITY,                                      
>   \ CAW
  877=a	                 PASSED.INTEGER%                                        
>  ! CJAS
  878=a	    
  879=a	       END FUNCTION
  880=a	    
  881: 	    %INCLUDE IDFEXT.J86 
  882=a	    \*******************************************************************
>************
  883=a	    \***                                                                
>         ***
  884=a	    \***      EXTERNAL FUNCTION DEFINITIONS FOR THE ITEM DESCRIPTION FIL
>E        ***
  885=a	    \***                                                                
>         ***
  886=a	    \***                       REFERENCE : IDFEXT.J86                   
>         ***
  887=a	    \***                                                                
>         ***
  888=a	    \***      Version A           Andrew Wedgeworth         9th July 199
>2        ***
  889=a	    \***
  890=a	    \***    VERSION C.              Robert Cowey.                       
>25 AUG 1993.
  891=a	    \***    No changes to this file.
  892=a	    \***
  893=a	    \***   VERSION D               Nik Sen                 22nd December
> 1994
  894=a	    \***   WRITE.IDF.HOLD added
  895=a	    \***
  896=a	    \*******************************************************************
>************
  897=a	    
  898=a	           FUNCTION IDF.SET EXTERNAL                                    
>  
  899=a	           END FUNCTION                                                 
>  
  900=a	    
  901=a	    
  902=a	           FUNCTION READ.IDF EXTERNAL                                   
>  
  903=a	              INTEGER*2 READ.IDF                                        
>  
  904=a	           END FUNCTION                                                 
>  
  905=a	    
  906=a	    
  907=a	           FUNCTION READ.IDF.LOCK EXTERNAL                              
>  
  908=a	              INTEGER*2 READ.IDF.LOCK                                   
>  
  909=a	           END FUNCTION                                                 
>  
  910=a	    
  911=a	           FUNCTION WRITE.IDF EXTERNAL
  912=a	              INTEGER*2 WRITE.IDF
  913=a	           END FUNCTION           
  914=a	    
  915=a	           FUNCTION WRITE.IDF.HOLD EXTERNAL
  916=a	              INTEGER*2 WRITE.IDF.HOLD
  917=a	           END FUNCTION
  918=a	    
  919=a	           FUNCTION WRITE.IDF.UNLOCK EXTERNAL                           
>       
  920=a	              INTEGER*2 WRITE.IDF.UNLOCK                                
>      
  921=a	           END FUNCTION                                                 
>  
  922: 	    
  923: 	    
  924: 	    
  925: 	    ON ERROR GOTO ERROR.DETECTED
  926: 	    
  927: 	           GOSUB INITIALIZATION
  928: 	           GOSUB MAIN.PROGRAM
  929: 	           GOSUB TERMINATION
  930: 	    
  931: 	    STOP
  932: 	    
  933: 	    INITIALIZATION:
  934: 	    
  935: 	    BLOCK.FILE$ = "C:/BLOCKITM.DAT"
*** error	      ^8
  936: 	    
  937: 	            CALL IRF.SET
  938: 	             CALL IDF.SET
  939: 	    
  940: 	            FUNCTION.FLAG$ EQ "O" 
*** error			  ^8
  941: 	    
  942: 	         PASSED.INTEGER% EQ IRF.REPORT.NUM% 
*** error		       ^8
  943: 	         PASSED.STRING$ EQ IRF.FILE.NAME$
*** error		      ^8
  944: 	         GOSUB CALL.F20.SESS.NUM.UTILITY
  945: 	         IRF.SESS.NUM% EQ F20.INTEGER.FILE.NO% 
  946: 	            
  947: 	            PASSED.INTEGER% EQ IDF.REPORT.NUM% 
*** error			   ^8
  948: 	         PASSED.STRING$ EQ IDF.FILE.NAME$
*** error		      ^8
  949: 	         GOSUB CALL.F20.SESS.NUM.UTILITY
  950: 	         IDF.SESS.NUM% EQ F20.INTEGER.FILE.NO%
  951: 	            
  952: 	            PASSED.INTEGER% EQ 456 
*** error			   ^8
  953: 	         PASSED.STRING$ EQ BLOCK.FILE$
*** error		      ^8	     ^8
  954: 	         GOSUB CALL.F20.SESS.NUM.UTILITY
  955: 	         BLOCK.SESS.NUM% EQ F20.INTEGER.FILE.NO%
*** error		       ^8
  956: 	            
  957: 	            
  958: 	            OPEN BLOCK.FILE$ AS BLOCK.SESS.NUM%
*** error			    ^8		       ^8
  959: 	    
  960: 	    RETURN
  961: 	    
  962: 	    CALL.F20.SESS.NUM.UTILITY: 
  963: 	            
  964: 	             FILE.OPERATION$ = FUNCTION.FLAG$
*** error			   ^8		    ^8
  965: 	             CURRENT.REPORT.NUM% = PASSED.INTEGER%
*** error			       ^8		 ^8
  966: 	             RC% = SESS.NUM.UTILITY (FUNCTION.FLAG$, PASSED.INTEGER%,   
>    \
*** error	       ^8				  ^8		   ^8
  967: 	                                     PASSED.STRING$)
*** error						  ^8
  968: 	             IF RC% <> 0 THEN GOTO ERROR.DETECTED
*** error		  ^8
  969: 	    
  970: 	    RETURN
  971: 	    
  972: 	    
  973: 	    
  974: 	    MAIN.PROGRAM:
  975: 	    
  976: 	           IF END #IRF.SESS.NUM% THEN NO.FILE
  977: 	           OPEN IRF.FILE.NAME$ KEYED RECL IRF.RECL% AS IRF.SESS.NUM% NOD
>EL         
  978: 	           IF END #IDF.SESS.NUM% THEN NO.FILE
  979: 	           OPEN IDF.FILE.NAME$ KEYED RECL IDF.RECL% AS IDF.SESS.NUM% NOD
>EL
  980: 	    READ.BEGIN:
  981: 	           WHILE NOT EOF1 
*** error			 ^8
  982: 	    
  983: 	        IF END #BLOCK.SESS.NUM% THEN NO.FILE
*** error			      ^8
  984: 	        READ #BLOCK.SESS.NUM% ;LINE LINE.RECORD$
*** error			    ^8		       ^8
  985: 	           
  986: 	           CMD$ = LEFT$(LINE.RECORD$,7) 
*** error	       ^8		    ^8
  987: 	           
  988: 	            
  989: 	           
  990: 	           IDF.BOOTS.CODE$ = PACK$("0" + CMD$) 
*** error					     ^8
  991: 	    
  992: 	           RC% = READ.IDF
*** error	      ^8
  993: 	             
  994: 	             IF RC% = 0 THEN BEGIN             
*** error		   ^8
  995: 	                     
  996: 	             
  997: 	                   IRF.BAR.CODE$ =  PACK$("0000000000") + IDF.FIRST.BAR.
>CODE$
  998: 	                    
  999: 	                   RC% = READ.IRF
*** error		      ^8
 1000: 	                            
 1001: 	                   IF RC% = 0 THEN BEGIN            
*** error			 ^8
 1002: 	                   
 1003: 	                           
 1004: 	                                    
 1005: 	               
 1006: 	                        PRINT "ITEM PRICE IS ,",UNPACK$(IRF.SALEPRIC)
*** error								   ^8
*** error								    ^27
 1007: 	                                    
 1008: 	                                   
 1009: 	                           ENDIF ELSE BEGIN
 1010: 	             
 1011: 	                    IRF.BAR.CODE$ = PACK$(RIGHT$(STRING$(22,"0") +      
>         \
 1012: 	                 UNPACK$(IRF.SECOND.BAR.CODE$),22)) 
*** error					    ^8
 1013: 	                            RC% = READ.IRF
*** error			       ^8
 1014: 	                            
 1015: 	                            IF RC% = 0 THEN BEGIN   
*** error				  ^8
 1016: 	                            PRINT "ITEM PRICE IS ,",UNPACK$(IRF.SALEPRIC
>)
*** error									
>^8										 
>^27
 1017: 	                           
 1018: 	                           ENDIF ELSE BEGIN
 1019: 	                
 1020: 	                           ENDIF 
 1021: 	                           
 1022: 	                           ENDIF   
 1023: 	                     
 1024: 	                       
 1025: 	    
 1026: 	         ENDIF ELSE BEGIN
 1027: 	            
 1028: 	            
 1029: 	            
 1030: 	            ENDIF
 1031: 	     
 1032: 	    WEND     
 1033: 	          
 1034: 	             
 1035: 	    
 1036: 	     
 1037: 	    
 1038: 	    NO.FILE:
 1039: 	    
 1040: 	        EOF1 = TRUE
*** error	   ^8	  ^8
 1041: 	           
 1042: 	           EOF = TRUE
*** error	      ^8     ^8
 1043: 	    
 1044: 	           GOTO TERMINATION
 1045: 	    
 1046: 	    RETURN
 1047: 	    
 1048: 	    
 1049: 	    TERMINATION:
 1050: 	    
 1051: 	        FUNCTION.FLAG$ EQ "C"
*** error		     ^8
 1052: 	           PASSED.INTEGER% EQ IRF.REPORT.NUM% 
*** error			  ^8
 1053: 	        PASSED.STRING$ EQ IRF.FILE.NAME$
*** error		     ^8
 1054: 	        GOSUB CALL.F20.SESS.NUM.UTILITY
 1055: 	        IRF.SESS.NUM% EQ F20.INTEGER.FILE.NO%
 1056: 	           
 1057: 	           FUNCTION.FLAG$ EQ "C"
*** error			 ^8
 1058: 	           PASSED.INTEGER% EQ IDF.REPORT.NUM% 
*** error			  ^8
 1059: 	        PASSED.STRING$ EQ IDF.FILE.NAME$
*** error		     ^8
 1060: 	        GOSUB CALL.F20.SESS.NUM.UTILITY
 1061: 	        UODOT.SESS.NUM% EQ F20.INTEGER.FILE.NO%
*** error		      ^8
 1062: 	    
 1063: 	           CLOSE IDF.SESS.NUM%
 1064: 	    
 1065: 	           CLOSE IRF.SESS.NUM%
 1066: 	    
 1067: 	    RETURN
 1068: 	    
 1069: 	    
 1070: 	    
 1071: 	    ERROR.DETECTED:
 1072: 	    
 1073: 	    PRINT   "An Error Occurred "   + ERR   + STR$(ERRF%)   + STR$(ERRL) 
> + CMD$
*** error									      
>^8
 1074: 	    
 1075: 	    IF ERR = "KF" OR ERR = "AC"  THEN BEGIN
 1076: 	    
 1077: 	        RESUME READ.BEGIN
 1078: 	           
 1079: 	    ENDIF
 1080: 	    
 1081: 	    END
 1082: 	    
 1083: 	    
 1084: 	    
End of Compilation
