   1: 0003: \*****************************************************************************
   2: 0003: \*****************************************************************************
   3: 0003: \***
   4: 0003: \***    PROGRAM  .....  MINPRINT
   5: 0003: \***    MODULE  ......  MINPRINT.BAS
   6: 0003: \***
   7: 0003: \***    REVISION 1.0.           ROBERT COWEY.                  01 NOV 1995.
   8: 0003: \***    Original version.
   9: 0003: \***
  10: 0003: \***    VERSION B (1.1)        Nik Sen                         06 FEB 1998
  11: 0003: \***    Re-written to use included code for file functions etc.
  12: 0003: \***
  13: 0003: \***    VERSION C              Nik Sen                         12 OCTOBER 1998
  14: 0003: \***    RF version. Changed to send count lists to RF files instead of
  15: 0003: \***    printing report if RF is active.
  16: 0003: \***
  17: 0003: \***    VERSION D              Charles Skadorwa                 7 DECEMBER 1998
  18: 0003: \***    Processing Statements added for debugging purposes.
  19: 0003: \***    RFSCF opened in NOWRITE NODEL mode instead of READONLY.
  20: 0003: \***    Check for List Driven Counting (RFSCF.ACTIVITY%) changed to check for
  21: 0003: \***    ASCII value "2" rather than bit value (& 64).
  22: 0003: \***
  23: 0003: \***    VERSION E              Charles Skadorwa                 15 January 1999
  24: 0003: \***    Program will now operate whether List Driven Counting is active or not.
  25: 0003: \***    Check removed from RF.PROCESS subroutine.
  26: 0003: \***
  27: 0003: \***    VERSION F              Charles Skadorwa                 18 January 1999
  28: 0003: \***    Items description now taken from the RPRPT file if one does not exist on
  29: 0003: \***    the ISF (this resulted in the item being ignored). In VALID.ITEM:,
  30: 0003: \***    IRF.DEAL.NUM$ should be initialised before the IRF is read,  otherwise
  31: 0003: \***    the next item will become a deal item if the previous one was!
  32: 0003: \***    CLILF size increased from 5,000 to 10,000 records to decrease chaining.
  33: 0003: \***    RFHOCNT.286 chained to if it is detected that MINPRINT is running outside
  34: 0003: \***    of normal hours (before 5pm or after 6am)- otherwise the Head Office
  35: 0003: \***    counts would be overwritten.
  36: 0003: \***    Barcode constructed from Boots Code if IDF barcode is null.
  37: 0003: \***    Initialise new CLILF field (CLILF.HO.SEQNO$)and CLOLF filed (CLOLF.TOTAL.ITEMS$).
  38: 0003: \***    Use pipe to instruct RF Server program (TRANSACT) to close down while
  39: 0003: \***    MINPRINT is executing (It will restart automatically at next signon).
  40: 0003: \***    If description not on ISF then description set to "X " in order that
  41: 0003: \***    TRANSACT will read the IDF and perform description formatting.
  42: 0003: \***
  43: 0003: \***    VERSION G              Julia Stones                  9th November 1999
  44: 0003: \***    Code removed that produced the RF report if RF was inactive on SOFTS
  45: 0003: \***    Please note that if RF is ACTIVE and DO MAIN gets set to 1 - before
  46: 0003: \***    changes were made this would have meant that the code would have
  47: 0003: \***    produced the RF report.  DO MAIN is not checked now and so the program
  48: 0003: \***    will just go into the termination part of the code.
  49: 0003: \***
  50: 0003: \***    VERSION H              Brian Greenfield              20th August 2003
  51: 0003: \***    Changes made for RF trial to accomodate IRF changes made in DEALS
  52: 0003: \***    rewrite.
  53: 0003: \***
  54: 0003: \***    REVISION 1.12.         ROBERT COWEY.                  09 SEP 2003.
  55: 0003: \***    Changes for RF trial.
  56: 0003: \***    Removed redundant PVCS revision control block from top of code.
  57: 0003: \***    Removed section of code at end of program that started RFHOCNT.
  58: 0003: \***    Corrected setting of HO.SEQNO within VALID.ITEMS routine.
  59: 0003: \***
  60: 0003: \***
  61: 0003: \***    VERSION I              Chris Combes (CC)            29th March 2004
  62: 0003: \***    Changes made to VALID.ITEM and CREATE.NEW.LIST procedures so lists are
  63: 0003: \***    divided into product groups rather than business units
  64: 0003: \***
  65: 0003: \***
  66: 0003: \***    Version J              Mark Goode                   17th September 2004
  67: 0003: \***    Changes made for OSSR Basic location project, additional information on
  68: 0003: \***    the CLILF/CLOLF files
  69: 0003: \***
  70: 0003: \***    Version K               Mark Goode                   14th January 2005
  71: 0003: \***    Changes made for OSSR WAN project, additioal information on the the CLOLF file.
  72: 0003: \***
  73: 0003: \***    Version L               Jamie Thorpe                 13th March 2006
  74: 0003: \***    Changes for Removal of RF Recounts project.This introduces the ability to
  75: 0003: \***    switch off the ability to perform recounts.
  76: 0003: \***
  77: 0003: \***    Version M               Jamie Thorpe                 4th April 2006
  78: 0003: \***    Updated the way that the CLOLF is initially created. This is to rectify
  79: 0003: \***    a hang reported in TRANSACT when it encounters 0 bytes in the file.
  80: 0003: \***
  81: 0003: \***    Version N              Charles Skadorwa              18th June 2009
  82: 0003: \***    CR006 - Change to ensure that if it is an MC70/POD store, then
  83: 0003: \***            processing will be identical to RF PPC processing. This is
  84: 0003: \***            achieved by checking SOFTS record 20 for " ACTIVE"
  85: 0003: \***
  86: 0003: \***    Version O              Arun Sudhakarannair           14th June 2012
  87: 0003: \***    The program is updated to support the following changes as part of
  88: 0003: \***    SFA Project
  89: 0003: \***        - Rerun and Rerun warning message
  90: 0003: \***              With the re-introduction of counts, it is important that
  91: 0003: \***              MINPRINT is not rerun without understanding what it will
  92: 0003: \***              do to the CLOLF.CLILF and the backups. Hence a new parameter
  93: 0003: \***              (RERUN) must be passed if run from command mode, with
  94: 0003: \***              help details. Format is "MINPRINT RERUN"
  95: 0003: \***        - Prepare a new RF Count report (RFCNTLST.DAY)
  96: 0003: \***              Report gives a summary for each count list type (Negative,
  97: 0003: \***              User Generated and Support Office) and also gives details
  98: 0003: \***              of which users performed the counts, and whether the list
  99: 0003: \***              was fully counted, part counted or not counted at all.
 100: 0003: \***        - For non RF/POD stores, create the CLOLF/CLILF
 101: 0003: \***              Currently, only RF/POD stores have the CLOLF/CLILF files
 102: 0003: \***              present. However as part of SFA, these files need creating
 103: 0003: \***              and populating like RF/POD stores
 104: 0003: \***        - Create daily backups of the CLOLF and CLILF files
 105: 0003: \***              Back up the CLOLF and CLILF files on a daily basis (rolling
 106: 0003: \***              7 days). Backup the files before RF.PROCESS subroutine is
 107: 0003: \***              called. The backup will be used to generate the weekly
 108: 0003: \***              store manager count report.
 109: 0003: \***        - Support the new CLOLF and CLILF formats
 110: 0003: \***        - Introduce a new OK file – MINOK.BIN
 111: 0003: \***              Introduce a new OK file to show success status of each step
 112: 0003: \***              of MINPRINT processing.
 113: 0003: \***
 114: 0003: \***    Version P              Bibin Thomas                  10th Aug 2012
 115: 0003: \***    Changes made to accommodate SFA CR7 requirements.
 116: 0003: \***    In case of a non trading day, MINPRINT is run any time b/w 21:05Hrs
 117: 0003: \***    and 00:30Hrs. So if MINPRINT is run after midnight, the program will
 118: 0003: \***    backup CLILF/CLOLF with Today's extension, where as it is actually
 119: 0003: \***    supposed to backup with yesterday's <DAY>.
 120: 0003: \***    Changes are made so that if MINPRINT is run after 00:00Hrs and before
 121: 0003: \***    04:00Hrs, CLILF/CLOLF is backed-up with file extension set to
 122: 0003: \***    yesterday, else with today.
 123: 0003: \***
 124: 0003: \***    Version Q              Charles Skadorwa (CCSk)       10th Sept 2012
 125: 0003: \***    SFA Defect 661 -  Summary counts are not updated.
 126: 0003: \***    Also corrected screen prompt from "u" to "you".
 127: 0003: \***
 128: 0003: \***    Version R              Tittoo Thomas (RTT)           21th Sept 2012
 129: 0003: \***    SFA Defect 688, 695 - Restricted multiple runs of MINPRINT in a day.
 130: 0003: \***    If MINPPRINT is found to have already run after 1200 noon the previous
 131: 0003: \***    day or before 12 noon today, the application stops without any further
 132: 0003: \***    processing.
 133: 0003: \***
 134: 0003: \***    Version S              Ranjith Gopalankutty(SRG)     10th Feb  2017
 135: 0003: \***    After 16A rollout MINPRINT is triggered after midnight as part of
 136: 0003: \***    end of the day reset, there is a date check happens in MINRFCNT
 137: 0003: \***    module before adding the records to RFCNTLST.DAY. Since the date
 138: 0003: \***    match doesn't happen, records are being ignored and count list 
 139: 0003: \***    are not appearing in controller screen. Fix is to ensure the date
 140: 0003: \***    parameter check is correct and record is added if the run is after
 141: 0003: \***    mid night.
 142: 0003: \*****************************************************************************
 143: 0003: \*****************************************************************************
 144: 0003: 
 145: 0003: 
 146: 0003: 
 147: 0003: 
 148: 0003: \*****************************************************************************
 149: 0003: \***
 150: 0003: \***    DEC included code defining file related fields
 151: 0003: \***
 152: 0003: \***..........................................................................
 153: 0003: 
 154: 0003:     %INCLUDE   RPRPTDEC.J86    ! Report file
 155: 0003: \*****************************************************************************
 156: 0003: \***                                                                         *
 157: 0003: \***           %INCLUDE FOR RPRPT - MINSITS RP REPORT FILE                         *
 158: 0003: \***                                                                         *
 159: 0003: \***                    - FIELD DECLARATIONS                                 *
 160: 0003: \***                    - FILE REFERENCE PARAMETERS                          *
 161: 0003: \***                                                                         *
 162: 0003: \***                    REFERENCE: RPRPTDEC.J86                              *
 163: 0003: \***                                                                         *
 164: 0003: \***           Version A      Nik Sen       24th February 1998                *
 165: 0003: \***                                                                         *
 166: 0003: \*****************************************************************************
 167: 0003: 
 168: 0003:    INTEGER*1 GLOBAL            \
 169: 0003:    RPRPT.SESS.NUM%
 170: 0003: 
 171: 0003:    INTEGER*2 GLOBAL            \   
 172: 0003:    RPRPT.REPORT.NUM%    
 173: 0003: 
 174: 0003:    STRING GLOBAL               \
 175: 0003:    RPRPT.FILE.NAME$
 176: 0003: 
 177: 0003:     %INCLUDE   PRINTDEC.J86    ! Printer
 178: 0003: 
 179: 0003: REM \
 180: 0003: \*******************************************************************************
 181: 0003: \*******************************************************************************
 182: 0003: \***
 183: 0003: \***    %INCLUDE FOR PRINT FILE VARIABLE DECLARATIONS
 184: 0003: \***
 185: 0003: \***        REFERENCE   :   PRINTDE (J86)
 186: 0003: \***
 187: 0003: \***        FILE TYPE   :   Printer / Labeller
 188: 0003: \***
 189: 0003: \***    VERSION A.              ANDREW WEDGEWORTH                   09 JUL 1992.
 190: 0003: \***    Original version created by merging PRINTFLG and PRINTNUG.
 191: 0003: \***
 192: 0003: \***    VERSION B.              UNKNOWN.                            ?? ??? 1992.
 193: 0003: \***    Changes unknown.             
 194: 0003: \***
 195: 0003: \***    VERSION C.              ROBERT COWEY.                       18 NOV 1992.
 196: 0003: \***    No changes made to this file.
 197: 0003: \***
 198: 0003: \***    Version D               Andrew Wedgeworth                 24th May 1992
 199: 0003: \***    Variable added to contain condensed print record length.
 200: 0003: \***
 201: 0003: \*******************************************************************************
 202: 0003: \*******************************************************************************
 203: 0003: 
 204: 0003: 
 205: 0003:     STRING GLOBAL \
 206: 0003:         PRINT.LINE$, \
 207: 0003:         PRINT.FILE.NAME$, \
 208: 0003:         SELF.LAN.NAME$, \
 209: 0003:         SELF.NOLAN.NAME$
 210: 0003: 
 211: 0003:     INTEGER*2 GLOBAL \
 212: 0003:         PRINT.CONDENSED.RECL%, \                                       ! DAW  
 213: 0003:         PRINT.SESS.NUM%, \
 214: 0003:         PRINT.REPORT.NUM%, \
 215: 0003:         PRINT.REPORT.RECL%, \
 216: 0003:         PRINT.SELF.RECL%
 217: 0003: 
 218: 0003:     %INCLUDE   SOFTSDEC.J86    ! SOFTSTAT                      CNS
 219: 0003: REM \
 220: 0003: \******************************************************************************
 221: 0003: \******************************************************************************
 222: 0003: \***
 223: 0003: \***                 %INCLUDE FOR THE SOFTWARE STATUS FILE
 224: 0003: \***   
 225: 0003: \***                      FILE TYPE  :   Direct
 226: 0003: \***
 227: 0003: \***                      REFERENCE  :   SOFTSDEC.J86
 228: 0003: \***
 229: 0003: \***	Version A	       Andrew Wedgeworth	      24th June 1992
 230: 0003: \***
 231: 0003: \******************************************************************************
 232: 0003: \*******************************************************************************
 233: 0003: 
 234: 0003:   STRING GLOBAL           \
 235: 0003:     SOFTS.RECORD$,        \           
 236: 0003:     SOFTS.SPACE$,         \           
 237: 0003:     SOFTS.FILE.NAME$    
 238: 0003:     
 239: 0003:   INTEGER*2 GLOBAL        \
 240: 0003:     SOFTS.RECL%,          \            
 241: 0003:     SOFTS.REPORT.NUM%,	  \      
 242: 0003:     SOFTS.SESS.NUM%
 243: 0003: 
 244: 0003:   INTEGER*4 GLOBAL        \
 245: 0003:     SOFTS.REC.NUM% 	         
 246: 0003:     %INCLUDE   RFSCFDEC.J86    ! RF Control File               CNS
 247: 0003: \******************************************************************************
 248: 0003: \******************************************************************************
 249: 0003: \***
 250: 0003: \***   $Workfile:   RFSCFDEC.J86  $
 251: 0003: \***
 252: 0003: \***   $Revision:   1.7  $
 253: 0003: \***
 254: 0003: \******************************************************************************
 255: 0003: \******************************************************************************
 256: 0003: \***
 257: 0003: \***
 258: 0003: \***
 259: 0003: \***
 260: 0003: \*****************************************************************************
 261: 0003: \*****************************************************************************
 262: 0003: \***
 263: 0003: \***               %INCLUDE FOR RFSCF - FIELD DECLARATIONS
 264: 0003: \***                                    FILE REFERENCE PARAMETERS
 265: 0003: \***
 266: 0003: \***                      FILE TYPE    : DIRECT
 267: 0003: \***
 268: 0003: \***                      REFERENCE    : RFSCFDEC
 269: 0003: \***
 270: 0003: \***           VERSION A : NIK SEN  5th October 1998
 271: 0003: \***
 272: 0003: \***
 273: 0003: \*******************************************************************************
 274: 0003: \*******************************************************************************
 275: 0003: \***           VERSIOB B       Mark Goode       23rd August 2004
 276: 0003: \***
 277: 0003: \***   Updated to reflect current RF version, also includes new fields for OSSR
 278: 0003: \*******************************************************************************
 279: 0003: \***           VERSION C       Jamie Thorpe      9th December 2004
 280: 0003: \***
 281: 0003: \***   Updated with record 3 variables.
 282: 0003: \*******************************************************************************
 283: 0003: \***           VERSION D       Jamie Thorpe     13th March 2006
 284: 0003: \***
 285: 0003: \***   Updated with record 1 variable.RFSCF.RECOUNT.DAYS.RETAIN%
 286: 0003: \*******************************************************************************
 287: 0003: \***           VERSION E       Peter Sserunkuma 28th September 2008
 288: 0003: \***
 289: 0003: \***   Added RFSCF.PLANNERS.ACTIVE$.  This was currently named
 290: 0003: \***   RFSCF.FILLER$ in record 1.
 291: 0003: \*******************************************************************************
 292: 0003: \***           VERSION F       Peter Sserunkuma   21st January 2009
 293: 0003: \***
 294: 0003: \***   Six new fields added to record 3 as part of SFSCF2 changes.
 295: 0003: \***   RFSCF.DIRECTS.ACTIVE$
 296: 0003: \***   RFSCF.ASN.ACTIVE$
 297: 0003: \***   RFSCF.POS.UOD.ACTIVE$
 298: 0003: \***   RFSCF.ONIGHT.DELIV$
 299: 0003: \***   RFSCF.ONIGHT.SCAN$
 300: 0003: \***   RFSCF.SCAN.BATCH$
 301: 0003: \*******************************************************************************
 302: 0003: \***           VERSION G       Tittoo Thomas          24th May 2012
 303: 0003: \***
 304: 0003: \***   Added RFSCF.PSP.LEAD.TIME$ in record 1, currently named RFSCF.FILLER$.
 305: 0003: \***   1 byte Packed and holds the number of days (usually 7 or 21 days). It
 306: 0003: \***   is used to indicate if a pending sales plan planner should be counted
 307: 0003: \***   if it becomes active in the next N days.
 308: 0003: \*******************************************************************************
 309: 0003: 
 310: 0003:   STRING GLOBAL                 \
 311: 0003:     RFSCF.ACTIVE$,              \ CJT
 312: 0003:     RFSCF.BCENTRES$,            \ CJT
 313: 0003:     RFSCF.CCHIST.NUM.DAYS$,     \CJT
 314: 0003:     RFSCF.FILE.NAME$,           \
 315: 0003:     RFSCF.FILLER$,              \
 316: 0003:     RFSCF.FILLER3$,             \ CJT
 317: 0003:     RFSCF.OSSRSTORE$,           \ BMG
 318: 0003:     RFSCF.PLANNERS.ACTIVE$,     \      !EPS
 319: 0003:     RFSCF.PSP.LEAD.TIME$,       \      !GTT
 320: 0003:     RFSCF.DIRECTS.ACTIVE$,      \      !FPS
 321: 0003:     RFSCF.ASN.ACTIVE$,          \      !FPS
 322: 0003:     RFSCF.POS.UOD.ACTIVE$,      \      !FPS
 323: 0003:     RFSCF.ONIGHT.DELIV$,        \      !FPS
 324: 0003:     RFSCF.ONIGHT.SCAN$,         \      !FPS
 325: 0003:     RFSCF.SCAN.BATCH.SIZE$             !FPS
 326: 0003: 
 327: 0003:   INTEGER*1 GLOBAL        \
 328: 0003:     RFSCF.ACTIVITY%,      \
 329: 0003:     RFSCF.EMUACTIVE%,     \
 330: 0003:     RFSCF.PRIMCURR%       ! BMG
 331: 0003: 
 332: 0003: 
 333: 0003:   INTEGER*2 GLOBAL        \
 334: 0003:     RFSCF.SESS.NUM%,      \
 335: 0003:     RFSCF.REPORT.NUM%,    \
 336: 0003:     RFSCF.RECL%,          \
 337: 0003:     RFSCF.PMEDTERM%,           \
 338: 0003:     RFSCF.QBUSTTERM%,          \
 339: 0003:     RFSCF.PMEDNEXTTXN%,        \
 340: 0003:     RFSCF.QBUSTNXTTXN%,        \
 341: 0003:     RFSCF.PCDATES%,            \
 342: 0003:     RFSCF.PCHKINC%,            \
 343: 0003:     RFSCF.HHTIPMIN%,           \
 344: 0003:     RFSCF.HHTIPMAX%,           \
 345: 0003:     RFSCF.RECOUNT.DAYS.RETAIN% ! DJT
 346: 0003: 
 347: 0003:   INTEGER*4 GLOBAL        \
 348: 0003:     RFSCF.REC.NUM%,       \
 349: 0003:     RFSCF.PMEDTXNCNT%,         \
 350: 0003:     RFSCF.PMEDQTY%,            \
 351: 0003:     RFSCF.QBUSTTXNCNT%,        \
 352: 0003:     RFSCF.QBUSTQTY%,           \
 353: 0003:     RFSCF.LDCPARM1%,           \
 354: 0003:     RFSCF.LDCPARM2%,           \
 355: 0003:     RFSCF.LDCPARM3%,           \
 356: 0003:     RFSCF.PCHKTARGET%,         \
 357: 0003:     RFSCF.CNTPCHK%,            \
 358: 0003:     RFSCF.PCHKUPPER%,          \
 359: 0003:     RFSCF.PCHKLOWER%,          \
 360: 0003:     RFSCF.PCHKDEFAULT%,        \
 361: 0003:     RFSCF.PCHKERRCNT%,         \
 362: 0003:     RFSCF.PCHKERRLST%,         \
 363: 0003:     RFSCF.EMUCNVFACT%          ! BMG
 364: 0003: 
 365: 0003: 
 366: 0003: 
 367: 0003: 
 368: 0003: 
 369: 0003: 
 370: 0003: 
 371: 0003: 
 372: 0003:     %INCLUDE   CLOLFDEC.J86    ! RF Count List Of Lists File   CNS
 373: 0003: 
 374: 0003: \******************************************************************************\******************************************************************************
 375: 0003: \******************************************************************************
 376: 0003: \***
 377: 0003: \***         %INCLUDE FOR RF LIST OF LISTS FILE FIELD DECLARATIONS
 378: 0003: \***
 379: 0003: \***               FILE TYPE    : DIRECT
 380: 0003: \***
 381: 0003: \***               REFERENCE    : CLOLFDEC.J86
 382: 0003: \***
 383: 0003: \***    VERSION A.           Nik Sen.               13 October 1998
 384: 0003: \***               New file for RF system. Holds list of counting lists. 
 385: 0003: \***
 386: 0003: \***    VERSION B            Charles Skadorwa        22nd January 1999
 387: 0003: \***               TOTAL.ITEMS added to keep track of total items in each list.
 388: 0003: \***                 
 389: 0003: \***    REVISION 1.4.            ROBERT COWEY.                  09 SEP 2003.
 390: 0003: \***    Changes for RF trial.
 391: 0003: \***    Removed redundant PVCS revision control block from top of code.
 392: 0003: \***    Recompiled to prevent future automatic recompiles.
 393: 0003: \***    No changes to actual code.
 394: 0003: \***
 395: 0003: \***    REVISION 1.5             ALAN CARR                     12 AUG 2004.
 396: 0003: \***    Changes for RF OSSR solution.
 397: 0003: \***    Added new flag "marked for OSSR count". This can be "Y" or "N"
 398: 0003: \***
 399: 0003: \***    REVISION 1.6            MARK GOODE                     5th January 2005.
 400: 0003: \***    Changes for RF OSSR WAN solution.
 401: 0003: \***    New field on the header record for remaining OSSR count figure and user ID
 402: 0003: \***
 403: 0003: \***    REVISION 1.7            SYAM JAYAN                     25th January 2012
 404: 0003: \***    The change is to rearrange/remove redundant fields and to add new
 405: 0003: \***    fields in CLOLF Format as part of Stock file accuracy project
 406: 0003: \***
 407: 0003: \*******************************************************************************
 408: 0003: \*******************************************************************************
 409: 0003: 
 410: 0003: STRING GLOBAL                   \
 411: 0003:     CLOLF.ACTIVE.STATUS$,       \                        ! 1.7 SJ
 412: 0003:     CLOLF.BULETT$,              \                        ! 1.7 SJ
 413: 0003:     CLOLF.CREATION.DATE$,       \Creation date           ! 1.7 SJ
 414: 0003:     CLOLF.CREATION.TIME$,       \Creation time           ! 1.7 SJ
 415: 0003:     CLOLF.CURRENT.LOCATION$,    \Current location        ! 1.7 SJ
 416: 0003:     CLOLF.EXPIRY.DATE$,         \Expiry date             ! 1.7 SJ
 417: 0003:     CLOLF.FILE.NAME$,           \                        ! 1.7 SJ
 418: 0003:     CLOLF.LISTID$,              \                        ! 1.7 SJ
 419: 0003:     CLOLF.LIST.NAME$,           \                        ! 1.7 SJ
 420: 0003:     CLOLF.LSTTYP$,              \                        ! 1.7 SJ
 421: 0003:     CLOLF.PICKER.USER.ID$,      \                        ! 1.7 SJ
 422: 0003:     CLOLF.PILST.ID$,            \                        ! 1.7 SJ
 423: 0003:     CLOLF.PICK.START.TIME$,     \Pick start time         ! 1.7 SJ
 424: 0003:     CLOLF.PICK.END.TIME$,       \Pick end time           ! 1.7 SJ
 425: 0003:     CLOLF.USERID$               ! 1.6 MG                 ! 1.7 SJ
 426: 0003:     !CLOLF.TOTAL.ITEMS$,        \ BCS                    ! 1.7 SJ
 427: 0003:     !CLOLF.SRITEMS$,            \                        ! 1.7 SJ
 428: 0003:     !CLOLF.BSITEMS$,            \                        ! 1.7 SJ
 429: 0003:     !CLOLF.BUNAME$,             \                        ! 1.7 SJ
 430: 0003:     !CLOLF.HOLISTID$,           \                        ! 1.7 SJ
 431: 0003:     !CLOLF.CNTDATE$,            \ 1.5 AC                 ! 1.7 SJ
 432: 0003:     !CLOLF.OSSR.FLAG$,          \ 1.5 AC                 ! 1.7 SJ
 433: 0003:     !CLOLF.OSSRITEMS$,          \ 1.6 MG                 ! 1.7 SJ
 434: 0003:   
 435: 0003: INTEGER*4 GLOBAL                \
 436: 0003:     CLOLF.RECORD.NUM%
 437: 0003: 
 438: 0003: INTEGER*2 GLOBAL                \
 439: 0003:     CLOLF.BSITEMS%,             \                        ! 1.7 SJ
 440: 0003:     CLOLF.OSSRITEMS%,           \                        ! 1.7 SJ
 441: 0003:     CLOLF.REPORT.NUM%,          \                        ! 1.7 SJ
 442: 0003:     CLOLF.SESS.NUM%,            \                        ! 1.7 SJ
 443: 0003:     CLOLF.SRITEMS%,             \                        ! 1.7 SJ
 444: 0003:     CLOLF.TOTAL.ITEMS%          !                        ! 1.7 SJ
 445: 0003:                                                   
 446: 0003: INTEGER*1 GLOBAL                \
 447: 0003:     CLOLF.RECL%         
 448: 0003: 
 449: 0003: 
 450: 0003:     %INCLUDE   CLILFDEC.J86    ! RF Count Lists File           CNS
 451: 0003: 
 452: 0003: \******************************************************************************\******************************************************************************
 453: 0003: \******************************************************************************
 454: 0003: \***
 455: 0003: \***         %INCLUDE FOR RF COUNT LISTS FILE FIELD DECLARATIONS
 456: 0003: \***
 457: 0003: \***               FILE TYPE    : KEYED
 458: 0003: \***
 459: 0003: \***               REFERENCE    : CLILFDEC.J86
 460: 0003: \***
 461: 0003: \***    VERSION A.              Nik Sen.                 13 October 1998
 462: 0003: \***                 New file for RF system. Holds count lists information.
 463: 0003: \***
 464: 0003: \***    VERSION B               Charles Skadorwa         22nd January 1999
 465: 0003: \***                 Head Office Sequence Number now held (from PIITM
 466: 0003: \***                 record) in order that a "complete" Type 13 transaction
 467: 0003: \***                 record is written to the STKMQ file. 
 468: 0003: \***
 469: 0003: \***    REVISION 1.4.            ROBERT COWEY.                  09 SEP 2003.
 470: 0003: \***    Changes for RF trial.
 471: 0003: \***    Removed redundant PVCS revision control block from top of code.
 472: 0003: \***    Recompiled to prevent future automatic recompiles.
 473: 0003: \***    No changes to actual code.
 474: 0003: \***
 475: 0003: \***    REVISION 1.5             ALAN CARR                      12 AUG 2004.
 476: 0003: \***    Changes for RF OSSR solution.
 477: 0003: \***    Added new fields for Off-Site StockRoom (OSSR) Basic Solution
 478: 0003: \***
 479: 0003: \***    REVISION 1.6             Mark Goode                     25th January 2005 
 480: 0003: \***
 481: 0003: \***    REVISION 1.7             Syam Jayan                     25th January 2012
 482: 0003: \***    The change is to rearrange/remove redundant fields and to add new
 483: 0003: \***    fields in CLILF Format as part of Stock file accuracy project
 484: 0003: \***
 485: 0003: \*******************************************************************************
 486: 0003: \*******************************************************************************
 487: 0003: 
 488: 0003: STRING GLOBAL                     \
 489: 0003:     CLILF.BOOTSCODE$,             \                                          ! 1.7 SJ
 490: 0003:     CLILF.COUNTED.STATUS$,        \ U-not counted, P-partially counted,      ! 1.7 SJ
 491: 0003:                                   \ C-counted                                ! 1.7 SJ
 492: 0003:     CLILF.DATE.LASTCNT$,          \ Date of Last Count field                 ! 1.7 SJ
 493: 0003:     CLILF.FILE.NAME$,             \                                          ! 1.7 SJ
 494: 0003:     CLILF.FILLER$(1),             \ Filler Array                             ! 1.7 SJ
 495: 0003:     CLILF.HO.SEQNO$,              \ Head Office Sequence No. from PIITM for  ! 1.7 SJ
 496: 0003:                                   \ Stock Support                            ! BCS ! 1.7 SJ
 497: 0003:     CLILF.ITEMSEQ$,               \ Item Sequence Number                     ! 1.7 SJ
 498: 0003:     CLILF.KEY$,                   \ LISTID + ITEMSEQ                         ! 1.7 SJ
 499: 0003:     CLILF.LISTID$,                \ List Number                              ! 1.7 SJ
 500: 0003:     CLILF.SPACE$                  ! Free space                               ! 1.7 SJ
 501: 0003:     !CLILF.BARCODE$,              \                                          ! 1.7 SJ
 502: 0003:     !CLILF.SELDESC$,              \ Shelf Edge Label Descriptor              ! 1.7 SJ
 503: 0003:     !CLILF.DEALMKR$,              \ Active Deal Marker                       ! 1.7 SJ
 504: 0003:     !CLILF.PRODGRP$,              \ Concept/Sequence Number                  ! 1.7 SJ
 505: 0003:     !CLILF.PRODGRPDESC$,          \ Product Group Descriptor                 ! 1.7 SJ 
 506: 0003:     !CLILF.BSCNT$,                \ Back Shop Counts                         ! 1.7 SJ
 507: 0003:     !CLILF.SFCNT$,                \ Shop Floor Counts                        ! 1.7 SJ
 508: 0003:     !CLILF.SALESSFCNT$,           \ Signed Sales at time of Shop Floor Count ! 1.7 SJ
 509: 0003:     !CLILF.SALEBSCNT$,            \ Sale at time of back shop count \ 1.5 AC ! 1.7 SJ
 510: 0003:     !CLILF.SALEOSSRCNT$,          \ Sale at time of OSSR count      \ 1.5 AC ! 1.7 SJ
 511: 0003:     !CLILF.OSSR.ITMSTKCNT$,       \ OSSR Item Stock count figure    \ 1.5 AC ! 1.7 SJ
 512: 0003:     !CLILF.TIMESFCNT$,            \ Time of Stock Floor count hh:mm \ 1.5 AC ! 1.7 SJ
 513: 0003:     !CLILF.TIMEBSCNT$,            \ Time of Back shop count hh:mm   \ 1.5 AC ! 1.7 SJ
 514: 0003:     !CLILF.TIMEOSSRCNT$,          \ Time of OSSR count hh:mm        \ 1.5 AC ! 1.7 SJ
 515: 0003: 
 516: 0003: INTEGER*4 GLOBAL                 \
 517: 0003:     CLILF.MODULE.ID%(1)          ! Planner ID Array (SRITL.POGDB%)           ! 1.7 SJ
 518: 0003: 
 519: 0003: INTEGER*2 GLOBAL                 \
 520: 0003:     CLILF.BSCNT%,                \ Main Backshop MBS Count                   ! 1.7 SJ
 521: 0003:     CLILF.BS.PEND.SA.CNT%,       \ Back Shop pending sales plan Count        ! 1.7 SJ
 522: 0003:     CLILF.COUNT%(1),             \ Count Array                               ! 1.7 SJ
 523: 0003:     CLILF.FILL.QUANTITY%(1),     \                                           ! 1.7 SJ
 524: 0003:     CLILF.OSSR.ITMSTKCNT%,       \ OSSR Item Stock count figure              ! 1.7 SJ
 525: 0003:     CLILF.OSSR.PEND.SA.CNT%,     \ OSSR pending sales plan Count field       ! 1.7 SJ
 526: 0003:     CLILF.RECL%,                 \                                           ! 1.7 SJ
 527: 0003:     CLILF.REPORT.NUM%,           \                                           ! 1.7 SJ
 528: 0003:     CLILF.SALESCNT%,             \ Sales count                               ! 1.7 SJ
 529: 0003:     CLILF.SESS.NUM%,             \ Clilf session number                      ! 1.7 SJ
 530: 0003:     CLILF.SFCNT%                 ! Shop floor count                          ! 1.7 SJ
 531: 0003:   
 532: 0003: INTEGER*1 GLOBAL                 \
 533: 0003:     CLILF.MODULE.SEQ%(1),        \ Module Seq Array (SRITL.MODULE.SEQ%)      ! 1.7 SJ
 534: 0003:     CLILF.REPEAT.CNT%(1)         ! Repeat Count Array (SRITL.REPEAT.CNT%)    ! 1.7 SJ
 535: 0003:     !CLILF.RECL%                 !                                           ! 1.7 SJ
 536: 0003: 
 537: 0003:     !%INCLUDE   ISFDEC.J86      ! Item Shelf Edge Label Descriptor File  CNS OAS
 538: 0003:     !%INCLUDE   IRFDEC.J86      ! Item Record File             CNS OAS
 539: 0003:     %INCLUDE   IDFDEC.J86      ! Item Data File                CNS
 540: 0003: REM \
 541: 0003: \******************************************************************************
 542: 0003: \******************************************************************************
 543: 0003: \***
 544: 0003: \***         %INCLUDE FOR ITEM DATA FILE - FIELD DECLARATIONS
 545: 0003: \***                                       FILE REFERENCE PARAMETERS
 546: 0003: \***
 547: 0003: \***                  FILE TYPE    : Keyed
 548: 0003: \***
 549: 0003: \***                  REFERENCE    : IDFDEC.J86
 550: 0003: \***
 551: 0003: \***         VERSION A : Andrew Wedgeworth  29th June 1992    
 552: 0003: \***
 553: 0003: \***    VERSION C.              Robert Cowey.                       25 AUG 1993.
 554: 0003: \***    Replaced un-used RANK$ with BSNS.CNTR$ and FILLER$.
 555: 0003: \***
 556: 0003: \***    VERSION D.              Andrew Wedgeworth               15th March 1995
 557: 0003: \***    Comments updated to reflect the fact that some bits on the file are
 558: 0003: \***    no longer used.
 559: 0003: \***
 560: 0003: \*******************************************************************************
 561: 0003: \*******************************************************************************
 562: 0003: 
 563: 0003:   STRING GLOBAL           \
 564: 0003:     IDF.FILE.NAME$,       \  
 565: 0003:     IDF.BOOTS.CODE$,      \ 4 byte UPD with check digit (key)
 566: 0003:     IDF.FIRST.BAR.CODE$,  \ 6 byte UPD without check digit
 567: 0003:     IDF.SECOND.BAR.CODE$, \ 6 byte UPD without check digit
 568: 0003:     IDF.NO.OF.BAR.CODES$, \ 2 byte UPD. Total number of bar codes for this item
 569: 0003:     IDF.PRODUCT.GRP$,     \ 3 byte UPD. The first two digits are the concept
 570: 0003:                           \ group and the last four the concept sequence
 571: 0003:     IDF.STNDRD.DESC$,     \ 24 bytes
 572: 0003:     IDF.STATUS.1$,        \ 1 byte, values B,C,D,P,X,Z and blank
 573: 0003:     IDF.INTRO.DATE$,      \ 3 byte UPD YYMMDD. Date first added to this file
 574: 0003:     IDF.BSNS.CNTR$,       \ 1 byte ASC. Business Centre ID letter      ! CRC
 575: 0003:     IDF.FILLER$,          \ 1 byte un-used                             ! CRC
 576: 0003:     IDF.PARENT.CODE$,     \ 4 byte UPD with check digit ; may be zero if no
 577: 0003:                           \ flashpacks, current IDF.BOOTS.CODE$ if parent line
 578: 0003:                           \ or Boots Code of parent line if a flashpack.
 579: 0003:     IDF.DATE.OF.LAST.SALE$! 3 byte UPD. Date of last sale.
 580: 0003: 
 581: 0003:   INTEGER*1 GLOBAL        \
 582: 0003:     IDF.BIT.FLAGS.1%,     \ 1 byte - bit values
 583: 0003:                           \ X"80"  - Group code flag
 584: 0003:                           \ X"40"  - Keylines flag
 585: 0003:                           \ X"20"  - Markdown flag
 586: 0003:                           \ X"10"  - Warehouse flag
 587: 0003:                           \ X"08"  - CSR flag
 588: 0003:                           \ X"04"  - Directs A flag
 589: 0003:                           \ X"02"  - Directs B flag
 590: 0003:                           \ X"01"  - Directs C flag
 591: 0003:     IDF.BIT.FLAGS.2%      \ 1 byte - bit values
 592: 0003:                           \ X"80"  - Own brand line flag
 593: 0003:                           \ X"40"  - Exclusive line flag
 594: 0003:                           \ X"20"  - Unused 
 595: 0003:                           \ X"10"  - Unused
 596: 0003:                           \ X"08"  - Stock system flag
 597: 0003:                           \ X"04"  - Pending count flag
 598: 0003:                           \ X"02"  - Reserved
 599: 0003:                           ! X"01"  - Reserved
 600: 0003: 
 601: 0003:   INTEGER*2 GLOBAL        \
 602: 0003:     IDF.RECL%,            \  
 603: 0003:     IDF.REPORT.NUM%,      \ 
 604: 0003:     IDF.SESS.NUM%
 605: 0003:     %INCLUDE   PGFDEC.J86      ! Product Group File            JMG
 606: 0003: 
 607: 0003: \REM
 608: 0003: \*******************************************************************************
 609: 0003: \*******************************************************************************
 610: 0003: \***
 611: 0003: \***    %INCLUDE FOR PRODUCT GROUP FILES VARIABLE DECLARATIONS
 612: 0003: \***
 613: 0003: \***        REFERENCE   :   PGFDEC (J86)
 614: 0003: \***
 615: 0003: \***        FILE TYPE   :   Direct (PGF and PGFD)
 616: 0003: \***                        Keyed (PGFO)
 617: 0003: \***
 618: 0003: \***    VERSION B.              ROBERT COWEY.                       30 SEP 1993.
 619: 0003: \***    Created by combining PGFDECA, PGFDFLDA, PGFOFLDA, PGFDNUMA and PGFONUMA.
 620: 0003: \***
 621: 0003: \***    REVISION 1.2.           ROBERT COWEY.                       27 OCT 2003.
 622: 0003: \***    Defined WRITE.PGF function.
 623: 0003: \***    No changes to this file.
 624: 0003: \***
 625: 0003: \***   Version C                Mark Goode                          21st December 2004
 626: 0003: \***   New field for Product groups marked as OSSR.
 627: 0003: \***   'Y' - OSSR Product group.
 628: 0003: \***   'N' - ' ' - Non-OSSR product group.
 629: 0003: \***
 630: 0003: \***    Version D               Tittoo Thomas                        2 SEP 2011
 631: 0003: \***    Changes to accomodate new csv format for PGDIR as part of
 632: 0003: \***    the Core Stores Release 2 project
 633: 0003: \***
 634: 0003: \*******************************************************************************
 635: 0003: \*******************************************************************************
 636: 0003: 
 637: 0003: 
 638: 0003: \*******************************************************************************
 639: 0003: \*******************************************************************************
 640: 0003: \***
 641: 0003: \***    OLD RECORD LAYOUT
 642: 0003: \***
 643: 0003: \***     1  3  UPD  PROD.GRP.NO$     Key
 644: 0003: \***     *  1  UPD  CON.GROUP$       Concept group
 645: 0003: \***     *  2  UPD  CON.SEQ$         Concept sequence
 646: 0003: \***     4 18  ASC  PROD.GRP.NAME$
 647: 0003: \***    22  1  ASC  SEL.FLAG$        "Y" Shelf edge labels not to be printed
 648: 0003: \***                                 "N" Shelf edge labels to be printed for
 649: 0003: \***                                     items in the product group
 650: 0003: \***    23  8  ASC  SPACE$
 651: 0003: \***
 652: 0003: \***    Record length 30
 653: 0003: \***
 654: 0003: \***    NEW CSV RECORD LAYOUT
 655: 0003: \***
 656: 0003: \***     1  ASC  REC.TYPE$        Hardcoded to 'P'
 657: 0003: \***     5  ASC  PROD.GRP.NO$     ccsss where,  cc is the Concept Group and
 658: 0003: \***                                            sss is the Sequence Number
 659: 0003: \***    18  ASC  PROD.GRP.NAME$
 660: 0003: \***     1  ASC  SEL.FLAG$        "Y" Shelf edge labels to be printed
 661: 0003: \***                              "N" Shelf edge labels not to be printed
 662: 0003: \***     1  UPD  OSSR.FLAG$       ALWAYS SET TO NULL - PLACEHOLDER ONLY
 663: 0003: \***
 664: 0003: \*******************************************************************************
 665: 0003: \*******************************************************************************
 666: 0003: \***
 667: 0003: \***    OTHER INFORMATION
 668: 0003: \***    Prefixes PGFDIR... and PGFO... are use for variables that are specific
 669: 0003: \***    to the direct (mainframe transmitted) of keyed (live store) usage of
 670: 0003: \***    the file.
 671: 0003: \***
 672: 0003: \*******************************************************************************
 673: 0003: \*******************************************************************************
 674: 0003: 
 675: 0003: 
 676: 0003:     STRING GLOBAL \
 677: 0003:         PGF.FILE.NAME$, \
 678: 0003:         PGF.PROD.GRP.NAME$, \
 679: 0003:         PGF.PROD.GRP.NO$, \
 680: 0003:         PGF.SEL.FLAG$, \
 681: 0003:         PGF.SPACE$, \
 682: 0003:         PGFDIR.FILE.NAME$, \
 683: 0003:         PGFDIR.REC.TYPE$, \                                             ! DTT
 684: 0003:         PGFO.FILE.NAME$,   \
 685: 0003:         PGF.OSSR.FLAG$
 686: 0003: 
 687: 0003:     INTEGER*2 GLOBAL \
 688: 0003:         PGF.RECL%, \
 689: 0003:         PGF.REPORT.NUM%, \
 690: 0003:         PGF.SESS.NUM%, \
 691: 0003:         PGFDIR.RECL%, \
 692: 0003:         PGFDIR.REPORT.NUM%, \
 693: 0003:         PGFDIR.SESS.NUM%, \
 694: 0003:         PGFO.RECL%, \
 695: 0003:         PGFO.REPORT.NUM%, \
 696: 0003:         PGFO.SESS.NUM%
 697: 0003: 
 698: 0003:     INTEGER*4 GLOBAL \
 699: 0003:         PGF.REC.NUM%, \
 700: 0003:         PGFDIR.REC.NO%
 701: 0003: 
 702: 0003:     %INCLUDE   MINLSDEC.J86    ! Minsits Recount Information   LJT
 703: 0003: 
 704: 0003: \*****************************************************************************
 705: 0003: \*****************************************************************************
 706: 0003: \***
 707: 0003: \***        %INCLUDE FIELD DECLARATIONS AND FILE REFERENCE PARAMETERS
 708: 0003: \***
 709: 0003: \***                   FILE TYPE:  KEYED
 710: 0003: \***
 711: 0003: \***                   REFERENCE:  MINLSDEC.J86
 712: 0003: \***
 713: 0003: \***              DESCRIPTION:  MINSITS RP - SCREEN COUNT INFORMATION
 714: 0003: \***
 715: 0003: \***
 716: 0003: \***
 717: 0003: \***      VERSION 1 : Julia Stones             8th January 1998  
 718: 0003: \***      
 719: 0003: \*****************************************************************************
 720: 0003: \*****************************************************************************
 721: 0003: 
 722: 0003: STRING GLOBAL   \
 723: 0003:    MINLS.FILE.NAME$,  \
 724: 0003:    MINLS.ITEM.CODE$,     \  4 byte UPD;  Record key
 725: 0003:    MINLS.RECOUNT.DATE$,  \  3 byte UPD;  YYMMDD      
 726: 0003:    MINLS.DISCREPANCY$,    \  3 byte UPD        
 727: 0003:    MINLS.COUNT.STATUS$     ! 1 byte ASCII 
 728: 0003: 
 729: 0003: INTEGER*2 GLOBAL  \
 730: 0003:    MINLS.RECL%,   \
 731: 0003:    MINLS.REPORT.NUM%,  \
 732: 0003:    MINLS.SESS.NUM%   !
 733: 0003: 
 734: 0003: 
 735: 0003: 
 736: 0003:     %INCLUDE   SRITLDEC.J86    ! Active Planner Details        OAS
 737: 0003: \********************************************************************
 738: 0003: \***      EXTERNAL FUNCTION DECLARATIONS FOR THE SRITL FILE
 739: 0003: \***      REFERENCE : SRITLDEC.J86
 740: 0003: \***      Version A           Neil Bennett            5th June 2006
 741: 0003: \***
 742: 0003: \********************************************************************
 743: 0003: 
 744: 0003:   INTEGER*1 GLOBAL        \
 745: 0003:     SRITL.RECORD.CHAIN%,  \ Chain Sequence
 746: 0003:     SRITL.MODULE.COUNT%,  \ Family hierarchy key level
 747: 0003:     SRITL.MODULE.SEQ%(1), \ Module sequence
 748: 0003:     SRITL.REPEAT.CNT%(1)  ! Repeat count
 749: 0003: 
 750: 0003:   INTEGER*2 GLOBAL        \
 751: 0003:     SRITL.CORE.COUNT%,    \ Sum of repeat count for core items
 752: 0003:     SRITL.MAX.MOD.KEYS%,  \ Maximum number of modules
 753: 0003:     SRITL.NON.CORE.CNT%,  \ Sum of repeat count for non core items
 754: 0003:     SRITL.SESS.NUM%,      \
 755: 0003:     SRITL.REPORT.NUM%,    \
 756: 0003:     SRITL.RECL%           !
 757: 0003: 
 758: 0003:   INTEGER*4 GLOBAL        \
 759: 0003:     SRITL.POGDB%(1)       ! Unique POG Database key
 760: 0003: 
 761: 0003:   STRING GLOBAL           \
 762: 0003:     SRITL.FILE.NAME$,     \ File name
 763: 0003:     SRITL.COPY.NAME$,     \ File name
 764: 0003:     SRITL.ITEM.CODE$,     \ Boots Item Code
 765: 0003:     SRITL.CORE.FLAG$(1),  \ Core/Non Core flag Y/N
 766: 0003:     SRITL.FILLER$         !
 767: 0003: 
 768: 0003: 
 769: 0003: 
 770: 0003: \*****************************************************************************
 771: 0003: \***
 772: 0003: \***    Included code defining function related global variables
 773: 0003: \***
 774: 0003: \***..........................................................................
 775: 0003: 
 776: 0003:     %INCLUDE PSBF01G.J86   !   APPLICATION.LOG
 777: 0003: REM \
 778: 0003: \*******************************************************************************
 779: 0003: \*******************************************************************************
 780: 0003: \***
 781: 0003: \***       %INCLUDE FOR GLOBAL DEFINITIONS FOR FUNCTION APPLICATION.LOG
 782: 0003: \***
 783: 0003: \***                FUNCTION NUMBER    : PSBF01
 784: 0003: \***
 785: 0003: \***                REFERENCE          : PSBF01G.J86
 786: 0003: \***
 787: 0003: \***                DATE OF LAST AMENDMENT  - 27/2/86
 788: 0003: \***
 789: 0003: \***
 790: 0003: \*******************************************************************************
 791: 0003: 
 792: 0003:       INTEGER GLOBAL  F01.RETURN.CODE%
 793: 0003: 
 794: 0003: 
 795: 0003:     %INCLUDE PSBF02G.J86   !   Update Date
 796: 0003: REM\
 797: 0003: \*******************************************************************************
 798: 0003: \*******************************************************************************
 799: 0003: \***
 800: 0003: \***        INCLUDE       : UPDATE.DATE globals
 801: 0003: \***
 802: 0003: \***        REFERENCE     : PSBF02G.J86
 803: 0003: \***
 804: 0003: \***        Version A     Bruce Scriver      4th March 1986
 805: 0003: \*** 
 806: 0003: \***        Version B     Andrew Wedgeworth   6th July 1992
 807: 0003: \***        Removal of return code field which no longer required.
 808: 0003: \***
 809: 0003: \*******************************************************************************
 810: 0003: \*******************************************************************************
 811: 0003: 
 812: 0003:       STRING   GLOBAL F02.DATE$
 813: 0003: 
 814: 0003:       ! 1 line deleted from here                                       ! BAW
 815: 0003: 
 816: 0003:     %INCLUDE PSBF06G.J86   !   Barcode check digit calculation  FCS
 817: 0003: REM\
 818: 0003: \*******************************************************************************
 819: 0003: \*******************************************************************************
 820: 0003: \***
 821: 0003: \***        INCLUDE       : CALC.BAR.CODE.CHECK.DIGIT globals
 822: 0003: \***
 823: 0003: \***        REFERENCE     : PSBF06G.J86
 824: 0003: \***
 825: 0003: \***        Version A     Bruce Scriver                 24th February 1986 
 826: 0003: \***
 827: 0003: \***        Version B     Andrew Wedgeworth                 15th July 1992
 828: 0003: \***        Removal of return code field which no longer required.
 829: 0003: \***
 830: 0003: \*******************************************************************************
 831: 0003: \*******************************************************************************
 832: 0003: 
 833: 0003:       STRING   GLOBAL F06.CHECK.DIGIT$
 834: 0003: 
 835: 0003: 
 836: 0003:     %INCLUDE PSBF20G.J86   !   ALLOCATE.DEALLOCATE.SESS.NUM
 837: 0003: REM\
 838: 0003: \*******************************************************************************
 839: 0003: \*******************************************************************************
 840: 0003: \***
 841: 0003: \***     %INCLUDE GLOBAL VARIABLE DEFINITIONS FOR SESS.NUM.UTILITY FUNCTION
 842: 0003: \***
 843: 0003: \***                       REFERENCE     : PSBF20G.J86
 844: 0003: \*** 
 845: 0003: \***     Version A              Bruce Scrive                   5th May 1988   
 846: 0003: \*** 
 847: 0003: \***     Version B              Robert Cowey                   7th May 1991
 848: 0003: \***     Global variable F20.INTEGER.FILE.NO% changed from one byte integer
 849: 0003: \***     to two byte integer.
 850: 0003: \***
 851: 0003: \***     Version D              Andrew Wedgeworth             1st July 1992
 852: 0003: \***     F20.RETURN.CODE% removed as it is no longer required.
 853: 0003: \***
 854: 0003: \*******************************************************************************
 855: 0003: \*******************************************************************************
 856: 0003: 
 857: 0003:       STRING    GLOBAL F20.FILE.NAME$,                                 \
 858: 0003:                        F20.STRING.FILE.NO$,                            \
 859: 0003:                        F20.TABLE.DIMENSIONED.FLAG$,                    \
 860: 0003:                        SESS.NUM.TABLE$(1)
 861: 0003: 
 862: 0003:       INTEGER*2 GLOBAL F20.INTEGER.FILE.NO%
 863: 0003: 
 864: 0003:       ! 1 line deleted from here                                       ! DAW 
 865: 0003: 
 866: 0003:     %INCLUDE PSBF13G.J86   !   To find the day of the week      OAS
 867: 0003: REM\
 868: 0003: \*******************************************************************************
 869: 0003: \*******************************************************************************
 870: 0003: \***
 871: 0003: \***        INCLUDE       : PSDATE globals
 872: 0003: \***
 873: 0003: \***        REFERENCE     : PSBF13G.J86
 874: 0003: \***
 875: 0003: \***     VERSION A                                  Bruce Scriver  6th Mar 86             
 876: 0003: \***            
 877: 0003: \***     VERSION B                                  Janet Lawrence 17 Aug 90
 878: 0003: \***     Add global to be used to indicate whether or not the function should
 879: 0003: \***     log an event when an invalid date is passed to it.
 880: 0003: \***
 881: 0003: \***     VERSION C                               Andrew Wedgeworth 17 July 92
 882: 0003: \***     Return code removed as no longer required.
 883: 0003: \***
 884: 0003: \*******************************************************************************
 885: 0003: \*******************************************************************************
 886: 0003: 
 887: 0003:       STRING    GLOBAL F13.DAY$,			\
 888: 0003:                        F13.DISPLAY.MESSAGE$		! BJAL
 889: 0003: 
 890: 0003: 
 891: 0003: 
 892: 0003: \*****************************************************************************
 893: 0003: \***
 894: 0003: \***    Global variable definitions
 895: 0003: \***
 896: 0003: \***..........................................................................
 897: 0003: 
 898: 0003:     STRING GLOBAL                           \
 899: 0003:         BATCH.SCREEN.FLAG$,                 \
 900: 0003:         COMM.MODE.FLAG$,                    \ OAS Set to B-Background  C-Foreground mode
 901: 0003:         CURRENT.CODE$,                      \
 902: 0003:         FILE.OPERATION$,                    \
 903: 0003:         MODULE.NUMBER$,                     \
 904: 0003:         OPERATOR.NUMBER$,                   \ OAS
 905: 0003:         REPORTING.STATUS$                   ! OAS
 906: 0003: 
 907: 0003:     INTEGER*2 GLOBAL                        \
 908: 0003:         CURRENT.REPORT.NUM%,                \
 909: 0003:         CURRENT.SESS.NUM%,                  \ OAS
 910: 0003:         FILE.RETURN.CODE%,                  \
 911: 0003:         FUNCTION.RETURN.CODE%
 912: 0003: 
 913: 0003:     INTEGER*1 GLOBAL                        \ OAS
 914: 0003:         TRUE,                               \ OAS
 915: 0003:         FALSE                               ! OAS
 916: 0003: 
 917: 0003: \*****************************************************************************
 918: 0003: \***
 919: 0003: \***    Variable definitions
 920: 0003: \***
 921: 0003: \***..........................................................................
 922: 0003: 
 923: 0003:     STRING                                  \ OAS
 924: 0003:         ADXSERVE.DATA$,                     \ DCS  \ OAS \ Holds display message
 925: 0003:        \ADXSTART.NAME$,                     \ OAS        \ Variable not used
 926: 0003:        \ADXSTART.PARM$,                     \ OAS        \ Variable not used
 927: 0003:        \ADXSTART.MESS$,                     \ OAS        \ Variable not used
 928: 0003:         BSNS.CNTR$,                         \ OAS
 929: 0003:        \COMMAND.STRING$,                    \ OAS        \ Variable not used
 930: 0003:         CLILF.DDD$,                         \ OAS
 931: 0003:         CLILF.BKUP.STATUS$,                 \ OAS
 932: 0003:         CLOLF.DDD$,                         \ OAS
 933: 0003:         CLOLF.BKUP.STATUS$,                 \ OAS
 934: 0003:         CLOLF.PGNAME$,                      \ ICC  \ OAS
 935: 0003:        \COMM.MODE.FLAG$,                    \ DCS  \ OAS \ MOVED TO TOP
 936: 0003:        \CRLF$,                              \ OAS        \ Variable not used
 937: 0003:         CURRENT.CODE.LOGGED$,               \ OAS
 938: 0003:         CURR.RUN.DAY$,                      \ RTT
 939: 0003:         FUNCTION.FLAG$,                     \ OAS
 940: 0003:         GET.DAY$,                           \ OAS
 941: 0003:        \GET.DATE$,                          \ OAS \ PBT
 942: 0003:         MINLS.HK.STATUS$,                   \ OAS
 943: 0003:         MINOK.FILE.NAME$,                   \ OAS
 944: 0003:         MINOK.FILLER$,                      \ RTT
 945: 0003:         MINOK.RECORD$,                      \ OAS
 946: 0003:         MINOK.RUN.DATE$,                    \ RTT
 947: 0003:         MINOK.RUN.TIME$,                    \ RTT
 948: 0003:         MINOK.TIME.STAMP$,                  \ RTT
 949: 0003:         MODULE$,                            \ OAS
 950: 0003:         OLD.BULETT$,                        \ CNS  \ OAS
 951: 0003:         OLD.PGNAME$,                        \ ICC  \ OAS
 952: 0003:         PASSED.STRING$,                     \ OAS
 953: 0003:         PIPE.OPEN$,                         \ FCS  \ OAS
 954: 0003:         PROGRAM$,                           \ OAS
 955: 0003:         QUOTES$,                            \ RTT
 956: 0003:         RESPONSE$,                          \ OAS
 957: 0003:         RPRPT.RECORD$,                      \ CNS  \ OAS
 958: 0003:        \RPRPT.REP.DATA$,                    \ OAS        \ Variable not used
 959: 0003:         TIME.NOW$,                          \ PBT
 960: 0003:         UPDATE.DATE$,                       \ CNS  \ OAS
 961: 0003:         VAR.STRING.1$,                      \ OAS
 962: 0003:         VAR.STRING.2$,                      \ OAS
 963: 0003:         YESTERDAY$                          ! RTT
 964: 0003: 
 965: 0003:     INTEGER*1                               \ OAS
 966: 0003:         COUNTER%,                           \ OAS
 967: 0003:         DO.MAIN,                            \ CNS  \ OAS
 968: 0003:         EOF,                                \ CNS  \ OAS
 969: 0003:         ERROR.COUNT%,                       \ OAS
 970: 0003:         EVENT.NUMBER%,                      \ OAS
 971: 0003:       \ LIST.ITEMS,                         \ CNS  \ OAS ! MOVED TO BOTTOM
 972: 0003:         MINPRINT.ALREADY.RUN%,              \ RTT
 973: 0003:         MINOK.ERROR.CHK%                    ! OAS
 974: 0003: 
 975: 0003:     INTEGER*2                               \ OAS
 976: 0003:         ADX.FUNCTION%,                      \ DCS  \ OAS
 977: 0003:         ADX.INTEGER%,                       \ DCS  \ OAS
 978: 0003:       \ CURRENT.SESS.NUM%,                  \ CNS  \ OAS ! MOVED TO TOP
 979: 0003:         LOOPCNT%,                           \ OAS
 980: 0003:         LIST.ITEMS,                         \ OAS
 981: 0003:         MESSAGE.NUMBER%,                    \ OAS
 982: 0003:         MINOK.REPORT.NUM%,                  \ OAS
 983: 0003:         MINOK.SESS.NUM%,                    \ OAS
 984: 0003:         PASSED.INTEGER%,                    \ OAS
 985: 0003:         RC%                                 ! OAS
 986: 0003:         !EVENT.NO%,                         ! FCS  \ OAS  \ Variable not used
 987: 0003:         !MESSAGE.NO%                        ! FCS  \ OAS  \ Variable not used
 988: 0003: 
 989: 0003:     INTEGER*4                               \ OAS
 990: 0003:         ADX.RETURN.CODE%,                   \ DCS  \ OAS
 991: 0003:         ADXCOPY.CHK%,                       \ OAS
 992: 0003:         FILE.SIZE%,                         \ OAS
 993: 0003:         RECORD.COUNT%                       ! OAS
 994: 0003:        !RPRPT.REC.MAX%,                     ! OAS         \ Variable not used
 995: 0003:        !RPRPT.REC.NUM%,                     ! OAS         \ Variable not used
 996: 0003:        !THE.TIME%                           ! FCS  \ OAS  \ Variable not used
 997: 0003: 
 998: 0003: \*****************************************************************************
 999: 0003: \***
1000: 0003: \***    EXT included code defining file related external functions
1001: 0003: \***
1002: 0003: \***..........................................................................
1003: 0003: 
1004: 0003:        %INCLUDE RPRPTEXT.J86
1005: 0003: \*****************************************************************************
1006: 0003: \***                                                                         *
1007: 0003: \*** EXTERNAL FUNCTION DEFINITIONS FOR THE MINSITS RP REPORT FILE            *
1008: 0003: \***                                                                         *
1009: 0003: \***                     REFERENCE : RPRPTEXT.J86                            *
1010: 0003: \***                                                                         *
1011: 0003: \***          Version A     Nik Sen            24th February 1998                *
1012: 0003: \***                                                                         *
1013: 0003: \*****************************************************************************
1014: 0003: 
1015: 0003:        FUNCTION RPRPT.SET EXTERNAL                                      
1016: 0003:        END FUNCTION                                                   
1017: 0003: 
1018: 0003:        %INCLUDE PRINTEXT.J86
1019: 0003: 
1020: 0003: REM \
1021: 0003: \*******************************************************************************
1022: 0003: \*******************************************************************************
1023: 0003: \***
1024: 0003: \***    %INCLUDE FOR PRINT FILE EXTERNAL FUNCTIONS
1025: 0003: \***
1026: 0003: \***        REFERENCE   :   PRINTEX (J86)
1027: 0003: \***
1028: 0003: \***        FILE TYPE   :   Printer / Labeller
1029: 0003: \***
1030: 0003: \***    VERSION A.              ANDREW WEDGEWORTH                   09 JUL 1992.
1031: 0003: \***    Original version created from PRINTEXG.
1032: 0003: \***
1033: 0003: \***    VERSION B.              UNKNOWN.                            ?? ??? 1992.
1034: 0003: \***    Changes unknown.
1035: 0003: \***
1036: 0003: \***    VERSION C.              ROBERT COWEY.                       18 NOV 1992.
1037: 0003: \***    Defined function variables for use as return codes.
1038: 0003: \***
1039: 0003: \***    Version C               Andrew Wedgeworth                 24th May 1992
1040: 0003: \***    Condensed print function added.
1041: 0003: \***
1042: 0003: \***    Version D               Stuart WIlliam McConnachie       31st July 2000.
1043: 0003: \***    Added function for PCL printing to LaserJet.
1044: 0003: \***
1045: 0003: \***    Version E               Charles Skadorwa                   4th Apr 2008.
1046: 0003: \***    Added parameter to WRITE.CONDENSED.PRINT function to
1047: 0003: \***    enable Alliance Pharmacy Brother Laser printers to print
1048: 0003: \***    in condensed mode.
1049: 0003: \***
1050: 0003: \***    Version F           Charles Skadorwa                       2nd Mar 2016.
1051: 0003: \***    It was found that certain reports would not print when stores
1052: 0003: \***    were converted to LAN attached printing.
1053: 0003: \***
1054: 0003: \***    Added new function: WRITE.PRINT.PLUS.LF based on WRITE.PRINT.
1055: 0003: \***    This adds a Line-Feed characters to every print line.
1056: 0003: \***
1057: 0003: \*******************************************************************************
1058: 0003: \*******************************************************************************
1059: 0003: 
1060: 0003: 
1061: 0003:     FUNCTION PRINT.SET EXTERNAL
1062: 0003:         INTEGER*2 PRINT.SET
1063: 0003:     END FUNCTION
1064: 0003: 
1065: 0003: 
1066: 0003:     FUNCTION WRITE.PRINT EXTERNAL
1067: 0003:        INTEGER*2 WRITE.PRINT
1068: 0003:     END FUNCTION
1069: 0003: 
1070: 0003: 
1071: 0003:     FUNCTION WRITE.PRINT.PLUS.LF EXTERNAL                               !FCS
1072: 0003:        INTEGER*2 WRITE.PRINT.PLUS.LF                                    !FCS
1073: 0003:     END FUNCTION                                                        !FCS
1074: 0003: 
1075: 0003: 
1076: 0003:     FUNCTION WRITE.CONDENSED.PRINT (AP.STORE) EXTERNAL                 ! ECSk
1077: 0003:        INTEGER*2 WRITE.CONDENSED.PRINT
1078: 0003:     END FUNCTION
1079: 0003: 
1080: 0003: 
1081: 0003:     FUNCTION WRITE.PCL.PRINT EXTERNAL                                  ! DSWM
1082: 0003:        INTEGER*2 WRITE.PCL.PRINT                                       ! DSWM
1083: 0003:     END FUNCTION                                                       ! DSWM
1084: 0003: 
1085: 0003: 
1086: 0003:     FUNCTION WRITE.LABEL EXTERNAL
1087: 0003:         INTEGER*2 WRITE.LABEL
1088: 0003:     END FUNCTION
1089: 0003: 
1090: 0003:        %INCLUDE SOFTSEXT.J86                                   ! CNS
1091: 0003: \*******************************************************************************
1092: 0003: \***                                                                         ***
1093: 0003: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE SOFTWARE STATUS FILE         ***
1094: 0003: \***                                                                         ***
1095: 0003: \***                     REFERENCE : SOFTSEXT.J86                            ***
1096: 0003: \***                                                                         ***
1097: 0003: \***      Version A         Andrew Wedgeworth          1st July 1992         ***
1098: 0003: \***
1099: 0003: \***   Version B
1100: 0003: \***                                                                      ***
1101: 0003: \***      Version C         Steve Wright               3rd May 1996          ***
1102: 0003: \***      Synchronise with function source.                                  ***
1103: 0003: \*******************************************************************************
1104: 0003: 
1105: 0003:       FUNCTION SOFTS.SET EXTERNAL 
1106: 0003:       END FUNCTION
1107: 0003:       
1108: 0003:       FUNCTION READ.SOFTS EXTERNAL
1109: 0003:           INTEGER*2 I%, READ.SOFTS
1110: 0003:       END FUNCTION	                   
1111: 0003: 
1112: 0003:       FUNCTION WRITE.SOFTS EXTERNAL
1113: 0003:           INTEGER*2 I%, WRITE.SOFTS
1114: 0003:       END FUNCTION
1115: 0003: 
1116: 0003: 
1117: 0003:        %INCLUDE RFSCFEXT.J86                                   ! CNS
1118: 0003: \******************************************************************************
1119: 0003: \******************************************************************************
1120: 0003: \***
1121: 0003: \***   $Workfile:   RFSCFEXT.J86  $
1122: 0003: \***
1123: 0003: \***   $Revision:   1.3  $
1124: 0003: \***
1125: 0003: \******************************************************************************
1126: 0003: \******************************************************************************
1127: 0003: \***
1128: 0003: \***
1129: 0003: \******************************************************************************
1130: 0003: \******************************************************************************
1131: 0003: \***
1132: 0003: \***                  FUNCTION DEFINITIONS FOR RFSCF
1133: 0003: \***
1134: 0003: \***                      REFERENCE    : RFSCFEXT
1135: 0003: \***
1136: 0003: \***           VERSION A : NIK SEN  5th October 1998
1137: 0003: \***
1138: 0003: \***
1139: 0003: \***   VERSION B             Mark Good
1140: 0003: \***   Added WRITE.RFSCF1
1141: 0003: \***
1142: 0003: \***   VERSION C             Jamie Thorpe
1143: 0003: \***   Added Read and Write dunctions for RFSCF record 3
1144: 0003: \***
1145: 0003: \***   VERSION D             Tittoo Thomas                         01 MAY 2013
1146: 0003: \***   Fixed READ and WRITE for RFSCF record 1 to have a return type set.
1147: 0003: \***
1148: 0003: \*****************************************************************************
1149: 0003: \*****************************************************************************
1150: 0003: 
1151: 0003:    FUNCTION RFSCF.SET EXTERNAL
1152: 0003:    END FUNCTION
1153: 0003: 
1154: 0003:    FUNCTION READ.RFSCF1 EXTERNAL
1155: 0003:       INTEGER*2 READ.RFSCF1            ! DTT
1156: 0003:    END FUNCTION
1157: 0003: 
1158: 0003:    FUNCTION WRITE.RFSCF1 EXTERNAL      ! BMG
1159: 0003:       INTEGER*2 WRITE.RFSCF1           ! DTT
1160: 0003:    END FUNCTION                        ! BMG
1161: 0003: 
1162: 0003:    FUNCTION READ.RFSCF3 EXTERNAL       ! CJT
1163: 0003:       INTEGER*2 READ.RFSCF3            ! CJT
1164: 0003:    END FUNCTION                        ! CJT
1165: 0003: 
1166: 0003:    FUNCTION WRITE.RFSCF3 EXTERNAL      ! CJT
1167: 0003:       INTEGER*2 WRITE.RFSCF3           ! CJT
1168: 0003:    END FUNCTION                        ! CJT
1169: 0003: 
1170: 0003:        %INCLUDE CLILFEXT.J86                                   ! CNS
1171: 0003:    
1172: 0003: \******************************************************************************
1173: 0003: \******************************************************************************\*****************************************************************************
1174: 0003: \***
1175: 0003: \***           FUNCTION DEFINITIONS FOR THE RF COUNT LISTS FILE
1176: 0003: \***
1177: 0003: \***           REFERENCE:   CLILFEXT.J86
1178: 0003: \***
1179: 0003: \***           VERSION A         Nik Sen         13th October 1998
1180: 0003: \***
1181: 0003: \***    REVISION 1.4.            ROBERT COWEY.                  09 SEP 2003.
1182: 0003: \***    Changes for RF trial.
1183: 0003: \***    Removed redundant PVCS revision control block from top of code.
1184: 0003: \***    Recompiled to prevent future automatic recompiles.
1185: 0003: \***    No changes to actual code.
1186: 0003: \***
1187: 0003: \*******************************************************************************
1188: 0003: \*******************************************************************************
1189: 0003: 
1190: 0003:    
1191: 0003:    FUNCTION CLILF.SET EXTERNAL
1192: 0003:    END FUNCTION
1193: 0003:    
1194: 0003:    FUNCTION READ.CLILF EXTERNAL
1195: 0003:       INTEGER*2 READ.CLILF
1196: 0003:    END FUNCTION
1197: 0003:    
1198: 0003:    FUNCTION WRITE.CLILF EXTERNAL
1199: 0003:       INTEGER*2 WRITE.CLILF
1200: 0003:    END FUNCTION
1201: 0003:  
1202: 0003:        %INCLUDE CLOLFEXT.J86                                   ! CNS
1203: 0003: 
1204: 0003: \******************************************************************************
1205: 0003: \******************************************************************************\*****************************************************************************
1206: 0003: \***
1207: 0003: \***           FUNCTION DEFINITIONS FOR THE RF COUNT LIST OF LISTS FILE
1208: 0003: \***
1209: 0003: \***           REFERENCE:   CLOLFEXT.J86
1210: 0003: \***
1211: 0003: \***           VERSION A         Nik Sen         13th October 1998
1212: 0003: \***
1213: 0003: \***    REVISION 1.4.            ROBERT COWEY.                  09 SEP 2003.
1214: 0003: \***    Changes for RF trial.
1215: 0003: \***    Removed redundant PVCS revision control block from top of code.
1216: 0003: \***    Recompiled to prevent future automatic recompiles.
1217: 0003: \***    No changes to actual code.
1218: 0003: \***
1219: 0003: \*******************************************************************************
1220: 0003: \*******************************************************************************
1221: 0003: 
1222: 0003:    FUNCTION CLOLF.SET EXTERNAL
1223: 0003:    END FUNCTION
1224: 0003:    
1225: 0003:    FUNCTION READ.CLOLF EXTERNAL
1226: 0003:       INTEGER*2 READ.CLOLF
1227: 0003:    END FUNCTION
1228: 0003:    
1229: 0003:    FUNCTION WRITE.CLOLF EXTERNAL
1230: 0003:       INTEGER*2 WRITE.CLOLF
1231: 0003:    END FUNCTION
1232: 0003:  
1233: 0003:        !%INCLUDE ISFEXT.J86                                    ! CNS !OAS
1234: 0003:        !%INCLUDE IRFEXT.J86                                    ! CNS !OAS
1235: 0003:        %INCLUDE IDFEXT.J86                                     ! CNS
1236: 0003: \*******************************************************************************
1237: 0003: \***                                                                         ***
1238: 0003: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE ITEM DESCRIPTION FILE        ***
1239: 0003: \***                                                                         ***
1240: 0003: \***                       REFERENCE : IDFEXT.J86                            ***
1241: 0003: \***                                                                         ***
1242: 0003: \***      Version A           Andrew Wedgeworth         9th July 1992        ***
1243: 0003: \***
1244: 0003: \***    VERSION C.              Robert Cowey.                       25 AUG 1993.
1245: 0003: \***    No changes to this file.
1246: 0003: \***
1247: 0003: \***   VERSION D               Nik Sen                 22nd December 1994
1248: 0003: \***   WRITE.IDF.HOLD added
1249: 0003: \***
1250: 0003: \*******************************************************************************
1251: 0003: 
1252: 0003:        FUNCTION IDF.SET EXTERNAL                                      
1253: 0003:        END FUNCTION                                                   
1254: 0003: 
1255: 0003: 
1256: 0003:        FUNCTION READ.IDF EXTERNAL                                     
1257: 0003:           INTEGER*2 READ.IDF                                          
1258: 0003:        END FUNCTION                                                   
1259: 0003: 
1260: 0003: 
1261: 0003:        FUNCTION READ.IDF.LOCK EXTERNAL                                
1262: 0003:           INTEGER*2 READ.IDF.LOCK                                     
1263: 0003:        END FUNCTION                                                   
1264: 0003: 
1265: 0003:        FUNCTION WRITE.IDF EXTERNAL
1266: 0003:           INTEGER*2 WRITE.IDF
1267: 0003:        END FUNCTION	       
1268: 0003: 
1269: 0003:        FUNCTION WRITE.IDF.HOLD EXTERNAL
1270: 0003:           INTEGER*2 WRITE.IDF.HOLD
1271: 0003:        END FUNCTION
1272: 0003: 
1273: 0003:        FUNCTION WRITE.IDF.UNLOCK EXTERNAL                                  
1274: 0003:           INTEGER*2 WRITE.IDF.UNLOCK                                      
1275: 0003:        END FUNCTION                                                   
1276: 0003:        %INCLUDE PGFEXT.J86                                     ! KMG
1277: 0003: 
1278: 0003: \REM
1279: 0003: \*******************************************************************************
1280: 0003: \*******************************************************************************
1281: 0003: \***
1282: 0003: \***    %INCLUDE FOR PRODUCT GROUP FILES EXTERNAL FUNCTIONS
1283: 0003: \***
1284: 0003: \***        REFERENCE   :   PGFDEC (J86)
1285: 0003: \***
1286: 0003: \***        FILE TYPE   :   Direct (PGF and PGFD)
1287: 0003: \***                        Keyed (PGFO)
1288: 0003: \***
1289: 0003: \***    VERSION B.              ROBERT COWEY.                       30 SEP 1993.
1290: 0003: \***    Created from PGFFUNB.
1291: 0003: \***
1292: 0003: \***    REVISION 1.2.           ROBERT COWEY.                       27 OCT 2003.
1293: 0003: \***    Defined WRITE.PGF function.
1294: 0003: \***
1295: 0003: \*******************************************************************************
1296: 0003: \*******************************************************************************
1297: 0003: 
1298: 0003: 
1299: 0003: FUNCTION PGF.SET EXTERNAL
1300: 0003:     INTEGER*2 PGF.SET
1301: 0003: END FUNCTION
1302: 0003: 
1303: 0003: FUNCTION READ.PGF EXTERNAL
1304: 0003:     INTEGER*2 READ.PGF
1305: 0003: END FUNCTION
1306: 0003: 
1307: 0003: FUNCTION WRITE.PGF EXTERNAL                                                ! 1.2 RC
1308: 0003:     INTEGER*2 WRITE.PGF                                                    ! 1.2 RC
1309: 0003: END FUNCTION                                                               ! 1.2 RC
1310: 0003: 
1311: 0003: FUNCTION READ.PGFDIR EXTERNAL
1312: 0003:     INTEGER*2 READ.PGFDIR
1313: 0003: END FUNCTION
1314: 0003: 
1315: 0003: FUNCTION WRITE.PGFDIR EXTERNAL
1316: 0003:     INTEGER*2 WRITE.PGFDIR
1317: 0003: END FUNCTION
1318: 0003: 
1319: 0003: FUNCTION READ.PGFO EXTERNAL
1320: 0003:     INTEGER*2 READ.PGFO
1321: 0003: END FUNCTION
1322: 0003: 
1323: 0003: FUNCTION WRITE.PGFO EXTERNAL
1324: 0003:     INTEGER*2 WRITE.PGFO
1325: 0003: END FUNCTION
1326: 0003: 
1327: 0003:        %INCLUDE MINLSEXT.J86   ! Minsits Recount Information   ! LJT
1328: 0003: 
1329: 0003: \*****************************************************************************
1330: 0003: \*****************************************************************************
1331: 0003: \***
1332: 0003: \***        %INCLUDE FOR FILE HANDLING FUNCTIONS EXTERNAL DEFINITIONS
1333: 0003: \***
1334: 0003: \***                   FILE TYPE:  KEYED
1335: 0003: \***
1336: 0003: \***                   REFERENCE:  MINLSEXT.J86
1337: 0003: \***
1338: 0003: \***	             DESCRIPTION:  MINSITS RP - SCREEN COUNT INFORMATION
1339: 0003: \***
1340: 0003: \***
1341: 0003: \***
1342: 0003: \***      VERSION 1 : Julia Stones             8th January 1998   
1343: 0003: \***      
1344: 0003: \*****************************************************************************
1345: 0003: \*****************************************************************************
1346: 0003: 
1347: 0003: 
1348: 0003:   FUNCTION MINLS.SET EXTERNAL
1349: 0003:      INTEGER*2 MINLS.SET
1350: 0003:   END FUNCTION
1351: 0003: 
1352: 0003: 
1353: 0003:   FUNCTION READ.MINLS EXTERNAL
1354: 0003:     INTEGER*2 READ.MINLS
1355: 0003:   END FUNCTION
1356: 0003:   
1357: 0003: 
1358: 0003:   FUNCTION READ.MINLS.LOCKED EXTERNAL
1359: 0003:     INTEGER*2 READ.MINLS.LOCKED
1360: 0003:   END FUNCTION  
1361: 0003: 
1362: 0003: 
1363: 0003:   FUNCTION WRITE.HOLD.MINLS EXTERNAL
1364: 0003:     INTEGER*2 WRITE.HOLD.MINLS
1365: 0003:   END FUNCTION
1366: 0003: 
1367: 0003: 
1368: 0003:   FUNCTION WRITE.UNLOCK.MINLS EXTERNAL
1369: 0003:     INTEGER*2 WRITE.UNLOCK.MINLS
1370: 0003:   END FUNCTION
1371: 0003: 
1372: 0003: 
1373: 0003:   FUNCTION WRITE.HOLD.UNLOCK.MINLS EXTERNAL
1374: 0003:     INTEGER*2 WRITE.HOLD.UNLOCK.MINLS
1375: 0003:   END FUNCTION
1376: 0003:   
1377: 0003: 
1378: 0003:   FUNCTION WRITE.MINLS EXTERNAL
1379: 0003:     INTEGER*2 WRITE.MINLS
1380: 0003:   END FUNCTION
1381: 0003: 
1382: 0003:        %INCLUDE PSBF13E.J86    ! To initialise day variable    ! OAS
1383: 0003: REM\
1384: 0003: \*******************************************************************************
1385: 0003: \*******************************************************************************
1386: 0003: \***
1387: 0003: \***        INCLUDE       : PSDATE external definition
1388: 0003: \***
1389: 0003: \***        REFERENCE     : PSBF13E.J86
1390: 0003: \***
1391: 0003: \***        Version A     Bruce Scriver                6th March 1986
1392: 0003: \*** 
1393: 0003: \***        Version B     Andrew Wedgeworth            17th July 1992  
1394: 0003: \***        Redundant parameters removed and PSDATE defined as a variable
1395: 0003: \***        to hold the return code. 
1396: 0003: \***
1397: 0003: \*******************************************************************************
1398: 0003: \*******************************************************************************
1399: 0003: 
1400: 0003:    FUNCTION PSDATE (INPUT.DATE$)                                               \
1401: 0003:    EXTERNAL
1402: 0003: 
1403: 0003:      STRING    INPUT.DATE$                                                   
1404: 0003:    
1405: 0003:      INTEGER*2 PSDATE 
1406: 0003: 
1407: 0003:    END FUNCTION
1408: 0003: 
1409: 0003:        %INCLUDE ADXCOPY.J86    ! To copy files                 ! OAS
1410: 0003: \******************************************************************************
1411: 0003: \******************************************************************************
1412: 0003: \***                                                                        ***
1413: 0003: \***    %INCLUDE FOR SUBROUTINE ADXCOPYF (an I.B.M. system subroutine)      ***
1414: 0003: \***                                                                        ***
1415: 0003: \***         DATE WRITTEN  :  13th May 1988                                 ***
1416: 0003: \***                                                                        ***
1417: 0003: \******************************************************************************
1418: 0003: \******************************************************************************
1419: 0003: 
1420: 0003:    SUB  ADXCOPYF (RETC, INFILE, OUTFILE, OPT0, OPT1, OPT2) EXTERNAL
1421: 0003: 
1422: 0003:       INTEGER*4   RETC
1423: 0003:       STRING      INFILE, OUTFILE
1424: 0003:       INTEGER*2   OPT0, OPT1, OPT2
1425: 0003: 
1426: 0003:    END  SUB
1427: 0003: 
1428: 0003:        %INCLUDE SRITLEXT.J86   ! Active Planner Details        ! OAS
1429: 0003: \********************************************************************
1430: 0003: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE SRITL FILE
1431: 0003: \***      REFERENCE : SRITLEXT.J86
1432: 0003: \***      Version A           Neil Bennett            7th July 2006
1433: 0003: \***
1434: 0003: \********************************************************************
1435: 0003: 
1436: 0003:        FUNCTION SRITL.SET EXTERNAL
1437: 0003:        END FUNCTION
1438: 0003: 
1439: 0003:        FUNCTION READ.SRITL EXTERNAL
1440: 0003:           INTEGER*2 READ.SRITL
1441: 0003:        END FUNCTION
1442: 0003: 
1443: 0003:        FUNCTION WRITE.SRITL EXTERNAL
1444: 0003:           INTEGER*2 WRITE.SRITL
1445: 0003:        END FUNCTION
1446: 0003: 
1447: 0003:         SUB MINRFCNT EXTERNAL                                   ! OAS
1448: 0003:         END SUB
1449: 0003: 
1450: 0003: \*****************************************************************************
1451: 0003: \***
1452: 0003: \***    Included code defining external Boots functions
1453: 0003: \***
1454: 0003: \***..........................................................................
1455: 0003: 
1456: 0003:     %INCLUDE PSBF01E.J86   !   APPLICATION.LOG
1457: 0003: REM \
1458: 0003: \*******************************************************************************
1459: 0003: \*******************************************************************************
1460: 0003: \***
1461: 0003: \***      %INCLUDE FOR EXTERNAL DEFINITION OF FUNCTION APPLICATION.LOG
1462: 0003: \***
1463: 0003: \***                      FUNCTION NUMBER   : PSBF01
1464: 0003: \***
1465: 0003: \***                    INCLUDE REFERENCE : PSBF01E.J86
1466: 0003: \*** 
1467: 0003: \***      Version B           Andrew Wedgeworth          1st July 1992
1468: 0003: \***      Three parameters which passed to the function have been removed.
1469: 0003: \***      APPLICATION.LOG has been added as a variable name (this holds the
1470: 0003: \***      return code).
1471: 0003: \***
1472: 0003: \*******************************************************************************
1473: 0003: 
1474: 0003: 
1475: 0003:    FUNCTION APPLICATION.LOG (MESSAGE.NO%,                                     \
1476: 0003:                              VAR.STRING.1$,                                   \
1477: 0003:                              VAR.STRING.2$,                                   \
1478: 0003:                              EVENT.NO%)  EXTERNAL
1479: 0003: 
1480: 0003:       INTEGER*1 EVENT.NO%
1481: 0003: 
1482: 0003:       INTEGER*2 APPLICATION.LOG,                                       \ GAW
1483: 0003:                 MESSAGE.NO%
1484: 0003: 
1485: 0003:       STRING VAR.STRING.1$,                                            \
1486: 0003:              VAR.STRING.2$
1487: 0003: 
1488: 0003:    END FUNCTION
1489: 0003: 
1490: 0003: \*******************************************************************************
1491: 0003:     %INCLUDE PSBF02E.J86   !   Update Date
1492: 0003: REM\
1493: 0003: \*******************************************************************************
1494: 0003: \*******************************************************************************
1495: 0003: \***
1496: 0003: \***        INCLUDE       : UPDATE.DATE external definition
1497: 0003: \***        AUTHOR        : Bruce Scriver (Basic Code)
1498: 0003: \***        DATE WRITTEN  : 4th March 1986 (Basic Code)
1499: 0003: \***
1500: 0003: \***        REFERENCE     : PSBF02E.J86
1501: 0003: \***
1502: 0003: \***        Version A     Bruce Scriver          4th March 1986
1503: 0003: \***
1504: 0003: \***        Version B     Andrew Wedgeworth       6th July 1992
1505: 0003: \***        Removal of redundant parameters, and inclusion of UPDATE.DATE as
1506: 0003: \***        a variable to hold the return code.
1507: 0003: \***
1508: 0003: \*******************************************************************************
1509: 0003: \*******************************************************************************
1510: 0003: 
1511: 0003:    FUNCTION UPDATE.DATE (INCREMENT%)                                   \
1512: 0003:    EXTERNAL
1513: 0003:    ! 3 parameters removed from here                                    ! BAW
1514: 0003: 
1515: 0003:    ! 3 lines deleted from here                                         ! BAW
1516: 0003:    
1517: 0003:       INTEGER*2 UPDATE.DATE                                            ! BAW
1518: 0003: 
1519: 0003:       INTEGER*4 INCREMENT%
1520: 0003: 
1521: 0003:    END FUNCTION
1522: 0003: 
1523: 0003:     %INCLUDE PSBF06E.J86   !   Barcode Check Digit Calculation   ! FCS ! OAS
1524: 0003: rem\
1525: 0003: \*******************************************************************************
1526: 0003: \*******************************************************************************
1527: 0003: \***
1528: 0003: \***
1529: 0003: \***         INCLUDE       : CALC.BAR.CODE.CHECK.DIGIT external definition
1530: 0003: \***
1531: 0003: \***         REFERENCE     : PSBF06E.J86
1532: 0003: \***
1533: 0003: \***         Version A     Bruce Scriver                  24th February 1986
1534: 0003: \***
1535: 0003: \***         Version B     Andrew Wedgeworth                  15th July 1992
1536: 0003: \***         Removal of redundant parameters, and inclusion of 
1537: 0003: \***         CALC.BAR.CODE.CHECK.DIGIT as a variable to hold the return code.
1538: 0003: \***
1539: 0003: \*******************************************************************************
1540: 0003: \*******************************************************************************
1541: 0003: 
1542: 0003:    FUNCTION CALC.BAR.CODE.CHECK.DIGIT (BAR.CODE.12$)                           \
1543: 0003:    EXTERNAL
1544: 0003:    ! 3 parameters removed from here                                    ! BAW
1545: 0003: 
1546: 0003:       STRING    BAR.CODE.12$
1547: 0003:    ! 3 variables removed from here                                     ! BAW
1548: 0003:    
1549: 0003:       INTEGER*2 CALC.BAR.CODE.CHECK.DIGIT                              ! BAW
1550: 0003:       
1551: 0003: 
1552: 0003:    END FUNCTION
1553: 0003: 
1554: 0003:     %INCLUDE PSBF08E.J86   !   Print Report Function
1555: 0003: rem\
1556: 0003: \*******************************************************************************
1557: 0003: \*******************************************************************************
1558: 0003: \***
1559: 0003: \***         INCLUDE       : PRINT.REPORT external definition
1560: 0003: \***
1561: 0003: \***         REFERENCE     : PSBF08E.J86
1562: 0003: \***
1563: 0003: \***         Version A     Bruce Scriver     27th February 1986
1564: 0003: \*** 
1565: 0003: \***         Version B     Andrew Wedgeworth      7th July 1992
1566: 0003: \***         Remove redundant parameters, and add PRINT.REPORT as a variable
1567: 0003: \***         to hold the return code.
1568: 0003: \*** 
1569: 0003: \***         Version C     Andrew Wedgeworth      24th May 1993
1570: 0003: \***         Extra parameter added to enable the printing of a condensed
1571: 0003: \***         report.
1572: 0003: \***
1573: 0003: \*******************************************************************************
1574: 0003: \*******************************************************************************
1575: 0003: 
1576: 0003:    FUNCTION PRINT.REPORT (SESSION.NUMBER%,CONDENSED.PRINT.FLAG$)       \ CAW
1577: 0003:    EXTERNAL
1578: 0003: 
1579: 0003:    STRING    CONDENSED.PRINT.FLAG$                                     ! CAW
1580: 0003:  
1581: 0003:    INTEGER   PRINT.REPORT,                                             \ BAW
1582: 0003:              SESSION.NUMBER%
1583: 0003: 
1584: 0003:    END FUNCTION
1585: 0003:     %INCLUDE PSBF20E.J86   !   ALLOCATE.DEALLOCATE.SESS.NUM
1586: 0003: REM\
1587: 0003: \*******************************************************************************
1588: 0003: \*******************************************************************************
1589: 0003: \***
1590: 0003: \***       %INCLUDE FOR EXTERNAL DEFINITION OF SESS.NUM.UTILITY
1591: 0003: \***
1592: 0003: \***                  REFERENCE     : PSBF20E.J86
1593: 0003: \***
1594: 0003: \***     VERSION C            Janet Smith                13th May 1992
1595: 0003: \***     Increased PASSED.INTEGER to 2 bytes to cater for more than
1596: 0003: \***     128 files.
1597: 0003: \***
1598: 0003: \***     VERSION D.           Andrew Wedgeworth          1st July 1992
1599: 0003: \***     Removal of redundant parameters and addition of SESS.NUM.UTILITY
1600: 0003: \***     as a variable.  This new variable contains the function's return
1601: 0003: \***     code.
1602: 0003: \***
1603: 0003: \*******************************************************************************
1604: 0003: \*******************************************************************************
1605: 0003: 
1606: 0003:    FUNCTION SESS.NUM.UTILITY (FUNCTION.FLAG$,                          \
1607: 0003:                               PASSED.INTEGER%,                         \
1608: 0003:                               PASSED.STRING$)                          \
1609: 0003:    EXTERNAL
1610: 0003: 
1611: 0003:    STRING    FUNCTION.FLAG$,                                           \
1612: 0003:              PASSED.STRING$
1613: 0003:    ! 3 variables removed from here                                     ! CAW
1614: 0003: 
1615: 0003: 
1616: 0003:    INTEGER*2 SESS.NUM.UTILITY,                                         \ CAW
1617: 0003:              PASSED.INTEGER%				               ! CJAS
1618: 0003: 
1619: 0003:    END FUNCTION
1620: 0003: 
1621: 0003:     %INCLUDE PSBF24E.J86   !   STANDARD.ERROR.DETECTED
1622: 0003: REM \
1623: 0003: \*******************************************************************************
1624: 0003: \*******************************************************************************
1625: 0003: \***
1626: 0003: \***    %INCLUDE FOR EXTERNAL DEFINITION OF STANDARD.ERROR.DETECTED FUNCTION
1627: 0003: \***
1628: 0003: \***                      REFERENCE     : PSBF24E.J86
1629: 0003: \***
1630: 0003: \***    Version A                 Janet Smith                  13th May 1992
1631: 0003: \***
1632: 0003: \*******************************************************************************
1633: 0003: \*******************************************************************************
1634: 0003: 
1635: 0003:    FUNCTION STANDARD.ERROR.DETECTED(ERRN%,                 \
1636: 0003: 				    ERRFILE%,              \
1637: 0003: 				    ERRL%,                 \
1638: 0003: 				    ERR$)        EXTERNAL
1639: 0003: 				    
1640: 0003:           STRING    ERR$
1641: 0003: 
1642: 0003:           INTEGER*2 ERRFILE%,              \
1643: 0003: 	            ERRL%,                 \
1644: 0003: 		    STANDARD.ERROR.DETECTED
1645: 0003: 		    
1646: 0003:           INTEGER*4 ERRN%
1647: 0003: 	  		    
1648: 0003:    END FUNCTION
1649: 0003: 
1650: 0003: 
1651: 0003:     %INCLUDE PSBF30E.J86   !   Process Keyed Record              ! LJT
1652: 0003: \*****************************************************************************
1653: 0003: \*****************************************************************************
1654: 0003: \***
1655: 0003: \***                 EXTERNAL FUNCTION DEFINITION PSBF30
1656: 0003: \***
1657: 0003: \*****************************************************************************
1658: 0003: \*****************************************************************************
1659: 0003: 
1660: 0003: \*****************************************************************************
1661: 0003: \*****************************************************************************
1662: 0003: \***
1663: 0003: \***   Version 96A              Mark Walker                31st May 1995
1664: 0003: \***   Original version.
1665: 0003: \***
1666: 0003: \***   Version B                Andrew Wedgeworth          17th March 1997
1667: 0003: \***   Added READONLY$ variable.  This parameter may be used to specify 
1668: 0003: \***   whether the file is to be opened with the READONLY option.
1669: 0003: \***
1670: 0003: \*****************************************************************************
1671: 0003: \*****************************************************************************
1672: 0003:  
1673: 0003:        FUNCTION PROCESS.KEYED.FILE(FILE.NAME$,                         \ 
1674: 0003:                                    REPORT.NUM%,                        \  
1675: 0003:                                    READONLY$) EXTERNAL
1676: 0003: 
1677: 0003:        STRING FILE.NAME$,READONLY$
1678: 0003:        INTEGER*2 PROCESS.KEYED.FILE,REPORT.NUM%
1679: 0003: 
1680: 0003:        END FUNCTION
1681: 0003: 
1682: 0003:     %INCLUDE ADXSERVE.J86  !   Message Logging                   ! DCS ! OAS
1683: 0003: \******************************************************************************
1684: 0003: \******************************************************************************
1685: 0003: \***                                                                        ***
1686: 0003: \***    %INCLUDE FOR FUNCTION ADXSERVE (an I.B.M. system function)          ***
1687: 0003: \***                                                                        ***
1688: 0003: \***         AUTHOR        :  Bruce Scriver                                 ***
1689: 0003: \***                                                                        ***
1690: 0003: \***         DATE WRITTEN  :  14th March 1986                               ***
1691: 0003: \***                                                                        ***
1692: 0003: \***         DATE OF LAST REVISION  - 14th March 1986                       ***
1693: 0003: \***                                                                        ***
1694: 0003: \***                                                                        ***
1695: 0003: \******************************************************************************
1696: 0003: \******************************************************************************
1697: 0003: 
1698: 0003:    SUB ADXSERVE (RETURN.CODE%,                                                \
1699: 0003:                  ADX.FUNCTION%,                                               \
1700: 0003:                  ADX.PARM.1%,                                                 \
1701: 0003:                  ADX.PARM.2$)                                                 \
1702: 0003:    EXTERNAL
1703: 0003:   
1704: 0003:       STRING     ADX.PARM.2$
1705: 0003: 
1706: 0003:       INTEGER*2  ADX.FUNCTION%,                                               \
1707: 0003:                  ADX.PARM.1%
1708: 0003: 
1709: 0003:       INTEGER*4  RETURN.CODE%                                                 \
1710: 0003: 
1711: 0003:    END SUB     
1712: 0003: 
1713: 0003:     %INCLUDE ADXSTART.J86  !   Chain to new program              ! FCS ! OAS
1714: 0003: \******************************************************************************
1715: 0003: \******************************************************************************
1716: 0003: \***                                                                        ***
1717: 0003: \***    %INCLUDE FOR FUNCTION ADXSTART (an I.B.M. system function)          ***
1718: 0003: \***                                                                        ***
1719: 0003: \***         AUTHOR        :  Barbara Holbrook                              ***
1720: 0003: \***                                                                        ***
1721: 0003: \***         DATE WRITTEN  :  26th June 1987                                ***
1722: 0003: \***                                                                        ***
1723: 0003: \***         DATE OF LAST REVISION  - 19th November 1987                    ***
1724: 0003: \***                                                                        ***
1725: 0003: \***                                                                        ***
1726: 0003: \******************************************************************************
1727: 0003: \******************************************************************************
1728: 0003: 
1729: 0003:    FUNCTION ADXSTART (ADX.NAME$,                                       \
1730: 0003:                       ADX.PARM$,                                       \
1731: 0003:                       ADX.MESS$)                                       \
1732: 0003:    EXTERNAL
1733: 0003: 
1734: 0003:       STRING     ADX.NAME$,                                            \
1735: 0003:                  ADX.PARM$,                                            \
1736: 0003:                  ADX.MESS$
1737: 0003: 
1738: 0003:       INTEGER*2  ADXSTART
1739: 0003: 
1740: 0003:    END FUNCTION
1741: 0003: 
1742: 0003:     %INCLUDE CMPDATE.J86   !   Date compare for Y2K compliance   ! IMG ! OAS
1743: 0003: !********************************************************************
1744: 0003: !***
1745: 0003: !***    INCLUDED CODE:  CMPDATE.J86
1746: 0003: !***    AUTHOR:         Stuart William McConnachie
1747: 0003: !***    DATE:           27th January 1997
1748: 0003: !***
1749: 0003: !********************************************************************
1750: 0003: !***   
1751: 0003: !***    Version B            Nik Sen                 30th March 1998
1752: 0003: !***    Changes to cope with a date of '000000' by replacing it with
1753: 0003: !***    '850101' before comparison. An all zero's date is valid in 
1754: 0003: !***    certain date fields and CMPDATE was returning the wrong result
1755: 0003: !***    when comparing with an actual date. Also change to cope with
1756: 0003: !***    dates of '999999' as some date fields are initialised to this
1757: 0003: !***    as a high value.
1758: 0003: !***
1759: 0003: !***    Version C    Stuart William McConnachie   20th December 1999
1760: 0003: !***    Improved function efficiency by changing tests for high and
1761: 0003: !***    low values, added above, to integers (rather than strings).
1762: 0003: !***    Also, using 850101 as a replacement for 000000, will not give
1763: 0003: !***    valid results after 350101 because of the 50 year wrap, so
1764: 0003: !***    corrected this.
1765: 0003: !***
1766: 0003: !***    Version D.  Stuart William McConnachie    26th February 2006
1767: 0003: !***    Place this code in it's own module in FUNLIB.  Make all
1768: 0003: !***    the functions herein EXTERNAL accordingly.
1769: 0003: !***
1770: 0003: !********************************************************************
1771: 0003: !***    
1772: 0003: !***    The following functions compare dates, checking for
1773: 0003: !***    century boundries.  Dates in the 50 years prior to the
1774: 0003: !***    compared date are less than the compared date, dates in
1775: 0003: !***    50 years after the compared date are greater than the
1776: 0003: !***    compared date.
1777: 0003: !***    Can handle dates in both packed and unpacked formats, or
1778: 0003: !***    a mixture of both.
1779: 0003: !***    In the case of a error, for example IH after detecting
1780: 0003: !***    illegal characters in VAL, the functions default to
1781: 0003: !***    comparing strings without testing for a change of century.
1782: 0003: !***
1783: 0003: !***    DATE.GT(DATE1$, DATE2$)  same as  DATE1$ >  DATE2$
1784: 0003: !***    DATE.GE(DATE1$, DATE2$)  same as  DATE1$ >= DATE2$
1785: 0003: !***    DATE.LT(DATE1$, DATE2$)  same as  DATE1$ <  DATE2$
1786: 0003: !***    DATE.LE(DATE1$, DATE2$)  same as  DATE1$ <= DATE2$
1787: 0003: !***
1788: 0003: !********************************************************************
1789: 0003: 
1790: 0003: FUNCTION DATE.GT(DATE1$, DATE2$) EXTERNAL                               !DSWM
1791: 0003:     STRING    DATE1$, DATE2$
1792: 0003:     INTEGER*1 DATE.GT
1793: 0003: END FUNCTION
1794: 0003: 
1795: 0003: 
1796: 0003: FUNCTION DATE.GE(DATE1$, DATE2$) EXTERNAL                               !DSWM
1797: 0003:     STRING    DATE1$, DATE2$
1798: 0003:     INTEGER*1 DATE.GE
1799: 0003: END FUNCTION
1800: 0003: 
1801: 0003: 
1802: 0003: FUNCTION DATE.LT(DATE1$, DATE2$) EXTERNAL                               !DSWM
1803: 0003:     STRING    DATE1$, DATE2$
1804: 0003:     INTEGER*1 DATE.LT
1805: 0003: END FUNCTION
1806: 0003: 
1807: 0003: 
1808: 0003: FUNCTION DATE.LE(DATE1$, DATE2$) EXTERNAL                               !DSWM
1809: 0003:     STRING    DATE1$, DATE2$
1810: 0003:     INTEGER*1 DATE.LE
1811: 0003: END FUNCTION
1812: 0003: 
1813: 0003:     %INCLUDE EALHSASC.J86  !                                           ! OAS
1814: 0003: \/* TIME STAMP BLOCK **********************************************
1815: 0003: \** END OF TIME STAMP BLOCK **************************************/
1816: 0003: !! THIS MODULE WAS CREATED BY APAR IR70269
1817: 0003: !*********************************************************************
1818: 0003: !
1819: 0003: ! ASSEMBLER SUBROUTNE DEFINITIONS
1820: 0003: !
1821: 0003: ! These definitions should be copied by any routine which wishes to
1822: 0003: ! use the performanced enhanced assembler routines.
1823: 0003: !
1824: 0003: !*********************************************************************
1825: 0003:  
1826: 0003: !*********************************************************************
1827: 0003: !
1828: 0003: ! SUBSTR
1829: 0003: !
1830: 0003: ! This routine performs a merge of two strings. String P3$, offset P4
1831: 0003: ! is merged into string P1$ offset P2 for a length of P5 bytes
1832: 0003: !
1833: 0003: ! CAUTION: P1$ must be long enough to totally contain P3$
1834: 0003: !
1835: 0003: ! NOTE: THE OFFSETS PASSED TO THIS ROUTINE ARE ZERO INDEXED
1836: 0003: !
1837: 0003: !*********************************************************************
1838: 0003:  
1839: 0003:  FUNCTION SUBSTR (P1$,P2,P3$,P4,P5) EXTERNAL
1840: 0003:  STRING P1$,P3$
1841: 0003:  INTEGER*2 P2,P4,P5
1842: 0003:  END FUNCTION
1843: 0003:  
1844: 0003: !*********************************************************************
1845: 0003: !
1846: 0003: ! GETN2/GETN4
1847: 0003: !
1848: 0003: ! These routines extract a two/four byte integer from a string.
1849: 0003: ! P2 is the offset within the string
1850: 0003: !
1851: 0003: ! NOTE: THE OFFSET PASSED TO THIS ROUTINE IS ZERO INDEXED
1852: 0003: !
1853: 0003: !*********************************************************************
1854: 0003:  
1855: 0003:  FUNCTION GETN2(P1$,P2) EXTERNAL
1856: 0003:  INTEGER*2 GETN2
1857: 0003:  STRING P1$
1858: 0003:  INTEGER*2 P2
1859: 0003:  END FUNCTION
1860: 0003:  
1861: 0003:  FUNCTION GETN4(P1$,P2) EXTERNAL
1862: 0003:  INTEGER*4 GETN4
1863: 0003:  STRING P1$
1864: 0003:  INTEGER*2 P2
1865: 0003:  END FUNCTION
1866: 0003:  
1867: 0003: !*********************************************************************
1868: 0003: !
1869: 0003: ! PUTN2/PUTN4
1870: 0003: !
1871: 0003: ! These routines insert a two/four byte integer into a string.
1872: 0003: ! P2 is the offset within the string and P3 is the source integer
1873: 0003: !
1874: 0003: ! NOTE: THE OFFSET PASSED TO THIS ROUTINE IS ZERO INDEXED
1875: 0003: !
1876: 0003: !*********************************************************************
1877: 0003:  
1878: 0003:  FUNCTION PUTN2(P1$,P2,P3) EXTERNAL
1879: 0003:  STRING P1$
1880: 0003:  INTEGER*2 P2,P3
1881: 0003:  END FUNCTION
1882: 0003:  
1883: 0003:  FUNCTION PUTN4(P1$,P2,P3) EXTERNAL
1884: 0003:  STRING P1$
1885: 0003:  INTEGER*2 P2
1886: 0003:  INTEGER*4 P3
1887: 0003:  END FUNCTION
1888: 0003:  
1889: 0003: !*********************************************************************
1890: 0003: !
1891: 0003: ! PACKBIN2/4
1892: 0003: !
1893: 0003: ! These routines take a packed decimal string and convert to integer
1894: 0003: ! (The equivalent of CBASIC INT%(VAL(UNPACK$())) )
1895: 0003: ! P1 is the source string, P2 the string offset and P3 the length
1896: 0003: !
1897: 0003: ! NOTE: THE OFFSET PASSED TO THIS ROUTINE IS ZERO INDEXED
1898: 0003: !
1899: 0003: !*********************************************************************
1900: 0003:  
1901: 0003:  FUNCTION PACKBIN2(P1$,P2,P3) EXTERNAL
1902: 0003:  INTEGER*2 PACKBIN2
1903: 0003:  STRING P1$
1904: 0003:  INTEGER*2 P2,P3
1905: 0003:  END FUNCTION
1906: 0003:  
1907: 0003:  FUNCTION PACKBIN4(P1$,P2,P3) EXTERNAL
1908: 0003:  INTEGER*4 PACKBIN4
1909: 0003:  STRING P1$
1910: 0003:  INTEGER*2 P2,P3
1911: 0003:  END FUNCTION
1912: 0003:  
1913: 0003: !*********************************************************************
1914: 0003: !
1915: 0003: ! ADDIN2/4
1916: 0003: !
1917: 0003: ! These routines add an integer into an integer which is imbedded within
1918: 0003: ! a string.  P1$ is the string containing at offset P2 the integer to be
1919: 0003: ! updated.  P3 is the integer to be added into P1$.
1920: 0003: !
1921: 0003: ! NOTE: THE OFFSET PASSED TO THIS ROUTINE IS ZERO INDEXED
1922: 0003: !
1923: 0003: !*********************************************************************
1924: 0003:  
1925: 0003:  FUNCTION ADDIN4(P1$,P2,P3) EXTERNAL
1926: 0003:  INTEGER*4 ADDIN4
1927: 0003:  STRING P1$
1928: 0003:  INTEGER*2 P2
1929: 0003:  INTEGER*4 P3
1930: 0003:  END FUNCTION
1931: 0003:  
1932: 0003:  FUNCTION ADDIN2(P1$,P2,P3) EXTERNAL
1933: 0003:  INTEGER*2 ADDIN2
1934: 0003:  STRING P1$
1935: 0003:  INTEGER*2 P2,P3
1936: 0003:  END FUNCTION
1937: 0003:  
1938: 0003: !*********************************************************************
1939: 0003: !
1940: 0003: ! MATCHB
1941: 0003: !
1942: 0003: ! This routine performs a fast match function when the string being
1943: 0003: ! searched for contains only a single character.  As with the MATCH
1944: 0003: ! function, P1$ is the character to be found, P2$ is the string to be
1945: 0003: ! searched, and P3 the offst at which to start the search.
1946: 0003: !
1947: 0003: !*********************************************************************
1948: 0003:  
1949: 0003:  FUNCTION MATCHB(P1$,P2$,P3) EXTERNAL
1950: 0003:  INTEGER*2 MATCHB
1951: 0003:  STRING P1$
1952: 0003:  STRING P2$
1953: 0003:  INTEGER*2 P3
1954: 0003:  END FUNCTION
1955: 0003:  
1956: 0003: \ REM!! *************************************************************!!
1957: 0003: \ REM!! PROCEDURE - CONVERT A PACKED DECIMAL DATA STRING TO A        !!
1958: 0003: \ REM!! 4 BYTE BINARY INTEGER REPRESENTED AS A STRING.               !!
1959: 0003: \ REM!! STRING "OUT$" MUST BE INITIALIZED BEFORE CALLING THE ROUTINE.!!
1960: 0003: \ REM!! *************************************************************!!
1961: 0003:  
1962: 0003: SUB UPDBIN4 (IN$,OUT$) EXTERNAL
1963: 0003: STRING IN$,OUT$
1964: 0003: END SUB
1965: 0003:  
1966: 0003: \ REM!! *************************************************************!!
1967: 0003: \ REM!! PROCEDURE - CONVERT A PACKED DECIMAL DATA STRING TO A        !!
1968: 0003: \ REM!! 3 BYTE BINARY INTEGER REPRESENTED AS A STRING.               !!
1969: 0003: \ REM!! STRING "OUT$" MUST BE INITIALIZED BEFORE CALLING THE ROUTINE.!!
1970: 0003: \ REM!! *************************************************************!!
1971: 0003:  
1972: 0003: SUB UPDBIN3 (IN$,OUT$) EXTERNAL
1973: 0003: STRING IN$,OUT$
1974: 0003: END SUB
1975: 0003:  
1976: 0003: \ REM!! *************************************************************!!
1977: 0003: \ REM!! PROCEDURE - CONVERT A PACKED DECIMAL DATA STRING TO A        !!
1978: 0003: \ REM!! 2 BYTE BINARY INTEGER REPRESENTED AS A STRING.               !!
1979: 0003: \ REM!! STRING "OUT$" MUST BE INITIALIZED BEFORE CALLING THE ROUTINE.!!
1980: 0003: \ REM!! *************************************************************!!
1981: 0003:  
1982: 0003: SUB UPDBIN2 (IN$,OUT$) EXTERNAL
1983: 0003: STRING IN$,OUT$
1984: 0003: END SUB
1985: 0003:  
1986: 0003: \ REM!! *************************************************************!!
1987: 0003: \ REM!! PROCEDURE - CONVERT A PACKED DECIMAL DATA STRING TO A        !!
1988: 0003: \ REM!! 1 BYTE BINARY INTEGER REPRESENTED AS A STRING.               !!
1989: 0003: \ REM!! STRING "OUT$" MUST BE INITIALIZED BEFORE CALLING THE ROUTINE.!!
1990: 0003: \ REM!! *************************************************************!!
1991: 0003:  
1992: 0003: SUB UPDBIN1 (IN$,OUT$) EXTERNAL
1993: 0003: STRING IN$,OUT$
1994: 0003: END SUB
1995: 0003:  
1996: 0003: \ REM!! *************************************************************!!
1997: 0003: \ REM!! PROCEDURE - CONVERT A PACKED DECIMAL DATA STRING TO A        !!
1998: 0003: \ REM!! 4 BYTE HEX REPRESENTATION OF A 2-BYTE INTEGER                !!
1999: 0003: \ REM!! STRING "OUT$" MUST BE INITIALIZED BEFORE CALLING THE ROUTINE.!!
2000: 0003: \ REM!! *************************************************************!!
2001: 0003:  
2002: 0003: SUB UPDHEX2 (IN$,OUT$) EXTERNAL
2003: 0003: STRING IN$,OUT$
2004: 0003: END SUB
2005: 0003:  
2006: 0003: \ REM!! *************************************************************!!
2007: 0003: \ REM!! PROCEDURE - CONVERT A PACKED DECIMAL DATA STRING TO A        !!
2008: 0003: \ REM!! 2 BYTE HEX REPRESENTATION OF A 1-BYTE INTEGER                !!
2009: 0003: \ REM!! STRING "OUT$" MUST BE INITIALIZED BEFORE CALLING THE ROUTINE.!!
2010: 0003: \ REM!! *************************************************************!!
2011: 0003:  
2012: 0003: SUB UPDHEX1 (IN$,OUT$) EXTERNAL
2013: 0003: STRING IN$,OUT$
2014: 0003: END SUB
2015: 0003:  
2016: 0003: \ REM!! *************************************************************!!
2017: 0003: \ REM!! PROCEDURE - CONVERT AN INPUT 4 BYTE INTEGER REPRESENTED AS A !!
2018: 0003: \ REM!! STRING TO A 2 BYTE BINARY INTEGER REPRESENTED AS A STRING    !!
2019: 0003: \ REM!! WHERE BOTH THE INPUT AND OUTPUT MAY BE IMBEDDED WITHIN THE   !!
2020: 0003: \ REM!! GIVEN STRING AT THE GIVEN OFFSET.                            !!
2021: 0003: \ REM!! STRING "OUT$" MUST BE INITIALIZED BEFORE CALLING THE ROUTINE.!!
2022: 0003: \ REM!!
2023: 0003: \ REM!! NOTE: THE OFFSETS PASSED TO THIS ROUTINE ARE UNIT INDEXED
2024: 0003: \ REM!! *************************************************************!!
2025: 0003:  
2026: 0003: SUB INTBIN2 (IN$,IN%,OUT$,OUT%) EXTERNAL
2027: 0003: STRING IN$,OUT$
2028: 0003: INTEGER IN%,OUT%
2029: 0003: END SUB
2030: 0003:  
2031: 0003: \ REM!! *************************************************************!!
2032: 0003: \ REM!! PROCEDURE - CONVERT AN INPUT 4 BYTE INTEGER REPRESENTED AS A !!
2033: 0003: \ REM!! STRING TO A 3 BYTE BINARY INTEGER REPRESENTED AS A STRING    !!
2034: 0003: \ REM!! WHERE BOTH THE INPUT AND OUTPUT MAY BE IMBEDDED WITHIN THE   !!
2035: 0003: \ REM!! GIVEN STRING AT THE GIVEN OFFSET.                            !!
2036: 0003: \ REM!! STRING "OUT$" MUST BE INITIALIZED BEFORE CALLING THE ROUTINE.!!
2037: 0003: \ REM!!
2038: 0003: \ REM!! NOTE: THE OFFSETS PASSED TO THIS ROUTINE ARE UNIT INDEXED
2039: 0003: \ REM!! *************************************************************!!
2040: 0003:  
2041: 0003: SUB INTBIN3 (IN$,IN%,OUT$,OUT%) EXTERNAL
2042: 0003: STRING IN$,OUT$
2043: 0003: INTEGER IN%,OUT%
2044: 0003: END SUB
2045: 0003:  
2046: 0003: \ REM!! *************************************************************!!
2047: 0003: \ REM!! PROCEDURE - CONVERT AN INPUT 4 BYTE INTEGER REPRESENTED AS A !!
2048: 0003: \ REM!! STRING TO A 4 BYTE BINARY INTEGER REPRESENTED AS A STRING    !!
2049: 0003: \ REM!! WHERE BOTH THE INPUT AND OUTPUT MAY BE IMBEDDED WITHIN THE   !!
2050: 0003: \ REM!! GIVEN STRING AT THE GIVEN OFFSET.                            !!
2051: 0003: \ REM!! STRING "OUT$" MUST BE INITIALIZED BEFORE CALLING THE ROUTINE.!!
2052: 0003: \ REM!!
2053: 0003: \ REM!! NOTE: THE OFFSETS PASSED TO THIS ROUTINE ARE UNIT INDEXED
2054: 0003: \ REM!! *************************************************************!!
2055: 0003:  
2056: 0003: SUB INTBIN4 (IN$,IN%,OUT$,OUT%) EXTERNAL
2057: 0003: STRING IN$,OUT$
2058: 0003: INTEGER IN%,OUT%
2059: 0003: END SUB
2060: 0003:  
2061: 0003: 
2062: 0003: !**********************************************************************! LJT
2063: 0003: !***                                                                   ! LJT
2064: 0003: !***      PROCESS.KEYED.RECORD$                                        ! LJT
2065: 0003: !***                                                                   ! LJT
2066: 0003: !***      'User exit' for PROCESS.KEYED.FILE (PSBF30)                  ! LJT
2067: 0003: !***                                                                   ! LJT
2068: 0003: !**********************************************************************! LJT
2069: 0003: 
2070: 0003: FUNCTION PROCESS.KEYED.RECORD$(RECORD$) PUBLIC                         ! LJT
2071: 001c: 
2072: 001c:     STRING PROCESS.KEYED.RECORD$,RECORD$                               ! LJT
2073: 001c: 
2074: 001c:        MINLS.ITEM.CODE$ = LEFT$(RECORD$,4)                             ! LJT
2075: 0036:        RC% = READ.MINLS                                                ! LJT
2076: 003e: 
2077: 003e:        F02.DATE$ = UNPACK$(MINLS.RECOUNT.DATE$)                        ! LJT
2078: 0059:        CALL UPDATE.DATE(RFSCF.RECOUNT.DAYS.RETAIN%)                    ! LJT
2079: 006b:        IF DATE.LE(F02.DATE$, DATE$) THEN BEGIN                         ! LJT
2080: 008a:           DELREC MINLS.SESS.NUM%; MINLS.ITEM.CODE$                     ! LJT
2081: 00a1:           !Turn off PENDING COUNT flag on the IDF                      ! LJT
2082: 00a1:           IDF.BOOTS.CODE$ = MINLS.ITEM.CODE$                           ! LJT
2083: 00b7:           RC% = READ.IDF                                               ! LJT
2084: 00bf:           IF RC% = 0 THEN BEGIN                                        ! LJT
2085: 00c4:           !Make sure the flag is set to on first                       ! LJT
2086: 00c4:              IF (IDF.BIT.FLAGS.2% AND 00000100b) <> 0 THEN BEGIN       ! LJT
2087: 00d1:              !It's on, so turn it off                                  ! LJT
2088: 00d1:                  IDF.BIT.FLAGS.2% = (IDF.BIT.FLAGS.2% XOR 4)           ! LJT
2089: 00e1:                  RC% = WRITE.IDF                                       ! LJT
2090: 00e9:              ENDIF                                                     ! LJT
2091: 00e9:           ENDIF                                                        ! LJT
2092: 00e9:        ENDIF                                                           ! LJT
2093: 00e9: 
2094: 00e9:     PROCESS.KEYED.RECORD$ = RECORD$                                    ! LJT
2095: 00f9: 
2096: 00f9: END FUNCTION                                                           ! LJT
2097: 010f: 
2098: 010f: \*****************************************************************************
2099: 010f: \***
2100: 010f: \***    PROGRAM.CONTROL
2101: 010f: \***
2102: 010f: \***..........................................................................
2103: 010f: 
2104: 010f: 
2105: 010f: MINPRINT.START:
2106: 0129: 
2107: 0129: 
2108: 0129:     ON ERROR GOTO ERROR.DETECTED
2109: 0136: 
2110: 0136:     IF LEFT$(COMMAND$,8) = "BACKGRND" THEN BEGIN                       ! DCS ! OAS
2111: 0168:         COMM.MODE.FLAG$ = "B"                                          ! DCS ! OAS
2112: 017a:     ENDIF ELSE BEGIN                                                   ! OAS
2113: 017a:         COMM.MODE.FLAG$ = "C"                                          ! DCS ! OAS
2114: 0189:         IF LEFT$(COMMAND$,8) = "RERUN" THEN BEGIN                      ! OAS
2115: 01be: 
2116: 01be:             !MINPRINT will run with the help of SLEEPER program in     ! OAS
2117: 01be:             !background. If MINPRINT has to be run manually, then      ! OAS
2118: 01be:             !user has to enter the following parameters in command     ! OAS
2119: 01be:             !mode, "MINPRINT RERUN".                                   ! OAS
2120: 01be: 
2121: 01be:             GOSUB MINPRINT.HELP                                        ! OAS
2122: 01c8:             INPUT "Do you really want to run MINPRINT? (Y/N) ";RESPONSE$ ! OAS ! CCSk
2123: 01e1: 
2124: 01e1:             !If the user enters wrong option other than "Y", "N", "y"  ! OAS
2125: 01e1:             !or "n", program will ask the user to enter the correct    ! OAS
2126: 01e1:             !choice                                                    ! OAS
2127: 01e1: 
2128: 01e1:             WHILE ((RESPONSE$ <> "Y" ) AND    \                        ! OAS
2129: 01e3:                    (RESPONSE$ <> "y" ) AND    \                        ! OAS
2130: 01e3:                    (RESPONSE$ <> "N" ) AND    \                        ! OAS
2131: 01e3:                    (RESPONSE$ <> "n" ) )                               ! OAS
2132: 01e3: 
2133: 01e3:                 INPUT "Enter the correct option (Y/N) ";RESPONSE$      ! OAS
2134: 01fc:             WEND                                                       ! OAS
2135: 028d: 
2136: 028d:             !If the user response is "Y" or "y" then re-run MINPRINT   ! OAS
2137: 028d:             !If the user response is "N" or "n" then STOP the program  ! OAS
2138: 028d: 
2139: 028d:             IF ((RESPONSE$ = "Y") OR       \                           ! OAS
2140: 02d1:                 (RESPONSE$ = "y")) THEN BEGIN                          ! OAS
2141: 02d1: 
2142: 02d1:                 ADXSERVE.DATA$ = "Re - running MINPRINT"               ! OAS
2143: 02de:                 GOSUB DISPLAY.MESSAGE                                  ! OAS
2144: 02ea: 
2145: 02ea:             ENDIF ELSE IF ((RESPONSE$ = "N") OR \                      ! OAS
2146: 032e:                            (RESPONSE$ = "n")) THEN BEGIN               ! OAS
2147: 032e:                 STOP                                                   ! OAS
2148: 0333:             ENDIF                                                      ! OAS
2149: 0335: 
2150: 0335:         ENDIF ELSE BEGIN                                               ! OAS
2151: 0335: 
2152: 0335:             !If the user runs MINPRINT without any parameter,          ! OAS
2153: 0335:             !then the program will display the help details            ! OAS
2154: 0335: 
2155: 0335:             GOSUB MINPRINT.HELP                                        ! OAS
2156: 033f:             STOP                                                       ! OAS
2157: 0344:         ENDIF                                                          ! OAS
2158: 0344: 
2159: 0344:     ENDIF
2160: 0344: 
2161: 0344:     ADXSERVE.DATA$ = "MINPRINT has started"                            ! DCS
2162: 0351:     GOSUB DISPLAY.MESSAGE                                              ! DCS
2163: 035b: 
2164: 035b:     GOSUB CREATE.MINOK.FILE                                            ! OAS
2165: 0365: 
2166: 0365:     IF MINPRINT.ALREADY.RUN% THEN BEGIN                                ! RTT
2167: 036c:        ADXSERVE.DATA$ = "MINPRINT already run. " +                     \ RTT
2168: 0380:                         "Rerun will overwrite CLILF/CLOLF backups"     ! RTT
2169: 0380:        GOSUB DISPLAY.MESSAGE                                           ! RTT
2170: 038a:        GOSUB STOP.PROGRAM                                              ! RTT
2171: 0394:     ENDIF                                                              ! RTT
2172: 0394: 
2173: 0394:     !Processing of RFCNTLST.DAY report which is defined in MINRFCNT.BAS! OAS
2174: 0394:     GOSUB CALL.MINRFCNT                                                ! OAS
2175: 039e: 
2176: 039e:     GOSUB INITIALISATION
2177: 03a8:     GOSUB GET.SOFTS
2178: 03b2: 
2179: 03b2:     DO.MAIN = 1                                                        ! CNS
2180: 03b7: 
2181: 03b7:     !If RF is ON, then will instruct RF server to close all files and  ! OAS
2182: 03b7:     !backup the CLILF and CLOLF files else it will continue with the   ! OAS
2183: 03b7:     !backup of CLILF/CLOLF files                                       ! OAS
2184: 03b7: 
2185: 03b7:     IF MATCH(" ACTIVE",SOFTS.RECORD$,1) THEN BEGIN                     ! NCS
2186: 03d4:        ADXSERVE.DATA$ = "Detected RF / Network PDT  Store"             ! DCS ! NCS
2187: 03e1:        GOSUB DISPLAY.MESSAGE                                           ! DCS
2188: 03eb:        DO.MAIN = 0                                                     ! CNS
2189: 03f0: 
2190: 03f0:        \***********************************************************    ! FCS ! OAS
2191: 03f0:        \***                                                            ! OAS
2192: 03f0:        \***  Instruct the RF Server to close all files                 ! FCS ! OAS
2193: 03f0:        \***                                                            ! OAS
2194: 03f0:        \***********************************************************    ! FCS ! OAS
2195: 03f0: 
2196: 03f0:        IF END #64 THEN RFS.BYPASS                                      ! HBG
2197: 03ff:        OPEN "PI:rfscomms" AS 64                                        ! FCS
2198: 0412:        PIPE.OPEN$ = "Y"                                                ! FCS
2199: 041f:        PRINT USING "&"; #64 ; "CLS*"                                   ! FCS
2200: 043a:        CLOSE 64                                                        ! FCS
2201: 0441:        PIPE.OPEN$ = "N"                                                ! FCS
2202: 044e:        ADXSERVE.DATA$ = "Waiting for RFS Close."                       ! FCS
2203: 045b:        GOSUB DISPLAY.MESSAGE                                           ! FCS
2204: 0465:        WAIT ;15000                                                     ! FCS
2205: 0474: 
2206: 0474:     ENDIF                                                              ! OAS
2207: 0474: 
2208: 0474: RFS.BYPASS:                                                            ! HBG
2209: 0474:     GOSUB BACKUP.CLILF.CLOLF.FILES                                     ! OAS
2210: 047e:     GOSUB RF.PROCESS                                                   ! CNS
2211: 0488:     !Earlier, only RF/POD stores have the CLOLF/CLILF files present
2212: 0488:     !(around 900 stores). All other stores are PDT stores and they do
2213: 0488:     !not use the CLOLF/CLILF. However as part of SFA, these files need
2214: 0488:     !creating and populating like RF/POD stores. Hence, removing the
2215: 0488:     !seprate processing section for the ‘non RF’ stores
2216: 0488: 
2217: 0488:     !ENDIF ELSE BEGIN                                                  ! DCS ! OAS
2218: 0488:     !  ADXSERVE.DATA$ = "Detected NON-RF Store"                        ! DCS ! NCS
2219: 0488:     !  GOSUB DISPLAY.MESSAGE                                           ! DCS ! OAS
2220: 0488:     !                                                                        ! OAS
2221: 0488:     !  GOSUB PROCESS.RFSCF                                             ! LJT ! OAS
2222: 0488:     !                                                                        ! OAS
2223: 0488:     !  ADXSERVE.DATA$ = "Open MINLS file"                              ! LJT ! OAS
2224: 0488:     !  GOSUB DISPLAY.MESSAGE                                           ! LJT ! OAS
2225: 0488:     !  CURRENT.SESS.NUM% = MINLS.SESS.NUM%                             ! LJT ! OAS
2226: 0488:     !  IF END #MINLS.SESS.NUM% THEN FILE.ERROR.EXIT                    ! LJT ! OAS
2227: 0488:     !  OPEN MINLS.FILE.NAME$ KEYED RECL MINLS.RECL% AS MINLS.SESS.NUM% \ LJT ! OAS
2228: 0488:     !                                                            NODEL ! LJT ! OAS
2229: 0488:     !                                                                        ! OAS
2230: 0488:     !  ADXSERVE.DATA$ = "Open IDF file"                                ! LJT ! OAS
2231: 0488:     !  GOSUB DISPLAY.MESSAGE                                           ! LJT ! OAS
2232: 0488:     !  CURRENT.SESS.NUM% = IDF.SESS.NUM%                               ! LJT ! OAS
2233: 0488:     !  IF END #IDF.SESS.NUM% THEN FILE.ERROR.EXIT                      ! LJT ! OAS
2234: 0488:     !  OPEN IDF.FILE.NAME$ KEYED RECL IDF.RECL% AS IDF.SESS.NUM%       \ LJT ! OAS
2235: 0488:     !                                                           NODEL  ! LJT ! OAS
2236: 0488:     !                                                                        ! OAS
2237: 0488:     !  RC% = PROCESS.KEYED.FILE(MINLS.FILE.NAME$,MINLS.REPORT.NUM%,"N")! LJT ! OAS
2238: 0488:     !                                                                        ! OAS
2239: 0488:     !  CLOSE MINLS.SESS.NUM%                                           ! LJT ! OAS
2240: 0488:     !ENDIF                                                             ! DCS ! OAS
2241: 0488: 
2242: 0488:     GOSUB WRITE.MINOK                                                  ! OAS
2243: 0492: 
2244: 0492:     GOSUB TERMINATION
2245: 049c: 
2246: 049c: 
2247: 049c: STOP.PROGRAM:
2248: 049c: 
2249: 049c:     ADXSERVE.DATA$ = "--- MINPRINT has finished ---"                   ! DCS
2250: 04a9:     GOSUB DISPLAY.MESSAGE                                              ! DCS
2251: 04b3: 
2252: 04b3: 
2253: 04b3:     STOP
2254: 04b8: 
2255: 04b8: 
2256: 04b8: \*****************************************************************************
2257: 04b8: \***
2258: 04b8: \***    MINPRINT.HELP
2259: 04b8: \***
2260: 04b8: \***..........................................................................
2261: 04b8: 
2262: 04b8: MINPRINT.HELP:
2263: 04b8: 
2264: 04b8:     PRINT "                         MINPRINT HELP                                       "! OAS
2265: 04c1:     PRINT "                                                                             "! OAS
2266: 04ca:     PRINT "This program requires the RERUN parameter to be entered for running          "! OAS
2267: 04d3:     PRINT "from command mode. For a rerun, the complete program will run, and it        "! OAS
2268: 04dc:     PRINT "must be noted that the following will take place:                            "! OAS
2269: 04e5:     PRINT "                                                                             "! OAS
2270: 04ee:     PRINT "-    backs up the CLOLF.BIN & CLILF.BIN count list files to CLOLF.nnn and    "! OAS
2271: 04f7:     PRINT "     CLILF.nnn where nnn is MON or TUE etc depending on todays date. This    "! OAS
2272: 0500:     PRINT "     will overwrite any existing backup files which feed into the Weekly     "! OAS
2273: 0509:     PRINT "     Count reporting                                                         "! OAS
2274: 0512:     PRINT "-    creates empty CLOLF.BIN and CLILF.BIN files deleting any counts         "! OAS
2275: 051b:     PRINT "     currently on the files                                                  "! OAS
2276: 0524:     PRINT "-    it is recommended to manually backup all CLILF/CLOLF backups and BIN    "! OAS
2277: 052d:     PRINT "     before rerunning MINPRINT                                               "! OAS
2278: 0536:     PRINT "                                                                             "! OAS
2279: 053f: 
2280: 053f: RETURN
2281: 0547: 
2282: 0547: \*****************************************************************************
2283: 0547: \***
2284: 0547: \***    WRITE.MINOK
2285: 0547: \***
2286: 0547: \***..........................................................................
2287: 0547: 
2288: 0547: WRITE.MINOK:                                                            ! OAS
2289: 0547: 
2290: 0547:     ADXSERVE.DATA$ = "Updating MINOK file"                              ! OAS
2291: 0554:     GOSUB DISPLAY.MESSAGE                                               ! OAS
2292: 055e: 
2293: 055e:     FUNCTION.FLAG$ EQ "C"                                               ! OAS
2294: 056b:     CURRENT.SESS.NUM% = MINOK.SESS.NUM%                                 ! OAS
2295: 0575:     IF END #MINOK.SESS.NUM% THEN FILE.ERROR.EXIT                        ! OAS
2296: 0586:     CREATE MINOK.FILE.NAME$ AS MINOK.SESS.NUM%                          ! OAS
2297: 059f: 
2298: 059f:     FILE.OPERATION$ = "W"                                               ! OAS
2299: 05ae:     CURRENT.REPORT.NUM% = MINOK.REPORT.NUM%                             ! OAS
2300: 05b8: 
2301: 05b8:     MINOK.ERROR.CHK% = FALSE                                            ! OAS
2302: 05c2: 
2303: 05c2: !                             MINOK FILE FORMAT                                    ! OAS
2304: 05c2: !                                                                                  ! OAS
2305: 05c2: !   |--------------------------|-------------|---------------------------------|   ! OAS
2306: 05c2: !   |Field Name                |  Field Type | Description                     |   ! OAS
2307: 05c2: !   |--------------------------|-------------|---------------------------------|   ! OAS
2308: 05c2: !   |Run date                  |  8 ASC      | CCYYMMDD                        |   ! OAS
2309: 05c2: !   |Run time                  |  6 ASC      | HHMMSS                          |   ! OAS
2310: 05c2: !   |Reporting status          |  1 ASC      | E = Report processing successful|   ! OAS
2311: 05c2: !   |                          |             | X = Report processing failed    |   ! OAS
2312: 05c2: !   |CLILF backup status       |  1 ASC      | E = Backup successful           |   ! OAS
2313: 05c2: !   |                          |             | X = Backup failed               |   ! OAS
2314: 05c2: !   |CLOLF backup status       |  1 ASC      | E = Backup successful           |   ! OAS
2315: 05c2: !   |                          |             | X = Backup failed               |   ! OAS
2316: 05c2: !   |MINLS housekeeping status |  1 ASC      | E = Processing successful       |   ! OAS
2317: 05c2: !   |                          |             | X = Processing failed           |   ! OAS
2318: 05c2: !   |Filler                    |  62 ASC     | Spaces                          |   ! OAS
2319: 05c2: !   |--------------------------|-------------|---------------------------------|   ! OAS
2320: 05c2: 
2321: 05c2: !    WRITE #MINOK.SESS.NUM%;                             \               ! OAS  ! RTT
2322: 05c2: !        LEFT$(MINOK.RECORD$, 14) +                      \               ! OAS  ! RTT
2323: 05c2: !        REPORTING.STATUS$ +                             \               ! OAS  ! RTT
2324: 05c2: !        CLILF.BKUP.STATUS$ +                            \               ! OAS  ! RTT
2325: 05c2: !        CLOLF.BKUP.STATUS$ +                            \               ! OAS  ! RTT
2326: 05c2: !        MINLS.HK.STATUS$ +                              \               ! OAS  ! RTT
2327: 05c2: !        STRING$(62, " ")                                                ! OAS  ! RTT
2328: 05c2: 
2329: 05c2:     WRITE #MINOK.SESS.NUM%;                             \               ! RTT
2330: 061b:         MINOK.RUN.DATE$ +                               \               ! RTT
2331: 061b:         MINOK.RUN.TIME$ +                               \               ! RTT
2332: 061b:         REPORTING.STATUS$ +                             \               ! RTT
2333: 061b:         CLILF.BKUP.STATUS$ +                            \               ! RTT
2334: 061b:         CLOLF.BKUP.STATUS$ +                            \               ! RTT
2335: 061b:         MINLS.HK.STATUS$ +                              \               ! RTT
2336: 061b:         STRING$(62, " ")                                                ! RTT
2337: 061b: 
2338: 061b:        MINOK.ERROR.CHK% = TRUE                                          ! OAS
2339: 0625: 
2340: 0625: MINOK.ERROR:                                                            ! OAS
2341: 0625: 
2342: 0625:     IF MINOK.ERROR.CHK% = FALSE THEN BEGIN                              ! OAS
2343: 0632: 
2344: 0632:         ADXSERVE.DATA$ = "MINOK file not processed successfully - ERROR"! OAS
2345: 063f:         GOSUB DISPLAY.MESSAGE                                           ! OAS
2346: 064b: 
2347: 064b:     ENDIF ELSE IF MINOK.ERROR.CHK% = TRUE THEN BEGIN                    ! OAS
2348: 0658: 
2349: 0658:         ADXSERVE.DATA$ = "MINOK file processed successfully"            ! OAS
2350: 0665:         GOSUB DISPLAY.MESSAGE                                           ! OAS
2351: 066f: 
2352: 066f:     ENDIF                                                               ! OAS
2353: 066f: 
2354: 066f:     CLOSE MINOK.SESS.NUM%                                               ! OAS
2355: 0678: 
2356: 0678: RETURN                                                                  ! OAS
2357: 0680: 
2358: 0680: \*****************************************************************************
2359: 0680: \***
2360: 0680: \***    INITIALISATION
2361: 0680: \***
2362: 0680: \***..........................................................................
2363: 0680: 
2364: 0680: 
2365: 0680: INITIALISATION:
2366: 0680: 
2367: 0680: 
2368: 0680:     ADXSERVE.DATA$ = "INITIALISATION"                                ! DCS
2369: 068d:     GOSUB DISPLAY.MESSAGE                                            ! DCS
2370: 0697:     GOSUB INITIALISE.VARIABLES
2371: 06a1: 
2372: 06a1:     GOSUB ALLOCATE.SESSION.NUMBERS
2373: 06ab: 
2374: 06ab: RETURN
2375: 06b3: 
2376: 06b3: 
2377: 06b3: \*****************************************************************************
2378: 06b3: \***
2379: 06b3: \***    INITIALISATION SPECIFIC ROUTINES
2380: 06b3: \***
2381: 06b3: \***..........................................................................
2382: 06b3: 
2383: 06b3: 
2384: 06b3: \*****************************************************************************
2385: 06b3: \***
2386: 06b3: \***    INITIALISE.VARIABLES
2387: 06b3: \***    Sets program variables.
2388: 06b3: \***
2389: 06b3: \***..........................................................................
2390: 06b3: 
2391: 06b3: 
2392: 06b3: INITIALISE.VARIABLES:
2393: 06b3: 
2394: 06b3:     ADXSERVE.DATA$ = "INITIALISE.VARIABLES"                            ! DCS
2395: 06c0:     GOSUB DISPLAY.MESSAGE                                              ! DCS
2396: 06ca: 
2397: 06ca:     PROGRAM$           EQ "MINPRINT"
2398: 06d7:     MODULE$            EQ "00"
2399: 06e4:     MODULE.NUMBER$     EQ  PROGRAM$ + MODULE$
2400: 0702:     BATCH.SCREEN.FLAG$ EQ "B" ! Batch
2401: 0711: 
2402: 0711:     FALSE = 0                                                          ! OAS
2403: 0719:     TRUE  = -1                                                         ! OAS
2404: 0721: 
2405: 0721:     YESTERDAY$ = "      "                                              ! RTT
2406: 072e: 
2407: 072e:     CLILF.BKUP.STATUS$ = "X"                                           ! OAS
2408: 073b:     CLOLF.BKUP.STATUS$ = "X"                                           ! OAS
2409: 0748:     MINLS.HK.STATUS$   = "E"                                           ! OAS
2410: 0755: 
2411: 0755: RETURN
2412: 075d: 
2413: 075d: !!!**************************************************************************
2414: 075d: !!!**************************************************************************
2415: 075d: !!!
2416: 075d: !!!   CALL.MINRFCNT
2417: 075d: !!!
2418: 075d: !!!   Call MINRFCNT module to write information to report file.
2419: 075d: !!!
2420: 075d: !!!**************************************************************************
2421: 075d: 
2422: 075d: CALL.MINRFCNT:
2423: 075d: 
2424: 075d:    CALL MINRFCNT
2425: 0762: 
2426: 0762: RETURN
2427: 076a: 
2428: 076a: \*****************************************************************************
2429: 076a: \***
2430: 076a: \***    ALLOCATE.SESSION.NUMBERS
2431: 076a: \***    Perform CALL.F20.SESS.NUM.UTILITY to allocate file session numbers
2432: 076a: \***    for all files referenced by the program.
2433: 076a: \***
2434: 076a: \***..........................................................................
2435: 076a: 
2436: 076a: 
2437: 076a: ALLOCATE.SESSION.NUMBERS:
2438: 076a: 
2439: 076a:     ADXSERVE.DATA$ = "ALLOCATE.SESSION.NUMBERS"                        ! DCS
2440: 0777:     GOSUB DISPLAY.MESSAGE                                              ! DCS
2441: 0781: 
2442: 0781:     CALL RPRPT.SET
2443: 0794:     CALL PRINT.SET
2444: 0799:     CALL SOFTS.SET                                                     ! CNS
2445: 07ac:     CALL RFSCF.SET                                                     ! CNS
2446: 07bf:     CALL CLOLF.SET                                                     ! CNS
2447: 07d2:     CALL CLILF.SET                                                     ! CNS
2448: 07e5:     !CALL ISF.SET                                                      ! CNS ! OAS
2449: 07e5:     !CALL IRF.SET                                                      ! CNS ! OAS
2450: 07e5:     CALL IDF.SET                                                       ! CNS
2451: 07f8:     CALL PGF.SET                                                       ! KMG
2452: 07fd:     CALL MINLS.SET                                                     ! LJT
2453: 0802:     CALL SRITL.SET                                                     ! OAS
2454: 0815: 
2455: 0815:     FUNCTION.FLAG$ EQ "O"
2456: 0822: 
2457: 0822:     PASSED.INTEGER% EQ RPRPT.REPORT.NUM%
2458: 082c:     PASSED.STRING$ EQ RPRPT.FILE.NAME$
2459: 0840:     GOSUB CALL.F20.SESS.NUM.UTILITY
2460: 084a:     RPRPT.SESS.NUM% EQ F20.INTEGER.FILE.NO%
2461: 0858: 
2462: 0858:     PASSED.INTEGER% = PRINT.REPORT.NUM%
2463: 0862:     PASSED.STRING$ = PRINT.FILE.NAME$
2464: 0876:     GOSUB CALL.F20.SESS.NUM.UTILITY
2465: 0880:     PRINT.SESS.NUM% = F20.INTEGER.FILE.NO%
2466: 088e: 
2467: 088e:     PASSED.INTEGER% EQ SOFTS.REPORT.NUM%                               ! CNS
2468: 0898:     PASSED.STRING$ EQ SOFTS.FILE.NAME$                                 ! CNS
2469: 08ac:     GOSUB CALL.F20.SESS.NUM.UTILITY                                    ! CNS
2470: 08b6:     SOFTS.SESS.NUM% EQ F20.INTEGER.FILE.NO%                            ! CNS
2471: 08c4: 
2472: 08c4:     PASSED.INTEGER% EQ RFSCF.REPORT.NUM%                               ! CNS
2473: 08ce:     PASSED.STRING$ EQ RFSCF.FILE.NAME$                                 ! CNS
2474: 08e2:     GOSUB CALL.F20.SESS.NUM.UTILITY                                    ! CNS
2475: 08ec:     RFSCF.SESS.NUM% EQ F20.INTEGER.FILE.NO%                            ! CNS
2476: 08fa: 
2477: 08fa:     PASSED.INTEGER% EQ CLOLF.REPORT.NUM%                               ! CNS
2478: 0904:     PASSED.STRING$ EQ CLOLF.FILE.NAME$                                 ! CNS
2479: 0918:     GOSUB CALL.F20.SESS.NUM.UTILITY                                    ! CNS
2480: 0922:     CLOLF.SESS.NUM% EQ F20.INTEGER.FILE.NO%                            ! CNS
2481: 0930: 
2482: 0930:     PASSED.INTEGER% EQ CLILF.REPORT.NUM%                               ! CNS
2483: 093a:     PASSED.STRING$ EQ CLILF.FILE.NAME$                                 ! CNS
2484: 094e:     GOSUB CALL.F20.SESS.NUM.UTILITY                                    ! CNS
2485: 0958:     CLILF.SESS.NUM% EQ F20.INTEGER.FILE.NO%                            ! CNS
2486: 0966: 
2487: 0966:     !Commenting the below as it is not required any more                     ! OAS
2488: 0966:     !PASSED.INTEGER% EQ ISF.REPORT.NUM%                                ! CNS ! OAS
2489: 0966:     !PASSED.STRING$ EQ ISF.FILE.NAME$                                  ! CNS ! OAS
2490: 0966:     !GOSUB CALL.F20.SESS.NUM.UTILITY                                   ! CNS ! OAS
2491: 0966:     !ISF.SESS.NUM% EQ F20.INTEGER.FILE.NO%                             ! CNS ! OAS
2492: 0966: 
2493: 0966:     !PASSED.INTEGER% EQ IRF.REPORT.NUM%                                ! CNS ! OAS
2494: 0966:     !PASSED.STRING$ EQ IRF.FILE.NAME$                                  ! CNS ! OAS
2495: 0966:     !GOSUB CALL.F20.SESS.NUM.UTILITY                                   ! CNS ! OAS
2496: 0966:     !IRF.SESS.NUM% EQ F20.INTEGER.FILE.NO%                             ! CNS ! OAS
2497: 0966: 
2498: 0966:     PASSED.INTEGER% EQ IDF.REPORT.NUM%                                 ! CNS
2499: 0970:     PASSED.STRING$ EQ IDF.FILE.NAME$                                   ! CNS
2500: 0984:     GOSUB CALL.F20.SESS.NUM.UTILITY                                    ! CNS
2501: 098e:     IDF.SESS.NUM% EQ F20.INTEGER.FILE.NO%                              ! CNS
2502: 099c: 
2503: 099c:     PASSED.INTEGER% EQ PGF.REPORT.NUM%                                 ! KMG
2504: 09a6:     PASSED.STRING$ EQ PGF.FILE.NAME$                                   ! KMG
2505: 09ba:     GOSUB CALL.F20.SESS.NUM.UTILITY                                    ! KMG
2506: 09c4:     PGF.SESS.NUM% EQ F20.INTEGER.FILE.NO%                              ! KMG
2507: 09d2: 
2508: 09d2:     PASSED.INTEGER% EQ MINLS.REPORT.NUM%                               ! LJT
2509: 09dc:     PASSED.STRING$ EQ MINLS.FILE.NAME$                                 ! LJT
2510: 09f0:     GOSUB CALL.F20.SESS.NUM.UTILITY                                    ! LJT
2511: 09fa:     MINLS.SESS.NUM% EQ F20.INTEGER.FILE.NO%                            ! LJT
2512: 0a08: 
2513: 0a08:     PASSED.INTEGER% = SRITL.REPORT.NUM%                                ! OAS
2514: 0a12:     PASSED.STRING$ = SRITL.FILE.NAME$                                  ! OAS
2515: 0a26:     GOSUB CALL.F20.SESS.NUM.UTILITY                                    ! OAS
2516: 0a30:     SRITL.SESS.NUM% = F20.INTEGER.FILE.NO%                             ! OAS
2517: 0a3e: 
2518: 0a3e:     ADXSERVE.DATA$ = "Session numbers allocated "                      ! DCS
2519: 0a4b:     GOSUB DISPLAY.MESSAGE                                              ! DCS
2520: 0a55: 
2521: 0a55: RETURN
2522: 0a5d: 
2523: 0a5d: \*****************************************************************************
2524: 0a5d: \***
2525: 0a5d: \***    CREATE.MINOK.FILE
2526: 0a5d: \***    Allocating Session number for MINOK file
2527: 0a5d: \***    Creating MINOK File
2528: 0a5d: \***    Writing initial values to the file
2529: 0a5d: \***
2530: 0a5d: \***..........................................................................
2531: 0a5d: 
2532: 0a5d: CREATE.MINOK.FILE:                                                     ! OAS
2533: 0a5d: 
2534: 0a5d:     ADXSERVE.DATA$ = "Creating MINOK File"                             ! OAS
2535: 0a6a:     GOSUB DISPLAY.MESSAGE                                              ! OAS
2536: 0a74: 
2537: 0a74:     !Initialised a temporary report number for MINOK file              ! OAS
2538: 0a74:     MINOK.REPORT.NUM% = 450                                            ! OAS
2539: 0a7a:     MINOK.FILE.NAME$ = "D:/ADX_UDT1/MINOK.BIN"                         ! OAS
2540: 0a87: 
2541: 0a87:     FUNCTION.FLAG$ EQ "O"                                              ! OAS
2542: 0a94: 
2543: 0a94:     PASSED.INTEGER% = MINOK.REPORT.NUM%                                ! OAS
2544: 0a9a:     PASSED.STRING$ = MINOK.FILE.NAME$                                  ! OAS
2545: 0aab:     GOSUB CALL.F20.SESS.NUM.UTILITY                                    ! OAS
2546: 0ab5:     MINOK.SESS.NUM% = F20.INTEGER.FILE.NO%                             ! OAS
2547: 0abf: 
2548: 0abf:     FUNCTION.FLAG$ EQ "C"                                              ! OAS
2549: 0acc: 
2550: 0acc:     CURRENT.SESS.NUM% = MINOK.SESS.NUM%                                ! OAS
2551: 0ad6: !    IF END #MINOK.SESS.NUM% THEN FILE.ERROR.EXIT                       ! OAS
2552: 0ad6: 
2553: 0ad6:     IF END #MINOK.SESS.NUM% THEN NO.PREV.RUN.DETAILS                   ! RTT
2554: 0ae7:     OPEN MINOK.FILE.NAME$ AS MINOK.SESS.NUM%                           ! RTT
2555: 0b00: 
2556: 0b00:     IF END #MINOK.SESS.NUM% THEN NO.PREV.RUN.DETAILS                   ! RTT
2557: 0b11:     READ FORM "C1,C8,C6,4C1,C62"; #MINOK.SESS.NUM%;                    \ RTT
2558: 0b6f:         QUOTES$,                                                       \ RTT
2559: 0b6f:         MINOK.RUN.DATE$,                                               \ RTT
2560: 0b6f:         MINOK.RUN.TIME$,                                               \ RTT
2561: 0b6f:         REPORTING.STATUS$,                                             \ RTT
2562: 0b6f:         CLILF.BKUP.STATUS$,                                            \ RTT
2563: 0b6f:         CLOLF.BKUP.STATUS$,                                            \ RTT
2564: 0b6f:         MINLS.HK.STATUS$,                                              \ RTT
2565: 0b6f:         MINOK.FILLER$                                                  ! RTT
2566: 0b6f: 
2567: 0b6f:     GOTO PROCESS.MINOK.RECORD                                          ! RTT
2568: 0b71: 
2569: 0b71: NO.PREV.RUN.DETAILS:                                                   ! RTT
2570: 0b71: 
2571: 0b71: PROCESS.MINOK.RECORD:                                                  ! RTT
2572: 0b71: 
2573: 0b71:     F02.DATE$ = DATE$                                                  ! RTT
2574: 0b81:     RC% = UPDATE.DATE(-1)                                              ! RTT
2575: 0b94:     YESTERDAY$ = F02.DATE$                                             ! RTT
2576: 0ba8: 
2577: 0ba8:     IF TIME$ > "120000" THEN BEGIN                                     ! RTT
2578: 0bc6:        CURR.RUN.DAY$ = DATE$ + "120000"                                ! RTT
2579: 0be8:     ENDIF ELSE BEGIN                                                   ! RTT
2580: 0be8:        CURR.RUN.DAY$ = YESTERDAY$ + "120000"                           ! RTT
2581: 0c00:     ENDIF                                                              ! RTT
2582: 0c00: 
2583: 0c00:     MINOK.TIME.STAMP$ = RIGHT$(MINOK.RUN.DATE$,6) + MINOK.RUN.TIME$    ! RTT
2584: 0c2e: 
2585: 0c2e:     IF MINOK.TIME.STAMP$ > CURR.RUN.DAY$ THEN BEGIN                    ! RTT
2586: 0c45:        MINPRINT.ALREADY.RUN% = -1                                      ! RTT
2587: 0c4a:     ENDIF                                                              ! RTT
2588: 0c4a: 
2589: 0c4a:     IF NOT MINPRINT.ALREADY.RUN% THEN BEGIN                            ! RTT
2590: 0c54:         MINOK.RUN.DATE$ = "20" + DATE$                                 ! RTT
2591: 0c69:         MINOK.RUN.TIME$ = TIME$                                        ! RTT
2592: 0c77:         CLOSE MINOK.SESS.NUM%                                          ! RTT
2593: 0c80:         CREATE MINOK.FILE.NAME$ AS MINOK.SESS.NUM%                     ! OAS
2594: 0c99: 
2595: 0c99: !        MINOK.RECORD$ = ("20" + DATE$) +               \               ! OAS ! RTT
2596: 0c99: !                        TIME$ +                        \               ! OAS ! RTT
2597: 0c99: !                        "XXXX" +                       \               ! OAS ! RTT
2598: 0c99: !                        STRING$(62, " ")                               ! OAS ! RTT
2599: 0c99: 
2600: 0c99:         MINOK.RECORD$ = MINOK.RUN.DATE$ +               \              ! RTT
2601: 0cc4:                         MINOK.RUN.TIME$ +               \              ! RTT
2602: 0cc4:                         "XXXX" +                        \              ! RTT
2603: 0cc4:                         STRING$(62, " ")                               ! RTT
2604: 0cc4: 
2605: 0cc4:         WRITE #MINOK.SESS.NUM%; MINOK.RECORD$                          ! OAS
2606: 0cdc:     ENDIF                                                              ! RTT
2607: 0cdc: 
2608: 0cdc:     CLOSE MINOK.SESS.NUM%                                              ! OAS
2609: 0ce5: 
2610: 0ce5: RETURN                                                                 ! OAS
2611: 0ced: 
2612: 0ced: \*****************************************************************************
2613: 0ced: \***
2614: 0ced: \***    GET.SOFTS
2615: 0ced: \***
2616: 0ced: \***..........................................................................
2617: 0ced: 
2618: 0ced: GET.SOFTS:                                                             ! CNS
2619: 0ced: 
2620: 0ced:     ADXSERVE.DATA$ = "GET.SOFTS"                                       ! DCS
2621: 0cfa:     GOSUB DISPLAY.MESSAGE                                              ! DCS
2622: 0d04: 
2623: 0d04:     FILE.OPERATION$ = "O"                                              ! CNS
2624: 0d13:     CURRENT.REPORT.NUM% = SOFTS.REPORT.NUM%                            ! CNS
2625: 0d21: 
2626: 0d21:     CURRENT.SESS.NUM% = SOFTS.SESS.NUM%                                ! CNS
2627: 0d2f:     IF END # SOFTS.SESS.NUM% THEN FILE.ERROR.EXIT                      ! CNS
2628: 0d43:     OPEN SOFTS.FILE.NAME$ DIRECT RECL SOFTS.RECL% \                      CNS
2629: 0d68:       AS SOFTS.SESS.NUM% NOWRITE NODEL                                 ! CNS
2630: 0d68: 
2631: 0d68:     FILE.SIZE% = SIZE(SOFTS.FILE.NAME$)                                ! CNS
2632: 0d85: 
2633: 0d85:     IF FILE.SIZE% = 0 \ ! File is empty                                  CNS
2634: 0dc3:        OR MOD(FILE.SIZE%,SOFTS.RECL%) <> 0 THEN \ ! File is corrupt      CNS
2635: 0dc3:        BEGIN                                                           ! CNS
2636: 0dc3:           ADXSERVE.DATA$ = "SOFTS file is corrupted"                   ! DCS
2637: 0dd0:           GOSUB DISPLAY.MESSAGE                                        ! DCS
2638: 0dda:           FILE.OPERATION$ = "S"                                        ! CNS
2639: 0de9:           GOTO FILE.ERROR.EXIT                                         ! CNS
2640: 0dec:        ENDIF                                                           ! CNS
2641: 0dec: 
2642: 0dec:     SOFTS.REC.NUM% = FILE.SIZE% / SOFTS.RECL%                          ! CNS
2643: 0e05: 
2644: 0e05:     SOFTS.RECORD$ = ""                                                 ! CNS
2645: 0e14: 
2646: 0e14:     IF SOFTS.REC.NUM% >= 20 THEN BEGIN                                 ! CNS
2647: 0e29:        SOFTS.REC.NUM% = 20                                             ! CNS
2648: 0e38:        RC% = READ.SOFTS                                                ! CNS
2649: 0e40:     ENDIF                                                              ! CNS
2650: 0e40: 
2651: 0e40:     CLOSE SOFTS.SESS.NUM%                                              ! CNS
2652: 0e4c: 
2653: 0e4c: RETURN                                                                 ! CNS
2654: 0e54: 
2655: 0e54: \*****************************************************************************
2656: 0e54: \***
2657: 0e54: \***    BACKUP OF CLILF AND CLOLF FILES AT EOD
2658: 0e54: \***
2659: 0e54: \***..........................................................................
2660: 0e54: 
2661: 0e54: BACKUP.CLILF.CLOLF.FILES:                                              ! OAS
2662: 0e54: 
2663: 0e54: !   GET.DATE$ = DATE$                                                  ! OAS ! PBT
2664: 0e54: 
2665: 0e54:     F02.DATE$ = DATE$                                                  ! PBT
2666: 0e64:     TIME.NOW$ = TIME$                                                  ! PBT
2667: 0e72:     IF TIME.NOW$ < "040000" THEN BEGIN                                 ! PBT
2668: 0e85:         !If it comes here, we need to set yesterday as the backup file ! PBT
2669: 0e85:         !extnesion.                                                    ! PBT
2670: 0e85:         CALL UPDATE.DATE(-1) !FO2.DATE$ = FO2.DATE$ - 1Day             ! PBT
2671: 0e95:     ENDIF                                                              ! PBT
2672: 0e95: 
2673: 0e95:     !Getting day using PSDATE FN                                       ! PBT
2674: 0e95: !   CALL PSDATE(GET.DATE$)                                             ! OAS ! OBT
2675: 0e95:     CALL PSDATE(F02.DATE$)                                             ! OBT
2676: 0ea8:     GET.DAY$ = F13.DAY$                                                ! OAS
2677: 0ebc: 
2678: 0ebc:     !First MINPRINT will backup CLILF.BIN. If CLILF backup is          ! OAS
2679: 0ebc:     !successful, then it will backup CLOLF.BIN                         ! OAS
2680: 0ebc: 
2681: 0ebc:     !Taking backup of CLILF.BIN                                        ! OAS
2682: 0ebc:     ADXSERVE.DATA$ = "Taking backup of CLILF.BIN"                      ! OAS
2683: 0ec9:     GOSUB DISPLAY.MESSAGE                                              ! OAS
2684: 0ed3: 
2685: 0ed3:     CLILF.DDD$ = "D:\ADX_UDT1\CLILF." + GET.DAY$                       ! OAS
2686: 0eeb:     CALL ADXCOPYF(ADXCOPY.CHK%,"D:\ADX_UDT1\CLILF.BIN",      \         ! OAS
2687: 0f38:                                       CLILF.DDD$,0,1,0)                ! OAS
2688: 0f38: 
2689: 0f38:    !Checking whether backup is created or not while using ADXCOPY FN   ! OAS
2690: 0f38:     IF ADXCOPY.CHK% = 0 THEN BEGIN                                     ! OAS
2691: 0f4e: 
2692: 0f4e:         ADXSERVE.DATA$ = "Backup of CLILF.BIN was completed successfully"    ! OAS
2693: 0f5b:         GOSUB DISPLAY.MESSAGE                                          ! OAS
2694: 0f65: 
2695: 0f65:         CLILF.BKUP.STATUS$ = "E"                                       ! OAS
2696: 0f72: 
2697: 0f72:         !Taking backup of CL0LF.BIN                                    ! OAS
2698: 0f72:         ADXSERVE.DATA$ = "Taking backup of CLOLF.BIN"                  ! OAS
2699: 0f7f:         GOSUB DISPLAY.MESSAGE                                          ! OAS
2700: 0f89: 
2701: 0f89:         CLOLF.DDD$ = "D:\ADX_UDT1\CLOLF." + GET.DAY$                   ! OAS
2702: 0fa1:         CALL ADXCOPYF(ADXCOPY.CHK%,"D:\ADX_UDT1\CLOLF.BIN",  \         ! OAS
2703: 0fee:                                           CLOLF.DDD$,0,1,0)            ! OAS
2704: 0fee: 
2705: 0fee:         !Checking whether backup is created using ADXCOPY FN           ! OAS
2706: 0fee:         IF ADXCOPY.CHK% = 0 THEN BEGIN                                 ! OAS
2707: 1001: 
2708: 1001:            ADXSERVE.DATA$ = "Backup of CLOLF.BIN was completed successfully" ! OAS
2709: 100e:            GOSUB DISPLAY.MESSAGE                                       ! OAS
2710: 1018:            CLOLF.BKUP.STATUS$ = "E"                                    ! OAS
2711: 1027: 
2712: 1027:         ENDIF ELSE BEGIN                                               ! OAS
2713: 1027: 
2714: 1027:            ADXSERVE.DATA$ = "*****ERROR: Could not backup CLOLF.BIN*****"    ! OAS
2715: 1034:            GOSUB DISPLAY.MESSAGE                                       ! OAS
2716: 103e: 
2717: 103e:         ENDIF                                                          ! OAS
2718: 1040: 
2719: 1040:     ENDIF ELSE BEGIN                                                   ! OAS
2720: 1040: 
2721: 1040:        ADXSERVE.DATA$ = "*****ERROR: Could not backup CLILF.BIN  *****"! OAS
2722: 104d:        GOSUB DISPLAY.MESSAGE                                           ! OAS
2723: 1057: 
2724: 1057:        ADXSERVE.DATA$ = "*****ERROR: So CLOLF.BIN backup not done*****"! OAS
2725: 1064:        GOSUB DISPLAY.MESSAGE                                           ! OAS
2726: 106e: 
2727: 106e:     ENDIF                                                              ! OAS
2728: 106e: 
2729: 106e: RETURN                                                                 ! OAS
2730: 1076: 
2731: 1076: \*****************************************************************************
2732: 1076: \***
2733: 1076: \***    RF PROCESS
2734: 1076: \***
2735: 1076: \***    Open RFSCF
2736: 1076: \***    Read RFSCF
2737: 1076: \***    Create CLILF & CLOLF
2738: 1076: \***    Read through RPRPT and extract required information
2739: 1076: \***    Write to CLILF & CLOLF files
2740: 1076: \***..........................................................................
2741: 1076: 
2742: 1076: RF.PROCESS:                                                            ! CNS
2743: 1076: 
2744: 1076:       ADXSERVE.DATA$ = "RF.PROCESS"                                    ! DCS
2745: 1083:       GOSUB DISPLAY.MESSAGE                                            ! DCS
2746: 108d: 
2747: 108d:       GOSUB PROCESS.RFSCF                                              ! LJT
2748: 1097: 
2749: 1097:       FILE.OPERATION$ = "O"                                            ! CNS
2750: 10a6: 
2751: 10a6:       IF RC% = 1 THEN BEGIN                                            ! CNS
2752: 10ad:          DO.MAIN = 1                                                   ! CNS
2753: 10b2:          GOTO END.RF.PROCESS                                           ! CNS
2754: 10b5:       ENDIF                                                            ! CNS
2755: 10b5: 
2756: 10b5:       ADXSERVE.DATA$ = "Create CLILF file"                             ! DCS
2757: 10c2:       GOSUB DISPLAY.MESSAGE                                            ! DCS
2758: 10cc:       CURRENT.SESS.NUM% = CLILF.SESS.NUM%                              ! CNS
2759: 10da:       IF END# CLILF.SESS.NUM% THEN CREATE.ERROR                        ! CNS
2760: 10ee:       CREATE POSFILE CLILF.FILE.NAME$ KEYED 6,,,10000 RECL CLILF.RECL% \ FCS
2761: 111d:              AS CLILF.SESS.NUM% MIRRORED PERUPDATE                     ! CNS
2762: 111d: 
2763: 111d:       ADXSERVE.DATA$ = "Create CLOLF file"                             ! DCS
2764: 112a:       GOSUB DISPLAY.MESSAGE                                            ! DCS
2765: 1134:       CURRENT.SESS.NUM% = CLOLF.SESS.NUM%                              ! CNS
2766: 1142:       IF END# CLOLF.SESS.NUM% THEN CREATE.ERROR                        ! CNS
2767: 1156:       CREATE POSFILE CLOLF.FILE.NAME$ DIRECT 0 RECL CLOLF.RECL%        \ MJT
2768: 1181:              AS CLOLF.SESS.NUM% MIRRORED ATCLOSE                       ! CNS
2769: 1181: 
2770: 1181:       !Commenting the below section as it not required anymore
2771: 1181:       !ADXSERVE.DATA$ = "Open ISF file"                                ! DCS !OAS
2772: 1181:       !GOSUB DISPLAY.MESSAGE                                           ! DCS !OAS
2773: 1181:       !CURRENT.SESS.NUM% = ISF.SESS.NUM%                               ! CNS !OAS
2774: 1181:       !IF END #ISF.SESS.NUM% THEN FILE.ERROR.EXIT                      ! CNS !OAS
2775: 1181:       !OPEN ISF.FILE.NAME$ KEYED RECL ISF.RECL% AS ISF.SESS.NUM%       \ CNS !OAS
2776: 1181:       !   NOWRITE NODEL                                                ! CNS !OAS
2777: 1181: 
2778: 1181:       !ADXSERVE.DATA$ = "Open IRF file"                                ! DCS !OAS
2779: 1181:       !GOSUB DISPLAY.MESSAGE                                           ! DCS !OAS
2780: 1181:       !CURRENT.SESS.NUM% = IRF.SESS.NUM%                               ! CNS !OAS
2781: 1181:       !IF END #IRF.SESS.NUM% THEN FILE.ERROR.EXIT                      ! CNS !OAS
2782: 1181:       !OPEN IRF.FILE.NAME$ KEYED RECL IRF.RECL% AS IRF.SESS.NUM%       \ CNS !OAS
2783: 1181:       !   NOWRITE NODEL                                                ! CNS !OAS
2784: 1181: 
2785: 1181:       ADXSERVE.DATA$ = "Open IDF file"                                 ! DCS
2786: 118e:       GOSUB DISPLAY.MESSAGE                                            ! DCS
2787: 1198:       CURRENT.SESS.NUM% = IDF.SESS.NUM%                                ! CNS
2788: 11a6:       IF END #IDF.SESS.NUM% THEN FILE.ERROR.EXIT                       ! CNS
2789: 11ba:       OPEN IDF.FILE.NAME$ KEYED RECL IDF.RECL% AS IDF.SESS.NUM%        \ CNS
2790: 11df:          NODEL                                                         ! CNS
2791: 11df: 
2792: 11df:       ADXSERVE.DATA$ = "Open RPRPT file"                               ! DCS
2793: 11ec:       GOSUB DISPLAY.MESSAGE                                            ! DCS
2794: 11f6:       CURRENT.SESS.NUM% = RPRPT.SESS.NUM%                              ! CNS
2795: 1205:       IF END # RPRPT.SESS.NUM% THEN FILE.ERROR.EXIT                    ! CNS
2796: 121b: 
2797: 121b:       OPEN RPRPT.FILE.NAME$ AS RPRPT.SESS.NUM%                         ! CNS
2798: 123c: 
2799: 123c:       IF END #RPRPT.SESS.NUM% THEN RPRPT.EOF                           ! CNS
2800: 1252: 
2801: 1252:       ADXSERVE.DATA$ = "Open PGF file"                                 ! KMG
2802: 125f:       GOSUB DISPLAY.MESSAGE                                            ! KMG
2803: 1269:       CURRENT.SESS.NUM% = PGF.SESS.NUM%                                ! KMG
2804: 1277:       IF END #PGF.SESS.NUM% THEN FILE.ERROR.EXIT                       ! KMG
2805: 128b:       OPEN PGF.FILE.NAME$ KEYED RECL PGF.RECL% AS PGF.SESS.NUM%        \ KMG
2806: 12b0:          NOWRITE NODEL                                                 ! KMG
2807: 12b0: 
2808: 12b0:       ADXSERVE.DATA$ = "Open MINLS file"                               ! LJT
2809: 12bd:       GOSUB DISPLAY.MESSAGE                                            ! LJT
2810: 12c7:       CURRENT.SESS.NUM% = MINLS.SESS.NUM%                              ! LJT
2811: 12d5:       IF END #MINLS.SESS.NUM% THEN FILE.ERROR.EXIT                     ! LJT
2812: 12e9:       OPEN MINLS.FILE.NAME$ KEYED RECL MINLS.RECL% AS MINLS.SESS.NUM%  ! LJT
2813: 130d: 
2814: 130d:       ADXSERVE.DATA$ = "Open SRITML file"                              ! OAS
2815: 131a:       GOSUB DISPLAY.MESSAGE                                            ! OAS
2816: 1324:       CURRENT.SESS.NUM% = SRITL.SESS.NUM%                              ! OAS
2817: 1332:       IF END #SRITL.SESS.NUM% THEN FILE.ERROR.EXIT                     ! OAS
2818: 1346:       OPEN SRITL.FILE.NAME$ KEYED RECL SRITL.RECL% AS SRITL.SESS.NUM%  \ OAS
2819: 136b:          NOWRITE NODEL
2820: 136b: 
2821: 136b:       ADXSERVE.DATA$ = "Set CLOLF/CLILF default values"                ! DCS
2822: 1378:       GOSUB DISPLAY.MESSAGE                                            ! DCS
2823: 1382:       EOF = 0                                                          ! CNS
2824: 1387: 
2825: 1387:      !OLD variables which are commented are put together,              ! OAS
2826: 1387:      !so that it can be taken out easily during the next release
2827: 1387:      !OLD.BULETT$ = " "                                                ! CNS ! OAS
2828: 1387:      !OLD.PGNAME$ = " "                                                ! ICC ! OAS
2829: 1387:      !CLOLF.CNTDATE$ = "19850101"                                      ! CNS ! OAS
2830: 1387:      !CLOLF.LISTID$ = "001"                                            ! CNS ! OAS
2831: 1387:      !CLOLF.HOLISTID$ = "0000"                                         ! CNS ! OAS
2832: 1387:      !CLOLF.OSSRITEMS$ = "000"                                         ! KMG ! OAS
2833: 1387:      !CLILF.BSCNT$ = "-001"                                            ! CNS ! OAS
2834: 1387:      !CLILF.SFCNT$ = "-001"                                            ! CNS ! OAS
2835: 1387:      !CLILF.SALESSFCNT$ = "0000"                                       ! CNS ! OAS
2836: 1387:      !CLILF.HO.SEQNO$   = "00"                                         ! FCS ! OAS
2837: 1387:      !CLILF.FILLER$ = "   "                                            ! CNS ! JMG
2838: 1387:      !CLILF.OSSR.ITMSTKCNT$ = "-001"                                   ! JMG ! OAS
2839: 1387:      !CLOLF.ACTIVE.STATUS$ = " "                                       ! CNS ! OAS
2840: 1387: 
2841: 1387:       LIST.ITEMS = 1                                                   ! CNS
2842: 138d:       CLOLF.LISTID$ = "001"                    !Set to one             !     ! OAS
2843: 139c:       CLOLF.USERID$ = "000"                    !Set to zero            ! KMG ! OAS
2844: 13ab:       CLOLF.LSTTYP$ = "R"                      !Recount List           ! CNS ! OAS
2845: 13ba:       CLOLF.BULETT$ = " "                      !Set to space           !     ! OAS
2846: 13c9:       CLOLF.LIST.NAME$ = "Recount List                  "              !     ! OAS
2847: 13d8:       CLOLF.PICKER.USER.ID$ = "000"            !Initialise to zero     !     ! OAS
2848: 13e7:       CLOLF.ACTIVE.STATUS$ = "I"               !Initial                !     ! OAS
2849: 13f6:       CLOLF.PILST.ID$ = "0000"                 !Set to zero            !     ! OAS
2850: 1405:       CLOLF.EXPIRY.DATE$ = PACK$("000000")     !Set to zero            !     ! OAS
2851: 1419:       CLOLF.PICK.START.TIME$ = PACK$("0000")   !Set to zero            !     ! OAS
2852: 142d:       CLOLF.PICK.END.TIME$ = PACK$("0000")     !Set to zero            !     ! OAS
2853: 1441:       CLOLF.CURRENT.LOCATION$ = " "            !Set to space           !     ! OAS
2854: 1450: 
2855: 1450:       CLOLF.RECORD.NUM% = 1         !REC position to write to CLOLF    ! CNS
2856: 145f: 
2857: 145f:       CLILF.HO.SEQNO$   = "00"                 !Set to zero            !     ! OAS
2858: 146e:       CLILF.COUNTED.STATUS$ = "U"              !Not Counted            !     ! OAS
2859: 147d:       CLILF.DATE.LASTCNT$ = PACK$("000000")    !Set to zero            !     ! OAS
2860: 1491:       CLILF.SALESCNT% = 0                      !Set to zero            !     ! OAS
2861: 149a:       CLILF.BSCNT% = -1                        !Set to -1              !     ! OAS
2862: 14a3:       CLILF.OSSR.ITMSTKCNT% = -1               !Set to -1              !     ! OAS
2863: 14ac:       CLILF.BS.PEND.SA.CNT% = -1               !Set to -1              !     ! OAS
2864: 14b5:       CLILF.OSSR.PEND.SA.CNT% = -1             !Set to -1              !     ! OAS
2865: 14be:       CLILF.SFCNT% = -1                        !Set to -1              !     ! OAS
2866: 14c7:       CLILF.SPACE$ = STRING$(16," ")                                   !     ! OAS
2867: 14dd: 
2868: 14dd:       ADXSERVE.DATA$ = "Start of Report File processing"               ! DCS
2869: 14ea:       GOSUB DISPLAY.MESSAGE                                            ! DCS
2870: 14f4: 
2871: 14f4:       WHILE NOT EOF                                                    ! CNS
2872: 14f7: 
2873: 14f7:          READ #RPRPT.SESS.NUM%; RPRPT.RECORD$                          ! CNS
2874: 1515: 
2875: 1515:         !CLOLF.BULETT$ = LEFT$(RPRPT.RECORD$,1)                        ! CNS ! OAS
2876: 1515:         !Getting the Business Center letter                            ! OAS
2877: 1515:         BSNS.CNTR$ = LEFT$(RPRPT.RECORD$,1)                            ! OAS
2878: 152f: 
2879: 152f:         !IF CLOLF.BULETT$ >= "A" AND CLOLF.BULETT$ <= "Z" THEN BEGIN   ! CNS ! OAS
2880: 152f: 
2881: 152f:         IF BSNS.CNTR$ >= "A" AND BSNS.CNTR$ <= "Z" THEN BEGIN
2882: 1576:            IF MID$(RPRPT.RECORD$,2,1) = " " THEN BEGIN                 ! CNS
2883: 15a3:               GOSUB EXTRACT.FIELDS                                     ! CNS
2884: 15ad:               !ISF.BOOTS.CODE$ = PACK$("0" + CLILF.BOOTSCODE$)         ! CNS ! OAS
2885: 15ad:               !ISF.S.E.DESC$ = "X "                                    ! HBG ! OAS
2886: 15ad:               !RC% = READ.ISF                                          ! CNS ! OAS
2887: 15ad: 
2888: 15ad:               !Removed the addition of "0" in CLILF.BOOTSCODE$ as      ! OAS
2889: 15ad:               !the new boots code contains 8 digits
2890: 15ad: 
2891: 15ad:               !MINLS.ITEM.CODE$ = PACK$("0" + CLILF.BOOTSCODE$)        ! LJT ! OAS
2892: 15ad:               MINLS.ITEM.CODE$ = PACK$(CLILF.BOOTSCODE$)               ! LJT ! OAS
2893: 15c8: 
2894: 15c8:               RC% = READ.MINLS                                         ! LJT
2895: 15d0: 
2896: 15d0:               IF RC% = 0 THEN BEGIN                                    ! LJT
2897: 15d8:                  IF DATE.LE(UNPACK$(MINLS.RECOUNT.DATE$),DATE$)        \ LJT
2898: 160a:                     THEN BEGIN                                         ! LJT
2899: 160a:                     F02.DATE$ = UNPACK$(MINLS.RECOUNT.DATE$)           ! LJT
2900: 1625:                     CALL UPDATE.DATE(RFSCF.RECOUNT.DAYS.RETAIN%)       ! LJT
2901: 1637: 
2902: 1637:                     IF DATE.LE(F02.DATE$, DATE$) THEN BEGIN            ! LJT
2903: 1659: 
2904: 1659:                        !Setting FILE.OPERATION$ flag to "D" for        ! OAS
2905: 1659:                        !catching any error while deleting the record   ! OAS
2906: 1659: 
2907: 1659:                        FILE.OPERATION$ = "D"                           ! OAS
2908: 1668:                        DELREC MINLS.SESS.NUM%; MINLS.ITEM.CODE$        ! LJT
2909: 167f:                        FILE.OPERATION$ = " "                           ! OAS
2910: 168e: 
2911: 168e:                        !Turn off PENDING COUNT flag on the IDF         ! LJT
2912: 168e:                        IDF.BOOTS.CODE$ = MINLS.ITEM.CODE$              ! LJT
2913: 16a4:                        RC% = READ.IDF                                  ! LJT
2914: 16ac:                        IF RC% = 0 THEN BEGIN                           ! LJT
2915: 16b1:                          !Make sure the flag is set to on first        ! LJT
2916: 16b1:                          IF (IDF.BIT.FLAGS.2% AND 00000100b) <> 0      \ LJT
2917: 16be:                              THEN BEGIN                                ! LJT
2918: 16be:                              !It's on, so turn it off                  ! LJT
2919: 16be:                              IDF.BIT.FLAGS.2% = (IDF.BIT.FLAGS.2% XOR 4)!LJT
2920: 16ce:                              RC% = WRITE.IDF                           ! LJT
2921: 16d6:                          ENDIF                                         ! LJT
2922: 16d6:                       ENDIF                                            ! LJT
2923: 16d8:                     ENDIF ELSE BEGIN                                   ! LJT
2924: 16d8:                        GOSUB VALID.ITEM                                ! CNS
2925: 16e2:                     ENDIF                                              ! LJT
2926: 16e2:                  ENDIF                                                 ! LJT
2927: 16e2:               ENDIF                                                    ! LJT
2928: 16e2:            ENDIF                                                       ! CNS
2929: 16e2:         ENDIF                                                          ! OAS
2930: 16e2:         !ELSE BEGIN                                                    ! CNS ! OAS
2931: 16e2:         !   IF CLOLF.BULETT$ = "*" THEN BEGIN                          ! CNS ! OAS
2932: 16e2:         !      UPDATE.DATE$ = MID$(RPRPT.RECORD$,41,2)                 ! CNS ! OAS
2933: 16e2:         !      IF VAL(UPDATE.DATE$) > 85 THEN BEGIN                    ! CNS ! OAS
2934: 16e2:         !         UPDATE.DATE$ = "19" + UPDATE.DATE$                   ! CNS ! OAS
2935: 16e2:         !      ENDIF ELSE BEGIN                                        ! CNS ! OAS
2936: 16e2:         !         UPDATE.DATE$ = "20" + UPDATE.DATE$                   ! CNS ! OAS
2937: 16e2:         !      ENDIF                                                   ! CNS ! OAS
2938: 16e2:         !      CLOLF.CNTDATE$ = UPDATE.DATE$ +                         \ CNS ! OAS
2939: 16e2:         !                       MID$(RPRPT.RECORD$,38,2) +             \ CNS ! OAS
2940: 16e2:         !                       MID$(RPRPT.RECORD$,35,2)               ! CNS ! OAS
2941: 16e2:         !   ENDIF                                                      ! CNS ! OAS
2942: 16e2:         !ENDIF                                                         ! CNS ! OAS
2943: 16e2: 
2944: 16e2: 
2945: 16e2: RPRPT.EOF.RETURN:                                                      ! CNS
2946: 16e2: 
2947: 16e2:       WEND                                                             ! CNS
2948: 16ec: 
2949: 16ec:       ADXSERVE.DATA$ = "End of Report File processing"                 ! DCS
2950: 16f9:       GOSUB DISPLAY.MESSAGE                                            ! DCS
2951: 1703: 
2952: 1703:       !GOSUB CREATE.NEW.LIST                                           ! CNS ! OAS
2953: 1703:       GOSUB CREATE.RECOUNT.LIST                                        ! OAS
2954: 170d: 
2955: 170d:       ADXSERVE.DATA$ = "Closing Files"                                 ! DCS
2956: 171a:       GOSUB DISPLAY.MESSAGE                                            ! DCS
2957: 1724: 
2958: 1724:       CLOSE RPRPT.SESS.NUM%                                            ! CNS
2959: 1732:       CLOSE CLILF.SESS.NUM%                                            ! CNS
2960: 173e:       CLOSE CLOLF.SESS.NUM%                                            ! CNS
2961: 174a:       !CLOSE ISF.SESS.NUM%                                             ! CNS ! OAS
2962: 174a:       !CLOSE IRF.SESS.NUM%                                             ! CNS ! OAS
2963: 174a:       CLOSE IDF.SESS.NUM%                                              ! CNS
2964: 1756:       CLOSE MINLS.SESS.NUM%                                            ! LJT
2965: 1762:       CLOSE SRITL.SESS.NUM%                                            ! OAS
2966: 176e:       ADXSERVE.DATA$ = "Files Closed"                                  ! DCS
2967: 177b:       GOSUB DISPLAY.MESSAGE                                            ! DCS
2968: 1785: 
2969: 1785: END.RF.PROCESS:                                                        ! CNS
2970: 1785: 
2971: 1785: 
2972: 1785: RETURN                                                                 ! CNS
2973: 178d: 
2974: 178d: RPRPT.EOF:                                                             ! CNS
2975: 178d: 
2976: 178d:        EOF = 1                                                         ! CNS
2977: 1792:        GOTO RPRPT.EOF.RETURN                                           ! CNS
2978: 1795: 
2979: 1795: 
2980: 1795: RFSCF.OPEN.ERROR:                                                      ! CNS
2981: 1795: 
2982: 1795:        DO.MAIN = 1                                                     ! CNS
2983: 179a:        GOTO END.RF.PROCESS                                             ! CNS
2984: 179c: 
2985: 179c: \*****************************************************************************
2986: 179c: \***
2987: 179c: \***   PROCESS.RFSCF
2988: 179c: \***
2989: 179c: \***   This code was originally in RF.PROCESS, I've moved it into a subroutine
2990: 179c: \***   so that it can also be used if RF is inactive.
2991: 179c: \***
2992: 179c: \*****************************************************************************
2993: 179c: 
2994: 179c:       PROCESS.RFSCF:
2995: 179c: 
2996: 179c:       FILE.OPERATION$ = "O"                                            ! CNS
2997: 17ab: 
2998: 17ab:       ADXSERVE.DATA$ = "Open/Read/Close RFSCF file"                    ! DCS
2999: 17b8:       GOSUB DISPLAY.MESSAGE                                            ! DCS
3000: 17c2: 
3001: 17c2:       IF END #RFSCF.SESS.NUM% THEN RFSCF.OPEN.ERROR                    ! CNS
3002: 17d6:       CURRENT.SESS.NUM% = RFSCF.SESS.NUM%
3003: 17e4:       OPEN RFSCF.FILE.NAME$ DIRECT RECL RFSCF.RECL% AS RFSCF.SESS.NUM% \ DCS
3004: 1809:             NOWRITE NODEL                                              ! DCS
3005: 1809:       RC% = READ.RFSCF1                                                ! CNS
3006: 1811: 
3007: 1811:       CLOSE RFSCF.SESS.NUM%                                            ! CNS
3008: 181d: 
3009: 181d:       RETURN
3010: 1825: 
3011: 1825: \*****************************************************************************
3012: 1825: \***
3013: 1825: \***   EXTRACT FIELDS
3014: 1825: \***
3015: 1825: \*****************************************************************************
3016: 1825: EXTRACT.FIELDS:                                                        ! CNS
3017: 1825: 
3018: 1825:       !Below statements are commented out, since these are             ! OAS
3019: 1825:       !not present in the updated CLOLF file format                    ! OAS
3020: 1825:       !CLOLF.BUNAME$ = MID$(RPRPT.RECORD$,3,15)                        ! CNS ! OAS
3021: 1825:       !CLILF.PRODGRP$ = MID$(RPRPT.RECORD$,19,2) + "0" +               \ CNS ! OAS
3022: 1825:       !                 MID$(RPRPT.RECORD$,22,3)                       ! CNS ! OAS
3023: 1825:       !CLILF.PRODGRPDESC$ = MID$(RPRPT.RECORD$,28,12)                  ! CNS ! OAS
3024: 1825: 
3025: 1825:       !Adding zero to CLILF.BOOTSCODE$ to make it to 8 digit item code ! OAS
3026: 1825: 
3027: 1825:       CLILF.BOOTSCODE$ = "0" + MID$(RPRPT.RECORD$,48,2) +              \ CNS ! OAS
3028: 1880:                          MID$(RPRPT.RECORD$,51,2) +                    \ CNS ! OAS
3029: 1880:                          MID$(RPRPT.RECORD$,54,3)                      ! CNS ! OAS
3030: 1880: 
3031: 1880: RETURN                                                                 ! CNS
3032: 1888: 
3033: 1888: \*****************************************************************************
3034: 1888: \***
3035: 1888: \***   VALID ITEM
3036: 1888: \***
3037: 1888: \***   Extract information from IDF and IRF and write to CLILF
3038: 1888: \***
3039: 1888: \*****************************************************************************
3040: 1888: VALID.ITEM:
3041: 1888: 
3042: 1888:        !The subroutine has undergone many changes as part of SFA project     ! OAS
3043: 1888: 
3044: 1888:        !CLOLF.PGNAME$ = CLILF.PRODGRPDESC$+"   "                       ! ICC ! OAS
3045: 1888:        !IF CLOLF.PGNAME$<> OLD.PGNAME$ OR LIST.ITEMS > 30 THEN BEGIN   ! ICC ! OAS
3046: 1888: 
3047: 1888:        !The below IF condition is changed to restrict the                    ! OAS
3048: 1888:        !list size to maximum of 999 records.                                 ! OAS
3049: 1888:        !IF LIST.ITEMS > 30 THEN BEGIN                                        ! OAS
3050: 1888:         IF LIST.ITEMS > 999 THEN BEGIN                                       ! OAS
3051: 1890:            GOSUB CREATE.RECOUNT.LIST                                   ! CNS ! OAS
3052: 189a:         ENDIF                                                          ! CNS ! OAS
3053: 189a: 
3054: 189a:        !CLILF.HO.SEQNO$ = RIGHT$(CLILF.ITEMSEQ$,2)                     ! 1.12 RC ! OAS
3055: 189a:        !CLILF.DEALMKR$ = "N"                                           ! CNS ! OAS
3056: 189a:        !CLILF.BARCODE$= RIGHT$("000000000000" + \
3057: 189a:        !                LEFT$(UNPACK$(IDF.BOOTS.CODE$),7),13)          ! FCS ! OAS
3058: 189a:        !CALL CALC.BAR.CODE.CHECK.DIGIT(RIGHT$(CLILF.BARCODE$,12))      ! FCS ! OAS
3059: 189a:        !CLILF.BARCODE$ = RIGHT$(CLILF.BARCODE$,12) + F06.CHECK.DIGIT$  ! FCS ! OAS
3060: 189a: 
3061: 189a:        CLILF.LISTID$ = CLOLF.LISTID$                                   ! CNS
3062: 18b0:        CLILF.ITEMSEQ$  = RIGHT$("000" + STR$(LIST.ITEMS),3)            ! CNS
3063: 18ee: 
3064: 18ee:        !IDF.BOOTS.CODE$ = ISF.BOOTS.CODE$                              ! CNS ! OAS
3065: 18ee:        !IDF.STNDRD.DESC$ = "UNKNOWN ITEM"                              ! FCS ! OAS
3066: 18ee: 
3067: 18ee:        !CLILF.DEALMKR is not present in the updated CLILF format.            ! OAS
3068: 18ee:        !As CLILF.DEALMKR is not needed, the below code section is            ! OAS
3069: 18ee:        !not required and hence commented                                     ! OAS
3070: 18ee: 
3071: 18ee:        !IRF.BAR.CODE$ = PACK$("000000000000000" + \
3072: 18ee:        !                LEFT$(UNPACK$(IDF.BOOTS.CODE$),7))             ! FCS ! OAS
3073: 18ee:        !RC% = READ.IDF                                                 ! CNS ! OAS
3074: 18ee: 
3075: 18ee:        !IF RC% = 0 THEN BEGIN
3076: 18ee:          !CHECK TO SEE IF IDF HAS VALID EAN BARCODE TO REPLACE BTC BARCODE        ! FCS ! OAS
3077: 18ee:          !IF IDF.FIRST.BAR.CODE$ <> PACK$("0000000000000000000000") THEN BEGIN    ! FCS ! OAS
3078: 18ee:             !IF VAL(UNPACK$(IDF.NO.OF.BAR.CODES$)) > 1   \                        ! FCS ! OAS
3079: 18ee:                !AND  (IDF.SECOND.BAR.CODE$ <> IRF.BAR.CODE$)  THEN BEGIN          ! FCS ! OAS
3080: 18ee: 
3081: 18ee:                !CALL CALC.BAR.CODE.CHECK.DIGIT(UNPACK$(IDF.SECOND.BAR.CODE$))     ! FCS ! OAS
3082: 18ee: 
3083: 18ee:                !CLILF.BARCODE$ = RIGHT$(UNPACK$(IDF.SECOND.BAR.CODE$) +  \        ! FCS ! OAS
3084: 18ee:                !     F06.CHECK.DIGIT$,13)                                         ! FCS ! OAS
3085: 18ee:                !IRF.BAR.CODE$ = PACK$("0000000000"+ UNPACK$(IDF.SECOND.BAR.CODE$))! FCS ! OAS
3086: 18ee:             !ENDIF ELSE BEGIN                                                     ! FCS ! OAS
3087: 18ee:                !CALL CALC.BAR.CODE.CHECK.DIGIT(UNPACK$(IDF.FIRST.BAR.CODE$))      ! FCS ! OAS
3088: 18ee: 
3089: 18ee:                !CLILF.BARCODE$ = RIGHT$(UNPACK$(IDF.FIRST.BAR.CODE$) +   \        ! FCS ! OAS
3090: 18ee:                !     F06.CHECK.DIGIT$,13)                                         ! FCS ! OAS
3091: 18ee:                !IRF.BAR.CODE$ = PACK$("0000000000"+ UNPACK$(IDF.FIRST.BAR.CODE$)) ! FCS ! OAS
3092: 18ee:             !ENDIF                                                                ! FCS ! OAS
3093: 18ee:          !ENDIF                                                                   ! FCS ! OAS
3094: 18ee: 
3095: 18ee: 
3096: 18ee:          !RC% = READ.IRF                                               ! CNS ! OAS
3097: 18ee:          !IF RC% = 0 THEN BEGIN                                        ! CNS ! OAS
3098: 18ee:             !IF IRF.DEAL.NUM$(0) = PACK$("0000") AND \                 ! HBG ! OAS
3099: 18ee:             !   IRF.DEAL.NUM$(1) = PACK$("0000") AND \                 ! HBG ! OAS
3100: 18ee:             !   IRF.DEAL.NUM$(2) = PACK$("0000") THEN BEGIN            ! HBG ! OAS
3101: 18ee:             !   CLILF.DEALMKR$ = "N"                                   ! HBG ! OAS
3102: 18ee:             !ENDIF ELSE BEGIN                                          ! HBG ! OAS
3103: 18ee:             !   CLILF.DEALMKR$ = "Y"                                   ! HBG ! OAS
3104: 18ee:             !ENDIF                                                     ! HBG ! OAS
3105: 18ee:          !ENDIF                                                        ! CNS ! OAS
3106: 18ee:        !ENDIF                                                          ! CNS ! OAS
3107: 18ee: 
3108: 18ee:       ! If SEL description not available, use short one on IDF         ! HBG ! OAS
3109: 18ee: 
3110: 18ee:       !CLILF.SELDESC$ is not present in the updated CLILF format.            ! OAS
3111: 18ee:       !The conditional statement given below is used to set the              ! OAS
3112: 18ee:       !variable CLILF.SELDESC$.As CLILF.SELDESC$ is not needed,              ! OAS
3113: 18ee:       !the below conditional statement is also commented.                    ! OAS
3114: 18ee:       !IF UCASE$(LEFT$(ISF.S.E.DESC$,2)) = "X " OR \                   ! HBG ! OAS
3115: 18ee:       !   ISF.S.E.DESC$ = STRING$(45," ") THEN BEGIN                   ! HBG ! OAS
3116: 18ee:       !   CLILF.SELDESC$ = IDF.STNDRD.DESC$ + STRING$(21," ")!length 45! HBG ! OAS
3117: 18ee:       !ENDIF ELSE BEGIN                                                ! HBG ! OAS
3118: 18ee:       !   CLILF.SELDESC$ = ISF.S.E.DESC$                               ! CNS ! OAS
3119: 18ee:       !ENDIF                                                           ! HBG ! OAS
3120: 18ee: 
3121: 18ee:        GOSUB PROCESS.SRITL   !To get the active planner details of an item   ! OAS
3122: 18f8: 
3123: 18f8:        CLILF.BOOTSCODE$ = PACK$(CLILF.BOOTSCODE$)                      ! OAS
3124: 1913:        CURRENT.REPORT.NUM% = CLILF.REPORT.NUM%                         ! CNS
3125: 1921:        FILE.OPERATION$ = "W"                                           ! CNS
3126: 1930:        RC% = WRITE.CLILF                                               ! CNS
3127: 1938:        IF RC% <> 0 THEN GOTO FILE.ERROR.EXIT                           ! CNS
3128: 1940: 
3129: 1940:        LIST.ITEMS = LIST.ITEMS + 1                                     ! CNS
3130: 1944: 
3131: 1944: RETURN
3132: 194c: 
3133: 194c: \*****************************************************************************
3134: 194c: \***
3135: 194c: \***   New functionality added -                                        ! OAS
3136: 194c: \***   PROCESS.SRITL
3137: 194c: \***   Extract information from SRITML (Active Planner Details)
3138: 194c: \***   for writing to CLILF
3139: 194c: \***
3140: 194c: \*****************************************************************************
3141: 194c: PROCESS.SRITL:
3142: 194c: 
3143: 194c:     !Initialising the details for each possible sales floor site        ! OAS
3144: 194c:     FOR COUNTER% = 0 TO 31                                              ! OAS
3145: 1954:         CLILF.MODULE.ID%(COUNTER%) = 0                                  ! OAS
3146: 1972:         CLILF.MODULE.SEQ%(COUNTER%) = 0                                 ! OAS
3147: 1989:         CLILF.REPEAT.CNT%(COUNTER%) = 0                                 ! OAS
3148: 19a0:         CLILF.COUNT%(COUNTER%) = -1                                     ! OAS
3149: 19b8:         CLILF.FILL.QUANTITY%(COUNTER%) = 0                              ! OAS
3150: 19d0:         CLILF.FILLER$(COUNTER%) = STRING$(4, " ")                       ! OAS
3151: 19f5:     NEXT COUNTER%                                                       ! OAS
3152: 1a07: 
3153: 1a07:     !Populate the Planner ID,Module and REPEAT COUNT from SRITML        ! OAS
3154: 1a07: 
3155: 1a07:     !Item code without check digit                                      ! OAS
3156: 1a07:     SRITL.ITEM.CODE$ = PACK$(MID$(CLILF.BOOTSCODE$,2, 6))               ! OAS
3157: 1a2b: 
3158: 1a2b:     SRITL.RECORD.CHAIN% = 0                                             ! OAS
3159: 1a33:     RC% = READ.SRITL                                                    ! OAS
3160: 1a3b:     RECORD.COUNT% = 0                                                   ! OAS
3161: 1a48: 
3162: 1a48:     WHILE RC% = 0                                                       ! OAS
3163: 1a4b: 
3164: 1a4b:         !For each module key                                                   ! OAS
3165: 1a4b:         FOR LOOPCNT% = 0 TO SRITL.MAX.MOD.KEYS% - 1                            ! OAS
3166: 1a54:             IF SRITL.POGDB%(LOOPCNT%) AND     \                                ! OAS
3167: 1aa6:                RECORD.COUNT% <= 32 THEN BEGIN                                  ! OAS
3168: 1aa6:                !32 is the maximum limit in CLILF                               ! OAS
3169: 1aa6:                 CLILF.MODULE.ID%(RECORD.COUNT%) = SRITL.POGDB%(LOOPCNT%)       ! OAS
3170: 1ad7:                 CLILF.MODULE.SEQ%(RECORD.COUNT%) = SRITL.MODULE.SEQ%(LOOPCNT%) ! OAS
3171: 1b0b:                 CLILF.REPEAT.CNT%(RECORD.COUNT%) = SRITL.REPEAT.CNT%(LOOPCNT%) ! OAS
3172: 1b3f:                 RECORD.COUNT% = RECORD.COUNT% + 1                              ! OAS
3173: 1b52:             ENDIF ELSE BEGIN                                                   ! OAS
3174: 1b52:                 LOOPCNT% = SRITL.MAX.MOD.KEYS%   !To quit the FOR Loop         ! OAS
3175: 1b5c:                 RC% = 1                          !To quit the While Loop       ! OAS
3176: 1b62:             ENDIF                                                              ! OAS
3177: 1b62:         NEXT LOOPCNT%                                                          ! OAS
3178: 1b7a: 
3179: 1b7a:         !Read the next record chain from SRITEM if the FOR loop         ! OAS
3180: 1b7a:         !is exited normally                                             ! OAS
3181: 1b7a: 
3182: 1b7a:         IF (RECORD.COUNT% <= 32) AND (RC% = 0) THEN BEGIN               ! OAS
3183: 1b9f:             !32 is the maximum limit in CLILF                           ! OAS
3184: 1b9f:             SRITL.RECORD.CHAIN% = SRITL.RECORD.CHAIN% + 1               ! OAS
3185: 1ba6:             RC% = READ.SRITL                                            ! OAS
3186: 1bb0:         ENDIF ELSE IF RECORD.COUNT% > 32 THEN BEGIN                     ! OAS
3187: 1bc1:             !CLILF cannot accomodate > 32                               ! OAS
3188: 1bc1:             ADXSERVE.DATA$ = "Error: Item " + CLILF.BOOTSCODE$          ! OAS
3189: 1bdc:             GOSUB DISPLAY.MESSAGE                                       ! OAS
3190: 1be6:             ADXSERVE.DATA$ = "       CLILF can only accomodate 32 sites"! OAS
3191: 1bf3:             GOSUB DISPLAY.MESSAGE                                       ! OAS
3192: 1bfd:         ENDIF                                                           ! OAS
3193: 1bfd: 
3194: 1bfd:     WEND                                                                ! OAS
3195: 1c07: 
3196: 1c07: RETURN                                                                  ! OAS
3197: 1c0f: 
3198: 1c0f: \*****************************************************************************
3199: 1c0f: \***
3200: 1c0f: \***   CREATE RECOUNT LIST                                             ! OAS - Changed the subroutine name
3201: 1c0f: \***
3202: 1c0f: \*****************************************************************************
3203: 1c0f: !Renamed the sub routine CREATE.NEW.LIST to CREATE.RECOUNT.LIST        ! OAS
3204: 1c0f: CREATE.RECOUNT.LIST:
3205: 1c0f:        !Grouping all the variables commented since they were not in    ! OAS
3206: 1c0f:        !the new CLOLF RECORD. Need to remove these in the next release ! OAS
3207: 1c0f:        !IF OLD.PGNAME$ <> " " THEN BEGIN                               ! ICC
3208: 1c0f:          !CLOLF.SRITEMS$ = RIGHT$("000" + STR$(LIST.ITEMS - 1),3)      ! CNS ! OAS
3209: 1c0f:          !ADXSERVE.DATA$ = "CREATE.NEW.LIST: " + CLOLF.LISTID$         ! DCS ! OAS
3210: 1c0f:          !CLOLF.BSITEMS$ = CLOLF.SRITEMS$                              ! CNS ! OAS
3211: 1c0f:          !CLOLF.TOTAL.ITEMS$ = CLOLF.SRITEMS$                          ! FCS ! OAS
3212: 1c0f:          !CLOLF.OSSRITEMS$ = CLOLF.SRITEMS$                            ! KMG ! OAS
3213: 1c0f:          !CLOLF.BULETT$ = OLD.BULETT$                                  ! CNS ! OAS
3214: 1c0f:          !CLOLF.PGNAME$ = OLD.PGNAME$                                  ! ICC
3215: 1c0f:          !CLOLF.BUNAME$ = CLOLF.PGNAME$                                ! ICC  - Assignment needed to BUNAME as 1
3216: 1c0f:                                                                        ! this is the var the WRITE.CLOLF
3217: 1c0f:                                                                        ! uses to write to the relevant part of
3218: 1c0f:                                                                        ! the CLOLF record
3219: 1c0f:         IF (LIST.ITEMS <= 1) THEN BEGIN \! If no list to populate      ! OAS
3220: 1c16:             ADXSERVE.DATA$ = "No list to create"                       ! OAS
3221: 1c23:             GOSUB DISPLAY.MESSAGE
3222: 1c30:         ENDIF \                                                        ! OAS
3223: 1c30:         ELSE BEGIN
3224: 1c30:             ADXSERVE.DATA$ = "CLOLF.LISTID: " + CLOLF.LISTID$          ! OAS
3225: 1c4b:             GOSUB DISPLAY.MESSAGE                                      ! DCS
3226: 1c55:             CLOLF.TOTAL.ITEMS% = LIST.ITEMS - 1                        ! OAS
3227: 1c60:             CLOLF.SRITEMS% = CLOLF.TOTAL.ITEMS%                        ! OAS
3228: 1c6e:             CLOLF.BSITEMS% = CLOLF.TOTAL.ITEMS%                        ! OAS
3229: 1c7c:             CLOLF.OSSRITEMS% = CLOLF.TOTAL.ITEMS%                      ! OAS
3230: 1c8a:             CURRENT.REPORT.NUM% = CLOLF.REPORT.NUM%                    ! CNS
3231: 1c98:             FILE.OPERATION$ = "W"                                      ! CNS
3232: 1ca7:             CLOLF.CREATION.DATE$ = PACK$(DATE$)                        ! OAS
3233: 1cbc:             CLOLF.CREATION.TIME$ = PACK$(LEFT$(TIME$,4))               ! OAS
3234: 1ce5: 
3235: 1ce5:             RC% = WRITE.CLOLF                                          ! CNS
3236: 1ced:             IF RC% <> 0 THEN GOTO FILE.ERROR.EXIT                      ! CNS
3237: 1cf5: 
3238: 1cf5:             !Grouping all the variables commented since they were not in the
3239: 1cf5:             !new CLOLF RECORD. Need to remove these in the next release
3240: 1cf5:             !CLOLF.OSSRITEMS$ = "000"                                  ! KMG ! OAS
3241: 1cf5:             !CLOLF.BULETT$ = LEFT$(RPRPT.RECORD$,1)                    ! CNS ! OAS
3242: 1cf5:             !CLOLF.PGNAME$ = MID$(RPRPT.RECORD$,28,12)+"   "           ! ICC ! OAS
3243: 1cf5: 
3244: 1cf5:             CLOLF.RECORD.NUM% = CLOLF.RECORD.NUM% + 1                  ! CNS
3245: 1d06:             CLOLF.LISTID$ = RIGHT$("000" + STR$(VAL(CLOLF.LISTID$) + 1),3)!CNS
3246: 1d6e:             LIST.ITEMS = 1                                             ! CNS
3247: 1d74: 
3248: 1d74:         ENDIF
3249: 1d74:        !ENDIF                                                          ! CNS ! OAS
3250: 1d74: 
3251: 1d74:          !Commented since they were not in the new CLOLF RECORD.       ! OAS
3252: 1d74:          !Need to remove these in the next release                     ! OAS
3253: 1d74:          !OLD.BULETT$ = CLOLF.BULETT$                                  ! CNS ! OAS
3254: 1d74:          !OLD.PGNAME$ = CLOLF.PGNAME$                                  ! ICC ! OAS
3255: 1d74: 
3256: 1d74: RETURN
3257: 1d7c: 
3258: 1d7c: 
3259: 1d7c: 
3260: 1d7c: \*******************************************************************   ! OAS
3261: 1d7c: \***    Display background message                                     ! OAS
3262: 1d7c: \***................................................................   ! OAS
3263: 1d7c: 
3264: 1d7c: DISPLAY.MESSAGE:                                                       ! DCS
3265: 1d7c:                                                                        ! DCS
3266: 1d7c:      IF COMM.MODE.FLAG$ = "B" THEN BEGIN                               ! DCS
3267: 1d92:          ADX.INTEGER%  = 0                                             ! DCS
3268: 1d98:          ADX.FUNCTION% = 26                                            ! DCS
3269: 1d9e:          CALL ADXSERVE (ADX.RETURN.CODE%,                              \ DCS
3270: 1db8:                         ADX.FUNCTION%,                                 \ DCS
3271: 1db8:                         ADX.INTEGER%,                                  \ DCS
3272: 1db8:                         ADXSERVE.DATA$)                                ! DCS
3273: 1db8:      ENDIF ELSE BEGIN                                                  ! DCS
3274: 1db8:         PRINT ADXSERVE.DATA$                                           ! DCS
3275: 1dc5:      ENDIF                                                             ! DCS
3276: 1dc5: RETURN                                                                 ! DCS
3277: 1dcd: 
3278: 1dcd: \*****************************************************************************
3279: 1dcd: \***
3280: 1dcd: \***    TERMINATION
3281: 1dcd: \***
3282: 1dcd: \***..........................................................................
3283: 1dcd: 
3284: 1dcd: 
3285: 1dcd: TERMINATION:
3286: 1dcd: 
3287: 1dcd:     ADXSERVE.DATA$ = "TERMINATION"                                     ! DCS
3288: 1dda:     GOSUB DISPLAY.MESSAGE                                              ! DCS
3289: 1de4: 
3290: 1de4:     GOSUB DEALLOCATE.SESSION.NUMBERS
3291: 1dee: 
3292: 1dee: RETURN
3293: 1df6: 
3294: 1df6: 
3295: 1df6: 
3296: 1df6: \*****************************************************************************
3297: 1df6: \***
3298: 1df6: \***    TERMINATION SPECIFIC ROUTINES
3299: 1df6: \***
3300: 1df6: \***..........................................................................
3301: 1df6: 
3302: 1df6: 
3303: 1df6: \*****************************************************************************
3304: 1df6: \***
3305: 1df6: \***    DEALLOCATE.SESSION.NUMBERS
3306: 1df6: \***    Perform CALL.F20.SESS.NUM.UTILITY to de-allocate file session numbers
3307: 1df6: \***    from all files referenced by the program.
3308: 1df6: \***
3309: 1df6: \***..........................................................................
3310: 1df6: 
3311: 1df6: 
3312: 1df6: DEALLOCATE.SESSION.NUMBERS:
3313: 1df6: 
3314: 1df6: 
3315: 1df6:     ADXSERVE.DATA$ = "DEALLOCATE.SESSION.NUMBERS"                      ! DCS
3316: 1e03:     GOSUB DISPLAY.MESSAGE                                              ! DCS
3317: 1e0d: 
3318: 1e0d:     FUNCTION.FLAG$ EQ "C"
3319: 1e1a: 
3320: 1e1a:     PASSED.INTEGER% EQ RPRPT.SESS.NUM%
3321: 1e25:     PASSED.STRING$ EQ ""
3322: 1e32:     GOSUB CALL.F20.SESS.NUM.UTILITY
3323: 1e3c: 
3324: 1e3c:     PASSED.INTEGER% = PRINT.SESS.NUM%
3325: 1e46:     PASSED.STRING$ = ""
3326: 1e53:     GOSUB CALL.F20.SESS.NUM.UTILITY
3327: 1e5d: 
3328: 1e5d:     PASSED.INTEGER% = SOFTS.SESS.NUM%                                  ! CNS
3329: 1e67:     PASSED.STRING$ = ""                                                ! CNS
3330: 1e74:     GOSUB CALL.F20.SESS.NUM.UTILITY                                    ! CNS
3331: 1e7e: 
3332: 1e7e:     PASSED.INTEGER% = RFSCF.SESS.NUM%                                  ! CNS
3333: 1e88:     PASSED.STRING$ = ""                                                ! CNS
3334: 1e95:     GOSUB CALL.F20.SESS.NUM.UTILITY                                    ! CNS
3335: 1e9f: 
3336: 1e9f:     PASSED.INTEGER% = CLOLF.SESS.NUM%                                  ! CNS
3337: 1ea9:     PASSED.STRING$ = ""                                                ! CNS
3338: 1eb6:     GOSUB CALL.F20.SESS.NUM.UTILITY                                    ! CNS
3339: 1ec0: 
3340: 1ec0:     PASSED.INTEGER% = CLILF.SESS.NUM%                                  ! CNS
3341: 1eca:     PASSED.STRING$ = ""                                                ! CNS
3342: 1ed7:     GOSUB CALL.F20.SESS.NUM.UTILITY                                    ! CNS
3343: 1ee1: 
3344: 1ee1:     !PASSED.INTEGER% = ISF.SESS.NUM%                                   ! CNS ! OAS
3345: 1ee1:     !PASSED.STRING$ = ""                                               ! CNS ! OAS
3346: 1ee1:     !GOSUB CALL.F20.SESS.NUM.UTILITY                                   ! CNS ! OAS
3347: 1ee1: 
3348: 1ee1:     !PASSED.INTEGER% = IRF.SESS.NUM%                                   ! CNS ! OAS
3349: 1ee1:     !PASSED.STRING$ = ""                                               ! CNS ! OAS
3350: 1ee1:     !GOSUB CALL.F20.SESS.NUM.UTILITY                                   ! CNS ! OAS
3351: 1ee1: 
3352: 1ee1:     PASSED.INTEGER% = IDF.SESS.NUM%                                    ! CNS
3353: 1eeb:     PASSED.STRING$ = ""                                                ! CNS
3354: 1ef8:     GOSUB CALL.F20.SESS.NUM.UTILITY                                    ! CNS
3355: 1f02: 
3356: 1f02:     PASSED.INTEGER% = MINLS.SESS.NUM%                                  ! LJT
3357: 1f0c:     PASSED.STRING$ = ""                                                ! LJT
3358: 1f19:     GOSUB CALL.F20.SESS.NUM.UTILITY                                    ! LJT
3359: 1f23: 
3360: 1f23:     PASSED.INTEGER% = SRITL.SESS.NUM%                                  ! OAS
3361: 1f2d:     PASSED.STRING$ = ""                                                ! OAS
3362: 1f3a:     GOSUB CALL.F20.SESS.NUM.UTILITY                                    ! OAS
3363: 1f44: 
3364: 1f44:     PASSED.INTEGER% = MINOK.SESS.NUM%                                  ! OAS
3365: 1f4a:     PASSED.STRING$ = ""                                                ! OAS
3366: 1f57:     GOSUB CALL.F20.SESS.NUM.UTILITY                                    ! OAS
3367: 1f61: 
3368: 1f61:     ADXSERVE.DATA$ = "Session numbers deallocated"                     ! DCS
3369: 1f6e:     GOSUB DISPLAY.MESSAGE                                              ! DCS
3370: 1f78: 
3371: 1f78: RETURN
3372: 1f80: 
3373: 1f80: 
3374: 1f80: \*****************************************************************************
3375: 1f80: \***
3376: 1f80: \***    CHECK.FUNCTION.RETURN.CODE:
3377: 1f80: \***    If FUNCTION.RETURN.CODE% is zero ...
3378: 1f80: \***        By-passes rest of procedure.
3379: 1f80: \***    Displays error message on background screen.
3380: 1f80: \***    Stops program.
3381: 1f80: \***
3382: 1f80: \***..........................................................................
3383: 1f80: 
3384: 1f80: 
3385: 1f80: CHECK.FUNCTION.RETURN.CODE:
3386: 1f80: 
3387: 1f80:     IF FUNCTION.RETURN.CODE% EQ 0 THEN \
3388: 1f8a:         BEGIN
3389: 1f8a:         RETURN
3390: 1f92:         ENDIF
3391: 1f92: 
3392: 1f92:     GOSUB STOP.PROGRAM
3393: 1f9c: 
3394: 1f9c: RETURN
3395: 1fa4: 
3396: 1fa4: 
3397: 1fa4: \*****************************************************************************
3398: 1fa4: \***
3399: 1fa4: \***    FORMAT.CURRENT.CODE:
3400: 1fa4: \***    Sets CURRENT.CODE.LOGGED$ for use with application event log.
3401: 1fa4: \***
3402: 1fa4: \***..........................................................................
3403: 1fa4: 
3404: 1fa4: 
3405: 1fa4: FORMAT.CURRENT.CODE:
3406: 1fa4: 
3407: 1fa4:     IF FILE.OPERATION$ EQ "C"                            \ ! Create
3408: 1fee:       OR FILE.OPERATION$ EQ "O" THEN                     \ ! Open
3409: 1fee:     BEGIN
3410: 1fee:         CURRENT.CODE.LOGGED$ EQ PACK$("00000000000000")
3411: 2000:     ENDIF
3412: 2000: 
3413: 2000:     IF FILE.OPERATION$ EQ "R"                            \ ! Read
3414: 204a:       OR FILE.OPERATION$ EQ "W" THEN                     \ ! Write
3415: 204a:     BEGIN
3416: 204a:         CURRENT.CODE.LOGGED$ EQ RIGHT$(CURRENT.CODE$,7)
3417: 2065:     ENDIF
3418: 2065: 
3419: 2065: RETURN
3420: 206d: 
3421: 206d: 
3422: 206d: 
3423: 206d: \*****************************************************************************
3424: 206d: \***
3425: 206d: \***    PROGRAM INDEPENDENT ROUTINES
3426: 206d: \***
3427: 206d: \***..........................................................................
3428: 206d: 
3429: 206d: 
3430: 206d: \*****************************************************************************
3431: 206d: \***
3432: 206d: \***    CALL.F01.APPLICATION.LOG:
3433: 206d: \***    References APPLICATION.LOG (F01) to write details of event defined
3434: 206d: \***    by EVENT.NUMBER% and VAR.STRING.1$ to Application Event Log, and to
3435: 206d: \***    display any message defined by MESSAGE.NUMBER% and VAR.STRING.2$.
3436: 206d: \***
3437: 206d: \***..........................................................................
3438: 206d: 
3439: 206d: 
3440: 206d: CALL.F01.APPLICATION.LOG:
3441: 206d: 
3442: 206d: 
3443: 206d:     FUNCTION.RETURN.CODE% EQ \
3444: 2095:       APPLICATION.LOG \
3445: 2095:        (MESSAGE.NUMBER%, \
3446: 2095:         VAR.STRING.1$, \
3447: 2095:         VAR.STRING.2$, \
3448: 2095:         EVENT.NUMBER%)
3449: 2095: 
3450: 2095:     GOSUB CHECK.FUNCTION.RETURN.CODE
3451: 209f: 
3452: 209f: RETURN
3453: 20a7: 
3454: 20a7: 
3455: 20a7: \*****************************************************************************
3456: 20a7: \***
3457: 20a7: \***    CALL.F20.SESS.NUM.UTILITY:
3458: 20a7: \***    References SESS.NUM.UTILITY (F20) to create, read, or delete entry on
3459: 20a7: \***    Session Number Table as determined by FUNCTION.FLAG$ ("O" "R" "C").
3460: 20a7: \***
3461: 20a7: \***..........................................................................
3462: 20a7: 
3463: 20a7: 
3464: 20a7: CALL.F20.SESS.NUM.UTILITY:
3465: 20a7: 
3466: 20a7: 
3467: 20a7:     FUNCTION.RETURN.CODE% EQ \
3468: 20ca:       SESS.NUM.UTILITY \
3469: 20ca:        (FUNCTION.FLAG$, \
3470: 20ca:         PASSED.INTEGER%, \
3471: 20ca:         PASSED.STRING$)
3472: 20ca: 
3473: 20ca:     GOSUB CHECK.FUNCTION.RETURN.CODE
3474: 20d4: 
3475: 20d4:     IF FUNCTION.FLAG$ = "R" THEN CURRENT.REPORT.NUM% = F20.INTEGER.FILE.NO% !HBG
3476: 20f5: 
3477: 20f5: RETURN
3478: 20fd: 
3479: 20fd: 
3480: 20fd: \*****************************************************************************
3481: 20fd: \***
3482: 20fd: \***    LOG.AN.EVENT.106:
3483: 20fd: \***    Writes details of Event 106 to application event log and displays
3484: 20fd: \***    message B501 (for file open errors) or B514 (for other errors).
3485: 20fd: \***
3486: 20fd: \***..........................................................................
3487: 20fd: 
3488: 20fd: 
3489: 20fd: LOG.AN.EVENT.106:
3490: 20fd: 
3491: 20fd: 
3492: 20fd:     ADXSERVE.DATA$ = "LOG.AN.EVENT.106 File Op= " + FILE.OPERATION$    ! DCS
3493: 2118:     GOSUB DISPLAY.MESSAGE                                              ! DCS
3494: 2122: 
3495: 2122:     EVENT.NUMBER% EQ 106
3496: 2127: 
3497: 2127:     GOSUB FORMAT.CURRENT.CODE
3498: 2131: 
3499: 2131:     !OBTAIN REPORT NUMBER                                              ! HBG
3500: 2131:     FUNCTION.FLAG$ = "R"                                               ! HBG
3501: 213e:     PASSED.INTEGER% = CURRENT.SESS.NUM%                                ! HBG
3502: 2148:     GOSUB CALL.F20.SESS.NUM.UTILITY                                    ! HBG
3503: 2152: 
3504: 2152:     VAR.STRING.1$ EQ                         \ ! Application event log data
3505: 21b9:         FILE.OPERATION$                    + \
3506: 21b9:         CHR$(SHIFT(CURRENT.REPORT.NUM%,8)) + \ ! Two byte integer byte order
3507: 21b9:         CHR$(SHIFT(CURRENT.REPORT.NUM%,0)) + \ ! reversed to give hex number
3508: 21b9:         CURRENT.CODE.LOGGED$
3509: 21b9: 
3510: 21b9:     GOSUB CALL.F01.APPLICATION.LOG
3511: 21c3: 
3512: 21c3: RETURN
3513: 21cb: 
3514: 21cb: 
3515: 21cb: 
3516: 21cb: \*****************************************************************************
3517: 21cb: \***
3518: 21cb: \***    IF END # AND ERROR.DETECTED ROUTINES
3519: 21cb: \***
3520: 21cb: \***..........................................................................
3521: 21cb: 
3522: 21cb: 
3523: 21cb: \******************************************************************************
3524: 21cb: \***
3525: 21cb: \***   CREATE.ERROR:
3526: 21cb: \***
3527: 21cb: \***   LOG an event 106
3528: 21cb: \***
3529: 21cb: \***   GOTO PROGRAM.EXIT
3530: 21cb: \***
3531: 21cb: \******************************************************************************
3532: 21cb: 
3533: 21cb: CREATE.ERROR:
3534: 21cb: 
3535: 21cb:        GOSUB LOG.AN.EVENT.106
3536: 21d5: 
3537: 21d5:        GOTO STOP.PROGRAM
3538: 21d8: 
3539: 21d8: \*****************************************************************************
3540: 21d8: \***
3541: 21d8: \***    FILE.ERROR.EXIT:
3542: 21d8: \***    Logs events for specific file errors.
3543: 21d8: \***    Formats error message and displays on background screen.
3544: 21d8: \***    Logs an event 106.
3545: 21d8: \***    Stops program.
3546: 21d8: \***
3547: 21d8: \***..........................................................................
3548: 21d8: 
3549: 21d8: 
3550: 21d8: FILE.ERROR.EXIT:
3551: 21d8: 
3552: 21d8: 
3553: 21d8:     GOSUB FORMAT.CURRENT.CODE
3554: 21e2:     GOSUB LOG.AN.EVENT.106
3555: 21ec:     GOTO  STOP.PROGRAM
3556: 21ef: 
3557: 21ef: \*****************************************************************************
3558: 21ef: \***
3559: 21ef: \***    ERROR.DETECTED:
3560: 21ef: \***    Increments ERROR.COUNT% by one and tests it against values greater
3561: 21ef: \***    than one before any other commands executed.
3562: 21ef: \***    Further errors within ERROR.DETECTED causing control to be passed here
3563: 21ef: \***    again result in this test being failed and the immediate diversion of
3564: 21ef: \***    program control to STOP.PROGRAM.
3565: 21ef: \***    If no chaining parameters passed ...
3566: 21ef: \***        Diverts program control to OBTAIN.CHAIN.PARAMETERS.FROM.COMMAND
3567: 21ef: \***    References STANDARD.ERROR.DETECTED to log Event 101 and display
3568: 21ef: \***    message B550.
3569: 21ef: \***
3570: 21ef: \***..........................................................................
3571: 21ef: 
3572: 21ef: 
3573: 21ef: ERROR.DETECTED:
3574: 21ef: 
3575: 21ef:     ADXSERVE.DATA$ = "ERROR.DETECTED"                                  ! DCS
3576: 21fc:     GOSUB DISPLAY.MESSAGE                                              ! DCS
3577: 2206: 
3578: 2206:     ERROR.COUNT% EQ ERROR.COUNT% + 1
3579: 220a: 
3580: 220a:     IF ERROR.COUNT% GT 1 THEN \
3581: 2211:         BEGIN
3582: 2211:         RESUME STOP.PROGRAM
3583: 2220:         ENDIF
3584: 2220: 
3585: 2220:     IF FILE.OPERATION$ = "W" AND \                                     ! OAS
3586: 2255:        CURRENT.SESS.NUM% = MINOK.SESS.NUM% THEN BEGIN                  ! OAS
3587: 2255: 
3588: 2255:         ADXSERVE.DATA$ = "Error while writing to MINOK File"           ! OAS
3589: 2262:         GOSUB DISPLAY.MESSAGE                                          ! OAS
3590: 226c:         ERROR.COUNT% = 0                                               ! OAS
3591: 2271:         RESUME MINOK.ERROR                                             ! OAS
3592: 2280: 
3593: 2280:     ENDIF                                                              ! OAS
3594: 2280: 
3595: 2280:     !Setting MINLS HOUSEKEEPING FLAG to FALSE when there is an error   ! OAS
3596: 2280:     !while deleting the record from the file                           ! OAS
3597: 2280: 
3598: 2280:     IF FILE.OPERATION$ = "D" THEN BEGIN                                ! OAS
3599: 2296: 
3600: 2296:         ADXSERVE.DATA$ = "Error while deleting MINLS record"           ! OAS
3601: 22a3:         GOSUB DISPLAY.MESSAGE                                          ! OAS
3602: 22ad:         MINLS.HK.STATUS$ = "X"                                         ! OAS
3603: 22ba:         ERROR.COUNT% = 0                                               ! OAS
3604: 22bf:         RESUME                                                         ! OAS
3605: 22ce: 
3606: 22ce:     ENDIF                                                              ! OAS
3607: 22ce: 
3608: 22ce: 
3609: 22ce:     IF ERR = "OE" THEN BEGIN                                           ! CNS
3610: 22ec:        IF CURRENT.SESS.NUM% = RFSCF.SESS.NUM% THEN BEGIN               ! CNS
3611: 22fc:           ERROR.COUNT% = 0                                             ! CNS
3612: 2301:           DO.MAIN = 1                                                  ! CNS
3613: 2306:           RESUME END.RF.PROCESS                                        ! CNS
3614: 2315:        ENDIF                                                           ! CNS
3615: 2315:     ENDIF                                                              ! CNS
3616: 2315: 
3617: 2315:     IF ERR = "KF" AND CURRENT.SESS.NUM% = SRITL.SESS.NUM%             \! OAS
3618: 2359:       THEN BEGIN                                                       ! OAS
3619: 2359:       ERROR.COUNT% = 0                                                 ! OAS
3620: 235e:       RESUME                                                           ! OAS
3621: 236d:     ENDIF                                                              ! OAS
3622: 236d: 
3623: 236d:     IF ERR = "CU" AND CURRENT.SESS.NUM% = MINOK.SESS.NUM%             \! RTT
3624: 23ae:       THEN BEGIN                                                       ! RTT
3625: 23ae:       ERROR.COUNT% = 0                                                 ! RTT
3626: 23b3:       RESUME                                                           ! RTT
3627: 23c2:     ENDIF                                                              ! RTT
3628: 23c2: 
3629: 23c2:     FUNCTION.RETURN.CODE% EQ  \ OAS
3630: 23ee:       STANDARD.ERROR.DETECTED \
3631: 23ee:        (ERRN,                 \ OAS
3632: 23ee:         ERRF%,                \ OAS
3633: 23ee:         ERRL,                 \ OAS
3634: 23ee:         ERR)
3635: 23ee: 
3636: 23ee: RESUME STOP.PROGRAM
3637: 2402: 
3638: 2402: 
3639: 2402: \*****************************************************************************
3640: 2402: \*****************************************************************************
3641: 2402: \***
3642: 2402: \***    End of program MINPRINT
3643: 2402: \***
3644: 2402: \*****************************************************************************
3645: 2402: \*****************************************************************************
3646: 2402: 
3647: 2402: 
3648: 2402: 
3649: 2402: 
3650: 2402: End of Compilation
