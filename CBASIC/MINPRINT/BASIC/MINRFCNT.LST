   1: 0000: \*****************************************************************************
   2: 0000: \*****************************************************************************
   3: 0000: \***
   4: 0000: \***    PROGRAM  .....  MINPRINT
   5: 0000: \***    MODULE  ......  MINRFCNT.BAS
   6: 0000: \***
   7: 0000: \***    REVISION 1.0.           Arun Sudhakarannair             14th June 2012
   8: 0000: \***    Original version.
   9: 0000: \***
  10: 0000: \***    VERSION B (1.1)         Tittoo Thomas                   04th Sept 2012
  11: 0000: \***    Fixed to specify the date format in RFCNTLST header to DD/MM/YY.
  12: 0000: \***    (SFA defect ID 600)
  13: 0000: \***
  14: 0000: \***    VERSION C (1.2)         Charles Skadorwa (CCSk)         10th Sept 2012
  15: 0000: \***    SFA Defect 661 - Summary counts are not updated.
  16: 0000: \***    Corrected Summary headings: "User Generated Lists" and
  17: 0000: \***         "Support Office Lists" swapped around (in 2 places).
  18: 0000: \***    Corrected time separator from "." to ":".
  19: 0000: \***    Commented out redundant code (as set by file function) and
  20: 0000: \***         moved a static variable outside of a loop.
  21: 0000: \***
  22: 0000: \***    VERSION D (1.3)            Tittoo Thomas (DTT)          24th Sept 2012
  23: 0000: \***    SFA Defect 693, 694 - Operator name and list creation time not correct
  24: 0000: \***    Corrected Summary & Detail headings: "User Generated Lists" and
  25: 0000: \***         "Support Office Lists" swapped around (in 2 places).
  26: 0000: \***
  27: 0000: \***    VERSION E (1.4)            Tittoo Thomas (ETT)          02nd Nov 2012
  28: 0000: \***    SFA Defect 779 - Excluded lists with Zero items or currently "In Creation"
  29: 0000: \***    status.
  30: 0000: \***
  31: 0000: \***    Version F              Ranjith Gopalankutty(FRG)     10th Feb  2017
  32: 0000: \***    After 16A rollout MINPRINT is triggered after midnight as part of
  33: 0000: \***    end of the day reset, there is a date check happens in MINRFCNT
  34: 0000: \***    module before adding the records to RFCNTLST.DAY. Since the date
  35: 0000: \***    match doesn't happen, records are being ignored and count list 
  36: 0000: \***    are not appearing in controller screen. Fix is to ensure the date
  37: 0000: \***    parameter check is correct and record is added if the run is after
  38: 0000: \***    mid night.
  39: 0000: \*****************************************************************************
  40: 0000: \***                                  OVERVIEW
  41: 0000: \***                                  ========
  42: 0000: \***    MINRFCNT takes data from CLILF and CLOLF and prepares RF Count report
  43: 0000: \***    (RFCNTLST.DAY). This report can be viewed both on the controller and
  44: 0000: \***    RF PPC/MC55 and POD MC55/MC70.
  45: 0000: \***
  46: 0000: \***    The report is split into 2 sections. The first part is a summary for
  47: 0000: \***    each count list type (Negative, User Generated and Support Office).
  48: 0000: \***    The second part gives details of which users performed the counts,
  49: 0000: \***    and whether the list was fully counted, part counted or not counted
  50: 0000: \***    at all.
  51: 0000: \***
  52: 0000: \*****************************************************************************
  53: 0000: \*****************************************************************************
  54: 0000: 
  55: 0000: \*****************************************************************************
  56: 0000: \***
  57: 0000: \***    DEC included code defining file related fields
  58: 0000: \***
  59: 0000: \***..........................................................................
  60: 0000: 
  61: 0000:     %INCLUDE   AFDEC.J86        ! GSA Authorisation File field declaration
  62: 0000: 
  63: 0000: \REM
  64: 0000: \*******************************************************************************
  65: 0000: \*******************************************************************************
  66: 0000: \***
  67: 0000: \***    %INCLUDE FOR GSA AUTHORISATION FILE VARIABLE DECLARATIONS
  68: 0000: \***
  69: 0000: \***        REFERENCE   :  AFDEC (J86)
  70: 0000: \***
  71: 0000: \***        FILE TYPE   :  Keyed
  72: 0000: \***
  73: 0000: \***    The GSA Authorisation File (EALAUTH.DAT) should not be confused with
  74: 0000: \***    the Operating System Authorisation File (ADXCSOUF.DAT).
  75: 0000: \***
  76: 0000: \***    VERSION A.              ROBERT COWEY.                       18 AUG 1992.
  77: 0000: \***    Original version created by merging AFFLDD and AFNUMD.
  78: 0000: \***
  79: 0000: \***    VERSION B.              Steve Windsor                          Nov 1992.
  80: 0000: \***    Addition of new fields for the CASTLE project.
  81: 0000: \***    Supervisor flag and operator model.
  82: 0000: \***
  83: 0000: \***    VERSION C.              ROBERT COWEY.                       03 MAR 1994.
  84: 0000: \***    Defined fields DATE.PSWD.CHANGE$, and MODEL.FLAGS.1% and ...2%.
  85: 0000: \***
  86: 0000: \***    VERSION D.             Mike Bishop                          30 JUN 2004
  87: 0000: \***    Defined field AF.STAFF.NUM$ AF.EMPLOYEE.FLAG$
  88: 0000: \***
  89: 0000: \***    VERSION E.             Alan Carr  (AJC)                      4 Oct 2004
  90: 0000: \***    Defined field AF.RECEIPT.NAME$
  91: 0000: \***
  92: 0000: \***    VERSION F.             Alan Carr  (AJC)                     31 Jan 2005
  93: 0000: \***    Defined field AF.GROUP.CODE$
  94: 0000: \***
  95: 0000: \***    REVISION 1.6.                ROBERT COWEY.                15 JUN 2009.
  96: 0000: \***    Changes for A9C POS improvements project.
  97: 0000: \***    Used up last available three bytes of EALAUTH user data by redefining 
  98: 0000: \***    remaining AF.USER$ variable as AF.BIRTH.DATE$.
  99: 0000: \***    See IBM manual "GSA Programming Guide" Appendix A-27 for file layout 
 100: 0000: \***    describing INDICAT flags (and position of original 20 bytes user data).
 101: 0000: \***
 102: 0000: \***    REVISION 1.7.                ROBERT COWEY.                22 JUN 2009.
 103: 0000: \***    Changes for A9C POS improvements project creating PSB99.286 Rv 1.8.
 104: 0000: \***    Defect 3247 - Redefined AF.BIRTH.DATE$ format as UPD-hex DDMCYY.
 105: 0000: \***    Description text change only - No code changes to this file.
 106: 0000: \***
 107: 0000: \*******************************************************************************
 108: 0000: \*******************************************************************************
 109: 0000: 
 110: 0000: 
 111: 0000:     STRING GLOBAL \
 112: 0000:         AF.BIRTH.DATE$,       \ ! 3 byte DDMCYY UPD/hex format         ! 1.7 RC
 113: 0000:                               \ ! M is month  A=Oct B=Nov C=Dec        ! 1.7 RC
 114: 0000:                               \ ! C is century  0=19xx 1=20xx          ! 1.7 RC
 115: 0000:         AF.DATE.PSWD.CHANGE$, \ ! 3 bytes UPD                          ! CRC
 116: 0000:         AF.FILE.NAME$, \
 117: 0000:         AF.FLAGS.01.12$, \      ! 15 bytes
 118: 0000:         AF.FLAGS.13.16$, \      ! 4 bytes
 119: 0000:         AF.OPERATOR.NAME$,\     ! 20 bytes
 120: 0000:         AF.OPERATOR.NO$, \      ! 4 byte UPD (key)
 121: 0000:         AF.OPTIONS.KEY$, \      ! 1 byte UPD
 122: 0000:         AF.PASSWORD$, \         ! 4 byte UPD
 123: 0000:         AF.RECEIPT.NAME$, \     ! 12 bytes                             ! AJC
 124: 0000:         AF.STAFF.NUM$, \         ! 4 byte UPD                          DMB
 125: 0000:         AF.EMPLOYEE.FLAG$, \     ! 1 byte UPD                          DMB
 126: 0000:         AF.GROUP.CODE$, \       ! 1  byte UPD                          AJC
 127: 0000: \       AF.USER$, \             ! 3  bytes                             ! 1.6 RC
 128: 0000:         AF.SUP.FLAG$, \         ! 1  byte                              BSJW
 129: 0000:         AF.OP.MODEL$            ! 3  bytes                             BSJW
 130: 0000: 
 131: 0000:     INTEGER*1 GLOBAL \
 132: 0000:         AF.INDICAT4%, \
 133: 0000:         AF.INDICAT5%, \
 134: 0000:         AF.INDICAT6%, \
 135: 0000:         AF.INDICAT7%, \
 136: 0000:         AF.INDICAT8%, \
 137: 0000:         AF.INDICAT9%, \
 138: 0000:         AF.INDICAT10%, \
 139: 0000:         AF.INDICAT11%, \
 140: 0000:         AF.INDICAT12%, \
 141: 0000:         AF.INDICAT13%, \
 142: 0000:         AF.INDICAT14%, \
 143: 0000:         AF.INDICAT15%, \
 144: 0000:         AF.INDICAT16%, \
 145: 0000:         AF.REPORT.NUM%
 146: 0000: 
 147: 0000:     INTEGER*2 GLOBAL \
 148: 0000:         AF.INDICAT1%, \
 149: 0000:         AF.INDICAT2%, \
 150: 0000:         AF.INDICAT3%, \
 151: 0000:         AF.MODEL.FLAGS.1%, \                                           ! CRC
 152: 0000:         AF.MODEL.FLAGS.2%, \                                           ! CRC
 153: 0000:         AF.RECL%, \
 154: 0000:         AF.SESS.NUM%
 155: 0000: 
 156: 0000:     %INCLUDE   CLILFDEC.J86     ! RF Count Lists File
 157: 0000: 
 158: 0000: \******************************************************************************\******************************************************************************
 159: 0000: \******************************************************************************
 160: 0000: \***
 161: 0000: \***         %INCLUDE FOR RF COUNT LISTS FILE FIELD DECLARATIONS
 162: 0000: \***
 163: 0000: \***               FILE TYPE    : KEYED
 164: 0000: \***
 165: 0000: \***               REFERENCE    : CLILFDEC.J86
 166: 0000: \***
 167: 0000: \***    VERSION A.              Nik Sen.                 13 October 1998
 168: 0000: \***                 New file for RF system. Holds count lists information.
 169: 0000: \***
 170: 0000: \***    VERSION B               Charles Skadorwa         22nd January 1999
 171: 0000: \***                 Head Office Sequence Number now held (from PIITM
 172: 0000: \***                 record) in order that a "complete" Type 13 transaction
 173: 0000: \***                 record is written to the STKMQ file. 
 174: 0000: \***
 175: 0000: \***    REVISION 1.4.            ROBERT COWEY.                  09 SEP 2003.
 176: 0000: \***    Changes for RF trial.
 177: 0000: \***    Removed redundant PVCS revision control block from top of code.
 178: 0000: \***    Recompiled to prevent future automatic recompiles.
 179: 0000: \***    No changes to actual code.
 180: 0000: \***
 181: 0000: \***    REVISION 1.5             ALAN CARR                      12 AUG 2004.
 182: 0000: \***    Changes for RF OSSR solution.
 183: 0000: \***    Added new fields for Off-Site StockRoom (OSSR) Basic Solution
 184: 0000: \***
 185: 0000: \***    REVISION 1.6             Mark Goode                     25th January 2005 
 186: 0000: \***
 187: 0000: \***    REVISION 1.7             Syam Jayan                     25th January 2012
 188: 0000: \***    The change is to rearrange/remove redundant fields and to add new
 189: 0000: \***    fields in CLILF Format as part of Stock file accuracy project
 190: 0000: \***
 191: 0000: \*******************************************************************************
 192: 0000: \*******************************************************************************
 193: 0000: 
 194: 0000: STRING GLOBAL                     \
 195: 0000:     CLILF.BOOTSCODE$,             \                                          ! 1.7 SJ
 196: 0000:     CLILF.COUNTED.STATUS$,        \ U-not counted, P-partially counted,      ! 1.7 SJ
 197: 0000:                                   \ C-counted                                ! 1.7 SJ
 198: 0000:     CLILF.DATE.LASTCNT$,          \ Date of Last Count field                 ! 1.7 SJ
 199: 0000:     CLILF.FILE.NAME$,             \                                          ! 1.7 SJ
 200: 0000:     CLILF.FILLER$(1),             \ Filler Array                             ! 1.7 SJ
 201: 0000:     CLILF.HO.SEQNO$,              \ Head Office Sequence No. from PIITM for  ! 1.7 SJ
 202: 0000:                                   \ Stock Support                            ! BCS ! 1.7 SJ
 203: 0000:     CLILF.ITEMSEQ$,               \ Item Sequence Number                     ! 1.7 SJ
 204: 0000:     CLILF.KEY$,                   \ LISTID + ITEMSEQ                         ! 1.7 SJ
 205: 0000:     CLILF.LISTID$,                \ List Number                              ! 1.7 SJ
 206: 0000:     CLILF.SPACE$                  ! Free space                               ! 1.7 SJ
 207: 0000:     !CLILF.BARCODE$,              \                                          ! 1.7 SJ
 208: 0000:     !CLILF.SELDESC$,              \ Shelf Edge Label Descriptor              ! 1.7 SJ
 209: 0000:     !CLILF.DEALMKR$,              \ Active Deal Marker                       ! 1.7 SJ
 210: 0000:     !CLILF.PRODGRP$,              \ Concept/Sequence Number                  ! 1.7 SJ
 211: 0000:     !CLILF.PRODGRPDESC$,          \ Product Group Descriptor                 ! 1.7 SJ 
 212: 0000:     !CLILF.BSCNT$,                \ Back Shop Counts                         ! 1.7 SJ
 213: 0000:     !CLILF.SFCNT$,                \ Shop Floor Counts                        ! 1.7 SJ
 214: 0000:     !CLILF.SALESSFCNT$,           \ Signed Sales at time of Shop Floor Count ! 1.7 SJ
 215: 0000:     !CLILF.SALEBSCNT$,            \ Sale at time of back shop count \ 1.5 AC ! 1.7 SJ
 216: 0000:     !CLILF.SALEOSSRCNT$,          \ Sale at time of OSSR count      \ 1.5 AC ! 1.7 SJ
 217: 0000:     !CLILF.OSSR.ITMSTKCNT$,       \ OSSR Item Stock count figure    \ 1.5 AC ! 1.7 SJ
 218: 0000:     !CLILF.TIMESFCNT$,            \ Time of Stock Floor count hh:mm \ 1.5 AC ! 1.7 SJ
 219: 0000:     !CLILF.TIMEBSCNT$,            \ Time of Back shop count hh:mm   \ 1.5 AC ! 1.7 SJ
 220: 0000:     !CLILF.TIMEOSSRCNT$,          \ Time of OSSR count hh:mm        \ 1.5 AC ! 1.7 SJ
 221: 0000: 
 222: 0000: INTEGER*4 GLOBAL                 \
 223: 0000:     CLILF.MODULE.ID%(1)          ! Planner ID Array (SRITL.POGDB%)           ! 1.7 SJ
 224: 0000: 
 225: 0000: INTEGER*2 GLOBAL                 \
 226: 0000:     CLILF.BSCNT%,                \ Main Backshop MBS Count                   ! 1.7 SJ
 227: 0000:     CLILF.BS.PEND.SA.CNT%,       \ Back Shop pending sales plan Count        ! 1.7 SJ
 228: 0000:     CLILF.COUNT%(1),             \ Count Array                               ! 1.7 SJ
 229: 0000:     CLILF.FILL.QUANTITY%(1),     \                                           ! 1.7 SJ
 230: 0000:     CLILF.OSSR.ITMSTKCNT%,       \ OSSR Item Stock count figure              ! 1.7 SJ
 231: 0000:     CLILF.OSSR.PEND.SA.CNT%,     \ OSSR pending sales plan Count field       ! 1.7 SJ
 232: 0000:     CLILF.RECL%,                 \                                           ! 1.7 SJ
 233: 0000:     CLILF.REPORT.NUM%,           \                                           ! 1.7 SJ
 234: 0000:     CLILF.SALESCNT%,             \ Sales count                               ! 1.7 SJ
 235: 0000:     CLILF.SESS.NUM%,             \ Clilf session number                      ! 1.7 SJ
 236: 0000:     CLILF.SFCNT%                 ! Shop floor count                          ! 1.7 SJ
 237: 0000:   
 238: 0000: INTEGER*1 GLOBAL                 \
 239: 0000:     CLILF.MODULE.SEQ%(1),        \ Module Seq Array (SRITL.MODULE.SEQ%)      ! 1.7 SJ
 240: 0000:     CLILF.REPEAT.CNT%(1)         ! Repeat Count Array (SRITL.REPEAT.CNT%)    ! 1.7 SJ
 241: 0000:     !CLILF.RECL%                 !                                           ! 1.7 SJ
 242: 0000: 
 243: 0000:     %INCLUDE   CLOLFDEC.J86     ! RF Count List Of Lists File
 244: 0000: 
 245: 0000: \******************************************************************************\******************************************************************************
 246: 0000: \******************************************************************************
 247: 0000: \***
 248: 0000: \***         %INCLUDE FOR RF LIST OF LISTS FILE FIELD DECLARATIONS
 249: 0000: \***
 250: 0000: \***               FILE TYPE    : DIRECT
 251: 0000: \***
 252: 0000: \***               REFERENCE    : CLOLFDEC.J86
 253: 0000: \***
 254: 0000: \***    VERSION A.           Nik Sen.               13 October 1998
 255: 0000: \***               New file for RF system. Holds list of counting lists. 
 256: 0000: \***
 257: 0000: \***    VERSION B            Charles Skadorwa        22nd January 1999
 258: 0000: \***               TOTAL.ITEMS added to keep track of total items in each list.
 259: 0000: \***                 
 260: 0000: \***    REVISION 1.4.            ROBERT COWEY.                  09 SEP 2003.
 261: 0000: \***    Changes for RF trial.
 262: 0000: \***    Removed redundant PVCS revision control block from top of code.
 263: 0000: \***    Recompiled to prevent future automatic recompiles.
 264: 0000: \***    No changes to actual code.
 265: 0000: \***
 266: 0000: \***    REVISION 1.5             ALAN CARR                     12 AUG 2004.
 267: 0000: \***    Changes for RF OSSR solution.
 268: 0000: \***    Added new flag "marked for OSSR count". This can be "Y" or "N"
 269: 0000: \***
 270: 0000: \***    REVISION 1.6            MARK GOODE                     5th January 2005.
 271: 0000: \***    Changes for RF OSSR WAN solution.
 272: 0000: \***    New field on the header record for remaining OSSR count figure and user ID
 273: 0000: \***
 274: 0000: \***    REVISION 1.7            SYAM JAYAN                     25th January 2012
 275: 0000: \***    The change is to rearrange/remove redundant fields and to add new
 276: 0000: \***    fields in CLOLF Format as part of Stock file accuracy project
 277: 0000: \***
 278: 0000: \*******************************************************************************
 279: 0000: \*******************************************************************************
 280: 0000: 
 281: 0000: STRING GLOBAL                   \
 282: 0000:     CLOLF.ACTIVE.STATUS$,       \                        ! 1.7 SJ
 283: 0000:     CLOLF.BULETT$,              \                        ! 1.7 SJ
 284: 0000:     CLOLF.CREATION.DATE$,       \Creation date           ! 1.7 SJ
 285: 0000:     CLOLF.CREATION.TIME$,       \Creation time           ! 1.7 SJ
 286: 0000:     CLOLF.CURRENT.LOCATION$,    \Current location        ! 1.7 SJ
 287: 0000:     CLOLF.EXPIRY.DATE$,         \Expiry date             ! 1.7 SJ
 288: 0000:     CLOLF.FILE.NAME$,           \                        ! 1.7 SJ
 289: 0000:     CLOLF.LISTID$,              \                        ! 1.7 SJ
 290: 0000:     CLOLF.LIST.NAME$,           \                        ! 1.7 SJ
 291: 0000:     CLOLF.LSTTYP$,              \                        ! 1.7 SJ
 292: 0000:     CLOLF.PICKER.USER.ID$,      \                        ! 1.7 SJ
 293: 0000:     CLOLF.PILST.ID$,            \                        ! 1.7 SJ
 294: 0000:     CLOLF.PICK.START.TIME$,     \Pick start time         ! 1.7 SJ
 295: 0000:     CLOLF.PICK.END.TIME$,       \Pick end time           ! 1.7 SJ
 296: 0000:     CLOLF.USERID$               ! 1.6 MG                 ! 1.7 SJ
 297: 0000:     !CLOLF.TOTAL.ITEMS$,        \ BCS                    ! 1.7 SJ
 298: 0000:     !CLOLF.SRITEMS$,            \                        ! 1.7 SJ
 299: 0000:     !CLOLF.BSITEMS$,            \                        ! 1.7 SJ
 300: 0000:     !CLOLF.BUNAME$,             \                        ! 1.7 SJ
 301: 0000:     !CLOLF.HOLISTID$,           \                        ! 1.7 SJ
 302: 0000:     !CLOLF.CNTDATE$,            \ 1.5 AC                 ! 1.7 SJ
 303: 0000:     !CLOLF.OSSR.FLAG$,          \ 1.5 AC                 ! 1.7 SJ
 304: 0000:     !CLOLF.OSSRITEMS$,          \ 1.6 MG                 ! 1.7 SJ
 305: 0000:   
 306: 0000: INTEGER*4 GLOBAL                \
 307: 0000:     CLOLF.RECORD.NUM%
 308: 0000: 
 309: 0000: INTEGER*2 GLOBAL                \
 310: 0000:     CLOLF.BSITEMS%,             \                        ! 1.7 SJ
 311: 0000:     CLOLF.OSSRITEMS%,           \                        ! 1.7 SJ
 312: 0000:     CLOLF.REPORT.NUM%,          \                        ! 1.7 SJ
 313: 0000:     CLOLF.SESS.NUM%,            \                        ! 1.7 SJ
 314: 0000:     CLOLF.SRITEMS%,             \                        ! 1.7 SJ
 315: 0000:     CLOLF.TOTAL.ITEMS%          !                        ! 1.7 SJ
 316: 0000:                                                   
 317: 0000: INTEGER*1 GLOBAL                \
 318: 0000:     CLOLF.RECL%         
 319: 0000: 
 320: 0000: 
 321: 0000: 
 322: 0000: \*****************************************************************************
 323: 0000: \***
 324: 0000: \***    Included code defining function related global variables
 325: 0000: \***
 326: 0000: \***..........................................................................
 327: 0000: 
 328: 0000:     %INCLUDE PSBF01G.J86        ! APPLICATION.LOG
 329: 0000: REM \
 330: 0000: \*******************************************************************************
 331: 0000: \*******************************************************************************
 332: 0000: \***
 333: 0000: \***       %INCLUDE FOR GLOBAL DEFINITIONS FOR FUNCTION APPLICATION.LOG
 334: 0000: \***
 335: 0000: \***                FUNCTION NUMBER    : PSBF01
 336: 0000: \***
 337: 0000: \***                REFERENCE          : PSBF01G.J86
 338: 0000: \***
 339: 0000: \***                DATE OF LAST AMENDMENT  - 27/2/86
 340: 0000: \***
 341: 0000: \***
 342: 0000: \*******************************************************************************
 343: 0000: 
 344: 0000:       INTEGER GLOBAL  F01.RETURN.CODE%
 345: 0000: 
 346: 0000: 
 347: 0000:     %INCLUDE PSBF02G.J86        ! UPDATE date variable                  ! FRG
 348: 0000: REM\
 349: 0000: \*******************************************************************************
 350: 0000: \*******************************************************************************
 351: 0000: \***
 352: 0000: \***        INCLUDE       : UPDATE.DATE globals
 353: 0000: \***
 354: 0000: \***        REFERENCE     : PSBF02G.J86
 355: 0000: \***
 356: 0000: \***        Version A     Bruce Scriver      4th March 1986
 357: 0000: \*** 
 358: 0000: \***        Version B     Andrew Wedgeworth   6th July 1992
 359: 0000: \***        Removal of return code field which no longer required.
 360: 0000: \***
 361: 0000: \*******************************************************************************
 362: 0000: \*******************************************************************************
 363: 0000: 
 364: 0000:       STRING   GLOBAL F02.DATE$
 365: 0000: 
 366: 0000:       ! 1 line deleted from here                                       ! BAW
 367: 0000: 
 368: 0000:     %INCLUDE PSBF14G.J86        ! SORT.TABLE globals
 369: 0000: REM\
 370: 0000: \*******************************************************************************
 371: 0000: \*******************************************************************************
 372: 0000: \***
 373: 0000: \***        INCLUDE       : SORT.TABLE globals
 374: 0000: \***
 375: 0000: \***        REFERENCE     : PSBF14G.J86
 376: 0000: \***
 377: 0000: \***        Version A     Bruce Scriver                3rd March 1986
 378: 0000: \*** 
 379: 0000: \***        Version B     Andrew Wedgeworth            17th July 1992
 380: 0000: \***        Removal of now redundant return code field.
 381: 0000: \***
 382: 0000: \*******************************************************************************
 383: 0000: \*******************************************************************************
 384: 0000: 
 385: 0000:       STRING   GLOBAL F14.TABLE$(1)
 386: 0000: 
 387: 0000: 
 388: 0000:     %INCLUDE PSBF20G.J86        ! Allocating Session Numbers            ! FRG
 389: 0000: REM\
 390: 0000: \*******************************************************************************
 391: 0000: \*******************************************************************************
 392: 0000: \***
 393: 0000: \***     %INCLUDE GLOBAL VARIABLE DEFINITIONS FOR SESS.NUM.UTILITY FUNCTION
 394: 0000: \***
 395: 0000: \***                       REFERENCE     : PSBF20G.J86
 396: 0000: \*** 
 397: 0000: \***     Version A              Bruce Scrive                   5th May 1988   
 398: 0000: \*** 
 399: 0000: \***     Version B              Robert Cowey                   7th May 1991
 400: 0000: \***     Global variable F20.INTEGER.FILE.NO% changed from one byte integer
 401: 0000: \***     to two byte integer.
 402: 0000: \***
 403: 0000: \***     Version D              Andrew Wedgeworth             1st July 1992
 404: 0000: \***     F20.RETURN.CODE% removed as it is no longer required.
 405: 0000: \***
 406: 0000: \*******************************************************************************
 407: 0000: \*******************************************************************************
 408: 0000: 
 409: 0000:       STRING    GLOBAL F20.FILE.NAME$,                                 \
 410: 0000:                        F20.STRING.FILE.NO$,                            \
 411: 0000:                        F20.TABLE.DIMENSIONED.FLAG$,                    \
 412: 0000:                        SESS.NUM.TABLE$(1)
 413: 0000: 
 414: 0000:       INTEGER*2 GLOBAL F20.INTEGER.FILE.NO%
 415: 0000: 
 416: 0000:       ! 1 line deleted from here                                       ! DAW 
 417: 0000: 
 418: 0000: 
 419: 0000: 
 420: 0000: \*****************************************************************************
 421: 0000: \***
 422: 0000: \***    Global variable definitions
 423: 0000: \***
 424: 0000: \***..........................................................................
 425: 0000: 
 426: 0000:     STRING GLOBAL               \
 427: 0000:         COMM.MODE.FLAG$,        \
 428: 0000:         CURRENT.CODE$,          \
 429: 0000:         FILE.OPERATION$,        \
 430: 0000:         REPORTING.STATUS$
 431: 0000: 
 432: 0000:     INTEGER*2 GLOBAL            \
 433: 0000:         CURRENT.REPORT.NUM%,    \
 434: 0000:         RFCNTLST.SESS.NUM%
 435: 0000: 
 436: 0000:     INTEGER*1 GLOBAL            \
 437: 0000:         FALSE,                  \
 438: 0000:         TRUE
 439: 0000: 
 440: 0000: \*****************************************************************************
 441: 0000: \***
 442: 0000: \***    Variable definitions
 443: 0000: \***
 444: 0000: \***..........................................................................
 445: 0000: 
 446: 0000:     STRING                      \
 447: 0000:         ADXSERVE.DATA$,         \
 448: 0000:         CURR.LIST.TYPE$,        \
 449: 0000:         CURRENT.TYPE$,          \
 450: 0000:         CURR.CNT.STATUS$,       \
 451: 0000:         CURR.RECORD$,           \
 452: 0000:         CURRENT.CODE.LOGGED$,   \
 453: 0000:         FUNCTION.FLAG$,         \
 454: 0000:         PASSED.STRING$,         \
 455: 0000:         PREV.TYPE$,             \
 456: 0000:         PREV.CNT.STATUS$,       \
 457: 0000:         RFCNTLST.FILE.NAME$,    \
 458: 0000:         RFCNTLST.RECORD$,       \
 459: 0000:         VAR.STRING.1$,          \
 460: 0000:         VAR.STRING.2$
 461: 0000: 
 462: 0000:     INTEGER*1                   \
 463: 0000:         COUNTER%,               \
 464: 0000:         ERROR.COUNT%
 465: 0000: 
 466: 0000:     INTEGER*2                   \
 467: 0000:         ADX.FUNCTION%,          \
 468: 0000:         ADX.INTEGER%,           \
 469: 0000:         CLOLF.NUMRECS%,         \
 470: 0000:         CLILF.COUNTER%,         \
 471: 0000:         CURR.RECORD.INDEX%,     \
 472: 0000:         EVENT.NUMBER%,          \
 473: 0000:         F14.LIMIT%,             \
 474: 0000:         F14TABLE.MAX.INDEX%,    \
 475: 0000:         FUNCTION.RETURN.CODE%,  \
 476: 0000:         ITEMS.NOT.COUNTED%,     \
 477: 0000:         LISTS.COUNTED.ARRAY%(1),\
 478: 0000:         MESSAGE.NUMBER%,        \
 479: 0000:         NUM.LISTS.ARRAY%(1),    \
 480: 0000:         PART.COUNT.ARRAY%(1),   \
 481: 0000:         PASSED.INTEGER%,        \
 482: 0000:         RC%,                    \
 483: 0000:         RFCNTLST.REPORT.NUM%,   \
 484: 0000:         UNCOUNTED.ARRAY%(1)
 485: 0000: 
 486: 0000:     INTEGER*4                   \
 487: 0000:         ADX.RETURN.CODE%
 488: 0000: 
 489: 0000: \*****************************************************************************
 490: 0000: \***
 491: 0000: \***    EXT included code defining file related external functions
 492: 0000: \***
 493: 0000: \***..........................................................................
 494: 0000: 
 495: 0000:     %INCLUDE AFEXT.J86          ! GSA Authorisation File function definition
 496: 0000: 
 497: 0000: \REM
 498: 0000: \*******************************************************************************
 499: 0000: \*******************************************************************************
 500: 0000: \***
 501: 0000: \***    %INCLUDE FOR GSA AUTHORISATION FILE EXTERNAL FUNCTIONS
 502: 0000: \***
 503: 0000: \***        REFERENCE   :  AFEXT (J86)
 504: 0000: \***
 505: 0000: \***        FILE TYPE   :  Keyed
 506: 0000: \***
 507: 0000: \***    The GSA Authorisation File (EALAUTH.DAT) should not be confused with
 508: 0000: \***    the Operating System Authorisation File (ADXCSOUF.DAT).
 509: 0000: \***
 510: 0000: \***    VERSION A.              ROBERT COWEY.                       18 AUG 1992.
 511: 0000: \***    Original version created from AFEXTA.
 512: 0000: \***
 513: 0000: \***    VERSION B.              Steve Windsor                       29 Dec 1992.
 514: 0000: \***    Version incremented to keep in line with other included code           
 515: 0000: \***
 516: 0000: \***    VERSION C.              ROBERT COWEY.                       03 MAR 1994.
 517: 0000: \***    No changes to this file.
 518: 0000: \***
 519: 0000: \***    REVISION 1.6.                ROBERT COWEY.                15 JUN 2009.
 520: 0000: \***    Changes for A9C POS improvements project.
 521: 0000: \***    Used up last available three bytes of EALAUTH user data by redefining 
 522: 0000: \***    remaining AF.USER$ variable as AF.BIRTH.DATE$.
 523: 0000: \***    No changes to this file.
 524: 0000: \***
 525: 0000: \***    REVISION 1.7.                ROBERT COWEY.                22 JUN 2009.
 526: 0000: \***    Changes for A9C POS improvements project creating PSB99.286 Rv 1.8.
 527: 0000: \***    Defect 3247 - Redefined AF.BIRTH.DATE$ format within AFDEC.J86.
 528: 0000: \***    Description text change only - No code changes to this file.
 529: 0000: \***
 530: 0000: \*******************************************************************************
 531: 0000: \*******************************************************************************
 532: 0000: 
 533: 0000: 
 534: 0000: FUNCTION AF.SET EXTERNAL
 535: 0000:     INTEGER*2 AF.SET
 536: 0000: END FUNCTION
 537: 0000: 
 538: 0000: 
 539: 0000: FUNCTION READ.AF EXTERNAL
 540: 0000:     INTEGER*2 READ.AF
 541: 0000: END FUNCTION
 542: 0000: 
 543: 0000: 
 544: 0000: FUNCTION READ.AF.LOCKED EXTERNAL
 545: 0000:     INTEGER*2 READ.AF.LOCKED
 546: 0000: END FUNCTION
 547: 0000: 
 548: 0000:   
 549: 0000: FUNCTION READ.AF.ABREV EXTERNAL
 550: 0000:     INTEGER*2 READ.AF.ABREV
 551: 0000: END FUNCTION
 552: 0000: 
 553: 0000: 
 554: 0000: FUNCTION READ.AF.ABREV.LOCKED EXTERNAL
 555: 0000:     INTEGER*2 READ.AF.ABREV.LOCKED
 556: 0000: END FUNCTION
 557: 0000: 
 558: 0000:   
 559: 0000: FUNCTION WRITE.AF.UNLOCK EXTERNAL
 560: 0000:     INTEGER*2 WRITE.AF.UNLOCK
 561: 0000: END FUNCTION
 562: 0000: 
 563: 0000: 
 564: 0000: FUNCTION WRITE.AF.ABREV EXTERNAL
 565: 0000:     INTEGER*2 WRITE.AF.ABREV
 566: 0000: END FUNCTION
 567: 0000: 
 568: 0000: 
 569: 0000: FUNCTION WRITE.AF.ABREV.UNLOCK EXTERNAL
 570: 0000:     INTEGER*2 WRITE.AF.ABREV.UNLOCK
 571: 0000: END FUNCTION
 572: 0000: 
 573: 0000:     %INCLUDE CLOLFEXT.J86       ! RF Count List Of Lists File
 574: 0000: 
 575: 0000: \******************************************************************************
 576: 0000: \******************************************************************************\*****************************************************************************
 577: 0000: \***
 578: 0000: \***           FUNCTION DEFINITIONS FOR THE RF COUNT LIST OF LISTS FILE
 579: 0000: \***
 580: 0000: \***           REFERENCE:   CLOLFEXT.J86
 581: 0000: \***
 582: 0000: \***           VERSION A         Nik Sen         13th October 1998
 583: 0000: \***
 584: 0000: \***    REVISION 1.4.            ROBERT COWEY.                  09 SEP 2003.
 585: 0000: \***    Changes for RF trial.
 586: 0000: \***    Removed redundant PVCS revision control block from top of code.
 587: 0000: \***    Recompiled to prevent future automatic recompiles.
 588: 0000: \***    No changes to actual code.
 589: 0000: \***
 590: 0000: \*******************************************************************************
 591: 0000: \*******************************************************************************
 592: 0000: 
 593: 0000:    FUNCTION CLOLF.SET EXTERNAL
 594: 0000:    END FUNCTION
 595: 0000:    
 596: 0000:    FUNCTION READ.CLOLF EXTERNAL
 597: 0000:       INTEGER*2 READ.CLOLF
 598: 0000:    END FUNCTION
 599: 0000:    
 600: 0000:    FUNCTION WRITE.CLOLF EXTERNAL
 601: 0000:       INTEGER*2 WRITE.CLOLF
 602: 0000:    END FUNCTION
 603: 0000:  
 604: 0000:     %INCLUDE CLILFEXT.J86       ! RF Count Lists File
 605: 0000:    
 606: 0000: \******************************************************************************
 607: 0000: \******************************************************************************\*****************************************************************************
 608: 0000: \***
 609: 0000: \***           FUNCTION DEFINITIONS FOR THE RF COUNT LISTS FILE
 610: 0000: \***
 611: 0000: \***           REFERENCE:   CLILFEXT.J86
 612: 0000: \***
 613: 0000: \***           VERSION A         Nik Sen         13th October 1998
 614: 0000: \***
 615: 0000: \***    REVISION 1.4.            ROBERT COWEY.                  09 SEP 2003.
 616: 0000: \***    Changes for RF trial.
 617: 0000: \***    Removed redundant PVCS revision control block from top of code.
 618: 0000: \***    Recompiled to prevent future automatic recompiles.
 619: 0000: \***    No changes to actual code.
 620: 0000: \***
 621: 0000: \*******************************************************************************
 622: 0000: \*******************************************************************************
 623: 0000: 
 624: 0000:    
 625: 0000:    FUNCTION CLILF.SET EXTERNAL
 626: 0000:    END FUNCTION
 627: 0000:    
 628: 0000:    FUNCTION READ.CLILF EXTERNAL
 629: 0000:       INTEGER*2 READ.CLILF
 630: 0000:    END FUNCTION
 631: 0000:    
 632: 0000:    FUNCTION WRITE.CLILF EXTERNAL
 633: 0000:       INTEGER*2 WRITE.CLILF
 634: 0000:    END FUNCTION
 635: 0000:  
 636: 0000: 
 637: 0000: \*****************************************************************************
 638: 0000: \***
 639: 0000: \***    Included code defining external Boots functions
 640: 0000: \***
 641: 0000: \***..........................................................................
 642: 0000: 
 643: 0000:     %INCLUDE ADXSERVE.J86       ! Message Logging
 644: 0000: \******************************************************************************
 645: 0000: \******************************************************************************
 646: 0000: \***                                                                        ***
 647: 0000: \***    %INCLUDE FOR FUNCTION ADXSERVE (an I.B.M. system function)          ***
 648: 0000: \***                                                                        ***
 649: 0000: \***         AUTHOR        :  Bruce Scriver                                 ***
 650: 0000: \***                                                                        ***
 651: 0000: \***         DATE WRITTEN  :  14th March 1986                               ***
 652: 0000: \***                                                                        ***
 653: 0000: \***         DATE OF LAST REVISION  - 14th March 1986                       ***
 654: 0000: \***                                                                        ***
 655: 0000: \***                                                                        ***
 656: 0000: \******************************************************************************
 657: 0000: \******************************************************************************
 658: 0000: 
 659: 0000:    SUB ADXSERVE (RETURN.CODE%,                                                \
 660: 0000:                  ADX.FUNCTION%,                                               \
 661: 0000:                  ADX.PARM.1%,                                                 \
 662: 0000:                  ADX.PARM.2$)                                                 \
 663: 0000:    EXTERNAL
 664: 0000:   
 665: 0000:       STRING     ADX.PARM.2$
 666: 0000: 
 667: 0000:       INTEGER*2  ADX.FUNCTION%,                                               \
 668: 0000:                  ADX.PARM.1%
 669: 0000: 
 670: 0000:       INTEGER*4  RETURN.CODE%                                                 \
 671: 0000: 
 672: 0000:    END SUB     
 673: 0000: 
 674: 0000:     %INCLUDE PSBF01E.J86        ! APPLICATION.LOG
 675: 0000: REM \
 676: 0000: \*******************************************************************************
 677: 0000: \*******************************************************************************
 678: 0000: \***
 679: 0000: \***      %INCLUDE FOR EXTERNAL DEFINITION OF FUNCTION APPLICATION.LOG
 680: 0000: \***
 681: 0000: \***                      FUNCTION NUMBER   : PSBF01
 682: 0000: \***
 683: 0000: \***                    INCLUDE REFERENCE : PSBF01E.J86
 684: 0000: \*** 
 685: 0000: \***      Version B           Andrew Wedgeworth          1st July 1992
 686: 0000: \***      Three parameters which passed to the function have been removed.
 687: 0000: \***      APPLICATION.LOG has been added as a variable name (this holds the
 688: 0000: \***      return code).
 689: 0000: \***
 690: 0000: \*******************************************************************************
 691: 0000: 
 692: 0000: 
 693: 0000:    FUNCTION APPLICATION.LOG (MESSAGE.NO%,                                     \
 694: 0000:                              VAR.STRING.1$,                                   \
 695: 0000:                              VAR.STRING.2$,                                   \
 696: 0000:                              EVENT.NO%)  EXTERNAL
 697: 0000: 
 698: 0000:       INTEGER*1 EVENT.NO%
 699: 0000: 
 700: 0000:       INTEGER*2 APPLICATION.LOG,                                       \ GAW
 701: 0000:                 MESSAGE.NO%
 702: 0000: 
 703: 0000:       STRING VAR.STRING.1$,                                            \
 704: 0000:              VAR.STRING.2$
 705: 0000: 
 706: 0000:    END FUNCTION
 707: 0000: 
 708: 0000: \*******************************************************************************
 709: 0000:     %INCLUDE PSBF02E.J86        ! Update Date External Function         ! FRG
 710: 0000: REM\
 711: 0000: \*******************************************************************************
 712: 0000: \*******************************************************************************
 713: 0000: \***
 714: 0000: \***        INCLUDE       : UPDATE.DATE external definition
 715: 0000: \***        AUTHOR        : Bruce Scriver (Basic Code)
 716: 0000: \***        DATE WRITTEN  : 4th March 1986 (Basic Code)
 717: 0000: \***
 718: 0000: \***        REFERENCE     : PSBF02E.J86
 719: 0000: \***
 720: 0000: \***        Version A     Bruce Scriver          4th March 1986
 721: 0000: \***
 722: 0000: \***        Version B     Andrew Wedgeworth       6th July 1992
 723: 0000: \***        Removal of redundant parameters, and inclusion of UPDATE.DATE as
 724: 0000: \***        a variable to hold the return code.
 725: 0000: \***
 726: 0000: \*******************************************************************************
 727: 0000: \*******************************************************************************
 728: 0000: 
 729: 0000:    FUNCTION UPDATE.DATE (INCREMENT%)                                   \
 730: 0000:    EXTERNAL
 731: 0000:    ! 3 parameters removed from here                                    ! BAW
 732: 0000: 
 733: 0000:    ! 3 lines deleted from here                                         ! BAW
 734: 0000:    
 735: 0000:       INTEGER*2 UPDATE.DATE                                            ! BAW
 736: 0000: 
 737: 0000:       INTEGER*4 INCREMENT%
 738: 0000: 
 739: 0000:    END FUNCTION
 740: 0000: 
 741: 0000:     %INCLUDE PSBF14E.J86        ! SORT.TABLE function definition
 742: 0000: REM\
 743: 0000: \*******************************************************************************
 744: 0000: \*******************************************************************************
 745: 0000: \***
 746: 0000: \***        INCLUDE       : SORT.TABLE external definition
 747: 0000: \***
 748: 0000: \***        REFERENCE     : PSBF14E.J86
 749: 0000: \***
 750: 0000: \***        Version A     Bruce Scriver                   3rd March 1986   
 751: 0000: \*** 
 752: 0000: \***        Version B     Andrew Wedgeworth               17th July 1992
 753: 0000: \***        Redundant function parameters removed.  SORT.TABLE defined as a
 754: 0000: \***        variable to hold the return code.
 755: 0000: \***
 756: 0000: \*******************************************************************************
 757: 0000: \*******************************************************************************
 758: 0000: 
 759: 0000:    FUNCTION SORT.TABLE (NUMBER.OF.ENTRIES%)                                    \
 760: 0000:    EXTERNAL
 761: 0000: 
 762: 0000:       INTEGER   NUMBER.OF.ENTRIES%,                                    \ BAW
 763: 0000:                 SORT.TABLE                 
 764: 0000: 
 765: 0000:    END FUNCTION
 766: 0000: 
 767: 0000:     %INCLUDE PSBF20E.J86        ! Allocating Session Numbers
 768: 0000: REM\
 769: 0000: \*******************************************************************************
 770: 0000: \*******************************************************************************
 771: 0000: \***
 772: 0000: \***       %INCLUDE FOR EXTERNAL DEFINITION OF SESS.NUM.UTILITY
 773: 0000: \***
 774: 0000: \***                  REFERENCE     : PSBF20E.J86
 775: 0000: \***
 776: 0000: \***     VERSION C            Janet Smith                13th May 1992
 777: 0000: \***     Increased PASSED.INTEGER to 2 bytes to cater for more than
 778: 0000: \***     128 files.
 779: 0000: \***
 780: 0000: \***     VERSION D.           Andrew Wedgeworth          1st July 1992
 781: 0000: \***     Removal of redundant parameters and addition of SESS.NUM.UTILITY
 782: 0000: \***     as a variable.  This new variable contains the function's return
 783: 0000: \***     code.
 784: 0000: \***
 785: 0000: \*******************************************************************************
 786: 0000: \*******************************************************************************
 787: 0000: 
 788: 0000:    FUNCTION SESS.NUM.UTILITY (FUNCTION.FLAG$,                          \
 789: 0000:                               PASSED.INTEGER%,                         \
 790: 0000:                               PASSED.STRING$)                          \
 791: 0000:    EXTERNAL
 792: 0000: 
 793: 0000:    STRING    FUNCTION.FLAG$,                                           \
 794: 0000:              PASSED.STRING$
 795: 0000:    ! 3 variables removed from here                                     ! CAW
 796: 0000: 
 797: 0000: 
 798: 0000:    INTEGER*2 SESS.NUM.UTILITY,                                         \ CAW
 799: 0000:              PASSED.INTEGER%				               ! CJAS
 800: 0000: 
 801: 0000:    END FUNCTION
 802: 0000: 
 803: 0000:     %INCLUDE PSBF24E.J86        ! STANDARD.ERROR.DETECTED
 804: 0000: REM \
 805: 0000: \*******************************************************************************
 806: 0000: \*******************************************************************************
 807: 0000: \***
 808: 0000: \***    %INCLUDE FOR EXTERNAL DEFINITION OF STANDARD.ERROR.DETECTED FUNCTION
 809: 0000: \***
 810: 0000: \***                      REFERENCE     : PSBF24E.J86
 811: 0000: \***
 812: 0000: \***    Version A                 Janet Smith                  13th May 1992
 813: 0000: \***
 814: 0000: \*******************************************************************************
 815: 0000: \*******************************************************************************
 816: 0000: 
 817: 0000:    FUNCTION STANDARD.ERROR.DETECTED(ERRN%,                 \
 818: 0000: 				    ERRFILE%,              \
 819: 0000: 				    ERRL%,                 \
 820: 0000: 				    ERR$)        EXTERNAL
 821: 0000: 				    
 822: 0000:           STRING    ERR$
 823: 0000: 
 824: 0000:           INTEGER*2 ERRFILE%,              \
 825: 0000: 	            ERRL%,                 \
 826: 0000: 		    STANDARD.ERROR.DETECTED
 827: 0000: 		    
 828: 0000:           INTEGER*4 ERRN%
 829: 0000: 	  		    
 830: 0000:    END FUNCTION
 831: 0000: 
 832: 0000: 
 833: 0000: 
 834: 0000: \*****************************************************************************
 835: 0000: \***
 836: 0000: \***    WRITE RFCNTLST
 837: 0000: \***    Detail      : This function writes data to the report file(RFCNTLST.DAY)
 838: 0000: \***                  The data which has to be written to report, is
 839: 0000: \***                  stored in the variable RFCNTLST.RECORD$ which inturn is
 840: 0000: \***                  written to the report file.
 841: 0000: \***                  This section also adds prefixes like "0M", "1M", "2M",
 842: 0000: \***                  "3M" or "4M" based on the heading types, which helps in
 843: 0000: \***                  formatting the report in a user friendly way in POD/PDT
 844: 0000: \***
 845: 0000: \***..........................................................................
 846: 0000: 
 847: 0000: FUNCTION WRITE.RFCNTLST (TYPE$)
 848: 0019: 
 849: 0019:     STRING TYPE$
 850: 0019: 
 851: 0019:     FILE.OPERATION$     = "W"
 852: 0028:     CURRENT.REPORT.NUM% = RFCNTLST.REPORT.NUM%
 853: 0032:     CURRENT.TYPE$ = TYPE$
 854: 0041: 
 855: 0041:     !If CURRENT.TYPE$ is "0M", "1M", "2M", "3M" or "4M" then
 856: 0041:     !    line starts with that corresponding letter
 857: 0041:     !If CURRENT.TYPE$ is "" then line starts with
 858: 0041:     !    previous type + D
 859: 0041:     !Eg: If PREV.TYPE$ = "1M" and CURRENT.TYPE$ = "" then
 860: 0041:     !    line starts with (1+1)D ie 2D
 861: 0041: 
 862: 0041:     IF CURRENT.TYPE$ = "0M" THEN BEGIN
 863: 0054:         RFCNTLST.RECORD$ = "0M" + RFCNTLST.RECORD$
 864: 006c:         PREV.TYPE$ = CURRENT.TYPE$
 865: 0080:     ENDIF ELSE IF CURRENT.TYPE$ = "1M" THEN BEGIN
 866: 0093:         RFCNTLST.RECORD$ = "1M" + RFCNTLST.RECORD$
 867: 00ab:         PREV.TYPE$ = CURRENT.TYPE$
 868: 00bf:     ENDIF ELSE IF CURRENT.TYPE$ = "2M" THEN BEGIN
 869: 00d2:         RFCNTLST.RECORD$ = "2M" + RFCNTLST.RECORD$
 870: 00ea:         PREV.TYPE$ = CURRENT.TYPE$
 871: 00fe:     ENDIF ELSE IF CURRENT.TYPE$ = "3M" THEN BEGIN
 872: 0111:         RFCNTLST.RECORD$ = "3M" + RFCNTLST.RECORD$
 873: 0129:         PREV.TYPE$ = CURRENT.TYPE$
 874: 013d:     ENDIF ELSE IF CURRENT.TYPE$ = "4M" THEN BEGIN
 875: 0150:         RFCNTLST.RECORD$ = "4M" + RFCNTLST.RECORD$
 876: 0168:         PREV.TYPE$ = CURRENT.TYPE$
 877: 017b:     ENDIF ELSE IF CURRENT.TYPE$ = "" THEN BEGIN
 878: 018e:         RFCNTLST.RECORD$ =  STR$(VAL(LEFT$(PREV.TYPE$,1)) + 1 ) \
 879: 01f7:                             + "D" + RFCNTLST.RECORD$
 880: 01f7:     ENDIF
 881: 01f7: 
 882: 01f7:     WRITE # RFCNTLST.SESS.NUM% ;RFCNTLST.RECORD$
 883: 0212: 
 884: 0212: END FUNCTION
 885: 0223: 
 886: 0223: \******************************************************************************
 887: 0223: \***
 888: 0223: \***   Sub-Program : GET.OP.NAME
 889: 0223: \***   Detail      : This function key read the EALAUTH and returns the
 890: 0223: \***                 Operator Name corresponding to the Operator ID. IF an
 891: 0223: \***                 Op Name is not obtained, the "**No Op name**      "
 892: 0223: \***                 is returned
 893: 0223: \******************************************************************************
 894: 0223: 
 895: 0223: FUNCTION GET.OP.NAME$
 896: 0237: 
 897: 0237:     STRING GET.OP.NAME$
 898: 0237:     GET.OP.NAME$ = "**No Op name**      "
 899: 0245: 
 900: 0245:     IF UNPACK$(AF.OPERATOR.NO$) <> "00000000" THEN BEGIN
 901: 0271:         RC% = READ.AF
 902: 0279:         IF RC% = 0 AND AF.OPERATOR.NAME$ <> "" THEN BEGIN
 903: 02a9:             !Op Name padded with space upto 20 Chars
 904: 02a9:             GET.OP.NAME$ = LEFT$(AF.OPERATOR.NAME$ +(STRING$(20," ")), 20)
 905: 02ef:         ENDIF
 906: 02ef:     ENDIF
 907: 02ef: 
 908: 02ef: END FUNCTION
 909: 0300: 
 910: 0300: \******************************************************************************
 911: 0300: \******************************************************************************
 912: 0300: \***
 913: 0300: \***        S T A R T    O F    SUB PROGRAM
 914: 0300: \***
 915: 0300: \******************************************************************************
 916: 0300: \******************************************************************************
 917: 0300: 
 918: 0300: SUB MINRFCNT PUBLIC
 919: 0314: 
 920: 0314:     ON ERROR GOTO ERROR.DETECTED:
 921: 0321: 
 922: 0321:     ADXSERVE.DATA$ = "*** Creating RFCNTLST.DAY report ***"
 923: 032e:     GOSUB DISPLAY.MESSAGE
 924: 0338: 
 925: 0338:     GOSUB INITIALISATION
 926: 0342:     GOSUB CREATE.RF.COUNT.DETAIL
 927: 034c:     GOSUB CREATE.RF.COUNT.SUMMARY
 928: 0356:     GOSUB CREATE.RF.COUNT.REPORT
 929: 0360: 
 930: 0360: STOP.MINRFCNT:
 931: 0360: 
 932: 0360:     CLOSE CLOLF.SESS.NUM%
 933: 036c:     CLOSE CLILF.SESS.NUM%
 934: 0378:     CLOSE AF.SESS.NUM%
 935: 0384:     CLOSE RFCNTLST.SESS.NUM%
 936: 0390: 
 937: 0390:     GOSUB DEALLOCATE.SESSION.NUMBERS
 938: 039a: 
 939: 039a:     IF ERROR.COUNT% > 0 THEN BEGIN
 940: 03a1:         ADXSERVE.DATA$ = "*** RFCNTLST.DAY report processing error ***"
 941: 03ae:         GOSUB DISPLAY.MESSAGE
 942: 03ba:     ENDIF ELSE BEGIN
 943: 03ba:         ADXSERVE.DATA$ = "*** RFCNTLST.DAY report creation success ***"
 944: 03c7:         GOSUB DISPLAY.MESSAGE
 945: 03d1:         REPORTING.STATUS$ = "E"
 946: 03e0:     ENDIF
 947: 03e0: 
 948: 03e0:     EXIT SUB
 949: 03e3: 
 950: 03e3: \*****************************************************************************
 951: 03e3: \***
 952: 03e3: \***    INITIALISATION
 953: 03e3: \***    Detail        : Below mentioned are the main initialization done here.
 954: 03e3: \***                  1. Setting RFCNTLST.FILE.NAME$ and RFCNTLST.REPORT.NUM%
 955: 03e3: \***                  2. Initialise the F14.TABLE$ array
 956: 03e3: \***                  3. Initialise NUM.LISTS.ARRAY%, LISTS.COUNTED.ARRAY%,
 957: 03e3: \***                     PART.COUNT.ARRAY%, UNCOUNTED.ARRAY% array
 958: 03e3: \***                  4. Allocating Session Numbers
 959: 03e3: \***                  6. Opening Files
 960: 03e3: \***                  7. Creates the RFCNTLST file
 961: 03e3: \***
 962: 03e3: \***..........................................................................
 963: 03e3: 
 964: 03e3: INITIALISATION:
 965: 03e3: 
 966: 03e3:     ADXSERVE.DATA$ = "Initialisation - MINRFCNT"
 967: 03f0:     GOSUB DISPLAY.MESSAGE
 968: 03fa: 
 969: 03fa:     RFCNTLST.FILE.NAME$  = "ADXLXACN::D:/ADX_UDT1/RFCNTLST.DAY"
 970: 0407:     RFCNTLST.REPORT.NUM% = 426
 971: 040d:     FALSE = 0
 972: 0415:     TRUE  = -1
 973: 041d:     REPORTING.STATUS$ = "X"
 974: 042c: 
 975: 042c:     !Initializing the F14.TABLE$, NUM.LISTS.ARRAY%, LISTS.COUNTED.ARRAY%,
 976: 042c:     !PART.COUNT.ARRAY%, UNCOUNTED.ARRAY% arrays
 977: 042c:     F14.LIMIT% = 1000
 978: 0432:     DIM F14.TABLE$(F14.LIMIT%)
 979: 045b:     DIM NUM.LISTS.ARRAY%(1000)
 980: 047d:     DIM LISTS.COUNTED.ARRAY%(1000)
 981: 049f:     DIM PART.COUNT.ARRAY%(1000)
 982: 04c1:     DIM UNCOUNTED.ARRAY%(1000)
 983: 04e3: 
 984: 04e3:     GOSUB ALLOCATE.SESSION.NUMBERS
 985: 04ed:     GOSUB OPEN.FILES
 986: 04f7: 
 987: 04f7: RETURN
 988: 04ff: 
 989: 04ff: \*****************************************************************************
 990: 04ff: \***
 991: 04ff: \***    ALLOCATE.SESSION.NUMBERS
 992: 04ff: \***    Detail        : Perform CALL.F20.SESS.NUM.UTILITY to allocate
 993: 04ff: \***                    file session numbers for all files referenced
 994: 04ff: \***                    by the program.
 995: 04ff: \***
 996: 04ff: \***..........................................................................
 997: 04ff: 
 998: 04ff: ALLOCATE.SESSION.NUMBERS:
 999: 04ff: 
1000: 04ff:     ADXSERVE.DATA$ = "Allocating Session numbers - MINRFCNT"
1001: 050c:     GOSUB DISPLAY.MESSAGE
1002: 0516: 
1003: 0516:     CALL CLOLF.SET
1004: 0529:     CALL CLILF.SET
1005: 053c:     CALL AF.SET
1006: 0541: 
1007: 0541:     FUNCTION.FLAG$ EQ "O"
1008: 054e: 
1009: 054e:     PASSED.INTEGER% EQ CLOLF.REPORT.NUM%
1010: 0558:     PASSED.STRING$ EQ CLOLF.FILE.NAME$
1011: 056c:     GOSUB CALL.F20.SESS.NUM.UTILITY
1012: 0576:     CLOLF.SESS.NUM% EQ F20.INTEGER.FILE.NO%
1013: 0584: 
1014: 0584:     PASSED.INTEGER% EQ CLILF.REPORT.NUM%
1015: 058e:     PASSED.STRING$ EQ CLILF.FILE.NAME$
1016: 05a2:     GOSUB CALL.F20.SESS.NUM.UTILITY
1017: 05ac:     CLILF.SESS.NUM% EQ F20.INTEGER.FILE.NO%
1018: 05ba: 
1019: 05ba:     PASSED.INTEGER% EQ AF.REPORT.NUM%
1020: 05c5:     PASSED.STRING$ EQ AF.FILE.NAME$
1021: 05d9:     GOSUB CALL.F20.SESS.NUM.UTILITY
1022: 05e3:     AF.SESS.NUM% EQ F20.INTEGER.FILE.NO%
1023: 05f1: 
1024: 05f1:     PASSED.INTEGER% EQ RFCNTLST.REPORT.NUM%
1025: 05f7:     PASSED.STRING$ EQ RFCNTLST.FILE.NAME$
1026: 0608:     GOSUB CALL.F20.SESS.NUM.UTILITY
1027: 0612:     RFCNTLST.SESS.NUM% EQ F20.INTEGER.FILE.NO%
1028: 0620: 
1029: 0620:     ADXSERVE.DATA$ = "Session numbers allocating success - MINRFCNT"
1030: 062d:     GOSUB DISPLAY.MESSAGE
1031: 0637: 
1032: 0637: RETURN
1033: 063f: 
1034: 063f: \*****************************************************************************
1035: 063f: \***
1036: 063f: \***    CALL.F20.SESS.NUM.UTILITY:
1037: 063f: \***    Detail        : References SESS.NUM.UTILITY (F20) to create,
1038: 063f: \***                    read, or delete entry on Session Number Table as
1039: 063f: \***                    determined by FUNCTION.FLAG$ ("O" "R" "C").
1040: 063f: \***
1041: 063f: \***..........................................................................
1042: 063f: 
1043: 063f: CALL.F20.SESS.NUM.UTILITY:
1044: 063f: 
1045: 063f:     FUNCTION.RETURN.CODE% EQ    \
1046: 065e:         SESS.NUM.UTILITY        \
1047: 065e:         (FUNCTION.FLAG$,        \
1048: 065e:         PASSED.INTEGER%,        \
1049: 065e:         PASSED.STRING$)
1050: 065e: 
1051: 065e: RETURN
1052: 0666: 
1053: 0666: \*****************************************************************************
1054: 0666: \***
1055: 0666: \***    OPEN.FILES:
1056: 0666: \***    Detail          :Opens CLOLF, CLILF and AF Files.
1057: 0666: \***
1058: 0666: \***..........................................................................
1059: 0666: 
1060: 0666: OPEN.FILES:
1061: 0666: 
1062: 0666:     FILE.OPERATION$     = "O"
1063: 0675: 
1064: 0675:     CURRENT.REPORT.NUM% = CLOLF.REPORT.NUM%
1065: 0683:     OPEN CLOLF.FILE.NAME$ DIRECT RECL CLOLF.RECL% AS CLOLF.SESS.NUM%
1066: 06a9: 
1067: 06a9:     CURRENT.REPORT.NUM% = CLILF.REPORT.NUM%
1068: 06b7:     OPEN CLILF.FILE.NAME$ KEYED RECL CLILF.RECL% AS CLILF.SESS.NUM%
1069: 06db: 
1070: 06db:     CURRENT.REPORT.NUM% = AF.REPORT.NUM%
1071: 06ea:     OPEN AF.FILE.NAME$ KEYED RECL AF.RECL%                          \
1072: 070f:          AS AF.SESS.NUM% NOWRITE NODEL
1073: 070f: 
1074: 070f:     CURRENT.REPORT.NUM% = RFCNTLST.REPORT.NUM%
1075: 0719:     OPEN RFCNTLST.FILE.NAME$ AS RFCNTLST.SESS.NUM% APPEND
1076: 0735: 
1077: 0735:     ADXSERVE.DATA$ = "Opened CLILF/CLOLF Backup Files - MINRFCNT"
1078: 0742:     GOSUB DISPLAY.MESSAGE
1079: 074c: 
1080: 074c: RETURN
1081: 0754: 
1082: 0754: \*****************************************************************************
1083: 0754: \***
1084: 0754: \***    CREATE.RF.COUNT.DETAIL:
1085: 0754: \***    Detail        : Below mentioned are the main process done here.
1086: 0754: \***                    1. Calculates number of CLOLF records
1087: 0754: \***                    2. Reads each CLOLF record and write the necessary
1088: 0754: \***                       data to F14.TABLE
1089: 0754: \***                    3. Reads CLILF records corresponding to CLOLF record
1090: 0754: \***                       and gets the details of items not counted in list
1091: 0754: \***                    4. Sort F14.TABLE
1092: 0754: \***
1093: 0754: \***..........................................................................
1094: 0754: 
1095: 0754: CREATE.RF.COUNT.DETAIL:
1096: 0754: 
1097: 0754:     ADXSERVE.DATA$ = "Processing CLOLF.BIN File - MINRFCNT"
1098: 0761:     GOSUB DISPLAY.MESSAGE
1099: 076b: 
1100: 076b:     !Reading CLOLF and getting the number of records
1101: 076b:     CLOLF.NUMRECS% = (SIZE(CLOLF.FILE.NAME$) / CLOLF.RECL%)
1102: 0795:     CURR.RECORD.INDEX% = 1
1103: 079b: 
1104: 079b:     FOR CLOLF.RECORD.NUM% = 1 TO CLOLF.NUMRECS%
1105: 07ad: 
1106: 07ad:         FILE.OPERATION$     = "R"
1107: 07bc:         CURRENT.REPORT.NUM% = CLOLF.REPORT.NUM%
1108: 07ca:         RC% = READ.CLOLF
1109: 07d2: 
1110: 07d2:         IF CLOLF.LSTTYP$ = "N" OR CLOLF.LSTTYP$ = "H" OR \
1111: 0847:            CLOLF.LSTTYP$ = "U" THEN BEGIN
1112: 0847: 
1113: 0847:             !Setting CURR.LIST.TYPE$ for sorting purpose
1114: 0847: !            IF CLOLF.LSTTYP$ = "N" THEN BEGIN                        ! CCsk
1115: 0847: !                CURR.LIST.TYPE$ = "1"                                ! CCsk
1116: 0847: !            ENDIF ELSE IF CLOLF.LSTTYP$ = "H" THEN BEGIN             ! CCsk
1117: 0847: !                CURR.LIST.TYPE$ = "2"                                ! CCsk
1118: 0847: !            ENDIF ELSE IF CLOLF.LSTTYP$ = "U" THEN BEGIN             ! CCsk
1119: 0847: !                CURR.LIST.TYPE$ = "3"                                ! CCsk
1120: 0847: !            ENDIF                                                    ! CCsk
1121: 0847:             IF CLOLF.LSTTYP$ = "N" THEN BEGIN
1122: 085d:                 CURR.LIST.TYPE$ = "1"
1123: 086c:             ENDIF ELSE IF CLOLF.LSTTYP$ = "U" THEN BEGIN              ! CCsk
1124: 0882:                 CURR.LIST.TYPE$ = "2"
1125: 0891:             ENDIF ELSE IF CLOLF.LSTTYP$ = "H" THEN BEGIN              ! CCsk
1126: 08a7:                 CURR.LIST.TYPE$ = "3"
1127: 08b4:             ENDIF
1128: 08b4: 
1129: 08b4:             !Setting CURR.CNT.STATUS$ for sorting & filtering purpose
1130: 08b4:             IF CLOLF.ACTIVE.STATUS$ = "C" THEN BEGIN
1131: 08ca:                 CURR.CNT.STATUS$ = "1"
1132: 08d9:             ENDIF ELSE IF CLOLF.ACTIVE.STATUS$ = "P" THEN BEGIN
1133: 08ef:                 CURR.CNT.STATUS$ = "2"
1134: 08fe:             ENDIF ELSE IF CLOLF.ACTIVE.STATUS$ = "I" THEN BEGIN
1135: 0914:                 CURR.CNT.STATUS$ = "3"
1136: 0923:             ENDIF ELSE IF CLOLF.ACTIVE.STATUS$ = " " THEN BEGIN       ! ETT
1137: 0939:                 CURR.CNT.STATUS$ = "4"                                ! ETT
1138: 0946:             ENDIF
1139: 0946: 
1140: 0946:             ITEMS.NOT.COUNTED% = 0
1141: 094c:             ADXSERVE.DATA$ = "Processing CLILF for CLOLF record " \
1142: 097b:                              + STR$(CLOLF.RECORD.NUM%) + " - MINRFCNT"
1143: 097b:             GOSUB DISPLAY.MESSAGE
1144: 0985: 
1145: 0985:             !Reading CLILF and getting the count of items with
1146: 0985:             !CLILF.COUNTED.STATUS$ = "P" OR CLILF.COUNTED.STATUS$ = "U"
1147: 0985:             !(Items not counted)
1148: 0985: 
1149: 0985:             CLILF.LISTID$  = CLOLF.LISTID$                                 ! CCSk
1150: 099b: 
1151: 099b:             FOR CLILF.COUNTER% = 1 TO CLOLF.TOTAL.ITEMS%
1152: 09a4: 
1153: 09a4:                 !CLILF.LISTID$  = CLOLF.LISTID$                            ! CCsk
1154: 09a4:                 CLILF.ITEMSEQ$ = RIGHT$("000" + STR$(CLILF.COUNTER%),3)
1155: 09e2:                 !FILE.OPERATION$     = "R"                                 ! CCSk
1156: 09e2:                 !CURRENT.REPORT.NUM% = CLILF.REPORT.NUM%                   ! CCSk
1157: 09e2:                 RC% = READ.CLILF
1158: 09ea: 
1159: 09ea:                 IF CLILF.COUNTED.STATUS$ = "P" OR \
1160: 0a34:                     CLILF.COUNTED.STATUS$ = "U" THEN BEGIN
1161: 0a34:                     ITEMS.NOT.COUNTED% = ITEMS.NOT.COUNTED% + 1
1162: 0a38:                 ENDIF
1163: 0a38: 
1164: 0a38:             NEXT CLILF.COUNTER%
1165: 0a4f: 
1166: 0a4f:             IF CLOLF.TOTAL.ITEMS% > 0 AND CURR.CNT.STATUS$ <> "4" THEN BEGIN   ! ETT
1167: 0a89:                 CURR.RECORD$ =  CURR.LIST.TYPE$                             + \
1168: 0ba7:                                 CURR.CNT.STATUS$                            + \
1169: 0ba7:                                 UNPACK$(CLOLF.CREATION.DATE$)               + \
1170: 0ba7:                                 UNPACK$(CLOLF.CREATION.TIME$)               + \
1171: 0ba7:                                 CLOLF.PICKER.USER.ID$                       + \
1172: 0ba7:                                 CLOLF.LISTID$                               + \
1173: 0ba7:                                 RIGHT$("000" + STR$(CLOLF.TOTAL.ITEMS%), 3) + \
1174: 0ba7:                                 UNPACK$(CLOLF.PICK.START.TIME$)             + \
1175: 0ba7:                                 UNPACK$(CLOLF.PICK.END.TIME$)               + \
1176: 0ba7:                                 CLOLF.USERID$ + \
1177: 0ba7:                                 RIGHT$("000" + STR$(ITEMS.NOT.COUNTED%), 3)
1178: 0ba7: 
1179: 0ba7:                 F14.TABLE$(CURR.RECORD.INDEX%) = CURR.RECORD$
1180: 0bc8:                 CURR.RECORD.INDEX% = CURR.RECORD.INDEX% + 1
1181: 0bcc:             ENDIF                                                              ! ETT
1182: 0bcc: 
1183: 0bcc:             IF CURR.RECORD.INDEX% = F14.LIMIT% THEN BEGIN
1184: 0bd5: 
1185: 0bd5:                 !The F14.TABLE$ array has reached its max limit, hence stop
1186: 0bd5:                 !processing further CLOLF/CLILF and continue the report
1187: 0bd5:                 !generation
1188: 0bd5: 
1189: 0bd5:                 ADXSERVE.DATA$ = "F14.TABLE$ array limit exceeded, the program "
1190: 0be2:                 GOSUB DISPLAY.MESSAGE
1191: 0bec:                 ADXSERVE.DATA$ = "will not generate the complete report "
1192: 0bf9:                 GOSUB DISPLAY.MESSAGE
1193: 0c03: 
1194: 0c03:                 !Set the variables to exit both the FOR loop
1195: 0c03:                 CLOLF.RECORD.NUM% = CLOLF.NUMRECS%
1196: 0c14: 
1197: 0c14:             ENDIF
1198: 0c14:         ENDIF
1199: 0c14:     NEXT CLOLF.RECORD.NUM%
1200: 0c3d: 
1201: 0c3d:     !Total no: of records in F14.TABLE$
1202: 0c3d:     F14TABLE.MAX.INDEX% = CURR.RECORD.INDEX% - 1
1203: 0c44: 
1204: 0c44: !       F14.TABLE LAYOUT
1205: 0c44: !
1206: 0c44: !    |---------|-------|-----------|------------------------------------|
1207: 0c44: !    |   From  |  To   |   Length  |    Name                            |
1208: 0c44: !    |---------|-------|-----------|------------------------------------|
1209: 0c44: !    |   1     |  1    |   1       |    CURR.LIST.TYPE$                 |
1210: 0c44: !    |   2     |  2    |   1       |    CURR.CNT.STATUS$                |
1211: 0c44: !    |   3     |  8    |   6       |    UNPACK$(CLOLF.CREATION.DATE$)   |
1212: 0c44: !    |   9     |  12   |   4       |    UNPACK$(CLOLF.CREATION.TIME$)   |
1213: 0c44: !    |   13    |  15   |   3       |    CLOLF.PICKER.USER.ID$           |
1214: 0c44: !    |   16    |  18   |   3       |    CLOLF.LISTID$                   |
1215: 0c44: !    |   19    |  21   |   3       |    STR$(CLOLF.TOTAL.ITEMS%)        |
1216: 0c44: !    |   22    |  25   |   4       |    UNPACK$(CLOLF.PICK.START.TIME$) |
1217: 0c44: !    |   26    |  29   |   4       |    UNPACK$(CLOLF.PICK.END.TIME$)   |
1218: 0c44: !    |   30    |  32   |   3       |    CLOLF.USERID$                   |
1219: 0c44: !    |   33    |  35   |   3       |    STR$(ITEMS.NOT.COUNTED%)        |
1220: 0c44: !    |---------|-------|-----------|------------------------------------|
1221: 0c44: 
1222: 0c44:     !Sorting F14.TABLE$
1223: 0c44:     CALL SORT.TABLE (F14TABLE.MAX.INDEX%)
1224: 0c4c: 
1225: 0c4c: RETURN
1226: 0c54: 
1227: 0c54: \*****************************************************************************
1228: 0c54: \***
1229: 0c54: \***    CREATE.RF.COUNT.SUMMARY:
1230: 0c54: \***    Detail        : Below mentioned are the main process done here.
1231: 0c54: \***                    1. Initialise the arrays NUM.LISTS.ARRAY%,
1232: 0c54: \***                       LISTS.COUNTED.ARRAY%, PART.COUNT.ARRAY%,
1233: 0c54: \***                       UNCOUNTED.ARRAY%
1234: 0c54: \***                    2. Writes the date and time in the report
1235: 0c54: \***                    3. Processes F14.TABLE and checks the value of
1236: 0c54: \***                       CURR.CNT.STATUS$ and setting the arrays
1237: 0c54: \***                       NUM.LISTS.ARRAY%, LISTS.COUNTED.ARRAY%,
1238: 0c54: \***                       PART.COUNT.ARRAY%, UNCOUNTED.ARRAY%
1239: 0c54: \***                    4. Writes the details to the report
1240: 0c54: \***
1241: 0c54: \***..........................................................................
1242: 0c54: 
1243: 0c54: CREATE.RF.COUNT.SUMMARY:
1244: 0c54: 
1245: 0c54:     ADXSERVE.DATA$ = "Processing RF.COUNT.SUMMARY - MINRFCNT "
1246: 0c61:     GOSUB DISPLAY.MESSAGE
1247: 0c6b: 
1248: 0c6b:     !Initialise the arrays NUM.LISTS.ARRAY%, LISTS.COUNTED.ARRAY%
1249: 0c6b:     !PART.COUNT.ARRAY%,UNCOUNTED.ARRAY%
1250: 0c6b: 
1251: 0c6b:     FOR COUNTER% = 1 TO 3
1252: 0c72:         NUM.LISTS.ARRAY%(COUNTER%) = 0
1253: 0c87:         LISTS.COUNTED.ARRAY%(COUNTER%) = 0
1254: 0c9c:         PART.COUNT.ARRAY%(COUNTER%) = 0
1255: 0cb1:         UNCOUNTED.ARRAY%(COUNTER%) = 0
1256: 0cc6:     NEXT COUNTER%
1257: 0cd5: 
1258: 0cd5:     !Writes the date and time in the report
1259: 0cd5: !    RFCNTLST.RECORD$  = RIGHT$(DATE$, 2)    + "/"  + \               !BTT
1260: 0cd5: !                        MID$(DATE$,3,2)     + "/"  + \               !BTT
1261: 0cd5: !                        "20" + LEFT$(DATE$, 2)     + \               !BTT
1262: 0cd5: !                        " at " + MID$(TIME$,1,2)   + \               !BTT
1263: 0cd5: !                        ":" + MID$(TIME$,3,2) + " "                  !BTT
1264: 0cd5:     RFCNTLST.RECORD$  = " " + RIGHT$(DATE$, 2) + "/"    + \           !BTT
1265: 0dab:                               MID$(DATE$,3,2)  + "/"    + \           !BTT
1266: 0dab:                               LEFT$(DATE$, 2)  + " at " + \           !BTT
1267: 0dab:                               MID$(TIME$,1,2)  + ":"    + \           !BTT
1268: 0dab:                               MID$(TIME$,3,2)  + "  "                 !BTT
1269: 0dab:     CALL WRITE.RFCNTLST("0M")
1270: 0dc4: 
1271: 0dc4:     RFCNTLST.RECORD$ = "Count List Summary  "
1272: 0dd1:     CALL WRITE.RFCNTLST("1M")
1273: 0dea: 
1274: 0dea:     !Counter 1 to 3 is used for the three lists
1275: 0dea:     !Negative Lists,User Generated Lists,Support Office Lists
1276: 0dea: 
1277: 0dea:     FOR COUNTER% = 1 TO 3
1278: 0df2: 
1279: 0df2:         !Reading F14.TABLE one by one
1280: 0df2:         FOR CURR.RECORD.INDEX% = 1 to F14TABLE.MAX.INDEX%
1281: 0dfb: 
1282: 0dfb:             !Checking each record corresponds to the list specified
1283: 0dfb:             !in COUNTER%
1284: 0dfb:             !Checking whether the list is created today or not
1285: 0dfb:             
1286: 0dfb:             ! Commented the line of code which checks the CLOLF creation    ! FRG
1287: 0dfb:             ! date against DATE$. After 16A MINPRINT gets triggered after   ! FRG
1288: 0dfb:             ! 12.00 clock, by which condition check always fails .          ! FRG
1289: 0dfb:             ! Amended the code so that, date$ is subtracted by one and      ! FRG
1290: 0dfb:             ! Checked against CLOLF creation                                ! FRG
1291: 0dfb: 
1292: 0dfb:             F02.DATE$ = DATE$                                               ! FRG
1293: 0e0b:             CALL UPDATE.DATE(-1)                                            ! FRG
1294: 0e1b: 
1295: 0e1b:             IF (LEFT$(F14.TABLE$(CURR.RECORD.INDEX%), 1) = STR$(COUNTER%))  \ FRG
1296: 0eac:                 AND (UNPACK$(CLOLF.CREATION.DATE$) = F02.DATE$) THEN BEGIN  ! FRG
1297: 0eac: 
1298: 0eac:             !   AND (UNPACK$(CLOLF.CREATION.DATE$) = DATE$) THEN BEGIN      ! FRG  
1299: 0eac: 
1300: 0eac:                 NUM.LISTS.ARRAY%(COUNTER%) = NUM.LISTS.ARRAY%(COUNTER%) + 1
1301: 0ebf: 
1302: 0ebf:                 !Checking CURR.CNT.STATUS$ from F14.TABLE and getting the
1303: 0ebf:                 !values in the arrays LISTS.COUNTED.ARRAY%, PART.COUNT.ARRAY%
1304: 0ebf:                 !and UNCOUNTED.ARRAY%
1305: 0ebf: 
1306: 0ebf:                 IF MID$(F14.TABLE$(CURR.RECORD.INDEX%),2,1) = "1" THEN BEGIN
1307: 0efa:                     LISTS.COUNTED.ARRAY%(COUNTER%) = LISTS.COUNTED.ARRAY%       \
1308: 0f10:                                                      (COUNTER%) + 1
1309: 0f10:                 ENDIF ELSE IF MID$(F14.TABLE$(CURR.RECORD.INDEX%),2,1) = "2"    \
1310: 0f4b:                               THEN BEGIN
1311: 0f4b:                     PART.COUNT.ARRAY%(COUNTER%) = PART.COUNT.ARRAY%(COUNTER%)   \
1312: 0f60:                                                   + 1
1313: 0f60:                 ENDIF ELSE IF MID$(F14.TABLE$(CURR.RECORD.INDEX%),2,1) = "3"    \
1314: 0f9b:                               THEN BEGIN
1315: 0f9b:                     UNCOUNTED.ARRAY%(COUNTER%) = UNCOUNTED.ARRAY%(COUNTER%) + 1
1316: 0fae:                 ENDIF
1317: 0fae: 
1318: 0fae:             ENDIF
1319: 0fae:         NEXT CURR.RECORD.INDEX%
1320: 0fc1: 
1321: 0fc1:         RFCNTLST.RECORD$ = "                    "
1322: 0fce:         CALL WRITE.RFCNTLST ("")
1323: 0fe7: 
1324: 0fe7:         !Writing the data to the report
1325: 0fe7:         IF COUNTER% = 1 THEN BEGIN
1326: 0fee:             RFCNTLST.RECORD$ = "Negative Lists      "
1327: 0ffd:         ENDIF ELSE IF COUNTER% = 2 THEN BEGIN
1328: 1004:             !RFCNTLST.RECORD$ = "User Generated Lists"                   ! CCSk
1329: 1004:             !RFCNTLST.RECORD$ = "Support Office Lists"                   ! CCSk ! DTT
1330: 1004:             RFCNTLST.RECORD$ = "User Generated Lists"                    ! DTT
1331: 1013:         ENDIF ELSE IF COUNTER% = 3 THEN BEGIN
1332: 101a:             !RFCNTLST.RECORD$ = "Support Office Lists"                   ! CCSk
1333: 101a:             !RFCNTLST.RECORD$ = "User Generated Lists"                   ! CCSk ! DTT
1334: 101a:             RFCNTLST.RECORD$ = "Support Office Lists"                    ! DTT
1335: 1027:         ENDIF
1336: 1027:         CALL WRITE.RFCNTLST ("")
1337: 1040: 
1338: 1040:         RFCNTLST.RECORD$ = "Num Lists Today "                       + \
1339: 10a2:                             RIGHT$( "   "                           + \
1340: 10a2:                             STR$(NUM.LISTS.ARRAY%(COUNTER%)),3)     + \
1341: 10a2:                             " "
1342: 10a2:         CALL WRITE.RFCNTLST ("")
1343: 10bb: 
1344: 10bb:         RFCNTLST.RECORD$ = "Lists counted   "                       + \
1345: 111d:                             RIGHT$( "   "                           + \
1346: 111d:                             STR$(LISTS.COUNTED.ARRAY%(COUNTER%)),3) + \
1347: 111d:                             " "
1348: 111d:         CALL WRITE.RFCNTLST ("")
1349: 1136: 
1350: 1136:         RFCNTLST.RECORD$ = "Part counted    "                       + \
1351: 1198:                             RIGHT$( "   "                           + \
1352: 1198:                             STR$(PART.COUNT.ARRAY%(COUNTER%)),3)    + \
1353: 1198:                             " "
1354: 1198:         CALL WRITE.RFCNTLST ("")
1355: 11b1: 
1356: 11b1:         RFCNTLST.RECORD$ = "Lists uncounted "                       + \
1357: 1213:                             RIGHT$( "   "                           + \
1358: 1213:                             STR$(UNCOUNTED.ARRAY%(COUNTER%)),3)     + \
1359: 1213:                             " "
1360: 1213:         CALL WRITE.RFCNTLST ("")
1361: 122c: 
1362: 122c:     NEXT COUNTER%
1363: 123e: 
1364: 123e:     RFCNTLST.RECORD$ = "--------------------"
1365: 124b:     CALL WRITE.RFCNTLST ("")
1366: 1264: 
1367: 1264: RETURN
1368: 126c: 
1369: 126c: \*****************************************************************************
1370: 126c: \***
1371: 126c: \***    CREATE.RF.COUNT.REPORT:
1372: 126c: \***    Detail        : Below mentioned are the main process done here.
1373: 126c: \***                    1. If F14 TABLE has no records, write the blank records
1374: 126c: \***                       Counted Lists, Part Counted Lists and Uncounted Lists
1375: 126c: \***                    2. Process F14.TABLE and write the data to the report
1376: 126c: \***
1377: 126c: \***..........................................................................
1378: 126c: 
1379: 126c: CREATE.RF.COUNT.REPORT:
1380: 126c: 
1381: 126c:     ADXSERVE.DATA$ = "Processing RF.COUNT.REPORT - MINRFCNT "
1382: 1279:     GOSUB DISPLAY.MESSAGE
1383: 1283: 
1384: 1283:     FOR COUNTER% = 1 TO 3
1385: 128b: 
1386: 128b:         IF COUNTER% = 1 THEN BEGIN
1387: 1292:             RFCNTLST.RECORD$ = "Negative Lists      "
1388: 12a1:         ENDIF ELSE IF COUNTER% = 2 THEN BEGIN
1389: 12a8:             !RFCNTLST.RECORD$ = "User Generated Lists"                   ! CCSk
1390: 12a8:             !RFCNTLST.RECORD$ = "Support Office Lists"                   ! CCSk ! DTT
1391: 12a8:             RFCNTLST.RECORD$ = "User Generated Lists"                    ! DTT
1392: 12b7:         ENDIF ELSE IF COUNTER% = 3 THEN BEGIN
1393: 12be:             !RFCNTLST.RECORD$ = "Support Office Lists"                   ! CCSk
1394: 12be:             !RFCNTLST.RECORD$ = "User Generated Lists"                   ! CCSk ! DTT
1395: 12be:             RFCNTLST.RECORD$ = "Support Office Lists"                    ! DTT
1396: 12cb:         ENDIF
1397: 12cb:         CALL WRITE.RFCNTLST ("1M")
1398: 12e4: 
1399: 12e4:         !If F14 TABLE has no records, write the blank records
1400: 12e4:         !Counted Lists, Part Counted Lists and Uncounted Lists
1401: 12e4: 
1402: 12e4:         IF F14TABLE.MAX.INDEX% = 1 THEN BEGIN
1403: 12eb:             RFCNTLST.RECORD$ = "Counted Lists       "
1404: 12f8:             CALL WRITE.RFCNTLST ("2M")
1405: 1311:             RFCNTLST.RECORD$ = "Part Counted Lists  "
1406: 131e:             CALL WRITE.RFCNTLST ("2M")
1407: 1337:             RFCNTLST.RECORD$ = "Uncounted Lists     "
1408: 1344:             CALL WRITE.RFCNTLST ("2M")
1409: 135d:         ENDIF
1410: 135d: 
1411: 135d:         PREV.CNT.STATUS$ = " "
1412: 136a: 
1413: 136a:         !Reading F14.TABLE one by one
1414: 136a:         FOR CURR.RECORD.INDEX% = 1 TO F14TABLE.MAX.INDEX%
1415: 1373: 
1416: 1373:             !Checking each record corresponds to the list specified in
1417: 1373:             !COUNTER% and CLOLF creation date matches with current date.
1418: 1373: 
1419: 1373:            ! Commented the line of code which checks the CLOLF creation    ! FRG
1420: 1373:            ! date against DATE$. After 16A, MINPRINT gets triggered after  ! FRG
1421: 1373:            ! 12.00 clock, due to that below date check condition fails     ! FRG
1422: 1373:            ! and doesn't write to the RFCNTLST.DAY file                    ! FRG
1423: 1373: 
1424: 1373: 
1425: 1373:             F02.DATE$ = DATE$                                              ! FRG
1426: 1383:             CALL UPDATE.DATE(-1)                                           ! FRG
1427: 1393: 
1428: 1393:             IF (LEFT$(F14.TABLE$(CURR.RECORD.INDEX%), 1) = STR$(COUNTER%)) \ FRG
1429: 1436:                 AND (MID$(F14.TABLE$(CURR.RECORD.INDEX%),3,6) = F02.DATE$) \ FRG
1430: 1436:                 THEN BEGIN                                                 ! FRG
1431: 1436: 
1432: 1436:                !AND (MID$(F14.TABLE$(CURR.RECORD.INDEX%),3,6) = DATE$)     \ FRG
1433: 1436:                 
1434: 1436: 
1435: 1436:                 CURR.CNT.STATUS$ = MID$(F14.TABLE$(CURR.RECORD.INDEX%),2,1)
1436: 1461: 
1437: 1461:                 !Getting CURR.CNT.STATUS$ from F14.TABLE
1438: 1461:                 IF CURR.CNT.STATUS$ = "1" THEN BEGIN
1439: 1477: 
1440: 1477:                     !Checks the Current Status to verify that
1441: 1477:                     !    PREV.CNT.STATUS$ <> CURR.CNT.STATUS$
1442: 1477:                     !If PREV.CNT.STATUS$ <> CURR.CNT.STATUS$ then
1443: 1477:                     !    print the header
1444: 1477: 
1445: 1477:                     IF PREV.CNT.STATUS$ <> CURR.CNT.STATUS$ THEN BEGIN
1446: 148e:                         RFCNTLST.RECORD$ = "Counted Lists       "
1447: 149b:                         CALL WRITE.RFCNTLST ("2M")
1448: 14b4:                     ENDIF
1449: 14b4: 
1450: 14b4:                     !If the list is User generated list, write the time
1451: 14b4:                     !and the user created the list in the report
1452: 14b4: 
1453: 14b4:                     IF COUNTER% = 2 THEN BEGIN
1454: 14be:                         AF.OPERATOR.NO$ = PACK$(RIGHT$(("00000000" +            \
1455: 1518:                                           MID$(F14.TABLE$(CURR.RECORD.INDEX%),  \
1456: 1518:                                           30,3)),8))
1457: 1518:                         CALL GET.OP.NAME$
1458: 151c:                         RFCNTLST.RECORD$ = MID$(F14.TABLE$(CURR.RECORD.INDEX%), \
1459: 15a2:                                            9,2) + ":" +                         \    ! CCSK
1460: 15a2:                                            MID$(F14.TABLE$(CURR.RECORD.INDEX%), \
1461: 15a2:                                            11,2) + " " +                        \
1462: 15a2:                                            LEFT$(GET.OP.NAME$,14) ! OP NAME SET TO 14 CHARACTERS
1463: 15a2:                         CALL WRITE.RFCNTLST ("3M")
1464: 15bb:                     ENDIF
1465: 15bb: 
1466: 15bb:                     RFCNTLST.RECORD$ =  "List " +                               \
1467: 166f:                                         MID$(F14.TABLE$(CURR.RECORD.INDEX%),    \
1468: 166f:                                         16,3) + " " +                           \
1469: 166f:                                         RIGHT$("   " + STR$(VAL(MID$(F14.TABLE$ \
1470: 166f:                                         (CURR.RECORD.INDEX%),19,3))), 3) +      \
1471: 166f:                                         " items  "
1472: 166f:                     CALL WRITE.RFCNTLST ("")
1473: 1688: 
1474: 1688:                     RFCNTLST.RECORD$ =  "from " +                               \
1475: 175c:                                         MID$(F14.TABLE$(CURR.RECORD.INDEX%),    \
1476: 175c:                                         22,2) + ":" +                           \
1477: 175c:                                         MID$(F14.TABLE$(CURR.RECORD.INDEX%),    \
1478: 175c:                                         24,2) + " to " +                        \
1479: 175c:                                         MID$(F14.TABLE$(CURR.RECORD.INDEX%),    \
1480: 175c:                                         26,2) + ":" +                           \
1481: 175c:                                         MID$(F14.TABLE$(CURR.RECORD.INDEX%),    \
1482: 175c:                                         28,2) + " "
1483: 175c:                     CALL WRITE.RFCNTLST ("")
1484: 1775: 
1485: 1775:                     !Set the key for reading the EALAUTH
1486: 1775:                     AF.OPERATOR.NO$ = PACK$(RIGHT$(("00000000" + \
1487: 17cf:                                       MID$(F14.TABLE$(CURR.RECORD.INDEX%),      \
1488: 17cf:                                       13,3)),8))
1489: 17cf:                     CALL GET.OP.NAME$
1490: 17d3: 
1491: 17d3:                     RFCNTLST.RECORD$ =  "By " + LEFT$(GET.OP.NAME$,17)
1492: 17fb:                     CALL WRITE.RFCNTLST ("")
1493: 1814:                     PREV.CNT.STATUS$ = CURR.CNT.STATUS$
1494: 1828: 
1495: 1828:                 ENDIF ELSE IF CURR.CNT.STATUS$ = "2" THEN BEGIN
1496: 183e: 
1497: 183e:                     IF PREV.CNT.STATUS$ = " " THEN BEGIN
1498: 1851:                         RFCNTLST.RECORD$ = "Counted Lists       "
1499: 185e:                         CALL WRITE.RFCNTLST ("2M")
1500: 1877:                     ENDIF
1501: 1877: 
1502: 1877:                     !Checks the Current Status to verify that
1503: 1877:                     !    PREV.CNT.STATUS$ <> CURR.CNT.STATUS$
1504: 1877:                     !If PREV.CNT.STATUS$ <> CURR.CNT.STATUS$ then
1505: 1877:                     !    print the header
1506: 1877: 
1507: 1877:                     IF PREV.CNT.STATUS$ <> CURR.CNT.STATUS$ THEN BEGIN
1508: 188e:                         RFCNTLST.RECORD$ = "Part Counted Lists  "
1509: 189b:                         CALL WRITE.RFCNTLST ("2M")
1510: 18b4:                     ENDIF
1511: 18b4: 
1512: 18b4:                     !If the list is User generated list, write the time
1513: 18b4:                     !and the user created the list in the report
1514: 18b4: 
1515: 18b4:                     IF COUNTER% = 2 THEN BEGIN
1516: 18be:                         AF.OPERATOR.NO$ = PACK$(RIGHT$(("00000000" +            \
1517: 1918:                                           MID$(F14.TABLE$(CURR.RECORD.INDEX%),  \
1518: 1918:                                           30,3)),8))
1519: 1918:                         CALL GET.OP.NAME$
1520: 191c:                         RFCNTLST.RECORD$ = MID$(F14.TABLE$(CURR.RECORD.INDEX%), \
1521: 19a2:                                            9,2) + ":" +                         \      ! CCSK
1522: 19a2:                                            MID$(F14.TABLE$(CURR.RECORD.INDEX%), \
1523: 19a2:                                            11,2) + " " +                        \
1524: 19a2:                                            LEFT$(GET.OP.NAME$,14) ! OP NAME SET TO 14 CHARACTERS
1525: 19a2:                         CALL WRITE.RFCNTLST ("3M")
1526: 19bb:                     ENDIF
1527: 19bb: 
1528: 19bb:                     RFCNTLST.RECORD$ =  "List " +                               \
1529: 1a6f:                                         MID$(F14.TABLE$(CURR.RECORD.INDEX%),    \
1530: 1a6f:                                         16,3) + " " +                           \
1531: 1a6f:                                         RIGHT$("   "+ STR$(VAL(MID$(F14.TABLE$  \
1532: 1a6f:                                         (CURR.RECORD.INDEX%),19,3))), 3) +      \
1533: 1a6f:                                         " items  "
1534: 1a6f:                     CALL WRITE.RFCNTLST ("")
1535: 1a88: 
1536: 1a88:                     RFCNTLST.RECORD$ =  "Uncounted " + RIGHT$("   " +           \
1537: 1b0b:                                         STR$(VAL(MID$(F14.TABLE$                \
1538: 1b0b:                                         (CURR.RECORD.INDEX%),33,3))), 3) +      \
1539: 1b0b:                                         " items "
1540: 1b0b:                     CALL WRITE.RFCNTLST ("")
1541: 1b24: 
1542: 1b24:                     RFCNTLST.RECORD$ =  "from " + MID$(F14.TABLE$               \
1543: 1bf8:                                         (CURR.RECORD.INDEX%),22,2) +            \
1544: 1bf8:                                         ":" + MID$(F14.TABLE$                   \
1545: 1bf8:                                         (CURR.RECORD.INDEX%),24,2) +            \
1546: 1bf8:                                         + " to " + MID$(F14.TABLE$              \
1547: 1bf8:                                         (CURR.RECORD.INDEX%),26,2) +            \
1548: 1bf8:                                         ":" + MID$(F14.TABLE$                   \
1549: 1bf8:                                         (CURR.RECORD.INDEX%),28,2) + " "
1550: 1bf8:                     CALL WRITE.RFCNTLST ("")
1551: 1c11: 
1552: 1c11:                     !Set the key for reading the EALAUTH
1553: 1c11:                     AF.OPERATOR.NO$ = PACK$(RIGHT$(("00000000" +                \
1554: 1c6b:                                       MID$(F14.TABLE$(CURR.RECORD.INDEX%),      \
1555: 1c6b:                                       13,3)),8))
1556: 1c6b:                     CALL GET.OP.NAME$
1557: 1c6f: 
1558: 1c6f:                     RFCNTLST.RECORD$ =  "By " + LEFT$(GET.OP.NAME$,17)
1559: 1c97:                     CALL WRITE.RFCNTLST ("")
1560: 1cb0:                     PREV.CNT.STATUS$ = CURR.CNT.STATUS$
1561: 1cc4: 
1562: 1cc4:                 ENDIF ELSE IF CURR.CNT.STATUS$ = "3" THEN BEGIN
1563: 1cda: 
1564: 1cda:                     IF PREV.CNT.STATUS$ = " " THEN BEGIN
1565: 1ced:                         RFCNTLST.RECORD$ = "Counted Lists       "
1566: 1cfa:                         CALL WRITE.RFCNTLST ("2M")
1567: 1d13:                         RFCNTLST.RECORD$ = "Part Counted Lists  "
1568: 1d20:                         CALL WRITE.RFCNTLST ("2M")
1569: 1d3b:                     ENDIF ELSE IF PREV.CNT.STATUS$ = "1" THEN BEGIN
1570: 1d4e:                         RFCNTLST.RECORD$ = "Part Counted Lists  "
1571: 1d5b:                         CALL WRITE.RFCNTLST ("2M")
1572: 1d74:                     ENDIF
1573: 1d74: 
1574: 1d74:                     !Checks the Current Status to verify that
1575: 1d74:                     !    PREV.CNT.STATUS$ <> CURR.CNT.STATUS$
1576: 1d74:                     !If PREV.CNT.STATUS$ <> CURR.CNT.STATUS$ then
1577: 1d74:                     !    print the header
1578: 1d74: 
1579: 1d74:                     IF PREV.CNT.STATUS$ <> CURR.CNT.STATUS$ THEN BEGIN
1580: 1d8b:                         RFCNTLST.RECORD$ = "Uncounted Lists     "
1581: 1d98:                         CALL WRITE.RFCNTLST ("2M")
1582: 1db1:                     ENDIF
1583: 1db1: 
1584: 1db1:                     !If the list is User generated list, write the time
1585: 1db1:                     !and the user created the list in the report
1586: 1db1: 
1587: 1db1:                     IF COUNTER% = 2 THEN BEGIN
1588: 1dbb:                         AF.OPERATOR.NO$ = PACK$(RIGHT$(("00000000" +            \
1589: 1e15:                                           MID$(F14.TABLE$(CURR.RECORD.INDEX%),  \
1590: 1e15:                                           30,3)),8))
1591: 1e15:                         CALL GET.OP.NAME$
1592: 1e19:                         RFCNTLST.RECORD$ = MID$(F14.TABLE$(CURR.RECORD.INDEX%), \
1593: 1e9f:                                             9,2) + ":" +                        \     ! CCSK
1594: 1e9f:                                            MID$(F14.TABLE$(CURR.RECORD.INDEX%), \
1595: 1e9f:                                            11,2) + " " +                        \
1596: 1e9f:                                            LEFT$(GET.OP.NAME$,14) ! OP NAME SET TO 14 CHARACTERS
1597: 1e9f:                         CALL WRITE.RFCNTLST ("3M")
1598: 1eb8:                     ENDIF
1599: 1eb8: 
1600: 1eb8:                     RFCNTLST.RECORD$ =  "List " + MID$(F14.TABLE$               \
1601: 1f6c:                                         (CURR.RECORD.INDEX%),16,3) +            \
1602: 1f6c:                                         " " + RIGHT$("   "  + STR$(VAL(MID$     \
1603: 1f6c:                                         (F14.TABLE$(CURR.RECORD.INDEX%),        \
1604: 1f6c:                                         19,3))), 3) + " items  "
1605: 1f6c:                     CALL WRITE.RFCNTLST ("")
1606: 1f85:                     PREV.CNT.STATUS$ = CURR.CNT.STATUS$
1607: 1f96: 
1608: 1f96:                 ENDIF
1609: 1f96:             ENDIF
1610: 1f96:         NEXT CURR.RECORD.INDEX%
1611: 1fa9: 
1612: 1fa9:         !If PREV.CNT.STATUS$ = " " then write the three headers
1613: 1fa9:         !    Counted Lists, Part Counted Lists, Uncounted Lists
1614: 1fa9:         !If PREV.CNT.STATUS$ = "1" then write the two headers
1615: 1fa9:         !    Part Counted Lists, Uncounted Lists
1616: 1fa9:         !If PREV.CNT.STATUS$ = "2" then write the two headers
1617: 1fa9:         !    Uncounted Lists
1618: 1fa9: 
1619: 1fa9:         IF PREV.CNT.STATUS$ = " " THEN BEGIN
1620: 1fbc:             RFCNTLST.RECORD$ = "Counted Lists       "
1621: 1fc9:             CALL WRITE.RFCNTLST ("2M")
1622: 1fe2:             RFCNTLST.RECORD$ = "Part Counted Lists  "
1623: 1fef:             CALL WRITE.RFCNTLST ("2M")
1624: 2008:             RFCNTLST.RECORD$ = "Uncounted Lists     "
1625: 2015:             CALL WRITE.RFCNTLST ("2M")
1626: 2031:         ENDIF ELSE IF PREV.CNT.STATUS$ = "1" THEN BEGIN
1627: 2044:             RFCNTLST.RECORD$ = "Part Counted Lists  "
1628: 2051:             CALL WRITE.RFCNTLST ("2M")
1629: 206a:             RFCNTLST.RECORD$ = "Uncounted Lists     "
1630: 2077:             CALL WRITE.RFCNTLST ("2M")
1631: 2092:         ENDIF ELSE IF PREV.CNT.STATUS$ = "2" THEN BEGIN
1632: 20a5:             RFCNTLST.RECORD$ = "Uncounted Lists     "
1633: 20b2:             CALL WRITE.RFCNTLST ("2M")
1634: 20cb:         ENDIF
1635: 20cb: 
1636: 20cb:         RFCNTLST.RECORD$ = "--------------------"
1637: 20d8:         CALL WRITE.RFCNTLST ("")
1638: 20f1: 
1639: 20f1:     NEXT COUNTER%
1640: 2103: 
1641: 2103:     RFCNTLST.RECORD$ = "   END OF REPORT    "
1642: 2110:     CALL WRITE.RFCNTLST ("")
1643: 2129: 
1644: 2129: RETURN
1645: 2131: 
1646: 2131: \*****************************************************************************
1647: 2131: \***
1648: 2131: \***    DEALLOCATE.SESSION.NUMBERS
1649: 2131: \***    Detail        : Perform CALL.F20.SESS.NUM.UTILITY to de-allocate file
1650: 2131: \***                    session numbers from all files referenced by the
1651: 2131: \***                    program.
1652: 2131: \***
1653: 2131: \***..........................................................................
1654: 2131: 
1655: 2131: DEALLOCATE.SESSION.NUMBERS:
1656: 2131: 
1657: 2131:     ADXSERVE.DATA$ = "Deallocating Session numbers - MINRFCNT"
1658: 213e:     GOSUB DISPLAY.MESSAGE
1659: 2148: 
1660: 2148:     FUNCTION.FLAG$ EQ "C"
1661: 2155: 
1662: 2155:     PASSED.INTEGER% = CLOLF.SESS.NUM%
1663: 215f:     PASSED.STRING$ = ""
1664: 216c:     GOSUB CALL.F20.SESS.NUM.UTILITY
1665: 2176: 
1666: 2176:     PASSED.INTEGER% = CLILF.SESS.NUM%
1667: 2180:     PASSED.STRING$ = ""
1668: 218d:     GOSUB CALL.F20.SESS.NUM.UTILITY
1669: 2197: 
1670: 2197:     PASSED.INTEGER% = AF.SESS.NUM%
1671: 21a1:     PASSED.STRING$ = ""
1672: 21ae:     GOSUB CALL.F20.SESS.NUM.UTILITY
1673: 21b8: 
1674: 21b8:     PASSED.INTEGER% = RFCNTLST.SESS.NUM%
1675: 21c2:     PASSED.STRING$ = ""
1676: 21cf:     GOSUB CALL.F20.SESS.NUM.UTILITY
1677: 21d9: 
1678: 21d9:     ADXSERVE.DATA$ = "Session numbers deallocating success - MINRFCNT"
1679: 21e6:     GOSUB DISPLAY.MESSAGE
1680: 21f0: 
1681: 21f0: RETURN
1682: 21f8: 
1683: 21f8: \*****************************************************************************
1684: 21f8: \***
1685: 21f8: \***    Display background message
1686: 21f8: \***
1687: 21f8: \***..........................................................................
1688: 21f8: 
1689: 21f8: DISPLAY.MESSAGE:
1690: 21f8: 
1691: 21f8:     IF COMM.MODE.FLAG$ = "B" THEN BEGIN
1692: 220e:         ADX.INTEGER%  = 0
1693: 2214:         ADX.FUNCTION% = 26
1694: 221a:         CALL ADXSERVE (ADX.RETURN.CODE%,     \
1695: 2234:                        ADX.FUNCTION%,        \
1696: 2234:                        ADX.INTEGER%,         \
1697: 2234:                        ADXSERVE.DATA$)
1698: 2234:     ENDIF ELSE BEGIN
1699: 2234:         PRINT ADXSERVE.DATA$
1700: 2241:     ENDIF
1701: 2241: 
1702: 2241: RETURN
1703: 2249: 
1704: 2249: \*****************************************************************************
1705: 2249: \***
1706: 2249: \***    FORMAT.CURRENT.CODE:
1707: 2249: \***    Detail        : Sets CURRENT.CODE.LOGGED$ for use with application
1708: 2249: \***                    event log.
1709: 2249: \***
1710: 2249: \***..........................................................................
1711: 2249: 
1712: 2249: FORMAT.CURRENT.CODE:
1713: 2249: 
1714: 2249:     IF FILE.OPERATION$ EQ "C"                            \ ! Create
1715: 2293:       OR FILE.OPERATION$ EQ "O" THEN                     \ ! Open
1716: 2293:     BEGIN
1717: 2293:         CURRENT.CODE.LOGGED$ EQ PACK$("00000000000000")
1718: 22a5:     ENDIF
1719: 22a5: 
1720: 22a5:     IF FILE.OPERATION$ EQ "R"                            \ ! Read
1721: 22ef:       OR FILE.OPERATION$ EQ "W" THEN                     \ ! Write
1722: 22ef:     BEGIN
1723: 22ef:         CURRENT.CODE.LOGGED$ EQ RIGHT$(CURRENT.CODE$,7)
1724: 230a:     ENDIF
1725: 230a: 
1726: 230a: RETURN
1727: 2312: 
1728: 2312: \*****************************************************************************
1729: 2312: \***
1730: 2312: \***    CALL.F01.APPLICATION.LOG:
1731: 2312: \***    Detail        : References APPLICATION.LOG (F01) to write details
1732: 2312: \***                    of event defined by EVENT.NUMBER% and VAR.STRING.1$
1733: 2312: \***                    to Application Event Log, and to display any message
1734: 2312: \***                    defined by MESSAGE.NUMBER% and VAR.STRING.2$.
1735: 2312: \***
1736: 2312: \***..........................................................................
1737: 2312: 
1738: 2312: CALL.F01.APPLICATION.LOG:
1739: 2312:     FUNCTION.RETURN.CODE% EQ    \
1740: 2336:         APPLICATION.LOG         \
1741: 2336:         (MESSAGE.NUMBER%,       \
1742: 2336:         VAR.STRING.1$,          \
1743: 2336:         VAR.STRING.2$,          \
1744: 2336:         EVENT.NUMBER%)
1745: 2336: RETURN
1746: 233e: 
1747: 233e: \*****************************************************************************
1748: 233e: \***
1749: 233e: \***    LOG.AN.EVENT.106:
1750: 233e: \***    Detail        : Writes details of Event 106 to application event
1751: 233e: \***                    log and displays message B501 (for file open errors)
1752: 233e: \***                    or B514 (for other errors).
1753: 233e: \***
1754: 233e: \***..........................................................................
1755: 233e: 
1756: 233e: LOG.AN.EVENT.106:
1757: 233e: 
1758: 233e:     ADXSERVE.DATA$ = "LOG.AN.EVENT.106 File Op= " + FILE.OPERATION$
1759: 2359:     GOSUB DISPLAY.MESSAGE
1760: 2363: 
1761: 2363:     EVENT.NUMBER% EQ 106
1762: 2369:     GOSUB FORMAT.CURRENT.CODE
1763: 2373:     VAR.STRING.1$ EQ                         \ ! Application event log data
1764: 23da:         FILE.OPERATION$                    + \
1765: 23da:         CHR$(SHIFT(CURRENT.REPORT.NUM%,8)) + \ ! Two byte integer byte order
1766: 23da:         CHR$(SHIFT(CURRENT.REPORT.NUM%,0)) + \ ! reversed to give hex number
1767: 23da:         CURRENT.CODE.LOGGED$
1768: 23da: 
1769: 23da:     GOSUB CALL.F01.APPLICATION.LOG
1770: 23e4: 
1771: 23e4: RETURN
1772: 23ec: 
1773: 23ec: \*****************************************************************************
1774: 23ec: \***
1775: 23ec: \***    ERROR.DETECTED:
1776: 23ec: \***    Detail        : Below mentioned are the main process done here.
1777: 23ec: \***                    1. Increments ERROR.COUNT% by one for errors that
1778: 23ec: \***                       are not handled
1779: 23ec: \***                    2. Further errors within ERROR.DETECTED causing
1780: 23ec: \***                       control to be passed here again result in this
1781: 23ec: \***                       test being failed and the immediate diversion of
1782: 23ec: \***                       program control to STOP.MINRFCNT
1783: 23ec: \***
1784: 23ec: \***..........................................................................
1785: 23ec: 
1786: 23ec: ERROR.DETECTED:
1787: 23ec: 
1788: 23ec:     IF ERR = "CU" THEN BEGIN
1789: 240a:         ERROR.COUNT% = 0
1790: 240f:         RESUME
1791: 241e:     ENDIF
1792: 241e: 
1793: 241e:     IF CURRENT.REPORT.NUM% = RFCNTLST.REPORT.NUM% THEN BEGIN
1794: 242e:         IF FILE.OPERATION$ = "W" THEN BEGIN
1795: 2444:             ADXSERVE.DATA$ = "Error in writing to RFCNTLST.DAY file"
1796: 2451:             GOSUB DISPLAY.MESSAGE
1797: 245b:             GOSUB LOG.AN.EVENT.106
1798: 2465:             RESUME STOP.MINRFCNT
1799: 2476:         ENDIF ELSE IF FILE.OPERATION$ = "O" THEN BEGIN
1800: 248c:             CREATE RFCNTLST.FILE.NAME$ AS RFCNTLST.SESS.NUM%
1801: 24a8:             ADXSERVE.DATA$ = "Created RFCNTLST.DAY File" + STRING$(17, " ") + \
1802: 24d2:                              "- MINRFCNT "
1803: 24d2:             GOSUB DISPLAY.MESSAGE
1804: 24dc:             RESUME
1805: 24eb:         ENDIF
1806: 24eb:     ENDIF
1807: 24eb: 
1808: 24eb:     IF FILE.OPERATION$ = "O" THEN BEGIN
1809: 2504:         ERROR.COUNT% = 0
1810: 2509:         IF CURRENT.REPORT.NUM% = CLOLF.REPORT.NUM% THEN BEGIN
1811: 2519:             ADXSERVE.DATA$ = "Error in opening CLOLF file"
1812: 2526:             GOSUB DISPLAY.MESSAGE
1813: 2530:             GOSUB LOG.AN.EVENT.106
1814: 253a:             RESUME STOP.MINRFCNT
1815: 254c:         ENDIF ELSE IF CURRENT.REPORT.NUM% = CLILF.REPORT.NUM% THEN BEGIN
1816: 255c:             ADXSERVE.DATA$ = "Error in opening CLILF file"
1817: 2569:             GOSUB DISPLAY.MESSAGE
1818: 2573:             GOSUB LOG.AN.EVENT.106
1819: 257d:             RESUME STOP.MINRFCNT
1820: 258e:         ENDIF ELSE IF CURRENT.REPORT.NUM% = AF.REPORT.NUM% THEN BEGIN
1821: 259f:             ADXSERVE.DATA$ = "Error in opening EALAUTH file"
1822: 25ac:             GOSUB DISPLAY.MESSAGE
1823: 25b6:             RESUME
1824: 25c5:         ENDIF
1825: 25c5:     ENDIF
1826: 25c5: 
1827: 25c5:     FUNCTION.RETURN.CODE% EQ  \
1828: 25ed:     STANDARD.ERROR.DETECTED   \
1829: 25ed:     (ERRN,                    \
1830: 25ed:     ERRF%,                    \
1831: 25ed:     ERRL,                     \
1832: 25ed:     ERR)
1833: 25ed: 
1834: 25ed:     ERROR.COUNT% = ERROR.COUNT% + 1
1835: 25f1:     IF ERROR.COUNT% > 1 THEN BEGIN
1836: 25f8:         RESUME STOP.MINRFCNT
1837: 2607:     ENDIF
1838: 2607: 
1839: 2607: END SUB
1840: 2613: 
1841: 2613: 
1842: 2613: End of Compilation
