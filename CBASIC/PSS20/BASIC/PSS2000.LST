   1: 0002: \*****************************************************************************
   2: 0002: \* Program:       PSS20             CREDIT CLAIMS REPORTING                  *
   3: 0002: \* Created:       04 November 1993                                           *
   4: 0002: \* Author:        Mick Bayliss                                               *
   5: 0002: \*                                                                           *
   6: 0002: \* Current Version        : D                                                *
   7: 0002: \*                                                                           *
   8: 0002: \* Date of last Amendment : 19th August 1994                                 *
   9: 0002: \* Last Amendment by      : Michael J. Kelsall                               *
  10: 0002: \*                                                                           *
  11: 0002: \*****************************************************************************
  12: 0002: \*****************************************************************************
  13: 0002: \* PROGRAM OVERVIEW                                                          *
  14: 0002: \*                                                                           *
  15: 0002: \*  This Program is part of the Returns/Automatic Credit Claiming System     *
  16: 0002: \*  and will be initiated daily via sleeper mode, or ad-hoc in command mode. *
  17: 0002: \*  This program will run if the Chilled Foods Software is active or the     *
  18: 0002: \*  Returns Software is active. The purpose of this program is to produce    *
  19: 0002: \*  reports on Credit Claiming activity and to perform weekly housekeeping   *
  20: 0002: \*  on Credit Claims files.                                                  *
  21: 0002: \*                                                                           *
  22: 0002: \*  If CHILLED FOODS ACTIVE then the Chilled Foods Wastage Report (CCCFW)    *
  23: 0002: \*  will be produced daily from CCLAM and CCITF. This report shows totals    *
  24: 0002: \*  of credit claimed for chilled foods wastage and the value of stock sold  *
  25: 0002: \*  to staff from the Credit Claiming Control file (CCTRL), the difference   *
  26: 0002: \*  between the above is calculated and displayed. Housekeeping of the       *
  27: 0002: \*  Claims files is performed weekly, on a Sunday or on a subsequent day if  * !4.1BMG
  28: 0002: \*  Sunday's housekeeping fails. The CCTRL file is updated to show the last  * !4.1BMG
  29: 0002: \*  successful housekeeping date (weekly) and to reset the Staff Sales       *
  30: 0002: \*  figure to zero (daily).                                                  *
  31: 0002: \*                                                                           *
  32: 0002: \*  If RETURNS IS ACTIVE then both reporting and housekeeping are performed  *
  33: 0002: \*  weekly on a Sunday or subsequent day due to failure. The Claiming        * !4.1BMG
  34: 0002: \*  activity shown in CCLAM and CCITF is reported in two reports, one a      *
  35: 0002: \*  Summary report (CCSMY) and one a detailed report (CCDET). Each report    *
  36: 0002: \*  shows Credit Claims data ordered by claim number within Business Centre. *
  37: 0002: \*  In addition the detailed report shows Item level data for credit claimed.*
  38: 0002: \*  Housekeeping is as for chilled foods, as is the CCTRL update.            *
  39: 0002: \*                                                                           *
  40: 0002: \*  If neither Chilled Foods nor Returns is active the no reporting or       *
  41: 0002: \*  housekeeping takes place. The CCTRL Staff Sales value will still be      *
  42: 0002: \*  reset to zero (daily).                                                   *
  43: 0002:  \*                                                                           *
  44: 0002: \*****************************************************************************
  45: 0002: \*                                                                           *
  46: 0002: \*   Version B (part 1)   Clive Norris              23rd February 1994       *
  47: 0002: \*                                                                           *
  48: 0002: \*     Changed to include maintenance of the new Credit Claiming             *
  49: 0002: \*     Stocktaking file (CCSTS) prior to Housekeeping when Returns is active *
  50: 0002: \*     The CCSTS file will be updated with the latest credit claim numbers   *
  51: 0002: \*     for each business centre from the CCLAM file.                         *
  52: 0002: \*                                                                           *
  53: 0002: \*   Version B (part 2)         Mick Bayliss              14th March 1994    *
  54: 0002: \*                                                                           *
  55: 0002: \*     If reason for claim is Repair/Estimate (23) or Plan 4 (26) then do    *
  56: 0002: \*     not show item level detail on Detail Report (CCDET) (Amendment to     *
  57: 0002: \*     RET.RPT.END.CLAIM:)                                                   *
  58: 0002: \*                                                                           *
  59: 0002: \*   Version C            Michael J. Kelsall        27th April 1994          *
  60: 0002: \*                                                                           *
  61: 0002: \*     Changes to fix problems detected during Returns system testing;       *
  62: 0002: \*     - Prevention of program loop if zero report date in CCTRL.            *
  63: 0002: \*     - Change of report description from credit note to credit claim       *
  64: 0002: \*     - Adjustment of qty field on CCDET from two to four digits.           *
  65: 0002: \*     - Change to remove item level details from cancelled claims on both   *
  66: 0002: \*         CCSMY and CCDET, also addition of line to indicate cancellation.  *
  67: 0002: \*     - Change to categorise all non-alphabetic Business centres encountered*
  68: 0002: \*         to a single BC table record.                                      *
  69: 0002: \*     - Change to combine EPSOM DIRECTS and OTHER DIRECTS supply routes to  *
  70: 0002: \*        a single supply route of 'O' - 'DIRECTS'                           *
  71: 0002: \*     - Removal of error handling of failed record deletion from CCLAM/CCITF*
  72: 0002: \*                                                                           *
  73: 0002: \*   Version D            David Smallwood           18th May 1994            *
  74: 0002: \*                                                                           *
  75: 0002: \*     - Do not display item header information if no items to display.      *
  76: 0002: \*     - Do not display item code "9999991"                                  *
  77: 0002: \*     - Calculate item price from CCITF.PRICE% (actually item value)        *
  78: 0002: \*                                                                           *
  79: 0002: \*   Version D (II)       Michael J. Kelsall        18th May 1994            *
  80: 0002: \*                                                                           *
  81: 0002: \*     - Slight mod to this mod to handle pharmacy qtys (claim/(qty/pack))   *
  82: 0002: \*     - Change to handle bar code formats correctly on CCDET                *
  83: 0002: \*     - Change to include pack size on CCDET for any pharmacy lines         *
  84: 0002: \*     - Change to add 'quick' fix to page throw on CCDET item level output  *
  85: 0002: \*     - Change to add item claim value to CCDET report                      *
  86: 0002: \*                                                                           *
  87: 0002: \*   Version 1.3       Julia Stones              4th July 1996               *
  88: 0002: \*                                                                           *
  89: 0002: \*     PSS20 currently only runs on a Sunday or on a subsequent day if       * !4.1BMG
  90: 0002: \*     Sunday's run failed for any reason.                                   * !4.1BMG
  91: 0002: \*     Change to PSS20 to housekeep claims daily i.e. claims over 6 days     *
  92: 0002: \*     old that were despatched before the last run of PSS20 and have been   *
  93: 0002: \*     retrieved to the centre will be deleted from CCLAM and CCITF.         *
  94: 0002: \*     Reporting will remain weekly.                                         *
  95: 0002: \*                                                                           *
  96: 0002: \*   Version 1.4       Rebecca Dakin              3rd February 1998          *
  97: 0002: \*                                                                           *
  98: 0002: \*     Changes have been made to make PSS20 Y2K compliant. DATE.LT, DATE.GE  *
  99: 0002: \*     and DATE.GT have been used to handle the date comparisons from a      *
 100: 0002: \*     function called CMPDATE.                                              *
 101: 0002: \*     All code for Chilled Foods active has been removed from the program   *
 102: 0002: \*     as it is now redundant.                                               *
 103: 0002: \*                                                                           *
 104: 0002: \*   Version 1.5       Amy Hoggard                 21st April 2000           *
 105: 0002: \*    Changes for Internationalisation to call ADXSERVE to determine how     *
 106: 0002: \*    many decimal places are in use.                                        *
 107: 0002: \*                                                                           *
 108: 0002: \*                                                                           *
 109: 0002: \*   Version 1.6       Amy Hoggard                 19th May                  *
 110: 0002: \*    Changes for Internationalisation to process new Business Centre        *
 111: 0002: \*    Numbers as well as current letters.                                    *
 112: 0002: \*    Also changed to call report descriptors from USERDESC in stead of      *
 113: 0002: \*    hard coding them so USERDESC file needed for UK and Taiwan             *
 114: 0002: \*                                                                           *
 115: 0002: \*   Version 1.7       Julia Stones                30th June                 *
 116: 0002: \*   Commented out the following change   - Change to categorise all         *
 117: 0002: \*   non-alphabetic Business centres encountered to a single BC table record.*
 118: 0002: \*   As non-alphabetic Business Centres now used for International processing*
 119: 0002: \*                                                                           *
 120: 0002: \*   Version 1.8       Brian Greenfield         20th December 2000           *
 121: 0002: \*   Re-jigged the logic to determine if the BC letter is valid or not.      *
 122: 0002: \*   If the BC letter is not between A & Z or between 1 & 9 it sets it to    *
 123: 0002: \*   ASCII value 91 (Don't ask me why, this is how it was before!)           *
 124: 0002: \*   This is to stop the program falling over when it comes across a BC      *
 125: 0002: \*   letter of SPACE in a CCLAM record, which is itself generated by a       *
 126: 0002: \*   manual claim of an item not found on file.                              *
 127: 0002: \*                                                                           *
 128: 0002: \*   Version 1.9       Jamie Thorpe             24th November 2003           *
 129: 0002: \*   Changed CCSMY reporting as part of the Credit Claiming Simplification   *
 130: 0002: \*   project. The new style summary report will now be split in to 2 parts.  *
 131: 0002: \*   The 1st section will detail any exception claims i.e. Any claims over of*
 132: 0002: \*   a high value (as defined on the Software status file). The Claim number *
 133: 0002: \*   reason code and value are detailed on the report.                       *
 134: 0002: \*   The 2nd section will list each reason code for which a claim has been   *
 135: 0002: \*   raised, along with the claim value.                                     *
 136: 0002: \*   The new style report is switchable, this is determined by reading the   *
 137: 0002: \*   CREDIT CLAIM record on softs Rec.43. If this is set to INACTIVE, then   *
 138: 0002: \*   the report will still be created in the original format, otherwise it   *
 139: 0002: \*   will be formatted in the new style.                                     *
 140: 0002: \*                                                                           *
 141: 0002: \*   Version 2.0       Jamie Thorpe             17th August 2004             *
 142: 0002: \*   Small change to the report so that amounts BELOW £400 are reconciled    *
 143: 0002: \*   rather than amounts ABOVE                                               *
 144: 0002: \*                                                                           *
 145: 0002: \*   Version 3.0      Julia Stones              24th November 2004           *
 146: 0002: \*                                                                           *
 147: 0002: \*   Changed all Integer 2 variables to Integer 4 (Store 7 have more than    *
 148: 0002: \*   33,000 items to be reported on the detail report                        *
 149: 0002: \*                                                                           *
 150: 0002: \*   Version 4.1      Brian Greenfield          17th October 2007            *
 151: 0002: \*   Changed to run reports on Sunday rather than Monday.                    *
 152: 0002: \*                                                                           *
 153: 0002: \*   Version 4.2      Harpal Matharu            27th January 2008            *
 154: 0002: \*   A9B RETURNS @ POS                                                       *
 155: 0002: \*   Changes made to the reports CCDET and CCSMY the store number is now     *
 156: 0002: \*   will be added on the header of each page. If the claim is created by    *
 157: 0002: \*   TILL the transaction number, till number and operator number will be    *
 158: 0002: \*   added.                                                                  *
 159: 0002: \*                                                                           *
 160: 0002: \*****************************************************************************
 161: 0002: \*  %INCLUDE global definitions for;                                         *
 162: 0002: \*                                                                           *
 163: 0002: \*  utility functions :            APPLICATION.LOG  (01)                     *
 164: 0002: \*                                 UPDATE.DATE (02)                          *
 165: 0002: \*                                 CALC.BAR.CODE.DISPLAY (07)                *
 166: 0002: \*                                 PSDATE (13)                               *
 167: 0002: \*                                 SESS.NUM.UTILITY (20)                     *
 168: 0002: \*                                 CONV.TO.INTEGER  (26)                     *
 169: 0002: \*                                                                           *
 170: 0002: \*  file functions    :            IDF, SOFTS, BCSMF                         *
 171: 0002: \*                                 CCLAM, CCITF, CCTRL, CCRSN,               *
 172: 0002: \*                                 CCSMY, CCDET                              *
 173: 0002: \*                                                                           *
 174: 0002: \*****************************************************************************
 175: 0002: 
 176: 0002: %INCLUDE PSBF01G.J86
 177: 0002: REM \
 178: 0002: \*******************************************************************************
 179: 0002: \*******************************************************************************
 180: 0002: \***
 181: 0002: \***       %INCLUDE FOR GLOBAL DEFINITIONS FOR FUNCTION APPLICATION.LOG
 182: 0002: \***
 183: 0002: \***                FUNCTION NUMBER    : PSBF01
 184: 0002: \***
 185: 0002: \***                REFERENCE          : PSBF01G.J86
 186: 0002: \***
 187: 0002: \***                DATE OF LAST AMENDMENT  - 27/2/86
 188: 0002: \***
 189: 0002: \***
 190: 0002: \*******************************************************************************
 191: 0002: 
 192: 0002:       INTEGER GLOBAL  F01.RETURN.CODE%
 193: 0002: 
 194: 0002: 
 195: 0002: %INCLUDE PSBF02G.J86
 196: 0002: REM\
 197: 0002: \*******************************************************************************
 198: 0002: \*******************************************************************************
 199: 0002: \***
 200: 0002: \***        INCLUDE       : UPDATE.DATE globals
 201: 0002: \***
 202: 0002: \***        REFERENCE     : PSBF02G.J86
 203: 0002: \***
 204: 0002: \***        Version A     Bruce Scriver      4th March 1986
 205: 0002: \*** 
 206: 0002: \***        Version B     Andrew Wedgeworth   6th July 1992
 207: 0002: \***        Removal of return code field which no longer required.
 208: 0002: \***
 209: 0002: \*******************************************************************************
 210: 0002: \*******************************************************************************
 211: 0002: 
 212: 0002:       STRING   GLOBAL F02.DATE$
 213: 0002: 
 214: 0002:       ! 1 line deleted from here                                       ! BAW
 215: 0002: 
 216: 0002: %INCLUDE PSBF07G.J86
 217: 0002: REM\
 218: 0002: \*******************************************************************************
 219: 0002: \*******************************************************************************
 220: 0002: \***
 221: 0002: \***        INCLUDE       : CALC.BAR.CODE.DISPLAY globals
 222: 0002: \***
 223: 0002: \***        REFERENCE     : PSBF07G.J86
 224: 0002: \***
 225: 0002: \***        Version A     Bruce Scriver                 24th February 1986
 226: 0002: \***  
 227: 0002: \***        Version B     Andrew Wedgeworth                 15th July 1992
 228: 0002: \***        Redundant return code field removed.  
 229: 0002: \***
 230: 0002: \*******************************************************************************
 231: 0002: \*******************************************************************************
 232: 0002: 
 233: 0002:       STRING   GLOBAL F07.BAR.CODE.FORMAT$
 234: 0002: 
 235: 0002: 
 236: 0002: %INCLUDE PSBF13G.J86
 237: 0002: REM\
 238: 0002: \*******************************************************************************
 239: 0002: \*******************************************************************************
 240: 0002: \***
 241: 0002: \***        INCLUDE       : PSDATE globals
 242: 0002: \***
 243: 0002: \***        REFERENCE     : PSBF13G.J86
 244: 0002: \***
 245: 0002: \***     VERSION A                                  Bruce Scriver  6th Mar 86             
 246: 0002: \***            
 247: 0002: \***     VERSION B                                  Janet Lawrence 17 Aug 90
 248: 0002: \***     Add global to be used to indicate whether or not the function should
 249: 0002: \***     log an event when an invalid date is passed to it.
 250: 0002: \***
 251: 0002: \***     VERSION C                               Andrew Wedgeworth 17 July 92
 252: 0002: \***     Return code removed as no longer required.
 253: 0002: \***
 254: 0002: \*******************************************************************************
 255: 0002: \*******************************************************************************
 256: 0002: 
 257: 0002:       STRING    GLOBAL F13.DAY$,			\
 258: 0002:                        F13.DISPLAY.MESSAGE$		! BJAL
 259: 0002: 
 260: 0002: 
 261: 0002: %INCLUDE PSBF14G.J86                                                    !1.9JAT
 262: 0002: REM\
 263: 0002: \*******************************************************************************
 264: 0002: \*******************************************************************************
 265: 0002: \***
 266: 0002: \***        INCLUDE       : SORT.TABLE globals
 267: 0002: \***
 268: 0002: \***        REFERENCE     : PSBF14G.J86
 269: 0002: \***
 270: 0002: \***        Version A     Bruce Scriver                3rd March 1986
 271: 0002: \*** 
 272: 0002: \***        Version B     Andrew Wedgeworth            17th July 1992
 273: 0002: \***        Removal of now redundant return code field.
 274: 0002: \***
 275: 0002: \*******************************************************************************
 276: 0002: \*******************************************************************************
 277: 0002: 
 278: 0002:       STRING   GLOBAL F14.TABLE$(1)
 279: 0002: 
 280: 0002: 
 281: 0002: %INCLUDE PSBF20G.J86
 282: 0002: REM\
 283: 0002: \*******************************************************************************
 284: 0002: \*******************************************************************************
 285: 0002: \***
 286: 0002: \***     %INCLUDE GLOBAL VARIABLE DEFINITIONS FOR SESS.NUM.UTILITY FUNCTION
 287: 0002: \***
 288: 0002: \***                       REFERENCE     : PSBF20G.J86
 289: 0002: \*** 
 290: 0002: \***     Version A              Bruce Scrive                   5th May 1988   
 291: 0002: \*** 
 292: 0002: \***     Version B              Robert Cowey                   7th May 1991
 293: 0002: \***     Global variable F20.INTEGER.FILE.NO% changed from one byte integer
 294: 0002: \***     to two byte integer.
 295: 0002: \***
 296: 0002: \***     Version D              Andrew Wedgeworth             1st July 1992
 297: 0002: \***     F20.RETURN.CODE% removed as it is no longer required.
 298: 0002: \***
 299: 0002: \*******************************************************************************
 300: 0002: \*******************************************************************************
 301: 0002: 
 302: 0002:       STRING    GLOBAL F20.FILE.NAME$,                                 \
 303: 0002:                        F20.STRING.FILE.NO$,                            \
 304: 0002:                        F20.TABLE.DIMENSIONED.FLAG$,                    \
 305: 0002:                        SESS.NUM.TABLE$(1)
 306: 0002: 
 307: 0002:       INTEGER*2 GLOBAL F20.INTEGER.FILE.NO%
 308: 0002: 
 309: 0002:       ! 1 line deleted from here                                       ! DAW 
 310: 0002: 
 311: 0002: %INCLUDE PSBF26G.J86
 312: 0002: 
 313: 0002: \*******************************************************************************
 314: 0002: \*******************************************************************************
 315: 0002: \***
 316: 0002: \***        %INCLUDE GLOBAL DEFINITIONS FOR CONV.TO.INTEGER FUNCTION
 317: 0002: \***
 318: 0002: \***                    REFERENCE     : PSBF26G.J86
 319: 0002: \*** 
 320: 0002: \***     Version A          Michael J. Kelsall            18th March 1993
 321: 0002: \***
 322: 0002: \*******************************************************************************
 323: 0002: \*******************************************************************************
 324: 0002: 
 325: 0002:       INTEGER*1   GLOBAL 	\
 326: 0002:       				\
 327: 0002:         F26.INTEGER.SIZE%,	\
 328: 0002: 				\
 329: 0002: 	F26.RETURN.CODE%
 330: 0002: 
 331: 0002: 
 332: 0002: %INCLUDE IDFDEC.J86                                                     ! BDCN
 333: 0002: REM \
 334: 0002: \******************************************************************************
 335: 0002: \******************************************************************************
 336: 0002: \***
 337: 0002: \***         %INCLUDE FOR ITEM DATA FILE - FIELD DECLARATIONS
 338: 0002: \***                                       FILE REFERENCE PARAMETERS
 339: 0002: \***
 340: 0002: \***                  FILE TYPE    : Keyed
 341: 0002: \***
 342: 0002: \***                  REFERENCE    : IDFDEC.J86
 343: 0002: \***
 344: 0002: \***         VERSION A : Andrew Wedgeworth  29th June 1992    
 345: 0002: \***
 346: 0002: \***    VERSION C.              Robert Cowey.                       25 AUG 1993.
 347: 0002: \***    Replaced un-used RANK$ with BSNS.CNTR$ and FILLER$.
 348: 0002: \***
 349: 0002: \***    VERSION D.              Andrew Wedgeworth               15th March 1995
 350: 0002: \***    Comments updated to reflect the fact that some bits on the file are
 351: 0002: \***    no longer used.
 352: 0002: \***
 353: 0002: \*******************************************************************************
 354: 0002: \*******************************************************************************
 355: 0002: 
 356: 0002:   STRING GLOBAL           \
 357: 0002:     IDF.FILE.NAME$,       \  
 358: 0002:     IDF.BOOTS.CODE$,      \ 4 byte UPD with check digit (key)
 359: 0002:     IDF.FIRST.BAR.CODE$,  \ 6 byte UPD without check digit
 360: 0002:     IDF.SECOND.BAR.CODE$, \ 6 byte UPD without check digit
 361: 0002:     IDF.NO.OF.BAR.CODES$, \ 2 byte UPD. Total number of bar codes for this item
 362: 0002:     IDF.PRODUCT.GRP$,     \ 3 byte UPD. The first two digits are the concept
 363: 0002:                           \ group and the last four the concept sequence
 364: 0002:     IDF.STNDRD.DESC$,     \ 24 bytes
 365: 0002:     IDF.STATUS.1$,        \ 1 byte, values B,C,D,P,X,Z and blank
 366: 0002:     IDF.INTRO.DATE$,      \ 3 byte UPD YYMMDD. Date first added to this file
 367: 0002:     IDF.BSNS.CNTR$,       \ 1 byte ASC. Business Centre ID letter      ! CRC
 368: 0002:     IDF.FILLER$,          \ 1 byte un-used                             ! CRC
 369: 0002:     IDF.PARENT.CODE$,     \ 4 byte UPD with check digit ; may be zero if no
 370: 0002:                           \ flashpacks, current IDF.BOOTS.CODE$ if parent line
 371: 0002:                           \ or Boots Code of parent line if a flashpack.
 372: 0002:     IDF.DATE.OF.LAST.SALE$! 3 byte UPD. Date of last sale.
 373: 0002: 
 374: 0002:   INTEGER*1 GLOBAL        \
 375: 0002:     IDF.BIT.FLAGS.1%,     \ 1 byte - bit values
 376: 0002:                           \ X"80"  - Group code flag
 377: 0002:                           \ X"40"  - Keylines flag
 378: 0002:                           \ X"20"  - Markdown flag
 379: 0002:                           \ X"10"  - Warehouse flag
 380: 0002:                           \ X"08"  - CSR flag
 381: 0002:                           \ X"04"  - Directs A flag
 382: 0002:                           \ X"02"  - Directs B flag
 383: 0002:                           \ X"01"  - Directs C flag
 384: 0002:     IDF.BIT.FLAGS.2%      \ 1 byte - bit values
 385: 0002:                           \ X"80"  - Own brand line flag
 386: 0002:                           \ X"40"  - Exclusive line flag
 387: 0002:                           \ X"20"  - Unused 
 388: 0002:                           \ X"10"  - Unused
 389: 0002:                           \ X"08"  - Stock system flag
 390: 0002:                           \ X"04"  - Pending count flag
 391: 0002:                           \ X"02"  - Reserved
 392: 0002:                           ! X"01"  - Reserved
 393: 0002: 
 394: 0002:   INTEGER*2 GLOBAL        \
 395: 0002:     IDF.RECL%,            \  
 396: 0002:     IDF.REPORT.NUM%,      \ 
 397: 0002:     IDF.SESS.NUM%
 398: 0002: %INCLUDE SOFTSDEC.J86
 399: 0002: REM \
 400: 0002: \******************************************************************************
 401: 0002: \******************************************************************************
 402: 0002: \***
 403: 0002: \***                 %INCLUDE FOR THE SOFTWARE STATUS FILE
 404: 0002: \***   
 405: 0002: \***                      FILE TYPE  :   Direct
 406: 0002: \***
 407: 0002: \***                      REFERENCE  :   SOFTSDEC.J86
 408: 0002: \***
 409: 0002: \***	Version A	       Andrew Wedgeworth	      24th June 1992
 410: 0002: \***
 411: 0002: \******************************************************************************
 412: 0002: \*******************************************************************************
 413: 0002: 
 414: 0002:   STRING GLOBAL           \
 415: 0002:     SOFTS.RECORD$,        \           
 416: 0002:     SOFTS.SPACE$,         \           
 417: 0002:     SOFTS.FILE.NAME$    
 418: 0002:     
 419: 0002:   INTEGER*2 GLOBAL        \
 420: 0002:     SOFTS.RECL%,          \            
 421: 0002:     SOFTS.REPORT.NUM%,	  \      
 422: 0002:     SOFTS.SESS.NUM%
 423: 0002: 
 424: 0002:   INTEGER*4 GLOBAL        \
 425: 0002:     SOFTS.REC.NUM% 	         
 426: 0002: %INCLUDE BCSMFDEC.J86
 427: 0002: REM \
 428: 0002: \******************************************************************************
 429: 0002: \******************************************************************************
 430: 0002: \***
 431: 0002: \***   %INCLUDE FOR BUSINESS CENTRE SUPPLY METHOD FILE REFERENCE PARAMETERS
 432: 0002: \***                                              FIELD DECLARATIONS
 433: 0002: \***
 434: 0002: \***               REFERENCE    : BCSMFDEC.J86
 435: 0002: \***
 436: 0002: \***  Version A - L Cook
 437: 0002: \***  Copied from bcsmfnue.j86 and bcsmffle.j86
 438: 0002: \***
 439: 0002: \***  Version B - Les Cook
 440: 0002: \***  to include integer missed from bcsmfflf.j86 in error
 441: 0002: \***
 442: 0002: \******************************************************************************
 443: 0002: \*******************************************************************************
 444: 0002: 
 445: 0002:   STRING GLOBAL           \
 446: 0002:     BCSMF.FILE.NAME$,              \ 
 447: 0002:     BCSMF.FSI$,                    \ 1 byte ASCII folio series identifier (key)
 448: 0002:     BCSMF.NAME$,                   \ 14 bytes ASCII business centre name
 449: 0002:     BCSMF.PSEUDO.BUSINESS.CENTRE$, \ 1 byte flag "Y" = pseudo bc
 450: 0002:     BCSMF.FILLER$                  ! 3 bytes spaces
 451: 0002: 
 452: 0002:   INTEGER*1 GLOBAL          \
 453: 0002:     BCSMF.RECNT.LIMIT%,     \ percentage of recounts that may be generated
 454: 0002:     BCSMF.MIN.RECNT.LIMIT%, \ minimum limit
 455: 0002:     BCSMF.MAX.RECNT.LIMIT%, \ maximum limit
 456: 0002:     BCSMF.DISCRPNCY.CNT%,   \ used to calculate   
 457: 0002:     BCSMF.DISCRPNCY.PERCNT%,\ if recount
 458: 0002:     BCSMF.STK.CNT.LIMIT%,   \ is necessary
 459: 0002:     BCSMF.SEQUENCE.NO%,     \ used for displaying
 460: 0002:     BCSMF.NO.REPEAT.TICKETS% ! Number of repeat FALCONCRAFT tickets	! CLC
 461: 0002: 
 462: 0002:   INTEGER*2 GLOBAL        \
 463: 0002:     BCSMF.DISCRPNCY.VAL%,   \ (in pounds) used for determining recounts
 464: 0002:     BCSMF.MIN.LIST.NO%,     \ allowable range of 
 465: 0002:     BCSMF.MAX.LIST.NO%,     \ spare list numbers
 466: 0002:     BCSMF.RECL%,          \
 467: 0002:     BCSMF.SESS.NUM%,      \
 468: 0002:     BCSMF.REPORT.NUM%
 469: 0002: %INCLUDE CCLAMDEC.J86
 470: 0002: 
 471: 0002: \*****************************************************************************
 472: 0002: \*****************************************************************************
 473: 0002: \***
 474: 0002: \***        %INCLUDE FIELD DECLARATIONS AND FILE REFERENCE PARAMETERS
 475: 0002: \***
 476: 0002: \***                   FILE TYPE:  KEYED
 477: 0002: \***
 478: 0002: \***                   REFERENCE:  CCLAMDEC.J86
 479: 0002: \***
 480: 0002: \***	             DESCRIPTION:  RETURNS / AUTOMATIC CREDIT CLAIMING
 481: 0002: \***				   FILE OF CURRENT CREDIT CLAIMS
 482: 0002: \***
 483: 0002: \***
 484: 0002: \***      VERSION A : Michael J. Kelsall      16th December 1993
 485: 0002: \***      
 486: 0002: \*****************************************************************************
 487: 0002: \*****************************************************************************
 488: 0002: 
 489: 0002: STRING GLOBAL			\
 490: 0002:    CCLAM.FILE.NAME$,		\
 491: 0002:    CCLAM.CREDIT.CLAIM.NUM$,	\  4 byte UPD;   Record Key
 492: 0002:    CCLAM.UOD.NUM$,		\  7 byte UPD
 493: 0002:    				\  CCLAM.NUM.OF.ITEMS% here (I2)
 494: 0002:    CCLAM.SUPPLY.ROUTE$,		\  1 byte ASC;  "W" = Warehouse,
 495: 0002:    				\ 	        "E" = EPSOM,
 496: 0002: 				\	        "O" = Other Directs,
 497: 0002: 				\               "D" = Dispensary.
 498: 0002:    CCLAM.DISP.LOCATION$,	\  1 byte ASC   "M" = MDS, "D" = Dispensary.
 499: 0002:    CCLAM.BC.LETTER$,		\  1 byte ASC    
 500: 0002:    CCLAM.RECALL.NUM$,		\  8 byte ASC
 501: 0002:    CCLAM.AUTHORISATION$,	\ 15 byte ASC
 502: 0002:    CCLAM.SUPPLIER$,		\ 15 byte ASC
 503: 0002:    CCLAM.METHOD.OF.RETURN$,	\  1 byte UPD;   1 = Carrier,
 504: 0002:    				\                2 = BIRD,
 505: 0002: 				\	 	 3 = Via D6,
 506: 0002: 				\		 4 = Representative.
 507: 0002:    CCLAM.CARRIER$,		\  1 byte UPD;   1 = GPO,
 508: 0002:    				\                2 = Parcelforce,
 509: 0002: 				\	 	 3 = Securicor,
 510: 0002: 				\ 		 4 = Other.
 511: 0002:    CCLAM.BIRD.NUM$,		\  8 byte ASC					
 512: 0002:    CCLAM.REASON.NUM$,		\  1 byte UPD     (See CSRNS declaration)
 513: 0002:    CCLAM.RECEIVING.STORE$,	\  2 byte UPD    
 514: 0002:    CCLAM.DESTINATION$,		\  1 byte UPD    1 = Business Centre, 
 515: 0002:    				\	         2 = MTS,
 516: 0002:    				\		 3 = Pharmacy, 
 517: 0002: 				\		 4 = Other.
 518: 0002:    CCLAM.WAREHOUSE.ROUTE$,	\  1 byte ASC   "R" = RDC, "C" = CSR.
 519: 0002:    CCLAM.UOD.TYPE$,		\  1 byte UPD    1 = Travel Outer,
 520: 0002:    				\		 2 = Town tray,
 521: 0002: 				\		 3 = Roll cage,
 522: 0002: 				\     	         4 = Other.
 523: 0002:    CCLAM.DAMAGE.REASON$,        \  1 byte UPD    1 = Bad packaging,	
 524: 0002:    				\		 2 = Poor handling.
 525: 0002:    CCLAM.INVOICE.NUM$,		\* 9 byte ASC 
 526: 0002:    CCLAM.FOLIO.NUM$,		\  3 byte UPD
 527: 0002:    CCLAM.BATCH.REF$,		\  3 byte UPD
 528: 0002:    CCLAM.WHOLE.PART.CON$,       \  1 byte ASC   "W" = Whole, "P" = Part
 529: 0002:    CCLAM.REPAIR.CATEGORY$, 	\  1 byte UPD;   1 = Plan4,
 530: 0002:    				\   		 2 = Estimate,
 531: 0002: 				\		 3 = Boots guarantee,
 532: 0002: 				\		 4 = Supplier guarantee,
 533: 0002: 				\		 5 = Other guarantee,
 534: 0002:    CCLAM.REPAIR.NUM$,		\  6 byte UPD
 535: 0002:    CCLAM.PLAN4.POLICY.NUM$,	\  6 byte UPD 
 536: 0002:    CCLAM.DDDA.DCDR.NUM$,	\  4 byte UPD
 537: 0002:    CCLAM.DELIV.NOTE.NUM$,	\* 9 byte ASC
 538: 0002:    CCLAM.DELIV.DATE$,		\  3 byte UPD
 539: 0002:    CCLAM.NUM.CARTONS.RECEIV$,	\  1 byte UPD
 540: 0002:    CCLAM.ORDER.NUM$,		\  7 byte ASC
 541: 0002:    CCLAM.COMMENT$,  		\*20 byte ASC
 542: 0002:    CCLAM.DATE.OF.CLAIM$,	\  3 byte UPD;  Date of UOD despatch
 543: 0002:    CCLAM.TIME.OF.CLAIM$,	\  3 byte UPD;  Time of UOD despatch
 544: 0002:    CCLAM.RETRIEVAL.FLAG$,	\  1 byte ASC;  "Y", "N"  PSS35 sets to Y
 545: 0002:    				\                         PSB30 sets to N
 546: 0002:    CCLAM.CF.RPT.MARKER$,	\  1 byte ASC;  "Y"       PSS35 sets to Y
 547: 0002:    				\               "N"       PSS20 sets to N
 548: 0002:    CCLAM.CANC.MARKER$,		\  1 byte ASC;  Y or N
 549: 0002:    CCLAM.FILLER$		!  7 byte ASC;  Spaces.
 550: 0002: 
 551: 0002: 
 552: 0002: INTEGER*2 GLOBAL		\
 553: 0002:    CCLAM.RECL%,			\
 554: 0002:    CCLAM.REPORT.NUM%,		\
 555: 0002:    CCLAM.SESS.NUM%,		\
 556: 0002: 				\
 557: 0002:    CCLAM.NUM.OF.ITEMS%		!  2 byte INT
 558: 0002: 
 559: 0002: %INCLUDE CCITFDEC.J86
 560: 0002: 
 561: 0002: \*****************************************************************************
 562: 0002: \*****************************************************************************
 563: 0002: \***
 564: 0002: \***        %INCLUDE FIELD DECLARATIONS AND FILE REFERENCE PARAMETERS
 565: 0002: \***
 566: 0002: \***                   FILE TYPE:  KEYED
 567: 0002: \***
 568: 0002: \***                   REFERENCE:  CCITFDEC.J86
 569: 0002: \***
 570: 0002: \***	             DESCRIPTION:  RETURNS / AUTOMATIC CREDIT CLAIMING
 571: 0002: \***				   FILE OF ITEMS PER CREDIT CLAIMS
 572: 0002: \***
 573: 0002: \***
 574: 0002: \***      VERSION A : Michael J. Kelsall      14th September 1993
 575: 0002: \***      
 576: 0002: \*****************************************************************************
 577: 0002: \*****************************************************************************
 578: 0002: 
 579: 0002: STRING GLOBAL			\
 580: 0002:    CCITF.FILE.NAME$,		\
 581: 0002:    CCITF.KEY$,			\  Record key (consists of next 2 fields);
 582: 0002:    CCITF.CREDIT.CLAIM.NUM$,	\  4 byte UPD
 583: 0002:    CCITF.ITEM.NUM$,		\  2 byte UPD
 584: 0002: 				\
 585: 0002:    CCITF.ITEM.BAR.CODE.FLAG$,	\  1 byte ASC;  "I" = Boots Item code,
 586: 0002:    				\               "B" = Barcode.
 587: 0002:    CCITF.BOOTS.BAR.CODE$,	\  7 byte UPD
 588: 0002:    				\  CCITF.QTY% here (I2)
 589: 0002:    CCITF.PRICE$,		\  3 byte UPD
 590: 0002:    CCITF.FILLER$ 		!  4 byte ASC;  Spaces
 591: 0002:    
 592: 0002: 
 593: 0002: INTEGER*2 GLOBAL		\
 594: 0002:    CCITF.RECL%,			\
 595: 0002:    CCITF.REPORT.NUM%,		\
 596: 0002:    CCITF.SESS.NUM%,		\
 597: 0002: 				\
 598: 0002:    CCITF.QTY%			!  2 byte INT
 599: 0002: 
 600: 0002: %INCLUDE CCTRLDEC.J86
 601: 0002: 
 602: 0002: \*****************************************************************************
 603: 0002: \*****************************************************************************
 604: 0002: \***
 605: 0002: \***        %INCLUDE FIELD DECLARATIONS AND FILE REFERENCE PARAMETERS
 606: 0002: \***
 607: 0002: \***                   FILE TYPE:  DIRECT
 608: 0002: \***
 609: 0002: \***                   REFERENCE:  CCTRLDEC.J86
 610: 0002: \***
 611: 0002: \***	             DESCRIPTION:  RETURNS / AUTOMATIC CREDIT CLAIMING
 612: 0002: \***				   CREDIT CLAIMS CONTROL FILE
 613: 0002: \***
 614: 0002: \***
 615: 0002: \***      VERSION A : Michael J. Kelsall      14th September 1993
 616: 0002: \***      
 617: 0002: \*****************************************************************************
 618: 0002: \*****************************************************************************
 619: 0002: 
 620: 0002: STRING GLOBAL			\
 621: 0002:    CCTRL.FILE.NAME$,		\
 622: 0002:    CCTRL.RECORD$,		\
 623: 0002:    CCTRL.CREDIT.CLAIM.NUM$,	\  4 byte UPD
 624: 0002:    CCTRL.CREDIT.RPT.RUN.DATE$,	\  3 byte UPD
 625: 0002:    CCTRL.UOD.RPT.RUN.DATE$,	\  3 byte UPD
 626: 0002:    CCTRL.FILLER$		! 65 byte ASC;  Spaces
 627: 0002:    
 628: 0002: 
 629: 0002: INTEGER*2 GLOBAL		\
 630: 0002:    CCTRL.RECL%,			\
 631: 0002:    CCTRL.REPORT.NUM%,		\
 632: 0002:    CCTRL.SESS.NUM%,		\
 633: 0002:    CCTRL.REC.NUM%
 634: 0002: 
 635: 0002: INTEGER*4 GLOBAL		\
 636: 0002:    CCTRL.STAFF.SALES%		!  4 INT, total sales to store staff,
 637: 0002:    				!  stored as 5 byte UPD on file
 638: 0002: 
 639: 0002: %INCLUDE CCRSNDEC.J86
 640: 0002: 
 641: 0002: \*****************************************************************************
 642: 0002: \*****************************************************************************
 643: 0002: \***
 644: 0002: \***        %INCLUDE FIELD DECLARATIONS AND FILE REFERENCE PARAMETERS
 645: 0002: \***
 646: 0002: \***                   FILE TYPE:  KEYED
 647: 0002: \***
 648: 0002: \***                   REFERENCE:  CCRSNDEC.J86
 649: 0002: \***
 650: 0002: \***                 DESCRIPTION:  RETURNS / AUTOMATIC CREDIT CLAIMING
 651: 0002: \***                               FILE OF RETURN REASON CODES 
 652: 0002: \***
 653: 0002: \***
 654: 0002: \***      VERSION A : Michael J. Kelsall      14th September 1993
 655: 0002: \***
 656: 0002: \***      Version B : Andy Cotton             16th June 2000
 657: 0002: \***
 658: 0002: \***      Version C : Andy Cotton             17th November 2003
 659: 0002: \***      Added alternate reason code
 660: 0002: \***      
 661: 0002: \*****************************************************************************
 662: 0002: \*****************************************************************************
 663: 0002: 
 664: 0002: STRING GLOBAL                   \
 665: 0002:    CCRSN.FILE.NAME$,            \
 666: 0002:    CCRSN.REASON$,               \  1 byte UPD;UK/TAI -1 = Faulty,          
 667: 0002:                                 \                     2 = Damage in transit,
 668: 0002:                                 \                 *   3 = Recall, Supplier Recall                       
 669: 0002:                                 \                     4 = Out of date,
 670: 0002:                                 \                     5 = 100% returns,
 671: 0002:                                 \                     6 = Damaged in store,
 672: 0002:                                 \                 *   7 = Fire/Flood damage, Customer Return (Not Stocked)
 673: 0002:                                 \                 *   8 = Cust. special waste, Customer Return(damaged)
 674: 0002:                                 \                 *   9 = Chilled food, Promotional Remainder
 675: 0002:                                 \                    10 = Chiller breakdown, 
 676: 0002:                                 \                 *  11 = Out of date (C Foods), End of Season Recall
 677: 0002:                                 \                 *  12 = Company / Shop use, Store Use
 678: 0002:                                 \                    13 = Assured Shopping,
 679: 0002:                                 \                 *  14 = Promise of Satisfaction, Tester
 680: 0002:                                 \                 *  15 = Known Theft, Known Theft
 681: 0002:                                 \                 *  16 = Beauty Consult allowance, Damaged on Receipt
 682: 0002:                                 \                 *  17 = Stolen in transit, Damaged in Store
 683: 0002:                                 \                 *  18 = Inter Store transfer, Inter Store Transfer
 684: 0002:                                 \                    19 = Rejected photowork,
 685: 0002:                                 \                    20 = Other transfers,
 686: 0002:                                 \                    21 = Missing,
 687: 0002:                                 \                 *  22 = Excess, Excess Delivery
 688: 0002:                                 \                 *  23 = Repair, Range Change
 689: 0002:                                 \                    24 = Other.
 690: 0002:                                 \                    25 = Faulty Deliv (Ch Fds)
 691: 0002:                                 \                    26 = Plan4
 692: 0002:                                 \                 *  27 = Breakage and Loss, Out of Age
 693: 0002:    CCRSN.DESC$,                 \ 30 byte ASC
 694: 0002:    CCRSN.PSS30.REQ$,            \ 1  byte ASC - Set to "Y" if reason required in program
 695: 0002:                                 \               Set to " " if reason not required in program
 696: 0002:    CCRSN.PSS93.REQ$,            \ 1  byte ASC - Set to numeric value of on screen position if required for PSS93
 697: 0002:                                 \               Set to zero if reason not required in program
 698: 0002:    CCRSN.ALTERNATE.REASON$,     \ 1  byte UPD   This holds the alternate reason code (e.g. if the key is the head
 699: 0002:                                 \               office Reason then this value will be the controller reason                                
 700: 0002:    CCRSN.FILLER$                ! 17 byte ASC
 701: 0002:    
 702: 0002: 
 703: 0002: INTEGER*2 GLOBAL                \
 704: 0002:    CCRSN.RECL%,                 \
 705: 0002:    CCRSN.REPORT.NUM%,           \
 706: 0002:    CCRSN.SESS.NUM%
 707: 0002: 
 708: 0002: %INCLUDE CCSMYDEC.J86
 709: 0002: REM \
 710: 0002: \******************************************************************************
 711: 0002: \******************************************************************************
 712: 0002: \***
 713: 0002: \***               %INCLUDE FOR RETURNS SUMMARY REPORT FILE  
 714: 0002: \***
 715: 0002: \***                      REFERENCE    :   CCSMYDEA.J86
 716: 0002: \***
 717: 0002: \***                      FILE TYPE    :   SEQUENTIAL
 718: 0002: \***
 719: 0002: \***       VERSION A        Michael J. Kelsall          3rd November 1993
 720: 0002: \***
 721: 0002: \******************************************************************************
 722: 0002: *******************************************************************************
 723: 0002: 
 724: 0002:   STRING GLOBAL           \
 725: 0002:     CCSMY.FILE.NAME$,     \
 726: 0002:     CCSMY.REPORT.LINE$    \ 80 bytes report line
 727: 0002: 
 728: 0002:   INTEGER*2 GLOBAL        \
 729: 0002:     CCSMY.REPORT.NUM%,    \
 730: 0002:     CCSMY.SESS.NUM%,      \
 731: 0002:     CCSMY.RECL%
 732: 0002: %INCLUDE CCSTSDEC.J86                                                   ! BDCN
 733: 0002: \*****************************************************************************
 734: 0002: \*****************************************************************************
 735: 0002: \***
 736: 0002: \***        %INCLUDE FIELD DECLARATIONS AND FILE REFERENCE PARAMETERS
 737: 0002: \***
 738: 0002: \***                   FILE TYPE:  DIRECT
 739: 0002: \***
 740: 0002: \***                   REFERENCE:  CCSTSDEC.J86
 741: 0002: \***
 742: 0002: \***	             DESCRIPTION:  CREDIT CLAIMING STOCKTAKING
 743: 0002: \***				   SUMMARY FILE
 744: 0002: \***
 745: 0002: \***
 746: 0002: \***      VERSION A : Clive Norris             9th February 1994
 747: 0002: \***      
 748: 0002: \*****************************************************************************
 749: 0002: \*****************************************************************************
 750: 0002: 
 751: 0002: STRING GLOBAL			\
 752: 0002:    CCSTS.FILE.NAME$,		\
 753: 0002:    CCSTS.RECORD$,		\  Breaks down into the following fields... 
 754: 0002:    CCSTS.FSI$,             	\  1 byte ASC   Folio series ID (from BCSMF)
 755: 0002:    CCSTS.NAME$,               	\ 14 byte ASC   Business Centre name
 756: 0002:    CCSTS.CLAIM$,                \  8 byte ASC   Latest credit claim no. 
 757: 0002:    CCSTS.FILLER$		!  9 byte ASC;  Spaces
 758: 0002:    
 759: 0002: 
 760: 0002: INTEGER*2 GLOBAL		\
 761: 0002:    CCSTS.RECL%,			\
 762: 0002:    CCSTS.REPORT.NUM%,		\
 763: 0002:    CCSTS.SESS.NUM%,		\
 764: 0002:    CCSTS.REC.NUM%
 765: 0002: 
 766: 0002: 
 767: 0002: %INCLUDE CCDETDEC.J86
 768: 0002: REM \
 769: 0002: \******************************************************************************
 770: 0002: \******************************************************************************
 771: 0002: \***
 772: 0002: \***               %INCLUDE FOR RETURNS DETAIL REPORT FILE  
 773: 0002: \***
 774: 0002: \***                      REFERENCE    :   CCDETDEC.J86
 775: 0002: \***
 776: 0002: \***                      FILE TYPE    :   SEQUENTIAL
 777: 0002: \***
 778: 0002: \***       VERSION A        Michael J. Kelsall          3rd November 1993
 779: 0002: \***
 780: 0002: \******************************************************************************
 781: 0002: *******************************************************************************
 782: 0002: 
 783: 0002:   STRING GLOBAL           \
 784: 0002:     CCDET.FILE.NAME$,     \
 785: 0002:     CCDET.REPORT.LINE$    \ 80 bytes report line
 786: 0002: 
 787: 0002:   INTEGER*2 GLOBAL        \
 788: 0002:     CCDET.REPORT.NUM%,    \
 789: 0002:     CCDET.SESS.NUM%,      \
 790: 0002:     CCDET.RECL%
 791: 0002: %INCLUDE UDESCDEC.J86   !1.6AH
 792: 0002: \******************************************************************************
 793: 0002: \******************************************************************************
 794: 0002: \***
 795: 0002: \***                      UDESC FILE                                       
 796: 0002: \***                      REFERENCE : UDESCDEC.J86 
 797: 0002: \***                                                                
 798: 0002: \***                      FILE TYPE : Direct                           
 799: 0002: \***                                                                
 800: 0002: \***                                                                
 801: 0002: \***   Version A.              Amy Hoggard                   19th May 2000
 802: 0002: \***   Original version.                                                    
 803: 0002: \***                                                                        
 804: 0002: \***                                                                       
 805: 0002: \******************************************************************************
 806: 0002: \******************************************************************************
 807: 0002: 
 808: 0002:  
 809: 0002: STRING GLOBAL        UDESC.FILE.NAME$,       \ 
 810: 0002:                      UDESC.RECORD$
 811: 0002:                      
 812: 0002: INTEGER*2 GLOBAL     UDESC.RECORD.NUM%,      \
 813: 0002:                      UDESC.REPORT.NUM%,      \
 814: 0002:                      UDESC.SESS.NUM%,        \
 815: 0002:                      DESC.LEN%,              \
 816: 0002:                      UDESC.RECL%
 817: 0002: 
 818: 0002: \*****************************************************************************
 819: 0002: \*  Declare GLOBAL program variables                                         *
 820: 0002: \*                                                                           *
 821: 0002: \*****************************************************************************
 822: 0002: 
 823: 0002: STRING GLOBAL                            \
 824: 0002:        ADXSERVE.DATA$,                   \ ! 1.5AH
 825: 0002:        CURRENT.CODE$,                    \
 826: 0002:        DIVIDER$,                         \ ! 1.5AH
 827: 0002:        FILE.OPERATION$,                  \
 828: 0002:        F20.FUNCTION$,                    \
 829: 0002:        F20.STRING$,                      \
 830: 0002:        STORE.NUMBER$                       ! 4.2HSM
 831: 0002: 
 832: 0002: INTEGER*2 GLOBAL                         \
 833: 0002:        CURRENCY.FORMAT%,                 \ ! 1.5AH
 834: 0002:        CURRENT.REPORT.NUM%,              \
 835: 0002:        DECIMAL.PLACES%,                  \ ! 1.5AH
 836: 0002:        F20.INTEGER%
 837: 0002: 
 838: 0002: 
 839: 0002: \*****************************************************************************
 840: 0002: \*  Declare LOCAL  program variables                                         *
 841: 0002: \*                                                                           *
 842: 0002: \*  nb. integer*1 program flags do not end in %                              *
 843: 0002: \*****************************************************************************
 844: 0002: 
 845: 0002: INTEGER*1 GLOBAL                        \program flags
 846: 0002:        TRUE,                            \
 847: 0002:        FALSE,                           \
 848: 0002:        CCDET.OPEN,                      \
 849: 0002:        CCLAM.OPEN,                      \
 850: 0002:        CCRSN.OPEN,                      \
 851: 0002:        CCSMY.OPEN,                      \
 852: 0002:        CCSTS.OPEN,                      \                                 BDCN
 853: 0002:        CHAR.FOUND,                      \
 854: 0002:        CURRENT.REASON.CODE%,            \                              !1.9JAT
 855: 0002:        DETAIL.FIRST.PART.FULL,          \
 856: 0002:        CREDIT.CLAIM.ACTIVE,             \                              !1.9JAT
 857: 0002:        DISPLAY.OUTPUT.ERROR,            \
 858: 0002:        EXCEPTION.HEADER.WRITTEN,        \                              !1.9JAT
 859: 0002:        EXCEPTION.ON.REPORT,             \                              !1.9JAT
 860: 0002:        END.OF.BC,                       \
 861: 0002:        END.OF.REPORT,                   \
 862: 0002:        ERROR.PROCESSING.ACTIVE,         \
 863: 0002:        EXIT.FLAG,                       \
 864: 0002:        REPORTING.REQUIRED,              \                              !1.3JAS
 865: 0002:        HEADER.PRINTED,                  \                                  DDS
 866: 0002:        MATCH.DELIMITER1,                \                              !1.9JAT
 867: 0002:        MATCH.DELIMITER2,                \                              !1.9JAT
 868: 0002:        PROGRAM.FAIL,                    \
 869: 0002:        REASON.CODE.ON.REPORT,           \                              !1.9JAT
 870: 0002:        RETURNS.ACTIVE,                  \
 871: 0002:        UPDATE.CCTRL.LAST.DATE,          \
 872: 0002:        SWAPPED,                         \
 873: 0002:        SORT.COMPLETE
 874: 0002: 
 875: 0002: INTEGER*4 GLOBAL                        \                     ! 3.0 JAS
 876: 0002:        A%,                              \
 877: 0002:        ADX.PARM.1%,                     \
 878: 0002:        B%,                              \
 879: 0002:        INCREMENT%,                      \
 880: 0002:        ITEM.NO%,                        \
 881: 0002:        L%,                              \
 882: 0002:        CLAIMS.COUNTER%,                 \                               1.9JAT
 883: 0002:        CCDET.LINE.NO%,                  \
 884: 0002:        CCDET.PAGE.NO%,                  \
 885: 0002:        CCSMY.LINE.NO%,                  \
 886: 0002:        CCSMY.PAGE.NO%,                  \
 887: 0002:        CCRSN.ALTERNATE.REASON%,         \                               1.9JAT
 888: 0002:        CCRSN.REASON.NUM%,               \                               1.9JAT
 889: 0002:        CHAR.POS%,                       \
 890: 0002:        HIGHEST.REASON.CODE%,            \                               1.9JAT
 891: 0002:        LINES.PER.PAGE%,                 \
 892: 0002:        LOG.EVENT.NO%,                   \
 893: 0002:        LOG.MESSAGE.NO%,                 \
 894: 0002:        MAX.CCLAM.SUBSCRIPT%,            \                               1.2MJK
 895: 0002:        PACK.SIZE%,                      \                                 DMJK
 896: 0002:        RC%,                             \
 897: 0002:        RECORD.NO%,                      \
 898: 0002:        RECORDS.PER.SECTOR%,             \
 899: 0002:        REPORT.REC.SIZE%,                \
 900: 0002:        SECTOR.RECORD.PART%,             \
 901: 0002:        SECTOR.SIZE%
 902: 0002: 
 903: 0002: INTEGER*4 GLOBAL                        \
 904: 0002:        ADX.FUNCTION%,                   \ ! 1.5AH
 905: 0002:        ADX.INTEGER%,                    \ ! 1.5AH
 906: 0002:        ADX.RETURN.CODE%,                \ ! 1.5AH
 907: 0002:        BC.TAB.IDX%,                     \
 908: 0002:        CLAIM.EXCEPTION.VALUE%,          \                               1.9JAT
 909: 0002:        CLAIM.TOTAL.VALUE%,              \
 910: 0002:        CREDIT.TOTAL.VALUE%,             \                               1.9JAT
 911: 0002:        CURRENT.CLAIM.VALUE%,            \
 912: 0002:        DEL.TAB.IDX%,                    \
 913: 0002:        DEL.TAB.NO.ENTRIES%,             \
 914: 0002:        ITEM.CLAIM.VALUE%,               \
 915: 0002:        ITEM.PRICE%,                     \
 916: 0002:        MAX.BC.TABLE.SIZE%,              \
 917: 0002:        MAX.REPORT.TABLE.SIZE%,          \
 918: 0002:        MAX.DELETE.TABLE.SIZE%,          \
 919: 0002:        NEW.CLAIM.VALUE%,                \                               1.9JAT
 920: 0002:        NUM.OF.SECTORS%,                 \
 921: 0002:        RPT.TAB.IDX%,                    \
 922: 0002:        RPT.TAB.NO.ENTRIES%,             \
 923: 0002:        SECTOR.NO%,                      \
 924: 0002:        TOTAL.CLAIM.VALUE%                                              !1.9JAT
 925: 0002: 
 926: 0002: STRING       GLOBAL                     \
 927: 0002:        ADJ$,                            \  !1.6AH
 928: 0002:        ADX.PARM.2$,                     \
 929: 0002:        BCSMF.RECORD$,                   \
 930: 0002:        BCSMF.SECTOR$,                   \
 931: 0002:        BC.TABLE$(1),                    \
 932: 0002:        BLANK.LINE$,                     \
 933: 0002:        CANCELLED.LINE$,                 \                                 CMJK
 934: 0002:        CCLAM.RECORD$,                   \
 935: 0002:        CCLAM.SECTOR$,                   \
 936: 0002:        CCDET.PAGE.NO$,                  \
 937: 0002:        CCSMY.PAGE.NO$,                  \
 938: 0002:        CLAIM.DETAIL$,                   \
 939: 0002:        COMPLETED.MESSAGE$,              \
 940: 0002:        CURRENCY.SYMBOL$,                \                              !1.9JAT
 941: 0002:        DAT$,                            \  !1.6AH
 942: 0002:        DELETE.TABLE$(1),                \
 943: 0002:        DETAIL.FIRST.PART$,              \
 944: 0002:        DETAIL.SECOND.PART$,             \
 945: 0002:        DISPLAY.BC$,                     \                                 CMJK
 946: 0002:        EOF.CCSTS.FLAG$,                 \                                 BDCN
 947: 0002:        FAILED.MESSAGE$,                 \
 948: 0002:        FIELD$,                          \
 949: 0002:        INVALID.BC$,                     \
 950: 0002:        ITEM.BAR.CODE$,                  \
 951: 0002:        ITEM.BOOTS.CODE$,                \
 952: 0002:        ITEM.CLAIM.VALUE$,               \                                 DMJK
 953: 0002:        ITEM.CODE$,                      \
 954: 0002:        ITEM.CODE.FLAG$,                 \
 955: 0002:        ITEM.PRICE$,                     \
 956: 0002:        ITEM.QTY$,                       \
 957: 0002:        ITEM.TABLE$(1),                  \
 958: 0002:        LAST.CREDIT.RUN.DATE$,           \
 959: 0002:        LOCATION$,                       \                              !1.9JAT
 960: 0002:        LOG.FAILED.MESSAGE$,             \
 961: 0002:        LOG.STRING.1.UNIQUE$,            \
 962: 0002:        LOG.STRING.2$,                   \
 963: 0002:        NUM.OF.PAGES$,                   \
 964: 0002:        NUMB$,                           \  !1.6AH
 965: 0002:        OUTPUT.MESSAGE$,                 \
 966: 0002:        PACK.SIZE$,                      \                                 DMJK
 967: 0002:        PAGE.NUM.MARKER$,                \
 968: 0002:        PAGE.THROW$,                     \
 969: 0002:        PRINT.REPORT.NO$,                \
 970: 0002:        PRINT.TIME$,                     \
 971: 0002:        PRINT.TODAYS.DATE$,              \
 972: 0002:        PRINT.WC.DATE$,                  \
 973: 0002:        REPORT.TABLE$(1),                \
 974: 0002:        ROI.CLAIM.EXCEPTION.VALUE$,      \                              !1.9JAT
 975: 0002:        SECTOR.FILLER$,                  \
 976: 0002:        NEW.CLAIM.RECORDS$(1),           \                               1.9JAT
 977: 0002:        NEW.REASON.CODE.RECORDS$(1),     \                               1.9JAT
 978: 0002:        SIX.DAYS.DATE$,                  \                               1.3JAS
 979: 0002:        START$,                          \  !1.6AH
 980: 0002:        STARTUP.MESSAGE$,                \
 981: 0002:        STORE.BC.LETTER$,                \
 982: 0002:        SUPPLY.ROUTE.DESC$,              \
 983: 0002:        TEMP$,                           \
 984: 0002:        TITLE$,                          \  !1.6AH
 985: 0002:        TODAYS.DATE$,                    \
 986: 0002:        TRAINING.BC$,                    \
 987: 0002:        UK.CLAIM.EXCEPTION.VALUE$,       \                               1.9JAT
 988: 0002:        UNIT$,                           \  !1.6AH
 989: 0002:        VALUE$,                          \
 990: 0002:        VALUE.NO.SPACES$,                \
 991: 0002:        WC.DATE$,                        \
 992: 0002:        DUMMY$,                          \
 993: 0002:        CURRENT.TILL.CLAIM$                                              !4.2HSM
 994: 0002:      
 995: 0002: 
 996: 0002: REAL                                    \
 997: 0002:        GAP,                             \
 998: 0002:        REAL.ITEM.CLAIM.VALUE,           \                                 DMJK
 999: 0002:        REAL.CCITF.QTY,                  \                                 DMJK
1000: 0002:        REAL.PACK.SIZE                   !                                 DMJK
1001: 0002: 
1002: 0002: \*****************************************************************************
1003: 0002: \* %INCLUDE external function definitions for;                               *
1004: 0002: \*                                                                           *
1005: 0002: \* utility functions :                    ADXSERVE                           *
1006: 0002: \*                                        CONV.TO.INTEGER                    *
1007: 0002: \*                                        APPLICATION.LOG (01)               *
1008: 0002: \*                                        UPDATE.DATE (02)                   *
1009: 0002: \*                                        CALC.BAR.CODE.DISPLAY (07)         *
1010: 0002: \*                                        PSDATE (13)                        *
1011: 0002: \*                                        SESS.NUM.UTILITY (20)              *
1012: 0002: \*                                        STANDARD.ERROR.DETECTED(24)        *
1013: 0002: \*                                        CONV.TO.INTEGER(26)                *
1014: 0002: \*                                                                           *
1015: 0002: \* file functions    :                    IDF, SOFTS, BCSMF                  *
1016: 0002: \*                                        CCLAM, CCITF, CCTRL, CCRSN,        *
1017: 0002: \*                                        CCSMY, CCDET, CCSTS, CMPDATE       *
1018: 0002: \*                                                                           *
1019: 0002: \*****************************************************************************
1020: 0002: 
1021: 0002: %INCLUDE ADXSERVE.J86
1022: 0002: \******************************************************************************
1023: 0002: \******************************************************************************
1024: 0002: \***                                                                        ***
1025: 0002: \***    %INCLUDE FOR FUNCTION ADXSERVE (an I.B.M. system function)          ***
1026: 0002: \***                                                                        ***
1027: 0002: \***         AUTHOR        :  Bruce Scriver                                 ***
1028: 0002: \***                                                                        ***
1029: 0002: \***         DATE WRITTEN  :  14th March 1986                               ***
1030: 0002: \***                                                                        ***
1031: 0002: \***         DATE OF LAST REVISION  - 14th March 1986                       ***
1032: 0002: \***                                                                        ***
1033: 0002: \***                                                                        ***
1034: 0002: \******************************************************************************
1035: 0002: \******************************************************************************
1036: 0002: 
1037: 0002:    SUB ADXSERVE (RETURN.CODE%,                                                \
1038: 0002:                  ADX.FUNCTION%,                                               \
1039: 0002:                  ADX.PARM.1%,                                                 \
1040: 0002:                  ADX.PARM.2$)                                                 \
1041: 0002:    EXTERNAL
1042: 0002:   
1043: 0002:       STRING     ADX.PARM.2$
1044: 0002: 
1045: 0002:       INTEGER*2  ADX.FUNCTION%,                                               \
1046: 0002:                  ADX.PARM.1%
1047: 0002: 
1048: 0002:       INTEGER*4  RETURN.CODE%                                                 \
1049: 0002: 
1050: 0002:    END SUB     
1051: 0002: 
1052: 0002: %INCLUDE PSBF01E.J86
1053: 0002: REM \
1054: 0002: \*******************************************************************************
1055: 0002: \*******************************************************************************
1056: 0002: \***
1057: 0002: \***      %INCLUDE FOR EXTERNAL DEFINITION OF FUNCTION APPLICATION.LOG
1058: 0002: \***
1059: 0002: \***                      FUNCTION NUMBER   : PSBF01
1060: 0002: \***
1061: 0002: \***                    INCLUDE REFERENCE : PSBF01E.J86
1062: 0002: \*** 
1063: 0002: \***      Version B           Andrew Wedgeworth          1st July 1992
1064: 0002: \***      Three parameters which passed to the function have been removed.
1065: 0002: \***      APPLICATION.LOG has been added as a variable name (this holds the
1066: 0002: \***      return code).
1067: 0002: \***
1068: 0002: \*******************************************************************************
1069: 0002: 
1070: 0002: 
1071: 0002:    FUNCTION APPLICATION.LOG (MESSAGE.NO%,                                     \
1072: 0002:                              VAR.STRING.1$,                                   \
1073: 0002:                              VAR.STRING.2$,                                   \
1074: 0002:                              EVENT.NO%)  EXTERNAL
1075: 0002: 
1076: 0002:       INTEGER*1 EVENT.NO%
1077: 0002: 
1078: 0002:       INTEGER*2 APPLICATION.LOG,                                       \ GAW
1079: 0002:                 MESSAGE.NO%
1080: 0002: 
1081: 0002:       STRING VAR.STRING.1$,                                            \
1082: 0002:              VAR.STRING.2$
1083: 0002: 
1084: 0002:    END FUNCTION
1085: 0002: 
1086: 0002: \*******************************************************************************
1087: 0002: %INCLUDE PSBF02E.J86
1088: 0002: REM\
1089: 0002: \*******************************************************************************
1090: 0002: \*******************************************************************************
1091: 0002: \***
1092: 0002: \***        INCLUDE       : UPDATE.DATE external definition
1093: 0002: \***        AUTHOR        : Bruce Scriver (Basic Code)
1094: 0002: \***        DATE WRITTEN  : 4th March 1986 (Basic Code)
1095: 0002: \***
1096: 0002: \***        REFERENCE     : PSBF02E.J86
1097: 0002: \***
1098: 0002: \***        Version A     Bruce Scriver          4th March 1986
1099: 0002: \***
1100: 0002: \***        Version B     Andrew Wedgeworth       6th July 1992
1101: 0002: \***        Removal of redundant parameters, and inclusion of UPDATE.DATE as
1102: 0002: \***        a variable to hold the return code.
1103: 0002: \***
1104: 0002: \*******************************************************************************
1105: 0002: \*******************************************************************************
1106: 0002: 
1107: 0002:    FUNCTION UPDATE.DATE (INCREMENT%)                                   \
1108: 0002:    EXTERNAL
1109: 0002:    ! 3 parameters removed from here                                    ! BAW
1110: 0002: 
1111: 0002:    ! 3 lines deleted from here                                         ! BAW
1112: 0002:    
1113: 0002:       INTEGER*2 UPDATE.DATE                                            ! BAW
1114: 0002: 
1115: 0002:       INTEGER*4 INCREMENT%
1116: 0002: 
1117: 0002:    END FUNCTION
1118: 0002: 
1119: 0002: %INCLUDE PSBF07E.J86
1120: 0002: rem\
1121: 0002: \*******************************************************************************
1122: 0002: \*******************************************************************************
1123: 0002: \***
1124: 0002: \***
1125: 0002: \***         INCLUDE       : CALC.BAR.CODE.DISPLAY external definition
1126: 0002: \***
1127: 0002: \***         REFERENCE     : PSBF07E.J86
1128: 0002: \***
1129: 0002: \***         Version A     Bruce Scriver                  24th February 1986
1130: 0002: \*** 
1131: 0002: \***         Version B     Andrew Wedgeworth                  15th July 1992
1132: 0002: \***         Removal of redundant variables.  CALC.BAR.CODE.DISPLAY defined as
1133: 0002: \***         a variable to hold the return code.
1134: 0002: \***
1135: 0002: \*******************************************************************************
1136: 0002: \*******************************************************************************
1137: 0002: 
1138: 0002:    FUNCTION CALC.BAR.CODE.DISPLAY (BAR.CODE.UPD$)                              \
1139: 0002:    EXTERNAL
1140: 0002:    ! 3 parameters removed from here                                    ! BAW   
1141: 0002: 
1142: 0002:    STRING    BAR.CODE.UPD$
1143: 0002:    ! 3 variables removed from here                                     ! BAW   
1144: 0002: 
1145: 0002:    INTEGER*2 CALC.BAR.CODE.DISPLAY                                     ! BAW   
1146: 0002:    
1147: 0002: 
1148: 0002:    END FUNCTION
1149: 0002: %INCLUDE PSBF13E.J86
1150: 0002: REM\
1151: 0002: \*******************************************************************************
1152: 0002: \*******************************************************************************
1153: 0002: \***
1154: 0002: \***        INCLUDE       : PSDATE external definition
1155: 0002: \***
1156: 0002: \***        REFERENCE     : PSBF13E.J86
1157: 0002: \***
1158: 0002: \***        Version A     Bruce Scriver                6th March 1986
1159: 0002: \*** 
1160: 0002: \***        Version B     Andrew Wedgeworth            17th July 1992  
1161: 0002: \***        Redundant parameters removed and PSDATE defined as a variable
1162: 0002: \***        to hold the return code. 
1163: 0002: \***
1164: 0002: \*******************************************************************************
1165: 0002: \*******************************************************************************
1166: 0002: 
1167: 0002:    FUNCTION PSDATE (INPUT.DATE$)                                               \
1168: 0002:    EXTERNAL
1169: 0002: 
1170: 0002:      STRING    INPUT.DATE$                                                   
1171: 0002:    
1172: 0002:      INTEGER*2 PSDATE 
1173: 0002: 
1174: 0002:    END FUNCTION
1175: 0002: 
1176: 0002: %INCLUDE PSBF14E.J86                                                    !1.9JAT
1177: 0002: REM\
1178: 0002: \*******************************************************************************
1179: 0002: \*******************************************************************************
1180: 0002: \***
1181: 0002: \***        INCLUDE       : SORT.TABLE external definition
1182: 0002: \***
1183: 0002: \***        REFERENCE     : PSBF14E.J86
1184: 0002: \***
1185: 0002: \***        Version A     Bruce Scriver                   3rd March 1986   
1186: 0002: \*** 
1187: 0002: \***        Version B     Andrew Wedgeworth               17th July 1992
1188: 0002: \***        Redundant function parameters removed.  SORT.TABLE defined as a
1189: 0002: \***        variable to hold the return code.
1190: 0002: \***
1191: 0002: \*******************************************************************************
1192: 0002: \*******************************************************************************
1193: 0002: 
1194: 0002:    FUNCTION SORT.TABLE (NUMBER.OF.ENTRIES%)                                    \
1195: 0002:    EXTERNAL
1196: 0002: 
1197: 0002:       INTEGER   NUMBER.OF.ENTRIES%,                                    \ BAW
1198: 0002:                 SORT.TABLE                 
1199: 0002: 
1200: 0002:    END FUNCTION
1201: 0002: 
1202: 0002: %INCLUDE PSBF20E.J86
1203: 0002: REM\
1204: 0002: \*******************************************************************************
1205: 0002: \*******************************************************************************
1206: 0002: \***
1207: 0002: \***       %INCLUDE FOR EXTERNAL DEFINITION OF SESS.NUM.UTILITY
1208: 0002: \***
1209: 0002: \***                  REFERENCE     : PSBF20E.J86
1210: 0002: \***
1211: 0002: \***     VERSION C            Janet Smith                13th May 1992
1212: 0002: \***     Increased PASSED.INTEGER to 2 bytes to cater for more than
1213: 0002: \***     128 files.
1214: 0002: \***
1215: 0002: \***     VERSION D.           Andrew Wedgeworth          1st July 1992
1216: 0002: \***     Removal of redundant parameters and addition of SESS.NUM.UTILITY
1217: 0002: \***     as a variable.  This new variable contains the function's return
1218: 0002: \***     code.
1219: 0002: \***
1220: 0002: \*******************************************************************************
1221: 0002: \*******************************************************************************
1222: 0002: 
1223: 0002:    FUNCTION SESS.NUM.UTILITY (FUNCTION.FLAG$,                          \
1224: 0002:                               PASSED.INTEGER%,                         \
1225: 0002:                               PASSED.STRING$)                          \
1226: 0002:    EXTERNAL
1227: 0002: 
1228: 0002:    STRING    FUNCTION.FLAG$,                                           \
1229: 0002:              PASSED.STRING$
1230: 0002:    ! 3 variables removed from here                                     ! CAW
1231: 0002: 
1232: 0002: 
1233: 0002:    INTEGER*2 SESS.NUM.UTILITY,                                         \ CAW
1234: 0002:              PASSED.INTEGER%				               ! CJAS
1235: 0002: 
1236: 0002:    END FUNCTION
1237: 0002: 
1238: 0002: %INCLUDE PSBF24E.J86
1239: 0002: REM \
1240: 0002: \*******************************************************************************
1241: 0002: \*******************************************************************************
1242: 0002: \***
1243: 0002: \***    %INCLUDE FOR EXTERNAL DEFINITION OF STANDARD.ERROR.DETECTED FUNCTION
1244: 0002: \***
1245: 0002: \***                      REFERENCE     : PSBF24E.J86
1246: 0002: \***
1247: 0002: \***    Version A                 Janet Smith                  13th May 1992
1248: 0002: \***
1249: 0002: \*******************************************************************************
1250: 0002: \*******************************************************************************
1251: 0002: 
1252: 0002:    FUNCTION STANDARD.ERROR.DETECTED(ERRN%,                 \
1253: 0002: 				    ERRFILE%,              \
1254: 0002: 				    ERRL%,                 \
1255: 0002: 				    ERR$)        EXTERNAL
1256: 0002: 				    
1257: 0002:           STRING    ERR$
1258: 0002: 
1259: 0002:           INTEGER*2 ERRFILE%,              \
1260: 0002: 	            ERRL%,                 \
1261: 0002: 		    STANDARD.ERROR.DETECTED
1262: 0002: 		    
1263: 0002:           INTEGER*4 ERRN%
1264: 0002: 	  		    
1265: 0002:    END FUNCTION
1266: 0002: 
1267: 0002: 
1268: 0002: %INCLUDE PSBF26E.J86
1269: 0002: REM\
1270: 0002: \*******************************************************************************
1271: 0002: \*******************************************************************************
1272: 0002: \***
1273: 0002: \***       %INCLUDE FOR EXTERNAL DEFINITION OF CONV.TO.INTEGER FUNCTION
1274: 0002: \***
1275: 0002: \***                  REFERENCE     : PSBF26E.J86
1276: 0002: \***
1277: 0002: \***      Version A           Michael J. Kelsall          18th March 1993
1278: 0002: \***
1279: 0002: \*******************************************************************************
1280: 0002: \*******************************************************************************
1281: 0002: 
1282: 0002:    FUNCTION CONV.TO.INTEGER ( NUM.STRING$ )				\
1283: 0002:    EXTERNAL
1284: 0002:    
1285: 0002:       REAL      CONV.TO.INTEGER
1286: 0002: 
1287: 0002:       STRING    NUM.STRING$
1288: 0002: 
1289: 0002:    END FUNCTION
1290: 0002: 
1291: 0002: 
1292: 0002: %INCLUDE IDFEXT.J86                                                     ! BDCN
1293: 0002: \*******************************************************************************
1294: 0002: \***                                                                         ***
1295: 0002: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE ITEM DESCRIPTION FILE        ***
1296: 0002: \***                                                                         ***
1297: 0002: \***                       REFERENCE : IDFEXT.J86                            ***
1298: 0002: \***                                                                         ***
1299: 0002: \***      Version A           Andrew Wedgeworth         9th July 1992        ***
1300: 0002: \***
1301: 0002: \***    VERSION C.              Robert Cowey.                       25 AUG 1993.
1302: 0002: \***    No changes to this file.
1303: 0002: \***
1304: 0002: \***   VERSION D               Nik Sen                 22nd December 1994
1305: 0002: \***   WRITE.IDF.HOLD added
1306: 0002: \***
1307: 0002: \*******************************************************************************
1308: 0002: 
1309: 0002:        FUNCTION IDF.SET EXTERNAL                                      
1310: 0002:        END FUNCTION                                                   
1311: 0002: 
1312: 0002: 
1313: 0002:        FUNCTION READ.IDF EXTERNAL                                     
1314: 0002:           INTEGER*2 READ.IDF                                          
1315: 0002:        END FUNCTION                                                   
1316: 0002: 
1317: 0002: 
1318: 0002:        FUNCTION READ.IDF.LOCK EXTERNAL                                
1319: 0002:           INTEGER*2 READ.IDF.LOCK                                     
1320: 0002:        END FUNCTION                                                   
1321: 0002: 
1322: 0002:        FUNCTION WRITE.IDF EXTERNAL
1323: 0002:           INTEGER*2 WRITE.IDF
1324: 0002:        END FUNCTION	       
1325: 0002: 
1326: 0002:        FUNCTION WRITE.IDF.HOLD EXTERNAL
1327: 0002:           INTEGER*2 WRITE.IDF.HOLD
1328: 0002:        END FUNCTION
1329: 0002: 
1330: 0002:        FUNCTION WRITE.IDF.UNLOCK EXTERNAL                                  
1331: 0002:           INTEGER*2 WRITE.IDF.UNLOCK                                      
1332: 0002:        END FUNCTION                                                   
1333: 0002: %INCLUDE SOFTSEXT.J86
1334: 0002: \*******************************************************************************
1335: 0002: \***                                                                         ***
1336: 0002: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE SOFTWARE STATUS FILE         ***
1337: 0002: \***                                                                         ***
1338: 0002: \***                     REFERENCE : SOFTSEXT.J86                            ***
1339: 0002: \***                                                                         ***
1340: 0002: \***      Version A         Andrew Wedgeworth          1st July 1992         ***
1341: 0002: \***
1342: 0002: \***   Version B
1343: 0002: \***                                                                      ***
1344: 0002: \***      Version C         Steve Wright               3rd May 1996          ***
1345: 0002: \***      Synchronise with function source.                                  ***
1346: 0002: \*******************************************************************************
1347: 0002: 
1348: 0002:       FUNCTION SOFTS.SET EXTERNAL 
1349: 0002:       END FUNCTION
1350: 0002:       
1351: 0002:       FUNCTION READ.SOFTS EXTERNAL
1352: 0002:           INTEGER*2 I%, READ.SOFTS
1353: 0002:       END FUNCTION	                   
1354: 0002: 
1355: 0002:       FUNCTION WRITE.SOFTS EXTERNAL
1356: 0002:           INTEGER*2 I%, WRITE.SOFTS
1357: 0002:       END FUNCTION
1358: 0002: 
1359: 0002: 
1360: 0002: %INCLUDE BCSMFEXT.J86
1361: 0002: \*****************************************************************************
1362: 0002: \*****************************************************************************
1363: 0002: \***
1364: 0002: \***   EXTERNAL FUNCTION DEFINITIONS FOR BUSINESS CENTRE SUPPLY METHOD FILE
1365: 0002: \***
1366: 0002: \***               REFERENCE: BCSMFFUN.BAS
1367: 0002: \***
1368: 0002: \***        Version B           Les Cook              11/1/93
1369: 0002: \***
1370: 0002: \*****************************************************************************
1371: 0002: \*****************************************************************************
1372: 0002: 
1373: 0002:     FUNCTION BCSMF.SET EXTERNAL
1374: 0002:     END FUNCTION
1375: 0002:     
1376: 0002:     FUNCTION READ.BCSMF EXTERNAL
1377: 0002:        INTEGER*2 READ.BCSMF
1378: 0002:     END FUNCTION
1379: 0002:     
1380: 0002:     FUNCTION READ.BCSMF.LOCK EXTERNAL
1381: 0002:        INTEGER*2 READ.BCSMF.LOCK
1382: 0002:     END FUNCTION
1383: 0002:     
1384: 0002:     FUNCTION WRITE.BCSMF EXTERNAL
1385: 0002:        INTEGER*2 WRITE.BCSMF
1386: 0002:     END FUNCTION
1387: 0002:     
1388: 0002:     FUNCTION WRITE.BCSMF.UNLOCK EXTERNAL
1389: 0002:        INTEGER*2 WRITE.BCSMF.UNLOCK
1390: 0002:     END FUNCTION
1391: 0002:     
1392: 0002:     
1393: 0002: %INCLUDE CCLAMEXT.J86
1394: 0002: 
1395: 0002: \*****************************************************************************
1396: 0002: \*****************************************************************************
1397: 0002: \***
1398: 0002: \***        %INCLUDE FOR FILE HANDLING FUNCTIONS EXTERNAL DEFINITIONS
1399: 0002: \***
1400: 0002: \***                   FILE TYPE:  KEYED
1401: 0002: \***
1402: 0002: \***                   REFERENCE:  CCLAMEXT.J86
1403: 0002: \***
1404: 0002: \***	             DESCRIPTION:  RETURNS / AUTOMATIC CREDIT CLAIMING
1405: 0002: \***				   FILE OF CURRENT CREDIT CLAIMS
1406: 0002: \***
1407: 0002: \***
1408: 0002: \***      VERSION A : Michael J. Kelsall      14th September 1993
1409: 0002: \***      
1410: 0002: \*****************************************************************************
1411: 0002: \*****************************************************************************
1412: 0002: 
1413: 0002: 
1414: 0002:   FUNCTION CCLAM.SET EXTERNAL
1415: 0002:      INTEGER*2 CCLAM.SET
1416: 0002:   END FUNCTION
1417: 0002: 
1418: 0002: 
1419: 0002:   FUNCTION READ.CCLAM EXTERNAL
1420: 0002:     INTEGER*2 READ.CCLAM
1421: 0002:   END FUNCTION
1422: 0002:   
1423: 0002: 
1424: 0002:   FUNCTION READ.CCLAM.LOCKED EXTERNAL
1425: 0002:     INTEGER*2 READ.CCLAM.LOCKED
1426: 0002:   END FUNCTION  
1427: 0002: 
1428: 0002: 
1429: 0002:   FUNCTION WRITE.HOLD.CCLAM EXTERNAL
1430: 0002:     INTEGER*2 WRITE.HOLD.CCLAM
1431: 0002:   END FUNCTION
1432: 0002: 
1433: 0002: 
1434: 0002:   FUNCTION WRITE.UNLOCK.CCLAM EXTERNAL
1435: 0002:     INTEGER*2 WRITE.UNLOCK.CCLAM
1436: 0002:   END FUNCTION
1437: 0002: 
1438: 0002: 
1439: 0002:   FUNCTION WRITE.HOLD.UNLOCK.CCLAM EXTERNAL
1440: 0002:     INTEGER*2 WRITE.HOLD.UNLOCK.CCLAM
1441: 0002:   END FUNCTION
1442: 0002:   
1443: 0002: 
1444: 0002:   FUNCTION WRITE.CCLAM EXTERNAL
1445: 0002:     INTEGER*2 WRITE.CCLAM
1446: 0002:   END FUNCTION
1447: 0002: 
1448: 0002: %INCLUDE CCITFEXT.J86
1449: 0002: 
1450: 0002: \*****************************************************************************
1451: 0002: \*****************************************************************************
1452: 0002: \***
1453: 0002: \***        %INCLUDE FOR FILE HANDLING FUNCTIONS EXTERNAL DEFINITIONS
1454: 0002: \***
1455: 0002: \***                   FILE TYPE:  KEYED
1456: 0002: \***
1457: 0002: \***                   REFERENCE:  CCITFEXT.J86
1458: 0002: \***
1459: 0002: \***	             DESCRIPTION:  RETURNS / AUTOMATIC CREDIT CLAIMING
1460: 0002: \***				   FILE OF ITEMS PER CREDIT CLAIM
1461: 0002: \***
1462: 0002: \***
1463: 0002: \***      VERSION A : Michael J. Kelsall      14th September 1993
1464: 0002: \***      
1465: 0002: \*****************************************************************************
1466: 0002: \*****************************************************************************
1467: 0002: 
1468: 0002: 
1469: 0002:   FUNCTION CCITF.SET EXTERNAL
1470: 0002:      INTEGER*2 CCITF.SET
1471: 0002:   END FUNCTION
1472: 0002: 
1473: 0002: 
1474: 0002:   FUNCTION READ.CCITF EXTERNAL
1475: 0002:     INTEGER*2 READ.CCITF
1476: 0002:   END FUNCTION
1477: 0002:   
1478: 0002: 
1479: 0002:   FUNCTION READ.CCITF.LOCKED EXTERNAL
1480: 0002:     INTEGER*2 READ.CCITF.LOCKED
1481: 0002:   END FUNCTION  
1482: 0002: 
1483: 0002: 
1484: 0002:   FUNCTION WRITE.HOLD.CCITF EXTERNAL
1485: 0002:     INTEGER*2 WRITE.HOLD.CCITF
1486: 0002:   END FUNCTION
1487: 0002: 
1488: 0002: 
1489: 0002:   FUNCTION WRITE.UNLOCK.CCITF EXTERNAL
1490: 0002:     INTEGER*2 WRITE.UNLOCK.CCITF
1491: 0002:   END FUNCTION
1492: 0002: 
1493: 0002: 
1494: 0002:   FUNCTION WRITE.HOLD.UNLOCK.CCITF EXTERNAL
1495: 0002:     INTEGER*2 WRITE.HOLD.UNLOCK.CCITF
1496: 0002:   END FUNCTION
1497: 0002:   
1498: 0002: 
1499: 0002:   FUNCTION WRITE.CCITF EXTERNAL
1500: 0002:     INTEGER*2 WRITE.CCITF
1501: 0002:   END FUNCTION
1502: 0002: 
1503: 0002: %INCLUDE CCTRLEXT.J86
1504: 0002: 
1505: 0002: \*****************************************************************************
1506: 0002: \*****************************************************************************
1507: 0002: \***
1508: 0002: \***        %INCLUDE FOR FILE HANDLING FUNCTIONS EXTERNAL DEFINITIONS
1509: 0002: \***
1510: 0002: \***                   FILE TYPE:  DIRECT
1511: 0002: \***
1512: 0002: \***                   REFERENCE:  CCTRLEXT.J86
1513: 0002: \***
1514: 0002: \***	             DESCRIPTION:  RETURNS / AUTOMATIC CREDIT CLAIMING
1515: 0002: \***				   CREDIT CLAIMS CONTROL FILE
1516: 0002: \***
1517: 0002: \***
1518: 0002: \***      VERSION A : Michael J. Kelsall      14th September 1993
1519: 0002: \***      
1520: 0002: \*****************************************************************************
1521: 0002: \*****************************************************************************
1522: 0002: 
1523: 0002: 
1524: 0002:   FUNCTION CCTRL.SET EXTERNAL
1525: 0002:      INTEGER*2 CCTRL.SET
1526: 0002:   END FUNCTION
1527: 0002: 
1528: 0002: 
1529: 0002:   FUNCTION READ.CCTRL EXTERNAL
1530: 0002:     INTEGER*2 READ.CCTRL
1531: 0002:   END FUNCTION
1532: 0002:   
1533: 0002: 
1534: 0002:   FUNCTION READ.CCTRL.LOCKED EXTERNAL
1535: 0002:     INTEGER*2 READ.CCTRL.LOCKED
1536: 0002:   END FUNCTION  
1537: 0002: 
1538: 0002: 
1539: 0002:   FUNCTION WRITE.HOLD.CCTRL EXTERNAL
1540: 0002:     INTEGER*2 WRITE.HOLD.CCTRL
1541: 0002:   END FUNCTION
1542: 0002: 
1543: 0002: 
1544: 0002:   FUNCTION WRITE.UNLOCK.CCTRL EXTERNAL
1545: 0002:     INTEGER*2 WRITE.UNLOCK.CCTRL
1546: 0002:   END FUNCTION
1547: 0002: 
1548: 0002: 
1549: 0002:   FUNCTION WRITE.HOLD.UNLOCK.CCTRL EXTERNAL
1550: 0002:     INTEGER*2 WRITE.HOLD.UNLOCK.CCTRL
1551: 0002:   END FUNCTION
1552: 0002:   
1553: 0002: 
1554: 0002:   FUNCTION WRITE.CCTRL EXTERNAL
1555: 0002:     INTEGER*2 WRITE.CCTRL
1556: 0002:   END FUNCTION
1557: 0002: 
1558: 0002: %INCLUDE CCRSNEXT.J86
1559: 0002: 
1560: 0002: \*****************************************************************************
1561: 0002: \*****************************************************************************
1562: 0002: \***
1563: 0002: \***        %INCLUDE FOR FILE HANDLING FUNCTIONS EXTERNAL DEFINITIONS
1564: 0002: \***
1565: 0002: \***                   FILE TYPE:  KEYED
1566: 0002: \***
1567: 0002: \***                   REFERENCE:  CCRSNEXT.J86
1568: 0002: \***
1569: 0002: \***	             DESCRIPTION:  RETURNS / AUTOMATIC CREDIT CLAIMING
1570: 0002: \***				   FILE OF RETURN REASON CODE
1571: 0002: \***
1572: 0002: \***
1573: 0002: \***      VERSION A : Michael J. Kelsall      14th September 1993
1574: 0002: \***      
1575: 0002: \*****************************************************************************
1576: 0002: \*****************************************************************************
1577: 0002: 
1578: 0002: 
1579: 0002:   FUNCTION CCRSN.SET EXTERNAL
1580: 0002:      INTEGER*2 CCRSN.SET
1581: 0002:   END FUNCTION
1582: 0002: 
1583: 0002: 
1584: 0002:   FUNCTION READ.CCRSN EXTERNAL
1585: 0002:     INTEGER*2 READ.CCRSN
1586: 0002:   END FUNCTION
1587: 0002:   
1588: 0002: 
1589: 0002:   FUNCTION READ.CCRSN.LOCKED EXTERNAL
1590: 0002:     INTEGER*2 READ.CCRSN.LOCKED
1591: 0002:   END FUNCTION  
1592: 0002: 
1593: 0002: 
1594: 0002:   FUNCTION WRITE.HOLD.CCRSN EXTERNAL
1595: 0002:     INTEGER*2 WRITE.HOLD.CCRSN
1596: 0002:   END FUNCTION
1597: 0002: 
1598: 0002: 
1599: 0002:   FUNCTION WRITE.UNLOCK.CCRSN EXTERNAL
1600: 0002:     INTEGER*2 WRITE.UNLOCK.CCRSN
1601: 0002:   END FUNCTION
1602: 0002: 
1603: 0002: 
1604: 0002:   FUNCTION WRITE.HOLD.UNLOCK.CCRSN EXTERNAL
1605: 0002:     INTEGER*2 WRITE.HOLD.UNLOCK.CCRSN
1606: 0002:   END FUNCTION
1607: 0002:   
1608: 0002: 
1609: 0002:   FUNCTION WRITE.CCRSN EXTERNAL
1610: 0002:     INTEGER*2 WRITE.CCRSN
1611: 0002:   END FUNCTION
1612: 0002: 
1613: 0002: %INCLUDE CCSMYEXT.J86
1614: 0002: REM \
1615: 0002: \******************************************************************************
1616: 0002: \******************************************************************************
1617: 0002: \***
1618: 0002: \***      %INCLUDE FOR RETURNS SUMMARY FILE EXTERNAL FUNCTION DEFINITIONS
1619: 0002: \***
1620: 0002: \***                   REFERENCE    : CCSMYEXA.J86
1621: 0002: \***
1622: 0002: \***      VERSION A          Michael Kelsall           3rd November 1993
1623: 0002: \***
1624: 0002: \******************************************************************************
1625: 0002: \******************************************************************************
1626: 0002: 
1627: 0002: 
1628: 0002:   FUNCTION CCSMY.SET EXTERNAL
1629: 0002:       INTEGER*2 CCSMY.SET
1630: 0002:   END FUNCTION
1631: 0002:   
1632: 0002: 
1633: 0002:   FUNCTION WRITE.CCSMY EXTERNAL
1634: 0002:       INTEGER*2 WRITE.CCSMY
1635: 0002:   END FUNCTION
1636: 0002: %INCLUDE CCDETEXT.J86
1637: 0002: REM \
1638: 0002: \******************************************************************************
1639: 0002: \******************************************************************************
1640: 0002: \***
1641: 0002: \***       %INCLUDE FOR RETURNS DETAIL FILE EXTERNAL FUNCTION DEFINITIONS
1642: 0002: \***
1643: 0002: \***                   REFERENCE    : CCDETEXT.J86
1644: 0002: \***
1645: 0002: \***      VERSION A          Michael Kelsall           3rd November 1993
1646: 0002: \***
1647: 0002: \******************************************************************************
1648: 0002: \******************************************************************************
1649: 0002: 
1650: 0002: 
1651: 0002:   FUNCTION CCDET.SET EXTERNAL
1652: 0002:       INTEGER*2 CCDET.SET
1653: 0002:   END FUNCTION
1654: 0002:   
1655: 0002: 
1656: 0002:   FUNCTION WRITE.CCDET EXTERNAL
1657: 0002:       INTEGER*2 WRITE.CCDET
1658: 0002:   END FUNCTION
1659: 0002: %INCLUDE CCSTSEXT.J86                                                   ! BDCN
1660: 0002: 
1661: 0002: \*****************************************************************************
1662: 0002: \*****************************************************************************
1663: 0002: \***
1664: 0002: \***        %INCLUDE FOR FILE HANDLING FUNCTIONS EXTERNAL DEFINITIONS
1665: 0002: \***
1666: 0002: \***                   FILE TYPE:  DIRECT
1667: 0002: \***
1668: 0002: \***                   REFERENCE:  CCSTSEXT.J86
1669: 0002: \***
1670: 0002: \***	             DESCRIPTION:  CREDIT CLAIMING STOCKTAKING
1671: 0002: \***				   SUMMARY FILE
1672: 0002: \***
1673: 0002: \***
1674: 0002: \***      VERSION A : Clive Norris             9th February 1994
1675: 0002: \***      
1676: 0002: \*****************************************************************************
1677: 0002: \*****************************************************************************
1678: 0002: 
1679: 0002: 
1680: 0002:   FUNCTION CCSTS.SET EXTERNAL
1681: 0002:      INTEGER*2 CCSTS.SET
1682: 0002:   END FUNCTION
1683: 0002: 
1684: 0002: 
1685: 0002:   FUNCTION READ.CCSTS EXTERNAL
1686: 0002:     INTEGER*2 READ.CCSTS
1687: 0002:   END FUNCTION
1688: 0002:   
1689: 0002: 
1690: 0002:   FUNCTION READ.CCSTS.LOCKED EXTERNAL
1691: 0002:     INTEGER*2 READ.CCSTS.LOCKED
1692: 0002:   END FUNCTION  
1693: 0002: 
1694: 0002: 
1695: 0002:   FUNCTION WRITE.HOLD.CCSTS EXTERNAL
1696: 0002:     INTEGER*2 WRITE.HOLD.CCSTS
1697: 0002:   END FUNCTION
1698: 0002: 
1699: 0002: 
1700: 0002:   FUNCTION WRITE.UNLOCK.CCSTS EXTERNAL
1701: 0002:     INTEGER*2 WRITE.UNLOCK.CCSTS
1702: 0002:   END FUNCTION
1703: 0002: 
1704: 0002: 
1705: 0002:   FUNCTION WRITE.HOLD.UNLOCK.CCSTS EXTERNAL
1706: 0002:     INTEGER*2 WRITE.HOLD.UNLOCK.CCSTS
1707: 0002:   END FUNCTION
1708: 0002:   
1709: 0002: 
1710: 0002:   FUNCTION WRITE.CCSTS EXTERNAL
1711: 0002:     INTEGER*2 WRITE.CCSTS
1712: 0002:   END FUNCTION
1713: 0002: 
1714: 0002: %INCLUDE CMPDATE.J86                                                    !1.4RD
1715: 0002: !********************************************************************
1716: 0002: !***
1717: 0002: !***    INCLUDED CODE:  CMPDATE.J86
1718: 0002: !***    AUTHOR:         Stuart William McConnachie
1719: 0002: !***    DATE:           27th January 1997
1720: 0002: !***
1721: 0002: !********************************************************************
1722: 0002: !***   
1723: 0002: !***    Version B            Nik Sen                 30th March 1998
1724: 0002: !***    Changes to cope with a date of '000000' by replacing it with
1725: 0002: !***    '850101' before comparison. An all zero's date is valid in 
1726: 0002: !***    certain date fields and CMPDATE was returning the wrong result
1727: 0002: !***    when comparing with an actual date. Also change to cope with
1728: 0002: !***    dates of '999999' as some date fields are initialised to this
1729: 0002: !***    as a high value.
1730: 0002: !***
1731: 0002: !***    Version C    Stuart William McConnachie   20th December 1999
1732: 0002: !***    Improved function efficiency by changing tests for high and
1733: 0002: !***    low values, added above, to integers (rather than strings).
1734: 0002: !***    Also, using 850101 as a replacement for 000000, will not give
1735: 0002: !***    valid results after 350101 because of the 50 year wrap, so
1736: 0002: !***    corrected this.
1737: 0002: !***
1738: 0002: !***    Version D.  Stuart William McConnachie    26th February 2006
1739: 0002: !***    Place this code in it's own module in FUNLIB.  Make all
1740: 0002: !***    the functions herein EXTERNAL accordingly.
1741: 0002: !***
1742: 0002: !********************************************************************
1743: 0002: !***    
1744: 0002: !***    The following functions compare dates, checking for
1745: 0002: !***    century boundries.  Dates in the 50 years prior to the
1746: 0002: !***    compared date are less than the compared date, dates in
1747: 0002: !***    50 years after the compared date are greater than the
1748: 0002: !***    compared date.
1749: 0002: !***    Can handle dates in both packed and unpacked formats, or
1750: 0002: !***    a mixture of both.
1751: 0002: !***    In the case of a error, for example IH after detecting
1752: 0002: !***    illegal characters in VAL, the functions default to
1753: 0002: !***    comparing strings without testing for a change of century.
1754: 0002: !***
1755: 0002: !***    DATE.GT(DATE1$, DATE2$)  same as  DATE1$ >  DATE2$
1756: 0002: !***    DATE.GE(DATE1$, DATE2$)  same as  DATE1$ >= DATE2$
1757: 0002: !***    DATE.LT(DATE1$, DATE2$)  same as  DATE1$ <  DATE2$
1758: 0002: !***    DATE.LE(DATE1$, DATE2$)  same as  DATE1$ <= DATE2$
1759: 0002: !***
1760: 0002: !********************************************************************
1761: 0002: 
1762: 0002: FUNCTION DATE.GT(DATE1$, DATE2$) EXTERNAL                               !DSWM
1763: 0002:     STRING    DATE1$, DATE2$
1764: 0002:     INTEGER*1 DATE.GT
1765: 0002: END FUNCTION
1766: 0002: 
1767: 0002: 
1768: 0002: FUNCTION DATE.GE(DATE1$, DATE2$) EXTERNAL                               !DSWM
1769: 0002:     STRING    DATE1$, DATE2$
1770: 0002:     INTEGER*1 DATE.GE
1771: 0002: END FUNCTION
1772: 0002: 
1773: 0002: 
1774: 0002: FUNCTION DATE.LT(DATE1$, DATE2$) EXTERNAL                               !DSWM
1775: 0002:     STRING    DATE1$, DATE2$
1776: 0002:     INTEGER*1 DATE.LT
1777: 0002: END FUNCTION
1778: 0002: 
1779: 0002: 
1780: 0002: FUNCTION DATE.LE(DATE1$, DATE2$) EXTERNAL                               !DSWM
1781: 0002:     STRING    DATE1$, DATE2$
1782: 0002:     INTEGER*1 DATE.LE
1783: 0002: END FUNCTION
1784: 0002: 
1785: 0002: %INCLUDE UDESCEXT.J86  !1.6AH
1786: 0002: \******************************************************************************
1787: 0002: \******************************************************************************
1788: 0002: \***
1789: 0002: \***                             UDESC FILE   
1790: 0002: \***                                                                
1791: 0002: \***                      REFERENCE : UDESCEXT.J86 
1792: 0002: \***                                                                
1793: 0002: \***                      FILE TYPE : Direct    
1794: 0002: \***                                                                
1795: 0002: \***                                                                
1796: 0002: \***   Version A.              Amy Hoggard                   19th May 2000 
1797: 0002: \***   Original version. 
1798: 0002: \***                                                                       
1799: 0002: \******************************************************************************
1800: 0002: \******************************************************************************
1801: 0002: 
1802: 0002:   
1803: 0002: 
1804: 0002: FUNCTION UDESC.SET EXTERNAL
1805: 0002: 
1806: 0002:     INTEGER*2 UDESC.SET
1807: 0002:     
1808: 0002: END FUNCTION
1809: 0002: 
1810: 0002: 
1811: 0002: FUNCTION READ.UDESC EXTERNAL
1812: 0002: 
1813: 0002:     INTEGER*2 READ.UDESC
1814: 0002:     
1815: 0002: END FUNCTION                
1816: 0002: 
1817: 0002: 
1818: 0002: 
1819: 0002: \*****************************************************************************
1820: 0002: \*****************************************************************************
1821: 0002: \* PROGRAM.START:                                                            *
1822: 0002: \*                                                                           *
1823: 0002: \*****************************************************************************
1824: 0002: 
1825: 0002: PROGRAM.START:
1826: 0024: 
1827: 0024:        ON ERROR GOTO ERROR.DETECTED
1828: 0039:  
1829: 0039:        GOSUB PROGRAM.INITIALISE
1830: 004b: 	 
1831: 004b:        GOSUB MAIN.PROCESS
1832: 005d: 	  
1833: 005d:        GOSUB PROGRAM.FINALISE
1834: 006f: 	  
1835: 006f:        GOTO PROGRAM.EXIT
1836: 007a: 
1837: 007a: \*****************************************************************************
1838: 007a: \*****************************************************************************
1839: 007a: \* PROGRAM.INITIALISE:                                                       *
1840: 007a: \*       Assign initial variable values;                                     *
1841: 007a: \*              initialise flags                                             *
1842: 007a: \*              assign messages/strings                                      *
1843: 007a: \*                                                                           *
1844: 007a: \*       display startup message                                             *
1845: 007a: \*       call SET file functions : IDF, SOFTS, BCSMF                         *
1846: 007a: \*                                 CCLAM, CCITF, CCTRL, CCRSN,               *
1847: 007a: \*                                 CCSMY, CCDET, CCSTS                       *
1848: 007a: \*       gosub ALLOCATE.SESSION.NUMBERS                                      *
1849: 007a: \*       gosub OPEN.FILES                                                    *
1850: 007a: \*                                                                           *
1851: 007a: \* RETURN                                                                    *
1852: 007a: \*****************************************************************************
1853: 007a: PROGRAM.INITIALISE:
1854: 008a: 
1855: 008a:        FALSE = 0
1856: 009a:        TRUE = 1
1857: 00aa:        EXIT.FLAG = FALSE
1858: 00c0:         EOF.CCSTS.FLAG$ = "N"                                           ! BDCN
1859: 00d7: 
1860: 00d7:        CALL UDESC.SET                                            !1.6AH
1861: 00e4:        GOSUB PROCESS.UDESC                                       !1.6AH
1862: 00f6: 
1863: 00f6:        CALL CCLAM.SET                                                  !1.2MJK
1864: 0103:        MAX.BC.TABLE.SIZE% = 43                                  !1.6AH !1.2MJK
1865: 011a:        SECTOR.SIZE% = 512                                              !1.2MJK
1866: 0131:        SECTOR.RECORD.PART% = 508                                       !1.2MJK
1867: 0148:                                                                        !1.2MJK
1868: 0148:        NUM.OF.SECTORS%      = (SIZE(CCLAM.FILE.NAME$)/SECTOR.SIZE%)-1  !1.2MJK
1869: 0180:        RECORDS.PER.SECTOR%  = (SECTOR.RECORD.PART%/CCLAM.RECL%)        !1.2MJK
1870: 01a3:        MAX.CCLAM.SUBSCRIPT% = NUM.OF.SECTORS%*RECORDS.PER.SECTOR%      !1.2MJK
1871: 01c2:                                                                        !1.2MJK
1872: 01c2:        MAX.REPORT.TABLE.SIZE% = MAX.CCLAM.SUBSCRIPT%                   !1.2MJK
1873: 01db:        MAX.DELETE.TABLE.SIZE% = MAX.CCLAM.SUBSCRIPT%                   !1.2MJK
1874: 01f4: 
1875: 01f4:        REPORT.REC.SIZE% = 84
1876: 020b: 
1877: 020b:        CLAIMS.COUNTER% = 1                                             !1.9JAT
1878: 0222:        EXCEPTION.HEADER.WRITTEN = FALSE                                !1.9JAT
1879: 0238:        CCRSN.OPEN = FALSE                                              !1.9JAT
1880: 024e:        EXCEPTION.ON.REPORT = FALSE                                     !1.9JAT
1881: 0264:        REASON.CODE.ON.REPORT = FALSE                                   !1.9JAT
1882: 027a:        HIGHEST.REASON.CODE% = 0                                        !1.9JAT
1883: 0291: 
1884: 0291:        BLANK.LINE$         = STRING$(75," ")
1885: 02af:        PAGE.THROW$         = STRING$(79," ") + CHR$(12)
1886: 02e2:        STARTUP.MESSAGE$    = START$                                     !1.6AH
1887: 0300:        COMPLETED.MESSAGE$  = "PSS20 completed successfully."
1888: 0317:        FAILED.MESSAGE$     = "PSS20 has failed. Check Application event log."
1889: 032e:        LOG.FAILED.MESSAGE$ = "Application Event Log has failed."
1890: 0345:        PRINT.REPORT.NO$    = " BR0020    "
1891: 035c:        INVALID.BC$         = "UNKNOWN BC    "                           ! CMJK
1892: 0373:        TRAINING.BC$        = "TRAINING BC   "
1893: 038a:        PAGE.NUM.MARKER$    = ">><<"
1894: 03a1:        CANCELLED.LINE$     = STRING$(4," ") +                           \ CMJK
1895: 03eb:                              "+  +  +  +    C A N C E L L E D    " +    \ CMJK
1896: 03eb:                              ADJ$ +   "  +  +  +  +" +                  \ CMJK    !1.6AH
1897: 03eb:                            STRING$(29," ")                              ! CMJK
1898: 03eb: 
1899: 03eb:        OUTPUT.MESSAGE$ = STARTUP.MESSAGE$
1900: 0409:        GOSUB DISPLAY.OUTPUT.MESSAGE
1901: 041b: 
1902: 041b:        CALL IDF.SET
1903: 0436:        CALL SOFTS.SET
1904: 0451:        CALL BCSMF.SET
1905: 046c:        CALL CCITF.SET
1906: 0479:        CALL CCTRL.SET
1907: 0486:        CALL CCRSN.SET
1908: 0493:        CALL CCSMY.SET
1909: 04a0:        CALL CCDET.SET
1910: 04ad:        CALL CCSTS.SET                                                   ! BDCN
1911: 04ba: 
1912: 04ba:        ADX.FUNCTION% = 4                                       ! 1.5AH
1913: 04d1:        ADX.INTEGER% = 0                                        ! 1.5AH
1914: 04e8: 
1915: 04e8:        CALL ADXSERVE(ADX.RETURN.CODE%,    \                    ! 1.5AH
1916: 0536:                      ADX.FUNCTION%,       \                    ! 1.5AH
1917: 0536:                      ADX.INTEGER%,        \                    ! 1.5AH
1918: 0536:                      ADXSERVE.DATA$)                           ! 1.5AH
1919: 0536: 
1920: 0536:        CURRENCY.FORMAT% = VAL(MID$(ADXSERVE.DATA$,7,1))        ! 1.5AH
1921: 0563:        DECIMAL.PLACES%  = VAL(MID$(ADXSERVE.DATA$,23,1))       ! 1.5AH
1922: 0590:        STORE.NUMBER$    = " STORE - " +    \                   ! 4.2HSM
1923: 05be:                           MID$(ADXSERVE.DATA$,1,4)             ! 4.2HSM
1924: 05be:        
1925: 05be:        IF CURRENCY.FORMAT% = 1 THEN BEGIN                      ! 1.5AH
1926: 05d0:           DIVIDER$ = "."                                       ! 1.5AH
1927: 05e9:        ENDIF ELSE BEGIN                                        ! 1.5AH
1928: 05f1:           DIVIDER$ = ","                                       ! 1.5AH
1929: 0608:        ENDIF                                                   ! 1.5AH
1930: 0610: 
1931: 0610:        GOSUB ALLOCATE.SESSION.NUMBERS
1932: 0622:        GOSUB OPEN.FILES
1933: 0634: RETURN
1934: 0644: 
1935: 0644: \*****************************************************************************
1936: 0644: \*****************************************************************************
1937: 0644: \* MAIN.PROCESS:                                                             *
1938: 0644: \*       gosub EVALUATE.SOFTWARE.STATUS                                      *
1939: 0644: \*       If Returns is active                                                *
1940: 0644: \*               gosub EVALUATE.REPORTING.REQUIRED                     !1.3JAS
1941: 0644: \*                             gosub INIT.DESPATCH.6.DAY.DATE          !1.3JAS
1942: 0644: \*                             gosub SETUP.BC.TABLE   (BC = Business Centre) *
1943: 0644: \*                             gosub EXTRACT.CCSTS.CLAIMS                    *
1944: 0644: \*                             gosub SETUP.CLAIMS.TABLES                     *
1945: 0644: \*                             gosub UPDATE.CCSTS.FILE                       *
1946: 0644: \*                             gosub CLAIMS.HOUSEKEEPING               !1.3JAS
1947: 0644: \*                             if Reporting required                   !1.3JAS
1948: 0644: \*                                gosub RET.CLAIMS.REPORTING           !1.3JAS
1949: 0644: \*                             endif                                   !1.3JAS
1950: 0644: \*        endif                                                              *
1951: 0644: \*        gosub UPDATE.CCTRL                                                 *
1952: 0644: \*       set Exit Flag                                                       *
1953: 0644: \*                                                                           *
1954: 0644: \* RETURN                                                                    *
1955: 0644: \*****************************************************************************
1956: 0644: MAIN.PROCESS:
1957: 0654:     
1958: 0654:     WHILE EXIT.FLAG = FALSE
1959: 065f:        GOSUB EVALUATE.SOFTWARE.STATUS
1960: 0671:        IF RETURNS.ACTIVE THEN BEGIN
1961: 0686: 	          
1962: 0686:               GOSUB EVALUATE.REPORTING.REQUIRED                        !1.3JAS
1963: 0698: 			  
1964: 0698:                 GOSUB INIT.DESPATCH.6.DAY.DATE                         !1.3JAS
1965: 06aa: 				 
1966: 06aa:                   GOSUB SETUP.BC.TABLE                                 !1.3JAS
1967: 06bc: 				 
1968: 06bc:                     GOSUB EXTRACT.CCSTS.CLAIMS                          ! BDCN
1969: 06ce: 					 
1970: 06ce:                     GOSUB SETUP.CLAIMS.TABLES
1971: 06e0: 					 
1972: 06e0:                     GOSUB UPDATE.CCSTS.FILE                             ! BDCN
1973: 06f2: 					 
1974: 06f2:                     GOSUB CLAIMS.HOUSEKEEPING                          !1.3JAS
1975: 0704: 					 
1976: 0704:                     IF REPORTING.REQUIRED THEN BEGIN                   !1.3JAS
1977: 0716: 					    
1978: 0716:                        GOSUB RET.CLAIMS.REPORTING                      !1.3JAS
1979: 0728: 					    
1980: 0728:                     ENDIF                                              !1.3JAS
1981: 0730:        ENDIF
1982: 0738: 	   
1983: 0738:        GOSUB UPDATE.CCTRL
1984: 074a: 	  
1985: 074a:        EXIT.FLAG = TRUE
1986: 0760:     WEND
1987: 077b: RETURN
1988: 078b: 
1989: 078b: \*****************************************************************************
1990: 078b: \*****************************************************************************
1991: 078b: \* PROGRAM.FINALISE:                                                         *
1992: 078b: \*       gosub CLOSE.FILES                                                   *
1993: 078b: \*       gosub DEALLOCATE.SESSION.NUMBERS                                    *
1994: 078b: \*                                                                           *
1995: 078b: \* RETURN                                                                    *
1996: 078b: \*****************************************************************************
1997: 078b: PROGRAM.FINALISE:
1998: 079b:        GOSUB CLOSE.FILES
1999: 07ad:        GOSUB DEALLOCATE.SESSION.NUMBERS
2000: 07bf: RETURN
2001: 07cf: 
2002: 07cf: \*****************************************************************************
2003: 07cf: \*****************************************************************************
2004: 07cf: \* PROGRAM.EXIT:                                                             *
2005: 07cf: \*       If not display output error condition                               *
2006: 07cf: \*              display appropriate success or fail message                  *
2007: 07cf: \*        endif                                                              *
2008: 07cf: \*       Terminate program execution                                         *
2009: 07cf: \*                                                                           *
2010: 07cf: \*****************************************************************************
2011: 07cf: PROGRAM.EXIT:
2012: 07df:        IF NOT DISPLAY.OUTPUT.ERROR THEN BEGIN
2013: 07f1:               IF PROGRAM.FAIL THEN BEGIN
2014: 0803:                          OUTPUT.MESSAGE$ = FAILED.MESSAGE$
2015: 0823:               ENDIF ELSE BEGIN
2016: 082b:                      OUTPUT.MESSAGE$ = COMPLETED.MESSAGE$
2017: 0849:               ENDIF
2018: 0851:        ENDIF
2019: 0859:        GOSUB DISPLAY.OUTPUT.MESSAGE
2020: 086b: 
2021: 086b:        STOP
2022: 0878: 
2023: 0878: \*****************************************************************************
2024: 0878: \*****************************************************************************
2025: 0878: \* EVALUATE.SOFTWARE.STATUS:                                                 *
2026: 0878: \*        Read SOFTS record 5                                                *
2027: 0878: \*        set Returns Active flag as appropriate                             *
2028: 0878: \*        Read SOFTS record 19                                               *
2029: 0878: \*        This is used to deterine which value to use for exceptional        *
2030: 0878: \*        reporting.                                                         *
2031: 0878: \*        Read SOFTS record 43, Set CREDIT CLAIM ACTIVE flag as appropriate  *
2032: 0878: \*        Set Exception values as appropriate.                               *
2033: 0878: \*                                                                           *
2034: 0878: \* RETURN                                                                    *
2035: 0878: \*****************************************************************************
2036: 0878: EVALUATE.SOFTWARE.STATUS:
2037: 0888:        SOFTS.REC.NUM% = 5
2038: 089f:        RC% = READ.SOFTS
2039: 08ba:        IF RC% <> 0 THEN BEGIN
2040: 08d9:           GOSUB READ.FILE.ERROR
2041: 08eb:        ENDIF
2042: 08f3:        IF SOFTS.RECORD$ = "RETURNS IS ACTIVE" THEN BEGIN
2043: 0911:           RETURNS.ACTIVE = TRUE
2044: 0927:        ENDIF
2045: 092f: 
2046: 092f:        SOFTS.REC.NUM% = 19                                                          !1.9JAT
2047: 0946:        RC% = READ.SOFTS                                                             !1.9JAT
2048: 0961:        IF RC% <> 0 THEN BEGIN                                                       !1.9JAT
2049: 0980:           GOSUB READ.FILE.ERROR                                                     !1.9JAT
2050: 0992:        ENDIF                                                                        !1.9JAT
2051: 099a:        IF LEFT$(SOFTS.RECORD$,20) = "EIRE STORE IS ACTIVE" THEN BEGIN               !1.9JAT
2052: 09cf:           LOCATION$ = "EIRE"                                                        !1.9JAT
2053: 09e8:        ENDIF ELSE BEGIN                                                             !1.9JAT
2054: 09f0:           LOCATION$ = "UK"                                                          !1.9JAT
2055: 0a07:        ENDIF                                                                        !1.9JAT
2056: 0a0f: 
2057: 0a0f:        CREDIT.CLAIM.ACTIVE = FALSE                                                  !1.9JAT
2058: 0a25:        SOFTS.REC.NUM% = 43                                                          !1.9JAT
2059: 0a3c:        RC% = READ.SOFTS                                                             !1.9JAT
2060: 0a57:        IF RC% <> 0 THEN BEGIN                                                       !1.9JAT
2061: 0a76:           GOSUB READ.FILE.ERROR                                                     !1.9JAT
2062: 0a88:        ENDIF                                                                        !1.9JAT
2063: 0a90:        IF LEFT$(SOFTS.RECORD$,22) = "CREDIT CLAIM IS ACTIVE" THEN BEGIN             !1.9JAT
2064: 0ac8:           CREDIT.CLAIM.ACTIVE = TRUE                                                !1.9JAT
2065: 0ade: 
2066: 0ade:            MATCH.DELIMITER1 = MATCH(",",SOFTS.RECORD$,26)                           !1.9JAT
2067: 0b03:            MATCH.DELIMITER2 = MATCH(",",SOFTS.RECORD$,(MATCH.DELIMITER1 + 1))       !1.9JAT
2068: 0b31:            UK.CLAIM.EXCEPTION.VALUE$= MID$(SOFTS.RECORD$,26,(MATCH.DELIMITER1 - 26))!1.9JAT
2069: 0b61:            ROI.CLAIM.EXCEPTION.VALUE$ = MID$(SOFTS.RECORD$,(MATCH.DELIMITER1 + 1), \!1.9JAT
2070: 0ba3:                                          (MATCH.DELIMITER2 - (MATCH.DELIMITER1 +1)))!1.9JAT
2071: 0ba3: 
2072: 0ba3:            IF LOCATION$ = "EIRE" THEN BEGIN                                         !1.9JAT
2073: 0bc1:               CLAIM.EXCEPTION.VALUE% = VAL(ROI.CLAIM.EXCEPTION.VALUE$)              !1.9JAT
2074: 0be8:               CURRENCY.SYMBOL$ = "EUR "                                             !1.9JAT
2075: 0c01:            ENDIF ELSE BEGIN                                                         !1.9JAT
2076: 0c09:               CLAIM.EXCEPTION.VALUE% = VAL(UK.CLAIM.EXCEPTION.VALUE$)               !1.9JAT
2077: 0c30:               CURRENCY.SYMBOL$ = "GBP "                                             !1.9JAT
2078: 0c47:            ENDIF                                                                    !1.9JAT
2079: 0c4f:        ENDIF
2080: 0c57: RETURN
2081: 0c67: 
2082: 0c67: 
2083: 0c67: 
2084: 0c67: \*****************************************************************************
2085: 0c67: \*****************************************************************************
2086: 0c67: \* EVALUATE.REPORTING.REQUIRED:                                        !1.3JAS
2087: 0c67: \*        Read CCTRL file for Last Credit Run Date                           *
2088: 0c67: \*        If today is a Sunday                                               *      !4.1BMG
2089: 0c67: \*           set Reporting Required to true                            !1.3JAS
2090: 0c67: \*        else                                                               *
2091: 0c67: \*           If last Credit Run Date < last Sunday's date               !1.4RD      !4.1BMG
2092: 0c67: \*              set Reporting Required to true                         !1.3JAS
2093: 0c67: \*           endif                                                           *
2094: 0c67: \*        endif                                                              *
2095: 0c67: \*                                                                           *
2096: 0c67: \* RETURN                                                                    *
2097: 0c67: \*****************************************************************************
2098: 0c67: EVALUATE.REPORTING.REQUIRED:                                           !1.3JAS
2099: 0c77:        CCTRL.REC.NUM% = 1
2100: 0c88:        RC% = READ.CCTRL
2101: 0ca3:        IF RC% <> 0 THEN BEGIN
2102: 0cc2:               GOSUB READ.FILE.ERROR
2103: 0cd4:        ENDIF
2104: 0cdc:        LAST.CREDIT.RUN.DATE$ = UNPACK$(CCTRL.CREDIT.RPT.RUN.DATE$)
2105: 0cff: 
2106: 0cff:        TODAYS.DATE$ = DATE$
2107: 0d17:        RC% = PSDATE(TODAYS.DATE$)
2108: 0d40:        IF RC% <> 0 THEN BEGIN
2109: 0d5f:               OUTPUT.MESSAGE$ = "System Date is invalid."
2110: 0d76:               GOSUB DISPLAY.OUTPUT.MESSAGE
2111: 0d88:               PROGRAM.FAIL = TRUE
2112: 0d9e:               GOTO PROGRAM.EXIT
2113: 0da9:        ENDIF
2114: 0db1:        IF F13.DAY$ = "SUN" THEN BEGIN                                  !4.1BMG
2115: 0dcf:               REPORTING.REQUIRED = TRUE                                !1.3JAS
2116: 0de8:        ENDIF ELSE BEGIN
2117: 0df0: 
2118: 0df0:               F02.DATE$ = TODAYS.DATE$
2119: 0e0e:               INCREMENT% = -1
2120: 0e25:               WHILE F13.DAY$ <> "SUN"                                  !4.1BMG
2121: 0e30:                      RC% = UPDATE.DATE(INCREMENT%)
2122: 0e59:                      IF RC% <> 0 THEN BEGIN
2123: 0e78:                             PROGRAM.FAIL = TRUE
2124: 0e8e:                             GOTO PROGRAM.EXIT
2125: 0e99:                      ENDIF
2126: 0ea1:                      RC% = PSDATE(F02.DATE$)
2127: 0eca:                      IF RC% <> 0 THEN BEGIN
2128: 0ee9:                             PROGRAM.FAIL = TRUE
2129: 0eff:                             GOTO PROGRAM.EXIT
2130: 0f0a:                      ENDIF
2131: 0f12:               WEND
2132: 0f33:               IF DATE.LT(LAST.CREDIT.RUN.DATE$,F02.DATE$) THEN BEGIN    !1.4RD
2133: 0f5d:                      REPORTING.REQUIRED = TRUE                         !1.3JAS
2134: 0f73:               ENDIF
2135: 0f7b:        ENDIF
2136: 0f83: 
2137: 0f83: RETURN
2138: 0f93: 
2139: 0f93: \*****************************************************************************
2140: 0f93: \*****************************************************************************
2141: 0f93: \***                                                                         *
2142: 0f93: \***    PROCESS.UDESC:                                                       *
2143: 0f93: \***                                                                         *
2144: 0f93: \***    Allocate session number                                              *
2145: 0f93: \***    Read in report descriptors                                           *
2146: 0f93: \***                                                                         *
2147: 0f93: \***                                                                         *
2148: 0f93: \*****************************************************************************
2149: 0f93: 
2150: 0f93: PROCESS.UDESC:                                                     !1.6AH
2151: 0fa3: 
2152: 0fa3:       F20.FUNCTION$ = "O"                                          !1.6AH
2153: 0fba:       F20.INTEGER%  = UDESC.REPORT.NUM%                            !1.6AH
2154: 0fd0:       F20.STRING$   = UDESC.FILE.NAME$                             !1.6AH
2155: 0fee:       GOSUB CALL.SESS.NUM.UTILITY                                  !1.6AH
2156: 1000:       UDESC.SESS.NUM% = F20.INTEGER.FILE.NO%                       !1.6AH
2157: 1016: 
2158: 1016:       OPEN "USERDESC" RECL 49 AS UDESC.SESS.NUM% NOWRITE NODEL     !1.6AH
2159: 1037: 
2160: 1037:       UDESC.RECORD.NUM% = 1                                        !1.6AH
2161: 1048:       CALL READ.UDESC                                              !1.6AH
2162: 1055:       START$ = UDESC.RECORD$                                       !1.6AH
2163: 1073: 
2164: 1073:       UDESC.RECORD.NUM% = 2                                        !1.6AH
2165: 1084:       CALL READ.UDESC                                              !1.6AH
2166: 1091:       ADJ$ = UDESC.RECORD$                                         !1.6AH
2167: 10af: 
2168: 10af:       UDESC.RECORD.NUM% = 3                                        !1.6AH
2169: 10c0:       CALL READ.UDESC                                              !1.6AH
2170: 10cd:       NUMB$ = UDESC.RECORD$                                        !1.6AH
2171: 10eb: 
2172: 10eb:       UDESC.RECORD.NUM% = 4                                        !1.6AH
2173: 10fc:       CALL READ.UDESC                                              !1.6AH
2174: 1109:       TITLE$ = UDESC.RECORD$                                       !1.6AH
2175: 1127: 
2176: 1127:       UDESC.RECORD.NUM% = 5                                        !1.6AH
2177: 1138:       CALL READ.UDESC                                              !1.6AH
2178: 1145:       UNIT$ = UDESC.RECORD$                                        !1.6AH
2179: 1163: 
2180: 1163:       UDESC.RECORD.NUM% = 6                                        !1.6AH
2181: 1174:       CALL READ.UDESC                                              !1.6AH
2182: 1181:       DAT$ = UDESC.RECORD$                                         !1.6AH
2183: 119f: 
2184: 119f: 
2185: 119f: RETURN                                                             !1.6AH
2186: 11af: 
2187: 11af: \*****************************************************************************
2188: 11af: \*****************************************************************************
2189: 11af: \* SETUP.BC.TABLE:                                                           *
2190: 11af: \*         The Business Centre (BC) Table holds the Business Centre letter   *
2191: 11af: \*         Code, Name, BCSMF sequence number and credit claim number.        *
2192: 11af: \*         The table has 26 entries and records are placed in the table      *
2193: 11af: \*         position corresponding to the ASCII number of the letter code     *
2194: 11af: \*         (A to Z being 1 to 26, ASC(A)-64 = 65-64 = 1 etc)                 *
2195: 11af: \*         Each entry is initialised with name "UNKNOWN BC" and inc sequence *
2196: 11af: \*         no."30" along with letter codes A to Z, then entries corresponding*
2197: 11af: \*         to the BCSMF are updated with valid data, the last but one entry) *
2198: 11af: \*         (Z) is set to "TRAINING BC " and sequence no. "99";               *
2199: 11af: \*                                                                           *
2200: 11af: \*         dimension BC Table                                                *
2201: 11af: \*         initialise each entry in BC Table (seq.no = 0, 'INVALID BC')      *
2202: 11af: \*         initialise 2nd to last (Z) entry in BC Table (seq.no=0,'TRAINING  *
2203: 11af: \*         BC') calculate number of sectors and no. of records per sector    *
2204: 11af: \*         for BCSMF read direct BCSMF file sector by sector, record by      *
2205: 11af: \*         record, until all sectors have been read                          *
2206: 11af: \*         for each Business Centre Record;                                  *
2207: 11af: \*         update the BC Table entry corresponding to the BC letter code     *
2208: 11af: \*         with the valid name and sequence number                           *
2209: 11af: \*                                                                           *
2210: 11af: \* RETURN                                                                    *
2211: 11af: \*****************************************************************************
2212: 11af: SETUP.BC.TABLE:
2213: 11bf:         DIM BC.TABLE$ (MAX.BC.TABLE.SIZE%)
2214: 11f8:        FOR BC.TAB.IDX% = 1 TO (MAX.BC.TABLE.SIZE%)
2215: 1212:           IF BC.TAB.IDX% > 9 AND BC.TAB.IDX% < 17 THEN BEGIN            !1.6AH
2216: 124f:              BC.TABLE$(BC.TAB.IDX%) = STRING$(25," ")                   !1.6AH! CMJK
2217: 1286:           ENDIF ELSE BEGIN                                              !1.6AH
2218: 128e:             BC.TABLE$(BC.TAB.IDX%) = CHR$(48 + BC.TAB.IDX%) +        \  !1.6AH
2219: 1332:                                      INVALID.BC$ +                   \
2220: 1332:                                  RIGHT$("00"+STR$(29+BC.TAB.IDX%),2) \   CMJK
2221: 1332:                                  + "00000000"                           ! CMJK
2222: 1332:           ENDIF
2223: 133a:        NEXT BC.TAB.IDX%
2224: 1372: 
2225: 1372:        BC.TAB.IDX% = MAX.BC.TABLE.SIZE%-1                               ! CMJK
2226: 138f:         BC.TABLE$(BC.TAB.IDX%) = CHR$(48 + BC.TAB.IDX%) +                    \
2227: 13ee:                                TRAINING.BC$ +                                \
2228: 13ee:                              "99" + "00000000"                          ! BDCN
2229: 13ee: 
2230: 13ee:        NUM.OF.SECTORS% = SIZE(BCSMF.FILE.NAME$) / SECTOR.SIZE%
2231: 141b:        RECORDS.PER.SECTOR% = SECTOR.RECORD.PART% / BCSMF.RECL%
2232: 143e: 
2233: 143e:        FOR SECTOR.NO% = 2 TO NUM.OF.SECTORS%
2234: 1458:            GOSUB READ.BCSMF.SECTOR
2235: 146a:            FOR RECORD.NO% = 1 TO RECORDS.PER.SECTOR%
2236: 1484:                BCSMF.RECORD$ = MID$(BCSMF.SECTOR$,                           \
2237: 14da:                                 ((RECORD.NO% - 1)*BCSMF.RECL%) + 1,          \
2238: 14da:                                  BCSMF.RECL%)
2239: 14da:               IF LEFT$(BCSMF.RECORD$,4) = PACK$(STRING$(4,"00")) THEN        \
2240: 151b:                   BEGIN
2241: 151b:                   GOTO NEXT.SECT
2242: 1527:               ENDIF ELSE BEGIN
2243: 152f:                   GOSUB PROCESS.BCSMF.RECORD
2244: 1541:               ENDIF
2245: 1549:            NEXT RECORD.NO%
2246: 1581:        NEXT.SECT:
2247: 1591:        NEXT SECTOR.NO%
2248: 15c9: RETURN
2249: 15d9: 
2250: 15d9: \*****************************************************************************
2251: 15d9: \*****************************************************************************
2252: 15d9: \* PROCESS.BCSMF.RECORD:                                                     *
2253: 15d9: \*     If BC is not Training BC ("Z")                                        *
2254: 15d9: \*     and not Pseudo Business Center (flag not = "Y")                       *
2255: 15d9: \*         save BC letter Code,Name and Sequence No. to corresponding        *
2256: 15d9: \*         BC Table entry and initialise claim number                        *
2257: 15d9: \*     endif                                                                 *
2258: 15d9: \*                                                                           *
2259: 15d9: \* RETURN                                                                    *
2260: 15d9: \*****************************************************************************
2261: 15d9: PROCESS.BCSMF.RECORD:
2262: 15e9:     IF  (LEFT$(BCSMF.RECORD$,1) <> "Z")                                      \
2263: 1669:     AND (MID$(BCSMF.RECORD$,29,1) <> "Y") THEN BEGIN                    ! BDCN
2264: 1669:         BC.TAB.IDX% = ASC(LEFT$(BCSMF.RECORD$,1)) - 48
2265: 169e:         BC.TABLE$(BC.TAB.IDX%) =                                             \
2266: 176b:                  LEFT$(BCSMF.RECORD$,1) +                                    \
2267: 176b:                    MID$(BCSMF.RECORD$,2,14) +                                \
2268: 176b:                 RIGHT$("00" + STR$(ASC(MID$(BCSMF.RECORD$,28,1))),2) +       \
2269: 176b:                  "00000000"                                             ! BDCN
2270: 176b:     ENDIF
2271: 1773: RETURN
2272: 1783: 
2273: 1783: 
2274: 1783: 
2275: 1783: 
2276: 1783: \*****************************************************************************
2277: 1783: \***                                                                         *
2278: 1783: \***    EXTRACT.CCSTS.CLAIMS:                                                *
2279: 1783: \***                                                                         *
2280: 1783: \***     Update BC table with current claim numbers from CCSTS records       *
2281: 1783: \***                                                                         *
2282: 1783: \*****************************************************************************
2283: 1783: 
2284: 1783:     EXTRACT.CCSTS.CLAIMS:
2285: 1793: 
2286: 1793:     CURRENT.REPORT.NUM% = CCSTS.REPORT.NUM%                             ! BDCN
2287: 17a9:     IF END #CCSTS.SESS.NUM% THEN OPEN.FILE.ERROR                        ! BDCN
2288: 17c5:     OPEN CCSTS.FILE.NAME$ DIRECT RECL CCSTS.RECL% AS CCSTS.SESS.NUM%    ! BDCN
2289: 17f1: 
2290: 17f1:     CCSTS.REC.NUM% = 1
2291: 1802: 
2292: 1802:     WHILE EOF.CCSTS.FLAG$ = "N"
2293: 180d:        CURRENT.REPORT.NUM% = CCSTS.REPORT.NUM%
2294: 1823:        RC% = READ.CCSTS
2295: 183e:        IF RC% <> 0 THEN GOTO CCSTS.READ.FAIL
2296: 1860:                                                                                
2297: 1860:        BC.TAB.IDX% = ASC(CCSTS.FSI$) - 48                              !1.6AH
2298: 1889:        IF BC.TAB.IDX% > 0 AND                                          \ BDCN
2299: 18cc:           BC.TAB.IDX% <= MAX.BC.TABLE.SIZE% THEN BEGIN                 ! BDCN
2300: 18cc: 
2301: 18cc:               BC.TABLE$(BC.TAB.IDX%)  =                                \ BDCN
2302: 1967:                    LEFT$(BC.TABLE$(BC.TAB.IDX%),17) +                  \ BDCN
2303: 1967:                    RIGHT$( STRING$(8,"0") + CCSTS.CLAIM$, 8)           ! BDCN
2304: 1967: 
2305: 1967:        ENDIF                                                           ! BDCN
2306: 196f:        CCSTS.REC.NUM% = CCSTS.REC.NUM% + 1                             ! BDCN
2307: 197e: 
2308: 197e:        RETURN.CCSTS.READ.FAIL:
2309: 198e: 
2310: 198e:     WEND
2311: 19af: 
2312: 19af:     RETURN
2313: 19bf: 
2314: 19bf: 
2315: 19bf: \*****************************************************************************
2316: 19bf: \*****************************************************************************
2317: 19bf: \* SETUP.CLAIMS.TABLES:                                                      *
2318: 19bf: \*     calculate number of sectors and no. of records per sector for CCLAM   *
2319: 19bf: \*     dimension tables and initialise table indices                         *
2320: 19bf: \*     open CCLAM in Direct mode                                             *
2321: 19bf: \*     read CCLAM file sector by sector, record by record until all sectors  *
2322: 19bf: \*     have been read                                                        *
2323: 19bf: \*     for each record gosub PROCESS.CCLAM.RECORD                            *
2324: 19bf: \*     close CCLAM file                                                      *
2325: 19bf: \*     store table number of entries ( = table indices -1 )                  *
2326: 19bf: \*     if Returns is Active                                                  *
2327: 19bf: \*         gosub SORT.REPORT.TABLE (sorts by BC sequence no., claim no.)     *
2328: 19bf: \*     endif                                                                 *
2329: 19bf: \*                                                                           *
2330: 19bf: \* RETURN                                                                    *
2331: 19bf: \*****************************************************************************
2332: 19bf: SETUP.CLAIMS.TABLES:
2333: 19cf:        NUM.OF.SECTORS% = SIZE(CCLAM.FILE.NAME$) / SECTOR.SIZE%
2334: 19fc:        RECORDS.PER.SECTOR% = SECTOR.RECORD.PART% / CCLAM.RECL%
2335: 1a1f: 
2336: 1a1f:        DIM REPORT.TABLE$ (MAX.REPORT.TABLE.SIZE%)
2337: 1a58:        DIM DELETE.TABLE$ (MAX.DELETE.TABLE.SIZE%)
2338: 1a91:        DIM NEW.CLAIM.RECORDS$(MAX.REPORT.TABLE.SIZE%)             !1.9JAT
2339: 1aca:        DIM NEW.REASON.CODE.RECORDS$(100)                          !1.9JAT
2340: 1af9: 
2341: 1af9:        RPT.TAB.IDX% = 1
2342: 1b10:        DEL.TAB.IDX% = 1
2343: 1b27: 
2344: 1b27:        GOSUB OPEN.CCLAM.DIRECT
2345: 1b39: 
2346: 1b39:        FOR SECTOR.NO% = 2 TO NUM.OF.SECTORS%
2347: 1b53:            GOSUB READ.CCLAM.SECTOR
2348: 1b65:            FOR RECORD.NO% = 1 TO RECORDS.PER.SECTOR%
2349: 1b7f:                      CCLAM.RECORD$ = MID$ (CCLAM.SECTOR$,                    \
2350: 1bd5:                                    ((RECORD.NO% - 1)*CCLAM.RECL%)+ 1,        \
2351: 1bd5:                                    CCLAM.RECL%)
2352: 1bd5:               IF LEFT$(CCLAM.RECORD$,4) = PACK$(STRING$(4,"00")) THEN        \
2353: 1c16:                   BEGIN
2354: 1c16:                   GOTO NEXT.SECTOR
2355: 1c22:                   ENDIF ELSE BEGIN
2356: 1c2a:                   GOSUB PROCESS.CCLAM.RECORD
2357: 1c3c:               ENDIF
2358: 1c44:            NEXT RECORD.NO%
2359: 1c7c:        NEXT.SECTOR:
2360: 1c8c:        NEXT SECTOR.NO%
2361: 1cc4: 
2362: 1cc4:        CLOSE CCLAM.SESS.NUM%
2363: 1cd8:        CCLAM.OPEN = FALSE
2364: 1cee: 
2365: 1cee:        RPT.TAB.NO.ENTRIES% = RPT.TAB.IDX% - 1
2366: 1d0b:        DEL.TAB.NO.ENTRIES% = DEL.TAB.IDX% - 1
2367: 1d28: 
2368: 1d28:        IF RETURNS.ACTIVE THEN BEGIN
2369: 1d3a:               GOSUB SORT.REPORT.TABLE
2370: 1d4c:        ENDIF
2371: 1d54: RETURN
2372: 1d64: 
2373: 1d64: \*****************************************************************************  !1.3JAS
2374: 1d64: \*****************************************************************************  !1.3JAS
2375: 1d64: \* INIT.DESPATCH.6.DAY.DATE:                                           !1.3JAS
2376: 1d64: \*     To check if the date of despatch was > than 6 days ago          !1.3JAS
2377: 1d64: \*                                                                     !1.3JAS
2378: 1d64: \* RETURN                                                              !1.3JAS
2379: 1d64: \*****************************************************************************
2380: 1d64: 
2381: 1d64: INIT.DESPATCH.6.DAY.DATE:                                              !1.3JAS
2382: 1d74:      F02.DATE$ = TODAYS.DATE$                                          !1.3JAS
2383: 1d92:      INCREMENT% = -6                                                   !1.3JAS
2384: 1da9:      RC% = UPDATE.DATE(INCREMENT%)                                     !1.3JAS
2385: 1dd2:      IF RC% <> 0 THEN BEGIN                                            !1.3JAS
2386: 1df1:         PROGRAM.FAIL = TRUE                                            !1.3JAS
2387: 1e07:         GOTO PROGRAM.EXIT                                              !1.3JAS
2388: 1e12:      ENDIF                                                             !1.3JAS
2389: 1e1a:      SIX.DAYS.DATE$ = F02.DATE$                                        !1.3JAS
2390: 1e38: RETURN                                                                 !1.3JAS
2391: 1e48: 
2392: 1e48: \*****************************************************************************
2393: 1e48: \*****************************************************************************
2394: 1e48: \* PROCESS.CCLAM.RECORD:                                                     *
2395: 1e48: \*      move CCLAM record data into CCLAM fields                             *
2396: 1e48: \*      if returns is active                                                 *
2397: 1e48: \*          Calculate BC.Table index from CCLAM BC letter                    *
2398: 1e48: \*          If CCLAM credit claim number > BC table entry claim number       *
2399: 1e48: \*              save CCLAM credit claim no. in BC table                      *
2400: 1e48: \*          endif                                                            *
2401: 1e48: \*          if Reporting required and not a cancelled UOD              !1.3JAS
2402: 1e48: \*              gosub RET.CLAIM.TO.RPT.TABLE                                 *
2403: 1e48: \*          endif                                                            *
2404: 1e48: \*       endif                                                               *
2405: 1e48: \*       if older than six days AND CCLAM Retrieval Flag = "N"          !1.4RD
2406: 1e48: \*       and it has previously been reported                                 *
2407: 1e48: \*            gosub SAVE.CLAIM.TO.DELETE.TABLE                               *
2408: 1e48: \*       endif                                                               *
2409: 1e48: \*                                                                           *
2410: 1e48: \* RETURN                                                                    *
2411: 1e48: \*****************************************************************************
2412: 1e48: PROCESS.CCLAM.RECORD:
2413: 1e58:        CCLAM.CREDIT.CLAIM.NUM$ = MID$(CCLAM.RECORD$,1,4)
2414: 1e7f:        CCLAM.NUM.OF.ITEMS%     = CONV.TO.INTEGER(MID$(CCLAM.RECORD$,12,2)) !BDCN
2415: 1ec2:        CCLAM.BC.LETTER$        = MID$(CCLAM.RECORD$,16,1)
2416: 1ee9:        CCLAM.AUTHORISATION$    = MID$(CCLAM.RECORD$,25,15)
2417: 1f10:        CCLAM.FILLER$           = MID$(CCLAM.RECORD$,154,7)                            !4.2HSM
2418: 1f38: 
2419: 1f38: !       IF ASC(CCLAM.BC.LETTER$)<65 OR ASC(CCLAM.BC.LETTER$)>90 THEN     \CMJK  1.7JAS
2420: 1f38: !          CCLAM.BC.LETTER$ = CHR$(91)                                    !CMJK  1.7JAS
2421: 1f38: 
2422: 1f38:        IF ASC(CCLAM.BC.LETTER$) > 90 THEN BEGIN                                       !1.8BMG
2423: 1f55:           CCLAM.BC.LETTER$ = CHR$(91)                                                 !1.8BMG
2424: 1f72:        ENDIF ELSE BEGIN                                                               !1.8BMG
2425: 1f7a:           IF ASC(CCLAM.BC.LETTER$) < 65 THEN BEGIN                                    !1.8BMG
2426: 1f97:              IF ASC(CCLAM.BC.LETTER$) < 49 OR ASC(CCLAM.BC.LETTER$) > 57 THEN BEGIN   !1.8BMG
2427: 1fdb:                 CCLAM.BC.LETTER$ = CHR$(91)                                           !1.8BMG
2428: 1ff5:              ENDIF                                                                    !1.8BMG
2429: 1ffd:           ENDIF                                                                       !1.8BMG
2430: 2005:        ENDIF                                                                          !1.8BMG
2431: 200d: 
2432: 200d: 
2433: 200d:        CCLAM.REASON.NUM$        = MID$(CCLAM.RECORD$,65,1)
2434: 2034:        CCLAM.DATE.OF.CLAIM$     = MID$(CCLAM.RECORD$,145,3)
2435: 205c:        CCLAM.RETRIEVAL.FLAG$    = MID$(CCLAM.RECORD$,151,1)
2436: 2084:        CCLAM.CF.RPT.MARKER$     = MID$(CCLAM.RECORD$,152,1)
2437: 20ac:        CCLAM.CANC.MARKER$       = MID$(CCLAM.RECORD$,153,1)              !CMJK
2438: 20d4: 
2439: 20d4: 
2440: 20d4:        IF RETURNS.ACTIVE THEN BEGIN
2441: 20e9:             BC.TAB.IDX%  = ASC(CCLAM.BC.LETTER$) - 48                   ! BDCN
2442: 2112:             IF BC.TAB.IDX% > 0 AND                                      \ BDCN
2443: 2155:                BC.TAB.IDX% <= MAX.BC.TABLE.SIZE% THEN BEGIN             ! BDCN
2444: 2155:                IF VAL(UNPACK$(CCLAM.CREDIT.CLAIM.NUM$)) >               \ BDCN
2445: 21ce:                   VAL(MID$(BC.TABLE$(BC.TAB.IDX%),18,8)) THEN BEGIN     ! BDCN
2446: 21ce: 
2447: 21ce:                   BC.TABLE$(BC.TAB.IDX%)  =                             \ BDCN
2448: 2279:                    LEFT$(BC.TABLE$(BC.TAB.IDX%),17) +                   \ BDCN
2449: 2279:                    RIGHT$( STRING$(8,"0") +                             \
2450: 2279:                    UNPACK$(CCLAM.CREDIT.CLAIM.NUM$),8 )                 ! BDCN
2451: 2279: 
2452: 2279:                ENDIF                                                    ! BDCN
2453: 2281:             ENDIF                                                       ! BDCN
2454: 2289:                                                                         ! BDCN
2455: 2289:             IF REPORTING.REQUIRED AND                                  \1.3JAS
2456: 231d:              DATE.GE (UNPACK$(CCLAM.DATE.OF.CLAIM$),                    \1.4RD
2457: 231d:                       LAST.CREDIT.RUN.DATE$) AND                        \1.4RD
2458: 231d:              CCLAM.CANC.MARKER$ <> "Y" AND                              \1.3JAS
2459: 231d:              CCLAM.RETRIEVAL.FLAG$ <> "Z" THEN BEGIN                    !1.1MJK
2460: 231d:              GOSUB RET.CLAIM.TO.REPORT.TABLE
2461: 232f:              IF CREDIT.CLAIM.ACTIVE = TRUE THEN BEGIN                   !1.9JAT
2462: 2347:                 GOSUB UPDATE.CLAIMS.TABLE                               !1.9JAT
2463: 2359:              ENDIF                                                      !1.9JAT
2464: 2361:             ENDIF                                                       !1.9JAT
2465: 2369: 
2466: 2369:        ENDIF
2467: 2371:           IF CCLAM.RETRIEVAL.FLAG$ = "N" AND                           \1.3JAS
2468: 240a:            DATE.LT (UNPACK$(CCLAM.DATE.OF.CLAIM$),SIX.DAYS.DATE$) AND   \1.4RD
2469: 240a:              DATE.LT (UNPACK$(CCLAM.DATE.OF.CLAIM$),                    \1.4RD
2470: 240a:                       LAST.CREDIT.RUN.DATE$) THEN BEGIN                 !1.4RD
2471: 240a:               GOSUB SAVE.CLAIM.TO.DELETE.TABLE
2472: 241c:        ENDIF
2473: 2424: RETURN
2474: 2434: 
2475: 2434: \*****************************************************************************
2476: 2434: \***                                                                         *
2477: 2434: \***    UPDATE.CCSTS.FILE:                                                   *
2478: 2434: \***                                                                         *
2479: 2434: \***     For each BC table entry                                             *
2480: 2434: \***        If a valid BC entry and not the Training BC                      *
2481: 2434: \***           and BC table entry claim no. is not zero                      *
2482: 2434: \***           Read CCSTS locked                                             *
2483: 2434: \***           Format output record from table entry                         *
2484: 2434: \***           Write CCSTS unlock                                            *
2485: 2434: \***        endif                                                            *
2486: 2434: \***     next entry                                                          *
2487: 2434: \***                                                                         *
2488: 2434: \***     close CCSTS file                                                    *
2489: 2434: \***                                                                         *
2490: 2434: \*****************************************************************************
2491: 2434: 
2492: 2434:     UPDATE.CCSTS.FILE:
2493: 2444: 
2494: 2444:       FOR BC.TAB.IDX% = 1 TO MAX.BC.TABLE.SIZE%                         ! BDCN
2495: 245e: 
2496: 245e:         IF MID$(BC.TABLE$(BC.TAB.IDX%),2,14) <> INVALID.BC$ AND              \
2497: 256a:            MID$(BC.TABLE$(BC.TAB.IDX%),2,14) <> TRAINING.BC$ AND             \
2498: 256a:            MID$(BC.TABLE$(BC.TAB.IDX%),18,8) <> "00000000" THEN BEGIN
2499: 256a: 
2500: 256a:            CCSTS.REC.NUM% = BC.TAB.IDX%                                 ! BDCN
2501: 2584:            CURRENT.REPORT.NUM% = CCSTS.REPORT.NUM%
2502: 259a:            RC% = READ.CCSTS.LOCKED                                      ! BDCN
2503: 25b5:            IF RC% <> 0 THEN GOTO READ.FILE.ERROR                        ! BDCN
2504: 25d7: 
2505: 25d7:            CCSTS.FSI$     = LEFT$(BC.TABLE$(BC.TAB.IDX%),1)             ! BDCN
2506: 2614:            CCSTS.NAME$    = MID$(BC.TABLE$(BC.TAB.IDX%),2,14)           ! BDCN
2507: 2651:            CCSTS.CLAIM$   = MID$(BC.TABLE$(BC.TAB.IDX%),18,8)           ! BDCN
2508: 268e:            CCSTS.FILLER$  = " "                                         ! BDCN
2509: 26a5: 
2510: 26a5:            RC% = WRITE.UNLOCK.CCSTS                                     ! BDCN
2511: 26c0:            IF RC% <> 0 THEN GOTO WRITE.FILE.ERROR                       ! BDCN
2512: 26e2:         ENDIF                                                           ! BDCN
2513: 26ea: 
2514: 26ea:       NEXT BC.TAB.IDX%
2515: 2722: 
2516: 2722:       CLOSE CCSTS.SESS.NUM%
2517: 2736: 
2518: 2736:     RETURN
2519: 2746: 
2520: 2746: 
2521: 2746: \*****************************************************************************
2522: 2746: \*****************************************************************************
2523: 2746: \* RET.CLAIM.TO.REPORT.TABLE:                                                *
2524: 2746: \*        using BC Letter Code from CCLAM record, look up the BC sequence    *
2525: 2746: \*        no. from the BC Table                                              *
2526: 2746: \*        save sequence no. and claim no. to report table                    *
2527: 2746: \*      add 1 to report table index                                          *
2528: 2746: \*      if report table index > max report table size                        *
2529: 2746: \*          log event  126                                                   *
2530: 2746: \*          exit program                                                     *
2531: 2746: \*      endif                                                                *
2532: 2746: \*                                                                           *
2533: 2746: \* RETURN                                                                    *
2534: 2746: \*****************************************************************************
2535: 2746: 
2536: 2746: RET.CLAIM.TO.REPORT.TABLE:
2537: 2756:        BC.TAB.IDX% = ASC(CCLAM.BC.LETTER$) - 48
2538: 277f:        REPORT.TABLE$(RPT.TAB.IDX%) = MID$(BC.TABLE$(BC.TAB.IDX%),16,2)  \!BMJB
2539: 27eb:                                   + CCLAM.CREDIT.CLAIM.NUM$
2540: 27eb:        RPT.TAB.IDX% = RPT.TAB.IDX% + 1
2541: 2804:        IF RPT.TAB.IDX% > MAX.REPORT.TABLE.SIZE% THEN BEGIN
2542: 2824:            LOG.EVENT.NO% = 126
2543: 283b:            LOG.STRING.1.UNIQUE$ = "REPORT TAB"
2544: 2852:            GOSUB LOG.AN.EVENT
2545: 2864:            PROGRAM.FAIL = TRUE
2546: 287a:            GOTO PROGRAM.EXIT
2547: 2885:        ENDIF
2548: 288d: RETURN
2549: 289d: 
2550: 289d: \*****************************************************************************
2551: 289d: \*****************************************************************************
2552: 289d: \* SORT.REPORT.TABLE:                              (Returns only)            *
2553: 289d: \*        if more than 1 entry in report table                               *
2554: 289d: \*              sort report table on BC sequence no.,claim no. ascending     *
2555: 289d: \*       endif                                                               *
2556: 289d: \*                                                                           *
2557: 289d: \* RETURN                                                                    *
2558: 289d: \*****************************************************************************
2559: 289d: SORT.REPORT.TABLE:
2560: 28ad:     IF RPT.TAB.NO.ENTRIES% > 1 THEN BEGIN
2561: 28cc:        GAP = RPT.TAB.NO.ENTRIES%
2562: 28eb:        WHILE NOT SORT.COMPLETE
2563: 28f6:            GAP = INT(GAP / 1.3)
2564: 2923:            IF GAP = 0 THEN GAP = 1
2565: 295a:            IF GAP = 9 OR GAP = 10 THEN GAP = 11
2566: 29cf:            SWAPPED = FALSE
2567: 29e5:            FOR A% = 1 TO (RPT.TAB.NO.ENTRIES% - GAP)
2568: 29ff:                B% = A% + GAP
2569: 2a3c:               IF REPORT.TABLE$(A%) > REPORT.TABLE$(B%) THEN BEGIN
2570: 2a90:                   TEMP$ = REPORT.TABLE$(A%)
2571: 2ac4:                   REPORT.TABLE$(A%) = REPORT.TABLE$(B%)
2572: 2b0e:                   REPORT.TABLE$(B%) = TEMP$
2573: 2b42:                   SWAPPED = TRUE
2574: 2b58:                ENDIF
2575: 2b60:            NEXT A%
2576: 2bb5:            IF (NOT SWAPPED) AND GAP = 1 THEN SORT.COMPLETE = TRUE
2577: 2c00:        WEND
2578: 2c15:     ENDIF
2579: 2c1d: RETURN
2580: 2c2d: 
2581: 2c2d: \*****************************************************************************
2582: 2c2d: \*****************************************************************************
2583: 2c2d: \* SAVE.CLAIM.TO.DELETE.TABLE:                                               *
2584: 2c2d: \*        save claim No.(4 bytes) and No. of Items (4 bytes) to delete table *
2585: 2c2d: \*      add 1 to delete table index                                          *
2586: 2c2d: \*      if delete table index > max delete table size                        *
2587: 2c2d: \*          log event  126                                                   *
2588: 2c2d: \*          exit program                                                     *
2589: 2c2d: \*      endif                                                                *
2590: 2c2d: \*                                                                           *
2591: 2c2d: \* RETURN                                                                    *
2592: 2c2d: \*****************************************************************************
2593: 2c2d: SAVE.CLAIM.TO.DELETE.TABLE:
2594: 2c3d:        DELETE.TABLE$(DEL.TAB.IDX%) = CCLAM.CREDIT.CLAIM.NUM$ +               \
2595: 2cab:                                        RIGHT$("0000" +                       \
2596: 2cab:                                         STR$(CCLAM.NUM.OF.ITEMS%),4)
2597: 2cab:        DEL.TAB.IDX% = DEL.TAB.IDX% + 1
2598: 2cc4:        IF DEL.TAB.IDX% > MAX.DELETE.TABLE.SIZE% THEN BEGIN
2599: 2ce4:            LOG.EVENT.NO% = 126
2600: 2cfb:            LOG.STRING.1.UNIQUE$ = "DELETE TAB"
2601: 2d12:            GOSUB LOG.AN.EVENT
2602: 2d24:            PROGRAM.FAIL = TRUE
2603: 2d3a:            GOTO PROGRAM.EXIT
2604: 2d45:        ENDIF
2605: 2d4d: RETURN
2606: 2d5d: 
2607: 2d5d: 
2608: 2d5d: \*****************************************************************************
2609: 2d5d: \*****************************************************************************
2610: 2d5d: \* RET.CLAIMS.REPORTING:                                                     *
2611: 2d5d: \*       this is the controlling routine for producing the Returns Credit    *
2612: 2d5d: \*       Claiming Summary and Detail Reports (CCSMY and CCDET)               *
2613: 2d5d: \*                                                                           *
2614: 2d5d: \*       gosub RET.RPT.START                                                 *
2615: 2d5d: \*       repeat until End of Report                                          *
2616: 2d5d: \*           gosub RET.RPT.PROCESS.BC                                        *
2617: 2d5d: \*       end repeat                                                          *
2618: 2d5d: \*       gosub RET.RPT.END                                                   *
2619: 2d5d: \*       gosub RET.RPT.NUM.OF.PAGES                                          *
2620: 2d5d: \*                                                                           *
2621: 2d5d: \* RETURN                                                                    *
2622: 2d5d: \*****************************************************************************
2623: 2d5d: RET.CLAIMS.REPORTING:
2624: 2d6d:     
2625: 2d6d:     GOSUB RET.RPT.START
2626: 2d7f: 	 
2627: 2d7f:     WHILE NOT END.OF.REPORT
2628: 2d89: 	    
2629: 2d89:        GOSUB RET.RPT.PROCESS.BC
2630: 2d9b: 	    
2631: 2d9b:     WEND
2632: 2dad:     
2633: 2dad:     GOSUB RET.RPT.END
2634: 2dbf: 	 
2635: 2dbf:     IF CREDIT.CLAIM.ACTIVE = TRUE THEN BEGIN                                 !1.9JAT
2636: 2dd7:        GOSUB CREATE.NEW.CCSMY                                                !1.9JAT
2637: 2de9:     ENDIF                                                                    !1.9JAT
2638: 2df1:     GOSUB RET.RPT.NUM.OF.PAGES
2639: 2e03: RETURN
2640: 2e13: 
2641: 2e13: \*****************************************************************************
2642: 2e13: \*****************************************************************************
2643: 2e13: \* RET.RPT.START:                                                            *
2644: 2e13: \*       gosub FORMAT.WC.DATE                                                *
2645: 2e13: \*       gosub OPEN.CCRSN                                                    *
2646: 2e13: \*       gosub OPEN.CCLAM.KEYED                                              *
2647: 2e13: \*       gosub RET.CREATE.REPORT.FILES                                       *
2648: 2e13: \*       gosub GET.LINES.PER.PAGE                                            *
2649: 2e13: \*       initialise Page Nos. = 0 and report table index = 1                 *
2650: 2e13: \*       format report date                                                  *
2651: 2e13: \*       format report time                                                  *
2652: 2e13: \*       if no. of claims in report table > 0                                *
2653: 2e13: \*           key read CCLAM (priming read)                                   *
2654: 2e13: \*       else                                                                *
2655: 2e13: \*           gosub CCSMY.START.NEW.PAGE                                      *
2656: 2e13: \*           gosub CCDET.START.NEW.PAGE                                      *
2657: 2e13: \*           set End of Report to True                                       *
2658: 2e13: \*       endif                                                               *
2659: 2e13: \* RETURN                                                                    *
2660: 2e13: \*****************************************************************************
2661: 2e13: 
2662: 2e13: RET.RPT.START:
2663: 2e23:     GOSUB FORMAT.WC.DATE
2664: 2e35:     GOSUB OPEN.CCRSN
2665: 2e47:     GOSUB OPEN.CCLAM.KEYED
2666: 2e59:     GOSUB RET.CREATE.REPORT.FILES
2667: 2e6b:     GOSUB GET.LINES.PER.PAGE
2668: 2e7d:     CCSMY.PAGE.NO% = 0
2669: 2e94:     CCDET.PAGE.NO% = 0
2670: 2eab:     RPT.TAB.IDX% = 1
2671: 2ec2: 
2672: 2ec2:     PRINT.TODAYS.DATE$ = MID$(TODAYS.DATE$,5,2) + "/" +                      \
2673: 2f32:                            MID$(TODAYS.DATE$,3,2) + "/" +                      \
2674: 2f32:                       MID$(TODAYS.DATE$,1,2)
2675: 2f32:     PRINT.TIME$ = LEFT$(TIME$,2) + ":" + MID$(TIME$,3,2)
2676: 2f89: 
2677: 2f89:     IF RPT.TAB.NO.ENTRIES% > 0 THEN BEGIN
2678: 2fa8:         CCLAM.CREDIT.CLAIM.NUM$ = RIGHT$(REPORT.TABLE$(RPT.TAB.IDX%),4)
2679: 2fe3:        RC% = READ.CCLAM
2680: 2ffe:        IF RC% <> 0 THEN BEGIN
2681: 301d:               GOSUB READ.FILE.ERROR
2682: 302f:        ENDIF
2683: 3037:        END.OF.REPORT = FALSE
2684: 304f:     ENDIF ELSE BEGIN
2685: 3057:         GOSUB CCSMY.START.NEW.PAGE
2686: 3069:         GOSUB CCDET.START.NEW.PAGE
2687: 307b:        END.OF.REPORT = TRUE
2688: 3091:     ENDIF
2689: 3099: RETURN
2690: 30a9: 
2691: 30a9: \*****************************************************************************
2692: 30a9: \*****************************************************************************
2693: 30a9: \* RET.RPT.PROCESS.BC:                                                       *
2694: 30a9: \*        this is the controlling routine for reporting each Business Centre *
2695: 30a9: \*                                                                           *
2696: 30a9: \*       gosub RET.RPT.START.BC                                              *
2697: 30a9: \*       repeat       until End of Report or End of BC                       *
2698: 30a9: \*              gosub RET.RPT.PROCESS.CLAIM                                  *
2699: 30a9: \*       end repeat                                                          *
2700: 30a9: \*                                                                           *
2701: 30a9: \* RETURN                                                                    *
2702: 30a9: \*****************************************************************************
2703: 30a9: RET.RPT.PROCESS.BC:
2704: 30b9: 
2705: 30b9:      
2706: 30b9:     GOSUB RET.RPT.START.BC
2707: 30cb:     WHILE  NOT END.OF.BC
2708: 30d5: 	          
2709: 30d5:              GOSUB RET.RPT.PROCESS.CLAIM
2710: 30e7:     WEND
2711: 30f9: RETURN
2712: 3109: 
2713: 3109: \*****************************************************************************
2714: 3109: \*****************************************************************************
2715: 3109: \* RET.RPT.START.BC:                                                         *
2716: 3109: \*       store current BC letter                                             *
2717: 3109: \*       gosub CCSMY.START.NEW.PAGE                                          *
2718: 3109: \*       gosub CCDET.START.NEW.PAGE                                          *
2719: 3109: \*       format BC Headers and write to CCSMY and CCDET Reports              *
2720: 3109: \*                                                                           *
2721: 3109: \* RETURN                                                                    *
2722: 3109: \*****************************************************************************
2723: 3109: RET.RPT.START.BC:
2724: 3119:      
2725: 3119:     STORE.BC.LETTER$ = CCLAM.BC.LETTER$
2726: 3137:     END.OF.BC = FALSE
2727: 314d: 
2728: 314d:     GOSUB CCSMY.START.NEW.PAGE
2729: 315f:     GOSUB CCDET.START.NEW.PAGE
2730: 3171: 
2731: 3171:     BC.TAB.IDX% = ASC(CCLAM.BC.LETTER$) - 48
2732: 319a: 
2733: 319a:     DISPLAY.BC$ = CCLAM.BC.LETTER$                                       !CMJK
2734: 31b8: 
2735: 31b8:     IF DISPLAY.BC$ = CHR$(91) THEN DISPLAY.BC$ = "-"                     !CMJK
2736: 31eb:        IF CREDIT.CLAIM.ACTIVE = FALSE THEN BEGIN                         !1.9JAT
2737: 3206: 
2738: 3206:           CCSMY.REPORT.LINE$ = " BC  " +                                 \
2739: 3259:                                 DISPLAY.BC$ +                            \CMJK
2740: 3259:                             ", " +                                       \
2741: 3259:                             MID$(BC.TABLE$(BC.TAB.IDX%),2,14)
2742: 3259:           GOSUB WRITE.CCSMY.REPORT
2743: 326b:           CCSMY.REPORT.LINE$ = " ---------------------"
2744: 3282:           GOSUB WRITE.CCSMY.REPORT
2745: 3294:           CCSMY.REPORT.LINE$ = BLANK.LINE$
2746: 32b2:           GOSUB WRITE.CCSMY.REPORT
2747: 32c4:        ENDIF                                                             !1.9JAT
2748: 32cc:     CCDET.REPORT.LINE$ = " BC  " +                                       \
2749: 331f:                           DISPLAY.BC$ +                                  \CMJK
2750: 331f:                       ", " +                                             \
2751: 331f:                       MID$(BC.TABLE$(BC.TAB.IDX%),2,14)
2752: 331f:     GOSUB WRITE.CCDET.REPORT
2753: 3331:     CCDET.REPORT.LINE$ = " ---------------------"
2754: 3348:     GOSUB WRITE.CCDET.REPORT
2755: 335a:     CCDET.REPORT.LINE$ = BLANK.LINE$
2756: 3378:     GOSUB WRITE.CCDET.REPORT
2757: 338a: 
2758: 338a: RETURN
2759: 339a: 
2760: 339a: \*****************************************************************************
2761: 339a: \*****************************************************************************
2762: 339a: \* RET.RPT.PROCESS.CLAIM:                                                    *
2763: 339a: \*       this is the controlling routine for reporting each claim within a   *
2764: 339a: \*       business centre                                                     *
2765: 339a: \*                                                                           *
2766: 339a: \*       gosub RET.RPT.START.CLAIM                                           *
2767: 339a: \*       repeat until Item No. > CCLAM.NUM.OF>ITEMS                          *
2768: 339a: \*              gosub RET.RPT.PROCESS.ITEM                                   *
2769: 339a: \*       end repeat                                                          *
2770: 339a: \*       gosub RET.RPT.END.CLAIM                                             *
2771: 339a: \*                                                                           *
2772: 339a: \* RETURN                                                                    *
2773: 339a: \*****************************************************************************
2774: 339a: 
2775: 339a: RET.RPT.PROCESS.CLAIM:
2776: 33aa:      
2777: 33aa:     IF CCLAM.CANC.MARKER$="Y" THEN BEGIN                                 !CMJK
2778: 33c8:       CLAIM.TOTAL.VALUE% = 0                                             !CMJK
2779: 33e1:     ENDIF ELSE BEGIN                                                     !CMJK
2780: 33e9: 	  
2781: 33e9:       GOSUB RET.RPT.START.CLAIM
2782: 33fb:       WHILE (NOT ITEM.NO% > CCLAM.NUM.OF.ITEMS%)
2783: 3405: 	       
2784: 3405:           GOSUB RET.RPT.PROCESS.ITEM
2785: 3417:       WEND
2786: 3434:     ENDIF                                                                !CMJK
2787: 343c:     GOSUB RET.RPT.END.CLAIM
2788: 344e: RETURN
2789: 345e: 
2790: 345e: \*****************************************************************************
2791: 345e: \*****************************************************************************
2792: 345e: \* RET.RPT.START.CLAIM:                                                      *
2793: 345e: \*    initialise Item No. = 1, Claim Total Value = 0                         *
2794: 345e: \*    dimension Item Table = CCLAM.NUM.OF.ITEMS                              *
2795: 345e: \*                                                                           *
2796: 345e: \* RETURN                                                                    *
2797: 345e: \*****************************************************************************
2798: 345e: RET.RPT.START.CLAIM:
2799: 346e:      
2800: 346e:     ITEM.NO% = 1
2801: 3485:     CLAIM.TOTAL.VALUE% = 0
2802: 349c:     DIM ITEM.TABLE$(CCLAM.NUM.OF.ITEMS%)
2803: 34d0:     CCITF.CREDIT.CLAIM.NUM$ = CCLAM.CREDIT.CLAIM.NUM$
2804: 34ee: RETURN
2805: 34fe: 
2806: 34fe: \*****************************************************************************
2807: 34fe: \*****************************************************************************
2808: 34fe: \* RET.RPT.PROCESS.ITEM:                                                     *
2809: 34fe: \*       read CCITF by key (if error gosub READ.FILE.ERROR)                  *
2810: 34fe: \*       Item Claim Value = Item Price * Item Quantity                       *
2811: 34fe: \*       Add Item Claim Value to Claim Total Value                           *
2812: 34fe: \*       Save Item details (Item/Bar code flag, Boots/Bar code, quantity     *
2813: 34fe: \*       and price to Item Table                                             *
2814: 34fe: \*       Add 1 to Item No.                                                   *
2815: 34fe: \*                                                                           *
2816: 34fe: \* RETURN                                                                    *
2817: 34fe: \*****************************************************************************
2818: 34fe: RET.RPT.PROCESS.ITEM:
2819: 350e:      
2820: 350e:     CCITF.ITEM.NUM$ = PACK$(RIGHT$("0000" + STR$(ITEM.NO%),4))	
2821: 355e:     CCITF.KEY$ = CCITF.CREDIT.CLAIM.NUM$ + CCITF.ITEM.NUM$
2822: 358a: 	 
2823: 358a: 	PRINT UNPACK$(CCITF.KEY$)
2824: 35aa: 	 
2825: 35aa:     RC% = READ.CCITF
2826: 35c5:     IF RC% <> 0 THEN BEGIN
2827: 35e4: 	    
2828: 35e4:         GOSUB READ.FILE.ERROR
2829: 35f6:  
2830: 35f6:     ENDIF
2831: 35fe:      
2832: 35fe:     ITEM.CLAIM.VALUE% = VAL(UNPACK$(CCITF.PRICE$))                       ! DDS
2833: 362d: 	PRINT "PASSED"
2834: 363e:     PACK.SIZE% = VAL(CCITF.FILLER$)                                     ! DMJK	
2835: 3665:     IF PACK.SIZE%>0 THEN BEGIN                                          ! DMJK
2836: 3681:       PACK.SIZE$ = "/"+RIGHT$("    "+STR$(PACK.SIZE%),4)                ! DMJK
2837: 36d5:     ENDIF ELSE BEGIN                                                    ! DMJK
2838: 36dd:       PACK.SIZE$ = STRING$(5," ")                                       ! DMJK
2839: 36fb:     ENDIF                                                               ! DMJK
2840: 3703: 
2841: 3703:     IF PACK.SIZE%<1 THEN PACK.SIZE% = 1                                 ! DMJK
2842: 372f:     IF CCITF.QTY% <> 0 THEN BEGIN                                        ! DDS
2843: 3744:        IF PACK.SIZE% = 1 THEN BEGIN                                     ! DMJK
2844: 3763:          ITEM.PRICE% = ITEM.CLAIM.VALUE% / CCITF.QTY%                    ! DDS
2845: 3789:        ENDIF ELSE BEGIN                                                 ! DMJK
2846: 3791:          REAL.ITEM.CLAIM.VALUE = ITEM.CLAIM.VALUE%                      ! DMJK
2847: 37b0:         REAL.CCITF.QTY = CCITF.QTY%                                     ! DMJK
2848: 37cb:         REAL.PACK.SIZE = PACK.SIZE%                                     ! DMJK
2849: 37ea:          ITEM.PRICE% = REAL.ITEM.CLAIM.VALUE /                          \ DMJK
2850: 3824:                       (REAL.CCITF.QTY/REAL.PACK.SIZE)                   ! DMJK
2851: 3824:        ENDIF                                                            ! DMJK
2852: 382e:     ENDIF ELSE BEGIN                                                     ! DDS
2853: 3836:        ITEM.PRICE% = 0                                                   ! DDS
2854: 384d:     ENDIF
2855: 3855:     CLAIM.TOTAL.VALUE% = CLAIM.TOTAL.VALUE% + ITEM.CLAIM.VALUE%
2856: 3870: 
2857: 3870:     VALUE$ = STR$(ITEM.CLAIM.VALUE%)                                    ! DMJK
2858: 3893:     GOSUB FORMAT.VALUE                                                  ! DMJK
2859: 38a5:     ITEM.CLAIM.VALUE$ = VALUE$                                          ! DMJK
2860: 38c3: 
2861: 38c3:     VALUE$ = STR$(ITEM.PRICE%)
2862: 38e6:     GOSUB FORMAT.VALUE
2863: 38f8: 
2864: 38f8: 
2865: 38f8:     ITEM.TABLE$(ITEM.NO%) = CCITF.ITEM.BAR.CODE.FLAG$ +                      \
2866: 39af:                              CCITF.BOOTS.BAR.CODE$ +                         \
2867: 39af:                          RIGHT$(STRING$(4," ")+STR$(CCITF.QTY%),4) +    \ CMJK
2868: 39af:                          VALUE$ + PACK.SIZE$       + ITEM.CLAIM.VALUE$  ! DMJK
2869: 39af: 
2870: 39af:     ITEM.NO% = ITEM.NO% + 1
2871: 39c8: 
2872: 39c8:     !Locate the index number where the current claim is stored on the claims tables 1.9JAT
2873: 39c8:     !UPDATE THE CLAIM VALUE FOR THIS ITEM TO THE TOTAL STORED ON THE CLAIMS TABLE   1.9JAT
2874: 39c8:     FOR A% = 1 TO CLAIMS.COUNTER%
2875: 39e2:         IF CCITF.CREDIT.CLAIM.NUM$ = LEFT$(NEW.CLAIM.RECORDS$(A%),4) THEN BEGIN     !1.9JAT
2876: 3a2c:            CURRENT.CLAIM.VALUE% = VAL(MID$(NEW.CLAIM.RECORDS$(A%),37,8))             !1.9JAT
2877: 3a75:            NEW.CLAIM.VALUE% = CURRENT.CLAIM.VALUE% + ITEM.CLAIM.VALUE%              !1.9JAT                      
2878: 3a94:            NEW.CLAIM.RECORDS$(A%) = (LEFT$(NEW.CLAIM.RECORDS$(A%),36) +            \ 1.9JAT
2879: 3b62:                                     RIGHT$("00000000" + STR$(NEW.CLAIM.VALUE%),8)+ \ 1.9JAT
2880: 3b62:                                     MID$(NEW.CLAIM.RECORDS$(A%),45,6))              !4.2HSM
2881: 3b62:            A% = CLAIMS.COUNTER%                                                     !1.9JAT
2882: 3b7b:         ENDIF                                                                       !1.9JAT
2883: 3b83:     NEXT A%                                                                         !1.9JAT
2884: 3bbb:    
2885: 3bbb: RETURN
2886: 3bcb: 
2887: 3bcb: \*****************************************************************************
2888: 3bcb: \*****************************************************************************
2889: 3bcb: \* RET.RPT.END.CLAIM:                                                        *
2890: 3bcb: \*     gosub RET.RPT.WRITE.CLAIM.HEADER                                      *
2891: 3bcb: \*     gosub RET.RPT.WRITE.CLAIM.DETAILS                                     *
2892: 3bcb: \*     if reason code is not '23' or '26'                                    *
2893: 3bcb: \*         initialise Item No. = 1                                           *
2894: 3bcb: \*         repeat until Item No. > CCLAM.NUM.OF.ITEMS                        *
2895: 3bcb: \*             gosub RET.RPT.WRITE.ITEM.DETAILS                              *
2896: 3bcb: \*         end repeat                                                        *
2897: 3bcb: \*     endif                                                                 *
2898: 3bcb: \*     Add 1 to Report table Index                                           *
2899: 3bcb: \*     If Report Table Index > No. of Report Table Entries                   *
2900: 3bcb: \*          set End of Report to True                                        *
2901: 3bcb: \*     else                                                                  *
2902: 3bcb: \*               read next CCLAM record by key                               *
2903: 3bcb: \*          if new BC Letter Code                                            *
2904: 3bcb: \*              set End of BC to True                                        *
2905: 3bcb: \*          endif                                                            *
2906: 3bcb: \*    endif                                                                  *
2907: 3bcb: \*    if required, start new page, else write blank lines to reports         *
2908: 3bcb: \*                                                                           *
2909: 3bcb: \* RETURN                                                                    *
2910: 3bcb: \*****************************************************************************
2911: 3bcb: 
2912: 3bcb: RET.RPT.END.CLAIM:
2913: 3bdb: 
2914: 3bdb:     GOSUB RET.RPT.WRITE.CLAIM.HEADER
2915: 3bed: 
2916: 3bed:     IF CCLAM.CANC.MARKER$ = "Y" THEN BEGIN                               !CMJK
2917: 3c0e:       IF CREDIT.CLAIM.ACTIVE = FALSE THEN BEGIN                          !1.9JAT
2918: 3c26:          CCSMY.REPORT.LINE$ = CANCELLED.LINE$                            !CMJK
2919: 3c44:          GOSUB WRITE.CCSMY.REPORT                                        !CMJK
2920: 3c56:       ENDIF                                                              !1.9JAT
2921: 3c5e:       CCDET.REPORT.LINE$ = CANCELLED.LINE$                               !CMJK
2922: 3c7c:       GOSUB WRITE.CCDET.REPORT                                           !CMJK
2923: 3c91:     ENDIF ELSE BEGIN                                                     !CMJK
2924: 3c99: 
2925: 3c99:       GOSUB RET.RPT.WRITE.CLAIM.DETAILS
2926: 3cab:       IF (UNPACK$(CCLAM.REASON.NUM$) <> "23")                            \BMJB
2927: 3d20:       AND (UNPACK$(CCLAM.REASON.NUM$) <> "26") THEN BEGIN                !BMJB
2928: 3d20:             ITEM.NO% = 1
2929: 3d37:        HEADER.PRINTED = 0                                                ! DDS
2930: 3d47:            WHILE (NOT ITEM.NO% > CCLAM.NUM.OF.ITEMS%)
2931: 3d51:             GOSUB RET.RPT.WRITE.ITEM.DETAILS
2932: 3d63:            WEND
2933: 3d80:       ENDIF                                                              !BMJB
2934: 3d88: 
2935: 3d88:     ENDIF                                                                !CMJK
2936: 3d90: 
2937: 3d90:     RPT.TAB.IDX% = RPT.TAB.IDX% + 1
2938: 3da9:     IF RPT.TAB.IDX% > RPT.TAB.NO.ENTRIES% THEN BEGIN
2939: 3dc9:         END.OF.BC = TRUE
2940: 3ddf:            END.OF.REPORT = TRUE
2941: 3df8:     ENDIF ELSE BEGIN
2942: 3e00:         CCLAM.CREDIT.CLAIM.NUM$ = RIGHT$(REPORT.TABLE$(RPT.TAB.IDX%),4)
2943: 3e3b:         RC% = READ.CCLAM
2944: 3e56:         IF RC% <> 0 THEN BEGIN
2945: 3e75:            GOSUB READ.FILE.ERROR
2946: 3e87:         ENDIF
2947: 3e8f: !        IF ASC(CCLAM.BC.LETTER$)<65 OR ASC(CCLAM.BC.LETTER$)>90 THEN     \CMJK  1.7JAS
2948: 3e8f: !         CCLAM.BC.LETTER$ = CHR$(91)                                     !CMJK  1.7JAS
2949: 3e8f: 
2950: 3e8f:         IF ASC(CCLAM.BC.LETTER$) > 90 THEN BEGIN                                       !1.8BMG
2951: 3eac:            CCLAM.BC.LETTER$ = CHR$(91)                                                 !1.8BMG
2952: 3ec9:         ENDIF ELSE BEGIN                                                               !1.8BMG
2953: 3ed1:            IF ASC(CCLAM.BC.LETTER$) < 65 THEN BEGIN                                    !1.8BMG
2954: 3eee:               IF ASC(CCLAM.BC.LETTER$) < 49 OR ASC(CCLAM.BC.LETTER$) > 57 THEN BEGIN   !1.8BMG
2955: 3f32:                  CCLAM.BC.LETTER$ = CHR$(91)                                           !1.8BMG
2956: 3f4c:               ENDIF                                                                    !1.8BMG
2957: 3f54:            ENDIF                                                                       !1.8BMG
2958: 3f5c:         ENDIF                                                                          !1.8BMG
2959: 3f64: 
2960: 3f64:        IF CCLAM.BC.LETTER$ <> STORE.BC.LETTER$ THEN BEGIN
2961: 3f89:            END.OF.BC = TRUE
2962: 3f9f:        ENDIF
2963: 3fa7:     ENDIF
2964: 3faf: 
2965: 3faf:     IF LINES.PER.PAGE% - (CCSMY.LINE.NO% - 1) < 2 THEN BEGIN
2966: 3fdd:         IF NOT END.OF.BC THEN BEGIN
2967: 3fef:                GOSUB CCSMY.START.NEW.PAGE
2968: 4001:        ENDIF
2969: 400b:     ENDIF ELSE BEGIN
2970: 4013:         IF CREDIT.CLAIM.ACTIVE = FALSE THEN BEGIN                             !1.9JAT
2971: 402b:            CCSMY.REPORT.LINE$ = BLANK.LINE$
2972: 4049:            GOSUB WRITE.CCSMY.REPORT
2973: 405b:            GOSUB WRITE.CCSMY.REPORT
2974: 406d:         ENDIF                                                                 !1.9JAT
2975: 4075:     ENDIF
2976: 407d: 
2977: 407d:     IF LINES.PER.PAGE% - (CCDET.LINE.NO% - 1) < 2 THEN BEGIN
2978: 40ab:         IF NOT END.OF.BC THEN BEGIN
2979: 40bd:                GOSUB CCDET.START.NEW.PAGE
2980: 40cf:        ENDIF
2981: 40d9:     ENDIF ELSE BEGIN
2982: 40e1:         CCDET.REPORT.LINE$ = BLANK.LINE$
2983: 40ff:         GOSUB WRITE.CCDET.REPORT
2984: 4111:         GOSUB WRITE.CCDET.REPORT
2985: 4123:     ENDIF
2986: 412b: RETURN
2987: 413b: 
2988: 413b: \*****************************************************************************
2989: 413b: \*****************************************************************************
2990: 413b: \* RET.RPT.WRITE.CLAIM.HEADER:                                               *
2991: 413b: \*     if less than 3 lines left on CCSMY page                               *
2992: 413b: \*         gosub CCSMY.START.NEW.PAGE                                        *
2993: 413b: \*     endif                                                                 *
2994: 413b: \*     if less than 3 lines left on CCDET page                               *
2995: 413b: \*         gosub CCDET.START.NEW.PAGE                                        *
2996: 413b: \*     endif                                                                 *
2997: 413b: \*     gosub FORMAT.VALUE to format Claim Total Value for printing           *
2998: 413b: \*     format and write Credit Claim header to CCSMY                         *
2999: 413b: \*     format and write Credit Claim header to CCDET                         *
3000: 413b: \*     write blank line to CCSMY/CCDET                                       *
3001: 413b: \*                                                                           *
3002: 413b: \* RETURN                                                                    *
3003: 413b: \*****************************************************************************
3004: 413b: RET.RPT.WRITE.CLAIM.HEADER:
3005: 414b: 
3006: 414b:    IF LINES.PER.PAGE% - (CCDET.LINE.NO% - 1) < 3 THEN BEGIN
3007: 4179:         GOSUB CCDET.START.NEW.PAGE
3008: 418b:     ENDIF
3009: 4193: 
3010: 4193:     VALUE$ = STR$(CLAIM.TOTAL.VALUE%)
3011: 41b6:     GOSUB FORMAT.VALUE
3012: 41c8: 
3013: 41c8: IF CREDIT.CLAIM.ACTIVE = FALSE THEN BEGIN                                    !1.9JAT
3014: 41e3: 
3015: 41e3:     IF LINES.PER.PAGE% - (CCSMY.LINE.NO% - 1) < 3 THEN BEGIN
3016: 4211:         GOSUB CCSMY.START.NEW.PAGE
3017: 4223:     ENDIF
3018: 422b: 
3019: 422b:     CCSMY.REPORT.LINE$ = NUMB$ + " : " + RIGHT$("00000000"   +               \1.6AH
3020: 42b8:                          UNPACK$(CCLAM.CREDIT.CLAIM.NUM$),8) +               \
3021: 42b8:                          STRING$(13," ")                     +               \
3022: 42b8:                          "Total value   "                    +               \
3023: 42b8:                          VALUE$
3024: 42b8:     GOSUB WRITE.CCSMY.REPORT
3025: 42ca:     CCSMY.REPORT.LINE$ = BLANK.LINE$
3026: 42e8:     GOSUB WRITE.CCSMY.REPORT
3027: 42fa: 
3028: 42fa: ENDIF                                                                        !1.9JAT
3029: 4302: 
3030: 4302:     CCDET.REPORT.LINE$ = NUMB$ + " : " + RIGHT$("00000000"   +               \1.6AH
3031: 438f:                          UNPACK$(CCLAM.CREDIT.CLAIM.NUM$),8) +               \
3032: 438f:                          STRING$(12," ")                     +               \
3033: 438f:                          "Total value   "                    +               \
3034: 438f:                          VALUE$
3035: 438f:     GOSUB WRITE.CCDET.REPORT
3036: 43a1:     
3037: 43a1:     GOSUB PROCESS.CURRENT.TILL.CLAIM                                         !4.2HSM                                 
3038: 43b3:     CCDET.REPORT.LINE$ = CURRENT.TILL.CLAIM$                                 !4.2HSM
3039: 43d1:     GOSUB WRITE.CCDET.REPORT                                                 !4.2HSM
3040: 43e3:                                                                              
3041: 43e3:     CCDET.REPORT.LINE$ = BLANK.LINE$
3042: 4401:     GOSUB WRITE.CCDET.REPORT
3043: 4413: 
3044: 4413: RETURN
3045: 4423: 
3046: 4423: \*****************************************************************************
3047: 4423: \*****************************************************************************
3048: 4423: \* RET.RPT.WRITE.CLAIM.DETAILS:                                              *
3049: 4423: \*     if Reason Code present on claim record                                *
3050: 4423: \*         read CCRSN using reason code key                                  *
3051: 4423: \*         format reason description line and write to CCSMY/CCDET           *
3052: 4423: \*     endif                                                                 *
3053: 4423: \*     if Supply Route present on claim record                               *
3054: 4423: \*         format Supply Route detail                                        *
3055: 4423: \*         gosub FORMAT.CLAIM.DETAIL (formats and prints claim details)      *
3056: 4423: \*     endif                                                                 *
3057: 4423: \*     if Recall Number present on claim record                              *
3058: 4423: \*         format Supply Route detail                                        *
3059: 4423: \*         gosub FORMAT.CLAIM.DETAIL                                         *
3060: 4423: \*     endif                                                                 *
3061: 4423: \*     if Authorisation present on claim record                              *
3062: 4423: \*         format Authorisation detail                                       *
3063: 4423: \*         gosub FORMAT.CLAIM.DETAIL                                         *
3064: 4423: \*     endif                                                                 *
3065: 4423: \*     if Supplier present on claim record                                   *
3066: 4423: \*         format Supplier detail                                            *
3067: 4423: \*         gosub FORMAT.CLAIM.DETAIL                                         *
3068: 4423: \*     endif                                                                 *
3069: 4423: \*     if Method of Return is present on claim record                        *
3070: 4423: \*         format Method of Return detail                                    *
3071: 4423: \*         if Carrier format Carrier detail                                  *
3072: 4423: \*         if BIRD format BIRD Number detail                                 *
3073: 4423: \*         gosub FORMAT.CLAIM.DETAIL                                         *
3074: 4423: \*     endif                                                                 *
3075: 4423: \*     if Receiving Store is present on claim record                         *
3076: 4423: \*         format Receiving Store detail                                     *
3077: 4423: \*         gosub FORMAT.CLAIM.DETAIL                                         *
3078: 4423: \*     endif                                                                 *
3079: 4423: \*     if Destination is present on claim record                             *
3080: 4423: \*         format Destination detail                                         *
3081: 4423: \*         gosub FORMAT.CLAIM.DETAIL                                         *
3082: 4423: \*     endif                                                                 *
3083: 4423: \*     if UOD Type is present on claim record                                *
3084: 4423: \*         format UOD Type detail                                            *
3085: 4423: \*         gosub FORMAT.CLAIM.DETAIL                                         *
3086: 4423: \*     endif                                                                 *
3087: 4423: \*     if Invoice Number is present on claim record                          *
3088: 4423: \*         format Invoice Number detail                                      *
3089: 4423: \*         gosub FORMAT.CLAIM.DETAIL                                         *
3090: 4423: \*     endif                                                                 *
3091: 4423: \*     if Folio Number is present on claim record                            *
3092: 4423: \*         format Folio Number detail                                        *
3093: 4423: \*         gosub FORMAT.CLAIM.DETAIL                                         *
3094: 4423: \*     endif                                                                 *
3095: 4423: \*     if Batch Ref. Number is present on claim record                       *
3096: 4423: \*         format Batch Ref Number detail                                    *
3097: 4423: \*         gosub FORMAT.CLAIM.DETAIL                                         *
3098: 4423: \*     endif                                                                 *
3099: 4423: \*     if Consignment Type is present on claim record                        *
3100: 4423: \*         format Consignment Type detail                                    *
3101: 4423: \*         gosub FORMAT.CLAIM.DETAIL                                         *
3102: 4423: \*     endif                                                                 *
3103: 4423: \*     if Repair Category is present on claim record                         *
3104: 4423: \*         format Repair Category detail                                     *
3105: 4423: \*         gosub FORMAT.CLAIM.DETAIL                                         *
3106: 4423: \*     endif                                                                 *
3107: 4423: \*     if Repair Number is present on claim record                           *
3108: 4423: \*         format Repair Number detail                                       *
3109: 4423: \*         gosub FORMAT.CLAIM.DETAIL                                         *
3110: 4423: \*     endif                                                                 *
3111: 4423: \*     if Plan4 Policy Number is present on claim record                     *
3112: 4423: \*         format Plan4 Policy Number detail                                 *
3113: 4423: \*         gosub FORMAT.CLAIM.DETAIL                                         *
3114: 4423: \*     endif                                                                 *
3115: 4423: \*     if DDDA/DCDR Number is present on claim record                        *
3116: 4423: \*         format DDDA/DDCR Number detail                                    *
3117: 4423: \*         gosub FORMAT.CLAIM.DETAIL                                         *
3118: 4423: \*     endif                                                                 *
3119: 4423: \*     if Delivery Note Number is present on claim record                    *
3120: 4423: \*         format Delivery Note Number Detail                                *
3121: 4423: \*         gosub FORMAT.CLAIM.DETAIL                                         *
3122: 4423: \*     endif                                                                 *
3123: 4423: \*     if first part of claim detail line is populated (not yet printed)     *
3124: 4423: \*         gosub FORMAT.CLAIM.DETAIL                                         *
3125: 4423: \*         (this ensures that all claim details present get printed)         *
3126: 4423: \*     endif                                                                 *
3127: 4423: \*                                                                           *
3128: 4423: \* RETURN                                                                    *
3129: 4423: \*****************************************************************************
3130: 4423: RET.RPT.WRITE.CLAIM.DETAILS:
3131: 4433: 
3132: 4433: \*Reason
3133: 4433:     IF CCLAM.REASON.NUM$ <> PACK$("00") THEN BEGIN
3134: 445c:         CCRSN.REASON$ = CCLAM.REASON.NUM$
3135: 447a:         RC% = READ.CCRSN
3136: 4495:         IF RC% <> 0 THEN BEGIN
3137: 44b4:                CCRSN.DESC$ = "NOT ON FILE                   "
3138: 44cb:         ENDIF
3139: 44d3: 
3140: 44d3:         IF CREDIT.CLAIM.ACTIVE = FALSE THEN BEGIN                    !1.9JAT
3141: 44eb:            CCSMY.REPORT.LINE$ = " Reason for return :  " +           \
3142: 4510:                                    CCRSN.DESC$
3143: 4510:            GOSUB WRITE.CCSMY.REPORT
3144: 4522:         ENDIF                                                        !1.9JAT
3145: 452a: 
3146: 452a:         CCDET.REPORT.LINE$ = " Reason for return :  " +              \
3147: 454f:                                 CCRSN.DESC$
3148: 454f:         GOSUB WRITE.CCDET.REPORT
3149: 4561:     ENDIF
3150: 4569: 
3151: 4569: \*Supply Route
3152: 4569:     IF CCLAM.SUPPLY.ROUTE$ <> " " THEN BEGIN
3153: 458a:         IF CCLAM.SUPPLY.ROUTE$ = "W" THEN BEGIN
3154: 45a8:             SUPPLY.ROUTE.DESC$ = "Warehouse       "
3155: 45c2:         ENDIF ELSE BEGIN
3156: 45ca:           IF CCLAM.SUPPLY.ROUTE$ = "O" THEN BEGIN
3157: 45e8:               SUPPLY.ROUTE.DESC$ = "Directs         "                    !CMJK
3158: 4601:           ENDIF ELSE BEGIN
3159: 4609:             IF CCLAM.SUPPLY.ROUTE$ = "D" THEN BEGIN
3160: 4627:               SUPPLY.ROUTE.DESC$ = "Dispensary      "
3161: 4640:               ENDIF ELSE BEGIN
3162: 4648:                SUPPLY.ROUTE.DESC$ = "Unknown Route   "
3163: 465f:             ENDIF
3164: 4667:           ENDIF
3165: 466f:         ENDIF
3166: 4677:         CLAIM.DETAIL$ = " Supply Route :       " + SUPPLY.ROUTE.DESC$
3167: 469c:         GOSUB FORMAT.CLAIM.DETAIL
3168: 46ae:     ENDIF
3169: 46b6: 
3170: 46b6: \*Recall Number
3171: 46b6:     IF CCLAM.RECALL.NUM$ <> STRING$(8," ") THEN BEGIN
3172: 46e1:         FIELD$ = CCLAM.RECALL.NUM$
3173: 46ff:        GOSUB LEFT.JUSTIFY.FIELD
3174: 4711:        CCLAM.RECALL.NUM$ = FIELD$
3175: 472f:         CLAIM.DETAIL$ = " Recall Number :      " +                           \
3176: 4754:                      CCLAM.RECALL.NUM$
3177: 4754:         GOSUB FORMAT.CLAIM.DETAIL
3178: 4766:     ENDIF
3179: 476e: 
3180: 476e: \*Authorisation
3181: 476e:     IF CCLAM.AUTHORISATION$ <> STRING$(15," ") THEN BEGIN  
3182: 4799:         IF CCLAM.FILLER$ = STRING$(7," ") THEN BEGIN                              !4.2HSM this will used for till claims 
3183: 47c4:             FIELD$ = CCLAM.AUTHORISATION$
3184: 47e2:             GOSUB LEFT.JUSTIFY.FIELD
3185: 47f4:             CCLAM.AUTHORISATION$ = FIELD$
3186: 4812:             CLAIM.DETAIL$ = " Authorisation :      " +                           \
3187: 4837:                              CCLAM.AUTHORISATION$
3188: 4837:             GOSUB FORMAT.CLAIM.DETAIL                                          
3189: 4849:         ENDIF                                                                     !4.2HSM
3190: 4851:     ENDIF
3191: 4859: 
3192: 4859: \*Supplier
3193: 4859:     IF CCLAM.SUPPLIER$ <> STRING$(15," ") THEN BEGIN
3194: 4884:         FIELD$ = CCLAM.SUPPLIER$
3195: 48a2:        GOSUB LEFT.JUSTIFY.FIELD
3196: 48b4:        CCLAM.SUPPLIER$ = FIELD$
3197: 48d2:         CLAIM.DETAIL$ = " Supplier :           " +                           \
3198: 48f7:                      CCLAM.SUPPLIER$
3199: 48f7:        GOSUB FORMAT.CLAIM.DETAIL
3200: 4909:     ENDIF
3201: 4911: 
3202: 4911: \*Method of Return
3203: 4911:     IF CCLAM.METHOD.OF.RETURN$ <> PACK$("00") THEN BEGIN
3204: 493a:         IF UNPACK$(CCLAM.METHOD.OF.RETURN$) = "01" THEN BEGIN         !Carrier
3205: 496e: 
3206: 496e:            IF UNPACK$(CCLAM.CARRIER$) = "01" THEN BEGIN                   !GPO
3207: 499f:                CLAIM.DETAIL$ = " Method of Return :   " +                    \
3208: 49c0:                             "GPO             "
3209: 49c0:            ENDIF ELSE BEGIN
3210: 49c8: 
3211: 49c8:            IF UNPACK$(CCLAM.CARRIER$) = "02" THEN BEGIN           !Parcelforce
3212: 49f9:                CLAIM.DETAIL$ = " Method of Return :   " +                    \
3213: 4a1a:                             "Parcelforce     "
3214: 4a1a:            ENDIF ELSE BEGIN
3215: 4a22: 
3216: 4a22:            IF UNPACK$(CCLAM.CARRIER$) = "03" THEN BEGIN             !Securicor
3217: 4a53:                CLAIM.DETAIL$ = " Method of Return :   " +                    \
3218: 4a74:                             "Securicor       "
3219: 4a74:            ENDIF ELSE BEGIN
3220: 4a7c: 
3221: 4a7c:            IF UNPACK$(CCLAM.CARRIER$) = "04" THEN BEGIN                 !Other
3222: 4aad:                CLAIM.DETAIL$ = " Method of Return :   " +                    \
3223: 4acd:                             "Other Carrier   "
3224: 4acd:            ENDIF ELSE BEGIN                                           !Invalid
3225: 4ad5: 
3226: 4ad5:                CLAIM.DETAIL$ = " Method of Return :   " +                    \
3227: 4af3:                             "Unknown Carrier "
3228: 4af3:            ENDIF
3229: 4afb:            ENDIF
3230: 4b03:            ENDIF
3231: 4b0b:            ENDIF
3232: 4b16:        ENDIF ELSE BEGIN
3233: 4b1e: 
3234: 4b1e:        IF UNPACK$(CCLAM.METHOD.OF.RETURN$) = "02" THEN BEGIN             !BIRD
3235: 4b4f:             FIELD$ = CCLAM.BIRD.NUM$
3236: 4b6d:            GOSUB LEFT.JUSTIFY.FIELD
3237: 4b7f:             CCLAM.BIRD.NUM$ = FIELD$
3238: 4b9d:            CLAIM.DETAIL$ = " BIRD Number :        " +                        \
3239: 4bc5:                          CCLAM.BIRD.NUM$
3240: 4bc5:        ENDIF ELSE BEGIN
3241: 4bcd: 
3242: 4bcd:        IF UNPACK$(CCLAM.METHOD.OF.RETURN$) = "03" THEN BEGIN           !Via D6
3243: 4bfe:            CLAIM.DETAIL$ = " Method of Return :   " +                        \
3244: 4c1f:                              "Via D6          "
3245: 4c1f:        ENDIF ELSE BEGIN
3246: 4c27: 
3247: 4c27:         IF UNPACK$(CCLAM.METHOD.OF.RETURN$) = "04" THEN BEGIN             !Rep
3248: 4c58:            CLAIM.DETAIL$ = " Method of Return :   " +                        \
3249: 4c78:                              "Representative  "
3250: 4c78:        ENDIF ELSE BEGIN                                               !Invalid
3251: 4c80:            CLAIM.DETAIL$ = " Method of Return :   " +                        \
3252: 4c9e:                              "Unknown Method  "
3253: 4c9e: 
3254: 4c9e:         ENDIF
3255: 4ca6:         ENDIF
3256: 4cae:        ENDIF
3257: 4cb6:        ENDIF
3258: 4cbe:         GOSUB FORMAT.CLAIM.DETAIL
3259: 4cd0:     ENDIF
3260: 4cd8: 
3261: 4cd8: \*Receiving Store
3262: 4cd8:     IF CCLAM.RECEIVING.STORE$ <> PACK$("0000") THEN BEGIN
3263: 4cfe:         CLAIM.DETAIL$ = " Receiving Store :    " +                           \
3264: 4d28:                      UNPACK$(CCLAM.RECEIVING.STORE$)
3265: 4d28:        GOSUB FORMAT.CLAIM.DETAIL
3266: 4d3a:     ENDIF
3267: 4d42: 
3268: 4d42: \*Destination
3269: 4d42:     IF CCLAM.DESTINATION$ <> PACK$("00") THEN BEGIN
3270: 4d6b:         IF UNPACK$(CCLAM.DESTINATION$) = "01" THEN BEGIN                   !BC
3271: 4d9c:                CLAIM.DETAIL$ = " Destination :        " +                    \
3272: 4dbd:                              "Business Centre "
3273: 4dbd:        ENDIF ELSE BEGIN
3274: 4dc5: 
3275: 4dc5:         IF UNPACK$(CCLAM.DESTINATION$) = "02" THEN BEGIN                  !MTS
3276: 4df6:                CLAIM.DETAIL$ = " Destination :        " +                    \
3277: 4e17:                              "MTS             "
3278: 4e17:        ENDIF ELSE BEGIN
3279: 4e1f: 
3280: 4e1f:         IF UNPACK$(CCLAM.DESTINATION$) = "03" THEN BEGIN             !Pharmacy
3281: 4e50:                CLAIM.DETAIL$ = " Destination :        " +                    \
3282: 4e71:                              "Pharmacy        "
3283: 4e71:        ENDIF ELSE BEGIN
3284: 4e79: 
3285: 4e79:         IF UNPACK$(CCLAM.DESTINATION$) = "04" THEN BEGIN                !Other
3286: 4eaa:                CLAIM.DETAIL$ = " Destination :        " +                    \
3287: 4eca:                              "Other Destn.    "
3288: 4eca:        ENDIF ELSE BEGIN                                               !Invalid
3289: 4ed2:                CLAIM.DETAIL$ = " Destination :        " +                    \
3290: 4ef0:                              "Unknown Destn.  "
3291: 4ef0:            ENDIF
3292: 4ef8:            ENDIF
3293: 4f00:            ENDIF
3294: 4f08:            ENDIF
3295: 4f10:         GOSUB FORMAT.CLAIM.DETAIL
3296: 4f22:     ENDIF
3297: 4f2a: 
3298: 4f2a: \*UOD Type
3299: 4f2a:     IF CCLAM.UOD.TYPE$ <> PACK$("00") THEN BEGIN
3300: 4f53:            IF UNPACK$(CCLAM.UOD.TYPE$) = "01" THEN BEGIN         !Travel Outer
3301: 4f84:                CLAIM.DETAIL$ = " UOD Type :           " +                    \
3302: 4fa5:                              "Travel Outer    "
3303: 4fa5:        ENDIF ELSE BEGIN
3304: 4fad: 
3305: 4fad:            IF UNPACK$(CCLAM.UOD.TYPE$) = "02" THEN BEGIN            !Town Tray
3306: 4fde:                CLAIM.DETAIL$ = " UOD Type :           " +                    \
3307: 4fff:                              "Town Tray       "
3308: 4fff:        ENDIF ELSE BEGIN
3309: 5007: 
3310: 5007:            IF UNPACK$(CCLAM.UOD.TYPE$) = "03" THEN BEGIN            !Roll Cage
3311: 5038:                CLAIM.DETAIL$ = " UOD Type :           " +                    \
3312: 5059:                              "Roll Cage       "
3313: 5059:        ENDIF ELSE BEGIN
3314: 5061: 
3315: 5061:            IF UNPACK$(CCLAM.UOD.TYPE$) = "04" THEN BEGIN                !Other
3316: 5092:                CLAIM.DETAIL$ = " UOD Type :           " +                    \
3317: 50b2:                              "Other UOD       "
3318: 50b2:        ENDIF ELSE BEGIN                                               !Invalid
3319: 50ba:                CLAIM.DETAIL$ = " UOD Type :           " +                    \
3320: 50d8:                              "Unknown UOD     "
3321: 50d8:        ENDIF
3322: 50e0:        ENDIF
3323: 50e8:        ENDIF
3324: 50f0:        ENDIF
3325: 50f8:        GOSUB FORMAT.CLAIM.DETAIL
3326: 510a:     ENDIF
3327: 5112: 
3328: 5112: \*Invoice Number
3329: 5112:     IF CCLAM.INVOICE.NUM$ <> STRING$(9," ") THEN BEGIN
3330: 513d:         FIELD$ = CCLAM.INVOICE.NUM$
3331: 515b:        GOSUB LEFT.JUSTIFY.FIELD
3332: 516d:        CCLAM.INVOICE.NUM$ = FIELD$
3333: 518b:         CLAIM.DETAIL$ = " Invoice Number :     " +                           \
3334: 51b0:                      CCLAM.INVOICE.NUM$
3335: 51b0:         GOSUB FORMAT.CLAIM.DETAIL
3336: 51c2:     ENDIF
3337: 51ca: 
3338: 51ca: \*Folio Number
3339: 51ca:     IF CCLAM.FOLIO.NUM$ <> PACK$(STRING$(6,"0")) THEN BEGIN
3340: 51f7:         CLAIM.DETAIL$ = " Folio Number :       " +                           \
3341: 5221:                      UNPACK$(CCLAM.FOLIO.NUM$)
3342: 5221:         GOSUB FORMAT.CLAIM.DETAIL
3343: 5233:     ENDIF
3344: 523b: 
3345: 523b: \*Batch Reference
3346: 523b:     IF CCLAM.BATCH.REF$ <> PACK$(STRING$(6,"0")) THEN BEGIN
3347: 5268:         CLAIM.DETAIL$ = " Batch Ref. Number :  " +                           \
3348: 5292:                      UNPACK$(CCLAM.BATCH.REF$)
3349: 5292:         GOSUB FORMAT.CLAIM.DETAIL
3350: 52a4:     ENDIF
3351: 52ac: 
3352: 52ac: \*Consignment Type
3353: 52ac:     IF CCLAM.WHOLE.PART.CON$ <> " " THEN BEGIN
3354: 52cd:         IF CCLAM.WHOLE.PART.CON$ = "W" THEN BEGIN                       !Whole
3355: 52eb:            CLAIM.DETAIL$ = " Consignment Type :   " +                        \
3356: 530c:                              "Whole           "
3357: 530c:        ENDIF ELSE BEGIN
3358: 5314: 
3359: 5314:         IF CCLAM.WHOLE.PART.CON$ = "P" THEN BEGIN                        !Part
3360: 5332:            CLAIM.DETAIL$ = " Consignment Type :   " +                        \
3361: 5352:                              "Part            "
3362: 5352:        ENDIF ELSE BEGIN                                               !Invalid
3363: 535a:            CLAIM.DETAIL$ = " Consignment Type :   " +                        \
3364: 5378:                              "Unknown Type    "
3365: 5378:            ENDIF
3366: 5380:            ENDIF
3367: 5388:        GOSUB FORMAT.CLAIM.DETAIL
3368: 539a:     ENDIF
3369: 53a2: 
3370: 53a2: \*Repair Category
3371: 53a2:     IF CCLAM.REPAIR.CATEGORY$ <> PACK$("00") THEN BEGIN
3372: 53cb:            IF UNPACK$(CCLAM.REPAIR.CATEGORY$) = "01" THEN BEGIN         !Plan4
3373: 53fc:                CLAIM.DETAIL$ = " Repair Category :    " +                    \
3374: 541d:                              "Plan4           "
3375: 541d:        ENDIF ELSE BEGIN
3376: 5425: 
3377: 5425:            IF UNPACK$(CCLAM.REPAIR.CATEGORY$) = "02" THEN BEGIN      !Estimate
3378: 5456:                CLAIM.DETAIL$ = " Repair Category :    " +                    \
3379: 5477:                              "Estimate        "
3380: 5477:        ENDIF ELSE BEGIN
3381: 547f: 
3382: 547f:            IF UNPACK$(CCLAM.REPAIR.CATEGORY$) = "03" THEN BEGIN   !Boots Guar.
3383: 54b0:                CLAIM.DETAIL$ = " Repair Category :    " +                    \
3384: 54d1:                              "Boots Guarantee "
3385: 54d1:        ENDIF ELSE BEGIN
3386: 54d9: 
3387: 54d9:            IF UNPACK$(CCLAM.REPAIR.CATEGORY$) = "04" THEN BEGIN   !Supp. Guar.
3388: 550a:                CLAIM.DETAIL$ = " Repair Category :    " +                    \
3389: 552b:                              "Supplier Guar.  "
3390: 552b:        ENDIF ELSE BEGIN
3391: 5533: 
3392: 5533:            IF UNPACK$(CCLAM.REPAIR.CATEGORY$) = "05" THEN BEGIN   !Other Guar.
3393: 5564:                CLAIM.DETAIL$ = " Repair Category :    " +                    \
3394: 5584:                              "Other Guarantee "
3395: 5584:        ENDIF ELSE BEGIN                                               !Invalid
3396: 558c:                CLAIM.DETAIL$ = " Repair Category :    " +                    \
3397: 55aa:                              "Unknown Category"
3398: 55aa:        ENDIF
3399: 55b2:        ENDIF
3400: 55ba:        ENDIF
3401: 55c2:        ENDIF
3402: 55ca:        ENDIF
3403: 55d2:        GOSUB FORMAT.CLAIM.DETAIL
3404: 55e4:     ENDIF
3405: 55ec: 
3406: 55ec: \*Repair Number
3407: 55ec:     IF CCLAM.REPAIR.NUM$ <> PACK$(STRING$(12,"0")) THEN BEGIN
3408: 5619:         CLAIM.DETAIL$ = " Repair Number :      " +                           \
3409: 5643:                      UNPACK$(CCLAM.REPAIR.NUM$)
3410: 5643:         GOSUB FORMAT.CLAIM.DETAIL
3411: 5655:     ENDIF
3412: 565d: 
3413: 565d: \*Plan4 Policy Number
3414: 565d:     IF CCLAM.PLAN4.POLICY.NUM$ <> PACK$(STRING$(12,"0")) THEN BEGIN
3415: 568a:         CLAIM.DETAIL$ = " Plan4 Policy Number: " +                           \
3416: 56b4:                      UNPACK$(CCLAM.PLAN4.POLICY.NUM$)
3417: 56b4:         GOSUB FORMAT.CLAIM.DETAIL
3418: 56c6:     ENDIF
3419: 56ce: 
3420: 56ce: \*DDDA/DCDR Number
3421: 56ce:     IF CCLAM.DDDA.DCDR.NUM$ <> PACK$(STRING$(8,"0")) THEN BEGIN
3422: 56fb:         CLAIM.DETAIL$ = " DDDA/DCDR Number :   " +                           \
3423: 5725:                      UNPACK$(CCLAM.DDDA.DCDR.NUM$)
3424: 5725:         GOSUB FORMAT.CLAIM.DETAIL
3425: 5737:     ENDIF
3426: 573f: 
3427: 573f: \*Delivery Note Number
3428: 573f:     IF CCLAM.DELIV.NOTE.NUM$ <> STRING$(9," ") THEN BEGIN
3429: 576a:         FIELD$ = CCLAM.DELIV.NOTE.NUM$
3430: 5788:        GOSUB LEFT.JUSTIFY.FIELD
3431: 579a:        CCLAM.DELIV.NOTE.NUM$ = FIELD$
3432: 57b8:         CLAIM.DETAIL$ = " Delivery Note No. :  " +                           \
3433: 57dd:                      CCLAM.DELIV.NOTE.NUM$
3434: 57dd:         GOSUB FORMAT.CLAIM.DETAIL
3435: 57ef:     ENDIF
3436: 57f7:   
3437: 57f7: \*If first part of claim detail line populated then print to reports
3438: 57f7:     IF DETAIL.FIRST.PART.FULL THEN BEGIN
3439: 5809:         CLAIM.DETAIL$ = STRING$(38," ")
3440: 5827:        GOSUB FORMAT.CLAIM.DETAIL
3441: 5839:     ENDIF
3442: 5841: RETURN
3443: 5851: 
3444: 5851: \*****************************************************************************
3445: 5851: \*****************************************************************************
3446: 5851: \* FORMAT.CLAIM.DETAIL:                                                      *
3447: 5851: \*     formats claim details into pairs on one line and prints to reports    *
3448: 5851: \*                                                                           *
3449: 5851: \*     if detail first part not full                                         *
3450: 5851: \*         move claim detail to first part                                   *
3451: 5851: \*         set Detail First Part Full to true                                *
3452: 5851: \*     else                                                                  *
3453: 5851: \*         else move claim detail to second part                             *
3454: 5851: \*         if less than 1 line left on CCSMY page                            *
3455: 5851: \*            gosub CCSMY.START.NEW.PAGE                                     *
3456: 5851: \*         endif                                                             *
3457: 5851: \*         if less than 1 line left on CCDET page                            *
3458: 5851: \*            gosub CCDET.START.NEW.PAGE                                     *
3459: 5851: \*         endif                                                             *
3460: 5851: \*         format CCSMY/CCDET report line = first part + second part         *
3461: 5851: \*         write detail lines to CCSMY/CCDET                                 *
3462: 5851: \*         initialise detail first part/second part to spaces                *
3463: 5851: \*         set Detail First Part Full to false                               *
3464: 5851: \*     endif                                                                 *
3465: 5851: \*                                                                           *
3466: 5851: \* RETURN                                                                    *
3467: 5851: \*****************************************************************************
3468: 5851: FORMAT.CLAIM.DETAIL:
3469: 5861:     IF NOT DETAIL.FIRST.PART.FULL THEN BEGIN
3470: 5873:         DETAIL.FIRST.PART$ = LEFT$(CLAIM.DETAIL$ + STRING$(38," "),38)
3471: 58c2:        DETAIL.FIRST.PART.FULL = TRUE
3472: 58db:     ENDIF ELSE BEGIN
3473: 58e3:         DETAIL.SECOND.PART$ = LEFT$(CLAIM.DETAIL$ + STRING$(38," "),38)
3474: 5932: 
3475: 5932:         IF LINES.PER.PAGE% - (CCSMY.LINE.NO% - 1) < 1 THEN BEGIN
3476: 5960:             GOSUB CCSMY.START.NEW.PAGE
3477: 5972:         ENDIF
3478: 597a:         IF LINES.PER.PAGE% - (CCDET.LINE.NO% - 1) < 1 THEN BEGIN
3479: 59a8:             GOSUB CCDET.START.NEW.PAGE
3480: 59ba:         ENDIF
3481: 59c2: 
3482: 59c2:        IF CREDIT.CLAIM.ACTIVE = FALSE THEN BEGIN                             !1.9JAT
3483: 59da:           CCSMY.REPORT.LINE$ = DETAIL.FIRST.PART$ +                          \
3484: 5a1c:                              STRING$(3," ") +                                \
3485: 5a1c:                              DETAIL.SECOND.PART$
3486: 5a1c:            GOSUB WRITE.CCSMY.REPORT                                          !1.9JAT
3487: 5a2e:        ENDIF
3488: 5a36:        CCDET.REPORT.LINE$ = DETAIL.FIRST.PART$ +                             \
3489: 5a78:                           STRING$(3," ") +                                   \
3490: 5a78:                           DETAIL.SECOND.PART$
3491: 5a78:         GOSUB WRITE.CCDET.REPORT
3492: 5a8a: 
3493: 5a8a:        DETAIL.FIRST.PART$ = STRING$(38," ")
3494: 5aa8:        DETAIL.SECOND.PART$ = STRING$(38," ")
3495: 5ac6:         DETAIL.FIRST.PART.FULL = FALSE
3496: 5adc:     ENDIF
3497: 5ae4: RETURN
3498: 5af4: 
3499: 5af4: \*****************************************************************************
3500: 5af4: \*****************************************************************************
3501: 5af4: \* RET.RPT.WRITE.ITEM.HEADER:                                                *
3502: 5af4: \*     format Item Details header line and write to CCDET report             *
3503: 5af4: \*                                                                           *
3504: 5af4: \* RETURN                                                                    *
3505: 5af4: \*****************************************************************************
3506: 5af4: RET.RPT.WRITE.ITEM.HEADER:
3507: 5b04: 
3508: 5b04:     IF LINES.PER.PAGE% - (CCDET.LINE.NO% - 1) < 4 THEN BEGIN
3509: 5b32:         GOSUB CCDET.START.NEW.PAGE
3510: 5b44:     ENDIF
3511: 5b4c:     CCDET.REPORT.LINE$ = BLANK.LINE$
3512: 5b6a:     GOSUB WRITE.CCDET.REPORT
3513: 5b7c:     CCDET.REPORT.LINE$ = "   Item Code             Description      " + \ DMJK
3514: 5b9a:                          "        Price    Qty/Pack       Value "       ! DMJK
3515: 5b9a: 
3516: 5b9a:     GOSUB WRITE.CCDET.REPORT
3517: 5bac:     CCDET.REPORT.LINE$ = BLANK.LINE$
3518: 5bca:     GOSUB WRITE.CCDET.REPORT
3519: 5bdc: RETURN
3520: 5bec: 
3521: 5bec: \*****************************************************************************
3522: 5bec: \*****************************************************************************
3523: 5bec: \* RET.RPT.WRITE.ITEM.DETAILS:                                               *
3524: 5bec: \*     read Item Table (item No.)                                            *
3525: 5bec: \*     if Item Code Flag is "I" (Boots Item Code)                            *
3526: 5bec: \*         read IDF by key (Boots Code)       and obtain item description    *
3527: 5bec: \*         format Boots Item Code for printing                               *
3528: 5bec: \*     else                                                                  *
3529: 5bec: \*         item description = 'not on file'                                  *
3530: 5bec: \*         format Item Bar Code for printing using Bar Code Display function *
3531: 5bec: \*     endif                                                                 *
3532: 5bec: \*     format Item Detail line and write to CCDET report                     *
3533: 5bec: \*                                                                           *
3534: 5bec: \* RETURN                                                                    *
3535: 5bec: \*****************************************************************************
3536: 5bec: RET.RPT.WRITE.ITEM.DETAILS:
3537: 5bfc: 
3538: 5bfc:     ITEM.CODE.FLAG$ = LEFT$(ITEM.TABLE$(ITEM.NO%),1)
3539: 5c39:     ITEM.CODE$ = MID$(ITEM.TABLE$(ITEM.NO%),2,7)                         !DMJK
3540: 5c76:     ITEM.QTY$ = MID$(ITEM.TABLE$(ITEM.NO%),9,4)
3541: 5cb3:     ITEM.PRICE$ = MID$(ITEM.TABLE$(ITEM.NO%),13,9)                       !DMJK
3542: 5cf0:     PACK.SIZE$ = MID$(ITEM.TABLE$(ITEM.NO%),22,5)                        !DMJK
3543: 5d2d:     ITEM.CLAIM.VALUE$ = RIGHT$(ITEM.TABLE$(ITEM.NO%),9)                  !DMJK
3544: 5d68: 
3545: 5d68:     IF ITEM.CODE$ = "9999991" OR                                         \ DDS
3546: 5dba:        ITEM.QTY$ = "   0" THEN BEGIN                                     ! DDS
3547: 5dba:        GOTO SKIP.PRINT                                                   ! DDS
3548: 5dc5:     ENDIF
3549: 5dcd: 
3550: 5dcd:     IF ITEM.CODE.FLAG$ = "I" THEN BEGIN                            !Boots Code
3551: 5dee:         IDF.BOOTS.CODE$ = RIGHT$(ITEM.CODE$,4)
3552: 5e13:        RC% = READ.IDF
3553: 5e2e:        IF RC% <> 0 THEN BEGIN
3554: 5e4d:            IDF.STNDRD.DESC$ = "+ + Item not on file + +"
3555: 5e64:        ENDIF
3556: 5e6c:        ITEM.BOOTS.CODE$ = RIGHT$(UNPACK$(RIGHT$(ITEM.CODE$,4)),7)
3557: 5eb3:        ITEM.CODE$ = STRING$(2," ") +                                         \
3558: 5f50:                    LEFT$(ITEM.BOOTS.CODE$,2) + "-" +                         \
3559: 5f50:                    MID$(ITEM.BOOTS.CODE$,3,2) + "-" +                        \
3560: 5f50:                    RIGHT$(ITEM.BOOTS.CODE$,3) +                              \
3561: 5f50:                    STRING$(6," ")
3562: 5f50:     ENDIF ELSE BEGIN                                                 !Bar Code
3563: 5f58:         IDF.STNDRD.DESC$ = "+ + Item not on file + +"
3564: 5f6f:         ITEM.BAR.CODE$ = PACK$(MID$(UNPACK$(ITEM.CODE$),2,12))          ! DMJK
3565: 5fab:        RC% = CALC.BAR.CODE.DISPLAY(ITEM.BAR.CODE$)
3566: 5fd4:        IF RC% <> 0 THEN BEGIN
3567: 5ff3:               PROGRAM.FAIL = TRUE
3568: 6009:            GOTO PROGRAM.EXIT
3569: 6014:        ENDIF
3570: 601c:        ITEM.CODE$ = F07.BAR.CODE.FORMAT$
3571: 603a:     ENDIF
3572: 6042: 
3573: 6042:     IF LINES.PER.PAGE% - (CCDET.LINE.NO% - 1) < 3 THEN BEGIN            ! DMJK
3574: 6070:         GOSUB CCDET.START.NEW.PAGE                                      ! DMJK
3575: 6082:     ENDIF                                                               ! DMJK
3576: 608a: 
3577: 608a:     IF NOT HEADER.PRINTED THEN BEGIN                                     ! DDS
3578: 609c:        GOSUB RET.RPT.WRITE.ITEM.HEADER                                   ! DDS
3579: 60ae:        HEADER.PRINTED = 1                                                ! DDS
3580: 60be:     ENDIF                                                                ! DDS
3581: 60c6: 
3582: 60c6:     CCDET.REPORT.LINE$ = " " + ITEM.CODE$ + "  " +                           \
3583: 6132:                           IDF.STNDRD.DESC$ + "  " +                     \ DMJK
3584: 6132:                       ITEM.PRICE$ +       "   " +                       \ DMJK
3585: 6132:                       ITEM.QTY$ +                                       \ DMJK
3586: 6132:                       PACK.SIZE$ + "   " +                              \ DMJK
3587: 6132:                       ITEM.CLAIM.VALUE$                                 ! DMJK
3588: 6132:     GOSUB WRITE.CCDET.REPORT
3589: 6144: 
3590: 6144: SKIP.PRINT:
3591: 6154: 
3592: 6154:     ITEM.NO% = ITEM.NO% + 1
3593: 616d: RETURN
3594: 617d: 
3595: 617d: \*****************************************************************************
3596: 617d: \*****************************************************************************
3597: 617d: \* RET.RPT.END:                                                              *
3598: 617d: \*    if new page required gosub CCSMY/CCDET.START.NEW.PAGE                  *
3599: 617d: \*    format End of Report line and write to CCSMY and CCDET reports         *
3600: 617d: \*    write page throw to end of each report                                 *
3601: 617d: \*                                                                           *
3602: 617d: \* RETURN                                                                    *
3603: 617d: \*****************************************************************************
3604: 617d: RET.RPT.END:
3605: 618d: 
3606: 618d:     IF CREDIT.CLAIM.ACTIVE = FALSE THEN BEGIN                                !1.9JAT
3607: 61a8: 
3608: 61a8:        IF LINES.PER.PAGE% - (CCSMY.LINE.NO% - 1) < 1 THEN BEGIN
3609: 61d6:           GOSUB CCSMY.START.NEW.PAGE
3610: 61e8:        ENDIF
3611: 61f0:        CCSMY.REPORT.LINE$ = STRING$(13," ") +                                   \
3612: 6220:                              "*  *  *   E N D   O F   R E P O R T    *  *  *"
3613: 6220:        GOSUB WRITE.CCSMY.REPORT
3614: 6232:     ENDIF                                                                    !1.9JAT
3615: 623a: 
3616: 623a:     IF LINES.PER.PAGE% - (CCDET.LINE.NO% - 1) < 1 THEN BEGIN
3617: 6268:            GOSUB CCDET.START.NEW.PAGE
3618: 627a:     ENDIF
3619: 6282:     CCDET.REPORT.LINE$ = STRING$(13," ") +                                   \
3620: 62b2:                           "*  *  *   E N D   O F   R E P O R T    *  *  *"
3621: 62b2:     GOSUB WRITE.CCDET.REPORT
3622: 62c4: 
3623: 62c4:     IF CREDIT.CLAIM.ACTIVE = FALSE THEN BEGIN                                !1.9JAT
3624: 62dc:        CCSMY.REPORT.LINE$ = PAGE.THROW$
3625: 62fa:        GOSUB WRITE.CCSMY.REPORT
3626: 630c:     ENDIF                                                                    !1.9JAT
3627: 6314: 
3628: 6314:     CCDET.REPORT.LINE$ = PAGE.THROW$
3629: 6332:     GOSUB WRITE.CCDET.REPORT
3630: 6344: RETURN
3631: 6354: 
3632: 6354: \*****************************************************************************
3633: 6354: \*****************************************************************************
3634: 6354: \* CCSMY.START.NEW.PAGE:                                                     *
3635: 6354: \*       write new page                                                      *
3636: 6354: \*       add 1 to page number                                                *
3637: 6354: \*       format page headers and write to CCSMY                              *
3638: 6354: \*       first page only - write header text to report                       *
3639: 6354: \*                                                                           *
3640: 6354: \* RETURN                                                                    *
3641: 6354: \*****************************************************************************
3642: 6354: CCSMY.START.NEW.PAGE:
3643: 6364: 
3644: 6364: IF CREDIT.CLAIM.ACTIVE = FALSE THEN BEGIN                                    !1.9JAT
3645: 637f:     CCSMY.LINE.NO% = 0
3646: 6396:     CCSMY.REPORT.LINE$ = PAGE.THROW$
3647: 63b4:     GOSUB WRITE.CCSMY.REPORT
3648: 63c6:     CCSMY.PAGE.NO% = CCSMY.PAGE.NO% + 1
3649: 63df:     CCSMY.PAGE.NO$ = RIGHT$("  " + STR$(CCSMY.PAGE.NO%),2)
3650: 642a: 
3651: 642a:     CCSMY.REPORT.LINE$ = PRINT.REPORT.NO$ +                                  \
3652: 647b:                           STRING$(50," ") +                                  \
3653: 647b:                       PRINT.TODAYS.DATE$ + " " +                             \
3654: 647b:                       PRINT.TIME$
3655: 647b:     GOSUB WRITE.CCSMY.REPORT
3656: 648d: 
3657: 648d:     CCSMY.REPORT.LINE$ = STRING$(11," ") + TITLE$ + " " + PRINT.WC.DATE$ + \ !1.6AH 4.2HSM
3658: 64de:                          STORE.NUMBER$                                       !4.2HSM
3659: 64de:     GOSUB WRITE.CCSMY.REPORT                                                 !4.2HSM
3660: 64f0:     CCSMY.REPORT.LINE$ = BLANK.LINE$
3661: 650e:     GOSUB WRITE.CCSMY.REPORT
3662: 6520: 
3663: 6520:     CCSMY.REPORT.LINE$ = STRING$(26," ") +                                   \
3664: 6584:                           "S U M M A R Y" +                                  \
3665: 6584:                       STRING$(23," ") +                                      \
3666: 6584:                       "Page " +                                              \
3667: 6584:                       CCSMY.PAGE.NO$ +                                       \
3668: 6584:                       " of "       +                                         \
3669: 6584:                       PAGE.NUM.MARKER$
3670: 6584:     GOSUB WRITE.CCSMY.REPORT
3671: 6596: 
3672: 6596: 
3673: 6596:     IF CCSMY.PAGE.NO% = 1 THEN BEGIN
3674: 65b8:         CCSMY.REPORT.LINE$ = BLANK.LINE$
3675: 65d6:         GOSUB WRITE.CCSMY.REPORT
3676: 65e8:        CCSMY.REPORT.LINE$ = " The following " + UNIT$ + " activities"+     \         !1.6AH
3677: 6615:                           " took place last week. If more "
3678: 6615:         GOSUB WRITE.CCSMY.REPORT
3679: 6627:        CCSMY.REPORT.LINE$ = " information is required request line" +        \
3680: 6645:                           " level report from EPOS controller. "
3681: 6645:         GOSUB WRITE.CCSMY.REPORT
3682: 6657:     ENDIF
3683: 665f: 
3684: 665f:     CCSMY.REPORT.LINE$ = BLANK.LINE$
3685: 667d:     GOSUB WRITE.CCSMY.REPORT
3686: 668f:     GOSUB WRITE.CCSMY.REPORT
3687: 66a1: 
3688: 66a1: ENDIF                                                                        !1.9JAT
3689: 66a9: RETURN
3690: 66b9: 
3691: 66b9: \*****************************************************************************
3692: 66b9: \*****************************************************************************
3693: 66b9: \* CCDET.START.NEW.PAGE:                                                     *
3694: 66b9: \*       write new page                                                      *
3695: 66b9: \*       add 1 to page number                                                *
3696: 66b9: \*       format page headers and write to CCSMY                              *
3697: 66b9: \*       first page only - write header text to report                       *
3698: 66b9: \*                                                                           *
3699: 66b9: \* RETURN                                                                    *
3700: 66b9: \*****************************************************************************
3701: 66b9: CCDET.START.NEW.PAGE:
3702: 66c9:     CCDET.LINE.NO% = 0
3703: 66e0:     CCDET.REPORT.LINE$ = PAGE.THROW$
3704: 66fe:     GOSUB WRITE.CCDET.REPORT
3705: 6710:     CCDET.PAGE.NO% = CCDET.PAGE.NO% + 1
3706: 6729:     CCDET.PAGE.NO$ = RIGHT$("  " + STR$(CCDET.PAGE.NO%),2)
3707: 6774: 
3708: 6774:     CCDET.REPORT.LINE$ = PRINT.REPORT.NO$ +                                  \
3709: 67c5:                           STRING$(50," ") +                                  \
3710: 67c5:                       PRINT.TODAYS.DATE$ + " " +                             \
3711: 67c5:                       PRINT.TIME$
3712: 67c5:     GOSUB WRITE.CCDET.REPORT
3713: 67d7: 
3714: 67d7:     CCDET.REPORT.LINE$ = STRING$(11," ") + TITLE$ + " " + PRINT.WC.DATE$ + \ !1.6AH  4.2HSM
3715: 6828:                          STORE.NUMBER$                                       !4.2HSM
3716: 6828: 
3717: 6828:     GOSUB WRITE.CCDET.REPORT
3718: 683a: 
3719: 683a:     CCDET.REPORT.LINE$ = BLANK.LINE$
3720: 6858:     GOSUB WRITE.CCDET.REPORT
3721: 686a: 
3722: 686a:     CCDET.REPORT.LINE$ = STRING$(28," ") +                                   \
3723: 68ce:                           "DETAILED REPORT" +                                \
3724: 68ce:                       STRING$(19," ") +                                      \
3725: 68ce:                       "Page " +                                              \
3726: 68ce:                       CCDET.PAGE.NO$ +                                       \
3727: 68ce:                       " of "       +                                         \
3728: 68ce:                       PAGE.NUM.MARKER$
3729: 68ce:     GOSUB WRITE.CCDET.REPORT
3730: 68e0: 
3731: 68e0:     IF CCDET.PAGE.NO% = 1 THEN BEGIN
3732: 68ff:         CCDET.REPORT.LINE$ = BLANK.LINE$
3733: 691d:         GOSUB WRITE.CCDET.REPORT
3734: 692f:        CCDET.REPORT.LINE$ = " The following " + DAT$ + " last week."            !1.6AH
3735: 6958:         GOSUB WRITE.CCDET.REPORT
3736: 696a:     ENDIF
3737: 6972: 
3738: 6972:     CCDET.REPORT.LINE$ = BLANK.LINE$
3739: 6990:     GOSUB WRITE.CCDET.REPORT
3740: 69a2:     GOSUB WRITE.CCDET.REPORT
3741: 69b4: RETURN
3742: 69c4: 
3743: 69c4: \*****************************************************************************
3744: 69c4: \*****************************************************************************
3745: 69c4: \* RET.RPT.NUM.OF.PAGES:                                                     *
3746: 69c4: \*    This routine replaces the 'page number marker' in the page headers     *
3747: 69c4: \*    for CCSMY and CCDET with the number of pages for that report.          *
3748: 69c4: \*                                                                           *
3749: 69c4: \*    close CCSMY file                                                       *
3750: 69c4: \*    open CCSMY Direct, record length 84                                    *
3751: 69c4: \*    repeat until End of CCSMY Report                                       *
3752: 69c4: \*        read CCSMY next report line                                        *
3753: 69c4: \*             check for End of CCSMY Report                                 *
3754: 69c4: \*             if page number marker is present on record line               *
3755: 69c4: \*                 replace page number marker with Number of Pages for CCSMY *
3756: 69c4: \*                 write CCSMY record                                        *
3757: 69c4: \*             endif                                                         *
3758: 69c4: \*    end repeat                                                             *
3759: 69c4: \*                                                                           *
3760: 69c4: \*    repeat the above process for CCDET report                              *
3761: 69c4: \*                                                                           *
3762: 69c4: \* RETURN                                                                    *
3763: 69c4: \*****************************************************************************
3764: 69c4: RET.RPT.NUM.OF.PAGES:
3765: 69d4:     IF CCSMY.OPEN THEN BEGIN
3766: 69e6:         CLOSE CCSMY.SESS.NUM%
3767: 69fa:        CCSMY.OPEN = FALSE
3768: 6a10:     ENDIF
3769: 6a18:     GOSUB OPEN.CCSMY.DIRECT
3770: 6a2a:     END.OF.REPORT = FALSE
3771: 6a40:     CCSMY.LINE.NO% = 1
3772: 6a57:     NUM.OF.PAGES$ = RIGHT$("  " + STR$(CCSMY.PAGE.NO%),2)
3773: 6aa2:     WHILE NOT END.OF.REPORT
3774: 6aad:         IF END #CCSMY.SESS.NUM% THEN END.OF.CCSMY.REPORT
3775: 6ac9:        READ FORM "C84"; #CCSMY.SESS.NUM%, CCSMY.LINE.NO%;                    \
3776: 6b03:                CCSMY.REPORT.LINE$
3777: 6b03:        IF MID$(CCSMY.REPORT.LINE$,75,4) = PAGE.NUM.MARKER$ THEN BEGIN
3778: 6b42:            TEMP$ = LEFT$(CCSMY.REPORT.LINE$,74)
3779: 6b69:            CCSMY.REPORT.LINE$ = TEMP$ +                                      \
3780: 6bd6:                                  NUM.OF.PAGES$ +                             \
3781: 6bd6:                              STRING$(5," ") +                                \
3782: 6bd6:                              CHR$(34) + CHR$(13) + CHR$(10)
3783: 6bd6:            GOSUB REWRITE.CCSMY.REPORT.LINE
3784: 6be8:        ENDIF
3785: 6bf0:        CCSMY.LINE.NO% = CCSMY.LINE.NO% + 1
3786: 6c09:        END.CCSMY.RECORD:
3787: 6c19:     WEND
3788: 6c2e: 
3789: 6c2e:     IF CCDET.OPEN THEN BEGIN
3790: 6c40:         CLOSE CCDET.SESS.NUM%
3791: 6c54:        CCDET.OPEN = FALSE
3792: 6c6a:     ENDIF
3793: 6c72:     GOSUB OPEN.CCDET.DIRECT
3794: 6c84:     END.OF.REPORT = FALSE
3795: 6c9a:     CCDET.LINE.NO% = 1
3796: 6cb1:     NUM.OF.PAGES$ = RIGHT$("  " + STR$(CCDET.PAGE.NO%),2)
3797: 6cfc:     WHILE NOT END.OF.REPORT
3798: 6d07:         IF END #CCDET.SESS.NUM% THEN END.OF.CCDET.REPORT
3799: 6d23:        READ FORM "C84"; #CCDET.SESS.NUM%, CCDET.LINE.NO%;                    \
3800: 6d5d:                CCDET.REPORT.LINE$
3801: 6d5d:        IF MID$(CCDET.REPORT.LINE$,75,4) = PAGE.NUM.MARKER$ THEN BEGIN
3802: 6d9c:            TEMP$ = LEFT$(CCDET.REPORT.LINE$,74)
3803: 6dc3:            CCDET.REPORT.LINE$ = TEMP$ +                                      \
3804: 6e30:                                  NUM.OF.PAGES$ +                             \
3805: 6e30:                              STRING$(5," ") +                                \
3806: 6e30:                              CHR$(34) + CHR$(13) + CHR$(10)
3807: 6e30:            GOSUB REWRITE.CCDET.REPORT.LINE
3808: 6e42:        ENDIF
3809: 6e4a:        CCDET.LINE.NO% = CCDET.LINE.NO% + 1
3810: 6e63:        END.CCDET.RECORD:
3811: 6e73:     WEND
3812: 6e88: 
3813: 6e88: RETURN
3814: 6e98: 
3815: 6e98: END.OF.CCSMY.REPORT:
3816: 6ea8:     END.OF.REPORT = TRUE
3817: 6ebe:     GOTO END.CCSMY.RECORD
3818: 6ec9: 
3819: 6ec9: END.OF.CCDET.REPORT:
3820: 6ed9:     END.OF.REPORT = TRUE
3821: 6eef:     GOTO END.CCDET.RECORD
3822: 6efa: 
3823: 6efa: \*****************************************************************************
3824: 6efa: \*****************************************************************************
3825: 6efa: \* FORMAT.VALUE:                                                             *
3826: 6efa: \*       formats an integer monetary value into a character string for       *
3827: 6efa: \*       printing on reports.                                                *
3828: 6efa: \*       formated string includes decimal point for  display and leading    *
3829: 6efa: \*       spaces.                                                             *
3830: 6efa: \*       total string length is 9 chars.                                     *
3831: 6efa: \*       input: value$ = str$(value.integer%)                                *
3832: 6efa: \*       output: value$ = formatted string                                   *
3833: 6efa: \*                                                                           *
3834: 6efa: \*       examples:                                                           *
3835: 6efa: \*                                                                           *
3836: 6efa: \*       input; value$ = str$(0)           output; value$ = "     0.00"      *
3837: 6efa: \*                                                                           *
3838: 6efa: \*       input; value$ = str$(2599)  output; value$ = "    25.99"            *
3839: 6efa: \*                                                                           *
3840: 6efa: \* RETURN                                                                    *
3841: 6efa: \*****************************************************************************
3842: 6efa: FORMAT.VALUE:
3843: 6f0a:        IF DECIMAL.PLACES% = 2 THEN BEGIN                         ! 1.5AH
3844: 6f1c:           IF VALUE$ = "0" THEN BEGIN
3845: 6f3a:                  TEMP$ = "0" + DIVIDER$ + "00"                   ! 1.5AH
3846: 6f63:                  GOTO FORMAT.VALUE.COMPLETE
3847: 6f6e:           ENDIF                                                  ! 1.5AH
3848: 6f78:        ENDIF ELSE BEGIN                                          ! 1.5AH
3849: 6f80:           IF VALUE$ = "0" THEN BEGIN                             ! 1.5AH
3850: 6f9e:                  TEMP$ = RIGHT$("00" + VALUE$,3)                 ! 1.5AH
3851: 6fd9:                  GOTO FORMAT.VALUE.COMPLETE                      ! 1.5AH
3852: 6fe4:           ENDIF                                                  ! 1.5AH
3853: 6fec:        ENDIF
3854: 6ff4: 
3855: 6ff4: 
3856: 6ff4:        L% = LEN(VALUE$)
3857: 7020:        IF DECIMAL.PLACES% = 2 THEN BEGIN                         ! 1.5AH
3858: 7035:           IF LEN(VALUE$) = 1 THEN BEGIN
3859: 7053:              TEMP$ = "0" + DIVIDER$ + "0" + VALUE$               ! 1.5AH
3860: 708a:           ENDIF ELSE BEGIN
3861: 7092:              IF LEN(VALUE$) = 2 THEN BEGIN
3862: 70b0:                 TEMP$ = "0" + DIVIDER$ + VALUE$                  ! 1.5AH
3863: 70e2:              ENDIF ELSE BEGIN
3864: 70ea:                 TEMP$ = LEFT$(VALUE$,L%-2) + DIVIDER$ + RIGHT$(VALUE$,2)   ! 1.5AH
3865: 714a:              ENDIF
3866: 7152:           ENDIF
3867: 715c:        ENDIF ELSE BEGIN                                          ! 1.5AH
3868: 7164:           TEMP$ = VALUE$                                         ! 1.5AH
3869: 7182:        ENDIF                                                     ! 1.5AH
3870: 718a: 
3871: 718a:        FORMAT.VALUE.COMPLETE:
3872: 719a:        VALUE$ = RIGHT$( STRING$(6," ") + TEMP$, 9)
3873: 71e7:        VALUE.NO.SPACES$ = TEMP$
3874: 7205: RETURN
3875: 7215: 
3876: 7215: \*****************************************************************************
3877: 7215: \*****************************************************************************
3878: 7215: \* FORMAT.WC.DATE:                                                           *
3879: 7215: \*       find date of Sunday last week                                       *      !4.1BMG
3880: 7215: \*       if last Sunday date > date of last report run find date for Sunday  *      !4.1BMG
3881: 7215: \*       prior to that, and so on until Sunday found is not > last report    *      !4.1BMG
3882: 7215: \*       run date - this is the week/commencing date for the current reports *
3883: 7215: \*       format WC date for printing on reports                              *
3884: 7215: \*                                                                           *
3885: 7215: \* RETURN                                                                    *
3886: 7215: \*****************************************************************************
3887: 7215: FORMAT.WC.DATE:
3888: 7225:        F13.DAY$ = ""
3889: 723c:        F02.DATE$ = TODAYS.DATE$
3890: 725a:        INCREMENT% = -7
3891: 7271:        WHILE F13.DAY$ <> "SUN"                                          !4.1BMG
3892: 727c:               RC% = UPDATE.DATE(INCREMENT%)
3893: 72a5:               IF RC% <> 0 THEN BEGIN
3894: 72c4:                      PROGRAM.FAIL = TRUE
3895: 72da:                      GOTO PROGRAM.EXIT
3896: 72e5:               ENDIF
3897: 72ed:               RC% = PSDATE(F02.DATE$)
3898: 7316:               IF RC% <> 0 THEN BEGIN
3899: 7335:                      PROGRAM.FAIL = TRUE
3900: 734b:                      GOTO PROGRAM.EXIT
3901: 7356:               ENDIF
3902: 735e:               INCREMENT% = -1
3903: 7375:        WEND
3904: 7396:        INCREMENT% = -7
3905: 73ad:         IF LAST.CREDIT.RUN.DATE$ <> "000000" THEN BEGIN                 ! CMJK
3906: 73ce:          WHILE DATE.GT (F02.DATE$,LAST.CREDIT.RUN.DATE$)                !1.4RD
3907: 73d8:               RC% = UPDATE.DATE(INCREMENT%)
3908: 7401:               IF RC% <> 0 THEN BEGIN
3909: 7420:                      PROGRAM.FAIL = TRUE
3910: 7436:                      GOTO PROGRAM.EXIT
3911: 7441:               ENDIF
3912: 7449:          WEND
3913: 7479:        ENDIF ELSE BEGIN                                                 ! CMJK
3914: 7481:            RC% = UPDATE.DATE(INCREMENT%)                                ! CMJK
3915: 74aa:          IF RC% <> 0 THEN BEGIN                                         ! CMJK
3916: 74c9:               PROGRAM.FAIL = TRUE                                       ! CMJK
3917: 74df:               GOTO PROGRAM.EXIT                                         ! CMJK
3918: 74ea:          ENDIF                                                          ! CMJK
3919: 74f2:        ENDIF                                                            ! CMJK
3920: 74fa:        WC.DATE$ = F02.DATE$
3921: 7518:        PRINT.WC.DATE$ = MID$(WC.DATE$,5,2) + "/" +                           \
3922: 7588:                        MID$(WC.DATE$,3,2) + "/" +                            \
3923: 7588:                        MID$(WC.DATE$,1,2)
3924: 7588: RETURN
3925: 7598: 
3926: 7598: \*****************************************************************************
3927: 7598: \*****************************************************************************
3928: 7598: \* GET.LINES.PER.PAGE:                                                       *
3929: 7598: \*       call ADXSERVE to determine the number of lines per page for reports *
3930: 7598: \*                                                                           *
3931: 7598: \* RETURN                                                                    *
3932: 7598: \*****************************************************************************
3933: 7598: GET.LINES.PER.PAGE:
3934: 75a8:     CALL ADXSERVE(RC%,4,0,ADX.PARM.2$)
3935: 75e4:     IF RC% <> 0 THEN BEGIN
3936: 7603:         LOG.EVENT.NO% = 24
3937: 761a:        LOG.STRING.1.UNIQUE$ = STR$(RC%)
3938: 763d:        GOSUB LOG.AN.EVENT
3939: 764f:        PROGRAM.FAIL = TRUE
3940: 7665:        GOTO PROGRAM.EXIT
3941: 7670:     ENDIF
3942: 7678:     LINES.PER.PAGE% = VAL(MID$(ADX.PARM.2$,20,3))
3943: 76ab: RETURN
3944: 76bb: 
3945: 76bb: \*****************************************************************************
3946: 76bb: \*****************************************************************************
3947: 76bb: \* LEFT.JUSTIFY.FIELD:                                                       *
3948: 76bb: \*           This routine strips away leading spaces from a character string,*
3949: 76bb: \*       thereby making it left justified.                                   *
3950: 76bb: \*                                                                           *
3951: 76bb: \*       input : field$ = char.string$                                       *
3952: 76bb: \*       output: field$                                                      *
3953: 76bb: \*                                                                           *
3954: 76bb: \*       eg. input : field$ = "   Hello"                                     *
3955: 76bb: \*           output: field$ = "Hello"                                        *
3956: 76bb: \*                                                                           *
3957: 76bb: \*       If field$ input is null or spaces then no action is taken on field$ *
3958: 76bb: \*       ie. returned value will be null or spaces                           *
3959: 76bb: \*                                                                           *
3960: 76bb: \* RETURN                                                                    *
3961: 76bb: \*****************************************************************************
3962: 76bb: LEFT.JUSTIFY.FIELD:
3963: 76cb:     IF LEN(FIELD$) > 0 THEN BEGIN
3964: 76ec:         CHAR.FOUND = FALSE
3965: 7702:         CHAR.POS% = 1
3966: 7719:        WHILE NOT CHAR.FOUND = TRUE                                           \
3967: 7724:          AND NOT (CHAR.POS% > LEN(FIELD$))
3968: 7724:            IF MID$(FIELD$,CHAR.POS%,1) <> " " THEN BEGIN
3969: 7763:                CHAR.FOUND = TRUE
3970: 777b:            ENDIF ELSE BEGIN
3971: 7783:                CHAR.POS% = CHAR.POS% +1
3972: 779c:            ENDIF
3973: 77a4:        WEND
3974: 77ec:        IF CHAR.FOUND THEN BEGIN
3975: 77fe:              TEMP$ = RIGHT$(FIELD$,( LEN(FIELD$) - (CHAR.POS% - 1) ) )
3976: 7851:            FIELD$ = TEMP$
3977: 786f:         ENDIF
3978: 7877:     ENDIF
3979: 787f: RETURN
3980: 788f: 
3981: 788f: \*****************************************************************************
3982: 788f: \*****************************************************************************
3983: 788f: \* CLAIMS.HOUSEKEEPING:                                                      *
3984: 788f: \*   GOSUB OPEN.CCLAM.KEYED                                                  *
3985: 788f: \*    for each claim held in the delete file;                                *
3986: 788f: \*        for each item associated with the claim;                           *
3987: 788f: \*              delete CCITF Item record by key                              *
3988: 788f: \*         delete CCLAM Claim record by key                                  *
3989: 788f: \*         CLOSE CCLAM.SESS.NUM%                                             *
3990: 788f: \*         CCLAM.OPEN = FALSE                                                *
3991: 788f: \*    Only set UPDATE.CCTRL.LAST.DATE to TRUE if Reporting Required    !1.3JAS
3992: 788f: \*    (CCTRL record re-written at finalise program)                    !1.3JAS
3993: 788f: \*                                                                           *
3994: 788f: \* RETURN                                                                    *
3995: 788f: \*****************************************************************************
3996: 788f: CLAIMS.HOUSEKEEPING:
3997: 789f:   GOSUB OPEN.CCLAM.KEYED                                               !1.3JAS
3998: 78b1:     FOR DEL.TAB.IDX% = 1 TO DEL.TAB.NO.ENTRIES% STEP 1
3999: 78cb:        CCLAM.CREDIT.CLAIM.NUM$ = LEFT$(DELETE.TABLE$(DEL.TAB.IDX%),4)
4000: 7908:        CCITF.CREDIT.CLAIM.NUM$ = LEFT$(DELETE.TABLE$(DEL.TAB.IDX%),4)
4001: 7945:        CCLAM.NUM.OF.ITEMS% = VAL(RIGHT$(DELETE.TABLE$(DEL.TAB.IDX%),4))
4002: 7986: 
4003: 7986:        FOR ITEM.NO% = 1 TO CCLAM.NUM.OF.ITEMS% STEP 1
4004: 79a0:            CCITF.ITEM.NUM$ = PACK$(RIGHT$("0000" + STR$(ITEM.NO%),4))
4005: 79f0:            CCITF.KEY$ = CCITF.CREDIT.CLAIM.NUM$ + CCITF.ITEM.NUM$
4006: 7a1c:            GOSUB DELREC.CCITF
4007: 7a2e:        NEXT ITEM.NO%
4008: 7a63: 
4009: 7a63:        GOSUB DELREC.CCLAM
4010: 7a75: 
4011: 7a75:     NEXT DEL.TAB.IDX%
4012: 7aad: 
4013: 7aad:     CLOSE CCLAM.SESS.NUM%                                              !1.3JAS
4014: 7ac1:     CCLAM.OPEN = FALSE                                                 !1.3JAS
4015: 7ad7: 
4016: 7ad7:     IF REPORTING.REQUIRED THEN BEGIN                                   !1.3JAS
4017: 7ae9:        UPDATE.CCTRL.LAST.DATE = TRUE
4018: 7b01:     ENDIF ELSE BEGIN                                                   !1.3JAS
4019: 7b09:           UPDATE.CCTRL.LAST.DATE = FALSE                               !1.3JAS
4020: 7b1f:     ENDIF                                                              !1.3JAS
4021: 7b27: RETURN
4022: 7b37: 
4023: 7b37: \*****************************************************************************
4024: 7b37: \*****************************************************************************
4025: 7b37: \* UPDATE.CCTRL:                                                             *
4026: 7b37: \*     read CCTRL record (locked)                                            *
4027: 7b37: \*     set Staff Sales to 0                                                  *
4028: 7b37: \*     if Update CCTRL Last Date = true                                      *
4029: 7b37: \*         set CCTRL Last Date = Today's Date                                *
4030: 7b37: \*     endif                                                                 *
4031: 7b37: \*     write CCTRL (unlock)                                                  *
4032: 7b37: \*                                                                           *
4033: 7b37: \* RETURN                                                                    *
4034: 7b37: \*****************************************************************************
4035: 7b37: UPDATE.CCTRL:
4036: 7b47:        CCTRL.REC.NUM% = 1
4037: 7b58:        RC% = READ.CCTRL.LOCKED
4038: 7b73:        IF RC% <> 0 THEN BEGIN
4039: 7b92:               GOSUB READ.FILE.ERROR
4040: 7ba4:        ENDIF
4041: 7bac:        CCTRL.STAFF.SALES% = 0
4042: 7bc3:        IF UPDATE.CCTRL.LAST.DATE THEN BEGIN
4043: 7bd5:               CCTRL.CREDIT.RPT.RUN.DATE$ = PACK$(TODAYS.DATE$)
4044: 7bf8:        ENDIF
4045: 7c00:        RC% = WRITE.UNLOCK.CCTRL
4046: 7c1b:        IF RC% <> 0 THEN BEGIN
4047: 7c3a:               GOSUB WRITE.FILE.ERROR
4048: 7c4c:        ENDIF
4049: 7c54: RETURN
4050: 7c64: 
4051: 7c64: \*****************************************************************************
4052: 7c64: \*****************************************************************************
4053: 7c64: \* OPEN.FILES:                                                               *
4054: 7c64: \*                                                                           *
4055: 7c64: \*      open IDF        KEYED            NOWRITE  NODEL                      *
4056: 7c64: \*      open SOFTS       DIRECT           NOWRITE  NODEL                     *
4057: 7c64: \*      open BCSMF       DIRECT           NOWRITE  NODEL                     *
4058: 7c64: \*      open CCITF       KEYED                                               *
4059: 7c64: \*      open CCTRL       DIRECT                                              *
4060: 7c64: \*      if open error then OPEN.FILE.ERROR                                   *
4061: 7c64: \*                                                                           *
4062: 7c64: \* RETURN                                                                    *
4063: 7c64: \*****************************************************************************
4064: 7c64: OPEN.FILES:
4065: 7c74: 
4066: 7c74:        CURRENT.REPORT.NUM% = IDF.REPORT.NUM%
4067: 7c8a:        IF END #IDF.SESS.NUM% THEN OPEN.FILE.ERROR
4068: 7ca6:        OPEN IDF.FILE.NAME$ KEYED RECL IDF.RECL% AS IDF.SESS.NUM%             \
4069: 7cd3:        NOWRITE NODEL
4070: 7cd3: 
4071: 7cd3: 
4072: 7cd3:        CURRENT.REPORT.NUM% = SOFTS.REPORT.NUM%
4073: 7ce9:        IF END #SOFTS.SESS.NUM% THEN OPEN.FILE.ERROR
4074: 7d05:        OPEN SOFTS.FILE.NAME$ DIRECT RECL SOFTS.RECL% AS SOFTS.SESS.NUM%      \
4075: 7d32:        NOWRITE NODEL
4076: 7d32: 
4077: 7d32:        CURRENT.REPORT.NUM% = BCSMF.REPORT.NUM%
4078: 7d48:        IF END #BCSMF.SESS.NUM% THEN OPEN.FILE.ERROR
4079: 7d64:        OPEN BCSMF.FILE.NAME$ DIRECT RECL SECTOR.SIZE% AS BCSMF.SESS.NUM%     \
4080: 7d96:        NOWRITE NODEL
4081: 7d96: 
4082: 7d96:        CURRENT.REPORT.NUM% = CCITF.REPORT.NUM%
4083: 7dac:        IF END #CCITF.SESS.NUM% THEN OPEN.FILE.ERROR
4084: 7dc8:        OPEN CCITF.FILE.NAME$ KEYED  RECL CCITF.RECL% AS CCITF.SESS.NUM%
4085: 7df4: 
4086: 7df4:        CURRENT.REPORT.NUM% = CCTRL.REPORT.NUM%
4087: 7e0a:        IF END #CCTRL.SESS.NUM% THEN OPEN.FILE.ERROR
4088: 7e26:        OPEN CCTRL.FILE.NAME$ DIRECT RECL CCTRL.RECL% AS CCTRL.SESS.NUM%
4089: 7e52: RETURN
4090: 7e62: 
4091: 7e62: \*****************************************************************************
4092: 7e62: \*****************************************************************************
4093: 7e62: \* OPEN.CCRSN:                                                               *
4094: 7e62: \*                                                                           *
4095: 7e62: \*      open CCRSN       KEYED            NOWRITE NODEL                      *
4096: 7e62: \*      if open error then OPEN.FILE.ERROR                                   *
4097: 7e62: \*                                                                           *
4098: 7e62: \* RETURN                                                                    *
4099: 7e62: \*****************************************************************************
4100: 7e62: OPEN.CCRSN:
4101: 7e72: 
4102: 7e72:        IF CCRSN.OPEN = FALSE THEN BEGIN                                     !1.9JAT
4103: 7e8a: 
4104: 7e8a:           CURRENT.REPORT.NUM% = CCRSN.REPORT.NUM%
4105: 7ea0:           IF END #CCRSN.SESS.NUM% THEN OPEN.FILE.ERROR
4106: 7ebc:           OPEN CCRSN.FILE.NAME$ KEYED  RECL CCRSN.RECL% AS CCRSN.SESS.NUM%      \
4107: 7ee9:           NOWRITE NODEL
4108: 7ee9:           CCRSN.OPEN = TRUE
4109: 7eff: 
4110: 7eff:        ENDIF                                                                !1.9JAT
4111: 7f07: RETURN
4112: 7f17: 
4113: 7f17: \*****************************************************************************
4114: 7f17: \*****************************************************************************
4115: 7f17: \* READ.BCSMF.SECTOR:                                                        *
4116: 7f17: \*      read one sector of data from BCSMF                                   *
4117: 7f17: \*                                                                           *
4118: 7f17: \* RETURN                                                                    *
4119: 7f17: \*****************************************************************************
4120: 7f17: READ.BCSMF.SECTOR:
4121: 7f27:        FILE.OPERATION$ = "R"
4122: 7f3e:        CURRENT.REPORT.NUM% = BCSMF.REPORT.NUM%
4123: 7f54:        IF END #BCSMF.SESS.NUM% THEN READ.FILE.ERROR
4124: 7f70:        READ FORM "C4,C508"; #BCSMF.SESS.NUM%, SECTOR.NO%;                    \
4125: 7fb5:                           SECTOR.FILLER$, BCSMF.SECTOR$
4126: 7fb5: RETURN
4127: 7fc5: 
4128: 7fc5: \*****************************************************************************
4129: 7fc5: \*****************************************************************************
4130: 7fc5: \* OPEN.CCLAM.DIRECT:                                                        *
4131: 7fc5: \*        open CCLAM      DIRECT     (RECL = Sector Size)                    *
4132: 7fc5: \*      if open error then OPEN.FILE.ERROR                                   *
4133: 7fc5: \*                                                                           *
4134: 7fc5: \* RETURN                                                                    *
4135: 7fc5: \*****************************************************************************
4136: 7fc5: OPEN.CCLAM.DIRECT:
4137: 7fd5:        CURRENT.REPORT.NUM% = CCLAM.REPORT.NUM%
4138: 7feb:        IF END #CCLAM.SESS.NUM% THEN OPEN.FILE.ERROR
4139: 8007:        OPEN CCLAM.FILE.NAME$ DIRECT RECL SECTOR.SIZE% AS CCLAM.SESS.NUM%
4140: 8038:        CCLAM.OPEN = TRUE
4141: 804e: RETURN
4142: 805e: 
4143: 805e: \*****************************************************************************
4144: 805e: \*****************************************************************************
4145: 805e: \* OPEN.CCLAM.KEYED:                                                         *
4146: 805e: \*        open CCLAM      KEYED                                              *
4147: 805e: \*      if open error then OPEN.FILE.ERROR                                   *
4148: 805e: \*                                                                           *
4149: 805e: \* RETURN                                                                    *
4150: 805e: \*****************************************************************************
4151: 805e: OPEN.CCLAM.KEYED:
4152: 806e:        CURRENT.REPORT.NUM% = CCLAM.REPORT.NUM%
4153: 8084:        IF END #CCLAM.SESS.NUM% THEN OPEN.FILE.ERROR
4154: 80a0:        OPEN CCLAM.FILE.NAME$ KEYED RECL CCLAM.RECL% AS CCLAM.SESS.NUM%
4155: 80cc:        CCLAM.OPEN = TRUE
4156: 80e2: RETURN
4157: 80f2: 
4158: 80f2: \*****************************************************************************
4159: 80f2: \*****************************************************************************
4160: 80f2: \* READ.CCLAM.SECTOR:                                                        *
4161: 80f2: \*      read one sector of data from CCLAM                                   *
4162: 80f2: \*                                                                           *
4163: 80f2: \* RETURN                                                                    *
4164: 80f2: \*****************************************************************************
4165: 80f2: READ.CCLAM.SECTOR:
4166: 8102:        FILE.OPERATION$ = "R"
4167: 8119:        CURRENT.REPORT.NUM% = CCLAM.REPORT.NUM%
4168: 812f:        IF END #CCLAM.SESS.NUM% THEN READ.FILE.ERROR
4169: 814b:        READ FORM "C4,C508"; #CCLAM.SESS.NUM%, SECTOR.NO%;                    \
4170: 8190:                           SECTOR.FILLER$, CCLAM.SECTOR$
4171: 8190: RETURN
4172: 81a0: 
4173: 81a0: \*****************************************************************************
4174: 81a0: \*****************************************************************************
4175: 81a0: \* RET.CREATE.REPORT.FILES:                                                  *
4176: 81a0: \*       Create new CCSMY Report File                                        *
4177: 81a0: \*       Create new CCDET Report File                                        *
4178: 81a0: \*       If error then gosub CREATE.FILE.ERROR                               *
4179: 81a0: \*                                                                           *
4180: 81a0: \* RETURN                                                                    *
4181: 81a0: \*****************************************************************************
4182: 81a0: RET.CREATE.REPORT.FILES:
4183: 81b0:        CURRENT.REPORT.NUM% = CCSMY.REPORT.NUM%
4184: 81c6:        IF END# CCSMY.SESS.NUM% THEN CREATE.FILE.ERROR
4185: 81e2:        CREATE POSFILE CCSMY.FILE.NAME$ AS CCSMY.SESS.NUM% MIRRORED ATCLOSE
4186: 8208:        CCSMY.OPEN = TRUE
4187: 821e: 
4188: 821e:        CURRENT.REPORT.NUM% = CCDET.REPORT.NUM%
4189: 8234:        IF END# CCDET.SESS.NUM% THEN CREATE.FILE.ERROR
4190: 8250:        CREATE POSFILE CCDET.FILE.NAME$ AS CCDET.SESS.NUM% MIRRORED ATCLOSE
4191: 8276:        CCDET.OPEN = TRUE
4192: 828c: RETURN
4193: 829c: 
4194: 829c: 
4195: 829c: \*****************************************************************************
4196: 829c: \*****************************************************************************
4197: 829c: \* OPEN.CCSMY.DIRECT:                                                        *
4198: 829c: \*        open CCSMY      DIRECT     (RECL = Report Record size = 84)        *
4199: 829c: \*      if open error then OPEN.FILE.ERROR                                   *
4200: 829c: \*                                                                           *
4201: 829c: \* RETURN                                                                    *
4202: 829c: \*****************************************************************************
4203: 829c: OPEN.CCSMY.DIRECT:
4204: 82ac:        CURRENT.REPORT.NUM% = CCSMY.REPORT.NUM%
4205: 82c2:        IF END #CCSMY.SESS.NUM% THEN OPEN.FILE.ERROR
4206: 82de:        OPEN CCSMY.FILE.NAME$ DIRECT RECL REPORT.REC.SIZE% AS CCSMY.SESS.NUM%
4207: 830f:        CCSMY.OPEN = TRUE
4208: 8325: RETURN
4209: 8335: 
4210: 8335: \*****************************************************************************
4211: 8335: \*****************************************************************************
4212: 8335: \* OPEN.CCDET.DIRECT:                                                        *
4213: 8335: \*        open CCDET      DIRECT     (RECL = Report Record size = 84)        *
4214: 8335: \*      if open error then OPEN.FILE.ERROR                                   *
4215: 8335: \*                                                                           *
4216: 8335: \* RETURN                                                                    *
4217: 8335: \*****************************************************************************
4218: 8335: OPEN.CCDET.DIRECT:
4219: 8345:        CURRENT.REPORT.NUM% = CCDET.REPORT.NUM%
4220: 835b:        IF END #CCDET.SESS.NUM% THEN OPEN.FILE.ERROR
4221: 8377:        OPEN CCDET.FILE.NAME$ DIRECT RECL REPORT.REC.SIZE% AS CCDET.SESS.NUM%
4222: 83a8:        CCDET.OPEN = TRUE
4223: 83be: RETURN
4224: 83ce: 
4225: 83ce: 
4226: 83ce: \*****************************************************************************
4227: 83ce: \*****************************************************************************
4228: 83ce: \* WRITE.CCSMY.REPORT:                                                       *
4229: 83ce: \*       edit CCSMY report line to 80 characters                             *
4230: 83ce: \*       write CCSMY report line                                             *
4231: 83ce: \*       if error gosub WRITE.FILE.ERROR                                     *
4232: 83ce: \*       add 1 to CCSMY Line No.                                             *
4233: 83ce: \*                                                                           *
4234: 83ce: \* RETURN                                                                    *
4235: 83ce: \*****************************************************************************
4236: 83ce: WRITE.CCSMY.REPORT:
4237: 83de:         CCSMY.REPORT.LINE$ = LEFT$(CCSMY.REPORT.LINE$ + STRING$(80," "),80)
4238: 842d:        RC% = WRITE.CCSMY
4239: 8448:        IF RC% <> 0 THEN BEGIN
4240: 8467:               GOSUB WRITE.FILE.ERROR
4241: 8479:        ENDIF
4242: 8481:        CCSMY.LINE.NO% = CCSMY.LINE.NO% + 1
4243: 849a: RETURN
4244: 84aa: 
4245: 84aa: \*****************************************************************************
4246: 84aa: \*****************************************************************************
4247: 84aa: \* REWRITE.CCSMY.REPORT.LINE:                                                *
4248: 84aa: \*       write CCSMY report line                                             *
4249: 84aa: \*       if error gosub WRITE.FILE.ERROR                                     *
4250: 84aa: \* RETURN                                                                    *
4251: 84aa: \*****************************************************************************
4252: 84aa: REWRITE.CCSMY.REPORT.LINE:
4253: 84ba:     CURRENT.REPORT.NUM%= CCSMY.REPORT.NUM%
4254: 84d0:     FILE.OPERATION$ = "W"
4255: 84e7:     IF END #CCSMY.SESS.NUM% THEN WRITE.FILE.ERROR
4256: 8503:     WRITE FORM "C84"; #CCSMY.SESS.NUM%, CCSMY.LINE.NO%;                      \
4257: 853d:           CCSMY.REPORT.LINE$
4258: 853d: RETURN
4259: 854d: 
4260: 854d: \*****************************************************************************
4261: 854d: \*****************************************************************************
4262: 854d: \* WRITE.CCDET.REPORT:                                                       *
4263: 854d: \*       edit CCDET report line to 80 characters                             *
4264: 854d: \*       write CCDET report line                                             *
4265: 854d: \*       if error gosub WRITE.FILE.ERROR                                     *
4266: 854d: \*       add 1 to CCDET Line No.                                             *
4267: 854d: \*                                                                           *
4268: 854d: \* RETURN                                                                    *
4269: 854d: \*****************************************************************************
4270: 854d: WRITE.CCDET.REPORT:
4271: 855d:         CCDET.REPORT.LINE$ = LEFT$(CCDET.REPORT.LINE$ + STRING$(80," "),80)
4272: 85ac:        RC% = WRITE.CCDET
4273: 85c7:        IF RC% <> 0 THEN BEGIN
4274: 85e6:               GOSUB WRITE.FILE.ERROR
4275: 85f8:        ENDIF
4276: 8600:        CCDET.LINE.NO% = CCDET.LINE.NO% + 1
4277: 8619: RETURN
4278: 8629: 
4279: 8629: \*****************************************************************************
4280: 8629: \*****************************************************************************
4281: 8629: \* REWRITE.CCDET.REPORT.LINE:                                                *
4282: 8629: \*       write CCDET report line                                             *
4283: 8629: \*       if error gosub WRITE.FILE.ERROR                                     *
4284: 8629: \* RETURN                                                                    *
4285: 8629: \*****************************************************************************
4286: 8629: REWRITE.CCDET.REPORT.LINE:
4287: 8639:     CURRENT.REPORT.NUM%= CCDET.REPORT.NUM%
4288: 864f:     FILE.OPERATION$ = "W"
4289: 8666:     IF END #CCDET.SESS.NUM% THEN WRITE.FILE.ERROR
4290: 8682:     WRITE FORM "C84"; #CCDET.SESS.NUM%, CCDET.LINE.NO%;                      \
4291: 86bc:           CCDET.REPORT.LINE$
4292: 86bc: RETURN
4293: 86cc: 
4294: 86cc: \*****************************************************************************
4295: 86cc: \*****************************************************************************
4296: 86cc: \* DELREC.CCITF:                                                             *
4297: 86cc: \*       delete record on CCITF File by key                                  *
4298: 86cc: \*       If error then branch to subroutine return                           *
4299: 86cc: \*                                                                           *
4300: 86cc: \* RETURN                                                                    *
4301: 86cc: \*****************************************************************************
4302: 86cc: DELREC.CCITF:
4303: 86dc:        CURRENT.REPORT.NUM% = CCITF.REPORT.NUM%
4304: 86f2:        IF END# CCITF.SESS.NUM% THEN CCITF.REC.ABSENT                     !CMJK
4305: 870e:        DELREC CCITF.SESS.NUM% ; CCITF.KEY$
4306: 872d:        CCITF.REC.ABSENT:                                                 !CMJK
4307: 873d: RETURN
4308: 874d: 
4309: 874d: \*****************************************************************************
4310: 874d: \*****************************************************************************
4311: 874d: \* DELREC.CCLAM:                                                             *
4312: 874d: \*       delete record on CCLAM File by key                                  *
4313: 874d: \*       If error then branch to subroutine return                           *
4314: 874d: \*                                                                           *
4315: 874d: \* RETURN                                                                    *
4316: 874d: \*****************************************************************************
4317: 874d: DELREC.CCLAM:
4318: 875d:        CURRENT.REPORT.NUM% = CCLAM.REPORT.NUM%
4319: 8773:        IF END# CCLAM.SESS.NUM% THEN CCLAM.REC.ABSENT                     !CMJK
4320: 878f:        DELREC CCLAM.SESS.NUM% ; CCLAM.CREDIT.CLAIM.NUM$
4321: 87ae:        CCLAM.REC.ABSENT:                                                 !CMJK
4322: 87be: RETURN
4323: 87ce: 
4324: 87ce: 
4325: 87ce: \*****************************************************************************
4326: 87ce: \***                                                                         *
4327: 87ce: \*** UPDATE.CLAIMS.TABLE 1.9JAT                                              *
4328: 87ce: \***                                                                         *
4329: 87ce: \*****************************************************************************
4330: 87ce: 
4331: 87ce: UPDATE.CLAIMS.TABLE:                                                          !1.9JAT
4332: 87de: 
4333: 87de:       GOSUB OPEN.CCRSN
4334: 87f0: 
4335: 87f0:       IF CCLAM.REASON.NUM$ <> PACK$("00") THEN BEGIN                          !1.9JAT
4336: 8819:          CCRSN.REASON$ = CCLAM.REASON.NUM$                                    !1.9JAT
4337: 8837:          RC% = READ.CCRSN                                                     !1.9JAT
4338: 8852:          IF RC% <> 0 THEN BEGIN                                               !1.9JAT
4339: 8871:             CCRSN.DESC$ = "NOT ON FILE                   "                    !1.9JAT
4340: 8888:          ENDIF                                                                !1.9JAT
4341: 8890:       ENDIF
4342: 8898: 
4343: 8898:       IF VAL(UNPACK$(CCRSN.ALTERNATE.REASON$))>HIGHEST.REASON.CODE% THEN BEGIN!1.9JAT
4344: 88e4:          HIGHEST.REASON.CODE% = VAL(UNPACK$(CCRSN.ALTERNATE.REASON$))         !1.9JAT
4345: 8913:       ENDIF
4346: 891b: 
4347: 891b:       IF LEFT$(CCLAM.FILLER$,7)  = STRING$(7," ") THEN BEGIN                  !4.2HSM
4348: 8957:           NEW.CLAIM.RECORDS$(CLAIMS.COUNTER%) = CCLAM.CREDIT.CLAIM.NUM$ +     \1.9JAT
4349: 89b6:                                                 CCLAM.REASON.NUM$       +     \1.9JAT
4350: 89b6:                                                 CCRSN.DESC$             +     \1.9JAT
4351: 89b6:                                                 CCRSN.ALTERNATE.REASON$ +     \1.9JAT
4352: 89b6:                                                 "00000000"                    !1.9JAT
4353: 89b6:       ENDIF ELSE BEGIN
4354: 89be:           NEW.CLAIM.RECORDS$(CLAIMS.COUNTER%) = CCLAM.CREDIT.CLAIM.NUM$ +     \4.2HSM
4355: 8a2e:                                                 CCLAM.REASON.NUM$       +     \4.2HSM
4356: 8a2e:                                                 CCRSN.DESC$             +     \4.2HSM
4357: 8a2e:                                                 CCRSN.ALTERNATE.REASON$ +     \4.2HSM
4358: 8a2e:                                                 "00000000"              +     \4.2HSM
4359: 8a2e:                                                 MID$(CCLAM.FILLER$,1,6)       !4.2HSM
4360: 8a2e:       ENDIF                                                                            
4361: 8a36:       CLAIMS.COUNTER% = CLAIMS.COUNTER% + 1                                   !1.9JAT
4362: 8a4f: 
4363: 8a4f: RETURN                                                                        !1.9JAT
4364: 8a5f: 
4365: 8a5f: \*****************************************************************************
4366: 8a5f: \***                                                                         *
4367: 8a5f: \*** CREATE.NEW.CCSMY  1.9JAT                                                *
4368: 8a5f: \***                                                                         *
4369: 8a5f: \*** Use the data stored in NEW.CLAIM.RECORDS$ to create the new style       *
4370: 8a5f: \*** CCSMY report.                                                           *
4371: 8a5f: \***                                                                         *
4372: 8a5f: \*****************************************************************************
4373: 8a5f: 
4374: 8a5f: CREATE.NEW.CCSMY:                                                             !1.9JAT
4375: 8a6f: 
4376: 8a6f:     !Sort the claim table by claim number                                     !1.9JAT
4377: 8a6f:     DIM F14.TABLE$(CLAIMS.COUNTER%)                                           !1.9JAT
4378: 8aa8: 
4379: 8aa8:     FOR A% = 1 TO CLAIMS.COUNTER%                                             !1.9JAT
4380: 8ac1:         F14.TABLE$ (A%) = NEW.CLAIM.RECORDS$(A%)                              !1.9JAT
4381: 8b0b:     NEXT A%                                                                   !1.9JAT
4382: 8b40: 
4383: 8b40:     RC% = SORT.TABLE(CLAIMS.COUNTER%)                                         !1.9JAT
4384: 8b69:     FOR A% = 1 TO CLAIMS.COUNTER%                                             !1.9JAT
4385: 8b82:         NEW.CLAIM.RECORDS$(A%) = F14.TABLE$(A%)                               !1.9JAT
4386: 8bcc:     NEXT A%                                                                   !1.9JAT
4387: 8c01: 
4388: 8c01:     DIM F14.TABLE$(0)                                                         !1.9JAT
4389: 8c30: 
4390: 8c30:     !Write the title to the CCSMY                                             !1.9JAT
4391: 8c30: 
4392: 8c30:     GOSUB WRITE.EXCEPTION.HEADER                                              !1.9JAT
4393: 8c42: 
4394: 8c42:     !Write exceptional claims to CCSMY                                        !1.9JAT
4395: 8c42:     FOR A% = 1 TO (CLAIMS.COUNTER% - 1)                                       !1.9JAT
4396: 8c5c:        ! CURRENT.CLAIM.VALUE% = VAL(RIGHT$(NEW.CLAIM.RECORDS$(A%),8))          !1.9JAT
4397: 8c5c:         CURRENT.CLAIM.VALUE%    = VAL(MID$(NEW.CLAIM.RECORDS$(A%),37,8))      !4.2HSM
4398: 8ca5:         IF CURRENT.CLAIM.VALUE% >= CLAIM.EXCEPTION.VALUE% THEN BEGIN          !1.9JAT
4399: 8cc5:            EXCEPTION.ON.REPORT = TRUE                                         !1.9JAT
4400: 8cdb:            GOSUB WRITE.EXCEPTION.SEGMENT                                      !1.9JAT
4401: 8ced:         ENDIF                                                                 !1.9JAT
4402: 8cf5:         CCRSN.ALTERNATE.REASON% = VAL(UNPACK$(MID$(NEW.CLAIM.RECORDS$(A%),36,1)))!1.9JAT
4403: 8d43:         CCRSN.REASON.NUM% = VAL(UNPACK$(MID$(NEW.CLAIM.RECORDS$(A%),5,1)))    !1.9JAT
4404: 8d91:         !Also build a table of reason codes for reporting later.              !1.9JAT
4405: 8d91:         IF LEFT$(NEW.REASON.CODE.RECORDS$(CCRSN.REASON.NUM%),1)               \1.9JAT
4406: 8ddf:                                                                = "" THEN BEGIN!1.9JAT
4407: 8ddf:            NEW.REASON.CODE.RECORDS$(CCRSN.REASON.NUM%) =                      \1.9JAT
4408: 8f01:                       RIGHT$("00" + STR$(CCRSN.ALTERNATE.REASON%),2)  +       \1.9JAT
4409: 8f01:                       RIGHT$("00" + STR$(CCRSN.REASON.NUM%),2)        +       \1.9JAT
4410: 8f01:                       MID$(NEW.CLAIM.RECORDS$(A%),6,30) + \ REASON DESC        1.9JAT                     
4411: 8f01:                       RIGHT$("00000000" + STR$(CURRENT.CLAIM.VALUE%),8)       !1.9JAT
4412: 8f01: 
4413: 8f01:         ENDIF ELSE BEGIN                                                      !1.9JAT
4414: 8f09:            TOTAL.CLAIM.VALUE% = VAL(RIGHT$(NEW.REASON.CODE.RECORDS$           \1.9JAT
4415: 8f50:                                           (CCRSN.REASON.NUM%),8))             !1.9JAT
4416: 8f50:            TOTAL.CLAIM.VALUE% = TOTAL.CLAIM.VALUE% + CURRENT.CLAIM.VALUE%     !1.9JAT
4417: 8f6b: 
4418: 8f6b:            NEW.REASON.CODE.RECORDS$(CCRSN.REASON.NUM%) = RIGHT$("00"  +       \1.9JAT
4419: 908a:                       STR$(CCRSN.ALTERNATE.REASON%),2) +                      \1.9JAT
4420: 908a:                       RIGHT$("00" + STR$(CCRSN.REASON.NUM%),2)        +       \1.9JAT
4421: 908a:                       MID$(NEW.CLAIM.RECORDS$(A%),6,30) + \ REASON DESC        1.9JAT
4422: 908a:                       RIGHT$("00000000" + STR$(TOTAL.CLAIM.VALUE%),8)         !1.9JAT
4423: 908a: 
4424: 908a:         ENDIF                                                                 !1.9JAT
4425: 9092:     NEXT A%                                                                   !1.9JAT
4426: 90ce: 
4427: 90ce:     VALUE$ = STR$(CLAIM.EXCEPTION.VALUE%)                                     !1.9JAT
4428: 90f1:     GOSUB FORMAT.VALUE                                                        !1.9JAT
4429: 9103: 
4430: 9103:     IF EXCEPTION.HEADER.WRITTEN = FALSE THEN BEGIN                            !1.9JAT
4431: 911b:          GOSUB WRITE.EXCEPTION.HEADER                                         !1.9JAT
4432: 912d:     ENDIF                                                                     !1.9JAT
4433: 9135: 
4434: 9135:     !Write a trailer for the exceptional lines segment                        !1.9JAT
4435: 9135:     CCSMY.REPORT.LINE$ = BLANK.LINE$                                          !1.9JAT
4436: 9153:     GOSUB WRITE.CCSMY.REPORT                                                  !1.9JAT
4437: 9165:     CCSMY.REPORT.LINE$ = BLANK.LINE$                                          !1.9JAT
4438: 9183:     GOSUB WRITE.CCSMY.REPORT                                                  !1.9JAT
4439: 9195:     IF EXCEPTION.ON.REPORT = TRUE THEN BEGIN                                  !1.9JAT
4440: 91ad:        CCSMY.REPORT.LINE$ = "All credit other than known theft will appear on the CN19 report" !1.9JAT
4441: 91c4:        GOSUB WRITE.CCSMY.REPORT                                               !1.9JAT
4442: 91d8:     ENDIF ELSE BEGIN                                                          !1.9JAT
4443: 91e0:        CCSMY.REPORT.LINE$ = "There are no credit claims above " +             \1.9JAT
4444: 9210:                              CURRENCY.SYMBOL$                   +             \1.9JAT
4445: 9210:                              VALUE.NO.SPACES$                                 !1.9JAT
4446: 9210:        GOSUB WRITE.CCSMY.REPORT                                               !1.9JAT
4447: 9222:     ENDIF
4448: 922a: 
4449: 922a: 
4450: 922a:     !Write reason code summary to CCSMY
4451: 922a:     GOSUB WRITE.REASON.CODE.SEGMENT                                           !1.9JAT
4452: 923c:     !Write End of Report trailer to CCSMY
4453: 923c:     CCSMY.REPORT.LINE$ = STRING$(13," ") +                                    \1.9JAT
4454: 926c:                              "*  *  *   E N D   O F   R E P O R T    *  *  *" !1.9JAT
4455: 926c:     GOSUB WRITE.CCSMY.REPORT                                                  !1.9JAT
4456: 927e:     CCSMY.REPORT.LINE$ = PAGE.THROW$                                          !1.9JAT
4457: 929c:     GOSUB WRITE.CCSMY.REPORT                                                  !1.9JAT
4458: 92ae: 
4459: 92ae:     GOSUB RET.RPT.NUM.OF.PAGES                                                !1.9JAT
4460: 92c0: 
4461: 92c0: RETURN                                                                        !1.9JAT
4462: 92d0: 
4463: 92d0: \*****************************************************************************
4464: 92d0: \***                                                                         *
4465: 92d0: \*** WRITE.EXCEPTION.SEGMENT 1.9JAT                                          *
4466: 92d0: \***                                                                         *
4467: 92d0: \*** Any claims in excess of the exception value taken from SOFTS will be    *
4468: 92d0: \*** written to the CCSMY report (At time of writing, these values are       *
4469: 92d0: \*** GBP400 or Eur400 in ROI                                                 *
4470: 92d0: \***                                                                         *
4471: 92d0: \*****************************************************************************
4472: 92d0: 
4473: 92d0: WRITE.EXCEPTION.SEGMENT:                                                                !1.9JAT
4474: 92e0:                                                                                    
4475: 92e0:       IF EXCEPTION.HEADER.WRITTEN = FALSE THEN BEGIN                                    !1.9JAT
4476: 92f8:          GOSUB WRITE.EXCEPTION.HEADER                                                   !1.9JAT
4477: 930a:       ENDIF                                                                             !1.9JAT
4478: 9312:                                                                                    
4479: 9312:       CCLAM.CREDIT.CLAIM.NUM$ = UNPACK$(LEFT$(NEW.CLAIM.RECORDS$(A%),4))                !1.9JAT
4480: 9354:       CCRSN.DESC$             = MID$(NEW.CLAIM.RECORDS$(A%),6,30)                       !1.9JAT
4481: 9391:       CCRSN.ALTERNATE.REASON$ = UNPACK$(MID$(NEW.CLAIM.RECORDS$(A%),36,1))              !1.9JAT
4482: 93d3:       !CURRENT.CLAIM.VALUE% = VAL(RIGHT$(NEW.CLAIM.RECORDS$(A%),8))                      !1.9JAT
4483: 93d3:       CURRENT.CLAIM.VALUE%    = VAL(MID$(NEW.CLAIM.RECORDS$(A%),37,8))                  !4.2HSM
4484: 941c:       CURRENT.TILL.CLAIM$     = UNPACK$(MID$(NEW.CLAIM.RECORDS$(A%),45,6))              !4.2HSM
4485: 945e: 
4486: 945e:       VALUE$ = STR$(CURRENT.CLAIM.VALUE%)                                               !1.9JAT
4487: 9481:       GOSUB FORMAT.VALUE                                                                !1.9JAT
4488: 9493:                                                                                      
4489: 9493:       CCSMY.REPORT.LINE$ = "Credit claim number : " + CCLAM.CREDIT.CLAIM.NUM$           !1.9JAT
4490: 94b8:       GOSUB WRITE.CCSMY.REPORT                                                          !1.9JAT                                    
4491: 94ca:       
4492: 94ca:       CCSMY.REPORT.LINE$ = "Transaction Number : " + MID$(CURRENT.TILL.CLAIM$,1,4) + \  !4.2HSM                        
4493: 953e:                            " Till Number : " + MID$(CURRENT.TILL.CLAIM$,6,3)       + \  !4.2HSM
4494: 953e:                            " Operator : " + MID$(CURRENT.TILL.CLAIM$,10,3)              !4.2HSM
4495: 953e:       GOSUB WRITE.CCSMY.REPORT                                                          !4.2HSM 
4496: 9550:       
4497: 9550:       CCSMY.REPORT.LINE$ = "Reason Code : " + CCRSN.ALTERNATE.REASON$ + " " +       \   !1.9JAT
4498: 9584:                                               CCRSN.DESC$                               !1.9JAT
4499: 9584:       GOSUB WRITE.CCSMY.REPORT                                                          !1.9JAT
4500: 9596:       CCSMY.REPORT.LINE$ = "Value : " + VALUE.NO.SPACES$                                !1.9JAT
4501: 95bb:       GOSUB WRITE.CCSMY.REPORT                                                          !1.9JAT
4502: 95cd:                                                                                     
4503: 95cd:       CCSMY.REPORT.LINE$ = BLANK.LINE$                                                  !1.9JAT
4504: 95eb:       GOSUB WRITE.CCSMY.REPORT                                                          !1.9JAT
4505: 95fd:                                                                                     
4506: 95fd:       IF LINES.PER.PAGE% - (CCSMY.LINE.NO% - 1) < 3 THEN BEGIN                          !1.9JAT
4507: 962b:          GOSUB WRITE.EXCEPTION.HEADER                                                   !1.9JAT
4508: 963d:       ENDIF                                                                             !1.9JAT
4509: 9645:                                                                                      
4510: 9645: RETURN
4511: 9655: 
4512: 9655: 
4513: 9655: \*****************************************************************************
4514: 9655: \***                                                                         *
4515: 9655: \*** WRITE.REASON.CODE.SEGMENT 1.9JAT                                        *
4516: 9655: \***                                                                         *
4517: 9655: \*** Write a list of used Reason Codes to the CCSMY, along with the amount   *
4518: 9655: \*** claimed against each code.                                              *
4519: 9655: \*** Data is taken from the NEW.REASON.CODE.RECORDS$ table, loaded in sub-   *
4520: 9655: \*** CREATE.NEW.CCSMY                                                        *
4521: 9655: \*****************************************************************************
4522: 9655: 
4523: 9655: WRITE.REASON.CODE.SEGMENT:                                                    !1.9JAT
4524: 9665: 
4525: 9665: 
4526: 9665:     !Sort the reason code table by Alternate Reason Code num                   !1.9JAT
4527: 9665:     DIM F14.TABLE$(HIGHEST.REASON.CODE%)                                       !1.9JAT
4528: 969e: 
4529: 969e:     FOR A% = 1 TO HIGHEST.REASON.CODE%                                        !1.9JAT
4530: 96b7:         F14.TABLE$ (A%) = NEW.REASON.CODE.RECORDS$(A%)                        !1.9JAT
4531: 9701:     NEXT A%                                                                   !1.9JAT
4532: 9736: 
4533: 9736:     RC% = SORT.TABLE(HIGHEST.REASON.CODE%)                                    !1.9JAT
4534: 975f:     FOR A% = 1 TO HIGHEST.REASON.CODE%                                        !1.9JAT
4535: 9778:         NEW.REASON.CODE.RECORDS$(A%) = F14.TABLE$(A%)                         !1.9JAT
4536: 97c2:     NEXT A%                                                                   !1.9JAT
4537: 97f7: 
4538: 97f7:     DIM F14.TABLE$(0)                                                         !1.9JAT
4539: 9826: 
4540: 9826:     GOSUB WRITE.REASON.CODE.HEADER                                            !1.9JAT
4541: 9838: 
4542: 9838:     FOR A% = 1 TO HIGHEST.REASON.CODE%                                        !1.9JAT
4543: 9852:         IF LEFT$(NEW.REASON.CODE.RECORDS$(A%),1) <> "" THEN BEGIN             !1.9JAT
4544: 98a0:            REASON.CODE.ON.REPORT = TRUE                                       !1.9JAT
4545: 98b6:            CCRSN.ALTERNATE.REASON$ = LEFT$(NEW.REASON.CODE.RECORDS$(A%),2)    !1.9JAT
4546: 98f3:            CCRSN.DESC$ = MID$(NEW.REASON.CODE.RECORDS$(A%),5,30)              !1.9JAT
4547: 9930:            TOTAL.CLAIM.VALUE% = VAL(RIGHT$(NEW.REASON.CODE.RECORDS$(A%),8))   !1.9JAT
4548: 9977:            VALUE$ = STR$(TOTAL.CLAIM.VALUE%)                                  !1.9JAT
4549: 999a:            GOSUB FORMAT.VALUE                                                 !1.9JAT
4550: 99ac: 
4551: 99ac:            CCSMY.REPORT.LINE$ = "Reason code " + CCRSN.ALTERNATE.REASON$ + " "\1.9JAT
4552: 99ef:                                 + CCRSN.DESC$ + ": " + VALUE.NO.SPACES$       !1.9JAT
4553: 99ef:            GOSUB WRITE.CCSMY.REPORT                                           !1.9JAT
4554: 9a01:            CCSMY.REPORT.LINE$ = BLANK.LINE$                                   !1.9JAT
4555: 9a1f:            GOSUB WRITE.CCSMY.REPORT                                           !1.9JAT
4556: 9a31:            IF LINES.PER.PAGE% - (CCSMY.LINE.NO% - 1) < 2 THEN BEGIN           !1.9JAT
4557: 9a5f:               GOSUB WRITE.REASON.CODE.HEADER                                  !1.9JAT
4558: 9a71:            ENDIF                                                              !1.9JAT
4559: 9a79:         ENDIF                                                                 !1.9JAT
4560: 9a81:     NEXT A%                                                                   !1.9JAT
4561: 9ab9:     CCSMY.REPORT.LINE$ = BLANK.LINE$                                          !1.9JAT
4562: 9ad7:     GOSUB WRITE.CCSMY.REPORT                                                  !1.9JAT
4563: 9ae9:     IF REASON.CODE.ON.REPORT = FALSE THEN BEGIN                               !1.9JAT
4564: 9b01:        CCSMY.REPORT.LINE$ = "There are no credit claims to report"            !1.9JAT
4565: 9b18:        GOSUB WRITE.CCSMY.REPORT                                               !1.9JAT
4566: 9b2a:     ENDIF                                                                     !1.9JAT
4567: 9b32:     CCSMY.REPORT.LINE$ = BLANK.LINE$                                          !1.9JAT
4568: 9b50:     GOSUB WRITE.CCSMY.REPORT                                                  !1.9JAT
4569: 9b62: 
4570: 9b62: RETURN
4571: 9b72: 
4572: 9b72: \*****************************************************************************
4573: 9b72: \***                                                                         *
4574: 9b72: \*** WRITE.EXCEPTION.HEADER  1.9JAT                                          *
4575: 9b72: \***                                                                         *
4576: 9b72: \*** Write the header details to the exception section of the CCSMY          *
4577: 9b72: \***                                                                         *
4578: 9b72: \*****************************************************************************
4579: 9b72: 
4580: 9b72:    WRITE.EXCEPTION.HEADER:
4581: 9b82: 
4582: 9b82:     CCSMY.LINE.NO% = 0                                                        !1.9JAT
4583: 9b99:     CCSMY.REPORT.LINE$ = PAGE.THROW$                                          !1.9JAT
4584: 9bb7:     GOSUB WRITE.CCSMY.REPORT                                                  !1.9JAT
4585: 9bc9:     CCSMY.REPORT.LINE$ = BLANK.LINE$                                          !1.9JAT
4586: 9be7:     GOSUB WRITE.CCSMY.REPORT                                                  !1.9JAT
4587: 9bf9:     CCSMY.PAGE.NO% = CCSMY.PAGE.NO% + 1                                       !1.9JAT
4588: 9c12:     CCSMY.PAGE.NO$ = RIGHT$("  " + STR$(CCSMY.PAGE.NO%),2)                    !1.9JAT
4589: 9c5d:     CCSMY.REPORT.LINE$ = BLANK.LINE$                                          !1.9JAT
4590: 9c7b:     GOSUB WRITE.CCSMY.REPORT                                                  !1.9JAT
4591: 9c8d: 
4592: 9c8d:     CCSMY.REPORT.LINE$ = PRINT.REPORT.NO$ +                                   \1.9JAT
4593: 9cde:                          STRING$(50," ") +                                    \1.9JAT
4594: 9cde:                          PRINT.TODAYS.DATE$ + " " +                           \1.9JAT
4595: 9cde:                          PRINT.TIME$                                          !1.9JAT
4596: 9cde:     GOSUB WRITE.CCSMY.REPORT                                                  !1.9JAT
4597: 9cf0:     CCSMY.REPORT.LINE$ = STRING$(11," ") + TITLE$ + " " + PRINT.WC.DATE$ + \  !1.9JAT
4598: 9d41:                          STORE.NUMBER$                                        !4.2HSM       
4599: 9d41:     GOSUB WRITE.CCSMY.REPORT                                                  !1.9JAT
4600: 9d53:     CCSMY.REPORT.LINE$ = BLANK.LINE$                                          !1.9JAT
4601: 9d71:     GOSUB WRITE.CCSMY.REPORT                                                  !1.9JAT
4602: 9d83:     CCSMY.REPORT.LINE$ = STRING$(62," ") +                                    \1.9JAT
4603: 9dcd:                          "Page " +                                            \1.9JAT
4604: 9dcd:                           CCSMY.PAGE.NO$ +                                    \1.9JAT
4605: 9dcd:                           " of "       +                                      \1.9JAT
4606: 9dcd:                           PAGE.NUM.MARKER$                                    !1.9JAT
4607: 9dcd:     GOSUB WRITE.CCSMY.REPORT                                                  !1.9JAT
4608: 9ddf:     CCSMY.REPORT.LINE$ = BLANK.LINE$                                          !1.9JAT
4609: 9dfd:     GOSUB WRITE.CCSMY.REPORT                                                  !1.9JAT
4610: 9e0f: 
4611: 9e0f:    VALUE$ = STR$(CLAIM.EXCEPTION.VALUE%)                                      !1.9JAT
4612: 9e32:    GOSUB FORMAT.VALUE                                                         !1.9JAT
4613: 9e44:    CCSMY.REPORT.LINE$ = "CREDIT CLAIMING VALUES BELOW " +                     \1.0JAT
4614: 9e78:                          CURRENCY.SYMBOL$               +                     \1.9JAT
4615: 9e78:                          VALUE.NO.SPACES$               +                     \1.9JAT
4616: 9e78:                          " - DO NOT RECONCILE"                                !1.9JAT
4617: 9e78:     GOSUB WRITE.CCSMY.REPORT                                                  !1.9JAT
4618: 9e8a:     CCSMY.REPORT.LINE$ = BLANK.LINE$                                          !1.9JAT
4619: 9ea8:     GOSUB WRITE.CCSMY.REPORT                                                  !1.9JAT
4620: 9eba: 
4621: 9eba:     EXCEPTION.HEADER.WRITTEN = TRUE                                           !1.9JAT
4622: 9ed0: 
4623: 9ed0:     RETURN
4624: 9ee0: 
4625: 9ee0: \*****************************************************************************
4626: 9ee0: \***                                                                         *
4627: 9ee0: \*** WRITE.REASON.CODE.HEADER  1.9JAT                                        *
4628: 9ee0: \***                                                                         *
4629: 9ee0: \*** Write the header details to the reason code section                     *
4630: 9ee0: \***                                                                         *
4631: 9ee0: \*****************************************************************************
4632: 9ee0: 
4633: 9ee0:    WRITE.REASON.CODE.HEADER:
4634: 9ef0: 
4635: 9ef0:     CCSMY.LINE.NO% = 0                                                        !1.9JAT
4636: 9f07:     CCSMY.REPORT.LINE$ = PAGE.THROW$                                          !1.9JAT
4637: 9f25:     GOSUB WRITE.CCSMY.REPORT                                                  !1.9JAT
4638: 9f37:     CCSMY.PAGE.NO% = CCSMY.PAGE.NO% + 1                                       !1.9JAT
4639: 9f50:     CCSMY.PAGE.NO$ = RIGHT$("  " + STR$(CCSMY.PAGE.NO%),2)                    !1.9JAT
4640: 9f9b:     CCSMY.REPORT.LINE$ = BLANK.LINE$                                          !1.9JAT
4641: 9fb9:     GOSUB WRITE.CCSMY.REPORT                                                  !1.9JAT
4642: 9fcb: 
4643: 9fcb:     CCSMY.REPORT.LINE$ = PRINT.REPORT.NO$ +                                   \1.9JAT
4644: a01c:                          STRING$(50," ") +                                    \1.9JAT
4645: a01c:                          PRINT.TODAYS.DATE$ + " " +                           \1.9JAT
4646: a01c:                          PRINT.TIME$                                          !1.9JAT
4647: a01c:     GOSUB WRITE.CCSMY.REPORT                                                  !1.9JAT
4648: a02e:     CCSMY.REPORT.LINE$ = STRING$(11," ") + TITLE$ + " " + PRINT.WC.DATE$ + \  !1.9JAT    
4649: a07f:                          STORE.NUMBER$                                        !4.2HSM    
4650: a07f:     GOSUB WRITE.CCSMY.REPORT                                                  !1.9JAT
4651: a091:     CCSMY.REPORT.LINE$ = BLANK.LINE$                                          !1.9JAT
4652: a0af:     GOSUB WRITE.CCSMY.REPORT                                                  !1.9JAT
4653: a0c1:     CCSMY.REPORT.LINE$ = STRING$(62," ") +                                    \1.9JAT
4654: a10b:                          "Page " +                                            \1.9JAT
4655: a10b:                           CCSMY.PAGE.NO$ +                                    \1.9JAT
4656: a10b:                           " of "       +                                      \1.9JAT
4657: a10b:                           PAGE.NUM.MARKER$                                    !1.9JAT
4658: a10b:     GOSUB WRITE.CCSMY.REPORT                                                  !1.9JAT
4659: a11d:     CCSMY.REPORT.LINE$ = BLANK.LINE$                                          !1.9JAT
4660: a13b:     GOSUB WRITE.CCSMY.REPORT                                                  !1.9JAT
4661: a14d: 
4662: a14d:     CCSMY.REPORT.LINE$ = "TOTAL CLAIMED AGAINST EACH REASON CODE - DO NOT RECONCILE"!1.9JAT
4663: a164:     GOSUB WRITE.CCSMY.REPORT                                                  !1.9JAT
4664: a176:     CCSMY.REPORT.LINE$ = BLANK.LINE$                                          !1.9JAT
4665: a194:     GOSUB WRITE.CCSMY.REPORT                                                  !1.9JAT
4666: a1a6: 
4667: a1a6:     RETURN
4668: a1b6: 
4669: a1b6: 
4670: a1b6: \*****************************************************************************
4671: a1b6: \***                                                                         *
4672: a1b6: \*** PROCESS.CURRENT.TILL.CLAIM  4.2 HSM                                     *
4673: a1b6: \***                                                                         *
4674: a1b6: \*** Keyreads the CCITF file to for Till Claims and writes them to the CCDET *
4675: a1b6: \*** report.                                                                 *
4676: a1b6: \***                                                                         *
4677: a1b6: \*****************************************************************************
4678: a1b6: 
4679: a1b6: PROCESS.CURRENT.TILL.CLAIM:                                                   
4680: a1c6:                                                                               
4681: a1c6:     CCITF.ITEM.NUM$ = PACK$(RIGHT$("0000" + STR$(ITEM.NO%),4))                !4.2HSM
4682: a216:     CCITF.KEY$ = CCITF.CREDIT.CLAIM.NUM$ + CCITF.ITEM.NUM$                    !4.2HSM
4683: a242:     RC% = READ.CCITF                                                          !4.2HSM
4684: a25d:     CURRENT.TILL.CLAIM$ = UNPACK$(MID$(CCLAM.FILLER$,1,6))                    !4.2HSM
4685: a289:     IF LEFT$(CCLAM.FILLER$,7) <> STRING$(7," ") THEN BEGIN                    !4.2HSM           
4686: a2c5:         CURRENT.TILL.CLAIM$ = "Transaction Number : " + \                     !4.2HSM
4687: a339:                              MID$(CURRENT.TILL.CLAIM$,1,4) + \                !4.2HSM 
4688: a339:                              " Till Number : " + \                            !4.2HSM
4689: a339:                              MID$(CURRENT.TILL.CLAIM$,6,3) + \                !4.2HSM 
4690: a339:                              " Operator : " + \                               !4.2HSM
4691: a339:                              MID$(CURRENT.TILL.CLAIM$,10,3)                   !4.2HSM                                          
4692: a339:     ENDIF                                                                     !4.2HSM
4693: a341:       
4694: a341: RETURN
4695: a351: 
4696: a351: \*****************************************************************************
4697: a351: \*****************************************************************************
4698: a351: \* CLOSE.FILES:                                                              *
4699: a351: \*       close files : IDF, SOFTS, BCSMF                                     *
4700: a351: \*                    CCLAM, CCITF, CCTRL, CCRSN,                            *
4701: a351: \*                    CCSMY, CCDET, CCSTS                                    *
4702: a351: \*                                                                           *
4703: a351: \* RETURN                                                                    *
4704: a351: \*****************************************************************************
4705: a351: CLOSE.FILES:
4706: a361:        CLOSE IDF.SESS.NUM%
4707: a375:        CLOSE SOFTS.SESS.NUM%
4708: a389:        CLOSE BCSMF.SESS.NUM%
4709: a39d:        CLOSE CCITF.SESS.NUM%
4710: a3b1:        CLOSE CCTRL.SESS.NUM%
4711: a3c5:        CLOSE UDESC.SESS.NUM%    !1.6AH
4712: a3d9:        IF CCRSN.OPEN THEN BEGIN
4713: a3eb:               CLOSE CCRSN.SESS.NUM%
4714: a3ff:               CCRSN.OPEN = FALSE
4715: a415:        ENDIF
4716: a41d:        IF CCLAM.OPEN THEN BEGIN
4717: a42f:               CLOSE CCLAM.SESS.NUM%
4718: a443:               CCLAM.OPEN = FALSE
4719: a459:        ENDIF
4720: a461:        IF CCSMY.OPEN THEN BEGIN
4721: a473:               CLOSE CCSMY.SESS.NUM%
4722: a487:               CCSMY.OPEN = FALSE
4723: a49d:        ENDIF
4724: a4a5:        IF CCDET.OPEN THEN BEGIN
4725: a4b7:               CLOSE CCDET.SESS.NUM%
4726: a4cb:               CCDET.OPEN = FALSE
4727: a4e1:        ENDIF
4728: a4e9:        IF CCSTS.OPEN THEN BEGIN                                         ! BDCN
4729: a4fb:               CLOSE CCSTS.SESS.NUM%                                     ! BDCN
4730: a50f:               CCSTS.OPEN = FALSE                                        ! BDCN
4731: a525:        ENDIF                                                            ! BDCN
4732: a52d: RETURN
4733: a53d: 
4734: a53d: 
4735: a53d: \*****************************************************************************
4736: a53d: \*****************************************************************************
4737: a53d: \* CCSTS.READ.FAIL:                                                          *
4738: a53d: \*      EOF reached - set EOF flag                                           *
4739: a53d: \*                                                                           *
4740: a53d: \*****************************************************************************
4741: a53d:    CCSTS.READ.FAIL:
4742: a54d: 
4743: a54d:         EOF.CCSTS.FLAG$ = "Y"
4744: a564:         GOTO RETURN.CCSTS.READ.FAIL
4745: a56f: 
4746: a56f: 
4747: a56f: 
4748: a56f: \*****************************************************************************
4749: a56f: \*****************************************************************************
4750: a56f: \* OPEN.FILE.ERROR:                                                          *
4751: a56f: \*      log event no 106 (IF END error)                                      *
4752: a56f: \*      unique event data includes O + file no                               *
4753: a56f: \*      gosub LOG.AN.EVENT                                                   *
4754: a56f: \*      goto PROGRAM.EXIT                                                    *
4755: a56f: \* RETURN                                                                    *
4756: a56f: \*****************************************************************************
4757: a56f: OPEN.FILE.ERROR:
4758: a57f:        LOG.EVENT.NO% = 106
4759: a596:        LOG.STRING.1.UNIQUE$ = "O" +                                          \
4760: a608:                             CHR$(SHIFT(CURRENT.REPORT.NUM%,8)) +             \
4761: a608:                             CHR$(SHIFT(CURRENT.REPORT.NUM%,0)) +             \
4762: a608:                             PACK$(STRING$(14,"0"))
4763: a608:        GOSUB LOG.AN.EVENT
4764: a61a:        PROGRAM.FAIL = TRUE
4765: a630:        GOTO PROGRAM.EXIT
4766: a63b: RETURN
4767: a64b: 
4768: a64b: \*****************************************************************************
4769: a64b: \*****************************************************************************
4770: a64b: \* CREATE.FILE.ERROR:                                                        *
4771: a64b: \*      log event no 106 (IF END error)                                      *
4772: a64b: \*      unique event data includes C + file no                               *
4773: a64b: \*      gosub LOG.AN.EVENT                                                   *
4774: a64b: \*      goto PROGRAM.EXIT                                                    *
4775: a64b: \* RETURN                                                                    *
4776: a64b: \*****************************************************************************
4777: a64b: CREATE.FILE.ERROR:
4778: a65b:        LOG.EVENT.NO% = 106
4779: a672:        LOG.STRING.1.UNIQUE$ = "C" +                                          \
4780: a6e4:                             CHR$(SHIFT(CURRENT.REPORT.NUM%,8)) +             \
4781: a6e4:                             CHR$(SHIFT(CURRENT.REPORT.NUM%,0)) +             \
4782: a6e4:                             PACK$(STRING$(14,"0"))
4783: a6e4:        GOSUB LOG.AN.EVENT
4784: a6f6:        PROGRAM.FAIL = TRUE
4785: a70c:        GOTO PROGRAM.EXIT
4786: a717: RETURN
4787: a727: 
4788: a727: \*****************************************************************************
4789: a727: \*****************************************************************************
4790: a727: \* READ.FILE.ERROR:                                                          *
4791: a727: \*      log event no 106 (IF END error)                                      *
4792: a727: \*      unique event data includes R + file no                               *
4793: a727: \*      gosub LOG.AN.EVENT                                                   *
4794: a727: \*      goto PROGRAM.EXIT                                                    *
4795: a727: \* RETURN                                                                    *
4796: a727: \*****************************************************************************
4797: a727: READ.FILE.ERROR:
4798: a737:        LOG.EVENT.NO% = 106
4799: a74e:        LOG.STRING.1.UNIQUE$ =  FILE.OPERATION$ +                             \
4800: a7c7:                             CHR$(SHIFT(CURRENT.REPORT.NUM%,8)) +             \
4801: a7c7:                             CHR$(SHIFT(CURRENT.REPORT.NUM%,0)) +             \
4802: a7c7:                             PACK$(STRING$(14,"0"))
4803: a7c7:        GOSUB LOG.AN.EVENT
4804: a7d9:        PROGRAM.FAIL = TRUE
4805: a7ef:        GOTO PROGRAM.EXIT
4806: a7fa: RETURN
4807: a80a: 
4808: a80a: \*****************************************************************************
4809: a80a: \*****************************************************************************
4810: a80a: \* WRITE.FILE.ERROR:                                                         *
4811: a80a: \*      log event no 106 (IF END error)                                      *
4812: a80a: \*      unique event data includes W + file no                               *
4813: a80a: \*      gosub LOG.AN.EVENT                                                   *
4814: a80a: \*      goto PROGRAM.EXIT                                                    *
4815: a80a: \* RETURN                                                                    *
4816: a80a: \*****************************************************************************
4817: a80a: WRITE.FILE.ERROR:
4818: a81a:        LOG.EVENT.NO% = 106
4819: a831:        LOG.STRING.1.UNIQUE$ =  FILE.OPERATION$ +                                   \
4820: a8aa:                             CHR$(SHIFT(CURRENT.REPORT.NUM%,8)) +             \
4821: a8aa:                             CHR$(SHIFT(CURRENT.REPORT.NUM%,0)) +             \
4822: a8aa:                             PACK$(STRING$(14,"0"))
4823: a8aa:        GOSUB LOG.AN.EVENT
4824: a8bc:        PROGRAM.FAIL = TRUE
4825: a8d2:        GOTO PROGRAM.EXIT
4826: a8dd: RETURN
4827: a8ed: 
4828: a8ed: \*****************************************************************************
4829: a8ed: \*****************************************************************************
4830: a8ed: \* ALLOCATE.SESSION.NUMBERS:                                                 *
4831: a8ed: \*       gosub CALL.SESS.NUM.UTILITY with function flag = "O" for each       *
4832: a8ed: \*      file used : IDF, SOFTS, BCSMF                                        *
4833: a8ed: \*                      CCLAM, CCITF, CCTRL, CCRSN,                          *
4834: a8ed: \*                      CCSMY, CCDET, CCSTS                                  *
4835: a8ed: \*                                                                           *
4836: a8ed: \* RETURN                                                                    *
4837: a8ed: \*****************************************************************************
4838: a8ed: ALLOCATE.SESSION.NUMBERS:
4839: a8fd: 
4840: a8fd:             F20.FUNCTION$ = "O"
4841: a914: 
4842: a914:         F20.INTEGER% = IDF.REPORT.NUM%
4843: a92a:         F20.STRING$  = IDF.FILE.NAME$
4844: a948:         GOSUB CALL.SESS.NUM.UTILITY
4845: a95a:         IDF.SESS.NUM% = F20.INTEGER.FILE.NO%
4846: a970: 
4847: a970:        F20.INTEGER% = SOFTS.REPORT.NUM%
4848: a986:        F20.STRING$  = SOFTS.FILE.NAME$
4849: a9a4:         GOSUB CALL.SESS.NUM.UTILITY
4850: a9b6:         SOFTS.SESS.NUM% = F20.INTEGER.FILE.NO%
4851: a9cc: 
4852: a9cc:        F20.INTEGER% = BCSMF.REPORT.NUM%
4853: a9e2:        F20.STRING$  = BCSMF.FILE.NAME$
4854: aa00:         GOSUB CALL.SESS.NUM.UTILITY
4855: aa12:         BCSMF.SESS.NUM% = F20.INTEGER.FILE.NO%
4856: aa28: 
4857: aa28:        F20.INTEGER% = CCLAM.REPORT.NUM%
4858: aa3e:        F20.STRING$  = CCLAM.FILE.NAME$
4859: aa5c:         GOSUB CALL.SESS.NUM.UTILITY
4860: aa6e:         CCLAM.SESS.NUM% = F20.INTEGER.FILE.NO%
4861: aa84: 
4862: aa84:        F20.INTEGER% = CCITF.REPORT.NUM%
4863: aa9a:        F20.STRING$  = CCITF.FILE.NAME$
4864: aab8:         GOSUB CALL.SESS.NUM.UTILITY
4865: aaca:         CCITF.SESS.NUM% = F20.INTEGER.FILE.NO%
4866: aae0: 
4867: aae0:        F20.INTEGER% = CCSTS.REPORT.NUM%                                 ! BDCN
4868: aaf6:        F20.STRING$  = CCSTS.FILE.NAME$                                  ! BDCN
4869: ab14:         GOSUB CALL.SESS.NUM.UTILITY                                     ! BDCN
4870: ab26:         CCSTS.SESS.NUM% = F20.INTEGER.FILE.NO%                          ! BDCN
4871: ab3c: 
4872: ab3c:        F20.INTEGER% = CCTRL.REPORT.NUM%
4873: ab52:        F20.STRING$  = CCTRL.FILE.NAME$
4874: ab70:         GOSUB CALL.SESS.NUM.UTILITY
4875: ab82:         CCTRL.SESS.NUM% = F20.INTEGER.FILE.NO%
4876: ab98: 
4877: ab98:        F20.INTEGER% = CCRSN.REPORT.NUM%
4878: abae:        F20.STRING$  = CCRSN.FILE.NAME$
4879: abcc:         GOSUB CALL.SESS.NUM.UTILITY
4880: abde:         CCRSN.SESS.NUM% = F20.INTEGER.FILE.NO%
4881: abf4: 
4882: abf4:        F20.INTEGER% = CCSMY.REPORT.NUM%
4883: ac0a:        F20.STRING$  = CCSMY.FILE.NAME$
4884: ac28:         GOSUB CALL.SESS.NUM.UTILITY
4885: ac3a:         CCSMY.SESS.NUM% = F20.INTEGER.FILE.NO%
4886: ac50: 
4887: ac50:        F20.INTEGER% = CCDET.REPORT.NUM%
4888: ac66:        F20.STRING$  = CCDET.FILE.NAME$
4889: ac84:         GOSUB CALL.SESS.NUM.UTILITY
4890: ac96:         CCDET.SESS.NUM% = F20.INTEGER.FILE.NO%
4891: acac: 
4892: acac: RETURN
4893: acbc: 
4894: acbc: \*****************************************************************************
4895: acbc: \*****************************************************************************
4896: acbc: \* DEALLOCATE.SESSION.NUMBERS                                                *
4897: acbc: \*       gosub CALL.SESS.NUM.UTILITY with function flag = "C" for each       *
4898: acbc: \*      file used : IDF, SPFTS, BCSMF                                        *
4899: acbc: \*                  CCLAM, CCITF, CCTRL, CCRSN,                              *
4900: acbc: \*                  CCSMY, CCDET, CCSTS                                      *
4901: acbc: \*                                                                           *
4902: acbc: \* RETURN                                                                    *
4903: acbc: \*****************************************************************************
4904: acbc: DEALLOCATE.SESSION.NUMBERS:
4905: accc: 
4906: accc:             F20.FUNCTION$ = "C"
4907: ace3: 
4908: ace3:         F20.INTEGER% = IDF.SESS.NUM%
4909: acf9:         GOSUB CALL.SESS.NUM.UTILITY
4910: ad0b: 
4911: ad0b:         F20.INTEGER% = SOFTS.SESS.NUM%
4912: ad21:         GOSUB CALL.SESS.NUM.UTILITY
4913: ad33: 
4914: ad33:         F20.INTEGER% = BCSMF.SESS.NUM%
4915: ad49:         GOSUB CALL.SESS.NUM.UTILITY
4916: ad5b: 
4917: ad5b:         F20.INTEGER% = CCLAM.SESS.NUM%
4918: ad71:         GOSUB CALL.SESS.NUM.UTILITY
4919: ad83: 
4920: ad83:         F20.INTEGER% = CCITF.SESS.NUM%
4921: ad99:         GOSUB CALL.SESS.NUM.UTILITY
4922: adab: 
4923: adab:         F20.INTEGER% = CCTRL.SESS.NUM%
4924: adc1:         GOSUB CALL.SESS.NUM.UTILITY
4925: add3: 
4926: add3:         F20.INTEGER% = CCRSN.SESS.NUM%
4927: ade9:         GOSUB CALL.SESS.NUM.UTILITY
4928: adfb: 
4929: adfb:         F20.INTEGER% = CCSMY.SESS.NUM%
4930: ae11:         GOSUB CALL.SESS.NUM.UTILITY
4931: ae23: 
4932: ae23:         F20.INTEGER% = CCDET.SESS.NUM%
4933: ae39:         GOSUB CALL.SESS.NUM.UTILITY
4934: ae4b: 
4935: ae4b:         F20.INTEGER% = CCSTS.SESS.NUM%                                  ! BDCN
4936: ae61:         GOSUB CALL.SESS.NUM.UTILITY                                     ! BDCN
4937: ae73: RETURN
4938: ae83: 
4939: ae83: \*****************************************************************************
4940: ae83: \*****************************************************************************
4941: ae83: \* CALL.SESS.NUM.UTILITY:                                                    *
4942: ae83: \*       call SESS.NUM.UTILITY                                               *
4943: ae83: \*      If F20.RETURN.CODE <> 0 THEN                                         *
4944: ae83: \*                goto PROGRAM.EXIT                                          *
4945: ae83: \*       endif                                                               *
4946: ae83: \*                                                                           *
4947: ae83: \* RETURN                                                                    *
4948: ae83: \*****************************************************************************
4949: ae83: CALL.SESS.NUM.UTILITY:
4950: ae93:        RC% = SESS.NUM.UTILITY(F20.FUNCTION$,                                 \
4951: aece:                                F20.INTEGER%,                                 \
4952: aece:                                F20.STRING$)
4953: aece:         IF RC% <> 0 THEN BEGIN
4954: aef0:            LOG.EVENT.NO% = 48
4955: af07:            LOG.STRING.1.UNIQUE$ = F20.FUNCTION$ +                            \
4956: af60:                                    RIGHT$("000000000" + STR$(RC%), 9)
4957: af60:            GOSUB LOG.AN.EVENT
4958: af72:            PROGRAM.FAIL = TRUE
4959: af88:             GOTO PROGRAM.EXIT
4960: af93:        ENDIF
4961: af9b: RETURN
4962: afab: 
4963: afab: \*****************************************************************************
4964: afab: \*****************************************************************************
4965: afab: \* DISPLAY.OUTPUT.MESSAGE:                                                   *
4966: afab: \*   if sleeper/background mode display message on background task           *
4967: afab: \*      call adxserve (return code,func=26,unused,message string)            *
4968: afab: \*      if error, log event and exit program                                 *
4969: afab: \*   else                                                                    *
4970: afab: \*      display message on screen (command mode)                             *
4971: afab: \*   endif                                                                   *
4972: afab: \*                                                                           *
4973: afab: \* RETURN                                                                    *
4974: afab: \*****************************************************************************
4975: afab: DISPLAY.OUTPUT.MESSAGE:
4976: afbb:          IF ( (LEFT$(COMMAND$,7) = "SLEEPER")                                \
4977: b045:          OR   (LEFT$(COMMAND$,8) = "BACKGRND") ) THEN BEGIN
4978: b045:                 CALL ADXSERVE (RC%, 26, 0, OUTPUT.MESSAGE$)
4979: b081:                 IF RC% <> 0 THEN BEGIN
4980: b0a3:                      DISPLAY.OUTPUT.ERROR = TRUE
4981: b0b9:                     LOG.EVENT.NO% = 23
4982: b0d0:                     LOG.STRING.1.UNIQUE$ = STR$(RC%)
4983: b0f3:                     GOSUB LOG.AN.EVENT
4984: b105:                   PROGRAM.FAIL = TRUE
4985: b11b:                     GOTO PROGRAM.EXIT
4986: b126:                 ENDIF
4987: b130:          ENDIF ELSE BEGIN
4988: b138:               PRINT OUTPUT.MESSAGE$
4989: b150:          ENDIF
4990: b158: RETURN
4991: b168: 
4992: b168: \*****************************************************************************
4993: b168: \*****************************************************************************
4994: b168: \* LOG.AN.EVENT:                                                             *
4995: b168: \*       Pass details of an event to application log                         *
4996: b168: \*       using 2 parameters - event no. and unique 10 byte data string       *
4997: b168: \*                                                                           *
4998: b168: \* RETURN                                                                    *
4999: b168: \*****************************************************************************
5000: b168: LOG.AN.EVENT:
5001: b178:        LOG.MESSAGE.NO% = 0                       ! set to 0 for batch programs
5002: b18f:        LOG.STRING.2$ = ""                     ! set to null for batch programs
5003: b1a6: 
5004: b1a6:        RC% = APPLICATION.LOG (       LOG.MESSAGE.NO%,                        \
5005: b1f3:                             LOG.STRING.1.UNIQUE$,                            \
5006: b1f3:                             LOG.STRING.2$,                                   \
5007: b1f3:                             LOG.EVENT.NO% )
5008: b1f3:        IF RC% <> 0 THEN BEGIN
5009: b212:               OUTPUT.MESSAGE$ = LOG.FAILED.MESSAGE$
5010: b230:               GOSUB DISPLAY.OUTPUT.MESSAGE
5011: b242:               PROGRAM.FAIL = TRUE
5012: b258:               GOTO PROGRAM.EXIT
5013: b263:        ENDIF
5014: b26b: RETURN
5015: b27b: 
5016: b27b: \*****************************************************************************
5017: b27b: \*****************************************************************************
5018: b27b: \* ERROR.DETECTED:                                                           *
5019: b27b: \*       if already processing an error (ie.error has occured within error   *
5020: b27b: \*       detected) then goto program.exit                                    *
5021: b27b: \*                                                                           *
5022: b27b: \*       call STANDARD.ERROR.DETECTED(ERRN, ERRF%, ERRL, ERR)                *
5023: b27b: \*       goto program.exit                                                   *
5024: b27b: \*****************************************************************************
5025: b27b: ERROR.DETECTED:
5026: b28b:        IF ERROR.PROCESSING.ACTIVE THEN GOTO PROGRAM.EXIT
5027: b2a0: 
5028: b2a0:        RC% = STANDARD.ERROR.DETECTED (ERRN,ERRF%,ERRL,ERR)
5029: b2db:        ERROR.PROCESSING.ACTIVE = TRUE
5030: b2f1:        PROGRAM.FAIL = TRUE
5031: b307:        GOTO PROGRAM.EXIT
5032: b317: 
5033: b317: \*****************************************************************************
5034: b317: \*****************************************************************************
5035: b317: \ End of program                                                             *
5036: b317: \*****************************************************************************
5037: b317: END
5038: b317: End of Compilation
