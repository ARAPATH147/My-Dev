   1: 0000: \********************************************************************
   2: 0000: \********************************************************************
   3: 0000: \***
   4: 0000: \***
   5: 0000: \***            PROGRAM         :       SRP10
   6: 0000: \***            AUTHOR          :       Neil Bennett
   7: 0000: \***            DATE WRITTEN    :       June 2006
   8: 0000: \***
   9: 0000: \***            MODULE          :       SRP10.BAS
  10: 0000: \***
  11: 0000: \***
  12: 0000: \***    VERSION A.          NEIL BENNETT.           02 JUN 2006.
  13: 0000: \***    Initial version.
  14: 0000: \***
  15: 0000: \***    VERSION B.          Charles Skadorwa.       11 DEC 2008.
  16: 0000: \***    No. of records on SRSXF increased from 30,000 to 60,000
  17: 0000: \***    due to increase in Intactix data volumes for large stores
  18: 0000: \***    which caused keyed file insertion errors.
  19: 0000: \***
  20: 0000: \***    Version C.          Ranjith Gopalankutty      15 March 2016  
  21: 0000: \***    INV10004135 - While housekeeping the planner files, current  
  22: 0000: \***    deletion subroutine(POG.DEL) deletes only SRPOG,SRMOD and    
  23: 0000: \***    SRPDF and leaving behind SRSXF. File builds up over time     
  24: 0000: \***    and fails POGOK suite. POG.DEL will be changed to include    
  25: 0000: \***    SRSXF deletion, also existing deletion logic of SRMOD file   
  26: 0000: \***    is outdated which will be changed too. Starting 2015,        
  27: 0000: \***    refresh of planner has increased, so need to increase the    
  28: 0000: \***    file capacity of SRPOG,SRMOD,SRPDF and SRSXF to double of    
  29: 0000: \***    its current size                                             
  30: 0000: \***
  31: 0000: \***    Version D.          Ranjith Gopalankutty      30 June 2016   
  32: 0000: \***    Post 16A Desk started receiving failures whenever a POGIL    
  33: 0000: \***    is attempted for planner refresh. Its found that its due to  
  34: 0000: \***    change done as part of increasing the file size.the earlier  
  35: 0000: \***    commented line was ending with '\' and the new line started  
  36: 0000: \***    immediately after that. Which compiler taking as commented   
  37: 0000: \***    line too and failing while creating new file. Fixed that.    
  38: 0000: \********************************************************************
  39: 0000: \********************************************************************
  40: 0000: 
  41: 0000: \********************************************************************
  42: 0000: \********************************************************************
  43: 0000: \***
  44: 0000: \***    Module Overview
  45: 0000: \***    ---------------
  46: 0000: \***
  47: 0000: \***    This ADCS initiated program takes the Intactix Space and
  48: 0000: \***    Range store data and applies it to the in store POG and
  49: 0000: \***    module keyed files.
  50: 0000: \***
  51: 0000: \********************************************************************
  52: 0000: \********************************************************************
  53: 0000: 
  54: 0000: \********************************************************************
  55: 0000: \***
  56: 0000: \***    Function globals
  57: 0000: \***
  58: 0000: \********************************************************************
  59: 0000: 
  60: 0000: %INCLUDE PSBF01G.J86    !APPLICATION LOG
  61: 0000: REM \
  62: 0000: \*******************************************************************************
  63: 0000: \*******************************************************************************
  64: 0000: \***
  65: 0000: \***       %INCLUDE FOR GLOBAL DEFINITIONS FOR FUNCTION APPLICATION.LOG
  66: 0000: \***
  67: 0000: \***                FUNCTION NUMBER    : PSBF01
  68: 0000: \***
  69: 0000: \***                REFERENCE          : PSBF01G.J86
  70: 0000: \***
  71: 0000: \***                DATE OF LAST AMENDMENT  - 27/2/86
  72: 0000: \***
  73: 0000: \***
  74: 0000: \*******************************************************************************
  75: 0000: 
  76: 0000:       INTEGER GLOBAL  F01.RETURN.CODE%
  77: 0000: 
  78: 0000: 
  79: 0000: %INCLUDE PSBF20G.J86    !SESSION NUMBER UTILITY
  80: 0000: REM\
  81: 0000: \*******************************************************************************
  82: 0000: \*******************************************************************************
  83: 0000: \***
  84: 0000: \***     %INCLUDE GLOBAL VARIABLE DEFINITIONS FOR SESS.NUM.UTILITY FUNCTION
  85: 0000: \***
  86: 0000: \***                       REFERENCE     : PSBF20G.J86
  87: 0000: \*** 
  88: 0000: \***     Version A              Bruce Scrive                   5th May 1988   
  89: 0000: \*** 
  90: 0000: \***     Version B              Robert Cowey                   7th May 1991
  91: 0000: \***     Global variable F20.INTEGER.FILE.NO% changed from one byte integer
  92: 0000: \***     to two byte integer.
  93: 0000: \***
  94: 0000: \***     Version D              Andrew Wedgeworth             1st July 1992
  95: 0000: \***     F20.RETURN.CODE% removed as it is no longer required.
  96: 0000: \***
  97: 0000: \*******************************************************************************
  98: 0000: \*******************************************************************************
  99: 0000: 
 100: 0000:       STRING    GLOBAL F20.FILE.NAME$,                                 \
 101: 0000:                        F20.STRING.FILE.NO$,                            \
 102: 0000:                        F20.TABLE.DIMENSIONED.FLAG$,                    \
 103: 0000:                        SESS.NUM.TABLE$(1)
 104: 0000: 
 105: 0000:       INTEGER*2 GLOBAL F20.INTEGER.FILE.NO%
 106: 0000: 
 107: 0000:       ! 1 line deleted from here                                       ! DAW 
 108: 0000: 
 109: 0000: %INCLUDE POGDEDEC.J86
 110: 0000: \********************************************************************
 111: 0000: \***      EXTERNAL FUNCTION DECLARATIONS FOR THE POGDE FILE
 112: 0000: \***      REFERENCE : POGOKDEC.J86
 113: 0000: \***      Version A           Neil Bennett            6th June 2006
 114: 0000: \***
 115: 0000: \********************************************************************
 116: 0000: 
 117: 0000:   INTEGER*2 GLOBAL                \
 118: 0000:     POGDE.SESS.NUM%,              \
 119: 0000:     POGDE.REPORT.NUM%             !
 120: 0000: 
 121: 0000:   STRING GLOBAL                   \
 122: 0000:     POGDE.COPY.NAME$,             \
 123: 0000:     POGDE.FILE.NAME$,             \
 124: 0000:     POGDE.RCD$                    !
 125: 0000: %INCLUDE POGOKDEC.J86
 126: 0000: \********************************************************************
 127: 0000: \***      EXTERNAL FUNCTION DECLARATIONS FOR THE POGOK FILE
 128: 0000: \***      REFERENCE : POGOKDEC.J86
 129: 0000: \***      Version A           Neil Bennett            6th June 2006
 130: 0000: \***
 131: 0000: \********************************************************************
 132: 0000: 
 133: 0000:   INTEGER*1 GLOBAL                \
 134: 0000:     POGOK.PE10.RETCODE%,          \
 135: 0000:     POGOK.PE5.RETCODE%,           \
 136: 0000:     POGOK.PE6.RETCODE%,           \
 137: 0000:     POGOK.PE7.RETCODE%,           \
 138: 0000:     POGOK.PE4.RETCODE%,           \
 139: 0000:     POGOK.PE19.RETCODE%           !
 140: 0000: 
 141: 0000:   INTEGER*2 GLOBAL                \
 142: 0000:     POGOK.DAYS.TO.RETAIN%,        \
 143: 0000:     POGOK.SESS.NUM%,              \
 144: 0000:     POGOK.REPORT.NUM%,            \
 145: 0000:     POGOK.RECL%                   !
 146: 0000: 
 147: 0000:   INTEGER*4 GLOBAL                \
 148: 0000:     POGOK.SRD.REC.COUNT%,         \
 149: 0000:     POGOK.SRM.REC.COUNT%
 150: 0000: 
 151: 0000:   STRING GLOBAL                   \
 152: 0000:     POGOK.FILE.NAME$,             \
 153: 0000:     POGOK.SRD.SER.NO$,            \
 154: 0000:     POGOK.SRM.SER.NO$,            \
 155: 0000:     POGOK.SRD.DATE$,              \
 156: 0000:     POGOK.SRM.DATE$,              \
 157: 0000:     POGOK.RELOAD$,                \
 158: 0000:     POGOK.PE10.RUNFLAG$,          \
 159: 0000:     POGOK.PE5.RUNFLAG$,           \
 160: 0000:     POGOK.PE6.RUNFLAG$,           \
 161: 0000:     POGOK.PE7.RUNFLAG$,           \
 162: 0000:     POGOK.PE4.RUNFLAG$,           \
 163: 0000:     POGOK.FAILED.SRD.SER.NO$,     \
 164: 0000:     POGOK.FAILED.SRD.DATE$,       \
 165: 0000:     POGOK.FAILED.SRM.SER.NO$,     \
 166: 0000:     POGOK.FAILED.SRM.DATE$,       \
 167: 0000:     POGOK.PE10.RUNDATE$,          \
 168: 0000:     POGOK.PE5.RUNDATE$,           \
 169: 0000:     POGOK.PE6.RUNDATE$,           \
 170: 0000:     POGOK.PE7.RUNDATE$,           \
 171: 0000:     POGOK.PE4.RUNDATE$,           \
 172: 0000:     POGOK.PE19.RUNFLAG$,          \
 173: 0000:     POGOK.PE19.RUNDATE$,          \
 174: 0000:     POGOK.FILLER$                 !
 175: 0000: %INCLUDE SRPDFDEC.J86
 176: 0000: \********************************************************************
 177: 0000: \***      EXTERNAL FUNCTION DECLARATIONS FOR THE SRPDF FILE
 178: 0000: \***      REFERENCE : SRPDFDEC.J86
 179: 0000: \***      Version A           Neil Bennett          7th August 2006
 180: 0000: \***
 181: 0000: \********************************************************************
 182: 0000: 
 183: 0000:   INTEGER*2 GLOBAL        \
 184: 0000:     SRPDF.SESS.NUM%,      \
 185: 0000:     SRPDF.REPORT.NUM%,    \
 186: 0000:     SRPDF.RECL%           !
 187: 0000: 
 188: 0000:   INTEGER*4 GLOBAL        \
 189: 0000:     SRPDF.POGDB%          ! Unique POG Database key
 190: 0000: 
 191: 0000:   STRING GLOBAL           \
 192: 0000:     SRPDF.FILE.NAME$,     \ File name
 193: 0000:     SRPDF.SHRT.DESC$,     \ Medium descriptor (50)
 194: 0000:     SRPDF.FULL.DESC$,     \ Full descriptor (100)
 195: 0000:     SRPDF.FILLER$         !
 196: 0000: 
 197: 0000: 
 198: 0000: %INCLUDE SRPOGDEC.J86
 199: 0000: \********************************************************************
 200: 0000: \***      EXTERNAL FUNCTION DECLARATIONS FOR THE SRPOG FILE
 201: 0000: \***      REFERENCE : SRPOGDEC.J86
 202: 0000: \***      Version A           Neil Bennett            5th June 2006
 203: 0000: \***
 204: 0000: \********************************************************************
 205: 0000: 
 206: 0000:   INTEGER*1 GLOBAL        \
 207: 0000:     SRPOG.MODULE.COUNT%,  \ Number of modules comprising POG
 208: 0000:     SRPOG.KEY.LEVEL%,     \ Family hierarchy key level
 209: 0000:     SRPOG.LIVE.RPT.CNT%,  \ Computed Live repeat count (Unset -1)
 210: 0000:     SRPOG.PEND.RPT.CNT%   ! Computed pending repeat count (Unset -1)
 211: 0000: 
 212: 0000:   INTEGER*2 GLOBAL        \
 213: 0000:     SRPOG.SESS.NUM%,      \
 214: 0000:     SRPOG.REPORT.NUM%,    \
 215: 0000:     SRPOG.RECL%           !
 216: 0000: 
 217: 0000:   INTEGER*4 GLOBAL        \
 218: 0000:     SRPOG.POGDB%,         \ Unique POG Database key
 219: 0000:     SRPOG.CAT.DBKEY%,     \ Family hierarchy key
 220: 0000:     SRPOG.CAT1.ID%,       \ hierarchy key
 221: 0000:     SRPOG.CAT2.ID%,       \ hierarchy key
 222: 0000:     SRPOG.CAT3.ID%,       \ hierarchy key
 223: 0000:     SRPOG.POGID%          ! POG Identifier
 224: 0000: 
 225: 0000:   STRING GLOBAL           \
 226: 0000:     SRPOG.FILE.NAME$,     \ File name
 227: 0000:     SRPOG.COPY.NAME$,     \ File name
 228: 0000:     SRPOG.ACT.DATE$,      \ Activation Date YYYY MM DD
 229: 0000:     SRPOG.DEACT.DATE$,    \ Deactivation Date YYYY MM DD
 230: 0000:     SRPOG.DESCRIPTION$,   \ Truncated POG description (30)
 231: 0000:     SRPOG.PLANNER.FAMILY$,\ Truncated Planner Family description (30)
 232: 0000:     SRPOG.DATE.RPT.CNT$,  \ Date repeat count is valid YYYY MM DD
 233: 0000:     SRPOG.FILLER$         !
 234: 0000: 
 235: 0000: 
 236: 0000: %INCLUDE SRMODDEC.J86
 237: 0000: \********************************************************************
 238: 0000: \***      EXTERNAL FUNCTION DECLARATIONS FOR THE SRMOD FILE
 239: 0000: \***      REFERENCE : SRMODDEC.J86
 240: 0000: \***      Version A           Neil Bennett            5th June 2006
 241: 0000: \***
 242: 0000: \********************************************************************
 243: 0000: 
 244: 0000:   INTEGER*1 GLOBAL             \
 245: 0000:     SRMOD.FACINGS%(1),         \
 246: 0000:     SRMOD.MODULE.SEQ%,         \
 247: 0000:     SRMOD.RECORD.CHAIN%,       \
 248: 0000:     SRMOD.SHELF.NUM%(1)
 249: 0000: 
 250: 0000:   INTEGER*2 GLOBAL             \
 251: 0000:     SRMOD.ITEM.COUNT%,         \
 252: 0000:     SRMOD.MAX.ITEMS%,          \
 253: 0000:     SRMOD.MDQ%(1),             \
 254: 0000:     SRMOD.PSC%(1),             \
 255: 0000:     SRMOD.RECL%,               \
 256: 0000:     SRMOD.REPORT.NUM%,         \
 257: 0000:     SRMOD.SHELF.COUNT%,        \
 258: 0000:     SRMOD.SESS.NUM%
 259: 0000: 
 260: 0000:   INTEGER*4 GLOBAL             \
 261: 0000:     SRMOD.POGDB%
 262: 0000: 
 263: 0000:   STRING GLOBAL                \
 264: 0000:     SRMOD.ARRAY$,              \
 265: 0000:     SRMOD.COPY.NAME$,          \
 266: 0000:     SRMOD.DESCRIPTOR$,         \
 267: 0000:     SRMOD.FILE.NAME$,          \
 268: 0000:     SRMOD.ITEM.CODE$(1),       \
 269: 0000:     SRMOD.FILLER$
 270: 0000: %INCLUDE SRSXFDEC.J86
 271: 0000: \********************************************************************
 272: 0000: \***      EXTERNAL FUNCTION DECLARATIONS FOR THE SRSXF FILE
 273: 0000: \***      REFERENCE : SRSXFDEC.J86
 274: 0000: \***      Version A           Neil Bennett          7th August 2006
 275: 0000: \***
 276: 0000: \********************************************************************
 277: 0000: 
 278: 0000:   INTEGER*1 GLOBAL        \
 279: 0000:     SRSXF.MODULE.SEQ%,    \
 280: 0000:     SRSXF.SHELF.NO%,      \
 281: 0000:     SRSXF.NOTCH.NO%       !
 282: 0000: 
 283: 0000:   INTEGER*2 GLOBAL        \
 284: 0000:     SRSXF.SESS.NUM%,      \
 285: 0000:     SRSXF.REPORT.NUM%,    \
 286: 0000:     SRSXF.RECL%           !
 287: 0000: 
 288: 0000:   INTEGER*4 GLOBAL        \
 289: 0000:     SRSXF.POGDB%,         \
 290: 0000:     SRSXF.SHELF.KEY%      !
 291: 0000: 
 292: 0000:   STRING GLOBAL           \
 293: 0000:     SRSXF.FILE.NAME$,     \ File name
 294: 0000:     SRSXF.SHELF.DESC$,    \
 295: 0000:     SRSXF.FILLER$         !
 296: 0000: 
 297: 0000: 
 298: 0000: 
 299: 0000: \********************************************************************
 300: 0000: \***
 301: 0000: \***    SRP10 variables
 302: 0000: \***
 303: 0000: \********************************************************************
 304: 0000: 
 305: 0000:    STRING    GLOBAL CURRENT.CODE$
 306: 0000:    INTEGER*2 GLOBAL CURRENT.REPORT.NUM%
 307: 0000:    STRING    GLOBAL FILE.OPERATION$
 308: 0000:    STRING    GLOBAL SB.ACTION$
 309: 0000:    STRING    GLOBAL SB.FILE.NAME$
 310: 0000:    INTEGER*2 GLOBAL SB.INTEGER%
 311: 0000:    INTEGER*2 GLOBAL SB.FILE.REP.NUM%
 312: 0000:    INTEGER*2 GLOBAL SB.FILE.SESS.NUM%
 313: 0000:    STRING    GLOBAL SB.STRING$
 314: 0000: 
 315: 0000:    INTEGER*2 ARRAY.COUNT%                                               ! CRG
 316: 0000:    INTEGER*1 bg%
 317: 0000:    INTEGER*1 CHAIN.COUNT%                                               ! CRG
 318: 0000:    STRING    comm.tail$
 319: 0000:    INTEGER*1 eof%
 320: 0000:    STRING    err.cd$
 321: 0000:    INTEGER*2 event.no%
 322: 0000:    STRING    file$
 323: 0000:    STRING    file.no$
 324: 0000:    INTEGER*1 run.suite%
 325: 0000:    INTEGER*1 init.fail%
 326: 0000:    INTEGER*1 init.load%
 327: 0000:    INTEGER*2 it.ptr%
 328: 0000:    INTEGER*2 item.cnt%
 329: 0000:    INTEGER*1 last.notch%
 330: 0000:    INTEGER*1 last.shelf%
 331: 0000:    STRING    mess$
 332: 0000:    INTEGER*2 message.no%
 333: 0000:    INTEGER*1 mod.cnt%
 334: 0000:    INTEGER*1 no.file%
 335: 0000:    INTEGER*1 no.inp.file%
 336: 0000:    INTEGER*1 no.mod.file%
 337: 0000:    INTEGER*1 no.pog.file%
 338: 0000:    INTEGER*1 no.read%
 339: 0000:    STRING    parm$
 340: 0000:    STRING    POGDE.DATE$
 341: 0000:    INTEGER*2 POGDE.DTR%
 342: 0000:    INTEGER*4 POGDE.SER.NO%
 343: 0000:    INTEGER*2 rc%
 344: 0000:    INTEGER*4 rc4%
 345: 0000:    INTEGER*4 rec.cnt%
 346: 0000:    STRING    rectyp$
 347: 0000:    STRING    rundate$
 348: 0000:    INTEGER*2 shelf.cnt%
 349: 0000:    INTEGER*1 srmod.chg%
 350: 0000:    INTEGER*2 shelf.item.seq%
 351: 0000:    INTEGER*2 sit.cnt%
 352: 0000:    INTEGER*1 SRMOD.COUNT.LIMIT%                                         ! CRG
 353: 0000:    INTEGER*1 srp10.error%
 354: 0000:    INTEGER*1 srp10.event%
 355: 0000:    INTEGER*1 tlr.read%
 356: 0000:    INTEGER*4 tlr.cnt%
 357: 0000:    STRING    text$
 358: 0000:    STRING    var.string.1$
 359: 0000:    STRING    var.string.2$
 360: 0000:    STRING    work$
 361: 0000: 
 362: 0000: \********************************************************************
 363: 0000: \***
 364: 0000: \***    External functions
 365: 0000: \***
 366: 0000: \********************************************************************
 367: 0000: 
 368: 0000: %INCLUDE ADXSERVE.J86   !Controller Services
 369: 0000: \******************************************************************************
 370: 0000: \******************************************************************************
 371: 0000: \***                                                                        ***
 372: 0000: \***    %INCLUDE FOR FUNCTION ADXSERVE (an I.B.M. system function)          ***
 373: 0000: \***                                                                        ***
 374: 0000: \***         AUTHOR        :  Bruce Scriver                                 ***
 375: 0000: \***                                                                        ***
 376: 0000: \***         DATE WRITTEN  :  14th March 1986                               ***
 377: 0000: \***                                                                        ***
 378: 0000: \***         DATE OF LAST REVISION  - 14th March 1986                       ***
 379: 0000: \***                                                                        ***
 380: 0000: \***                                                                        ***
 381: 0000: \******************************************************************************
 382: 0000: \******************************************************************************
 383: 0000: 
 384: 0000:    SUB ADXSERVE (RETURN.CODE%,                                                \
 385: 0000:                  ADX.FUNCTION%,                                               \
 386: 0000:                  ADX.PARM.1%,                                                 \
 387: 0000:                  ADX.PARM.2$)                                                 \
 388: 0000:    EXTERNAL
 389: 0000:   
 390: 0000:       STRING     ADX.PARM.2$
 391: 0000: 
 392: 0000:       INTEGER*2  ADX.FUNCTION%,                                               \
 393: 0000:                  ADX.PARM.1%
 394: 0000: 
 395: 0000:       INTEGER*4  RETURN.CODE%                                                 \
 396: 0000: 
 397: 0000:    END SUB     
 398: 0000: 
 399: 0000: %INCLUDE PSBF01E.J86    !APPLICATION LOG
 400: 0000: REM \
 401: 0000: \*******************************************************************************
 402: 0000: \*******************************************************************************
 403: 0000: \***
 404: 0000: \***      %INCLUDE FOR EXTERNAL DEFINITION OF FUNCTION APPLICATION.LOG
 405: 0000: \***
 406: 0000: \***                      FUNCTION NUMBER   : PSBF01
 407: 0000: \***
 408: 0000: \***                    INCLUDE REFERENCE : PSBF01E.J86
 409: 0000: \*** 
 410: 0000: \***      Version B           Andrew Wedgeworth          1st July 1992
 411: 0000: \***      Three parameters which passed to the function have been removed.
 412: 0000: \***      APPLICATION.LOG has been added as a variable name (this holds the
 413: 0000: \***      return code).
 414: 0000: \***
 415: 0000: \*******************************************************************************
 416: 0000: 
 417: 0000: 
 418: 0000:    FUNCTION APPLICATION.LOG (MESSAGE.NO%,                                     \
 419: 0000:                              VAR.STRING.1$,                                   \
 420: 0000:                              VAR.STRING.2$,                                   \
 421: 0000:                              EVENT.NO%)  EXTERNAL
 422: 0000: 
 423: 0000:       INTEGER*1 EVENT.NO%
 424: 0000: 
 425: 0000:       INTEGER*2 APPLICATION.LOG,                                       \ GAW
 426: 0000:                 MESSAGE.NO%
 427: 0000: 
 428: 0000:       STRING VAR.STRING.1$,                                            \
 429: 0000:              VAR.STRING.2$
 430: 0000: 
 431: 0000:    END FUNCTION
 432: 0000: 
 433: 0000: \*******************************************************************************
 434: 0000: %INCLUDE PSBF20E.J86    !SESSION NUMBER UTILITY
 435: 0000: REM\
 436: 0000: \*******************************************************************************
 437: 0000: \*******************************************************************************
 438: 0000: \***
 439: 0000: \***       %INCLUDE FOR EXTERNAL DEFINITION OF SESS.NUM.UTILITY
 440: 0000: \***
 441: 0000: \***                  REFERENCE     : PSBF20E.J86
 442: 0000: \***
 443: 0000: \***     VERSION C            Janet Smith                13th May 1992
 444: 0000: \***     Increased PASSED.INTEGER to 2 bytes to cater for more than
 445: 0000: \***     128 files.
 446: 0000: \***
 447: 0000: \***     VERSION D.           Andrew Wedgeworth          1st July 1992
 448: 0000: \***     Removal of redundant parameters and addition of SESS.NUM.UTILITY
 449: 0000: \***     as a variable.  This new variable contains the function's return
 450: 0000: \***     code.
 451: 0000: \***
 452: 0000: \*******************************************************************************
 453: 0000: \*******************************************************************************
 454: 0000: 
 455: 0000:    FUNCTION SESS.NUM.UTILITY (FUNCTION.FLAG$,                          \
 456: 0000:                               PASSED.INTEGER%,                         \
 457: 0000:                               PASSED.STRING$)                          \
 458: 0000:    EXTERNAL
 459: 0000: 
 460: 0000:    STRING    FUNCTION.FLAG$,                                           \
 461: 0000:              PASSED.STRING$
 462: 0000:    ! 3 variables removed from here                                     ! CAW
 463: 0000: 
 464: 0000: 
 465: 0000:    INTEGER*2 SESS.NUM.UTILITY,                                         \ CAW
 466: 0000:              PASSED.INTEGER%				               ! CJAS
 467: 0000: 
 468: 0000:    END FUNCTION
 469: 0000: 
 470: 0000: %INCLUDE PSBF24E.J86    !STANDARD ERROR DETECTED
 471: 0000: REM \
 472: 0000: \*******************************************************************************
 473: 0000: \*******************************************************************************
 474: 0000: \***
 475: 0000: \***    %INCLUDE FOR EXTERNAL DEFINITION OF STANDARD.ERROR.DETECTED FUNCTION
 476: 0000: \***
 477: 0000: \***                      REFERENCE     : PSBF24E.J86
 478: 0000: \***
 479: 0000: \***    Version A                 Janet Smith                  13th May 1992
 480: 0000: \***
 481: 0000: \*******************************************************************************
 482: 0000: \*******************************************************************************
 483: 0000: 
 484: 0000:    FUNCTION STANDARD.ERROR.DETECTED(ERRN%,                 \
 485: 0000: 				    ERRFILE%,              \
 486: 0000: 				    ERRL%,                 \
 487: 0000: 				    ERR$)        EXTERNAL
 488: 0000: 				    
 489: 0000:           STRING    ERR$
 490: 0000: 
 491: 0000:           INTEGER*2 ERRFILE%,              \
 492: 0000: 	            ERRL%,                 \
 493: 0000: 		    STANDARD.ERROR.DETECTED
 494: 0000: 		    
 495: 0000:           INTEGER*4 ERRN%
 496: 0000: 	  		    
 497: 0000:    END FUNCTION
 498: 0000: 
 499: 0000: 
 500: 0000: 
 501: 0000: %INCLUDE BTCMEM.J86
 502: 0000: !********************************************************************
 503: 0000: !***
 504: 0000: !***    INCLUDED CODE:  BTCMEM.J86
 505: 0000: !***    AUTHOR:         Stuart William McConnachie
 506: 0000: !***    DATE:           26th February 2006
 507: 0000: !***
 508: 0000: !********************************************************************
 509: 0000: !***
 510: 0000: !***    Controller CBASIC Memory Functions
 511: 0000: !***
 512: 0000: !********************************************************************
 513: 0000: 
 514: 0000: !Get a single byte integer from a string offset
 515: 0000: FUNCTION GETN1 (S$, P%) EXTERNAL
 516: 0000:     STRING S$
 517: 0000:     INTEGER*2 P%
 518: 0000:     INTEGER*2 GETN1
 519: 0000: END FUNCTION
 520: 0000: 
 521: 0000: !Get a two byte integer from a string offset
 522: 0000: FUNCTION GETN2 (S$, P%) EXTERNAL
 523: 0000:     STRING S$
 524: 0000:     INTEGER*2 P%
 525: 0000:     INTEGER*2 GETN2
 526: 0000: END FUNCTION
 527: 0000: 
 528: 0000: !Get a four byte integer from a string offset
 529: 0000: FUNCTION GETN4 (S$, P%) EXTERNAL
 530: 0000:     STRING S$
 531: 0000:     INTEGER*2 P%
 532: 0000:     INTEGER*4 GETN4
 533: 0000: END FUNCTION
 534: 0000: 
 535: 0000: !Get a 10 byte CBASIC real from a string offset
 536: 0000: FUNCTION GETR10 (S$, P%) EXTERNAL
 537: 0000:     STRING S$
 538: 0000:     INTEGER*2 P%
 539: 0000:     REAL GETR10
 540: 0000: END FUNCTION
 541: 0000: 
 542: 0000: !Put a single byte integer into a string at offset
 543: 0000: FUNCTION PUTN1 (S$, P%, N%) EXTERNAL
 544: 0000:     STRING S$
 545: 0000:     INTEGER*2 P%
 546: 0000:     INTEGER*1 N%
 547: 0000:     INTEGER*1 PUTN1
 548: 0000: END FUNCTION
 549: 0000: 
 550: 0000: !Put a two byte integer into a string at offset
 551: 0000: FUNCTION PUTN2 (S$, P%, N%) EXTERNAL
 552: 0000:     STRING S$
 553: 0000:     INTEGER*2 P%
 554: 0000:     INTEGER*2 N%
 555: 0000:     INTEGER*1 PUTN2
 556: 0000: END FUNCTION
 557: 0000: 
 558: 0000: !Put a four byte integer into a string at offset
 559: 0000: FUNCTION PUTN4 (S$, P%, N%) EXTERNAL
 560: 0000:     STRING S$
 561: 0000:     INTEGER*2 P%
 562: 0000:     INTEGER*4 N%
 563: 0000:     INTEGER*1 PUTN4
 564: 0000: END FUNCTION
 565: 0000: 
 566: 0000: !Put a 10 byte CBASIC real into a string at offset
 567: 0000: FUNCTION PUTR10 (S$, P%, R) EXTERNAL
 568: 0000:     STRING S$
 569: 0000:     INTEGER*2 P%
 570: 0000:     REAL R
 571: 0000:     INTEGER*1 PUTR10
 572: 0000: END FUNCTION
 573: 0000: 
 574: 0000: !Peek a two byte integer from a memory address
 575: 0000: FUNCTION PEEKN2 (A%) EXTERNAL
 576: 0000:     INTEGER*4 A%
 577: 0000:     INTEGER*2 PEEKN2
 578: 0000: END FUNCTION
 579: 0000: 
 580: 0000: !Peek a four byte integer from a memory address
 581: 0000: FUNCTION PEEKN4 (A%) EXTERNAL
 582: 0000:     INTEGER*4 A%
 583: 0000:     INTEGER*4 PEEKN4
 584: 0000: END FUNCTION
 585: 0000: 
 586: 0000: !Peek a 10 byte CBASIC real from a memory address
 587: 0000: FUNCTION PEEKR10 (A%) EXTERNAL
 588: 0000:     INTEGER*4 A%
 589: 0000:     REAL PEEKR10
 590: 0000: END FUNCTION
 591: 0000: 
 592: 0000: !Poke a two byte integer to a memory address
 593: 0000: FUNCTION POKEN2 (A%, N%) EXTERNAL
 594: 0000:     INTEGER*4 A%
 595: 0000:     INTEGER*2 N%
 596: 0000:     INTEGER*1 POKEN2
 597: 0000: END FUNCTION
 598: 0000: 
 599: 0000: !Poke a four byte integer to a memory address
 600: 0000: FUNCTION POKEN4 (A%, N%) EXTERNAL
 601: 0000:     INTEGER*4 A%
 602: 0000:     INTEGER*4 N%
 603: 0000:     INTEGER*1 POKEN4
 604: 0000: END FUNCTION
 605: 0000: 
 606: 0000: !Poke a 10 byte CBASIC real to a memory address
 607: 0000: FUNCTION POKER10 (A%, R) EXTERNAL
 608: 0000:     INTEGER*4 A%
 609: 0000:     REAL R
 610: 0000:     INTEGER*1 POKER10
 611: 0000: END FUNCTION
 612: 0000: 
 613: 0000: %INCLUDE SRPEXT.J86
 614: 0000: \********************************************************************
 615: 0000: \***      Space and Range Planner Common Functions  (SRPFUN)
 616: 0000: \***      Version A           Neil Bennett          24.08.2006
 617: 0000: \***
 618: 0000: \....................................................................
 619: 0000: \***
 620: 0000: \***    GET.CATID Construct a 4 byte integer Category ID from 3
 621: 0000: \***              hierarchical (I4) keys supplied.
 622: 0000: \***
 623: 0000: \********************************************************************
 624: 0000: 
 625: 0000:    FUNCTION GET.CATID%(lev1%,lev2%,lev3%) EXTERNAL
 626: 0000: 
 627: 0000:     INTEGER*4 GET.CATID%
 628: 0000:     INTEGER*4 lev1%, lev2%, lev3%
 629: 0000: 
 630: 0000:    END FUNCTION
 631: 0000: 
 632: 0000: \********************************************************************
 633: 0000: %INCLUDE POGDEEXT.J86
 634: 0000: \********************************************************************
 635: 0000: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE POGDE FILE
 636: 0000: \***      REFERENCE : POGDEEXT.J86
 637: 0000: \***      Version A           Neil Bennett            8th June 2006
 638: 0000: \***
 639: 0000: \********************************************************************
 640: 0000: 
 641: 0000:        FUNCTION POGDE.SET EXTERNAL
 642: 0000:        END FUNCTION
 643: 0000: 
 644: 0000:        FUNCTION READ.POGDE EXTERNAL
 645: 0000:           INTEGER*2 READ.POGDE
 646: 0000:        END FUNCTION
 647: 0000: %INCLUDE POGOKEXT.J86
 648: 0000: \********************************************************************
 649: 0000: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE POGOK FILE
 650: 0000: \***      REFERENCE : POGOKEXT.J86
 651: 0000: \***      Version A           Neil Bennett            6th June 2006
 652: 0000: \***
 653: 0000: \********************************************************************
 654: 0000: 
 655: 0000:        FUNCTION POGOK.SET EXTERNAL
 656: 0000:        END FUNCTION
 657: 0000: 
 658: 0000:        FUNCTION READ.POGOK EXTERNAL
 659: 0000:           INTEGER*2 READ.POGOK
 660: 0000:        END FUNCTION
 661: 0000: 
 662: 0000:        FUNCTION READ.POGOK.LOCK EXTERNAL
 663: 0000:           INTEGER*2 READ.POGOK.LOCK
 664: 0000:        END FUNCTION
 665: 0000: 
 666: 0000:        FUNCTION WRITE.POGOK EXTERNAL
 667: 0000:           INTEGER*2 WRITE.POGOK
 668: 0000:        END FUNCTION
 669: 0000: 
 670: 0000:        FUNCTION WRITE.POGOK.UNLOCK EXTERNAL
 671: 0000:           INTEGER*2 WRITE.POGOK.UNLOCK
 672: 0000:        END FUNCTION
 673: 0000: 
 674: 0000:        FUNCTION CREATE.POGOK EXTERNAL
 675: 0000:           INTEGER*2 CREATE.POGOK
 676: 0000:        END FUNCTION
 677: 0000: %INCLUDE SRPDFEXT.J86
 678: 0000: \********************************************************************
 679: 0000: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE SRPDF FILE
 680: 0000: \***      REFERENCE : SRPDFEXT.J86
 681: 0000: \***      Version A           Neil Bennett          7th August 2006
 682: 0000: \***
 683: 0000: \********************************************************************
 684: 0000: 
 685: 0000:        FUNCTION SRPDF.SET EXTERNAL
 686: 0000:        END FUNCTION
 687: 0000: 
 688: 0000:        FUNCTION READ.SRPDF EXTERNAL
 689: 0000:           INTEGER*2 READ.SRPDF
 690: 0000:        END FUNCTION
 691: 0000: 
 692: 0000:        FUNCTION WRITE.SRPDF EXTERNAL
 693: 0000:           INTEGER*2 WRITE.SRPDF
 694: 0000:        END FUNCTION
 695: 0000: 
 696: 0000:        FUNCTION DELREC.SRPDF EXTERNAL
 697: 0000:           INTEGER*2 DELREC.SRPDF
 698: 0000:        END FUNCTION
 699: 0000: %INCLUDE SRPOGEXT.J86
 700: 0000: \********************************************************************
 701: 0000: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE SRPOG FILE
 702: 0000: \***      REFERENCE : SRPOGEXT.J86
 703: 0000: \***      Version A           Neil Bennett            5th June 2006
 704: 0000: \***
 705: 0000: \********************************************************************
 706: 0000: 
 707: 0000:        FUNCTION SRPOG.SET EXTERNAL
 708: 0000:        END FUNCTION
 709: 0000: 
 710: 0000:        FUNCTION READ.SRPOG EXTERNAL
 711: 0000:           INTEGER*2 READ.SRPOG
 712: 0000:        END FUNCTION
 713: 0000: 
 714: 0000:        FUNCTION WRITE.SRPOG EXTERNAL
 715: 0000:           INTEGER*2 WRITE.SRPOG
 716: 0000:        END FUNCTION
 717: 0000: 
 718: 0000:        FUNCTION DELREC.SRPOG EXTERNAL
 719: 0000:           INTEGER*2 DELREC.SRPOG
 720: 0000:        END FUNCTION
 721: 0000: %INCLUDE SRMODEXT.J86
 722: 0000: \********************************************************************
 723: 0000: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE SRMOD FILE
 724: 0000: \***      REFERENCE : SRMODEXT.J86
 725: 0000: \***      Version A           Neil Bennett            5th June 2006
 726: 0000: \***
 727: 0000: \********************************************************************
 728: 0000: 
 729: 0000:        FUNCTION SRMOD.SET EXTERNAL
 730: 0000:        END FUNCTION
 731: 0000: 
 732: 0000:        FUNCTION READ.SRMOD EXTERNAL
 733: 0000:           INTEGER*2 READ.SRMOD
 734: 0000:        END FUNCTION
 735: 0000: 
 736: 0000:        FUNCTION WRITE.SRMOD EXTERNAL
 737: 0000:           INTEGER*2 WRITE.SRMOD
 738: 0000:        END FUNCTION
 739: 0000: 
 740: 0000:        FUNCTION DELREC.SRMOD EXTERNAL
 741: 0000:           INTEGER*2 DELREC.SRMOD
 742: 0000:        END FUNCTION
 743: 0000: 
 744: 0000:        SUB SRMOD.SPLIT.SHELF.ITEM EXTERNAL
 745: 0000:        END SUB
 746: 0000: %INCLUDE SRSXFEXT.J86
 747: 0000: \********************************************************************
 748: 0000: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE SRSXF FILE
 749: 0000: \***      REFERENCE : SRSXFEXT.J86
 750: 0000: \***      Version A           Neil Bennett          7th August 2006
 751: 0000: \***
 752: 0000: \********************************************************************
 753: 0000: 
 754: 0000:        FUNCTION SRSXF.SET EXTERNAL
 755: 0000:        END FUNCTION
 756: 0000: 
 757: 0000:        FUNCTION READ.SRSXF EXTERNAL
 758: 0000:           INTEGER*2 READ.SRSXF
 759: 0000:        END FUNCTION
 760: 0000: 
 761: 0000:        FUNCTION WRITE.SRSXF EXTERNAL
 762: 0000:           INTEGER*2 WRITE.SRSXF
 763: 0000:        END FUNCTION
 764: 0000: 
 765: 0000:        FUNCTION DELREC.SRSXF EXTERNAL
 766: 0000:           INTEGER*2 DELREC.SRSXF
 767: 0000:        END FUNCTION
 768: 0000: 
 769: 0000:    FUNCTION ADXSTART(NAME$, PARM$, MESS$) EXTERNAL
 770: 0000:       INTEGER*2 ADXSTART
 771: 0000:       STRING    NAME$, PARM$, MESS$
 772: 0000:    END FUNCTION
 773: 0000: 
 774: 0000: \********************************************************************
 775: 0000: \***
 776: 0000: \***    SRP10 functions
 777: 0000: \***
 778: 0000: \********************************************************************
 779: 0000: 
 780: 0000: \********************************************************************
 781: 0000: \********************************************************************
 782: 0000: \***
 783: 0000: \***    S T A R T  O F  M A I N L I N E  C O D E
 784: 0000: \***
 785: 0000: \********************************************************************
 786: 0000: \********************************************************************
 787: 0000: 
 788: 0000:     ON ERROR GOTO ERROR.DETECTED
 789: 002f: 
 790: 002f: START.PROGRAM:
 791: 0037: 
 792: 0037:     mess$ = "Program started - Initialising ....."
 793: 004c:     GOSUB DISPLAY.MSG
 794: 005e:     GOSUB INITIALISATION
 795: 0070: 
 796: 0070:     IF NOT init.fail% THEN BEGIN
 797: 007f:        mess$ = "Processing S&R Change Delta File ..."
 798: 0094:        GOSUB DISPLAY.MSG
 799: 00a6:        GOSUB MAIN.PROCESS
 800: 00b8:     ENDIF
 801: 00c0: 
 802: 00c0: TIDY.END.PROG:
 803: 00d0: 
 804: 00d0:     IF run.suite% THEN BEGIN
 805: 00e2:        mess$ = "Updating run File and Tidy up ......"
 806: 00f7:        GOSUB DISPLAY.MSG
 807: 0109:        GOSUB UPDATE.RUN.FILE
 808: 011b:        mess$ = "Program Ended - Flag " + POGOK.PE10.RUNFLAG$        \
 809: 0166:              + " Code " + STR$(POGOK.PE10.RETCODE%) + " ......"
 810: 0166:     ENDIF ELSE BEGIN
 811: 016e:        mess$ = "Suite already processed today - Ending."
 812: 0183:     ENDIF
 813: 018b: 
 814: 018b:     GOSUB DISPLAY.MSG
 815: 019d:     GOSUB TERMINATION
 816: 01af: 
 817: 01af: FATAL.END.PROG:
 818: 01bf: 
 819: 01bf:     IF err.cd$ <> "" THEN BEGIN
 820: 01da: 
 821: 01da:        mess$ = "Program Abended ERR >" + err.cd$ + "<"
 822: 01fe:        GOSUB DISPLAY.MSG
 823: 0210: 
 824: 0210:     ENDIF
 825: 0218: 
 826: 0218: STOP
 827: 0225: 
 828: 0225: \********************************************************************
 829: 0225: \********************************************************************
 830: 0225: \***
 831: 0225: \***    S T A R T  O F  S U B R O U T I N E S
 832: 0225: \***
 833: 0225: \********************************************************************
 834: 0225: \********************************************************************
 835: 0225: 
 836: 0225: \********************************************************************
 837: 0225: \***
 838: 0225: \***    SUBROUTINE      :       MAIN.PROCESS
 839: 0225: \***
 840: 0225: \********************************************************************
 841: 0225: \***
 842: 0225: \***    READ sequentially through the POG Delta file
 843: 0225: \***
 844: 0225: \***    Process each record type
 845: 0225: \***
 846: 0225: \***    RETURN
 847: 0225: \***
 848: 0225: \********************************************************************
 849: 0225: 
 850: 0225: MAIN.PROCESS:
 851: 0235: 
 852: 0235:    mod.cnt%  = 0
 853: 0242:    sit.cnt%  = 0
 854: 0250:    eof%      = 0
 855: 025d: 
 856: 025d:    WHILE eof% = 0                                                    \
 857: 0268:      AND tlr.read% = 0                              ! Set in Init
 858: 0268: 
 859: 0268:       rc% = READ.POGDE
 860: 0278:       IF rc% <> 0 THEN BEGIN
 861: 0287:          eof% = 1
 862: 0297:       ENDIF ELSE BEGIN
 863: 029f: 
 864: 029f:          rectyp$ = UNPACK$(MID$(POGDE.RCD$,1,1))
 865: 02c9: 
 866: 02c9:          IF mod.cnt% <> 0 THEN BEGIN
 867: 02db:             IF LEFT$(rectyp$,1) = "0"                               \
 868: 0352:             OR LEFT$(rectyp$,1) = "9" THEN BEGIN
 869: 0352:                IF mod.cnt% <> SRPOG.MODULE.COUNT% THEN BEGIN
 870: 0367:                   srp10.event% = 7
 871: 0374:                   GOSUB LOG.EVENT
 872: 0386:                   GOSUB WRITE.POG.FINAL
 873: 0398:                ENDIF
 874: 03a0:                mod.cnt% = 0
 875: 03ad:             ENDIF
 876: 03b5:          ENDIF
 877: 03bd: 
 878: 03bd:          IF srmod.chg% > 0 THEN BEGIN
 879: 03cf:             IF LEFT$(rectyp$,1) <> "2" THEN BEGIN
 880: 0401:                srmod.chg% = 0
 881: 040e:                GOSUB WRITE.MODULE.FINAL
 882: 0422:             ENDIF ELSE IF item.cnt% <> 0                            \
 883: 045f:                       AND MOD(item.cnt%,                            \
 884: 045f:                               (SRMOD.MAX.ITEMS%)) = 0 THEN BEGIN
 885: 045f:                GOSUB WRITE.MODULE
 886: 0471:             ENDIF
 887: 0479:          ENDIF
 888: 0481: 
 889: 0481:          IF rectyp$ = "01" THEN BEGIN              ! POG Add
 890: 049c:             rec.cnt% = rec.cnt% +1
 891: 04b5:             GOSUB POG.ADD
 892: 04ca:          ENDIF ELSE IF rectyp$ = "02" THEN BEGIN   ! POG Delete
 893: 04e5:             rec.cnt% = rec.cnt% +1
 894: 04fe:             GOSUB POG.DEL
 895: 0513:          ENDIF ELSE IF rectyp$ = "03" THEN BEGIN   ! POG Change
 896: 052e:             rec.cnt% = rec.cnt% +1
 897: 0547:             GOSUB POG.ADD
 898: 055c:          ENDIF ELSE IF rectyp$ = "10" THEN BEGIN   ! Module Add
 899: 0577:             rec.cnt% = rec.cnt% +1
 900: 0590:             mod.cnt% = mod.cnt% +1
 901: 059c:             GOSUB MOD.ADD
 902: 05b1:          ENDIF ELSE IF rectyp$ = "21" THEN BEGIN   ! Shelf/Item Add
 903: 05cc:             rec.cnt% = rec.cnt% +1
 904: 05e5:             GOSUB ITEM.ADD
 905: 05f9:          ENDIF ELSE IF rectyp$ = "99" THEN BEGIN   ! Trailer Record
 906: 0614:             rec.cnt% = rec.cnt% +1
 907: 062d:             tlr.read% = 1
 908: 063a:             tlr.cnt% = GETN4(POGDE.RCD$,1)
 909: 0664:          ENDIF
 910: 066c: 
 911: 066c:       ENDIF
 912: 0674: 
 913: 0674:    WEND
 914: 069b: 
 915: 069b: RETURN
 916: 06ab: 
 917: 06ab: \********************************************************************
 918: 06ab: \***
 919: 06ab: \***    SUBROUTINE      :       POG.ADD
 920: 06ab: \***
 921: 06ab: \********************************************************************
 922: 06ab: \***
 923: 06ab: \***    Set SRPOG values from POGDE record
 924: 06ab: \***
 925: 06ab: \***    Write to SRPOG file
 926: 06ab: \***
 927: 06ab: \***    RETURN
 928: 06ab: \***
 929: 06ab: \********************************************************************
 930: 06ab: 
 931: 06ab: POG.ADD:
 932: 06bb: 
 933: 06bb: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
 934: 06bb: \* Set POGDB from delta file                                       *\
 935: 06bb: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
 936: 06bb: 
 937: 06bb:    SRPOG.POGDB%          = GETN4(POGDE.RCD$,  9    )
 938: 06e7: 
 939: 06e7: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
 940: 06e7: \* For POG change, read existing record and keep module count      *\
 941: 06e7: \*    (this will never be changed - delete POG and add POG used)   *\
 942: 06e7: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
 943: 06e7: 
 944: 06e7:    IF rectyp$ = "03" THEN BEGIN
 945: 0702:       rc% = READ.SRPOG
 946: 0712:       IF rc% <> 0 THEN BEGIN
 947: 0721:          SRPOG.MODULE.COUNT%   = GETN1(POGDE.RCD$,118    )
 948: 0745:       ENDIF
 949: 074f:    ENDIF ELSE BEGIN
 950: 0757:       SRPOG.MODULE.COUNT%   = GETN1(POGDE.RCD$,118    )
 951: 077b:    ENDIF
 952: 0783: 
 953: 0783: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
 954: 0783: \* Set remaining variables supplied in Delta file                  *\
 955: 0783: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
 956: 0783: 
 957: 0783:    SRPOG.POGID%          = GETN4(POGDE.RCD$,  1    )
 958: 07af:    SRPOG.ACT.DATE$       =  MID$(POGDE.RCD$,  6,  4)
 959: 07d6:    SRPOG.PLANNER.FAMILY$ =  MID$(POGDE.RCD$, 64, 30)
 960: 07fd:       ! (Truncated from 50 bytes)
 961: 07fd:    SRPOG.DEACT.DATE$     =  MID$(POGDE.RCD$,114,  4)
 962: 0824:    SRPOG.CAT1.ID%        = GETN4(POGDE.RCD$,119    )
 963: 0850:    SRPOG.CAT2.ID%        = GETN4(POGDE.RCD$,123    )
 964: 087c:    SRPOG.CAT3.ID%        = GETN4(POGDE.RCD$,127    )
 965: 08a8: 
 966: 08a8:    SRPDF.POGDB%          = SRPOG.POGDB%
 967: 08c1:    SRPDF.SHRT.DESC$      =  MID$(POGDE.RCD$, 14, 50)
 968: 08e8:    SRPDF.FULL.DESC$      =  MID$(POGDE.RCD$,132,100)
 969: 0910: 
 970: 0910: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
 971: 0910: \* Extract SRPOG.DESCRIPTION$ (30 bytes) from short decriptor      *\
 972: 0910: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
 973: 0910: 
 974: 0910:    SRPOG.DESCRIPTION$    = LEFT$(SRPDF.SHRT.DESC$, 30)
 975: 0937: 
 976: 0937: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
 977: 0937: \* Build SRPOG.CAT.DBKEY from category keys in Delta file          *\
 978: 0937: \* Set key level                                                   *\
 979: 0937: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
 980: 0937: 
 981: 0937:    IF SRPOG.CAT3.ID% <> 0 THEN BEGIN
 982: 0956:       SRPOG.KEY.LEVEL% = 3
 983: 0968:    ENDIF ELSE IF SRPOG.CAT2.ID% <> 0 THEN BEGIN
 984: 0987:       SRPOG.KEY.LEVEL% = 2
 985: 0999:    ENDIF ELSE BEGIN
 986: 09a1:       SRPOG.KEY.LEVEL% = 1
 987: 09b1:    ENDIF
 988: 09b9: 
 989: 09b9:    SRPOG.CAT.DBKEY% = GET.CATID%(SRPOG.CAT1.ID%,                    \
 990: 09f9:                                  SRPOG.CAT2.ID%,                    \
 991: 09f9:                                  SRPOG.CAT3.ID%)
 992: 09f9: 
 993: 09f9: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
 994: 09f9: \* Set repeat count values to default unset                        *\
 995: 09f9: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
 996: 09f9: 
 997: 09f9:    SRPOG.LIVE.RPT.CNT% = -1
 998: 0a09:    SRPOG.DATE.RPT.CNT$ = PACK$("00000000")
 999: 0a25:    SRPOG.PEND.RPT.CNT% = -1
1000: 0a35: 
1001: 0a35: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1002: 0a35: \* Set filler                                                      *\
1003: 0a35: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1004: 0a35: 
1005: 0a35:    SRPOG.FILLER$ = " "
1006: 0a4c:    SRPDF.FILLER$ = STRING$(15," ")
1007: 0a6a: 
1008: 0a6a: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1009: 0a6a: \* Write SRPOG record to file                                      *\
1010: 0a6a: \* Write SRPDF record to file                                      *\
1011: 0a6a: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1012: 0a6a: 
1013: 0a6a:    rc% = WRITE.SRPOG
1014: 0a7a:    IF rc% <> 0 THEN BEGIN
1015: 0a89:       GOSUB FILE.ERROR
1016: 0a9b:    ENDIF
1017: 0aa3:    rc% = WRITE.SRPDF
1018: 0ab3:    IF rc% <> 0 THEN BEGIN
1019: 0ac2:       GOSUB FILE.ERROR
1020: 0ad4:    ENDIF
1021: 0adc: 
1022: 0adc: RETURN
1023: 0aec: 
1024: 0aec: \********************************************************************
1025: 0aec: \***
1026: 0aec: \***    SUBROUTINE      :       POG.DEL
1027: 0aec: \***
1028: 0aec: \********************************************************************
1029: 0aec: \***
1030: 0aec: \***    Build SRPOG key from POGDE record
1031: 0aec: \***
1032: 0aec: \***    Read record from SRPOG file
1033: 0aec: \***
1034: 0aec: \***    Delete record from SRPOG file (Ignore not found errors)
1035: 0aec: \***
1036: 0aec: \***    Delete child records from SRMOD using key + module count
1037: 0aec: \***
1038: 0aec: \***    Delete notch details from SRSXF for the modules                 ! CRG
1039: 0aec: \***
1040: 0aec: \***    RETURN
1041: 0aec: \***
1042: 0aec: \********************************************************************
1043: 0aec: 
1044: 0aec: POG.DEL:
1045: 0afc: 
1046: 0afc:    SRPOG.POGID%        = GETN4(POGDE.RCD$, 1)                           ! CRG
1047: 0b28:    SRPOG.POGDB%        = GETN4(POGDE.RCD$, 5)                           ! CRG
1048: 0b54:    SRPOG.ACT.DATE$     = MID$(POGDE.RCD$,10, 4)                         ! CRG
1049: 0b7b:    SRPDF.POGDB%        = SRPOG.POGDB%                                   ! CRG
1050: 0b94:    SRSXF.POGDB%        = SRPOG.POGDB%                                   ! CRG
1051: 0bad:    SRMOD.POGDB%        = SRPOG.POGDB%                                   ! CRG
1052: 0bc6:    SRMOD.MODULE.SEQ%   = 0                                              ! CRG
1053: 0bd6:    SRMOD.RECORD.CHAIN% = 0                                              ! CRG
1054: 0be6:    ARRAY.COUNT%        = 0                                              ! CRG
1055: 0bf4:    CHAIN.COUNT%        = 0                                              ! CRG
1056: 0c01:    
1057: 0c01:   ! Module count will be changing from planner to planner but           ! CRG
1058: 0c01:   ! Iteration has to happen 127 times. In the past, it is noticed that  ! CRG
1059: 0c01:   ! Module sequence number are not always incremented in order, it      ! CRG
1060: 0c01:   ! will be random (1,4,7 etc.) So below count will make sure that      ! CRG
1061: 0c01:   ! deletion covers the entire module range.                            ! CRG
1062: 0c01:   
1063: 0c01:    SRMOD.COUNT.LIMIT%  = 127                                            ! CRG
1064: 0c0e:    
1065: 0c0e:    RC% = DELREC.SRPOG                                                   ! CRG
1066: 0c1e:    RC% = DELREC.SRPDF                                                   ! CRG
1067: 0c2e: 
1068: 0c2e:   ! Delete all the Module records and its chain records for this POG    ! CRG
1069: 0c2e:   ! from SRMOD file and delete the corresponding shelf records from     ! CRG
1070: 0c2e:   ! SRSXF file                                                          ! CRG
1071: 0c2e: 
1072: 0c2e:    WHILE SRMOD.MODULE.SEQ% >= 0 AND                      \              ! CRG
1073: 0c39:          SRMOD.MODULE.SEQ% <= SRMOD.COUNT.LIMIT%                        ! CRG
1074: 0c39: 
1075: 0c39:       !Read SRMOD File                                                  ! CRG
1076: 0c39:       RC% = READ.SRMOD                                                  ! CRG
1077: 0c49: 
1078: 0c49:       IF RC% = 0 THEN BEGIN                                             ! CRG
1079: 0c5b: 
1080: 0c5b:          !If module record is read successfully then, get its chain     ! CRG
1081: 0c5b:          !records count                                                 ! CRG
1082: 0c5b: 
1083: 0c5b:          IF SRMOD.ITEM.COUNT% > SRMOD.MAX.ITEMS% THEN BEGIN             ! CRG
1084: 0c73:             CHAIN.COUNT% = SRMOD.ITEM.COUNT% / SRMOD.MAX.ITEMS%         ! CRG
1085: 0c8d:          ENDIF                                                          ! CRG
1086: 0c95: 
1087: 0c95:          !Assign the current SRMOD module sequence to SRSXF module      ! CRG
1088: 0c95:          !sequence                                                      ! CRG
1089: 0c95: 
1090: 0c95:          SRSXF.MODULE.SEQ% = SRMOD.MODULE.SEQ%                          ! CRG
1091: 0cab: 
1092: 0cab:          WHILE SRMOD.RECORD.CHAIN% <= CHAIN.COUNT%                      ! CRG
1093: 0cb6: 
1094: 0cb6:             !Get the shelf numbers from SRSXF file for all module       ! CRG
1095: 0cb6:             !records and its chain records and delete them from         ! CRG
1096: 0cb6:             !SRSXF file                                                 ! CRG
1097: 0cb6: 
1098: 0cb6:             FOR ARRAY.COUNT% = 0 TO SRMOD.MAX.ITEMS% - 1                ! CRG
1099: 0cc6:                SRSXF.SHELF.NO% = SRMOD.SHELF.NUM%(ARRAY.COUNT%)         ! CRG
1100: 0cea:                !Ignore delete errors                                    ! CRG
1101: 0cea:                RC% = DELREC.SRSXF                                       ! CRG
1102: 0cfa:             NEXT ARRAY.COUNT%                                           ! CRG
1103: 0d17: 
1104: 0d17:     ! Delete errors will be ignored as iteration happens for 127 times  ! CRG
1105: 0d17:     ! even if the module sequence numbers are less. This is done to     ! CRG
1106: 0d17:     ! avoid dumping of the event log with error message                 ! CRG
1107: 0d17: 
1108: 0d17:             RC% = DELREC.SRMOD                                          ! CRG
1109: 0d27: 
1110: 0d27:             !Increment the chain number to read the next chain record   ! CRG
1111: 0d27:             !or to exit from the while loop                             ! CRG
1112: 0d27:             SRMOD.RECORD.CHAIN% = SRMOD.RECORD.CHAIN% + 1               ! CRG
1113: 0d36: 
1114: 0d36:             !Read and delete the chain records if any                   ! CRG
1115: 0d36:             RC% = 1                                                     ! CRG
1116: 0d44: 
1117: 0d44:             WHILE (RC% = 1) AND (SRMOD.RECORD.CHAIN% <= CHAIN.COUNT%)   ! CRG
1118: 0d4e:                RC% = READ.SRMOD                                         ! CRG
1119: 0d5e:                IF RC% THEN BEGIN                                        ! CRG
1120: 0d6e:                   SRMOD.RECORD.CHAIN% = SRMOD.RECORD.CHAIN% + 1         ! CRG
1121: 0d7d:                ENDIF                                                    ! CRG
1122: 0d85:             WEND                                                        ! CRG
1123: 0dae: 
1124: 0dae:          WEND                                                           ! CRG
1125: 0dc6: 
1126: 0dc6:       ENDIF                                                             ! CRG
1127: 0dce: 
1128: 0dce:       !Increment SRMOD module sequence to check for the next available  ! CRG
1129: 0dce:       !module sequence in the SRMOD file                                ! CRG
1130: 0dce:       SRMOD.MODULE.SEQ% = SRMOD.MODULE.SEQ% + 1                         ! CRG
1131: 0ddd: 
1132: 0ddd:       !Reset the chain numbers and chain count for next module record   ! CRG
1133: 0ddd:       SRMOD.RECORD.CHAIN% = 0                                           ! CRG
1134: 0ded:       CHAIN.COUNT% = 0                                                  ! CRG
1135: 0dfa:    WEND                                                                 ! CRG
1136: 0e29: 
1137: 0e29:    ! Below original subroutine will be commented out as current logic   ! CRG
1138: 0e29:    ! does not delete records from SRSXF file. Deletion engine is        ! CRG
1139: 0e29:    ! outdated ,it leaves behind many records untouched, and over time   ! CRG
1140: 0e29:    ! it piles up in the file and POGOK suite fails                      ! CRG
1141: 0e29: 
1142: 0e29: 
1143: 0e29:     
1144: 0e29: 
1145: 0e29:    ! rc% = READ.SRPOG                                                   ! CRG
1146: 0e29:    ! IF rc% = 0 THEN BEGIN                                              ! CRG
1147: 0e29:    !   rc% = DELREC.SRPOG                                               ! CRG
1148: 0e29:    !   SRMOD.POGDB% = SRPOG.POGDB%                                      ! CRG
1149: 0e29:    !   SRMOD.MODULE.SEQ% = 0                                            ! CRG
1150: 0e29:    !   SRMOD.RECORD.CHAIN% = 0                                          ! CRG
1151: 0e29:    !   WHILE SRMOD.MODULE.SEQ% <= SRPOG.MODULE.COUNT%                   ! CRG
1152: 0e29:    !      rc% = READ.SRMOD                                              ! CRG
1153: 0e29:    !      rc% = DELREC.SRMOD                                            ! CRG
1154: 0e29:    !      WHILE SRMOD.ITEM.COUNT% > 50                                  ! CRG
1155: 0e29:    !         SRMOD.RECORD.CHAIN% = SRMOD.RECORD.CHAIN% +1               ! CRG
1156: 0e29:    !         SRMOD.ITEM.COUNT% = SRMOD.ITEM.COUNT% -50                  ! CRG
1157: 0e29:    !         rc% = DELREC.SRMOD                                         ! CRG
1158: 0e29:    !      WEND                                                          ! CRG
1159: 0e29:    !      SRMOD.MODULE.SEQ% = SRMOD.MODULE.SEQ% +1                      ! CRG
1160: 0e29:    !      SRMOD.RECORD.CHAIN% = 0                                       ! CRG
1161: 0e29:    !   WEND                                                             ! CRG
1162: 0e29:    ! ENDIF                                                              ! CRG
1163: 0e29:    ! rc% = READ.SRPDF                                                   ! CRG
1164: 0e29:    ! IF rc% = 0 THEN BEGIN                                              ! CRG
1165: 0e29:    !    rc% = DELREC.SRPDF                                              ! CRG
1166: 0e29:    ! ENDIF                                                              ! CRG
1167: 0e29: 
1168: 0e29: RETURN
1169: 0e39: 
1170: 0e39: \********************************************************************
1171: 0e39: \***
1172: 0e39: \***    SUBROUTINE      :       MOD.ADD
1173: 0e39: \***
1174: 0e39: \********************************************************************
1175: 0e39: \***
1176: 0e39: \***    Set SRMOD values from POGDE record
1177: 0e39: \***
1178: 0e39: \***    Write to SRMOD file
1179: 0e39: \***
1180: 0e39: \***    RETURN
1181: 0e39: \***
1182: 0e39: \********************************************************************
1183: 0e39: 
1184: 0e39: MOD.ADD:
1185: 0e49: 
1186: 0e49:    srmod.chg%  =  1
1187: 0e56:    item.cnt%   =  0
1188: 0e64:    shelf.cnt%  =  0
1189: 0e72:    last.shelf% = -1
1190: 0e7f: 
1191: 0e7f:    SRMOD.POGDB%           = GETN4(POGDE.RCD$, 5)
1192: 0eab:    SRMOD.MODULE.SEQ%      = GETN1(POGDE.RCD$,13)
1193: 0ecf:    SRMOD.RECORD.CHAIN%    = 0
1194: 0edf:    SRMOD.DESCRIPTOR$      = MID$ (POGDE.RCD$,15,30)
1195: 0f06:    FOR it.ptr% = 0 TO (SRMOD.MAX.ITEMS% -1)
1196: 0f17:       SRMOD.SHELF.NUM%(it.ptr%) = 0
1197: 0f35:       SRMOD.FACINGS%(it.ptr%)   = 0
1198: 0f53:       SRMOD.ITEM.CODE$(it.ptr%) = STRING$(3,CHR$(0))
1199: 0f82:       SRMOD.MDQ%(it.ptr%)       = 0
1200: 0fa1:       SRMOD.PSC%(it.ptr%)       = 0
1201: 0fc0:    NEXT it.ptr%
1202: 0fe0:    it.ptr% = 0
1203: 0fee:    SRMOD.SHELF.COUNT%     = GETN2(POGDE.RCD$,44)
1204: 1012:    SRMOD.ITEM.COUNT%      = 0
1205: 1023:    SRMOD.FILLER$          = STRING$(18," ")
1206: 1041: 
1207: 1041:    IF SRPOG.POGID% <> GETN4(POGDE.RCD$,1) THEN BEGIN
1208: 107b:       srp10.event% = 6
1209: 1088:       GOSUB LOG.EVENT
1210: 109a:    ENDIF
1211: 10a2: 
1212: 10a2: RETURN
1213: 10b2: 
1214: 10b2: \********************************************************************
1215: 10b2: \***
1216: 10b2: \***    SUBROUTINE      :       ITEM.ADD
1217: 10b2: \***
1218: 10b2: \********************************************************************
1219: 10b2: \***
1220: 10b2: \***    Set SRMOD values from POGDE record
1221: 10b2: \***
1222: 10b2: \***    Write to SRMOD file
1223: 10b2: \***
1224: 10b2: \***    RETURN
1225: 10b2: \***
1226: 10b2: \********************************************************************
1227: 10b2: 
1228: 10b2: ITEM.ADD:
1229: 10c2: 
1230: 10c2:    IF last.shelf% <> GETN1(POGDE.RCD$,12)                           \
1231: 1121:    OR last.notch% <> GETN1(POGDE.RCD$, 1) THEN BEGIN
1232: 1121:       shelf.cnt%        = shelf.cnt% +1
1233: 112d:       last.shelf%       = GETN1(POGDE.RCD$,12)
1234: 114d:       last.notch%       = GETN1(POGDE.RCD$, 1)
1235: 116d:       SRSXF.POGDB%      = SRMOD.POGDB%
1236: 1186:       SRSXF.MODULE.SEQ% = SRMOD.MODULE.SEQ%
1237: 119c:       SRSXF.SHELF.NO%   = GETN1(POGDE.RCD$,12)
1238: 11c0:       SRSXF.NOTCH.NO%   = GETN1(POGDE.RCD$, 1)
1239: 11e4:       SRSXF.SHELF.KEY%  = GETN4(POGDE.RCD$,13)
1240: 1210:       SRSXF.SHELF.DESC$ = STRING$(50,CHR$(0))
1241: 1231:       SRSXF.FILLER$     = "  "
1242: 1248:       rc% = WRITE.SRSXF
1243: 1258:       IF rc% <> 0 THEN BEGIN
1244: 1267:          GOSUB FILE.ERROR
1245: 1279:       ENDIF
1246: 1281:    ENDIF
1247: 1289: 
1248: 1289:    SRMOD.FACINGS%(it.ptr%)   = GETN1(POGDE.RCD$, 2)
1249: 12c1:    SRMOD.ITEM.CODE$(it.ptr%) = MID$ (POGDE.RCD$, 6, 3)
1250: 12f6:    SRMOD.MDQ%(it.ptr%)       = GETN2(POGDE.RCD$, 8)
1251: 132e:    SRMOD.PSC%(it.ptr%)       = GETN2(POGDE.RCD$,10)
1252: 1366:    SRMOD.SHELF.NUM%(it.ptr%) = GETN1(POGDE.RCD$,12)
1253: 139e:    it.ptr%  = it.ptr% +1
1254: 13aa: 
1255: 13aa: \  shelf.item.seq%   = GETN2(POGDE.RCD$, 3)      ! not used ?
1256: 13aa:    item.cnt%         = item.cnt% +1
1257: 13b6:    SRMOD.ITEM.COUNT% = item.cnt%
1258: 13c8: 
1259: 13c8: RETURN
1260: 13d8: 
1261: 13d8: \********************************************************************
1262: 13d8: \***
1263: 13d8: \***    SUBROUTINE      :       WRITE.MODULE
1264: 13d8: \***
1265: 13d8: \********************************************************************
1266: 13d8: \***
1267: 13d8: \***    Write to SRMOD file
1268: 13d8: \***
1269: 13d8: \***    Increment CHAIN sequence ready for possible next write
1270: 13d8: \***
1271: 13d8: \***    RETURN
1272: 13d8: \***
1273: 13d8: \********************************************************************
1274: 13d8: 
1275: 13d8: WRITE.MODULE:
1276: 13e8: 
1277: 13e8:    rc% = WRITE.SRMOD
1278: 13f8:    IF rc% <> 0 THEN BEGIN
1279: 1407:       GOSUB FILE.ERROR
1280: 1419:    ENDIF
1281: 1421: 
1282: 1421:    FOR it.ptr% = 0 TO (SRMOD.MAX.ITEMS% -1)
1283: 1432:       SRMOD.SHELF.NUM%(it.ptr%) = 0
1284: 1450:       SRMOD.FACINGS%(it.ptr%)   = 0
1285: 146e:       SRMOD.ITEM.CODE$(it.ptr%) = STRING$(3,CHR$(0))
1286: 149d:       SRMOD.MDQ%(it.ptr%)       = 0
1287: 14bc:       SRMOD.PSC%(it.ptr%)       = 0
1288: 14db:    NEXT it.ptr%
1289: 14fb:    it.ptr% = 0
1290: 1509: 
1291: 1509:    SRMOD.RECORD.CHAIN%    = SRMOD.RECORD.CHAIN% +1
1292: 1518: 
1293: 1518: RETURN
1294: 1528: 
1295: 1528: \********************************************************************
1296: 1528: \***
1297: 1528: \***    SUBROUTINE      :       WRITE.MODULE.FINAL
1298: 1528: \***
1299: 1528: \********************************************************************
1300: 1528: \***
1301: 1528: \***    Write to SRMOD file
1302: 1528: \***
1303: 1528: \***    Update previous records in chain with item count
1304: 1528: \***
1305: 1528: \***    RETURN
1306: 1528: \***
1307: 1528: \********************************************************************
1308: 1528: 
1309: 1528: WRITE.MODULE.FINAL:
1310: 1538: 
1311: 1538: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1312: 1538: \* Shelf count not set by host insert computed count               *\
1313: 1538: \* This is the count of shelves and/or notch changes within a shelf*\
1314: 1538: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1315: 1538: 
1316: 1538:    SRMOD.SHELF.COUNT% = shelf.cnt%
1317: 154a: 
1318: 154a: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1319: 154a: \* Write any outstanding items to file                             *\
1320: 154a: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1321: 154a: 
1322: 154a:    IF it.ptr% > 0 THEN BEGIN
1323: 1559:       GOSUB WRITE.MODULE
1324: 156b:    ENDIF
1325: 1573: 
1326: 1573: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1327: 1573: \* Decrement the chain pointer by 2 to point to last but 1 write   *\
1328: 1573: \*    as the last write would have had the correct item count      *\
1329: 1573: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1330: 1573: 
1331: 1573:    SRMOD.RECORD.CHAIN% = SRMOD.RECORD.CHAIN% -2
1332: 1583: 
1333: 1583: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1334: 1583: \* For each record back to the first, update the item count field  *\
1335: 1583: \* and the shelf count field.                                      *\
1336: 1583: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1337: 1583: 
1338: 1583:    WHILE SRMOD.RECORD.CHAIN% >= 0
1339: 158e:       rc% = READ.SRMOD
1340: 159e:       IF rc% <> 0 THEN BEGIN
1341: 15ad:          GOSUB FILE.ERROR
1342: 15bf:       ENDIF
1343: 15c7:       SRMOD.ITEM.COUNT% = item.cnt%
1344: 15d9:       SRMOD.SHELF.COUNT% = shelf.cnt%
1345: 15eb:       rc% = WRITE.SRMOD
1346: 15fb:       IF rc% <> 0 THEN BEGIN
1347: 160a:          GOSUB FILE.ERROR
1348: 161c:       ENDIF
1349: 1624:       SRMOD.RECORD.CHAIN% = SRMOD.RECORD.CHAIN% -1
1350: 1633:    WEND
1351: 1648: 
1352: 1648: RETURN
1353: 1658: 
1354: 1658: \********************************************************************
1355: 1658: \***
1356: 1658: \***    SUBROUTINE      :       WRITE.POG.FINAL
1357: 1658: \***
1358: 1658: \********************************************************************
1359: 1658: \***
1360: 1658: \***    Write to SRPOG file updating module count
1361: 1658: \***
1362: 1658: \***    RETURN
1363: 1658: \***
1364: 1658: \********************************************************************
1365: 1658: 
1366: 1658: WRITE.POG.FINAL:
1367: 1668: 
1368: 1668:    rc% = READ.SRPOG
1369: 1678:    IF rc% <> 0 THEN BEGIN
1370: 1687:       GOSUB FILE.ERROR
1371: 1699:    ENDIF
1372: 16a1:    SRPOG.MODULE.COUNT% = mod.cnt%
1373: 16b3:    rc% = WRITE.SRPOG
1374: 16c3:    IF rc% <> 0 THEN BEGIN
1375: 16d2:       GOSUB FILE.ERROR
1376: 16e4:    ENDIF
1377: 16ec: 
1378: 16ec: RETURN
1379: 16fc: 
1380: 16fc: \********************************************************************
1381: 16fc: \***
1382: 16fc: \***    SUBROUTINE      :       INITIALISATION
1383: 16fc: \***
1384: 16fc: \********************************************************************
1385: 16fc: \***
1386: 16fc: \***    Initialise main program variables
1387: 16fc: \***
1388: 16fc: \***    Allocate session numbers to files
1389: 16fc: \***
1390: 16fc: \***    OPEN required files
1391: 16fc: \***
1392: 16fc: \***    SET program started flag
1393: 16fc: \***
1394: 16fc: \***    Check run is valid
1395: 16fc: \***
1396: 16fc: \***    RETURN
1397: 16fc: \***
1398: 16fc: \********************************************************************
1399: 16fc: 
1400: 16fc: INITIALISATION:
1401: 170c: 
1402: 170c: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1403: 170c: \* Set program variables                                           *\
1404: 170c: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1405: 170c: 
1406: 170c:    bg%           = 0
1407: 1719:    init.fail%    = 0
1408: 1726:    rec.cnt%      = 0
1409: 173b:    srmod.chg%    = 0
1410: 1748:    srp10.error%  = 0
1411: 1755:    srp10.event%  = 0
1412: 1762:    tlr.cnt%      = 0
1413: 1777:    tlr.read%     = 0
1414: 1784:    comm.tail$    = COMMAND$
1415: 179a: 
1416: 179a:    IF LEFT$(comm.tail$, 8) = "BACKGRND" THEN BEGIN
1417: 17cc:       bg% = 1
1418: 17d9:       comm.tail$ = MID$(comm.tail$,10,LEN(comm.tail$) -9)
1419: 180b:    ENDIF
1420: 1813: 
1421: 1813: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1422: 1813: \* Set todays date YYYYMMDD                                        *\
1423: 1813: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1424: 1813: 
1425: 1813:    rundate$ = PACK$("20"+DATE$)
1426: 183a: 
1427: 183a: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1428: 183a: \* Allocate Session Numbers and Open Files                         *\
1429: 183a: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1430: 183a: 
1431: 183a:    GOSUB ALLOCATE.SESS.NUMS
1432: 184c: 
1433: 184c:    GOSUB OPEN.FILES
1434: 185e: 
1435: 185e: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1436: 185e: \* Set POGOK run flag                                              *\
1437: 185e: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1438: 185e: 
1439: 185e:    no.read% = 0
1440: 186b: retry1:
1441: 187b:    rc% = READ.POGOK.LOCK
1442: 188b:    IF rc% <> 0 THEN BEGIN
1443: 189a:       GOSUB FILE.ERROR
1444: 18ac:       IF no.read% > 0 THEN GOTO retry1
1445: 18bd:    ENDIF
1446: 18c5: 
1447: 18c5:    run.suite% = 2
1448: 18d2:    IF LEFT$(comm.tail$, 7) = "SLEEPER" THEN BEGIN
1449: 1907:       IF POGOK.PE10.RUNDATE$ = rundate$                             \
1450: 195d:      AND POGOK.PE10.RUNFLAG$ <> "X" THEN BEGIN
1451: 195d:          run.suite% = run.suite% -1
1452: 196b:       ENDIF ELSE BEGIN
1453: 1973:          POGOK.PE10.RUNFLAG$ = "S"
1454: 198a:       ENDIF
1455: 1992:       IF POGOK.PE5.RUNDATE$ = rundate$                              \
1456: 19e8:      AND POGOK.PE5.RUNFLAG$ <> "X" THEN BEGIN
1457: 19e8:          run.suite% = run.suite% -1
1458: 19f6:       ENDIF ELSE BEGIN
1459: 19fe:          GOSUB START.SRP5
1460: 1a10:       ENDIF
1461: 1a1a:    ENDIF ELSE BEGIN
1462: 1a22:       POGOK.PE10.RUNFLAG$ = "S"
1463: 1a39:       GOSUB START.SRP5
1464: 1a4b:    ENDIF
1465: 1a53: 
1466: 1a53:    rc% = WRITE.POGOK.UNLOCK
1467: 1a63:    IF rc% <> 0 THEN BEGIN
1468: 1a72:       GOSUB FILE.ERROR
1469: 1a84:    ENDIF
1470: 1a8c: 
1471: 1a8c:    IF NOT run.suite% THEN BEGIN
1472: 1a9b:       init.fail% = -1
1473: 1aa8:       RETURN
1474: 1ab8:    ENDIF
1475: 1ac0: 
1476: 1ac0: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1477: 1ac0: \* Read input file header record                                   *\
1478: 1ac0: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1479: 1ac0: 
1480: 1ac0:    IF NOT no.inp.file% THEN BEGIN
1481: 1acf:       rc% = READ.POGDE
1482: 1adf:       IF rc% <> 0 THEN BEGIN
1483: 1aee:          GOSUB FILE.ERROR
1484: 1b00:       ENDIF
1485: 1b08:    ENDIF
1486: 1b10: 
1487: 1b10: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1488: 1b10: \* Check for header record                                         *\
1489: 1b10: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1490: 1b10: 
1491: 1b10:    IF (NOT no.inp.file%)                                            \
1492: 1b6c:   AND (UNPACK$(MID$(POGDE.RCD$,1,1)) = "00") THEN BEGIN
1493: 1b6c:       rec.cnt% = rec.cnt% +1
1494: 1b85:       POGDE.SER.NO% = GETN4(POGDE.RCD$,1)
1495: 1baf:       POGDE.DATE$   = MID$(POGDE.RCD$,6,4)
1496: 1bd4:       POGDE.DTR%    = GETN2(POGDE.RCD$,9)
1497: 1bf4: 
1498: 1bf4: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1499: 1bf4: \* NOT rerun AND serial number and date are equal - Duplicate      *\
1500: 1bf4: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1501: 1bf4: 
1502: 1bf4:       IF LEFT$(comm.tail$, 5) <> "RERUN"                            \
1503: 1c6e:      AND LEFT$(comm.tail$, 7) <> "SLEEPER" THEN BEGIN               !
1504: 1c6e:          IF VAL(POGOK.SRD.SER.NO$) = POGDE.SER.NO%                  \
1505: 1cdd:         AND POGOK.SRD.DATE$ = POGDE.DATE$ THEN BEGIN
1506: 1cdd: 
1507: 1cdd:             ! Log event for duplicate
1508: 1cdd:             srp10.event% = 2
1509: 1cea:             GOSUB LOG.EVENT
1510: 1cfc: 
1511: 1cfc:             srp10.error% = srp10.error% OR 08H
1512: 1d0c: 
1513: 1d0c:             init.fail% = 1
1514: 1d19: 
1515: 1d19:             RETURN
1516: 1d29: 
1517: 1d29:          ENDIF
1518: 1d31:       ENDIF
1519: 1d39: 
1520: 1d39: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1521: 1d39: \* serial number or date < reset file - Old data                   *\
1522: 1d39: \*    (allow for serial number rollover @ 9999)                    *\
1523: 1d39: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1524: 1d39: 
1525: 1d39:       rc% = VAL(POGOK.SRD.SER.NO$)
1526: 1d56:       IF rc% = 9999 THEN rc% = 0
1527: 1d6c: 
1528: 1d6c:       IF rc% > GETN4(POGDE.RCD$,1)                                  \
1529: 1dde:       OR POGOK.SRD.DATE$ > MID$(POGDE.RCD$,6,4) THEN BEGIN
1530: 1dde: 
1531: 1dde:          srp10.event% = 3
1532: 1deb:          GOSUB LOG.EVENT
1533: 1dfd: 
1534: 1dfd:          srp10.error% = srp10.error% OR 04H
1535: 1e0d: 
1536: 1e0d:          init.fail% = 1
1537: 1e1a: 
1538: 1e1a:          RETURN
1539: 1e2a: 
1540: 1e2a:       ENDIF
1541: 1e32: 
1542: 1e32: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1543: 1e32: \* Initial load                                                    *\
1544: 1e32: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1545: 1e32: 
1546: 1e32:       IF MID$(POGDE.RCD$,12,1) = "I" THEN BEGIN
1547: 1e6a: 
1548: 1e6a:          init.load% = 1
1549: 1e77: 
1550: 1e77:          IF NOT no.pog.file% THEN BEGIN
1551: 1e89:             CLOSE SRPOG.SESS.NUM%
1552: 1e9d:             IF END #SRPOG.SESS.NUM% THEN NO.SRPOG.COPY
1553: 1eb9:             OPEN SRPOG.COPY.NAME$ AS SRPOG.SESS.NUM%
1554: 1ee0:             DELETE SRPOG.SESS.NUM%
1555: 1ef4: NO.SRPOG.COPY:
1556: 1f04:             rc% = RENAME(SRPOG.COPY.NAME$,SRPOG.FILE.NAME$)
1557: 1f2a:          ENDIF
1558: 1f32:          IF NOT no.mod.file% THEN BEGIN
1559: 1f44:             CLOSE SRMOD.SESS.NUM%
1560: 1f58:             IF END #SRMOD.SESS.NUM% THEN NO.SRMOD.COPY
1561: 1f74:             OPEN SRMOD.COPY.NAME$ AS SRMOD.SESS.NUM%
1562: 1f9b:             DELETE SRMOD.SESS.NUM%
1563: 1faf: NO.SRMOD.COPY:
1564: 1fbf:             rc% = RENAME(SRMOD.COPY.NAME$,SRMOD.FILE.NAME$)
1565: 1fe5:          ENDIF
1566: 1fed: 
1567: 1fed:          GOSUB CREATE.SRPOG
1568: 1fff:          GOSUB CREATE.SRMOD
1569: 2014: 
1570: 2014: 
1571: 2014:       ENDIF ELSE IF MID$(POGDE.RCD$,12,1) = "D" THEN BEGIN
1572: 204c: 
1573: 204c: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1574: 204c: \* delta file and no existing                                      *\
1575: 204c: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1576: 204c: 
1577: 204c:          IF no.pog.file% OR no.mod.file% THEN BEGIN
1578: 2060: 
1579: 2060:             srp10.event% = 5
1580: 206d:             GOSUB LOG.EVENT
1581: 207f: 
1582: 207f:             srp10.error% = srp10.error% OR 10H
1583: 208f: 
1584: 208f:             IF NOT no.pog.file% THEN BEGIN
1585: 209e:                DELETE SRPOG.SESS.NUM%
1586: 20b2:             ENDIF
1587: 20ba:             IF NOT no.mod.file% THEN BEGIN
1588: 20c9:                DELETE SRMOD.SESS.NUM%
1589: 20dd:             ENDIF
1590: 20e5: 
1591: 20e5:             GOSUB CREATE.SRPOG
1592: 20f7:             GOSUB CREATE.SRMOD
1593: 2109: 
1594: 2109:          ENDIF
1595: 2111: 
1596: 2111:       ENDIF
1597: 211c: 
1598: 211c:    ENDIF ELSE BEGIN
1599: 2124: 
1600: 2124: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1601: 2124: \* No header record or No input file                               *\
1602: 2124: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1603: 2124: 
1604: 2124:       srp10.event% = 1
1605: 2131:       GOSUB LOG.EVENT
1606: 2143: 
1607: 2143:       srp10.error% = srp10.error% OR 20H
1608: 2153:       init.fail% = 1
1609: 2160: 
1610: 2160:       IF no.pog.file% OR no.mod.file% THEN BEGIN
1611: 2174: 
1612: 2174:          IF NOT no.pog.file% THEN BEGIN
1613: 2183:             DELETE SRPOG.SESS.NUM%
1614: 2197:          ENDIF
1615: 219f:          IF NOT no.mod.file% THEN BEGIN
1616: 21ae:             DELETE SRMOD.SESS.NUM%
1617: 21c2:          ENDIF
1618: 21ca: 
1619: 21ca:          GOSUB CREATE.SRPOG
1620: 21dc:          GOSUB CREATE.SRMOD
1621: 21ee: 
1622: 21ee:       ENDIF
1623: 21f6: 
1624: 21f6:    ENDIF
1625: 21fe: 
1626: 21fe: RETURN
1627: 220e: 
1628: 220e: \********************************************************************
1629: 220e: \***
1630: 220e: \***    SUBROUTINE      :       ALLOCATE.SESS.NUMS
1631: 220e: \***
1632: 220e: \********************************************************************
1633: 220e: \***
1634: 220e: \***    Allocate all session numbers
1635: 220e: \***
1636: 220e: \********************************************************************
1637: 220e: 
1638: 220e: ALLOCATE.SESS.NUMS:
1639: 221e: 
1640: 221e:     SB.ACTION$ = "O"
1641: 2235: 
1642: 2235:     SB.INTEGER% = POGDE.REPORT.NUM%
1643: 224b:     SB.STRING$  = POGDE.FILE.NAME$
1644: 2269:     GOSUB SB.FILE.UTILS
1645: 227b:     POGDE.SESS.NUM% = SB.FILE.SESS.NUM%
1646: 2291: 
1647: 2291:     SB.INTEGER% = POGOK.REPORT.NUM%
1648: 22a7:     SB.STRING$  = POGOK.FILE.NAME$
1649: 22c5:     GOSUB SB.FILE.UTILS
1650: 22d7:     POGOK.SESS.NUM% = SB.FILE.SESS.NUM%
1651: 22ed: 
1652: 22ed:     SB.INTEGER% = SRPOG.REPORT.NUM%
1653: 2303:     SB.STRING$  = SRPOG.FILE.NAME$
1654: 2321:     GOSUB SB.FILE.UTILS
1655: 2333:     SRPOG.SESS.NUM% = SB.FILE.SESS.NUM%
1656: 2349: 
1657: 2349:     SB.INTEGER% = SRMOD.REPORT.NUM%
1658: 235f:     SB.STRING$  = SRMOD.FILE.NAME$
1659: 237d:     GOSUB SB.FILE.UTILS
1660: 238f:     SRMOD.SESS.NUM% = SB.FILE.SESS.NUM%
1661: 23a5: 
1662: 23a5:     SB.INTEGER% = SRPDF.REPORT.NUM%
1663: 23bb:     SB.STRING$  = SRPDF.FILE.NAME$
1664: 23d9:     GOSUB SB.FILE.UTILS
1665: 23eb:     SRPDF.SESS.NUM% = SB.FILE.SESS.NUM%
1666: 2401: 
1667: 2401:     SB.INTEGER% = SRSXF.REPORT.NUM%
1668: 2417:     SB.STRING$  = SRSXF.FILE.NAME$
1669: 2435:     GOSUB SB.FILE.UTILS
1670: 2447:     SRSXF.SESS.NUM% = SB.FILE.SESS.NUM%
1671: 245d: 
1672: 245d: RETURN
1673: 246d: 
1674: 246d: \********************************************************************
1675: 246d: \***
1676: 246d: \***    SUBROUTINE      :       OPEN.FILES
1677: 246d: \***
1678: 246d: \********************************************************************
1679: 246d: \***
1680: 246d: \***    Open required files
1681: 246d: \***
1682: 246d: \********************************************************************
1683: 246d: 
1684: 246d: OPEN.FILES:
1685: 247d: 
1686: 247d:    CALL POGDE.SET
1687: 2498:    CALL POGOK.SET
1688: 24b3:    CALL SRPDF.SET
1689: 24ce:    CALL SRPOG.SET
1690: 24e9:    CALL SRMOD.SET
1691: 2504:    CALL SRSXF.SET
1692: 251f: 
1693: 251f:    FILE.OPERATION$ = "O"
1694: 2536: 
1695: 2536:    no.inp.file% = 1
1696: 2543:    CURRENT.REPORT.NUM% = POGDE.REPORT.NUM%
1697: 2559:    IF END # POGDE.SESS.NUM% THEN pogde.open.err
1698: 2575:    rc4% = SIZE(POGDE.FILE.NAME$)
1699: 259a:    rc%  = MOD(rc4%, 1024)
1700: 25b2:    IF rc% <> 0 THEN BEGIN
1701: 25c4:       mess$ = STRING$(1024 -rc%, " ")
1702: 25e6:       work$ = "C" + STR$(LEN(mess$))
1703: 2619:       OPEN POGDE.FILE.NAME$ AS POGDE.SESS.NUM% APPEND
1704: 2640:       WRITE FORM work$; #POGDE.SESS.NUM%; mess$
1705: 266b:       CLOSE POGDE.SESS.NUM%
1706: 267f:    ENDIF
1707: 2687: 
1708: 2687:    OPEN POGDE.FILE.NAME$ DIRECT RECL 1024 AS POGDE.SESS.NUM%        \
1709: 26b0:         NOWRITE NODEL
1710: 26b0:    no.inp.file% = 0
1711: 26bd: pogde.open.err:
1712: 26cd: 
1713: 26cd:    no.file% = 1
1714: 26da:    CURRENT.REPORT.NUM% = POGOK.REPORT.NUM%
1715: 26f0:    IF END # POGOK.SESS.NUM% THEN pogok.open.err
1716: 270c:    OPEN POGOK.FILE.NAME$ DIRECT RECL POGOK.RECL% AS POGOK.SESS.NUM% \
1717: 2739:          NODEL
1718: 2739:    no.file% = 0
1719: 2746: pogok.open.err:
1720: 2756:    IF no.file% = 1 THEN BEGIN
1721: 2765:       rc% = CREATE.POGOK
1722: 2775:       IF rc% <> 0 THEN BEGIN
1723: 2784:          GOSUB CREATE.ERROR
1724: 2796:       ENDIF
1725: 279e:    ENDIF
1726: 27a6: 
1727: 27a6:    no.pog.file% = 1
1728: 27b3:    CURRENT.REPORT.NUM% = SRPOG.REPORT.NUM%
1729: 27c9:    IF END # SRPOG.SESS.NUM% THEN srpog.open.err
1730: 27e5:    OPEN SRPOG.FILE.NAME$ KEYED RECL SRPOG.RECL% AS SRPOG.SESS.NUM%
1731: 2811:    no.pog.file% = 0
1732: 281e: srpog.open.err:
1733: 282e: 
1734: 282e:    no.mod.file% = 1
1735: 283b:    CURRENT.REPORT.NUM% = SRMOD.REPORT.NUM%
1736: 2851:    IF END # SRMOD.SESS.NUM% THEN srmod.open.err
1737: 286d:    OPEN SRMOD.FILE.NAME$ KEYED RECL SRMOD.RECL% AS SRMOD.SESS.NUM%
1738: 2899:    no.mod.file% = 0
1739: 28a6: srmod.open.err:
1740: 28b6: 
1741: 28b6:    no.file% = 1
1742: 28c3:    CURRENT.REPORT.NUM% = SRPDF.REPORT.NUM%
1743: 28d9:    IF END # SRPDF.SESS.NUM% THEN srpdf.open.err
1744: 28f5:    OPEN SRPDF.FILE.NAME$ KEYED RECL SRPDF.RECL% AS SRPDF.SESS.NUM%
1745: 2921:    no.file% = 0
1746: 292e: srpdf.open.err:
1747: 293e:    IF no.file% = 1 THEN BEGIN
1748: 294d:       no.file% = 0
1749: 295a:       IF NOT no.inp.file% THEN BEGIN
1750: 2969:          FILE.OPERATION$ = "C"
1751: 2980:    ! Planner refresh from Inctactix has been increased over time so     ! CRG 
1752: 2980:    ! doubling the file capacity to double of its current size           ! CRG
1753: 2980:    
1754: 2980:    !      CREATE POSFILE SRPDF.FILE.NAME$ KEYED 4,,,3000                ! DRG
1755: 2980: 
1756: 2980:           CREATE POSFILE SRPDF.FILE.NAME$ KEYED 4,,,6000                \ CRG
1757: 29b7:                 RECL SRPDF.RECL% AS SRPDF.SESS.NUM% MIRRORED ATCLOSE
1758: 29b7:       ENDIF
1759: 29bf:    ENDIF
1760: 29c7: 
1761: 29c7:    no.file% = 1
1762: 29d4:    CURRENT.REPORT.NUM% = SRSXF.REPORT.NUM%
1763: 29ea:    IF END # SRSXF.SESS.NUM% THEN srsxf.open.err
1764: 2a06:    OPEN SRSXF.FILE.NAME$ KEYED RECL SRSXF.RECL% AS SRSXF.SESS.NUM%
1765: 2a32:    no.file% = 0
1766: 2a3f: srsxf.open.err:
1767: 2a4f:    IF no.file% = 1 THEN BEGIN
1768: 2a5e:       no.file% = 0
1769: 2a6b:       IF NOT no.inp.file% THEN BEGIN
1770: 2a7a:          FILE.OPERATION$ = "C"
1771: 2a91: 
1772: 2a91:    ! Planner refresh from Inctactix has been increased over time so     ! CRG 
1773: 2a91:    ! increasing the file capacity to 1.5 times of its current size      ! CRG 
1774: 2a91: 
1775: 2a91:    !      CREATE POSFILE SRSXF.FILE.NAME$ KEYED 6,,,60000               ! DRG
1776: 2a91: 
1777: 2a91:           CREATE POSFILE SRSXF.FILE.NAME$ KEYED 6,,,90000               \ CRG
1778: 2ac8:                 RECL SRSXF.RECL% AS SRSXF.SESS.NUM% MIRRORED ATCLOSE
1779: 2ac8:       ENDIF
1780: 2ad0:    ENDIF
1781: 2ad8: 
1782: 2ad8: RETURN
1783: 2ae8: 
1784: 2ae8: \********************************************************************
1785: 2ae8: \***
1786: 2ae8: \***    SUBROUTINE      :       UPDATE.RUN.FILE
1787: 2ae8: \***
1788: 2ae8: \********************************************************************
1789: 2ae8: \***
1790: 2ae8: \***    READ POGOK Locked
1791: 2ae8: \***
1792: 2ae8: \***    Set up variables according to run results
1793: 2ae8: \***
1794: 2ae8: \***    WRITE POGOK Unlock
1795: 2ae8: \***
1796: 2ae8: \***    RETURN
1797: 2ae8: \***
1798: 2ae8: \********************************************************************
1799: 2ae8: 
1800: 2ae8: UPDATE.RUN.FILE:
1801: 2af8: 
1802: 2af8: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1803: 2af8: \* Set todays date YYYYMMDD (set again incase 24:00 passed)        *\
1804: 2af8: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1805: 2af8: 
1806: 2af8:    rundate$ = PACK$("20"+DATE$)
1807: 2b1f: 
1808: 2b1f: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1809: 2b1f: \* Set error codes for incomplete Delta file                       *\
1810: 2b1f: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1811: 2b1f: 
1812: 2b1f:    IF (srp10.error% AND 80H) = 80H                                  \
1813: 2b43:   AND init.fail% = 0 THEN BEGIN
1814: 2b43:       IF tlr.read% = 0 THEN BEGIN
1815: 2b52:          srp10.error% = srp10.error% OR 02H
1816: 2b64:       ENDIF ELSE IF tlr.cnt% <> rec.cnt% THEN BEGIN
1817: 2b7f:          srp10.error% = srp10.error% OR 01H
1818: 2b8f:       ENDIF
1819: 2b97:    ENDIF
1820: 2b9f: 
1821: 2b9f: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1822: 2b9f: \* Read POGOK file - Retry if locked                               *\
1823: 2b9f: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1824: 2b9f: 
1825: 2b9f:    no.read% = 0
1826: 2bac: retry2:
1827: 2bbc:    rc% = READ.POGOK.LOCK
1828: 2bcc:    IF rc% <> 0 THEN BEGIN
1829: 2bdb:       GOSUB FILE.ERROR
1830: 2bed:       IF no.read% > 0 THEN GOTO retry2
1831: 2bfe:    ENDIF
1832: 2c06: 
1833: 2c06: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1834: 2c06: \* Update POGOK based on run results                               *\
1835: 2c06: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1836: 2c06: 
1837: 2c06:    IF init.load% THEN BEGIN
1838: 2c15:       POGOK.RELOAD$ = "N"
1839: 2c2c:    ENDIF
1840: 2c34: 
1841: 2c34:    POGOK.PE10.RUNDATE$ = rundate$
1842: 2c4f:    IF (srp10.error% AND 20H) <> 0 THEN BEGIN
1843: 2c60:       ! Delta File not found or No header record
1844: 2c60:       POGOK.PE10.RUNFLAG$ = "Y"
1845: 2c77:       POGOK.PE10.RETCODE% = 6
1846: 2c8a:    ENDIF ELSE IF (srp10.error% AND 83H) <> 0 THEN BEGIN
1847: 2c9e:       ! Abend via Main error routine (80H)
1848: 2c9e:       ! Incorrect record count (01H) or No trailer record (02H)
1849: 2c9e:       srp10.event% = 4
1850: 2cab:       GOSUB LOG.EVENT
1851: 2cbd:       POGOK.PE10.RUNFLAG$      = "X"
1852: 2cd4:       IF (srp10.error% AND 80H) = 80H THEN BEGIN
1853: 2ce5:          POGOK.PE10.RETCODE% = 8
1854: 2cf7:       ENDIF ELSE BEGIN
1855: 2cff:          POGOK.PE10.RETCODE% = (srp10.error% AND 03H)
1856: 2d13:       ENDIF
1857: 2d1b:       POGOK.SRD.REC.COUNT%     = rec.cnt%
1858: 2d32:       POGOK.FAILED.SRD.SER.NO$ = RIGHT$("0000"                      \
1859: 2d7a:                                       + STR$(POGDE.SER.NO%),4)
1860: 2d7a:       POGOK.FAILED.SRD.DATE$   = POGDE.DATE$
1861: 2d98:    ENDIF ELSE IF (srp10.error% AND 04H) <> 0 THEN BEGIN
1862: 2da9:       ! Old data
1863: 2da9:       POGOK.PE10.RUNFLAG$ = "Y"
1864: 2dc0:       POGOK.PE10.RETCODE% = 3
1865: 2dd3:    ENDIF ELSE IF (srp10.error% AND 08H) <> 0 THEN BEGIN
1866: 2de4:       ! Already processed (Not 'RERUN')
1867: 2de4:       POGOK.PE10.RUNFLAG$ = "E"
1868: 2dfb:       POGOK.PE10.RETCODE% = 4
1869: 2e0e:    ENDIF ELSE IF (srp10.error% AND 10H) <> 0 THEN BEGIN
1870: 2e1f:       ! Init Load expected - Delta received
1871: 2e1f:       POGOK.PE10.RUNFLAG$ = "Y"
1872: 2e36:       POGOK.PE10.RETCODE% = 5
1873: 2e46:       POGOK.RELOAD$       = "Y"
1874: 2e5f:    ENDIF ELSE BEGIN
1875: 2e67:       ! No problems
1876: 2e67:       POGOK.PE10.RUNFLAG$ = "E"
1877: 2e7e:       POGOK.PE10.RETCODE% = 0
1878: 2e8e:    ENDIF
1879: 2e96: 
1880: 2e96:    IF POGOK.PE10.RETCODE% = 0                                       \
1881: 2ec3:    OR POGOK.PE10.RETCODE% = 5 THEN BEGIN
1882: 2ec3:       POGOK.SRD.SER.NO$     = RIGHT$("0000"+STR$(POGDE.SER.NO%),4)
1883: 2f0b:       POGOK.SRD.DATE$       = POGDE.DATE$
1884: 2f26:       POGOK.SRD.REC.COUNT%  = rec.cnt%
1885: 2f3d:       POGOK.DAYS.TO.RETAIN% = POGDE.DTR%
1886: 2f4f:    ENDIF
1887: 2f57: 
1888: 2f57: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1889: 2f57: \* Write to POGOK                                                  *\
1890: 2f57: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1891: 2f57: 
1892: 2f57:    rc% = WRITE.POGOK.UNLOCK
1893: 2f67:    IF rc% <> 0 THEN BEGIN
1894: 2f76:       GOSUB FILE.ERROR
1895: 2f88:    ENDIF
1896: 2f90: 
1897: 2f90: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1898: 2f90: \* Delete copies of SRPOG/SRMOD if they exist (Not if abended)     *\
1899: 2f90: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1900: 2f90: 
1901: 2f90:    IF POGOK.PE10.RUNFLAG$ <> "X" THEN BEGIN
1902: 2fb1:       IF SIZE(SRPOG.COPY.NAME$) > 0 THEN BEGIN
1903: 2fe0:          CLOSE SRPOG.SESS.NUM%
1904: 2ff4:          OPEN SRPOG.COPY.NAME$ AS SRPOG.SESS.NUM%
1905: 301b:          DELETE SRPOG.SESS.NUM%
1906: 302f:       ENDIF
1907: 3037:       IF SIZE(SRMOD.COPY.NAME$) > 0 THEN BEGIN
1908: 3066:          CLOSE SRMOD.SESS.NUM%
1909: 307a:          OPEN SRMOD.COPY.NAME$ AS SRMOD.SESS.NUM%
1910: 30a1:          DELETE SRMOD.SESS.NUM%
1911: 30b5:       ENDIF
1912: 30bd:    ENDIF
1913: 30c5: 
1914: 30c5: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1915: 30c5: \* Delete old copy of delta file/ Save current (Not if abended)    *\
1916: 30c5: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1917: 30c5: 
1918: 30c5:    IF POGOK.PE10.RUNFLAG$ <> "X" THEN BEGIN
1919: 30e6:       IF SIZE(POGDE.COPY.NAME$) > 0 THEN BEGIN
1920: 3115:          CLOSE POGDE.SESS.NUM%
1921: 3129:          OPEN POGDE.COPY.NAME$ AS POGDE.SESS.NUM%
1922: 3150:          DELETE POGDE.SESS.NUM%
1923: 3164:       ENDIF
1924: 316c:       rc% = RENAME(POGDE.COPY.NAME$,POGDE.FILE.NAME$)
1925: 3192:    ENDIF
1926: 319a: 
1927: 319a: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1928: 319a: \* Start - House keeping & Index Prime                             *\
1929: 319a: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1930: 319a: 
1931: 319a:    GOSUB START.SRP6
1932: 31ac: 
1933: 31ac: RETURN
1934: 31bc: 
1935: 31bc: \********************************************************************
1936: 31bc: \***
1937: 31bc: \***    SUBROUTINE      :       TERMINATION
1938: 31bc: \***
1939: 31bc: \********************************************************************
1940: 31bc: \***
1941: 31bc: \***    Deallocate all session numbers
1942: 31bc: \***
1943: 31bc: \***    CLOSE the required files
1944: 31bc: \***
1945: 31bc: \********************************************************************
1946: 31bc: 
1947: 31bc: TERMINATION:
1948: 31cc: 
1949: 31cc:     SB.ACTION$ = "C"
1950: 31e3:     SB.STRING$ = ""
1951: 31fa: 
1952: 31fa:     SB.INTEGER% = POGDE.SESS.NUM%
1953: 3210:     CLOSE SB.INTEGER%
1954: 3224:     GOSUB SB.FILE.UTILS
1955: 3236: 
1956: 3236:     SB.INTEGER% = POGOK.SESS.NUM%
1957: 324c:     CLOSE SB.INTEGER%
1958: 3260:     GOSUB SB.FILE.UTILS
1959: 3272: 
1960: 3272:     SB.INTEGER% = SRPDF.SESS.NUM%
1961: 3288:     CLOSE SB.INTEGER%
1962: 329c:     GOSUB SB.FILE.UTILS
1963: 32ae: 
1964: 32ae:     SB.INTEGER% = SRPOG.SESS.NUM%
1965: 32c4:     CLOSE SB.INTEGER%
1966: 32d8:     GOSUB SB.FILE.UTILS
1967: 32ea: 
1968: 32ea:     SB.INTEGER% = SRMOD.SESS.NUM%
1969: 3300:     CLOSE SB.INTEGER%
1970: 3314:     GOSUB SB.FILE.UTILS
1971: 3326: 
1972: 3326:     SB.INTEGER% = SRSXF.SESS.NUM%
1973: 333c:     CLOSE SB.INTEGER%
1974: 3350:     GOSUB SB.FILE.UTILS
1975: 3362: 
1976: 3362: RETURN
1977: 3372: 
1978: 3372: \********************************************************************
1979: 3372: \***
1980: 3372: \***    SUBROUTINE      :       START.SRP5
1981: 3372: \***
1982: 3372: \********************************************************************
1983: 3372: 
1984: 3372: 
1985: 3372: START.SRP5:
1986: 3382: 
1987: 3382:    file$ = "ADX_UPGM:SRP05.286"
1988: 3397:    parm$ = comm.tail$
1989: 33b0:    text$ = "S&R MAPPING LOAD - Started by SRP10 -"                  \
1990: 3431:          + MID$(TIME$,1,2) + ":"                                    \
1991: 3431:          + MID$(TIME$,3,2) + ":"                                    \
1992: 3431:          + MID$(TIME$,5,2)                                          !
1993: 3431:    rc%   = ADXSTART(file$, parm$, text$)
1994: 345c:    IF rc% <> 0 THEN BEGIN
1995: 346b:       srp10.event% = 8
1996: 3478:       GOSUB LOG.EVENT
1997: 348a:    ENDIF
1998: 3492: 
1999: 3492: RETURN
2000: 34a2: 
2001: 34a2: \********************************************************************
2002: 34a2: \***
2003: 34a2: \***    SUBROUTINE      :       START.SRP6
2004: 34a2: \***
2005: 34a2: \********************************************************************
2006: 34a2: 
2007: 34a2: 
2008: 34a2: START.SRP6:
2009: 34b2: 
2010: 34b2:    file$ = "ADX_UPGM:SRP06.286"
2011: 34c7:    parm$ = comm.tail$
2012: 34e0:    text$ = "S&R Housekeeping + Index from SRP10 -"                  \
2013: 3561:          + MID$(TIME$,1,2) + ":"                                    \
2014: 3561:          + MID$(TIME$,3,2) + ":"                                    \
2015: 3561:          + MID$(TIME$,5,2)                                          !
2016: 3561:    rc%   = ADXSTART(file$, parm$, text$)
2017: 358c:    IF rc% <> 0 THEN BEGIN
2018: 359b:       srp10.event% = 8
2019: 35a8:       GOSUB LOG.EVENT
2020: 35ba:    ENDIF
2021: 35c2: 
2022: 35c2: RETURN
2023: 35d2: 
2024: 35d2: \********************************************************************
2025: 35d2: \***
2026: 35d2: \***    SUBROUTINE      :       CREATE.SRPOG
2027: 35d2: \***
2028: 35d2: \********************************************************************
2029: 35d2: 
2030: 35d2: CREATE.SRPOG:
2031: 35e2: 
2032: 35e2:    IF END #SRPOG.SESS.NUM% THEN CREATE.ERROR
2033: 35fe:    CURRENT.REPORT.NUM% = SRPOG.REPORT.NUM%
2034: 3614:    
2035: 3614:    ! Planner refresh from Inctactix has been increased over time so     ! CRG 
2036: 3614:    ! increasing the file capacity to double of its current size         ! CRG 
2037: 3614:    
2038: 3614:    ! CREATE POSFILE SRPOG.FILE.NAME$ KEYED 4,,,3000                     ! DRG
2039: 3614: 
2040: 3614:      CREATE POSFILE SRPOG.FILE.NAME$ KEYED 4,,,6000                   \ ! CRG
2041: 364b:           RECL SRPOG.RECL% AS SRPOG.SESS.NUM% MIRRORED ATCLOSE
2042: 364b: 
2043: 364b:    no.pog.file% = 0
2044: 3658: 
2045: 3658:    RETURN
2046: 3668: 
2047: 3668: \********************************************************************
2048: 3668: \***
2049: 3668: \***    SUBROUTINE      :       CREATE.SRMOD
2050: 3668: \***
2051: 3668: \********************************************************************
2052: 3668: 
2053: 3668: 
2054: 3668: CREATE.SRMOD:
2055: 3678: 
2056: 3678:    IF END #SRMOD.SESS.NUM% THEN CREATE.ERROR
2057: 3694:    CURRENT.REPORT.NUM% = SRMOD.REPORT.NUM%
2058: 36aa:    
2059: 36aa:    ! Planner refresh from inctactix has been increased over time so     ! CRG 
2060: 36aa:    ! increasing the file capacity to double of its current size         ! CRG 
2061: 36aa:    ! CREATE POSFILE SRMOD.FILE.NAME$ KEYED 6,,,4000                     ! DRG
2062: 36aa: 
2063: 36aa:      CREATE POSFILE SRMOD.FILE.NAME$ KEYED 6,,,8000                   \ ! CRG
2064: 36e1:           RECL SRMOD.RECL% AS SRMOD.SESS.NUM% MIRRORED ATCLOSE
2065: 36e1: 
2066: 36e1:    no.mod.file% = 0
2067: 36ee: 
2068: 36ee:    RETURN
2069: 36fe: 
2070: 36fe: \********************************************************************
2071: 36fe: \***
2072: 36fe: \***    SUBROUTINE      :       DISPLAY.MSG
2073: 36fe: \***
2074: 36fe: \********************************************************************
2075: 36fe: 
2076: 36fe: DISPLAY.MSG:
2077: 370e: 
2078: 370e:    mess$ = LEFT$(mess$ + STRING$(36," "), 36) + " "                 \
2079: 37d3:          + MID$(TIME$,1,2) + ":"                                    \
2080: 37d3:          + MID$(TIME$,3,2) + ":"                                    \
2081: 37d3:          + MID$(TIME$,5,2)                                          !
2082: 37d3: 
2083: 37d3:    IF bg% = 1 THEN BEGIN
2084: 37e2:       CALL ADXSERVE (rc4%, 26, 0, mess$)
2085: 381c:    ENDIF ELSE BEGIN
2086: 3824:       PRINT mess$
2087: 3839:    ENDIF
2088: 3841: 
2089: 3841: RETURN
2090: 3851: 
2091: 3851: \********************************************************************
2092: 3851: \***
2093: 3851: \***    SUBROUTINE      :       LOG.EVENT
2094: 3851: \***
2095: 3851: \***    srp10.event% = 1 - Header not 1st record in Delta file
2096: 3851: \***                   2 - Duplicate Delta File
2097: 3851: \***                   3 - Old Delta File
2098: 3851: \***                   4 - Premature eof on Delta file
2099: 3851: \***                   5 - Delta received - no existing POG/MOD file
2100: 3851: \***                   6 - ID of module record <> ID of POG Header
2101: 3851: \***                   7 - POG module records < POG module count
2102: 3851: \***                   8 - ADXSTART error
2103: 3851: \***
2104: 3851: \********************************************************************
2105: 3851: 
2106: 3851: LOG.EVENT:
2107: 3861: 
2108: 3861:    IF srp10.event% <  1                                             \
2109: 3880:    OR srp10.event% >  8 THEN BEGIN
2110: 3880:       GOTO 0
2111: 388b:    ENDIF
2112: 3893: 
2113: 3893:    message.no%   = 0
2114: 38a1: 
2115: 38a1:    ON srp10.event% GOSUB 1, 2, 3, 4, 5, 6, 7, 8
2116: 38c9: 
2117: 38c9: 0:
2118: 38d9:    srp10.event% = 0
2119: 38e6: 
2120: 38e6: RETURN
2121: 38f6: 
2122: 38f6: 1:
2123: 3906:    event.no%     = 17
2124: 3914:    var.string.1$ = RIGHT$("000" + STR$(POGDE.REPORT.NUM%),3)        \
2125: 3995:                  + "00 " + LEFT$(rectyp$ + "   ",3)
2126: 3995:    var.string.2$ = ""
2127: 39aa:    GOTO LOG.IT
2128: 39b5: 
2129: 39b5: 2:
2130: 39c5:    event.no%     = 177
2131: 39d3:    var.string.1$ = CHR$(SHIFT(POGDE.REPORT.NUM%,8))                 \
2132: 3a33:                  + CHR$(SHIFT(POGDE.REPORT.NUM%,0))                 \
2133: 3a33:                  + "D"
2134: 3a33:    var.string.2$ = ""
2135: 3a48:    GOTO LOG.IT
2136: 3a53: 
2137: 3a53: 3:
2138: 3a63:    event.no%     = 177
2139: 3a71:    var.string.1$ = CHR$(SHIFT(POGDE.REPORT.NUM%,8))                 \
2140: 3ad1:                  + CHR$(SHIFT(POGDE.REPORT.NUM%,0))                 \
2141: 3ad1:                  + "O"
2142: 3ad1:    var.string.2$ = ""
2143: 3ae6:    GOTO LOG.IT
2144: 3af1: 
2145: 3af1: 4:
2146: 3b01:    ! (Serial number not logged)
2147: 3b01:    event.no%     = 92
2148: 3b0f:    var.string.1$ = CHR$(SHIFT(POGDE.REPORT.NUM%,8))                 \
2149: 3bf5:                  + CHR$(SHIFT(POGDE.REPORT.NUM%,0))                 \
2150: 3bf5:                  + PACK$(RIGHT$("00000000" +STR$(tlr.cnt%),8))      \
2151: 3bf5:                  + PACK$(RIGHT$("00000000" +STR$(rec.cnt%),8))
2152: 3bf5:    var.string.2$ = ""
2153: 3c0a:    GOTO LOG.IT
2154: 3c15: 
2155: 3c15: 5:
2156: 3c25:    event.no%     = 178
2157: 3c33:    IF no.pog.file% THEN BEGIN
2158: 3c42:       work$ = "SRPOG"
2159: 3c59:    ENDIF ELSE BEGIN
2160: 3c61:       work$ = "     "
2161: 3c76:    ENDIF
2162: 3c7e:    IF no.mod.file% THEN BEGIN
2163: 3c8d:       work$ = work$                                                 \
2164: 3caf:             + "SRMOD"
2165: 3caf:    ENDIF ELSE BEGIN
2166: 3cb7:       work$ = work$                                                 \
2167: 3cd7:             + "     "
2168: 3cd7:    ENDIF
2169: 3cdf:    var.string.1$ = work$
2170: 3cf8:    var.string.2$ = ""
2171: 3d0d:    work$         = ""
2172: 3d22:    GOTO LOG.IT
2173: 3d2d: 
2174: 3d2d: 6:
2175: 3d3d:    event.no%     = 181
2176: 3d4b:    work$         = STRING$(8,CHR$(0))
2177: 3d6a:    CALL PUTN4(work$,0,VAL(UNPACK$(MID$(POGDE.RCD$,2,3))))
2178: 3da9:    CALL PUTN4(work$,4,SRPOG.POGID%)
2179: 3dce:    var.string.1$ = CHR$(SHIFT(POGDE.REPORT.NUM%,8))                 \
2180: 3e32:                  + CHR$(SHIFT(POGDE.REPORT.NUM%,0))                 \
2181: 3e32:                  + work$
2182: 3e32:    var.string.2$ = ""
2183: 3e47:    GOTO LOG.IT
2184: 3e52: 
2185: 3e52: 7:
2186: 3e62:    event.no%     = 182
2187: 3e70:    work$     = STRING$(2,CHR$(0))
2188: 3e8f:    CALL PUTN1(work$,0,mod.cnt%)
2189: 3eae:    CALL PUTN1(work$,1,SRPOG.MODULE.COUNT%)
2190: 3ed1:    var.string.1$ = CHR$(SHIFT(POGDE.REPORT.NUM%,8))                 \
2191: 3f35:                  + CHR$(SHIFT(POGDE.REPORT.NUM%,0))                 \
2192: 3f35:                  + work$
2193: 3f35:    var.string.2$ = ""
2194: 3f4a:    GOTO LOG.IT
2195: 3f54: 
2196: 3f54: 8:
2197: 3f64:    event.no%     =  42
2198: 3f72:    var.string.1$ = STR$(rc%)
2199: 3f8e:    var.string.2$ = ""
2200: 3fa3: 
2201: 3fa3: LOG.IT:
2202: 3fb3: 
2203: 3fb3:    CALL APPLICATION.LOG(message.no%,                                \
2204: 3fdc:                         var.string.1$,                              \
2205: 3fdc:                         var.string.2$,                              \
2206: 3fdc:                         event.no%)
2207: 3fdc: 
2208: 3fdc: RETURN
2209: 3fec: 
2210: 3fec: \********************************************************************
2211: 3fec: \***
2212: 3fec: \***    SUBROUTINE      :       SB.FILE.UTILS
2213: 3fec: \***
2214: 3fec: \********************************************************************
2215: 3fec: \***
2216: 3fec: \***      Allocate/report/de-allocate a file session number
2217: 3fec: \***
2218: 3fec: \********************************************************************
2219: 3fec: \***
2220: 3fec: \***      Parameters : 2 or 3 (depending on action)
2221: 3fec: \***
2222: 3fec: \***         SB.ACTION$  = "O" for allocate file session number
2223: 3fec: \***                       "R" for report file session number
2224: 3fec: \***                       "C" for de-allocate file session number
2225: 3fec: \***
2226: 3fec: \***         SB.INTEGER% = file reporting number for action "O" or
2227: 3fec: \***                       file session number for actions "R" or "C"
2228: 3fec: \***
2229: 3fec: \***         SB.STRING$  = logical file name for action "O" or
2230: 3fec: \***                       null ("") for action "R" and "C"
2231: 3fec: \***
2232: 3fec: \***      Output : 1 or 2 (depending on action)
2233: 3fec: \***
2234: 3fec: \***         SB.FILE.NAME$     = logical file name for action "R"
2235: 3fec: \***
2236: 3fec: \***         SB.FILE.SESS.NUM% = file session number for action "O"
2237: 3fec: \***                             or undefined for action "C"
2238: 3fec: \***         OR
2239: 3fec: \***         SB.FILE.REP.NUM%  = file reporting number for action "R"
2240: 3fec: \***                             or undefined for action "C"
2241: 3fec: \***
2242: 3fec: \********************************************************************
2243: 3fec: 
2244: 3fec: SB.FILE.UTILS:
2245: 3ffc: 
2246: 3ffc:     CALL SESS.NUM.UTILITY(SB.ACTION$, SB.INTEGER%, SB.STRING$)
2247: 4029: 
2248: 4029:     IF SB.ACTION$ = "O" THEN BEGIN
2249: 4047: 
2250: 4047:         SB.FILE.SESS.NUM% = F20.INTEGER.FILE.NO%
2251: 405f: 
2252: 405f:     ENDIF ELSE IF SB.ACTION$ = "R" THEN BEGIN
2253: 407d: 
2254: 407d:         SB.FILE.REP.NUM% = F20.INTEGER.FILE.NO%
2255: 4093:         SB.FILE.NAME$ = F20.FILE.NAME$
2256: 40b1: 
2257: 40b1:     ENDIF
2258: 40b9: 
2259: 40b9: RETURN
2260: 40c9: 
2261: 40c9: \********************************************************************
2262: 40c9: \***
2263: 40c9: \***    SUBROUTINE      :       CREATE.ERROR
2264: 40c9: \***
2265: 40c9: \********************************************************************
2266: 40c9: 
2267: 40c9: CREATE.ERROR:
2268: 40d9: 
2269: 40d9:    FILE.OPERATION$ = "C"
2270: 40f0: 
2271: 40f0:    GOSUB FILE.ERROR
2272: 4102: 
2273: 4102:    GOTO TIDY.END.PROG
2274: 410d: 
2275: 410d: RETURN
2276: 411d: 
2277: 411d: \********************************************************************
2278: 411d: \********************************************************************
2279: 411d: \***
2280: 411d: \***    E N D  O F  L O W  L E V E L  S U B R O U T I N E S
2281: 411d: \***
2282: 411d: \********************************************************************
2283: 411d: \********************************************************************
2284: 411d: 
2285: 411d: 
2286: 411d: \********************************************************************
2287: 411d: \********************************************************************
2288: 411d: \***
2289: 411d: \***    S T A R T  O F  E R R O R  R O U T I N E S
2290: 411d: \***
2291: 411d: \********************************************************************
2292: 411d: \********************************************************************
2293: 411d: \********************************************************************
2294: 411d: \***
2295: 411d: \***    ERROR ROUTINE   :       FILE.ERROR
2296: 411d: \***
2297: 411d: \********************************************************************
2298: 411d: 
2299: 411d: FILE.ERROR:
2300: 412d: 
2301: 412d:     IF SB.ACTION$ = "C" THEN RETURN             ! Ignore close errs
2302: 4153: 
2303: 4153:     event.no%   = 106
2304: 4161:     message.no% = 0
2305: 416f: 
2306: 416f:     file.no$ = CHR$(SHIFT(CURRENT.REPORT.NUM%,8)) +                 \
2307: 41c0:                CHR$(SHIFT(CURRENT.REPORT.NUM%,0))
2308: 41c0: 
2309: 41c0:     var.string.2$ = RIGHT$("000" + STR$(CURRENT.REPORT.NUM%),3)
2310: 4208: 
2311: 4208:     IF FILE.OPERATION$ = "R" THEN BEGIN
2312: 4229:         IF no.read% < 60                                             \
2313: 4254:        AND CURRENT.REPORT.NUM% = POGOK.REPORT.NUM% THEN BEGIN
2314: 4254:            WAIT ; 500
2315: 426b:            no.read% = no.read% +1
2316: 4279:         ENDIF ELSE BEGIN
2317: 4281:            var.string.2$ = var.string.2$                            \
2318: 42ad:                          + UNPACK$(CURRENT.CODE$)
2319: 42ad:         ENDIF
2320: 42b5:     ENDIF
2321: 42bd: 
2322: 42bd:     var.string.1$ = FILE.OPERATION$ +                               \
2323: 42f4:                     file.no$ +                                      \
2324: 42f4:                     PACK$(STRING$(12,"0"))
2325: 42f4: 
2326: 42f4:     CALL APPLICATION.LOG(message.no%,                               \
2327: 431d:                          var.string.1$,                             \
2328: 431d:                          var.string.2$,                             \
2329: 431d:                          event.no%)
2330: 431d: 
2331: 431d: RETURN
2332: 432d: 
2333: 432d: \********************************************************************
2334: 432d: \***
2335: 432d: \***    ERROR ROUTINE   :       ERROR.DETECTED
2336: 432d: \***
2337: 432d: \********************************************************************
2338: 432d: 
2339: 432d: ERROR.DETECTED:
2340: 433d: 
2341: 433d:     IF ERR = "OE" AND ERRF% = 0 THEN RESUME     ! Size errors
2342: 4394:     IF ERR = "CU" THEN RESUME
2343: 43c9: 
2344: 43c9:     CALL STANDARD.ERROR.DETECTED(ERRN,                              \
2345: 43f6:                                  ERRF%,                             \
2346: 43f6:                                  ERRL,                              \
2347: 43f6:                                  ERR)
2348: 43f6: 
2349: 43f6:     err.cd$ = ERR + " rec " + str$(rec.cnt%)
2350: 442b: 
2351: 442b:     IF (srp10.error% AND 80H) = 0 THEN BEGIN
2352: 443c:        srp10.error% = srp10.error% OR 80H
2353: 444c:        RESUME TIDY.END.PROG
2354: 4465:     ENDIF ELSE BEGIN
2355: 446d:        RESUME FATAL.END.PROG
2356: 4484:     ENDIF
2357: 4491: 
2358: 4491: END
2359: 4491: End of Compilation
