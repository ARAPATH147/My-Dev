   1: 0003: 
   2: 0003: \******************************************************************************
   3: 0003: \******************************************************************************
   4: 0003: \***                                                                          *
   5: 0003: \***            PROGRAM         :       PSB99                                 *
   6: 0003: \***            AUTHOR          :       Mark Walker                           *
   7: 0003: \***            DATE WRITTEN    :       March 4th 1994                        *
   8: 0003: \***                                                                          *
   9: 0003: \***            MODULE          :       PSB9900                               *
  10: 0003: \***                                                                          *
  11: 0003: \******************************************************************************
  12: 0003: \******************************************************************************
  13: 0003: 
  14: 0003: 
  15: 0003: \******************************************************************************
  16: 0003: \******************************************************************************
  17: 0003: \***                                                                          *
  18: 0003: \***    Module Overview                                                       *
  19: 0003: \***    ---------------                                                       *
  20: 0003: \***                                                                          *
  21: 0003: \***    This program allows the user to add, change, delete or report on      *
  22: 0003: \***    operators. The following options are available :                      *
  23: 0003: \***                                                                          *
  24: 0003: \***            - Add a new operator                                          *
  25: 0003: \***            - Display operator details                                    *
  26: 0003: \***            - Change operator details                                     *
  27: 0003: \***            - Set operator password                                       *
  28: 0003: \***            - Delete an operator                                          *
  29: 0003: \***            - Report operators                                            *
  30: 0003: \***                                                                          *
  31: 0003: \******************************************************************************
  32: 0003: \******************************************************************************
  33: 0003: 
  34: 0003: \******************************************************************************
  35: 0003: \******************************************************************************
  36: 0003: \***                                                                          *
  37: 0003: \***    VERSION H.                 Mark Walker                4th March 1994  *
  38: 0003: \***    This module has been rewritten for the Controller Security package.   *
  39: 0003: \***                                                                          *
  40: 0003: \***    The re-written version excludes the pre-4690 OPEN, WRITE, TCLOSE and
  41: 0003: \***    CLOSE of printer, along with associated checking of printer status.
  42: 0003: \***
  43: 0003: \***    REVISION 1.1            ROBERT COWEY.                     26 SEP 1994.
  44: 0003: \***    Removed version letters from included code (not commented).
  45: 0003: \***    Prevented update of authorisation files following use of F3 QUIT key.
  46: 0003: \***    -Initial PVCS revision.
  47: 0003: \***    -Corrected F3=ENTER error on leaving screens.
  48: 0003: \***
  49: 0003: \***    REVISION 1.2            MIKE BISHOP                       13 JUL 2004.
  50: 0003: \***    Additional fields staff number and employee flag added.
  51: 0003: \***    -Relinked to new Printfun due to a change
  52: 0003: \***    -for printing reports for international
  53: 0003: \***
  54: 0003: \***    REVISION 1.3            Alan Carr  (AJC)                   4 Oct 2004.
  55: 0003: \***    Additional field Name on Receipt added.
  56: 0003: \***    -Changes for Beauty Commission project
  57: 0003: \***    -Operator Staff number and employee flag
  58: 0003: \***    -must now be entered
  59: 0003: \***
  60: 0003: \***    REVISION 1.4            Alan Carr  (AJC)                  31 Jan 2004.
  61: 0003: \***    Add GROUP CODE for Beauty Commisson.
  62: 0003: \***    -Added Group Code for MTSL processing
  63: 0003: \***
  64: 0003: \***    REVISION 1.5.                ROBERT COWEY.                09 JUN 2009.
  65: 0003: \***    Removed discontinued PVCS variables $Log $Workfile and $Revision.
  66: 0003: \***    Moved comments captured by these to this comment box (prefixed "-").
  67: 0003: \***    Replaced call to CHECK.FIELDS.06 with call to DELETE.AN.OPERATOR.
  68: 0003: \***    Removed variables not used by either PSB9900 or PSB9901.
  69: 0003: \***
  70: 0003: \***    Redefined PROCESS.SCREEN.06 and numerous subroutines as subprograms.
  71: 0003: \***    Separated these into new module PSB9902 to reduce code size below 64k.
  72: 0003: \***    New code segment sizes are approx 56K for PSB9900 and 15K for PSB9902.
  73: 0003: \***    If the PSB9900 code size needs to be reduced further it should be
  74: 0003: \***    possible to transfer many of the PUBLIC functions to PSB9902.
  75: 0003: \***
  76: 0003: \***    REVISION 1.6.                ROBERT COWEY.                15 JUN 2009.
  77: 0003: \***    Changes for A9C POS Improvements project creating PSB99.286 Rv 1.6.
  78: 0003: \***    Displayed operator Birth Date on all screens except reports.
  79: 0003: \***    Add Operator acreen ...
  80: 0003: \***      Forced setting of Birth Date.
  81: 0003: \***      Continued to allow zeros to be entered for Staff Number.
  82: 0003: \***    Change Operator screen ...
  83: 0003: \***      Allowed (but not forced) setting of Birth Date.
  84: 0003: \***      Prevented access to Birth Date variable if already set.
  85: 0003: \***      Allowed (but not forced) setting of Staff Number.
  86: 0003: \***      Prevented access to Staff Number variable if already set.
  87: 0003: \***
  88: 0003: \***    REVISION 1.7.                ROBERT COWEY.                20 JUL 2009.
  89: 0003: \***    Changes for A9C POS Improvements project creating PSB99.286 Rv 1.7.
  90: 0003: \***    Fix for minor bug found whilst correcting defect 3247.
  91: 0003: \***    Corrected VALID.BIRTH.DATE function message (to allow 14th birthday).
  92: 0003: \***
  93: 0003: \***    REVISION 1.8.                ROBERT COWEY.                22 JUL 2009.
  94: 0003: \***    Changes for A9C POS Improvements project creating PSB99.286 Rv 1.8.
  95: 0003: \***    Defect 3247 - Redefined AF.BIRTH.DATE$ format as UPD-hex DDMCYY.
  96: 0003: \***    Modified code to use PSB9902 date format conversion functions when
  97: 0003: \***    updating or validating AF.BIRTH.DATE$.
  98: 0003: \***    Modified VALID.BIRTH.DATE function to accept ages 14 to 99.
  99: 0003: \***
 100: 0003: \***    REVISION 1.9.                Nalini Mathusoothanan        01 AUG 2011.
 101: 0003: \***    Changes for Core 2 Release project.
 102: 0003: \***        - To enforce the Staff Number to be entered for all new users.
 103: 0003: \***        - Make the Staff Number field mandatory for Boots Employees only.
 104: 0003: \***        - Display error message when Staff Number has not been entered.
 105: 0003: \***    Change to use PRINT.REPORT function, which handles YLBP printers.
 106: 0003: \***
 107: 0003: \******************************************************************************
 108: 0003: 
 109: 0003:         %INCLUDE MODELDEC.J86
 110: 0003: \*******************************************************************************
 111: 0003: \*******************************************************************************
 112: 0003: \***
 113: 0003: \***          %INCLUDE FOR OPERATOR MODEL FILE VARIABLE DECLARATIONS
 114: 0003: \***
 115: 0003: \***                     REFERENCE : MODELDEC
 116: 0003: \***
 117: 0003: \***                     FILE TYPE : Keyed
 118: 0003: \***
 119: 0003: \***    VERSION A.               Mark Walker                     7th March 1994
 120: 0003: \***    Original version.
 121: 0003: \***
 122: 0003: \*******************************************************************************
 123: 0003: \*******************************************************************************
 124: 0003: 
 125: 0003: 
 126: 0003: \*******************************************************************************
 127: 0003: \*******************************************************************************
 128: 0003: \***
 129: 0003: \***    MODEL RECORD LAYOUT
 130: 0003: \***
 131: 0003: \***     1  2  ASC  KEY$                 Key (Model type and identifier)
 132: 0003: \***     1  1  ASC  TYPE$                Model type (T)ill or (C)ontroller
 133: 0003: \***     2  1  UPD  IDENTIFIER$          Model number '01' - '99'
 134: 0003: \***     3 20  ASC  DESCRIPTION$         Model Description
 135: 0003: \***    23  3  ASC  REPORT.DESC$         Report Description
 136: 0003: \***    26  1  ASC  DISPLAY.FLAG$        Display on Auth Screen? (Y/N)
 137: 0003: \***    27  1  ASC  EALAUTH.OPTIONSK$    EALAUTH files options key field
 138: 0003: \***    28 19  ASC  EALAUTH.FLAGS$       EALAUTH files authorisation flags
 139: 0003: \***    47  1  UPD  ADXCSOUF.USER.ID$    ADXCSOUF files user ID field
 140: 0003: \***    48  1  UPD  ADXCSOUF.GROUP.ID$   ADXCSOUF files group ID field
 141: 0003: \***    49 14  ASC  ADXCSOUF.FLAGS$      ADXCSOUF files authorisation flags
 142: 0003: \***    63  3  ASC  MODEL.NUM$           OPMOD model number
 143: 0003: \***                                       "901" Personal Service
 144: 0003: \***                                       "904" Controller Clerk
 145: 0003: \***                                       "905" Pharmacy
 146: 0003: \***                                       "908" Management
 147: 0003: \***                                       "909" Security Level One
 148: 0003: \***    66  1  ASC  SUPERVISOR.FLAG$     Till Supervisor? (Y/N)
 149: 0003: \***    67  6  ASC  FILLER$              
 150: 0003: \***
 151: 0003: \***    Record length 72
 152: 0003: \***
 153: 0003: \*******************************************************************************
 154: 0003: \*******************************************************************************
 155: 0003:  
 156: 0003:         STRING GLOBAL                   MODEL.ADXCSOUF.FLAGS$,          \
 157: 0003:                                         MODEL.ADXCSOUF.GROUP.ID$,       \
 158: 0003:                                         MODEL.ADXCSOUF.USER.ID$,        \
 159: 0003:                                         MODEL.DESCRIPTION$,             \
 160: 0003:                                         MODEL.DISPLAY.FLAG$,            \
 161: 0003:                                         MODEL.EALAUTH.FLAGS$,           \
 162: 0003:                                         MODEL.EALAUTH.OPTIONSK$,        \
 163: 0003:                                         MODEL.FILE.NAME$,               \
 164: 0003:                                         MODEL.FILLER$,                  \
 165: 0003:                                         MODEL.IDENTIFIER$,              \
 166: 0003:                                         MODEL.KEY$,                     \
 167: 0003:                                         MODEL.MODEL.NUM$,               \
 168: 0003:                                         MODEL.RECORD$,                  \
 169: 0003:                                         MODEL.REPORT.DESC$,             \
 170: 0003:                                         MODEL.SUPERVISOR.FLAG$,         \
 171: 0003:                                         MODEL.TYPE$
 172: 0003: 
 173: 0003: 
 174: 0003:         INTEGER*2 GLOBAL                MODEL.RECL%,                    \
 175: 0003:                                         MODEL.REPORT.NUM%,              \
 176: 0003:                                         MODEL.SESS.NUM%
 177: 0003:         %INCLUDE CSOUFDEC.J86
 178: 0003: \*****************************************************************************
 179: 0003: \*****************************************************************************
 180: 0003: \***
 181: 0003: \***               %INCLUDE FOR ADXCSOUF.DAT - FIELD DECLARATIONS
 182: 0003: \***                                           FILE REFERENCE PARAMETERS
 183: 0003: \***
 184: 0003: \***                      FILE TYPE    : DIRECT
 185: 0003: \***
 186: 0003: \***                      REFERENCE    : CSOUFDEA.J86
 187: 0003: \***
 188: 0003: \***      Version A             Steve Windsor                 Nov 92      
 189: 0003: \***
 190: 0003: \*****************************************************************************
 191: 0003: \*****************************************************************************
 192: 0003: 
 193: 0003: 
 194: 0003: REM \
 195: 0003: 
 196: 0003: 
 197: 0003:     STRING GLOBAL               \
 198: 0003:         CSOUF.FILE.NAME$        \
 199: 0003: 
 200: 0003:     INTEGER*2 GLOBAL            \
 201: 0003:         CSOUF.RECL%,            \
 202: 0003:         CSOUF.REPORT.NUM%,      \
 203: 0003:         CSOUF.SESS.NUM%
 204: 0003: 
 205: 0003:     INTEGER*4 GLOBAL            \
 206: 0003:         CSOUF.REC.NUM%          \
 207: 0003: 
 208: 0003: 
 209: 0003: REM \
 210: 0003: 
 211: 0003: 
 212: 0003:     STRING GLOBAL               \
 213: 0003:         CSOUF.REC$,             \ 34 bytes
 214: 0003:         CSOUF.OP.ID$,           \  8 bytes 
 215: 0003:         CSOUF.FILLER.01$,       \  1 byte
 216: 0003:         CSOUF.PSWD$,            \  8 bytes
 217: 0003:         CSOUF.FILLER.02$,       \  1 byte
 218: 0003:         CSOUF.USER.ID$,         \  1 byte UPD
 219: 0003:         CSOUF.GROUP.ID$,        \  1 byte UPD
 220: 0003:         CSOUF.FLAGS$            ! 14 bytes
 221: 0003: 
 222: 0003:         %INCLUDE AFDEC.J86
 223: 0003: 
 224: 0003: \REM
 225: 0003: \*******************************************************************************
 226: 0003: \*******************************************************************************
 227: 0003: \***
 228: 0003: \***    %INCLUDE FOR GSA AUTHORISATION FILE VARIABLE DECLARATIONS
 229: 0003: \***
 230: 0003: \***        REFERENCE   :  AFDEC (J86)
 231: 0003: \***
 232: 0003: \***        FILE TYPE   :  Keyed
 233: 0003: \***
 234: 0003: \***    The GSA Authorisation File (EALAUTH.DAT) should not be confused with
 235: 0003: \***    the Operating System Authorisation File (ADXCSOUF.DAT).
 236: 0003: \***
 237: 0003: \***    VERSION A.              ROBERT COWEY.                       18 AUG 1992.
 238: 0003: \***    Original version created by merging AFFLDD and AFNUMD.
 239: 0003: \***
 240: 0003: \***    VERSION B.              Steve Windsor                          Nov 1992.
 241: 0003: \***    Addition of new fields for the CASTLE project.
 242: 0003: \***    Supervisor flag and operator model.
 243: 0003: \***
 244: 0003: \***    VERSION C.              ROBERT COWEY.                       03 MAR 1994.
 245: 0003: \***    Defined fields DATE.PSWD.CHANGE$, and MODEL.FLAGS.1% and ...2%.
 246: 0003: \***
 247: 0003: \***    VERSION D.             Mike Bishop                          30 JUN 2004
 248: 0003: \***    Defined field AF.STAFF.NUM$ AF.EMPLOYEE.FLAG$
 249: 0003: \***
 250: 0003: \***    VERSION E.             Alan Carr  (AJC)                      4 Oct 2004
 251: 0003: \***    Defined field AF.RECEIPT.NAME$
 252: 0003: \***
 253: 0003: \***    VERSION F.             Alan Carr  (AJC)                     31 Jan 2005
 254: 0003: \***    Defined field AF.GROUP.CODE$
 255: 0003: \***
 256: 0003: \***    REVISION 1.6.                ROBERT COWEY.                15 JUN 2009.
 257: 0003: \***    Changes for A9C POS improvements project.
 258: 0003: \***    Used up last available three bytes of EALAUTH user data by redefining 
 259: 0003: \***    remaining AF.USER$ variable as AF.BIRTH.DATE$.
 260: 0003: \***    See IBM manual "GSA Programming Guide" Appendix A-27 for file layout 
 261: 0003: \***    describing INDICAT flags (and position of original 20 bytes user data).
 262: 0003: \***
 263: 0003: \***    REVISION 1.7.                ROBERT COWEY.                22 JUN 2009.
 264: 0003: \***    Changes for A9C POS improvements project creating PSB99.286 Rv 1.8.
 265: 0003: \***    Defect 3247 - Redefined AF.BIRTH.DATE$ format as UPD-hex DDMCYY.
 266: 0003: \***    Description text change only - No code changes to this file.
 267: 0003: \***
 268: 0003: \*******************************************************************************
 269: 0003: \*******************************************************************************
 270: 0003: 
 271: 0003: 
 272: 0003:     STRING GLOBAL \
 273: 0003:         AF.BIRTH.DATE$,       \ ! 3 byte DDMCYY UPD/hex format         ! 1.7 RC
 274: 0003:                               \ ! M is month  A=Oct B=Nov C=Dec        ! 1.7 RC
 275: 0003:                               \ ! C is century  0=19xx 1=20xx          ! 1.7 RC
 276: 0003:         AF.DATE.PSWD.CHANGE$, \ ! 3 bytes UPD                          ! CRC
 277: 0003:         AF.FILE.NAME$, \
 278: 0003:         AF.FLAGS.01.12$, \      ! 15 bytes
 279: 0003:         AF.FLAGS.13.16$, \      ! 4 bytes
 280: 0003:         AF.OPERATOR.NAME$,\     ! 20 bytes
 281: 0003:         AF.OPERATOR.NO$, \      ! 4 byte UPD (key)
 282: 0003:         AF.OPTIONS.KEY$, \      ! 1 byte UPD
 283: 0003:         AF.PASSWORD$, \         ! 4 byte UPD
 284: 0003:         AF.RECEIPT.NAME$, \     ! 12 bytes                             ! AJC
 285: 0003:         AF.STAFF.NUM$, \         ! 4 byte UPD                          DMB
 286: 0003:         AF.EMPLOYEE.FLAG$, \     ! 1 byte UPD                          DMB
 287: 0003:         AF.GROUP.CODE$, \       ! 1  byte UPD                          AJC
 288: 0003: \       AF.USER$, \             ! 3  bytes                             ! 1.6 RC
 289: 0003:         AF.SUP.FLAG$, \         ! 1  byte                              BSJW
 290: 0003:         AF.OP.MODEL$            ! 3  bytes                             BSJW
 291: 0003: 
 292: 0003:     INTEGER*1 GLOBAL \
 293: 0003:         AF.INDICAT4%, \
 294: 0003:         AF.INDICAT5%, \
 295: 0003:         AF.INDICAT6%, \
 296: 0003:         AF.INDICAT7%, \
 297: 0003:         AF.INDICAT8%, \
 298: 0003:         AF.INDICAT9%, \
 299: 0003:         AF.INDICAT10%, \
 300: 0003:         AF.INDICAT11%, \
 301: 0003:         AF.INDICAT12%, \
 302: 0003:         AF.INDICAT13%, \
 303: 0003:         AF.INDICAT14%, \
 304: 0003:         AF.INDICAT15%, \
 305: 0003:         AF.INDICAT16%, \
 306: 0003:         AF.REPORT.NUM%
 307: 0003: 
 308: 0003:     INTEGER*2 GLOBAL \
 309: 0003:         AF.INDICAT1%, \
 310: 0003:         AF.INDICAT2%, \
 311: 0003:         AF.INDICAT3%, \
 312: 0003:         AF.MODEL.FLAGS.1%, \                                           ! CRC
 313: 0003:         AF.MODEL.FLAGS.2%, \                                           ! CRC
 314: 0003:         AF.RECL%, \
 315: 0003:         AF.SESS.NUM%
 316: 0003: 
 317: 0003:         %INCLUDE OPAUDDEC.J86
 318: 0003: \*******************************************************************************
 319: 0003: \*******************************************************************************
 320: 0003: \***
 321: 0003: \***   %INCLUDE FOR OPERATOR AUTHORISATION AUDIT FILE VARIABLE DECLARATIONS
 322: 0003: \***
 323: 0003: \***                     REFERENCE : OPAUDDEC
 324: 0003: \***
 325: 0003: \***                     FILE TYPE : Direct
 326: 0003: \***
 327: 0003: \***    VERSION A.               Mark Walker                  22nd March 1994
 328: 0003: \***    Original version.
 329: 0003: \***
 330: 0003: \*******************************************************************************
 331: 0003: \*******************************************************************************
 332: 0003: 
 333: 0003:         STRING GLOBAL                   OPAUD.RECORD$,                  \
 334: 0003:                                         OPAUD.FILE.NAME$,		\
 335: 0003:                                         OPAUD.DATE$,			\
 336: 0003: 					OPAUD.TIME$,			\
 337: 0003: 					OPAUD.CURRENT.ID$,		\
 338: 0003: 					OPAUD.CHANGED.ID$,		\
 339: 0003: 					OPAUD.OPTION$,			\
 340: 0003: 					OPAUD.DETAILS.1$,		\
 341: 0003: 					OPAUD.DETAILS.2$,		\
 342: 0003: 					OPAUD.FILLER$,			\
 343: 0003: 					OPAUD.CRLF$,			\
 344: 0003: 					OPAUD.LAST.REC.UPDATED$,	\
 345: 0003: 					OPAUD.FILE.SIZE$
 346: 0003: 
 347: 0003:         INTEGER*2 GLOBAL                OPAUD.RECL%,                    \
 348: 0003:                                         OPAUD.REPORT.NUM%,              \
 349: 0003:                                         OPAUD.SESS.NUM%,                \
 350: 0003:                                         OPAUD.REC.NUM%
 351: 0003:         %INCLUDE PRINTDEC.J86
 352: 0003: 
 353: 0003: REM \
 354: 0003: \*******************************************************************************
 355: 0003: \*******************************************************************************
 356: 0003: \***
 357: 0003: \***    %INCLUDE FOR PRINT FILE VARIABLE DECLARATIONS
 358: 0003: \***
 359: 0003: \***        REFERENCE   :   PRINTDE (J86)
 360: 0003: \***
 361: 0003: \***        FILE TYPE   :   Printer / Labeller
 362: 0003: \***
 363: 0003: \***    VERSION A.              ANDREW WEDGEWORTH                   09 JUL 1992.
 364: 0003: \***    Original version created by merging PRINTFLG and PRINTNUG.
 365: 0003: \***
 366: 0003: \***    VERSION B.              UNKNOWN.                            ?? ??? 1992.
 367: 0003: \***    Changes unknown.             
 368: 0003: \***
 369: 0003: \***    VERSION C.              ROBERT COWEY.                       18 NOV 1992.
 370: 0003: \***    No changes made to this file.
 371: 0003: \***
 372: 0003: \***    Version D               Andrew Wedgeworth                 24th May 1992
 373: 0003: \***    Variable added to contain condensed print record length.
 374: 0003: \***
 375: 0003: \*******************************************************************************
 376: 0003: \*******************************************************************************
 377: 0003: 
 378: 0003: 
 379: 0003:     STRING GLOBAL \
 380: 0003:         PRINT.LINE$, \
 381: 0003:         PRINT.FILE.NAME$, \
 382: 0003:         SELF.LAN.NAME$, \
 383: 0003:         SELF.NOLAN.NAME$
 384: 0003: 
 385: 0003:     INTEGER*2 GLOBAL \
 386: 0003:         PRINT.CONDENSED.RECL%, \                                       ! DAW  
 387: 0003:         PRINT.SESS.NUM%, \
 388: 0003:         PRINT.REPORT.NUM%, \
 389: 0003:         PRINT.REPORT.RECL%, \
 390: 0003:         PRINT.SELF.RECL%
 391: 0003: 
 392: 0003:         %INCLUDE PPDFDEC.J86
 393: 0003: 
 394: 0003: \REM
 395: 0003: \*******************************************************************************
 396: 0003: \*******************************************************************************
 397: 0003: \***
 398: 0003: \***    %INCLUDE FOR PHARMACY PASSWORD DETAILS FILES VARIABLE DECLARATIONS
 399: 0003: \***
 400: 0003: \***        REFERENCE   :   PPDFDEC (J86)
 401: 0003: \***
 402: 0003: \***        FILE TYPE   :   Direct
 403: 0003: \***
 404: 0003: \***    VERSION A.              ROBERT COWEY.                       21 FEB 1994.
 405: 0003: \***    Original version.
 406: 0003: \***
 407: 0003: \*******************************************************************************
 408: 0003: \*******************************************************************************
 409: 0003: 
 410: 0003: 
 411: 0003: \*******************************************************************************
 412: 0003: \*******************************************************************************
 413: 0003: \***
 414: 0003: \***    PPDF RECORD LAYOUT
 415: 0003: \***
 416: 0003: \***     1  3  UPD  DATE.LAST.PSWD$      Date of last password change (YYMMDD)
 417: 0003: \***     4  1  UPD  PSWD.DURATION$       Password duration (days)
 418: 0003: \***     5  1  ASC  INTERMEDIATE.FLAG$   "Y" PHRML and ADXCSOUF passwords
 419: 0003: \***                                         maintained in parallel (identical)
 420: 0003: \***                                     "N" PHRML and EALAUTH passwords differ
 421: 0003: \***     6 11  ASC  FILLER$              Spaces
 422: 0003: \***
 423: 0003: \***    Record length 16
 424: 0003: \***
 425: 0003: \*******************************************************************************
 426: 0003: \*******************************************************************************
 427: 0003: 
 428: 0003:  
 429: 0003:     STRING GLOBAL \
 430: 0003:         PPDF.DATE.LAST.PSWD$, \
 431: 0003:         PPDF.FILE.NAME$, \
 432: 0003:         PPDF.FILLER$, \
 433: 0003:         PPDF.INTERMEDIATE.FLAG$, \
 434: 0003:         PPDF.PSWD.DURATION$
 435: 0003: 
 436: 0003: 
 437: 0003:     INTEGER*2 GLOBAL \
 438: 0003:         PPDF.RECL%, \
 439: 0003:         PPDF.REPORT.NUM%, \
 440: 0003:         PPDF.SESS.NUM%
 441: 0003: 
 442: 0003: 
 443: 0003:     INTEGER*4 GLOBAL \
 444: 0003:         PPDF.REC.NUM%
 445: 0003: 
 446: 0003:         %INCLUDE PHRMLDEC.J86
 447: 0003: 
 448: 0003: \REM
 449: 0003: \*******************************************************************************
 450: 0003: \*******************************************************************************
 451: 0003: \***
 452: 0003: \***    %INCLUDE FOR PHARMACY LOCAL FILES VARIABLE DECLARATIONS
 453: 0003: \***
 454: 0003: \***        REFERENCE   :   PHRMLDE (J86)
 455: 0003: \***
 456: 0003: \***        FILE TYPE   :   Accessed as dircet
 457: 0003: \***
 458: 0003: \***    VERSION A.              ROBERT COWEY.                       24 MAR 1994.
 459: 0003: \***    Original version dealing with Pharmacy password field only.
 460: 0003: \***
 461: 0003: \*******************************************************************************
 462: 0003: \*******************************************************************************
 463: 0003: 
 464: 0003: 
 465: 0003: \*******************************************************************************
 466: 0003: \*******************************************************************************
 467: 0003: \***
 468: 0003: \***    PHRML FILE LAYOUT
 469: 0003: \***
 470: 0003: \***        1  32499  ASC  Not referenced   Pharmacy specific information
 471: 0003: \***    32500      9  ASC  PASSWORD$        First nine bytes of ten byte 
 472: 0003: \***                                        Pharmacy password
 473: 0003: \***        *      3  ASC                   Non encrypted ASC password
 474: 0003: \***        *      6  ASC                   Unused bytes set to CHR$(0)
 475: 0003: \***    32509    101  ASC  Not referenced   Pharmacy specific information
 476: 0003: \***
 477: 0003: \***    Record length 9 (to facilitate easy access to password field)
 478: 0003: \***
 479: 0003: \*******************************************************************************
 480: 0003: \*******************************************************************************
 481: 0003: 
 482: 0003:  
 483: 0003:     STRING GLOBAL \
 484: 0003:         PHRML.FILE.NAME$, \
 485: 0003:         PHRML.PASSWORD$
 486: 0003: 
 487: 0003: 
 488: 0003:     INTEGER*2 GLOBAL \
 489: 0003:         PHRML.RECL%, \
 490: 0003:         PHRML.REPORT.NUM%, \
 491: 0003:         PHRML.SESS.NUM%
 492: 0003: 
 493: 0003: 
 494: 0003:     INTEGER*4 GLOBAL \
 495: 0003:         PHRML.REC.NUM%
 496: 0003: 
 497: 0003: 
 498: 0003:         %INCLUDE PSBF03G.J86   ! Display Manager
 499: 0003: REM \
 500: 0003: \*******************************************************************************
 501: 0003: \***
 502: 0003: \***      INCLUDED CODE FOR DISPLAY MANAGER FUNCTIONS GLOBAL DECLARATIONS
 503: 0003: \***
 504: 0003: \***                    REFERENCE :  PSBF03G.J86
 505: 0003: \***              
 506: 0003: \***      Version A                                        21st March 1986
 507: 0003: \***
 508: 0003: \***      Version B          Andrew Wedgeworth              27th July 1992
 509: 0003: \***      Removal of F03.RETURN.CODE% which is no longer used.
 510: 0003: \***
 511: 0003: \*******************************************************************************
 512: 0003: 
 513: 0003:    ! 1 line deleted from here                                          ! BAW
 514: 0003:    INTEGER*2   GLOBAL   F03.RETURNED.INTEGER%    ! from IBM Display Manager
 515: 0003:    STRING      GLOBAL   F03.RETURNED.STRING$     ! from IBM Display Manager
 516: 0003: 
 517: 0003: 
 518: 0003: 
 519: 0003: 
 520: 0003: 
 521: 0003: 
 522: 0003:         %INCLUDE PSBF20G.J86   ! Session Number Utility
 523: 0003: REM\
 524: 0003: \*******************************************************************************
 525: 0003: \*******************************************************************************
 526: 0003: \***
 527: 0003: \***     %INCLUDE GLOBAL VARIABLE DEFINITIONS FOR SESS.NUM.UTILITY FUNCTION
 528: 0003: \***
 529: 0003: \***                       REFERENCE     : PSBF20G.J86
 530: 0003: \*** 
 531: 0003: \***     Version A              Bruce Scrive                   5th May 1988   
 532: 0003: \*** 
 533: 0003: \***     Version B              Robert Cowey                   7th May 1991
 534: 0003: \***     Global variable F20.INTEGER.FILE.NO% changed from one byte integer
 535: 0003: \***     to two byte integer.
 536: 0003: \***
 537: 0003: \***     Version D              Andrew Wedgeworth             1st July 1992
 538: 0003: \***     F20.RETURN.CODE% removed as it is no longer required.
 539: 0003: \***
 540: 0003: \*******************************************************************************
 541: 0003: \*******************************************************************************
 542: 0003: 
 543: 0003:       STRING    GLOBAL F20.FILE.NAME$,                                 \
 544: 0003:                        F20.STRING.FILE.NO$,                            \
 545: 0003:                        F20.TABLE.DIMENSIONED.FLAG$,                    \
 546: 0003:                        SESS.NUM.TABLE$(1)
 547: 0003: 
 548: 0003:       INTEGER*2 GLOBAL F20.INTEGER.FILE.NO%
 549: 0003: 
 550: 0003:       ! 1 line deleted from here                                       ! DAW 
 551: 0003: 
 552: 0003: 
 553: 0003:         %INCLUDE PSBUSEG.J86
 554: 0003: \/*********************************************************************/ PSBUSEG
 555: 0003: \/*                                                                   */ PSBUSEG
 556: 0003: \/* PSBUSEG.J86  -  Definitions for Chain/Use with PSB Screen Program */ PSBUSEG
 557: 0003: \/* ----------------------------------------------------------------- */ PSBUSEG
 558: 0003: \/*                                                                   */ PSBUSEG
 559: 0003: \/*********************************************************************/ PSBUSEG
 560: 0003:                                                                        ! PSBUSEG
 561: 0003:         STRING GLOBAL  PSBCHN.PRG,      \ Program to chain to          ! PSBUSEG
 562: 0003:                        PSBCHN.OP,       \ Operator Id                  ! PSBUSEG
 563: 0003:                        PSBCHN.APP,      \ Program chained from         ! PSBUSEG
 564: 0003:                        PSBCHN.MENCON,   \ Menu Control                 ! PSBUSEG
 565: 0003:                        PSBCHN.U1,       \ User parameter               ! PSBUSEG
 566: 0003:                        PSBCHN.U2,       \ User parameter               ! PSBUSEG
 567: 0003:                        PSBCHN.U3        ! User parameter               ! PSBUSEG
 568: 0003:                                                                        ! PSBUSEG
 569: 0003: 
 570: 0003:         STRING GLOBAL           BATCH.SCREEN.FLAG$,                    \
 571: 0003:                                 CHAIN.TO.PROG$,                        \
 572: 0003:                                 CURSOR.STATE$,                         \
 573: 0003: \ 1.5 RC                        INITIAL.DATA$,                         \
 574: 0003:                                 INVISIBLE$,                            \
 575: 0003: \ 1.5 RC                        SAVED.STRING$,                         \
 576: 0003:                                 LAST.MESSAGE$,                         \
 577: 0003:                                 MODULE.NUMBER$,                        \
 578: 0003:                                 OPERATOR.NUMBER$,                      \
 579: 0003:                                 SB.ACTION$,                            \
 580: 0003:                                 SB.FILE.NAME$,                         \
 581: 0003:                                 SB.STRING$,                            \
 582: 0003:                                 STRING.DATA$,                          \
 583: 0003:                                 VAR.STRING.1$,                         \
 584: 0003:                                 VAR.STRING.2$,                         \
 585: 0003:                                 VISIBLE$,                              \
 586: 0003:                                 DISPLAY.MESSAGE.TEXT$,                 \
 587: 0003:                                 CURSOR.ON$,                            \
 588: 0003:                                 CURSOR.OFF$,                           \
 589: 0003:                                 CHAR$,                                 \
 590: 0003:                                 FILE.OPERATION$,                       \
 591: 0003:                                 FILE.NO$,                              \
 592: 0003:                                 CURRENT.CODE$,                         \
 593: 0003:                                 WORKFILE.FILE.NAME$                    ! 1.9 NM
 594: 0003: 
 595: 0003:         INTEGER*1 GLOBAL        EVENT.NO%,                             \
 596: 0003:                                 TRUE,FALSE,                            \
 597: 0003:                                 EXIT.KEY.PRESSED(1)
 598: 0003: 
 599: 0003:         INTEGER*2 GLOBAL        CURRENT.REPORT.NUM%,                   \
 600: 0003:                                 SB.INTEGER%,                           \
 601: 0003:                                 SB.FILE.REP.NUM%,                      \
 602: 0003:                                 SB.FILE.SESS.NUM%,                     \
 603: 0003:                                 CURSOR.POSITION%,                      \
 604: 0003:                                 DISPLAY.MESSAGE.NUMBER%,               \
 605: 0003:                                 INTEGER.DATA%,                         \
 606: 0003:                                 RETURN.FIELD%,                         \
 607: 0003: \ 1.5 RC                        P%,                                    \
 608: 0003:                                 I%,                                    \
 609: 0003:                                 J%,                                    \
 610: 0003: \ 1.5 RC                        C%,                                    \
 611: 0003:                                 S%,                                    \
 612: 0003:                                 FUNCTION.KEY%,                         \
 613: 0003: \ 1.5 RC                        KEY.SELECTED%,                         \
 614: 0003:                                 MESSAGE.NO%,                           \
 615: 0003:                                 OLD.POSITION%,                         \
 616: 0003:                                 SAVED.POSITION%,                       \
 617: 0003:                                 HELP.KEY%,                             \
 618: 0003:                                 QUIT.KEY%,                             \
 619: 0003:                                 END.KEY%,                              \
 620: 0003:                                 HOME.KEY%,                             \
 621: 0003:                                 TAB.KEY%,                              \
 622: 0003:                                 BTAB.KEY%,                             \
 623: 0003:                                 ESC.KEY%,                              \
 624: 0003:                                 ENTER.KEY%,                            \
 625: 0003:                                 PGUP.KEY%,                             \
 626: 0003:                                 PGDN.KEY%,                             \
 627: 0003:                                 F7UP.KEY%,                             \
 628: 0003:                                 F8DN.KEY%,                             \
 629: 0003:                                 INVISIBLE.FIELD%,                      \
 630: 0003:                                 WORKFILE.REPORT.NUM%,                  \ 1.9 NM
 631: 0003:                                 WORKFILE.SESS.NUM%                     ! 1.9 NM
 632: 0003: 
 633: 0003:         STRING GLOBAL           BIRTH.DATE$, \ ! DDMMCCYY              ! 1.6 RC
 634: 0003:                                 OPTION$,                               \
 635: 0003:                                 OPERATOR.ID$,                          \
 636: 0003:                                 OPERATOR.NAME$,                        \
 637: 0003:                                 OPERATOR.PASSWORD$,                    \
 638: 0003:                                 MODEL.FLAG$,                           \
 639: 0003:                                 CONFIRM$,                              \
 640: 0003:                                 TILL.MODEL.FLAG$(1),                   \
 641: 0003:                                 CTLR.MODEL.FLAG$(1),                   \
 642: 0003:                                 TILL.MODEL.NAME$(1),                   \
 643: 0003:                                 CTLR.MODEL.NAME$(1),                   \
 644: 0003:                                 TILL.MODEL.RECORD$(1),                 \
 645: 0003:                                 CTLR.MODEL.RECORD$(1),                 \
 646: 0003:                                 TODAYS.DATE$,                          \
 647: 0003:                                 CSOUF.RECORD$,                         \
 648: 0003:                                 CSOUF.OPERATION$,                      \
 649: 0003:                                 MODEL.NUMBER$,                         \
 650: 0003:                                 SUPERVISOR.FLAG$,                      \
 651: 0003:                                 OPTIONS.KEY$,                          \
 652: 0003: \ 1.5 RC                        USER.ID$,                              \
 653: 0003:                                 GROUP.ID$,                             \
 654: 0003:                                 OLD.OPERATOR.ID$,                      \
 655: 0003:                                 OLD.PASSWORD$,                         \
 656: 0003:                                 MONTH.ARRAY$(1),                       \
 657: 0003:                                 DISPLAY.DATE$,                         \
 658: 0003:                                 STAFF.NO$,                             \
 659: 0003:                                 EMPLOYEE.FLG$,                         \ AJC
 660: 0003:                                 RECEIPT.NAME$,                         \ AJC
 661: 0003:                                 GROUP.CODE$                            !\ AJC
 662: 0003: 
 663: 0003:         INTEGER*1 GLOBAL        VALID.BIRTH.DATE.FOUND,                \ 1.6 RC
 664: 0003:                                 VALID.OPTION.FOUND,                    \
 665: 0003:                                 VALID.OPERATOR.ID.FOUND,               \
 666: 0003:                                 VALID.NAME.FOUND,                      \
 667: 0003:                                 VALID.PASSWORD.FOUND,                  \
 668: 0003:                                 VALID.STAFF.NO.FOUND,                  \
 669: 0003:                                 VALID.EMPLOYEE.FLG.FOUND,              \
 670: 0003:                                 VALID.RECEIPT.NAME.FOUND,              \ AJC
 671: 0003:                                 VALID.GROUP.CODE.FOUND,                \ AJC
 672: 0003:                                 VALID.MODEL.FLAG.FOUND,                \
 673: 0003:                                 VALID.CONFIRM.FOUND,                   \
 674: 0003:                                 CSOUF.RECORD.FOUND,                    \
 675: 0003:                                 OPTION.ALLOWED(1)
 676: 0003: 
 677: 0003:         INTEGER*2 GLOBAL        S1.OPTION%,                            \
 678: 0003:                                 S1.DATE%,                              \
 679: 0003:                                 S2.BIRTH.DATE%,                        \ 1.6 RC
 680: 0003:                                 S2.OPERATOR.ID%,                       \
 681: 0003:                                 S2.NAME%,                              \
 682: 0003:                                 S2.PASSWORD%,                          \
 683: 0003:                                 S2.STAFF.NO%,                          \
 684: 0003:                                 S2.EMPLOYEE.FLG%,                      \
 685: 0003:                                 S2.RECEIPT.NAME%,                      \  AJC
 686: 0003:                                 S2.GROUP.CODE%,                        \  AJC 1.4
 687: 0003:                                 S2.CONFIRM%,                           \
 688: 0003:                                 S2.CONFIRM.TEXT%,                      \
 689: 0003:                                 S3.BIRTH.DATE%,                        \ 1.6 RC
 690: 0003:                                 S3.OPERATOR.ID%,                       \
 691: 0003:                                 S3.NAME%,                              \
 692: 0003:                                 S3.STAFF.NO%,                          \
 693: 0003:                                 S3.EMPLOYEE.FLG%,                      \
 694: 0003:                                 S3.RECEIPT.NAME%,                      \  AJC
 695: 0003:                                 S3.GROUP.CODE%,                        \  AJC 1.4
 696: 0003:                                 S4.BIRTH.DATE%,                        \ 1.6 RC
 697: 0003:                                 S4.OPERATOR.ID%,                       \
 698: 0003:                                 S4.NAME%,                              \
 699: 0003:                                 S4.STAFF.NO%,                          \
 700: 0003:                                 S4.EMPLOYEE.FLG%,                      \
 701: 0003:                                 S4.RECEIPT.NAME%,                      \  AJC
 702: 0003:                                 S4.GROUP.CODE%,                        \  AJC 1.4
 703: 0003:                                 S5.BIRTH.DATE%,                        \ 1.6 RC
 704: 0003:                                 S5.OPERATOR.ID%,                       \
 705: 0003:                                 S5.NAME%,                              \
 706: 0003:                                 S5.PASSWORD%,                          \
 707: 0003:                                 S5.STAFF.NO%,                          \
 708: 0003:                                 S5.EMPLOYEE.FLG%,                      \
 709: 0003:                                 S5.RECEIPT.NAME%,                      \  AJC
 710: 0003:                                 S5.GROUP.CODE%,                        \  AJC 1.4
 711: 0003:                                 S6.BIRTH.DATE%,                        \ 1.6 RC
 712: 0003:                                 S6.OPERATOR.ID%,                       \
 713: 0003:                                 S6.NAME%,                              \
 714: 0003:                                 S6.STAFF.NO%,                          \
 715: 0003:                                 S6.EMPLOYEE.FLG%,                      \
 716: 0003:                                 S6.RECEIPT.NAME%,                      \  AJC
 717: 0003:                                 S6.GROUP.CODE%,                        \  AJC 1.4
 718: 0003:                                 S7.REPORT.OPTION%,                     \
 719: 0003:                                 S7.SORT.OPTION%,                       \
 720: 0003:                                 S2.TILL.MODEL.TEXT%(1),                \
 721: 0003:                                 S2.TILL.MODEL.FLAG%(1),                \
 722: 0003:                                 S2.CTLR.MODEL.TEXT%(1),                \
 723: 0003:                                 S2.CTLR.MODEL.FLAG%(1),                \
 724: 0003:                                 TILL.PTR%,                             \
 725: 0003:                                 MAX.TILL.PTR%,                         \
 726: 0003:                                 CTLR.PTR%,                             \
 727: 0003:                                 MAX.CTLR.PTR%,                         \
 728: 0003:                                 MAX.TILL.MODELS%,                      \
 729: 0003:                                 MAX.CTLR.MODELS%,                      \
 730: 0003:                                 INDICATOR%,                            \
 731: 0003:                                 AUTH.FLAGS%,                           \
 732: 0003:                                 TILL.INDEX%,                           \
 733: 0003:                                 CTLR.INDEX%,                           \
 734: 0003:                                 SAVED.OPAUD.REC.NUM%                   !\
 735: 0003: 
 736: 0003:          INTEGER*4 GLOBAL        BIT.MASK%,                            \
 737: 0003:                                 OPM.BIT.MASK%,                         \
 738: 0003:                                 SDK.BIT.MASK%
 739: 0003: 
 740: 0003:         %INCLUDE MODELEXT.J86
 741: 0003: \*******************************************************************************
 742: 0003: \*******************************************************************************
 743: 0003: \***
 744: 0003: \***            %INCLUDE FOR OPERATOR MODEL FILE EXTERNAL FUNCTIONS
 745: 0003: \***
 746: 0003: \***                         REFERENCE : MODELEXT
 747: 0003: \***
 748: 0003: \***                         FILE TYPE : Keyed
 749: 0003: \***
 750: 0003: \***    VERSION A.              Mark Walker                      7th March 1994
 751: 0003: \***    Original version.
 752: 0003: \***
 753: 0003: \*******************************************************************************
 754: 0003: \*******************************************************************************
 755: 0003: 
 756: 0003:         FUNCTION MODEL.SET EXTERNAL
 757: 0003:         INTEGER*2 MODEL.SET
 758: 0003:         END FUNCTION
 759: 0003: 
 760: 0003:         FUNCTION READ.MODEL EXTERNAL
 761: 0003:         INTEGER*2 READ.MODEL
 762: 0003:         END FUNCTION
 763: 0003: 
 764: 0003:         FUNCTION WRITE.MODEL EXTERNAL
 765: 0003:         INTEGER*2 WRITE.MODEL
 766: 0003:         END FUNCTION
 767: 0003:         %INCLUDE CSOUFEXT.J86
 768: 0003: \*****************************************************************************
 769: 0003: \*****************************************************************************
 770: 0003: \***
 771: 0003: \***         FUNCTION DEFINITIONS FOR Operating System Authorisation file
 772: 0003: \***
 773: 0003: \***                    REFERENCE : CSOUFEXA.J86
 774: 0003: \***
 775: 0003: \***    Version A           Steve Windsor                      Nov 92 
 776: 0003: \***
 777: 0003: \*****************************************************************************
 778: 0003: \*****************************************************************************
 779: 0003: 
 780: 0003:    FUNCTION CSOUF.SET EXTERNAL
 781: 0003:    END FUNCTION
 782: 0003: 
 783: 0003: FUNCTION READ.CSOUF.ABREV EXTERNAL
 784: 0003:    INTEGER*2 READ.CSOUF.ABREV
 785: 0003:   END FUNCTION
 786: 0003: 
 787: 0003: FUNCTION READ.CSOUF.ABREV.LOCKED EXTERNAL
 788: 0003:    INTEGER*2 READ.CSOUF.ABREV.LOCKED
 789: 0003:   END FUNCTION
 790: 0003: 
 791: 0003: FUNCTION WRITE.CSOUF.ABREV.UNLOCK EXTERNAL
 792: 0003:    INTEGER*2 WRITE.CSOUF.ABREV.UNLOCK
 793: 0003:   END FUNCTION
 794: 0003: 
 795: 0003: FUNCTION WRITE.CSOUF.ABREV EXTERNAL
 796: 0003:    INTEGER*2 WRITE.CSOUF.ABREV
 797: 0003:   END FUNCTION
 798: 0003: 
 799: 0003:         %INCLUDE AFEXT.J86
 800: 0003: 
 801: 0003: \REM
 802: 0003: \*******************************************************************************
 803: 0003: \*******************************************************************************
 804: 0003: \***
 805: 0003: \***    %INCLUDE FOR GSA AUTHORISATION FILE EXTERNAL FUNCTIONS
 806: 0003: \***
 807: 0003: \***        REFERENCE   :  AFEXT (J86)
 808: 0003: \***
 809: 0003: \***        FILE TYPE   :  Keyed
 810: 0003: \***
 811: 0003: \***    The GSA Authorisation File (EALAUTH.DAT) should not be confused with
 812: 0003: \***    the Operating System Authorisation File (ADXCSOUF.DAT).
 813: 0003: \***
 814: 0003: \***    VERSION A.              ROBERT COWEY.                       18 AUG 1992.
 815: 0003: \***    Original version created from AFEXTA.
 816: 0003: \***
 817: 0003: \***    VERSION B.              Steve Windsor                       29 Dec 1992.
 818: 0003: \***    Version incremented to keep in line with other included code           
 819: 0003: \***
 820: 0003: \***    VERSION C.              ROBERT COWEY.                       03 MAR 1994.
 821: 0003: \***    No changes to this file.
 822: 0003: \***
 823: 0003: \***    REVISION 1.6.                ROBERT COWEY.                15 JUN 2009.
 824: 0003: \***    Changes for A9C POS improvements project.
 825: 0003: \***    Used up last available three bytes of EALAUTH user data by redefining 
 826: 0003: \***    remaining AF.USER$ variable as AF.BIRTH.DATE$.
 827: 0003: \***    No changes to this file.
 828: 0003: \***
 829: 0003: \***    REVISION 1.7.                ROBERT COWEY.                22 JUN 2009.
 830: 0003: \***    Changes for A9C POS improvements project creating PSB99.286 Rv 1.8.
 831: 0003: \***    Defect 3247 - Redefined AF.BIRTH.DATE$ format within AFDEC.J86.
 832: 0003: \***    Description text change only - No code changes to this file.
 833: 0003: \***
 834: 0003: \*******************************************************************************
 835: 0003: \*******************************************************************************
 836: 0003: 
 837: 0003: 
 838: 0003: FUNCTION AF.SET EXTERNAL
 839: 0003:     INTEGER*2 AF.SET
 840: 0003: END FUNCTION
 841: 0003: 
 842: 0003: 
 843: 0003: FUNCTION READ.AF EXTERNAL
 844: 0003:     INTEGER*2 READ.AF
 845: 0003: END FUNCTION
 846: 0003: 
 847: 0003: 
 848: 0003: FUNCTION READ.AF.LOCKED EXTERNAL
 849: 0003:     INTEGER*2 READ.AF.LOCKED
 850: 0003: END FUNCTION
 851: 0003: 
 852: 0003:   
 853: 0003: FUNCTION READ.AF.ABREV EXTERNAL
 854: 0003:     INTEGER*2 READ.AF.ABREV
 855: 0003: END FUNCTION
 856: 0003: 
 857: 0003: 
 858: 0003: FUNCTION READ.AF.ABREV.LOCKED EXTERNAL
 859: 0003:     INTEGER*2 READ.AF.ABREV.LOCKED
 860: 0003: END FUNCTION
 861: 0003: 
 862: 0003:   
 863: 0003: FUNCTION WRITE.AF.UNLOCK EXTERNAL
 864: 0003:     INTEGER*2 WRITE.AF.UNLOCK
 865: 0003: END FUNCTION
 866: 0003: 
 867: 0003: 
 868: 0003: FUNCTION WRITE.AF.ABREV EXTERNAL
 869: 0003:     INTEGER*2 WRITE.AF.ABREV
 870: 0003: END FUNCTION
 871: 0003: 
 872: 0003: 
 873: 0003: FUNCTION WRITE.AF.ABREV.UNLOCK EXTERNAL
 874: 0003:     INTEGER*2 WRITE.AF.ABREV.UNLOCK
 875: 0003: END FUNCTION
 876: 0003: 
 877: 0003:         %INCLUDE OPAUDEXT.J86
 878: 0003: \*******************************************************************************
 879: 0003: \*******************************************************************************
 880: 0003: \***
 881: 0003: \***    %INCLUDE FOR OPERATOR AUTHORISATION AUDIT FILE EXTERNAL FUNCTIONS
 882: 0003: \***
 883: 0003: \***                         REFERENCE : OPAUDEXT
 884: 0003: \***
 885: 0003: \***                         FILE TYPE : Direct
 886: 0003: \***
 887: 0003: \***    VERSION A.              Mark Walker                   22nd March 1994
 888: 0003: \***    Original version.
 889: 0003: \***
 890: 0003: \*******************************************************************************
 891: 0003: \*******************************************************************************
 892: 0003: 
 893: 0003:         FUNCTION OPAUD.SET EXTERNAL
 894: 0003:         INTEGER*2 OPAUD.SET
 895: 0003:         END FUNCTION
 896: 0003: 
 897: 0003:         FUNCTION READ.OPAUD EXTERNAL
 898: 0003:         INTEGER*2 READ.OPAUD
 899: 0003:         END FUNCTION 
 900: 0003: 
 901: 0003:         FUNCTION WRITE.OPAUD EXTERNAL
 902: 0003:         INTEGER*2 WRITE.OPAUD
 903: 0003:         END FUNCTION 
 904: 0003: 
 905: 0003:         %INCLUDE PRINTEXT.J86
 906: 0003: 
 907: 0003: REM \
 908: 0003: \*******************************************************************************
 909: 0003: \*******************************************************************************
 910: 0003: \***
 911: 0003: \***    %INCLUDE FOR PRINT FILE EXTERNAL FUNCTIONS
 912: 0003: \***
 913: 0003: \***        REFERENCE   :   PRINTEX (J86)
 914: 0003: \***
 915: 0003: \***        FILE TYPE   :   Printer / Labeller
 916: 0003: \***
 917: 0003: \***    VERSION A.              ANDREW WEDGEWORTH                   09 JUL 1992.
 918: 0003: \***    Original version created from PRINTEXG.
 919: 0003: \***
 920: 0003: \***    VERSION B.              UNKNOWN.                            ?? ??? 1992.
 921: 0003: \***    Changes unknown.
 922: 0003: \***
 923: 0003: \***    VERSION C.              ROBERT COWEY.                       18 NOV 1992.
 924: 0003: \***    Defined function variables for use as return codes.
 925: 0003: \***
 926: 0003: \***    Version C               Andrew Wedgeworth                 24th May 1992
 927: 0003: \***    Condensed print function added.
 928: 0003: \***
 929: 0003: \***    Version D               Stuart WIlliam McConnachie       31st July 2000.
 930: 0003: \***    Added function for PCL printing to LaserJet.
 931: 0003: \***
 932: 0003: \***    Version E               Charles Skadorwa                   4th Apr 2008.
 933: 0003: \***    Added parameter to WRITE.CONDENSED.PRINT function to
 934: 0003: \***    enable Alliance Pharmacy Brother Laser printers to print
 935: 0003: \***    in condensed mode.
 936: 0003: \***
 937: 0003: \***    Version F           Charles Skadorwa                       2nd Mar 2016.
 938: 0003: \***    It was found that certain reports would not print when stores
 939: 0003: \***    were converted to LAN attached printing.
 940: 0003: \***
 941: 0003: \***    Added new function: WRITE.PRINT.PLUS.LF based on WRITE.PRINT.
 942: 0003: \***    This adds a Line-Feed characters to every print line.
 943: 0003: \***
 944: 0003: \*******************************************************************************
 945: 0003: \*******************************************************************************
 946: 0003: 
 947: 0003: 
 948: 0003:     FUNCTION PRINT.SET EXTERNAL
 949: 0003:         INTEGER*2 PRINT.SET
 950: 0003:     END FUNCTION
 951: 0003: 
 952: 0003: 
 953: 0003:     FUNCTION WRITE.PRINT EXTERNAL
 954: 0003:        INTEGER*2 WRITE.PRINT
 955: 0003:     END FUNCTION
 956: 0003: 
 957: 0003: 
 958: 0003:     FUNCTION WRITE.PRINT.PLUS.LF EXTERNAL                               !FCS
 959: 0003:        INTEGER*2 WRITE.PRINT.PLUS.LF                                    !FCS
 960: 0003:     END FUNCTION                                                        !FCS
 961: 0003: 
 962: 0003: 
 963: 0003:     FUNCTION WRITE.CONDENSED.PRINT (AP.STORE) EXTERNAL                 ! ECSk
 964: 0003:        INTEGER*2 WRITE.CONDENSED.PRINT
 965: 0003:     END FUNCTION
 966: 0003: 
 967: 0003: 
 968: 0003:     FUNCTION WRITE.PCL.PRINT EXTERNAL                                  ! DSWM
 969: 0003:        INTEGER*2 WRITE.PCL.PRINT                                       ! DSWM
 970: 0003:     END FUNCTION                                                       ! DSWM
 971: 0003: 
 972: 0003: 
 973: 0003:     FUNCTION WRITE.LABEL EXTERNAL
 974: 0003:         INTEGER*2 WRITE.LABEL
 975: 0003:     END FUNCTION
 976: 0003: 
 977: 0003:         %INCLUDE PPDFEXT.J86
 978: 0003: 
 979: 0003: \REM
 980: 0003: \*******************************************************************************
 981: 0003: \*******************************************************************************
 982: 0003: \***
 983: 0003: \***    %INCLUDE FOR PHARMACY PASSWORD DETAILS FILES EXTERNAL FUNCTIONS
 984: 0003: \***
 985: 0003: \***        REFERENCE   :   PPDFEXT (J86)
 986: 0003: \***
 987: 0003: \***        FILE TYPE   :   Direct
 988: 0003: \***
 989: 0003: \***    VERSION A.              ROBERT COWEY.                       21 FEB 1994.
 990: 0003: \***    Original version created from PPDFFUNA.
 991: 0003: \***
 992: 0003: \*******************************************************************************
 993: 0003: \*******************************************************************************
 994: 0003: 
 995: 0003: 
 996: 0003: FUNCTION PPDF.SET EXTERNAL
 997: 0003:     INTEGER*2 PPDF.SET
 998: 0003: END FUNCTION
 999: 0003: 
1000: 0003: FUNCTION READ.PPDF EXTERNAL
1001: 0003:     INTEGER*2 READ.PPDF
1002: 0003: END FUNCTION
1003: 0003: 
1004: 0003: FUNCTION WRITE.PPDF EXTERNAL
1005: 0003:     INTEGER*2 WRITE.PPDF
1006: 0003: END FUNCTION
1007: 0003: 
1008: 0003:         %INCLUDE PHRMLEXT.J86
1009: 0003: 
1010: 0003: \REM
1011: 0003: \*******************************************************************************
1012: 0003: \*******************************************************************************
1013: 0003: \***
1014: 0003: \***    %INCLUDE FOR PHARMACY LOCAL FILES EXTERNAL FUNCTIONS
1015: 0003: \***
1016: 0003: \***        REFERENCE   :   PHRMLEX (J86)
1017: 0003: \***
1018: 0003: \***        FILE TYPE   :   Accessed as direct
1019: 0003: \***
1020: 0003: \***    VERSION A.              ROBERT COWEY.                       24 MAR 1994.
1021: 0003: \***    Original version created from PHRMLFUA.
1022: 0003: \***
1023: 0003: \*******************************************************************************
1024: 0003: \*******************************************************************************
1025: 0003: 
1026: 0003: 
1027: 0003: FUNCTION PHRML.SET EXTERNAL
1028: 0003:     INTEGER*2 PHRML.SET
1029: 0003: END FUNCTION
1030: 0003: 
1031: 0003: FUNCTION WRITE.PHRML.PASSWORD EXTERNAL
1032: 0003:     INTEGER*2 WRITE.PHRML.PASSWORD
1033: 0003: END FUNCTION
1034: 0003: 
1035: 0003: 
1036: 0003:         %INCLUDE PSBF01E.J86   ! Application Log
1037: 0003: REM \
1038: 0003: \*******************************************************************************
1039: 0003: \*******************************************************************************
1040: 0003: \***
1041: 0003: \***      %INCLUDE FOR EXTERNAL DEFINITION OF FUNCTION APPLICATION.LOG
1042: 0003: \***
1043: 0003: \***                      FUNCTION NUMBER   : PSBF01
1044: 0003: \***
1045: 0003: \***                    INCLUDE REFERENCE : PSBF01E.J86
1046: 0003: \*** 
1047: 0003: \***      Version B           Andrew Wedgeworth          1st July 1992
1048: 0003: \***      Three parameters which passed to the function have been removed.
1049: 0003: \***      APPLICATION.LOG has been added as a variable name (this holds the
1050: 0003: \***      return code).
1051: 0003: \***
1052: 0003: \*******************************************************************************
1053: 0003: 
1054: 0003: 
1055: 0003:    FUNCTION APPLICATION.LOG (MESSAGE.NO%,                                     \
1056: 0003:                              VAR.STRING.1$,                                   \
1057: 0003:                              VAR.STRING.2$,                                   \
1058: 0003:                              EVENT.NO%)  EXTERNAL
1059: 0003: 
1060: 0003:       INTEGER*1 EVENT.NO%
1061: 0003: 
1062: 0003:       INTEGER*2 APPLICATION.LOG,                                       \ GAW
1063: 0003:                 MESSAGE.NO%
1064: 0003: 
1065: 0003:       STRING VAR.STRING.1$,                                            \
1066: 0003:              VAR.STRING.2$
1067: 0003: 
1068: 0003:    END FUNCTION
1069: 0003: 
1070: 0003: \*******************************************************************************
1071: 0003:         %INCLUDE PSBF03E.J86   ! Display Manager
1072: 0003: REM \
1073: 0003: \*******************************************************************************
1074: 0003: \***
1075: 0003: \***    %INCLUDED CODE FOR EXTERNAL DEFINITIONS OF DISPLAY MANAGER FUNCTIONS
1076: 0003: \***     
1077: 0003: \***            REFERENCE       : PSBF03E.J86     
1078: 0003: \***     
1079: 0003: \***            DATE.WRITTEN    : 21/03/1986     
1080: 0003: \***     
1081: 0003: \***    Version B              Andrew Wedgeworth              21st July 1992
1082: 0003: \***    Remove redundant function parameters (BATCH.SCREEN.FLAG$, 
1083: 0003: \***    MODULE.NUMBER$ and OPERATOR.NUMBER$).  Function names defined as 
1084: 0003: \***    variables to hold return codes.
1085: 0003: \***
1086: 0003: \*******************************************************************************
1087: 0003: 
1088: 0003:    FUNCTION DM.INITDM (STRING.DATA$,                                   \
1089: 0003:                        INTEGER.DATA%)   EXTERNAL
1090: 0003: 
1091: 0003:       STRING      STRING.DATA$
1092: 0003: 
1093: 0003:       INTEGER*2   DM.INITDM,                                           \ BAW
1094: 0003:                   INTEGER.DATA%
1095: 0003:                          
1096: 0003:      
1097: 0003: 
1098: 0003:    END FUNCTION
1099: 0003: 
1100: 0003:    FUNCTION DM.CLRSCR (STRING.DATA$,                                   \
1101: 0003:                        INTEGER.DATA%)   EXTERNAL
1102: 0003: 
1103: 0003:       STRING      STRING.DATA$
1104: 0003: 
1105: 0003:       INTEGER*2   DM.CLRSCR,                                           \ BAW
1106: 0003:                   INTEGER.DATA%
1107: 0003: 
1108: 0003:    END FUNCTION
1109: 0003: 
1110: 0003:    FUNCTION DM.CLSDIS (STRING.DATA$,                                   \
1111: 0003:                        INTEGER.DATA%)   EXTERNAL
1112: 0003: 
1113: 0003:       STRING      STRING.DATA$
1114: 0003: 
1115: 0003:       INTEGER*2   DM.CLSDIS,                                           \ BAW
1116: 0003:                   INTEGER.DATA%
1117: 0003: 
1118: 0003:    END FUNCTION
1119: 0003: 
1120: 0003:    FUNCTION DM.OPNDIS (STRING.DATA$,                                   \
1121: 0003:                        INTEGER.DATA%)   EXTERNAL
1122: 0003: 
1123: 0003:       STRING      STRING.DATA$
1124: 0003: 
1125: 0003:       INTEGER*2   DM.OPNDIS,                                           \ BAW 
1126: 0003:                   INTEGER.DATA%
1127: 0003: 
1128: 0003:    END FUNCTION
1129: 0003: 
1130: 0003:    FUNCTION DM.DISPD  (STRING.DATA$,                                   \
1131: 0003:                        INTEGER.DATA%)   EXTERNAL
1132: 0003: 
1133: 0003:       STRING      STRING.DATA$
1134: 0003: 
1135: 0003:       INTEGER*2   DM.DISPD,                                            \ BAW
1136: 0003:                   INTEGER.DATA%
1137: 0003: 
1138: 0003:    END FUNCTION
1139: 0003: 
1140: 0003:    FUNCTION DM.RETDM  (STRING.DATA$,                                   \
1141: 0003:                        INTEGER.DATA%)   EXTERNAL
1142: 0003: 
1143: 0003:       STRING      STRING.DATA$
1144: 0003: 
1145: 0003:       INTEGER*2   DM.RETDM,                                            \ BAW 
1146: 0003:                   INTEGER.DATA%
1147: 0003: 
1148: 0003:    END FUNCTION
1149: 0003: 
1150: 0003:    FUNCTION DM.CURS   (STRING.DATA$,                                   \
1151: 0003:                        INTEGER.DATA%)   EXTERNAL
1152: 0003: 
1153: 0003:       STRING      STRING.DATA$
1154: 0003: 
1155: 0003:       INTEGER*2   DM.CURS,                                             \ BAW      
1156: 0003:                   INTEGER.DATA%
1157: 0003: 
1158: 0003:    END FUNCTION
1159: 0003: 
1160: 0003:    FUNCTION DM.RETF   (STRING.DATA$,                                   \
1161: 0003:                        INTEGER.DATA%)   EXTERNAL
1162: 0003: 
1163: 0003:       STRING      STRING.DATA$
1164: 0003: 
1165: 0003:       INTEGER*2   DM.RETF,                                             \ BAW
1166: 0003:                   INTEGER.DATA%
1167: 0003: 
1168: 0003:    END FUNCTION
1169: 0003: 
1170: 0003:    FUNCTION DM.SETF   (STRING.DATA$,                                   \
1171: 0003:                        INTEGER.DATA%)   EXTERNAL
1172: 0003: 
1173: 0003:       STRING      STRING.DATA$
1174: 0003: 
1175: 0003:       INTEGER*2   DM.SETF,                                             \ BAW
1176: 0003:                   INTEGER.DATA%
1177: 0003: 
1178: 0003:    END FUNCTION
1179: 0003: 
1180: 0003:    FUNCTION DM.POSF   (STRING.DATA$,                            \
1181: 0003:                        INTEGER.DATA%)   EXTERNAL
1182: 0003: 
1183: 0003:       STRING      STRING.DATA$
1184: 0003: 
1185: 0003:       INTEGER*2   DM.POSF,                                             \ BAW
1186: 0003:                   INTEGER.DATA%
1187: 0003: 
1188: 0003:    END FUNCTION
1189: 0003: 
1190: 0003:    FUNCTION DM.NEXTF  (STRING.DATA$,                                   \
1191: 0003:                        INTEGER.DATA%)   EXTERNAL
1192: 0003: 
1193: 0003:       STRING      STRING.DATA$
1194: 0003: 
1195: 0003:       INTEGER*2   DM.NEXTF,                                            \ BAW
1196: 0003:                   INTEGER.DATA%
1197: 0003: 
1198: 0003:    END FUNCTION
1199: 0003: 
1200: 0003:    FUNCTION DM.PUTF   (STRING.DATA$,                                   \
1201: 0003:                        INTEGER.DATA%)   EXTERNAL
1202: 0003: 
1203: 0003:       STRING      STRING.DATA$
1204: 0003: 
1205: 0003:       INTEGER*2   DM.PUTF,                                             \ BAW
1206: 0003:                   INTEGER.DATA%
1207: 0003: 
1208: 0003:    END FUNCTION
1209: 0003: 
1210: 0003:    FUNCTION DM.GETF   (STRING.DATA$,                                   \ BAW
1211: 0003:                        INTEGER.DATA%)   EXTERNAL
1212: 0003: 
1213: 0003:       STRING      STRING.DATA$
1214: 0003: 
1215: 0003:       INTEGER*2   DM.GETF,                                             \ BAW 
1216: 0003:                   INTEGER.DATA%
1217: 0003: 
1218: 0003:    END FUNCTION
1219: 0003: 
1220: 0003:    FUNCTION DM.UPDF   (STRING.DATA$,                                   \
1221: 0003:                        INTEGER.DATA%)   EXTERNAL
1222: 0003: 
1223: 0003:       STRING      STRING.DATA$
1224: 0003: 
1225: 0003:       INTEGER*2   DM.UPDF,                                             \ BAW
1226: 0003:                   INTEGER.DATA%
1227: 0003: 
1228: 0003:    END FUNCTION
1229: 0003: 
1230: 0003:    FUNCTION DM.RESF   (STRING.DATA$,                                   \
1231: 0003:                        INTEGER.DATA%)   EXTERNAL
1232: 0003: 
1233: 0003:       STRING      STRING.DATA$
1234: 0003: 
1235: 0003:       INTEGER*2   DM.RESF,                                             \ BAW
1236: 0003:                   INTEGER.DATA%
1237: 0003: 
1238: 0003:    END FUNCTION
1239: 0003: 
1240: 0003: \*******************************************************************************
1241: 0003:         %INCLUDE PSBF04E.J86   ! External Message
1242: 0003: REM \
1243: 0003: \*******************************************************************************
1244: 0003: \*******************************************************************************
1245: 0003: \***
1246: 0003: \***      %INCLUDE FOR EXTERNAL DEFINITION OF FUNCTION EXTERNAL.MESSAGE
1247: 0003: \***
1248: 0003: \***
1249: 0003: \***            FUNCTION NUMBER    : PSBF04
1250: 0003: \***
1251: 0003: \***            INCLUDE REFERENCE  : PSBF04E.J86
1252: 0003: \***
1253: 0003: \***            DATE WRITTEN       : 5th March 1986
1254: 0003: \***
1255: 0003: \***        Version B        Andrew Wedgeworth         15th July 1992
1256: 0003: \***        Redundant function parameters removed.  EXTERNAL.MESSAGE
1257: 0003: \***        is defined as a variable which holds the return code.  
1258: 0003: \***
1259: 0003: \*******************************************************************************
1260: 0003: \*******************************************************************************
1261: 0003: 
1262: 0003:    FUNCTION EXTERNAL.MESSAGE  (MESSAGE.NO%,                            \
1263: 0003:                                STRING.DATA$,                           \
1264: 0003:                                RETURN.FIELD%) EXTERNAL
1265: 0003:    ! 3 parameters deleted from here                                    ! BAW
1266: 0003: 
1267: 0003:       STRING     STRING.DATA$
1268: 0003: 
1269: 0003:       INTEGER*2  EXTERNAL.MESSAGE,                                     \ BAW
1270: 0003:                  MESSAGE.NO%,                                          \
1271: 0003:                  RETURN.FIELD%
1272: 0003: 
1273: 0003:    END FUNCTION
1274: 0003: 
1275: 0003: \*******************************************************************************
1276: 0003:         %INCLUDE PSBF12E.J86   ! Help
1277: 0003: REM \
1278: 0003: \*****************************************************************************
1279: 0003: \*****************************************************************************
1280: 0003: \***
1281: 0003: \***      %INCLUDE FOR EXTERNAL DEFINITION OF HELP FUNCTION
1282: 0003: \***
1283: 0003: \***            FUNCTION NUMBER      : PSBF12
1284: 0003: \***
1285: 0003: \***            REFERENCE            : PSBF12E.J86
1286: 0003: \***
1287: 0003: \***            DATE WRITTEN         : 17th March 1986
1288: 0003: \***
1289: 0003: \***      Version B           Andrew Wedgeworth           21st July 1992
1290: 0003: \***      Removal of redundant function parameters. HELP included as a 
1291: 0003: \***      variable to hold the return code.
1292: 0003: \***
1293: 0003: \*****************************************************************************
1294: 0003: \*****************************************************************************
1295: 0003: 
1296: 0003:    FUNCTION HELP (SCREEN.NO$) EXTERNAL
1297: 0003: 
1298: 0003:        STRING SCREEN.NO$
1299: 0003:        
1300: 0003:        INTEGER*2 HELP       
1301: 0003: 
1302: 0003:    END FUNCTION
1303: 0003: 
1304: 0003: \******************************************************************************
1305: 0003:         %INCLUDE PSBF20E.J86   ! Session Number Utility
1306: 0003: REM\
1307: 0003: \*******************************************************************************
1308: 0003: \*******************************************************************************
1309: 0003: \***
1310: 0003: \***       %INCLUDE FOR EXTERNAL DEFINITION OF SESS.NUM.UTILITY
1311: 0003: \***
1312: 0003: \***                  REFERENCE     : PSBF20E.J86
1313: 0003: \***
1314: 0003: \***     VERSION C            Janet Smith                13th May 1992
1315: 0003: \***     Increased PASSED.INTEGER to 2 bytes to cater for more than
1316: 0003: \***     128 files.
1317: 0003: \***
1318: 0003: \***     VERSION D.           Andrew Wedgeworth          1st July 1992
1319: 0003: \***     Removal of redundant parameters and addition of SESS.NUM.UTILITY
1320: 0003: \***     as a variable.  This new variable contains the function's return
1321: 0003: \***     code.
1322: 0003: \***
1323: 0003: \*******************************************************************************
1324: 0003: \*******************************************************************************
1325: 0003: 
1326: 0003:    FUNCTION SESS.NUM.UTILITY (FUNCTION.FLAG$,                          \
1327: 0003:                               PASSED.INTEGER%,                         \
1328: 0003:                               PASSED.STRING$)                          \
1329: 0003:    EXTERNAL
1330: 0003: 
1331: 0003:    STRING    FUNCTION.FLAG$,                                           \
1332: 0003:              PASSED.STRING$
1333: 0003:    ! 3 variables removed from here                                     ! CAW
1334: 0003: 
1335: 0003: 
1336: 0003:    INTEGER*2 SESS.NUM.UTILITY,                                         \ CAW
1337: 0003:              PASSED.INTEGER%				               ! CJAS
1338: 0003: 
1339: 0003:    END FUNCTION
1340: 0003: 
1341: 0003:         %INCLUDE PSBF24E.J86   ! Standard Error Detected
1342: 0003: REM \
1343: 0003: \*******************************************************************************
1344: 0003: \*******************************************************************************
1345: 0003: \***
1346: 0003: \***    %INCLUDE FOR EXTERNAL DEFINITION OF STANDARD.ERROR.DETECTED FUNCTION
1347: 0003: \***
1348: 0003: \***                      REFERENCE     : PSBF24E.J86
1349: 0003: \***
1350: 0003: \***    Version A                 Janet Smith                  13th May 1992
1351: 0003: \***
1352: 0003: \*******************************************************************************
1353: 0003: \*******************************************************************************
1354: 0003: 
1355: 0003:    FUNCTION STANDARD.ERROR.DETECTED(ERRN%,                 \
1356: 0003: 				    ERRFILE%,              \
1357: 0003: 				    ERRL%,                 \
1358: 0003: 				    ERR$)        EXTERNAL
1359: 0003: 				    
1360: 0003:           STRING    ERR$
1361: 0003: 
1362: 0003:           INTEGER*2 ERRFILE%,              \
1363: 0003: 	            ERRL%,                 \
1364: 0003: 		    STANDARD.ERROR.DETECTED
1365: 0003: 		    
1366: 0003:           INTEGER*4 ERRN%
1367: 0003: 	  		    
1368: 0003:    END FUNCTION
1369: 0003: 
1370: 0003: 
1371: 0003: 
1372: 0003:         %INCLUDE ADXAUTH.J86
1373: 0003: 
1374: 0003: REM \
1375: 0003: \*******************************************************************************
1376: 0003: \*******************************************************************************
1377: 0003: \***
1378: 0003: \***    %INCLUDE FOR FUNCTION ADXAUTH (I.B.M. system function)
1379: 0003: \***
1380: 0003: \***        REFERENCE     :    ADXAUTH.J86
1381: 0003: \***
1382: 0003: \***    Version A.                  Robert Cowey.                    8 Jul 1991.
1383: 0003: \***    Initial version based on coding within PSB3700C.BAS.
1384: 0003: \***
1385: 0003: \*******************************************************************************
1386: 0003: \*******************************************************************************
1387: 0003: 
1388: 0003: 
1389: 0003:     FUNCTION ADXAUTH \
1390: 0003:        (FUNC, \
1391: 0003:         OPID$, \
1392: 0003:         OPPW$, \
1393: 0003:         OPID2$) \
1394: 0003:             EXTERNAL
1395: 0003: 
1396: 0003:     STRING \
1397: 0003:         OPID$, \
1398: 0003:         OPPW$, \
1399: 0003:         OPID2$
1400: 0003: 
1401: 0003:     INTEGER*2 \
1402: 0003:         ADXAUTH, \
1403: 0003:         FUNC
1404: 0003: 
1405: 0003:     END FUNCTION
1406: 0003: 
1407: 0003: 
1408: 0003:         %INCLUDE DMEXTR.J86
1409: 0003: \/* TIME STAMP BLOCK **************************************************
1410: 0003: \** END OF TIME STAMP BLOCK ******************************************/
1411: 0003:  REM  INCLUDE FILE FOR  DISPLAY MANAGER EXTERNAL FUNCTIONS FOR CB80  June 7/82
1412: 0003:  REM  IR91470 01 10 91  LAB G53  marked for EFT
1413: 0003:         DEF CLRSCR EXTERNAL             REM Clear screen for Display Manager
1414: 0003:         INTEGER CLRSCR
1415: 0003:         FEND
1416: 0003:         DEF CLSDIS EXTERNAL
1417: 0003:         INTEGER CLSDIS
1418: 0003:         FEND                            REM Close Display Manager
1419: 0003:         DEF DISPD(I%) EXTERNAL          REM Display a display.
1420: 0003:         INTEGER DISPD
1421: 0003:         FEND
1422: 0003:         DEF CURS(X$) EXTERNAL           REM turn on/off cursor visibility.
1423: 0003:         STRING CURS
1424: 0003:         FEND
1425: 0003:         DEF ENDF EXTERNAL               REM ENDF method of return.
1426: 0003:         INTEGER ENDF
1427: 0003:         FEND
1428: 0003:         DEF GETF EXTERNAL               REM GETF get data from a field
1429: 0003:         STRING GETF
1430: 0003:         FEND
1431: 0003:         DEF INITDM(A$) EXTERNAL         REM INITIALIZE Display Manager
1432: 0003:         INTEGER INITDM
1433: 0003:         FEND
1434: 0003:         DEF NXTF(I%)  EXTERNAL          REM NXTF Go to Next Field
1435: 0003:         INTEGER NXTF
1436: 0003:         FEND
1437: 0003:         DEF POSF(I%) EXTERNAL           REM POSTION on Field
1438: 0003:         INTEGER POSF
1439: 0003:         FEND
1440: 0003: 
1441: 0003:         DEF OPNDIS(A$) EXTERNAL         REM OPEN DISPLAY FILE
1442: 0003:         INTEGER OPNDIS
1443: 0003:         FEND
1444: 0003:         DEF PUTF(A$)  EXTERNAL          REM PUT data to Field
1445: 0003:         INTEGER PUTF
1446: 0003:         FEND
1447: 0003:         DEF RESF(I%)  EXTERNAL          REM RESUME field
1448: 0003:         STRING RESF
1449: 0003:         FEND
1450: 0003: 
1451: 0003:         DEF RETDM  EXTERNAL             REM RETURN Display Mgr Characteristics
1452: 0003:         STRING RETDM
1453: 0003:         FEND
1454: 0003:         DEF SETF(A$) EXTERNAL           REM SET Field  video attributes
1455: 0003:         STRING SETF
1456: 0003:         FEND
1457: 0003:         DEF UPDF  EXTERNAL                      REM UPDATE Field data
1458: 0003:         STRING UPDF
1459: 0003:         FEND
1460: 0003: 
1461: 0003:         DEF RETF EXTERNAL
1462: 0003:         STRING RETF
1463: 0003:         FEND
1464: 0003:    REM  END OF INCLUDE FILE FOR DISPLAY MANAGER CALLS FOR CB80
1465: 0003: 
1466: 0003:         SUB PSB9901 EXTERNAL
1467: 0003:         END SUB
1468: 0003: 
1469: 0003:         SUB PSB9902 EXTERNAL ! Separation of PROCESS.SCREEN.06         ! 1.5 RC
1470: 0003:         END SUB                                                        ! 1.5 RC
1471: 0003: 
1472: 0003: 
1473: 0003: 
1474: 0003: \******************************************************************************
1475: 0003: \***
1476: 0003: \***    EXTERNAL FUNCTIONS DEFINED WITHIN PSB9902
1477: 0003: \***
1478: 0003: \***...........................................................................
1479: 0003: 
1480: 0003: FUNCTION VALID.YYMMDD (YYMMDD$) EXTERNAL ! PSB9902                     ! 1.6 RC
1481: 0003:     INTEGER*1 VALID.YYMMDD                                             ! 1.6 RC
1482: 0003: END FUNCTION                                                           ! 1.6 RC
1483: 0003: 
1484: 0003: FUNCTION DDMCYY.HEX.FROM.DDMMCCYY$ (DDMMCCYY$) EXTERNAL ! PSB9902      ! 1.8 RC
1485: 0003:     STRING DDMCYY.HEX.FROM.DDMMCCYY$                                   ! 1.8 RC
1486: 0003: END FUNCTION                                                           ! 1.8 RC
1487: 0003: 
1488: 0003: FUNCTION YYMMDD.FROM.DDMCYY.HEX$ (DDMCYY.HEX$) EXTERNAL ! PSB9902      ! 1.8 RC
1489: 0003:     STRING YYMMDD.FROM.DDMCYY.HEX$                                     ! 1.8 RC
1490: 0003: END FUNCTION                                                           ! 1.8 RC
1491: 0003: 
1492: 0003: FUNCTION VALID.DDMCYY (DDMCYY.HEX$) EXTERNAL ! PSB9902                 ! 1.8 RC
1493: 0003:     INTEGER*1 VALID.DDMCYY                                             ! 1.8 RC
1494: 0003: END FUNCTION                                                           ! 1.8 RC
1495: 0003: 
1496: 0003: 
1497: 0003: \******************************************************************************
1498: 0003: \***
1499: 0003: \***    INTERNAL FUNCTIONS
1500: 0003: \***
1501: 0003: \***...........................................................................
1502: 0003: 
1503: 0003: 
1504: 0003: \******************************************************************************
1505: 0003: \***                                                                          *
1506: 0003: \***    FUNCTION        :       DISPLAY.SCREEN                                *
1507: 0003: \***                                                                          *
1508: 0003: \******************************************************************************
1509: 0003: \***                                                                          *
1510: 0003: \***    Displays the required screen                                          *
1511: 0003: \***                                                                          *
1512: 0003: \******************************************************************************
1513: 0003: 
1514: 0003:         FUNCTION DISPLAY.SCREEN(SCREEN.NUMBER%) PUBLIC
1515: 0027: 
1516: 0027:         INTEGER*2                               SCREEN.NUMBER%
1517: 0027: 
1518: 0027:         STRING.DATA$ = ""
1519: 003e:         INTEGER.DATA% = 0
1520: 004f: 
1521: 004f:         CALL DM.CLRSCR(STRING.DATA$,                                   \
1522: 0071:                        INTEGER.DATA%)
1523: 0071: 
1524: 0071:         STRING.DATA$ = "B99" + RIGHT$("00" + STR$(SCREEN.NUMBER%),2)
1525: 00be:         INTEGER.DATA% = 0
1526: 00cf: 
1527: 00cf:         CALL DM.DISPD(STRING.DATA$,                                    \
1528: 00f1:                       INTEGER.DATA%)
1529: 00f1: 
1530: 00f1:         END FUNCTION
1531: 0105: 
1532: 0105: \******************************************************************************
1533: 0105: \***                                                                          *
1534: 0105: \***    FUNCTION        :       SCREEN.HELP                                   *
1535: 0105: \***                                                                          *
1536: 0105: \******************************************************************************
1537: 0105: \***                                                                          *
1538: 0105: \***    Displays the required HELP screen                                     *
1539: 0105: \***                                                                          *
1540: 0105: \******************************************************************************
1541: 0105: 
1542: 0105:         FUNCTION SCREEN.HELP(SCREEN.NUMBER%) PUBLIC
1543: 0129: 
1544: 0129:         STRING                                  SCREEN.NUMBER$
1545: 0129: 
1546: 0129:         INTEGER*2                               SCREEN.NUMBER%
1547: 0129: 
1548: 0129:         STRING.DATA$ = ""
1549: 0140:         INTEGER.DATA% = 1
1550: 0151: 
1551: 0151:         CALL DM.POSF(STRING.DATA$,                                     \
1552: 0173:                      INTEGER.DATA%)
1553: 0173: 
1554: 0173:         STRING.DATA$ = ""
1555: 018a:         INTEGER.DATA% = 0
1556: 019b: 
1557: 019b:         CALL DM.UPDF(STRING.DATA$,                                     \
1558: 01bd:                      INTEGER.DATA%)
1559: 01bd: 
1560: 01bd:         LAST.MESSAGE$ = F03.RETURNED.STRING$
1561: 01db: 
1562: 01db:         SCREEN.NUMBER$ = "B99" + RIGHT$("00" +                         \
1563: 0226:                          STR$(SCREEN.NUMBER%),2)
1564: 0226: 
1565: 0226:         CALL HELP(SCREEN.NUMBER$)
1566: 023e: 
1567: 023e:         STRING.DATA$  = ""
1568: 0255:         INTEGER.DATA% = 1
1569: 0266: 
1570: 0266:         CALL DM.POSF(STRING.DATA$,                                     \
1571: 0288:                      INTEGER.DATA%)
1572: 0288: 
1573: 0288:         STRING.DATA$  = "31"
1574: 029f:         INTEGER.DATA% = 0
1575: 02b0: 
1576: 02b0:         CALL DM.SETF(STRING.DATA$,                                     \
1577: 02d2:                      INTEGER.DATA%)
1578: 02d2: 
1579: 02d2:         STRING.DATA$  = LAST.MESSAGE$
1580: 02f0:         INTEGER.DATA% = 0
1581: 0301: 
1582: 0301:         CALL DM.PUTF(STRING.DATA$,                                     \
1583: 0323:                      INTEGER.DATA%)
1584: 0323: 
1585: 0323:         END FUNCTION
1586: 0337: 
1587: 0337: \******************************************************************************
1588: 0337: \***                                                                          *
1589: 0337: \***    FUNCTION        :       VALID.OPTION                                  *
1590: 0337: \***                                                                          *
1591: 0337: \******************************************************************************
1592: 0337: \***                                                                          *
1593: 0337: \***    Checks that the option is valid                                       *
1594: 0337: \***                                                                          *
1595: 0337: \******************************************************************************
1596: 0337: 
1597: 0337:         FUNCTION VALID.OPTION PUBLIC
1598: 035b: 
1599: 035b:         INTEGER*1                               VALID.OPTION
1600: 035b: 
1601: 035b:         VALID.OPTION = FALSE
1602: 036d: 
1603: 036d:         IF OPTION$ >= "1" AND                                          \
1604: 03bf:            OPTION$ <= "6" THEN                                         \
1605: 03bf:            VALID.OPTION = TRUE
1606: 03d1: 
1607: 03d1:         END FUNCTION
1608: 03e8: 
1609: 03e8: \******************************************************************************
1610: 03e8: \***                                                                          *
1611: 03e8: \***    FUNCTION        :       VALID.OPERATOR.ID                             *
1612: 03e8: \***                                                                          *
1613: 03e8: \******************************************************************************
1614: 03e8: \***                                                                          *
1615: 03e8: \***    Checks that the operator ID is valid                                  *
1616: 03e8: \***                                                                          *
1617: 03e8: \******************************************************************************
1618: 03e8: 
1619: 03e8:         FUNCTION VALID.OPERATOR.ID PUBLIC
1620: 040c: 
1621: 040c:         INTEGER*1                               VALID.OPERATOR.ID
1622: 040c: 
1623: 040c:         VALID.OPERATOR.ID = FALSE
1624: 041e: 
1625: 041e:         IF OPERATOR.ID$ >= "100" AND                                   \
1626: 0470:            OPERATOR.ID$ <= "999" THEN                                  \
1627: 0470:            VALID.OPERATOR.ID = TRUE
1628: 0482: 
1629: 0482:         END FUNCTION
1630: 0499: 
1631: 0499: \******************************************************************************
1632: 0499: \***                                                                          *
1633: 0499: \***    FUNCTION        :       VALID.NAME                                    *
1634: 0499: \***                                                                          *
1635: 0499: \******************************************************************************
1636: 0499: \***                                                                          *
1637: 0499: \***    Checks that the operator name is valid                                *
1638: 0499: \***                                                                          *
1639: 0499: \******************************************************************************
1640: 0499: 
1641: 0499:         FUNCTION VALID.NAME PUBLIC
1642: 04bd: 
1643: 04bd:         INTEGER*1                               VALID.NAME
1644: 04bd: 
1645: 04bd:         VALID.NAME = FALSE
1646: 04cf: 
1647: 04cf:         IF OPERATOR.NAME$ <> "" THEN                                   \
1648: 04ed:            VALID.NAME = TRUE
1649: 04ff: 
1650: 04ff:         END FUNCTION
1651: 0516: 
1652: 0516: \******************************************************************************
1653: 0516: \***                                                                          *
1654: 0516: \***    FUNCTION        :       VALID.PASSWORD                                *
1655: 0516: \***                                                                          *
1656: 0516: \******************************************************************************
1657: 0516: \***                                                                          *
1658: 0516: \***    Checks that the operator password is valid                            *
1659: 0516: \***                                                                          *
1660: 0516: \******************************************************************************
1661: 0516: 
1662: 0516:         FUNCTION VALID.PASSWORD PUBLIC
1663: 053a: 
1664: 053a:         INTEGER*1                               VALID.PASSWORD
1665: 053a: 
1666: 053a:         VALID.PASSWORD = FALSE
1667: 054c: 
1668: 054c:         IF OPERATOR.PASSWORD$ >= "100" AND                             \
1669: 059e:            OPERATOR.PASSWORD$ <= "999" THEN                            \
1670: 059e:            VALID.PASSWORD = TRUE
1671: 05b0: 
1672: 05b0:         END FUNCTION
1673: 05c7: 
1674: 05c7: \******************************************************************************
1675: 05c7: \***                                                                          *
1676: 05c7: \***    FUNCTION        :       VALID.STAFF.NO                                *
1677: 05c7: \***                                                                          *
1678: 05c7: \******************************************************************************
1679: 05c7: \***                                                                          *
1680: 05c7: \***    Checks that the operator staff no is valid                            *
1681: 05c7: \***    If staff no. is zero for boots employee then display error message    *
1682: 05c7: \***                                                                          *
1683: 05c7: \******************************************************************************
1684: 05c7: 
1685: 05c7:         FUNCTION VALID.STAFF.NO(CHECK.NOT.NULL) PUBLIC                 ! 1.9 NM
1686: 05eb: 
1687: 05eb:             INTEGER*1                           VALID.STAFF.NO,   \    ! 1.9 NM
1688: 05eb:                                                 CHECK.NOT.NULL         ! 1.9 NM
1689: 05eb:             VALID.STAFF.NO = FALSE
1690: 05fd:             DISPLAY.MESSAGE.TEXT$ = "Staff Number must be " +     \    ! 1.9 NM
1691: 061b:                                     "zero or greater"                  ! 1.9 NM
1692: 061b: 
1693: 061b:             IF STAFF.NO$ >= "00000000"                            \
1694: 0670:             AND STAFF.NO$ <= "99999999"    THEN BEGIN                  ! 1.9 NM
1695: 0670: 
1696: 0670:                 VALID.STAFF.NO = TRUE                                  ! 1.9 NM
1697: 0682:                 DISPLAY.MESSAGE.TEXT$ = ""                             ! 1.9 NM
1698: 0699: 
1699: 0699:                 IF CHECK.NOT.NULL                                 \    ! 1.9 NM
1700: 06f0:                 AND EMPLOYEE.FLG$ = "Y"                           \    ! 1.9 NM
1701: 06f0:                 AND STAFF.NO$ = "00000000" THEN BEGIN                  ! 1.9 NM
1702: 06f0:                     VALID.STAFF.NO = FALSE                             ! 1.9 NM
1703: 0702:                     DISPLAY.MESSAGE.TEXT$ = "Staff Number  " +    \    ! 1.9 NM
1704: 0724:                                         "must be entered "   +    \    ! 1.9 NM
1705: 0724:                                         "for Boots Employees"          ! 1.9 NM
1706: 0724:                 ENDIF                                                  ! 1.9 NM
1707: 072c: 
1708: 072c:             ENDIF                                                      ! 1.9 NM
1709: 0734: 
1710: 0734:         END FUNCTION
1711: 074b: 
1712: 074b: 
1713: 074b: \******************************************************************************
1714: 074b: \***
1715: 074b: \***    VALID.AF.STAFF.NUM
1716: 074b: \***    Checks whether staff number read from authorisation file is set
1717: 074b: \***    Assumes a non-zero numeric value is a valid staff number
1718: 074b: \***    Checks value on file rather than STAFF.NO$ entered from screen
1719: 074b: \***
1720: 074b: \***...........................................................................
1721: 074b: 
1722: 074b: FUNCTION VALID.AF.STAFF.NUM ! Entire function new for Rv 1.6          ! 1.6 RC
1723: 076f: 
1724: 076f:     STRING    WORK$
1725: 076f:     INTEGER*1 VALID.AF.STAFF.NUM
1726: 076f: 
1727: 076f:     VALID.AF.STAFF.NUM = 0 ! FALSE
1728: 077b: 
1729: 077b:     WORK$ = TRANSLATE$(UNPACK$(AF.STAFF.NUM$), "0123456789#", "########## ")
1730: 07b4: 
1731: 07b4:     IF WORK$ <> "########" THEN EXIT FUNCTION ! Contains non-numeric nibbles
1732: 07d1: 
1733: 07d1:     IF AF.STAFF.NUM$ = PACK$("00000000") THEN EXIT FUNCTION ! No value set
1734: 07f9: 
1735: 07f9:     VALID.AF.STAFF.NUM = -1 ! TRUE
1736: 0805: 
1737: 0805: END FUNCTION
1738: 081c: 
1739: 081c: 
1740: 081c: \******************************************************************************
1741: 081c: \***
1742: 081c: \***    VALID.BIRTH.DATE
1743: 081c: \***    Changes to this function should also be effected within PSB9902
1744: 081c: \***    function VALID.DDMCYY.
1745: 081c: \***
1746: 081c: \***    Confirms BIRTH.DATE$ is a valid date with a realistic century.
1747: 081c: \***    Confirms BIRTH.DATE$ is date of 14th birthday or later.
1748: 081c: \***    Confirms BIRTH.DATE$ is before 100th birthday.
1749: 081c: \***    Birth date is rejected if operator age is 13yrs X months but is
1750: 081c: \***    accepted from 14th birthday onwards.
1751: 081c: \***    Birth date is accepted if operator age is 99yrs X months but is
1752: 081c: \***    rejected from 100th birthday onwards
1753: 081c: \***
1754: 081c: \***...........................................................................
1755: 081c: 
1756: 081c: FUNCTION VALID.BIRTH.DATE ! Entire function new for Rv 1.6             ! 1.6 RC
1757: 0840: 
1758: 0840:     STRING    YYMMDD$
1759: 0840:     STRING    WORK$
1760: 0840:     INTEGER*1 VALID.BIRTH.DATE
1761: 0840:     INTEGER*4 CCYYMMDD%
1762: 0840: 
1763: 0840:     VALID.BIRTH.DATE = 0 ! FALSE
1764: 084c: 
1765: 084c: !   Confirm BIRTH.DATE$ is eight bytes numeric data
1766: 084c: 
1767: 084c:     WORK$ = TRANSLATE$(BIRTH.DATE$, "0123456789#", "########## ")
1768: 0875: 
1769: 0875:     IF WORK$ <> "########" THEN BEGIN
1770: 0890:        DISPLAY.MESSAGE.NUMBER% = 123 ! B123 INVALID DATE SPECIFIED
1771: 08a1:        EXIT FUNCTION ! Not eight bytes numeric
1772: 08ac:      ENDIF
1773: 08b4: 
1774: 08b4: !   Confirm BIRTH.DATE$ has a sensible CC component                    ! 1.8 RC
1775: 08b4: 
1776: 08b4:     IF   VAL( MID$(BIRTH.DATE$,5,2) ) < 19 \                           ! 1.8 RC
1777: 0963:       OR VAL( MID$(BIRTH.DATE$,5,2) ) > 20 THEN BEGIN \                ! 1.8 RC
1778: 0963:         DISPLAY.MESSAGE.NUMBER% = 123 ! B123 INVALID DATE SPECIFIED    ! 1.8 RC
1779: 0974:         EXIT FUNCTION ! Unrealistic century                            ! 1.8 RC
1780: 097f:     ENDIF                                                              ! 1.8 RC
1781: 0987: 
1782: 0987: !   Confirm BIRTH.DATE$ has a valid YYMMDD combination
1783: 0987: 
1784: 0987:     YYMMDD$ = MID$(BIRTH.DATE$,7,2) + \   ! Valid BIRTH.DATE$ has
1785: 09ed:               MID$(BIRTH.DATE$,3,2) + \   ! unpacked DDMMCCYY format
1786: 09ed:               MID$(BIRTH.DATE$,1,2)
1787: 09ed: 
1788: 09ed:     IF NOT VALID.YYMMDD (YYMMDD$) THEN BEGIN ! Invalid date
1789: 0a09:        DISPLAY.MESSAGE.NUMBER% = 123 ! B123 INVALID DATE SPECIFIED
1790: 0a1a:        EXIT FUNCTION
1791: 0a25:     ENDIF
1792: 0a2d: 
1793: 0a2d: !   Reject birth date when age is before 14th birthday                 ! 1.8 RC
1794: 0a2d: !     "B196 Value entered must be dd/mm/ccyy or earlier                ! 1.8 RC
1795: 0a2d: !             (minimum age allowed is 14)"                             ! 1.8 RC
1796: 0a2d: 
1797: 0a2d:     CCYYMMDD% = VAL( MID$(BIRTH.DATE$,5,2) + YYMMDD$ ) \               ! 1.8 RC
1798: 0aa6:                   + 140000 ! Adds 14 years to birth date               ! 1.8 RC
1799: 0aa6: 
1800: 0aa6:     IF CCYYMMDD% > VAL("20" + DATE$) THEN BEGIN
1801: 0afc:         DISPLAY.MESSAGE.NUMBER% = 196 ! B196 Value entered must be ...
1802: 0b0d:         DISPLAY.MESSAGE.TEXT$ = \                                      ! 1.7 RC
1803: 0be6:           MID$(DATE$,5,2) + "/" + \                ! DD
1804: 0be6:           MID$(DATE$,3,2) + "/" + \                ! MM
1805: 0be6:           STR$(VAL("20" + MID$(DATE$,1,2))-14) + \ ! CCYY -14 years
1806: 0be6:                              " or earlier (minimum age allowed is 14)" ! 1.7 RC
1807: 0be6:         EXIT FUNCTION
1808: 0bf1:     ENDIF
1809: 0bf9: 
1810: 0bf9: !   Reject birth date when age is on or after 100th birthday           ! 1.8 RC
1811: 0bf9: !     "B196 Value entered must be later than dd/mm/ccyy                ! 1.8 RC
1812: 0bf9: !             (maximum age allowed is 99)"                             ! 1.8 RC
1813: 0bf9: 
1814: 0bf9:     CCYYMMDD% = VAL( MID$(BIRTH.DATE$,5,2) + YYMMDD$ ) \               ! 1.8 RC
1815: 0c72:                   + 1000000 ! Adds 100 years to birth date             ! 1.8 RC
1816: 0c72: 
1817: 0c72:     IF CCYYMMDD% <= VAL("20" + DATE$) THEN BEGIN                       ! 1.8 RC
1818: 0cc8:         DISPLAY.MESSAGE.NUMBER% = 196 ! B196 Value entered must be ... ! 1.8 RC
1819: 0cd9:         DISPLAY.MESSAGE.TEXT$ = "later than " + \                      ! 1.8 RC
1820: 0db6:           MID$(DATE$,5,2) + "/" + \                 ! DD               ! 1.8 RC
1821: 0db6:           MID$(DATE$,3,2) + "/" + \                 ! MM               ! 1.8 RC
1822: 0db6:           STR$(VAL("20" + MID$(DATE$,1,2))-100) + \ ! CCYY -100 years  ! 1.8 RC
1823: 0db6:                              " (maximum age allowed is 99)"            ! 1.8 RC
1824: 0db6:         EXIT FUNCTION                                                  ! 1.8 RC
1825: 0dc0:     ENDIF                                                              ! 1.8 RC
1826: 0dc8: 
1827: 0dc8:     VALID.BIRTH.DATE = -1 ! TRUE
1828: 0dd4: 
1829: 0dd4: END FUNCTION
1830: 0deb: 
1831: 0deb: 
1832: 0deb: \******************************************************************************
1833: 0deb: \***                                                                          *
1834: 0deb: \***    FUNCTION        :       VALID.EMPLOYEE.FLG                            *
1835: 0deb: \***                                                                          *
1836: 0deb: \******************************************************************************
1837: 0deb: \***                                                                          *
1838: 0deb: \***    Checks that the employee flag is valid                                *
1839: 0deb: \***                                                                          *
1840: 0deb: \******************************************************************************
1841: 0deb: 
1842: 0deb:         FUNCTION VALID.EMPLOYEE.FLG PUBLIC
1843: 0e0f: 
1844: 0e0f:         INTEGER*1                               VALID.EMPLOYEE.FLG
1845: 0e0f: 
1846: 0e0f:         VALID.EMPLOYEE.FLG = FALSE
1847: 0e21: 
1848: 0e21:         IF EMPLOYEE.FLG$ = "Y" OR                                        \
1849: 0e73:            EMPLOYEE.FLG$ = "N" THEN                                      \
1850: 0e73:            VALID.EMPLOYEE.FLG = TRUE
1851: 0e85: 
1852: 0e85:         END FUNCTION
1853: 0e9c: 
1854: 0e9c: 
1855: 0e9c: \******************************************************************************
1856: 0e9c: \***                                                                          *
1857: 0e9c: \***    FUNCTION        :       VALID.GROUP.CODE                  ! AJC  1.4  *
1858: 0e9c: \***                                                                          *
1859: 0e9c: \******************************************************************************
1860: 0e9c: \***                                                                          *
1861: 0e9c: \***    Checks that GROUP CODE for Beauty Commission is valid                 *
1862: 0e9c: \***                                                                          *
1863: 0e9c: \******************************************************************************
1864: 0e9c: 
1865: 0e9c:         FUNCTION VALID.GROUP.CODE PUBLIC                                ! AJC 1.4
1866: 0ec0: 
1867: 0ec0:         INTEGER*1                               VALID.GROUP.CODE        ! AJC 1.4
1868: 0ec0: 
1869: 0ec0:         VALID.GROUP.CODE = FALSE                                        ! AJC 1.4
1870: 0ed2: 
1871: 0ed2:         IF GROUP.CODE$  >= "00" AND                                     \ AJC 1.4
1872: 0f24:            GROUP.CODE$  <= "99" THEN                                    \ AJC 1.4
1873: 0f24:            VALID.GROUP.CODE = TRUE                                      ! AJC 1.4
1874: 0f36: 
1875: 0f36:         END FUNCTION                                                    ! AJC 1.4
1876: 0f4d: 
1877: 0f4d: \******************************************************************************
1878: 0f4d: \***                                                                          *
1879: 0f4d: \***    FUNCTION        :       VALID.MODEL.FLAG                              *
1880: 0f4d: \***                                                                          *
1881: 0f4d: \******************************************************************************
1882: 0f4d: \***                                                                          *
1883: 0f4d: \***    Checks that the model flag is valid                                   *
1884: 0f4d: \***                                                                          *
1885: 0f4d: \******************************************************************************
1886: 0f4d: 
1887: 0f4d:         FUNCTION VALID.MODEL.FLAG PUBLIC
1888: 0f71: 
1889: 0f71:         INTEGER*1                               VALID.MODEL.FLAG
1890: 0f71: 
1891: 0f71:         VALID.MODEL.FLAG = FALSE
1892: 0f83: 
1893: 0f83:         IF MODEL.FLAG$ = "Y" OR                                        \
1894: 0fd5:            MODEL.FLAG$ = "N" THEN                                      \
1895: 0fd5:            VALID.MODEL.FLAG = TRUE
1896: 0fe7: 
1897: 0fe7:         END FUNCTION
1898: 0ffe: 
1899: 0ffe: \******************************************************************************
1900: 0ffe: \***                                                                          *
1901: 0ffe: \***    FUNCTION        :       VALID.CONFIRM                                 *
1902: 0ffe: \***                                                                          *
1903: 0ffe: \******************************************************************************
1904: 0ffe: \***                                                                          *
1905: 0ffe: \***    Checks that the confirmation entry is valid                           *
1906: 0ffe: \***                                                                          *
1907: 0ffe: \******************************************************************************
1908: 0ffe: 
1909: 0ffe:         FUNCTION VALID.CONFIRM PUBLIC
1910: 1022: 
1911: 1022:         INTEGER*1                               VALID.CONFIRM
1912: 1022: 
1913: 1022:         VALID.CONFIRM = FALSE
1914: 1034: 
1915: 1034:         IF CONFIRM$ = "Y" OR                                           \
1916: 1086:            CONFIRM$ = "N" THEN                                         \
1917: 1086:            VALID.CONFIRM = TRUE
1918: 1098: 
1919: 1098:         END FUNCTION
1920: 10af: 
1921: 10af: 
1922: 10af: \******************************************************************************
1923: 10af: \***                                                                          *
1924: 10af: \***    FUNCTION        :       VALID.RECEIPT.NAME                    ! AJC   *
1925: 10af: \***                                                                          *
1926: 10af: \******************************************************************************
1927: 10af: \***                                                                          *
1928: 10af: \***    Checks that the name to be printed on the receipt is valid    ! AJC   *
1929: 10af: \***                                                                          *
1930: 10af: \******************************************************************************
1931: 10af: 
1932: 10af:         FUNCTION VALID.RECEIPT.NAME PUBLIC                            ! AJC
1933: 10d3: 
1934: 10d3:         INTEGER*1                               VALID.RECEIPT.NAME    ! AJC
1935: 10d3: 
1936: 10d3:         VALID.RECEIPT.NAME = FALSE                                    ! AJC
1937: 10e5: 
1938: 10e5:         FOR I% = 1 TO 12                                     !
1939: 10f9: 
1940: 10f9:             IF I% = 1 THEN BEGIN
1941: 110e:             IF LEFT$(RECEIPT.NAME$, I% + 1) = PACK$("0000")  \!OR
1942: 114f:                    THEN BEGIN                                !
1943: 114f:               RECEIPT.NAME$ = (" ")                         \
1944: 1184:                             + RIGHT$(RECEIPT.NAME$, I% + 10)
1945: 1184:             ENDIF
1946: 118c:             ENDIF
1947: 1194: 
1948: 1194:             IF I% = 12 THEN BEGIN
1949: 11a9:             IF RIGHT$(RECEIPT.NAME$, 1) = PACK$("00")   \
1950: 11e1:                       THEN BEGIN                                !
1951: 11e1:             RECEIPT.NAME$ = LEFT$(RECEIPT.NAME$, I% - 1 ) + " " !
1952: 1221:             ENDIF
1953: 1229:             ENDIF
1954: 1231: 
1955: 1231:             IF I% > 1 AND I% < 12 THEN BEGIN
1956: 1260:             IF MID$(RECEIPT.NAME$, I%, I% + 1) = PACK$("0000000000000000") OR  \
1957: 14cd:                MID$(RECEIPT.NAME$, I%, I% + 1) = PACK$("00000000000000") OR  \
1958: 14cd:                MID$(RECEIPT.NAME$, I%, I% + 1) = PACK$("000000000000") OR  \
1959: 14cd:                MID$(RECEIPT.NAME$, I%, I% + 1) = PACK$("0000000000") OR  \
1960: 14cd:                MID$(RECEIPT.NAME$, I%, I% + 1) = PACK$("00000000") OR  \
1961: 14cd:                MID$(RECEIPT.NAME$, I%, I% + 1) = PACK$("000000") OR  \
1962: 14cd:                MID$(RECEIPT.NAME$, I%, I% + 1) = PACK$("0000") OR  \
1963: 14cd:                MID$(RECEIPT.NAME$, I%, I% + 1) = PACK$("00")   \
1964: 14cd:                    THEN BEGIN                                !
1965: 14cd:               RECEIPT.NAME$ = LEFT$(RECEIPT.NAME$, I% - 1) + " " \
1966: 1528:                               + RIGHT$(RECEIPT.NAME$, 12 - I%)
1967: 1528:             ENDIF                                             !
1968: 1530:             ENDIF                                             !
1969: 1538: 
1970: 1538:         NEXT I%                                              !
1971: 155c: 
1972: 155c:         IF RECEIPT.NAME$ <> "" THEN                                  \! AJC
1973: 157a:            VALID.RECEIPT.NAME = TRUE                                  ! AJC
1974: 158c: 
1975: 158c:         END FUNCTION                                                  ! AJC
1976: 15a3: 
1977: 15a3: \******************************************************************************
1978: 15a3: \***                                                                          *
1979: 15a3: \***    FUNCTION        :       READ.CSOUF.RECORD                             *
1980: 15a3: \***                                                                          *
1981: 15a3: \******************************************************************************
1982: 15a3: \***                                                                          *
1983: 15a3: \***    Read a record from the ADXCSOUF file                                  *
1984: 15a3: \***                                                                          *
1985: 15a3: \******************************************************************************
1986: 15a3: 
1987: 15a3:         FUNCTION READ.CSOUF.RECORD PUBLIC
1988: 15c7: 
1989: 15c7:         INTEGER*1                               READ.CSOUF.RECORD
1990: 15c7: 
1991: 15c7:         READ.CSOUF.RECORD = 1
1992: 15d3: 
1993: 15d3:         IF END # CSOUF.SESS.NUM% THEN CSOUF.READ.ERROR
1994: 15ef:         READ FORM "C34"; # CSOUF.SESS.NUM%, CSOUF.REC.NUM%; CSOUF.RECORD$
1995: 1629: 
1996: 1629:         READ.CSOUF.RECORD = 0
1997: 1635: 
1998: 1635:         EXIT FUNCTION
1999: 163f: 
2000: 163f:         CSOUF.READ.ERROR:
2001: 164f: 
2002: 164f:         CURRENT.REPORT.NUM% = CSOUF.REPORT.NUM%
2003: 1665:         FILE.OPERATION$ = "R"
2004: 167c:         CURRENT.CODE$ = ""
2005: 1693: 
2006: 1693:         END FUNCTION
2007: 16aa: 
2008: 16aa: \******************************************************************************
2009: 16aa: \***                                                                          *
2010: 16aa: \***    FUNCTION        :       DELETE.CSOUF.RECORD                           *
2011: 16aa: \***                                                                          *
2012: 16aa: \******************************************************************************
2013: 16aa: \***                                                                          *
2014: 16aa: \***    Delete a record from the ADXCSOUF file                                *
2015: 16aa: \***                                                                          *
2016: 16aa: \******************************************************************************
2017: 16aa: 
2018: 16aa:         FUNCTION DELETE.CSOUF.RECORD PUBLIC
2019: 16ce: 
2020: 16ce:         INTEGER*1                               DELETE.CSOUF.RECORD
2021: 16ce: 
2022: 16ce:         DELETE.CSOUF.RECORD = 1
2023: 16da: 
2024: 16da:         IF END # CSOUF.SESS.NUM% THEN CSOUF.WRITE.ERROR
2025: 16f6:         WRITE FORM "C34"; # CSOUF.SESS.NUM%, CSOUF.REC.NUM%; CSOUF.RECORD$
2026: 1730: 
2027: 1730:         DELETE.CSOUF.RECORD = 0
2028: 173c: 
2029: 173c:         EXIT FUNCTION
2030: 1746: 
2031: 1746:         CSOUF.WRITE.ERROR:
2032: 1756: 
2033: 1756:         CURRENT.REPORT.NUM% = CSOUF.REPORT.NUM%
2034: 176c:         FILE.OPERATION$ = "W"
2035: 1783:         CURRENT.CODE$ = ""
2036: 179a: 
2037: 179a:         END FUNCTION
2038: 17b1: 
2039: 17b1: \******************************************************************************
2040: 17b1: \***                                                                          *
2041: 17b1: \***    FUNCTION        :       FORMAT.DATE$                                  *
2042: 17b1: \***                                                                          *
2043: 17b1: \******************************************************************************
2044: 17b1: \***                                                                          *
2045: 17b1: \***    Format the date for displaying on the screen                          *
2046: 17b1: \***                                                                          *
2047: 17b1: \******************************************************************************
2048: 17b1: 
2049: 17b1:         FUNCTION FORMAT.DATE$(D$) PUBLIC
2050: 17da: 
2051: 17da:         STRING                                  D$,                    \
2052: 17da:                                                 DAY$,                  \
2053: 17da:                                                 MONTH$,                \
2054: 17da:                                                 YEAR$,                 \
2055: 17da:                                                 CENTURY$,              \
2056: 17da:                                                 FORMAT.DATE$
2057: 17da: 
2058: 17da:         DAY$     = RIGHT$("  " + STR$(VAL(MID$(D$,5,2))),2)
2059: 183c:         MONTH$   = MONTH.ARRAY$(VAL(MID$(D$,3,2)))
2060: 1879:         YEAR$    = MID$(D$,1,2)
2061: 1899:         CENTURY$ = "19"
2062: 18ae: 
2063: 18ae:         IF VAL(YEAR$) < 80 THEN                                        \
2064: 18e0:         BEGIN
2065: 18e0:            CENTURY$ = "20"
2066: 18f5:         ENDIF
2067: 18fd: 
2068: 18fd:         FORMAT.DATE$ = DAY$ + " " + MONTH$ + " " + CENTURY$ + YEAR$
2069: 193a: 
2070: 193a:         END FUNCTION
2071: 1958: 
2072: 1958: 
2073: 1958: \******************************************************************************
2074: 1958: \***
2075: 1958: \***    DEFINITIONS OF EXTERNAL SUBPROGRAMS SEPARATED INTO PSB9902     ! 1.5 RC
2076: 1958: \***
2077: 1958: \***...........................................................................
2078: 1958: 
2079: 1958: 
2080: 1958: SUB SB.FILE.UTILS EXTERNAL ! PSB9902                                   ! 1.5 RC
2081: 1958: END SUB                                                                ! 1.5 RC
2082: 1958: 
2083: 1958: SUB GET.INPUT EXTERNAL ! PSB9902                                       ! 1.5 RC
2084: 1958: END SUB                                                                ! 1.5 RC
2085: 1958: 
2086: 1958: SUB PUT.CURSOR.IN.FIELD EXTERNAL ! PSB9902                             ! 1.5 RC
2087: 1958: END SUB                                                                ! 1.5 RC
2088: 1958: 
2089: 1958: SUB RESUME.INPUT EXTERNAL ! PSB9902                                    ! 1.5 RC
2090: 1958: END SUB                                                                ! 1.5 RC
2091: 1958: 
2092: 1958: SUB SET.CURSOR.STATE EXTERNAL ! PSB9902                                ! 1.5 RC
2093: 1958: END SUB                                                                ! 1.5 RC
2094: 1958: 
2095: 1958: SUB SET.FIELD EXTERNAL ! PSB9902                                       ! 1.5 RC
2096: 1958: END SUB                                                                ! 1.5 RC
2097: 1958: 
2098: 1958: SUB SET.FIELD.ATTRIBUTES EXTERNAL ! PSB9902                            ! 1.5 RC
2099: 1958: END SUB                                                                ! 1.5 RC
2100: 1958: 
2101: 1958: SUB CLEAR.MESSAGE EXTERNAL ! PSB9902                                   ! 1.5 RC
2102: 1958: END SUB                                                                ! 1.5 RC
2103: 1958: 
2104: 1958: SUB DISPLAY.MESSAGE EXTERNAL ! PSB9902                                 ! 1.5 RC
2105: 1958: END SUB                                                                ! 1.5 RC
2106: 1958: 
2107: 1958: SUB WAIT.MESSAGE EXTERNAL ! PSB9902                                    ! 1.5 RC
2108: 1958: END SUB                                                                ! 1.5 RC
2109: 1958: 
2110: 1958: SUB CHAIN.TO.CALLER EXTERNAL ! PSB9902                                 ! 1.5 RC
2111: 1958: END SUB                                                                ! 1.5 RC
2112: 1958: 
2113: 1958: SUB CLEAR.MODEL.FLAGS EXTERNAL ! PSB9902                               ! 1.5 RC
2114: 1958: END SUB                                                                ! 1.5 RC
2115: 1958: 
2116: 1958: SUB DISPLAY.FORMATTED.DATE EXTERNAL ! PSB9902                          ! 1.5 RC
2117: 1958: END SUB                                                                ! 1.5 RC
2118: 1958: 
2119: 1958: SUB GET.CSOUF.RECORD EXTERNAL ! PSB9902                                ! 1.5 RC
2120: 1958: END SUB                                                                ! 1.5 RC
2121: 1958: 
2122: 1958: SUB GET.OPERATOR.DETAILS EXTERNAL ! PSB9902                            ! 1.5 RC
2123: 1958: END SUB                                                                ! 1.5 RC
2124: 1958: 
2125: 1958: SUB HIDE.CONFIRM.MESSAGE EXTERNAL ! PSB9902                            ! 1.5 RC
2126: 1958: END SUB                                                                ! 1.5 RC
2127: 1958: 
2128: 1958: SUB RESET.MODEL.FLAGS EXTERNAL ! PSB9902                               ! 1.5 RC
2129: 1958: END SUB                                                                ! 1.5 RC
2130: 1958: 
2131: 1958: SUB RESTORE.MODEL.FLAGS EXTERNAL ! PSB9902                             ! 1.5 RC
2132: 1958: END SUB                                                                ! 1.5 RC
2133: 1958: 
2134: 1958: 
2135: 1958: \******************************************************************************
2136: 1958: \***                                                                          *
2137: 1958: \***    SUBROUTINE      :       RESTORE.FIELDS.02                             *
2138: 1958: \***                                                                          *
2139: 1958: \******************************************************************************
2140: 1958: \***                                                                          *
2141: 1958: \***    Redisplay all fields for the add an operator screen                   *
2142: 1958: \***                                                                          *
2143: 1958: \******************************************************************************
2144: 1958: 
2145: 1958: SUB     RESTORE.FIELDS.02 PUBLIC                                       ! 1.5 RC
2146: 197c: 
2147: 197c:         CURSOR.STATE$ = CURSOR.OFF$
2148: 199a:         CALL SET.CURSOR.STATE                                          ! 1.5 RC
2149: 19a7: 
2150: 19a7:         CALL DISPLAY.FORMATTED.DATE                                    ! 1.5 RC
2151: 19b4: 
2152: 19b4:         CURSOR.POSITION% = S2.OPERATOR.ID%
2153: 19ca:         CALL PUT.CURSOR.IN.FIELD                                       ! 1.5 RC
2154: 19d7: 
2155: 19d7:         IF VAL(OPERATOR.ID$) > 0 THEN                                  \
2156: 1a0c:         BEGIN
2157: 1a0c:            OPERATOR.ID$ = STR$(VAL(OPERATOR.ID$))
2158: 1a3b:         ENDIF                                                          \
2159: 1a3b:         ELSE                                                           \
2160: 1a43:         BEGIN
2161: 1a43:            OPERATOR.ID$ = ""
2162: 1a5a:         ENDIF
2163: 1a62: 
2164: 1a62:         STRING.DATA$ = OPERATOR.ID$
2165: 1a80:         CALL SET.FIELD                                                 ! 1.5 RC
2166: 1a8d: 
2167: 1a8d:         CURSOR.POSITION% = S2.NAME%
2168: 1aa3:         CALL PUT.CURSOR.IN.FIELD                                       ! 1.5 RC
2169: 1ab0: 
2170: 1ab0:         STRING.DATA$ = OPERATOR.NAME$
2171: 1ace:         CALL SET.FIELD                                                 ! 1.5 RC
2172: 1adb: 
2173: 1adb:         CURSOR.POSITION% = S2.PASSWORD%
2174: 1af1:         CALL PUT.CURSOR.IN.FIELD                                       ! 1.5 RC
2175: 1afe: 
2176: 1afe:         IF VAL(OPERATOR.PASSWORD$) > 0 THEN                            \
2177: 1b33:         BEGIN
2178: 1b33:            OPERATOR.PASSWORD$ = STR$(VAL(OPERATOR.PASSWORD$))
2179: 1b62:         ENDIF                                                          \
2180: 1b62:         ELSE                                                           \
2181: 1b6a:         BEGIN
2182: 1b6a:            OPERATOR.PASSWORD$ = ""
2183: 1b81:         ENDIF
2184: 1b89: 
2185: 1b89:         STRING.DATA$ = OPERATOR.PASSWORD$
2186: 1ba7:         CALL SET.FIELD                                                 ! 1.5 RC
2187: 1bb4: 
2188: 1bb4:         CURSOR.POSITION% = S2.STAFF.NO%
2189: 1bca:         CALL PUT.CURSOR.IN.FIELD                                       ! 1.5 RC
2190: 1bd7: 
2191: 1bd7:         STRING.DATA$ = STAFF.NO$
2192: 1bf5:         CALL SET.FIELD                                                 ! 1.5 RC
2193: 1c02: 
2194: 1c02:         CURSOR.POSITION% = S2.RECEIPT.NAME%                           ! AJC
2195: 1c18:         CALL PUT.CURSOR.IN.FIELD                                       ! 1.5 RC
2196: 1c25: 
2197: 1c25:         STRING.DATA$ = RECEIPT.NAME$                                  ! AJC
2198: 1c43:         CALL SET.FIELD                                                 ! 1.5 RC
2199: 1c50: 
2200: 1c50:         CURSOR.POSITION% = S2.BIRTH.DATE%                              ! 1.6 RC
2201: 1c66:         CALL PUT.CURSOR.IN.FIELD                                       ! 1.6 RC
2202: 1c73: 
2203: 1c73:         IF BIRTH.DATE$ <> "" THEN BEGIN \                              ! 1.6 RC
2204: 1c91:             STRING.DATA$ = MID$(BIRTH.DATE$,1,2) + "/" + \             ! 1.6 RC
2205: 1d01:                            MID$(BIRTH.DATE$,3,2) + "/" + \             ! 1.6 RC
2206: 1d01:                            MID$(BIRTH.DATE$,5,4)                       ! 1.6 RC
2207: 1d01:         ENDIF                                                          ! 1.6 RC
2208: 1d09:         CALL SET.FIELD                                                 ! 1.6 RC
2209: 1d16: 
2210: 1d16:         CURSOR.POSITION% = S2.GROUP.CODE%                             ! AJC 1.4
2211: 1d2c:         CALL PUT.CURSOR.IN.FIELD                                       ! 1.5 RC
2212: 1d39: 
2213: 1d39:         STRING.DATA$ = GROUP.CODE$                                    ! AJC 1.4
2214: 1d57:         CALL SET.FIELD                                                 ! 1.5 RC
2215: 1d64: 
2216: 1d64:         CURSOR.POSITION% = S2.EMPLOYEE.FLG%
2217: 1d7a:         CALL PUT.CURSOR.IN.FIELD                                       ! 1.5 RC
2218: 1d87: 
2219: 1d87:         STRING.DATA$ = EMPLOYEE.FLG$
2220: 1da5:         CALL SET.FIELD                                                 ! 1.5 RC
2221: 1db2: 
2222: 1db2:         CALL RESTORE.MODEL.FLAGS                                       ! 1.5 RC
2223: 1dbf: 
2224: 1dbf:         CURSOR.POSITION% = S2.CONFIRM%
2225: 1dd5:         CALL PUT.CURSOR.IN.FIELD                                       ! 1.5 RC
2226: 1de2: 
2227: 1de2:         STRING.DATA$ = CONFIRM$
2228: 1e00:         CALL SET.FIELD                                                 ! 1.5 RC
2229: 1e0d: 
2230: 1e0d:         CURSOR.STATE$ = CURSOR.ON$
2231: 1e2b:         CALL SET.CURSOR.STATE                                          ! 1.5 RC
2232: 1e38: 
2233: 1e38: END SUB                                                                ! 1.5 RC
2234: 1e4c: 
2235: 1e4c: 
2236: 1e4c: \******************************************************************************
2237: 1e4c: \***                                                                          *
2238: 1e4c: \***    SUBROUTINE      :       RESTORE.FIELDS.04                             *
2239: 1e4c: \***                                                                          *
2240: 1e4c: \******************************************************************************
2241: 1e4c: \***                                                                          *
2242: 1e4c: \***    Redisplay all fields for the change operator screen                   *
2243: 1e4c: \***                                                                          *
2244: 1e4c: \******************************************************************************
2245: 1e4c: 
2246: 1e4c: SUB     RESTORE.FIELDS.04 PUBLIC                                       ! 1.5 RC
2247: 1e70: 
2248: 1e70:         CURSOR.STATE$ = CURSOR.OFF$
2249: 1e8e:         CALL SET.CURSOR.STATE                                          ! 1.5 RC
2250: 1e9b: 
2251: 1e9b:         CALL DISPLAY.FORMATTED.DATE                                    ! 1.5 RC
2252: 1ea8: 
2253: 1ea8:         CURSOR.POSITION% = S4.OPERATOR.ID%
2254: 1ebe:         CALL PUT.CURSOR.IN.FIELD                                       ! 1.5 RC
2255: 1ecb: 
2256: 1ecb:         IF VAL(OPERATOR.ID$) > 0 THEN                                  \
2257: 1f00:         BEGIN
2258: 1f00:            OPERATOR.ID$ = STR$(VAL(OPERATOR.ID$))
2259: 1f2f:         ENDIF                                                          \
2260: 1f2f:         ELSE                                                           \
2261: 1f37:         BEGIN
2262: 1f37:            OPERATOR.ID$ = ""
2263: 1f4e:         ENDIF
2264: 1f56: 
2265: 1f56:         STRING.DATA$ = OPERATOR.ID$
2266: 1f74:         CALL SET.FIELD                                                 ! 1.5 RC
2267: 1f81: 
2268: 1f81:         CURSOR.POSITION% = S4.NAME%
2269: 1f97:         CALL PUT.CURSOR.IN.FIELD                                       ! 1.5 RC
2270: 1fa4: 
2271: 1fa4:         STRING.DATA$ = OPERATOR.NAME$
2272: 1fc2:         CALL SET.FIELD                                                 ! 1.5 RC
2273: 1fcf: 
2274: 1fcf:         CURSOR.POSITION% = S4.STAFF.NO%
2275: 1fe5:         CALL PUT.CURSOR.IN.FIELD                                       ! 1.5 RC
2276: 1ff2: 
2277: 1ff2:         STRING.DATA$ = STAFF.NO$
2278: 2010:         CALL SET.FIELD                                                 ! 1.5 RC
2279: 201d: 
2280: 201d:         CURSOR.POSITION% = S4.BIRTH.DATE%                              ! 1.6 RC
2281: 2033:         CALL PUT.CURSOR.IN.FIELD                                       ! 1.6 RC
2282: 2040: 
2283: 2040:         IF BIRTH.DATE$ <> "" THEN BEGIN \                              ! 1.6 RC
2284: 205e:             STRING.DATA$ = MID$(BIRTH.DATE$,1,2) + \                   ! 1.6 RC
2285: 20c6:                            MID$(BIRTH.DATE$,3,2) + \                   ! 1.6 RC
2286: 20c6:                            MID$(BIRTH.DATE$,5,4)                       ! 1.6 RC
2287: 20c6:         ENDIF                                                          ! 1.6 RC
2288: 20ce:         CALL SET.FIELD                                                 ! 1.6 RC
2289: 20db: 
2290: 20db:         CURSOR.POSITION% = S4.RECEIPT.NAME%                           ! AJC
2291: 20f1:         CALL PUT.CURSOR.IN.FIELD                                       ! 1.5 RC
2292: 20fe: 
2293: 20fe:         STRING.DATA$ = RECEIPT.NAME$                                  ! AJC
2294: 211c:         CALL SET.FIELD                                                 ! 1.5 RC
2295: 2129: 
2296: 2129:         CURSOR.POSITION% = S4.GROUP.CODE%                             ! AJC 1.4
2297: 213f:         CALL PUT.CURSOR.IN.FIELD                                       ! 1.5 RC
2298: 214c: 
2299: 214c:         STRING.DATA$ = GROUP.CODE$                                    ! AJC 1.4
2300: 216a:         CALL SET.FIELD                                                 ! 1.5 RC
2301: 2177: 
2302: 2177:         CURSOR.POSITION% = S4.EMPLOYEE.FLG%
2303: 218d:         CALL PUT.CURSOR.IN.FIELD                                       ! 1.5 RC
2304: 219a: 
2305: 219a:         STRING.DATA$ = EMPLOYEE.FLG$
2306: 21b8:         CALL SET.FIELD                                                 ! 1.5 RC
2307: 21c5: 
2308: 21c5:         CALL RESTORE.MODEL.FLAGS                                       ! 1.5 RC
2309: 21d2: 
2310: 21d2:         CURSOR.POSITION% = S2.CONFIRM%
2311: 21e8:         CALL PUT.CURSOR.IN.FIELD                                       ! 1.5 RC
2312: 21f5: 
2313: 21f5:         STRING.DATA$ = CONFIRM$
2314: 2213:         CALL SET.FIELD                                                 ! 1.5 RC
2315: 2220: 
2316: 2220:         CURSOR.STATE$ = CURSOR.ON$
2317: 223e:         CALL SET.CURSOR.STATE                                          ! 1.5 RC
2318: 224b: 
2319: 224b: END SUB                                                                ! 1.5 RC
2320: 225f: 
2321: 225f: 
2322: 225f: \******************************************************************************
2323: 225f: \***                                                                          *
2324: 225f: \***    SUBROUTINE      :       RESTORE.FIELDS.05                             *
2325: 225f: \***                                                                          *
2326: 225f: \******************************************************************************
2327: 225f: \***                                                                          *
2328: 225f: \***    Redisplay all fields for the set operator password screen             *
2329: 225f: \***                                                                          *
2330: 225f: \******************************************************************************
2331: 225f: 
2332: 225f: SUB     RESTORE.FIELDS.05 PUBLIC                                       ! 1.5 RC
2333: 2283: 
2334: 2283:         CURSOR.STATE$ = CURSOR.OFF$
2335: 22a1:         CALL SET.CURSOR.STATE                                          ! 1.5 RC
2336: 22ae: 
2337: 22ae:         CALL DISPLAY.FORMATTED.DATE                                    ! 1.5 RC
2338: 22bb: 
2339: 22bb:         CURSOR.POSITION% = S5.OPERATOR.ID%
2340: 22d1:         CALL PUT.CURSOR.IN.FIELD                                       ! 1.5 RC
2341: 22de: 
2342: 22de:         IF VAL(OPERATOR.ID$) > 0 THEN                                  \
2343: 2313:         BEGIN
2344: 2313:            OPERATOR.ID$ = STR$(VAL(OPERATOR.ID$))
2345: 2342:         ENDIF                                                          \
2346: 2342:         ELSE                                                           \
2347: 234a:         BEGIN
2348: 234a:            OPERATOR.ID$ = ""
2349: 2361:         ENDIF
2350: 2369: 
2351: 2369:         STRING.DATA$ = OPERATOR.ID$
2352: 2387:         CALL SET.FIELD                                                 ! 1.5 RC
2353: 2394: 
2354: 2394:         CURSOR.POSITION% = S5.NAME%
2355: 23aa:         CALL PUT.CURSOR.IN.FIELD                                       ! 1.5 RC
2356: 23b7: 
2357: 23b7:         STRING.DATA$ = OPERATOR.NAME$
2358: 23d5:         CALL SET.FIELD                                                 ! 1.5 RC
2359: 23e2: 
2360: 23e2:         CURSOR.POSITION% = S5.PASSWORD%
2361: 23f8:         CALL PUT.CURSOR.IN.FIELD                                       ! 1.5 RC
2362: 2405: 
2363: 2405:         IF VAL(OPERATOR.PASSWORD$) > 0 THEN                            \
2364: 243a:         BEGIN
2365: 243a:            OPERATOR.PASSWORD$ = STR$(VAL(OPERATOR.PASSWORD$))
2366: 2469:         ENDIF                                                          \
2367: 2469:         ELSE                                                           \
2368: 2471:         BEGIN
2369: 2471:            OPERATOR.PASSWORD$ = ""
2370: 2488:         ENDIF
2371: 2490: 
2372: 2490:         STRING.DATA$ = OPERATOR.PASSWORD$
2373: 24ae:         CALL SET.FIELD                                                 ! 1.5 RC
2374: 24bb: 
2375: 24bb:         CURSOR.POSITION% = S5.STAFF.NO%
2376: 24d1:         CALL PUT.CURSOR.IN.FIELD                                       ! 1.5 RC
2377: 24de: 
2378: 24de:         STRING.DATA$ = STAFF.NO$
2379: 24fc:         CALL SET.FIELD                                                 ! 1.5 RC
2380: 2509: 
2381: 2509:         CURSOR.POSITION% = S5.RECEIPT.NAME%                           ! AJC
2382: 251f:         CALL PUT.CURSOR.IN.FIELD                                       ! 1.5 RC
2383: 252c: 
2384: 252c:         STRING.DATA$ = RECEIPT.NAME$                                  ! AJC
2385: 254a:         CALL SET.FIELD                                                 ! 1.5 RC
2386: 2557: 
2387: 2557:         CURSOR.POSITION% = S5.BIRTH.DATE%                              ! 1.6 RC
2388: 256d:         CALL PUT.CURSOR.IN.FIELD                                       ! 1.6 RC
2389: 257a: 
2390: 257a:         IF BIRTH.DATE$ <> "" THEN BEGIN \                              ! 1.6 RC
2391: 2598:             STRING.DATA$ = MID$(BIRTH.DATE$,1,2) + "/" + \             ! 1.6 RC
2392: 2608:                            MID$(BIRTH.DATE$,3,2) + "/" + \             ! 1.6 RC
2393: 2608:                            MID$(BIRTH.DATE$,5,4)                       ! 1.6 RC
2394: 2608:         ENDIF                                                          ! 1.6 RC
2395: 2610:         CALL SET.FIELD                                                 ! 1.6 RC
2396: 261d: 
2397: 261d:         CURSOR.POSITION% = S5.GROUP.CODE%                             ! AJC 1.4
2398: 2633:         CALL PUT.CURSOR.IN.FIELD                                       ! 1.5 RC
2399: 2640: 
2400: 2640:         STRING.DATA$ = GROUP.CODE$                                    ! AJC 1.4
2401: 265e:         CALL SET.FIELD                                                 ! 1.5 RC
2402: 266b: 
2403: 266b:         CURSOR.POSITION% = S5.EMPLOYEE.FLG%
2404: 2681:         CALL PUT.CURSOR.IN.FIELD                                       ! 1.5 RC
2405: 268e: 
2406: 268e:         STRING.DATA$ = EMPLOYEE.FLG$
2407: 26ac:         CALL SET.FIELD                                                 ! 1.5 RC
2408: 26b9: 
2409: 26b9:         CALL RESTORE.MODEL.FLAGS                                       ! 1.5 RC
2410: 26c6: 
2411: 26c6:         CURSOR.POSITION% = S2.CONFIRM%
2412: 26dc:         CALL PUT.CURSOR.IN.FIELD                                       ! 1.5 RC
2413: 26e9: 
2414: 26e9:         STRING.DATA$ = CONFIRM$
2415: 2707:         CALL SET.FIELD                                                 ! 1.5 RC
2416: 2714: 
2417: 2714:         CURSOR.STATE$ = CURSOR.ON$
2418: 2732:         CALL SET.CURSOR.STATE                                          ! 1.5 RC
2419: 273f: 
2420: 273f: END SUB                                                                ! 1.5 RC
2421: 2753: 
2422: 2753: ! Included as part of Core 2 Release                                   ! 1.9 NM
2423: 2753: \******************************************************************************
2424: 2753: \***                                                                          *
2425: 2753: \***    SUBROUTINE      :       WRK.SET                                       *
2426: 2753: \***                                                                          *
2427: 2753: \******************************************************************************
2428: 2753: \***                                                                          *
2429: 2753: \***    Initialise variables for work file                                    *
2430: 2753: \***                                                                          *
2431: 2753: \******************************************************************************
2432: 2753: 
2433: 2753: SUB     WRK.SET PUBLIC                                                 ! 1.9 NM
2434: 2777: 
2435: 2777:         WORKFILE.REPORT.NUM% = 426 ! Temporary work file               ! 1.9 NM
2436: 2788:         WORKFILE.FILE.NAME$ = "ADXLXACN::D:\ADX_UDT1\PSB99RPT.BIN"     ! 1.9 NM
2437: 279f: 
2438: 279f: END SUB                                                                ! 1.9 NM
2439: 27b3: 
2440: 27b3: SUB RESTORE.FIELDS.06 EXTERNAL ! PSB9902                               ! 1.5 RC
2441: 27b3: END SUB                                                                ! 1.5 RC
2442: 27b3: 
2443: 27b3: SUB REVEAL.CONFIRM.MESSAGE EXTERNAL ! PSB9902                          ! 1.5 RC
2444: 27b3: END SUB                                                                ! 1.5 RC
2445: 27b3: 
2446: 27b3: SUB SET.OLD.OPAUD.DETAILS EXTERNAL ! PSB9902                           ! 1.5 RC
2447: 27b3: END SUB                                                                ! 1.5 RC
2448: 27b3: 
2449: 27b3: SUB SET.NEW.OPAUD.DETAILS EXTERNAL ! PSB9902                           ! 1.5 RC
2450: 27b3: END SUB                                                                ! 1.5 RC
2451: 27b3: 
2452: 27b3: SUB WRITE.OPAUD.RECORDS EXTERNAL ! PSB9902                             ! 1.5 RC
2453: 27b3: END SUB                                                                ! 1.5 RC
2454: 27b3: 
2455: 27b3: 
2456: 27b3: \******************************************************************************
2457: 27b3: \***
2458: 27b3: \***    HIGH LEVEL SUBPROGRAMS
2459: 27b3: \***    Dependant on one or more previously defined subprograms
2460: 27b3: \***
2461: 27b3: \******************************************************************************
2462: 27b3: 
2463: 27b3: SUB GET.QUIT.CONFIRM EXTERNAL ! PSB9902                                ! 1.5 RC
2464: 27b3: END SUB                                                                ! 1.5 RC
2465: 27b3: 
2466: 27b3: SUB GET.CONFIRM EXTERNAL ! PSB9902                                     ! 1.5 RC
2467: 27b3: END SUB                                                                ! 1.5 RC
2468: 27b3: 
2469: 27b3: SUB GET.QUIT.KEY EXTERNAL ! PSB9902                                    ! 1.5 RC
2470: 27b3: END SUB                                                                ! 1.5 RC
2471: 27b3: 
2472: 27b3: ! SUB CLEAR.FIELDS.06 EXTERNAL ! PSB9902                               ! 1.5 RC
2473: 27b3: ! END SUB                                                              ! 1.5 RC
2474: 27b3: 
2475: 27b3: ! SUB DELETE.AUTH.RECORDS EXTERNAL ! PSB9902                           ! 1.5 RC
2476: 27b3: ! END SUB                                                              ! 1.5 RC
2477: 27b3: 
2478: 27b3: ! SUB DELETE.AN.OPERATOR EXTERNAL ! PSB9902                            ! 1.5 RC
2479: 27b3: ! END SUB                                                              ! 1.5 RC
2480: 27b3: 
2481: 27b3: ! SUB GET.OPERATOR.ID.06 EXTERNAL ! PSB9902                            ! 1.5 RC
2482: 27b3: ! END SUB                                                              ! 1.5 RC
2483: 27b3: 
2484: 27b3: 
2485: 27b3: \******************************************************************************
2486: 27b3: \******************************************************************************
2487: 27b3: \***                                                                          *
2488: 27b3: \***    S T A R T  O F  M A I N L I N E  C O D E                              *
2489: 27b3: \***                                                                          *
2490: 27b3: \******************************************************************************
2491: 27b3: \******************************************************************************
2492: 27b3: 
2493: 27b3:         ON ERROR GOTO ERROR.DETECTED
2494: 27e2: 
2495: 27e2:         %INCLUDE PSBUSEE.J86
2496: 27e2: \/*********************************************************************/ PSBUSEE
2497: 27e2: \/*                                                                   */ PSBUSEE
2498: 27e2: \/*      PSBUSEE.J86  -  USE in PSB Application Program               */ PSBUSEE
2499: 27e2: \/*      ----------------------------------------------               */ PSBUSEE
2500: 27e2: \/*                                                                   */ PSBUSEE
2501: 27e2: \/*********************************************************************/ PSBUSEE
2502: 27e2:                                                                        ! PSBUSEE
2503: 27e2:         USE  PSBCHN.OP , PSBCHN.APP , PSBCHN.MENCON , PSBCHN.U1 ,      \ PSBUSEE
2504: 2836:              PSBCHN.U2 , PSBCHN.U3                                     ! PSBUSEE
2505: 2836:                                                                        ! PSBUSEE
2506: 2836: 
2507: 2836:         RESUME.FROM.NP.ERROR: ! Resume point from NP error             ! 1.5 RC
2508: 2846: 
2509: 2846:         GOSUB INITIALISATION
2510: 2858: 
2511: 2858:         GOSUB PROCESS.SCREEN.01
2512: 286a: 
2513: 286a:         GOSUB TERMINATION
2514: 287c: 
2515: 287c:         STOP
2516: 2889: 
2517: 2889: \******************************************************************************
2518: 2889: \******************************************************************************
2519: 2889: \***                                                                          *
2520: 2889: \***    S T A R T  O F  S U B R O U T I N E S                                 *
2521: 2889: \***                                                                          *
2522: 2889: \******************************************************************************
2523: 2889: \******************************************************************************
2524: 2889: 
2525: 2889: 
2526: 2889: \******************************************************************************
2527: 2889: \***                                                                          *
2528: 2889: \***    SUBROUTINE      :       INITIALISATION                                *
2529: 2889: \***                                                                          *
2530: 2889: \******************************************************************************
2531: 2889: \***                                                                          *
2532: 2889: \***    Initialise main program variables                                     *
2533: 2889: \***                                                                          *
2534: 2889: \***    Allocate session numbers to files                                     *
2535: 2889: \***                                                                          *
2536: 2889: \***    OPEN required files                                                   *
2537: 2889: \***                                                                          *
2538: 2889: \***    Initialise Display Manager                                            *
2539: 2889: \***                                                                          *
2540: 2889: \***    RETURN                                                                *
2541: 2889: \***                                                                          *
2542: 2889: \******************************************************************************
2543: 2889: 
2544: 2889:         INITIALISATION:
2545: 2899: 
2546: 2899:         CALL MODEL.SET
2547: 28a6:         CALL AF.SET
2548: 28b3:         CALL CSOUF.SET
2549: 28ce:         CALL OPAUD.SET
2550: 28db:         CALL PRINT.SET
2551: 28e8:         CALL PPDF.SET
2552: 28f5:         CALL PHRML.SET
2553: 2902:         CALL WRK.SET                                                   ! 1.9 NM
2554: 290e: 
2555: 290e:         AF.FILE.NAME$ = "EALAUTH"                                      ! HMW
2556: 2925: 
2557: 2925:         DIM EXIT.KEY.PRESSED(8),                                       \
2558: 2954:             TILL.MODEL.FLAG$(8),                                       \
2559: 2983:             CTLR.MODEL.FLAG$(16),                                      \
2560: 29b2:             TILL.MODEL.NAME$(8),                                       \
2561: 29e1:             CTLR.MODEL.NAME$(16),                                      \
2562: 2a10:             TILL.MODEL.RECORD$(8),                                     \
2563: 2a3f:             CTLR.MODEL.RECORD$(16),                                    \
2564: 2a6e:             S2.TILL.MODEL.FLAG%(8),                                    \
2565: 2a9d:             S2.TILL.MODEL.TEXT%(8),                                    \
2566: 2acc:             S2.CTLR.MODEL.FLAG%(16),                                   \
2567: 2afb:             S2.CTLR.MODEL.TEXT%(16),                                   \
2568: 2b2a:             OPTION.ALLOWED(6),                                         \
2569: 2b59:             MONTH.ARRAY$(12)
2570: 2b88: 
2571: 2b88:         BATCH.SCREEN.FLAG$ = "S"
2572: 2b9f:         MODULE.NUMBER$     = "PSB9900"
2573: 2bb6:         OPERATOR.NUMBER$   = PSBCHN.OP
2574: 2bd4:         CHAIN.TO.PROG$     = "PSB50"
2575: 2beb:         VAR.STRING.2$      = ""
2576: 2c02: 
2577: 2c02:         DISPLAY.MESSAGE.TEXT$ = ""
2578: 2c19: 
2579: 2c19:         TODAYS.DATE$ = DATE$
2580: 2c31: 
2581: 2c31:         TRUE  = -1
2582: 2c41:         FALSE = 0
2583: 2c51: 
2584: 2c51:         VISIBLE$    = "0"
2585: 2c68:         INVISIBLE$  = "1"
2586: 2c7f:         CURSOR.ON$  = "0"
2587: 2c96:         CURSOR.OFF$ = "1"
2588: 2cad: 
2589: 2cad:         MONTH.ARRAY$(1)  = "JAN"
2590: 2cd0:         MONTH.ARRAY$(2)  = "FEB"
2591: 2cf3:         MONTH.ARRAY$(3)  = "MAR"
2592: 2d16:         MONTH.ARRAY$(4)  = "APR"
2593: 2d39:         MONTH.ARRAY$(5)  = "MAY"
2594: 2d5c:         MONTH.ARRAY$(6)  = "JUN"
2595: 2d7f:         MONTH.ARRAY$(7)  = "JUL"
2596: 2da2:         MONTH.ARRAY$(8)  = "AUG"
2597: 2dc5:         MONTH.ARRAY$(9)  = "SEP"
2598: 2de8:         MONTH.ARRAY$(10) = "OCT"
2599: 2e0b:         MONTH.ARRAY$(11) = "NOV"
2600: 2e2e:         MONTH.ARRAY$(12) = "DEC"
2601: 2e51: 
2602: 2e51:         DISPLAY.DATE$ = FORMAT.DATE$(DATE$)
2603: 2e6d: 
2604: 2e6d:         HELP.KEY%  = -1
2605: 2e7e:         QUIT.KEY%  = -3
2606: 2e8f:         ESC.KEY%   = 27
2607: 2ea0:         ENTER.KEY% = 0
2608: 2eb1:         BTAB.KEY%  = 8217
2609: 2ec2:         END.KEY%   = 335
2610: 2ed3:         HOME.KEY%  = 327
2611: 2ee4:         TAB.KEY%   = 9
2612: 2ef5:         PGUP.KEY%  = 329
2613: 2f06:         PGDN.KEY%  = 337
2614: 2f17:         F7UP.KEY%  = -7
2615: 2f28:         F8DN.KEY%  = -8
2616: 2f39: 
2617: 2f39:         OPM.BIT.MASK% = 0080H
2618: 2f50:         SDK.BIT.MASK% = 8000H
2619: 2f67: 
2620: 2f67:         INVISIBLE.FIELD% = 5
2621: 2f78:         S1.OPTION%       = 6
2622: 2f89:         S1.DATE%         = 60
2623: 2f9a: 
2624: 2f9a:         S2.OPERATOR.ID%  = 6
2625: 2fab:         S2.NAME%         = 7
2626: 2fbc:         S2.GROUP.CODE%   = 62                                         ! AJC 1.4
2627: 2fcd:         S2.PASSWORD%     = 8
2628: 2fde:         S2.STAFF.NO%     = 58
2629: 2fef:         S2.EMPLOYEE.FLG% = 59
2630: 3000:         S2.RECEIPT.NAME% = 61                                         ! AJC
2631: 3011:         S2.BIRTH.DATE%   = 63                                         ! 1.6 RC
2632: 3022:         S2.CONFIRM%      = 4
2633: 3033:         S2.CONFIRM.TEXT% = 57
2634: 3044: 
2635: 3044:         S3.OPERATOR.ID%  = 6
2636: 3055:         S3.NAME%         = 7
2637: 3066:         S3.STAFF.NO%     = 58
2638: 3077:         S3.EMPLOYEE.FLG% = 59
2639: 3088:         S3.RECEIPT.NAME% = 61                                         ! AJC
2640: 3099:         S3.GROUP.CODE%   = 62                                         ! AJC 1.4
2641: 30aa:         S3.BIRTH.DATE%   = 63                                         ! 1.6 RC
2642: 30bb: 
2643: 30bb:         S4.OPERATOR.ID%  = 6
2644: 30cc:         S4.NAME%         = 7
2645: 30dd:         S4.GROUP.CODE%   = 62                                         ! AJC 1.4
2646: 30ee:         S4.STAFF.NO%     = 58
2647: 30ff:         S4.EMPLOYEE.FLG% = 59
2648: 3110:         S4.RECEIPT.NAME% = 61                                         ! AJC
2649: 3121:         S4.BIRTH.DATE%   = 63                                         ! 1.6 RC
2650: 3132: 
2651: 3132:         S5.OPERATOR.ID%  = 6
2652: 3143:         S5.NAME%         = 7
2653: 3154:         S5.PASSWORD%     = 8
2654: 3165:         S5.STAFF.NO%     = 58
2655: 3176:         S5.EMPLOYEE.FLG% = 59
2656: 3187:         S5.RECEIPT.NAME% = 61                                         ! AJC
2657: 3198:         S5.GROUP.CODE%   = 62                                         ! AJC 1.4
2658: 31a9:         S5.BIRTH.DATE%   = 63                                         ! 1.6 RC
2659: 31ba: 
2660: 31ba:         S6.OPERATOR.ID%  = 6
2661: 31cb:         S6.NAME%         = 7
2662: 31dc:         S6.STAFF.NO%     = 58
2663: 31ed:         S6.EMPLOYEE.FLG% = 59
2664: 31fe:         S6.RECEIPT.NAME% = 61                                         ! AJC
2665: 320f:         S6.GROUP.CODE%   = 62                                         ! AJC 1.4
2666: 3220:         S6.BIRTH.DATE%   = 63                                         ! 1.6 RC
2667: 3231: 
2668: 3231:         S7.SORT.OPTION%   = 6
2669: 3242:         S7.REPORT.OPTION% = 7
2670: 3253: 
2671: 3253:         FOR I% = 1 TO 6
2672: 3266:             OPTION.ALLOWED(I%) = TRUE
2673: 3293:         NEXT I%
2674: 32b4: 
2675: 32b4:         FOR I% = 1 TO 8
2676: 32c8:             S2.TILL.MODEL.TEXT%(I%)     = I% + 8
2677: 32f8:             S2.TILL.MODEL.FLAG%(I%)     = I% + 32
2678: 3328:             S2.CTLR.MODEL.TEXT%(I%)     = I% + 16
2679: 3358:             S2.CTLR.MODEL.FLAG%(I%)     = I% + 40
2680: 3388:             S2.CTLR.MODEL.TEXT%(I% + 8) = I% + 24
2681: 33bc:             S2.CTLR.MODEL.FLAG%(I% + 8) = I% + 48
2682: 33f0:         NEXT I%
2683: 3414: 
2684: 3414:         MAX.TILL.MODELS% = 8
2685: 3425:         MAX.CTLR.MODELS% = 16
2686: 3436: 
2687: 3436:         GOSUB ALLOCATE.SESS.NUMS
2688: 3448: 
2689: 3448:         CURRENT.REPORT.NUM% = AF.REPORT.NUM%
2690: 345f:         IF END # AF.SESS.NUM% THEN OPEN.ERROR
2691: 347b:         OPEN AF.FILE.NAME$ KEYED RECL AF.RECL% AS AF.SESS.NUM%
2692: 34a7: 
2693: 34a7:         CURRENT.REPORT.NUM% = CSOUF.REPORT.NUM%
2694: 34bd:         IF END # CSOUF.SESS.NUM% THEN OPEN.ERROR
2695: 34d9:         OPEN CSOUF.FILE.NAME$ DIRECT RECL CSOUF.RECL% AS CSOUF.SESS.NUM%
2696: 3505: 
2697: 3505:         CURRENT.REPORT.NUM% = OPAUD.REPORT.NUM%
2698: 351b:         IF END # OPAUD.SESS.NUM% THEN CREATE.OPAUD.FILE
2699: 3537:         OPEN OPAUD.FILE.NAME$ DIRECT RECL OPAUD.RECL% AS OPAUD.SESS.NUM%
2700: 3563: 
2701: 3563:         GOTO OPAUD.FILE.FOUND
2702: 356e: 
2703: 356e:         CREATE.OPAUD.FILE:
2704: 357e: 
2705: 357e:         CREATE POSFILE OPAUD.FILE.NAME$                                \
2706: 35af:                DIRECT 0                                                \
2707: 35af:                RECL OPAUD.RECL%                                        \
2708: 35af:                AS OPAUD.SESS.NUM%                                      \
2709: 35af:                LOCAL
2710: 35af: 
2711: 35af:         OPAUD.REC.NUM%          = 1
2712: 35c0:         OPAUD.LAST.REC.UPDATED$ = "0100"
2713: 35d7:         OPAUD.FILE.SIZE$        = "0100"
2714: 35ee:         OPAUD.FILLER$           = STRING$(70," ")
2715: 360c:         OPAUD.CRLF$             = CHR$(0DH) + CHR$(0AH)
2716: 363b: 
2717: 363b:         IF WRITE.OPAUD <> 0 THEN                                       \
2718: 364d:         BEGIN
2719: 364d:            GOSUB FILE.ERROR
2720: 365f:         ENDIF
2721: 3667: 
2722: 3667:         OPAUD.FILE.FOUND:
2723: 3677: 
2724: 3677:         GOSUB READ.OPAUD.HEADER.RECORD
2725: 3689: 
2726: 3689:         STRING.DATA$ = "B9901"
2727: 36a0:         INTEGER.DATA% = -1
2728: 36b1: 
2729: 36b1:         CALL DM.INITDM(STRING.DATA$,                                   \
2730: 36d3:                        INTEGER.DATA%)
2731: 36d3: 
2732: 36d3:         GOSUB GET.OPERATOR.AUTH
2733: 36e5: 
2734: 36e5:         GOSUB BUILD.MODEL.TABLES
2735: 36f7: 
2736: 36f7:         RETURN
2737: 3707: 
2738: 3707: \******************************************************************************
2739: 3707: \***                                                                          *
2740: 3707: \***    SUBROUTINE      :       READ.OPAUD.HEADER.RECORD                      *
2741: 3707: \***                                                                          *
2742: 3707: \******************************************************************************
2743: 3707: \***                                                                          *
2744: 3707: \***    Read the header record from the OPAUD file                            *
2745: 3707: \***                                                                          *
2746: 3707: \******************************************************************************
2747: 3707: 
2748: 3707:         READ.OPAUD.HEADER.RECORD:
2749: 3717: 
2750: 3717:         OPAUD.REC.NUM% = 1
2751: 3728: 
2752: 3728:         IF READ.OPAUD = 0 THEN                                         \
2753: 373d:         BEGIN
2754: 373d:            OPAUD.REC.NUM% = VAL(OPAUD.LAST.REC.UPDATED$) + 1
2755: 3781: 
2756: 3781:            IF OPAUD.REC.NUM% > VAL(OPAUD.FILE.SIZE$) THEN              \
2757: 37b6:            BEGIN
2758: 37b6:               OPAUD.REC.NUM% = 2
2759: 37c7:            ENDIF
2760: 37d1:         ENDIF                                                          \
2761: 37d1:         ELSE                                                           \
2762: 37d9:         BEGIN
2763: 37d9:            GOSUB FILE.ERROR
2764: 37eb:         ENDIF
2765: 37f3: 
2766: 37f3:         RETURN
2767: 3803: 
2768: 3803: \******************************************************************************
2769: 3803: \***                                                                          *
2770: 3803: \***    SUBROUTINE      :       GET.OPERATOR.AUTH                             *
2771: 3803: \***                                                                          *
2772: 3803: \******************************************************************************
2773: 3803: \***                                                                          *
2774: 3803: \***    Get the authorisation of options for the current operator             *
2775: 3803: \***                                                                          *
2776: 3803: \******************************************************************************
2777: 3803: 
2778: 3803:         GET.OPERATOR.AUTH:
2779: 3813: 
2780: 3813:         AF.OPERATOR.NO$ = PACK$(RIGHT$(STRING$(8,"0") +                \
2781: 3865:                           OPERATOR.NUMBER$,8))
2782: 3865: 
2783: 3865:         IF LEN(OPERATOR.NUMBER$) = 8 THEN                              \
2784: 3883:         BEGIN
2785: 3883:            OPAUD.CURRENT.ID$ = "*" +                                   \
2786: 38c2:                                LEFT$(OPERATOR.NUMBER$,1) +             \
2787: 38c2:                                "*"
2788: 38c2:         ENDIF                                                          \
2789: 38c2:         ELSE                                                           \
2790: 38ca:         BEGIN
2791: 38ca:            OPAUD.CURRENT.ID$ = RIGHT$("000" + OPERATOR.NUMBER$,3)
2792: 3905:         ENDIF
2793: 390d: 
2794: 390d:         IF READ.AF.ABREV = 0 THEN                                      \
2795: 3922:         BEGIN
2796: 3922:            IF NOT (((AF.MODEL.FLAGS.2% AND OPM.BIT.MASK%) > 0) OR      \
2797: 39a3:                   ((AF.MODEL.FLAGS.2% AND SDK.BIT.MASK%) > 0)) THEN    \
2798: 39a3:            BEGIN
2799: 39a3:               OPTION.ALLOWED(1) = FALSE
2800: 39cb:               OPTION.ALLOWED(3) = FALSE
2801: 39f3:               OPTION.ALLOWED(4) = FALSE
2802: 3a1b:               OPTION.ALLOWED(5) = FALSE
2803: 3a43:            ENDIF
2804: 3a4d:         ENDIF                                                          \
2805: 3a4d:         ELSE                                                           \
2806: 3a55:         BEGIN
2807: 3a55:            GOSUB FILE.ERROR
2808: 3a67:         ENDIF
2809: 3a6f: 
2810: 3a6f:         RETURN
2811: 3a7f: 
2812: 3a7f: \******************************************************************************
2813: 3a7f: \***                                                                          *
2814: 3a7f: \***    SUBROUTINE      :       BUILD.MODEL.TABLES                            *
2815: 3a7f: \***                                                                          *
2816: 3a7f: \******************************************************************************
2817: 3a7f: \***                                                                          *
2818: 3a7f: \***    Build a table of the till and controller models from the MODEL file   *
2819: 3a7f: \***                                                                          *
2820: 3a7f: \******************************************************************************
2821: 3a7f: 
2822: 3a7f:         BUILD.MODEL.TABLES:
2823: 3a8f: 
2824: 3a8f:         CURRENT.REPORT.NUM% = MODEL.REPORT.NUM%
2825: 3aa5:         IF END # MODEL.SESS.NUM% THEN OPEN.ERROR
2826: 3ac1:         OPEN MODEL.FILE.NAME$ KEYED RECL MODEL.RECL% AS MODEL.SESS.NUM%
2827: 3aed: 
2828: 3aed:         TILL.PTR% = 0
2829: 3afe: 
2830: 3afe:         FOR I% = 1 TO MAX.TILL.MODELS%
2831: 3b12: 
2832: 3b12:             MODEL.KEY$ = "T" + PACK$(RIGHT$("00" + STR$(I%),2))
2833: 3b68: 
2834: 3b68:             IF READ.MODEL = 0 THEN                                     \
2835: 3b7d:             BEGIN
2836: 3b7d:                IF MODEL.DISPLAY.FLAG$ = "Y" THEN                       \
2837: 3b9e:                BEGIN
2838: 3b9e:                   TILL.PTR%                     = TILL.PTR% + 1
2839: 3bad:                   TILL.MODEL.RECORD$(TILL.PTR%) = MODEL.KEY$ + MODEL.RECORD$
2840: 3bea:                   TILL.MODEL.NAME$(TILL.PTR%)   = MID$(MODEL.RECORD$,1,20)
2841: 3c22:                ENDIF
2842: 3c2a:             ENDIF
2843: 3c32: 
2844: 3c32:         NEXT I%
2845: 3c5c: 
2846: 3c5c:         MAX.TILL.PTR% = TILL.PTR%
2847: 3c72: 
2848: 3c72:         CTLR.PTR% = 0
2849: 3c83: 
2850: 3c83:         FOR I% = 1 TO MAX.CTLR.MODELS%
2851: 3c97: 
2852: 3c97:             MODEL.KEY$ = "C" + PACK$(RIGHT$("00" + STR$(I%),2))
2853: 3ced: 
2854: 3ced:             IF READ.MODEL = 0 THEN                                     \
2855: 3d02:             BEGIN
2856: 3d02:                IF MODEL.DISPLAY.FLAG$ = "Y" THEN                       \
2857: 3d23:                BEGIN
2858: 3d23:                   CTLR.PTR%                     = CTLR.PTR% + 1
2859: 3d32:                   CTLR.MODEL.RECORD$(CTLR.PTR%) = MODEL.KEY$ + MODEL.RECORD$
2860: 3d6f:                   CTLR.MODEL.NAME$(CTLR.PTR%)   = MID$(MODEL.RECORD$,1,20)
2861: 3da7:                ENDIF
2862: 3daf:             ENDIF
2863: 3db7: 
2864: 3db7:         NEXT I%
2865: 3de1:         MAX.CTLR.PTR% = CTLR.PTR%
2866: 3df7: 
2867: 3df7:         CLOSE MODEL.SESS.NUM%
2868: 3e0b: 
2869: 3e0b:         RETURN
2870: 3e1b: 
2871: 3e1b: 
2872: 3e1b: \******************************************************************************
2873: 3e1b: \***                                                                          *
2874: 3e1b: \***    SUBROUTINE      :       PROCESS.SCREEN.01                             *
2875: 3e1b: \***                                                                          *
2876: 3e1b: \******************************************************************************
2877: 3e1b: \***                                                                          *
2878: 3e1b: \***    Control routine for the initial screen                                *
2879: 3e1b: \***                                                                          *
2880: 3e1b: \******************************************************************************
2881: 3e1b: 
2882: 3e1b:         PROCESS.SCREEN.01:
2883: 3e2b: 
2884: 3e2b:         S% = 1
2885: 3e3c: 
2886: 3e3c:         CALL DISPLAY.SCREEN(1)
2887: 3e5a: 
2888: 3e5a:         OPTION$ = ""
2889: 3e71: 
2890: 3e71:         GOSUB RESTORE.FIELDS.01
2891: 3e83: 
2892: 3e83:         EXIT.KEY.PRESSED(1) = FALSE
2893: 3eab: 
2894: 3eab:         WHILE NOT EXIT.KEY.PRESSED(1)
2895: 3eb5:               GOSUB GET.OPTION.01
2896: 3ec7:         WEND
2897: 3ee5: 
2898: 3ee5:         RETURN
2899: 3ef5: 
2900: 3ef5: \******************************************************************************
2901: 3ef5: \***                                                                          *
2902: 3ef5: \***    SUBROUTINE      :       RESTORE.FIELDS.01                             *
2903: 3ef5: \***                                                                          *
2904: 3ef5: \******************************************************************************
2905: 3ef5: \***                                                                          *
2906: 3ef5: \***    Displays the fields for the initial screen                            *
2907: 3ef5: \***                                                                          *
2908: 3ef5: \******************************************************************************
2909: 3ef5: 
2910: 3ef5:         RESTORE.FIELDS.01:
2911: 3f05: 
2912: 3f05:         CURSOR.STATE$ = CURSOR.OFF$
2913: 3f23:         CALL SET.CURSOR.STATE                                          ! 1.5 RC
2914: 3f30: 
2915: 3f30:         CALL DISPLAY.FORMATTED.DATE                                    ! 1.5 RC
2916: 3f3d: 
2917: 3f3d:         FOR I% = 1 TO 6
2918: 3f51: 
2919: 3f51:             IF OPTION.ALLOWED(I%) THEN                                 \
2920: 3f74:             BEGIN
2921: 3f74:                CURSOR.POSITION% = 10 + I%
2922: 3f8f:                CALL PUT.CURSOR.IN.FIELD                                ! 1.5 RC
2923: 3f9c: 
2924: 3f9c:                STRING.DATA$ = "31"
2925: 3fb3:                CALL SET.FIELD.ATTRIBUTES                               ! 1.5 RC
2926: 3fc0:             ENDIF
2927: 3fc8: 
2928: 3fc8:         NEXT I%
2929: 3fec: 
2930: 3fec:         CURSOR.POSITION% = S1.OPTION%
2931: 4002:         CALL PUT.CURSOR.IN.FIELD                                       ! 1.5 RC
2932: 400f: 
2933: 400f:         STRING.DATA$ = OPTION$
2934: 402d:         CALL SET.FIELD                                                 ! 1.5 RC
2935: 403a: 
2936: 403a:         CURSOR.STATE$ = CURSOR.ON$
2937: 4058:         CALL SET.CURSOR.STATE                                          ! 1.5 RC
2938: 4065: 
2939: 4065:         RETURN
2940: 4075: 
2941: 4075: 
2942: 4075: \******************************************************************************
2943: 4075: \***                                                                          *
2944: 4075: \***    SUBROUTINE      :       GET.OPTION.01                                 *
2945: 4075: \***                                                                          *
2946: 4075: \******************************************************************************
2947: 4075: \***                                                                          *
2948: 4075: \***    Input routine for selecting an option from the main menu              *
2949: 4075: \***                                                                          *
2950: 4075: \******************************************************************************
2951: 4075: 
2952: 4075:         GET.OPTION.01:
2953: 4085: 
2954: 4085:         CURSOR.POSITION% = S1.OPTION%
2955: 409b:         CALL PUT.CURSOR.IN.FIELD                                       ! 1.5 RC
2956: 40a8: 
2957: 40a8:         EXIT.KEY.PRESSED(1) = FALSE
2958: 40d0:         VALID.OPTION.FOUND  = FALSE
2959: 40e6: 
2960: 40e6:         CALL GET.INPUT                                                 ! 1.5 RC
2961: 40f3: 
2962: 40f3:         WHILE NOT (EXIT.KEY.PRESSED(1) OR                              \
2963: 40fe:                   VALID.OPTION.FOUND)
2964: 40fe: 
2965: 40fe:               OPTION$ = F03.RETURNED.STRING$
2966: 411c: 
2967: 411c:               IF NOT (FUNCTION.KEY% = ENTER.KEY% OR                    \
2968: 417c:                  FUNCTION.KEY% = HELP.KEY% OR                          \
2969: 417c:                  FUNCTION.KEY% = QUIT.KEY% OR                          \
2970: 417c:                  FUNCTION.KEY% = ESC.KEY%) THEN                        \
2971: 417c:               BEGIN
2972: 417c:                  DISPLAY.MESSAGE.NUMBER% = 1
2973: 418d:                  CALL DISPLAY.MESSAGE                                  ! 1.5 RC
2974: 419a:                  CALL RESUME.INPUT                                     ! 1.5 RC
2975: 41aa:               ENDIF                                                    \
2976: 41aa:               ELSE                                                     \
2977: 41b2:               IF FUNCTION.KEY% = QUIT.KEY% THEN                        \
2978: 41ca:                  EXIT.KEY.PRESSED(1) = TRUE                            \
2979: 41f5:               ELSE                                                     \
2980: 41fd:               IF FUNCTION.KEY% = ESC.KEY% THEN                         \
2981: 4215:               BEGIN
2982: 4215:                  CHAIN.TO.PROG$ = "PSB50"
2983: 422c:                  PSBCHN.MENCON  = "000000"
2984: 4243:                  CALL CHAIN.TO.CALLER                                  ! 1.5 RC
2985: 4253:               ENDIF                                                    \
2986: 4253:               ELSE                                                     \
2987: 425b:               IF FUNCTION.KEY% = HELP.KEY% THEN                        \
2988: 4273:               BEGIN
2989: 4273:                  CALL SCREEN.HELP(1)
2990: 4291:                  GOSUB RESTORE.FIELDS.01
2991: 42a3: 
2992: 42a3:                  CURSOR.POSITION% = S1.OPTION%
2993: 42b9:                  CALL PUT.CURSOR.IN.FIELD                              ! 1.5 RC
2994: 42c6: 
2995: 42c6:                  CALL GET.INPUT                                        ! 1.5 RC
2996: 42d5:               ENDIF                                                    \
2997: 42d5:               ELSE                                                     \
2998: 42dd:               BEGIN
2999: 42dd:                  IF VALID.OPTION THEN                                  \
3000: 42ed:                     VALID.OPTION.FOUND = TRUE                          \
3001: 4305:                  ELSE                                                  \
3002: 430d:                  BEGIN
3003: 430d:                     ! B003 Invalid selection number
3004: 430d:                     DISPLAY.MESSAGE.NUMBER% = 3
3005: 431e:                     CALL DISPLAY.MESSAGE                               ! 1.5 RC
3006: 432b:                     CALL RESUME.INPUT                                  ! 1.5 RC
3007: 4338:                  ENDIF
3008: 4340:               ENDIF
3009: 4348:         WEND
3010: 436f: 
3011: 436f:         IF VALID.OPTION.FOUND AND                                      \
3012: 4397:            NOT EXIT.KEY.PRESSED(1) THEN                                \
3013: 4397:         BEGIN
3014: 4397:            CALL CLEAR.MESSAGE                                          ! 1.5 RC
3015: 43a4: 
3016: 43a4:            STRING.DATA$ = OPTION$
3017: 43c2:            CALL SET.FIELD                                              ! 1.5 RC
3018: 43cf: 
3019: 43cf:            IF FUNCTION.KEY% = ENTER.KEY% THEN                          \
3020: 43e7:               GOSUB REQUIRED.OPTION
3021: 43f9:         ENDIF
3022: 4401: 
3023: 4401:         RETURN
3024: 4411: 
3025: 4411: \******************************************************************************
3026: 4411: \***                                                                          *
3027: 4411: \***    SUBROUTINE      :       PROCESS.SCREEN.02                             *
3028: 4411: \***                                                                          *
3029: 4411: \******************************************************************************
3030: 4411: \***                                                                          *
3031: 4411: \***    Control routine for the add an operator screen                        *
3032: 4411: \***                                                                          *
3033: 4411: \******************************************************************************
3034: 4411: 
3035: 4411:         PROCESS.SCREEN.02:
3036: 4421: 
3037: 4421:         S% = 2
3038: 4432: 
3039: 4432:         CALL DISPLAY.SCREEN(2)
3040: 4450: 
3041: 4450:         OLD.OPERATOR.ID$    = ""
3042: 4467:         OPERATOR.ID$        = ""
3043: 447e:         OPERATOR.NAME$      = ""
3044: 4495:         OPERATOR.PASSWORD$  = ""
3045: 44ac:         STAFF.NO$           = ""
3046: 44c3:         EMPLOYEE.FLG$       = ""
3047: 44da:         RECEIPT.NAME$       = ""                                       ! AJC
3048: 44f1:         BIRTH.DATE$         = ""                                       ! 1.6 RC
3049: 4508:         GROUP.CODE$           = ""                                       ! AJC 1.4
3050: 451f:         MODEL.FLAG$         = "N"
3051: 4536:         CONFIRM$            = "N"
3052: 454d: 
3053: 454d:         CALL RESET.MODEL.FLAGS                                         ! 1.5 RC
3054: 455a: 
3055: 455a:         CALL SET.OLD.OPAUD.DETAILS                                     ! 1.5 RC
3056: 4567: 
3057: 4567:         CALL RESTORE.FIELDS.02                                         ! 1.5 RC
3058: 4573: 
3059: 4573:         EXIT.KEY.PRESSED(2) = FALSE
3060: 459b: 
3061: 459b:         WHILE NOT EXIT.KEY.PRESSED(2)
3062: 45a5:               GOSUB GET.OPERATOR.ID.02
3063: 45b7:         WEND
3064: 45d5: 
3065: 45d5:         RETURN
3066: 45e5: 
3067: 45e5: 
3068: 45e5: \******************************************************************************
3069: 45e5: \***                                                                          *
3070: 45e5: \***    SUBROUTINE      :       CLEAR.FIELDS.02                               *
3071: 45e5: \***                                                                          *
3072: 45e5: \******************************************************************************
3073: 45e5: \***                                                                          *
3074: 45e5: \***    Clear all fields for the add operator screen                          *
3075: 45e5: \***                                                                          *
3076: 45e5: \******************************************************************************
3077: 45e5: 
3078: 45e5:         CLEAR.FIELDS.02:
3079: 45f5: 
3080: 45f5:         CURSOR.STATE$ = CURSOR.OFF$
3081: 4613:         CALL SET.CURSOR.STATE                                          ! 1.5 RC
3082: 4620: 
3083: 4620:         IF OPERATOR.NAME$ <> "" THEN                                   \
3084: 463e:         BEGIN
3085: 463e:            CURSOR.POSITION% = S2.NAME%
3086: 4654:            CALL PUT.CURSOR.IN.FIELD                                    ! 1.5 RC
3087: 4661: 
3088: 4661:            STRING.DATA$ = ""
3089: 4678:            CALL SET.FIELD                                              ! 1.5 RC
3090: 4685:         ENDIF
3091: 468d: 
3092: 468d:         IF OPERATOR.PASSWORD$ <> "" THEN                               \
3093: 46ab:         BEGIN
3094: 46ab:            CURSOR.POSITION% = S2.PASSWORD%
3095: 46c1:            CALL PUT.CURSOR.IN.FIELD                                    ! 1.5 RC
3096: 46ce: 
3097: 46ce:            STRING.DATA$ = ""
3098: 46e5:            CALL SET.FIELD                                              ! 1.5 RC
3099: 46f2:         ENDIF
3100: 46fa: 
3101: 46fa:         CURSOR.POSITION% = S2.STAFF.NO%
3102: 4710:         CALL PUT.CURSOR.IN.FIELD                                       ! 1.5 RC
3103: 471d: 
3104: 471d:         STRING.DATA$ = ""
3105: 4734:         CALL SET.FIELD                                                 ! 1.5 RC
3106: 4741: 
3107: 4741:         CURSOR.POSITION% = S2.RECEIPT.NAME%                           ! AJC
3108: 4757:         CALL PUT.CURSOR.IN.FIELD                                       ! 1.5 RC
3109: 4764: 
3110: 4764:         STRING.DATA$ = ""                                             ! AJC
3111: 477b:         CALL SET.FIELD                                                 ! 1.5 RC
3112: 4788: 
3113: 4788:         CURSOR.POSITION% = S2.BIRTH.DATE%                              ! 1.6 RC
3114: 479e:         CALL PUT.CURSOR.IN.FIELD                                       ! 1.6 RC
3115: 47ab: 
3116: 47ab:         STRING.DATA$ = ""                                              ! 1.6 RC
3117: 47c2:         CALL SET.FIELD                                                 ! 1.6 RC
3118: 47cf: 
3119: 47cf:         CURSOR.POSITION% = S2.GROUP.CODE%                             ! AJC 1.4
3120: 47e5:         CALL PUT.CURSOR.IN.FIELD                                       ! 1.5 RC
3121: 47f2: 
3122: 47f2:         STRING.DATA$ = ""                                             ! AJC 1.4
3123: 4809:         CALL SET.FIELD                                                 ! 1.5 RC
3124: 4816: 
3125: 4816:         CURSOR.POSITION% = S2.EMPLOYEE.FLG%
3126: 482c:         CALL PUT.CURSOR.IN.FIELD                                       ! 1.5 RC
3127: 4839: 
3128: 4839:         STRING.DATA$ = ""
3129: 4850:         CALL SET.FIELD                                                 ! 1.5 RC
3130: 485d: 
3131: 485d:         CALL CLEAR.MODEL.FLAGS                                         ! 1.5 RC
3132: 486a: 
3133: 486a:         CURSOR.STATE$ = CURSOR.ON$
3134: 4888:         CALL SET.CURSOR.STATE                                          ! 1.5 RC
3135: 4895: 
3136: 4895:         RETURN
3137: 48a5: 
3138: 48a5: 
3139: 48a5: \******************************************************************************
3140: 48a5: \***                                                                          *
3141: 48a5: \***    SUBROUTINE      :       GET.OPERATOR.ID.02                            *
3142: 48a5: \***                                                                          *
3143: 48a5: \******************************************************************************
3144: 48a5: \***                                                                          *
3145: 48a5: \***    Input routine for the operator ID on the add an operator screen       *
3146: 48a5: \***                                                                          *
3147: 48a5: \******************************************************************************
3148: 48a5: 
3149: 48a5:         GET.OPERATOR.ID.02:
3150: 48b5: 
3151: 48b5:         CURSOR.POSITION% = S2.OPERATOR.ID%
3152: 48cb:         CALL PUT.CURSOR.IN.FIELD                                       ! 1.5 RC
3153: 48d8: 
3154: 48d8:         EXIT.KEY.PRESSED(2)     = FALSE
3155: 4900:         VALID.OPERATOR.ID.FOUND = FALSE
3156: 4916: 
3157: 4916:         CALL GET.INPUT                                                 ! 1.5 RC
3158: 4923: 
3159: 4923:         WHILE NOT (EXIT.KEY.PRESSED(2) OR                              \
3160: 492e:                   VALID.OPERATOR.ID.FOUND)
3161: 492e: 
3162: 492e:               OPERATOR.ID$ = RIGHT$(STRING$(3,"0") +                   \
3163: 4995:                              STR$(VAL(F03.RETURNED.STRING$)),3)
3164: 4995: 
3165: 4995:               IF NOT (FUNCTION.KEY% = ENTER.KEY% OR                    \
3166: 4a21:                  FUNCTION.KEY% = END.KEY% OR                           \
3167: 4a21:                  FUNCTION.KEY% = TAB.KEY% OR                           \
3168: 4a21:                  FUNCTION.KEY% = HELP.KEY% OR                          \
3169: 4a21:                  FUNCTION.KEY% = QUIT.KEY% OR                          \
3170: 4a21:                  FUNCTION.KEY% = ESC.KEY%) THEN                        \
3171: 4a21:               BEGIN
3172: 4a21:                  DISPLAY.MESSAGE.NUMBER% = 1
3173: 4a32:                  CALL DISPLAY.MESSAGE                                  ! 1.5 RC
3174: 4a3f:                  CALL RESUME.INPUT                                     ! 1.5 RC
3175: 4a4f:               ENDIF                                                    \
3176: 4a4f:               ELSE                                                     \
3177: 4a57:               IF FUNCTION.KEY% = QUIT.KEY% THEN                        \
3178: 4a6f:               BEGIN
3179: 4a6f:                  EXIT.KEY.PRESSED(S%) = TRUE
3180: 4a9f:               ENDIF                                                    \
3181: 4a9f:               ELSE                                                     \
3182: 4aa7:               IF FUNCTION.KEY% = ESC.KEY% THEN                         \
3183: 4abf:               BEGIN
3184: 4abf:                  CHAIN.TO.PROG$ = "PSB50"
3185: 4ad6:                  PSBCHN.MENCON  = "000000"
3186: 4aed:                  CALL CHAIN.TO.CALLER                                  ! 1.5 RC
3187: 4afd:               ENDIF                                                    \
3188: 4afd:               ELSE                                                     \
3189: 4b05:               IF FUNCTION.KEY% = HELP.KEY% THEN                        \
3190: 4b1d:               BEGIN
3191: 4b1d:                  CALL SCREEN.HELP(2)
3192: 4b3b:                  CALL RESTORE.FIELDS.02                                ! 1.5 RC
3193: 4b47: 
3194: 4b47:                  CURSOR.POSITION% = S2.OPERATOR.ID%
3195: 4b5d:                  CALL PUT.CURSOR.IN.FIELD                              ! 1.5 RC
3196: 4b6a: 
3197: 4b6a:                  CALL GET.INPUT                                        ! 1.5 RC
3198: 4b79:               ENDIF                                                    \
3199: 4b79:               ELSE                                                     \
3200: 4b81:               BEGIN
3201: 4b81:                  IF VALID.OPERATOR.ID THEN                             \
3202: 4b91:                     VALID.OPERATOR.ID.FOUND = TRUE                     \
3203: 4ba9:                  ELSE                                                  \
3204: 4bb1:                  BEGIN
3205: 4bb1:                     ! B058 Invalid operator ID
3206: 4bb1:                     DISPLAY.MESSAGE.NUMBER% = 58
3207: 4bc2:                     CALL DISPLAY.MESSAGE                               ! 1.5 RC
3208: 4bcf:                     CALL RESUME.INPUT                                  ! 1.5 RC
3209: 4bdc:                  ENDIF
3210: 4be4:               ENDIF
3211: 4bec:         WEND
3212: 4c13: 
3213: 4c13:         IF VALID.OPERATOR.ID.FOUND AND                                 \
3214: 4c3e:            NOT EXIT.KEY.PRESSED(2) THEN                                \
3215: 4c3e:         BEGIN
3216: 4c3e:            CALL CLEAR.MESSAGE                                          ! 1.5 RC
3217: 4c4b: 
3218: 4c4b:            STRING.DATA$ = OPERATOR.ID$
3219: 4c69:            CALL SET.FIELD                                              ! 1.5 RC
3220: 4c76: 
3221: 4c76:            IF FUNCTION.KEY% = TAB.KEY% OR                              \
3222: 4cc3:               FUNCTION.KEY% = END.KEY% OR                              \
3223: 4cc3:               FUNCTION.KEY% = ENTER.KEY% THEN                          \
3224: 4cc3:            BEGIN
3225: 4cc3:               IF VAL(OPERATOR.ID$) >= 901 AND                          \
3226: 4d8f:                  VAL(OPERATOR.ID$) <= 909 AND                          \
3227: 4d8f:                  VAL(OPERATOR.ID$) <> 905 THEN                         \
3228: 4d8f:               BEGIN
3229: 4d8f:                  OLD.OPERATOR.ID$ = ""
3230: 4da6: 
3231: 4da6:                  GOSUB CLEAR.FIELDS.02
3232: 4db8: 
3233: 4db8:                  DISPLAY.MESSAGE.NUMBER% = 173
3234: 4dc9:                  CALL DISPLAY.MESSAGE                                  ! 1.5 RC
3235: 4dd9:               ENDIF                                                    \
3236: 4dd9:               ELSE                                                     \
3237: 4de1:               IF OLD.OPERATOR.ID$ <> OPERATOR.ID$ THEN                 \
3238: 4e09:               BEGIN
3239: 4e09:                  AF.OPERATOR.NO$ = PACK$(RIGHT$(STRING$(8,"0") +       \
3240: 4e5b:                                    OPERATOR.ID$,8))
3241: 4e5b: 
3242: 4e5b:                  IF READ.AF.ABREV <> 0 THEN                            \
3243: 4e6d:                  BEGIN
3244: 4e6d:                     OLD.OPERATOR.ID$ = OPERATOR.ID$
3245: 4e8b: 
3246: 4e8b:                     GOSUB GET.NAME.02
3247: 4e9f:                  ENDIF                                                 \
3248: 4e9f:                  ELSE                                                  \
3249: 4ea7:                  BEGIN
3250: 4ea7:                     OLD.OPERATOR.ID$ = ""
3251: 4ebe: 
3252: 4ebe:                     GOSUB CLEAR.FIELDS.02
3253: 4ed0: 
3254: 4ed0:                     ! B172 Operator ID already in use
3255: 4ed0:                     DISPLAY.MESSAGE.NUMBER% = 172
3256: 4ee1:                     CALL DISPLAY.MESSAGE                               ! 1.5 RC
3257: 4eee:                  ENDIF
3258: 4ef9:               ENDIF                                                    \
3259: 4ef9:               ELSE                                                     \
3260: 4f01:               IF OLD.OPERATOR.ID$ = OPERATOR.ID$ THEN                  \
3261: 4f29:               BEGIN
3262: 4f29:                  IF FUNCTION.KEY% = ENTER.KEY% THEN                    \
3263: 4f41:                  BEGIN
3264: 4f41:                     GOSUB CHECK.FIELDS.02
3265: 4f55:                  ENDIF                                                 \
3266: 4f55:                  ELSE                                                  \
3267: 4f5d:                  IF FUNCTION.KEY% = TAB.KEY% THEN                      \
3268: 4f75:                  BEGIN
3269: 4f75:                     GOSUB GET.NAME.02
3270: 4f89:                  ENDIF                                                 \
3271: 4f89:                  ELSE                                                  \
3272: 4f91:                  IF FUNCTION.KEY% = END.KEY% THEN                      \
3273: 4fa9:                  BEGIN
3274: 4fa9:                     GOSUB GET.EMPLOYEE.FLG.02
3275: 4fbb:                  ENDIF
3276: 4fc3:               ENDIF
3277: 4fcb:            ENDIF
3278: 4fd3:         ENDIF
3279: 4fdb: 
3280: 4fdb:         RETURN
3281: 4feb: 
3282: 4feb: \******************************************************************************
3283: 4feb: \***                                                                          *
3284: 4feb: \***    SUBROUTINE      :       GET.NAME.02                                   *
3285: 4feb: \***                                                                          *
3286: 4feb: \******************************************************************************
3287: 4feb: \***                                                                          *
3288: 4feb: \***    Input routine for the operator name on the add an operator screen     *
3289: 4feb: \***                                                                          *
3290: 4feb: \******************************************************************************
3291: 4feb: 
3292: 4feb:         GET.NAME.02:
3293: 4ffb: 
3294: 4ffb:         CURSOR.POSITION% = S2.NAME%
3295: 5011:         CALL PUT.CURSOR.IN.FIELD                                       ! 1.5 RC
3296: 501e: 
3297: 501e:         EXIT.KEY.PRESSED(2) = FALSE
3298: 5046:         VALID.NAME.FOUND    = FALSE
3299: 505c: 
3300: 505c:         CALL GET.INPUT                                                 ! 1.5 RC
3301: 5069: 
3302: 5069:         WHILE NOT (EXIT.KEY.PRESSED(2) OR                              \
3303: 5074:                   VALID.NAME.FOUND)
3304: 5074: 
3305: 5074:               OPERATOR.NAME$ = UCASE$(F03.RETURNED.STRING$)
3306: 5097: 
3307: 5097:               IF NOT (FUNCTION.KEY% = ENTER.KEY% OR                    \
3308: 514f:                  FUNCTION.KEY% = END.KEY% OR                           \
3309: 514f:                  FUNCTION.KEY% = TAB.KEY% OR                           \
3310: 514f:                  FUNCTION.KEY% = BTAB.KEY% OR                          \
3311: 514f:                  FUNCTION.KEY% = HOME.KEY% OR                          \
3312: 514f:                  FUNCTION.KEY% = HELP.KEY% OR                          \
3313: 514f:                  FUNCTION.KEY% = QUIT.KEY% OR                          \
3314: 514f:                  FUNCTION.KEY% = ESC.KEY%) THEN                        \
3315: 514f:               BEGIN
3316: 514f:                  DISPLAY.MESSAGE.NUMBER% = 1
3317: 5160:                  CALL DISPLAY.MESSAGE                                  ! 1.5 RC
3318: 516d:                  CALL RESUME.INPUT                                     ! 1.5 RC
3319: 517d:               ENDIF                                                    \
3320: 517d:               ELSE                                                     \
3321: 5185:               IF FUNCTION.KEY% = QUIT.KEY% THEN                        \
3322: 519d:               BEGIN
3323: 519d:                  CALL GET.QUIT.CONFIRM                                 ! 1.5 RC
3324: 51ad:               ENDIF                                                    \
3325: 51ad:               ELSE                                                     \
3326: 51b5:               IF FUNCTION.KEY% = ESC.KEY% THEN                         \
3327: 51cd:               BEGIN
3328: 51cd:                  CHAIN.TO.PROG$ = "PSB50"
3329: 51e4:                  PSBCHN.MENCON  = "000000"
3330: 51fb:                  CALL CHAIN.TO.CALLER                                  ! 1.5 RC
3331: 520b:               ENDIF                                                    \
3332: 520b:               ELSE                                                     \
3333: 5213:               IF FUNCTION.KEY% = HELP.KEY% THEN                        \
3334: 522b:               BEGIN
3335: 522b:                  CALL SCREEN.HELP(2)
3336: 5249:                  CALL RESTORE.FIELDS.02                                ! 1.5 RC
3337: 5255: 
3338: 5255:                  CURSOR.POSITION% = S2.NAME%
3339: 526b:                  CALL PUT.CURSOR.IN.FIELD                              ! 1.5 RC
3340: 5278: 
3341: 5278:                  CALL GET.INPUT                                        ! 1.5 RC
3342: 5287:               ENDIF                                                    \
3343: 5287:               ELSE                                                     \
3344: 528f:               BEGIN
3345: 528f:                  IF VALID.NAME THEN                                    \
3346: 529f:                     VALID.NAME.FOUND = TRUE                            \
3347: 52b7:                  ELSE                                                  \
3348: 52bf:                  BEGIN
3349: 52bf:                     ! B358 Invalid name
3350: 52bf:                     DISPLAY.MESSAGE.NUMBER% = 358
3351: 52d0:                     CALL DISPLAY.MESSAGE                               ! 1.5 RC
3352: 52dd:                     CALL RESUME.INPUT                                  ! 1.5 RC
3353: 52ea:                  ENDIF
3354: 52f2:               ENDIF
3355: 52fa:         WEND
3356: 5321: 
3357: 5321:         IF VALID.NAME.FOUND AND                                        \
3358: 534c:            NOT EXIT.KEY.PRESSED(2) THEN                                \
3359: 534c:         BEGIN
3360: 534c:            CALL CLEAR.MESSAGE                                          ! 1.5 RC
3361: 5359: 
3362: 5359:            OPERATOR.NAME$ = LEFT$(OPERATOR.NAME$ +                     \
3363: 53a8:                             STRING$(20," "),20)
3364: 53a8: 
3365: 53a8:            STRING.DATA$ = OPERATOR.NAME$
3366: 53c6:            CALL SET.FIELD                                              ! 1.5 RC
3367: 53d3: 
3368: 53d3:            IF FUNCTION.KEY% = TAB.KEY% THEN                            \
3369: 53eb:            BEGIN
3370: 53eb:               GOSUB GET.PASSWORD.02
3371: 5400:            ENDIF                                                       \
3372: 5400:            ELSE                                                        \
3373: 5408:            IF FUNCTION.KEY% = HOME.KEY% OR                             \
3374: 543c:               FUNCTION.KEY% = BTAB.KEY% THEN                           \
3375: 543c:            BEGIN
3376: 543c:               GOSUB GET.OPERATOR.ID.02
3377: 5450:            ENDIF                                                       \
3378: 5450:            ELSE                                                        \
3379: 5458:            IF FUNCTION.KEY% = END.KEY% THEN                            \
3380: 5470:            BEGIN
3381: 5470:               GOSUB GET.EMPLOYEE.FLG.02
3382: 5484:            ENDIF                                                       \
3383: 5484:            ELSE                                                        \
3384: 548c:            IF FUNCTION.KEY% = ENTER.KEY% THEN                          \
3385: 54a4:            BEGIN
3386: 54a4:               GOSUB CHECK.FIELDS.02
3387: 54b6:            ENDIF
3388: 54be:         ENDIF
3389: 54c6: 
3390: 54c6:         RETURN
3391: 54d6: 
3392: 54d6: \******************************************************************************
3393: 54d6: \***                                                                          *
3394: 54d6: \***    SUBROUTINE      :       GET.PASSWORD.02                               *
3395: 54d6: \***                                                                          *
3396: 54d6: \******************************************************************************
3397: 54d6: \***                                                                          *
3398: 54d6: \***    Input routine for the password on the add an operator screen          *
3399: 54d6: \***                                                                          *
3400: 54d6: \******************************************************************************
3401: 54d6: 
3402: 54d6:         GET.PASSWORD.02:
3403: 54e6: 
3404: 54e6:         CURSOR.POSITION% = S2.PASSWORD%
3405: 54fc:         CALL PUT.CURSOR.IN.FIELD                                       ! 1.5 RC
3406: 5509: 
3407: 5509:         EXIT.KEY.PRESSED(2)  = FALSE
3408: 5531:         VALID.PASSWORD.FOUND = FALSE
3409: 5547: 
3410: 5547:         CALL GET.INPUT                                                 ! 1.5 RC
3411: 5554: 
3412: 5554:         WHILE NOT (EXIT.KEY.PRESSED(2) OR                              \
3413: 555f:                   VALID.PASSWORD.FOUND)
3414: 555f: 
3415: 555f:               OPERATOR.PASSWORD$ = RIGHT$(STRING$(3,"0") +             \
3416: 55c6:                                    STR$(VAL(F03.RETURNED.STRING$)),3)
3417: 55c6: 
3418: 55c6:               IF NOT (FUNCTION.KEY% = ENTER.KEY% OR                    \
3419: 567e:                  FUNCTION.KEY% = END.KEY% OR                           \
3420: 567e:                  FUNCTION.KEY% = TAB.KEY% OR                           \
3421: 567e:                  FUNCTION.KEY% = BTAB.KEY% OR                          \
3422: 567e:                  FUNCTION.KEY% = HOME.KEY% OR                          \
3423: 567e:                  FUNCTION.KEY% = HELP.KEY% OR                          \
3424: 567e:                  FUNCTION.KEY% = QUIT.KEY% OR                          \
3425: 567e:                  FUNCTION.KEY% = ESC.KEY%) THEN                        \
3426: 567e:               BEGIN
3427: 567e:                  DISPLAY.MESSAGE.NUMBER% = 1
3428: 568f:                  CALL DISPLAY.MESSAGE                                  ! 1.5 RC
3429: 569c:                  CALL RESUME.INPUT                                     ! 1.5 RC
3430: 56ac:               ENDIF                                                    \
3431: 56ac:               ELSE                                                     \
3432: 56b4:               IF FUNCTION.KEY% = QUIT.KEY% THEN                        \
3433: 56cc:               BEGIN
3434: 56cc:                  CALL GET.QUIT.CONFIRM                                 ! 1.5 RC
3435: 56dc:               ENDIF                                                    \
3436: 56dc:               ELSE                                                     \
3437: 56e4:               IF FUNCTION.KEY% = ESC.KEY% THEN                         \
3438: 56fc:               BEGIN
3439: 56fc:                  CHAIN.TO.PROG$ = "PSB50"
3440: 5713:                  PSBCHN.MENCON  = "000000"
3441: 572a:                  CALL CHAIN.TO.CALLER                                  ! 1.5 RC
3442: 573a:               ENDIF                                                    \
3443: 573a:               ELSE                                                     \
3444: 5742:               IF FUNCTION.KEY% = HELP.KEY% THEN                        \
3445: 575a:               BEGIN
3446: 575a:                  CALL SCREEN.HELP(2)
3447: 5778:                  CALL RESTORE.FIELDS.02                                ! 1.5 RC
3448: 5784: 
3449: 5784:                  CURSOR.POSITION% = S2.PASSWORD%
3450: 579a:                  CALL PUT.CURSOR.IN.FIELD                              ! 1.5 RC
3451: 57a7: 
3452: 57a7:                  CALL GET.INPUT                                        ! 1.5 RC
3453: 57b6:               ENDIF                                                    \
3454: 57b6:               ELSE                                                     \
3455: 57be:               BEGIN
3456: 57be:                  IF VALID.PASSWORD THEN                                \
3457: 57ce:                     VALID.PASSWORD.FOUND = TRUE                        \
3458: 57e6:                  ELSE                                                  \
3459: 57ee:                  BEGIN
3460: 57ee:                     ! B332 Invalid password
3461: 57ee:                     DISPLAY.MESSAGE.NUMBER% = 332
3462: 57ff:                     CALL DISPLAY.MESSAGE                               ! 1.5 RC
3463: 580c:                     CALL RESUME.INPUT                                  ! 1.5 RC
3464: 5819:                  ENDIF
3465: 5821:               ENDIF
3466: 5829:         WEND
3467: 5850: 
3468: 5850:         IF VALID.PASSWORD.FOUND AND                                    \
3469: 587b:            NOT EXIT.KEY.PRESSED(2) THEN                                \
3470: 587b:         BEGIN
3471: 587b:            CALL CLEAR.MESSAGE                                          ! 1.5 RC
3472: 5888: 
3473: 5888:            STRING.DATA$ = OPERATOR.PASSWORD$
3474: 58a6:            CALL SET.FIELD                                              ! 1.5 RC
3475: 58b3: 
3476: 58b3:            IF FUNCTION.KEY% = TAB.KEY% THEN                            \
3477: 58cb:            BEGIN
3478: 58cb:               GOSUB GET.STAFF.NO.02
3479: 58df:            ENDIF                                                       \
3480: 58df:            ELSE                                                        \
3481: 58e7:            IF FUNCTION.KEY% = HOME.KEY% THEN                           \
3482: 58ff:            BEGIN
3483: 58ff:               GOSUB GET.OPERATOR.ID.02
3484: 5913:            ENDIF                                                       \
3485: 5913:            ELSE                                                        \
3486: 591b:            IF FUNCTION.KEY% = BTAB.KEY% THEN                           \
3487: 5933:            BEGIN
3488: 5933:               GOSUB GET.NAME.02
3489: 5947:            ENDIF                                                       \
3490: 5947:            ELSE
3491: 594f:            IF FUNCTION.KEY% = END.KEY% THEN                            \
3492: 5967:            BEGIN
3493: 5967:               GOSUB GET.EMPLOYEE.FLG.02
3494: 597b:            ENDIF                                                       \
3495: 597b:            ELSE                                                        \
3496: 5983:            IF FUNCTION.KEY% = ENTER.KEY% THEN                          \
3497: 599b:            BEGIN
3498: 599b:               GOSUB CHECK.FIELDS.02
3499: 59ad:            ENDIF
3500: 59b5:         ENDIF
3501: 59bd: 
3502: 59bd:         RETURN
3503: 59cd: 
3504: 59cd: \******************************************************************************
3505: 59cd: \***                                                                          *
3506: 59cd: \***    SUBROUTINE      :       GET.STAFF.NO.02                               *
3507: 59cd: \***                                                                          *
3508: 59cd: \******************************************************************************
3509: 59cd: \***                                                                          *
3510: 59cd: \***    Input routine for the staff no on the add an operator screen          *
3511: 59cd: \***                                                                          *
3512: 59cd: \******************************************************************************
3513: 59cd: 
3514: 59cd:         GET.STAFF.NO.02:
3515: 59dd: 
3516: 59dd:         CURSOR.POSITION% = S2.STAFF.NO%
3517: 59f3:         CALL PUT.CURSOR.IN.FIELD                                       ! 1.5 RC
3518: 5a00: 
3519: 5a00:         EXIT.KEY.PRESSED(2)  = FALSE
3520: 5a28:         VALID.STAFF.NO.FOUND = FALSE
3521: 5a3e: 
3522: 5a3e:         CALL GET.INPUT                                                 ! 1.5 RC
3523: 5a4b: 
3524: 5a4b:         WHILE NOT (EXIT.KEY.PRESSED(2) OR                              \
3525: 5a56:                   VALID.STAFF.NO.FOUND)
3526: 5a56: 
3527: 5a56:               STAFF.NO$ = RIGHT$(STRING$(8,"0") +             \
3528: 5abd:                                    STR$(VAL(F03.RETURNED.STRING$)),8)
3529: 5abd: 
3530: 5abd:               IF NOT (FUNCTION.KEY% = ENTER.KEY% OR                    \
3531: 5b75:                  FUNCTION.KEY% = END.KEY% OR                           \
3532: 5b75:                  FUNCTION.KEY% = TAB.KEY% OR                           \
3533: 5b75:                  FUNCTION.KEY% = BTAB.KEY% OR                          \
3534: 5b75:                  FUNCTION.KEY% = HOME.KEY% OR                          \
3535: 5b75:                  FUNCTION.KEY% = HELP.KEY% OR                          \
3536: 5b75:                  FUNCTION.KEY% = QUIT.KEY% OR                          \
3537: 5b75:                  FUNCTION.KEY% = ESC.KEY%) THEN                        \
3538: 5b75:               BEGIN
3539: 5b75:                  DISPLAY.MESSAGE.NUMBER% = 1
3540: 5b86:                  CALL DISPLAY.MESSAGE                                  ! 1.5 RC
3541: 5b93:                  CALL RESUME.INPUT                                     ! 1.5 RC
3542: 5ba3:               ENDIF                                                    \
3543: 5ba3:               ELSE                                                     \
3544: 5bab:               IF FUNCTION.KEY% = QUIT.KEY% THEN                        \
3545: 5bc3:               BEGIN
3546: 5bc3:                  CALL GET.QUIT.CONFIRM                                 ! 1.5 RC
3547: 5bd3:               ENDIF                                                    \
3548: 5bd3:               ELSE                                                     \
3549: 5bdb:               IF FUNCTION.KEY% = ESC.KEY% THEN                         \
3550: 5bf3:               BEGIN
3551: 5bf3:                  CHAIN.TO.PROG$ = "PSB50"
3552: 5c0a:                  PSBCHN.MENCON  = "000000"
3553: 5c21:                  CALL CHAIN.TO.CALLER                                  ! 1.5 RC
3554: 5c31:               ENDIF                                                    \
3555: 5c31:               ELSE                                                     \
3556: 5c39:               IF FUNCTION.KEY% = HELP.KEY% THEN                        \
3557: 5c51:               BEGIN
3558: 5c51:                  CALL SCREEN.HELP(2)
3559: 5c6f:                  CALL RESTORE.FIELDS.02                                ! 1.5 RC
3560: 5c7b: 
3561: 5c7b:                  CURSOR.POSITION% = S2.STAFF.NO%
3562: 5c91:                  CALL PUT.CURSOR.IN.FIELD                              ! 1.5 RC
3563: 5c9e: 
3564: 5c9e:                  CALL GET.INPUT                                        ! 1.5 RC
3565: 5cae:               ENDIF                                                    \
3566: 5cae:               ELSE                                                     \
3567: 5cb6:               BEGIN
3568: 5cb6:                  IF VALID.STAFF.NO(FALSE)                             \! 1.9 NM
3569: 5cd1:                  THEN BEGIN                                            ! 1.9 NM
3570: 5cd1:                     VALID.STAFF.NO.FOUND = TRUE
3571: 5ce9:                  ENDIF ELSE BEGIN                                      ! 1.9 NM
3572: 5cf1: 
3573: 5cf1:                     ! B221 Free format
3574: 5cf1:                     DISPLAY.MESSAGE.NUMBER% = 221
3575: 5d02: 
3576: 5d02:                     !Commented as part of Core 2 Release               ! 1.9 NM
3577: 5d02:                     !DISPLAY.MESSAGE.TEXT$ =                          \! 1.9 NM
3578: 5d02:                     !"STAFF NUMBER MUST BE 0 OR GREATER"               ! 1.9 NM
3579: 5d02: 
3580: 5d02:                     CALL DISPLAY.MESSAGE                               ! 1.5 RC
3581: 5d0f:                     CALL RESUME.INPUT                                  ! 1.5 RC
3582: 5d1c:                  ENDIF
3583: 5d24:               ENDIF
3584: 5d2c:         WEND
3585: 5d53: 
3586: 5d53:         IF VALID.STAFF.NO.FOUND AND                                    \
3587: 5d7e:            NOT EXIT.KEY.PRESSED(2) THEN                                \
3588: 5d7e:         BEGIN
3589: 5d7e:            CALL CLEAR.MESSAGE                                          ! 1.5 RC
3590: 5d8b: 
3591: 5d8b:            STRING.DATA$ = STAFF.NO$
3592: 5da9:            CALL SET.FIELD                                              ! 1.5 RC
3593: 5db6: 
3594: 5db6:            IF FUNCTION.KEY% = TAB.KEY% THEN                            \ !.6 RC
3595: 5dce:            BEGIN
3596: 5dce:               GOSUB GET.BIRTH.DATE.02                                  ! 1.6 RC
3597: 5de3:            ENDIF                                                       \
3598: 5de3:            ELSE                                                        \
3599: 5deb:            IF FUNCTION.KEY% = HOME.KEY% THEN                           \
3600: 5e03:            BEGIN
3601: 5e03:               GOSUB GET.OPERATOR.ID.02
3602: 5e18:            ENDIF                                                       \
3603: 5e18:            ELSE                                                        \
3604: 5e20:            IF FUNCTION.KEY% = BTAB.KEY% THEN                           \
3605: 5e38:            BEGIN
3606: 5e38:               GOSUB GET.PASSWORD.02
3607: 5e4c:            ENDIF                                                       \
3608: 5e4c:            ELSE                                                        \
3609: 5e54:            IF FUNCTION.KEY% = END.KEY% THEN                            \ !.6 RC
3610: 5e6c:            BEGIN                                                       ! 1.6 RC
3611: 5e6c:               GOSUB GET.EMPLOYEE.FLG.02                                ! 1.6 RC
3612: 5e80:            ENDIF                                                       \ 1.6 RC
3613: 5e80:            ELSE                                                        \ 1.6 RC
3614: 5e88:            IF FUNCTION.KEY% = ENTER.KEY% THEN                          \
3615: 5ea0:            BEGIN
3616: 5ea0:               GOSUB CHECK.FIELDS.02
3617: 5eb2:            ENDIF
3618: 5eba:         ENDIF
3619: 5ec2: 
3620: 5ec2:         RETURN
3621: 5ed2: 
3622: 5ed2: 
3623: 5ed2: \******************************************************************************
3624: 5ed2: \***
3625: 5ed2: \***    SUBROUTINE      :       GET.BIRTH.DATE.02
3626: 5ed2: \***
3627: 5ed2: \******************************************************************************
3628: 5ed2: \***
3629: 5ed2: \***    Input routine for the birth date on the add an operator screen
3630: 5ed2: \***
3631: 5ed2: \******************************************************************************
3632: 5ed2: 
3633: 5ed2:         GET.BIRTH.DATE.02: ! Entire procedure new for Rv 1.6              ! 1.6 RC
3634: 5ee2:                            ! Modified from copy of GET.PASSWORD.02        ! 1.6 RC
3635: 5ee2: 
3636: 5ee2:         CURSOR.POSITION% = S2.BIRTH.DATE%
3637: 5ef8:         CALL PUT.CURSOR.IN.FIELD
3638: 5f05: 
3639: 5f05:         EXIT.KEY.PRESSED(2)  = FALSE
3640: 5f2d:         VALID.BIRTH.DATE.FOUND = FALSE
3641: 5f43: 
3642: 5f43:         CALL GET.INPUT
3643: 5f50: 
3644: 5f50:         WHILE NOT (EXIT.KEY.PRESSED(2) OR  \
3645: 5f5b:                   VALID.BIRTH.DATE.FOUND)
3646: 5f5b: 
3647: 5f5b:               BIRTH.DATE$ = F03.RETURNED.STRING$
3648: 5f79: 
3649: 5f79:               IF NOT (FUNCTION.KEY% = ENTER.KEY% OR \
3650: 6031:                  FUNCTION.KEY% = END.KEY% OR \
3651: 6031:                  FUNCTION.KEY% = TAB.KEY% OR \
3652: 6031:                  FUNCTION.KEY% = BTAB.KEY% OR \
3653: 6031:                  FUNCTION.KEY% = HOME.KEY% OR \
3654: 6031:                  FUNCTION.KEY% = HELP.KEY% OR \
3655: 6031:                  FUNCTION.KEY% = QUIT.KEY% OR \
3656: 6031:                  FUNCTION.KEY% = ESC.KEY%) THEN \
3657: 6031:               BEGIN
3658: 6031:                  DISPLAY.MESSAGE.NUMBER% = 1
3659: 6042:                  CALL DISPLAY.MESSAGE
3660: 604f:                  CALL RESUME.INPUT
3661: 605f:               ENDIF \
3662: 605f:               ELSE \
3663: 6067:               IF FUNCTION.KEY% = QUIT.KEY% THEN \
3664: 607f:               BEGIN
3665: 607f:                  CALL GET.QUIT.CONFIRM
3666: 608f:               ENDIF \
3667: 608f:               ELSE \
3668: 6097:               IF FUNCTION.KEY% = ESC.KEY% THEN \
3669: 60af:               BEGIN
3670: 60af:                  CHAIN.TO.PROG$ = "PSB50"
3671: 60c6:                  PSBCHN.MENCON  = "000000"
3672: 60dd:                  CALL CHAIN.TO.CALLER
3673: 60ed:               ENDIF \
3674: 60ed:               ELSE \
3675: 60f5:               IF FUNCTION.KEY% = HELP.KEY% THEN \
3676: 610d:               BEGIN
3677: 610d:                  CALL SCREEN.HELP(2)
3678: 612b:                  CALL RESTORE.FIELDS.02
3679: 6137:                  CURSOR.POSITION% = S2.BIRTH.DATE%
3680: 614d:                  CALL PUT.CURSOR.IN.FIELD
3681: 615a:                  CALL GET.INPUT
3682: 6169:               ENDIF \
3683: 6169:               ELSE \
3684: 6171:               BEGIN
3685: 6171:                  IF VALID.BIRTH.DATE THEN \ ! Validates BIRTH.DATE$
3686: 6181:                     VALID.BIRTH.DATE.FOUND = TRUE \
3687: 6199:                  ELSE \
3688: 61a1:                  BEGIN
3689: 61a1: !                   DISPLAY.MESSAGE.NUMBER% set within VALID.BIRTH.DATE
3690: 61a1:                     CALL DISPLAY.MESSAGE
3691: 61ae:                     CALL RESUME.INPUT
3692: 61bb:                  ENDIF
3693: 61c3:               ENDIF
3694: 61cb:         WEND
3695: 61f2: 
3696: 61f2:         IF VALID.BIRTH.DATE.FOUND AND \
3697: 621d:            NOT EXIT.KEY.PRESSED(2) THEN \
3698: 621d:         BEGIN
3699: 621d:            CALL CLEAR.MESSAGE
3700: 622a: 
3701: 622a:            STRING.DATA$ = BIRTH.DATE$
3702: 6248:            CALL SET.FIELD
3703: 6255: 
3704: 6255:            IF FUNCTION.KEY% = TAB.KEY% THEN \
3705: 626d:            BEGIN
3706: 626d:               GOSUB GET.RECEIPT.NAME.02
3707: 6282:            ENDIF \
3708: 6282:            ELSE \
3709: 628a:            IF FUNCTION.KEY% = HOME.KEY% THEN \
3710: 62a2:            BEGIN
3711: 62a2:               GOSUB GET.OPERATOR.ID.02
3712: 62b7:            ENDIF \
3713: 62b7:            ELSE \
3714: 62bf:            IF FUNCTION.KEY% = BTAB.KEY% THEN \
3715: 62d7:            BEGIN
3716: 62d7:               GOSUB GET.STAFF.NO.02
3717: 62eb:            ENDIF \
3718: 62eb:            ELSE \
3719: 62f3:            IF FUNCTION.KEY% = END.KEY% THEN \
3720: 630b:            BEGIN
3721: 630b:               GOSUB GET.EMPLOYEE.FLG.02
3722: 631f:            ENDIF \
3723: 631f:            ELSE \
3724: 6327:            IF FUNCTION.KEY% = ENTER.KEY% THEN \
3725: 633f:            BEGIN
3726: 633f:               GOSUB CHECK.FIELDS.02
3727: 6351:            ENDIF
3728: 6359:         ENDIF
3729: 6361: 
3730: 6361:         RETURN
3731: 6371: 
3732: 6371: 
3733: 6371: \******************************************************************************
3734: 6371: \***                                                                          *
3735: 6371: \***    SUBROUTINE      :       GET.RECEIPT.NAME.02                     ! AJC *
3736: 6371: \***                                                                          *
3737: 6371: \******************************************************************************
3738: 6371: \***                                                                          *
3739: 6371: \***    Input routine for the receipt name on the add an operator screen! AJC *
3740: 6371: \***                                                                          *
3741: 6371: \******************************************************************************
3742: 6371: 
3743: 6371:         GET.RECEIPT.NAME.02:                                          ! AJC
3744: 6381: 
3745: 6381:         CURSOR.POSITION% = S2.RECEIPT.NAME%                           ! AJC
3746: 6397:         CALL PUT.CURSOR.IN.FIELD                                       ! 1.5 RC
3747: 63a4: 
3748: 63a4:         EXIT.KEY.PRESSED(2)  = FALSE                                  ! AJC
3749: 63cc:         VALID.RECEIPT.NAME.FOUND = FALSE                              ! AJC
3750: 63e2: 
3751: 63e2:         CALL GET.INPUT                                                 ! 1.5 RC
3752: 63ef: 
3753: 63ef:         WHILE NOT (EXIT.KEY.PRESSED(2) OR                            \! AJC
3754: 63fa:                   VALID.RECEIPT.NAME.FOUND)                           ! AJC
3755: 63fa: 
3756: 63fa:               RECEIPT.NAME$ = F03.RETURNED.STRING$                    ! AJC
3757: 6418: 
3758: 6418:               IF NOT (FUNCTION.KEY% = ENTER.KEY% OR                  \! AJC
3759: 64d0:                  FUNCTION.KEY% = END.KEY% OR                         \! AJC
3760: 64d0:                  FUNCTION.KEY% = TAB.KEY% OR                         \! AJC
3761: 64d0:                  FUNCTION.KEY% = BTAB.KEY% OR                        \! AJC
3762: 64d0:                  FUNCTION.KEY% = HOME.KEY% OR                        \! AJC
3763: 64d0:                  FUNCTION.KEY% = HELP.KEY% OR                        \! AJC
3764: 64d0:                  FUNCTION.KEY% = QUIT.KEY% OR                        \! AJC
3765: 64d0:                  FUNCTION.KEY% = ESC.KEY%) THEN                      \! AJC
3766: 64d0:               BEGIN                                                   ! AJC
3767: 64d0:                  DISPLAY.MESSAGE.NUMBER% = 1                          ! AJC
3768: 64e1:                  CALL DISPLAY.MESSAGE                                  ! 1.5 RC
3769: 64ee:                  CALL RESUME.INPUT                                     ! 1.5 RC
3770: 64fe:               ENDIF                                                  \! AJC
3771: 64fe:               ELSE                                                   \! AJC
3772: 6506:               IF FUNCTION.KEY% = QUIT.KEY% THEN                      \! AJC
3773: 651e:               BEGIN                                                   ! AJC
3774: 651e:                  CALL GET.QUIT.CONFIRM                                 ! 1.5 RC
3775: 652e:               ENDIF                                                  \! AJC
3776: 652e:               ELSE                                                   \! AJC
3777: 6536:               IF FUNCTION.KEY% = ESC.KEY% THEN                       \! AJC
3778: 654e:               BEGIN                                                   ! AJC
3779: 654e:                  CHAIN.TO.PROG$ = "PSB50"                             ! AJC
3780: 6565:                  PSBCHN.MENCON  = "000000"                            ! AJC
3781: 657c:                  CALL CHAIN.TO.CALLER                                  ! 1.5 RC
3782: 658c:               ENDIF                                                  \! AJC
3783: 658c:               ELSE                                                   \! AJC
3784: 6594:               IF FUNCTION.KEY% = HELP.KEY% THEN                      \! AJC
3785: 65ac:               BEGIN                                                   ! AJC
3786: 65ac:                  CALL SCREEN.HELP(2)                                  ! AJC
3787: 65ca:                  CALL RESTORE.FIELDS.02                                ! 1.5 RC
3788: 65d6: 
3789: 65d6:                  CURSOR.POSITION% = S2.RECEIPT.NAME%                  ! AJC
3790: 65ec:                  CALL PUT.CURSOR.IN.FIELD                              ! 1.5 RC
3791: 65f9: 
3792: 65f9:                  CALL GET.INPUT                                        ! 1.5 RC
3793: 6609:               ENDIF                                                  \! AJC
3794: 6609:               ELSE                                                   \! AJC
3795: 6611:               BEGIN                                                   ! AJC
3796: 6611: 
3797: 6611:                  IF VALID.RECEIPT.NAME THEN                          \! AJC
3798: 6621:                     VALID.RECEIPT.NAME.FOUND = TRUE                  \! AJC
3799: 6639:                  ELSE                                                \! AJC
3800: 6641:                  BEGIN                                                ! AJC
3801: 6641:                     ! B221 Free format                                ! AJC
3802: 6641:                     DISPLAY.MESSAGE.NUMBER% = 221                     ! AJC
3803: 6652:                     DISPLAY.MESSAGE.TEXT$ =                          \! AJC
3804: 6669:                     "NAME ON RECEIPT MUST BE ENTERED  "               ! AJC
3805: 6669:                     CALL DISPLAY.MESSAGE                               ! 1.5 RC
3806: 6676:                     CALL RESUME.INPUT                                  ! 1.5 RC
3807: 6683:                  ENDIF                                                ! AJC
3808: 668b:               ENDIF                                                   ! AJC
3809: 6693:         WEND                                                          ! AJC
3810: 66ba: 
3811: 66ba:         IF VALID.RECEIPT.NAME.FOUND AND                              \! AJC
3812: 66e5:            NOT EXIT.KEY.PRESSED(2) THEN                              \! AJC
3813: 66e5:         BEGIN                                                         ! AJC
3814: 66e5:            CALL CLEAR.MESSAGE                                          ! 1.5 RC
3815: 66f2: 
3816: 66f2:            STRING.DATA$ = RECEIPT.NAME$                               ! AJC
3817: 6710:            CALL SET.FIELD                                              ! 1.5 RC
3818: 671d: 
3819: 671d:            IF FUNCTION.KEY% = TAB.KEY% THEN                          \!  1.6 RC
3820: 6735:            BEGIN                                                      ! AJC
3821: 6735: !AJC 1.4      GOSUB GET.EMPLOYEE.FLG.02                               ! AJC
3822: 6735:               GOSUB GET.GROUP.CODE.02                                 ! AJC 1.4
3823: 674a:            ENDIF                                                     \! AJC
3824: 674a:            ELSE                                                      \! AJC
3825: 6752:            IF FUNCTION.KEY% = HOME.KEY% THEN                         \! AJC
3826: 676a:            BEGIN                                                      ! AJC
3827: 676a:               GOSUB GET.OPERATOR.ID.02                                ! AJC
3828: 677f:            ENDIF                                                     \! AJC
3829: 677f:            ELSE                                                      \! AJC
3830: 6787:            IF FUNCTION.KEY% = BTAB.KEY% THEN                         \! AJC
3831: 679f:            BEGIN                                                      ! AJC
3832: 679f:               GOSUB GET.BIRTH.DATE.02                                  ! !.1 RC
3833: 67b3:            ENDIF                                                     \! AJC
3834: 67b3:            ELSE                                                      \! AJC
3835: 67bb:            IF FUNCTION.KEY% = END.KEY% THEN \                          ! 1.6 RC
3836: 67d3:            BEGIN                                                       ! 1.6 RC
3837: 67d3:               GOSUB GET.EMPLOYEE.FLG.02                                ! 1.6 RC
3838: 67e7:            ENDIF \                                                     ! 1.6 RC
3839: 67e7:            ELSE \                                                      ! 1.6 RC
3840: 67ef:            IF FUNCTION.KEY% = ENTER.KEY% THEN                        \! AJC
3841: 6807:            BEGIN                                                      ! AJC
3842: 6807:               GOSUB CHECK.FIELDS.02                                   ! AJC
3843: 6819:            ENDIF                                                      ! AJC
3844: 6821:         ENDIF                                                         ! AJC
3845: 6829: 
3846: 6829:         RETURN
3847: 6839: 
3848: 6839: \******************************************************************************
3849: 6839: \***                                                                          *
3850: 6839: \***    SUBROUTINE      :       GET.EMPLOYEE.FLG.02                           *
3851: 6839: \***                                                                          *
3852: 6839: \******************************************************************************
3853: 6839: \***                                                                          *
3854: 6839: \***    Input routine for the employee flag on the add an operator screen     *
3855: 6839: \***                                                                          *
3856: 6839: \******************************************************************************
3857: 6839: 
3858: 6839:         GET.EMPLOYEE.FLG.02:
3859: 6849: 
3860: 6849:         CURSOR.POSITION% = S2.EMPLOYEE.FLG%
3861: 685f:         CALL PUT.CURSOR.IN.FIELD                                       ! 1.5 RC
3862: 686c: 
3863: 686c:         EXIT.KEY.PRESSED(2)  = FALSE
3864: 6894:         VALID.EMPLOYEE.FLG.FOUND = FALSE
3865: 68aa: 
3866: 68aa:         CALL GET.INPUT                                                 ! 1.5 RC
3867: 68b7: 
3868: 68b7:         WHILE NOT (EXIT.KEY.PRESSED(2) OR                              \
3869: 68c2:                   VALID.EMPLOYEE.FLG.FOUND)
3870: 68c2: 
3871: 68c2:               EMPLOYEE.FLG$ = UCASE$(F03.RETURNED.STRING$)
3872: 68e5: 
3873: 68e5:               IF NOT (FUNCTION.KEY% = ENTER.KEY% OR                    \
3874: 699d:                  FUNCTION.KEY% = END.KEY% OR                           \
3875: 699d:                  FUNCTION.KEY% = TAB.KEY% OR                           \
3876: 699d:                  FUNCTION.KEY% = BTAB.KEY% OR                          \
3877: 699d:                  FUNCTION.KEY% = HOME.KEY% OR                          \
3878: 699d:                  FUNCTION.KEY% = HELP.KEY% OR                          \
3879: 699d:                  FUNCTION.KEY% = QUIT.KEY% OR                          \
3880: 699d:                  FUNCTION.KEY% = ESC.KEY%) THEN                        \
3881: 699d:               BEGIN
3882: 699d:                  DISPLAY.MESSAGE.NUMBER% = 1
3883: 69ae:                  CALL DISPLAY.MESSAGE                                  ! 1.5 RC
3884: 69bb:                  CALL RESUME.INPUT                                     ! 1.5 RC
3885: 69cb:               ENDIF                                                    \
3886: 69cb:               ELSE                                                     \
3887: 69d3:               IF FUNCTION.KEY% = QUIT.KEY% THEN                        \
3888: 69eb:               BEGIN
3889: 69eb:                  CALL GET.QUIT.CONFIRM                                 ! 1.5 RC
3890: 69fb:               ENDIF                                                    \
3891: 69fb:               ELSE                                                     \
3892: 6a03:               IF FUNCTION.KEY% = ESC.KEY% THEN                         \
3893: 6a1b:               BEGIN
3894: 6a1b:                  CHAIN.TO.PROG$ = "PSB50"
3895: 6a32:                  PSBCHN.MENCON  = "000000"
3896: 6a49:                  CALL CHAIN.TO.CALLER                                  ! 1.5 RC
3897: 6a59:               ENDIF                                                    \
3898: 6a59:               ELSE                                                     \
3899: 6a61:               IF FUNCTION.KEY% = HELP.KEY% THEN                        \
3900: 6a79:               BEGIN
3901: 6a79:                  CALL SCREEN.HELP(2)
3902: 6a97:                  CALL RESTORE.FIELDS.02                                ! 1.5 RC
3903: 6aa3: 
3904: 6aa3:                  CURSOR.POSITION% = S2.EMPLOYEE.FLG%
3905: 6ab9:                  CALL PUT.CURSOR.IN.FIELD                              ! 1.5 RC
3906: 6ac6: 
3907: 6ac6:                  CALL GET.INPUT                                        ! 1.5 RC
3908: 6ad5:               ENDIF                                                    \
3909: 6ad5:               ELSE                                                     \
3910: 6add:               BEGIN
3911: 6add:                  IF VALID.EMPLOYEE.FLG THEN                            \
3912: 6aed:                     VALID.EMPLOYEE.FLG.FOUND = TRUE                    \
3913: 6b05:                  ELSE                                                  \
3914: 6b0d:                  BEGIN
3915: 6b0d:                     ! B064 YOU MUST ONLY TYPE "N" OR "Y"
3916: 6b0d:                     DISPLAY.MESSAGE.NUMBER% = 64
3917: 6b1e:                     CALL DISPLAY.MESSAGE                               ! 1.5 RC
3918: 6b2b:                     CALL RESUME.INPUT                                  ! 1.5 RC
3919: 6b38:                  ENDIF
3920: 6b40:               ENDIF
3921: 6b48:         WEND
3922: 6b6f: 
3923: 6b6f:         IF VALID.EMPLOYEE.FLG.FOUND AND                                \
3924: 6b9a:            NOT EXIT.KEY.PRESSED(2) THEN                                \
3925: 6b9a:         BEGIN
3926: 6b9a:            CALL CLEAR.MESSAGE                                          ! 1.5 RC
3927: 6ba7: 
3928: 6ba7:            STRING.DATA$ = EMPLOYEE.FLG$
3929: 6bc5:            CALL SET.FIELD                                              ! 1.5 RC
3930: 6bd2: 
3931: 6bd2:            IF FUNCTION.KEY% = TAB.KEY% THEN                            \
3932: 6bea:            BEGIN
3933: 6bea:               TILL.PTR% = 1
3934: 6bfb:               GOSUB GET.TILL.MODEL.02
3935: 6c10:            ENDIF                                                       \
3936: 6c10:            ELSE                                                        \
3937: 6c18:            IF FUNCTION.KEY% = HOME.KEY% THEN                           \
3938: 6c30:            BEGIN
3939: 6c30:               GOSUB GET.OPERATOR.ID.02
3940: 6c45:            ENDIF                                                       \
3941: 6c45:            ELSE                                                        \
3942: 6c4d:            IF FUNCTION.KEY% = BTAB.KEY% THEN                           \
3943: 6c65:            BEGIN
3944: 6c65: !             GOSUB GET.STAFF.NO.02                                    ! AJC
3945: 6c65: ! AJC 1.4     GOSUB GET.RECEIPT.NAME.02                                ! AJC
3946: 6c65:               GOSUB GET.GROUP.CODE.02                                  ! AJC 1.4
3947: 6c7a:            ENDIF                                                       \
3948: 6c7a:            ELSE                                                        \
3949: 6c82:            IF FUNCTION.KEY% = END.KEY% THEN                            \ AJC 1.4
3950: 6c9a:            BEGIN                                                       ! AJC 1.4
3951: 6c9a:              TILL.PTR% = MAX.TILL.PTR%                                 ! AJC 1.4
3952: 6cb0:              GOSUB GET.TILL.MODEL.02                                   ! AJC 1.4
3953: 6cc4:            ENDIF                                                       \ AJC 1.4
3954: 6cc4:            ELSE                                                        \ AJC 1.4
3955: 6ccc:            IF FUNCTION.KEY% = ENTER.KEY% THEN                          \
3956: 6ce4:            BEGIN
3957: 6ce4:               GOSUB CHECK.FIELDS.02
3958: 6cf6:            ENDIF
3959: 6cfe:         ENDIF
3960: 6d06: 
3961: 6d06:         RETURN
3962: 6d16: 
3963: 6d16: \******************************************************************************
3964: 6d16: \***                                                                          *
3965: 6d16: \***    SUBROUTINE      :       GET.GROUP.CODE.02                   ! AJC 1.4 *
3966: 6d16: \***                                                                          *
3967: 6d16: \******************************************************************************
3968: 6d16: \***                                                                          *
3969: 6d16: \***    Input routine for the Behaviour Group on Add an operator screen       *
3970: 6d16: \***                                                                          *
3971: 6d16: \******************************************************************************
3972: 6d16: 
3973: 6d16:         GET.GROUP.CODE.02:                                            ! AJC 1.4
3974: 6d26: 
3975: 6d26:         CURSOR.POSITION% = S2.GROUP.CODE%                             ! AJC 1.4
3976: 6d3c:         CALL PUT.CURSOR.IN.FIELD                                       ! 1.5 RC
3977: 6d49: 
3978: 6d49:         EXIT.KEY.PRESSED(2)  = FALSE                                  ! AJC 1.4
3979: 6d71:         VALID.GROUP.CODE.FOUND = FALSE                                ! AJC 1.4
3980: 6d87: 
3981: 6d87:         CALL GET.INPUT                                                 ! 1.5 RC
3982: 6d94: 
3983: 6d94:         WHILE NOT (EXIT.KEY.PRESSED(2) OR                            \! AJC 1.4
3984: 6d9f:                   VALID.GROUP.CODE.FOUND)                             ! AJC 1.4
3985: 6d9f: 
3986: 6d9f:               GROUP.CODE$ = RIGHT$(STRING$(2,"0") +                  \  AJC 1.4
3987: 6e06:                                    STR$(VAL(F03.RETURNED.STRING$)),2) ! AJC 1.4
3988: 6e06: 
3989: 6e06:               IF NOT (FUNCTION.KEY% = ENTER.KEY% OR                  \! AJC 1.4
3990: 6ebe:                  FUNCTION.KEY% = END.KEY% OR                         \! AJC 1.4
3991: 6ebe:                  FUNCTION.KEY% = TAB.KEY% OR                         \! AJC 1.4
3992: 6ebe:                  FUNCTION.KEY% = BTAB.KEY% OR                        \! AJC 1.4
3993: 6ebe:                  FUNCTION.KEY% = HOME.KEY% OR                        \! AJC 1.4
3994: 6ebe:                  FUNCTION.KEY% = HELP.KEY% OR                        \! AJC 1.4
3995: 6ebe:                  FUNCTION.KEY% = QUIT.KEY% OR                        \! AJC 1.4
3996: 6ebe:                  FUNCTION.KEY% = ESC.KEY%) THEN                      \! AJC 1.4
3997: 6ebe:               BEGIN                                                   ! AJC 1.4
3998: 6ebe:                  DISPLAY.MESSAGE.NUMBER% = 1                          ! AJC 1.4
3999: 6ecf:                  CALL DISPLAY.MESSAGE                                  ! 1.5 RC
4000: 6edc:                  CALL RESUME.INPUT                                     ! 1.5 RC
4001: 6eec:               ENDIF                                                  \! AJC 1.4
4002: 6eec:               ELSE                                                   \! AJC 1.4
4003: 6ef4:               IF FUNCTION.KEY% = QUIT.KEY% THEN                      \! AJC 1.4
4004: 6f0c:               BEGIN                                                   ! AJC 1.4
4005: 6f0c:                  CALL GET.QUIT.CONFIRM                                 ! 1.5 RC
4006: 6f1c:               ENDIF                                                  \! AJC 1.4
4007: 6f1c:               ELSE                                                   \! AJC 1.4
4008: 6f24:               IF FUNCTION.KEY% = ESC.KEY% THEN                       \! AJC 1.4
4009: 6f3c:               BEGIN                                                   ! AJC 1.4
4010: 6f3c:                  CHAIN.TO.PROG$ = "PSB50"                             ! AJC 1.4
4011: 6f53:                  PSBCHN.MENCON  = "000000"                            ! AJC 1.4
4012: 6f6a:                  CALL CHAIN.TO.CALLER                                  ! 1.5 RC
4013: 6f7a:               ENDIF                                                  \! AJC 1.4
4014: 6f7a:               ELSE                                                   \! AJC 1.4
4015: 6f82:               IF FUNCTION.KEY% = HELP.KEY% THEN                      \! AJC 1.4
4016: 6f9a:               BEGIN                                                   ! AJC 1.4
4017: 6f9a:                  CALL SCREEN.HELP(2)                                  ! AJC 1.4
4018: 6fb8:                  CALL RESTORE.FIELDS.02                                ! 1.5 RC
4019: 6fc4: 
4020: 6fc4:                  CURSOR.POSITION% = S2.GROUP.CODE%                    ! AJC 1.4
4021: 6fda:                  CALL PUT.CURSOR.IN.FIELD                              ! 1.5 RC
4022: 6fe7: 
4023: 6fe7:                  CALL GET.INPUT                                        ! 1.5 RC
4024: 6ff7:               ENDIF                                                  \! AJC 1.4
4025: 6ff7:               ELSE                                                   \! AJC 1.4
4026: 6fff:               BEGIN                                                   ! AJC 1.4
4027: 6fff: 
4028: 6fff:                  IF VALID.GROUP.CODE THEN                            \! AJC 1.4
4029: 700f:                     VALID.GROUP.CODE.FOUND = TRUE                    \! AJC 1.4
4030: 7027:                  ELSE                                                \! AJC 1.4
4031: 702f:                  BEGIN                                                ! AJC 1.4
4032: 702f:                     ! B221 Free format                                ! AJC 1.4
4033: 702f:                     DISPLAY.MESSAGE.NUMBER% = 221                     ! AJC 1.4
4034: 7040:                     DISPLAY.MESSAGE.TEXT$ =                          \! AJC 1.4
4035: 7057:                     "GROUP CODE MUST BE ENTERED  "                    ! AJC 1.4
4036: 7057:                     CALL DISPLAY.MESSAGE                               ! 1.5 RC
4037: 7064:                     CALL RESUME.INPUT                                  ! 1.5 RC
4038: 7071:                  ENDIF                                                ! AJC 1.4
4039: 7079:               ENDIF                                                   ! AJC 1.4
4040: 7081:         WEND                                                          ! AJC 1.4
4041: 70a8: 
4042: 70a8:         IF VALID.GROUP.CODE.FOUND AND                                \! AJC 1.4
4043: 70d3:            NOT EXIT.KEY.PRESSED(2) THEN                              \! AJC 1.4
4044: 70d3:         BEGIN                                                         ! AJC 1.4
4045: 70d3:            CALL CLEAR.MESSAGE                                          ! 1.5 RC
4046: 70e0: 
4047: 70e0:            STRING.DATA$ = GROUP.CODE$                                 ! AJC 1.4
4048: 70fe:            CALL SET.FIELD                                              ! 1.5 RC
4049: 710b: 
4050: 710b:            IF FUNCTION.KEY% = TAB.KEY% OR                             \ AJC 1.4
4051: 713f:               FUNCTION.KEY% = END.KEY% THEN                           \ AJC 1.4
4052: 713f:            BEGIN                                                      ! AJC 1.4
4053: 713f:              GOSUB GET.EMPLOYEE.FLG.02                                ! AJC 1.4
4054: 7154:            ENDIF                                                     \! AJC 1.4
4055: 7154:            ELSE                                                      \! AJC 1.4
4056: 715c:            IF FUNCTION.KEY% = HOME.KEY% THEN                         \! AJC 1.4
4057: 7174:            BEGIN                                                      ! AJC 1.4
4058: 7174:               GOSUB GET.OPERATOR.ID.02                                ! AJC 1.4
4059: 7188:            ENDIF                                                     \! AJC 1.4
4060: 7188:            ELSE                                                      \! AJC 1.4
4061: 7190:            IF FUNCTION.KEY% = BTAB.KEY% THEN                         \! AJC 1.4
4062: 71a8:            BEGIN                                                      ! AJC 1.4
4063: 71a8:               GOSUB GET.RECEIPT.NAME.02                               ! AJC 1.4
4064: 71bc:            ENDIF                                                     \! AJC 1.4
4065: 71bc:            ELSE                                                      \! AJC 1.4
4066: 71c4:            IF FUNCTION.KEY% = ENTER.KEY% THEN                        \! AJC 1.4
4067: 71dc:            BEGIN                                                      ! AJC 1.4
4068: 71dc:               GOSUB CHECK.FIELDS.02                                   ! AJC 1.4
4069: 71ee:            ENDIF                                                      ! AJC 1.4
4070: 71f6:         ENDIF                                                         ! AJC 1.4
4071: 71fe: 
4072: 71fe:         RETURN
4073: 720e: 
4074: 720e: \******************************************************************************
4075: 720e: \***                                                                          *
4076: 720e: \***    SUBROUTINE      :       GET.TILL.MODEL.02                             *
4077: 720e: \***                                                                          *
4078: 720e: \******************************************************************************
4079: 720e: \***                                                                          *
4080: 720e: \***    Input routine for the till model flags on the add an operator screen  *
4081: 720e: \***                                                                          *
4082: 720e: \******************************************************************************
4083: 720e: 
4084: 720e:         GET.TILL.MODEL.02:
4085: 721e: 
4086: 721e:         CURSOR.POSITION% = S2.TILL.MODEL.FLAG%(TILL.PTR%)
4087: 7245:         CALL PUT.CURSOR.IN.FIELD                                       ! 1.5 RC
4088: 7252: 
4089: 7252:         EXIT.KEY.PRESSED(2)    = FALSE
4090: 727a:         VALID.MODEL.FLAG.FOUND = FALSE
4091: 7290: 
4092: 7290:         CALL GET.INPUT                                                 ! 1.5 RC
4093: 729d: 
4094: 729d:         WHILE NOT (EXIT.KEY.PRESSED(2) OR                              \
4095: 72a8:                   VALID.MODEL.FLAG.FOUND)
4096: 72a8: 
4097: 72a8:               MODEL.FLAG$ = UCASE$(F03.RETURNED.STRING$)
4098: 72cb: 
4099: 72cb:               IF NOT (FUNCTION.KEY% = ENTER.KEY% OR                    \
4100: 7383:                  FUNCTION.KEY% = END.KEY% OR                           \
4101: 7383:                  FUNCTION.KEY% = TAB.KEY% OR                           \
4102: 7383:                  FUNCTION.KEY% = BTAB.KEY% OR                          \
4103: 7383:                  FUNCTION.KEY% = HOME.KEY% OR                          \
4104: 7383:                  FUNCTION.KEY% = HELP.KEY% OR                          \
4105: 7383:                  FUNCTION.KEY% = QUIT.KEY% OR                          \
4106: 7383:                  FUNCTION.KEY% = ESC.KEY%) THEN                        \
4107: 7383:               BEGIN
4108: 7383:                  DISPLAY.MESSAGE.NUMBER% = 1
4109: 7394:                  CALL DISPLAY.MESSAGE                                  ! 1.5 RC
4110: 73a1:                  CALL RESUME.INPUT                                     ! 1.5 RC
4111: 73b1:               ENDIF                                                    \
4112: 73b1:               ELSE                                                     \
4113: 73b9:               IF FUNCTION.KEY% = QUIT.KEY% THEN                        \
4114: 73d1:               BEGIN
4115: 73d1:                  CALL GET.QUIT.CONFIRM                                 ! 1.5 RC
4116: 73e1:               ENDIF                                                    \
4117: 73e1:               ELSE                                                     \
4118: 73e9:               IF FUNCTION.KEY% = ESC.KEY% THEN                         \
4119: 7401:               BEGIN
4120: 7401:                  CHAIN.TO.PROG$ = "PSB50"
4121: 7418:                  PSBCHN.MENCON  = "000000"
4122: 742f:                  CALL CHAIN.TO.CALLER                                  ! 1.5 RC
4123: 743f:               ENDIF                                                    \
4124: 743f:               ELSE                                                     \
4125: 7447:               IF FUNCTION.KEY% = HELP.KEY% THEN                        \
4126: 7462:               BEGIN
4127: 7462:                  CALL SCREEN.HELP(2)
4128: 7480:                  CALL RESTORE.FIELDS.02                                ! 1.5 RC
4129: 748c: 
4130: 748c:                  CURSOR.POSITION% = S2.TILL.MODEL.FLAG%(TILL.PTR%)
4131: 74b3:                  CALL PUT.CURSOR.IN.FIELD                              ! 1.5 RC
4132: 74c0: 
4133: 74c0:                  STRING.DATA$ = MODEL.FLAG$
4134: 74de:                  CALL SET.FIELD                                        ! 1.5 RC
4135: 74eb: 
4136: 74eb:                  CALL GET.INPUT                                        ! 1.5 RC
4137: 74fa:               ENDIF                                                    \
4138: 74fa:               ELSE                                                     \
4139: 7502:               BEGIN
4140: 7502:                  IF VALID.MODEL.FLAG THEN                              \
4141: 7512:                     VALID.MODEL.FLAG.FOUND = TRUE                      \
4142: 752a:                  ELSE                                                  \
4143: 7532:                  BEGIN
4144: 7532:                     ! B359 Invalid model flag
4145: 7532:                     DISPLAY.MESSAGE.NUMBER% = 359
4146: 7543:                     CALL DISPLAY.MESSAGE                               ! 1.5 RC
4147: 7550:                     CALL RESUME.INPUT                                  ! 1.5 RC
4148: 755d:                  ENDIF
4149: 7565:               ENDIF
4150: 756d:         WEND
4151: 7594: 
4152: 7594:         IF VALID.MODEL.FLAG.FOUND AND                                  \
4153: 75bf:            NOT EXIT.KEY.PRESSED(2) THEN                                \
4154: 75bf:         BEGIN
4155: 75bf:            CALL CLEAR.MESSAGE                                          ! 1.5 RC
4156: 75cc: 
4157: 75cc:            TILL.MODEL.FLAG$(TILL.PTR%) = MODEL.FLAG$
4158: 75fb: 
4159: 75fb:            STRING.DATA$ = MODEL.FLAG$
4160: 7619:            CALL SET.FIELD                                              ! 1.5 RC
4161: 7626: 
4162: 7626:            IF FUNCTION.KEY% = TAB.KEY% THEN                            \
4163: 763e:            BEGIN
4164: 763e:               IF TILL.PTR% = MAX.TILL.PTR% THEN                        \
4165: 7656:               BEGIN
4166: 7656:                  CTLR.PTR% = 1
4167: 7667:                  GOSUB GET.CTLR.MODEL.02
4168: 767b:               ENDIF                                                    \
4169: 767b:               ELSE                                                     \
4170: 7683:               BEGIN
4171: 7683:                  TILL.PTR% = TILL.PTR% + 1
4172: 7692:                  GOTO GET.TILL.MODEL.02
4173: 769d:               ENDIF
4174: 76a8:            ENDIF                                                       \
4175: 76a8:            ELSE                                                        \
4176: 76b0:            IF FUNCTION.KEY% = HOME.KEY% THEN                           \
4177: 76c8:            BEGIN
4178: 76c8:               IF TILL.PTR% = 1 THEN                                    \
4179: 76da:               BEGIN
4180: 76da:                  GOSUB GET.OPERATOR.ID.02
4181: 76ee:               ENDIF                                                    \
4182: 76ee:               ELSE                                                     \
4183: 76f6:               BEGIN
4184: 76f6:                  TILL.PTR% = 1
4185: 7707:                  GOTO GET.TILL.MODEL.02
4186: 7712:               ENDIF
4187: 771d:            ENDIF                                                       \
4188: 771d:            ELSE                                                        \
4189: 7725:            IF FUNCTION.KEY% = BTAB.KEY% THEN                           \
4190: 773d:            BEGIN
4191: 773d:               IF TILL.PTR% = 1 THEN                                    \
4192: 774f:               BEGIN
4193: 774f:                  GOSUB GET.EMPLOYEE.FLG.02
4194: 7763:               ENDIF                                                    \
4195: 7763:               ELSE                                                     \
4196: 776b:               BEGIN
4197: 776b:                  TILL.PTR% = TILL.PTR% - 1
4198: 777a:                  GOTO GET.TILL.MODEL.02
4199: 7785:               ENDIF
4200: 7790:            ENDIF                                                       \
4201: 7790:            ELSE                                                        \
4202: 7798:            IF FUNCTION.KEY% = END.KEY% THEN                            \
4203: 77b3:            BEGIN
4204: 77b3:               IF TILL.PTR% = MAX.TILL.PTR% THEN                        \
4205: 77cb:               BEGIN
4206: 77cb:                  CTLR.PTR% = MAX.CTLR.PTR%
4207: 77e1:                  GOSUB GET.CTLR.MODEL.02
4208: 77f5:               ENDIF                                                    \
4209: 77f5:               ELSE                                                     \
4210: 77fd:               BEGIN
4211: 77fd:                  TILL.PTR% = MAX.TILL.PTR%
4212: 7813:                  GOTO GET.TILL.MODEL.02
4213: 781e:               ENDIF
4214: 7828:            ENDIF                                                       \
4215: 7828:            ELSE                                                        \
4216: 7830:            IF FUNCTION.KEY% = ENTER.KEY% THEN                          \
4217: 7848:            BEGIN
4218: 7848:               GOSUB CHECK.FIELDS.02
4219: 785a:            ENDIF
4220: 7862:         ENDIF
4221: 786a: 
4222: 786a:         RETURN
4223: 787a: 
4224: 787a: \******************************************************************************
4225: 787a: \***                                                                          *
4226: 787a: \***    SUBROUTINE      :       GET.CTLR.MODEL.02                             *
4227: 787a: \***                                                                          *
4228: 787a: \******************************************************************************
4229: 787a: \***                                                                          *
4230: 787a: \***    Input routine for the ctlr model flags on the add an operator screen  *
4231: 787a: \***                                                                          *
4232: 787a: \******************************************************************************
4233: 787a: 
4234: 787a:         GET.CTLR.MODEL.02:
4235: 788a: 
4236: 788a:         CURSOR.POSITION% = S2.CTLR.MODEL.FLAG%(CTLR.PTR%)
4237: 78b1:         CALL PUT.CURSOR.IN.FIELD                                       ! 1.5 RC
4238: 78be: 
4239: 78be:         EXIT.KEY.PRESSED(2)    = FALSE
4240: 78e6:         VALID.MODEL.FLAG.FOUND = FALSE
4241: 78fc: 
4242: 78fc:         CALL GET.INPUT                                                 ! 1.5 RC
4243: 7909: 
4244: 7909:         WHILE NOT (EXIT.KEY.PRESSED(2) OR                              \
4245: 7914:                   VALID.MODEL.FLAG.FOUND)
4246: 7914: 
4247: 7914:               MODEL.FLAG$ = UCASE$(F03.RETURNED.STRING$)
4248: 7937: 
4249: 7937:               IF NOT (FUNCTION.KEY% = ENTER.KEY% OR                    \
4250: 79ef:                  FUNCTION.KEY% = END.KEY% OR                           \
4251: 79ef:                  FUNCTION.KEY% = TAB.KEY% OR                           \
4252: 79ef:                  FUNCTION.KEY% = BTAB.KEY% OR                          \
4253: 79ef:                  FUNCTION.KEY% = HOME.KEY% OR                          \
4254: 79ef:                  FUNCTION.KEY% = HELP.KEY% OR                          \
4255: 79ef:                  FUNCTION.KEY% = QUIT.KEY% OR                          \
4256: 79ef:                  FUNCTION.KEY% = ESC.KEY%) THEN                        \
4257: 79ef:               BEGIN
4258: 79ef:                  DISPLAY.MESSAGE.NUMBER% = 1
4259: 7a00:                  CALL DISPLAY.MESSAGE                                  ! 1.5 RC
4260: 7a0d:                  CALL RESUME.INPUT                                     ! 1.5 RC
4261: 7a1d:               ENDIF                                                    \
4262: 7a1d:               ELSE                                                     \
4263: 7a25:               IF FUNCTION.KEY% = QUIT.KEY% THEN                        \
4264: 7a3d:               BEGIN
4265: 7a3d:                  CALL GET.QUIT.CONFIRM                                 ! 1.5 RC
4266: 7a4d:               ENDIF                                                    \
4267: 7a4d:               ELSE                                                     \
4268: 7a55:               IF FUNCTION.KEY% = ESC.KEY% THEN                         \
4269: 7a6d:               BEGIN
4270: 7a6d:                  CHAIN.TO.PROG$ = "PSB50"
4271: 7a84:                  PSBCHN.MENCON  = "000000"
4272: 7a9b:                  CALL CHAIN.TO.CALLER                                  ! 1.5 RC
4273: 7aab:               ENDIF                                                    \
4274: 7aab:               ELSE                                                     \
4275: 7ab3:               IF FUNCTION.KEY% = HELP.KEY% THEN                        \
4276: 7ace:               BEGIN
4277: 7ace:                  CALL SCREEN.HELP(2)
4278: 7aec:                  CALL RESTORE.FIELDS.02                                ! 1.5 RC
4279: 7af8: 
4280: 7af8:                  CURSOR.POSITION% = S2.CTLR.MODEL.FLAG%(CTLR.PTR%)
4281: 7b1f:                  CALL PUT.CURSOR.IN.FIELD                              ! 1.5 RC
4282: 7b2c: 
4283: 7b2c:                  STRING.DATA$ = MODEL.FLAG$
4284: 7b4a:                  CALL SET.FIELD                                        ! 1.5 RC
4285: 7b57: 
4286: 7b57:                  CALL GET.INPUT                                        ! 1.5 RC
4287: 7b66:               ENDIF                                                    \
4288: 7b66:               ELSE                                                     \
4289: 7b6e:               BEGIN
4290: 7b6e:                  IF VALID.MODEL.FLAG THEN                              \
4291: 7b7e:                     VALID.MODEL.FLAG.FOUND = TRUE                      \
4292: 7b96:                  ELSE                                                  \
4293: 7b9e:                  BEGIN
4294: 7b9e:                     ! B359 Invalid model flag
4295: 7b9e:                     DISPLAY.MESSAGE.NUMBER% = 359
4296: 7baf:                     CALL DISPLAY.MESSAGE                               ! 1.5 RC
4297: 7bbc:                     CALL RESUME.INPUT                                  ! 1.5 RC
4298: 7bc9:                  ENDIF
4299: 7bd1:               ENDIF
4300: 7bd9:         WEND
4301: 7c00: 
4302: 7c00:         IF VALID.MODEL.FLAG.FOUND AND                                  \
4303: 7c2b:            NOT EXIT.KEY.PRESSED(2) THEN                                \
4304: 7c2b:         BEGIN
4305: 7c2b:            CALL CLEAR.MESSAGE                                          ! 1.5 RC
4306: 7c38: 
4307: 7c38:            CTLR.MODEL.FLAG$(CTLR.PTR%) = MODEL.FLAG$
4308: 7c67: 
4309: 7c67:            STRING.DATA$ = MODEL.FLAG$
4310: 7c85:            CALL SET.FIELD                                              ! 1.5 RC
4311: 7c92: 
4312: 7c92:            IF FUNCTION.KEY% = TAB.KEY% THEN                            \
4313: 7caa:            BEGIN
4314: 7caa:               IF CTLR.PTR% = MAX.CTLR.PTR% THEN                        \
4315: 7cc2:               BEGIN
4316: 7cc2:                  ! B001 Invalid key pressed
4317: 7cc2:                  DISPLAY.MESSAGE.NUMBER% = 1
4318: 7cd3:                  CALL DISPLAY.MESSAGE                                  ! 1.5 RC
4319: 7ce0:                  GOTO GET.CTLR.MODEL.02
4320: 7ced:               ENDIF                                                    \
4321: 7ced:               ELSE                                                     \
4322: 7cf5:               BEGIN
4323: 7cf5:                  CTLR.PTR% = CTLR.PTR% + 1
4324: 7d04:                  GOTO GET.CTLR.MODEL.02
4325: 7d0f:               ENDIF
4326: 7d1a:            ENDIF                                                       \
4327: 7d1a:            ELSE                                                        \
4328: 7d22:            IF FUNCTION.KEY% = HOME.KEY% THEN                           \
4329: 7d3a:            BEGIN
4330: 7d3a:               IF CTLR.PTR% = 1 THEN                                    \
4331: 7d4c:               BEGIN
4332: 7d4c:                  TILL.PTR% = 1
4333: 7d5d:                  GOSUB GET.TILL.MODEL.02
4334: 7d71:               ENDIF                                                    \
4335: 7d71:               ELSE                                                     \
4336: 7d79:               BEGIN
4337: 7d79:                  CTLR.PTR% = 1
4338: 7d8a:                  GOTO GET.CTLR.MODEL.02
4339: 7d95:               ENDIF
4340: 7da0:            ENDIF                                                       \
4341: 7da0:            ELSE                                                        \
4342: 7da8:            IF FUNCTION.KEY% = BTAB.KEY% THEN                           \
4343: 7dc0:            BEGIN
4344: 7dc0:               IF CTLR.PTR% = 1 THEN                                    \
4345: 7dd2:               BEGIN
4346: 7dd2:                  TILL.PTR% = MAX.TILL.PTR%
4347: 7de8:                  GOSUB GET.TILL.MODEL.02
4348: 7dfc:               ENDIF                                                    \
4349: 7dfc:               ELSE                                                     \
4350: 7e04:               BEGIN
4351: 7e04:                  CTLR.PTR% = CTLR.PTR% - 1
4352: 7e13:                  GOTO GET.CTLR.MODEL.02
4353: 7e1e:               ENDIF
4354: 7e29:            ENDIF                                                       \
4355: 7e29:            ELSE                                                        \
4356: 7e31:            IF FUNCTION.KEY% = END.KEY% THEN                            \
4357: 7e4c:            BEGIN
4358: 7e4c:               IF CTLR.PTR% = MAX.CTLR.PTR% THEN                        \
4359: 7e64:               BEGIN
4360: 7e64:                  ! B001 Invalid key pressed
4361: 7e64:                  DISPLAY.MESSAGE.NUMBER% = 1
4362: 7e75:                  CALL DISPLAY.MESSAGE                                  ! 1.5 RC
4363: 7e82:                  GOTO GET.CTLR.MODEL.02
4364: 7e8f:               ENDIF                                                    \
4365: 7e8f:               ELSE                                                     \
4366: 7e97:               BEGIN
4367: 7e97:                  CTLR.PTR% = MAX.CTLR.PTR%
4368: 7ead:                  GOTO GET.CTLR.MODEL.02
4369: 7eb8:               ENDIF
4370: 7ec2:            ENDIF                                                       \
4371: 7ec2:            ELSE                                                        \
4372: 7eca:            IF FUNCTION.KEY% = ENTER.KEY% THEN                          \
4373: 7ee2:            BEGIN
4374: 7ee2:               GOSUB CHECK.FIELDS.02
4375: 7ef4:            ENDIF
4376: 7efc:         ENDIF
4377: 7f04: 
4378: 7f04:         RETURN
4379: 7f14: 
4380: 7f14: \******************************************************************************
4381: 7f14: \***                                                                          *
4382: 7f14: \***    SUBROUTINE      :       CHECK.FIELDS.02                               *
4383: 7f14: \***                                                                          *
4384: 7f14: \******************************************************************************
4385: 7f14: \***                                                                          *
4386: 7f14: \***    Validate all input fields for the add operator screen                 *
4387: 7f14: \***                                                                          *
4388: 7f14: \******************************************************************************
4389: 7f14: 
4390: 7f14:         CHECK.FIELDS.02:
4391: 7f24: 
4392: 7f24:         IF NOT VALID.OPERATOR.ID THEN                                  \
4393: 7f34:         BEGIN
4394: 7f34:            ! B058 Invalid operator ID
4395: 7f34:            DISPLAY.MESSAGE.NUMBER% = 58
4396: 7f45:            CALL DISPLAY.MESSAGE                                        ! 1.5 RC
4397: 7f52: 
4398: 7f52:            GOSUB GET.OPERATOR.ID.02
4399: 7f64: 
4400: 7f64:            GOTO CHECK.FIELDS.02.FAILED
4401: 7f6f:         ENDIF
4402: 7f77: 
4403: 7f77:         IF NOT VALID.NAME THEN                                         \
4404: 7f87:         BEGIN
4405: 7f87:            ! B358 Invalid name
4406: 7f87:            DISPLAY.MESSAGE.NUMBER% = 358
4407: 7f98:            CALL DISPLAY.MESSAGE                                        ! 1.5 RC
4408: 7fa5: 
4409: 7fa5:            GOSUB GET.NAME.02
4410: 7fb7: 
4411: 7fb7:            GOTO CHECK.FIELDS.02.FAILED
4412: 7fc2:         ENDIF
4413: 7fca: 
4414: 7fca:         IF NOT VALID.PASSWORD THEN                                     \
4415: 7fda:         BEGIN
4416: 7fda:            ! B332 Invalid password
4417: 7fda:            DISPLAY.MESSAGE.NUMBER% = 332
4418: 7feb:            CALL DISPLAY.MESSAGE                                        ! 1.5 RC
4419: 7ff8: 
4420: 7ff8:            GOSUB GET.PASSWORD.02
4421: 800a: 
4422: 800a:            GOTO CHECK.FIELDS.02.FAILED
4423: 8015:         ENDIF
4424: 801d: 
4425: 801d:         IF NOT VALID.STAFF.NO(TRUE) THEN                               \ 1.9 NM
4426: 8038:         BEGIN
4427: 8038:            ! B332 Free format
4428: 8038:            DISPLAY.MESSAGE.NUMBER% = 221
4429: 8049: 
4430: 8049:            !Commented as part of Core 2 Release                        ! 1.9 NM
4431: 8049:            !DISPLAY.MESSAGE.TEXT$ =                                    \ 1.9 NM
4432: 8049:            !  "STAFF NUMBER MUST BE 0 OR GREATER"                      ! 1.9 NM
4433: 8049: 
4434: 8049:            CALL DISPLAY.MESSAGE                                        ! 1.5 RC
4435: 8056: 
4436: 8056:            GOSUB GET.STAFF.NO.02
4437: 8068: 
4438: 8068:            GOTO CHECK.FIELDS.02.FAILED
4439: 8073:         ENDIF
4440: 807b: 
4441: 807b:         IF NOT VALID.BIRTH.DATE THEN \                                 ! 1.6 RC
4442: 808b:         BEGIN                                                          ! 1.6 RC
4443: 808b: !          DISPLAY.MESSAGE.NUMBER% set within VALID.BIRTH.DATE         ! 1.6 RC
4444: 808b:            CALL DISPLAY.MESSAGE                                        ! 1.6 RC
4445: 8098:            GOSUB GET.BIRTH.DATE.02                                     ! 1.6 RC
4446: 80aa:            GOTO CHECK.FIELDS.02.FAILED                                 ! 1.6 RC
4447: 80b5:         ENDIF                                                          ! 1.6 RC
4448: 80bd: 
4449: 80bd:         IF NOT VALID.RECEIPT.NAME THEN                                 \ ! AJC
4450: 80cd:         BEGIN                                                            ! AJC
4451: 80cd:            ! B332 Free format                                            ! AJC
4452: 80cd:            DISPLAY.MESSAGE.NUMBER% = 221                                 ! AJC
4453: 80de:            DISPLAY.MESSAGE.TEXT$ =                                     \ ! AJC
4454: 80f5:              "NAME ON RECEIPT MUST BE ENTERED  "                         ! AJC
4455: 80f5:            CALL DISPLAY.MESSAGE                                        ! 1.5 RC
4456: 8102:                                                                          ! AJC
4457: 8102:            GOSUB GET.RECEIPT.NAME.02                                     ! AJC
4458: 8114:                                                                          ! AJC
4459: 8114:            GOTO CHECK.FIELDS.02.FAILED                                   ! AJC
4460: 811f:         ENDIF                                                            ! AJC
4461: 8127: 
4462: 8127:         IF NOT VALID.GROUP.CODE THEN                                   \ ! AJC 1.4
4463: 8137:         BEGIN                                                            ! AJC 1.4
4464: 8137:            ! B332 Free format                                            ! AJC 1.4
4465: 8137:            DISPLAY.MESSAGE.NUMBER% = 221                                 ! AJC 1.4
4466: 8148:            DISPLAY.MESSAGE.TEXT$ =                                     \ ! AJC 1.4
4467: 815f:              "GROUP CODE MUST BE ENTERED  "                              ! AJC 1.4
4468: 815f:            CALL DISPLAY.MESSAGE                                        ! 1.5 RC
4469: 816c:                                                                          ! AJC 1.4
4470: 816c:            GOSUB GET.GROUP.CODE.02                                       ! AJC 1.4
4471: 817e:                                                                          ! AJC 1.4
4472: 817e:            GOTO CHECK.FIELDS.02.FAILED                                   ! AJC 1.4
4473: 8189:         ENDIF                                                            ! AJC 1.4
4474: 8191: 
4475: 8191:         IF NOT VALID.EMPLOYEE.FLG THEN                                  \
4476: 81a1:         BEGIN
4477: 81a1:            ! B064 YOU MUST ONLY TYPE "N" OR "Y"
4478: 81a1:            DISPLAY.MESSAGE.NUMBER% = 64
4479: 81b2:            CALL DISPLAY.MESSAGE                                        ! 1.5 RC
4480: 81bf: 
4481: 81bf:            GOSUB GET.EMPLOYEE.FLG.02
4482: 81d1: 
4483: 81d1:            GOTO CHECK.FIELDS.02.FAILED
4484: 81dc:         ENDIF
4485: 81e4: 
4486: 81e4:         I% = 1
4487: 81f5: 
4488: 81f5:         WHILE I% <= MAX.TILL.PTR%
4489: 8200: 
4490: 8200:               MODEL.FLAG$ = TILL.MODEL.FLAG$(I%)
4491: 822f: 
4492: 822f:               IF NOT VALID.MODEL.FLAG THEN                             \
4493: 823f:               BEGIN
4494: 823f:                  ! B359 Invalid model flag
4495: 823f:                  DISPLAY.MESSAGE.NUMBER% = 359
4496: 8250:                  CALL DISPLAY.MESSAGE                                  ! 1.5 RC
4497: 825d: 
4498: 825d:                  TILL.PTR% = I%
4499: 8273:                  GOSUB GET.TILL.MODEL.02
4500: 8285: 
4501: 8285:                  GOTO CHECK.FIELDS.02.FAILED
4502: 8290:               ENDIF
4503: 8298: 
4504: 8298:               I% = I% + 1
4505: 82a7: 
4506: 82a7:         WEND
4507: 82c2: 
4508: 82c2:         I% = 1
4509: 82d3: 
4510: 82d3:         WHILE I% <= MAX.CTLR.PTR%
4511: 82de: 
4512: 82de:               MODEL.FLAG$ = CTLR.MODEL.FLAG$(I%)
4513: 830d: 
4514: 830d:               IF NOT VALID.MODEL.FLAG THEN                             \
4515: 831d:               BEGIN
4516: 831d:                  ! B359 Invalid model flag
4517: 831d:                  DISPLAY.MESSAGE.NUMBER% = 359
4518: 832e:                  CALL DISPLAY.MESSAGE                                  ! 1.5 RC
4519: 833b: 
4520: 833b:                  CTLR.PTR% = I%
4521: 8351:                  GOSUB GET.CTLR.MODEL.02
4522: 8363: 
4523: 8363:                  GOTO CHECK.FIELDS.02.FAILED
4524: 836d:               ENDIF
4525: 8375: 
4526: 8375:               I% = I% + 1
4527: 8384: 
4528: 8384:         WEND
4529: 839f: 
4530: 839f:         GOSUB ADD.AN.OPERATOR
4531: 83b1: 
4532: 83b1:         CHECK.FIELDS.02.FAILED:
4533: 83c1: 
4534: 83c1:         RETURN
4535: 83d1: 
4536: 83d1: \******************************************************************************
4537: 83d1: \***                                                                          *
4538: 83d1: \***    SUBROUTINE      :       ADD.AN.OPERATOR                               *
4539: 83d1: \***                                                                          *
4540: 83d1: \******************************************************************************
4541: 83d1: \***                                                                          *
4542: 83d1: \***    Add an operator to the authorisation files                            *
4543: 83d1: \***                                                                          *
4544: 83d1: \******************************************************************************
4545: 83d1: 
4546: 83d1:         ADD.AN.OPERATOR:
4547: 83e1: 
4548: 83e1:         CSOUF.OPERATION$ = "ADD"
4549: 83f8: 
4550: 83f8:         CALL REVEAL.CONFIRM.MESSAGE                                    ! 1.5 RC
4551: 8405: 
4552: 8405:         CALL GET.CONFIRM                                               ! 1.5 RC
4553: 8412: 
4554: 8412:         CALL HIDE.CONFIRM.MESSAGE                                      ! 1.5 RC
4555: 841f: 
4556: 841f:         IF CONFIRM$ = "Y" THEN                                         \
4557: 843d:         BEGIN
4558: 843d:            CALL WAIT.MESSAGE                                           ! 1.5 RC
4559: 844a:            GOSUB UPDATE.AUTH.RECORDS
4560: 845c:         ENDIF
4561: 8464: 
4562: 8464:         RETURN
4563: 8474: 
4564: 8474: 
4565: 8474: \******************************************************************************
4566: 8474: \***                                                                          *
4567: 8474: \***    SUBROUTINE      :       UPDATE.AUTH.RECORDS                           *
4568: 8474: \***                                                                          *
4569: 8474: \******************************************************************************
4570: 8474: \***                                                                          *
4571: 8474: \***    Write authorisation records to the EALAUTH and ADXCSOUF files         *
4572: 8474: \***                                                                          *
4573: 8474: \******************************************************************************
4574: 8474: 
4575: 8474:         UPDATE.AUTH.RECORDS:
4576: 8484: 
4577: 8484:         AF.OPERATOR.NO$      = PACK$(RIGHT$(STRING$(8,"0") +           \
4578: 84d6:                                OPERATOR.ID$,8))
4579: 84d6: 
4580: 84d6:         AF.PASSWORD$         = PACK$(RIGHT$(STRING$(8,"0") +           \
4581: 8528:                                OPERATOR.PASSWORD$,8))
4582: 8528: 
4583: 8528:         AF.OPERATOR.NAME$    = OPERATOR.NAME$
4584: 8546: 
4585: 8546:         AF.RECEIPT.NAME$     = RECEIPT.NAME$                           ! AJC
4586: 8564: 
4587: 8564: !       AF.RESERVED$         = PACK$(STRING$(24,"0"))                  ! AJC
4588: 8564: 
4589: 8564:         IF CSOUF.OPERATION$ = "ADD" THEN                               \
4590: 8582:         BEGIN
4591: 8582:            AF.DATE.PSWD.CHANGE$ = PACK$(TODAYS.DATE$)
4592: 85a5:         ENDIF
4593: 85ad: 
4594: 85ad:         AF.STAFF.NUM$        = PACK$(RIGHT$(STRING$(8,"0") +           \
4595: 85ff:                                STAFF.NO$,8))
4596: 85ff: 
4597: 85ff:         AF.BIRTH.DATE$ = DDMCYY.HEX.FROM.DDMMCCYY$ (BIRTH.DATE$)       ! 1.8 RC
4598: 8622: 
4599: 8622:         IF EMPLOYEE.FLG$ = "Y" THEN BEGIN
4600: 8640:            AF.EMPLOYEE.FLAG$ = PACK$("00")
4601: 865e:         ENDIF ELSE BEGIN
4602: 8666:            AF.EMPLOYEE.FLAG$ = PACK$("01")
4603: 8682:         ENDIF
4604: 868a: 
4605: 868a:         IF GROUP.CODE$         = " " THEN BEGIN                        ! AJC 1.4
4606: 86a8:            AF.GROUP.CODE$      = ""                                    ! AJC 1.4
4607: 86c1:         ENDIF ELSE BEGIN                                               ! AJC 1.4
4608: 86c9:            AF.GROUP.CODE$      = PACK$(GROUP.CODE$)                    ! AJC 1.4
4609: 86ec:         ENDIF                                                          ! AJC 1.4
4610: 86f4: 
4611: 86f4:         CSOUF.OP.ID$         = LEFT$(OPERATOR.ID$ +                    \
4612: 8743:                                STRING$(8," "),8)
4613: 8743: 
4614: 8743:         CSOUF.FILLER.01$     = " "
4615: 875a:         CSOUF.PSWD$          = "********"
4616: 8771:         CSOUF.FILLER.02$     = " "
4617: 8788: 
4618: 8788:         GOSUB SET.CSOUF.IDS
4619: 879a:         GOSUB SET.AF.OPTIONS.KEY
4620: 87ac:         GOSUB SET.AF.FLAGS
4621: 87be:         GOSUB SET.CSOUF.FLAGS
4622: 87d0:         GOSUB SET.AF.TILL.MODEL.FLAGS
4623: 87e2:         GOSUB SET.AF.CTLR.MODEL.FLAGS
4624: 87f4:         GOSUB SET.OLD.MODEL.INFO
4625: 8806: 
4626: 8806:         CALL GET.CSOUF.RECORD                                          ! 1.5 RC
4627: 8813: 
4628: 8813:         IF WRITE.AF.ABREV = 0 THEN                                     \
4629: 8825:         BEGIN
4630: 8825:            IF WRITE.CSOUF.ABREV = 0 THEN                               \
4631: 8837:            BEGIN
4632: 8837:               GOSUB SET.CSOUF.PASSWORD
4633: 8849:               CALL SET.NEW.OPAUD.DETAILS                               ! 1.5 RC
4634: 8856:               CALL WRITE.OPAUD.RECORDS                                 ! 1.5 RC
4635: 8865:            ENDIF                                                       \
4636: 8865:            ELSE                                                        \
4637: 886d:            BEGIN
4638: 886d:               GOSUB FILE.ERROR
4639: 887f:            ENDIF
4640: 8889:         ENDIF                                                          \
4641: 8889:         ELSE                                                           \
4642: 8891:         BEGIN
4643: 8891:            GOSUB FILE.ERROR
4644: 88a3:         ENDIF
4645: 88ab: 
4646: 88ab:         CALL GET.QUIT.KEY                                              ! 1.5 RC
4647: 88b8: 
4648: 88b8:         RETURN
4649: 88c8: 
4650: 88c8: \******************************************************************************
4651: 88c8: \***                                                                          *
4652: 88c8: \***    SUBROUTINE      :       SET.CSOUF.PASSWORD                            *
4653: 88c8: \***                                                                          *
4654: 88c8: \******************************************************************************
4655: 88c8: \***                                                                          *
4656: 88c8: \***    Write the encrypted password to the ADXCSOUF file                     *
4657: 88c8: \***                                                                          *
4658: 88c8: \******************************************************************************
4659: 88c8: 
4660: 88c8:         SET.CSOUF.PASSWORD:
4661: 88d8: 
4662: 88d8:         IF ADXAUTH(8,CSOUF.OP.ID$,                                     \
4663: 890c:                    OPERATOR.PASSWORD$,"") = 0 THEN                     \
4664: 890c:         BEGIN
4665: 890c:            IF CSOUF.OPERATION$ = "ADD" THEN                            \
4666: 892a:            BEGIN
4667: 892a:               ! B178 Operator details successfully added
4668: 892a:               DISPLAY.MESSAGE.NUMBER% = 178
4669: 893b:               CALL DISPLAY.MESSAGE                                     ! 1.5 RC
4670: 894b:            ENDIF                                                       \
4671: 894b:            ELSE                                                        \
4672: 8953:            IF CSOUF.OPERATION$ = "CHANGE" THEN                         \
4673: 8971:            BEGIN
4674: 8971:               IF VAL(OPERATOR.ID$) = 905 THEN                          \
4675: 89a6:               BEGIN
4676: 89a6:                  GOSUB UPDATE.PPDF.RECORD
4677: 89b8:               ENDIF
4678: 89c0: 
4679: 89c0:               ! B179 Operator details successfully changed
4680: 89c0:               DISPLAY.MESSAGE.NUMBER% = 179
4681: 89d1:               CALL DISPLAY.MESSAGE                                     ! 1.5 RC
4682: 89de:            ENDIF
4683: 89e8:         ENDIF                                                          \
4684: 89e8:         ELSE                                                           \
4685: 89f0:         BEGIN
4686: 89f0:            GOSUB FILE.ERROR
4687: 8a02:         ENDIF
4688: 8a0a: 
4689: 8a0a:         RETURN
4690: 8a1a: 
4691: 8a1a: \******************************************************************************
4692: 8a1a: \***                                                                          *
4693: 8a1a: \***    SUBROUTINE      :       SET.CSOUF.IDS:                                *
4694: 8a1a: \***                                                                          *
4695: 8a1a: \******************************************************************************
4696: 8a1a: \***                                                                          *
4697: 8a1a: \***    Combine the user and group IDs from the selected models               *
4698: 8a1a: \***                                                                          *
4699: 8a1a: \******************************************************************************
4700: 8a1a: 
4701: 8a1a:         SET.CSOUF.IDS:
4702: 8a2a: 
4703: 8a2a:         CSOUF.USER.ID$  = PACK$("01")
4704: 8a46:         CSOUF.GROUP.ID$ = PACK$("03")
4705: 8a62: 
4706: 8a62:         FOR I% = 1 TO MAX.CTLR.PTR%
4707: 8a76: 
4708: 8a76:             IF CTLR.MODEL.FLAG$(I%) = "Y" THEN                         \
4709: 8aa8:             BEGIN
4710: 8aa8:                GROUP.ID$ = MID$(CTLR.MODEL.RECORD$(I%),48,1)
4711: 8ae0: 
4712: 8ae0:                IF VAL(UNPACK$(GROUP.ID$)) <                            \
4713: 8b3c:                   VAL(UNPACK$(CSOUF.GROUP.ID$)) THEN                   \
4714: 8b3c:                BEGIN
4715: 8b3c:                   CSOUF.GROUP.ID$ = GROUP.ID$
4716: 8b5a:                ENDIF
4717: 8b62: 
4718: 8b62:             ENDIF
4719: 8b6a: 
4720: 8b6a:         NEXT I%
4721: 8b94: 
4722: 8b94:         RETURN
4723: 8ba4: 
4724: 8ba4: \******************************************************************************
4725: 8ba4: \***                                                                          *
4726: 8ba4: \***    SUBROUTINE      :       SET.AF.OPTIONS.KEY                            *
4727: 8ba4: \***                                                                          *
4728: 8ba4: \******************************************************************************
4729: 8ba4: \***                                                                          *
4730: 8ba4: \***    Combine the options authorisation key from the selected models        *
4731: 8ba4: \***                                                                          *
4732: 8ba4: \******************************************************************************
4733: 8ba4: 
4734: 8ba4:         SET.AF.OPTIONS.KEY:
4735: 8bb4: 
4736: 8bb4:         AF.OPTIONS.KEY$ = PACK$("01")
4737: 8bd0: 
4738: 8bd0:         FOR I% = 1 TO MAX.CTLR.PTR%
4739: 8be4: 
4740: 8be4:             IF CTLR.MODEL.FLAG$(I%) = "Y" THEN                         \
4741: 8c16:             BEGIN
4742: 8c16:                OPTIONS.KEY$ = MID$(CTLR.MODEL.RECORD$(I%),27,1)
4743: 8c4e: 
4744: 8c4e:                IF VAL(UNPACK$(OPTIONS.KEY$)) >                         \
4745: 8caa:                   VAL(UNPACK$(AF.OPTIONS.KEY$)) THEN                   \
4746: 8caa:                BEGIN
4747: 8caa:                   AF.OPTIONS.KEY$ = OPTIONS.KEY$
4748: 8cc8:                ENDIF
4749: 8cd0:             ENDIF
4750: 8cd8: 
4751: 8cd8:         NEXT I%
4752: 8d02: 
4753: 8d02:         RETURN
4754: 8d12: 
4755: 8d12: 
4756: 8d12: \******************************************************************************
4757: 8d12: \***                                                                          *
4758: 8d12: \***    SUBROUTINE      :       SET.AF.FLAGS                                  *
4759: 8d12: \***                                                                          *
4760: 8d12: \******************************************************************************
4761: 8d12: \***                                                                          *
4762: 8d12: \***    Combine the EALAUTH flags from the selected models                    *
4763: 8d12: \***                                                                          *
4764: 8d12: \******************************************************************************
4765: 8d12: 
4766: 8d12:         SET.AF.FLAGS:
4767: 8d22: 
4768: 8d22:         AF.FLAGS.01.12$ = ""
4769: 8d39:         AF.FLAGS.13.16$ = ""
4770: 8d50: 
4771: 8d50:         FOR I% = 1 TO 19
4772: 8d64: 
4773: 8d64:             INDICATOR% = 0
4774: 8d75: 
4775: 8d75:             FOR J% = 1 TO MAX.TILL.PTR%
4776: 8d89: 
4777: 8d89:                 IF TILL.MODEL.FLAG$(J%) = "Y" THEN                     \
4778: 8db8:                 BEGIN
4779: 8db8:                    AUTH.FLAGS% = ASC(MID$(TILL.MODEL.RECORD$(J%),      \
4780: 8dff:                                  27 + I%,1))
4781: 8dff: 
4782: 8dff:                    INDICATOR% = INDICATOR% OR AUTH.FLAGS%
4783: 8e1c:                 ENDIF
4784: 8e24: 
4785: 8e24:             NEXT J%
4786: 8e4e: 
4787: 8e4e:             FOR J% = 1 TO MAX.CTLR.PTR%
4788: 8e62: 
4789: 8e62:                 IF CTLR.MODEL.FLAG$(J%) = "Y" THEN                     \
4790: 8e91:                 BEGIN
4791: 8e91:                    AUTH.FLAGS% = ASC(MID$(CTLR.MODEL.RECORD$(J%),      \
4792: 8ed8:                                  27 + I%,1))
4793: 8ed8: 
4794: 8ed8:                    INDICATOR% = INDICATOR% OR AUTH.FLAGS%
4795: 8ef5:                 ENDIF
4796: 8efd: 
4797: 8efd:             NEXT J%
4798: 8f27: 
4799: 8f27:             IF I% >= 1 AND                                             \
4800: 8f53:                I% <= 15 THEN                                           \
4801: 8f53:             BEGIN
4802: 8f53:                AF.FLAGS.01.12$ = AF.FLAGS.01.12$ + CHR$(INDICATOR%)
4803: 8f82:             ENDIF                                                      \
4804: 8f82:             ELSE                                                       \
4805: 8f8a:             BEGIN
4806: 8f8a:                AF.FLAGS.13.16$ = AF.FLAGS.13.16$ + CHR$(INDICATOR%)
4807: 8fb7:             ENDIF
4808: 8fbf: 
4809: 8fbf:         NEXT I%
4810: 8fe3: 
4811: 8fe3:         RETURN
4812: 8ff3: 
4813: 8ff3: \******************************************************************************
4814: 8ff3: \***                                                                          *
4815: 8ff3: \***    SUBROUTINE      :       SET.CSOUF.FLAGS                               *
4816: 8ff3: \***                                                                          *
4817: 8ff3: \******************************************************************************
4818: 8ff3: \***                                                                          *
4819: 8ff3: \***    Combine the ADXCSOUF flags from the selected models                   *
4820: 8ff3: \***                                                                          *
4821: 8ff3: \******************************************************************************
4822: 8ff3: 
4823: 8ff3:         SET.CSOUF.FLAGS:
4824: 9003: 
4825: 9003:         CSOUF.FLAGS$ = ""
4826: 901a: 
4827: 901a:         FOR I% = 1 TO 14
4828: 902e: 
4829: 902e: 
4830: 902e:             INDICATOR% = 0
4831: 903f: 
4832: 903f:             FOR J% = 1 TO MAX.TILL.PTR%
4833: 9053: 
4834: 9053:                 IF TILL.MODEL.FLAG$(J%) = "Y" THEN                     \
4835: 9082:                 BEGIN
4836: 9082:                    AUTH.FLAGS% = ASC(MID$(TILL.MODEL.RECORD$(J%),      \
4837: 90c9:                                  48 + I%,1))
4838: 90c9: 
4839: 90c9:                    INDICATOR% = INDICATOR% OR AUTH.FLAGS%
4840: 90e6:                 ENDIF
4841: 90ee: 
4842: 90ee:             NEXT J%
4843: 9118: 
4844: 9118:             FOR J% = 1 TO MAX.CTLR.PTR%
4845: 912c: 
4846: 912c:                 IF CTLR.MODEL.FLAG$(J%) = "Y" THEN                     \
4847: 915b:                 BEGIN
4848: 915b:                    AUTH.FLAGS% = ASC(MID$(CTLR.MODEL.RECORD$(J%),      \
4849: 91a2:                                  48 + I%,1))
4850: 91a2: 
4851: 91a2:                    INDICATOR% = INDICATOR% OR AUTH.FLAGS%
4852: 91bf:                 ENDIF
4853: 91c7: 
4854: 91c7:             NEXT J%
4855: 91f1: 
4856: 91f1:             CSOUF.FLAGS$ = CSOUF.FLAGS$ + CHR$(INDICATOR%)
4857: 921e: 
4858: 921e:         NEXT I%
4859: 9242: 
4860: 9242:         RETURN
4861: 9252: 
4862: 9252: \******************************************************************************
4863: 9252: \***                                                                          *
4864: 9252: \***    SUBROUTINE      :       SET.OLD.MODEL.INFO                            *
4865: 9252: \***                                                                          *
4866: 9252: \******************************************************************************
4867: 9252: \***                                                                          *
4868: 9252: \***    Calculate the best match for the model number and supervisor flag     *
4869: 9252: \***                                                                          *
4870: 9252: \******************************************************************************
4871: 9252: 
4872: 9252:         SET.OLD.MODEL.INFO:
4873: 9262: 
4874: 9262:         AF.SUP.FLAG$ = "N"
4875: 9279:         AF.OP.MODEL$ = "905"
4876: 9290: 
4877: 9290:         FOR I% = 1 TO MAX.TILL.PTR%
4878: 92a4: 
4879: 92a4:             IF TILL.MODEL.FLAG$(I%) = "Y" THEN                         \
4880: 92d6:             BEGIN
4881: 92d6:                MODEL.NUMBER$    = MID$(TILL.MODEL.RECORD$(I%),63,3)
4882: 930e:                SUPERVISOR.FLAG$ = MID$(TILL.MODEL.RECORD$(I%),66,1)
4883: 9346: 
4884: 9346:                IF SUPERVISOR.FLAG$ = "Y" AND                           \
4885: 9398:                   AF.SUP.FLAG$ = "N" THEN                              \
4886: 9398:                BEGIN
4887: 9398:                   AF.SUP.FLAG$ = "Y"
4888: 93af:                ENDIF
4889: 93b7: 
4890: 93b7:                IF MODEL.NUMBER$ = "901" AND                            \
4891: 9409:                   AF.OP.MODEL$ <> "901" THEN                           \
4892: 9409:                BEGIN
4893: 9409:                   AF.OP.MODEL$ = "901"
4894: 9423:                ENDIF                                                   \
4895: 9423:                ELSE                                                    \
4896: 942b:                IF MODEL.NUMBER$ = "909" AND                            \
4897: 94a3:                   (AF.OP.MODEL$ <> "901" OR                            \
4898: 94a3:                   AF.OP.MODEL$ <> "909") THEN                          \
4899: 94a3:                BEGIN
4900: 94a3:                   AF.OP.MODEL$ = "909"
4901: 94ba:                ENDIF
4902: 94c2:             ENDIF
4903: 94ca: 
4904: 94ca:         NEXT I%
4905: 94f4: 
4906: 94f4:         FOR I% = 1 TO MAX.CTLR.PTR%
4907: 9508: 
4908: 9508:             IF CTLR.MODEL.FLAG$(I%) = "Y" THEN                         \
4909: 953a:             BEGIN
4910: 953a:                MODEL.NUMBER$    = MID$(CTLR.MODEL.RECORD$(I%),63,3)
4911: 9572: 
4912: 9572:                IF MODEL.NUMBER$ = "908" AND                            \
4913: 95c4:                   AF.OP.MODEL$ <> "908" THEN                           \
4914: 95c4:                BEGIN
4915: 95c4:                   AF.OP.MODEL$ = "908"
4916: 95de:                ENDIF                                                   \
4917: 95de:                ELSE                                                    \
4918: 95e6:                IF MODEL.NUMBER$ = "904" AND                            \
4919: 965e:                   (AF.OP.MODEL$ <> "908" OR                            \
4920: 965e:                   AF.OP.MODEL$ <> "904") THEN                          \
4921: 965e:                BEGIN
4922: 965e:                   AF.OP.MODEL$ = "904"
4923: 9675:                ENDIF
4924: 967d: 
4925: 967d:             ENDIF
4926: 9685: 
4927: 9685:         NEXT I%
4928: 96af: 
4929: 96af:         RETURN
4930: 96bf: 
4931: 96bf: 
4932: 96bf: \******************************************************************************
4933: 96bf: \***                                                                          *
4934: 96bf: \***    SUBROUTINE      :       SET.AF.TILL.MODEL.FLAGS                       *
4935: 96bf: \***                                                                          *
4936: 96bf: \******************************************************************************
4937: 96bf: \***                                                                          *
4938: 96bf: \***    Set the till authorisation flags on EALAUTH                           *
4939: 96bf: \***                                                                          *
4940: 96bf: \******************************************************************************
4941: 96bf: 
4942: 96bf:         SET.AF.TILL.MODEL.FLAGS:
4943: 96cf: 
4944: 96cf:         AF.MODEL.FLAGS.1% = 0
4945: 96e0: 
4946: 96e0:         FOR I% = 1 TO MAX.TILL.PTR%
4947: 96f4: 
4948: 96f4:             IF TILL.MODEL.FLAG$(I%) = "Y" THEN                         \
4949: 9726:             BEGIN
4950: 9726:                BIT.MASK% = VAL(UNPACK$(MID$(                           \
4951: 976f:                            TILL.MODEL.RECORD$(I%),2,1)))
4952: 976f: 
4953: 976f:                BIT.MASK% = 2 ^ (BIT.MASK% - 1)
4954: 97a0: 
4955: 97a0:                AF.MODEL.FLAGS.1% = AF.MODEL.FLAGS.1% OR BIT.MASK%
4956: 97d8:             ENDIF
4957: 97e0: 
4958: 97e0:         NEXT I%
4959: 980a: 
4960: 980a:         RETURN
4961: 981a: 
4962: 981a: \******************************************************************************
4963: 981a: \***                                                                          *
4964: 981a: \***    SUBROUTINE      :       SET.AF.CTLR.MODEL.FLAGS                       *
4965: 981a: \***                                                                          *
4966: 981a: \******************************************************************************
4967: 981a: \***                                                                          *
4968: 981a: \***    Set the controller authorisation flags on EALAUTH                     *
4969: 981a: \***                                                                          *
4970: 981a: \******************************************************************************
4971: 981a: 
4972: 981a:         SET.AF.CTLR.MODEL.FLAGS:
4973: 982a: 
4974: 982a:         AF.MODEL.FLAGS.2% = 0
4975: 983b: 
4976: 983b:         FOR I% = 1 TO MAX.CTLR.PTR%
4977: 984f: 
4978: 984f:             IF CTLR.MODEL.FLAG$(I%) = "Y" THEN                         \
4979: 9881:             BEGIN
4980: 9881:                BIT.MASK% = VAL(UNPACK$(MID$(                           \
4981: 98ca:                            CTLR.MODEL.RECORD$(I%),2,1)))
4982: 98ca: 
4983: 98ca:                BIT.MASK% = 2 ^ (BIT.MASK% - 1)
4984: 98fb: 
4985: 98fb:                AF.MODEL.FLAGS.2% = AF.MODEL.FLAGS.2% OR BIT.MASK%
4986: 9933:             ENDIF
4987: 993b: 
4988: 993b:         NEXT I%
4989: 9965: 
4990: 9965:         RETURN
4991: 9975: 
4992: 9975: 
4993: 9975: \******************************************************************************
4994: 9975: \***
4995: 9975: \***    SUBROUTINE      :       REQUIRED.OPTION
4996: 9975: \***
4997: 9975: \******************************************************************************
4998: 9975: \***
4999: 9975: \***    Select the required option
5000: 9975: \***
5001: 9975: \******************************************************************************
5002: 9975: 
5003: 9975:         REQUIRED.OPTION:
5004: 9985: 
5005: 9985:         IF OPTION.ALLOWED(VAL(OPTION$)) THEN                           \
5006: 99b7:         BEGIN
5007: 99b7:            IF OPTION$ = "1" THEN                                       \
5008: 99d5:            BEGIN
5009: 99d5:               GOSUB PROCESS.SCREEN.02
5010: 99ea:            ENDIF                                                       \
5011: 99ea:            ELSE                                                        \
5012: 99f2:            IF OPTION$ = "2" THEN                                       \
5013: 9a10:            BEGIN
5014: 9a10:               GOSUB PROCESS.SCREEN.03
5015: 9a25:            ENDIF                                                       \
5016: 9a25:            ELSE                                                        \
5017: 9a2d:            IF OPTION$ = "3" THEN                                       \
5018: 9a4b:            BEGIN
5019: 9a4b:               GOSUB PROCESS.SCREEN.04
5020: 9a60:            ENDIF                                                       \
5021: 9a60:            ELSE                                                        \
5022: 9a68:            IF OPTION$ = "4" THEN                                       \
5023: 9a86:            BEGIN
5024: 9a86:               GOSUB PROCESS.SCREEN.05
5025: 9a9b:            ENDIF                                                       \
5026: 9a9b:            ELSE                                                        \
5027: 9aa3:            IF OPTION$ = "5" THEN                                       \
5028: 9ac1:            BEGIN
5029: 9ac1:               GOSUB PROCESS.SCREEN.06
5030: 9ad5:            ENDIF                                                       \
5031: 9ad5:            ELSE                                                        \
5032: 9add:            IF OPTION$ = "6" THEN                                       \
5033: 9afb:            BEGIN
5034: 9afb:               GOSUB PROCESS.SCREEN.07
5035: 9b0d:            ENDIF
5036: 9b17:         ENDIF                                                          \
5037: 9b17:         ELSE                                                           \
5038: 9b1f:         BEGIN
5039: 9b1f:            ! B004 No authorisation for this selection
5040: 9b1f:            DISPLAY.MESSAGE.NUMBER% = 4
5041: 9b30:            CALL DISPLAY.MESSAGE                                        ! 1.5 RC
5042: 9b3d: 
5043: 9b3d:            GOTO END.REQUIRED.OPTION
5044: 9b47:         ENDIF
5045: 9b4f: 
5046: 9b4f:         CALL DISPLAY.SCREEN(1)
5047: 9b6d: 
5048: 9b6d:         GOSUB RESTORE.FIELDS.01
5049: 9b7f: 
5050: 9b7f:         EXIT.KEY.PRESSED(1) = FALSE
5051: 9ba7: 
5052: 9ba7:         END.REQUIRED.OPTION:
5053: 9bb7: 
5054: 9bb7:         RETURN
5055: 9bc7: 
5056: 9bc7: \******************************************************************************
5057: 9bc7: \***                                                                          *
5058: 9bc7: \***    SUBROUTINE      :       PROCESS.SCREEN.03                             *
5059: 9bc7: \***                                                                          *
5060: 9bc7: \******************************************************************************
5061: 9bc7: \***                                                                          *
5062: 9bc7: \***    Control routine for the display operator screen                       *
5063: 9bc7: \***                                                                          *
5064: 9bc7: \******************************************************************************
5065: 9bc7: 
5066: 9bc7:         PROCESS.SCREEN.03:
5067: 9bd7: 
5068: 9bd7:         S% = 3
5069: 9be8: 
5070: 9be8:         CALL DISPLAY.SCREEN(3)
5071: 9c06: 
5072: 9c06:         OLD.OPERATOR.ID$   = ""
5073: 9c1d:         OPERATOR.ID$       = ""
5074: 9c34:         OPERATOR.NAME$     = ""
5075: 9c4b:         OPERATOR.PASSWORD$ = ""
5076: 9c62:         STAFF.NO$          = ""
5077: 9c79:         EMPLOYEE.FLG$      = ""
5078: 9c90:         BIRTH.DATE$        = ""                                        ! 1.6 RC
5079: 9ca7:         RECEIPT.NAME$      = ""                                       ! AJC
5080: 9cbe:         GROUP.CODE$        = ""                                       ! AJC 1.4
5081: 9cd5:         MODEL.FLAG$        = ""
5082: 9cec: 
5083: 9cec:         CALL RESET.MODEL.FLAGS                                         ! 1.5 RC
5084: 9cf9: 
5085: 9cf9:         GOSUB RESTORE.FIELDS.03
5086: 9d0b: 
5087: 9d0b:         EXIT.KEY.PRESSED(3) = FALSE
5088: 9d33: 
5089: 9d33:         WHILE NOT EXIT.KEY.PRESSED(3)
5090: 9d3d:               GOSUB GET.OPERATOR.ID.03
5091: 9d4f:         WEND
5092: 9d6d: 
5093: 9d6d:         RETURN
5094: 9d7d: 
5095: 9d7d: \******************************************************************************
5096: 9d7d: \***                                                                          *
5097: 9d7d: \***    SUBROUTINE      :       RESTORE.FIELDS.03                             *
5098: 9d7d: \***                                                                          *
5099: 9d7d: \******************************************************************************
5100: 9d7d: \***                                                                          *
5101: 9d7d: \***    Redisplay all fields for the display operator screen                  *
5102: 9d7d: \***                                                                          *
5103: 9d7d: \******************************************************************************
5104: 9d7d: 
5105: 9d7d:         RESTORE.FIELDS.03:
5106: 9d8d: 
5107: 9d8d:         CURSOR.STATE$ = CURSOR.OFF$
5108: 9dab:         CALL SET.CURSOR.STATE                                          ! 1.5 RC
5109: 9db8: 
5110: 9db8:         CALL DISPLAY.FORMATTED.DATE                                    ! 1.5 RC
5111: 9dc5: 
5112: 9dc5:         CURSOR.POSITION% = S3.OPERATOR.ID%
5113: 9ddb:         CALL PUT.CURSOR.IN.FIELD                                       ! 1.5 RC
5114: 9de8: 
5115: 9de8:         IF VAL(OPERATOR.ID$) > 0 THEN                                  \
5116: 9e1d:         BEGIN
5117: 9e1d:            OPERATOR.ID$ = STR$(VAL(OPERATOR.ID$))
5118: 9e4c:         ENDIF                                                          \
5119: 9e4c:         ELSE                                                           \
5120: 9e54:         BEGIN
5121: 9e54:            OPERATOR.ID$ = ""
5122: 9e6b:         ENDIF
5123: 9e73: 
5124: 9e73:         STRING.DATA$ = OPERATOR.ID$
5125: 9e91:         CALL SET.FIELD                                                 ! 1.5 RC
5126: 9e9e: 
5127: 9e9e:         CURSOR.POSITION% = S3.NAME%
5128: 9eb4:         CALL PUT.CURSOR.IN.FIELD                                       ! 1.5 RC
5129: 9ec1: 
5130: 9ec1:         STRING.DATA$ = OPERATOR.NAME$
5131: 9edf:         CALL SET.FIELD                                                 ! 1.5 RC
5132: 9eec: 
5133: 9eec:         CURSOR.POSITION% = S3.STAFF.NO%
5134: 9f02:         CALL PUT.CURSOR.IN.FIELD                                       ! 1.5 RC
5135: 9f0f: 
5136: 9f0f:         STRING.DATA$ = STAFF.NO$
5137: 9f2d:         CALL SET.FIELD                                                 ! 1.5 RC
5138: 9f3a: 
5139: 9f3a:         CURSOR.POSITION% = S3.RECEIPT.NAME%                           ! AJC
5140: 9f50:         CALL PUT.CURSOR.IN.FIELD                                       ! 1.5 RC
5141: 9f5d: 
5142: 9f5d:         STRING.DATA$ = RECEIPT.NAME$                                  ! AJC
5143: 9f7b:         CALL SET.FIELD                                                 ! 1.5 RC
5144: 9f88: 
5145: 9f88:         CURSOR.POSITION% = S3.BIRTH.DATE%                              ! 1.6 RC
5146: 9f9e:         CALL PUT.CURSOR.IN.FIELD                                       ! 1.6 RC
5147: 9fab: 
5148: 9fab:         IF BIRTH.DATE$ <> "" THEN BEGIN \                              ! 1.6 RC
5149: 9fc9:             STRING.DATA$ = MID$(BIRTH.DATE$,1,2) + "/" + \             ! 1.6 RC
5150: a039:                            MID$(BIRTH.DATE$,3,2) + "/" + \             ! 1.6 RC
5151: a039:                            MID$(BIRTH.DATE$,5,4)                       ! 1.6 RC
5152: a039:         ENDIF                                                          ! 1.6 RC
5153: a041:         CALL SET.FIELD                                                 ! 1.6 RC
5154: a04e: 
5155: a04e:         CURSOR.POSITION% = S3.GROUP.CODE%                             ! AJC 1.4
5156: a064:         CALL PUT.CURSOR.IN.FIELD                                       ! 1.5 RC
5157: a071: 
5158: a071:         STRING.DATA$ = GROUP.CODE$                                    ! AJC 1.4
5159: a08f:         CALL SET.FIELD                                                 ! 1.5 RC
5160: a09c: 
5161: a09c:         CURSOR.POSITION% = S3.EMPLOYEE.FLG%
5162: a0b2:         CALL PUT.CURSOR.IN.FIELD                                       ! 1.5 RC
5163: a0bf: 
5164: a0bf:         STRING.DATA$ = EMPLOYEE.FLG$
5165: a0dd:         CALL SET.FIELD                                                 ! 1.5 RC
5166: a0ea: 
5167: a0ea:         CALL RESTORE.MODEL.FLAGS                                       ! 1.5 RC
5168: a0f7: 
5169: a0f7:         CURSOR.STATE$ = CURSOR.ON$
5170: a115:         CALL SET.CURSOR.STATE                                          ! 1.5 RC
5171: a122: 
5172: a122:         RETURN
5173: a132: 
5174: a132: \******************************************************************************
5175: a132: \***                                                                          *
5176: a132: \***    SUBROUTINE      :       CLEAR.FIELDS.03                               *
5177: a132: \***                                                                          *
5178: a132: \******************************************************************************
5179: a132: \***                                                                          *
5180: a132: \***    Clear all fields for the display operator screen                      *
5181: a132: \***                                                                          *
5182: a132: \******************************************************************************
5183: a132: 
5184: a132:         CLEAR.FIELDS.03:
5185: a142: 
5186: a142:         CURSOR.STATE$ = CURSOR.OFF$
5187: a160:         CALL SET.CURSOR.STATE                                          ! 1.5 RC
5188: a16d: 
5189: a16d:         IF OPERATOR.NAME$ <> "" THEN                                   \
5190: a18b:         BEGIN
5191: a18b:            CURSOR.POSITION% = S3.NAME%
5192: a1a1:            CALL PUT.CURSOR.IN.FIELD                                    ! 1.5 RC
5193: a1ae: 
5194: a1ae:            STRING.DATA$ = ""
5195: a1c5:            CALL SET.FIELD                                              ! 1.5 RC
5196: a1d2:         ENDIF
5197: a1da: 
5198: a1da:         IF STAFF.NO$ <> "" THEN BEGIN
5199: a1f8:            CURSOR.POSITION% = S3.STAFF.NO%
5200: a20e:            CALL PUT.CURSOR.IN.FIELD                                    ! 1.5 RC
5201: a21b: 
5202: a21b:            STRING.DATA$ = ""
5203: a232:            CALL SET.FIELD                                              ! 1.5 RC
5204: a23f:         ENDIF
5205: a247: 
5206: a247:         IF BIRTH.DATE$ <> "" THEN BEGIN                                ! 1.6 RC
5207: a265:            CURSOR.POSITION% = S3.BIRTH.DATE%                           ! 1.6 RC
5208: a27b:            CALL PUT.CURSOR.IN.FIELD                                    ! 1.6 RC
5209: a288:            STRING.DATA$ = ""                                           ! 1.6 RC
5210: a29f:            CALL SET.FIELD                                              ! 1.5 RC
5211: a2ac:         ENDIF                                                          ! 1.6 RC
5212: a2b4: 
5213: a2b4:         IF RECEIPT.NAME$ <> "" THEN                                   \ AJC
5214: a2d2:         BEGIN                                                         ! AJC
5215: a2d2:            CURSOR.POSITION% = S3.RECEIPT.NAME%                        ! AJC
5216: a2e8:            CALL PUT.CURSOR.IN.FIELD                                    ! 1.5 RC
5217: a2f5: 
5218: a2f5:            STRING.DATA$ = ""                                          ! AJC
5219: a30c:            CALL SET.FIELD                                              ! 1.5 RC
5220: a319:         ENDIF                                                         ! AJC
5221: a321: 
5222: a321:         IF GROUP.CODE$ <> "" THEN                                     \ AJC 1.4
5223: a33f:         BEGIN                                                         ! AJC 1.4
5224: a33f:            CURSOR.POSITION% = S3.GROUP.CODE%                          ! AJC 1.4
5225: a355:            CALL PUT.CURSOR.IN.FIELD                                    ! 1.5 RC
5226: a362: 
5227: a362:            STRING.DATA$ = ""                                          ! AJC 1.4
5228: a379:            CALL SET.FIELD                                              ! 1.5 RC
5229: a386:         ENDIF                                                         ! AJC 1.4
5230: a38e: 
5231: a38e:         IF EMPLOYEE.FLG$ <> "" THEN BEGIN
5232: a3ac:            CURSOR.POSITION% = S3.EMPLOYEE.FLG%
5233: a3c2:            CALL PUT.CURSOR.IN.FIELD                                    ! 1.5 RC
5234: a3cf: 
5235: a3cf:            STRING.DATA$ = ""
5236: a3e6:            CALL SET.FIELD                                              ! 1.5 RC
5237: a3f3:         ENDIF
5238: a3fb: 
5239: a3fb:         MODEL.FLAG$ = ""
5240: a412: 
5241: a412:         CALL CLEAR.MODEL.FLAGS                                         ! 1.5 RC
5242: a41f: 
5243: a41f:         CURSOR.STATE$ = CURSOR.ON$
5244: a43d:         CALL SET.CURSOR.STATE                                          ! 1.5 RC
5245: a44a: 
5246: a44a:         RETURN
5247: a45a: 
5248: a45a: \******************************************************************************
5249: a45a: \***                                                                          *
5250: a45a: \***    SUBROUTINE      :       GET.OPERATOR.ID.03                            *
5251: a45a: \***                                                                          *
5252: a45a: \******************************************************************************
5253: a45a: \***                                                                          *
5254: a45a: \***    Input routine for the operator ID on the display operator screen      *
5255: a45a: \***                                                                          *
5256: a45a: \******************************************************************************
5257: a45a: 
5258: a45a:         GET.OPERATOR.ID.03:
5259: a46a: 
5260: a46a:         CURSOR.POSITION% = S3.OPERATOR.ID%
5261: a480:         CALL PUT.CURSOR.IN.FIELD                                       ! 1.5 RC
5262: a48d: 
5263: a48d:         EXIT.KEY.PRESSED(3)     = FALSE
5264: a4b5:         VALID.OPERATOR.ID.FOUND = FALSE
5265: a4cb: 
5266: a4cb:         CALL GET.INPUT                                                 ! 1.5 RC
5267: a4d8: 
5268: a4d8:         WHILE NOT (EXIT.KEY.PRESSED(3) OR                              \
5269: a4e3:                   VALID.OPERATOR.ID.FOUND)
5270: a4e3: 
5271: a4e3:               OPERATOR.ID$ = RIGHT$(STRING$(3,"0") +                   \
5272: a54a:                              STR$(VAL(F03.RETURNED.STRING$)),3)
5273: a54a: 
5274: a54a:               IF NOT (FUNCTION.KEY% = ENTER.KEY% OR                    \
5275: a5aa:                  FUNCTION.KEY% = HELP.KEY% OR                          \
5276: a5aa:                  FUNCTION.KEY% = QUIT.KEY% OR                          \
5277: a5aa:                  FUNCTION.KEY% = ESC.KEY%) THEN                        \
5278: a5aa:               BEGIN
5279: a5aa:                  DISPLAY.MESSAGE.NUMBER% = 1
5280: a5bb:                  CALL DISPLAY.MESSAGE                                  ! 1.5 RC
5281: a5c8:                  CALL RESUME.INPUT                                     ! 1.5 RC
5282: a5d8:               ENDIF                                                    \
5283: a5d8:               ELSE                                                     \
5284: a5e0:               IF FUNCTION.KEY% = QUIT.KEY% THEN                        \
5285: a5f8:               BEGIN
5286: a5f8:                  EXIT.KEY.PRESSED(S%) = TRUE
5287: a628:               ENDIF                                                    \
5288: a628:               ELSE                                                     \
5289: a630:               IF FUNCTION.KEY% = ESC.KEY% THEN                         \
5290: a648:               BEGIN
5291: a648:                  CHAIN.TO.PROG$ = "PSB50"
5292: a65f:                  PSBCHN.MENCON  = "000000"
5293: a676:                  CALL CHAIN.TO.CALLER                                  ! 1.5 RC
5294: a686:               ENDIF                                                    \
5295: a686:               ELSE                                                     \
5296: a68e:               IF FUNCTION.KEY% = HELP.KEY% THEN                        \
5297: a6a6:               BEGIN
5298: a6a6:                  CALL SCREEN.HELP(3)
5299: a6c4:                  GOSUB RESTORE.FIELDS.03
5300: a6d6: 
5301: a6d6:                  CURSOR.POSITION% = S3.OPERATOR.ID%
5302: a6ec:                  CALL PUT.CURSOR.IN.FIELD                              ! 1.5 RC
5303: a6f9: 
5304: a6f9:                  CALL GET.INPUT                                        ! 1.5 RC
5305: a708:               ENDIF                                                    \
5306: a708:               ELSE                                                     \
5307: a710:               BEGIN
5308: a710:                  IF VALID.OPERATOR.ID THEN                             \
5309: a720:                     VALID.OPERATOR.ID.FOUND = TRUE                     \
5310: a738:                  ELSE                                                  \
5311: a740:                  BEGIN
5312: a740:                     ! B058 Invalid operator ID
5313: a740:                     DISPLAY.MESSAGE.NUMBER% = 58
5314: a751:                     CALL DISPLAY.MESSAGE                               ! 1.5 RC
5315: a75e:                     CALL RESUME.INPUT                                  ! 1.5 RC
5316: a76b:                  ENDIF
5317: a773:               ENDIF
5318: a77b:         WEND
5319: a7a2: 
5320: a7a2:         IF VALID.OPERATOR.ID.FOUND AND                                 \
5321: a7cd:            NOT EXIT.KEY.PRESSED(3) THEN                                \
5322: a7cd:         BEGIN
5323: a7cd:            CALL CLEAR.MESSAGE                                          ! 1.5 RC
5324: a7da: 
5325: a7da:            STRING.DATA$ = OPERATOR.ID$
5326: a7f8:            CALL SET.FIELD                                              ! 1.5 RC
5327: a805: 
5328: a805:            IF FUNCTION.KEY% = ENTER.KEY% THEN                          \
5329: a820:            BEGIN
5330: a820:               IF OLD.OPERATOR.ID$ <> OPERATOR.ID$ THEN                 \
5331: a848:               BEGIN
5332: a848:                  AF.OPERATOR.NO$ = PACK$(RIGHT$(STRING$(8,"0") +       \
5333: a89a:                                    OPERATOR.ID$,8))
5334: a89a: 
5335: a89a:                  IF READ.AF.ABREV = 0 THEN                             \
5336: a8ac:                  BEGIN
5337: a8ac:                     OLD.OPERATOR.ID$ = OPERATOR.ID$
5338: a8ca: 
5339: a8ca:                     CALL GET.OPERATOR.DETAILS                          ! 1.5 RC
5340: a8d7:                     GOSUB RESTORE.FIELDS.03
5341: a8eb:                  ENDIF                                                 \
5342: a8eb:                  ELSE                                                  \
5343: a8f3:                  BEGIN
5344: a8f3:                     OLD.OPERATOR.ID$ = ""
5345: a90a: 
5346: a90a:                     GOSUB CLEAR.FIELDS.03
5347: a91c: 
5348: a91c:                     ! B171 Operator ID not currently in use
5349: a91c:                     DISPLAY.MESSAGE.NUMBER% = 171
5350: a92d:                     CALL DISPLAY.MESSAGE                               ! 1.5 RC
5351: a93a:                  ENDIF
5352: a942:               ENDIF
5353: a94a:            ENDIF
5354: a952:         ENDIF
5355: a95a: 
5356: a95a:         RETURN
5357: a96a: 
5358: a96a: \******************************************************************************
5359: a96a: \***                                                                          *
5360: a96a: \***    SUBROUTINE      :       PROCESS.SCREEN.04                             *
5361: a96a: \***                                                                          *
5362: a96a: \******************************************************************************
5363: a96a: \***                                                                          *
5364: a96a: \***    Control routine for the change operator screen                        *
5365: a96a: \***                                                                          *
5366: a96a: \******************************************************************************
5367: a96a: 
5368: a96a:         PROCESS.SCREEN.04:
5369: a97a: 
5370: a97a:         S% = 4
5371: a98b: 
5372: a98b:         CALL DISPLAY.SCREEN(4)
5373: a9a9: 
5374: a9a9:         OLD.OPERATOR.ID$   = ""
5375: a9c0:         OPERATOR.ID$       = ""
5376: a9d7:         OPERATOR.NAME$     = ""
5377: a9ee:         OPERATOR.PASSWORD$ = ""
5378: aa05:         STAFF.NO$          = ""
5379: aa1c:         BIRTH.DATE$        = ""                                       ! 1.6 RC
5380: aa33:         EMPLOYEE.FLG$      = ""
5381: aa4a:         RECEIPT.NAME$      = ""                                       ! AJC
5382: aa61:         GROUP.CODE$        = ""                                       ! AJC 1.4
5383: aa78:         MODEL.FLAG$        = ""
5384: aa8f:         CONFIRM$           = "N"
5385: aaa6: 
5386: aaa6:         CALL RESET.MODEL.FLAGS                                         ! 1.5 RC
5387: aab3: 
5388: aab3:         CALL RESTORE.FIELDS.04                                         ! 1.5 RC
5389: aabf: 
5390: aabf:         EXIT.KEY.PRESSED(4) = FALSE
5391: aae7: 
5392: aae7:         WHILE NOT EXIT.KEY.PRESSED(4)
5393: aaf1:               GOSUB GET.OPERATOR.ID.04
5394: ab03:         WEND
5395: ab21: 
5396: ab21:         RETURN
5397: ab31: 
5398: ab31: 
5399: ab31: \******************************************************************************
5400: ab31: \***                                                                          *
5401: ab31: \***    SUBROUTINE      :       CLEAR.FIELDS.04                               *
5402: ab31: \***                                                                          *
5403: ab31: \******************************************************************************
5404: ab31: \***                                                                          *
5405: ab31: \***    Clear all fields for the change operator screen                       *
5406: ab31: \***                                                                          *
5407: ab31: \******************************************************************************
5408: ab31: 
5409: ab31:         CLEAR.FIELDS.04:
5410: ab41: 
5411: ab41:         CURSOR.STATE$ = CURSOR.OFF$
5412: ab5f:         CALL SET.CURSOR.STATE                                          ! 1.5 RC
5413: ab6c: 
5414: ab6c:         IF OPERATOR.NAME$ <> "" THEN                                   \
5415: ab8a:         BEGIN
5416: ab8a:            CURSOR.POSITION% = S4.NAME%
5417: aba0:            CALL PUT.CURSOR.IN.FIELD                                    ! 1.5 RC
5418: abad: 
5419: abad:            STRING.DATA$ = ""
5420: abc4:            CALL SET.FIELD                                              ! 1.5 RC
5421: abd1:         ENDIF
5422: abd9: 
5423: abd9:         IF STAFF.NO$ <> "" THEN BEGIN
5424: abf7:            CURSOR.POSITION% = S4.STAFF.NO%
5425: ac0d:            CALL PUT.CURSOR.IN.FIELD                                    ! 1.5 RC
5426: ac1a: 
5427: ac1a:            STRING.DATA$ = ""
5428: ac31:            CALL SET.FIELD                                              ! 1.5 RC
5429: ac3e:         ENDIF
5430: ac46: 
5431: ac46:         IF BIRTH.DATE$ <> "" THEN BEGIN                                ! 1.6 RC
5432: ac64:            CURSOR.POSITION% = S4.BIRTH.DATE%                           ! 1.6 RC
5433: ac7a:            CALL PUT.CURSOR.IN.FIELD                                    ! 1.6 RC
5434: ac87:            STRING.DATA$ = ""                                           ! 1.6 RC
5435: ac9e:            CALL SET.FIELD                                              ! 1.5 RC
5436: acab:         ENDIF                                                          ! 1.6 RC
5437: acb3: 
5438: acb3:         IF RECEIPT.NAME$ <> "" THEN                                   \ AJC
5439: acd1:         BEGIN                                                         ! AJC
5440: acd1:            CURSOR.POSITION% = S4.RECEIPT.NAME%                        ! AJC
5441: ace7:            CALL PUT.CURSOR.IN.FIELD                                    ! 1.5 RC
5442: acf4: 
5443: acf4:            STRING.DATA$ = ""                                          ! AJC
5444: ad0b:            CALL SET.FIELD                                              ! 1.5 RC
5445: ad18:         ENDIF                                                         ! AJC
5446: ad20: 
5447: ad20:         IF GROUP.CODE$ <> "" THEN                                     \ AJC 1.4
5448: ad3e:         BEGIN                                                         ! AJC 1.4
5449: ad3e:            CURSOR.POSITION% = S4.GROUP.CODE%                          ! AJC 1.4
5450: ad54:            CALL PUT.CURSOR.IN.FIELD                                    ! 1.5 RC
5451: ad61: 
5452: ad61:            STRING.DATA$ = ""                                          ! AJC 1.4
5453: ad78:            CALL SET.FIELD                                              ! 1.5 RC
5454: ad85:         ENDIF                                                         ! AJC 1.4
5455: ad8d: 
5456: ad8d:         IF EMPLOYEE.FLG$ <> "" THEN BEGIN
5457: adab:            CURSOR.POSITION% = S4.EMPLOYEE.FLG%
5458: adc1:            CALL PUT.CURSOR.IN.FIELD                                    ! 1.5 RC
5459: adce: 
5460: adce:            STRING.DATA$ = ""
5461: ade5:            CALL SET.FIELD                                              ! 1.5 RC
5462: adf2:         ENDIF
5463: adfa: 
5464: adfa:         MODEL.FLAG$ = ""
5465: ae11: 
5466: ae11:         CALL CLEAR.MODEL.FLAGS                                         ! 1.5 RC
5467: ae1e: 
5468: ae1e:         CURSOR.STATE$ = CURSOR.ON$
5469: ae3c:         CALL SET.CURSOR.STATE                                          ! 1.5 RC
5470: ae49: 
5471: ae49:         RETURN
5472: ae59: 
5473: ae59: \******************************************************************************
5474: ae59: \***                                                                          *
5475: ae59: \***    SUBROUTINE      :       GET.OPERATOR.ID.04                            *
5476: ae59: \***                                                                          *
5477: ae59: \******************************************************************************
5478: ae59: \***                                                                          *
5479: ae59: \***    Input routine for the operator ID on the change operator screen       *
5480: ae59: \***                                                                          *
5481: ae59: \******************************************************************************
5482: ae59: 
5483: ae59:         GET.OPERATOR.ID.04:
5484: ae69: 
5485: ae69:         CURSOR.POSITION% = S4.OPERATOR.ID%
5486: ae7f:         CALL PUT.CURSOR.IN.FIELD                                       ! 1.5 RC
5487: ae8c: 
5488: ae8c:         EXIT.KEY.PRESSED(4)     = FALSE
5489: aeb4:         VALID.OPERATOR.ID.FOUND = FALSE
5490: aeca: 
5491: aeca:         CALL GET.INPUT                                                 ! 1.5 RC
5492: aed7: 
5493: aed7:         WHILE NOT (EXIT.KEY.PRESSED(4) OR                              \
5494: aee2:                   VALID.OPERATOR.ID.FOUND)
5495: aee2: 
5496: aee2:               OPERATOR.ID$ = RIGHT$(STRING$(3,"0") +                   \
5497: af49:                              STR$(VAL(F03.RETURNED.STRING$)),3)
5498: af49: 
5499: af49:               IF NOT (FUNCTION.KEY% = ENTER.KEY% OR                    \
5500: afd5:                  FUNCTION.KEY% = TAB.KEY% OR                           \
5501: afd5:                  FUNCTION.KEY% = END.KEY% OR                           \
5502: afd5:                  FUNCTION.KEY% = HELP.KEY% OR                          \
5503: afd5:                  FUNCTION.KEY% = QUIT.KEY% OR                          \
5504: afd5:                  FUNCTION.KEY% = ESC.KEY%) THEN                        \
5505: afd5:               BEGIN
5506: afd5:                  DISPLAY.MESSAGE.NUMBER% = 1
5507: afe6:                  CALL DISPLAY.MESSAGE                                  ! 1.5 RC
5508: aff3:                  CALL RESUME.INPUT                                     ! 1.5 RC
5509: b003:               ENDIF                                                    \
5510: b003:               ELSE                                                     \
5511: b00b:               IF FUNCTION.KEY% = QUIT.KEY% THEN                        \
5512: b023:               BEGIN
5513: b023:                  EXIT.KEY.PRESSED(S%) = TRUE
5514: b053:               ENDIF                                                    \
5515: b053:               ELSE                                                     \
5516: b05b:               IF FUNCTION.KEY% = ESC.KEY% THEN                         \
5517: b073:               BEGIN
5518: b073:                  CHAIN.TO.PROG$ = "PSB50"
5519: b08a:                  PSBCHN.MENCON  = "000000"
5520: b0a1:                  CALL CHAIN.TO.CALLER                                  ! 1.5 RC
5521: b0b1:               ENDIF                                                    \
5522: b0b1:               ELSE                                                     \
5523: b0b9:               IF FUNCTION.KEY% = HELP.KEY% THEN                        \
5524: b0d1:               BEGIN
5525: b0d1:                  CALL SCREEN.HELP(4)
5526: b0ef:                  CALL RESTORE.FIELDS.04                                ! 1.5 RC
5527: b0fb: 
5528: b0fb:                  CURSOR.POSITION% = S4.OPERATOR.ID%
5529: b111:                  CALL PUT.CURSOR.IN.FIELD                              ! 1.5 RC
5530: b11e: 
5531: b11e:                  CALL GET.INPUT                                        ! 1.5 RC
5532: b12d:               ENDIF                                                    \
5533: b12d:               ELSE                                                     \
5534: b135:               BEGIN
5535: b135:                  IF VALID.OPERATOR.ID THEN                             \
5536: b145:                     VALID.OPERATOR.ID.FOUND = TRUE                     \
5537: b15d:                  ELSE                                                  \
5538: b165:                  BEGIN
5539: b165:                     ! B058 Invalid operator ID
5540: b165:                     DISPLAY.MESSAGE.NUMBER% = 58
5541: b176:                     CALL DISPLAY.MESSAGE                               ! 1.5 RC
5542: b183:                     CALL RESUME.INPUT                                  ! 1.5 RC
5543: b190:                  ENDIF
5544: b198:               ENDIF
5545: b1a0:         WEND
5546: b1c7: 
5547: b1c7:         IF VALID.OPERATOR.ID.FOUND AND                                 \
5548: b1f2:            NOT EXIT.KEY.PRESSED(4) THEN                                \
5549: b1f2:         BEGIN
5550: b1f2:            CALL CLEAR.MESSAGE                                          ! 1.5 RC
5551: b1ff: 
5552: b1ff:            STRING.DATA$ = OPERATOR.ID$
5553: b21d:            CALL SET.FIELD                                              ! 1.5 RC
5554: b22a: 
5555: b22a:            IF FUNCTION.KEY% = TAB.KEY% OR                              \
5556: b277:               FUNCTION.KEY% = END.KEY% OR                              \
5557: b277:               FUNCTION.KEY% = ENTER.KEY% THEN                          \
5558: b277:            BEGIN
5559: b277:               IF VAL(OPERATOR.ID$) = 905 THEN                          \
5560: b2ac:               BEGIN
5561: b2ac:                  OLD.OPERATOR.ID$ = ""
5562: b2c3: 
5563: b2c3:                  GOSUB CLEAR.FIELDS.04
5564: b2d5: 
5565: b2d5:                  DISPLAY.MESSAGE.NUMBER% = 361
5566: b2e6:                  CALL DISPLAY.MESSAGE                                  ! 1.5 RC
5567: b2f6:               ENDIF                                                    \
5568: b2f6:               ELSE                                                     \
5569: b2fe:               IF VAL(OPERATOR.NUMBER$) = VAL(OPERATOR.ID$) THEN        \
5570: b337:               BEGIN
5571: b337:                  OLD.OPERATOR.ID$ = ""
5572: b34e: 
5573: b34e:                  GOSUB CLEAR.FIELDS.04
5574: b360: 
5575: b360:                  ! B360 An operator cannot change their own details
5576: b360:                  DISPLAY.MESSAGE.NUMBER% = 360
5577: b371:                  CALL DISPLAY.MESSAGE                                  ! 1.5 RC
5578: b381:               ENDIF                                                    \
5579: b381:               ELSE                                                     \
5580: b389:               IF OLD.OPERATOR.ID$ <> OPERATOR.ID$ THEN                 \
5581: b3b1:               BEGIN
5582: b3b1:                  AF.OPERATOR.NO$ = PACK$(RIGHT$(STRING$(8,"0") +       \
5583: b403:                                    OPERATOR.ID$,8))
5584: b403: 
5585: b403:                  IF READ.AF.ABREV = 0 THEN                             \
5586: b418:                  BEGIN
5587: b418:                     OLD.OPERATOR.ID$ = OPERATOR.ID$
5588: b436: 
5589: b436:                     CALL GET.OPERATOR.DETAILS                          ! 1.5 RC
5590: b443:                     CALL SET.OLD.OPAUD.DETAILS                         ! 1.5 RC
5591: b450:                     CALL RESTORE.FIELDS.04                             ! 1.5 RC
5592: b45c: 
5593: b45c:                     IF NOT VALID.AF.STAFF.NUM THEN \                   ! 1.6 RC
5594: b46c: \                       Staff number not set so allow user to change   ! 1.6 RC
5595: b46c:                         GOSUB GET.STAFF.NO.04 \                        ! 1.6 RC
5596: b480:                     ELSE \                                             ! 1.6 RC
5597: b488:                         IF NOT VALID.DDMCYY (AF.BIRTH.DATE$) THEN \    ! 1.8 RC
5598: b4a7: \                           Birth Date not set so allow user to change ! 1.6 RC
5599: b4a7:                             GOSUB GET.BIRTH.DATE.04 \                  ! 1.6 RC
5600: b4bb:                         ELSE \                                         ! 1.6 RC
5601: b4c3:                             GOSUB GET.RECEIPT.NAME.04                  ! 1.6 RC
5602: b4d7: 
5603: b4d7: !ajc                TILL.PTR% = 1
5604: b4d7: !ajc                GOSUB GET.TILL.MODEL.04
5605: b4d7:                  ENDIF                                                 \
5606: b4d7:                  ELSE                                                  \
5607: b4df:                  BEGIN
5608: b4df:                     OLD.OPERATOR.ID$ = ""
5609: b4f6: 
5610: b4f6:                     GOSUB CLEAR.FIELDS.04
5611: b508: 
5612: b508:                     ! B171 Operator ID not currently in use
5613: b508:                     DISPLAY.MESSAGE.NUMBER% = 171
5614: b519:                     CALL DISPLAY.MESSAGE                               ! 1.5 RC
5615: b526:                  ENDIF
5616: b531:               ENDIF                                                    \
5617: b531:               ELSE                                                     \
5618: b539:               IF OLD.OPERATOR.ID$ = OPERATOR.ID$ THEN                  \
5619: b561:               BEGIN
5620: b561:                  IF FUNCTION.KEY% = ENTER.KEY% THEN                    \
5621: b579:                  BEGIN
5622: b579:                     GOSUB CHECK.FIELDS.04
5623: b58e:                  ENDIF                                                 \
5624: b58e:                  ELSE                                                  \
5625: b596:                  IF FUNCTION.KEY% = TAB.KEY% THEN                      \
5626: b5b1:                  BEGIN
5627: b5b1: !ajc                TILL.PTR% = 1
5628: b5b1: !ajc                GOSUB GET.TILL.MODEL.04
5629: b5b1:                     IF NOT VALID.AF.STAFF.NUM THEN \                   ! 1.6 RC
5630: b5c1: \                       Staff number not set so allow user to change   ! 1.6 RC
5631: b5c1:                         GOSUB GET.STAFF.NO.04 \                        ! 1.6 RC
5632: b5d5:                     ELSE \                                             ! 1.6 RC
5633: b5dd:                         IF NOT VALID.DDMCYY (AF.BIRTH.DATE$) THEN \    ! 1.8 RC
5634: b5fc: \                           Birth Date not set so allow user to change ! 1.6 RC
5635: b5fc:                             GOSUB GET.BIRTH.DATE.04 \                  ! 1.6 RC
5636: b610:                         ELSE \                                         ! 1.6 RC
5637: b618:                             GOSUB GET.RECEIPT.NAME.04                  ! 1.6 RC
5638: b62c:                  ENDIF                                                 \
5639: b62c:                  ELSE                                                  \
5640: b634:                  IF FUNCTION.KEY% = END.KEY% THEN                      \
5641: b64c:                  BEGIN
5642: b64c:                     TILL.PTR% = MAX.TILL.PTR%
5643: b662:                     GOSUB GET.TILL.MODEL.04
5644: b674:                  ENDIF
5645: b67c:               ENDIF
5646: b684:            ENDIF                                                       \
5647: b684: 
5648: b68c:         ENDIF
5649: b694: 
5650: b694:         RETURN
5651: b6a4: 
5652: b6a4: 
5653: b6a4: \******************************************************************************
5654: b6a4: \***
5655: b6a4: \***    SUBROUTINE      :       GET.STAFF.NO.04
5656: b6a4: \***
5657: b6a4: \******************************************************************************
5658: b6a4: \***
5659: b6a4: \***    Input routine for the staff no on the add an operator screen
5660: b6a4: \***
5661: b6a4: \******************************************************************************
5662: b6a4: 
5663: b6a4:         GET.STAFF.NO.04: ! Entire procedure new for Rv 1.6             ! 1.6 RC
5664: b6b4:                          ! Modified from copy of GET.STAFF.NO.02       ! 1.6 RC
5665: b6b4: 
5666: b6b4:         CURSOR.POSITION% = S4.STAFF.NO%
5667: b6ca:         CALL PUT.CURSOR.IN.FIELD
5668: b6d7: 
5669: b6d7:         EXIT.KEY.PRESSED(4)  = FALSE
5670: b6ff:         VALID.STAFF.NO.FOUND = FALSE
5671: b715: 
5672: b715:         CALL GET.INPUT
5673: b722: 
5674: b722:         WHILE NOT (EXIT.KEY.PRESSED(4) OR \
5675: b72d:                   VALID.STAFF.NO.FOUND)
5676: b72d: 
5677: b72d:               STAFF.NO$ = RIGHT$(STRING$(8,"0") +             \
5678: b794:                                    STR$(VAL(F03.RETURNED.STRING$)),8)
5679: b794: 
5680: b794:               IF NOT (FUNCTION.KEY% = ENTER.KEY% OR \
5681: b84c:                  FUNCTION.KEY% = END.KEY% OR \
5682: b84c:                  FUNCTION.KEY% = TAB.KEY% OR \
5683: b84c:                  FUNCTION.KEY% = BTAB.KEY% OR \
5684: b84c:                  FUNCTION.KEY% = HOME.KEY% OR \
5685: b84c:                  FUNCTION.KEY% = HELP.KEY% OR \
5686: b84c:                  FUNCTION.KEY% = QUIT.KEY% OR \
5687: b84c:                  FUNCTION.KEY% = ESC.KEY%) THEN \
5688: b84c:               BEGIN
5689: b84c:                  DISPLAY.MESSAGE.NUMBER% = 1
5690: b85d:                  CALL DISPLAY.MESSAGE
5691: b86a:                  CALL RESUME.INPUT
5692: b87a:               ENDIF \
5693: b87a:               ELSE \
5694: b882:               IF FUNCTION.KEY% = QUIT.KEY% THEN \
5695: b89a:               BEGIN
5696: b89a:                  CALL GET.QUIT.CONFIRM
5697: b8aa:               ENDIF \
5698: b8aa:               ELSE \
5699: b8b2:               IF FUNCTION.KEY% = ESC.KEY% THEN \
5700: b8ca:               BEGIN
5701: b8ca:                  CHAIN.TO.PROG$ = "PSB50"
5702: b8e1:                  PSBCHN.MENCON  = "000000"
5703: b8f8:                  CALL CHAIN.TO.CALLER
5704: b908:               ENDIF \
5705: b908:               ELSE \
5706: b910:               IF FUNCTION.KEY% = HELP.KEY% THEN \
5707: b928:               BEGIN
5708: b928:                  CALL SCREEN.HELP(4)
5709: b946:                  CALL RESTORE.FIELDS.04
5710: b952: 
5711: b952:                  CURSOR.POSITION% = S4.STAFF.NO%
5712: b968:                  CALL PUT.CURSOR.IN.FIELD
5713: b975: 
5714: b975:                  CALL GET.INPUT
5715: b985:               ENDIF \
5716: b985:               ELSE \
5717: b98d:               BEGIN
5718: b98d:                  IF VALID.STAFF.NO(FALSE)                              \ 1.9 NM
5719: b9a8:                  THEN BEGIN                                            ! 1.9 NM
5720: b9a8:                     VALID.STAFF.NO.FOUND = TRUE \
5721: b9c0:                  ENDIF ELSE BEGIN                                      ! 1.9 NM
5722: b9c8:                     ! B221 Free format
5723: b9c8:                     DISPLAY.MESSAGE.NUMBER% = 221
5724: b9d9: 
5725: b9d9:                     !Commented as part of Core 2 Release               ! 1.9 NM
5726: b9d9:                     !DISPLAY.MESSAGE.TEXT$ =                           \ 1.9 NM
5727: b9d9:                     !"STAFF NUMBER MUST BE 0 OR GREATER"               ! 1.9 NM
5728: b9d9: 
5729: b9d9:                     CALL DISPLAY.MESSAGE
5730: b9e6:                     CALL RESUME.INPUT
5731: b9f3:                  ENDIF
5732: b9fb:               ENDIF
5733: ba03:         WEND
5734: ba2a: 
5735: ba2a:         IF VALID.STAFF.NO.FOUND AND \
5736: ba55:            NOT EXIT.KEY.PRESSED(4) THEN \
5737: ba55:         BEGIN
5738: ba55:            CALL CLEAR.MESSAGE
5739: ba62: 
5740: ba62:            STRING.DATA$ = STAFF.NO$
5741: ba80:            CALL SET.FIELD
5742: ba8d: 
5743: ba8d:            IF FUNCTION.KEY% = TAB.KEY% THEN \
5744: baa5:            BEGIN
5745: baa5:               IF NOT VALID.DDMCYY (AF.BIRTH.DATE$) THEN \              ! 1.8 RC
5746: bac4: \                 Birth Date not set so allow user to change           ! 1.6 RC
5747: bac4:                   GOSUB GET.BIRTH.DATE.04 \                            ! 1.6 RC
5748: bad8:               ELSE \                                                   ! 1.6 RC
5749: bae0:                   GOSUB GET.RECEIPT.NAME.04                            ! 1.6 RC
5750: baf5:            ENDIF \
5751: baf5:            ELSE \
5752: bafd:            IF (   FUNCTION.KEY% = HOME.KEY% \
5753: bb31:                OR FUNCTION.KEY% = BTAB.KEY%) THEN \
5754: bb31:            BEGIN
5755: bb31:               GOSUB GET.OPERATOR.ID.04
5756: bb46:            ENDIF \
5757: bb46:            ELSE \
5758: bb4e:            IF FUNCTION.KEY% = END.KEY% THEN \
5759: bb66:            BEGIN
5760: bb66:               TILL.PTR% = MAX.TILL.PTR%
5761: bb7c:               GOSUB GET.TILL.MODEL.04
5762: bb90:            ENDIF \
5763: bb90:            ELSE \
5764: bb98:            IF FUNCTION.KEY% = ENTER.KEY% THEN \
5765: bbb0:            BEGIN
5766: bbb0:               GOSUB CHECK.FIELDS.04
5767: bbc2:            ENDIF
5768: bbca:         ENDIF
5769: bbd2: 
5770: bbd2:         RETURN
5771: bbe2: 
5772: bbe2: 
5773: bbe2: \******************************************************************************
5774: bbe2: \***
5775: bbe2: \***    SUBROUTINE      :       GET.BIRTH.DATE.04
5776: bbe2: \***
5777: bbe2: \******************************************************************************
5778: bbe2: \***
5779: bbe2: \***    Input routine for the birth date on the add an operator screen
5780: bbe2: \***
5781: bbe2: \******************************************************************************
5782: bbe2: 
5783: bbe2:         GET.BIRTH.DATE.04: ! Entire procedure new for Rv 1.6           ! 1.6 RC
5784: bbf2:                            ! Modified from copy of GET.PASSWORD.02     ! 1.6 RC
5785: bbf2: 
5786: bbf2:         CURSOR.POSITION% = S4.BIRTH.DATE%
5787: bc08:         CALL PUT.CURSOR.IN.FIELD
5788: bc15: 
5789: bc15:         EXIT.KEY.PRESSED(4)  = FALSE
5790: bc3d:         VALID.BIRTH.DATE.FOUND = FALSE
5791: bc53: 
5792: bc53:         CALL GET.INPUT
5793: bc60: 
5794: bc60:         WHILE NOT (EXIT.KEY.PRESSED(4) OR  \
5795: bc6b:                   VALID.BIRTH.DATE.FOUND)
5796: bc6b: 
5797: bc6b:               BIRTH.DATE$ = F03.RETURNED.STRING$
5798: bc89: 
5799: bc89:               IF NOT (FUNCTION.KEY% = ENTER.KEY% OR \
5800: bd41:                  FUNCTION.KEY% = END.KEY% OR \
5801: bd41:                  FUNCTION.KEY% = TAB.KEY% OR \
5802: bd41:                  FUNCTION.KEY% = BTAB.KEY% OR \
5803: bd41:                  FUNCTION.KEY% = HOME.KEY% OR \
5804: bd41:                  FUNCTION.KEY% = HELP.KEY% OR \
5805: bd41:                  FUNCTION.KEY% = QUIT.KEY% OR \
5806: bd41:                  FUNCTION.KEY% = ESC.KEY%) THEN \
5807: bd41:               BEGIN
5808: bd41:                  DISPLAY.MESSAGE.NUMBER% = 1
5809: bd52:                  CALL DISPLAY.MESSAGE
5810: bd5f:                  CALL RESUME.INPUT
5811: bd6f:               ENDIF \
5812: bd6f:               ELSE \
5813: bd77:               IF FUNCTION.KEY% = QUIT.KEY% THEN \
5814: bd8f:               BEGIN
5815: bd8f:                  CALL GET.QUIT.CONFIRM
5816: bd9f:               ENDIF \
5817: bd9f:               ELSE \
5818: bda7:               IF FUNCTION.KEY% = ESC.KEY% THEN \
5819: bdbf:               BEGIN
5820: bdbf:                  CHAIN.TO.PROG$ = "PSB50"
5821: bdd6:                  PSBCHN.MENCON  = "000000"
5822: bded:                  CALL CHAIN.TO.CALLER
5823: bdfd:               ENDIF \
5824: bdfd:               ELSE \
5825: be05:               IF FUNCTION.KEY% = HELP.KEY% THEN \
5826: be1d:               BEGIN
5827: be1d:                  CALL SCREEN.HELP(4)
5828: be3b:                  CALL RESTORE.FIELDS.04
5829: be47:                  CURSOR.POSITION% = S4.BIRTH.DATE%
5830: be5d:                  CALL PUT.CURSOR.IN.FIELD
5831: be6a:                  CALL GET.INPUT
5832: be7a:               ENDIF \
5833: be7a:               ELSE \
5834: be82:               BEGIN
5835: be82:                   IF   BIRTH.DATE$ = "00000000" \                      ! 1.6 RC
5836: beb8:                     OR VALID.BIRTH.DATE THEN \ ! Validates BIRTH.DATE$   1.6 RC
5837: beb8: \                    Change Operator screen allows change of Birth Date  1.6 RC
5838: beb8: \                    but does not force it (so BIRTH.DATE$ zero allowed) 1.6 RC
5839: beb8:                      VALID.BIRTH.DATE.FOUND = TRUE \
5840: bed0:                   ELSE \
5841: bed8:                   BEGIN
5842: bed8: !                    DISPLAY.MESSAGE.NUMBER% set within VALID.BIRTH.DATE 1.6 RC
5843: bed8:                      CALL DISPLAY.MESSAGE
5844: bee5:                      CALL RESUME.INPUT
5845: bef2:                   ENDIF
5846: befa:               ENDIF
5847: bf02:         WEND
5848: bf29: 
5849: bf29:         IF VALID.BIRTH.DATE.FOUND AND \
5850: bf54:            NOT EXIT.KEY.PRESSED(4) THEN \
5851: bf54:         BEGIN
5852: bf54:            CALL CLEAR.MESSAGE
5853: bf61: 
5854: bf61:            STRING.DATA$ = BIRTH.DATE$
5855: bf7f:            CALL SET.FIELD
5856: bf8c: 
5857: bf8c:            IF FUNCTION.KEY% = TAB.KEY% THEN \
5858: bfa4:            BEGIN
5859: bfa4:               GOSUB GET.RECEIPT.NAME.04
5860: bfb9:            ENDIF \
5861: bfb9:            ELSE \
5862: bfc1:            IF FUNCTION.KEY% = HOME.KEY% THEN \
5863: bfd9:            BEGIN
5864: bfd9:               GOSUB GET.OPERATOR.ID.04
5865: bfee:            ENDIF \
5866: bfee:            ELSE \
5867: bff6:            IF FUNCTION.KEY% = BTAB.KEY% THEN \
5868: c00e:            BEGIN
5869: c00e:               IF NOT VALID.AF.STAFF.NUM THEN \                         ! 1.6 RC
5870: c01e: \                 Staff Number not set so allow user to change         ! 1.6 RC
5871: c01e:                   GOSUB GET.STAFF.NO.04 \                              ! 1.6 RC
5872: c032:               ELSE \                                                   ! 1.6 RC
5873: c03a:                   GOSUB GET.OPERATOR.ID.04 \                           ! 1.6 RC
5874: c04c:            ENDIF \
5875: c057:            ELSE \
5876: c05f:            IF FUNCTION.KEY% = END.KEY% THEN \
5877: c077:            BEGIN
5878: c077:               TILL.PTR% = MAX.TILL.PTR%
5879: c08d:               GOSUB GET.TILL.MODEL.04
5880: c0a1:            ENDIF \
5881: c0a1:            ELSE \
5882: c0a9:            IF FUNCTION.KEY% = ENTER.KEY% THEN \
5883: c0c1:            BEGIN
5884: c0c1:               GOSUB CHECK.FIELDS.04
5885: c0d3:            ENDIF
5886: c0db:         ENDIF
5887: c0e3: 
5888: c0e3:         RETURN
5889: c0f3: 
5890: c0f3: 
5891: c0f3: \******************************************************************************
5892: c0f3: \***                                                                          *
5893: c0f3: \***    SUBROUTINE      :       GET.RECEIPT.NAME.04                     ! AJC *
5894: c0f3: \***                                                                          *
5895: c0f3: \******************************************************************************
5896: c0f3: \***                                                                          *
5897: c0f3: \***    Input routine for the receipt name on the change operator screen! AJC *
5898: c0f3: \***                                                                          *
5899: c0f3: \******************************************************************************
5900: c0f3: 
5901: c0f3:         GET.RECEIPT.NAME.04:                                          ! AJC
5902: c103: 
5903: c103:         CURSOR.POSITION% = S4.RECEIPT.NAME%                           ! AJC
5904: c119:         CALL PUT.CURSOR.IN.FIELD                                       ! 1.5 RC
5905: c126: 
5906: c126:         EXIT.KEY.PRESSED(4)  = FALSE                                  ! AJC
5907: c14e:         VALID.RECEIPT.NAME.FOUND = FALSE                              ! AJC
5908: c164: 
5909: c164:         CALL GET.INPUT                                                 ! 1.5 RC
5910: c171: 
5911: c171:         WHILE NOT (EXIT.KEY.PRESSED(4) OR                            \! AJC
5912: c17c:                   VALID.RECEIPT.NAME.FOUND)                           ! AJC
5913: c17c: 
5914: c17c:               RECEIPT.NAME$ = F03.RETURNED.STRING$                    ! AJC
5915: c19a: 
5916: c19a:               IF NOT (FUNCTION.KEY% = ENTER.KEY% OR                  \! AJC
5917: c252:                  FUNCTION.KEY% = END.KEY% OR                         \! AJC
5918: c252:                  FUNCTION.KEY% = TAB.KEY% OR                         \! AJC
5919: c252:                  FUNCTION.KEY% = BTAB.KEY% OR                        \! AJC
5920: c252:                  FUNCTION.KEY% = HOME.KEY% OR                        \! AJC
5921: c252:                  FUNCTION.KEY% = HELP.KEY% OR                        \! AJC
5922: c252:                  FUNCTION.KEY% = QUIT.KEY% OR                        \! AJC
5923: c252:                  FUNCTION.KEY% = ESC.KEY%) THEN                      \! AJC
5924: c252:               BEGIN                                                   ! AJC
5925: c252:                  DISPLAY.MESSAGE.NUMBER% = 1                          ! AJC
5926: c263:                  CALL DISPLAY.MESSAGE                                  ! 1.5 RC
5927: c270:                  CALL RESUME.INPUT                                     ! 1.5 RC
5928: c280:               ENDIF                                                  \! AJC
5929: c280:               ELSE                                                   \! AJC
5930: c288:               IF FUNCTION.KEY% = QUIT.KEY% THEN                      \!
5931: c2a0:               BEGIN                                                   !
5932: c2a0:                  EXIT.KEY.PRESSED(S%) = TRUE                          !
5933: c2d0:               ENDIF                                                  \!
5934: c2d0:               ELSE                                                   \! AJC
5935: c2d8:               IF FUNCTION.KEY% = ESC.KEY% THEN                       \! AJC
5936: c2f0:               BEGIN                                                   ! AJC
5937: c2f0:                  CHAIN.TO.PROG$ = "PSB50"                             ! AJC
5938: c307:                  PSBCHN.MENCON  = "000000"                            ! AJC
5939: c31e:                  CALL CHAIN.TO.CALLER                                  ! 1.5 RC
5940: c32e:               ENDIF                                                  \! AJC
5941: c32e:               ELSE                                                   \! AJC
5942: c336:               IF FUNCTION.KEY% = HELP.KEY% THEN                      \! AJC
5943: c34e:               BEGIN                                                   ! AJC
5944: c34e:                  CALL SCREEN.HELP(4)                                  ! AJC
5945: c36c:                  CALL RESTORE.FIELDS.04                                ! 1.5 RC
5946: c378: 
5947: c378:                  CURSOR.POSITION% = S4.RECEIPT.NAME%                  ! AJC
5948: c38e:                  CALL PUT.CURSOR.IN.FIELD                              ! 1.5 RC
5949: c39b: 
5950: c39b:                  CALL GET.INPUT                                        ! 1.5 RC
5951: c3ab:               ENDIF                                                  \! AJC
5952: c3ab:               ELSE                                                   \! AJC
5953: c3b3:               BEGIN                                                   ! AJC
5954: c3b3:                  IF VALID.RECEIPT.NAME THEN                          \! AJC
5955: c3c3:                     VALID.RECEIPT.NAME.FOUND = TRUE                  \! AJC
5956: c3db:                  ELSE                                                \! AJC
5957: c3e3:                  BEGIN                                                ! AJC
5958: c3e3:                     ! B221 Free format                                ! AJC
5959: c3e3:                     DISPLAY.MESSAGE.NUMBER% = 221                     ! AJC
5960: c3f4:                     DISPLAY.MESSAGE.TEXT$ =                          \! AJC
5961: c40b:                     "NAME ON RECEIPT MUST BE ENTERED  "               ! AJC
5962: c40b:                     CALL DISPLAY.MESSAGE                               ! 1.5 RC
5963: c418:                     CALL RESUME.INPUT                                  ! 1.5 RC
5964: c425:                  ENDIF                                                ! AJC
5965: c42d:               ENDIF                                                   ! AJC
5966: c435:         WEND                                                          ! AJC
5967: c45c: 
5968: c45c:         IF VALID.RECEIPT.NAME.FOUND AND                              \! AJC
5969: c487:            NOT EXIT.KEY.PRESSED(4) THEN                              \! AJC
5970: c487:         BEGIN                                                         ! AJC
5971: c487:            CALL CLEAR.MESSAGE                                          ! 1.5 RC
5972: c494: 
5973: c494:            STRING.DATA$ = RECEIPT.NAME$                               ! AJC
5974: c4b2:            CALL SET.FIELD                                              ! 1.5 RC
5975: c4bf: 
5976: c4bf:            IF FUNCTION.KEY% = TAB.KEY% THEN                      \
5977: c4d7:            BEGIN
5978: c4d7: !              TILL.PTR% = 1                                          ! AJC
5979: c4d7: !              GOSUB GET.TILL.MODEL.04                                ! AJC
5980: c4d7:                GOSUB GET.GROUP.CODE.04                                ! AJC 1.4
5981: c4ec:            ENDIF                                                 \
5982: c4ec:            ELSE                                                  \
5983: c4f4:            IF FUNCTION.KEY% = END.KEY% THEN                      \
5984: c50c:            BEGIN
5985: c50c:               TILL.PTR% = MAX.TILL.PTR%
5986: c522:               GOSUB GET.TILL.MODEL.04
5987: c537:            ENDIF                                                 \
5988: c537:            ELSE                                                      \! AJC
5989: c53f:            IF FUNCTION.KEY% = HOME.KEY% THEN \                         ! 1.6 RC
5990: c557:            BEGIN                                                      ! AJC
5991: c557:               GOSUB GET.OPERATOR.ID.04                                ! AJC
5992: c56c:            ENDIF                                                     \! AJC
5993: c56c:            ELSE                                                      \! AJC
5994: c574:            IF FUNCTION.KEY% = BTAB.KEY% THEN \                         ! 1.6 RC
5995: c58f:            BEGIN                                                       ! 1.6 RC
5996: c58f:                IF NOT VALID.DDMCYY (AF.BIRTH.DATE$) THEN \             ! 1.8 RC
5997: c5ae: \                  Birth Date not set so allow user to change          ! 1.6 RC
5998: c5ae:                    GOSUB GET.BIRTH.DATE.04 \                           ! 1.6 RC
5999: c5c2:                ELSE \                                                  ! 1.6 RC
6000: c5ca:                    IF NOT VALID.AF.STAFF.NUM THEN \                    ! 1.6 RC
6001: c5da: \                      Staff number not set so allow user to change    ! 1.6 RC
6002: c5da:                        GOSUB GET.STAFF.NO.04 \                         ! 1.6 RC
6003: c5ee:                    ELSE \                                              ! 1.6 RC
6004: c5f6:                        GOSUB GET.OPERATOR.ID.04                        ! 1.6 RC
6005: c60a:            ENDIF \                                                     ! 1.6 RC
6006: c60a:            ELSE \                                                      ! 1.6 RC
6007: c612:            IF FUNCTION.KEY% = ENTER.KEY% THEN                        \! AJC
6008: c62a:            BEGIN                                                      ! AJC
6009: c62a:               GOSUB CHECK.FIELDS.04                                   ! AJC
6010: c63c:            ENDIF                                                      ! AJC
6011: c644:         ENDIF                                                         ! AJC
6012: c64c: 
6013: c64c:         RETURN
6014: c65c: 
6015: c65c: \******************************************************************************
6016: c65c: \***                                                                          *
6017: c65c: \***    SUBROUTINE      :       GET.GROUP.CODE.04                   ! AJC 1.4 *
6018: c65c: \***                                                                          *
6019: c65c: \******************************************************************************
6020: c65c: \***                                                                          *
6021: c65c: \***    Input routine for the dept no. on the change operator screen          *
6022: c65c: \***                                                                          *
6023: c65c: \******************************************************************************
6024: c65c: 
6025: c65c:         GET.GROUP.CODE.04:                                            ! AJC 1.4
6026: c66c: 
6027: c66c:         CURSOR.POSITION% = S4.GROUP.CODE%                             ! AJC 1.4
6028: c682:         CALL PUT.CURSOR.IN.FIELD                                       ! 1.5 RC
6029: c68f: 
6030: c68f:         EXIT.KEY.PRESSED(4)  = FALSE                                  ! AJC 1.4
6031: c6b7:         VALID.GROUP.CODE.FOUND = FALSE                                ! AJC 1.4
6032: c6cd: 
6033: c6cd:         CALL GET.INPUT                                                 ! 1.5 RC
6034: c6da: 
6035: c6da:         WHILE NOT (EXIT.KEY.PRESSED(4) OR                            \! AJC 1.4
6036: c6e5:                   VALID.GROUP.CODE.FOUND)                             ! AJC 1.4
6037: c6e5: 
6038: c6e5:               GROUP.CODE$ = RIGHT$(STRING$(2,"0") +                  \  AJC 1.4
6039: c74c:                                    STR$(VAL(F03.RETURNED.STRING$)),2) ! AJC 1.4
6040: c74c: 
6041: c74c:               IF NOT (FUNCTION.KEY% = ENTER.KEY% OR                  \! AJC 1.4
6042: c804:                  FUNCTION.KEY% = END.KEY% OR                         \! AJC 1.4
6043: c804:                  FUNCTION.KEY% = TAB.KEY% OR                         \! AJC 1.4
6044: c804:                  FUNCTION.KEY% = BTAB.KEY% OR                        \! AJC 1.4
6045: c804:                  FUNCTION.KEY% = HOME.KEY% OR                        \! AJC 1.4
6046: c804:                  FUNCTION.KEY% = HELP.KEY% OR                        \! AJC 1.4
6047: c804:                  FUNCTION.KEY% = QUIT.KEY% OR                        \! AJC 1.4
6048: c804:                  FUNCTION.KEY% = ESC.KEY%) THEN                      \! AJC 1.4
6049: c804:               BEGIN                                                   ! AJC 1.4
6050: c804:                  DISPLAY.MESSAGE.NUMBER% = 1                          ! AJC 1.4
6051: c815:                  CALL DISPLAY.MESSAGE                                  ! 1.5 RC
6052: c822:                  CALL RESUME.INPUT                                     ! 1.5 RC
6053: c832:               ENDIF                                                  \! AJC 1.4
6054: c832:               ELSE                                                   \! AJC 1.4
6055: c83a:               IF FUNCTION.KEY% = QUIT.KEY% THEN                      \!
6056: c852:               BEGIN                                                   !
6057: c852:                  EXIT.KEY.PRESSED(S%) = TRUE                          !
6058: c882:               ENDIF                                                  \!
6059: c882:               ELSE                                                   \! AJC 1.4
6060: c88a:               IF FUNCTION.KEY% = ESC.KEY% THEN                       \! AJC 1.4
6061: c8a2:               BEGIN                                                   ! AJC 1.4
6062: c8a2:                  CHAIN.TO.PROG$ = "PSB50"                             ! AJC 1.4
6063: c8b9:                  PSBCHN.MENCON  = "000000"                            ! AJC 1.4
6064: c8d0:                  CALL CHAIN.TO.CALLER                                  ! 1.5 RC
6065: c8e0:               ENDIF                                                  \! AJC 1.4
6066: c8e0:               ELSE                                                   \! AJC 1.4
6067: c8e8:               IF FUNCTION.KEY% = HELP.KEY% THEN                      \! AJC 1.4
6068: c900:               BEGIN                                                   ! AJC 1.4
6069: c900:                  CALL SCREEN.HELP(4)                                  ! AJC 1.4
6070: c91e:                  CALL RESTORE.FIELDS.04                                ! 1.5 RC
6071: c92a: 
6072: c92a:                  CURSOR.POSITION% = S4.GROUP.CODE%                    ! AJC 1.4
6073: c940:                  CALL PUT.CURSOR.IN.FIELD                              ! 1.5 RC
6074: c94d: 
6075: c94d:                  CALL GET.INPUT                                        ! 1.5 RC
6076: c95d:               ENDIF                                                  \! AJC 1.4
6077: c95d:               ELSE                                                   \! AJC 1.4
6078: c965:               BEGIN                                                   ! AJC 1.4
6079: c965:                  IF VALID.GROUP.CODE     THEN                        \! AJC 1.4
6080: c975:                     VALID.GROUP.CODE.FOUND = TRUE                    \! AJC 1.4
6081: c98d:                  ELSE                                                \! AJC 1.4
6082: c995:                  BEGIN                                                ! AJC 1.4
6083: c995:                     ! B221 Free format                                ! AJC 1.4
6084: c995:                     DISPLAY.MESSAGE.NUMBER% = 221                     ! AJC 1.4
6085: c9a6:                     DISPLAY.MESSAGE.TEXT$ =                          \! AJC 1.4
6086: c9bd:                     "GROUP CODE MUST BE ENTERED  "                    ! AJC 1.4
6087: c9bd:                     CALL DISPLAY.MESSAGE                               ! 1.5 RC
6088: c9ca:                     CALL RESUME.INPUT                                  ! 1.5 RC
6089: c9d7:                  ENDIF                                                ! AJC 1.4
6090: c9df:               ENDIF                                                   ! AJC 1.4
6091: c9e7:         WEND                                                          ! AJC 1.4
6092: ca0e: 
6093: ca0e:         IF VALID.GROUP.CODE.FOUND AND                                \! AJC 1.4
6094: ca39:            NOT EXIT.KEY.PRESSED(4) THEN                              \! AJC 1.4
6095: ca39:         BEGIN                                                         ! AJC 1.4
6096: ca39:            CALL CLEAR.MESSAGE                                          ! 1.5 RC
6097: ca46: 
6098: ca46:            STRING.DATA$ = GROUP.CODE$                                 ! AJC 1.4
6099: ca64:            CALL SET.FIELD                                              ! 1.5 RC
6100: ca71: 
6101: ca71:            IF FUNCTION.KEY% = TAB.KEY% THEN                      \
6102: ca89:            BEGIN
6103: ca89:               TILL.PTR% = 1
6104: ca9a:               GOSUB GET.TILL.MODEL.04
6105: caaf:            ENDIF                                                 \
6106: caaf:            ELSE                                                  \
6107: cab7:            IF FUNCTION.KEY% = END.KEY% THEN                      \
6108: cacf:            BEGIN
6109: cacf:               TILL.PTR% = MAX.TILL.PTR%
6110: cae5:               GOSUB GET.TILL.MODEL.04
6111: cafa:            ENDIF                                                     \
6112: cafa:            ELSE                                                      \! AJC 1.4
6113: cb02:            IF FUNCTION.KEY% = HOME.KEY% THEN                         \! AJC 1.4
6114: cb1a:            BEGIN                                                      ! AJC 1.4
6115: cb1a:               GOSUB GET.OPERATOR.ID.04                                ! AJC 1.4
6116: cb2e:            ENDIF                                                     \! AJC 1.4
6117: cb2e:            ELSE                                                      \! AJC 1.4
6118: cb36:            IF FUNCTION.KEY% = BTAB.KEY% THEN                         \! AJC 1.4
6119: cb4e:            BEGIN                                                      ! AJC 1.4
6120: cb4e:               GOSUB GET.RECEIPT.NAME.04                               ! AJC 1.4
6121: cb62:            ENDIF                                                     \! AJC 1.4
6122: cb62:            ELSE                                                      \! AJC 1.4
6123: cb6a:            IF FUNCTION.KEY% = ENTER.KEY% THEN                        \! AJC 1.4
6124: cb82:            BEGIN                                                      ! AJC 1.4
6125: cb82:               GOSUB CHECK.FIELDS.04                                   ! AJC 1.4
6126: cb94:            ENDIF                                                      ! AJC 1.4
6127: cb9c:         ENDIF                                                         ! AJC 1.4
6128: cba4: 
6129: cba4:         RETURN
6130: cbb4: 
6131: cbb4: \******************************************************************************
6132: cbb4: \***                                                                          *
6133: cbb4: \***    SUBROUTINE      :       GET.TILL.MODEL.04                             *
6134: cbb4: \***                                                                          *
6135: cbb4: \******************************************************************************
6136: cbb4: \***                                                                          *
6137: cbb4: \***    Input routine for the till model flags on the change operator screen  *
6138: cbb4: \***                                                                          *
6139: cbb4: \******************************************************************************
6140: cbb4: 
6141: cbb4:         GET.TILL.MODEL.04:
6142: cbc4: 
6143: cbc4:         CURSOR.POSITION% = S2.TILL.MODEL.FLAG%(TILL.PTR%)
6144: cbeb:         CALL PUT.CURSOR.IN.FIELD                                       ! 1.5 RC
6145: cbf8: 
6146: cbf8:         EXIT.KEY.PRESSED(4)    = FALSE
6147: cc20:         VALID.MODEL.FLAG.FOUND = FALSE
6148: cc36: 
6149: cc36:         CALL GET.INPUT                                                 ! 1.5 RC
6150: cc43: 
6151: cc43:         WHILE NOT (EXIT.KEY.PRESSED(4) OR                              \
6152: cc4e:                   VALID.MODEL.FLAG.FOUND)
6153: cc4e: 
6154: cc4e:               MODEL.FLAG$ = UCASE$(F03.RETURNED.STRING$)
6155: cc71: 
6156: cc71:               IF NOT (FUNCTION.KEY% = ENTER.KEY% OR                    \
6157: cd29:                  FUNCTION.KEY% = END.KEY% OR                           \
6158: cd29:                  FUNCTION.KEY% = TAB.KEY% OR                           \
6159: cd29:                  FUNCTION.KEY% = BTAB.KEY% OR                          \
6160: cd29:                  FUNCTION.KEY% = HOME.KEY% OR                          \
6161: cd29:                  FUNCTION.KEY% = HELP.KEY% OR                          \
6162: cd29:                  FUNCTION.KEY% = QUIT.KEY% OR                          \
6163: cd29:                  FUNCTION.KEY% = ESC.KEY%) THEN                        \
6164: cd29:               BEGIN
6165: cd29:                  DISPLAY.MESSAGE.NUMBER% = 1
6166: cd3a:                  CALL DISPLAY.MESSAGE                                  ! 1.5 RC
6167: cd47:                  CALL RESUME.INPUT                                     ! 1.5 RC
6168: cd57:               ENDIF                                                    \
6169: cd57:               ELSE                                                     \
6170: cd5f:               IF FUNCTION.KEY% = QUIT.KEY% THEN                        \
6171: cd77:               BEGIN
6172: cd77:                  CALL GET.QUIT.CONFIRM                                 ! 1.5 RC
6173: cd87:               ENDIF                                                    \
6174: cd87:               ELSE                                                     \
6175: cd8f:               IF FUNCTION.KEY% = ESC.KEY% THEN                         \
6176: cda7:               BEGIN
6177: cda7:                  CHAIN.TO.PROG$ = "PSB50"
6178: cdbe:                  PSBCHN.MENCON  = "000000"
6179: cdd5:                  CALL CHAIN.TO.CALLER                                  ! 1.5 RC
6180: cde5:               ENDIF                                                    \
6181: cde5:               ELSE                                                     \
6182: cded:               IF FUNCTION.KEY% = HELP.KEY% THEN                        \
6183: ce08:               BEGIN
6184: ce08:                  CALL SCREEN.HELP(4)
6185: ce26:                  CALL RESTORE.FIELDS.04                                ! 1.5 RC
6186: ce32: 
6187: ce32:                  CURSOR.POSITION% = S2.TILL.MODEL.FLAG%(TILL.PTR%)
6188: ce59:                  CALL PUT.CURSOR.IN.FIELD                              ! 1.5 RC
6189: ce66: 
6190: ce66:                  STRING.DATA$ = MODEL.FLAG$
6191: ce84:                  CALL SET.FIELD                                        ! 1.5 RC
6192: ce91: 
6193: ce91:                  CALL GET.INPUT                                        ! 1.5 RC
6194: cea0:               ENDIF                                                    \
6195: cea0:               ELSE                                                     \
6196: cea8:               BEGIN
6197: cea8:                  IF VALID.MODEL.FLAG THEN                              \
6198: ceb8:                     VALID.MODEL.FLAG.FOUND = TRUE                      \
6199: ced0:                  ELSE                                                  \
6200: ced8:                  BEGIN
6201: ced8:                     ! B359 Invalid model flag
6202: ced8:                     DISPLAY.MESSAGE.NUMBER% = 359
6203: cee9:                     CALL DISPLAY.MESSAGE                               ! 1.5 RC
6204: cef6:                     CALL RESUME.INPUT                                  ! 1.5 RC
6205: cf03:                  ENDIF
6206: cf0b:               ENDIF
6207: cf13:         WEND
6208: cf3a: 
6209: cf3a:         IF VALID.MODEL.FLAG.FOUND AND                                  \
6210: cf65:            NOT EXIT.KEY.PRESSED(4) THEN                                \
6211: cf65:         BEGIN
6212: cf65:            CALL CLEAR.MESSAGE                                          ! 1.5 RC
6213: cf72: 
6214: cf72:            TILL.MODEL.FLAG$(TILL.PTR%) = MODEL.FLAG$
6215: cfa1: 
6216: cfa1:            STRING.DATA$ = MODEL.FLAG$
6217: cfbf:            CALL SET.FIELD                                              ! 1.5 RC
6218: cfcc: 
6219: cfcc:            IF FUNCTION.KEY% = TAB.KEY% THEN                            \
6220: cfe4:            BEGIN
6221: cfe4:               IF TILL.PTR% = MAX.TILL.PTR% THEN                        \
6222: cffc:               BEGIN
6223: cffc:                  CTLR.PTR% = 1
6224: d00d:                  GOSUB GET.CTLR.MODEL.04
6225: d021:               ENDIF                                                    \
6226: d021:               ELSE                                                     \
6227: d029:               BEGIN
6228: d029:                  TILL.PTR% = TILL.PTR% + 1
6229: d038:                  GOTO GET.TILL.MODEL.04
6230: d043:               ENDIF
6231: d04e:            ENDIF                                                       \
6232: d04e:            ELSE                                                        \
6233: d056:            IF FUNCTION.KEY% = HOME.KEY% THEN                           \
6234: d06e:            BEGIN
6235: d06e:               IF TILL.PTR% = 1 THEN                                    \
6236: d080:               BEGIN
6237: d080:                  GOSUB GET.OPERATOR.ID.04
6238: d094:               ENDIF                                                    \
6239: d094:               ELSE                                                     \
6240: d09c:               BEGIN
6241: d09c:                  TILL.PTR% = 1
6242: d0ad:                  GOTO GET.TILL.MODEL.04
6243: d0b8:               ENDIF
6244: d0c3:            ENDIF                                                       \
6245: d0c3:            ELSE                                                        \
6246: d0cb:            IF FUNCTION.KEY% = BTAB.KEY% THEN                           \
6247: d0e3:            BEGIN
6248: d0e3:               IF TILL.PTR% = 1 THEN                                    \
6249: d0f5:               BEGIN
6250: d0f5: !                GOSUB GET.OPERATOR.ID.04
6251: d0f5: !AJC 1.4         GOSUB GET.RECEIPT.NAME.04
6252: d0f5:                  GOSUB GET.GROUP.CODE.04                               ! AJC 1.4
6253: d109:               ENDIF                                                    \
6254: d109:               ELSE                                                     \
6255: d111:               BEGIN
6256: d111:                  TILL.PTR% = TILL.PTR% - 1
6257: d120:                  GOTO GET.TILL.MODEL.04
6258: d12b:               ENDIF
6259: d136:            ENDIF                                                       \
6260: d136:            ELSE                                                        \
6261: d13e:            IF FUNCTION.KEY% = END.KEY% THEN                            \
6262: d159:            BEGIN
6263: d159:               IF TILL.PTR% = MAX.TILL.PTR% THEN                        \
6264: d171:               BEGIN
6265: d171:                  CTLR.PTR% = MAX.CTLR.PTR%
6266: d187:                  GOSUB GET.CTLR.MODEL.04
6267: d19b:               ENDIF                                                    \
6268: d19b:               ELSE                                                     \
6269: d1a3:               BEGIN
6270: d1a3:                  TILL.PTR% = MAX.TILL.PTR%
6271: d1b9:                  GOTO GET.TILL.MODEL.04
6272: d1c4:               ENDIF
6273: d1ce:            ENDIF                                                       \
6274: d1ce:            ELSE                                                        \
6275: d1d6:            IF FUNCTION.KEY% = ENTER.KEY% THEN                          \
6276: d1ee:            BEGIN
6277: d1ee:               GOSUB CHECK.FIELDS.04
6278: d200:            ENDIF
6279: d208:         ENDIF
6280: d210: 
6281: d210:         RETURN
6282: d220: 
6283: d220: \******************************************************************************
6284: d220: \***                                                                          *
6285: d220: \***    SUBROUTINE      :       GET.CTLR.MODEL.04                             *
6286: d220: \***                                                                          *
6287: d220: \******************************************************************************
6288: d220: \***                                                                          *
6289: d220: \***    Input routine for the ctlr model flags on the change operator screen  *
6290: d220: \***                                                                          *
6291: d220: \******************************************************************************
6292: d220: 
6293: d220:         GET.CTLR.MODEL.04:
6294: d230: 
6295: d230:         CURSOR.POSITION% = S2.CTLR.MODEL.FLAG%(CTLR.PTR%)
6296: d257:         CALL PUT.CURSOR.IN.FIELD                                       ! 1.5 RC
6297: d264: 
6298: d264:         EXIT.KEY.PRESSED(4)    = FALSE
6299: d28c:         VALID.MODEL.FLAG.FOUND = FALSE
6300: d2a2: 
6301: d2a2:         CALL GET.INPUT                                                 ! 1.5 RC
6302: d2af: 
6303: d2af:         WHILE NOT (EXIT.KEY.PRESSED(4) OR                              \
6304: d2ba:                   VALID.MODEL.FLAG.FOUND)
6305: d2ba: 
6306: d2ba:               MODEL.FLAG$ = UCASE$(F03.RETURNED.STRING$)
6307: d2dd: 
6308: d2dd:               IF NOT (FUNCTION.KEY% = ENTER.KEY% OR                    \
6309: d395:                  FUNCTION.KEY% = END.KEY% OR                           \
6310: d395:                  FUNCTION.KEY% = TAB.KEY% OR                           \
6311: d395:                  FUNCTION.KEY% = BTAB.KEY% OR                          \
6312: d395:                  FUNCTION.KEY% = HOME.KEY% OR                          \
6313: d395:                  FUNCTION.KEY% = HELP.KEY% OR                          \
6314: d395:                  FUNCTION.KEY% = QUIT.KEY% OR                          \
6315: d395:                  FUNCTION.KEY% = ESC.KEY%) THEN                        \
6316: d395:               BEGIN
6317: d395:                  DISPLAY.MESSAGE.NUMBER% = 1
6318: d3a6:                  CALL DISPLAY.MESSAGE                                  ! 1.5 RC
6319: d3b3:                  CALL RESUME.INPUT                                     ! 1.5 RC
6320: d3c3:               ENDIF                                                    \
6321: d3c3:               ELSE                                                     \
6322: d3cb:               IF FUNCTION.KEY% = QUIT.KEY% THEN                        \
6323: d3e3:               BEGIN
6324: d3e3:                  CALL GET.QUIT.CONFIRM                                 ! 1.5 RC
6325: d3f3:               ENDIF                                                    \
6326: d3f3:               ELSE                                                     \
6327: d3fb:               IF FUNCTION.KEY% = ESC.KEY% THEN                         \
6328: d413:               BEGIN
6329: d413:                  CHAIN.TO.PROG$ = "PSB50"
6330: d42a:                  PSBCHN.MENCON  = "000000"
6331: d441:                  CALL CHAIN.TO.CALLER                                  ! 1.5 RC
6332: d451:               ENDIF                                                    \
6333: d451:               ELSE                                                     \
6334: d459:               IF FUNCTION.KEY% = HELP.KEY% THEN                        \
6335: d474:               BEGIN
6336: d474:                  CALL SCREEN.HELP(4)
6337: d492:                  CALL RESTORE.FIELDS.04                                ! 1.5 RC
6338: d49e: 
6339: d49e:                  CURSOR.POSITION% = S2.CTLR.MODEL.FLAG%(CTLR.PTR%)
6340: d4c5:                  CALL PUT.CURSOR.IN.FIELD                              ! 1.5 RC
6341: d4d2: 
6342: d4d2:                  STRING.DATA$ = MODEL.FLAG$
6343: d4f0:                  CALL SET.FIELD                                        ! 1.5 RC
6344: d4fd: 
6345: d4fd:                  CALL GET.INPUT                                        ! 1.5 RC
6346: d50c:               ENDIF                                                    \
6347: d50c:               ELSE                                                     \
6348: d514:               BEGIN
6349: d514:                  IF VALID.MODEL.FLAG THEN                              \
6350: d524:                     VALID.MODEL.FLAG.FOUND = TRUE                      \
6351: d53c:                  ELSE                                                  \
6352: d544:                  BEGIN
6353: d544:                     ! B359 Invalid model flag
6354: d544:                     DISPLAY.MESSAGE.NUMBER% = 359
6355: d555:                     CALL DISPLAY.MESSAGE                               ! 1.5 RC
6356: d562:                     CALL RESUME.INPUT                                  ! 1.5 RC
6357: d56f:                  ENDIF
6358: d577:               ENDIF
6359: d57f:         WEND
6360: d5a6: 
6361: d5a6:         IF VALID.MODEL.FLAG.FOUND AND                                  \
6362: d5d1:            NOT EXIT.KEY.PRESSED(4) THEN                                \
6363: d5d1:         BEGIN
6364: d5d1:            CALL CLEAR.MESSAGE                                          ! 1.5 RC
6365: d5de: 
6366: d5de:            CTLR.MODEL.FLAG$(CTLR.PTR%) = MODEL.FLAG$
6367: d60d: 
6368: d60d:            STRING.DATA$ = MODEL.FLAG$
6369: d62b:            CALL SET.FIELD                                              ! 1.5 RC
6370: d638: 
6371: d638:            IF FUNCTION.KEY% = TAB.KEY% THEN                            \
6372: d650:            BEGIN
6373: d650:               IF CTLR.PTR% = MAX.CTLR.PTR% THEN                        \
6374: d668:               BEGIN
6375: d668:                  ! B001 Invalid key pressed
6376: d668:                  DISPLAY.MESSAGE.NUMBER% = 1
6377: d679:                  CALL DISPLAY.MESSAGE                                  ! 1.5 RC
6378: d686:                  GOTO GET.CTLR.MODEL.04
6379: d693:               ENDIF                                                    \
6380: d693:               ELSE                                                     \
6381: d69b:               BEGIN
6382: d69b:                  CTLR.PTR% = CTLR.PTR% + 1
6383: d6aa:                  GOTO GET.CTLR.MODEL.04
6384: d6b5:               ENDIF
6385: d6c0:            ENDIF                                                       \
6386: d6c0:            ELSE                                                        \
6387: d6c8:            IF FUNCTION.KEY% = HOME.KEY% THEN                           \
6388: d6e0:            BEGIN
6389: d6e0:               IF CTLR.PTR% = 1 THEN                                    \
6390: d6f2:               BEGIN
6391: d6f2:                  TILL.PTR% = 1
6392: d703:                  GOSUB GET.TILL.MODEL.04
6393: d717:               ENDIF                                                    \
6394: d717:               ELSE                                                     \
6395: d71f:               BEGIN
6396: d71f:                  CTLR.PTR% = 1
6397: d730:                  GOTO GET.CTLR.MODEL.04
6398: d73b:               ENDIF
6399: d746:            ENDIF                                                       \
6400: d746:            ELSE                                                        \
6401: d74e:            IF FUNCTION.KEY% = BTAB.KEY% THEN                           \
6402: d766:            BEGIN
6403: d766:               IF CTLR.PTR% = 1 THEN                                    \
6404: d778:               BEGIN
6405: d778:                  TILL.PTR% = MAX.TILL.PTR%
6406: d78e:                  GOSUB GET.TILL.MODEL.04
6407: d7a2:               ENDIF                                                    \
6408: d7a2:               ELSE                                                     \
6409: d7aa:               BEGIN
6410: d7aa:                  CTLR.PTR% = CTLR.PTR% - 1
6411: d7b9:                  GOTO GET.CTLR.MODEL.04
6412: d7c4:               ENDIF
6413: d7cf:            ENDIF                                                       \
6414: d7cf:            ELSE                                                        \
6415: d7d7:            IF FUNCTION.KEY% = END.KEY% THEN                            \
6416: d7f2:            BEGIN
6417: d7f2:               IF CTLR.PTR% = MAX.CTLR.PTR% THEN                        \
6418: d80a:               BEGIN
6419: d80a:                  ! B001 Invalid key pressed
6420: d80a:                  DISPLAY.MESSAGE.NUMBER% = 1
6421: d81b:                  CALL DISPLAY.MESSAGE                                  ! 1.5 RC
6422: d828:                  GOTO GET.CTLR.MODEL.04
6423: d835:               ENDIF                                                    \
6424: d835:               ELSE                                                     \
6425: d83d:               BEGIN
6426: d83d:                  CTLR.PTR% = MAX.CTLR.PTR%
6427: d853:                  GOTO GET.CTLR.MODEL.04
6428: d85e:               ENDIF
6429: d868:            ENDIF                                                       \
6430: d868:            ELSE                                                        \
6431: d870:            IF FUNCTION.KEY% = ENTER.KEY% THEN                          \
6432: d888:            BEGIN
6433: d888:               GOSUB CHECK.FIELDS.04
6434: d89a:            ENDIF
6435: d8a2:         ENDIF
6436: d8aa: 
6437: d8aa:         RETURN
6438: d8ba: 
6439: d8ba: \******************************************************************************
6440: d8ba: \***                                                                          *
6441: d8ba: \***    SUBROUTINE      :       CHECK.FIELDS.04                               *
6442: d8ba: \***                                                                          *
6443: d8ba: \******************************************************************************
6444: d8ba: \***                                                                          *
6445: d8ba: \***    Validate all input fields for the change operator screen              *
6446: d8ba: \***                                                                          *
6447: d8ba: \******************************************************************************
6448: d8ba: 
6449: d8ba:         CHECK.FIELDS.04:
6450: d8ca: 
6451: d8ca:         IF NOT VALID.OPERATOR.ID THEN                                  \
6452: d8da:         BEGIN
6453: d8da:            ! B058 Invalid operator ID
6454: d8da:            DISPLAY.MESSAGE.NUMBER% = 58
6455: d8eb:            CALL DISPLAY.MESSAGE                                        ! 1.5 RC
6456: d8f8: 
6457: d8f8:            GOSUB GET.OPERATOR.ID.04
6458: d90a: 
6459: d90a:            GOTO CHECK.FIELDS.04.FAILED
6460: d915:         ENDIF
6461: d91d: 
6462: d91d:         IF NOT VALID.STAFF.NO(FALSE) THEN \                            ! 1.9 NM
6463: d938:         BEGIN                                                          ! 1.6 RC
6464: d938:            ! B332 Free format                                          ! 1.6 RC
6465: d938:            DISPLAY.MESSAGE.NUMBER% = 221                               ! 1.6 RC
6466: d949: 
6467: d949:            !Commented as part of Core 2 Release                        ! 1.9 NM
6468: d949:            !DISPLAY.MESSAGE.TEXT$ = \                                  ! 1.9 NM
6469: d949:            !  "STAFF NUMBER MUST BE 0 OR GREATER"                      ! 1.9 NM
6470: d949: 
6471: d949:            CALL DISPLAY.MESSAGE                                        ! 1.6 RC
6472: d956: 
6473: d956:            GOSUB GET.STAFF.NO.04                                       ! 1.6 RC
6474: d968: 
6475: d968:            GOTO CHECK.FIELDS.04.FAILED                                 ! !.6 RC
6476: d973:         ENDIF                                                          ! !.6 RC
6477: d97b: 
6478: d97b:         IF    (NOT VALID.BIRTH.DATE) \           ! Brackets not needed ! 1.6 RC
6479: d9b1:           AND (BIRTH.DATE$ <> "00000000") THEN \ ! added for clarity   ! 1.6 RC
6480: d9b1: \         Change Operator screen allows change of Birth Date           ! 1.6 RC
6481: d9b1: \         but does not force it (so BIRTH.DATE$ zero allowed)          ! 1.6 RC
6482: d9b1:         BEGIN                                                          ! 1.6 RC
6483: d9b1: !          DISPLAY.MESSAGE.NUMBER% set within VALID.BIRTH.DATE         ! 1.6 RC
6484: d9b1:            CALL DISPLAY.MESSAGE                                        ! 1.6 RC
6485: d9be:            GOSUB GET.BIRTH.DATE.04                                     ! 1.6 RC
6486: d9d0:            GOTO CHECK.FIELDS.04.FAILED                                 ! 1.6 RC
6487: d9db:         ENDIF                                                          ! 1.6 RC
6488: d9e3: 
6489: d9e3:         I% = 1
6490: d9f4: 
6491: d9f4:         WHILE I% <= MAX.TILL.PTR%
6492: d9ff: 
6493: d9ff:               MODEL.FLAG$ = TILL.MODEL.FLAG$(I%)
6494: da2e: 
6495: da2e:               IF NOT VALID.MODEL.FLAG THEN                             \
6496: da3e:               BEGIN
6497: da3e:                  ! B359 Invalid model flag
6498: da3e:                  DISPLAY.MESSAGE.NUMBER% = 359
6499: da4f:                  DISPLAY.MESSAGE.TEXT$   = "Invalid model flag"
6500: da66:                  CALL DISPLAY.MESSAGE                                  ! 1.5 RC
6501: da73: 
6502: da73:                  TILL.PTR% = I%
6503: da89:                  GOSUB GET.TILL.MODEL.04
6504: da9b: 
6505: da9b:                  GOTO CHECK.FIELDS.04.FAILED
6506: daa6:               ENDIF
6507: daae: 
6508: daae:               I% = I% + 1
6509: dabd: 
6510: dabd:         WEND
6511: dad8: 
6512: dad8:         I% = 1
6513: dae9: 
6514: dae9:         WHILE I% <= MAX.CTLR.PTR%
6515: daf4: 
6516: daf4:               MODEL.FLAG$ = CTLR.MODEL.FLAG$(I%)
6517: db23: 
6518: db23:               IF NOT VALID.MODEL.FLAG THEN                             \
6519: db33:               BEGIN
6520: db33:                  ! B359 Invalid model flag
6521: db33:                  DISPLAY.MESSAGE.NUMBER% = 359
6522: db44:                  CALL DISPLAY.MESSAGE                                  ! 1.5 RC
6523: db51: 
6524: db51:                  CTLR.PTR% = I%
6525: db67:                  GOSUB GET.CTLR.MODEL.04
6526: db79: 
6527: db79:                  GOTO CHECK.FIELDS.04.FAILED
6528: db83:               ENDIF
6529: db8b: 
6530: db8b:               I% = I% + 1
6531: db9a: 
6532: db9a:         WEND
6533: dbb5: 
6534: dbb5:         GOSUB CHANGE.OPERATOR.DETAILS
6535: dbc7: 
6536: dbc7:         CHECK.FIELDS.04.FAILED:
6537: dbd7: 
6538: dbd7:         RETURN
6539: dbe7: 
6540: dbe7: \******************************************************************************
6541: dbe7: \***                                                                          *
6542: dbe7: \***    SUBROUTINE      :       CHANGE.OPERATOR.DETAILS                       *
6543: dbe7: \***                                                                          *
6544: dbe7: \******************************************************************************
6545: dbe7: \***                                                                          *
6546: dbe7: \***    Change an operator on the authorisation files                         *
6547: dbe7: \***                                                                          *
6548: dbe7: \******************************************************************************
6549: dbe7: 
6550: dbe7:         CHANGE.OPERATOR.DETAILS:
6551: dbf7: 
6552: dbf7:         CSOUF.OPERATION$ = "CHANGE"
6553: dc0e: 
6554: dc0e:         CALL REVEAL.CONFIRM.MESSAGE                                    ! 1.5 RC
6555: dc1b: 
6556: dc1b:         CALL GET.CONFIRM                                               ! 1.5 RC
6557: dc28: 
6558: dc28:         CALL HIDE.CONFIRM.MESSAGE                                      ! 1.5 RC
6559: dc35: 
6560: dc35:         IF CONFIRM$ = "Y" THEN                                         \
6561: dc53:         BEGIN
6562: dc53:            CALL WAIT.MESSAGE                                           ! 1.5 RC
6563: dc60:            GOSUB UPDATE.AUTH.RECORDS
6564: dc72:         ENDIF
6565: dc7a: 
6566: dc7a:         RETURN
6567: dc8a: 
6568: dc8a: \******************************************************************************
6569: dc8a: \***                                                                          *
6570: dc8a: \***    SUBROUTINE      :       PROCESS.SCREEN.05                             *
6571: dc8a: \***                                                                          *
6572: dc8a: \******************************************************************************
6573: dc8a: \***                                                                          *
6574: dc8a: \***    Control routine for the set operator password screen                  *
6575: dc8a: \***                                                                          *
6576: dc8a: \******************************************************************************
6577: dc8a: 
6578: dc8a:         PROCESS.SCREEN.05:
6579: dc9a: 
6580: dc9a:         S% = 5
6581: dcab: 
6582: dcab:         CALL DISPLAY.SCREEN(5)
6583: dcc9: 
6584: dcc9:         OLD.OPERATOR.ID$   = ""
6585: dce0:         OPERATOR.ID$       = ""
6586: dcf7:         OPERATOR.NAME$     = ""
6587: dd0e:         OPERATOR.PASSWORD$ = ""
6588: dd25:         STAFF.NO$          = ""
6589: dd3c:         RECEIPT.NAME$      = ""                                       ! AJC
6590: dd53:         BIRTH.DATE$        = ""                                        ! 1.6 RC
6591: dd6a:         GROUP.CODE$        = ""                                       ! AJC 1.4
6592: dd81:         EMPLOYEE.FLG$      = ""
6593: dd98:         MODEL.FLAG$        = ""
6594: ddaf:         CONFIRM$           = "N"
6595: ddc6: 
6596: ddc6:         CALL RESET.MODEL.FLAGS                                         ! 1.5 RC
6597: ddd3: 
6598: ddd3:         CALL RESTORE.FIELDS.05                                         ! 1.5 RC
6599: dddf: 
6600: dddf:         EXIT.KEY.PRESSED(5) = FALSE
6601: de07: 
6602: de07:         WHILE NOT EXIT.KEY.PRESSED(5)
6603: de11:               GOSUB GET.OPERATOR.ID.05
6604: de23:         WEND
6605: de41: 
6606: de41:         RETURN
6607: de51: 
6608: de51: 
6609: de51: \******************************************************************************
6610: de51: \***                                                                          *
6611: de51: \***    SUBROUTINE      :       CLEAR.FIELDS.05                               *
6612: de51: \***                                                                          *
6613: de51: \******************************************************************************
6614: de51: \***                                                                          *
6615: de51: \***    Clear all fields for the set operator password screen                 *
6616: de51: \***                                                                          *
6617: de51: \******************************************************************************
6618: de51: 
6619: de51:         CLEAR.FIELDS.05:
6620: de61: 
6621: de61:         CURSOR.STATE$ = CURSOR.OFF$
6622: de7f:         CALL SET.CURSOR.STATE                                          ! 1.5 RC
6623: de8c: 
6624: de8c:         IF OPERATOR.NAME$ <> "" THEN                                   \
6625: deaa:         BEGIN
6626: deaa:            CURSOR.POSITION% = S5.NAME%
6627: dec0:            CALL PUT.CURSOR.IN.FIELD                                    ! 1.5 RC
6628: decd: 
6629: decd:            STRING.DATA$ = ""
6630: dee4:            CALL SET.FIELD                                              ! 1.5 RC
6631: def1:         ENDIF
6632: def9: 
6633: def9:         IF OPERATOR.PASSWORD$ <> "" THEN \                             ! 1.6 RC
6634: df17:         BEGIN                                                          ! 1.6 RC
6635: df17:            CURSOR.POSITION% = S5.PASSWORD%                             ! 1.6 RC
6636: df2d:            CALL PUT.CURSOR.IN.FIELD                                    ! 1.6 RC
6637: df3a:            STRING.DATA$ = ""                                           ! 1.6 RC
6638: df51:            CALL SET.FIELD                                              ! 1.6 RC
6639: df5e:         ENDIF                                                          ! 1.6 RC
6640: df66: 
6641: df66:         IF STAFF.NO$ <> "" THEN BEGIN
6642: df84:            CURSOR.POSITION% = S5.STAFF.NO%
6643: df9a:            CALL PUT.CURSOR.IN.FIELD                                    ! 1.5 RC
6644: dfa7: 
6645: dfa7:            STRING.DATA$ = ""
6646: dfbe:            CALL SET.FIELD                                              ! 1.5 RC
6647: dfcb:         ENDIF
6648: dfd3: 
6649: dfd3:         IF BIRTH.DATE$ <> "" THEN BEGIN                                ! 1.6 RC
6650: dff1:            CURSOR.POSITION% = S5.BIRTH.DATE%                           ! 1.6 RC
6651: e007:            CALL PUT.CURSOR.IN.FIELD                                    ! 1.6 RC
6652: e014:            STRING.DATA$ = ""                                           ! 1.6 RC
6653: e02b:            CALL SET.FIELD                                              ! 1.5 RC
6654: e038:         ENDIF                                                          ! 1.6 RC
6655: e040: 
6656: e040:         IF RECEIPT.NAME$ <> "" THEN                                   \ AJC
6657: e05e:         BEGIN                                                         ! AJC
6658: e05e:            CURSOR.POSITION% = S5.RECEIPT.NAME%                        ! AJC
6659: e074:            CALL PUT.CURSOR.IN.FIELD                                    ! 1.5 RC
6660: e081: 
6661: e081:            STRING.DATA$ = ""                                          ! AJC
6662: e098:            CALL SET.FIELD                                              ! 1.5 RC
6663: e0a5:         ENDIF                                                         ! AJC
6664: e0ad: 
6665: e0ad:         IF GROUP.CODE$ <> "" THEN                                     \ AJC 1.4
6666: e0cb:         BEGIN                                                         ! AJC 1.4
6667: e0cb:            CURSOR.POSITION% = S5.GROUP.CODE%                          ! AJC 1.4
6668: e0e1:            CALL PUT.CURSOR.IN.FIELD                                    ! 1.5 RC
6669: e0ee: 
6670: e0ee:            STRING.DATA$ = ""                                          ! AJC 1.4
6671: e105:            CALL SET.FIELD                                              ! 1.5 RC
6672: e112:         ENDIF                                                         ! AJC 1.4
6673: e11a: 
6674: e11a:         IF EMPLOYEE.FLG$ <> "" THEN BEGIN
6675: e138:            CURSOR.POSITION% = S5.EMPLOYEE.FLG%
6676: e14e:            CALL PUT.CURSOR.IN.FIELD                                    ! 1.5 RC
6677: e15b: 
6678: e15b:            STRING.DATA$ = ""
6679: e172:            CALL SET.FIELD                                              ! 1.5 RC
6680: e17f:         ENDIF
6681: e187: 
6682: e187:         MODEL.FLAG$ = ""
6683: e19e: 
6684: e19e:         CALL CLEAR.MODEL.FLAGS                                         ! 1.5 RC
6685: e1ab: 
6686: e1ab:         CURSOR.STATE$ = CURSOR.ON$
6687: e1c9:         CALL SET.CURSOR.STATE                                          ! 1.5 RC
6688: e1d6: 
6689: e1d6:         RETURN
6690: e1e6: 
6691: e1e6: \******************************************************************************
6692: e1e6: \***                                                                          *
6693: e1e6: \***    SUBROUTINE      :       GET.OPERATOR.ID.05                            *
6694: e1e6: \***                                                                          *
6695: e1e6: \******************************************************************************
6696: e1e6: \***                                                                          *
6697: e1e6: \***    Input routine for the operator ID on the set password screen          *
6698: e1e6: \***                                                                          *
6699: e1e6: \******************************************************************************
6700: e1e6: 
6701: e1e6:         GET.OPERATOR.ID.05:
6702: e1f6: 
6703: e1f6:         CURSOR.POSITION% = S5.OPERATOR.ID%
6704: e20c:         CALL PUT.CURSOR.IN.FIELD                                       ! 1.5 RC
6705: e219: 
6706: e219:         EXIT.KEY.PRESSED(5)     = FALSE
6707: e241:         VALID.OPERATOR.ID.FOUND = FALSE
6708: e257: 
6709: e257:         CALL GET.INPUT                                                 ! 1.5 RC
6710: e264: 
6711: e264:         WHILE NOT (EXIT.KEY.PRESSED(5) OR                              \
6712: e26f:                   VALID.OPERATOR.ID.FOUND)
6713: e26f: 
6714: e26f:               OPERATOR.ID$ = RIGHT$(STRING$(3,"0") +                   \
6715: e2d6:                              STR$(VAL(F03.RETURNED.STRING$)),3)
6716: e2d6: 
6717: e2d6:               IF NOT (FUNCTION.KEY% = ENTER.KEY% OR                    \
6718: e362:                  FUNCTION.KEY% = TAB.KEY% OR                           \
6719: e362:                  FUNCTION.KEY% = END.KEY% OR                           \
6720: e362:                  FUNCTION.KEY% = HELP.KEY% OR                          \
6721: e362:                  FUNCTION.KEY% = QUIT.KEY% OR                          \
6722: e362:                  FUNCTION.KEY% = ESC.KEY%) THEN                        \
6723: e362:               BEGIN
6724: e362:                  DISPLAY.MESSAGE.NUMBER% = 1
6725: e373:                  CALL DISPLAY.MESSAGE                                  ! 1.5 RC
6726: e380:                  CALL RESUME.INPUT                                     ! 1.5 RC
6727: e390:               ENDIF                                                    \
6728: e390:               ELSE                                                     \
6729: e398:               IF FUNCTION.KEY% = QUIT.KEY% THEN                        \
6730: e3b0:               BEGIN
6731: e3b0:                  EXIT.KEY.PRESSED(S%) = TRUE
6732: e3e0:               ENDIF                                                    \
6733: e3e0:               ELSE                                                     \
6734: e3e8:               IF FUNCTION.KEY% = ESC.KEY% THEN                         \
6735: e400:               BEGIN
6736: e400:                  CHAIN.TO.PROG$ = "PSB50"
6737: e417:                  PSBCHN.MENCON  = "000000"
6738: e42e:                  CALL CHAIN.TO.CALLER                                  ! 1.5 RC
6739: e43e:               ENDIF                                                    \
6740: e43e:               ELSE                                                     \
6741: e446:               IF FUNCTION.KEY% = HELP.KEY% THEN                        \
6742: e45e:               BEGIN
6743: e45e:                  CALL SCREEN.HELP(5)
6744: e47c:                  CALL RESTORE.FIELDS.05                                ! 1.5 RC
6745: e488: 
6746: e488:                  CURSOR.POSITION% = S5.OPERATOR.ID%
6747: e49e:                  CALL PUT.CURSOR.IN.FIELD                              ! 1.5 RC
6748: e4ab: 
6749: e4ab:                  CALL GET.INPUT                                        ! 1.5 RC
6750: e4ba:               ENDIF                                                    \
6751: e4ba:               ELSE                                                     \
6752: e4c2:               BEGIN
6753: e4c2:                  IF VALID.OPERATOR.ID THEN                             \
6754: e4d2:                     VALID.OPERATOR.ID.FOUND = TRUE                     \
6755: e4ea:                  ELSE                                                  \
6756: e4f2:                  BEGIN
6757: e4f2:                     ! B058 Invalid operator ID
6758: e4f2:                     DISPLAY.MESSAGE.NUMBER% = 58
6759: e503:                     CALL DISPLAY.MESSAGE                               ! 1.5 RC
6760: e510:                     CALL RESUME.INPUT                                  ! 1.5 RC
6761: e51d:                  ENDIF
6762: e525:               ENDIF
6763: e52d:         WEND
6764: e554: 
6765: e554:         IF VALID.OPERATOR.ID.FOUND AND                                 \
6766: e57f:            NOT EXIT.KEY.PRESSED(5) THEN                                \
6767: e57f:         BEGIN
6768: e57f:            CALL CLEAR.MESSAGE                                          ! 1.5 RC
6769: e58c: 
6770: e58c:            STRING.DATA$ = OPERATOR.ID$
6771: e5aa:            CALL SET.FIELD                                              ! 1.5 RC
6772: e5b7: 
6773: e5b7:            IF FUNCTION.KEY% = TAB.KEY% OR                              \
6774: e604:               FUNCTION.KEY% = END.KEY% OR                              \
6775: e604:               FUNCTION.KEY% = ENTER.KEY% THEN                          \
6776: e604:            BEGIN
6777: e604: 
6778: e604:               IF OLD.OPERATOR.ID$ <> OPERATOR.ID$ THEN                 \
6779: e62c:               BEGIN
6780: e62c:                  AF.OPERATOR.NO$ = PACK$(RIGHT$(STRING$(8,"0") +       \
6781: e67e:                                    OPERATOR.ID$,8))
6782: e67e: 
6783: e67e:                  IF READ.AF.ABREV = 0 THEN                             \
6784: e693:                  BEGIN
6785: e693:                     OLD.OPERATOR.ID$ = OPERATOR.ID$
6786: e6b1:                     OLD.PASSWORD$    = RIGHT$(STRING$(3,"0") +         \
6787: e70e:                                        UNPACK$(AF.PASSWORD$),3)
6788: e70e: 
6789: e70e:                     CALL GET.OPERATOR.DETAILS                          ! 1.5 RC
6790: e71b:                     CALL SET.OLD.OPAUD.DETAILS                         ! 1.5 RC
6791: e728: 
6792: e728:                     OPERATOR.PASSWORD$ = ""
6793: e73f: 
6794: e73f:                     CALL RESTORE.FIELDS.05                             ! 1.5 RC
6795: e74b: 
6796: e74b:                     GOSUB GET.PASSWORD.05
6797: e75f:                  ENDIF                                                 \
6798: e75f:                  ELSE                                                  \
6799: e767:                  BEGIN
6800: e767:                     OLD.OPERATOR.ID$ = ""
6801: e77e: 
6802: e77e:                     GOSUB CLEAR.FIELDS.05
6803: e790: 
6804: e790:                     ! B171 Operator ID not currently in use
6805: e790:                     DISPLAY.MESSAGE.NUMBER% = 171
6806: e7a1:                     CALL DISPLAY.MESSAGE                               ! 1.5 RC
6807: e7ae:                  ENDIF
6808: e7b9:               ENDIF                                                    \
6809: e7b9:               ELSE                                                     \
6810: e7c1:               IF OLD.OPERATOR.ID$ = OPERATOR.ID$ THEN                  \
6811: e7e9:               BEGIN
6812: e7e9:                  IF FUNCTION.KEY% = ENTER.KEY% THEN                    \
6813: e801:                  BEGIN
6814: e801:                     GOSUB CHECK.FIELDS.05
6815: e815:                  ENDIF                                                 \
6816: e815:                  ELSE                                                  \
6817: e81d:                  IF FUNCTION.KEY% = TAB.KEY% OR                        \
6818: e851:                     FUNCTION.KEY% = END.KEY% THEN                      \
6819: e851:                  BEGIN
6820: e851:                     GOSUB GET.PASSWORD.05
6821: e863:                  ENDIF
6822: e86b:               ENDIF
6823: e873:            ENDIF                                                       \
6824: e873:         ENDIF
6825: e87b: 
6826: e87b:         RETURN
6827: e88b: 
6828: e88b: \******************************************************************************
6829: e88b: \***                                                                          *
6830: e88b: \***    SUBROUTINE      :       GET.PASSWORD.05                               *
6831: e88b: \***                                                                          *
6832: e88b: \******************************************************************************
6833: e88b: \***                                                                          *
6834: e88b: \***    Input routine for the password on the set password screen             *
6835: e88b: \***                                                                          *
6836: e88b: \******************************************************************************
6837: e88b: 
6838: e88b:         GET.PASSWORD.05:
6839: e89b: 
6840: e89b:         CURSOR.POSITION% = S5.PASSWORD%
6841: e8b1:         CALL PUT.CURSOR.IN.FIELD                                       ! 1.5 RC
6842: e8be: 
6843: e8be:         EXIT.KEY.PRESSED(5)  = FALSE
6844: e8e6:         VALID.PASSWORD.FOUND = FALSE
6845: e8fc: 
6846: e8fc:         CALL GET.INPUT                                                 ! 1.5 RC
6847: e909: 
6848: e909:         WHILE NOT (EXIT.KEY.PRESSED(5) OR                              \
6849: e914:                   VALID.PASSWORD.FOUND)
6850: e914: 
6851: e914:               OPERATOR.PASSWORD$ = RIGHT$(STRING$(3,"0") +             \
6852: e97b:                                    STR$(VAL(F03.RETURNED.STRING$)),3)
6853: e97b: 
6854: e97b:               IF NOT (FUNCTION.KEY% = ENTER.KEY% OR                    \
6855: ea07:                  FUNCTION.KEY% = BTAB.KEY% OR                          \
6856: ea07:                  FUNCTION.KEY% = HOME.KEY% OR                          \
6857: ea07:                  FUNCTION.KEY% = HELP.KEY% OR                          \
6858: ea07:                  FUNCTION.KEY% = QUIT.KEY% OR                          \
6859: ea07:                  FUNCTION.KEY% = ESC.KEY%) THEN                        \
6860: ea07:               BEGIN
6861: ea07:                  DISPLAY.MESSAGE.NUMBER% = 1
6862: ea18:                  CALL DISPLAY.MESSAGE                                  ! 1.5 RC
6863: ea25:                  CALL RESUME.INPUT                                     ! 1.5 RC
6864: ea35:               ENDIF                                                    \
6865: ea35:               ELSE                                                     \
6866: ea3d:               IF FUNCTION.KEY% = QUIT.KEY% THEN                        \
6867: ea55:               BEGIN
6868: ea55:                  CALL GET.QUIT.CONFIRM                                 ! 1.5 RC
6869: ea65:               ENDIF                                                    \
6870: ea65:               ELSE                                                     \
6871: ea6d:               IF FUNCTION.KEY% = ESC.KEY% THEN                         \
6872: ea85:               BEGIN
6873: ea85:                  CHAIN.TO.PROG$ = "PSB50"
6874: ea9c:                  PSBCHN.MENCON  = "000000"
6875: eab3:                  CALL CHAIN.TO.CALLER                                  ! 1.5 RC
6876: eac3:               ENDIF                                                    \
6877: eac3:               ELSE                                                     \
6878: eacb:               IF FUNCTION.KEY% = HELP.KEY% THEN                        \
6879: eae3:               BEGIN
6880: eae3:                  CALL SCREEN.HELP(5)
6881: eb01:                  CALL RESTORE.FIELDS.05                                ! 1.5 RC
6882: eb0d: 
6883: eb0d:                  CURSOR.POSITION% = S5.PASSWORD%
6884: eb23:                  CALL PUT.CURSOR.IN.FIELD                              ! 1.5 RC
6885: eb30: 
6886: eb30:                  CALL GET.INPUT                                        ! 1.5 RC
6887: eb3f:               ENDIF                                                    \
6888: eb3f:               ELSE                                                     \
6889: eb47:               BEGIN
6890: eb47:                  IF VALID.PASSWORD THEN                                \
6891: eb57:                     VALID.PASSWORD.FOUND = TRUE                        \
6892: eb6f:                  ELSE                                                  \
6893: eb77:                  BEGIN
6894: eb77:                     ! B332 Invalid password
6895: eb77:                     DISPLAY.MESSAGE.NUMBER% = 332
6896: eb88:                     CALL DISPLAY.MESSAGE                               ! 1.5 RC
6897: eb95:                     CALL RESUME.INPUT                                  ! 1.5 RC
6898: eba2:                  ENDIF
6899: ebaa:               ENDIF
6900: ebb2:         WEND
6901: ebd9: 
6902: ebd9:         IF VALID.PASSWORD.FOUND AND                                    \
6903: ec04:            NOT EXIT.KEY.PRESSED(5) THEN                                \
6904: ec04:         BEGIN
6905: ec04:            CALL CLEAR.MESSAGE                                          ! 1.5 RC
6906: ec11: 
6907: ec11:            STRING.DATA$ = OPERATOR.PASSWORD$
6908: ec2f:            CALL SET.FIELD                                              ! 1.5 RC
6909: ec3c: 
6910: ec3c:            IF OLD.PASSWORD$ = OPERATOR.PASSWORD$ THEN                  \
6911: ec61:            BEGIN
6912: ec61:               DISPLAY.MESSAGE.NUMBER% = 363
6913: ec72:               CALL DISPLAY.MESSAGE                                     ! 1.5 RC
6914: ec7f: 
6915: ec7f:               GOTO GET.PASSWORD.05
6916: ec8d:            ENDIF                                                       \
6917: ec8d:            ELSE                                                        \
6918: ec95:            IF FUNCTION.KEY% = HOME.KEY% OR                             \
6919: ecc9:               FUNCTION.KEY% = BTAB.KEY% THEN                           \
6920: ecc9:            BEGIN
6921: ecc9:               GOSUB GET.OPERATOR.ID.05
6922: ecdd:            ENDIF                                                       \
6923: ecdd:            ELSE                                                        \
6924: ece5:            IF FUNCTION.KEY% = ENTER.KEY% THEN                          \
6925: ecfd:            BEGIN
6926: ecfd:               GOSUB CHECK.FIELDS.05
6927: ed0f:            ENDIF
6928: ed17:         ENDIF
6929: ed1f: 
6930: ed1f:         RETURN
6931: ed2f: 
6932: ed2f: \******************************************************************************
6933: ed2f: \***                                                                          *
6934: ed2f: \***    SUBROUTINE      :       CHECK.FIELDS.05                               *
6935: ed2f: \***                                                                          *
6936: ed2f: \******************************************************************************
6937: ed2f: \***                                                                          *
6938: ed2f: \***    Validate all input fields for the set password screen                 *
6939: ed2f: \***                                                                          *
6940: ed2f: \******************************************************************************
6941: ed2f: 
6942: ed2f:         CHECK.FIELDS.05:
6943: ed3f: 
6944: ed3f:         IF NOT VALID.OPERATOR.ID THEN                                  \
6945: ed4f:         BEGIN
6946: ed4f:            ! B058 Invalid operator ID
6947: ed4f:            DISPLAY.MESSAGE.NUMBER% = 58
6948: ed60:            CALL DISPLAY.MESSAGE                                        ! 1.5 RC
6949: ed6d: 
6950: ed6d:            GOSUB GET.OPERATOR.ID.05
6951: ed7f: 
6952: ed7f:            GOTO CHECK.FIELDS.05.FAILED
6953: ed89:         ENDIF
6954: ed91: 
6955: ed91:         IF NOT VALID.PASSWORD THEN                                     \
6956: eda1:         BEGIN
6957: eda1:            ! B332 Invalid password
6958: eda1:            DISPLAY.MESSAGE.NUMBER% = 332
6959: edb2:            CALL DISPLAY.MESSAGE                                        ! 1.5 RC
6960: edbf: 
6961: edbf:            GOSUB GET.PASSWORD.05
6962: edd1: 
6963: edd1:            GOTO CHECK.FIELDS.05.FAILED
6964: eddb:         ENDIF
6965: ede3: 
6966: ede3:         GOSUB SET.OPERATOR.PASSWORD
6967: edf5: 
6968: edf5:         CHECK.FIELDS.05.FAILED:
6969: ee05: 
6970: ee05:         RETURN
6971: ee15: 
6972: ee15: \******************************************************************************
6973: ee15: \***                                                                          *
6974: ee15: \***    SUBROUTINE      :       SET.OPERATOR.PASSWORD                         *
6975: ee15: \***                                                                          *
6976: ee15: \******************************************************************************
6977: ee15: \***                                                                          *
6978: ee15: \***    Set the password on the authorisation files                           *
6979: ee15: \***                                                                          *
6980: ee15: \******************************************************************************
6981: ee15: 
6982: ee15:         SET.OPERATOR.PASSWORD:
6983: ee25: 
6984: ee25:         CSOUF.OPERATION$ = "CHANGE"
6985: ee3c: 
6986: ee3c:         CALL REVEAL.CONFIRM.MESSAGE                                    ! 1.5 RC
6987: ee49: 
6988: ee49:         CALL GET.CONFIRM                                               ! 1.5 RC
6989: ee56: 
6990: ee56:         CALL HIDE.CONFIRM.MESSAGE                                      ! 1.5 RC
6991: ee63: 
6992: ee63:         IF CONFIRM$ = "Y" THEN                                         \
6993: ee81:         BEGIN
6994: ee81:            CALL WAIT.MESSAGE                                           ! 1.5 RC
6995: ee8e:            GOSUB CHANGE.PASSWORD.DETAILS
6996: eea0:         ENDIF
6997: eea8: 
6998: eea8:         RETURN
6999: eeb8: 
7000: eeb8: \******************************************************************************
7001: eeb8: \***                                                                          *
7002: eeb8: \***    SUBROUTINE      :       CHANGE.PASSWORD.DETAILS                       *
7003: eeb8: \***                                                                          *
7004: eeb8: \******************************************************************************
7005: eeb8: \***                                                                          *
7006: eeb8: \***    Write the password to the EALAUTH and ADXCSOUF files                  *
7007: eeb8: \***                                                                          *
7008: eeb8: \******************************************************************************
7009: eeb8: 
7010: eeb8:         CHANGE.PASSWORD.DETAILS:
7011: eec8: 
7012: eec8:         AF.OPERATOR.NO$      = PACK$(RIGHT$(STRING$(8,"0") +           \
7013: ef1a:                                OPERATOR.ID$,8))
7014: ef1a: 
7015: ef1a:         AF.PASSWORD$         = PACK$(RIGHT$(STRING$(8,"0") +           \
7016: ef6c:                                OPERATOR.PASSWORD$,8))
7017: ef6c: 
7018: ef6c:         AF.DATE.PSWD.CHANGE$ = PACK$(TODAYS.DATE$)
7019: ef8f: 
7020: ef8f:         CSOUF.OP.ID$         = LEFT$(OPERATOR.ID$ +                    \
7021: efde:                                STRING$(8," "),8)
7022: efde: 
7023: efde:         CSOUF.PSWD$          = "********"
7024: eff5: 
7025: eff5:         IF WRITE.AF.ABREV = 0 THEN                                     \
7026: f007:         BEGIN
7027: f007:            GOSUB SET.CSOUF.PASSWORD
7028: f019:            CALL SET.NEW.OPAUD.DETAILS                                  ! 1.5 RC
7029: f026:            CALL WRITE.OPAUD.RECORDS                                    ! 1.5 RC
7030: f035:         ENDIF                                                          \
7031: f035:         ELSE                                                           \
7032: f03d:         BEGIN
7033: f03d:            GOSUB FILE.ERROR
7034: f04f:         ENDIF
7035: f057: 
7036: f057:         CALL GET.QUIT.KEY                                              ! 1.5 RC
7037: f064: 
7038: f064:         RETURN
7039: f074: 
7040: f074: \******************************************************************************
7041: f074: \***                                                                          *
7042: f074: \***    SUBROUTINE      :       UPDATE.PPDF.RECORD                            *
7043: f074: \***                                                                          *
7044: f074: \******************************************************************************
7045: f074: \***                                                                          *
7046: f074: \***    Update the pharmacy password details file                             *
7047: f074: \***                                                                          *
7048: f074: \******************************************************************************
7049: f074: 
7050: f074:         UPDATE.PPDF.RECORD:
7051: f084: 
7052: f084:         CURRENT.REPORT.NUM% = PPDF.REPORT.NUM%
7053: f09a:         IF END # PPDF.SESS.NUM% THEN OPEN.ERROR
7054: f0b6:         OPEN PPDF.FILE.NAME$ DIRECT RECL PPDF.RECL% AS PPDF.SESS.NUM%
7055: f0e2: 
7056: f0e2:         PPDF.REC.NUM% = 1
7057: f0f9: 
7058: f0f9:         IF READ.PPDF = 0 THEN                                          \
7059: f10b:         BEGIN
7060: f10b:            IF PPDF.INTERMEDIATE.FLAG$ = "Y" THEN                       \
7061: f129:            BEGIN
7062: f129:               GOSUB SET.PHRML.PASSWORD
7063: f13b:            ENDIF
7064: f143: 
7065: f143:            GOSUB SET.PPDF.DATE                                         ! HMW
7066: f157:         ENDIF                                                          \
7067: f157:         ELSE                                                           \
7068: f15f:         BEGIN
7069: f15f:            GOSUB FILE.ERROR
7070: f171:         ENDIF
7071: f179: 
7072: f179:         CLOSE PPDF.SESS.NUM%
7073: f18d: 
7074: f18d:         RETURN
7075: f19d: 
7076: f19d: \******************************************************************************
7077: f19d: \***                                                                          *
7078: f19d: \***    SUBROUTINE      :       SET.PHRML.PASSWORD                            *
7079: f19d: \***                                                                          *
7080: f19d: \******************************************************************************
7081: f19d: \***                                                                          *
7082: f19d: \***    Update the password on the PHRML file                                 *
7083: f19d: \***                                                                          *
7084: f19d: \******************************************************************************
7085: f19d: 
7086: f19d:         SET.PHRML.PASSWORD:
7087: f1ad: 
7088: f1ad:         CURRENT.REPORT.NUM% = PHRML.REPORT.NUM%
7089: f1c3:         IF END # PHRML.SESS.NUM% THEN OPEN.ERROR
7090: f1df:         OPEN PHRML.FILE.NAME$ DIRECT RECL PHRML.RECL% AS               \
7091: f20b:              PHRML.SESS.NUM%
7092: f20b: 
7093: f20b:         PHRML.PASSWORD$ = LEFT$(OPERATOR.PASSWORD$ +                   \
7094: f26a:                           PACK$(STRING$(18,"0")),9)
7095: f26a: 
7096: f26a:         IF WRITE.PHRML.PASSWORD <> 0 THEN                              \
7097: f27c:         BEGIN
7098: f27c:            GOSUB FILE.ERROR
7099: f28e:         ENDIF
7100: f296: 
7101: f296:         CLOSE PHRML.SESS.NUM%
7102: f2aa: 
7103: f2aa:         RETURN
7104: f2ba: 
7105: f2ba: \******************************************************************************
7106: f2ba: \***                                                                          *
7107: f2ba: \***    SUBROUTINE      :       SET.PPDF.DATE                                 *
7108: f2ba: \***                                                                          *
7109: f2ba: \******************************************************************************
7110: f2ba: \***                                                                          *
7111: f2ba: \***    Update the date of last password change on the PPDF file              *
7112: f2ba: \***                                                                          *
7113: f2ba: \******************************************************************************
7114: f2ba: 
7115: f2ba:         SET.PPDF.DATE:
7116: f2ca: 
7117: f2ca:         PPDF.DATE.LAST.PSWD$ = PACK$(TODAYS.DATE$)
7118: f2ed: 
7119: f2ed:         IF WRITE.PPDF <> 0 THEN                                        \
7120: f2ff:         BEGIN
7121: f2ff:            GOSUB FILE.ERROR
7122: f311:         ENDIF
7123: f319: 
7124: f319:         RETURN
7125: f329: 
7126: f329: 
7127: f329: \******************************************************************************
7128: f329: \***                                                                          *
7129: f329: \***    SUBROUTINE      :       PROCESS.SCREEN.06                             *
7130: f329: \***                                                                          *
7131: f329: \******************************************************************************
7132: f329: \***                                                                          *
7133: f329: \***    Control routine for the delete an operator screen                     *
7134: f329: \***                                                                          *
7135: f329: \******************************************************************************
7136: f329: 
7137: f329:         PROCESS.SCREEN.06:
7138: f339: 
7139: f339:         CALL PSB9902 ! Processing separated into module PSB9902        ! 1.5 RC
7140: f346: 
7141: f346:         RETURN
7142: f356: 
7143: f356: 
7144: f356: \******************************************************************************
7145: f356: \***                                                                          *
7146: f356: \***    SUBROUTINE      :       CHECK.FIELDS.06                               *
7147: f356: \***                                                                          *
7148: f356: \******************************************************************************
7149: f356: \***                                                                          *
7150: f356: \***    Validate all input fields for the delete an operator screen           *
7151: f356: \***                                                                          *
7152: f356: \******************************************************************************
7153: f356: 
7154: f356: !   Entire procedure neutralised for Rv 1.5                            ! 1.5 RC
7155: f356: !   VALID.OPERATOR.ID function is TRUE when OPERATOR.ID$ is from 100 to 999
7156: f356: !   CHECK.FIELDS.06 only called from end of GET.OPERATOR.ID.06 routine
7157: f356: !     when VALID.OPERATOR.ID.FOUND is TRUE
7158: f356: !   VALID.OPERATOR.ID.FOUND is set FALSE at start of GET.OPERATOR.ID.06
7159: f356: !     and set TRUE witin it only when VALID.OPERATOR.ID is TRUE
7160: f356: !   Similar code exists within GET.OPERATOR.ID... 02 03 04 05 routines
7161: f356: !   Therefore the IF NOT VALID.OPERATOR.ID path below will never execute
7162: f356: !   This means a CALL to this subroutine can be replaced by
7163: f356: !     a CALL to DELETE.AN.OPERATOR
7164: f356: 
7165: f356: 
7166: f356: !       CHECK.FIELDS.06: ! Entire procedure neutralised for Rv 1.5     ! 1.5 RC
7167: f356: 
7168: f356: !       IF NOT VALID.OPERATOR.ID THEN                                  \
7169: f356: !       BEGIN
7170: f356: !          ! B058 Invalid operator ID
7171: f356: !          DISPLAY.MESSAGE.NUMBER% = 58
7172: f356: !          GOSUB DISPLAY.MESSAGE
7173: f356: 
7174: f356: !          GOSUB GET.OPERATOR.ID.06
7175: f356: 
7176: f356: !          GOTO CHECK.FIELDS.06.FAILED
7177: f356: !       ENDIF
7178: f356: 
7179: f356: !       GOSUB DELETE.AN.OPERATOR
7180: f356: 
7181: f356: !       CHECK.FIELDS.06.FAILED:
7182: f356: 
7183: f356: !       RETURN
7184: f356: 
7185: f356: 
7186: f356: \******************************************************************************
7187: f356: \***                                                                          *
7188: f356: \***    SUBROUTINE      :       PROCESS.SCREEN.07                             *
7189: f356: \***                                                                          *
7190: f356: \******************************************************************************
7191: f356: \***                                                                          *
7192: f356: \***    Control routine for the report operators screen                       *
7193: f356: \***                                                                          *
7194: f356: \******************************************************************************
7195: f356: 
7196: f356:         PROCESS.SCREEN.07:
7197: f366: 
7198: f366:         CALL PSB9901
7199: f373: 
7200: f373:         RETURN
7201: f383: 
7202: f383: 
7203: f383: \******************************************************************************
7204: f383: \***                                                                          *
7205: f383: \***    SUBROUTINE      :       TERMINATION                                   *
7206: f383: \***                                                                          *
7207: f383: \******************************************************************************
7208: f383: \***                                                                          *
7209: f383: \***    Deallocate all session numbers                                        *
7210: f383: \***                                                                          *
7211: f383: \***    CLOSE the required files                                              *
7212: f383: \***                                                                          *
7213: f383: \***    CHAIN back to a previous screen program                               *
7214: f383: \***                                                                          *
7215: f383: \******************************************************************************
7216: f383: 
7217: f383:         TERMINATION:
7218: f393: 
7219: f393:         CALL CHAIN.TO.CALLER                                           ! 1.5 RC
7220: f3a0: 
7221: f3a0:         RETURN
7222: f3b0: 
7223: f3b0: \******************************************************************************
7224: f3b0: \***                                                                          *
7225: f3b0: \***    SUBROUTINE      :       ALLOCATE.SESS.NUMS                            *
7226: f3b0: \***                                                                          *
7227: f3b0: \******************************************************************************
7228: f3b0: \***                                                                          *
7229: f3b0: \***    Allocate all session numbers                                          *
7230: f3b0: \***                                                                          *
7231: f3b0: \******************************************************************************
7232: f3b0: 
7233: f3b0:         ALLOCATE.SESS.NUMS:
7234: f3c0: 
7235: f3c0:         SB.ACTION$ = "O"
7236: f3d7: 
7237: f3d7:         SB.INTEGER% = MODEL.REPORT.NUM%
7238: f3ed:         SB.STRING$ = MODEL.FILE.NAME$
7239: f40b:         CALL SB.FILE.UTILS                                             ! 1.5 RC
7240: f418:         MODEL.SESS.NUM% = SB.FILE.SESS.NUM%
7241: f42e: 
7242: f42e:         SB.INTEGER% = CSOUF.REPORT.NUM%
7243: f444:         SB.STRING$ = CSOUF.FILE.NAME$
7244: f462:         CALL SB.FILE.UTILS                                             ! 1.5 RC
7245: f46f:         CSOUF.SESS.NUM% = SB.FILE.SESS.NUM%
7246: f485: 
7247: f485:         SB.INTEGER% = AF.REPORT.NUM%
7248: f49c:         SB.STRING$ = AF.FILE.NAME$
7249: f4ba:         CALL SB.FILE.UTILS                                             ! 1.5 RC
7250: f4c7:         AF.SESS.NUM% = SB.FILE.SESS.NUM%
7251: f4dd: 
7252: f4dd:         SB.INTEGER% = OPAUD.REPORT.NUM%
7253: f4f3:         SB.STRING$ = OPAUD.FILE.NAME$
7254: f511:         CALL SB.FILE.UTILS                                             ! 1.5 RC
7255: f51e:         OPAUD.SESS.NUM% = SB.FILE.SESS.NUM%
7256: f534: 
7257: f534:         SB.INTEGER% = PRINT.REPORT.NUM%
7258: f54a:         SB.STRING$ = PRINT.FILE.NAME$
7259: f568:         CALL SB.FILE.UTILS                                             ! 1.5 RC
7260: f575:         PRINT.SESS.NUM% = SB.FILE.SESS.NUM%
7261: f58b: 
7262: f58b:         SB.INTEGER% = PPDF.REPORT.NUM%
7263: f5a1:         SB.STRING$ = PPDF.FILE.NAME$
7264: f5bf:         CALL SB.FILE.UTILS                                             ! 1.5 RC
7265: f5cc:         PPDF.SESS.NUM% = SB.FILE.SESS.NUM%
7266: f5e2: 
7267: f5e2:         SB.INTEGER% = PHRML.REPORT.NUM%
7268: f5f8:         SB.STRING$ = PHRML.FILE.NAME$
7269: f616:         CALL SB.FILE.UTILS                                             ! 1.5 RC
7270: f623:         PHRML.SESS.NUM% = SB.FILE.SESS.NUM%
7271: f639: 
7272: f639:         SB.INTEGER% = WORKFILE.REPORT.NUM%                             ! 1.9 NM
7273: f64f:         SB.STRING$ = WORKFILE.FILE.NAME$                               ! 1.9 NM
7274: f66d:         CALL SB.FILE.UTILS                                             ! 1.9 NM
7275: f67a:         WORKFILE.SESS.NUM% = SB.FILE.SESS.NUM%                         ! 1.9 NM
7276: f690: 
7277: f690:         RETURN
7278: f6a0: 
7279: f6a0: 
7280: f6a0: \******************************************************************************
7281: f6a0: \******************************************************************************
7282: f6a0: \***                                                                          *
7283: f6a0: \***    E N D  O F  S U B R O U T I N E S                                     *
7284: f6a0: \***                                                                          *
7285: f6a0: \******************************************************************************
7286: f6a0: \******************************************************************************
7287: f6a0: 
7288: f6a0: 
7289: f6a0: \******************************************************************************
7290: f6a0: \******************************************************************************
7291: f6a0: \***                                                                          *
7292: f6a0: \***    S T A R T  O F  E R R O R  R O U T I N E S                            *
7293: f6a0: \***                                                                          *
7294: f6a0: \******************************************************************************
7295: f6a0: \******************************************************************************
7296: f6a0: 
7297: f6a0: \******************************************************************************
7298: f6a0: \***                                                                          *
7299: f6a0: \***    ERROR ROUTINE   :       FILE.ERROR                                    *
7300: f6a0: \***                                                                          *
7301: f6a0: \******************************************************************************
7302: f6a0: 
7303: f6a0:         FILE.ERROR:
7304: f6b0: 
7305: f6b0:         EVENT.NO% = 106
7306: f6c0: 
7307: f6c0:         FILE.NO$ = CHR$(SHIFT(CURRENT.REPORT.NUM%,8)) +                \
7308: f713:                    CHR$(SHIFT(CURRENT.REPORT.NUM%,0))
7309: f713: 
7310: f713:         IF FILE.OPERATION$ = "O" THEN                                  \
7311: f731:         BEGIN
7312: f731:            MESSAGE.NO%   = 501
7313: f742:            VAR.STRING.2$ = RIGHT$("000" +                              \
7314: f78f:                            STR$(CURRENT.REPORT.NUM%),3)
7315: f78f:         ENDIF                                                          \
7316: f78f:         ELSE                                                           \
7317: f797:         IF FILE.OPERATION$ = "R" THEN                                  \
7318: f7b5:         BEGIN
7319: f7b5:            MESSAGE.NO% = 508
7320: f7c6:            VAR.STRING.2$ = RIGHT$("000" +                              \
7321: f82c:                            STR$(CURRENT.REPORT.NUM%),3) +              \
7322: f82c:                            CURRENT.CODE$
7323: f82c:         ENDIF                                                          \
7324: f82c:         ELSE                                                           \
7325: f834:         IF FILE.OPERATION$ = "W" THEN                                  \
7326: f852:         BEGIN
7327: f852:            MESSAGE.NO% = 509
7328: f863:            VAR.STRING.2$ = RIGHT$("000" +                              \
7329: f8ad:                            STR$(CURRENT.REPORT.NUM%),3)
7330: f8ad:         ENDIF
7331: f8b5: 
7332: f8b5:         VAR.STRING.1$ = FILE.OPERATION$ +                              \
7333: f8f1:                         FILE.NO$ +                                     \
7334: f8f1:                         PACK$(STRING$(12,"0"))
7335: f8f1: 
7336: f8f1:         CALL APPLICATION.LOG(MESSAGE.NO%,                              \
7337: f927:                              VAR.STRING.1$,                            \
7338: f927:                              VAR.STRING.2$,                            \
7339: f927:                              EVENT.NO%)
7340: f927: 
7341: f927:         RETURN
7342: f937: 
7343: f937: \******************************************************************************
7344: f937: \***                                                                          *
7345: f937: \***    ERROR ROUTINE   :       OPEN.ERROR                                    *
7346: f937: \***                                                                          *
7347: f937: \******************************************************************************
7348: f937: 
7349: f937:         OPEN.ERROR:
7350: f947: 
7351: f947:         FILE.OPERATION$ = "O"
7352: f95e:         GOSUB FILE.ERROR
7353: f970: 
7354: f970:         CHAIN.TO.PROG$ = "PSB50"
7355: f987:         PSBCHN.MENCON  = "000000"
7356: f99e:         CALL CHAIN.TO.CALLER                                           ! 1.5 RC
7357: f9ab: 
7358: f9ab: \******************************************************************************
7359: f9ab: \***                                                                          *
7360: f9ab: \***    ERROR ROUTINE   :       ERROR.DETECTED                                *
7361: f9ab: \***                                                                          *
7362: f9ab: \******************************************************************************
7363: f9ab: 
7364: f9ab:         ERROR.DETECTED:
7365: f9bb: 
7366: f9bb: !       Resolve "NP" error to facilitate program running from          ! 1.5 RC
7367: f9bb: !       debugger or command line                                       ! 1.5 RC
7368: f9bb: 
7369: f9bb:         IF ERR = "NP" THEN \ ! No Parameters passed on CHAIN           ! 1.5 RC
7370: f9e4:             BEGIN            ! when USE statement executed             ! 1.5 RC
7371: f9e4:             PSBCHN.PRG    = ""                                         ! 1.5 RC
7372: f9fb:             PSBCHN.OP     = "99999999" ! Parameters in use for A9C     ! 1.5 RC
7373: fa12:             PSBCHN.APP    = "PSB50"    ! (though only PSBCHN.APP       ! 1.5 RC
7374: fa29:             PSBCHN.MENCON = "413000"   !  used within program)         ! 1.5 RC
7375: fa40:             PSBCHN.U1     = ""                                         ! 1.5 RC
7376: fa57:             PSBCHN.U2     = ""                                         ! 1.5 RC
7377: fa6e:             PSBCHN.U3     = ""                                         ! 1.5 RC
7378: fa85:             RESUME RESUME.FROM.NP.ERROR                                ! 1.5 RC
7379: fa9c:             ENDIF                                                      ! 1.5 RC
7380: faa4: 
7381: faa4: !   PRINT "MAIN: ERROR.DETECTED at " + \
7382: faa4: !      MID$(TIME$,1,2) + ":" + MID$(TIME$,3,2) + ":" + MID$(TIME$,5,2)
7383: faa4: !   PRINT "ERRN .... " + ERRNH ! Function call to translate ERRN
7384: faa4: !   PRINT "ERRF% ... " + STR$(ERRF%)
7385: faa4: !   PRINT "ERR ..... " + ERR
7386: faa4: !   PRINT "ERRL .... " + STR$(ERRL)
7387: faa4: 
7388: faa4:         CALL STANDARD.ERROR.DETECTED(ERRN,                             \
7389: fad1:                                      ERRF%,                            \
7390: fad1:                                      ERRL,                             \
7391: fad1:                                      ERR)
7392: fad1: 
7393: fad1:         CHAIN.TO.PROG$ = "PSB50"
7394: fae8:         CALL CHAIN.TO.CALLER                                           ! 1.5 RC
7395: fafa: 
7396: fafa:         END
7397: fafa: 
7398: fafa: End of Compilation
