   1: 0000: \*******************************************************************************! LCSk
   2: 0000: \*******************************************************************************! LCSk
   3: 0000: \***                                                                            ! LCSk
   4: 0000: \*** IMPORTANT                                                                  ! LCSk
   5: 0000: \*** =========                                                                  ! LCSk
   6: 0000: \***    All references to UPDT.IRF.UPDT have been commented out and replaced    ! LCSk
   7: 0000: \***    with UPDT.IRF.TIF.UPDT due to the following issue found post MCF:       ! LCSk
   8: 0000: \***                                                                            ! LCSk
   9: 0000: \***    Node ID check removed as it is preventing the TIF from being updated in ! LCSk
  10: 0000: \***    Single MCF controller stores ie. MCF has changed the single DE nodes    ! LCSk
  11: 0000: \***    to CE. This change should have been done as part of the MCF project,    ! LCSk
  12: 0000: \***    however, the Business were not willing to pay for the relinking and     ! LCSk
  13: 0000: \***    testing of some 200+ programs. There is a slight processing overhead    ! LCSk
  14: 0000: \***    in dual-MCF stores, since the TIF will now be updated in them as well,  ! LCSk
  15: 0000: \***    however the impact is small and TOF does not run in this environment.   ! LCSk
  16: 0000: \***                                                                            ! LCSk
  17: 0000: \***    If you wish to use the old UPDT.IRF.UPDT function then you will need to ! LCSk
  18: 0000: \***    either:                                                                 ! LCSk
  19: 0000: \***                                                                            ! LCSk
  20: 0000: \***          1. Check out the previous OBJs, PSBF19e.J86 and update the .INP   ! LCSk
  21: 0000: \***             and .MAK to include the functions PSBF19, PSBF41 & PSBF42      ! LCSk
  22: 0000: \***       or                                                                   ! LCSk
  23: 0000: \***          2. Check out the previous PSBF19e.J86 and function library:       ! LCSk
  24: 0000: \***             FUNLIB.L86                                                     ! LCSk
  25: 0000: \***                                                                            ! LCSk
  26: 0000: \*******************************************************************************! LCSk
  27: 0000: \*******************************************************************************! LCSk
  28: 0000: 
  29: 0000: \*******************************************************************************
  30: 0000: \*******************************************************************************
  31: 0000: \***
  32: 0000: \***
  33: 0000: \***        FUNCTION      : UPDT.IRF.TIF.UPDT (was UPDT.IRF.UPDT)     ! LCSk
  34: 0000: \***        AUTHOR        : Richard Hopkinson (Pseudocode)
  35: 0000: \***                      : Richard Hopkinson (Basic Code)
  36: 0000: \***
  37: 0000: \***        DATE WRITTEN  : 11th March 1988   (Pseudocode)
  38: 0000: \***                      : 11th March 1988   (Basic Code)
  39: 0000: \***
  40: 0000: \***        REFERENCE     : PSBF19
  41: 0000: \***
  42: 0000: \***
  43: 0000: \***        VERSION B        D.S. O'DARE (Pseudocode)      25th November 1988
  44: 0000: \***                         B.C. WILLIS (Basic code)       2nd December 1988
  45: 0000: \***        89A VERSION.
  46: 0000: \***        Changes to small stores version of program.
  47: 0000: \***        Change to incorporate new function SESS.NUM.UTILITY (PSBF20), to
  48: 0000: \***        allocate file session numbers dynamically via the global Session
  49: 0000: \***        Number Table.  Message 550 replaces message number 551 and message
  50: 0000: \***        502 is changed to message number 508.  The decision to write the
  51: 0000: \***        IRF unlocked or not, is no longer based on the calling module
  52: 0000: \***        number, but rather on an extra parameter (irf.locked.flag) passed
  53: 0000: \***        by the calling program.  The program-to-chain-to has been amended
  54: 0000: \***        from "01" to "50".
  55: 0000: \***
  56: 0000: \***        VERSION C        JANET LAWRENCE                10th April 1989
  57: 0000: \***        Various small changes: will only read the TIF to see if an item
  58: 0000: \***        is already on it if the ACD flag is not "ADD"; sets messages
  59: 0000: \***        up correctly; stops adding records to the TIF if it is full;
  60: 0000: \***        doesn't increment the TIF record count if only altering a record.
  61: 0000: \***
  62: 0000: \***        VERSION D        ANDREW WEDGEWORTH              21st July 1992
  63: 0000: \***        Redundant function parameters removed.  Standard error detected
  64: 0000: \***        function used to log event 101s.
  65: 0000: \***
  66: 0000: \***        VERSION E        MARK WALKER                     8th June 1993
  67: 0000: \***        Debug code removed from the CLOSE.IRF.UPDT function.
  68: 0000: \***
  69: 0000: \***        VERSION F        STEVE PERKINS             21st September 1993
  70: 0000: \***        Deals project: Changed IRF and TIF record layouts, to take
  71: 0000: \***        account of new deals fields added.
  72: 0000: \***
  73: 0000: \***        VERSION G (1.1)    Nik Sen                 31st January 1995
  74: 0000: \***        Version letters removed from included code (not commented).
  75: 0000: \***
  76: 0000: \***        VERSION H         Dave West                 8th September 1998
  77: 0000: \***        Changes made for GSA v2, also changes made to TIF processing so
  78: 0000: \***        record is written before header record and record number set to
  79: 0000: \***        file size instead of being incremented. (TIF changes originally
  80: 0000: \***        written by Nik Sen).
  81: 0000: \***
  82: 0000: \***        VERSION I       Stuart William McConnachie  14th February 2000
  83: 0000: \***        Changed IRF.INDICAT2$ to bit flags IRF.INDICAT2%.
  84: 0000: \***
  85: 0000: \***        VERSION J            Stuart Highley              10th May 2002
  86: 0000: \***        Added code to log events when many prices are being updated to
  87: 0000: \***        the same price.  This should help identify the pricing bug.
  88: 0000: \***
  89: 0000: \***        VERSION K       Stuart William McConnachie  7th August 2002
  90: 0000: \***        Removed above code.
  91: 0000: \***
  92: 0000: \***    REVISION 1.7.                                              AUG 2002
  93: 0000: \***    Removed debug code. (This comment added for revision 1.9).
  94: 0000: \***
  95: 0000: \***    REVISION 1.8.                ROBERT COWEY                6 AUG 2002.
  96: 0000: \***    Major changes to UPDT.IRF.UPDT function for 2002 Deals Rewrite project.
  97: 0000: \***    Removed redundant code processing unused TIF and TMCF file formats.
  98: 0000: \***    Used SPLIT.NEW.IRF.DATA$ (new for IRFFUN.BAS revision 1.7) to extract
  99: 0000: \***    individual IRF variables from NEW.IRF.DATA$ (IRF record string passed
 100: 0000: \***    into function) on entry to function. (There are no internal IRF reads).
 101: 0000: \***    Used SPLIT.TIF.IRF.DATA$ (new for TIFFUN.BAS revision 1.5) to extract
 102: 0000: \***    individual TIF variables from TIF.IRF.DATA$ (IRF record string copied
 103: 0000: \***    from NEW.IRF.DATA$) immediately prior to the WRITE to the TIF.
 104: 0000: \***    Use of these SPLIT... functions keeps both IRF and TIF record layouts
 105: 0000: \***    invisible (and independant) from the UPDT.IRF.UPDT function.
 106: 0000: \***
 107: 0000: \***    REVISION 1.9.                ROBERT COWEY.                05 DEC 2003.
 108: 0000: \***    Corrected revision number comment for previous change from 1.7 to 1.8.
 109: 0000: \***    Changes to functions for Deal Limit removal project.
 110: 0000: \***    Moved SPLIT.NEW.IRF.DATA$ to start of UPDT.IRF.UPDT function.
 111: 0000: \***    Deleted IRFDEX record when deleting Boots-item-code IRF record
 112: 0000: \***    using PSBF19 specific session number F19.IRFDEX.SESS.NUM%.
 113: 0000: \***
 114: 0000: \***    Version 1.10      Stuart William McConnachie     31st Oct 2006
 115: 0000: \***    Chain back to PSB50.286, instead of xxx50.286 derived from
 116: 0000: \***    first three letters of MODULE.NUMBER$.  Doesn't work for
 117: 0000: \***    PSD and SRP applications.
 118: 0000: \***
 119: 0000: \***    REVISION 1.11                Neil Bennett.                14 Nov 2006.
 120: 0000: \***    Changed to include updates to the Product History File (PHF) for CIP.
 121: 0000: \***    Changed to allow the recognition of the calling program (defaults to
 122: 0000: \***    'R' - RPD) by checking for a second character to the IRF.LOCKED.FLAG$
 123: 0000: \***    in the update routine. This is used for the PHF update. Reads of files
 124: 0000: \***    is done by using a 'unique' session number and saving the 'global'
 125: 0000: \***    session number if already set up, thus allowing for the files to be
 126: 0000: \***    in use (or not) by the calling program.
 127: 0000: \***
 128: 0000: \***    REVISION 1.11a               Neil Bennett.                28 Feb 2007.
 129: 0000: \***    Fix to 1.11 to set the Last Increase date if a price increase is
 130: 0000: \***    received and there is no current price history. (assumes that the
 131: 0000: \***    Global var IRF.SALEPRIC$ is set to the current price when the function
 132: 0000: \***    is called).
 133: 0000: \***
 134: 0000: \***    REVISION 1.12                Paul Bowers                 3rd March 2007
 135: 0000: \***    Fixes to revision 1.11 and 1.11a
 136: 0000: \***
 137: 0000: \***    REVISION 1.13                Brian Greenfield            19th April 2007
 138: 0000: \***    If a Markdown item's label type is already set to type 3, clearance,
 139: 0000: \***    force it to stay as clearance no matter what the new label type is.
 140: 0000: \***    Also force change type to "C" instead of "R".
 141: 0000: \***
 142: 0000: \***    REVISION 1.14                Brian Greenfield            17th May 2007
 143: 0000: \***    If an item is a WEEE item then force the PHF label type to a
 144: 0000: \***    standard label, type 0. this is a CIP phase 2 change request.
 145: 0000: \***    Correct the number of records on the PHF create.
 146: 0000: \***
 147: 0000: \***    REVISION 1.15                Neil Bennett               18th June 2007
 148: 0000: \***    Fix to was/was/now label setting. PHF processing code moved to external
 149: 0000: \***    function PSBF46 as now required from PSBF10 also.
 150: 0000: \***
 151: 0000: \***    REVISION 1.16                Neil Bennett                2nd July 2007
 152: 0000: \***    Trap for BTCPR00000229 - Stop PSBF46 being called with group code bar
 153: 0000: \***    codes as this will force Clearance to be set as markdown flag never set
 154: 0000: \***    on group codes.
 155: 0000: \***
 156: 0000: \***    VERSION L                Charles Skadorwa            25th Sept 2013
 157: 0000: \***    F261 Gift Card Mall IIN Range Extension Project - Commented ! LCSk
 158: 0000: \***    Node ID check removed as it is preventing the TIF from being updated in
 159: 0000: \***    MCF controller stores ie. MCF has changed the single DE nodes to CE.
 160: 0000: \***    This change should have been done as part of the MCF project, however,
 161: 0000: \***    the Business were not willing to pay for the relinking and testing of
 162: 0000: \***    some 200+ programs. There is a slight processing overhead in dual-MCF
 163: 0000: \***    stores, since the TIF will now be updated in them as well, however the
 164: 0000: \***    impact is small and TOF does not run in this environment.
 165: 0000: \***
 166: 0000: \*******************************************************************************
 167: 0000: \*******************************************************************************
 168: 0000: 
 169: 0000: REM peudocode follows...
 170: 0000: 
 171: 0000: \*******************************************************************************
 172: 0000: \*******************************************************************************
 173: 0000: \***
 174: 0000: \***
 175: 0000: \***                   FUNCTION OVERVIEW
 176: 0000: \***                   -----------------
 177: 0000: \***
 178: 0000: \***     This function handles operations concerned with the new TOF (Terminal
 179: 0000: \***     Offline Feature), which enables price look-ups to take place in the
 180: 0000: \***     till in the event of a controller failure. Whenever an item is updated
 181: 0000: \***     on the IRF, it should be processed in the following manner, in order to
 182: 0000: \***     keep the terminal file up to date.
 183: 0000: \***     NOTE: All items on the Item Movement File will be included in the TIF
 184: 0000: \***     overnight, after PSB30 has finished.
 185: 0000: \***
 186: 0000: \***     There are three entry points to this function :
 187: 0000: \***
 188: 0000: \***
 189: 0000: \***     1    Called at the start of the program, to open files.
 190: 0000: \***
 191: 0000: \***
 192: 0000: \***     2    Called when an update is to be performed; this can be divided
 193: 0000: \***          into four procedures:
 194: 0000: \***
 195: 0000: \***          i   Write the item record to the IRF, with hold.
 196: 0000: \***
 197: 0000: \***          ii  Write the Terminal Maintenance Control File header record,
 198: 0000: \***              with hold.
 199: 0000: \***
 200: 0000: \***          iii Write the Terminal Image File record.
 201: 0000: \***
 202: 0000: \***          iv  Write the Terminal Maintenance Control File data record.
 203: 0000: \***
 204: 0000: \***
 205: 0000: \***     3    Called at the end of the program, to close files.
 206: 0000: \***
 207: 0000: \***
 208: 0000: \***     Due to the limitations in file sizes on the terminal, both the TMCF
 209: 0000: \***     and the TIF must be checked to ensure their maximum file sizes are not
 210: 0000: \***     exceeded.
 211: 0000: \***
 212: 0000: \***
 213: 0000: \*******************************************************************************
 214: 0000: \*******************************************************************************
 215: 0000: \***
 216: 0000: \***  %INCLUDE of globals for external function CONV.TO.HEX
 217: 0000: \***  %INCLUDE of globals for external function CONV.TO.STRING
 218: 0000: \***  %INCLUDE of globals for external function UPDATE.IRF
 219: 0000: \***  %INCLUDE of globals for screen chaining parameters
 220: 0000: \***  %INCLUDE of globals for SESS.NUM.UTILITY function
 221: 0000: \***
 222: 0000: \***  %INCLUDE of statements for IRF
 223: 0000: \***  %INCLUDE of statements for TIF
 224: 0000: \***  %INCLUDE of statements for TMCF
 225: 0000: \***  %INCLUDE of statements for GAOPT
 226: 0000: \***  %INCLUDE of statements for external function APPLICATION.LOG
 227: 0000: \***  %INCLUDE of statements for external function ADXERROR
 228: 0000: \***  %INCLUDE of statements for external function ADXSERVE
 229: 0000: \***  %INCLUDE of statements for external function CONV.TO.HEX
 230: 0000: \***  %INCLUDE of statements for external function CONV.TO.STRING
 231: 0000: \***  %INCLUDE of statements for external function SESS.NUM.UTILITY
 232: 0000: \***  %INCLUDE of statements for external function STANDARD.ERROR.DETECTED
 233: 0000: \***
 234: 0000: \-------------------------------------------------------------------------------
 235: 0000: 
 236: 0000:       ! 1 line deleted from here                                      ! DAW
 237: 0000:       %INCLUDE PSBF02G.J86                                            ! 1.11 NWB
 238: 0000: REM\
 239: 0000: \*******************************************************************************
 240: 0000: \*******************************************************************************
 241: 0000: \***
 242: 0000: \***        INCLUDE       : UPDATE.DATE globals
 243: 0000: \***
 244: 0000: \***        REFERENCE     : PSBF02G.J86
 245: 0000: \***
 246: 0000: \***        Version A     Bruce Scriver      4th March 1986
 247: 0000: \*** 
 248: 0000: \***        Version B     Andrew Wedgeworth   6th July 1992
 249: 0000: \***        Removal of return code field which no longer required.
 250: 0000: \***
 251: 0000: \*******************************************************************************
 252: 0000: \*******************************************************************************
 253: 0000: 
 254: 0000:       STRING   GLOBAL F02.DATE$
 255: 0000: 
 256: 0000:       ! 1 line deleted from here                                       ! BAW
 257: 0000: 
 258: 0000:       %INCLUDE PSBF16G.J86                                            ! DAW
 259: 0000: REM\
 260: 0000: \*******************************************************************************
 261: 0000: \*******************************************************************************
 262: 0000: \***
 263: 0000: \***           %INCLUDE GLOBAL DEFINITIONS FOR CONV.TO.HEX FUNCTION
 264: 0000: \***
 265: 0000: \***                       REFERENCE     : PSBF16G.J86
 266: 0000: \*** 
 267: 0000: \***       Version A           Bruce Scriver            25th February 1986
 268: 0000: \***
 269: 0000: \***       Version B         Andrew Wedgeworth               2nd July 1992
 270: 0000: \***       Removal of now redundant F16.RETURN.CODE%.
 271: 0000: \***
 272: 0000: \*******************************************************************************
 273: 0000: \*******************************************************************************
 274: 0000: 
 275: 0000:       STRING   GLOBAL F16.HEX.STRING$
 276: 0000: 
 277: 0000:       ! 1 line deleted from here                                       ! BAW
 278: 0000:       %INCLUDE PSBF17G.J86                                            ! DAW
 279: 0000: REM \
 280: 0000: \*******************************************************************************
 281: 0000: \*******************************************************************************
 282: 0000: \***
 283: 0000: \***
 284: 0000: \***        %INCLUDE GLOBAL DEFINITIONS FOR CONV.TO.STRING FUNCTION
 285: 0000: \***
 286: 0000: \***                    REFERENCE     : PSBF17G.J86
 287: 0000: \***
 288: 0000: \***        Version A         Bruce Scriver      24th February 1986
 289: 0000: \***
 290: 0000: \***        Version B       Andrew Wedgeworth         2nd July 1992
 291: 0000: \***        Removal of now redundant F17.RETURN.CODE%
 292: 0000: \***
 293: 0000: \*******************************************************************************
 294: 0000: \*******************************************************************************
 295: 0000: 
 296: 0000:       STRING   GLOBAL F17.RETURNED.STRING$
 297: 0000: 
 298: 0000:       ! 1 line deleted from here                                       ! BAW
 299: 0000: 
 300: 0000:       %INCLUDE PSBF18G.J86                                            ! 1.11 NWB
 301: 0000: REM\
 302: 0000: \*******************************************************************************
 303: 0000: \*******************************************************************************
 304: 0000: \***
 305: 0000: \***        INCLUDE       : CALC.BOOTS.CODE.CHECK.DIGIT globals
 306: 0000: \***
 307: 0000: \***        REFERENCE     : PSBF18G.J86
 308: 0000: \***
 309: 0000: \***        Version A     Stephen Kelsey                  23rd March 1987
 310: 0000: \***
 311: 0000: \***        Version B     Andrew Wedgeworth                 7th July 1992
 312: 0000: \***        Removal of return code field which no longer required.
 313: 0000: \***
 314: 0000: \*******************************************************************************
 315: 0000: \*******************************************************************************
 316: 0000: 
 317: 0000:       STRING   GLOBAL F18.CHECK.DIGIT$
 318: 0000:     
 319: 0000:       ! 1 line deleted from here                                       ! BAW    
 320: 0000: 
 321: 0000:       %INCLUDE PSBF19G.J86                                            !FSJW
 322: 0000: REM \
 323: 0000: \*******************************************************************************
 324: 0000: \*******************************************************************************
 325: 0000: \***
 326: 0000: \***
 327: 0000: \***            INCLUDE       : UPDATE IRF globals
 328: 0000: \***
 329: 0000: \***            REFERENCE     : PSBF19G.J86
 330: 0000: \***
 331: 0000: \***      Version A              Richard Hopkinson            16th March 1988
 332: 0000: \***
 333: 0000: \***      Version B              Janet Lawrence               12th April 1989
 334: 0000: \***      Version letter incremented to match that of external defintion of 
 335: 0000: \***      function 19.  
 336: 0000: \***
 337: 0000: \***      Version C              Andrew Wedgeworth             21st July 1992
 338: 0000: \***      Return code field removed as no longer used.
 339: 0000: \***
 340: 0000: \***      Version F              Steve Perkins                 20th October 1993
 341: 0000: \***      Version letter updated to keep in line with PSBF19.BAS
 342: 0000: \***
 343: 0000: \***    REVISION 1.9.                ROBERT COWEY.                08 DEC 2003.
 344: 0000: \***    Changes for Deal Limit removal project.
 345: 0000: \***    Revision number updated to keep in step with PSBF19.BAS.
 346: 0000: \***    Declared variables for IRFDEX and F19.NODE.FILE...
 347: 0000: \***
 348: 0000: \*******************************************************************************
 349: 0000: \*******************************************************************************
 350: 0000: 
 351: 0000:       STRING   F19.RETURNED.STRING                                     ! CAW
 352: 0000:       STRING   F19.NODE.FILE.NAME$                                         ! 1.9 RC
 353: 0000: 
 354: 0000:       STRING   GLOBAL NODE.ID$
 355: 0000:       STRING   GLOBAL TIF.FULL$
 356: 0000:       STRING   GLOBAL TIF.OPEN.FLAG$
 357: 0000:       STRING   GLOBAL TMCF.FULL$
 358: 0000:       STRING   GLOBAL TMCF.OPEN.FLAG$
 359: 0000:       
 360: 0000:       INTEGER*2 GLOBAL F19.IRFDEX.SESS.NUM%                                ! 1.9 RC
 361: 0000:       
 362: 0000:       INTEGER*2 F19.NODE.REPORT.NUM%                                       ! 1.9 RC
 363: 0000:       INTEGER*2 F19.NODE.SESS.NUM%                                         ! 1.9 RC
 364: 0000:       %INCLUDE PSBF20G.J86                                            ! DAW
 365: 0000: REM\
 366: 0000: \*******************************************************************************
 367: 0000: \*******************************************************************************
 368: 0000: \***
 369: 0000: \***     %INCLUDE GLOBAL VARIABLE DEFINITIONS FOR SESS.NUM.UTILITY FUNCTION
 370: 0000: \***
 371: 0000: \***                       REFERENCE     : PSBF20G.J86
 372: 0000: \*** 
 373: 0000: \***     Version A              Bruce Scrive                   5th May 1988   
 374: 0000: \*** 
 375: 0000: \***     Version B              Robert Cowey                   7th May 1991
 376: 0000: \***     Global variable F20.INTEGER.FILE.NO% changed from one byte integer
 377: 0000: \***     to two byte integer.
 378: 0000: \***
 379: 0000: \***     Version D              Andrew Wedgeworth             1st July 1992
 380: 0000: \***     F20.RETURN.CODE% removed as it is no longer required.
 381: 0000: \***
 382: 0000: \*******************************************************************************
 383: 0000: \*******************************************************************************
 384: 0000: 
 385: 0000:       STRING    GLOBAL F20.FILE.NAME$,                                 \
 386: 0000:                        F20.STRING.FILE.NO$,                            \
 387: 0000:                        F20.TABLE.DIMENSIONED.FLAG$,                    \
 388: 0000:                        SESS.NUM.TABLE$(1)
 389: 0000: 
 390: 0000:       INTEGER*2 GLOBAL F20.INTEGER.FILE.NO%
 391: 0000: 
 392: 0000:       ! 1 line deleted from here                                       ! DAW 
 393: 0000: 
 394: 0000:       %INCLUDE PSBF46G.J86                                            ! 1.15 NWB
 395: 0000: \*******************************************************************************
 396: 0000: \*******************************************************************************
 397: 0000: \***
 398: 0000: \***        INCLUDE       : GET.LABEL.TYPE Globals
 399: 0000: \***
 400: 0000: \***        REFERENCE     : PSBF46G.J86
 401: 0000: \***
 402: 0000: \***        Version A     Neil Bennett       18th June 2007
 403: 0000: \***
 404: 0000: \*******************************************************************************
 405: 0000: \*******************************************************************************
 406: 0000: 
 407: 0000:       STRING    GLOBAL F46.LABEL.TYPE$
 408: 0000:       INTEGER*4 GLOBAL F46.WAS.PRICE%
 409: 0000:       INTEGER*4 GLOBAL F46.WAS.WAS.PRICE%
 410: 0000: 
 411: 0000:       %INCLUDE PSBUSEG.J86
 412: 0000: \/*********************************************************************/ PSBUSEG
 413: 0000: \/*                                                                   */ PSBUSEG
 414: 0000: \/* PSBUSEG.J86  -  Definitions for Chain/Use with PSB Screen Program */ PSBUSEG
 415: 0000: \/* ----------------------------------------------------------------- */ PSBUSEG
 416: 0000: \/*                                                                   */ PSBUSEG
 417: 0000: \/*********************************************************************/ PSBUSEG
 418: 0000:                                                                        ! PSBUSEG
 419: 0000:         STRING GLOBAL  PSBCHN.PRG,      \ Program to chain to          ! PSBUSEG
 420: 0000:                        PSBCHN.OP,       \ Operator Id                  ! PSBUSEG
 421: 0000:                        PSBCHN.APP,      \ Program chained from         ! PSBUSEG
 422: 0000:                        PSBCHN.MENCON,   \ Menu Control                 ! PSBUSEG
 423: 0000:                        PSBCHN.U1,       \ User parameter               ! PSBUSEG
 424: 0000:                        PSBCHN.U2,       \ User parameter               ! PSBUSEG
 425: 0000:                        PSBCHN.U3        ! User parameter               ! PSBUSEG
 426: 0000:                                                                        ! PSBUSEG
 427: 0000: 
 428: 0000: 
 429: 0000:       STRING GLOBAL                                                   \ DAW
 430: 0000:          BATCH.SCREEN.FLAG$,                                          \ DAW
 431: 0000:          MODULE.NUMBER$                                               ! DAW
 432: 0000: 
 433: 0000:       STRING                                                          \ 1.11NWB
 434: 0000:          IDF.OPEN.FLAG$,                                              \ 1.11NWB
 435: 0000:          PHF.OPEN.FLAG$,                                              \ 1.11NWB
 436: 0000:          SRITL.OPEN.FLAG$                                             ! 1.11NWB
 437: 0000: 
 438: 0000:       INTEGER*2                                                       \ 1.11NWB
 439: 0000:          F19.IDF.SESS.NUM%,                                           \ 1.11NWB
 440: 0000:          F19.SOFTS.SESS.NUM%,                                         \ 1.11NWB
 441: 0000:          F19.SRITL.SESS.NUM%,                                         \ 1.11NWB
 442: 0000:          SAV.IDF.SESS.NUM%,                                           \ 1.11NWB
 443: 0000:          SAV.SOFTS.SESS.NUM%,                                         \ 1.11NWB
 444: 0000:          SAV.SRITL.SESS.NUM%                                          ! 1.11NWB
 445: 0000: 
 446: 0000:       %INCLUDE IRFDEC.J86                                             ! FSP
 447: 0000: 
 448: 0000: \**********************************************************************************
 449: 0000: \***
 450: 0000: \***       %INCLUDE FOR ITEM RECORD FILE - FIELD DECLARATIONS
 451: 0000: \***                                     - FILE REFERENCE PARAMETERS
 452: 0000: \***
 453: 0000: \***                      FILE TYPE    : Keyed
 454: 0000: \***
 455: 0000: \***                      REFERENCE    : IRFDEC.J86
 456: 0000: \***
 457: 0000: \***     Version A               Andrew Wedgeworth            29th June 1992
 458: 0000: \***
 459: 0000: \***     Version B               Andrew Wedgeworth        14th December 1992
 460: 0000: \***     Version letter incremented to match other IRF code.
 461: 0000: \***
 462: 0000: \***     Version C             Steve Windsor          12.02.93
 463: 0000: \***     Version letter incremented to match other IRF code.
 464: 0000: \***
 465: 0000: \***     Version D             Steve Windsor          12.05.93
 466: 0000: \***     Version letter incremented to match other IRF code.
 467: 0000: \***
 468: 0000: \***     Version E           Steve Perkins       20th September 1993
 469: 0000: \***     Deals project : Handling of Converted/Unconverted records
 470: 0000: \***     ++   Anything with 'Delete' after initials should be   ++
 471: 0000: \***     ++   deleted once the IRF has been converted in all    ++
 472: 0000: \***     ++   stores.                                           ++
 473: 0000: \***
 474: 0000: \***     Version F           Mark Walker            5th January 1994
 475: 0000: \***     Version letter incremented to match other IRF code.
 476: 0000: \***
 477: 0000: \***     Version 96A         Mark Walker               22nd May 1995
 478: 0000: \***     Definition for IRF.POINTS% added.
 479: 0000: \***
 480: 0000: \***                     Stuart McConnachie           12th June 1995
 481: 0000: \***     INDICAT3% comments added for discount/loyalty flags.
 482: 0000: \***
 483: 0000: \***     Version for 96C  Andrew Wedgeworth            22nd May 1996
 484: 0000: \***     Removed IRF.FILLER$ field, as this is now redundant.
 485: 0000: \***
 486: 0000: \***     Version G     Stuart William McConnachie      11th February 2000
 487: 0000: \***     Converted IRF.INDICAT2$ to integer flag byte.
 488: 0000: \***
 489: 0000: \***     REVISION 1.6.               ROBERT COWEY.               9 JUL 2002.
 490: 0000: \***     Major changes for 2002 Deals Rewrite project.
 491: 0000: \***     Incorporated up to date record layout to assist development work
 492: 0000: \***     (placed in the IRFDEC.J86 to make it visible from ...LST files).
 493: 0000: \***     Moved various comments against variables to record layout.
 494: 0000: \***     Relisted variables in alphabetical order.
 495: 0000: \***     Deleted redundant variables associated with the old deals system ...
 496: 0000: \***     DEAL.NUM$, DEAL.SAVING$
 497: 0000: \***     Retained variables that are otherwise redundant (to be set to null X'00'
 498: 0000: \***     within file functions) ...
 499: 0000: \***     INDICAT2%, INDICAT4%, SALEQUAN$, POINTS%
 500: 0000: \***     Defined variables to hold interpreted deals data for new deals system ...
 501: 0000: \***     DEAL.NUM$(n) and LIST.ID%(n) (where 'n' represents entry 0, 1 and 2).
 502: 0000: \***     These two variables are interpretations of DEAL.DATA% which is defined
 503: 0000: \***     locally within IRFFUN.BAS to keep underlying data invisible to programs.
 504: 0000: \***
 505: 0000: \***     REVISION 1.7                ROBERT COWEY.               5 AUG 2002.
 506: 0000: \***     Further changes for 2002 Deals Rewrite project (PSBF19 related).
 507: 0000: \***     Defined NEW.IRF.DATA$ as a global variable for use with new functions
 508: 0000: \***     CONCAT.NEW.IRF.DATA$ and SPLIT.NEW.IRF.DATA$.
 509: 0000: \***
 510: 0000: \***     REVISION 1.8                ROBERT COWEY.              15 JUL 2003.
 511: 0000: \***     Usage of INDICAT0% bit-3 X'08' changed to Item Contains Alcohol.
 512: 0000: \***     No changes to this file other than description.
 513: 0000: \***     No changes to IRF file functions.
 514: 0000: \***
 515: 0000: \***     REVISION 1.9.      STUART WILLIAM MCCONNACHIE           22 OCT 2003.
 516: 0000: \***     Changes to remove limit of 3 deals per item.
 517: 0000: \***     Declaration of new variables for IRF Deal Extension file (IRFDEX).
 518: 0000: \***
 519: 0000: \***     REVISION 2.0.            ALAN CARR                       9 FEB 2006.
 520: 0000: \***     Add new IRF.INDICAT8% 1 byte, amend IRF.UNUSED$ from 3 to 2 bytes.
 521: 0000: \***
 522: 0000: \***     REVISION 2.1              TITTOO THOMAS                  01 July 2011
 523: 0000: \***     The IRF.UNUSED field is disintegrated to 2 new indicator fields
 524: 0000: \***                      IRF.INDICAT9%   1 INT
 525: 0000: \***                      IRF.INDICAT10%  1 INT
 526: 0000: \***...............................................................................
 527: 0000: 
 528: 0000: 
 529: 0000: \**********************************************************************************
 530: 0000: \***
 531: 0000: \***    IRF RECORD LAYOUT - REVISION 1.7 - CORRECT FOR 2011 CORE Stores PROJECT
 532: 0000: \***
 533: 0000: \***     1 11  UPD  BAR.CODE$   Without check digit - File KEY
 534: 0000: \***    12  1  INT  INDICAT0%
 535: 0000: \***                    X"01" - Contains statins                           ! 2.2 TT
 536: 0000: \***                    X"02" - Item not priced (giveaway)
 537: 0000: \***                    X"04" - Item not returnable
 538: 0000: \***                    X"08" - Item contains alcohol
 539: 0000: \***                    X"10" - Blocked from sale                          ! 2.2 TT
 540: 0000: \***                    X"20" - Enforced price entry
 541: 0000: \***                    X"40" - Enforced quantity entry
 542: 0000: \***                    X"80" - Movement kept
 543: 0000: \***    13  1  INT  INDICAT1%
 544: 0000: \***                    X"01" - Asprin
 545: 0000: \***                    X"02" - Paracetamol
 546: 0000: \***                    X"04" - TPLU inclusion flag
 547: 0000: \***                    X"08" - Giftcard item                              ! 2.2 TT
 548: 0000: \***                    X"10" - Withdrawn Block from sale                  ! 2.2 TT
 549: 0000: \***                    X"20" - Non-solid dose painkiller                  ! 2.2 TT
 550: 0000: \***                    X"40" - Insurance policy item                      ! 2.2 TT
 551: 0000: \***                    X"80" - Ibuprofen
 552: 0000: \***    14  2  INT  DEAL.DATA%(0)   Interpreted into sub-variables ...
 553: 0000: \***                    X'3F' - into DEAL.NUM$(0) "0000" to "9999" (2 byte UPD)
 554: 0000: \***                    X'C0' - into LIST.ID%(0) X'00' X
 555: 0000: \***                                             X'01' A
 556: 0000: \***                                             X'10' B
 557: 0000: \***                                             X'11' C                   ! 1.9 RC
 558: 0000: \***    16  1  INT  INDICAT8%                                              ! 2.0 AJC
 559: 0000: \***                    X"01" - Chlamydia NHS test kit                     ! 2.2 TT
 560: 0000: \***                    X"02" - Chlamydia open sell test kit               ! 2.2 TT
 561: 0000: \***                    X"04" - Unrestricted group code                    ! 2.2 TT
 562: 0000: \***                    X"08" - Nightingale Till prompt                    ! 2.2 TT
 563: 0000: \***                    X"10" - Contains Ephedrine                         ! 2.2 TT
 564: 0000: \***                    X"60" -  X'00' - If also Blocked From Sale Recall, ! 2.2 TT
 565: 0000: \***                                        Emergency                      ! 2.2 TT
 566: 0000: \***                             X'00' - If NOT Blocked From Sale Recall,  ! 2.2 TT
 567: 0000: \***                                        No recall                      ! 2.2 TT
 568: 0000: \***                             X'20' 100% returns                        ! 2.2 TT
 569: 0000: \***                             X'40' Withdrawn recall                    ! 2.2 TT
 570: 0000: \***                             X'60' Reverse Logistics                   ! 2.2 TT
 571: 0000: \***                    X"80" - WEEE item flag                             ! 2.0 AJC
 572: 0000: \***    17  1  INT  INDICAT9%
 573: 0000: \***                    X'3F' - Disposal special instruction (0-63)
 574: 0000: \***                    X"40" - Resaleable Indicator
 575: 0000: \***                    X"80" - Boots.com Extended Indicator
 576: 0000: \***    18  1  INT  INDICAT10%
 577: 0000: \***                    X'07' - Age restrictions
 578: 0000: \***                             X'00' - No Age restriction
 579: 0000: \***                             X'01' - Age 12 or over
 580: 0000: \***                             X'02' - Age 15 or over
 581: 0000: \***                             X'03' - Age 16 or over
 582: 0000: \***                             X'04' - Age 18 or over
 583: 0000: \***                             X'05' - Age 21 or over
 584: 0000: \***                             X'06' - Reserved
 585: 0000: \***                             X'07' - Reserved
 586: 0000: \***                    X'38' - Ethical classification
 587: 0000: \***                             X'00' - No ethical classification
 588: 0000: \***                             X'08' - Pharmacy medicine (P)
 589: 0000: \***                             X'10' - General Sale License (GSL)
 590: 0000: \***                             X'18' - Prescription Only Medicine (POM)
 591: 0000: \***                             X'20' - Reserved
 592: 0000: \***                             X'28' - Reserved
 593: 0000: \***                             X'30' - Reserved
 594: 0000: \***                             X'38' - Reserved
 595: 0000: \***                    X'C0' - Returns route
 596: 0000: \***                             X'00' - Not Returnable (Destroy)
 597: 0000: \***                             X'40' - Returns & Recovery
 598: 0000: \***                             X'80' - Direct
 599: 0000: \***                             X'C0' - Semi-centralised
 600: 0000: \***    19  5  UPD  SALEPRIC$   Current price in pence
 601: 0000: \***    24  1  INT  INDICAT5%   Guarantee duration
 602: 0000: \***                    X'3F' - Lowest 6 bits indicate duration (1-63)
 603: 0000: \***                    X'40' - Contains Pseudoephedrine                   ! 2.2 TT
 604: 0000: \***                    X'80' - Guarantee Duration Type                    ! 2.2 TT
 605: 0000: \***                              (1 = Months, 0 = Years)                  ! 2.2 TT
 606: 0000: \***    25 18  ASC  ITEMNAME$   Description used by till
 607: 0000: \***    43  3  UPD  BOOTS.CODE$ Without check digit
 608: 0000: \***    46  2  INT  DEAL.DATA%(1)   Similar structure to DEAL.DATA%(0)
 609: 0000: \***    48  2  INT  DEAL.DATA%(2)   Similar structure to DEAL.DATA%(0)
 610: 0000: \***    50  1  INT  INDICAT3%
 611: 0000: \***                    X"01" - Discountexempt (item exempt from discount)
 612: 0000: \***                    X"02" - Boots brand item
 613: 0000: \***                    X"04" - Item redeemable for loyalty
 614: 0000: \***                    X"08" - Loyalty exempt (item exempt from loyalty)
 615: 0000: \***                    X"10" - **Redundant                                ! 2.2 TT
 616: 0000: \***                    X"20" - Local Price active
 617: 0000: \***                    X"40" - Stock system item
 618: 0000: \***                    X"80" - **Redundant                                ! 2.2 TT
 619: 0000: \***
 620: 0000: \***    Record Length 50
 621: 0000: \***
 622: 0000: \***
 623: 0000: \***    IRF DEAL EXTENSION RECORD LAYOUT ! 1.9 RC
 624: 0000: \***
 625: 0000: \***     1  3  UPD  BOOTS.CODE$
 626: 0000: \***     4  2  INT  IRF.DEAL.DATA%(3)   Similar structure to DEAL.DATA%(0)
 627: 0000: \***     6  2  INT  IRF.DEAL.DATA%(4)   Similar structure to DEAL.DATA%(0)
 628: 0000: \***     8  2  INT  IRF.DEAL.DATA%(5)   Similar structure to DEAL.DATA%(0)
 629: 0000: \***    10  2  INT  IRF.DEAL.DATA%(6)   Similar structure to DEAL.DATA%(0)
 630: 0000: \***    12  2  INT  IRF.DEAL.DATA%(7)   Similar structure to DEAL.DATA%(0)
 631: 0000: \***    14  2  INT  IRF.DEAL.DATA%(8)   Similar structure to DEAL.DATA%(0)
 632: 0000: \***    16  2  INT  IRF.DEAL.DATA%(9)   Similar structure to DEAL.DATA%(0)
 633: 0000: \***
 634: 0000: \***    Record Length 17
 635: 0000: \***
 636: 0000: \**********************************************************************************
 637: 0000: 
 638: 0000: 
 639: 0000:     STRING GLOBAL            \
 640: 0000:         IRF.ALT.FILE.NAME$,  \
 641: 0000:         IRF.BAR.CODE$,       \
 642: 0000:         IRF.BOOTS.CODE$,     \
 643: 0000:         IRF.DEAL.SAVING$,    \ 2 byte - deal saving amount (0 - œ99.99) ! ESP
 644: 0000:         IRF.DEPARTME$,       \ 3 byte UPD. Department number          ! ESP Delete
 645: 0000:         IRF.FILE.NAME$,      \
 646: 0000:         IRF.HOLDING.PRICE$,  \ 4 byte UPD. Current H.O. price in pence if a local
 647: 0000:                              \ price is in effect, zero otherwise.     ! ESP Delete
 648: 0000:         IRF.ITEMNAME$,       \
 649: 0000: \       IRF.MPGROUP$,        \ Removed SBH 31/1/96
 650: 0000:         IRF.RECORD$,         \                                         ! ESP Delete
 651: 0000:         IRF.SALEPRIC$,       \
 652: 0000:         IRF.SALEQUAN$,       \ Redundant (set to null within functions)    ! 1.6 RC
 653: 0000:         IRF.UNUSED$,         \                                                        ! 1.6 RC
 654: 0000:         NEW.IRF.DATA$        !                                             ! 1.7 RC
 655: 0000: 
 656: 0000:     STRING GLOBAL            \                                             ! 1.6 RC
 657: 0000:         IRF.DEAL.NUM$(1)                                                   ! 1.6 RC
 658: 0000: 
 659: 0000:     INTEGER*1 GLOBAL         \
 660: 0000:         IRF.DD.SUB%,         \ IRF.DEAL.DATA% subscript                    ! 1.6 RC
 661: 0000:         IRF.INDICAT0%,       \
 662: 0000:         IRF.INDICAT1%,       \
 663: 0000:         IRF.INDICAT2%,       \ Redundant (set to null within functions)    ! 1.6 RC
 664: 0000:         IRF.INDICAT3%,       \
 665: 0000:         IRF.INDICAT4%,       \ Redundant (set to null within functions)    ! 1.6 RC
 666: 0000:         IRF.INDICAT5%,       \                                             ! 2.0 AJC
 667: 0000:         IRF.INDICAT8%,       \                                             ! 2.0 AJC
 668: 0000:         IRF.INDICAT9%,       \                                             ! 2.2 TT
 669: 0000:         IRF.INDICAT10%                                                     ! 2.2 TT
 670: 0000: 
 671: 0000:     INTEGER*1 GLOBAL         \                                             ! 1.6 RC
 672: 0000:         IRF.LIST.ID%(1)                                                    ! 1.6 RC
 673: 0000: 
 674: 0000:     INTEGER*2 GLOBAL         \
 675: 0000:         IRF.ALT.REPORT.NUM%, \
 676: 0000:         IRF.ALT.SESS.NUM%,   \
 677: 0000:         IRF.POINTS%,         \ Redundant (set to null within functions)    ! 1.6 RC
 678: 0000:         IRF.RECL%,           \
 679: 0000:         IRF.REPORT.NUM%,     \
 680: 0000:         IRF.SESS.NUM%,       \
 681: 0000:         IRF.MAX.DEALS%       !                                             ! 1.9 SM
 682: 0000: 
 683: 0000:     STRING GLOBAL IRFDEX.FILE.NAME$                                        ! 1.9 SM
 684: 0000: 
 685: 0000:     INTEGER*2 GLOBAL IRFDEX.SESS.NUM%                                      ! 1.9 SM
 686: 0000:     INTEGER*2 GLOBAL IRFDEX.REPORT.NUM%                                    ! 1.9 SM
 687: 0000:     INTEGER*2 GLOBAL IRFDEX.RECL%                                          ! 1.9 SM
 688: 0000: 
 689: 0000: 
 690: 0000: !   INTEGER*2 GLOBAL      \ IRF.DEAL.DATA%(n) variables are defined locally  1.6 RC
 691: 0000: !       IRF.DEAL.DATA%(1) \ within IRFFUN.BAS to keep invisible to programs  1.6 RC
 692: 0000: 
 693: 0000:       %INCLUDE TIFDEC.J86                                             ! FSP
 694: 0000: 
 695: 0000: \*********************************************************************************
 696: 0000: \***
 697: 0000: \***    %INCLUDE FOR TERMINAL ITEM FILE - VARIABLE DECLARATIONS
 698: 0000: \***
 699: 0000: \***            FILE TYPE : Keyed
 700: 0000: \***          
 701: 0000: \***            REFERENCE : TIFDEC.J86
 702: 0000: \***
 703: 0000: \***    Version A             Steve Windsor          06.05.93
 704: 0000: \*** 
 705: 0000: \***    Version B             Steve Perkins          21.09.93
 706: 0000: \***    Deals project: fields names updated to reflect new
 707: 0000: \***    IRF layout for deals project.
 708: 0000: \***
 709: 0000: \***    Version C              Dave West             08.09.98
 710: 0000: \***    Added declarations for GSA v2
 711: 0000: \***
 712: 0000: \***    Version D      Stuart William McConnachie    11.02.2000
 713: 0000: \***    Changed TIF.INDICAT2$ to TIF.INDICAT2%
 714: 0000: \***    Changed TIF.DEAL.NUM$ to TIF.DEAL.NUM%
 715: 0000: \***
 716: 0000: \***    REVISION 1.5.                ROBERT COWEY.                05 AUG 2002.
 717: 0000: \***    Major changes for 2002 Deals Rewrite project.
 718: 0000: \***    Incorporated up to date record layout to assist development work 
 719: 0000: \***    (placed in the TIFDEC.J86 to make it visible from ...LST files).
 720: 0000: \***    Defined TIF.IRF.DATA$ as a global variable for use with new functions
 721: 0000: \***    CONCAT.TIF.IRF.DATA$ and SPLIT.TIF.IRF.DATA$.
 722: 0000: \***
 723: 0000: \***    REVISION 1.6.                ROBERT COWEY.                23 JAN 2003.
 724: 0000: \***    Corrected comments only.
 725: 0000: \***
 726: 0000: \***.............................................................................
 727: 0000: 
 728: 0000: 
 729: 0000: \*********************************************************************************
 730: 0000: \***
 731: 0000: \***    TIF RECORD LAYOUT - REVISION 1.5 - CORRECT FOR 2002 DEALS RE-WRITE PROJECT
 732: 0000: \***
 733: 0000: \***    Within Boots stores the TMCF.DESCTYPE% = 4
 734: 0000: \***    This defines the TIF.FORMAT% = 7 (TIF.RECL% = 18) layout that follows
 735: 0000: \***    Other TIF.FORMAT% layouts are not used by Boots
 736: 0000: \***
 737: 0000: \***     1  6  UPD  BAR.CODE$   Without check digit - File KEY
 738: 0000: \***       11  UPD  Modified    Padded with leading zeros to an 11 byte UPD
 739: 0000: \***     7  1  INT  INDICAT6%   Bit flags - Identical to IRF.INDICAT1%
 740: 0000: \***                    X"01" - Asprin
 741: 0000: \***                    X"02" - Paracetamol
 742: 0000: \***                    X"04" - TPLU inclusion flag
 743: 0000: \***                              "04" on till
 744: 0000: \***                              "00" not on till
 745: 0000: \***                    X"08" - Stock number required
 746: 0000: \***                    X"10" - Pharmacy item
 747: 0000: \***                    X"20" - Age restricted video
 748: 0000: \***                    X"40" - Insurance
 749: 0000: \***                    X"80" - Ibuprofen
 750: 0000: \***     8  2  INT  DEAL.DATA%(0)   See IRFDEC.J86 for further detail
 751: 0000: \***                    Sub-structure not used by TIF file functions
 752: 0000: \***                    X'3F' - Deal number 0 to 9999
 753: 0000: \***                    X'C0' - List ID     X'00' X
 754: 0000: \***                                        X'01' A
 755: 0000: \***                                        X'10' B
 756: 0000: \***                                        X'11' C                       ! 1.6 RC
 757: 0000: \***    10  2  INT  DEAL.DATA%(1)   See DEAL.DATA(0) for structure
 758: 0000: \***    12  3  UPD  SALEPRIC$   Current price in pence
 759: 0000: \***                            Zero price indicates Enforced Price Entry
 760: 0000: \***                            X'FFFFFF' indicates 1p giveaway item not priced
 761: 0000: \***                            (flag set on TIF.INDICAT0% by TIF READ function)
 762: 0000: \***        5  UPD  Modified    Padded with leading zeros to a 5 byte UPD
 763: 0000: \***    15  1  INT  INDICAT5%   Guarantee duration
 764: 0000: \***                    X'3F' - Lowest 6 bits indicate duration (1-63)
 765: 0000: \***                    X'80' - Highest bit indicates months if set (years if not)
 766: 0000: \***                    X'40' - Item movement kept (not related to guarentee data)
 767: 0000: \***                            (flag set on TIF.INDICAT0% by TIF READ function)
 768: 0000: \***    16  2  INT  DEAL.DATA%(2)   See DEAL.DATA(0) for structure
 769: 0000: \***    18  1  INT  INDICAT3%   Bit flags - Identical to IRF.INDICAT3%
 770: 0000: \***                    X"01" - Discount exempt (item exempt from discount)
 771: 0000: \***                    X"02" - Boots brand item
 772: 0000: \***                    X"04" - Item redeemable for loyalty
 773: 0000: \***                    X"08" - Loyalty exempt (item exempt from loyalty)
 774: 0000: \***                    X"10" - Wellbeing Services item
 775: 0000: \***                    X"20" - Local Price active
 776: 0000: \***                    X"40" - Stock system item
 777: 0000: \***                    X"80" - CSR item
 778: 0000: \***
 779: 0000: \***    Record length 18
 780: 0000: \***
 781: 0000: \***    TIF VARIABLES - HELD EXTERNALLY FROM RECORD ITSELF
 782: 0000: \***
 783: 0000: \***     -  1  INT  INDICAT0%   Bit flags
 784: 0000: \***                    X"02" - Item not priced (giveaway)  Held in SALEPRIC
 785: 0000: \***                    X"80" - Item Movement kept          Held in INDICAT5%
 786: 0000: \***
 787: 0000: \***..............................................................................
 788: 0000:                                             
 789: 0000:     
 790: 0000:     STRING GLOBAL         \
 791: 0000:         TIF.BAR.CODE$,    \
 792: 0000:         TIF.BOOTS.CODE$,  \
 793: 0000:         TIF.DEAL.SAVING$, \ ! No longer used                              ! 1.5 RC
 794: 0000:         TIF.FILE.NAME$,   \
 795: 0000:         TIF.FILLER$,      \ ! No longer used                              ! 1.5 RC
 796: 0000:         TIF.IRF.DATA$,    \ ! Used to hold copy of IRF record string
 797: 0000:         TIF.ITEMNAME$,    \ ! No longer used                              ! 1.5 RC
 798: 0000:         TIF.MPGROUP$,     \ ! No longer used                              ! 1.5 RC
 799: 0000:         TIF.RECORD$,      \                                               ! 1.5 RC
 800: 0000:         TIF.SALEQUAN$,    \ ! No longer used                              ! 1.5 RC
 801: 0000:         TIF.SALEPRIC$
 802: 0000: 
 803: 0000:         
 804: 0000:     INTEGER*1 GLOBAL   \
 805: 0000:         TIF.INDICAT0%, \
 806: 0000:         TIF.INDICAT1%, \
 807: 0000:         TIF.INDICAT2%, \ ! No longer used                                 ! 1.5 RC
 808: 0000:         TIF.INDICAT3%, \
 809: 0000:         TIF.INDICAT4%, \ ! No longer used                                 ! 1.5 RC
 810: 0000:         TIF.INDICAT5%, \ ! No longer used                                 ! 1.5 RC
 811: 0000:         TIF.INDICAT6%, \
 812: 0000:         TIF.FORMAT%    ! Boots format (TIF.FORMAT% = 7) only is used      ! 1.5 RC
 813: 0000: 
 814: 0000:     
 815: 0000:     INTEGER*2 GLOBAL     \
 816: 0000:         TIF.DEAL.NUM%,   \ ! No longer used                               ! 1.5 RC
 817: 0000:         TIF.RECL%,       \ ! Actual RECL used in OPEN, READ, WRITE statements
 818: 0000:         TIF.RECL1%,      \ ! No longer used                               ! 1.5 RC
 819: 0000:         TIF.RECL2%,      \ ! No longer used                               ! 1.5 RC
 820: 0000:         TIF.RECL3%,      \ ! No longer used                               ! 1.5 RC
 821: 0000:         TIF.RECL4%,      \ ! No longer used                               ! 1.5 RC
 822: 0000:         TIF.RECL5%,      \ ! No longer used                               ! 1.5 RC
 823: 0000:         TIF.RECL6%,      \ ! No longer used                               ! 1.5 RC
 824: 0000:         TIF.RECL7%,      \ ! Record length for TIF.FORMAT% = 7
 825: 0000:         TIF.REPORT.NUM%, \
 826: 0000:         TIF.SESS.NUM%
 827: 0000: 
 828: 0000: 
 829: 0000:     INTEGER*2 GLOBAL \                                                    ! 1.5 RC
 830: 0000:         TIF.DEAL.DATA%(1)                                                 ! 1.5 RC
 831: 0000: 
 832: 0000: 
 833: 0000:       %INCLUDE TMCFDEC.J86                                            ! FSP
 834: 0000: \*****************************************************************************
 835: 0000: \*****************************************************************************
 836: 0000: \***
 837: 0000: \***         %INCLUDE FOR TERMINAL MAINT CONT FILE - FIELD DECLARATIONS
 838: 0000: \***                                          FILE REFERENCE PARAMETERS
 839: 0000: \***
 840: 0000: \***                      FILE TYPE    :
 841: 0000: \***
 842: 0000: \***                      REFERENCE    : tmcfdeca.J86
 843: 0000: \***
 844: 0000: \***      Version A             Steve Windsor          8.2.93
 845: 0000: \***
 846: 0000: \***    Revision 1.3            ROBERT COWEY                      19 JUN 2002
 847: 0000: \***    Defined new function WRITE.TMCF.HEADER.
 848: 0000: \***    No changes to this file.
 849: 0000: \***
 850: 0000: \*****************************************************************************
 851: 0000: \*****************************************************************************
 852: 0000: 
 853: 0000: 
 854: 0000:   STRING GLOBAL            \
 855: 0000:     TMCF.FILE.NAME$
 856: 0000: 
 857: 0000:   INTEGER*2 GLOBAL         \
 858: 0000:     TMCF.REC.NO%,          \
 859: 0000:     TMCF.SESS.NUM%,        \
 860: 0000:     TMCF.REPORT.NUM%
 861: 0000: 
 862: 0000:   STRING GLOBAL            \
 863: 0000:     TMCF.RCDKEY$,          \ 11 byte UPD.     Key of last item updated
 864: 0000:     TMCF.SPACE$,           \ 20 byte ASC.     Not used at present        
 865: 0000:     TMCF.TERMLOAD$,        \ 2 byte UPD.      ID of terminal loading TIF
 866: 0000:     TMCF.MNTDATA$          ! 50 byte ASC.     Data for IRF record   
 867: 0000: 
 868: 0000: 
 869: 0000:   INTEGER*1 GLOBAL         \
 870: 0000:     TMCF.ACTION%,          \ 1 byte integer.  1 = Add/replace, 2 = delete
 871: 0000:     TMCF.DESCTYPE%,        \ 1 byte integer.  1 = full descriptor
 872: 0000:                            \                  2 = short descriptor
 873: 0000:                            \                  3 = no descriptor
 874: 0000:     TMCF.TERMILU%,         \ 1 byte integer.  Terminal look-up used;
 875: 0000:                            \                  0 = no, 1 = yes
 876: 0000:     TMCF.USERDATA%         ! 1 byte integer.  user data included flag
 877: 0000: 
 878: 0000: 
 879: 0000:   INTEGER*2 GLOBAL         \
 880: 0000:     TMCF.FILELVL%,         \ 2 byte integer.  Reload level for terminals
 881: 0000:     TMCF.RECL%             ! 2 byte integer.  TMCF record length
 882: 0000: 
 883: 0000: 
 884: 0000:   INTEGER*4 GLOBAL         \
 885: 0000:     TMCF.MAINTLVL%,        \ 4 byte integer. Maintenance level of last update
 886: 0000:     TMCF.NUMITEMS%,        \ 4 byte integer. Maximum number of items on TIF
 887: 0000:     TMCF.NUMRECS%          ! 4 byte integer. Current number of items on TIF
 888: 0000:       %INCLUDE GAOPTDEC.J86                                           ! FSP
 889: 0000: \******************************************************************************
 890: 0000: \******************************************************************************
 891: 0000: \***
 892: 0000: \***   $Workfile:   GAOPTDEC.J86  $
 893: 0000: \***
 894: 0000: \***   $Revision:   1.1  $
 895: 0000: \***
 896: 0000: \******************************************************************************
 897: 0000: \******************************************************************************
 898: 0000: \***
 899: 0000: \***   $Log:   V:\archive\j86\gaoptdec.j8v  $
 900: 0000: \***   
 901: 0000: \***      Rev 1.1   22 Dec 1994 11:56:46   DEVOSPS
 902: 0000: \***   ADDED GAOPT.RECL% AND GAOPT.RECNO%
 903: 0000: \***   VARIABLES
 904: 0000: \***   
 905: 0000: \******************************************************************************
 906: 0000: \******************************************************************************\*****************************************************************************
 907: 0000: \***      %INCLUDE for GAOPT - field declarations
 908: 0000: \***      Reference : GAOPTDEA.J86
 909: 0000: \***      Version A             Steve Windsor          10.05.93
 910: 0000: \.............................................................................
 911: 0000: 
 912: 0000:   STRING GLOBAL           \
 913: 0000:     GAOPT.FILE.NAME$,     \
 914: 0000:     LOCAL.GAOPT.FILE.NAME$
 915: 0000: 
 916: 0000:   INTEGER*2 GLOBAL        \
 917: 0000:     GAOPT.SESS.NUM%,      \
 918: 0000:     GAOPT.RECL%
 919: 0000: 
 920: 0000:   INTEGER*1 GLOBAL        \ 
 921: 0000:     GAOPT.REPORT.NUM%     ! 
 922: 0000: 
 923: 0000:   INTEGER*1 GLOBAL        \
 924: 0000:     GAOPT.LOGMSGS%,       \ Log warning message allowed
 925: 0000:     GAOPT.TERMILU%,       \ Terminal lookup used
 926: 0000:     GAOPT.OFFLCHNG%,      \ Offline price changes allowed
 927: 0000:     GAOPT.DESCTYPE%,      \ Item descriptor type
 928: 0000:     GAOPT.USERDATA%,      \ User data fields included
 929: 0000:     GAOPT.PCKGFCTR%       ! Packing factor
 930: 0000: 
 931: 0000:   INTEGER*4 GLOBAL        \  
 932: 0000:     GAOPT.RECNO%,         \ 
 933: 0000:     GAOPT.NUMITEMS%,      \ Number of item records
 934: 0000:     GAOPT.DFLTSIZE%       ! Default threshold size of TMCF
 935: 0000:     
 936: 0000: 
 937: 0000:       %INCLUDE IDFDEC.J86                                             ! 1.11 NWB
 938: 0000: REM \
 939: 0000: \******************************************************************************
 940: 0000: \******************************************************************************
 941: 0000: \***
 942: 0000: \***         %INCLUDE FOR ITEM DATA FILE - FIELD DECLARATIONS
 943: 0000: \***                                       FILE REFERENCE PARAMETERS
 944: 0000: \***
 945: 0000: \***                  FILE TYPE    : Keyed
 946: 0000: \***
 947: 0000: \***                  REFERENCE    : IDFDEC.J86
 948: 0000: \***
 949: 0000: \***         VERSION A : Andrew Wedgeworth  29th June 1992    
 950: 0000: \***
 951: 0000: \***    VERSION C.              Robert Cowey.                       25 AUG 1993.
 952: 0000: \***    Replaced un-used RANK$ with BSNS.CNTR$ and FILLER$.
 953: 0000: \***
 954: 0000: \***    VERSION D.              Andrew Wedgeworth               15th March 1995
 955: 0000: \***    Comments updated to reflect the fact that some bits on the file are
 956: 0000: \***    no longer used.
 957: 0000: \***
 958: 0000: \*******************************************************************************
 959: 0000: \*******************************************************************************
 960: 0000: 
 961: 0000:   STRING GLOBAL           \
 962: 0000:     IDF.FILE.NAME$,       \  
 963: 0000:     IDF.BOOTS.CODE$,      \ 4 byte UPD with check digit (key)
 964: 0000:     IDF.FIRST.BAR.CODE$,  \ 6 byte UPD without check digit
 965: 0000:     IDF.SECOND.BAR.CODE$, \ 6 byte UPD without check digit
 966: 0000:     IDF.NO.OF.BAR.CODES$, \ 2 byte UPD. Total number of bar codes for this item
 967: 0000:     IDF.PRODUCT.GRP$,     \ 3 byte UPD. The first two digits are the concept
 968: 0000:                           \ group and the last four the concept sequence
 969: 0000:     IDF.STNDRD.DESC$,     \ 24 bytes
 970: 0000:     IDF.STATUS.1$,        \ 1 byte, values B,C,D,P,X,Z and blank
 971: 0000:     IDF.INTRO.DATE$,      \ 3 byte UPD YYMMDD. Date first added to this file
 972: 0000:     IDF.BSNS.CNTR$,       \ 1 byte ASC. Business Centre ID letter      ! CRC
 973: 0000:     IDF.FILLER$,          \ 1 byte un-used                             ! CRC
 974: 0000:     IDF.PARENT.CODE$,     \ 4 byte UPD with check digit ; may be zero if no
 975: 0000:                           \ flashpacks, current IDF.BOOTS.CODE$ if parent line
 976: 0000:                           \ or Boots Code of parent line if a flashpack.
 977: 0000:     IDF.DATE.OF.LAST.SALE$! 3 byte UPD. Date of last sale.
 978: 0000: 
 979: 0000:   INTEGER*1 GLOBAL        \
 980: 0000:     IDF.BIT.FLAGS.1%,     \ 1 byte - bit values
 981: 0000:                           \ X"80"  - Group code flag
 982: 0000:                           \ X"40"  - Keylines flag
 983: 0000:                           \ X"20"  - Markdown flag
 984: 0000:                           \ X"10"  - Warehouse flag
 985: 0000:                           \ X"08"  - CSR flag
 986: 0000:                           \ X"04"  - Directs A flag
 987: 0000:                           \ X"02"  - Directs B flag
 988: 0000:                           \ X"01"  - Directs C flag
 989: 0000:     IDF.BIT.FLAGS.2%      \ 1 byte - bit values
 990: 0000:                           \ X"80"  - Own brand line flag
 991: 0000:                           \ X"40"  - Exclusive line flag
 992: 0000:                           \ X"20"  - Unused 
 993: 0000:                           \ X"10"  - Unused
 994: 0000:                           \ X"08"  - Stock system flag
 995: 0000:                           \ X"04"  - Pending count flag
 996: 0000:                           \ X"02"  - Reserved
 997: 0000:                           ! X"01"  - Reserved
 998: 0000: 
 999: 0000:   INTEGER*2 GLOBAL        \
1000: 0000:     IDF.RECL%,            \  
1001: 0000:     IDF.REPORT.NUM%,      \ 
1002: 0000:     IDF.SESS.NUM%
1003: 0000:       %INCLUDE PHFDEC.J86                                             ! 1.11 NWB
1004: 0000: \/******************************************************************/
1005: 0000: \/*                                                                */
1006: 0000: \/* PRICE HISTORY FILE GLOBAl VARIABLE DECLARATIONS                */
1007: 0000: \/*                                                                */
1008: 0000: \/* REFERENCE   : PHFDEC.J86                                       */
1009: 0000: \/*                                                                */
1010: 0000: \/* VERSION A.          Neil Bennett.           23 OCTOBER 2006    */
1011: 0000: \/*                                                                */
1012: 0000: \/******************************************************************/
1013: 0000: 
1014: 0000:    STRING GLOBAL                \
1015: 0000:       PHF.FILE.NAME$,           \
1016: 0000:                                 \
1017: 0000:       PHF.BAR.CODE$,            \ PD  6 Barcode
1018: 0000:       PHF.CURR.TYPE$,           \ ASC 1 L/R/E (Local/Rpd/Emergency)
1019: 0000:       PHF.CURR.DATE$,           \ PD  3 YYMMDD
1020: 0000:       PHF.CURR.LABL$,           \ ASC 1 0,1,2,3 for current label type
1021: 0000:       PHF.HIST1.DATE$,          \ PD  3 YYMMDD
1022: 0000:       PHF.HIST1.TYPE$,          \ ASC 1 L/R/E (Local/Rpd/Emergency)
1023: 0000:       PHF.HIST2.DATE$,          \ PD  3 YYMMDD
1024: 0000:       PHF.HIST2.TYPE$,          \ ASC 1 L/R/E (Local/Rpd/Emergency)
1025: 0000:       PHF.LAST.INC.DATE$,       \ PD  3 YYMMDD
1026: 0000:       PHF.PEND.DATE$,           \ PD  3 YYMMDD
1027: 0000:       PHF.PEND.TYPE$,           \ ASC 1 L/R/E (Local/Rpd/Emergency)
1028: 0000:       PHF.FILLER$               ! ASC 2 Not Used
1029: 0000: 
1030: 0000:    INTEGER*2 GLOBAL             \
1031: 0000:       PHF.RECL%,                \
1032: 0000:       PHF.REPORT.NUM%,          \
1033: 0000:       PHF.SESS.NUM%             !
1034: 0000: 
1035: 0000:    INTEGER*4 GLOBAL             \
1036: 0000:       PHF.CURR.PRICE%,          \ INT 4 Price in pence
1037: 0000:       PHF.HIST1.PRICE%,         \ INT 4 Price in pence
1038: 0000:       PHF.HIST2.PRICE%,         \ INT 4 Price in pence
1039: 0000:       PHF.PEND.PRICE%           ! INT 4 Price in pence
1040: 0000: 
1041: 0000: \/******************************************************************/
1042: 0000:       %INCLUDE SRITLDEC.J86                                           ! 1.11 NWB
1043: 0000: \********************************************************************
1044: 0000: \***      EXTERNAL FUNCTION DECLARATIONS FOR THE SRITL FILE
1045: 0000: \***      REFERENCE : SRITLDEC.J86
1046: 0000: \***      Version A           Neil Bennett            5th June 2006
1047: 0000: \***
1048: 0000: \********************************************************************
1049: 0000: 
1050: 0000:   INTEGER*1 GLOBAL        \
1051: 0000:     SRITL.RECORD.CHAIN%,  \ Chain Sequence
1052: 0000:     SRITL.MODULE.COUNT%,  \ Family hierarchy key level
1053: 0000:     SRITL.MODULE.SEQ%(1), \ Module sequence
1054: 0000:     SRITL.REPEAT.CNT%(1)  ! Repeat count
1055: 0000: 
1056: 0000:   INTEGER*2 GLOBAL        \
1057: 0000:     SRITL.CORE.COUNT%,    \ Sum of repeat count for core items
1058: 0000:     SRITL.MAX.MOD.KEYS%,  \ Maximum number of modules
1059: 0000:     SRITL.NON.CORE.CNT%,  \ Sum of repeat count for non core items
1060: 0000:     SRITL.SESS.NUM%,      \
1061: 0000:     SRITL.REPORT.NUM%,    \
1062: 0000:     SRITL.RECL%           !
1063: 0000: 
1064: 0000:   INTEGER*4 GLOBAL        \
1065: 0000:     SRITL.POGDB%(1)       ! Unique POG Database key
1066: 0000: 
1067: 0000:   STRING GLOBAL           \
1068: 0000:     SRITL.FILE.NAME$,     \ File name
1069: 0000:     SRITL.COPY.NAME$,     \ File name
1070: 0000:     SRITL.ITEM.CODE$,     \ Boots Item Code
1071: 0000:     SRITL.CORE.FLAG$(1),  \ Core/Non Core flag Y/N
1072: 0000:     SRITL.FILLER$         !
1073: 0000: 
1074: 0000: 
1075: 0000:       %INCLUDE SOFTSDEC.J86                                           ! 1.11 NWB
1076: 0000: REM \
1077: 0000: \******************************************************************************
1078: 0000: \******************************************************************************
1079: 0000: \***
1080: 0000: \***                 %INCLUDE FOR THE SOFTWARE STATUS FILE
1081: 0000: \***   
1082: 0000: \***                      FILE TYPE  :   Direct
1083: 0000: \***
1084: 0000: \***                      REFERENCE  :   SOFTSDEC.J86
1085: 0000: \***
1086: 0000: \***	Version A	       Andrew Wedgeworth	      24th June 1992
1087: 0000: \***
1088: 0000: \******************************************************************************
1089: 0000: \*******************************************************************************
1090: 0000: 
1091: 0000:   STRING GLOBAL           \
1092: 0000:     SOFTS.RECORD$,        \           
1093: 0000:     SOFTS.SPACE$,         \           
1094: 0000:     SOFTS.FILE.NAME$    
1095: 0000:     
1096: 0000:   INTEGER*2 GLOBAL        \
1097: 0000:     SOFTS.RECL%,          \            
1098: 0000:     SOFTS.REPORT.NUM%,	  \      
1099: 0000:     SOFTS.SESS.NUM%
1100: 0000: 
1101: 0000:   INTEGER*4 GLOBAL        \
1102: 0000:     SOFTS.REC.NUM% 	         
1103: 0000: 
1104: 0000:       %INCLUDE ADXERROR.J86
1105: 0000: \******************************************************************************
1106: 0000: \******************************************************************************
1107: 0000: \***                                                                        ***
1108: 0000: \***    %INCLUDE FOR FUNCTION ADXERROR (an I.B.M. system function)          ***
1109: 0000: \***                                                                        ***
1110: 0000: \***         AUTHOR        :  Stephen Kelsey                                ***
1111: 0000: \***                                                                        ***
1112: 0000: \***         DATE WRITTEN  :  21st February 1986                            ***
1113: 0000: \***                                                                        ***
1114: 0000: \***         DATE OF LAST REVISION  - 21st February 1986                    ***
1115: 0000: \***                                                                        ***
1116: 0000: \***         VERSION B     :  Stuart William McConnachie  18th March 1997   ***
1117: 0000: \***    Define size of ADXERROR return value from function.  This change    ***
1118: 0000: \***    was introduced by IBM in the 4690 Programming Guide.  Not defining  ***
1119: 0000: \***    this variable can cause Memory Protection Violations at run time.   ***
1120: 0000: \***                                                                        ***
1121: 0000: \******************************************************************************
1122: 0000: \******************************************************************************
1123: 0000: 
1124: 0000:    FUNCTION ADXERROR (TERM%,                                                  \
1125: 0000:                       MSGGRP%,                                                \
1126: 0000:                       MSGNUM%,                                                \
1127: 0000:                       SEVERITY%,                                              \
1128: 0000:                       EVENT.NUM%,                                             \
1129: 0000:                       UNIQUE$) EXTERNAL
1130: 0000: 
1131: 0000:       INTEGER*2  MSGNUM%,                                                     \
1132: 0000:                  TERM%,                                                       \
1133: 0000:                  ADXERROR                                                     !BSWM
1134: 0000: 
1135: 0000:       INTEGER*1 EVENT.NUM%,                                                   \
1136: 0000:                 MSGGRP%,                                                      \
1137: 0000:                 SEVERITY%
1138: 0000: 
1139: 0000:       STRING  UNIQUE$
1140: 0000: 
1141: 0000:    END FUNCTION
1142: 0000: 
1143: 0000:       %INCLUDE ADXSERVE.J86
1144: 0000: \******************************************************************************
1145: 0000: \******************************************************************************
1146: 0000: \***                                                                        ***
1147: 0000: \***    %INCLUDE FOR FUNCTION ADXSERVE (an I.B.M. system function)          ***
1148: 0000: \***                                                                        ***
1149: 0000: \***         AUTHOR        :  Bruce Scriver                                 ***
1150: 0000: \***                                                                        ***
1151: 0000: \***         DATE WRITTEN  :  14th March 1986                               ***
1152: 0000: \***                                                                        ***
1153: 0000: \***         DATE OF LAST REVISION  - 14th March 1986                       ***
1154: 0000: \***                                                                        ***
1155: 0000: \***                                                                        ***
1156: 0000: \******************************************************************************
1157: 0000: \******************************************************************************
1158: 0000: 
1159: 0000:    SUB ADXSERVE (RETURN.CODE%,                                                \
1160: 0000:                  ADX.FUNCTION%,                                               \
1161: 0000:                  ADX.PARM.1%,                                                 \
1162: 0000:                  ADX.PARM.2$)                                                 \
1163: 0000:    EXTERNAL
1164: 0000:   
1165: 0000:       STRING     ADX.PARM.2$
1166: 0000: 
1167: 0000:       INTEGER*2  ADX.FUNCTION%,                                               \
1168: 0000:                  ADX.PARM.1%
1169: 0000: 
1170: 0000:       INTEGER*4  RETURN.CODE%                                                 \
1171: 0000: 
1172: 0000:    END SUB     
1173: 0000: 
1174: 0000:       %INCLUDE PSBF01E.J86                                            ! DAW
1175: 0000: REM \
1176: 0000: \*******************************************************************************
1177: 0000: \*******************************************************************************
1178: 0000: \***
1179: 0000: \***      %INCLUDE FOR EXTERNAL DEFINITION OF FUNCTION APPLICATION.LOG
1180: 0000: \***
1181: 0000: \***                      FUNCTION NUMBER   : PSBF01
1182: 0000: \***
1183: 0000: \***                    INCLUDE REFERENCE : PSBF01E.J86
1184: 0000: \*** 
1185: 0000: \***      Version B           Andrew Wedgeworth          1st July 1992
1186: 0000: \***      Three parameters which passed to the function have been removed.
1187: 0000: \***      APPLICATION.LOG has been added as a variable name (this holds the
1188: 0000: \***      return code).
1189: 0000: \***
1190: 0000: \*******************************************************************************
1191: 0000: 
1192: 0000: 
1193: 0000:    FUNCTION APPLICATION.LOG (MESSAGE.NO%,                                     \
1194: 0000:                              VAR.STRING.1$,                                   \
1195: 0000:                              VAR.STRING.2$,                                   \
1196: 0000:                              EVENT.NO%)  EXTERNAL
1197: 0000: 
1198: 0000:       INTEGER*1 EVENT.NO%
1199: 0000: 
1200: 0000:       INTEGER*2 APPLICATION.LOG,                                       \ GAW
1201: 0000:                 MESSAGE.NO%
1202: 0000: 
1203: 0000:       STRING VAR.STRING.1$,                                            \
1204: 0000:              VAR.STRING.2$
1205: 0000: 
1206: 0000:    END FUNCTION
1207: 0000: 
1208: 0000: \*******************************************************************************
1209: 0000:       %INCLUDE PSBF02E.J86                                            ! 1.11 NWB
1210: 0000: REM\
1211: 0000: \*******************************************************************************
1212: 0000: \*******************************************************************************
1213: 0000: \***
1214: 0000: \***        INCLUDE       : UPDATE.DATE external definition
1215: 0000: \***        AUTHOR        : Bruce Scriver (Basic Code)
1216: 0000: \***        DATE WRITTEN  : 4th March 1986 (Basic Code)
1217: 0000: \***
1218: 0000: \***        REFERENCE     : PSBF02E.J86
1219: 0000: \***
1220: 0000: \***        Version A     Bruce Scriver          4th March 1986
1221: 0000: \***
1222: 0000: \***        Version B     Andrew Wedgeworth       6th July 1992
1223: 0000: \***        Removal of redundant parameters, and inclusion of UPDATE.DATE as
1224: 0000: \***        a variable to hold the return code.
1225: 0000: \***
1226: 0000: \*******************************************************************************
1227: 0000: \*******************************************************************************
1228: 0000: 
1229: 0000:    FUNCTION UPDATE.DATE (INCREMENT%)                                   \
1230: 0000:    EXTERNAL
1231: 0000:    ! 3 parameters removed from here                                    ! BAW
1232: 0000: 
1233: 0000:    ! 3 lines deleted from here                                         ! BAW
1234: 0000:    
1235: 0000:       INTEGER*2 UPDATE.DATE                                            ! BAW
1236: 0000: 
1237: 0000:       INTEGER*4 INCREMENT%
1238: 0000: 
1239: 0000:    END FUNCTION
1240: 0000: 
1241: 0000:       %INCLUDE PSBF16E.J86                                            ! DAW
1242: 0000: REM\
1243: 0000: \*******************************************************************************
1244: 0000: \*******************************************************************************
1245: 0000: \***
1246: 0000: \***       %INCLUDE FOR EXTERNAL DEFINITION OF CONV.TO.HEX FUNCTION
1247: 0000: \***
1248: 0000: \***                  REFERENCE     : PSBF16E.J86
1249: 0000: \***
1250: 0000: \***       Version A            Bruce Scriver          25th February 1986
1251: 0000: \***
1252: 0000: \***       Version B           Andrew Wedgeworth            2nd July 1992
1253: 0000: \***       Removal of redundant parameters, and CONV.TO.HEX defined as a 
1254: 0000: \***       variable to hold the return code. 
1255: 0000: \***
1256: 0000: \*******************************************************************************
1257: 0000: \*******************************************************************************
1258: 0000: 
1259: 0000:    FUNCTION CONV.TO.HEX (INTEGER4%)                                            \
1260: 0000:    EXTERNAL
1261: 0000:    ! 3 parameters removed from here                                    ! BAW
1262: 0000: 
1263: 0000:    ! 3 lines deleted from here                                         ! BAW
1264: 0000:    
1265: 0000:       INTEGER*2 CONV.TO.HEX                                            ! BAW
1266: 0000: 
1267: 0000:       INTEGER*4 INTEGER4%
1268: 0000: 
1269: 0000:    END FUNCTION
1270: 0000: 
1271: 0000:       %INCLUDE PSBF17E.J86                                            ! DAW
1272: 0000: REM \
1273: 0000: \*******************************************************************************
1274: 0000: \*******************************************************************************
1275: 0000: \***
1276: 0000: \***
1277: 0000: \***       %INCLUDE FOR EXTERNAL DEFINITION OF CONV.TO.STRING FUNCTION
1278: 0000: \***
1279: 0000: \***                     REFERENCE     : PSBF17E.J86
1280: 0000: \***
1281: 0000: \***       Version A            Bruce Scriver       24th February 1986           
1282: 0000: \***
1283: 0000: \***       Version B          Andrew Wedgeworth          2nd July 1992
1284: 0000: \***       Redundant parameters removed, and the function's name is 
1285: 0000: \***       is defined as a variable to hold the return code. 
1286: 0000: \***
1287: 0000: \*******************************************************************************
1288: 0000: \*******************************************************************************
1289: 0000: 
1290: 0000:    FUNCTION CONV.TO.STRING (EVENT.NUMBER%,                                     \
1291: 0000:                             INTEGER4%)                                         \
1292: 0000:    EXTERNAL
1293: 0000: ! 3 parameters removed from here                                       ! BAW
1294: 0000: 
1295: 0000: ! 3 lines deleted from here                                            ! BAW
1296: 0000: 
1297: 0000:       INTEGER*1 EVENT.NUMBER%
1298: 0000: 
1299: 0000:       INTEGER*2 CONV.TO.STRING                                         ! BAW
1300: 0000: 
1301: 0000:       INTEGER*4 INTEGER4%
1302: 0000: 
1303: 0000:    END FUNCTION
1304: 0000: 
1305: 0000:       %INCLUDE PSBF18E.J86                                            ! 1.11 NWB
1306: 0000: REM\
1307: 0000: \*******************************************************************************
1308: 0000: \*******************************************************************************
1309: 0000: \***
1310: 0000: \***        INCLUDE       : CALC.BOOTS.CODE.CHECK.DIGIT external definition
1311: 0000: \***
1312: 0000: \***        REFERENCE     : PSBF18E.J86
1313: 0000: \***
1314: 0000: \***        Version A      Stephen Kelsey                   23rd March 1987 
1315: 0000: \***
1316: 0000: \***        Version B      Andrew Wedgeworth                  7th July 1992 
1317: 0000: \***        Removal of redundant parameters, and inclusion of function's 
1318: 0000: \***        name as a variable to hold the return code.
1319: 0000: \***
1320: 0000: \*******************************************************************************
1321: 0000: \*******************************************************************************
1322: 0000: 
1323: 0000:    FUNCTION CALC.BOOTS.CODE.CHECK.DIGIT (BOOTS.CODE.6.DIGIT$)          \ 
1324: 0000:    EXTERNAL
1325: 0000:    ! 3 parameters removed from here                                    ! BAW
1326: 0000: 
1327: 0000:    STRING BOOTS.CODE.6.DIGIT$
1328: 0000:    ! 3 variables deleted from here                                     ! BAW
1329: 0000:    
1330: 0000:    INTEGER* 2 CALC.BOOTS.CODE.CHECK.DIGIT                              ! BAW
1331: 0000:    
1332: 0000:    END FUNCTION
1333: 0000: 
1334: 0000:       %INCLUDE PSBF20E.J86                                            ! DAW
1335: 0000: REM\
1336: 0000: \*******************************************************************************
1337: 0000: \*******************************************************************************
1338: 0000: \***
1339: 0000: \***       %INCLUDE FOR EXTERNAL DEFINITION OF SESS.NUM.UTILITY
1340: 0000: \***
1341: 0000: \***                  REFERENCE     : PSBF20E.J86
1342: 0000: \***
1343: 0000: \***     VERSION C            Janet Smith                13th May 1992
1344: 0000: \***     Increased PASSED.INTEGER to 2 bytes to cater for more than
1345: 0000: \***     128 files.
1346: 0000: \***
1347: 0000: \***     VERSION D.           Andrew Wedgeworth          1st July 1992
1348: 0000: \***     Removal of redundant parameters and addition of SESS.NUM.UTILITY
1349: 0000: \***     as a variable.  This new variable contains the function's return
1350: 0000: \***     code.
1351: 0000: \***
1352: 0000: \*******************************************************************************
1353: 0000: \*******************************************************************************
1354: 0000: 
1355: 0000:    FUNCTION SESS.NUM.UTILITY (FUNCTION.FLAG$,                          \
1356: 0000:                               PASSED.INTEGER%,                         \
1357: 0000:                               PASSED.STRING$)                          \
1358: 0000:    EXTERNAL
1359: 0000: 
1360: 0000:    STRING    FUNCTION.FLAG$,                                           \
1361: 0000:              PASSED.STRING$
1362: 0000:    ! 3 variables removed from here                                     ! CAW
1363: 0000: 
1364: 0000: 
1365: 0000:    INTEGER*2 SESS.NUM.UTILITY,                                         \ CAW
1366: 0000:              PASSED.INTEGER%				               ! CJAS
1367: 0000: 
1368: 0000:    END FUNCTION
1369: 0000: 
1370: 0000:       %INCLUDE PSBF24E.J86                                            ! DAW
1371: 0000: REM \
1372: 0000: \*******************************************************************************
1373: 0000: \*******************************************************************************
1374: 0000: \***
1375: 0000: \***    %INCLUDE FOR EXTERNAL DEFINITION OF STANDARD.ERROR.DETECTED FUNCTION
1376: 0000: \***
1377: 0000: \***                      REFERENCE     : PSBF24E.J86
1378: 0000: \***
1379: 0000: \***    Version A                 Janet Smith                  13th May 1992
1380: 0000: \***
1381: 0000: \*******************************************************************************
1382: 0000: \*******************************************************************************
1383: 0000: 
1384: 0000:    FUNCTION STANDARD.ERROR.DETECTED(ERRN%,                 \
1385: 0000: 				    ERRFILE%,              \
1386: 0000: 				    ERRL%,                 \
1387: 0000: 				    ERR$)        EXTERNAL
1388: 0000: 				    
1389: 0000:           STRING    ERR$
1390: 0000: 
1391: 0000:           INTEGER*2 ERRFILE%,              \
1392: 0000: 	            ERRL%,                 \
1393: 0000: 		    STANDARD.ERROR.DETECTED
1394: 0000: 		    
1395: 0000:           INTEGER*4 ERRN%
1396: 0000: 	  		    
1397: 0000:    END FUNCTION
1398: 0000: 
1399: 0000: 
1400: 0000:       %INCLUDE PSBF46E.J86                                            ! 1.15 NWB
1401: 0000: \*******************************************************************************
1402: 0000: \*******************************************************************************
1403: 0000: \***
1404: 0000: \***        INCLUDE       : GET.LABEL.TYPE external definition
1405: 0000: \***        AUTHOR        : Neil Bennett
1406: 0000: \***        DATE WRITTEN  : 18th June 2007
1407: 0000: \***
1408: 0000: \***        REFERENCE     : PSBF46E.J86
1409: 0000: \***
1410: 0000: \***        Version A     Neil Bennett           18th June 2007
1411: 0000: \***
1412: 0000: \*******************************************************************************
1413: 0000: \*******************************************************************************
1414: 0000: 
1415: 0000:    FUNCTION GET.LABEL.TYPE(BAR.CODE$,                  \ UPD 6
1416: 0000:                            OLD.PRICE%,                 \ INT 4
1417: 0000:                            NEW.PRICE%,                 \ INT 4
1418: 0000:                            UPDATE.PHF$) EXTERNAL       ! ASC 1
1419: 0000: 
1420: 0000:       INTEGER*1 GET.LABEL.TYPE
1421: 0000:       INTEGER*4 OLD.PRICE%
1422: 0000:       INTEGER*4 NEW.PRICE%
1423: 0000:       STRING    UPDATE.PHF$
1424: 0000: 
1425: 0000:    END FUNCTION
1426: 0000: 
1427: 0000: 
1428: 0000:       %INCLUDE IRFEXT.J86                                             ! FSP
1429: 0000: \*********************************************************************************
1430: 0000: \***
1431: 0000: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE ITEM REFERENCE FILE
1432: 0000: \***
1433: 0000: \***                    REFERENCE : IRFEXT.J86
1434: 0000: \***
1435: 0000: \***      Version A          Andrew Wedgeworth        9th July 1992
1436: 0000: \***
1437: 0000: \***      Version B          Andrew Wedgeworth        14th December 1992
1438: 0000: \***      Version letter incremented to match other IRF code.
1439: 0000: \***
1440: 0000: \***      Version C           Steve Windsor        12.02.93
1441: 0000: \***      Added external reference to read the alternate IRF.
1442: 0000: \***
1443: 0000: \***      Version D           Steve Windsor        12.05.93
1444: 0000: \***      Added all external references that wre in the original FNS.
1445: 0000: \***
1446: 0000: \***      Version E           Steve Perkins        21.09.93
1447: 0000: \***      Deals project: Fields changed for new deals project
1448: 0000: \*** 
1449: 0000: \***      Version F           Mark Walker          5th January 1994
1450: 0000: \***      Version letter incremented to match other IRF code.           
1451: 0000: \***                                                                    
1452: 0000: \***      Version G     Stuart William McConnachie      11th February 2000
1453: 0000: \***      Converted IRF.INDICAT2$ to integer flag byte.
1454: 0000: \***
1455: 0000: \***      REVISION 1.6.               ROBERT COWEY.               9 JUL 2002.
1456: 0000: \***      Major changes to IRF layout for 2002 Deals Rewrite project.
1457: 0000: \***      No changes to this particular file for this revision.
1458: 0000: \***
1459: 0000: \***      REVISION 1.7.               ROBERT COWEY.               5 AUG 2002.
1460: 0000: \***      Further changes for 2002 Deals Rewrite project (PSBF19 related).
1461: 0000: \***      Defined new functions CONCAT.NEW.IRF.DATA$ and SPLIT.NEW.IRF.DATA$.
1462: 0000: \***
1463: 0000: \***      REVISION 1.8                ROBERT COWEY.              15 JUL 2003.
1464: 0000: \***      Usage of INDICAT0% bit-3 X'08' changed to Item Contains Alcohol.
1465: 0000: \***      No changes to this file other than description.
1466: 0000: \***      No changes to IRF file functions.
1467: 0000: \***
1468: 0000: \***      REVISION 1.9.      STUART WILLIAM MCCONNACHIE           22 OCT 2003.
1469: 0000: \***      Changes to remove limit of 3 deals per item.
1470: 0000: \***      No changes to this file.
1471: 0000: \***
1472: 0000: \***      REVISION 2.0.             ALAN CARR                      9 FEB 2006.
1473: 0000: \***      Add new IRF.INDICAT8% 1 byte, amend IRF.UNUSED$ from 3 to 2 bytes.
1474: 0000: \***      No changes to this file.
1475: 0000: \***
1476: 0000: \***..............................................................................
1477: 0000:    
1478: 0000:    FUNCTION IRF.SET EXTERNAL
1479: 0000:    END FUNCTION
1480: 0000: 
1481: 0000:   FUNCTION CONCAT.NEW.IRF.DATA$ EXTERNAL                                  ! 1.7 RC
1482: 0000:   END FUNCTION                                                            ! 1.7 RC
1483: 0000: 
1484: 0000:   FUNCTION SPLIT.NEW.IRF.DATA$ EXTERNAL                                   ! 1.7 RC
1485: 0000:   END FUNCTION                                                            ! 1.7 RC
1486: 0000:   
1487: 0000:   FUNCTION READ.IRF EXTERNAL
1488: 0000:    INTEGER*2 READ.IRF
1489: 0000:   END FUNCTION
1490: 0000: 
1491: 0000:   FUNCTION READ.IRF.ALT EXTERNAL
1492: 0000:    INTEGER*2 READ.IRF.ALT
1493: 0000:   END FUNCTION
1494: 0000: 
1495: 0000:   FUNCTION READ.IRF.LOCK EXTERNAL
1496: 0000:    INTEGER*2 READ.IRF.LOCK
1497: 0000:   END FUNCTION
1498: 0000: 
1499: 0000:   FUNCTION WRITE.IRF EXTERNAL
1500: 0000:    INTEGER*2 WRITE.IRF
1501: 0000:   END FUNCTION
1502: 0000: 
1503: 0000:   FUNCTION WRITE.IRF.UNLOCK EXTERNAL
1504: 0000:    INTEGER*2 WRITE.IRF.UNLOCK
1505: 0000:   END FUNCTION
1506: 0000: 
1507: 0000:   FUNCTION WRITE.IRF.HOLD EXTERNAL
1508: 0000:    INTEGER*2 WRITE.IRF.HOLD
1509: 0000:   END FUNCTION
1510: 0000: 
1511: 0000:   FUNCTION WRITE.IRF.HOLD.UNLOCK EXTERNAL
1512: 0000:    INTEGER*2 WRITE.IRF.HOLD.UNLOCK
1513: 0000:   END FUNCTION
1514: 0000: 
1515: 0000:   
1516: 0000:       %INCLUDE TIFEXT.J86                                             ! FSP
1517: 0000: \*****************************************************************************
1518: 0000: \***
1519: 0000: \***    %INCLUDE FOR TERMINAL ITEM FILE - EXTERNAL FUNCTION DEFINITIONS
1520: 0000: \***
1521: 0000: \***            REFERENCE : TIFEXT
1522: 0000: \***
1523: 0000: \***    Version A           Steve Windsor        06.05.93
1524: 0000: \***  
1525: 0000: \***    Version B           Steve Perkins        21.09.93
1526: 0000: \***    Deals project: No change to this code  
1527: 0000: \***
1528: 0000: \***    REVISION 1.5.                ROBERT COWEY.                05 AUG 2002.
1529: 0000: \***    Major changes for 2002 Deals Rewrite project.
1530: 0000: \***    Deleted redundant functions specific to unused record lengths and layouts.
1531: 0000: \***        READ.TIF.FULL.PLUS.USER.DATA
1532: 0000: \***        READ.TIF.FULL.NO.USER.DATA
1533: 0000: \***        READ.TIF.SHORT.PLUS.USER.DATA
1534: 0000: \***        READ.TIF.SHORT.NO.USER.DATA
1535: 0000: \***        READ.TIF.JUST.USER.DATA
1536: 0000: \***        READ.TIF.NO.DESC.OR.DATA
1537: 0000: \***        WRITE.TIF.FULL.NO.USER.DATA
1538: 0000: \***        WRITE.TIF.SHORT.PLUS.USER.DATA
1539: 0000: \***        WRITE.TIF.SHORT.NO.USER.DATA
1540: 0000: \***        WRITE.TIF.JUST.USER.DATA
1541: 0000: \***        WRITE.TIF.NO.DESC.OR.DATA
1542: 0000: \***      Defined new functions CREATE.TIF.RECORD$ and SPLIT.TIF.IRF.DATA$.
1543: 0000: \***
1544: 0000: \***    REVISION 1.6.                ROBERT COWEY.                23 JAN 2003.
1545: 0000: \***    No changes to this file for this revision.
1546: 0000: \***
1547: 0000: \***.............................................................................
1548: 0000: 
1549: 0000: 
1550: 0000: FUNCTION TIF.SET EXTERNAL
1551: 0000: END FUNCTION
1552: 0000: 
1553: 0000: FUNCTION CREATE.TIF.RECORD$ EXTERNAL                                    ! 1.5 RC
1554: 0000: END FUNCTION                                                            ! 1.5 RC
1555: 0000: 
1556: 0000: FUNCTION SPLIT.TIF.IRF.DATA$ EXTERNAL                                   ! 1.5 RC
1557: 0000: END FUNCTION                                                            ! 1.5 RC
1558: 0000: 
1559: 0000: !   Funtions deleted    1.5 RC
1560: 0000: 
1561: 0000: FUNCTION READ.TIF.BOOTS.DATA EXTERNAL
1562: 0000:    INTEGER*2 READ.TIF.BOOTS.DATA
1563: 0000: END FUNCTION
1564: 0000: 
1565: 0000: !   Funtions deleted    1.5 RC
1566: 0000: 
1567: 0000: FUNCTION WRITE.TIF.BOOTS.DATA EXTERNAL
1568: 0000:     INTEGER*2 WRITE.TIF.BOOTS.DATA
1569: 0000: END FUNCTION
1570: 0000: 
1571: 0000:       %INCLUDE TMCFEXT.J86                                            ! DAW
1572: 0000: \*****************************************************************************
1573: 0000: \***         FUNCTION DEFINITIONS FOR TERMINAL MAINT CONTROL FILE
1574: 0000: \***                    REFERENCE : TMCFEXT
1575: 0000: \***    Version A           Steve Windsor          8.2.93
1576: 0000: \***
1577: 0000: \***    Revision 1.3            ROBERT COWEY                      19 JUN 2002
1578: 0000: \***    Defined new function WRITE.TMCF.HEADER.
1579: 0000: \***
1580: 0000: \*****************************************************************************
1581: 0000: \*****************************************************************************
1582: 0000: 
1583: 0000:    FUNCTION TMCF.SET EXTERNAL
1584: 0000:    END FUNCTION
1585: 0000: 
1586: 0000:   FUNCTION READ.TMCF.DATA.RECORD EXTERNAL
1587: 0000:    INTEGER*2 READ.TMCF.DATA.RECORD
1588: 0000:   END FUNCTION
1589: 0000: 
1590: 0000:   FUNCTION READ.TMCF.HEADER.LOCKED EXTERNAL
1591: 0000:    INTEGER*2 READ.TMCF.HEADER.LOCKED
1592: 0000:   END FUNCTION
1593: 0000: 
1594: 0000:   FUNCTION READ.TMCF.HEADER EXTERNAL
1595: 0000:    INTEGER*2 READ.TMCF.HEADER
1596: 0000:   END FUNCTION
1597: 0000: 
1598: 0000:   FUNCTION WRITE.TMCF.HEADER EXTERNAL ! 1.1 RC New function
1599: 0000:    INTEGER*2 WRITE.TMCF.HEADER
1600: 0000:   END FUNCTION
1601: 0000: 
1602: 0000:   FUNCTION WRITE.TMCF.HEADER.HOLD.UNLOCK EXTERNAL
1603: 0000:    INTEGER*2 WRITE.TMCF.HEADER.HOLD.UNLOCK
1604: 0000:   END FUNCTION
1605: 0000: 
1606: 0000:   FUNCTION WRITE.TMCF.HEADER.UNLOCK EXTERNAL
1607: 0000:    INTEGER*2 WRITE.TMCF.HEADER.UNLOCK
1608: 0000:   END FUNCTION
1609: 0000: 
1610: 0000:   FUNCTION WRITE.TMCF.DATA EXTERNAL
1611: 0000:    INTEGER*2 WRITE.TMCF.DATA  
1612: 0000:   END FUNCTION
1613: 0000: 
1614: 0000:       %INCLUDE GAOPTEXT.J86                                           ! DAW
1615: 0000: \*****************************************************************************
1616: 0000: \***    Function definitions for GAOPT
1617: 0000: \***    Reference : GAOPTEXA.J86
1618: 0000: \***    Version A           Steve Windsor        10.05.93
1619: 0000: \.............................................................................
1620: 0000: 
1621: 0000:    FUNCTION GAOPT.SET EXTERNAL
1622: 0000:    END FUNCTION
1623: 0000: 
1624: 0000:   FUNCTION READ.GAOPT EXTERNAL
1625: 0000:    INTEGER*2 READ.GAOPT
1626: 0000:   END FUNCTION
1627: 0000: 
1628: 0000:   FUNCTION READ.GAOPT.LOCKED EXTERNAL
1629: 0000:    INTEGER*2 READ.GAOPT.LOCKED
1630: 0000:   END FUNCTION
1631: 0000: 
1632: 0000:   FUNCTION WRITE.GAOPT EXTERNAL
1633: 0000:    INTEGER*2 WRITE.GAOPT
1634: 0000:   END FUNCTION
1635: 0000: 
1636: 0000:   FUNCTION WRITE.GAOPT.UNLOCK EXTERNAL
1637: 0000:    INTEGER*2 WRITE.GAOPT.UNLOCK
1638: 0000:   END FUNCTION
1639: 0000:       %INCLUDE IDFEXT.J86                                             ! 1.11 NWB
1640: 0000: \*******************************************************************************
1641: 0000: \***                                                                         ***
1642: 0000: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE ITEM DESCRIPTION FILE        ***
1643: 0000: \***                                                                         ***
1644: 0000: \***                       REFERENCE : IDFEXT.J86                            ***
1645: 0000: \***                                                                         ***
1646: 0000: \***      Version A           Andrew Wedgeworth         9th July 1992        ***
1647: 0000: \***
1648: 0000: \***    VERSION C.              Robert Cowey.                       25 AUG 1993.
1649: 0000: \***    No changes to this file.
1650: 0000: \***
1651: 0000: \***   VERSION D               Nik Sen                 22nd December 1994
1652: 0000: \***   WRITE.IDF.HOLD added
1653: 0000: \***
1654: 0000: \*******************************************************************************
1655: 0000: 
1656: 0000:        FUNCTION IDF.SET EXTERNAL                                      
1657: 0000:        END FUNCTION                                                   
1658: 0000: 
1659: 0000: 
1660: 0000:        FUNCTION READ.IDF EXTERNAL                                     
1661: 0000:           INTEGER*2 READ.IDF                                          
1662: 0000:        END FUNCTION                                                   
1663: 0000: 
1664: 0000: 
1665: 0000:        FUNCTION READ.IDF.LOCK EXTERNAL                                
1666: 0000:           INTEGER*2 READ.IDF.LOCK                                     
1667: 0000:        END FUNCTION                                                   
1668: 0000: 
1669: 0000:        FUNCTION WRITE.IDF EXTERNAL
1670: 0000:           INTEGER*2 WRITE.IDF
1671: 0000:        END FUNCTION	       
1672: 0000: 
1673: 0000:        FUNCTION WRITE.IDF.HOLD EXTERNAL
1674: 0000:           INTEGER*2 WRITE.IDF.HOLD
1675: 0000:        END FUNCTION
1676: 0000: 
1677: 0000:        FUNCTION WRITE.IDF.UNLOCK EXTERNAL                                  
1678: 0000:           INTEGER*2 WRITE.IDF.UNLOCK                                      
1679: 0000:        END FUNCTION                                                   
1680: 0000:       %INCLUDE PHFEXT.J86                                             ! 1.11 NWB
1681: 0000: \/******************************************************************/
1682: 0000: \/*                                                                */
1683: 0000: \/* PRICE HISTORY FILE EXTERNAL FUNCTION DEFINITIONS               */
1684: 0000: \/*                                                                */
1685: 0000: \/* REFERENCE   : PHFEXT.J86                                       */
1686: 0000: \/*                                                                */
1687: 0000: \/* VERSION A.          Neil Bennett.           23 OCTOBER 2006    */
1688: 0000: \/*                                                                */
1689: 0000: \/******************************************************************/
1690: 0000: 
1691: 0000:    FUNCTION PHF.SET EXTERNAL
1692: 0000:       INTEGER*1 PHF.SET
1693: 0000:    END FUNCTION
1694: 0000: 
1695: 0000:    FUNCTION READ.PHF EXTERNAL
1696: 0000:       INTEGER*2 READ.PHF
1697: 0000:    END FUNCTION
1698: 0000: 
1699: 0000:    FUNCTION WRITE.PHF EXTERNAL
1700: 0000:       INTEGER*2 WRITE.PHF
1701: 0000:    END FUNCTION
1702: 0000: 
1703: 0000: \/******************************************************************/
1704: 0000:       %INCLUDE SRITLEXT.J86                                           ! 1.11 NWB
1705: 0000: \********************************************************************
1706: 0000: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE SRITL FILE
1707: 0000: \***      REFERENCE : SRITLEXT.J86
1708: 0000: \***      Version A           Neil Bennett            7th July 2006
1709: 0000: \***
1710: 0000: \********************************************************************
1711: 0000: 
1712: 0000:        FUNCTION SRITL.SET EXTERNAL
1713: 0000:        END FUNCTION
1714: 0000: 
1715: 0000:        FUNCTION READ.SRITL EXTERNAL
1716: 0000:           INTEGER*2 READ.SRITL
1717: 0000:        END FUNCTION
1718: 0000: 
1719: 0000:        FUNCTION WRITE.SRITL EXTERNAL
1720: 0000:           INTEGER*2 WRITE.SRITL
1721: 0000:        END FUNCTION
1722: 0000:       %INCLUDE SOFTSEXT.J86                                           ! 1.11 NWB
1723: 0000: \*******************************************************************************
1724: 0000: \***                                                                         ***
1725: 0000: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE SOFTWARE STATUS FILE         ***
1726: 0000: \***                                                                         ***
1727: 0000: \***                     REFERENCE : SOFTSEXT.J86                            ***
1728: 0000: \***                                                                         ***
1729: 0000: \***      Version A         Andrew Wedgeworth          1st July 1992         ***
1730: 0000: \***
1731: 0000: \***   Version B
1732: 0000: \***                                                                      ***
1733: 0000: \***      Version C         Steve Wright               3rd May 1996          ***
1734: 0000: \***      Synchronise with function source.                                  ***
1735: 0000: \*******************************************************************************
1736: 0000: 
1737: 0000:       FUNCTION SOFTS.SET EXTERNAL 
1738: 0000:       END FUNCTION
1739: 0000:       
1740: 0000:       FUNCTION READ.SOFTS EXTERNAL
1741: 0000:           INTEGER*2 I%, READ.SOFTS
1742: 0000:       END FUNCTION	                   
1743: 0000: 
1744: 0000:       FUNCTION WRITE.SOFTS EXTERNAL
1745: 0000:           INTEGER*2 I%, WRITE.SOFTS
1746: 0000:       END FUNCTION
1747: 0000: 
1748: 0000: 
1749: 0000: 
1750: 0000: REM EJECT
1751: 0000: \*******************************************************************************
1752: 0000: \*********                 Function OPEN.IRF.UPDT                     **********
1753: 0000: \*******************************************************************************
1754: 0000: \***
1755: 0000: \*** FUNCTION OPEN.IRF.UPDT (new IRF data,
1756: 0000: \***                         add/change/delete flag)  PUBLIC
1757: 0000: \***
1758: 0000: \-------------------------------------------------------------------------------
1759: 0000: 
1760: 0000:    FUNCTION OPEN.IRF.UPDT (NEW.IRF.DATA$,                              \
1761: 0000:                            ACD.FLAG$)                                  \
1762: 0000:    PUBLIC
1763: 001e: 
1764: 001e:       STRING    ACD.FLAG$,                                             \
1765: 001e:                 ADX.PARM.2$,                                           \
1766: 001e: \ 1 line deleted from here                                             \ DAW
1767: 001e:                 ERRFILE$,                                              \
1768: 001e:                 ERRNUM$,                                               \
1769: 001e:                 FILE$,                                                 \
1770: 001e:                 FUNCTION.FLAG$,                                        \ BBCW
1771: 001e:                 IRF.LOCKED.FLAG$,                                      \ BBCW
1772: 001e: \ 1 line deleted from here                                             \ DAW
1773: 001e:                 NEW.IRF.DATA$,                                         \
1774: 001e: \ 1 line deleted from here                                             \ DAW
1775: 001e:                 PASSED.STRING$,                                        \ BBCW
1776: 001e:                 STRING.ERRL$,                                          \
1777: 001e:                 UNIQUE$,                                               \
1778: 001e:                 VAR.STRING.1$,                                         \
1779: 001e:                 VAR.STRING.2$
1780: 001e: 
1781: 001e:       INTEGER*1 CIP.ACTIVE%,                                           \ 1.11 NWB
1782: 001e:                 EVENT.NUM%,                                            \
1783: 001e:                 FILE.NO%,                                              \ BBCW
1784: 001e:                 INTEGER1%,                                             \
1785: 001e:                 MSGGRP%,                                               \
1786: 001e:                 PASSED.INTEGER%,                                       \ BBCW
1787: 001e:                 SEVERITY%
1788: 001e: 
1789: 001e:       INTEGER   ADX.FUNCTION%,                                         \
1790: 001e:                 ADX.PARM.1%,                                           \
1791: 001e:                 EVENT.NO%,                                             \
1792: 001e:                 MESSAGE.NUMBER%,                                       \
1793: 001e:                 MSGNUM%,                                               \
1794: 001e:                 OPEN.IRF.UPDT,                                         \ DAW
1795: 001e:                 RET.CODE%,                                             \
1796: 001e:                 SESSION.NUMBER%,                                       \
1797: 001e:                 TERM%
1798: 001e: 
1799: 001e:       INTEGER*4 INTEGER4%
1800: 001e: 
1801: 001e: !     Lines deleted                                                       ! 1.8 RC
1802: 001e: !     Un-necessary duplication of OPEN.IRF.UPDT file SET calls (below)    ! 1.8 RC
1803: 001e: 
1804: 001e: \*******************************************************************************
1805: 001e: \***
1806: 001e: \***   ON ERROR goto UPDT.OPEN.ERROR.DETECTED  (after logging the error, the
1807: 001e: \***                                            function is immediately left)
1808: 001e: \***
1809: 001e: \***
1810: 001e: \***   set FILE.NO% to 0
1811: 001e: \***   REM set up storage areas for ADXERROR required fields in case of memory
1812: 001e: \***   overflow
1813: 001e: \***
1814: 001e: \***   set chaining module to first module in current application
1815: 001e: \***
1816: 001e: \-------------------------------------------------------------------------------
1817: 001e: 
1818: 001e:       ON ERROR GOTO UPDT.OPEN.ERROR.DETECTED
1819: 002b: 
1820: 002b:       CALL IRF.SET                                                     ! FSP
1821: 003e:       CALL TIF.SET                                                     ! FSP
1822: 0051:       CALL TMCF.SET                                                    ! FSP
1823: 0064:       CALL GAOPT.SET                                                   ! FSP
1824: 0077:       CALL IDF.SET                                                    ! 1.11 NWB
1825: 008a:       CALL PHF.SET                                                    ! 1.11 NWB
1826: 008f:       CALL SRITL.SET                                                  ! 1.11 NWB
1827: 00a2: 
1828: 00a2:       F19.NODE.FILE.NAME$  EQ "ADXLXACN::C:\TEST.LAN"                      ! 1.9 RC
1829: 00af:       F19.NODE.REPORT.NUM% EQ  676                                         ! 1.9 RC
1830: 00b5: 
1831: 00b5:       FILE.NO% = 0
1832: 00ba:       TIF.FULL$ = "N"
1833: 00c9:       TMCF.FULL$ = "N"
1834: 00d8:       UNIQUE$ = "          "
1835: 00e5:       ERRNUM$ = "    "
1836: 00f2:       ERRFILE$ = " "
1837: 00ff:       STRING.ERRL$ = "      "
1838: 010c:       OPEN.IRF.UPDT = 0                                                ! DAW
1839: 0111: 
1840: 0111:       PSBCHN.PRG = "ADX_UPGM:PSB50.286"                                !1.10 SWM
1841: 0120: 
1842: 0120: 
1843: 0120: \*******************************************************************************
1844: 0120: \***
1845: 0120: \***   set adx function to 4 (return node ID)
1846: 0120: \***   set parameter 1 to terminal number
1847: 0120: \***
1848: 0120: \***   CALL ADXSERVE (return code,
1849: 0120: \***                  adx function,
1850: 0120: \***                  parameter 1,
1851: 0120: \***                  parameter 2)
1852: 0120: \***
1853: 0120: \***   IF the node ID <> "CE" THEN    (was DE)                         ! LCSk
1854: 0120: \***      set error flag to "NODE"
1855: 0120: \***      GOTO FUNCTION.EXIT
1856: 0120: \***   endif
1857: 0120: \***
1858: 0120: \***   set FUNCTION.FLAG$ to "O",
1859: 0120: \***       PASSED.INTEGER% to GAOPT.REPORT.NUM% and
1860: 0120: \***       PASSED.STRING$ to GAOPT.FILE.NAME$
1861: 0120: \***
1862: 0120: \***   use SESS.NUM.UTILITY function to allocate session number
1863: 0120: \***   IF F20.RETURN.CODE% <> 0 THEN
1864: 0120: \***      GOTO PROGRAM EXIT
1865: 0120: \***   ENDIF
1866: 0120: \***
1867: 0120: \***   set gaopt session number to F20.INTEGER.FILE.NO%
1868: 0120: \***   set file no to F20.INTEGER.FILE.NO%
1869: 0120: \***
1870: 0120: \***   IF END #gaopt session number THEN FILE.OPEN.ERROR
1871: 0120: \***   OPEN the local version of GAOPT  (random)
1872: 0120: \***   IF END #gaopt session number THEN FILE.READ.ERROR
1873: 0120: \***   CALL READ.LOCAL.GAOPT
1874: 0120: \***   CLOSE the local version of GAOPT
1875: 0120: \***
1876: 0120: \***   set FUNCTION.FLAG$ to "C",
1877: 0120: \***       PASSED.INTEGER% to gaopt session number and
1878: 0120: \***       PASSED.STRING$ to ""
1879: 0120: \***
1880: 0120: \***   use SESS.NUM.UTILITY function to deallocate session number
1881: 0120: \***   IF F20.RETURN.CODE% <> 0 THEN
1882: 0120: \***      GOTO PROGRAM EXIT
1883: 0120: \***   ENDIF
1884: 0120: \***
1885: 0120: \***   set FUNCTION.FLAG$ to "O",
1886: 0120: \***       PASSED.INTEGER% to TMCF.REPORT.NUM% and
1887: 0120: \***       PASSED.STRING$ to TMCF.FILE.NAME$
1888: 0120: \***
1889: 0120: \***   use SESS.NUM.UTILITY function to allocate session number
1890: 0120: \***   IF F20.RETURN.CODE% <> 0 THEN
1891: 0120: \***      GOTO PROGRAM EXIT
1892: 0120: \***   ENDIF
1893: 0120: \***
1894: 0120: \***   set tmcf session number to F20.INTEGER.FILE.NO%
1895: 0120: \***   set file no to F20.INTEGER.FILE.NO%
1896: 0120: \***
1897: 0120: \***   IF END #tmcf session number THEN FILE.OPEN.ERROR
1898: 0120: \***   OPEN the tmcf DIRECT
1899: 0120: \***   IF END #tmcf session number THEN FILE.READ.ERROR
1900: 0120: \***   CALL READ.TMCF.HEADER
1901: 0120: \***   IF terminal look-up not activated THEN
1902: 0120: \***      set error flag to "TERMILU 0"
1903: 0120: \***      GOTO FUNCTION.EXIT
1904: 0120: \***   endif
1905: 0120: \***
1906: 0120: \***   get tif format
1907: 0120: \***
1908: 0120: \***  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
1909: 0120: \***  !!!!
1910: 0120: \***  !!!! Use TIF.FORMAT% to hold the format of the TIF in numerical form, ie:
1911: 0120: \***  !!!!
1912: 0120: \***  !!!!                  1 = full descriptor and user data
1913: 0120: \***  !!!!                  2 = full descriptor, no user data
1914: 0120: \***  !!!!                  3 = short descriptor and user data
1915: 0120: \***  !!!!                  4 = short descriptor, no user data
1916: 0120: \***  !!!!                  5 = no descriptor, just user data
1917: 0120: \***  !!!!                  6 = no descriptor or user data
1918: 0120: \***  !!!!
1919: 0120: \***  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
1920: 0120: \***
1921: 0120: \***   set FUNCTION.FLAG$ to "O",
1922: 0120: \***       PASSED.INTEGER% to TIF.REPORT.NUM% and
1923: 0120: \***       PASSED.STRING$ to TIF.FILE.NAME$
1924: 0120: \***
1925: 0120: \***   use SESS.NUM.UTILITY function to allocate session number
1926: 0120: \***   IF F20.RETURN.CODE% <> 0 THEN
1927: 0120: \***      GOTO PROGRAM EXIT
1928: 0120: \***   ENDIF
1929: 0120: \***
1930: 0120: \***   set tif session number to F20.INTEGER.FILE.NO%
1931: 0120: \***   set file no to F20.INTEGER.FILE.NO%
1932: 0120: \***
1933: 0120: \***   IF END #tif session number THEN FILE.OPEN.ERROR
1934: 0120: \***   OPEN the tif KEYED
1935: 0120: \***
1936: 0120: \***   set FUNCTION.FLAG$ to "O",                                     ! 1.11 NWB
1937: 0120: \***       PASSED.INTEGER% to PHF.REPORT.NUM% and                     ! 1.11 NWB
1938: 0120: \***       PASSED.STRING$ to PHF.FILE.NAME$                           ! 1.11 NWB
1939: 0120: \***
1940: 0120: \***   use SESS.NUM.UTILITY function to allocate session number       ! 1.11 NWB
1941: 0120: \***   IF F20.RETURN.CODE% <> 0 THEN                                  ! 1.11 NWB
1942: 0120: \***      GOTO PROGRAM EXIT                                           ! 1.11 NWB
1943: 0120: \***   ENDIF                                                          ! 1.11 NWB
1944: 0120: \***
1945: 0120: \***   set phf session number to F20.INTEGER.FILE.NO%                 ! 1.11 NWB
1946: 0120: \***   set file no to F20.INTEGER.FILE.NO%                            ! 1.11 NWB
1947: 0120: \***
1948: 0120: \***   IF END #phf session number THEN SKIP.PHF.FILES                 ! 1.11 NWB
1949: 0120: \***   OPEN the phf KEYED                                             ! 1.11 NWB
1950: 0120: \***
1951: 0120: \***   set FUNCTION.FLAG$ to "O",                                     ! 1.11 NWB
1952: 0120: \***       PASSED.INTEGER% to IDF.REPORT.NUM% and                     ! 1.11 NWB
1953: 0120: \***       PASSED.STRING$ to IDF.FILE.NAME$                           ! 1.11 NWB
1954: 0120: \***
1955: 0120: \***   use SESS.NUM.UTILITY function to allocate session number       ! 1.11 NWB
1956: 0120: \***   IF F20.RETURN.CODE% <> 0 THEN                                  ! 1.11 NWB
1957: 0120: \***      GOTO PROGRAM EXIT                                           ! 1.11 NWB
1958: 0120: \***   ENDIF                                                          ! 1.11 NWB
1959: 0120: \***
1960: 0120: \***   set idf session number to F20.INTEGER.FILE.NO%                 ! 1.11 NWB
1961: 0120: \***   set file no to F20.INTEGER.FILE.NO%                            ! 1.11 NWB
1962: 0120: \***
1963: 0120: \***   IF END #idf session number THEN FILE.OPEN.ERROR                ! 1.11 NWB
1964: 0120: \***   OPEN the idf KEYED                                             ! 1.11 NWB
1965: 0120: \***
1966: 0120: \***   set FUNCTION.FLAG$ to "O",                                     ! 1.11 NWB
1967: 0120: \***       PASSED.INTEGER% to SRITL.REPORT.NUM% and                   ! 1.11 NWB
1968: 0120: \***       PASSED.STRING$ to SRITL.FILE.NAME$                         ! 1.11 NWB
1969: 0120: \***
1970: 0120: \***   use SESS.NUM.UTILITY function to allocate session number       ! 1.11 NWB
1971: 0120: \***   IF F20.RETURN.CODE% <> 0 THEN                                  ! 1.11 NWB
1972: 0120: \***      GOTO PROGRAM EXIT                                           ! 1.11 NWB
1973: 0120: \***   ENDIF                                                          ! 1.11 NWB
1974: 0120: \***
1975: 0120: \***   set sritl session number to F20.INTEGER.FILE.NO%               ! 1.11 NWB
1976: 0120: \***   set file no to F20.INTEGER.FILE.NO%                            ! 1.11 NWB
1977: 0120: \***
1978: 0120: \***   IF END #sritl session number THEN NO.SRITL.FILE                ! 1.11 NWB
1979: 0120: \***   OPEN the phf KEYED                                             ! 1.11 NWB
1980: 0120: \***
1981: 0120: \***   SKIP.PHF.FILES:                                                ! 1.11 NWB
1982: 0120: \***
1983: 0120: \***   GOTO FUNCTION.EXIT
1984: 0120: \***
1985: 0120: \***
1986: 0120: \-------------------------------------------------------------------------------
1987: 0120: 
1988: 0120:       ADX.FUNCTION% = 4
1989: 0126:       ADX.PARM.1% = 0
1990: 012c: 
1991: 012c:       CALL ADXSERVE (RET.CODE%,                                       \
1992: 0161:                      ADX.FUNCTION%,                                   \
1993: 0161:                      ADX.PARM.1%,                                     \
1994: 0161:                      ADX.PARM.2$)
1995: 0161: 
1996: 0161:       IF RET.CODE% <> 0 THEN                                          \
1997: 0168:          MSGNUM% = 300                                               :\
1998: 016e:          MSGGRP% = ASC("A")                                          :\
1999: 017a:          SEVERITY% = 3                                               :\
2000: 017f:          TERM% = 0                                                   :\
2001: 0185:          EVENT.NUM% = 23                                             :\
2002: 018a:          UNIQUE$ = STR$(RET.CODE%) + STR$(ADX.FUNCTION%)             :\
2003: 01b7:          CALL ADXERROR (TERM%,                                        \
2004: 01de:                         MSGGRP%,                                      \
2005: 01de:                         MSGNUM%,                                      \
2006: 01de:                         SEVERITY%,                                    \
2007: 01de:                         EVENT.NUM%,                                   \
2008: 01de:                         UNIQUE$)                                     :\
2009: 01de:          GOTO FUNCTION.EXIT
2010: 01e1: 
2011: 01e1: !     Allocate a session number to the IRFDEX and open the file.           ! 1.9 RC
2012: 01e1: !     Do not use IRFDEX.SESS.NUM% as this will change the operation of     ! 1.9 RC
2013: 01e1: !     IRFFUN functions when called from programs not opening the IRFDEX.   ! 1.9 RC
2014: 01e1: 
2015: 01e1:       FUNCTION.FLAG$  EQ "O"                                               ! 1.9 RC
2016: 01ee:       PASSED.INTEGER% EQ IRFDEX.REPORT.NUM%                                ! 1.9 RC
2017: 01f8:       PASSED.STRING$  EQ IRFDEX.FILE.NAME$                                 ! 1.9 RC
2018: 020c: 
2019: 020c:       RET.CODE% EQ SESS.NUM.UTILITY (FUNCTION.FLAG$, \                     ! 1.9 RC
2020: 022c:                                      PASSED.INTEGER%, \                    ! 1.9 RC
2021: 022c:                                      PASSED.STRING$)                       ! 1.9 RC
2022: 022c: 
2023: 022c:       IF RET.CODE% NE 0 THEN GOTO PROGRAM.EXIT ! PSBF20 failure            ! 1.9 RC
2024: 0234: 
2025: 0234:       F19.IRFDEX.SESS.NUM% EQ F20.INTEGER.FILE.NO%                         ! 1.9 RC
2026: 0242: 
2027: 0242:       FILE.NO% EQ F20.INTEGER.FILE.NO%                                     ! 1.9 RC
2028: 024c:       IF END # F19.IRFDEX.SESS.NUM% THEN FILE.OPEN.ERROR                   ! 1.9 RC
2029: 0260: 
2030: 0260:       OPEN IRFDEX.FILE.NAME$ KEYED RECL IRFDEX.RECL% \                     ! 1.9 RC
2031: 0284:          AS F19.IRFDEX.SESS.NUM%                                           ! 1.9 RC
2032: 0284: 
2033: 0284:       NODE.ID$ = MID$(ADX.PARM.2$,14,2)
2034: 02a0: 
2035: 02a0: !     Check whether the Node ID is a valid store controller configuration. ! 1.9 RC
2036: 02a0: !     If not then open the dummy file used on development controllers.     ! 1.9 RC
2037: 02a0: !     If the dummy file is found set the Node ID to CE to force PSBF19     ! 1.9 RC ! LCSk
2038: 02a0: !     to process as though for a 1PS store (ie; Update the TIF and TMCFR). ! 1.9 RC
2039: 02a0: 
2040: 02a0:       IF    NODE.ID$ NE "CE" \      ! Node ID does not correspond to any   ! 1.9 RC
2041: 0315:         AND NODE.ID$ NE "CF" \      ! valid 1PS or 2PS store configuration ! 1.9 RC
2042: 0315:         AND NODE.ID$ NE "DE" THEN \ ! (so may be a development controller) ! 1.9 RC
2043: 0315:           BEGIN                                                            ! 1.9 RC
2044: 0315: 
2045: 0315:           FUNCTION.FLAG$  EQ "O"                                           ! 1.9 RC
2046: 0322:           PASSED.INTEGER% EQ F19.NODE.REPORT.NUM%                          ! 1.9 RC
2047: 0328:           PASSED.STRING$  EQ F19.NODE.FILE.NAME$                           ! 1.9 RC
2048: 0339: 
2049: 0339:           RET.CODE% EQ SESS.NUM.UTILITY (FUNCTION.FLAG$, \                 ! 1.9 RC
2050: 0359:                                          PASSED.INTEGER%, \                ! 1.9 RC
2051: 0359:                                          PASSED.STRING$)                   ! 1.9 RC
2052: 0359: 
2053: 0359:           IF RET.CODE% NE 0 THEN GOTO PROGRAM.EXIT                         ! 1.9 RC
2054: 0361: 
2055: 0361:           F19.NODE.SESS.NUM% EQ F20.INTEGER.FILE.NO%                       ! 1.9 RC
2056: 036b: 
2057: 036b:           IF END # F19.NODE.SESS.NUM% THEN F19.NODE.FILE.NOT.PRESENT       ! 1.9 RC
2058: 0379: 
2059: 0379:           OPEN F19.NODE.FILE.NAME$ DIRECT RECL 1 \ ! Opens dummy file on   ! 1.9 RC
2060: 0392:              AS F19.NODE.SESS.NUM%                 ! dev controller        ! 1.9 RC
2061: 0392: 
2062: 0392:          !NODE.ID$ EQ "DE" ! Dummy file present so node ID set to DE       ! 1.9 RC ! LCSk
2063: 0392:           NODE.ID$ EQ "CE" ! Dummy file present so node ID set to CE       ! LCSk
2064: 03a1: 
2065: 03a1:           CLOSE F19.NODE.SESS.NUM%                                         ! 1.9 RC
2066: 03aa: 
2067: 03aa: F19.NODE.FILE.NOT.PRESENT: ! File not present on development controller    ! 1.9 RC
2068: 03aa: 
2069: 03aa:           ENDIF                                                            ! 1.9 RC
2070: 03aa: 
2071: 03aa:       FUNCTION.FLAG$  = "O"                                           ! 1.11 NWB
2072: 03b7:       PASSED.INTEGER% = PHF.REPORT.NUM%                               ! 1.11 NWB
2073: 03c1:       PASSED.STRING$  = PHF.FILE.NAME$                                ! 1.11 NWB
2074: 03d5: 
2075: 03d5:       RET.CODE% = SESS.NUM.UTILITY (FUNCTION.FLAG$,                   \ 1.11 NWB
2076: 03f5:                                     PASSED.INTEGER%,                  \ 1.11 NWB
2077: 03f5:                                     PASSED.STRING$)                   ! 1.11 NWB
2078: 03f5: 
2079: 03f5:       IF RET.CODE% <> 0 THEN GOTO PROGRAM.EXIT                        ! 1.11 NWB
2080: 03fd: 
2081: 03fd:       PHF.SESS.NUM% = F20.INTEGER.FILE.NO%                            ! 1.11 NWB
2082: 040b:       FILE.NO%      = F20.INTEGER.FILE.NO%                            ! 1.11 NWB
2083: 0415:       IF END # PHF.SESS.NUM% THEN CHECK.CIP.STATUS                    ! 1.11 NWB
2084: 0429:       OPEN PHF.FILE.NAME$ KEYED RECL PHF.RECL%                        \ 1.11 NWB
2085: 044d:            AS PHF.SESS.NUM%                                           ! 1.11 NWB
2086: 044d: 
2087: 044d: PHF.CREATE.RESUME:                                                    ! 1.11 NWB
2088: 044d:       PHF.OPEN.FLAG$ = "Y"                                            ! 1.11 NWB
2089: 045a: 
2090: 045a:       FUNCTION.FLAG$  = "O"                                           ! 1.11 NWB
2091: 0467:       PASSED.INTEGER% = IDF.REPORT.NUM%                               ! 1.11 NWB
2092: 0471:       PASSED.STRING$  = IDF.FILE.NAME$                                ! 1.11 NWB
2093: 0485: 
2094: 0485:       RET.CODE% = SESS.NUM.UTILITY (FUNCTION.FLAG$,                   \ 1.11 NWB
2095: 04a5:                                     PASSED.INTEGER%,                  \ 1.11 NWB
2096: 04a5:                                     PASSED.STRING$)                   ! 1.11 NWB
2097: 04a5: 
2098: 04a5:       IF RET.CODE% <> 0 THEN GOTO PROGRAM.EXIT                        ! 1.11 NWB
2099: 04ad: 
2100: 04ad:       F19.IDF.SESS.NUM% = F20.INTEGER.FILE.NO%                        ! 1.11 NWB
2101: 04b7:       FILE.NO% = F20.INTEGER.FILE.NO%                                 ! 1.11 NWB
2102: 04c2:       IF END # F19.IDF.SESS.NUM% THEN FILE.OPEN.ERROR                 ! 1.11 NWB
2103: 04d0:       OPEN IDF.FILE.NAME$ KEYED RECL IDF.RECL%                        \ 1.11 NWB
2104: 04f2:            AS F19.IDF.SESS.NUM%  NOWRITE NODEL                        ! 1.11 NWB
2105: 04f2: 
2106: 04f2:       IDF.OPEN.FLAG$ = "Y"                                            ! 1.11 NWB
2107: 04ff: 
2108: 04ff:       FUNCTION.FLAG$  = "O"                                           ! 1.11 NWB
2109: 050c:       PASSED.INTEGER% = SRITL.REPORT.NUM%                             ! 1.11 NWB
2110: 0516:       PASSED.STRING$  = SRITL.FILE.NAME$                              ! 1.11 NWB
2111: 052a: 
2112: 052a:       RET.CODE% = SESS.NUM.UTILITY (FUNCTION.FLAG$,                   \ 1.11 NWB
2113: 054a:                                     PASSED.INTEGER%,                  \ 1.11 NWB
2114: 054a:                                     PASSED.STRING$)                   ! 1.11 NWB
2115: 054a: 
2116: 054a:       IF RET.CODE% <> 0 THEN GOTO PROGRAM.EXIT                        ! 1.11 NWB
2117: 0552: 
2118: 0552:       F19.SRITL.SESS.NUM% = F20.INTEGER.FILE.NO%                      ! 1.11 NWB
2119: 055c:       FILE.NO% = F20.INTEGER.FILE.NO%                                 ! 1.11 NWB
2120: 0567:       IF END # F19.SRITL.SESS.NUM% THEN NO.SRITL.FILE                 ! 1.11 NWB
2121: 0575:       OPEN SRITL.FILE.NAME$ KEYED RECL SRITL.RECL%                    \ 1.11 NWB
2122: 0597:            AS F19.SRITL.SESS.NUM%  NOWRITE NODEL                      ! 1.11 NWB
2123: 0597: 
2124: 0597:       SRITL.OPEN.FLAG$ = "Y"                                          ! 1.11 NWB
2125: 05a4: SKIP.CIP.FILES:                                                       ! 1.11 NWB
2126: 05a4: NO.SRITL.FILE:                                                        ! 1.11 NWB
2127: 05a4: 
2128: 05a4:      !IF NODE.ID$ <> "DE" THEN                                        \ ! LCSk
2129: 05a4:      !   GOTO FUNCTION.EXIT                                             ! LCSk
2130: 05a4: 
2131: 05a4:       FUNCTION.FLAG$  = "O"                                           ! BBCW
2132: 05b1:       PASSED.INTEGER% = GAOPT.REPORT.NUM%                             ! BBCW
2133: 05bb:       PASSED.STRING$  = GAOPT.FILE.NAME$                              ! BBCW
2134: 05cf: 
2135: 05cf:       RET.CODE% = SESS.NUM.UTILITY (FUNCTION.FLAG$,                   \ DAW
2136: 05ef:                                     PASSED.INTEGER%,                  \ BBCW
2137: 05ef:                                     PASSED.STRING$)                   ! BBCW
2138: 05ef: 
2139: 05ef:       IF RET.CODE% <> 0 THEN GOTO PROGRAM.EXIT                        ! DAW
2140: 05f7: 
2141: 05f7:       GAOPT.SESS.NUM% = F20.INTEGER.FILE.NO%                          ! BBCW
2142: 0605:       FILE.NO%        = F20.INTEGER.FILE.NO%                          ! BBCW
2143: 060f:       IF END # GAOPT.SESS.NUM% THEN FILE.OPEN.ERROR
2144: 0623:       OPEN LOCAL.GAOPT.FILE.NAME$ RECL GAOPT.RECL%                    \
2145: 0648:            AS GAOPT.SESS.NUM% NOWRITE NODEL
2146: 0648: 
2147: 0648: !     GAOPT.REC.NO% = 1
2148: 0648:       RET.CODE% = READ.GAOPT                                          ! FSP
2149: 0650:       IF RET.CODE% <> 0 THEN BEGIN                                    ! FSP
2150: 0655:          GOSUB FILE.READ.ERROR                                        ! FSP
2151: 065f:       ENDIF                                                           ! FSP
2152: 065f: 
2153: 065f:       CLOSE GAOPT.SESS.NUM%
2154: 066b: 
2155: 066b:       FUNCTION.FLAG$  = "C"                                           ! BBCW
2156: 0678:       PASSED.INTEGER% = GAOPT.SESS.NUM%                               ! BBCW
2157: 0682:       PASSED.STRING$  = ""                                            ! BBCW
2158: 068f:       RET.CODE% = SESS.NUM.UTILITY (FUNCTION.FLAG$,                   \ DAW
2159: 06af:                                     PASSED.INTEGER%,                  \ BBCW
2160: 06af:                                     PASSED.STRING$)                   ! BBCW
2161: 06af: 
2162: 06af:       IF RET.CODE% <> 0 THEN GOTO PROGRAM.EXIT                       ! DAW
2163: 06b7: 
2164: 06b7:       FUNCTION.FLAG$  = "O"                                           ! BBCW
2165: 06c4:       PASSED.INTEGER% = TMCF.REPORT.NUM%                              ! BBCW
2166: 06ce:       PASSED.STRING$  = TMCF.FILE.NAME$                               ! BBCW
2167: 06e2:       RET.CODE% = SESS.NUM.UTILITY (FUNCTION.FLAG$,                   \ DAW
2168: 0702:                                     PASSED.INTEGER%,                  \ BBCW
2169: 0702:                                     PASSED.STRING$)                   ! BBCW
2170: 0702: 
2171: 0702:       IF RET.CODE% <> 0 THEN GOTO PROGRAM.EXIT                        ! DAW
2172: 070a: 
2173: 070a:       TMCF.SESS.NUM% = F20.INTEGER.FILE.NO%                           ! BBCW
2174: 0718:       FILE.NO%       = F20.INTEGER.FILE.NO%                           ! BBCW
2175: 0722:       IF END # TMCF.SESS.NUM% THEN FILE.OPEN.ERROR
2176: 0736:       OPEN TMCF.FILE.NAME$ DIRECT RECL TMCF.RECL%                     \
2177: 075b:            AS TMCF.SESS.NUM% NODEL
2178: 075b: 
2179: 075b: 
2180: 075b:       TMCF.OPEN.FLAG$ = "Y"
2181: 076a: 
2182: 076a:       TMCF.REC.NO% = 1
2183: 0773:       RET.CODE% = READ.TMCF.HEADER                                    ! FSP
2184: 077b:       IF RET.CODE% <> 0 THEN BEGIN                                    ! FSP
2185: 0780:          GOSUB FILE.READ.ERROR                                        ! FSP
2186: 078a:       ENDIF                                                           ! FSP
2187: 078a: 
2188: 078a:       IF TMCF.TERMILU% = 0 THEN                                       \
2189: 0794:          GOTO FUNCTION.EXIT
2190: 0797: 
2191: 0797: !   Removed redundant code processing unused TIF and TMCF file formats    ! 1.8 RC
2192: 0797: 
2193: 0797:       IF TMCF.DESCTYPE% = 4 THEN                                      \ DW
2194: 07a1:          TIF.RECL% = TIF.RECL7% : TIF.FORMAT% = 7                     ! DW
2195: 07b7: 
2196: 07b7:       FUNCTION.FLAG$  = "O"                                           ! BBCW
2197: 07c4:       PASSED.INTEGER% = TIF.REPORT.NUM%                               ! BBCW
2198: 07ce:       PASSED.STRING$  = TIF.FILE.NAME$                                ! BBCW
2199: 07e2: 
2200: 07e2:       RET.CODE% = SESS.NUM.UTILITY (FUNCTION.FLAG$,                   \ DAW
2201: 0802:                                     PASSED.INTEGER%,                  \ BBCW
2202: 0802:                                     PASSED.STRING$)                   ! BBCW
2203: 0802: 
2204: 0802:       IF RET.CODE% <> 0 THEN GOTO PROGRAM.EXIT                        ! DAW
2205: 080a: 
2206: 080a:       TIF.SESS.NUM% = F20.INTEGER.FILE.NO%                            ! BBCW
2207: 0818:       FILE.NO%      = F20.INTEGER.FILE.NO%                            ! BBCW
2208: 0822:       IF END # TIF.SESS.NUM% THEN FILE.OPEN.ERROR
2209: 0836:       OPEN TIF.FILE.NAME$ KEYED RECL TIF.RECL%                        \
2210: 085a:            AS TIF.SESS.NUM%
2211: 085a: 
2212: 085a:       TIF.OPEN.FLAG$ = "Y"
2213: 0869: 
2214: 0869:       GOTO FUNCTION.EXIT
2215: 086c: 
2216: 086c: 
2217: 086c: \*******************************************************************************
2218: 086c: \***
2219: 086c: \***   CHECK.CIP.STATUS
2220: 086c: \***
2221: 086c: \*******************************************************************************
2222: 086c: 
2223: 086c: CHECK.CIP.STATUS:                                                     ! 1.11 NWB
2224: 086c: 
2225: 086c:       RET.CODE% = SOFTS.SET                                           ! 1.11 NWB
2226: 087e: 
2227: 087e: \/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */   1.11 NWB
2228: 087e: \/* Open SOFTSTAT file
2229: 087e: \/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */   1.11 NWB
2230: 087e: 
2231: 087e:       RET.CODE% = SESS.NUM.UTILITY ("O",                              \ 1.11 NWB
2232: 089f:                                     SOFTS.REPORT.NUM%,                \ 1.11 NWB
2233: 089f:                                     SOFTS.FILE.NAME$)                 ! 1.11 NWB
2234: 089f:       F19.SOFTS.SESS.NUM% = F20.INTEGER.FILE.NO%                      ! 1.11 NWB
2235: 08aa: 
2236: 08aa:       IF END# F19.SOFTS.SESS.NUM% THEN SKIP.CIP.FILES                 ! 1.11 NWB
2237: 08b8:       OPEN SOFTS.FILE.NAME$ DIRECT RECL SOFTS.RECL%                   \ 1.11 NWB
2238: 08da:           AS F19.SOFTS.SESS.NUM% NOWRITE NODEL                        ! 1.11 NWB
2239: 08da: 
2240: 08da: \/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */   1.11 NWB
2241: 08da: \/* Read required records and set GLOBAL vars accordingly
2242: 08da: \/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */   1.11 NWB
2243: 08da: 
2244: 08da:       CIP.ACTIVE% = 0                                                 ! 1.11 NWB
2245: 08df:       SOFTS.REC.NUM% = 48                                             ! 1.11 NWB
2246: 08ee:       SAV.SOFTS.SESS.NUM% = SOFTS.SESS.NUM%                           ! 1.11 NWB
2247: 08f8:       SOFTS.SESS.NUM% = F19.SOFTS.SESS.NUM%                           ! 1.11 NWB
2248: 0903:       RET.CODE% = READ.SOFTS                                          ! 1.11 NWB
2249: 090b:       SOFTS.SESS.NUM% = SAV.SOFTS.SESS.NUM%                           ! 1.11 NWB
2250: 0916:       SAV.SOFTS.SESS.NUM% = 0                                         ! 1.11 NWB
2251: 091c:       IF RET.CODE% = 0                                                \ 1.11 NWB
2252: 094b:      AND MATCH("INACTIVE", SOFTS.RECORD$, 1) = 0 THEN BEGIN           ! 1.11 NWB
2253: 094b:          CIP.ACTIVE% = -1                                             ! 1.11 NWB
2254: 0950:       ENDIF                                                           ! 1.11 NWB
2255: 0950: 
2256: 0950: \/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */   1.11 NWB
2257: 0950: \/* CLOSE Softstat file                                                 1.11 NWB
2258: 0950: \/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */   1.11 NWB
2259: 0950: 
2260: 0950:       CLOSE F19.SOFTS.SESS.NUM%                                       ! 1.11 NWB
2261: 0959:       RET.CODE% = SESS.NUM.UTILITY ("C", F19.SOFTS.SESS.NUM%, "")     ! 1.11 NWB
2262: 0970: 
2263: 0970:       IF CIP.ACTIVE% THEN BEGIN                                       ! 1.11 NWB
2264: 0977:          IF END #PHF.SESS.NUM% THEN FILE.OPEN.ERROR                   ! 1.11 NWB
2265: 098b:          CREATE POSFILE PHF.FILE.NAME$ KEYED 6,,, 600000              \ 1.11 NWB ! 1.14BMG
2266: 09ba:                RECL PHF.RECL% AS PHF.SESS.NUM% MIRRORED PERUPDATE     ! 1.11 NWB
2267: 09ba:          GOTO PHF.CREATE.RESUME                                       ! 1.11 NWB
2268: 09bd:       ENDIF                                                           ! 1.11 NWB
2269: 09bd: 
2270: 09bd:       GOTO SKIP.CIP.FILES                                             ! 1.11 NWB
2271: 09c0: 
2272: 09c0: \*******************************************************************************
2273: 09c0: \***
2274: 09c0: \***   FILE.OPEN.ERROR:
2275: 09c0: \***
2276: 09c0: \***         set FUNCTION.FLAG$ to "R"
2277: 09c0: \***             PASSED.INTEGER% to file no and
2278: 09c0: \***             PASSED.STRING$ to ""
2279: 09c0: \***         use SESS.NUM.UTILITY function to obtain reporting number for ERRF%
2280: 09c0: \***         IF F20.RETURN.CODE% <> 0 THEN
2281: 09c0: \***            GOTO PROGRAM.EXIT
2282: 09c0: \***         ENDIF
2283: 09c0: \***
2284: 09c0: \***         set ERRFILE$ to CHR$(F20.INTEGER.FILE.NO%)
2285: 09c0: \***         set VAR.STRING.2$ to F20.STRING.FILE.NO$
2286: 09c0: \***
2287: 09c0: \***         CALL APPLICATION.LOG to log error number 501
2288: 09c0: \***         GOTO FUNCTION.EXIT
2289: 09c0: \***
2290: 09c0: \***
2291: 09c0: \***   FUNCTION.EXIT:
2292: 09c0: \***
2293: 09c0: \***      EXIT the function
2294: 09c0: \***
2295: 09c0: \***
2296: 09c0: \***
2297: 09c0: \-------------------------------------------------------------------------------
2298: 09c0: 
2299: 09c0:    FILE.OPEN.ERROR:
2300: 09c0: 
2301: 09c0:       FUNCTION.FLAG$  = "R"                                            ! BBCW
2302: 09cd:       PASSED.INTEGER% = FILE.NO%                                       ! BBCW
2303: 09d3:       PASSED.STRING$  = ""                                             ! BBCW
2304: 09e0:       RET.CODE% = SESS.NUM.UTILITY (FUNCTION.FLAG$,                    \ DAW
2305: 0a00:                                     PASSED.INTEGER%,                   \ BBCW
2306: 0a00:                                     PASSED.STRING$)                    ! BBCW
2307: 0a00: 
2308: 0a00:       IF RET.CODE% <> 0 THEN GOTO PROGRAM.EXIT                         ! BBCW
2309: 0a08: 
2310: 0a08:       EVENT.NO% = 6
2311: 0a0e:       INTEGER1% = FILE.NO%                                             ! BBCW
2312: 0a14:       ERRFILE$  = CHR$(F20.INTEGER.FILE.NO%)                           ! BBCW
2313: 0a29: 
2314: 0a29:       MESSAGE.NUMBER% = 501
2315: 0a2f:       VAR.STRING.1$ = "O" + ERRFILE$
2316: 0a47:       VAR.STRING.2$ = F20.STRING.FILE.NO$                              ! BBCW
2317: 0a5b:       RET.CODE% = APPLICATION.LOG (MESSAGE.NUMBER%,                    \ DAW
2318: 0a7f:                                    VAR.STRING.1$,                      \
2319: 0a7f:                                    VAR.STRING.2$,                      \
2320: 0a7f:                                    EVENT.NO%)                         :\
2321: 0a7f: 
2322: 0a7f:       OPEN.IRF.UPDT = 1                                                ! HAW
2323: 0a84: 
2324: 0a84: 
2325: 0a84:    FUNCTION.EXIT:
2326: 0a84: 
2327: 0a84:       EXIT FUNCTION
2328: 0a87: 
2329: 0a87: 
2330: 0a87: \*******************************************************************************
2331: 0a87: \***
2332: 0a87: \***   FILE.READ.ERROR:
2333: 0a87: \***
2334: 0a87: \***         set FUNCTION.FLAG$ to "R"
2335: 0a87: \***             PASSED.INTEGER% to file no and
2336: 0a87: \***             PASSED.STRING$ to ""
2337: 0a87: \***         use SESS.NUM.UTILITY function to obtain reporting number for ERRF%
2338: 0a87: \***         IF F20.RETURN.CODE% <> 0 THEN
2339: 0a87: \***            GOTO PROGRAM.EXIT
2340: 0a87: \***         ENDIF
2341: 0a87: \***
2342: 0a87: \***         set ERRFILE$ to CHR$(F20.INTEGER.FILE.NO%)
2343: 0a87: \***         set VAR.STRING.2$ to F20.STRING.FILE.NO$
2344: 0a87: \***
2345: 0a87: \***         CALL APPLICATION.LOG to log error number 503
2346: 0a87: \***         GOTO FUNCTION.EXIT
2347: 0a87: \***
2348: 0a87: \***
2349: 0a87: \***      EXIT the function
2350: 0a87: \***
2351: 0a87: \***
2352: 0a87: \***
2353: 0a87: \-------------------------------------------------------------------------------
2354: 0a87: 
2355: 0a87:    FILE.READ.ERROR:
2356: 0a87: 
2357: 0a87:       FUNCTION.FLAG$  = "R"                                            ! BBCW
2358: 0a94:       PASSED.INTEGER% = FILE.NO%                                       ! BBCW
2359: 0a9a:       PASSED.STRING$  = ""                                             ! BBCW
2360: 0aa7:       RET.CODE% = SESS.NUM.UTILITY (FUNCTION.FLAG$,                    \ DAW
2361: 0ac7:                                     PASSED.INTEGER%,                   \ BBCW
2362: 0ac7:                                     PASSED.STRING$)                    ! BBCW
2363: 0ac7: 
2364: 0ac7:       IF RET.CODE% <> 0 THEN GOTO PROGRAM.EXIT                         ! DAW
2365: 0acf: 
2366: 0acf:       EVENT.NO% = 6
2367: 0ad5:       INTEGER1% = FILE.NO%                                             ! BBCW
2368: 0adb:       ERRFILE$ = CHR$(F20.INTEGER.FILE.NO%)                            ! BBCW
2369: 0af0: 
2370: 0af0: 
2371: 0af0:       MESSAGE.NUMBER% = 503
2372: 0af6:       VAR.STRING.1$ = "R" + ERRFILE$
2373: 0b0e:       VAR.STRING.2$ = F20.STRING.FILE.NO$                              ! BBCW
2374: 0b22:       RET.CODE% = APPLICATION.LOG (MESSAGE.NUMBER%,                    \ DAW
2375: 0b46:                                    VAR.STRING.1$,                      \
2376: 0b46:                                    VAR.STRING.2$,                      \
2377: 0b46:                                    EVENT.NO%)                         :\
2378: 0b46: 
2379: 0b46:       OPEN.IRF.UPDT = 1                                                ! DAW
2380: 0b4b:       GOTO FUNCTION.EXIT
2381: 0b4e: 
2382: 0b4e: 
2383: 0b4e: \*******************************************************************************
2384: 0b4e: \*********************** subroutine follows ************************************
2385: 0b4e: \*******************************************************************************
2386: 0b4e: \***
2387: 0b4e: \*** UPDT.OPEN.ERROR.DETECTED
2388: 0b4e: \***
2389: 0b4e: \***   Set the function 19 return code to 1.
2390: 0b4e: \***
2391: 0b4e: \***   Log an event 18, message number 553 for a chaining error.  Other errors
2392: 0b4e: \***   are logged as event 101s by calling the standard error detected function.
2393: 0b4e: \***
2394: 0b4e: \***   If the calling program is a batch program then processing stops.  If it
2395: 0b4e: \***   is a screen program then the first program in the current application is
2396: 0b4e: \***   chained back to.
2397: 0b4e: \***
2398: 0b4e: \-------------------------------------------------------------------------------
2399: 0b4e: 
2400: 0b4e:    UPDT.OPEN.ERROR.DETECTED:
2401: 0b4e: 
2402: 0b4e:       OPEN.IRF.UPDT = 1                                                ! DAW
2403: 0b53: 
2404: 0b53:       ! lines deleted from here                                        ! DAW
2405: 0b53: 
2406: 0b53: 
2407: 0b53:       IF ERR = "CM" OR ERR = "CT" THEN                        \REM chain failure
2408: 0bad:          MESSAGE.NUMBER% = 553                                        :\
2409: 0bb3:          VAR.STRING.1$  = "BF19 " + MID$(MODULE.NUMBER$,3,1) + "50  " :\ BBCW
2410: 0be6:          VAR.STRING.2$  = "PS" + MID$(MODULE.NUMBER$,3,1) + "50"      :\ BBCW
2411: 0c19:          EVENT.NO%      = 18                                          :\
2412: 0c1f:          RET.CODE% = APPLICATION.LOG (MESSAGE.NUMBER%,                 \ DAW
2413: 0c43:                                       VAR.STRING.1$,                   \
2414: 0c43:                                       VAR.STRING.2$,                   \
2415: 0c43:                                       EVENT.NO%)
2416: 0c43: 
2417: 0c43: 
2418: 0c43:       IF ERR <> "CM" AND ERR <> "CT" THEN                              \
2419: 0c9a:          RET.CODE% = STANDARD.ERROR.DETECTED (ERRN,                    \ DAW
2420: 0cc2:                                               ERRF%,                   \ DAW                                       \
2421: 0cc2:                                               ERRL,                    \ DAW
2422: 0cc2:                                               ERR)                     ! DAW
2423: 0cc2:       RESUME FUNCTION.EXIT
2424: 0cd1:    PROGRAM.EXIT:                                                       ! BBCW
2425: 0cd1: 
2426: 0cd1:       IF BATCH.SCREEN.FLAG$ <> "S" THEN                                \
2427: 0ce7:          STOP
2428: 0cec: 
2429: 0cec:       %INCLUDE PSBCHNE.J86
2430: 0cec: \/*********************************************************************/ PSBCHNE
2431: 0cec: \/*                                                                   */ PSBCHNE
2432: 0cec: \/*      PSBCHNE.J86  -  Chain to PSB Application Program             */ PSBCHNE
2433: 0cec: \/*      ------------------------------------------------             */ PSBCHNE
2434: 0cec: \/*                                                                   */ PSBCHNE
2435: 0cec: \/*********************************************************************/ PSBCHNE
2436: 0cec:                                                                        ! PSBCHNE
2437: 0cec:         CHAIN  PSBCHN.PRG , PSBCHN.OP , PSBCHN.APP , PSBCHN.MENCON ,   \ PSBCHNE
2438: 0d64:                             PSBCHN.U1 , PSBCHN.U2  , PSBCHN.U3         ! PSBCHNE
2439: 0d64:                                                                        ! PSBCHNE
2440: 0d64: 
2441: 0d64:    END FUNCTION
2442: 0d7d: 
2443: 0d7d: 
2444: 0d7d: \*******************************************************************************
2445: 0d7d: \*********                 Function UPDT.IRF.TIF.UPDT                 ********** ! ! LCSk
2446: 0d7d: \*******************************************************************************
2447: 0d7d: \***
2448: 0d7d: \*** FUNCTION UPDT.IRF.TIF.UPDT (new IRF data,                                   ! ! LCSk
2449: 0d7d: \***                             add/change/delete flag
2450: 0d7d: \***                             irf locked flag) PUBLIC
2451: 0d7d: \***
2452: 0d7d: \***     If irf.locked flag is 2 chars, then 1st is irf.locked.flag and the ! 1.1
2453: 0d7d: \***     second is the calling program type (R/L/E - RPD/Local/Emergency)   ! 1.1
2454: 0d7d: \***     which will default to 'R' if not present.                          ! 1.1
2455: 0d7d: \***
2456: 0d7d: \-------------------------------------------------------------------------------
2457: 0d7d: 
2458: 0d7d:   !FUNCTION UPDT.IRF.UPDT (NEW.IRF.DATA$,                              ! ! LCSk
2459: 0d7d:    FUNCTION UPDT.IRF.TIF.UPDT (NEW.IRF.DATA$,                          \ ! ! LCSk
2460: 0d7d:                                ACD.FLAG$,                              \ BBCW
2461: 0d7d:                                IRF.LOCKED.FLAG$)                       \ BBCW
2462: 0d7d:    PUBLIC
2463: 0da0: 
2464: 0da0:       STRING    ACD.FLAG$,                                             \
2465: 0da0: \ 1 line deleted from here                                             \ DAW
2466: 0da0:                 ERRFILE$,                                              \
2467: 0da0:                 ERRNUM$,                                               \
2468: 0da0:                 FILE$,                                                 \
2469: 0da0:                 FUNCTION.FLAG$,                                        \ BBCW
2470: 0da0:                 IRF.LOCKED.FLAG$,                                      \ BBCW
2471: 0da0: \ 1 line deleted from here                                             \ DAW
2472: 0da0:                 NEW.IRF.DATA$,                                         \
2473: 0da0:                 NEW.LABEL$,                                            \ 1.11 NWB
2474: 0da0:                 NEW.TYPE$,                                             \ 1.11 NWB
2475: 0da0:                 ON.TIF.FLAG$,                                          \
2476: 0da0: \ 1 line deleted from here                                             \ DAW
2477: 0da0:                 PASSED.STRING$,                                        \ BBCW
2478: 0da0:                 PIPE.NUM$,                                             \ BBCW
2479: 0da0:                 PIPE.OPEN.FLAG$,                                       \ CJAL
2480: 0da0:                 RETURN.CODE$,                                          \
2481: 0da0:                 STRING.ERRL$,                                          \
2482: 0da0:                 TMCF.EOF$,                                             \
2483: 0da0:                 UNIQUE$,                                               \
2484: 0da0:                 VAR.STRING.1$,                                         \
2485: 0da0:                 VAR.STRING.2$
2486: 0da0: 
2487: 0da0:       INTEGER*1 EALGARLP.REPORT.NUM%,                                  \ BBCW
2488: 0da0:                 EVENT.NUM%,                                            \
2489: 0da0:                 FILE.NO%,                                              \ BBCW
2490: 0da0:                 INTEGER1%,                                             \
2491: 0da0:                 MSGGRP%,                                               \
2492: 0da0:                 ON.LP%,                                                \ 1.11 NWB
2493: 0da0:                 PASSED.INTEGER%,                                       \ BBCW
2494: 0da0:                 pc%,                                                   \ 1.11 NWB
2495: 0da0:                 PHF.DATA%,                                             \ 1.11 NWB
2496: 0da0:                 SEVERITY%,                                             \
2497: 0da0:                 TMCF.SAVED.ACTION                                      !  NFH
2498: 0da0: 
2499: 0da0:       INTEGER   EALGARLP.SESS.NUM%,                                    \ BBCW
2500: 0da0:                 EVENT.NO%,                                             \
2501: 0da0:                 F17.RETURN.CODE%,                                      \ DAW
2502: 0da0:                 MESSAGE.NUMBER%,                                       \
2503: 0da0:                 MSGNUM%,                                               \
2504: 0da0:                 RC%,                                                   \ 1.11 NWB
2505: 0da0:                 RET.CODE%,                                             \
2506: 0da0:                 SESSION.NUMBER%,                                       \
2507: 0da0:                 TERM%,                                                 \
2508: 0da0:                \UPDT.IRF.UPDT,                                         \ DAW ! ! LCSk
2509: 0da0:                 UPDT.IRF.TIF.UPDT,                                     \ ! ! LCSk
2510: 0da0:                 WAIT.PERIOD%                                           ! BBCW
2511: 0da0: 
2512: 0da0:       INTEGER*4 INTEGER4%,                                             \
2513: 0da0:                 NEW.PRICE%,                                            \ 1.11 NWB
2514: 0da0:                 OLD.PRICE%,                                            \ 1.11a NWB
2515: 0da0:                 TMCF.SIZE%
2516: 0da0: 
2517: 0da0: \*******************************************************************************
2518: 0da0: \***
2519: 0da0: \***   ON ERROR goto UPDT.UPDT.ERROR.DETECTED  (after logging the error, the
2520: 0da0: \***                                            function is immediately left)
2521: 0da0: \***
2522: 0da0: \***
2523: 0da0: \***   REM set up storage areas for ADXERROR required fields in case of memory
2524: 0da0: \***   overflow
2525: 0da0: \***
2526: 0da0: \***   set chaining module to first module in current application
2527: 0da0: \***
2528: 0da0: \-------------------------------------------------------------------------------
2529: 0da0: 
2530: 0da0:       ON ERROR GOTO UPDT.UPDT.ERROR.DETECTED
2531: 0dad: 
2532: 0dad: !     Lines deleted                                                       ! 1.8 RC
2533: 0dad: !     Un-necessary duplication of OPEN.IRF.UPDT file SET calls            ! 1.8 RC
2534: 0dad: 
2535: 0dad:      !UPDT.IRF.UPDT = 0                                                ! DAW ! ! LCSk
2536: 0dad:       UPDT.IRF.TIF.UPDT = 0                                               ! ! LCSk
2537: 0db2:       UNIQUE$ = "          "
2538: 0dbf:       ERRNUM$ = "    "
2539: 0dcc:       ERRFILE$ = " "
2540: 0dd9:       STRING.ERRL$ = "      "
2541: 0de6: 
2542: 0de6:       PSBCHN.PRG = "ADX_UPGM:PSB50.286"                                !1.10 SWM
2543: 0df5: 
2544: 0df5: !     Debug code removed in revision 1.6                                  ! 1.8 RC
2545: 0df5: 
2546: 0df5: \*******************************************************************************
2547: 0df5: \***
2548: 0df5: \***  REMOVED IF the controller id is not "DE" OR                      ! LCSk
2549: 0df5: \***  REMOVED   the on tif flag is off THEN                            ! LCSk
2550: 0df5: \***  REMOVED   GOTO ONLY.PROCESS.IRF                                  ! LCSk
2551: 0df5: \***  REMOVED endif                                                    ! LCSk
2552: 0df5: \***
2553: 0df5: \***  IF the ACD flag is not ADD THEN
2554: 0df5: \***     read the TIF using the IRF bar code as key, to determine the value of
2555: 0df5: \***     the on tif flag
2556: 0df5: \***
2557: 0df5: \***  GOSUB CREATE.PIPE
2558: 0df5: \***
2559: 0df5: \***  IF END of the TMCF then FILE.READ.ERROR
2560: 0df5: \***  CALL READ.TMCF.HEADER
2561: 0df5: \***
2562: 0df5: \***  IF acd flag = add THEN
2563: 0df5: \***     GOSUB ADD.TIF
2564: 0df5: \***  ELSE
2565: 0df5: \***     IF acd flag = change THEN
2566: 0df5: \***        GOSUB CHANGE.TIF
2567: 0df5: \***     ELSE
2568: 0df5: \***        GOSUB DELETE.TIF
2569: 0df5: \***     endif
2570: 0df5: \***  endif
2571: 0df5: \***
2572: 0df5: \***  set FILE.NO% to TMCF session number
2573: 0df5: \***  WRITE the data record to the end of the TMCF
2574: 0df5: \***
2575: 0df5: \***  IF tmcf size > tmcf max size AND
2576: 0df5: \***     tmcf full flag is "N" THEN
2577: 0df5: \***     set tmcf full flag to "Y"
2578: 0df5: \***     CALL ADXERROR logging message number A301,
2579: 0df5: \***                           severity 3,
2580: 0df5: \***                           event number 6.
2581: 0df5: \***  endif
2582: 0df5: \***
2583: 0df5: \***  CLOSE the pipe
2584: 0df5: \***
2585: 0df5: \***  FUNCTION.EXIT:
2586: 0df5: \***
2587: 0df5: \***     EXIT FUNCTION
2588: 0df5: \***
2589: 0df5: \***
2590: 0df5: \*******************************************************************************
2591: 0df5: 
2592: 0df5:     NEW.TYPE$ = "R"                     ! Default to RPD              ! 1.11 NWB
2593: 0e02:     IF LEN(IRF.LOCKED.FLAG$) = 2 THEN BEGIN                           ! 1.11 NWB
2594: 0e13:        NEW.TYPE$        = RIGHT$(IRF.LOCKED.FLAG$, 1)                 ! 1.11 NWB
2595: 0e29:        IRF.LOCKED.FLAG$ = LEFT$ (IRF.LOCKED.FLAG$, 1)                 ! 1.11 NWB
2596: 0e42:     ENDIF                                                             ! 1.11 NWB
2597: 0e42: 
2598: 0e42:     ! Save passed price for later use in PHF Process                  ! 1.11a NWB
2599: 0e42:     OLD.PRICE% = 0                                                    ! 1.11a NWB
2600: 0e4f:     IF ACD.FLAG$ = "CHANGE" THEN                                      \ 1.11a NWB
2601: 0e60:        OLD.PRICE% = VAL(UNPACK$(IRF.SALEPRIC$))                       ! 1.11a NWB
2602: 0e85: 
2603: 0e85:     CALL SPLIT.NEW.IRF.DATA$ ! Sets IRF variables from IRF record string  ! 1.8 RC
2604: 0e8a:                              ! TIF variables only set prior to TIF write  ! 1.8 RC
2605: 0e8a:                              ! Moved to function start for revision 1.9   ! 1.9 RC
2606: 0e8a: 
2607: 0e8a:    !IF NODE.ID$ <> "DE" THEN                                         \ ! LCSk
2608: 0e8a:    !   GOSUB ONLY.PROCESS.IRF                                       :\ ! LCSk
2609: 0e8a:    !   GOTO FUNCTION.EXIT                                              ! LCSk
2610: 0e8a: 
2611: 0e8a: !! setting of TIF.FORMAT moved to the OPEN routine where        !FSJW
2612: 0e8a: !! the RECL's are set                           !FSJW
2613: 0e8a: 
2614: 0e8a:       IF ACD.FLAG$ <> "ADD" THEN \                                     ! CJAL
2615: 0e9b:           BEGIN                                                        ! 1.8 RC
2616: 0e9b: !         Removed redundant code processing                            ! 1.8 RC
2617: 0e9b: !         unused TIF and TMCF file formats                             ! 1.8 RC
2618: 0e9b:           TIF.BAR.CODE$ = IRF.BAR.CODE$                                ! 1.8 RC
2619: 0eb1:           RET.CODE% = READ.TIF.BOOTS.DATA                              ! DW
2620: 0eb9:           GOSUB TEST.TIF.RETURN.CODE                                   ! DW
2621: 0ec3:           ENDIF                                                        ! 1.8 RC
2622: 0ec3: 
2623: 0ec3: !   Label removed from here                                            ! CJAL
2624: 0ec3: 
2625: 0ec3:       GOSUB CREATE.PIPE
2626: 0ecd: 
2627: 0ecd:       FILE.NO%     = TMCF.SESS.NUM%                                    ! BBCW
2628: 0ed7:       TMCF.REC.NO% = 1
2629: 0ee0:       RET.CODE% = READ.TMCF.HEADER.LOCKED                              ! FSP
2630: 0ee8:       IF RET.CODE% <> 0 THEN BEGIN                                     ! FSP
2631: 0eed:          GOSUB FILE.READ.ERROR                                         ! FSP
2632: 0ef7:       ENDIF                                                            ! FSP
2633: 0ef7: 
2634: 0ef7: \**********************************************************************!  NFH
2635: 0ef7: \ REM Lines moved from here to further down                            !  NFH
2636: 0ef7: 
2637: 0ef7:       IF ACD.FLAG$ = "ADD" THEN                                        \
2638: 0f08:          GOSUB ADD.TIF                                                :\
2639: 0f12:          GOSUB UPDATE.TIF                                              \
2640: 0f1e:       ELSE                                                             \
2641: 0f1e:          IF ACD.FLAG$ = "CHANGE" THEN                                  \
2642: 0f2f:             GOSUB CHANGE.TIF                                          :\
2643: 0f39:             GOSUB UPDATE.TIF                                           \
2644: 0f45:          ELSE                                                          \
2645: 0f45:             GOSUB DELETE.TIF
2646: 0f4f: 
2647: 0f4f:       TMCF.SAVED.ACTION = TMCF.ACTION%                                 !  NFH
2648: 0f59:                                                                        !  NFH
2649: 0f59: \**********************************************************************!  NFH
2650: 0f59: \ REM Lines moved to here                                              !  NFH
2651: 0f59:                                                                        !  NFH
2652: 0f59: 
2653: 0f59: ! Lines moved to TMCF.UPDATE
2654: 0f59: !     TMCF.REC.NO% = 1 + SIZE(TMCF.FILE.NAME$) / 51                    !  NFH
2655: 0f59: 
2656: 0f59: !     TMCF.ACTION% = TMCF.SAVED.ACTION                                 !  NFH
2657: 0f59: 
2658: 0f59: !     TMCF.MNTDATA$ = NEW.IRF.DATA$
2659: 0f59: 
2660: 0f59: !     RET.CODE% =  WRITE.TMCF.DATA                                     ! FSP
2661: 0f59: !     IF RET.CODE% <>  0 THEN BEGIN                                    ! FSP
2662: 0f59: !        GOSUB FILE.WRITE.ERROR                                        ! FSP
2663: 0f59: !     ENDIF                                                            ! FSP
2664: 0f59: ! End of moved lines
2665: 0f59: 
2666: 0f59:       TMCF.SIZE% = SIZE("EALTMCFR")
2667: 0f6f: 
2668: 0f6f:       IF TMCF.SIZE% > GAOPT.DFLTSIZE% AND                              \
2669: 0fb2:          TMCF.FULL$ = "N" THEN                                         \
2670: 0fb2:          TMCF.FULL$ = "Y"                                             :\
2671: 0fc1:          MSGNUM% = 301                                                :\
2672: 0fc7:          MSGGRP% = ASC("A")                                           :\ CJAL
2673: 0fd3:          SEVERITY% = 3                                                :\
2674: 0fd8:          TERM% = 0                                                    :\
2675: 0fde:          EVENT.NUM% = 6                                               :\
2676: 0fe3:          UNIQUE$ = "W" + STR$(TMCF.REPORT.NUM%)                       :\ BBCW
2677: 1002:          CALL ADXERROR (TERM%,                                         \
2678: 1029:                         MSGGRP%,                                       \
2679: 1029:                         MSGNUM%,                                       \
2680: 1029:                         SEVERITY%,                                     \
2681: 1029:                         EVENT.NUM%,                                    \
2682: 1029:                         UNIQUE$)
2683: 1029: 
2684: 1029: !  Following line moved up from end of this section                    ! CJAL
2685: 1029:    FUNCTION.EXIT:                                                      ! CJAL
2686: 1029: 
2687: 1029:       IF PIPE.OPEN.FLAG$ = "Y" THEN                                    \ CJAL
2688: 103c:          PIPE.OPEN.FLAG$ = "N"                                        :\ CJAL
2689: 1049:          CLOSE EALGARLP.SESS.NUM%                                      ! BBCW
2690: 1052: 
2691: 1052:       FUNCTION.FLAG$  = "C"                                            ! BBCW
2692: 105f:       PASSED.INTEGER% = EALGARLP.SESS.NUM%                             ! BBCW
2693: 1065:       PASSED.STRING$  = ""                                             ! BBCW
2694: 1072: 
2695: 1072:       RET.CODE% = SESS.NUM.UTILITY (FUNCTION.FLAG$,                    \ DAW
2696: 1092:                                     PASSED.INTEGER%,                   \ BBCW
2697: 1092:                                     PASSED.STRING$)                    ! BBCW
2698: 1092: 
2699: 1092:       IF RET.CODE% <> 0 THEN GOTO PROGRAM.EXIT                         ! DAW
2700: 109a: 
2701: 109a: !  Label moved from here                                               ! CJAL
2702: 109a: 
2703: 109a:       EXIT FUNCTION
2704: 109d: 
2705: 109d: 
2706: 109d: \*******************************************************************************
2707: 109d: \*********************** subroutines follow ************************************
2708: 109d: \*******************************************************************************
2709: 109d: \***
2710: 109d: \***  TMCF.UPDATE
2711: 109d: \***
2712: 109d: \***  Lines moved here from above
2713: 109d: \***
2714: 109d: \*******************************************************************************
2715: 109d: 
2716: 109d: TMCF.UPDATE:
2717: 109d: 
2718: 109d:       TMCF.REC.NO% = 1 + SIZE(TMCF.FILE.NAME$) / 51                    !  NFH
2719: 10cc: 
2720: 10cc: !     TMCF.ACTION% = TMCF.SAVED.ACTION                                 !  NFH
2721: 10cc: 
2722: 10cc:       TMCF.MNTDATA$ = NEW.IRF.DATA$ ! IRF record string passed to function
2723: 10dd: 
2724: 10dd:       RET.CODE% =  WRITE.TMCF.DATA                                     ! FSP
2725: 10e5:       IF RET.CODE% <>  0 THEN BEGIN                                    ! FSP
2726: 10ea:          GOSUB FILE.WRITE.ERROR                                        ! FSP
2727: 10f4:       ENDIF
2728: 10f4: 
2729: 10f4:       TMCF.MAINTLVL% = TMCF.REC.NO%
2730: 1109: 
2731: 1109: RETURN
2732: 1111: 
2733: 1111: \*******************************************************************************
2734: 1111: \***
2735: 1111: \***  CREATE.PIPE:
2736: 1111: \***
2737: 1111: \***     ON ERROR GOTO PIPE.ERROR
2738: 1111: \***
2739: 1111: \***     set pipe open flag to "N"
2740: 1111: \***     set return code to null
2741: 1111: \***
2742: 1111: \***     CREATE the pipe EALGARLP AS 1
2743: 1111: \***
2744: 1111: \***     set wait period to zero
2745: 1111: \***
2746: 1111: \***     WHILE return code is not null (i.e. create failed)
2747: 1111: \***
2748: 1111: \***        IF wait period exceeds half an hour THEN
2749: 1111: \***           log event 52 (Time out on pipe)
2750: 1111: \***           set return code to 1
2751: 1111: \***           exit function
2752: 1111: \***
2753: 1111: \***        WAIT 1 second
2754: 1111: \***        set return code to null
2755: 1111: \***        CREATE the pipe EALGARLP AS 1
2756: 1111: \***
2757: 1111: \***     WEND
2758: 1111: \***
2759: 1111: \***     ON ERROR GOTO UPDT.UPDT.ERROR.DETECTED
2760: 1111: \***
2761: 1111: \***     set pipe open flag to "Y"
2762: 1111: \***
2763: 1111: \***     RETURN
2764: 1111: \***
2765: 1111: \***  PIPE.ERROR:
2766: 1111: \***
2767: 1111: \***     set return code to ERR
2768: 1111: \***
2769: 1111: \***     RESUME
2770: 1111: \***
2771: 1111: \***
2772: 1111: \-------------------------------------------------------------------------------
2773: 1111: 
2774: 1111:    CREATE.PIPE:
2775: 1111: 
2776: 1111:       PIPE.OPEN.FLAG$ = "N"                                            ! CJAL
2777: 111e:       RETURN.CODE$ = ""
2778: 112b: 
2779: 112b:       EALGARLP.REPORT.NUM% = 104                                       ! BBCW
2780: 1130:       PIPE.NUM$ = "104"                                                ! BBCW
2781: 113d:       FUNCTION.FLAG$       = "O"                                       ! BBCW
2782: 114a:       PASSED.INTEGER%      = EALGARLP.REPORT.NUM%                      ! BBCW
2783: 1150:       PASSED.STRING$       = "PI:EALGARLP"                             ! BBCW
2784: 115d: 
2785: 115d:       RET.CODE% = SESS.NUM.UTILITY (FUNCTION.FLAG$,                    \ DAW
2786: 117d:                                     PASSED.INTEGER%,                   \ BBCW
2787: 117d:                                     PASSED.STRING$)                    ! BBCW
2788: 117d: 
2789: 117d:       IF RET.CODE% <> 0 THEN GOTO PROGRAM.EXIT                         ! DAW
2790: 1185: 
2791: 1185:       EALGARLP.SESS.NUM% = F20.INTEGER.FILE.NO%                        ! BBCW
2792: 118f:       FILE.NO%           = F20.INTEGER.FILE.NO%                        ! BBCW
2793: 119a: 
2794: 119a:       ON ERROR GOTO PIPE.ERROR
2795: 11a7: 
2796: 11a7:       CREATE "PI:EALGARLP" AS EALGARLP.SESS.NUM%                       ! BBCW
2797: 11bc: 
2798: 11bc:       WAIT.PERIOD% = 0                                                 ! BBCW
2799: 11c2: 
2800: 11c2:       WHILE RETURN.CODE$ <> ""
2801: 11c4:          IF WAIT.PERIOD% > 1800 THEN                                   \ BBCW
2802: 11cc:             EVENT.NO% = 52                                            :\ BBCW
2803: 11d2:             MESSAGE.NUMBER% = 0                                       :\ BBCW
2804: 11d8:             VAR.STRING.1$ = "EALGARLP"                                :\ BBCW
2805: 11e5:             RET.CODE% = APPLICATION.LOG (MESSAGE.NUMBER%,              \ DAW
2806: 1209:                                          VAR.STRING.1$,                \ BBCW
2807: 1209:                                          VAR.STRING.2$,                \ BBCW
2808: 1209:                                          EVENT.NO%)                   :\ BBCW
2809: 1209:            !UPDT.IRF.UPDT = 1                                         :\ DAW ! ! LCSk
2810: 1209:             UPDT.IRF.TIF.UPDT = 1                                     :\ ! ! LCSk
2811: 1209:             GOTO FUNCTION.EXIT                                         ! BBCW
2812: 1209: 
2813: 1209:          WAIT; 1000
2814: 1218:          RETURN.CODE$ = ""
2815: 1225:          CREATE "PI:EALGARLP" AS EALGARLP.SESS.NUM%                    ! BBCW
2816: 123a:          WAIT.PERIOD% = WAIT.PERIOD% + 1                               ! BBCW
2817: 123e: 
2818: 123e:       WEND
2819: 1254: 
2820: 1254:       ON ERROR GOTO UPDT.UPDT.ERROR.DETECTED
2821: 1261:       PIPE.OPEN.FLAG$ = "Y"                                            ! CJAL
2822: 126e: 
2823: 126e:       RETURN
2824: 1276: 
2825: 1276:    PIPE.ERROR:
2826: 1276: 
2827: 1276:       RETURN.CODE$ = ERR
2828: 1284: 
2829: 1284:       RESUME
2830: 1293: 
2831: 1293: 
2832: 1293: \*******************************************************************************
2833: 1293: \***
2834: 1293: \***  ADD.TIF:
2835: 1293: \***
2836: 1293: \***     check size of TIF - if too large, GOSUB CHECK.MESSAGE.DISPLAYED
2837: 1293: \***          and exit function
2838: 1293: \***
2839: 1293: \***     set up individual IRF fields from new irf data
2840: 1293: \***     set FILE.NO% to IRF.SESS.NUM%
2841: 1293: \***     IF irf locked flag = "Y" THEN
2842: 1293: \***        CALL WRITE.IRF.HOLD.UNLOCK
2843: 1293: \***     ELSE
2844: 1293: \***        CALL WRITE.IRF.HOLD
2845: 1293: \***     ENDIF
2846: 1293: \***     set tmcf action to 2
2847: 1293: \***     set tmcf rcdkey to irf key
2848: 1293: \***     add 1 to tmcf numrecs
2849: 1293: \***     set FILE.NO% to TMCF.SESS.NUM%
2850: 1293: \***     CALL WRITE.TMCF.HEADER.HOLD.UNLOCK
2851: 1293: \***
2852: 1293: \***     RETURN
2853: 1293: \***
2854: 1293: \-------------------------------------------------------------------------------
2855: 1293: 
2856: 1293:    ADD.TIF:
2857: 1293: 
2858: 1293:       IF GAOPT.NUMITEMS% < TMCF.NUMRECS% THEN                          \ CJAL
2859: 12ab:          GOSUB CHECK.MESSAGE.DISPLAYED                                :\ CJAL
2860: 12b5:          GOSUB FUNCTION.EXIT                                           ! CJAL
2861: 12bf: 
2862: 12bf: !     Lines deleted - IRF variables now set by SPLIT.NEW.IRF.DATA$        ! 1.8 RC
2863: 12bf: 
2864: 12bf:       FILE.NO% = IRF.SESS.NUM%                                         ! BBCW
2865: 12c9:       IF IRF.LOCKED.FLAG$ = "Y" THEN BEGIN                             ! BBCW
2866: 12da: 
2867: 12da:          RET.CODE% =  WRITE.IRF.HOLD.UNLOCK                            ! BBCW
2868: 12e2:          IF RET.CODE% <> 0 THEN BEGIN                                  ! FSP
2869: 12e7:             GOSUB FILE.WRITE.ERROR                                     ! FSP
2870: 12f1:          ENDIF                                                         ! FSP
2871: 12f3:                                                                        ! FSP
2872: 12f3:       ENDIF ELSE BEGIN                                                 ! BBCW
2873: 12f3:                                                                        ! FSP
2874: 12f3:          RET.CODE% = WRITE.IRF.HOLD                                    ! FSP  ! BBCW
2875: 12fb:          IF RET.CODE% <> 0 THEN BEGIN                                  ! FSP
2876: 1300:             GOSUB FILE.WRITE.ERROR                                     ! FSP
2877: 130a:          ENDIF                                                         ! FSP
2878: 130a:                                                                        ! FSP
2879: 130a:      ENDIF                                                             ! FSP
2880: 130a: 
2881: 130a:      GOSUB PROCESS.PHF                                                ! 1.11 NWB
2882: 1314: 
2883: 1314:       TMCF.ACTION% = 2
2884: 131c: ! DW  TMCF.MAINTLVL% = TMCF.MAINTLVL% + 1                              !  NFH
2885: 131c:       TMCF.RCDKEY$ = MID$(NEW.IRF.DATA$,1,11)
2886: 1336:       TMCF.NUMRECS% = TMCF.NUMRECS% + 1
2887: 1347:       FILE.NO% = TMCF.SESS.NUM%                                        ! BBCW
2888: 1351: 
2889: 1351:       GOSUB TMCF.UPDATE                                                ! DW
2890: 135b: 
2891: 135b:       TMCF.REC.NO% = 1                                                 ! DW
2892: 1364:       RET.CODE% = WRITE.TMCF.HEADER.HOLD.UNLOCK
2893: 136c:       IF RET.CODE% <> 0 THEN BEGIN                                     ! FSP
2894: 1371:          GOSUB FILE.WRITE.ERROR                                        ! FSP
2895: 137b:       ENDIF                                                            ! FSP
2896: 137b: 
2897: 137b: 
2898: 137b:       RETURN
2899: 1383: 
2900: 1383: 
2901: 1383: \*******************************************************************************
2902: 1383: \***
2903: 1383: \***  CHECK.MESSAGE.DISPLAYED:
2904: 1383: \***
2905: 1383: \***     If the tif full flag is "N" (ie. 1st time this has happened) THEN
2906: 1383: \***        set tif full flag to "Y" call ADXERROR to log an event 42
2907: 1383: \***
2908: 1383: \***     RETURN
2909: 1383: \***
2910: 1383: \-------------------------------------------------------------------------------
2911: 1383: 
2912: 1383:      CHECK.MESSAGE.DISPLAYED:                                          ! CJAL
2913: 1383: 
2914: 1383:        IF TIF.FULL$ = "N" THEN                                         \
2915: 139c:           TIF.FULL$ = "Y"                                             :\
2916: 13ab:           MSGNUM% = 300                                               :\
2917: 13b1:           MSGGRP% = ASC("A")                                          :\
2918: 13bd:           SEVERITY% = 3                                               :\
2919: 13c2:           TERM% = 0                                                   :\
2920: 13c8:           EVENT.NUM% = 46                                             :\
2921: 13cd:           UNIQUE$ = STR$(TIF.REPORT.NUM%) +                            \ BBCW
2922: 1415:                    RIGHT$(UNPACK$(TIF.BAR.CODE$),8)                   :\ BBCW
2923: 1415:           CALL ADXERROR (TERM%,                                        \
2924: 143c:                          MSGGRP%,                                      \
2925: 143c:                          MSGNUM%,                                      \
2926: 143c:                          SEVERITY%,                                    \
2927: 143c:                          EVENT.NUM%,                                   \
2928: 143c:                          UNIQUE$)                                      !
2929: 143c: 
2930: 143c:           RETURN                                                       ! CJAL
2931: 1444: 
2932: 1444: 
2933: 1444: \*******************************************************************************
2934: 1444: \***
2935: 1444: \***  CHANGE.TIF:
2936: 1444: \***
2937: 1444: \***     set up individual IRF fields from new irf data
2938: 1444: \***     set FILE.NO% to irf session no
2939: 1444: \***     IF irf locked flag = "Y" THEN
2940: 1444: \***        CALL WRITE.IRF.HOLD.UNLOCK
2941: 1444: \***     ELSE
2942: 1444: \***        CALL WRITE.IRF.HOLD
2943: 1444: \***     ENDIF
2944: 1444: \***
2945: 1444: \***     set tmcf action to 2
2946: 1444: \***     set tmcf rcdkey to irf key
2947: 1444: \***     set FILE.NO% to tmcf session no
2948: 1444: \***
2949: 1444: \***     RETURN
2950: 1444: \***
2951: 1444: \-------------------------------------------------------------------------------
2952: 1444: 
2953: 1444:    CHANGE.TIF:
2954: 1444: 
2955: 1444: !     Lines deleted - IRF variables now set by SPLIT.NEW.IRF.DATA$        ! 1.8 RC
2956: 1444: 
2957: 1444:       FILE.NO%           = IRF.SESS.NUM%                               ! BBCW
2958: 144e: 
2959: 144e:       IF IRF.LOCKED.FLAG$ = "Y" THEN BEGIN                             ! BBCW
2960: 145f: 
2961: 145f:          RET.CODE% =  WRITE.IRF.HOLD.UNLOCK                            ! BBCW
2962: 1467:          IF RET.CODE% <> 0 THEN BEGIN                                  ! FSP
2963: 146c:             GOSUB FILE.WRITE.ERROR                                     ! FSP
2964: 1476:          ENDIF                                                         ! FSP
2965: 1478:                                                                        ! FSP
2966: 1478:       ENDIF ELSE BEGIN                                                 ! BBCW
2967: 1478:                                                                        ! FSP
2968: 1478:          RET.CODE% = WRITE.IRF.HOLD                                    ! FSP
2969: 1480:          IF RET.CODE% <> 0 THEN BEGIN                                  ! FSP
2970: 1485:             GOSUB FILE.WRITE.ERROR                                     ! FSP
2971: 148f:          ENDIF                                                         ! FSP
2972: 148f:                                                                        ! FSP
2973: 148f:       ENDIF                                                            ! FSP
2974: 148f: 
2975: 148f:      GOSUB PROCESS.PHF                                                ! 1.11 NWB
2976: 1499: 
2977: 1499:       TMCF.ACTION%   = 2
2978: 14a1: ! DW  TMCF.MAINTLVL% = TMCF.MAINTLVL% + 1                              !  NFH
2979: 14a1:       TMCF.RCDKEY$   = MID$(NEW.IRF.DATA$,1,11)
2980: 14bb:       FILE.NO%       = TMCF.SESS.NUM%                                  ! BBCW
2981: 14c5: 
2982: 14c5:       GOSUB TMCF.UPDATE                                                ! DW
2983: 14cf: 
2984: 14cf:       TMCF.REC.NO% = 1                                                 ! DW
2985: 14d8:       RET.CODE% = WRITE.TMCF.HEADER.HOLD.UNLOCK
2986: 14e0:       IF RET.CODE% <> 0 THEN BEGIN                                     ! FSP
2987: 14e5:          GOSUB FILE.WRITE.ERROR                                        ! FSP
2988: 14ef:       ENDIF                                                            ! FSP
2989: 14ef: 
2990: 14ef: 
2991: 14ef:       RETURN
2992: 14f7: 
2993: 14f7: 
2994: 14f7: \*******************************************************************************
2995: 14f7: \***
2996: 14f7: \***  UPDATE.TIF:
2997: 14f7: \***
2998: 14f7: \***     set up front part of TIF record from new IRF data
2999: 14f7: \***             (all formats use this data)
3000: 14f7: \***
3001: 14f7: \***     IF tif format is 1 THEN
3002: 14f7: \***        set up remainder of TIF record from new IRF data
3003: 14f7: \***        set FILE.NO% to tif session no
3004: 14f7: \***        CALL WRITE.TIF.FULL.PLUS.USER.DATA
3005: 14f7: \***     ELSE
3006: 14f7: \***        IF tif format is 2 THEN
3007: 14f7: \***           set up remainder of TIF record from new IRF data
3008: 14f7: \***           set FILE.NO% to tif session no
3009: 14f7: \***           CALL WRITE.TIF.FULL.NO.USER.DATA
3010: 14f7: \***        ELSE
3011: 14f7: \***           IF tif format is 3 THEN
3012: 14f7: \***              set up remainder of TIF record from new IRF data
3013: 14f7: \***              set FILE.NO% to tif session no
3014: 14f7: \***              CALL WRITE.TIF.SHORT.PLUS.USER.DATA
3015: 14f7: \***           ELSE
3016: 14f7: \***              IF tif format is 4 THEN
3017: 14f7: \***                 set up remainder of TIF record from new IRF data
3018: 14f7: \***                 set FILE.NO% to tif session no
3019: 14f7: \***                 CALL WRITE.TIF.SHORT.NO.USER.DATA
3020: 14f7: \***              ELSE
3021: 14f7: \***                 IF tif format is 5 THEN
3022: 14f7: \***                    set up remainder of TIF record from new IRF data
3023: 14f7: \***                    set FILE.NO% to tif session no
3024: 14f7: \***                    CALL WRITE.TIF.JUST.USER.DATA
3025: 14f7: \***                 ELSE
3026: 14f7: \***                    IF tif format is 6 THEN
3027: 14f7: \***                       set up remainder of TIF record from new IRF data
3028: 14f7: \***                       set FILE.NO% to tif session no
3029: 14f7: \***                       CALL WRITE.TIF.NO.DESC.OR.DATA
3030: 14f7: \***                    endif
3031: 14f7: \***                 endif
3032: 14f7: \***              endif
3033: 14f7: \***           endif
3034: 14f7: \***        endif
3035: 14f7: \***     endif
3036: 14f7: \***
3037: 14f7: \***     RETURN
3038: 14f7: \***
3039: 14f7: \***
3040: 14f7: \-------------------------------------------------------------------------------
3041: 14f7: 
3042: 14f7: UPDATE.TIF:
3043: 14f7: 
3044: 14f7: !   Lines deleted - TIF variables now set by SPLIT.TIF.IRF.DATA$          ! 1.8 RC
3045: 14f7: 
3046: 14f7:     TIF.IRF.DATA$ EQ NEW.IRF.DATA$ ! IRF record string passed to function ! 1.8 RC
3047: 1508: 
3048: 1508:     CALL SPLIT.TIF.IRF.DATA$ ! Sets TIF variables from IRF record string  ! 1.8 RC
3049: 150d: 
3050: 150d: !   Removed redundant code processing unused TIF and TMCF file formats    ! 1.8 RC
3051: 150d: 
3052: 150d:     FILE.NO% = TIF.SESS.NUM%                                      ! DW
3053: 1517: 
3054: 1517:     RET.CODE% = WRITE.TIF.BOOTS.DATA                              ! DW
3055: 151f:     IF RET.CODE% <>  0 THEN BEGIN                                 ! DW
3056: 1524:         GOSUB FILE.WRITE.ERROR                                     ! DW
3057: 152e:     ENDIF                                                         ! DW
3058: 152e: 
3059: 152e: RETURN
3060: 1536: 
3061: 1536: 
3062: 1536: \*******************************************************************************
3063: 1536: \***
3064: 1536: \***  DELETE.TIF:
3065: 1536: \***
3066: 1536: \***     update the TMCF header fields
3067: 1536: \***     set FILE.NO% to tmcf session no
3068: 1536: \***     CALL WRITE.TMCF.WITH.UNLOCK
3069: 1536: \***
3070: 1536: \***     delete the IRF record
3071: 1536: \***     set FILE.NO% to irf session no
3072: 1536: \***
3073: 1536: \***     delete the TIF record
3074: 1536: \***     set FILE.NO% to tif session no
3075: 1536: \***
3076: 1536: \***     RETURN
3077: 1536: \***
3078: 1536: \***
3079: 1536: \-------------------------------------------------------------------------------
3080: 1536: 
3081: 1536:    DELETE.TIF:
3082: 1536: 
3083: 1536:       TMCF.ACTION% = 5
3084: 153e: ! DW  TMCF.MAINTLVL% = TMCF.MAINTLVL% + 1                              !  NFH
3085: 153e:       TMCF.RCDKEY$ = MID$(NEW.IRF.DATA$,1,11)
3086: 1558:       TMCF.NUMRECS% = TMCF.NUMRECS% - 1
3087: 1569:       FILE.NO% = TMCF.SESS.NUM%                                        ! BBCW
3088: 1573: 
3089: 1573:       GOSUB TMCF.UPDATE                                                ! DW
3090: 157d: 
3091: 157d:       TMCF.REC.NO% = 1                                                 ! DW
3092: 1586:       RET.CODE% = WRITE.TMCF.HEADER.UNLOCK                             ! FSP
3093: 158e:       IF RET.CODE% <>  0 THEN BEGIN                                    ! FSP
3094: 1593:          GOSUB FILE.WRITE.ERROR                                        ! FSP
3095: 159d:       ENDIF                                                            ! FSP
3096: 159d: 
3097: 159d:       GOSUB DELETE.IRF.AND.IRFDEX.RECS                                     ! 1.9 RC
3098: 15a7: 
3099: 15a7:       GOSUB PROCESS.PHF                                               ! 1.11 NWB
3100: 15b1: 
3101: 15b1:       FILE.NO% = IRF.SESS.NUM%                                         ! BBCW
3102: 15bb: 
3103: 15bb: !     Lines deleted                                                       ! 1.8 RC
3104: 15bb: 
3105: 15bb:       TIF.BAR.CODE$ = RIGHT$(TIF.BAR.CODE$,6)                       ! DW
3106: 15d8:       DELREC TIF.SESS.NUM%; TIF.BAR.CODE$
3107: 15ef:       FILE.NO% = TIF.SESS.NUM%                                         ! BBCW
3108: 15f9: 
3109: 15f9:       RETURN
3110: 1601: 
3111: 1601: 
3112: 1601: \*******************************************************************************
3113: 1601: \***
3114: 1601: \***  ONLY.PROCESS.IRF:
3115: 1601: \***
3116: 1601: \***     IF acd flag is add THEN
3117: 1601: \***        GOSUB ONLY.ADD.IRF
3118: 1601: \***     ELSE
3119: 1601: \***        IF acd flag is change THEN
3120: 1601: \***           GOSUB ONLY.CHANGE.IRF
3121: 1601: \***        ELSE
3122: 1601: \***           GOSUB ONLY.DELETE.IRF
3123: 1601: \***        endif
3124: 1601: \***     endif
3125: 1601: \***
3126: 1601: \***
3127: 1601: \***     RETURN
3128: 1601: \***
3129: 1601: \***
3130: 1601: \-------------------------------------------------------------------------------
3131: 1601: 
3132: 1601:    ONLY.PROCESS.IRF:
3133: 1601: 
3134: 1601:       IF ACD.FLAG$ = "ADD" THEN                                        \
3135: 1612:          GOSUB ONLY.ADD.IRF                                            \
3136: 161e:       ELSE                                                             \
3137: 161e:          IF ACD.FLAG$ = "CHANGE" THEN                                  \
3138: 162f:             GOSUB ONLY.CHANGE.IRF                                      \
3139: 163b:          ELSE                                                          \
3140: 163b:             GOSUB ONLY.DELETE.IRF
3141: 1645: 
3142: 1645:       GOSUB PROCESS.PHF                                               ! 1.11 NWB
3143: 164f: 
3144: 164f:       RETURN
3145: 1657: 
3146: 1657: 
3147: 1657: \*******************************************************************************
3148: 1657: \***
3149: 1657: \***  ONLY.ADD.IRF:
3150: 1657: \***
3151: 1657: \***     format new irf data into individual fields
3152: 1657: \***     set FILE.NO% to irf session no
3153: 1657: \***
3154: 1657: \***     CALL WRITE.IRF
3155: 1657: \***
3156: 1657: \***     RETURN
3157: 1657: \***
3158: 1657: \***
3159: 1657: \-------------------------------------------------------------------------------
3160: 1657: 
3161: 1657:    ONLY.ADD.IRF:
3162: 1657: 
3163: 1657: !   Lines deleted - IRF variables now set by SPLIT.NEW.IRF.DATA$          ! 1.8 RC
3164: 1657: 
3165: 1657:     FILE.NO% = IRF.SESS.NUM%                                         ! BBCW
3166: 1661:     RET.CODE% = WRITE.IRF                                            ! FSP
3167: 1669:     IF RET.CODE% <>  0 THEN BEGIN                                    ! FSP
3168: 166e:        GOSUB FILE.WRITE.ERROR                                        ! FSP
3169: 1678:     ENDIF                                                            ! FSP
3170: 1678: 
3171: 1678: 
3172: 1678:     RETURN
3173: 1680: 
3174: 1680: 
3175: 1680: \*******************************************************************************
3176: 1680: \***
3177: 1680: \***  ONLY.CHANGE.IRF:
3178: 1680: \***
3179: 1680: \***     format new irf data into individual fields
3180: 1680: \***     set FILE.NO% to irf session no
3181: 1680: \***
3182: 1680: \***     IF irf locked flag = "Y" THEN
3183: 1680: \***        CALL WRITE.IRF.HOLD.UNLOCK
3184: 1680: \***     ELSE
3185: 1680: \***        CALL WRITE.IRF.HOLD
3186: 1680: \***     ENDIF
3187: 1680: \***
3188: 1680: \***     RETURN
3189: 1680: \***
3190: 1680: \***
3191: 1680: \-------------------------------------------------------------------------------
3192: 1680: 
3193: 1680:    ONLY.CHANGE.IRF:
3194: 1680: 
3195: 1680: !     Lines deleted - IRF variables now set by SPLIT.NEW.IRF.DATA$     ! 1.8 RC
3196: 1680: 
3197: 1680:       FILE.NO% = IRF.SESS.NUM%                                         ! BBCW
3198: 168a: 
3199: 168a:       IF IRF.LOCKED.FLAG$ = "Y" THEN BEGIN                             ! BBCW
3200: 169b: 
3201: 169b:          RET.CODE% = WRITE.IRF.UNLOCK                                  ! BBCW
3202: 16a3:          IF RET.CODE% <>  0 THEN BEGIN                                 ! FSP
3203: 16a8:             GOSUB FILE.WRITE.ERROR                                     ! FSP
3204: 16b2:          ENDIF                                                         ! FSP
3205: 16b4:                                                                        ! FSP
3206: 16b4:       ENDIF ELSE BEGIN                                                             \ BBCW
3207: 16b4:                                                                        ! FSP
3208: 16b4:          RET.CODE% = WRITE.IRF                                         ! BBCW
3209: 16bc:          IF RET.CODE% <>  0 THEN BEGIN                                 ! FSP
3210: 16c1:             GOSUB FILE.WRITE.ERROR                                     ! FSP
3211: 16cb:          ENDIF                                                         ! FSP
3212: 16cb:                                                                        ! FSP
3213: 16cb:       ENDIF                                                            ! FSP
3214: 16cb: 
3215: 16cb:       RETURN
3216: 16d3: 
3217: 16d3: 
3218: 16d3: \*******************************************************************************
3219: 16d3: \***
3220: 16d3: \***  ONLY.DELETE.IRF:
3221: 16d3: \***
3222: 16d3: \***
3223: 16d3: \***     DELREC the IRF record
3224: 16d3: \***     If the IRF.BARCODE$ is the Boots code IRF.BARCODE$ ...
3225: 16d3: \***         Delete any corresponding IRFDEX record that may exist.
3226: 16d3: \***
3227: 16d3: \***     RETURN
3228: 16d3: \***
3229: 16d3: \***
3230: 16d3: \-------------------------------------------------------------------------------
3231: 16d3: 
3232: 16d3:    ONLY.DELETE.IRF:
3233: 16d3:    DELETE.IRF.AND.IRFDEX.RECS:                                             ! 1.9 RC
3234: 16d3: 
3235: 16d3:       IRF.BAR.CODE$ = MID$(NEW.IRF.DATA$,1,11)
3236: 16ed: 
3237: 16ed:       DELREC IRF.SESS.NUM%; IRF.BAR.CODE$
3238: 1704: 
3239: 1704:       IF IRF.BAR.CODE$ EQ \                                                ! 1.9 RC
3240: 1740:            PACK$("0000000000000000") + IRF.BOOTS.CODE$ THEN \              ! 1.9 RC
3241: 1740:           BEGIN                                                            ! 1.9 RC
3242: 1740:           IF END # F19.IRFDEX.SESS.NUM% THEN IRFDEX.REC.DELETED            ! 1.9 RC
3243: 1754:           DELREC F19.IRFDEX.SESS.NUM%; IRF.BOOTS.CODE$                     ! 1.9 RC
3244: 176b: IRFDEX.REC.DELETED:                                                        ! 1.9 RC
3245: 176b:           ENDIF                                                            ! 1.9 RC
3246: 176b: 
3247: 176b:       RETURN
3248: 1773: 
3249: 1773: 
3250: 1773: \*******************************************************************************
3251: 1773: \***
3252: 1773: \*** Process Product History File
3253: 1773: \***
3254: 1773: \*******************************************************************************
3255: 1773: 
3256: 1773: PROCESS.PHF:                                                          ! 1.11 NWB
3257: 1773: 
3258: 1773:       IF PHF.OPEN.FLAG$ <> "Y" THEN RETURN                            ! 1.11 NWB
3259: 178e: 
3260: 178e:       ! Reject Group Codes                                            ! 1.16 NWB
3261: 178e:       IF LEFT$(IRF.BAR.CODE$, 5) <> PACK$("0000000000") THEN BEGIN    ! 1.16 NWB
3262: 17c0:          RETURN                                                       ! 1.16 NWB
3263: 17c8:       ENDIF                                                           ! 1.16 NWB
3264: 17c8: 
3265: 17c8:       ! IRF.BAR.CODE$ = 11 bytes UPD to PHF.BAR.CODE$ = 6 bytes UPD   ! 1.11 NWB
3266: 17c8:       PHF.BAR.CODE$ =                                                 \
3267: 1810:             PACK$(RIGHT$("000000000000"+UNPACK$(IRF.BAR.CODE$), 12))  ! 1.12 PAB
3268: 1810: 
3269: 1810:       IF VAL(UNPACK$(PHF.BAR.CODE$)) <> 0  AND                        \ 1.12 PAB
3270: 1883:          LEN (PHF.BAR.CODE$) = 6 THEN BEGIN                           ! 1.12 PAB
3271: 1883: 
3272: 1883:          IF ACD.FLAG$ = "DELETE" THEN BEGIN                           ! 1.11 NWB
3273: 1894:             IF END #PHF.SESS.NUM% THEN PHF.REC.DELETED                ! 1.11 NWB
3274: 18a8:             DELREC PHF.SESS.NUM%; PHF.BAR.CODE$                       ! 1.11 NWB
3275: 18bf: PHF.REC.DELETED:                                                      ! 1.11 NWB
3276: 18bf:             RETURN                                                    ! 1.11 NWB
3277: 18c7:          ENDIF                                                        ! 1.11 NWB
3278: 18c7: 
3279: 18c7: ! Following code extracted into new external function PSBF46
3280: 18c7: 
3281: 18c7:          NEW.PRICE% = VAL(UNPACK$(IRF.SALEPRIC$))                     ! 1.15 NWB
3282: 18ec: 
3283: 18ec:          IF GET.LABEL.TYPE(PHF.BAR.CODE$,                             \ 1.15 NWB
3284: 1917:                            OLD.PRICE%,                                \ 1.15 NWB
3285: 1917:                            NEW.PRICE%,                                \ 1.15 NWB
3286: 1917:                            "Y" ) <> 0 THEN RETURN                     ! 1.15 NWB
3287: 191f: 
3288: 191f:       ENDIF                                                           ! 1.15 NWB
3289: 191f: 
3290: 191f: RETURN                                                                ! 1.15 NWB
3291: 1927: 
3292: 1927: \        NEW.LABEL$ = ""                                              ! 1.11 NWB
3293: 1927: \        NEW.PRICE% = VAL(UNPACK$(IRF.SALEPRIC$))                     ! 1.11 NWB
3294: 1927: 
3295: 1927: \        PHF.DATA% = -1                                               ! 1.11 NWB
3296: 1927: 
3297: 1927: \        IF LEN(PHF.BAR.CODE$) = 6 THEN BEGIN                         ! 1.12 PAB
3298: 1927: \           RC% = READ.PHF                                            ! 1.11 NW
3299: 1927: \        ENDIF ELSE BEGIN
3300: 1927: \           RC% = 1                                                   ! 1.12 PAB
3301: 1927: \        ENDIF
3302: 1927: 
3303: 1927: \        IF RC% <> 0 THEN BEGIN                                       ! 1.11 NWB
3304: 1927: 
3305: 1927: \           PHF.DATA% = 0                                             ! 1.11 NWB
3306: 1927: 
3307: 1927: \           PHF.CURR.PRICE%      = 0                                  ! 1.11 NWB
3308: 1927: \           PHF.PEND.PRICE%      = 0                                  ! 1.11 NWB
3309: 1927: \           PHF.HIST1.PRICE%     = 0                                  ! 1.11 NWB
3310: 1927: \           PHF.HIST2.PRICE%     = 0                                  ! 1.11 NWB
3311: 1927: 
3312: 1927: \           PHF.CURR.TYPE$       = " "                                ! 1.11 NWB
3313: 1927: \           PHF.PEND.TYPE$       = " "                                ! 1.11 NWB
3314: 1927: \           PHF.HIST1.TYPE$      = " "                                ! 1.11 NWB
3315: 1927: \           PHF.HIST2.TYPE$      = " "                                ! 1.11 NWB
3316: 1927: 
3317: 1927: \           PHF.CURR.DATE$       = PACK$("000000")                    ! 1.11 NWB
3318: 1927: \           PHF.PEND.DATE$       = PHF.CURR.DATE$                     ! 1.11 NWB
3319: 1927: \           PHF.HIST1.DATE$      = PHF.CURR.DATE$                     ! 1.11 NWB
3320: 1927: \           PHF.HIST2.DATE$      = PHF.CURR.DATE$                     ! 1.11 NWB
3321: 1927: \           PHF.LAST.INC.DATE$   = PHF.CURR.DATE$                     ! 1.11 NWB
3322: 1927: 
3323: 1927: \           PHF.FILLER$          = "  "                               ! 1.11 NWB
3324: 1927: 
3325: 1927: \        ENDIF                                                        ! 1.11 NWB
3326: 1927: 
3327: 1927: \        ! Don't process if price hasn't changed                      ! 1.11 NWB
3328: 1927: \        IF NEW.PRICE% = PHF.CURR.PRICE% THEN BEGIN                   ! 1.11 NWB
3329: 1927: \           RETURN                                                    ! 1.11 NWB
3330: 1927: \        ENDIF                                                        ! 1.11 NWB
3331: 1927: 
3332: 1927: \        CALL CALC.BOOTS.CODE.CHECK.DIGIT(UNPACK$(IRF.BOOTS.CODE$))   ! 1.11 NWB
3333: 1927: \        IDF.BOOTS.CODE$ = PACK$(RIGHT$("00000000"                    \ 1.11 NWB
3334: 1927: \                                     + UNPACK$(IRF.BOOTS.CODE$)      \ 1.11 NWB
3335: 1927: \                                     + F18.CHECK.DIGIT$, 8))         ! 1.11 NWB
3336: 1927: 
3337: 1927: \        SAV.IDF.SESS.NUM% = IDF.SESS.NUM%                            ! 1.11 NWB
3338: 1927: \        IDF.SESS.NUM% = F19.IDF.SESS.NUM%                            ! 1.11 NWB
3339: 1927: \        RC% = READ.IDF                                               ! 1.11 NWB
3340: 1927: \        IDF.SESS.NUM% = SAV.IDF.SESS.NUM%                            ! 1.11 NWB
3341: 1927: \        SAV.IDF.SESS.NUM% = 0                                        ! 1.11 NWB
3342: 1927: 
3343: 1927: \        ! Check item is on live planner                              ! 1.11 NWB
3344: 1927: \        ON.LP% = 0                                                   ! 1.11 NWB
3345: 1927: \        IF SRITL.OPEN.FLAG$ = "Y" THEN BEGIN                         ! 1.11 NWB
3346: 1927: \           SRITL.ITEM.CODE$ = IRF.BOOTS.CODE$                        ! 1.11 NWB
3347: 1927: \           SRITL.RECORD.CHAIN% = 0                                   ! 1.11 NWB
3348: 1927: \           SAV.SRITL.SESS.NUM% = SRITL.SESS.NUM%                     ! 1.11 NWB
3349: 1927: \           SRITL.SESS.NUM% = F19.SRITL.SESS.NUM%                     ! 1.11 NWB
3350: 1927: \           RC% = READ.SRITL                                          ! 1.11 NWB
3351: 1927: \           SRITL.SESS.NUM% = SAV.SRITL.SESS.NUM%                     ! 1.11 NWB
3352: 1927: \           SAV.SRITL.SESS.NUM% = 0                                   ! 1.11 NWB
3353: 1927: \           IF RC% = 0 THEN BEGIN                                     ! 1.11 NWB
3354: 1927: \              ON.LP% = -1                                            ! 1.11 NWB
3355: 1927: \           ENDIF                                                     ! 1.11 NWB
3356: 1927: \        ENDIF                                                        ! 1.11 NWB
3357: 1927: 
3358: 1927: \        !  If price increase set the last increase date              ! 1.11a NWB
3359: 1927: \        IF (NEW.PRICE%  > OLD.PRICE%                                 \ 1.11a NWB
3360: 1927: \            AND OLD.PRICE% > 0      )                                \ 1.11a NWB
3361: 1927: \        OR (PHF.DATA% = -1                                           \ 1.11a NWB
3362: 1927: \            AND NEW.PRICE%  > PHF.CURR.PRICE%) THEN BEGIN            ! 1.11a NWB
3363: 1927: \           PHF.LAST.INC.DATE$ = PACK$(DATE$)                         ! 1.11 NWB
3364: 1927: \        ENDIF                                                        ! 1.11 NWB
3365: 1927: 
3366: 1927: \        IF (IDF.BIT.FLAGS.1% AND 20H) = 0 THEN BEGIN                 ! 1.11 NWB
3367: 1927: \           ! Not markdown item                                       ! 1.11 NWB
3368: 1927: \           NEW.LABEL$ = "0"                             ! Standard   ! 1.11 NWB
3369: 1927: \        ENDIF ELSE IF NEW.PRICE% <> PHF.CURR.PRICE% THEN BEGIN       ! 1.11 NWB
3370: 1927: 
3371: 1927: \           ! Get number of price changes in last 28 days             ! 1.11 NWB
3372: 1927: \           !   (incl this one)                                       ! 1.11 NWB
3373: 1927: \           F02.DATE$ = DATE$                                         ! 1.11 NWB
3374: 1927: \           RC% = UPDATE.DATE(-28)                                    ! 1.11 NWB
3375: 1927: \           pc% = 0                                                   ! 1.11 NWB
3376: 1927: \           F02.DATE$ = PACK$(F02.DATE$)                              ! 1.11 NWB
3377: 1927: \           IF F02.DATE$ < PHF.HIST2.DATE$ THEN BEGIN                 ! 1.11 NWB
3378: 1927: \              pc% = 3                                                ! 1.11 NWB
3379: 1927: \           ENDIF ELSE IF F02.DATE$ < PHF.HIST1.DATE$ THEN BEGIN      ! 1.11 NWB
3380: 1927: \              pc% = 2                                                ! 1.11 NWB
3381: 1927: \           ENDIF ELSE IF F02.DATE$ < PHF.CURR.DATE$  THEN BEGIN      ! 1.11 NWB
3382: 1927: \              pc% = 1                                                ! 1.11 NWB
3383: 1927: \           ENDIF                                                     ! 1.11 NWB
3384: 1927: 
3385: 1927: \           IF PHF.DATA% = 0                                          \ 1.11 NWB
3386: 1927: \           OR ON.LP% = 0                                             \ 1.11 NWB
3387: 1927: \           OR F02.DATE$ < PHF.LAST.INC.DATE$ THEN BEGIN              ! 1.11 NWB
3388: 1927: \              ! If no price history available                        ! 1.11 NWB
3389: 1927: \              ! OR Not on Live planner                               ! 1.11 NWB
3390: 1927: \              ! OR a price increase within last 28 days              ! 1.11 NWB
3391: 1927: \              NEW.LABEL$ = "3"                          ! Clearance  ! 1.11 NWB
3392: 1927: \           ENDIF ELSE IF pc% = 1 THEN BEGIN                          ! 1.11 NWB
3393: 1927: \              ! This is only change in last 28 days                  ! 1.11 NWB
3394: 1927: \              NEW.LABEL$ = "1"                          ! Was/Now    ! 1.11 NWB
3395: 1927: \           ENDIF ELSE BEGIN                                          ! 1.11 NWB
3396: 1927: \              ! More than 1 change in last 28 days                   ! 1.11 NWB
3397: 1927: \              NEW.LABEL$ = "2"                          ! Was/Was/Now! 1.11 NWB
3398: 1927: \           ENDIF                                                     ! 1.11 NWB
3399: 1927: 
3400: 1927: \           !If already set to clearance, force to stay as clearance. ! 1.13 BMG
3401: 1927: \           IF PHF.CURR.LABL$ = "3" THEN NEW.LABEL$ = "3"             ! 1.13 BMG
3402: 1927: \           !Force markdown items to be flagged as new type "C"       ! 1.13 BMG
3403: 1927: \           NEW.TYPE$ = "C"                                           ! 1.13 BMG
3404: 1927: \           !If a WEEE item, force label to type 0                    ! 1.14 BMG
3405: 1927: \           IF (IRF.INDICAT8% AND 10000000b) THEN NEW.LABEL$ = "0"    ! 1.14 BMG
3406: 1927: 
3407: 1927: \        ENDIF                                                        ! 1.11 NWB
3408: 1927: 
3409: 1927: \        IF NEW.LABEL$ <> "" THEN BEGIN                               ! 1.11 NWB
3410: 1927: 
3411: 1927: \           ! Ripple through the price history                        ! 1.11 NWB
3412: 1927: \           PHF.HIST2.PRICE% = PHF.HIST1.PRICE%                       ! 1.11 NWB
3413: 1927: \           PHF.HIST1.PRICE% = PHF.CURR.PRICE%                        ! 1.11 NWB
3414: 1927: \           PHF.CURR.PRICE%  = NEW.PRICE%                             ! 1.11 NWB
3415: 1927: 
3416: 1927: \           PHF.HIST2.DATE$  = PHF.HIST1.DATE$                        ! 1.11 NWB
3417: 1927: \           PHF.HIST1.DATE$  = PHF.CURR.DATE$                         ! 1.11 NWB
3418: 1927: \           PHF.CURR.DATE$   = PACK$(DATE$)                           ! 1.11 NWB
3419: 1927: 
3420: 1927: \           PHF.HIST2.TYPE$  = PHF.HIST1.TYPE$                        ! 1.11 NWB
3421: 1927: \           PHF.HIST1.TYPE$  = PHF.CURR.TYPE$                         ! 1.11 NWB
3422: 1927: \           PHF.CURR.TYPE$   = NEW.TYPE$                              ! 1.11 NWB
3423: 1927: 
3424: 1927: \           PHF.CURR.LABL$   = NEW.LABEL$                             ! 1.11 NWB
3425: 1927: 
3426: 1927: \           PHF.FILLER$      = "  "                                   ! 1.11 NWB
3427: 1927: 
3428: 1927: \           RC% = WRITE.PHF                                           ! 1.11 NWB
3429: 1927: 
3430: 1927: \        ENDIF                                                        ! 1.11 NWB
3431: 1927: 
3432: 1927: \     ENDIF                                                           ! 1.11 NWB
3433: 1927: 
3434: 1927: \RETURN                                                               ! 1.11 NWB
3435: 1927: 
3436: 1927: \*******************************************************************************
3437: 1927: \***
3438: 1927: \***  TEST.TIF.RETURN.CODE
3439: 1927: \***
3440: 1927: \***  Tests return code from reading TIF and send control to para
3441: 1927: \***  which updates the IRF only, then exits function
3442: 1927: \***
3443: 1927: \-------------------------------------------------------------------------------
3444: 1927: 
3445: 1927:       TEST.TIF.RETURN.CODE:                                              ! FSP
3446: 1927:                                                                          ! FSP
3447: 1927:          IF RET.CODE% <> 0 THEN BEGIN                                    ! FSP
3448: 192e:             GOSUB TIF.READ.ERROR                                         ! FSP
3449: 1938:          ENDIF                                                           ! FSP
3450: 1938:                                                                          ! FSP
3451: 1938:       RETURN                                                             ! FSP
3452: 1940: 
3453: 1940: 
3454: 1940: \*******************************************************************************
3455: 1940: \***
3456: 1940: \***   FILE.READ.ERROR:
3457: 1940: \***
3458: 1940: \***         set FUNCTION.FLAG$ to "R"
3459: 1940: \***             PASSED.INTEGER% to FILE.NO% and
3460: 1940: \***             PASSED.STRING$ to ""
3461: 1940: \***         use SESS.NUM.UTILITY function to obtain reporting no for FILE.NO%
3462: 1940: \***         IF F20.RETURN.CODE% <> 0 THEN
3463: 1940: \***            GOTO PROGRAM.EXIT
3464: 1940: \***         ENDIF
3465: 1940: \***
3466: 1940: \***         set ERRFILE$ to CHR$(F20.INTEGER.FILE.NO%)
3467: 1940: \***         set VAR.STRING.2$ to F20.STRING.FILE.NO$
3468: 1940: \***
3469: 1940: \***         CALL APPLICATION.LOG to log error number 503
3470: 1940: \***         GOTO FUNCTION.EXIT
3471: 1940: \***
3472: 1940: \***
3473: 1940: \***      EXIT the function
3474: 1940: \***
3475: 1940: \***
3476: 1940: \***
3477: 1940: \-------------------------------------------------------------------------------
3478: 1940: 
3479: 1940:    FILE.READ.ERROR:
3480: 1940: 
3481: 1940:       FUNCTION.FLAG$  = "R"                                            ! BBCW
3482: 194d:       PASSED.INTEGER% = FILE.NO%                                       ! BBCW
3483: 1953:       PASSED.STRING$  = ""                                             ! BBCW
3484: 1960:       RET.CODE% = SESS.NUM.UTILITY (FUNCTION.FLAG$,                    \ DAW
3485: 1980:                                     PASSED.INTEGER%,                   \ BBCW
3486: 1980:                                     PASSED.STRING$)                    ! BBCW
3487: 1980: 
3488: 1980:       IF RET.CODE% <> 0 THEN GOTO PROGRAM.EXIT                         ! DAW
3489: 1988: 
3490: 1988:       EVENT.NO% = 6
3491: 198e:       INTEGER1% = FILE.NO%                                             ! BBCW
3492: 1994:       ERRFILE$  = CHR$(F20.INTEGER.FILE.NO%)                           ! BBCW
3493: 19a9: 
3494: 19a9:       MESSAGE.NUMBER% = 503
3495: 19af:       VAR.STRING.1$ = "R" + ERRFILE$
3496: 19c7:       VAR.STRING.2$ = F20.STRING.FILE.NO$                              ! BBCW
3497: 19db:       RET.CODE% = APPLICATION.LOG (MESSAGE.NUMBER%,                    \ DAW
3498: 19ff:                                    VAR.STRING.1$,                      \
3499: 19ff:                                    VAR.STRING.2$,                      \
3500: 19ff:                                    EVENT.NO%)                         :\
3501: 19ff: 
3502: 19ff:      !UPDT.IRF.UPDT = 1                                                ! DAW ! ! LCSk
3503: 19ff:       UPDT.IRF.TIF.UPDT = 1                                            ! ! LCSk
3504: 1a04:       GOTO FUNCTION.EXIT
3505: 1a07: 
3506: 1a07: 
3507: 1a07: \*******************************************************************************
3508: 1a07: \***
3509: 1a07: \***   FILE.WRITE.ERROR:
3510: 1a07: \***
3511: 1a07: \***         set FUNCTION.FLAG$ to "R"
3512: 1a07: \***             PASSED.INTEGER% to FILE.NO% and
3513: 1a07: \***             PASSED.STRING$ to ""
3514: 1a07: \***         use SESS.NUM.UTILITY function to obtain reporting no for FILE.NO%
3515: 1a07: \***         IF F20.RETURN.CODE% <> 0 THEN
3516: 1a07: \***            GOTO PROGRAM.EXIT
3517: 1a07: \***         ENDIF
3518: 1a07: \***
3519: 1a07: \***         set ERRFILE$ to CHR$(F20.INTEGER.FILE.NO%)
3520: 1a07: \***         set VAR.STRING.2$ to F20.STRING.FILE.NO$
3521: 1a07: \***
3522: 1a07: \***         CALL APPLICATION.LOG to log error number 504
3523: 1a07: \***         GOTO FUNCTION.EXIT
3524: 1a07: \***
3525: 1a07: \***
3526: 1a07: \***      EXIT the function
3527: 1a07: \***
3528: 1a07: \***
3529: 1a07: \***
3530: 1a07: \-------------------------------------------------------------------------------
3531: 1a07: 
3532: 1a07:    FILE.WRITE.ERROR:
3533: 1a07: 
3534: 1a07:       FUNCTION.FLAG$  = "R"                                            ! BBCW
3535: 1a14:       PASSED.INTEGER% = FILE.NO%                                       ! BBCW
3536: 1a1a:       PASSED.STRING$  = ""                                             ! BBCW
3537: 1a27:       RET.CODE% = SESS.NUM.UTILITY (FUNCTION.FLAG$,                    \ DAW
3538: 1a47:                                     PASSED.INTEGER%,                   \ BBCW
3539: 1a47:                                     PASSED.STRING$)                    ! BBCW
3540: 1a47: 
3541: 1a47:       IF RET.CODE% <> 0 THEN GOTO PROGRAM.EXIT                         ! DAW
3542: 1a4f: 
3543: 1a4f:       EVENT.NO% = 6
3544: 1a55:       INTEGER1% = FILE.NO%                                             ! BBCW
3545: 1a5b:       ERRFILE$ = CHR$(F20.INTEGER.FILE.NO%)                            ! BBCW
3546: 1a70: 
3547: 1a70: 
3548: 1a70:       MESSAGE.NUMBER% = 504
3549: 1a76:       VAR.STRING.1$   = "W" + ERRFILE$
3550: 1a8e:       VAR.STRING.2$   = F20.STRING.FILE.NO$                            ! BBCW
3551: 1aa2:       RET.CODE% = APPLICATION.LOG (MESSAGE.NUMBER%,                    \ DAW
3552: 1ac6:                                    VAR.STRING.1$,                      \
3553: 1ac6:                                    VAR.STRING.2$,                      \
3554: 1ac6:                                    EVENT.NO%)                         :\
3555: 1ac6: 
3556: 1ac6:      !UPDT.IRF.UPDT = 1                                                ! DAW ! ! LCSk
3557: 1ac6:       UPDT.IRF.TIF.UPDT = 1                                            ! ! LCSk
3558: 1acb:       GOTO FUNCTION.EXIT
3559: 1ace: 
3560: 1ace: 
3561: 1ace: \*******************************************************************************
3562: 1ace: \***
3563: 1ace: \***  TIF.READ.ERROR:
3564: 1ace: \***
3565: 1ace: \***    GOSUB ONLY.PROCESS.IRF
3566: 1ace: \***
3567: 1ace: \***    GOTO FUNCTION.EXIT
3568: 1ace: \***
3569: 1ace: \***
3570: 1ace: \-------------------------------------------------------------------------------
3571: 1ace: 
3572: 1ace:    TIF.READ.ERROR:
3573: 1ace: 
3574: 1ace: !  2 lines removed here                                                ! CJAL
3575: 1ace:       GOSUB ONLY.PROCESS.IRF
3576: 1ad8:       GOTO FUNCTION.EXIT
3577: 1adb: 
3578: 1adb: 
3579: 1adb: \*******************************************************************************
3580: 1adb: \***
3581: 1adb: \*** UPDT.UPDT.ERROR.DETECTED:
3582: 1adb: \***
3583: 1adb: \***   set UPDT.IRF.TIF.UPDT  to 1 (was) UPDT.IRF.UPDT                 ! ! LCSk
3584: 1adb: \***
3585: 1adb: \***         set FUNCTION.FLAG$ to "R"
3586: 1adb: \***             PASSED.INTEGER% to ERRF% and
3587: 1adb: \***             PASSED.STRING$ to ""
3588: 1adb: \***         use SESS.NUM.UTILITY function to obtain reporting number for ERRF%
3589: 1adb: \***         IF F20.RETURN.CODE% <> 0 THEN
3590: 1adb: \***            GOTO PROGRAM.EXIT
3591: 1adb: \***         ENDIF
3592: 1adb: \***
3593: 1adb: \***   set ERRFILE$ to CHR$(F20.INTEGER.FILE.NO%)
3594: 1adb: \***
3595: 1adb: \***   IF the returned error code is OM (out of memory) THEN
3596: 1adb: \***      CALL ADXERROR to log the error
3597: 1adb: \***   ELSE
3598: 1adb: \***      IF the returned error code is EF (delete failure) THEN
3599: 1adb: \***         set VAR.STRING.2$ to F20.STRING.FILE.NO$
3600: 1adb: \***         CALL APPLICATION.LOG to log error number 508
3601: 1adb: \***         RESUME processing to the label FUNCTION.EXIT
3602: 1adb: \***      ELSE
3603: 1adb: \***         IF the returned error code is WT (write failure) THEN
3604: 1adb: \***            set VAR.STRING.2$ to F20.STRING.FILE.NO$
3605: 1adb: \***            CALL APPLICATION.LOG to log error number 552
3606: 1adb: \***            RESUME processing to the label FUNCTION.EXIT
3607: 1adb: \***         ELSE
3608: 1adb: \***            IF the returned error code is CM, CT (chain failure) THEN
3609: 1adb: \***               set VAR.STRING.1$ to "BF19 " + (3rd byte of MODULE.NUMBER$) +
3610: 1adb: \***                                           "50  "
3611: 1adb: \***               set VAR.STRING.2$ to "PS" + (3rd byte MODULE.NUMBER$) + "50"
3612: 1adb: \***               CALL APPLICATION.LOG to log message number 553
3613: 1adb: \***            ELSE
3614: 1adb: \***               log an event 101, message 550 via the standard error
3615: 1adb: \***               detected function
3616: 1adb: \***            endif
3617: 1adb: \***         endif
3618: 1adb: \***      endif
3619: 1adb: \***   endif
3620: 1adb: \***
3621: 1adb: \*** PROGRAM.EXIT:
3622: 1adb: \***
3623: 1adb: \***   IF program is not screen program THEN
3624: 1adb: \***      STOP
3625: 1adb: \***   ENDIF
3626: 1adb: \***
3627: 1adb: \***   %INCLUDE PSBCHNE.J86
3628: 1adb: \***
3629: 1adb: \*** END FUNCTION
3630: 1adb: \***
3631: 1adb: \-------------------------------------------------------------------------------
3632: 1adb: 
3633: 1adb:    UPDT.UPDT.ERROR.DETECTED:
3634: 1adb: 
3635: 1adb:      !UPDT.IRF.UPDT = 1                                                ! DAW ! ! LCSk
3636: 1adb:       UPDT.IRF.TIF.UPDT = 1                                            ! ! LCSk
3637: 1ae0:       FUNCTION.FLAG$   = "R"                                           ! BBCW
3638: 1aed:       PASSED.INTEGER%  = ERRF%                                         ! BBCW
3639: 1af5:       PASSED.STRING$   = ""                                            ! BBCW
3640: 1b02:       RET.CODE% = SESS.NUM.UTILITY (FUNCTION.FLAG$,                    \ DAW
3641: 1b22:                                     PASSED.INTEGER%,                   \ BBCW
3642: 1b22:                                     PASSED.STRING$)                    ! BBCW
3643: 1b22: 
3644: 1b22:       ERRFILE$ = CHR$(F20.INTEGER.FILE.NO%)                            ! BBCW
3645: 1b37: 
3646: 1b37: \ 6 lines deleted from here                                            \ BBCW
3647: 1b37: 
3648: 1b37:       IF ERR <> "CM" AND ERR <> "CT" THEN                              \
3649: 1b91:          EVENT.NO% = 1                                                :\
3650: 1b97:          INTEGER4% = ERRN                                             :\
3651: 1ba9:          F17.RETURN.CODE% = CONV.TO.STRING (EVENT.NO%,                 \ DAW
3652: 1bc1:                                             INTEGER4%)                :\
3653: 1bc1:          IF F17.RETURN.CODE% = 0 THEN                                  \
3654: 1bc6:             ERRNUM$      = F17.RETURNED.STRING$                       :\
3655: 1bda:             STRING.ERRL$ = STR$(ERRL)                                 :\
3656: 1bf0:             WHILE LEN(STRING.ERRL$) < 6                               :\
3657: 1bf2:                STRING.ERRL$ = "0" + STRING.ERRL$                      :\
3658: 1c0a:             WEND
3659: 1c1d: 
3660: 1c1d: \ 8 lines deleted from here                                            \ BBCW
3661: 1c1d: 
3662: 1c1d:       IF ERR = "OM" THEN                                      \REM out of memory
3663: 1c3e:          IF F17.RETURN.CODE% = 0 THEN                                  \
3664: 1c48:             TERM%         = 0                                         :\
3665: 1c4e:             MSGGRP%       = ASC("J")                                  :\
3666: 1c5a:             MSGNUM%       = 0                                         :\
3667: 1c60:             SEVERITY%     = 3                                         :\
3668: 1c65:             EVENT.NUM%    = 1                                         :\
3669: 1c6a:             UNIQUE$      =                                             \
3670: 1ca3:                    ERRNUM$ + ERRFILE$ + ERR + PACK$(STRING.ERRL$)     :\
3671: 1ca3:             RET.CODE%    = ADXERROR (TERM%,                            \
3672: 1ccd:                                      MSGGRP%,                          \
3673: 1ccd:                                      MSGNUM%,                          \
3674: 1ccd:                                      SEVERITY%,                        \
3675: 1ccd:                                      EVENT.NUM%,                       \
3676: 1ccd:                                      UNIQUE$)
3677: 1ccd: 
3678: 1ccd: 
3679: 1ccd:       IF ERR = "EF" THEN                                      \REM delete failure
3680: 1cee:          MESSAGE.NUMBER% = 508                                        :\ BBCW
3681: 1cf4:          VAR.STRING.1$ =                                               \
3682: 1d2d:                 ERRNUM$ + ERRFILE$ + ERR + PACK$(STRING.ERRL$)        :\
3683: 1d2d:          VAR.STRING.2$ = F20.STRING.FILE.NO$                          :\ BBCW
3684: 1d41:          RET.CODE% = APPLICATION.LOG (MESSAGE.NUMBER%,                 \ DAW
3685: 1d65:                                       VAR.STRING.1$,                   \
3686: 1d65:                                       VAR.STRING.2$,                   \
3687: 1d65:                                       EVENT.NO%)                      :\
3688: 1d65:          RESUME
3689: 1d74: 
3690: 1d74: 
3691: 1d74:       IF ERR = "WT" THEN                                      \REM write failure
3692: 1d95:          MESSAGE.NUMBER% = 552                                        :\
3693: 1d9b:          VAR.STRING.1$ =                                               \
3694: 1dd4:                 ERRNUM$ + ERRFILE$ + ERR + PACK$(STRING.ERRL$)        :\
3695: 1dd4:          VAR.STRING.2$ = F20.STRING.FILE.NO$                          :\ BBCW
3696: 1de8:          RET.CODE% = APPLICATION.LOG (MESSAGE.NUMBER%,                 \ DAW
3697: 1e0c:                                       VAR.STRING.1$,                   \
3698: 1e0c:                                       VAR.STRING.2$,                   \
3699: 1e0c:                                       EVENT.NO%)                      :\
3700: 1e0c:          RESUME FUNCTION.EXIT
3701: 1e1b: 
3702: 1e1b:       IF ERR = "CM" OR ERR = "CT" THEN                        \REM chain failure
3703: 1e75:          MESSAGE.NUMBER% = 553                                        :\
3704: 1e7b:          VAR.STRING.1$  = "BF19 " + MID$(MODULE.NUMBER$,3,1) + "50  " :\ BBCW
3705: 1eae:          VAR.STRING.2$  = "PS" + MID$(MODULE.NUMBER$,3,1) + "50"      :\ BBCW
3706: 1ee1:          EVENT.NO%      = 18                                          :\
3707: 1ee7:          RET.CODE% = APPLICATION.LOG (MESSAGE.NUMBER%,                 \ DAW
3708: 1f0b:                                       VAR.STRING.1$,                   \
3709: 1f0b:                                       VAR.STRING.2$,                   \
3710: 1f0b:                                       EVENT.NO%)
3711: 1f0b: 
3712: 1f0b:       IF ERR <> "OM" AND                                               \
3713: 1f8f:          ERR <> "CM" AND ERR <> "CT" THEN                              \
3714: 1f8f:      \ lines deleted from here                                     \ DAW
3715: 1f8f:          RET.CODE% = STANDARD.ERROR.DETECTED (ERRN,                    \ DAW
3716: 1fb7:                                               ERRF%,                   \ DAW                                       \
3717: 1fb7:                                               ERRL,                    \ DAW
3718: 1fb7:                                               ERR)                     ! DAW
3719: 1fb7: 
3720: 1fb7: 
3721: 1fb7:    PROGRAM.EXIT:                                                       ! BBCW
3722: 1fb7: 
3723: 1fb7:       IF BATCH.SCREEN.FLAG$ <> "S" THEN                                \
3724: 1fcd:          STOP
3725: 1fd2: 
3726: 1fd2:       %INCLUDE PSBCHNE.J86
3727: 1fd2: \/*********************************************************************/ PSBCHNE
3728: 1fd2: \/*                                                                   */ PSBCHNE
3729: 1fd2: \/*      PSBCHNE.J86  -  Chain to PSB Application Program             */ PSBCHNE
3730: 1fd2: \/*      ------------------------------------------------             */ PSBCHNE
3731: 1fd2: \/*                                                                   */ PSBCHNE
3732: 1fd2: \/*********************************************************************/ PSBCHNE
3733: 1fd2:                                                                        ! PSBCHNE
3734: 1fd2:         CHAIN  PSBCHN.PRG , PSBCHN.OP , PSBCHN.APP , PSBCHN.MENCON ,   \ PSBCHNE
3735: 204a:                             PSBCHN.U1 , PSBCHN.U2  , PSBCHN.U3         ! PSBCHNE
3736: 204a:                                                                        ! PSBCHNE
3737: 204a: 
3738: 204a:    END FUNCTION
3739: 2068: 
3740: 2068: 
3741: 2068: \*******************************************************************************
3742: 2068: \*********                 Function CLOSE.IRF.UPDT                    **********
3743: 2068: \*******************************************************************************
3744: 2068: \***
3745: 2068: \*** FUNCTION CLOSE.IRF.UPDT (new IRF data,
3746: 2068: \***                          add/change/delete flag)  PUBLIC
3747: 2068: \***
3748: 2068: \-------------------------------------------------------------------------------
3749: 2068: 
3750: 2068:    FUNCTION CLOSE.IRF.UPDT (NEW.IRF.DATA$,                             \
3751: 2068:                             ACD.FLAG$)                                 \
3752: 2068:    PUBLIC
3753: 2086: 
3754: 2086:       STRING    ACD.FLAG$,                                             \
3755: 2086: \ 1 line deleted from here                                             \ DAW
3756: 2086:                 ERRFILE$,                                              \
3757: 2086:                 ERRNUM$,                                               \
3758: 2086:                 FILE$,                                                 \
3759: 2086:                 FUNCTION.FLAG$,                                        \ BBCW
3760: 2086:                 IRF.LOCKED.FLAG$,                                      \ BBCW
3761: 2086: \ 1 line deleted from here                                             \ DAW
3762: 2086:                 NEW.IRF.DATA$,                                         \
3763: 2086: \ 1 line deleted from here                                             \ DAW
3764: 2086:                 PASSED.STRING$,                                        \ BBCW
3765: 2086:                 STRING.ERRL$,                                          \
3766: 2086:                 UNIQUE$,                                               \
3767: 2086:                 VAR.STRING.1$,                                         \
3768: 2086:                 VAR.STRING.2$
3769: 2086: 
3770: 2086:       INTEGER*1 EVENT.NUM%,                                            \
3771: 2086:                 MSGGRP%,                                               \
3772: 2086:                 PASSED.INTEGER%,                                       \ BBCW
3773: 2086:                 SEVERITY%
3774: 2086: 
3775: 2086:       INTEGER   CLOSE.IRF.UPDT,                                        \ DAW
3776: 2086:                 EVENT.NO%,                                             \
3777: 2086:                 MESSAGE.NUMBER%,                                       \
3778: 2086:                 MSGNUM%,                                               \
3779: 2086:                 RET.CODE%,                                             \
3780: 2086:                 SESSION.NUMBER%,                                       \
3781: 2086:                 TERM%
3782: 2086: 
3783: 2086:       INTEGER*4 INTEGER4%
3784: 2086: 
3785: 2086: 
3786: 2086:       CALL TIF.SET                                                     ! FSP
3787: 2099:       CALL TMCF.SET                                                    ! FSP
3788: 20ac:       CALL GAOPT.SET                                                   ! FSP
3789: 20bf: 
3790: 20bf: 
3791: 20bf: \*******************************************************************************
3792: 20bf: \***
3793: 20bf: \***   ON ERROR goto UPDT.CLOSE.ERROR.DETECTED  (after logging the error, the
3794: 20bf: \***                                             function is immediately left)
3795: 20bf: \***
3796: 20bf: \***
3797: 20bf: \***   REM set up storage areas for ADXERROR required fields in case of memory
3798: 20bf: \***   overflow
3799: 20bf: \***
3800: 20bf: \***   set chaining module to first module in current application
3801: 20bf: \***
3802: 20bf: \-------------------------------------------------------------------------------
3803: 20bf: 
3804: 20bf:       ON ERROR GOTO UPDT.CLOSE.ERROR.DETECTED
3805: 20cc: 
3806: 20cc:       UNIQUE$ = "          "
3807: 20d9:       ERRNUM$ = "    "
3808: 20e6:       ERRFILE$ = " "
3809: 20f3:       STRING.ERRL$ = "      "
3810: 2100:       CLOSE.IRF.UPDT = 0                                               ! DAW
3811: 2105: 
3812: 2105:       PSBCHN.PRG = "ADX_UPGM:PSB50.286"                                !1.10 SWM
3813: 2114: 
3814: 2114: 
3815: 2114: \*******************************************************************************
3816: 2114: \***
3817: 2114: \***     IF the tif open flag is "Y" THEN
3818: 2114: \***        CLOSE the tif session number
3819: 2114: \***        set FUNCTION.FLAG$ to "C",
3820: 2114: \***            PASSED.INTEGER% to tif session number and
3821: 2114: \***            PASSED.STRING$ to ""
3822: 2114: \***        use SESS.NUM.UTILITY function to deallocate session number
3823: 2114: \***        IF F20.RETURN.CODE% <> 0 THEN
3824: 2114: \***           GOTO PROGRAM EXIT
3825: 2114: \***        ENDIF
3826: 2114: \***     ENDIF
3827: 2114: \***
3828: 2114: \***     IF the tmcf open flag is "Y" THEN
3829: 2114: \***        CLOSE the tmcf session number
3830: 2114: \***        set FUNCTION.FLAG$ to "C",
3831: 2114: \***            PASSED.INTEGER% to tif session number and
3832: 2114: \***            PASSED.STRING$ to ""
3833: 2114: \***        use SESS.NUM.UTILITY function to deallocate session number
3834: 2114: \***        IF F20.RETURN.CODE% <> 0 THEN
3835: 2114: \***           GOTO PROGRAM EXIT
3836: 2114: \***        ENDIF
3837: 2114: \***     ENDIF
3838: 2114: \***
3839: 2114: \***     IF the idf open flag is "Y" THEN                             ! 1.11 NWB
3840: 2114: \***        CLOSE the idf session number                              ! 1.11 NWB
3841: 2114: \***        set FUNCTION.FLAG$ to "C",                                ! 1.11 NWB
3842: 2114: \***            PASSED.INTEGER% to idf session number and             ! 1.11 NWB
3843: 2114: \***            PASSED.STRING$ to ""                                  ! 1.11 NWB
3844: 2114: \***        use SESS.NUM.UTILITY function to deallocate session number! 1.11 NWB
3845: 2114: \***        IF F20.RETURN.CODE% <> 0 THEN                             ! 1.11 NWB
3846: 2114: \***           GOTO PROGRAM EXIT                                      ! 1.11 NWB
3847: 2114: \***        ENDIF                                                     ! 1.11 NWB
3848: 2114: \***     ENDIF                                                        ! 1.11 NWB
3849: 2114: \***
3850: 2114: \***     IF the phf open flag is "Y" THEN                             ! 1.11 NWB
3851: 2114: \***        CLOSE the phf session number                              ! 1.11 NWB
3852: 2114: \***        set FUNCTION.FLAG$ to "C",                                ! 1.11 NWB
3853: 2114: \***            PASSED.INTEGER% to phf session number and             ! 1.11 NWB
3854: 2114: \***            PASSED.STRING$ to ""                                  ! 1.11 NWB
3855: 2114: \***        use SESS.NUM.UTILITY function to deallocate session number! 1.11 NWB
3856: 2114: \***        IF F20.RETURN.CODE% <> 0 THEN                             ! 1.11 NWB
3857: 2114: \***           GOTO PROGRAM EXIT                                      ! 1.11 NWB
3858: 2114: \***        ENDIF                                                     ! 1.11 NWB
3859: 2114: \***     ENDIF                                                        ! 1.11 NWB
3860: 2114: \***
3861: 2114: \***   FUNCTION.EXIT:
3862: 2114: \***
3863: 2114: \***     EXIT the function
3864: 2114: \***
3865: 2114: \***
3866: 2114: \-------------------------------------------------------------------------------
3867: 2114: 
3868: 2114: \ Code removed from here                                               ! EMW
3869: 2114: 
3870: 2114: !     Close the IRFDEX and deallocate the session number                   ! 1.9 RC
3871: 2114: 
3872: 2114:       CLOSE F19.IRFDEX.SESS.NUM%                                           ! 1.9 RC
3873: 2120: 
3874: 2120:       FUNCTION.FLAG$  EQ "C"                                               ! 1.9 RC
3875: 212d:       PASSED.INTEGER% EQ F19.IRFDEX.SESS.NUM%                              ! 1.9 RC
3876: 2137:       PASSED.STRING$  EQ ""                                                ! 1.9 RC
3877: 2144:       RET.CODE% EQ SESS.NUM.UTILITY (FUNCTION.FLAG$, \                     ! 1.9 RC
3878: 2164:                                      PASSED.INTEGER%, \                    ! 1.9 RC
3879: 2164:                                      PASSED.STRING$)                       ! 1.9 RC
3880: 2164: 
3881: 2164:       IF RET.CODE% NE 0 THEN GOTO PROGRAM.EXIT ! PSBF20 failure            ! 1.9 RC
3882: 216c: 
3883: 216c:       IF IDF.OPEN.FLAG$ = "Y" THEN                                    \ 1.11 NWB
3884: 217f:          CLOSE F19.IDF.SESS.NUM%                                      ! 1.11 NWB
3885: 2188: 
3886: 2188:       FUNCTION.FLAG$  = "C"                                           ! 1.11 NWB
3887: 2195:       PASSED.INTEGER% = F19.IDF.SESS.NUM%                             ! 1.11 NWB
3888: 219b:       PASSED.STRING$  = ""                                            ! 1.11 NWB
3889: 21a8:       RET.CODE% = SESS.NUM.UTILITY (FUNCTION.FLAG$,                   \ 1.11 NWB
3890: 21c8:                                     PASSED.INTEGER%,                  \ 1.11 NWB
3891: 21c8:                                     PASSED.STRING$)                   ! 1.11 NWB
3892: 21c8: 
3893: 21c8:       IF RET.CODE% <> 0 THEN GOTO PROGRAM.EXIT                        ! 1.11 NWB
3894: 21d0: 
3895: 21d0:       IF PHF.OPEN.FLAG$ = "Y" THEN                                    \ 1.11 NWB
3896: 21e3:          CLOSE PHF.SESS.NUM%                                          ! 1.11 NWB
3897: 21ef: 
3898: 21ef:       FUNCTION.FLAG$  = "C"                                           ! 1.11 NWB
3899: 21fc:       PASSED.INTEGER% = PHF.SESS.NUM%                                 ! 1.11 NWB
3900: 2206:       PASSED.STRING$  = ""                                            ! 1.11 NWB
3901: 2213:       RET.CODE% = SESS.NUM.UTILITY (FUNCTION.FLAG$,                   \ 1.11 NWB
3902: 2233:                                     PASSED.INTEGER%,                  \ 1.11 NWB
3903: 2233:                                     PASSED.STRING$)                   ! 1.11 NWB
3904: 2233: 
3905: 2233:       IF RET.CODE% <> 0 THEN GOTO PROGRAM.EXIT                        ! 1.11 NWB
3906: 223b: 
3907: 223b:       IF SRITL.OPEN.FLAG$ = "Y" THEN                                  \ 1.11 NWB
3908: 224e:          CLOSE F19.SRITL.SESS.NUM%                                    ! 1.11 NWB
3909: 2257: 
3910: 2257:       FUNCTION.FLAG$  = "C"                                           ! 1.11 NWB
3911: 2264:       PASSED.INTEGER% = F19.SRITL.SESS.NUM%                           ! 1.11 NWB
3912: 226a:       PASSED.STRING$  = ""                                            ! 1.11 NWB
3913: 2277:       RET.CODE% = SESS.NUM.UTILITY (FUNCTION.FLAG$,                   \ 1.11 NWB
3914: 2297:                                     PASSED.INTEGER%,                  \ 1.11 NWB
3915: 2297:                                     PASSED.STRING$)                   ! 1.11 NWB
3916: 2297: 
3917: 2297:       IF RET.CODE% <> 0 THEN GOTO PROGRAM.EXIT                        ! 1.11 NWB
3918: 229f: 
3919: 229f:       IF TIF.OPEN.FLAG$ = "Y" THEN                                     \
3920: 22b5:          CLOSE TIF.SESS.NUM%
3921: 22c1: 
3922: 22c1:       FUNCTION.FLAG$  = "C"                                            ! BBCW
3923: 22ce:       PASSED.INTEGER% = TIF.SESS.NUM%                                  ! BBCW
3924: 22d8:       PASSED.STRING$  = ""                                             ! BBCW
3925: 22e5:       RET.CODE% = SESS.NUM.UTILITY (FUNCTION.FLAG$,                    \ DAW
3926: 2305:                                     PASSED.INTEGER%,                   \ BBCW
3927: 2305:                                     PASSED.STRING$)                    ! BBCW
3928: 2305: 
3929: 2305:       IF RET.CODE% <> 0 THEN GOTO PROGRAM.EXIT                         ! DAW
3930: 230d: 
3931: 230d:       IF TMCF.OPEN.FLAG$ = "Y" THEN                                    \
3932: 2323:          CLOSE TMCF.SESS.NUM%
3933: 232f: 
3934: 232f:       FUNCTION.FLAG$  = "C"                                            ! BBCW
3935: 233c:       PASSED.INTEGER% = TMCF.SESS.NUM%                                 ! BBCW
3936: 2346:       PASSED.STRING$  = ""                                             ! BBCW
3937: 2353:       RET.CODE% = SESS.NUM.UTILITY (FUNCTION.FLAG$,                    \ DAW
3938: 2373:                                     PASSED.INTEGER%,                   \ BBCW
3939: 2373:                                     PASSED.STRING$)                    ! BBCW
3940: 2373: 
3941: 2373:       IF RET.CODE% <> 0 THEN GOTO PROGRAM.EXIT                         ! DAW
3942: 237b: 
3943: 237b:    FUNCTION.EXIT:
3944: 237b: 
3945: 237b:       EXIT FUNCTION
3946: 237e: 
3947: 237e: 
3948: 237e: \*******************************************************************************
3949: 237e: \***
3950: 237e: \*** UPDT.CLOSE.ERROR.DETECTED:
3951: 237e: \***
3952: 237e: \***   Set the function 19 return code to 1.
3953: 237e: \***
3954: 237e: \***   Log an event 18, message number 553 for a chaining error.  Other errors
3955: 237e: \***   are logged as event 101s by calling the standard error detected function.
3956: 237e: \***
3957: 237e: \***   If the calling program is a batch program then processing stops.  If it
3958: 237e: \***   is a screen program then the first program in the current application is
3959: 237e: \***   chained back to.
3960: 237e: \***
3961: 237e: \-------------------------------------------------------------------------------
3962: 237e: 
3963: 237e:    UPDT.CLOSE.ERROR.DETECTED:
3964: 237e: 
3965: 237e:       CLOSE.IRF.UPDT = 1                                               ! DAW
3966: 2383: 
3967: 2383:       IF ERR = "CM" OR ERR = "CT" THEN                        \REM chain failure
3968: 23dd:          MESSAGE.NUMBER% = 553                                        :\
3969: 23e3:          VAR.STRING.1$  = "BF19 " + MID$(MODULE.NUMBER$,3,1) + "50  " :\ BBCW
3970: 2416:          VAR.STRING.2$  = "PS" + MID$(MODULE.NUMBER$,3,1) + "50"      :\ BBCW
3971: 2449:          EVENT.NO%      = 18                                          :\
3972: 244f:          RET.CODE% = APPLICATION.LOG (MESSAGE.NUMBER%,                 \ DAW
3973: 2473:                                       VAR.STRING.1$,                   \
3974: 2473:                                       VAR.STRING.2$,                   \
3975: 2473:                                       EVENT.NO%)
3976: 2473: 
3977: 2473: 
3978: 2473:       IF ERR <> "CM" AND ERR <> "CT" THEN                              \
3979: 24ca:          \ lines deleted from here                                     \ DAW
3980: 24ca:          RET.CODE% = STANDARD.ERROR.DETECTED (ERRN,                    \ DAW
3981: 24f2:                                               ERRF%,                   \ DAW                                       \
3982: 24f2:                                               ERRL,                    \ DAW
3983: 24f2:                                               ERR)                     ! DAW
3984: 24f2: 
3985: 24f2: 
3986: 24f2:    PROGRAM.EXIT:                                                       ! BBCW
3987: 24f2: 
3988: 24f2:       IF BATCH.SCREEN.FLAG$ <> "S" THEN                                \
3989: 2508:          STOP
3990: 250d: 
3991: 250d:       %INCLUDE PSBCHNE.J86
3992: 250d: \/*********************************************************************/ PSBCHNE
3993: 250d: \/*                                                                   */ PSBCHNE
3994: 250d: \/*      PSBCHNE.J86  -  Chain to PSB Application Program             */ PSBCHNE
3995: 250d: \/*      ------------------------------------------------             */ PSBCHNE
3996: 250d: \/*                                                                   */ PSBCHNE
3997: 250d: \/*********************************************************************/ PSBCHNE
3998: 250d:                                                                        ! PSBCHNE
3999: 250d:         CHAIN  PSBCHN.PRG , PSBCHN.OP , PSBCHN.APP , PSBCHN.MENCON ,   \ PSBCHNE
4000: 2585:                             PSBCHN.U1 , PSBCHN.U2  , PSBCHN.U3         ! PSBCHNE
4001: 2585:                                                                        ! PSBCHNE
4002: 2585: 
4003: 2585:    END FUNCTION
4004: 259e: 
4005: 259e: End of Compilation
