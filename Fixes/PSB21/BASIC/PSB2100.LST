   1: 0003: \*******************************************************************************
   2: 0003: \*******************************************************************************
   3: 0003: \***
   4: 0003: \***
   5: 0003: \***            PROGRAM         :       PSB21
   6: 0003: \***            MODULE          :       PSB2100
   7: 0003: \***            AUTHOR          :       Charles Skadorwa / Mark Walker / Mark Goode
   8: 0003: \***            DATE WRITTEN    :       Sept 2011
   9: 0003: \***
  10: 0003: \*******************************************************************************
  11: 0003: \***
  12: 0003: \***   VERSION 1.0        Charles Skadorwa/Mark Walker/Mark Goode  30 SEP 2011
  13: 0003: \***   Initial version.
  14: 0003: \***
  15: 0003: \***   VERSION 1.1            Mark Goode                        22 December 2011
  16: 0003: \***   Re-introduce date validation process for RPD date field.
  17: 0003: \***
  18: 0003: \***   VERSION 1.2            Charles Skadorwa                  16 January 2012
  19: 0003: \***   Defect 3333: PSB21 log file shows misleading message.
  20: 0003: \***                Text change "PSB21 PGF PROCESSING" changed to
  21: 0003: \***                            "PSB21 IUF PROCESSING".
  22: 0003: \***
  23: 0003: \***   VERSION 1.3            Charles Skadorwa                  20 January 2012
  24: 0003: \***   Defect 2781: PSB21 sends 2 DEC messages (success & failure) when invalid
  25: 0003: \***                trailer count found. Trailer processing modified.
  26: 0003: \***
  27: 0003: \***   Defect    8: Confusing duplicate error messages. IUF Pre-processing ERROR4
  28: 0003: \***                & ERROR6 changed to ERROR10 & ERROR11 respectively.
  29: 0003: \***
  30: 0003: \***   Defect   10: Fix to Price record date checking.
  31: 0003: \***
  32: 0003: \***    VERSION 1.4.                ROBERT COWEY.                25 JAN 2012.
  33: 0003: \***    Incremented version text to 1.4.
  34: 0003: \***    Reduced text to fit 46 characters of background display but excluded
  35: 0003: \***    version date to avoid any confusion with run date.
  36: 0003: \***    Opened/Created log file UNLOCKED to force physical write for each
  37: 0003: \***    logical write in order to capture log data when program abends.
  38: 0003: \***    (The extra overhead will be very small for normal program runs).
  39: 0003: \***
  40: 0003: \***    Defect 3569 (b).
  41: 0003: \***    Changed NIADF report number to 834 (as 830 in use by DEALX2).
  42: 0003: \***
  43: 0003: \***    Also ...
  44: 0003: \***    Set JOBSOK.FLAG$ to "X" prior to calling PROGRAM.EXIT due to invalid
  45: 0003: \***    IUF header.
  46: 0003: \***    Improved log messages when no IUF backup made.
  47: 0003: \***
  48: 0003: \***    VERSION 1.5.                ROBERT COWEY.                02 FEB 2012.
  49: 0003: \***    Changes creating PSB21.286 Core Release 2 version 1.5.
  50: 0003: \***    Incremented version text to 1.5.
  51: 0003: \***
  52: 0003: \***    Defect 2678
  53: 0003: \***    Modified PPFK functions to prevent unwanted retention of superceded
  54: 0003: \***    price changes.
  55: 0003: \***
  56: 0003: \***    Defect 21 - Commented 1.5 RC (21).                       07 FEB 2012.
  57: 0003: \***    Original fix (and associated comments) were incorrect as they were    ! 1.6 RC (21)
  58: 0003: \***    based on a mis-understanding of variable IUF.DISCOUNTABLE$.           ! 1.6 RC (21)
  59: 0003: \***    The fix has now been re-coded (commented 1.6 RC (21) ) and any        ! 1.6 RC (21)
  60: 0003: \***    potentially confusing comments also corrected or removed.             ! 1.6 RC (21)
  61: 0003: \***
  62: 0003: \***    VERSION 1.6            Charles Skadorwa                  14 FEB 2012
  63: 0003: \***    Various defects following WPI.
  64: 0003: \***
  65: 0003: \***    VERSION 1.6 RC.        ROBERT COWEY.                     21 FEB 2012.
  66: 0003: \***    Continued Charlies version 1.6 to retain this as next lab release.
  67: 0003: \***
  68: 0003: \***    Defect 21 - Commented 1.6 RC (21).
  69: 0003: \***    Reinstated original variable name CURR.DISCOUNTABLE$.
  70: 0003: \***
  71: 0003: \***    Defect 50 - Commented 1.6 RC (50).                       22 FEB 2012.
  72: 0003: \***    Shortened message text to fit 46 character background display.
  73: 0003: \***    Also set initial DO.MESSAGE("PSB21 PROGRAM START ..." to TRUE to
  74: 0003: \***    re-instate its display on background screen.
  75: 0003: \***
  76: 0003: \***    Also ... Commented 1.6 RC  Matrix nn                     24 FEB 2012.
  77: 0003: \***    Reported IUF item code in addition to IUF record number when
  78: 0003: \***    VALIDATE.IUF.FIELDS routine rejects a particular IUF matrix entry
  79: 0003: \***    and skips the record.
  80: 0003: \***
  81: 0003: \***    Defect 87 - Commented 1.6 RC (87)                        24 FEB 2012.
  82: 0003: \***    Defined IUF.OPEN flag to keep track of IUF file open status.
  83: 0003: \***    Used this to prevent attempted backup if IUF still open as occurs
  84: 0003: \***    when ERROR.DETECTED calls PROGRAM.EXIT calls BACKUP.IUF.FILE.
  85: 0003: \***
  86: 0003: \***    Defect 71 - Commented 1.6 RC (71)                        24 FEB 2012.
  87: 0003: \***    For Core R2 IUF ...
  88: 0003: \***    Removed code rejecting items with invalid IUF.UNRESTRICTED.GROUP.CODE$
  89: 0003: \***    as these are now intercepted (and defaulted to "N") within READ.IUF.
  90: 0003: \***
  91: 0003: \***    Defect 71 - Reversed out - Commented 1.6 RC (71b)        27 FEB 2012.
  92: 0003: \***    The previous fix correctly follows Detailed Design 1.6 however the
  93: 0003: \***    DD refers to setting of IRF flags from valid IUF data ("N" or "Y").
  94: 0003: \***    The project level documents however require that invalid IUF data
  95: 0003: \***    for this variable causes the item to be rejected.
  96: 0003: \***
  97: 0003: \***    Modified VALIDATE.IUF.FIELDS to remove the MATCH statement from this
  98: 0003: \***    variables original validation code (as it did not trap null values).
  99: 0003: \***
 100: 0003: \***    Defect 90 - Commented 1.6 RC (90)                        27 FEB 2012.
 101: 0003: \***    Modified VALIDATE.IUF.FIELDS to retain IUF.RPD.DATE$ as 8 digits
 102: 0003: \***    until loaded into CURR.DATE.DUE$ table.
 103: 0003: \***    Modified STORE.PRICE.CHANGE to convert 8-digit ASCII IUF.RPD.DATE$
 104: 0003: \***    to 6-digits (3 bytes packed) when passed to CURR.DATE.DUE$.
 105: 0003: \***    This then passes to PPFK.DATE.DUE$ and is then written to the PPFK
 106: 0003: \***    temporary file via a WRITE FORM (defining it as 3 bytes packed).
 107: 0003: \***    (The PPFK is intimately associated with 6-digit PPFI RPD dates).
 108: 0003: \***
 109: 0003: \***    VERSION 1.7.                ROBERT COWEY.                28 FEB 2012.
 110: 0003: \***    Changes creating PSB21.286 Core Release 2 version 1.7.
 111: 0003: \***    Incremented version text to 1.7.
 112: 0003: \***    Set JOBOK to "X" when legacy IUF is processed after a Core R2 IUF.
 113: 0003: \***
 114: 0003: \***    VERSION 1.8.                ROBERT COWEY.                08 MAR 2012.
 115: 0003: \***    Changes creating PSB21.286 Core Release 2 version 1.8.
 116: 0003: \***    Incremented lab release version text to V1.8.
 117: 0003: \***
 118: 0003: \***    Defect 8 - Commented 1.8 RC (8)                          12 MAR 2012.
 119: 0003: \***    Defined flag IUF.OPEN.ERROR.REPORTED and used it to ensure no more
 120: 0003: \***    than one IUF open error is ever reported to the PSB21day.log file.
 121: 0003: \***
 122: 0003: \***    VERSION 1.9.                ROBERT COWEY.                13 MAR 2012.
 123: 0003: \***    Changes creating PSB21.286 Core Release 2 version 1.9.
 124: 0003: \***    Incremented lab release version text to v1.9.
 125: 0003: \***
 126: 0003: \***    Defect 109 - Commented 1.9 RC (109)                      19 MAR 2012.
 127: 0003: \***    Rejected IUF emergency 99999 RPD's as these are now generated
 128: 0003: \***    internally within the program.
 129: 0003: \***
 130: 0003: \***    VERSION 1.10.               ROBERT COWEY.                21 MAR 2012.
 131: 0003: \***    Changes creating PSB21.286 Core Release 2 version 1.10.
 132: 0003: \***    Incremented lab release version text to v1.10.
 133: 0003: \***
 134: 0003: \***    Defect 113 - Commented 1.10 RC (113)
 135: 0003: \***    Defined SORT.TABLE$ for use in sorting CURR data tables (from IUF)
 136: 0003: \***    and PPFK data tables (from PPFI) into descending date-RPD order.
 137: 0003: \***
 138: 0003: \***    Wrote STORE.EMERG.PRICE.CHANGE(N%) based on STORE.PRICE.CHANGE(N%)
 139: 0003: \***    to place emergency 99999 RPD onto (IUF) CURR data table
 140: 0003: \***    Wrote CHECK.IF.CURR.SORT.NEEDED(M%) to be called by both of these
 141: 0003: \***    to set CURR.SORT.NEEDED flag TRUE when underlying data (from IUF)
 142: 0003: \***    is not in sequence.
 143: 0003: \***    Wrote SORT.CURR.TABLES to sort CURR data tables when needed
 144: 0003: \***    (and reset CURR.SORT.NEEDED to FALSE).
 145: 0003: \***    Modified STORE.PRICE.CHANGE precedure to set PRICE.CHANGE.TODAY flag
 146: 0003: \***    TRUE (for use in preventing an un-necessary emergency 99999 RPD)
 147: 0003: \***    when one of the price changes is for the current day.
 148: 0003: \***
 149: 0003: \***    VERSION 1.11.               ROBERT COWEY.                05 APR 2012.
 150: 0003: \***    Changes creating PSB21.286 Core Release 2 version 1.11.
 151: 0003: \***    Incremented lab release version text to v1.11.
 152: 0003: \***
 153: 0003: \***    Defect 169 - Commented 1.11 RC (169)
 154: 0003: \***    Defined subprogram IUF.END.BATCH.PROCESSES to group together the
 155: 0003: \***    tasks performed when an IUF trailer record is encountered after
 156: 0003: \***    processing a batch of IUF data.
 157: 0003: \***    Also called this when an IUF trailer record is encountered after
 158: 0003: \***    processing an empty IUF batch (header and trailer only) provided
 159: 0003: \***    it has not already been executed from the main loop.
 160: 0003: \***
 161: 0003: \***    VERSION 1.12.               ROBERT COWEY.                17 APR 2012.
 162: 0003: \***    Changes creating PSB21.286 Core Release 2 version 1.12.
 163: 0003: \***    Incremented lab release version text to v1.12.
 164: 0003: \***
 165: 0003: \***    Defect 177 - Commented 1.12 RC (177)
 166: 0003: \***    Correction to place RPD data on the output PPFI in ascending date
 167: 0003: \***    order (latest last) as needed by PSB72 Effect Price Change program.
 168: 0003: \***    Associated changes to programs internal sort of PPFI and IUF data.
 169: 0003: \***
 170: 0003: \***    VERSION 1.13.               ROBERT COWEY.                23 APR 2012.
 171: 0003: \***    Changes creating PSB21.286 Core Release 2 version 1.13.
 172: 0003: \***    Incremented lab release version text to v1.13.
 173: 0003: \***
 174: 0003: \***    Defect 179 - Commented 1.13 RC (179)
 175: 0003: \***    Moved setting of RICF.RECORD.NO% from CREATE.RICF to UPDATE.RICF.
 176: 0003: \***
 177: 0003: \***    Defect 190 - Commented 1.13 RC (190)                     24 APR 2012.
 178: 0003: \***    Moved DELETE.PPFK.KEYED.FILE into PROGRAM.EXIT to ensure PPFK is
 179: 0003: \***    always deleted even when program does not complete successfully.
 180: 0003: \***
 181: 0003: \***    VERSION 1.14.               ROBERT COWEY.                26 APR 2012.
 182: 0003: \***    Changes creating PSB21.286 Core Release 2 version 1.14.
 183: 0003: \***    Incremented lab release version text to v1.14.
 184: 0003: \***
 185: 0003: \***    Defect 190 corrrection - Commented 1.14 RC (190)         30 APR 2012.
 186: 0003: \***    Re-instated DELETE.PPFK.KEYED.FILE prior to PROCESS.NIADF.FILE to
 187: 0003: \***    ensure PPFK deleted prior to requiring RAM disk for NIADF.
 188: 0003: \***    PPFK is now only deleted from PROGRAM.EXIT itself (by DESTROY.PPFK)
 189: 0003: \***    when JOBSOK.FLAG$ is "X" (since this is set prior to all unexpected
 190: 0003: \***    calls to PROGRAM.EXIT).
 191: 0003: \***
 192: 0003: \***    VERSION 1.15.               ROBERT COWEY.                01 MAY 2012.
 193: 0003: \***    Changes creating PSB21.286 Core Release 2 version 1.15.
 194: 0003: \***    Incremented lab release version text to v1.15.
 195: 0003: \***
 196: 0003: \***    Defect 200 - See TIFFUN.BAS
 197: 0003: \***    Modified READ.TIF function to bypass file read for null TIF.BARCODE$.
 198: 0003: \***
 199: 0003: \***    Defect 223 - Commented 1.15 RC (223)                     04 MAY 2012.
 200: 0003: \***    Modified UNEXPECTED.RECORD.TYPE routine to exit the program with
 201: 0003: \***    JOBSOK.FLAG$ "X" for unexpected legacy IUF record type.
 202: 0003: \***
 203: 0003: \***    VERSION 1.15 supplemental   CHARLES SKADORWA.            04 MAY 2012.
 204: 0003: \***    Modified ERROR.DETECTED to report SU subscript (table overflow) error
 205: 0003: \***    to PSB21day.LOG file.
 206: 0003: \***    Ensured BCF is only opened when needed (then closed afterwards).
 207: 0003: \***
 208: 0003: \***    VERSION 1.16.               ROBERT COWEY.                09 MAY 2012.
 209: 0003: \***    Changes creating PSB21.286 Core Release 2 version 1.16.
 210: 0003: \***    Incremented lab release version text to v1.16.
 211: 0003: \***
 212: 0003: \***    Defect 226 - Commented 1.16 RC (226)
 213: 0003: \***    Modified OPEN.FILES to cater for stores not having a CIPPMR and set
 214: 0003: \***    CIPPM.PRESENT flag appropriately to indicate this.
 215: 0003: \***
 216: 0003: \***    VERSION 1.17.               ROBERT COWEY.                16 MAY 2012.
 217: 0003: \***    Changes creating PSB21.286 Core Release 2 version 1.17.
 218: 0003: \***    Incremented lab release version text to v1.17.
 219: 0003: \***
 220: 0003: \***    Defect 230 - Commented 1.17 RC (230)
 221: 0003: \***    Modified BACKUP.IUF to ensure IUF is renamed to IUFBK.day
 222: 0003: \***    (via ADXCOPYF then delete of IUF) only when JOBSOK.FLAG$ indicates
 223: 0003: \***    PSB21 has been successful or IUF does not need to be reprocessed.
 224: 0003: \***    Modified IUF.END.BATCH.PROCESSES to update BCF (and send associated
 225: 0003: \***    DEC message) only after IUF trailer count validated.
 226: 0003: \***
 227: 0003: \***    VERSION 1.18.               ROBERT COWEY.                22 MAY 2012.
 228: 0003: \***    Changes creating PSB21.286 Core Release 2 version 1.18.
 229: 0003: \***    Incremented lab release version text to v1.18.
 230: 0003: \***
 231: 0003: \***    Pilot defect - Commented 1.18 RC (237)
 232: 0003: \***    Modified DETERMINE.LOG.FILE routine to set log file name correctly.
 233: 0003: \***
 234: 0003: \***    Pilot defect - Commented 1.18 RC (239)
 235: 0003: \***    Set PROCESS.NIADF flag FALSE to temporarily prevent processing of
 236: 0003: \***    NIADF until defect 239 is investigated and resolved.
 237: 0003: \***
 238: 0003: \***    VERSION 1.19.               ROBERT COWEY.                24 MAY 2012.
 239: 0003: \***    Changes creating PSB21.286 Core Release 2 version 1.19.
 240: 0003: \***    Incremented lab release version text to v1.19.
 241: 0003: \***    Nullified previous change to reinstate NIADF processing.
 242: 0003: \***
 243: 0003: \***    Pilot defect - Commented 1.19 RC (238)
 244: 0003: \***    Defined F18.SOPTS.READ flag as global in modules PSB2100 and PSB2104.
 245: 0003: \***    Called PSBF18 CALC.BOOTS.CODE.CHECK.DIGIT from INITIALISATION to
 246: 0003: \***    perform function-internal read of SOPTS record 96 at program start.
 247: 0003: \***    This avoids session number contention problems causing ERRN 00000014.
 248: 0003: \***
 249: 0003: \***    VERSION 1.20.               ROBERT COWEY.                28 MAY 2012.
 250: 0003: \***    Changes creating PSB21.286 Core Release 2 version 1.20.
 251: 0003: \***    Incremented lab release version text to v1.20.
 252: 0003: \***
 253: 0003: \***    Pilot defect - Commented 1.20 RC (240)
 254: 0003: \***    Defined procedure CHECK.PROCESS.PGF to check for and handle errors
 255: 0003: \***    from PROCESS.PGF.
 256: 0003: \***
 257: 0003: \***    VERSION 1.21.               ROBERT COWEY.                11 JUN 2012.
 258: 0003: \***    Changes creating PSB21.286 Core Release 2 version 1.21.
 259: 0003: \***    Incremented lab release version text to v1.21.
 260: 0003: \***
 261: 0003: \***    Lab test defect - Commented 1.21 RC (242)
 262: 0003: \***    Corrected NIADF processing to ensure IRFDEX updated when new item is
 263: 0003: \***    on more than three deals.
 264: 0003: \***    Allocated IRFDEX session number and opened and closed the file.
 265: 0003: \***
 266: 0003: \***    VERSION 1.22                CHARLES SKADORWA.            20 JUN 2012.
 267: 0003: \***    Defect 243 - Commented 1.22 CS (243)
 268: 0003: \***    Changes creating PSB21.286 Core Release 2 version 1.22.
 269: 0003: \***    Incremented lab release version text to v1.22.
 270: 0003: \***
 271: 0003: \***    VERSION A                   CHARLES SKADORWA.             5 SEP 2013.
 272: 0003: \***    F261 Gift Card Mall IIN Range Extension Project - Commented ! ACSk
 273: 0003: \***    Incremented lab release version text to vA.
 274: 0003: \***
 275: 0003: \***    VERSION B                   CHARLES SKADORWA.            18 FEB 2014.
 276: 0003: \***    F261 Gift Card Mall IIN Range Extension Project - Commented ! BCSk
 277: 0003: \***    Defect 495 - GCM: PSB21: 'Not Returnable' flag value is getting
 278: 0003: \***                              set to 1 for a non GCM item.
 279: 0003: \***    The IUF.RETURNABLE$ flag (initialised to "Y") gets set in the READ.IUF
 280: 0003: \***    function (IUFFUN.BAS) according to the value set against the Product
 281: 0003: \***    Group for the item (that's read into an internal table [REFPGF.RECORDS$]
 282: 0003: \***    from the REFPGF file). This value is used to determine the Return
 283: 0003: \***    Route. If the value is not set ie. zero, then the IUF.RETURNABLE$ flag
 284: 0003: \***    is set to "N". The current logic in UPDATE.IRF only UNsets the
 285: 0003: \***    Returnable bit flag (IRF.INDICAT0% Bit 3) if it is a new item (not on
 286: 0003: \***    IDF),otherwise the item retains its original setting.
 287: 0003: \***
 288: 0003: \***    My mistake was thinking that the IUF.RETURNABLE$ flag related to this
 289: 0003: \***    bit flag, however, it is used to set IRF.INDICAT10% Bit 6.
 290: 0003: \***
 291: 0003: \***    The fix is to set IRF.INDICAT0% Bit 3 directly in UPDATE.IRF if the
 292: 0003: \***    item is in one of the specified GCM product groups read from the BCF.
 293: 0003: \***    Release version left at vA as not released but date changed to
 294: 0003: \***    18-02-2014.
 295: 0003: \***
 296: 0003: \***    VERSION C                   CHARLES SKADORWA.            25 FEB 2014.
 297: 0003: \***    F261 Gift Card Mall IIN Range Extension Project - Commented ! CCSk
 298: 0003: \***    Defect 517 - GCM: PSB21: 'Not Returnable' flag value is NOT
 299: 0003: \***                              getting set to 1 for a new GCM item.
 300: 0003: \***    Change to UPDATE.IRF in PSB2101.BAS to reference CURR.PROD.GRP$
 301: 0003: \***    instead of IUF.PROD.GRP$.
 302: 0003: \***    Release version left at vA as not released but date changed to
 303: 0003: \***    25-02-2014.
 304: 0003: \***
 305: 0003: \***    VERSION D                   Mark Walker                 4th Mar 2014
 306: 0003: \***    F337 Centralised View of Stock
 307: 0003: \***    Incremented lab release version text to vD.
 308: 0003: \***
 309: 0003: \***    VERSION E                   Mark Walker                 6th May 2014
 310: 0003: \***    F337 Centralised View of Stock
 311: 0003: \***    Incremented lab release version text to vE.
 312: 0003: \***
 313: 0003: \***    VERSION F                   Mark Walker                23rd May 2014
 314: 0003: \***    F337 Centralised View of Stock
 315: 0003: \***    Incremented lab release version text to vF.
 316: 0003: \***
 317: 0003: \***    VERSION G                   Mark Walker                 8th Jul 2014
 318: 0003: \***    F353 Deal Limits Increase
 319: 0003: \***    Removed DINF and NIADF file processing.
 320: 0003: \***    Removed module 4 from program overview (uncommented).
 321: 0003: \***    Incremented lab release version text to vG.
 322: 0003: \***
 323: 0003: \***    VERSION H                   Rejiya Nair            13th May 2016
 324: 0003: \***    PRJ1452 Restricting Item Sales
 325: 0003: \***    - Add/Update the new keyed file; IRFITGRP if the IRF file is set
 326: 0003: \***      for the bit "enforced quantity entry" (bit 7) in IRF.INDICAT0.
 327: 0003: \***    - Delete the item record from IRFITGRP if bit 7 in IRF.INDICAT0
 328: 0003: \***      is reset.
 329: 0003: \***    - Removed the previously tagged commented out code.
 330: 0003: \***
 331: 0003: \***    VERSION I                   Ranjith Gopalankutty        4th Nov 2016
 332: 0003: \***    INV10004090 - Fix for duplicate entry issue in PPFI
 333: 0003: \***    Fixed the 'For' loop breaking condition in Function 
 334: 0003: \***    PROCESS.BTREE.RECORD$ within submodule PSB2103.BAS,
 335: 0003: \***    Fix will ensure duplicate entries issue in PPFI is
 336: 0003: \***    not repeated and hence CIPOK also works without 
 337: 0003: \***    problems.
 338: 0003: \***    Incremented the version of PSB21 to vI
 339: 0003: \***----------------------------------------------------------------------------
 340: 0003: \***  IMPORTANT: When you change PSB21, please search for the line containing
 341: 0003: \***------------        CALL DO.MESSAGE("PSB21 PROGRAM START
 342: 0003: \***             in Module PSB2100 and wind the date and version on.
 343: 0003: \***
 344: 0003: \*******************************************************************************
 345: 0003: \*******************************************************************************
 346: 0003: 
 347: 0003: \*******************************************************************************
 348: 0003: \*******************************************************************************
 349: 0003: \***
 350: 0003: \***    Program Overview
 351: 0003: \***    ----------------
 352: 0003: \***
 353: 0003: \***    This is a multi-modular program which Processes the Item Update File that
 354: 0003: \***    is sent from the Boots Central Systems and prepares the data ready for the
 355: 0003: \***    next program in the item Update Suite. This program has been rewritten as
 356: 0003: \***    part of the CORE Heritage Stores Release 2 Outbound project.
 357: 0003: \***
 358: 0003: \***
 359: 0003: \***    Started By: PSB20 Item Update Suite Control Program
 360: 0003: \***
 361: 0003: \***    Calls     : none
 362: 0003: \***
 363: 0003: \***    Chains to : PSB20
 364: 0003: \***
 365: 0003: \***
 366: 0003: \***
 367: 0003: \***    MODULE 0:  Main Processing Control
 368: 0003: \***               This is the main control module. It performs the initialisation
 369: 0003: \***               and contains the main processing loop that is used to process the
 370: 0003: \***               IUF. Nb. this program handles both IUF's in the Old format and the
 371: 0003: \***               new CSV format. The format is hidden by the IUF function calls ie.
 372: 0003: \***               the old fomat records are converted/transalated into the new format.
 373: 0003: \***               Old format IUF's contain only one batch whereas new IUF's can contain
 374: 0003: \***               multiple batches - a pre-processing stage ensures that duplicate items
 375: 0003: \***               that appear in earlier batches are skipped.
 376: 0003: \***
 377: 0003: \***               An item is not processed until all its associated records have been read
 378: 0003: \***               in and validated. Invalid items are skipped.
 379: 0003: \***
 380: 0003: \***               A comprehensive daily log is maintained of all processing activity in
 381: 0003: \***               D:\ADX_UDT1\PSB21MON.LOG through to D:\ADX_UDT1\PSB21SUN.LOG.
 382: 0003: \***
 383: 0003: \***
 384: 0003: \***    MODULE 1:  IUF Processing
 385: 0003: \***               This module updates all the associated data files for an item.
 386: 0003: \***
 387: 0003: \***
 388: 0003: \***    MODULE 2:  PGFDIR Processing
 389: 0003: \***               The purpose of this module is to remove old product groups from the PGF.
 390: 0003: \***               It achieves this by reading the existing PGF into a table and reading
 391: 0003: \***               through the PGFDIR. All PGFDIR records are written to a work file,
 392: 0003: \***               however, its flags are updated if the product group exists on the PGF.
 393: 0003: \***               At the end of processing, the PGF is replaced by the work file.
 394: 0003: \***
 395: 0003: \***
 396: 0003: \***    MODULE 3:  Price Change (PPFI) Processing
 397: 0003: \***               The purpose of this module is to perform price change processing.
 398: 0003: \***               It updates the PPFI with the current price changes in the IUF.
 399: 0003: \***
 400: 0003: \***
 401: 0003: \***    MODULE 5:  Program Exit Processing
 402: 0003: \***               Update JOBSOK, send message to DEC API and chain to PSB20 passing
 403: 0003: \***               processing date.
 404: 0003: \***
 405: 0003: \***
 406: 0003: \*******************************************************************************
 407: 0003: \*******************************************************************************
 408: 0003: 
 409: 0003: \*******************************************************************************
 410: 0003: \***
 411: 0003: \***    Included code defining file related global variables
 412: 0003: \***
 413: 0003: \***............................................................................
 414: 0003: %INCLUDE BCFDEC.J86     ! Boots Control File
 415: 0003: \*****************************************************************************
 416: 0003: \*****************************************************************************
 417: 0003: \***
 418: 0003: \***               %INCLUDE FOR BCF - FIELD DECLARATIONS
 419: 0003: \***                                  FILE REFERENCE PARAMETERS
 420: 0003: \***
 421: 0003: \***                      FILE TYPE    : SEQUENTIAL
 422: 0003: \***
 423: 0003: \***                      REFERENCE    : BCFDEC.J86
 424: 0003: \***
 425: 0003: \***      Version A             Steve Windsor          5th Jan 1993
 426: 0003: \***
 427: 0003: \***      Version B             Michael J. Kelsall    01st Dec 1993
 428: 0003: \***      Addition to file of CCMVT serial number as part of
 429: 0003: \***      RETURNS/AUTOMATIC CREDIT CLAIMING package.
 430: 0003: \***
 431: 0003: \***      Version C           Stuart William McConnachie 23rd Jan 1995
 432: 0003: \***      Addition of TXR serial number as part of the TRANSACTION RETRIEVAL
 433: 0003: \***      project.
 434: 0003: \***
 435: 0003: \***      Version D           Stuart William McConnachie  7th June 1995
 436: 0003: \***      Converted calls to enable more than 1 record on the BCF.
 437: 0003: \***      The second record is to be used for the No7 customer card trial.
 438: 0003: \***
 439: 0003: \***      Version E                 Stuart Highley        7th April 1999
 440: 0003: \***      Added new fields for cash accounting.
 441: 0003: \***
 442: 0003: \***      Version F                 Mark Goode            20th May 2000
 443: 0003: \***      Added new fields for Dentistry project.
 444: 0003: \***
 445: 0003: \***      Version G                 Mark Goode            18th July 2000
 446: 0003: \***      Added new fields for Well-Being project.
 447: 0003: \***
 448: 0003: \***      Version I                 Amy Hoggard           13th Oct 2000
 449: 0003: \***      Added new fields for ECO project.
 450: 0003: \***
 451: 0003: \***      Version K                 Brian Greenfield      1st May 2001
 452: 0003: \***      Added new field for Wellbeing Services record 13.
 453: 0003: \***
 454: 0003: \***      Version L                 Amy Hoggard           4th Jan 2002
 455: 0003: \***      Added new field for ETOPUP project.
 456: 0003: \***
 457: 0003: \***      Version M                 Julia Stones          22nd July 2002
 458: 0003: \***      Added new fields for Deals rewrite project record 14.
 459: 0003: \***
 460: 0003: \***    Revision 4.6            ROBERT COWEY.            19 MAY 2003.
 461: 0003: \***    Modifications for All Txn Data To CDAS project.
 462: 0003: \***    Removed redundant variables ...
 463: 0003: \***      BCF.CTSL1.SERIAL.NUM$, BCF.CTSL2,SERIAL.NUM$
 464: 0003: \***    Defined new variable ...
 465: 0003: \***      BCF.MTSLQ.DAYS$, BCF.FILLER67$
 466: 0003: \***
 467: 0003: \***    Revision 4.7           Julia Stones              9th July 2003.
 468: 0003: \***    Modifications for New Lines Report project.
 469: 0003: \***    Defined new variable
 470: 0003: \***    BCF.NEWLINES.WEEKS$
 471: 0003: \***
 472: 0003: \***    Revision 4.8           Julia Stones              3rd October 2003.
 473: 0003: \***    Modifications for New Lines Report project.
 474: 0003: \***    Defined new variable
 475: 0003: \***    BCF.NEWLINES.LINES$
 476: 0003: \***
 477: 0003: \***    Version N              Jamie Thorpe             27th June 2006
 478: 0003: \***    Added BCF.DVCHR.SERIAL.NUM$
 479: 0003: \***
 480: 0003: \***    Revision 4.10          Charles Skadorwa            4th July 2011
 481: 0003: \***    CORE Heritage Stores Release 2 (Outbound) Project.
 482: 0003: \***    New variables defined: BCF.ECC.DATETIMESTAMP$
 483: 0003: \***                           BCF.IUF.DATETIMESTAMP$
 484: 0003: \***
 485: 0003: \***    Revision 4.11          Arun Sudhakaran             10th April 2013
 486: 0003: \***    Added new variables for including Supplier Number lengths
 487: 0003: \***    as part of Automatic Booking In of Chilled Food ASNs project
 488: 0003: \***
 489: 0003: \***    Revision 4.12          Charles Skadorwa            5th Sept 2013
 490: 0003: \***    F261 Gift Card Mall IIN Range Extension Project - Commented !4.12 CSk
 491: 0003: \***    Defined new variables for GCM Product Group Number and Record 22
 492: 0003: \***    lengths.
 493: 0003: \***
 494: 0003: \***    Version O              Mark Walker                  3rd Feb 2014
 495: 0003: \***    F337 Centralised View of Stock
 496: 0003: \***    - Defined variables for record 23 (stock snapshot parameters).
 497: 0003: \***    - Minor formatting changes (uncommented).
 498: 0003: \***
 499: 0003: \***    Revision O             Charles Skadorwa             25th June 2014
 500: 0003: \***    F353 Deal Limits Increase Project.
 501: 0003: \***    Renamed 3 variables in function BCF.RECORD.14.W -
 502: 0003: \***        BCF.DINF.NUM.REC$ becomes BCF.ITMDL.NUM.REC$
 503: 0003: \***        BCF.DINF.KEY.LEN$ becomes BCF.ITMDL.KEY.LEN$
 504: 0003: \***        BCF.ECC.DATETIMESTAMP$ becomes BCF.FILLER.DATETIMESTAMP$
 505: 0003: \*****************************************************************************
 506: 0003: \*****************************************************************************
 507: 0003: 
 508: 0003:     STRING GLOBAL                                                       \
 509: 0003:         BCF.FILE.NAME$
 510: 0003: 
 511: 0003:     INTEGER*2 GLOBAL                                                    \
 512: 0003:         BCF.RECL%,                                                      \   !OMW
 513: 0003:         BCF.REPORT.NUM%,                                                \
 514: 0003:         BCF.SESS.NUM%
 515: 0003: 
 516: 0003:     STRING GLOBAL                                                       \
 517: 0003:     BCF.RECORD$,          \ 80 bytes
 518: 0003:     BCF.IUF.SERIAL.NO$,   \ 5 bytes, IUF serial number
 519: 0003:     BCF.OPEN.DATE$,       \ 6 bytes, Last store opening date (YYMMDD)
 520: 0003:     BCF.FILLER.DATE$,     \ 3 bytes, filler
 521: 0003:     BCF.LABEL.DATE$,      \ 6 bytes, label print date (YYMMDD)
 522: 0003:     BCF.SALES.SERIAL.NO$ ,\ 5 bytes, sales serial number
 523: 0003:     BCF.STMVB.SERIAL.NO$, \ 5 bytes, current serial number          \
 524: 0003:                               \     of Stock Movement Backup file       \
 525: 0003:     BCF.TOF.DAYS$,        \ 2 bytes, number of days' worth of sales to \
 526: 0003:                           \       be held on the TIF at re-build       \
 527: 0003:         BCF.EPS.BATCH$,       \ 2 bytes, highest batch number to have   \
 528: 0003:                               \     been reported upon by PSE31         \
 529: 0003:     BCF.NO.EPF.COPIES$,   \ 2 bytes, no. of copies of EPS payment file \
 530: 0003:     BCF.CCMVT.SERIAL.NUM$,\ 5 bytes ASC                                ! BMJK
 531: 0003:     BCF.TXR.SERIAL.NUM$,  \ 5 bytes transaction retrieval serial number!SWM
 532: 0003:     BCF.CUSTD.SERIAL.NUM$,\ 5 bytes customer data file serial number   !SWM
 533: 0003:     BCF.PSB58.DATE$,      \ 6 bytes date of last MTSL/CUSTW cut-off    !SWM
 534: 0003:     BCF.CTSL1.SERIAL.NUM$,\ 5 bytes serial number on first MTSLQ (and  ! 4.6 RC
 535: 0003:                           \         thereore CTSL1) batch header       ! 4.6 RC
 536: 0003:     BCF.MTSLQ.DAYS$,      \ 2 byte MTSLQ data retention period (PSB14) ! 4.6 RC
 537: 0003:     BCF.FILLER67$,        \ 8 bytes filler beginning at byte 67        ! 4.6 RC
 538: 0003:         BCF.NTIUF.SERIAL.NO$,                                           \   !FMG
 539: 0003:         BCF.DENTISTRY.PSAUDIT.SERIAL.NO$,                               \   !FMG
 540: 0003:         BCF.WELL.SERIAL.NO$,                                            \   !GMG
 541: 0003:         BCF.WELL.PSAUDIT.SERIAL.NO$,                                    \   !GMG
 542: 0003:     BCF.ACSAL.SERIAL.NUM$,\ 5 bytes serial number on ACSAL             !ESDH
 543: 0003:     BCF.DENTISTRY.PRODUCT.GROUP$,                                      \FMG
 544: 0003:     BCF.WELL.PRODUCT.GROUP$,                                           \GMG
 545: 0003:     BCF.FILLER$,         \! 1 byte, filler                             !BMJK
 546: 0003:     BCF.WELL.SERV.PRODUCT.GROUP$,                                      \KBG
 547: 0003:         BCF.ETOPUP.PROD.GRP$,                                           \   !LAH
 548: 0003:         BCF.END.FILLER$,                                                \   !LAH
 549: 0003:     BCF.TBAG.BATCH.NO$,                                                \IAH
 550: 0003:     BCF.TBAG.DAYS.KEPT$,                                               \IAH
 551: 0003:     BCF.NEWLINES.WEEKS$,                                               \4.7JAS
 552: 0003:     BCF.NEWLINES.LINES$,                                               \4.8JAS
 553: 0003:     BCF.TBAG.FILLER$,                                                  \ 79 Bytes filler !IAH 70 Bytes filler 4.7JAS ! 65 Bytes fille 4.8JAS
 554: 0003:     BCF.DEALDIR.SERIAL.NUM$, \ 4 bytes serial number                   !MJAS
 555: 0003:     BCF.DIDIR.SERIAL.NUM$,   \ 4 bytes serial number                   !MJAS
 556: 0003:     BCF.DEAL.NUM.REC$,       \ 6 bytes number of records in deal file  !MJAS
 557: 0003:     BCF.ITMDL.NUM.REC$,      \ 6 bytes number of records in ITMDL file !OCS
 558: 0003:     BCF.DEAL.KEY.LEN$,       \ 3 bytes key length of deal file         !MJAS
 559: 0003:     BCF.ITMDL.KEY.LEN$,      \ 3 bytes bytes ITMDL record key length   !OCS
 560: 0003:     BCF.DVCHR.SERIAL.NUM$,   \ 4 bytes serial numbr                    !NJT !4.10CSk
 561: 0003:     BCF.FILLER.DATETIMESTAMP$,\17 bytes filler for future use          !OCS
 562: 0003:     BCF.IUF.DATETIMESTAMP$, \ !17 bytes timestamp YYYYMMDDHHMMSSsss     !4.10CSk
 563: 0003:                             \ !   Last successfully processed IUF from SAP.
 564: 0003:         BCF.ITEM.STATUS$(1),     \1 byte array, item status             \   !OMW
 565: 0003:         BCF.NEGATIVE.STOCK.FLAG$(1), \1 byte array, Flag (Y/N) whether  \   !OMW
 566: 0003:                                  \   to include items with a negative   \   !OMW
 567: 0003:                                  \   stock figure in the initial stock  \   !OMW
 568: 0003:                                  \   snapshot messages.                 \   !OMW
 569: 0003:         BCF.POSITIVE.STOCK.FLAG$(1), \1 byte array, Flag (Y/N) whether  \   !OMW
 570: 0003:                                  \   to include items with a positive   \   !OMW
 571: 0003:                                  \   stock figure in the initial stock  \   !OMW
 572: 0003:                                  \   snapshot messages.                 \   !OMW
 573: 0003:         BCF.ZERO.STOCK.FLAG$(1)  !1 byte array, Flag (Y/N) whether to   \   !OMW
 574: 0003:                                  \   include items with a zero          \   !OMW
 575: 0003:                                  \   stock figure in the initial stock  \   !OMW
 576: 0003:                                  !   snapshot messages.                     !OMW
 577: 0003:                 
 578: 0003:     INTEGER*1                                                           \
 579: 0003:         BCF.NO.CPM.COPIES%
 580: 0003: 
 581: 0003:     INTEGER*2 GLOBAL                                                    \
 582: 0003:     BCF.CC.SERIAL.NO,        \ 1 byte UPD, CC serial number
 583: 0003:         BCF.MAX.STATUS.COUNT%,        \ Maximum number of item status   \   !OMW
 584: 0003:     BCF.REC21.REC.LEN%,      \ Total Supplier number length            !4.11 AS
 585: 0003:     BCF.REC21.SUPPLIER.LEN%, \ Length of the supplier number           !4.11 AS
 586: 0003:         BCF.MAX.STOCK.INIT.MESSAGES%, \ Maximum number of initial       \   !OMW
 587: 0003:                                       \ stock snapshot message to       \   !OMW
 588: 0003:                                       \ send per day.                   \   !OMW
 589: 0003:         BCF.MAX.STOCK.INIT.ITEMS%,    \ Maximum number of items to      \   !OMW
 590: 0003:                                       \ include in a single initial     \   !OMW
 591: 0003:                                       \ stock snapshot message.         \   !OMW
 592: 0003:         BCF.NEGATIVE.DAYS%(1),        \ Number of days' movements with  \   !OMW
 593: 0003:                                       \ a negative stock figure to      \   !OMW
 594: 0003:                                       \ include in the initial stock    \   !OMW
 595: 0003:                                       \ snapshot messages.              \   !OMW
 596: 0003:         BCF.POSITIVE.DAYS%(1),        \ Number of days' movements with  \   !OMW
 597: 0003:                                       \ a positive stock figure to      \   !OMW
 598: 0003:                                       \ include in the initial stock    \   !OMW
 599: 0003:                                       \ snapshot messages.              \   !OMW
 600: 0003:         BCF.REC22.REC.LEN%,           \                                 \   !4.12 CSk
 601: 0003:         BCF.REC22.PROD.GROUP.LEN%,    \ Length of GCM Product Group No  \   !4.12 CSk
 602: 0003:         BCF.ZERO.DAYS%(1)             \ Number of days' movements with  \   !OMW
 603: 0003:                                       \ a zero stock figure to include  \   !OMW
 604: 0003:                                       \ in the initial stock snapshot   \   !OMW
 605: 0003:                                       ! messages.                           !OMW
 606: 0003: 
 607: 0003: 
 608: 0003:     INTEGER*4 GLOBAL                                                    \
 609: 0003:         BCF.REC.NO%
 610: 0003: 
 611: 0003: %INCLUDE CIPPMDEC.J86   ! Markdown File
 612: 0003: \/******************************************************************/
 613: 0003: \/*                                                                */
 614: 0003: \/* CIPPM FILE GLOBAl VARIABLE DECLARATIONS                        */
 615: 0003: \/*                                                                */
 616: 0003: \/* REFERENCE   : CIPPMDEC.J86                                     */
 617: 0003: \/*                                                                */
 618: 0003: \/* VERSION A.          Neil Bennett.              16 APRIL 2007   */
 619: 0003: \/*                                                                */
 620: 0003: \/******************************************************************/
 621: 0003: 
 622: 0003:    STRING GLOBAL                \
 623: 0003:       CIPPM.BKUP.NAME$,         \
 624: 0003:       CIPPM.FILE.NAME$,         \
 625: 0003:                                 \
 626: 0003:       CIPPM.RCD$                !
 627: 0003: 
 628: 0003:    INTEGER*2 GLOBAL             \
 629: 0003:       CIPPM.REPORT.NUM%,        \
 630: 0003:       CIPPM.SESS.NUM%           !
 631: 0003: 
 632: 0003: \/******************************************************************/
 633: 0003: %INCLUDE DRUGDEC.J86    ! Drug File
 634: 0003: REM \
 635: 0003: \******************************************************************************
 636: 0003: \******************************************************************************
 637: 0003: \***
 638: 0003: \***         %INCLUDE FOR DRUG FILE - FIELD DECLARATIONS
 639: 0003: \***                                  FILE REFERENCE PARAMETERS
 640: 0003: \***
 641: 0003: \***                  FILE TYPE    : Keyed
 642: 0003: \***
 643: 0003: \***                  REFERENCE    : DRUGDEC.J86
 644: 0003: \***
 645: 0003: \***         VERSION A : Nalini Mathusoothanan     12 July 2011
 646: 0003: \***
 647: 0003: \***    Holds stock counting details for ethical lines.
 648: 0003: \*******************************************************************************
 649: 0003: \*******************************************************************************
 650: 0003: 
 651: 0003:   STRING GLOBAL           \
 652: 0003:     DRUG.FILE.NAME$,      \ DRUG file name - DRUG.BIN
 653: 0003:     DRUG.ITEM.CODE$,      \ 3  byte UPD Boots item code (excluding check digit)
 654: 0003:     DRUG.DESCRIPTION$,    \ 40 byte ASC Drug Description
 655: 0003:     DRUG.FILLER$          \ Filler - packed zeroes
 656: 0003: 
 657: 0003:   INTEGER*1 GLOBAL        \
 658: 0003:     DRUG.BIT.FLAGS.1%     \ 1 byte - bit values
 659: 0003:                           \ X"80"  - Active in store (load into POD)
 660: 0003:                           \ X"40"  - Reserved for future use
 661: 0003:                           \ X"20"  - Reserved for future use
 662: 0003:                           \ X"10"  - Reserved for future use
 663: 0003:                           \ X"08"  - Reserved for future use
 664: 0003:                           \ X"04"  - Reserved for future use
 665: 0003:                           \ X"02"  - Reserved for future use
 666: 0003:                           \ X"01"  - Reserved for future use
 667: 0003: 
 668: 0003:   INTEGER*2 GLOBAL        \
 669: 0003:     DRUG.RECL%,           \ Record Length - 56
 670: 0003:     DRUG.REPORT.NUM%,     \ Drug File session Report Number
 671: 0003:     DRUG.SESS.NUM%        \ Drug File Session Number
 672: 0003: 
 673: 0003:   INTEGER*4 GLOBAL        \
 674: 0003:     DRUG.PACK.SIZE%       ! The number of tablets, or the weight, or the volume
 675: 0003: %INCLUDE IDFDEC.J86     ! Item Data File
 676: 0003: REM \
 677: 0003: \******************************************************************************
 678: 0003: \******************************************************************************
 679: 0003: \***
 680: 0003: \***         %INCLUDE FOR ITEM DATA FILE - FIELD DECLARATIONS
 681: 0003: \***                                       FILE REFERENCE PARAMETERS
 682: 0003: \***
 683: 0003: \***                  FILE TYPE    : Keyed
 684: 0003: \***
 685: 0003: \***                  REFERENCE    : IDFDEC.J86
 686: 0003: \***
 687: 0003: \***         VERSION A : Andrew Wedgeworth  29th June 1992    
 688: 0003: \***
 689: 0003: \***    VERSION C.              Robert Cowey.                       25 AUG 1993.
 690: 0003: \***    Replaced un-used RANK$ with BSNS.CNTR$ and FILLER$.
 691: 0003: \***
 692: 0003: \***    VERSION D.              Andrew Wedgeworth               15th March 1995
 693: 0003: \***    Comments updated to reflect the fact that some bits on the file are
 694: 0003: \***    no longer used.
 695: 0003: \***
 696: 0003: \*******************************************************************************
 697: 0003: \*******************************************************************************
 698: 0003: 
 699: 0003:   STRING GLOBAL           \
 700: 0003:     IDF.FILE.NAME$,       \  
 701: 0003:     IDF.BOOTS.CODE$,      \ 4 byte UPD with check digit (key)
 702: 0003:     IDF.FIRST.BAR.CODE$,  \ 6 byte UPD without check digit
 703: 0003:     IDF.SECOND.BAR.CODE$, \ 6 byte UPD without check digit
 704: 0003:     IDF.NO.OF.BAR.CODES$, \ 2 byte UPD. Total number of bar codes for this item
 705: 0003:     IDF.PRODUCT.GRP$,     \ 3 byte UPD. The first two digits are the concept
 706: 0003:                           \ group and the last four the concept sequence
 707: 0003:     IDF.STNDRD.DESC$,     \ 24 bytes
 708: 0003:     IDF.STATUS.1$,        \ 1 byte, values B,C,D,P,X,Z and blank
 709: 0003:     IDF.INTRO.DATE$,      \ 3 byte UPD YYMMDD. Date first added to this file
 710: 0003:     IDF.BSNS.CNTR$,       \ 1 byte ASC. Business Centre ID letter      ! CRC
 711: 0003:     IDF.FILLER$,          \ 1 byte un-used                             ! CRC
 712: 0003:     IDF.PARENT.CODE$,     \ 4 byte UPD with check digit ; may be zero if no
 713: 0003:                           \ flashpacks, current IDF.BOOTS.CODE$ if parent line
 714: 0003:                           \ or Boots Code of parent line if a flashpack.
 715: 0003:     IDF.DATE.OF.LAST.SALE$! 3 byte UPD. Date of last sale.
 716: 0003: 
 717: 0003:   INTEGER*1 GLOBAL        \
 718: 0003:     IDF.BIT.FLAGS.1%,     \ 1 byte - bit values
 719: 0003:                           \ X"80"  - Group code flag
 720: 0003:                           \ X"40"  - Keylines flag
 721: 0003:                           \ X"20"  - Markdown flag
 722: 0003:                           \ X"10"  - Warehouse flag
 723: 0003:                           \ X"08"  - CSR flag
 724: 0003:                           \ X"04"  - Directs A flag
 725: 0003:                           \ X"02"  - Directs B flag
 726: 0003:                           \ X"01"  - Directs C flag
 727: 0003:     IDF.BIT.FLAGS.2%      \ 1 byte - bit values
 728: 0003:                           \ X"80"  - Own brand line flag
 729: 0003:                           \ X"40"  - Exclusive line flag
 730: 0003:                           \ X"20"  - Unused 
 731: 0003:                           \ X"10"  - Unused
 732: 0003:                           \ X"08"  - Stock system flag
 733: 0003:                           \ X"04"  - Pending count flag
 734: 0003:                           \ X"02"  - Reserved
 735: 0003:                           ! X"01"  - Reserved
 736: 0003: 
 737: 0003:   INTEGER*2 GLOBAL        \
 738: 0003:     IDF.RECL%,            \  
 739: 0003:     IDF.REPORT.NUM%,      \ 
 740: 0003:     IDF.SESS.NUM%
 741: 0003: %INCLUDE IEFDEC.J86     ! Item EAN File
 742: 0003: REM \
 743: 0003: \******************************************************************************
 744: 0003: \******************************************************************************
 745: 0003: \***
 746: 0003: \***         %INCLUDE FOR ITEM EAN CODES FILE - FIELD DECLARATIONS
 747: 0003: \***                                            FILE REFERENCE PARAMETERS
 748: 0003: \***
 749: 0003: \***               FILE TYPE    : Keyed
 750: 0003: \***
 751: 0003: \***               REFERENCE    : IEFDEC.J86
 752: 0003: \***
 753: 0003: \***    VERSION B.              ROBERT COWEY.                       21 OCT 1993.
 754: 0003: \***    No changes to this file.
 755: 0003: \***
 756: 0003: \*******************************************************************************
 757: 0003: \*******************************************************************************
 758: 0003: 
 759: 0003:   STRING GLOBAL                      \
 760: 0003:     IEF.FILE.NAME$,		     \
 761: 0003:     IEF.BOOTS.CODE.BAR.CODE$,        \ 9 byte UPD -                        BBAAS
 762: 0003:                                      \ 3 bytes UPD boots code              BBAAS   
 763: 0003:                                      \ + 6 UPD bar code,                   BBAAS
 764: 0003:                                      \ no check digits. (key)              BBAAS
 765: 0003:     IEF.NEXT.BAR.CODE$               ! 6 byte UPD without check digit
 766: 0003: 
 767: 0003:   INTEGER*2 GLOBAL        \
 768: 0003:     IEF.REPORT.NUM%,	  \
 769: 0003:     IEF.SESS.NUM%,	  \ 
 770: 0003:     IEF.RECL%
 771: 0003: %INCLUDE IEXDEC.J86     ! Item Extension File
 772: 0003: REM \
 773: 0003: \******************************************************************************
 774: 0003: \******************************************************************************
 775: 0003: \***
 776: 0003: \***         %INCLUDE FOR Item Extension FILE - FIELD DECLARATIONS
 777: 0003: \***                                            FILE REFERENCE PARAMETERS
 778: 0003: \***
 779: 0003: \***                  FILE TYPE    : Keyed
 780: 0003: \***
 781: 0003: \***                  REFERENCE    : DRUGDEC.J86
 782: 0003: \***
 783: 0003: \***         VERSION A :       Nalini Mathusoothanan                12 July 2011
 784: 0003: \***
 785: 0003: \***    Holds the Stock Supplier Number.
 786: 0003: \*******************************************************************************
 787: 0003: \*******************************************************************************
 788: 0003: 
 789: 0003:   STRING GLOBAL               \
 790: 0003:     IEX.FILE.NAME$,           \ IEX file name - IEX.BIN
 791: 0003:     IEX.ITEM.CODE$,           \ 3  byte UPD Boots Item Code (no check digit)
 792: 0003:     IEX.ACTUAL.SUPPLIER.NUM$, \ 4  byte UPD Actual Last Supplier Number
 793: 0003:     IEX.PRIMARY.SUPPLIER$,    \ 4  byte UPD Primary Supplier Number
 794: 0003:     IEX.FILLER$               \ 17 byte UPD Filler - packed zeroes
 795: 0003: 
 796: 0003:   INTEGER*2 GLOBAL        \
 797: 0003:     IEX.RECL%,            \ Record Length - 28
 798: 0003:     IEX.REPORT.NUM%,      \ Drug File session Report Number
 799: 0003:     IEX.SESS.NUM%         \ Drug File Session Number
 800: 0003: 
 801: 0003: 
 802: 0003: %INCLUDE IRFDEC.J86     ! Item Reference File
 803: 0003: 
 804: 0003: \**********************************************************************************
 805: 0003: \***
 806: 0003: \***       %INCLUDE FOR ITEM RECORD FILE - FIELD DECLARATIONS
 807: 0003: \***                                     - FILE REFERENCE PARAMETERS
 808: 0003: \***
 809: 0003: \***                      FILE TYPE    : Keyed
 810: 0003: \***
 811: 0003: \***                      REFERENCE    : IRFDEC.J86
 812: 0003: \***
 813: 0003: \***     Version A               Andrew Wedgeworth            29th June 1992
 814: 0003: \***
 815: 0003: \***     Version B               Andrew Wedgeworth        14th December 1992
 816: 0003: \***     Version letter incremented to match other IRF code.
 817: 0003: \***
 818: 0003: \***     Version C             Steve Windsor          12.02.93
 819: 0003: \***     Version letter incremented to match other IRF code.
 820: 0003: \***
 821: 0003: \***     Version D             Steve Windsor          12.05.93
 822: 0003: \***     Version letter incremented to match other IRF code.
 823: 0003: \***
 824: 0003: \***     Version E           Steve Perkins       20th September 1993
 825: 0003: \***     Deals project : Handling of Converted/Unconverted records
 826: 0003: \***     ++   Anything with 'Delete' after initials should be   ++
 827: 0003: \***     ++   deleted once the IRF has been converted in all    ++
 828: 0003: \***     ++   stores.                                           ++
 829: 0003: \***
 830: 0003: \***     Version F           Mark Walker            5th January 1994
 831: 0003: \***     Version letter incremented to match other IRF code.
 832: 0003: \***
 833: 0003: \***     Version 96A         Mark Walker               22nd May 1995
 834: 0003: \***     Definition for IRF.POINTS% added.
 835: 0003: \***
 836: 0003: \***                     Stuart McConnachie           12th June 1995
 837: 0003: \***     INDICAT3% comments added for discount/loyalty flags.
 838: 0003: \***
 839: 0003: \***     Version for 96C  Andrew Wedgeworth            22nd May 1996
 840: 0003: \***     Removed IRF.FILLER$ field, as this is now redundant.
 841: 0003: \***
 842: 0003: \***     Version G     Stuart William McConnachie      11th February 2000
 843: 0003: \***     Converted IRF.INDICAT2$ to integer flag byte.
 844: 0003: \***
 845: 0003: \***     REVISION 1.6.               ROBERT COWEY.               9 JUL 2002.
 846: 0003: \***     Major changes for 2002 Deals Rewrite project.
 847: 0003: \***     Incorporated up to date record layout to assist development work
 848: 0003: \***     (placed in the IRFDEC.J86 to make it visible from ...LST files).
 849: 0003: \***     Moved various comments against variables to record layout.
 850: 0003: \***     Relisted variables in alphabetical order.
 851: 0003: \***     Deleted redundant variables associated with the old deals system ...
 852: 0003: \***     DEAL.NUM$, DEAL.SAVING$
 853: 0003: \***     Retained variables that are otherwise redundant (to be set to null X'00'
 854: 0003: \***     within file functions) ...
 855: 0003: \***     INDICAT2%, INDICAT4%, SALEQUAN$, POINTS%
 856: 0003: \***     Defined variables to hold interpreted deals data for new deals system ...
 857: 0003: \***     DEAL.NUM$(n) and LIST.ID%(n) (where 'n' represents entry 0, 1 and 2).
 858: 0003: \***     These two variables are interpretations of DEAL.DATA% which is defined
 859: 0003: \***     locally within IRFFUN.BAS to keep underlying data invisible to programs.
 860: 0003: \***
 861: 0003: \***     REVISION 1.7                ROBERT COWEY.               5 AUG 2002.
 862: 0003: \***     Further changes for 2002 Deals Rewrite project (PSBF19 related).
 863: 0003: \***     Defined NEW.IRF.DATA$ as a global variable for use with new functions
 864: 0003: \***     CONCAT.NEW.IRF.DATA$ and SPLIT.NEW.IRF.DATA$.
 865: 0003: \***
 866: 0003: \***     REVISION 1.8                ROBERT COWEY.              15 JUL 2003.
 867: 0003: \***     Usage of INDICAT0% bit-3 X'08' changed to Item Contains Alcohol.
 868: 0003: \***     No changes to this file other than description.
 869: 0003: \***     No changes to IRF file functions.
 870: 0003: \***
 871: 0003: \***     REVISION 1.9.      STUART WILLIAM MCCONNACHIE           22 OCT 2003.
 872: 0003: \***     Changes to remove limit of 3 deals per item.
 873: 0003: \***     Declaration of new variables for IRF Deal Extension file (IRFDEX).
 874: 0003: \***
 875: 0003: \***     REVISION 2.0.            ALAN CARR                       9 FEB 2006.
 876: 0003: \***     Add new IRF.INDICAT8% 1 byte, amend IRF.UNUSED$ from 3 to 2 bytes.
 877: 0003: \***
 878: 0003: \***     REVISION 2.1              TITTOO THOMAS                  01 July 2011
 879: 0003: \***     The IRF.UNUSED field is disintegrated to 2 new indicator fields
 880: 0003: \***                      IRF.INDICAT9%   1 INT
 881: 0003: \***                      IRF.INDICAT10%  1 INT
 882: 0003: \***...............................................................................
 883: 0003: 
 884: 0003: 
 885: 0003: \**********************************************************************************
 886: 0003: \***
 887: 0003: \***    IRF RECORD LAYOUT - REVISION 1.7 - CORRECT FOR 2011 CORE Stores PROJECT
 888: 0003: \***
 889: 0003: \***     1 11  UPD  BAR.CODE$   Without check digit - File KEY
 890: 0003: \***    12  1  INT  INDICAT0%
 891: 0003: \***                    X"01" - Contains statins                           ! 2.2 TT
 892: 0003: \***                    X"02" - Item not priced (giveaway)
 893: 0003: \***                    X"04" - Item not returnable
 894: 0003: \***                    X"08" - Item contains alcohol
 895: 0003: \***                    X"10" - Blocked from sale                          ! 2.2 TT
 896: 0003: \***                    X"20" - Enforced price entry
 897: 0003: \***                    X"40" - Enforced quantity entry
 898: 0003: \***                    X"80" - Movement kept
 899: 0003: \***    13  1  INT  INDICAT1%
 900: 0003: \***                    X"01" - Asprin
 901: 0003: \***                    X"02" - Paracetamol
 902: 0003: \***                    X"04" - TPLU inclusion flag
 903: 0003: \***                    X"08" - Giftcard item                              ! 2.2 TT
 904: 0003: \***                    X"10" - Withdrawn Block from sale                  ! 2.2 TT
 905: 0003: \***                    X"20" - Non-solid dose painkiller                  ! 2.2 TT
 906: 0003: \***                    X"40" - Insurance policy item                      ! 2.2 TT
 907: 0003: \***                    X"80" - Ibuprofen
 908: 0003: \***    14  2  INT  DEAL.DATA%(0)   Interpreted into sub-variables ...
 909: 0003: \***                    X'3F' - into DEAL.NUM$(0) "0000" to "9999" (2 byte UPD)
 910: 0003: \***                    X'C0' - into LIST.ID%(0) X'00' X
 911: 0003: \***                                             X'01' A
 912: 0003: \***                                             X'10' B
 913: 0003: \***                                             X'11' C                   ! 1.9 RC
 914: 0003: \***    16  1  INT  INDICAT8%                                              ! 2.0 AJC
 915: 0003: \***                    X"01" - Chlamydia NHS test kit                     ! 2.2 TT
 916: 0003: \***                    X"02" - Chlamydia open sell test kit               ! 2.2 TT
 917: 0003: \***                    X"04" - Unrestricted group code                    ! 2.2 TT
 918: 0003: \***                    X"08" - Nightingale Till prompt                    ! 2.2 TT
 919: 0003: \***                    X"10" - Contains Ephedrine                         ! 2.2 TT
 920: 0003: \***                    X"60" -  X'00' - If also Blocked From Sale Recall, ! 2.2 TT
 921: 0003: \***                                        Emergency                      ! 2.2 TT
 922: 0003: \***                             X'00' - If NOT Blocked From Sale Recall,  ! 2.2 TT
 923: 0003: \***                                        No recall                      ! 2.2 TT
 924: 0003: \***                             X'20' 100% returns                        ! 2.2 TT
 925: 0003: \***                             X'40' Withdrawn recall                    ! 2.2 TT
 926: 0003: \***                             X'60' Reverse Logistics                   ! 2.2 TT
 927: 0003: \***                    X"80" - WEEE item flag                             ! 2.0 AJC
 928: 0003: \***    17  1  INT  INDICAT9%
 929: 0003: \***                    X'3F' - Disposal special instruction (0-63)
 930: 0003: \***                    X"40" - Resaleable Indicator
 931: 0003: \***                    X"80" - Boots.com Extended Indicator
 932: 0003: \***    18  1  INT  INDICAT10%
 933: 0003: \***                    X'07' - Age restrictions
 934: 0003: \***                             X'00' - No Age restriction
 935: 0003: \***                             X'01' - Age 12 or over
 936: 0003: \***                             X'02' - Age 15 or over
 937: 0003: \***                             X'03' - Age 16 or over
 938: 0003: \***                             X'04' - Age 18 or over
 939: 0003: \***                             X'05' - Age 21 or over
 940: 0003: \***                             X'06' - Reserved
 941: 0003: \***                             X'07' - Reserved
 942: 0003: \***                    X'38' - Ethical classification
 943: 0003: \***                             X'00' - No ethical classification
 944: 0003: \***                             X'08' - Pharmacy medicine (P)
 945: 0003: \***                             X'10' - General Sale License (GSL)
 946: 0003: \***                             X'18' - Prescription Only Medicine (POM)
 947: 0003: \***                             X'20' - Reserved
 948: 0003: \***                             X'28' - Reserved
 949: 0003: \***                             X'30' - Reserved
 950: 0003: \***                             X'38' - Reserved
 951: 0003: \***                    X'C0' - Returns route
 952: 0003: \***                             X'00' - Not Returnable (Destroy)
 953: 0003: \***                             X'40' - Returns & Recovery
 954: 0003: \***                             X'80' - Direct
 955: 0003: \***                             X'C0' - Semi-centralised
 956: 0003: \***    19  5  UPD  SALEPRIC$   Current price in pence
 957: 0003: \***    24  1  INT  INDICAT5%   Guarantee duration
 958: 0003: \***                    X'3F' - Lowest 6 bits indicate duration (1-63)
 959: 0003: \***                    X'40' - Contains Pseudoephedrine                   ! 2.2 TT
 960: 0003: \***                    X'80' - Guarantee Duration Type                    ! 2.2 TT
 961: 0003: \***                              (1 = Months, 0 = Years)                  ! 2.2 TT
 962: 0003: \***    25 18  ASC  ITEMNAME$   Description used by till
 963: 0003: \***    43  3  UPD  BOOTS.CODE$ Without check digit
 964: 0003: \***    46  2  INT  DEAL.DATA%(1)   Similar structure to DEAL.DATA%(0)
 965: 0003: \***    48  2  INT  DEAL.DATA%(2)   Similar structure to DEAL.DATA%(0)
 966: 0003: \***    50  1  INT  INDICAT3%
 967: 0003: \***                    X"01" - Discountexempt (item exempt from discount)
 968: 0003: \***                    X"02" - Boots brand item
 969: 0003: \***                    X"04" - Item redeemable for loyalty
 970: 0003: \***                    X"08" - Loyalty exempt (item exempt from loyalty)
 971: 0003: \***                    X"10" - **Redundant                                ! 2.2 TT
 972: 0003: \***                    X"20" - Local Price active
 973: 0003: \***                    X"40" - Stock system item
 974: 0003: \***                    X"80" - **Redundant                                ! 2.2 TT
 975: 0003: \***
 976: 0003: \***    Record Length 50
 977: 0003: \***
 978: 0003: \***
 979: 0003: \***    IRF DEAL EXTENSION RECORD LAYOUT ! 1.9 RC
 980: 0003: \***
 981: 0003: \***     1  3  UPD  BOOTS.CODE$
 982: 0003: \***     4  2  INT  IRF.DEAL.DATA%(3)   Similar structure to DEAL.DATA%(0)
 983: 0003: \***     6  2  INT  IRF.DEAL.DATA%(4)   Similar structure to DEAL.DATA%(0)
 984: 0003: \***     8  2  INT  IRF.DEAL.DATA%(5)   Similar structure to DEAL.DATA%(0)
 985: 0003: \***    10  2  INT  IRF.DEAL.DATA%(6)   Similar structure to DEAL.DATA%(0)
 986: 0003: \***    12  2  INT  IRF.DEAL.DATA%(7)   Similar structure to DEAL.DATA%(0)
 987: 0003: \***    14  2  INT  IRF.DEAL.DATA%(8)   Similar structure to DEAL.DATA%(0)
 988: 0003: \***    16  2  INT  IRF.DEAL.DATA%(9)   Similar structure to DEAL.DATA%(0)
 989: 0003: \***
 990: 0003: \***    Record Length 17
 991: 0003: \***
 992: 0003: \**********************************************************************************
 993: 0003: 
 994: 0003: 
 995: 0003:     STRING GLOBAL            \
 996: 0003:         IRF.ALT.FILE.NAME$,  \
 997: 0003:         IRF.BAR.CODE$,       \
 998: 0003:         IRF.BOOTS.CODE$,     \
 999: 0003:         IRF.DEAL.SAVING$,    \ 2 byte - deal saving amount (0 - 99.99) ! ESP
1000: 0003:         IRF.DEPARTME$,       \ 3 byte UPD. Department number          ! ESP Delete
1001: 0003:         IRF.FILE.NAME$,      \
1002: 0003:         IRF.HOLDING.PRICE$,  \ 4 byte UPD. Current H.O. price in pence if a local
1003: 0003:                              \ price is in effect, zero otherwise.     ! ESP Delete
1004: 0003:         IRF.ITEMNAME$,       \
1005: 0003: \       IRF.MPGROUP$,        \ Removed SBH 31/1/96
1006: 0003:         IRF.RECORD$,         \                                         ! ESP Delete
1007: 0003:         IRF.SALEPRIC$,       \
1008: 0003:         IRF.SALEQUAN$,       \ Redundant (set to null within functions)    ! 1.6 RC
1009: 0003:         IRF.UNUSED$,         \                                                        ! 1.6 RC
1010: 0003:         NEW.IRF.DATA$        !                                             ! 1.7 RC
1011: 0003: 
1012: 0003:     STRING GLOBAL            \                                             ! 1.6 RC
1013: 0003:         IRF.DEAL.NUM$(1)                                                   ! 1.6 RC
1014: 0003: 
1015: 0003:     INTEGER*1 GLOBAL         \
1016: 0003:         IRF.DD.SUB%,         \ IRF.DEAL.DATA% subscript                    ! 1.6 RC
1017: 0003:         IRF.INDICAT0%,       \
1018: 0003:         IRF.INDICAT1%,       \
1019: 0003:         IRF.INDICAT2%,       \ Redundant (set to null within functions)    ! 1.6 RC
1020: 0003:         IRF.INDICAT3%,       \
1021: 0003:         IRF.INDICAT4%,       \ Redundant (set to null within functions)    ! 1.6 RC
1022: 0003:         IRF.INDICAT5%,       \                                             ! 2.0 AJC
1023: 0003:         IRF.INDICAT8%,       \                                             ! 2.0 AJC
1024: 0003:         IRF.INDICAT9%,       \                                             ! 2.2 TT
1025: 0003:         IRF.INDICAT10%                                                     ! 2.2 TT
1026: 0003: 
1027: 0003:     INTEGER*1 GLOBAL         \                                             ! 1.6 RC
1028: 0003:         IRF.LIST.ID%(1)                                                    ! 1.6 RC
1029: 0003: 
1030: 0003:     INTEGER*2 GLOBAL         \
1031: 0003:         IRF.ALT.REPORT.NUM%, \
1032: 0003:         IRF.ALT.SESS.NUM%,   \
1033: 0003:         IRF.POINTS%,         \ Redundant (set to null within functions)    ! 1.6 RC
1034: 0003:         IRF.RECL%,           \
1035: 0003:         IRF.REPORT.NUM%,     \
1036: 0003:         IRF.SESS.NUM%,       \
1037: 0003:         IRF.MAX.DEALS%       !                                             ! 1.9 SM
1038: 0003: 
1039: 0003:     STRING GLOBAL IRFDEX.FILE.NAME$                                        ! 1.9 SM
1040: 0003: 
1041: 0003:     INTEGER*2 GLOBAL IRFDEX.SESS.NUM%                                      ! 1.9 SM
1042: 0003:     INTEGER*2 GLOBAL IRFDEX.REPORT.NUM%                                    ! 1.9 SM
1043: 0003:     INTEGER*2 GLOBAL IRFDEX.RECL%                                          ! 1.9 SM
1044: 0003: 
1045: 0003: 
1046: 0003: !   INTEGER*2 GLOBAL      \ IRF.DEAL.DATA%(n) variables are defined locally  1.6 RC
1047: 0003: !       IRF.DEAL.DATA%(1) \ within IRFFUN.BAS to keep invisible to programs  1.6 RC
1048: 0003: 
1049: 0003: %INCLUDE ITGRPDEC.J86   ! IRF Attribute Extension File                  !HRN
1050: 0003: \***********************************************************************
1051: 0003: \***********************************************************************
1052: 0003: \***
1053: 0003: \***    DESCRIPTION: IRFITGRP (IRF Attribute Extension File)
1054: 0003: \***                 Field Definitions
1055: 0003: \***
1056: 0003: \***    FILE TYPE : Keyed
1057: 0003: \***
1058: 0003: \***********************************************************************
1059: 0003: \***
1060: 0003: \***    Version A.              Rejiya Nair             12th May 2016
1061: 0003: \***    PRJ1452 Restricting Item Sales
1062: 0003: \***    Initial version.
1063: 0003: \***
1064: 0003: \***********************************************************************
1065: 0003: \***********************************************************************
1066: 0003: 
1067: 0003: \***********************************************************************
1068: 0003: \***********************************************************************
1069: 0003: \***
1070: 0003: \***    File Record Layout
1071: 0003: \***
1072: 0003: \***    IRFITGRP.ITEM.CODE$          3 UPD  Item code (Key)
1073: 0003: \***    IRFITGRP.GROUP.NO%           1 INT  Group number of the item
1074: 0003: \***
1075: 0003: \***********************************************************************
1076: 0003: \***********************************************************************
1077: 0003: 
1078: 0003:     INTEGER*2 GLOBAL                                                   \
1079: 0003:         IRFITGRP.KEYL%,                                                \
1080: 0003:         IRFITGRP.RECL%,                                                \
1081: 0003:         IRFITGRP.REPORT.NUM%,                                          \
1082: 0003:         IRFITGRP.SESS.NUM%
1083: 0003: 
1084: 0003:     INTEGER*1 GLOBAL                                                   \
1085: 0003:         IRFITGRP.GROUP.NO%,                                            \
1086: 0003:         IRFITGRP.OPEN
1087: 0003: 
1088: 0003:     STRING GLOBAL                                                      \
1089: 0003:         IRFITGRP.FILE.NAME$,                                           \
1090: 0003:         IRFITGRP.ITEM.CODE$
1091: 0003: %INCLUDE ISFDEC.J86     ! Item Shelf Edge Label Description File
1092: 0003: REM \
1093: 0003: \******************************************************************************
1094: 0003: \******************************************************************************
1095: 0003: \***
1096: 0003: \***         %INCLUDE FOR ITEM SHELF EDGE DESCRIPTION FILE 
1097: 0003: \***
1098: 0003: \***               - FILE REFERENCE PARAMETERS
1099: 0003: \***               - FIELD DECLARATIONS
1100: 0003: \***
1101: 0003: \***               FILE TYPE    : Keyed  
1102: 0003: \***
1103: 0003: \***               REFERENCE    : ISFDEC.J86
1104: 0003: \***
1105: 0003: \******************************************************************************
1106: 0003: \******************************************************************************
1107: 0003: 
1108: 0003:   INTEGER*4 GLOBAL        \
1109: 0003:     ISF.INTEGER.4%,       \ BRD
1110: 0003:     IUDF.FILE.SIZE%       ! BRD
1111: 0003:   
1112: 0003:   INTEGER*2 GLOBAL        \
1113: 0003:     ISF.SESS.NUM%,        \
1114: 0003:     ISF.REPORT.NUM%,      \ 
1115: 0003:     ISF.RECL%,            \
1116: 0003:     ISF.INTEGER.2%        ! BRD
1117: 0003:     
1118: 0003:   INTEGER*2               \ BRD
1119: 0003:     IUDF.REPORT.NUM%,     \ BRD
1120: 0003:     IUDF.SESS.NUM%,       \ BRD
1121: 0003:     IUDF.RECL%,           \ BRD
1122: 0003:     UNIT.NAME.COUNTER%,   \ BRD
1123: 0003:     IUDF.RECORD.POSITION%,\ BRD
1124: 0003:     PRINT.FLAG%           ! BRD
1125: 0003:     
1126: 0003:     
1127: 0003:   STRING GLOBAL           \
1128: 0003:     ISF.BOOTS.CODE$,      \ 4 byte UPD with check digit (key)
1129: 0003:     ISF.S.E.DESC$,        \ 45 bytes. Shelf edge description
1130: 0003:     ISF.ITEM.QTY$,        \ 4 byte UPD. Shelf Item Qty
1131: 0003:     ISF.UNIT.MEASUREMENT$,\ 2 byte UPD. Unit Measurement
1132: 0003:     ISF.UNIT.NAME$,       \ 10 bytes. Unit Name eg. 'ml'
1133: 0003:     ISF.SEL.PRINTED.FLAG$,\ 1 byte UPD. Last printed version
1134: 0003:     ISF.FILE.NAME$,       \
1135: 0003:     IUDF.RECORD$          ! CCS
1136: 0003:     
1137: 0003:   STRING                  \
1138: 0003:     RECORD.FORMAT$,       \ BRD
1139: 0003:     IUDF.FILE.NAME$ !,      \ BRD
1140: 0003:     ! IUDF.RECORD$          ! BRD
1141: 0003: 
1142: 0003: %INCLUDE IUFDEC.J86     ! Item Update File
1143: 0003: \REM
1144: 0003: \*******************************************************************************
1145: 0003: \*******************************************************************************
1146: 0003: \***
1147: 0003: \***    %INCLUDE FOR ITEM UPDATE FILES VARIABLE DECLARATIONS
1148: 0003: \***
1149: 0003: \***        REFERENCE   :   IUFDEC (J86)
1150: 0003: \***
1151: 0003: \***        FILE TYPE   :   Sequential
1152: 0003: \***
1153: 0003: \***    VERSION H.              ROBERT COWEY.                       24 AUG 1993.
1154: 0003: \***    Original version created by combining IUFFLDG and IUFNUMG.
1155: 0003: \***
1156: 0003: \***    VERSION I.              ROBERT COWEY.                       25 AUG 1993.
1157: 0003: \***    Added NEW.DEAL.COUNT$ and BC.LETTER$ to record type "001" (Item
1158: 0003: \***    reference).
1159: 0003: \***    Removed falconcraft detail variables (SALESPLAN.ID$, BUS.CENTRE$,
1160: 0003: \***    START.DATE$, END.DATE$, TICKET.TYPE$, GENOF.NUM$, GENOF.DESC$,
1161: 0003: \***    FOOTER.TYPE$) from record types "003" (Deal price) and "004" (Item
1162: 0003: \***    pending).
1163: 0003: \***    Defined record type "006" (Deals).
1164: 0003: \***
1165: 0003: \***    VERSION J.              Andrew Wedgeworth                13th March 1995
1166: 0003: \***    Focus flag, Price Pledge flag and ASCOTT/COMPASS flag replaced with
1167: 0003: \***    fields for the Staff Discount, Customer Loyalty and Give-away systems.
1168: 0003: \***
1169: 0003: \***    VERSION K               Rebecca Dakin                    28th June 1999
1170: 0003: \***
1171: 0003: \***    Version L        Andy Cotton & Amy Hoggard     29th Jan 2003
1172: 0003: \***    Change use and name of variable IUF.DEAL.PRICE.FLAG$ to IUF.KEYLINES.FLAG$
1173: 0003: \***
1174: 0003: \***    Version M               Brian Greenfield                 25th June 2004
1175: 0003: \***    Added new IUF.MARKDOWN$ tor use with SEL Markdown flagged items.
1176: 0003: \***
1177: 0003: \***    Version 1.6           Charles Skadorwa                 4th July 2011
1178: 0003: \***    CORE Heritage Stores Release 2 (Outbound) Project.
1179: 0003: \***    Added new globals.
1180: 0003: \***
1181: 0003: \***    VERSION 1.7.                ROBERT COWEY.                07 FEB 2012.
1182: 0003: \***    Changes creating PSB21.286 Core Release 2 version 1.5.
1183: 0003: \***
1184: 0003: \***    Defect 21 - Commented 1.9 RC (21).
1185: 0003: \***    Commented real meaning of IUF.DISCOUNTABLE$ as Discount Exempt.
1186: 0003: \***
1187: 0003: \***    VERSION 1.8.                ROBERT COWEY.                20 FEB 2012.
1188: 0003: \***    Changes creating PSB21.286 Core Release 2 version 1.6.
1189: 0003: \***    Correction relating to transformation of legacy IUF data to Core R2 format
1190: 0003: \***
1191: 0003: \***    Defect 44 - Commented 1.11 RC (44).
1192: 0003: \***    Replaced variables HEALTH.CONCEPT.GROUPS$ and HEALTH.GROUP$ with more
1193: 0003: \***    meaningfully named single variable INSURE.CONCEPT.GROUPS$.
1194: 0003: \***
1195: 0003: \***    VERSION B               Rejiya Nair             13th May 2016
1196: 0003: \***    PRJ1452 Restricting Item Sales
1197: 0003: \***    - Declaration of two new variables (version tagged as !BRN)
1198: 0003: \***    - Removed the commented out code
1199: 0003: \***
1200: 0003: \*******************************************************************************
1201: 0003: \*******************************************************************************
1202: 0003: 
1203: 0003: 
1204: 0003: \*******************************************************************************
1205: 0003: \*******************************************************************************
1206: 0003: \***
1207: 0003: \***    RECORD LAYOUTS
1208: 0003: \***
1209: 0003: \***    HEADER RECORD
1210: 0003: \***
1211: 0003: \***     1  7  ASC  BOOTS.CODE$
1212: 0003: \***     8  3  ASC  TRANS.TYPE$             "000" Header
1213: 0003: \***    11  4  ASC  IUF.BRANCH.NO$
1214: 0003: \***    15  5  ASC  IUF.SERIAL.NO$
1215: 0003: \***
1216: 0003: \***    ITEM REFERENCE RECORD
1217: 0003: \***
1218: 0003: \***     1  7  ASC  BOOTS.CODE$
1219: 0003: \***     8  3  ASC  TRANS.TYPE$             "001" Item reference
1220: 0003: \***    11  1  ASC  IUF.GRP.CODE.FLAG$
1221: 0003: \***    12 24  ASC  IUF.STNDRD.DESC$
1222: 0003: \***    36 18  ASC  IUF.TILL.DESC$
1223: 0003: \***    54 45  ASC  IUF.S.E.DESC$
1224: 0003: \***    99  1  ASC  IUF.SUPPLY.ROUTE$
1225: 0003: \***   100  1  ASC  IUF.GIVEAWAY$
1226: 0003: \***   101  5  ASC  IUF.PROD.GRP$
1227: 0003: \***   106  1  ASC  IUF.GUARANTEE.CAT$          ! SBH CHANGED FROM ENF.QTY 31/1/96
1228: 0003: \***   107  1  ASC  IUF.ENF.PRICE.ENTRY$
1229: 0003: \***   108  1  ASC  IUF.LOYALTY.FLAG$
1230: 0003: \***   109  1  ASC  IUF.DISCOUNT.CAT$
1231: 0003: \***   110  1  ASC  IUF.OWN.BRAND$
1232: 0003: \***   111  1  ASC  IUF.DIRECT.PROC$
1233: 0003: \***   112  1  ASC  IUF.STATUS.1$
1234: 0003: \***   113  1  ASC  IUF.EANS.CHANGED$
1235: 0003: \***   114  3  ASC  IUF.NO.OF.EANS$
1236: 0003: \***   117  8  ASC  IUF.CURRENT.PRICE$      Price in pence
1237: 0003: \***   125  1  ASC  IUF.NO.OF.RPD.PRICES$
1238: 0003: \***   126  2  ASC  IUF.NO.OF.FLASHPACKS$
1239: 0003: \***   128  7  ASC  IUF.ORIGIN.CODE$
1240: 0003: \***   135  1  ASC  IUF.DEAL.PRICE.FLAG$    !L CHANGED TO IUF.KEYLINES.FLAG$
1241: 0003: \***   136  1  ASC  IUF.STOCK.SYSTEM.FLAG$  "Y" Stock system item
1242: 0003: \***                                        "N" Non stock system item
1243: 0003: \***   137  2  ASC  NEW.DEAL.COUNT$         Number of type 6 records
1244: 0003: \***   139  1  ASC  BC.LETTER$              Business centre letter
1245: 0003: \***
1246: 0003: \***    FLASHPACK RECORD
1247: 0003: \***
1248: 0003: \***     1  7  ASC  BOOTS.CODE$
1249: 0003: \***     8  3  ASC  TRANS.TYPE$             "002" Flashpack
1250: 0003: \***    11  7  ASC  FLASH.PACK.CODE$
1251: 0003: \***    18  3  ASC  MULTIPLICATION.FACTOR$
1252: 0003: \***
1253: 0003: \***    DEAL PRICE RECORD
1254: 0003: \***
1255: 0003: \***     1  7  ASC  BOOTS.CODE$
1256: 0003: \***     8  3  ASC  TRANS.TYPE$             "003" Deal price
1257: 0003: \***    11  1  ASC  DEAL.TYPE$
1258: 0003: \***    12  2  ASC  DEAL.QUANTITY$
1259: 0003: \***    14  5  ASC  SPECIAL.PRICE$          Price in pence
1260: 0003: \***    19  2  ASC  M.P.GROUP$
1261: 0003: \***    21  6  ASC  FIRST.DATE$             YYMMDD format
1262: 0003: \***    27  6  ASC  LAST.DATE$              YYMMDD format
1263: 0003: \***
1264: 0003: \***    ITEM PENDING PRICE RECORD
1265: 0003: \***
1266: 0003: \***     1  7  ASC  BOOTS.CODE$
1267: 0003: \***     8  3  ASC  TRANS.TYPE$             "004" Item pending price
1268: 0003: \***    11  6  ASC  RPD.DATE$               YYMMDD format
1269: 0003: \***    17  8  ASC  NEW.PRICE$              Price in pance
1270: 0003: \***    25  5  ASC  RPD.NO$
1271: 0003: \***    30  1  ASC  MARKDOWN$               Markdown flag of "Y" or "N" !MBG
1272: 0003: \***
1273: 0003: \***    ITEM BARCODE RECORD
1274: 0003: \***
1275: 0003: \***     1  7  ASC  BOOTS.CODE$
1276: 0003: \***     8  3  ASC  TRANS.TYPE$             "005" Item barcode
1277: 0003: \***    11 12  ASC  BAR.CODE$
1278: 0003: \***
1279: 0003: \***    DEALS RECORD (MULTI-BUY FORMAT)     Sorted by ...
1280: 0003: \***                                          BOOTS.CODE$ then DEAL.NUMBER$
1281: 0003: \***
1282: 0003: \***     1  7  ASC  BOOTS.CODE$             Boots item code with check digit
1283: 0003: \***     8  3  ASC  TRANS.TYPE$             "006" Deals
1284: 0003: \***    11  6  ASC  START.DATE$             YYMMDD format
1285: 0003: \***    17  6  ASC  END.DATE$               YYMMDD format
1286: 0003: \***    23  1  ASC  DEAL.ID$                "M" Multi-Buy
1287: 0003: \***    24  1  ASC  PAIR.TRIPLET.FLAG$      " " (not used for Multi-Buy)
1288: 0003: \***    25  1  ASC  3FOR2.FLAG$             "T" Three-For-Two type Multi-Buy
1289: 0003: \***    26  2  ASC  DEAL.LIMIT$             2 to 15 Qualifying purchases
1290: 0003: \***    28  4  ASC  DEAL.NUMBER$            100 to 9999
1291: 0003: \***    32  4  ASC  SAVED.AMOUNT$           1 to 9999 if fixed saving
1292: 0003: \***                                        zero if highest price purchased
1293: 0003: \***
1294: 0003: \***    DEALS RECORD (LINK-SAVE FORMAT)     Sorted by ...
1295: 0003: \***                                          BOOTS.CODE$ then DEAL.NUMBER$
1296: 0003: \***
1297: 0003: \***     1  7  ASC  BOOTS.CODE$             Boots item code with check digit
1298: 0003: \***     8  3  ASC  TRANS.TYPE$             "006" Deals
1299: 0003: \***    11  6  ASC  START.DATE$             YYMMDD format
1300: 0003: \***    17  6  ASC  END.DATE$               YYMMDD format
1301: 0003: \***    23  1  ASC  DEAL.ID$                "A" "B" "X" Link-Save list ID
1302: 0003: \***    24  1  ASC  PAIR.TRIPLET.FLAG$      "P" Pair, "T" Triplet
1303: 0003: \***    25  1  ASC  3FOR2.FLAG$             " " (not used for Link-Save)
1304: 0003: \***    26  2  ASC  DEAL.LIMIT$             1 to 15 Qualifying (list) purchases
1305: 0003: \***    28  4  ASC  DEAL.NUMBER$            100 to 9999
1306: 0003: \***    32  4  ASC  SAVED.AMOUNT$           1 to 9999 if fixed saving
1307: 0003: \***                                        zero if highest price purchased
1308: 0003: \***    TRAILER RECORD
1309: 0003: \***
1310: 0003: \***     1  7  ASC  BOOTS.CODE$
1311: 0003: \***    ]8  3  ASC  TRANS.TYPE$             "999" Trailer
1312: 0003: \***    11  7  ASC  IUF.ITEM.COUNT$
1313: 0003: \***
1314: 0003: \*******************************************************************************
1315: 0003: \*******************************************************************************
1316: 0003: 
1317: 0003: 
1318: 0003:     STRING GLOBAL                                                       \
1319: 0003:         IUF.FILE.NAME$
1320: 0003: 
1321: 0003:     INTEGER*1 GLOBAL                                                    \ 1.6CSk
1322: 0003:         IUF.NEW.FORMAT                                                  ! 1.6CSk
1323: 0003: 
1324: 0003:     INTEGER*2 GLOBAL                                                    \
1325: 0003:         IUF.REPORT.NUM%,                                                \
1326: 0003:         IUF.SESS.NUM%,                                                  \ 1.6CSk
1327: 0003:         REFPGF.COUNT%,                                                  \ 1.6CSk
1328: 0003:         REFPGF.REPORT.NUM%,                                             \ 1.6CSk
1329: 0003:         REFPGF.SESS.NUM%                                                ! 1.6CSk
1330: 0003: 
1331: 0003:   STRING GLOBAL                                                         \
1332: 0003:         IUF.3FOR2.FLAG$,                                                \ IRC
1333: 0003:         IUF.BAR.CODE$,                                                  \
1334: 0003:         IUF.BC.LETTER$,                                                 \ IRC
1335: 0003:         IUF.BOOTS.CODE$,                                                \
1336: 0003:         IUF.BRANCH.NO$,                                                 \
1337: 0003:         IUF.CURRENT.PRICE$,                                             \
1338: 0003:         IUF.DEAL.ID$,                                                   \ IRC
1339: 0003:         IUF.DEAL.LIMIT$,                                                \ IRC
1340: 0003:         IUF.DEAL.NUMBER$,                                               \ IRC
1341: 0003:         IUF.KEYLINES.FLAG$,                                             \ LAC/AH
1342: 0003:         IUF.DEAL.QUANTITY$,                                             \
1343: 0003:         IUF.DEAL.TYPE$,                                                 \
1344: 0003:         IUF.DIRECT.PROC$,                                               \
1345: 0003:         IUF.DISCOUNT.CAT$,                                              \ JAW
1346: 0003:         IUF.EANS.CHANGED$,                                              \
1347: 0003:         IUF.END.DATE$,                                                  \
1348: 0003:         IUF.ENF.PRICE.ENTRY$,                                           \
1349: 0003:         IUF.GUARANTEE.CAT$,                                             \ SBH 31/1/96
1350: 0003:         IUF.FIRST.DATE$,                                                \
1351: 0003:         IUF.FLASH.PACK.CODE$,                                           \
1352: 0003:         IUF.GIVEAWAY$,                                                  \ JAW
1353: 0003:         IUF.GRP.NO$,                                                   \!BRN
1354: 0003:         IUF.GRP.CODE.FLAG$,                                             \
1355: 0003:         IUF.ITEM.COUNT$,                                                \
1356: 0003:         IUF.ITEM.QTY$,                                                  \ KRD
1357: 0003:         IUF.LAST.DATE$,                                                 \
1358: 0003:         IUF.LOYALTY.FLAG$,                                              \ JAW
1359: 0003:         IUF.M.P.GROUP$,                                                 \
1360: 0003:         IUF.MULTIPLICATION.FACTOR$,                                     \
1361: 0003:         IUF.NEW.DEAL.COUNT$,                                            \ IRC
1362: 0003:         IUF.NEW.PRICE$,                                                 \
1363: 0003:         IUF.NO.OF.EANS$,                                                \
1364: 0003:         IUF.NO.OF.RPD.PRICES$,                                          \
1365: 0003:         IUF.OWN.BRAND$,                                                 \
1366: 0003:         IUF.PAIR.TRIPLET.FLAG$,                                         \ IRC
1367: 0003:         IUF.PROD.GRP$,                                                  \
1368: 0003:         IUF.RECORD$,                                                    \
1369: 0003:         IUF.RESTRICT.SALES.FLAG$,                                      \!BRN
1370: 0003:         IUF.RPD.DATE$,                                                  \
1371: 0003:         IUF.RPD.NO$,                                                    \
1372: 0003:         IUF.S.E.DESC$,                                                  \
1373: 0003:         IUF.SAVED.AMOUNT$,                                              \ IRC
1374: 0003:         IUF.SERIAL.NO$,                                                 \
1375: 0003:         IUF.SPECIAL.PRICE$,                                             \
1376: 0003:         IUF.START.DATE$,                                                \ IRC
1377: 0003:         IUF.STATUS.1$,                                                  \
1378: 0003:         IUF.STNDRD.DESC$,                                               \
1379: 0003:         IUF.STOCK.SYSTEM.FLAG$,                                         \
1380: 0003:         IUF.SUPPLY.ROUTE$,                                              \
1381: 0003:         IUF.TILL.DESC$,                                                 \
1382: 0003:         IUF.TRANS.TYPE$,                                                \
1383: 0003:         IUF.UNIT.MEASUREMENT$,                                          \ KRD
1384: 0003:         IUF.UNIT.NAME$                                                  ! KRD
1385: 0003: 
1386: 0003:   STRING GLOBAL                                                         \ 1.6CSk
1387: 0003:         AGES$(1),                                                       \ 1.6CSk
1388: 0003:         GIFTBRCD.TABLE$(1),                                             \ 1.6CSk
1389: 0003:         IUF.MATRIX$(1),                                                 \ 1.6CSk
1390: 0003:         MEDICINES.TABLE$(1),                                            \ 1.6CSk
1391: 0003:         REFPGF.RECORDS$(1)                                              ! 1.6CSk
1392: 0003: 
1393: 0003:   STRING GLOBAL                                                         \ 1.6CSk
1394: 0003:         AGE$,                                                           \ 1.6CSk
1395: 0003:         AGE.RESTRICT$,                                                  \ 1.6CSk
1396: 0003:         ALCOHOL.PROD.GRP.LIST$,                                         \ 1.6CSk
1397: 0003:         ALL.MEDICINES$,                                                 \ 1.6CSk
1398: 0003:         ALREADY.IN.TABLE$,                                              \ 1.6CSk
1399: 0003:         ASPIRIN.RECORD$,                                                \ 1.6CSk
1400: 0003:         DOSAGE$,                                                        \ 1.6CSk
1401: 0003:         EPHED.TEMP$,                                                    \ 1.6CSk
1402: 0003:         GIFTRECORD$,                                                    \ 1.6CSk
1403: 0003:         INSURE.CONCEPT.GROUPS$, \ ! From BCF record 2                   \ 1.11 RC (44)
1404: 0003:         IBRUPROFEN.RECORD$,                                             \ 1.6CSk
1405: 0003:         IUF.AGE.RESTRICTION$,                                           \ 1.6CSk
1406: 0003:         IUF.BLOCKED.FROM.SALE$,                                         \ 1.6CSk
1407: 0003:         IUF.BOOTS.COM.EXTENDED$,                                        \ 1.6CSk
1408: 0003:         IUF.CONTAINS.ALCOHOL$,                                          \ 1.6CSk
1409: 0003:         IUF.CONTAINS.ASPIRIN$,                                          \ 1.6CSk
1410: 0003:         IUF.CONTAINS.EPHEDRINE$,                                        \ 1.6CSk
1411: 0003:         IUF.CONTAINS.IBUPROFEN$,                                        \ 1.6CSk
1412: 0003:         IUF.CONTAINS.NONSOLID.PAINKILLER$,                              \ 1.6CSk
1413: 0003:         IUF.CONTAINS.PARACETAMOL$,                                      \ 1.6CSk
1414: 0003:         IUF.CONTAINS.PSEUDOEPHEDRINE$,                                  \ 1.6CSk
1415: 0003:         IUF.DATE.SENSITIVE$,                                            \ 1.6CSk
1416: 0003:         IUF.DISCOUNTABLE$, \ ! Mis-leading variable name (should be Discount Exempt)  ! 1.9 RC (21)
1417: 0003:                            \ ! "Y" equates to IRF.INDICAT3% X'01' Discount Exempt ON  ! 1.9 RC (21)
1418: 0003:         IUF.EARN.POINTS$,                                               \ 1.6CSk
1419: 0003:         IUF.EFFERVESCENT$,                                              \ 1.6CSk
1420: 0003:         IUF.ETHICAL.ACTIVE$,                                            \ 1.6CSk
1421: 0003:         IUF.ETHICAL.CLASS$,                                             \ 1.6CSk
1422: 0003:         IUF.ETHICAL.DESCRIPTION$,                                       \ 1.6CSk
1423: 0003:         IUF.ETHICAL.PACK.SIZE$,                                         \ 1.6CSk
1424: 0003:         IUF.GIFTCARD$,                                                  \ 1.6CSk
1425: 0003:         IUF.GUARANTEE.LENGTH$,                                          \ 1.6CSk
1426: 0003:         IUF.INSURANCE$,                                                 \ 1.6CSk
1427: 0003:         IUF.INITIAL.LOAD$,                                              \ 1.6CSk
1428: 0003:         IUF.MARKDOWN$,                                                  \ 1.6CSk
1429: 0003:         IUF.PRIMARY.SUPPLIER$,                                          \ 1.6CSk
1430: 0003:         IUF.REC.COUNT$,                                                 \ 1.6CSk
1431: 0003:         IUF.REC.TYPE$,                                                  \ 1.6CSk
1432: 0003:         IUF.REDEEMABLE$,                                                \ 1.6CSk
1433: 0003:         IUF.RESALEABLE$,                                                \ 1.6CSk
1434: 0003:         IUF.RETURN.ROUTE$,                                              \ 1.6CSk
1435: 0003:         IUF.RETURNABLE$,                                                \ 1.6CSk
1436: 0003:         IUF.SPECIAL.INSTRUCTION$,                                       \ 1.6CSk
1437: 0003:         IUF.STORE.NUM$,                                                 \ 1.6CSk
1438: 0003:         IUF.TIME.STAMP$,                                                \ 1.6CSk
1439: 0003:         IUF.UNRESTRICTED.GROUP.CODE$,                                   \ 1.6CSk
1440: 0003:         PARACETAMOL.RECORD$,                                            \ 1.6CSk
1441: 0003:         PROD.GRP$                                                       ! 1.6CSk
1442: 0003: 
1443: 0003: 
1444: 0003: 
1445: 0003:   INTEGER*2 GLOBAL                                                      \ 1.6CSk
1446: 0003:         A%,                                                             \ 1.6CSk
1447: 0003:         J%,                                                             \ 1.6CSk
1448: 0003:         ADD.TO.TABLE%,                                                  \ 1.6CSk
1449: 0003:         AGE.POS%,                                                       \ 1.6CSk
1450: 0003:         GIFTBRCD.COUNT%,                                                \ 1.6CSk
1451: 0003:         HEALTH.INDEX%,                                                  \ 1.6CSk
1452: 0003:         MATCH.COMMA%,                                                   \ 1.6CSk
1453: 0003:         MATCH.POS1%,                                                    \ 1.6CSk
1454: 0003:         MATCH.POS2%,                                                    \ 1.6CSk
1455: 0003:         MEDICINES.IN.TABLE%,                                            \ 1.6CSk
1456: 0003:         NO.OF.AGES%,                                                    \ 1.6CSk
1457: 0003:         NO.OF.MEDICINES%,                                               \ 1.6CSk
1458: 0003:         PROD.GRP.NUM%,                                                  \ 1.6CSk
1459: 0003:         SPACE%                                                          ! 1.6CSk
1460: 0003: 
1461: 0003: %INCLUDE JOBOKDEC.J86   ! Jobs OK File
1462: 0003: \*****************************************************************************
1463: 0003: \*****************************************************************************
1464: 0003: \***
1465: 0003: \***               %INCLUDE FOR XXXXXXXXXXX - FIELD DECLARATIONS
1466: 0003: \***                                          FILE REFERENCE PARAMETERS
1467: 0003: \***
1468: 0003: \***                      FILE TYPE    :
1469: 0003: \***
1470: 0003: \***                      REFERENCE    : jobokdea.J86
1471: 0003: \***
1472: 0003: \***    Version A               Steve Windsor          ZZZZZZZZZZZZZZZZ
1473: 0003: \***
1474: 0003: \***    Version B.              Robert Cowey.          07 OCT 1993.
1475: 0003: \***    No changes to this file.
1476: 0003: \***
1477: 0003: \***    Version C.              Mark Walker            ???
1478: 0003: \***    ???
1479: 0003: \***
1480: 0003: \***    Version D.              Stuart Highley         5th May 2000
1481: 0003: \***    Added variables for Dentistry (ExACT) and Well-being.
1482: 0003: \***
1483: 0003: \***    Version E.              Harpal Matharu        17th Jun 2010
1484: 0003: \***    Added variable for PSD87
1485: 0003: \***
1486: 0003: \***    Version F.              Nalini Mathusoothanan 22nd Jun 2011
1487: 0003: \***    Added new variables for Core 2 Release
1488: 0003: \***    JOBSOK.IUF.SOURCE$ 1 byte    - IUF processor [Mainframe or SAP ECC]
1489: 0003: \***    JOBSOK.LAST.PROCESSED.BATCH$ - Serial number of last successfully
1490: 0003: \***                                   processed batch.
1491: 0003: \***
1492: 0003: \*****************************************************************************
1493: 0003: \*****************************************************************************
1494: 0003: 
1495: 0003: REM \
1496: 0003: 
1497: 0003:   STRING GLOBAL           \
1498: 0003:     JOBSOK.FILE.NAME$
1499: 0003: 
1500: 0003:   INTEGER*2 GLOBAL        \
1501: 0003:     JOBSOK.REPORT.NUM%,   \ BBCW
1502: 0003:     JOBSOK.SESS.NUM%
1503: 0003: REM \
1504: 0003: 
1505: 0003:   STRING GLOBAL           \
1506: 0003:     JOBSOK.RECORD$,       \ 80 bytes
1507: 0003:     JOBSOK.PSB21$,        \ 1 byte, BLANK = not run
1508: 0003:                           \         S     = program started
1509: 0003:                           \         E     = program ended OK
1510: 0003:                           \         X     = program ended in error
1511: 0003:                           \         Y     = program ended OK after a minor error
1512: 0003:     JOBSOK.PSB22$,        \ 1 byte, BLANK = not run
1513: 0003:                           \         S     = program started
1514: 0003:                           \         E     = program ended OK
1515: 0003:                           \         X     = program ended in error
1516: 0003:                           \         Y     = program ended OK after a minor error
1517: 0003:     JOBSOK.PSB23$,        \ 1 byte, BLANK = not run
1518: 0003:                           \         S     = program started
1519: 0003:                           \         E     = program ended OK
1520: 0003:                           \         X     = program ended in error
1521: 0003:                           \         Y     = program ended OK after a minor error
1522: 0003:     JOBSOK.PSB24$,        \ 1 byte, BLANK = not run
1523: 0003:                           \         S     = program started
1524: 0003:                           \         E     = program ended OK
1525: 0003:                           \         X     = program ended in error
1526: 0003:                           \         Y     = program ended OK after a minor error
1527: 0003:     JOBSOK.PSB25$,        \ 1 byte, BLANK = not run
1528: 0003:                           \         S     = program started
1529: 0003:                           \         E     = program ended OK
1530: 0003:                           \         X     = program ended in error
1531: 0003:                           \         Y     = program ended OK after a minor error
1532: 0003:     JOBSOK.DATE$,         \ 4 bytes MMDD  = processing date
1533: 0003:     JOBSOK.STATUS$,       \ 1 byte, 0 = everything OK
1534: 0003:                           \         1 = controller files missing
1535: 0003:                           \         2 = till files missing
1536: 0003:                           \         3 = controller and till files missing
1537: 0003:     JOBSOK.PSB27$,        \ 1 byte, BLANK = not run                  ! CMW
1538: 0003:                           \         S     = program started          ! CMW
1539: 0003:                           \         E     = program ended OK         ! CMW
1540: 0003:                           \         X     = program ended in error   ! CMW
1541: 0003:     JOBSOK.PSB28$,        \ 1 byte, BLANK = not run                  ! CMW
1542: 0003:                           \         S     = program started          ! CMW
1543: 0003:                           \         E     = program ended OK         ! CMW
1544: 0003:                           \         X     = program ended in error   ! CMW
1545: 0003:     JOBSOK.DENTIST$,      \ 1  byte, BLANK = not run                 ! DSH
1546: 0003:                           \         S     = program started          ! DSH
1547: 0003:                           \         E     = program ended OK         ! DSH
1548: 0003:                           \         X     = program ended in error   ! DSH
1549: 0003:     JOBSOK.WBEING$,       \ 1  byte, BLANK = not run                 ! DSH
1550: 0003:                           \         S     = program started          ! DSH
1551: 0003:                           \         E     = program ended OK         ! DSH
1552: 0003:                           \         X     = program ended in error   ! DSH
1553: 0003:     JOBSOK.PSD87$,        \ 1  byte, BLANK = not run                 ! EHSM
1554: 0003:                           \         S     = program started          ! EHSM
1555: 0003:                           \         E     = program ended OK         ! EHSM
1556: 0003:                           \         X     = program ended in error   ! EHSM
1557: 0003:     JOBSOK.IUF.SOURCE$,   \ 1  byte, BLANK = No IUF was present.     ! FNM
1558: 0003:                           \             This is possible when cutover! FNM
1559: 0003:                           \             to SAP ECC and there are no  ! FNM
1560: 0003:                           \             item deltas on a night.      ! FNM
1561: 0003:                           \         M     = Mainframe                ! FNM
1562: 0003:                           \         E     = SAP ECC                  ! FNM
1563: 0003:                           \
1564: 0003:     JOBSOK.LAST.PROCESSED.BATCH$,                                    \ FNM
1565: 0003:                           \ 17 ASC , Successful Batch Serial Number  ! FNM
1566: 0003:     JOBSOK.SPACE$         ! 47 bytes                                 ! FNM
1567: 0003: 
1568: 0003:   INTEGER*2 GLOBAL        \
1569: 0003:     JOBSOK.RECL%
1570: 0003: %INCLUDE LOCALDEC.J86   ! Local Price File
1571: 0003: \***********************************************************************
1572: 0003: \***********************************************************************
1573: 0003: \***
1574: 0003: \***    DESCRIPTION: Local Price File
1575: 0003: \***                 Field Definitions
1576: 0003: \***
1577: 0003: \***    FILE TYPE : Keyed
1578: 0003: \***
1579: 0003: \***********************************************************************
1580: 0003: \***
1581: 0003: \***    Version A.          Paul Flanagan                1st Jul 1993
1582: 0003: \***    Initial version.
1583: 0003: \***
1584: 0003: \***    Version B.          Clive Norris                24th Nov 1993
1585: 0003: \***    AUTH.NUM$, STOCK.FIG$ and RETRIEVAL.FLAG$ replaced filler as
1586: 0003: \***    part of the RETURNS/AUTOMATIC CREDIT CLAIMING package.
1587: 0003: \***
1588: 0003: \***    Version C.          Mick Bayliss                 6th Dec 1994
1589: 0003: \***    Added missing field.
1590: 0003: \***
1591: 0003: \***    Version D.          Mark Walker                  1st Jul 2015
1592: 0003: \***    F392 Retail Stock 5
1593: 0003: \***    Added key length field.
1594: 0003: \***
1595: 0003: \***********************************************************************
1596: 0003: \***********************************************************************
1597: 0003: 
1598: 0003:     STRING GLOBAL             \
1599: 0003:         LOCAL.AUTH.NUM$,      \ 4 bytes UPD Auth'n number
1600: 0003:                               \             from Business Centre.
1601: 0003:         LOCAL.END.DATE$,      \ 3 bytes UPD yymmdd.
1602: 0003:         LOCAL.FILE.NAME$,     \
1603: 0003:         LOCAL.H.O.PRICE$,     \ 5 byte UPD.
1604: 0003:         LOCAL.HO.CHANGE$,     \ 3 bytes UPD. Date of HO price change
1605: 0003:                               \ (this will be zero if no change since
1606: 0003:                               \ local price was initiated).
1607: 0003:         LOCAL.ITEM.CODE$,     \ 4 bytes UPD (key) Boots code 
1608: 0003:                               \                   with check digit. 
1609: 0003:         LOCAL.OPERATOR$,      \ 4 bytes UPD operator id (when set up).
1610: 0003:         LOCAL.PRICE$,         \ 5 bytes UPD.
1611: 0003:         LOCAL.REASON$,        \ 4 byte ASCII 
1612: 0003:         LOCAL.RETRIEVAL.FLAG$,\ 1 byte ASC "Y" or "N"  
1613: 0003:         LOCAL.SPACE$,         \                                            !CMJB
1614: 0003:         LOCAL.START.DATE$,    \ 3 bytes UPD yymmdd. 
1615: 0003:         LOCAL.START.TIME$     ! 2 bytes UPD hhmm.
1616: 0003:         
1617: 0003:     INTEGER*2 GLOBAL          \
1618: 0003:         LOCAL.KEYL%,          \                                             !DMW
1619: 0003:         LOCAL.RECL%,          \
1620: 0003:         LOCAL.REPORT.NUM%,    \
1621: 0003:         LOCAL.SESS.NUM%,      \
1622: 0003:         LOCAL.STOCK.FIG%      !  No. of items authorised at the price.
1623: 0003: 
1624: 0003: %INCLUDE NLINEDEC.J86   ! New Lines File
1625: 0003: 
1626: 0003: \*****************************************************************************
1627: 0003: \*****************************************************************************
1628: 0003: \***
1629: 0003: \***        %INCLUDE FIELD DECLARATIONS AND FILE REFERENCE PARAMETERS
1630: 0003: \***
1631: 0003: \***                   FILE TYPE:  KEYED
1632: 0003: \***
1633: 0003: \***                   REFERENCE:  NLINEDEC.J86
1634: 0003: \***
1635: 0003: \***              DESCRIPTION:  NEWLINES - NEWLINES INFORMATION
1636: 0003: \***
1637: 0003: \***
1638: 0003: \***
1639: 0003: \***      VERSION 1 : Julia Stones             7th July 2003
1640: 0003: \***
1641: 0003: \***      Version 1.1   Julia Stones           6th October 2003
1642: 0003: \***      Added Newlines count to hold value of last number of existing new
1643: 0003: \***      lines added.
1644: 0003: \***
1645: 0003: \***    REVISION 1.2.                ROBERT COWEY.               05 DEC 2003.
1646: 0003: \***    Changed NLINE reporting number from 660 to 670.
1647: 0003: \***    No code changes to this file.
1648: 0003: \***
1649: 0003: \*****************************************************************************
1650: 0003: \*****************************************************************************
1651: 0003: 
1652: 0003: STRING GLOBAL   \
1653: 0003:    NEWLINES.FILE.NAME$,  \
1654: 0003:    NEWLINES.BOOTS.CODE$,     \  4 byte UPD;  Record key
1655: 0003:    NEWLINES.DATE.ADDED$,     \  4 byte UPD;  CCYYMMDD
1656: 0003:    NEWLINES.FILLER$          !  6 bytes
1657: 0003: 
1658: 0003: INTEGER*2 GLOBAL  \
1659: 0003:    NEWLINES.RECL%,   \
1660: 0003:    NEWLINES.REPORT.NUM%,  \
1661: 0003:    NEWLINES.COUNT%,       \
1662: 0003:    NEWLINES.SESS.NUM%   !
1663: 0003: 
1664: 0003: 
1665: 0003: 
1666: 0003: %INCLUDE PGFDEC.J86     ! Product Group Description File
1667: 0003: 
1668: 0003: \REM
1669: 0003: \*******************************************************************************
1670: 0003: \*******************************************************************************
1671: 0003: \***
1672: 0003: \***    %INCLUDE FOR PRODUCT GROUP FILES VARIABLE DECLARATIONS
1673: 0003: \***
1674: 0003: \***        REFERENCE   :   PGFDEC (J86)
1675: 0003: \***
1676: 0003: \***        FILE TYPE   :   Direct (PGF and PGFD)
1677: 0003: \***                        Keyed (PGFO)
1678: 0003: \***
1679: 0003: \***    VERSION B.              ROBERT COWEY.                       30 SEP 1993.
1680: 0003: \***    Created by combining PGFDECA, PGFDFLDA, PGFOFLDA, PGFDNUMA and PGFONUMA.
1681: 0003: \***
1682: 0003: \***    REVISION 1.2.           ROBERT COWEY.                       27 OCT 2003.
1683: 0003: \***    Defined WRITE.PGF function.
1684: 0003: \***    No changes to this file.
1685: 0003: \***
1686: 0003: \***   Version C                Mark Goode                          21st December 2004
1687: 0003: \***   New field for Product groups marked as OSSR.
1688: 0003: \***   'Y' - OSSR Product group.
1689: 0003: \***   'N' - ' ' - Non-OSSR product group.
1690: 0003: \***
1691: 0003: \***    Version D               Tittoo Thomas                        2 SEP 2011
1692: 0003: \***    Changes to accomodate new csv format for PGDIR as part of
1693: 0003: \***    the Core Stores Release 2 project
1694: 0003: \***
1695: 0003: \*******************************************************************************
1696: 0003: \*******************************************************************************
1697: 0003: 
1698: 0003: 
1699: 0003: \*******************************************************************************
1700: 0003: \*******************************************************************************
1701: 0003: \***
1702: 0003: \***    OLD RECORD LAYOUT
1703: 0003: \***
1704: 0003: \***     1  3  UPD  PROD.GRP.NO$     Key
1705: 0003: \***     *  1  UPD  CON.GROUP$       Concept group
1706: 0003: \***     *  2  UPD  CON.SEQ$         Concept sequence
1707: 0003: \***     4 18  ASC  PROD.GRP.NAME$
1708: 0003: \***    22  1  ASC  SEL.FLAG$        "Y" Shelf edge labels not to be printed
1709: 0003: \***                                 "N" Shelf edge labels to be printed for
1710: 0003: \***                                     items in the product group
1711: 0003: \***    23  8  ASC  SPACE$
1712: 0003: \***
1713: 0003: \***    Record length 30
1714: 0003: \***
1715: 0003: \***    NEW CSV RECORD LAYOUT
1716: 0003: \***
1717: 0003: \***     1  ASC  REC.TYPE$        Hardcoded to 'P'
1718: 0003: \***     5  ASC  PROD.GRP.NO$     ccsss where,  cc is the Concept Group and
1719: 0003: \***                                            sss is the Sequence Number
1720: 0003: \***    18  ASC  PROD.GRP.NAME$
1721: 0003: \***     1  ASC  SEL.FLAG$        "Y" Shelf edge labels to be printed
1722: 0003: \***                              "N" Shelf edge labels not to be printed
1723: 0003: \***     1  UPD  OSSR.FLAG$       ALWAYS SET TO NULL - PLACEHOLDER ONLY
1724: 0003: \***
1725: 0003: \*******************************************************************************
1726: 0003: \*******************************************************************************
1727: 0003: \***
1728: 0003: \***    OTHER INFORMATION
1729: 0003: \***    Prefixes PGFDIR... and PGFO... are use for variables that are specific
1730: 0003: \***    to the direct (mainframe transmitted) of keyed (live store) usage of
1731: 0003: \***    the file.
1732: 0003: \***
1733: 0003: \*******************************************************************************
1734: 0003: \*******************************************************************************
1735: 0003: 
1736: 0003: 
1737: 0003:     STRING GLOBAL \
1738: 0003:         PGF.FILE.NAME$, \
1739: 0003:         PGF.PROD.GRP.NAME$, \
1740: 0003:         PGF.PROD.GRP.NO$, \
1741: 0003:         PGF.SEL.FLAG$, \
1742: 0003:         PGF.SPACE$, \
1743: 0003:         PGFDIR.FILE.NAME$, \
1744: 0003:         PGFDIR.REC.TYPE$, \                                             ! DTT
1745: 0003:         PGFO.FILE.NAME$,   \
1746: 0003:         PGF.OSSR.FLAG$
1747: 0003: 
1748: 0003:     INTEGER*2 GLOBAL \
1749: 0003:         PGF.RECL%, \
1750: 0003:         PGF.REPORT.NUM%, \
1751: 0003:         PGF.SESS.NUM%, \
1752: 0003:         PGFDIR.RECL%, \
1753: 0003:         PGFDIR.REPORT.NUM%, \
1754: 0003:         PGFDIR.SESS.NUM%, \
1755: 0003:         PGFO.RECL%, \
1756: 0003:         PGFO.REPORT.NUM%, \
1757: 0003:         PGFO.SESS.NUM%
1758: 0003: 
1759: 0003:     INTEGER*4 GLOBAL \
1760: 0003:         PGF.REC.NUM%, \
1761: 0003:         PGFDIR.REC.NO%
1762: 0003: 
1763: 0003: %INCLUDE PPFDEC.J86     ! Pending Price File
1764: 0003: 
1765: 0003: \REM
1766: 0003: \*******************************************************************************
1767: 0003: \*******************************************************************************
1768: 0003: \***
1769: 0003: \***    %INCLUDE FOR PENDING PRICES FILES VARIABLE DECLARATIONS
1770: 0003: \***
1771: 0003: \***        REFERENCE   :   PPFDEC (J86)
1772: 0003: \***
1773: 0003: \***        FILE TYPE   :   Sequential
1774: 0003: \***
1775: 0003: \***    VERSION D.              ROBERT COWEY.                       23 AUG 1993.
1776: 0003: \***    Original version created by combining PPFFLDC, PPFINUMC and PPFONUMC.
1777: 0003: \***
1778: 0003: \***    VERSION E.              ROBERT COWEY.                       26 OCT 1993.
1779: 0003: \***    Removed SPLAN.ID$ from RPD and Deal records.
1780: 0003: \***    Defined Link-Save Multi-Buy Deal record.
1781: 0003: \***
1782: 0003: \***    VERSION F               BRIAN GREENFIELD                    24 JUN 2004.
1783: 0003: \***    Added Markdown variables to RPD record.
1784: 0003: \***    
1785: 0003: \*******************************************************************************
1786: 0003: \*******************************************************************************
1787: 0003: 
1788: 0003: 
1789: 0003: \*******************************************************************************
1790: 0003: \*******************************************************************************
1791: 0003: \***
1792: 0003: \***    RECORD LAYOUTS
1793: 0003: \***
1794: 0003: \***    TRAILER RECORD
1795: 0003: \***
1796: 0003: \***     1  7  ASC  BOOTS.CODE$     "99999999"
1797: 0003: \***     8  1  ASC  REC.TYPE.FLAG$  "T" Trailer
1798: 0003: \***     9  5  ASC  REC.COUNT$
1799: 0003: \***
1800: 0003: \***    RPD RECORD
1801: 0003: \***
1802: 0003: \***     1  7  ASC  BOOTS.CODE$       Boots code including check digit
1803: 0003: \***     8  1  ASC  REC.TYPE.FLAG$    "R" RPD
1804: 0003: \***     9  6  ASC  DATE.DUE$         YYMMDD
1805: 0003: \***    15  5  ASC  RPD.NO$
1806: 0003: \***    20  1  ASC  STATUS.FLAG$      "S" label printed but price not effected
1807: 0003: \***                                  "L" Locally priced - No label printed
1808: 0003: \***                                  "D" Deal priced - No label printed
1809: 0003: \***                                  " " Yet to be processed
1810: 0003: \***    21  1  ASC  INC.DEC.FLAG$     "D", "I", (" " if no change or deal price)
1811: 0003: \***    22  8  ASC  PRICE$
1812: 0003: \***    30  1  ASC  MARKDOWN$         Mark-down "Y" or "N"               ! FBG
1813: 0003: \***
1814: 0003: \***    DEAL PRICE RECORD
1815: 0003: \***
1816: 0003: \***     1  7  ASC  BOOTS.CODE$       Boots code including check digit
1817: 0003: \***     8  1  ASC  REC.TYPE.FLAG$    "D" Deal price
1818: 0003: \***     9  1  ASC  DEAL.TYPE$        "0", "1", "2", "3"
1819: 0003: \***    10  2  ASC  DEAL.QUANTITY$
1820: 0003: \***    12  5  ASC  SPECIAL.PRICE$
1821: 0003: \***    17  2  ASC  M.P.GROUP$
1822: 0003: \***    19  6  ASC  FIRST.DATE$       YYMMDD
1823: 0003: \***    25  6  ASC  LAST.DATE$        YYMMDD
1824: 0003: \***    31  1  ASC  EFFECT.FLAG$
1825: 0003: \***
1826: 0003: \***    LINK-SAVE MULTI-BUY DEAL RECORD
1827: 0003: \***
1828: 0003: \***     1  7  ASC  BOOTS.CODE$       Boots code including check digit
1829: 0003: \***     8  1  ASC  REC.TYPE.FLAG$    "B" Link-Save Multi-Buy deal record
1830: 0003: \***     9  1  ASC  DEAL.ID$          "M", "A", "B", "X"
1831: 0003: \***    10  1  ASC  PAIR.TRIP.FLAG$   "P", "T", " "
1832: 0003: \***    11  1  ASC  3FOR2.FLAG$       "T", " "
1833: 0003: \***    12  2  ASC  DEAL.LIMIT$       1 to 15
1834: 0003: \***    14  4  ASC  DEAL.NUM$         1 to 9999
1835: 0003: \***    18  4  ASC  SAVED.AMOUNT$     0 to 9999
1836: 0003: \***    22  6  ASC  DEAL.DATE.START$  YYMMDD of deal start
1837: 0003: \***    28  6  ASC  DEAL.DATE.FINISH$ YYMMDD of deal finish
1838: 0003: \***    34  1  ASC  ACTIVE.FLAG$      "Y", "N"
1839: 0003: \***
1840: 0003: \*******************************************************************************
1841: 0003: \*******************************************************************************
1842: 0003: \***
1843: 0003: \***    OTHER INFORMATION
1844: 0003: \***
1845: 0003: \***    Prefixes PPFI... and PPFO... are used for variables that are specific
1846: 0003: \***    to the INPUT or OUTPUT usage of the file.
1847: 0003: \***
1848: 0003: \*******************************************************************************
1849: 0003: \*******************************************************************************
1850: 0003: 
1851: 0003:  
1852: 0003:     STRING GLOBAL \
1853: 0003:         PPF.3FOR2.FLAG$, \                                             ! ERC
1854: 0003:         PPF.ACTIVE.FLAG$, \                                            ! ERC
1855: 0003:         PPF.BOOTS.CODE$, \
1856: 0003:         PPF.DATE.DUE$, \
1857: 0003:         PPF.DEAL.DATE.FINISH$, \                                       ! ERC
1858: 0003:         PPF.DEAL.DATE.START$, \                                        ! ERC
1859: 0003:         PPF.DEAL.ID$, \                                                ! ERC
1860: 0003:         PPF.DEAL.LIMIT$, \                                             ! ERC
1861: 0003:         PPF.DEAL.NUM$, \                                               ! ERC
1862: 0003:         PPF.DEAL.QUANTITY$, \
1863: 0003:         PPF.DEAL.TYPE$, \
1864: 0003:         PPF.EFFECT.FLAG$, \
1865: 0003:         PPF.FIRST.DATE$, \
1866: 0003:         PPF.INC.DEC.FLAG$, \
1867: 0003:         PPF.LAST.DATE$, \
1868: 0003:         PPF.MARKDOWN$, \                                               ! FBG
1869: 0003:         PPF.M.P.GROUP$, \
1870: 0003:         PPF.PAIR.TRIP.FLAG$, \                                         ! ERC
1871: 0003:         PPF.PRICE$, \
1872: 0003:         PPF.REC.COUNT$, \
1873: 0003:         PPF.REC.TYPE.FLAG$, \
1874: 0003:         PPF.RECORD$, \
1875: 0003:         PPF.RPD.NO$, \
1876: 0003:         PPF.SAVED.AMOUNT$, \                                           ! ERC
1877: 0003:         PPF.SPECIAL.PRICE$, \
1878: 0003:         PPF.STATUS.FLAG$, \
1879: 0003:         PPFI.3FOR2.FLAG$, \                                            ! ERC
1880: 0003:         PPFI.ACTIVE.FLAG$, \                                           ! ERC
1881: 0003:         PPFI.BOOTS.CODE$, \
1882: 0003:         PPFI.DATE.DUE$, \
1883: 0003:         PPFI.DEAL.DATE.FINISH$, \                                      ! ERC
1884: 0003:         PPFI.DEAL.DATE.START$, \                                       ! ERC
1885: 0003:         PPFI.DEAL.ID$, \                                               ! ERC
1886: 0003:         PPFI.DEAL.LIMIT$, \                                            ! ERC
1887: 0003:         PPFI.DEAL.NUM$, \                                              ! ERC
1888: 0003:         PPFI.DEAL.QUANTITY$, \
1889: 0003:         PPFI.DEAL.TYPE$, \
1890: 0003:         PPFI.EFFECT.FLAG$, \
1891: 0003:         PPFI.FILE.NAME$, \
1892: 0003:         PPFI.FIRST.DATE$, \
1893: 0003:         PPFI.INC.DEC.FLAG$, \
1894: 0003:         PPFI.LAST.DATE$, \
1895: 0003:         PPFI.MARKDOWN$, \                                               ! FBG
1896: 0003:         PPFI.M.P.GROUP$, \
1897: 0003:         PPFI.PAIR.TRIP.FLAG$, \                                        ! ERC
1898: 0003:         PPFI.PRICE$, \
1899: 0003:         PPFI.REC.COUNT$, \
1900: 0003:         PPFI.REC.TYPE.FLAG$, \
1901: 0003:         PPFI.RECORD$, \
1902: 0003:         PPFI.RPD.NO$, \
1903: 0003:         PPFI.SAVED.AMOUNT$, \                                          ! ERC
1904: 0003:         PPFI.SPECIAL.PRICE$, \
1905: 0003:         PPFI.STATUS.FLAG$, \
1906: 0003:         PPFO.FILE.NAME$
1907: 0003: 
1908: 0003:     INTEGER*2 GLOBAL \
1909: 0003:         PPFI.REPORT.NUM%, \
1910: 0003:         PPFO.REPORT.NUM%, \
1911: 0003:         PPFI.SESS.NUM%, \
1912: 0003:         PPFO.SESS.NUM%
1913: 0003: 
1914: 0003: %INCLUDE PPFKDEC.J86    ! Pending Price Keyed Work File
1915: 0003: \******************************************************************************
1916: 0003: \******************************************************************************
1917: 0003: \***
1918: 0003: \***    Pending Prices Keyed File (PPFK) variable definitions
1919: 0003: \***
1920: 0003: \******************************************************************************
1921: 0003: \***
1922: 0003: \***    Version 1.0             Mark Walker                 13th October 2011
1923: 0003: \***    Initial version.
1924: 0003: \***
1925: 0003: \***    VERSION 1.1.                ROBERT COWEY.                02 FEB 2012.
1926: 0003: \***    Changes creating PSB21.286 Core Release 2 version 1.5.
1927: 0003: \***    Defect 2678
1928: 0003: \***    Defined variable PPFK.PCR.COUNT.READ% to save total number of price 
1929: 0003: \***    changes for an item as found by READ.PPFK
1930: 0003: \***
1931: 0003: \***    VERSION 1.2.                ROBERT COWEY.                01 MAR 2012.
1932: 0003: \***    Changes creating PSB21.286 Core Release 2 version 1.7.
1933: 0003: \***    Defect 53.
1934: 0003: \***    Modified function DELETE.PPFK.
1935: 0003: \***    No code changes to this file.
1936: 0003: \***
1937: 0003: \******************************************************************************
1938: 0003: \******************************************************************************
1939: 0003: 
1940: 0003:     STRING GLOBAL                           \
1941: 0003:         PPFK.FILE.NAME$,                    \
1942: 0003:         PPFK.BOOTS.CODE$,                   \
1943: 0003:         PPFK.DATE.DUE$(1),                  \
1944: 0003:         PPFK.RPD.NO$(1),                    \
1945: 0003:         PPFK.STATUS.FLAG$(1),               \
1946: 0003:         PPFK.INC.DEC.FLAG$(1),              \        
1947: 0003:         PPFK.PRICE$(1),                     \
1948: 0003:         PPFK.MARKDOWN$(1),                  \
1949: 0003:         PPFK.READ.FORM$,                    \
1950: 0003:         PPFK.WRITE.FORM$,                   \
1951: 0003:         PPFK.PACK01$,                       \
1952: 0003:         PPFK.PACK03$,                       \
1953: 0003:         PPFK.PACK04$
1954: 0003:         
1955: 0003:     INTEGER*2 GLOBAL                        \
1956: 0003:         PPFK.SESS.NUM%,                     \
1957: 0003:         PPFK.REPORT.NUM%,                   \
1958: 0003:         PPFK.PCR.MAX%,                      \
1959: 0003:         PPFK.PCR.PER.RECORD%,               \
1960: 0003:         PPFK.PCR.RECL%,                     \
1961: 0003:         PPFK.PCR.COUNT%,                    \
1962: 0003:         PPFK.PCR.COUNT.READ%,               \ ! 1.1 RC
1963: 0003:         PPFK.RECL%,                         \
1964: 0003:         PPFK.KEYL%
1965: 0003:         
1966: 0003:     INTEGER*4 GLOBAL                        \
1967: 0003:         PPFK.MAXR%
1968: 0003: 
1969: 0003: %INCLUDE RICFDEC.J86    ! Redeem Items Change File
1970: 0003: \******************************************************************************
1971: 0003: \******************************************************************************
1972: 0003: \***
1973: 0003: \***                     REDEEM ITEMS CHANGE FILE    
1974: 0003: \***                                                                
1975: 0003: \***                      REFERENCE : RICFDEC.J86 
1976: 0003: \***                                                                
1977: 0003: \***                      FILE TYPE : Sequential                       
1978: 0003: \***                                                                
1979: 0003: \***                                                                
1980: 0003: \***   Version A.              Jamie Thorpe                  1st July 1997
1981: 0003: \***   Original version.                                                    
1982: 0003: \***                                                                         
1983: 0003: \***                                                                       
1984: 0003: \******************************************************************************
1985: 0003: \******************************************************************************
1986: 0003: 
1987: 0003:  
1988: 0003: STRING GLOBAL        RICF.FILE.NAME$,       \ 
1989: 0003:                      RICF.RECORD$,          \          
1990: 0003:                      RICF.ITEM.CODE$,       \
1991: 0003:                      RICF.DELIVERY.FLAG$,   \
1992: 0003:                      RICF.REDEEM.ITEM$,     \
1993: 0003:                   RICF.ITEM.DESCRIPTION$,   \
1994: 0003:                      RICF.PRICE$,           \
1995: 0003:                      RICF.FILLER$,          \ 
1996: 0003:                      RICF.REC.COUNT$,       \
1997: 0003:                      RICF.ITEM.QTY$,        \ BRD
1998: 0003:                      RICF.UNIT.MEASUREMENT$,\ BRD
1999: 0003:                      RICF.UNIT.NAME$,       \ BRD
2000: 0003:                      RICF.PRODUCT.GROUP$
2001: 0003:                    
2002: 0003:                     
2003: 0003:     
2004: 0003: 
2005: 0003:   INTEGER*2 GLOBAL   RICF.ALT.SESS.NUM%,  \
2006: 0003:                      RICF.REPORT.NUM%,    \ 
2007: 0003:                      RICF.ALT.REPORT.NUM%,\ 
2008: 0003:                      RICF.SESS.NUM%,      \
2009: 0003:                      RICF.RECL%,         \
2010: 0003:                      RICF.RECORD.NO%
2011: 0003:                      
2012: 0003: %INCLUDE SOFTSDEC.J86   ! Software Status File
2013: 0003: REM \
2014: 0003: \******************************************************************************
2015: 0003: \******************************************************************************
2016: 0003: \***
2017: 0003: \***                 %INCLUDE FOR THE SOFTWARE STATUS FILE
2018: 0003: \***   
2019: 0003: \***                      FILE TYPE  :   Direct
2020: 0003: \***
2021: 0003: \***                      REFERENCE  :   SOFTSDEC.J86
2022: 0003: \***
2023: 0003: \***	Version A	       Andrew Wedgeworth	      24th June 1992
2024: 0003: \***
2025: 0003: \******************************************************************************
2026: 0003: \*******************************************************************************
2027: 0003: 
2028: 0003:   STRING GLOBAL           \
2029: 0003:     SOFTS.RECORD$,        \           
2030: 0003:     SOFTS.SPACE$,         \           
2031: 0003:     SOFTS.FILE.NAME$    
2032: 0003:     
2033: 0003:   INTEGER*2 GLOBAL        \
2034: 0003:     SOFTS.RECL%,          \            
2035: 0003:     SOFTS.REPORT.NUM%,	  \      
2036: 0003:     SOFTS.SESS.NUM%
2037: 0003: 
2038: 0003:   INTEGER*4 GLOBAL        \
2039: 0003:     SOFTS.REC.NUM% 	         
2040: 0003: %INCLUDE STKMQDEC.J86   ! Stock Movement Queue File
2041: 0003: REM \
2042: 0003: \******************************************************************************
2043: 0003: \******************************************************************************
2044: 0003: \***
2045: 0003: \***      %INCLUDE FOR STOCK MOVEMENT QUEUE FILE FIELD DECLARATIONS
2046: 0003: \***                                             FILE REFERENCE PARAMETERS
2047: 0003: \***
2048: 0003: \***               FILE TYPE    : Sequential
2049: 0003: \***
2050: 0003: \***               REFERENCE    : STKMQDEC.J86
2051: 0003: \***
2052: 0003: \***      Version A.     L. Cook
2053: 0003: \***
2054: 0003: \***      Combined from STKMQNUE.J86 and STKMQFLE.J86
2055: 0003: \***
2056: 0003: \***      Version B.     S.P. Kelsey (CTG)            7th November
2057: 0003: \***      Include CSR Marker in the Type 1 and Type 18 transactions.
2058: 0003: \***
2059: 0003: \***      Version C.     S. Goulding                 8th March
2060: 0003: \***      Add fields for new tranctions types 21 & 23
2061: 0003: \***
2062: 0003: \***      Version D.     ???????????            ????????????
2063: 0003: \***      ????????????????????????????????????????????????????????
2064: 0003: \***
2065: 0003: \***      Version E.     Michael J. Kelsall           16th Dec 1993.
2066: 0003: \***      Addition of txn types, 24, 25, 26, 27 and 28. As part of the
2067: 0003: \***      RETURNS/AUTOMATIC CREDIT CLAIMING system.
2068: 0003: \***
2069: 0003: \***      Version 1.1    Michael J. Kelsall           10th Aug 1994.
2070: 0003: \***      Changes as part of R/ACC update to allow for zero price claim
2071: 0003: \***      processing. Addition of type 29 txn for this change.
2072: 0003: \***
2073: 0003: \***      Version 1.2    Nik Sen                       8th November 1994
2074: 0003: \***      Addition of transaction type 30 as oart of Epsom Life CSR Phase 2
2075: 0003: \***
2076: 0003: \***      Version 1.3    Neil Bennett                   2nd January 2007
2077: 0003: \***      Add ASN processing support. (Rec Type 17)
2078: 0003: \***
2079: 0003: \***      Version 1.4    Brian Greenfield               14th may 2007
2080: 0003: \***      Added STKMQ.RECALL.TYPE$ for use in A7C RECALLS - only type 26 records.
2081: 0003: \***
2082: 0003: \***      Version 1.5    Neil Bennett                  31st January 2008
2083: 0003: \***      Add STKMQ.FLAG$ for record type 11
2084: 0003: \***
2085: 0003: \***      Version 1.6    Dave Constable                5th September 2008
2086: 0003: \***      Add STKMQ.FLAG$ for record type 33
2087: 0003: \***
2088: 0003: \***      Version 1.7    Dave Constable                30th December 2008
2089: 0003: \***      Add STKMQ.RESCAN$ for record type 33
2090: 0003: \***
2091: 0003: \***      Version 1.8    Dave Constable                6th January 2009
2092: 0003: \***      Add Bookin date & time for record type 33
2093: 0003: \***
2094: 0003: \***      Version F      Mark Walker                      27th Mar 2014
2095: 0003: \***      F337 Centralised View of Stock
2096: 0003: \***      - Relocated STKMQ item processing variables to here.
2097: 0003: \***
2098: 0003: \******************************************************************************
2099: 0003: \*******************************************************************************
2100: 0003: \***
2101: 0003: \***  The length of the records on this file vary depending on the record
2102: 0003: \***  transaction type, but they all comprise combinations of the fields
2103: 0003: \***  defined below.
2104: 0003: \***
2105: 0003: \***  Transaction type 0 (Header record) - RECORD DELIMITER, TRANS TYPE,
2106: 0003: \***     FIELD DELIMITER, CREATION DATE, CREATION TIME, RECORD DELIMITER,
2107: 0003: \***     END OF RECORD MARKER.
2108: 0003: \***
2109: 0003: \***  Transaction type 1 - RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
2110: 0003: \***     TIME, FSI, FOLIO YEAR, FOLIO MONTH, FOLIO NUMBER, STORE SUFFIX,
2111: 0003: \***     COUNT OF ITEMS, INVOICE DAY,(FIELD DELIMITER, BOOTS CODE,
2112: 0003: \***     FIELD DELIMITER, QUANTITY, FIELD DELIMITER, CSR MARKER),
2113: 0003: \***     RECORD DELIMITER, END OF RECORD MARKER.
2114: 0003: \***     The fields within brackets are repeated as many times as count of items.
2115: 0003: \***
2116: 0003: \***  Transaction type 2 - RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
2117: 0003: \***     TIME, BOOTS CODE, FIELD DELIMITER, QUANTITY, RECORD DELIMITER,
2118: 0003: \***     END OF RECORD MARKER.
2119: 0003: \***
2120: 0003: \***  Transaction type 3 - RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
2121: 0003: \***     TIME, BOOTS CODE, FIELD DELIMITER, QUANTITY, FIELD DELIMITER,
2122: 0003: \***     REASON CODE, STORE/RETURN CODE, RECORD DELIMITER, END OF RECORD MARKER
2123: 0003: \***
2124: 0003: \***  Transaction type 4 - RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
2125: 0003: \***     TIME, BOOTS CODE, ON IDF FLAG, FIELD DELIMITER, QUANTITY,
2126: 0003: \***     RECORD DELIMITER, END OF RECORD MARKER
2127: 0003: \***
2128: 0003: \***  Transaction type 5 - RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
2129: 0003: \***     TIME, BOOTS CODE, COUNT FLAG, STOCK MOVEMENT DATE, FIELD DELIMITER,
2130: 0003: \***     QUANTITY, RECORD DELIMITER, END OF RECORD MARKER
2131: 0003: \***
2132: 0003: \***  Transaction type 6 - RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
2133: 0003: \***     TIME, BOOTS CODE, REASON (1 byte ASCII)
2134: 0003: \***     RECORD DELIMITER, END OF RECORD MARKER
2135: 0003: \***
2136: 0003: \***  Transaction type 7 - RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
2137: 0003: \***     TIME, BOOTS CODE, CONCEPT SEQUENCE
2138: 0003: \***     RECORD DELIMITER, END OF RECORD MARKER
2139: 0003: \***
2140: 0003: \***  Transaction type 8 - RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
2141: 0003: \***     TIME, PRODUCT GROUP, RECORD DELIMITER, END OF RECORD
2142: 0003: \***     MARKER
2143: 0003: \***
2144: 0003: \***  Transaction type 9 - RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
2145: 0003: \***     TIME, LIST NUMBER, ITEM NUMBER, LIST TYPE,
2146: 0003: \***     COUNT.BY.DATE, RECORD DELIMITER, END OF RECORD MARKER
2147: 0003: \***
2148: 0003: \***  Transaction type 10- RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
2149: 0003: \***     TIME, BOOTS CODE,
2150: 0003: \***     RECORD DELIMITER, END OF RECORD MARKER
2151: 0003: \***
2152: 0003: \***  Transaction type 11- RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
2153: 0003: \***     TIME, BOOTS CODE, FIELD DELIMITER, COUNT QUANTITY, FIELD DELIMITER(opt),
2154: 0003: \***     SOURCE(opt), FLAG(opt), RECORD DELIMITER, END OF RECORD MARKER
2155: 0003: \***
2156: 0003: \***  Transaction type 12- RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
2157: 0003: \***     TIME, BOOTS CODE,
2158: 0003: \***     RECORD DELIMITER, END OF RECORD MARKER
2159: 0003: \***
2160: 0003: \***  Transaction type 13- RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
2161: 0003: \***     TIME, LIST NUMBER, ITEM NUMBER, ITEM STATUS,ITEM CODE,
2162: 0003: \***     COUNT DATE, COUNT TIME, PRICE, FIELD DELIMITER, SHOP FLOOR COUNT,
2163: 0003: \***     FIELD DELIMITER, BACKROOM COUNT, RECORD DELIMITER, END OF REC MARKER
2164: 0003: \***
2165: 0003: \***  Transaction type 14- RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
2166: 0003: \***     TIME, LIST NUMBER, LIST STATUS, RECORD DELIMITER,
2167: 0003: \***     END OF RECORD MARKER
2168: 0003: \***
2169: 0003: \***  Transaction type 16- RECORD DELIMIER, TRANS TYPE, FIELD DELIMITER, DATE,
2170: 0003: \***     TIME, BC LETTER, FIELD DELIMITER, ORIGINAL RECOUNT
2171: 0003: \***     PERCENTAGE, FIELD DELIMITER, CHANGED RECOUNT PERCENTAGE,
2172: 0003: \***     RECORD DELIMITER, END OF RECORD DELIMITER
2173: 0003: \***
2174: 0003: \***  Transaction type 17- RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
2175: 0003: \***     TIME, SOURCE, SUPPLIER NUMBER, ORDER NUMBER, ORDER SUFFIX, PAGE
2176: 0003: \***     NUMBER, ITEM COUNT,
2177: 0003: \***     CARTON NUMBER, CARTON FLAG,                                        ! 1.3NWB
2178: 0003: \***     FIELD DELIMITER, ITEM CODE, BAR CODE,
2179: 0003: \***     QUANTITY - GOOD, FIELD DELIMITER, QUANTITY - DAMAGED, FIELD DELIMITER,
2180: 0003: \***     QUANTITY - STOLEN (the last 8 fields repeat ITEM COUNT times),
2181: 0003: \***     RECORD DELIMITER, END OF RECORD DELIMITER
2182: 0003: \***
2183: 0003: \***  Transaction type 18- RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
2184: 0003: \***     TIME, FOLIO IDENTIFIER, FOLIO YEAR, FOLIO MONTH, FOLIO NUMBER,
2185: 0003: \***     STORE SUFFIX, ITEM COUNT, INVOICE DAY, EXPECTED DATE OF DELIVERY,
2186: 0003: \***     DALLAS MARKER, FIELD DELIMITER, ITEM CODE, FIELD DELIMITER,
2187: 0003: \***     ORDER QUANTITY, FIELD DELIMITER, CSR MARKER,
2188: 0003: \***     (the last six fields repeat ITEM COUNT times),
2189: 0003: \***     RECORD DELIMITER, END OF RECORD DELIMITER
2190: 0003: \***
2191: 0003: \***  Transaction type 19- RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
2192: 0003: \***     TIME, SUPPLIER NUMBER, ORDER NUMBER, ORDER SUFFIX, CONFIRM/AMEND FLAG,
2193: 0003: \***     START TIME, END TIME, NO SINGLES ADDED, NO ITEMS ADDED, NO ITEMS
2194: 0003: \***     BOOKED IN, RECORD DELIMITER, END OF RECORD DELIMITER
2195: 0003: \***
2196: 0003: \***  Transaction type 21 - RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
2197: 0003: \***     TIME, DISTRIBUTION CENTRE, WAREHOUSE NUMBER, STORE NUMBER, UOD NUMBER,
2198: 0003: \***     STATUS, RECORD DELIMITER, END OF RECORD MARKER
2199: 0003: \***
2200: 0003: \***  Transaction type 23 - RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
2201: 0003: \***     TIME, DISTRIBUTION CENTRE, WAREHOUSE NUMBER, STORE NUMBER, UOD NUMBER,
2202: 0003: \***     STATUS, BOOTS/BAR CODE, BOOTS/BAR CODE FLAG, QUANTITY, FIELD DELIMITER
2203: 0003: \***     FSI,FOLIO YEAR, FOLIO MONTH, STORE SUFFIX, FOLIO NO, CSR MARKER
2204: 0003: \***     RECORD DELIMITER, END OF RECORD MARKER
2205: 0003: \***
2206: 0003: \***
2207: 0003: \***  RETURNS/AUTOMATIC CREDIT CLAIMING RECORD TYPES;
2208: 0003: \***
2209: 0003: \***  Transaction type 24 - Whole or Part consignment record
2210: 0003: \***     RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE, TIME,
2211: 0003: \***     CREDIT CLAIM NUM, BC LETTER, CLAIM TYPE, SUPPLIER NUM, INVOICE NUM,
2212: 0003: \***     FOLIO NUM, BATCH REF NUM, WHOLE/PART CONSIGNMENT, REPAIR CATEGORY,
2213: 0003: \***     REPAIR NUM, PLAN4 POLICY NUM, DDDA/DCDR NUM, DELIV NOTE NUM,
2214: 0003: \***     DELIV DATE, NUM OF CARTONS, ORDER NUM, COMMENT, NUM OF ITEMS,
2215: 0003: \***     ITEM/BAR CODE FLAG, BOOTS/BAR CODE, QTY, PRICE, RECORD DELIMITER,
2216: 0003: \***     END OF RECORD MARKER
2217: 0003: \***     (ITEM/BAR CODE FLAG to PRICE repeated NUM OF ITEMS times)
2218: 0003: \***
2219: 0003: \***  Transaction type 25 - Non-sales func 16 and Misc. txns from controller
2220: 0003: \***     RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE, TIME,
2221: 0003: \***     CREDIT CLAIM NUM, NUM OF ITEMS, AUTH CODE/CONTACT,
2222: 0003: \***     ADJUST STOCK FIGURE FLAG, REASON, ITEM/BAR CODE FLAG, BOOTS/BAR CODE,
2223: 0003: \***     QTY, PRICE, RECORD DELIMITER, END OF RECORD MARKER
2224: 0003: \***     (ITEM/BAR CODE FLAG to PRICE repeated NUM OF ITEMS times)
2225: 0003: \***
2226: 0003: \***  Transaction type 26 - Data from LDT
2227: 0003: \***     RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE, TIME, UOD NUM,
2228: 0003: \***     UOD STATUS, CREDIT CLAIM NUM, NUM OF ITEMS UPDATED, TOTAL QTY IN UOD,
2229: 0003: \***     ADJUST STOCK FIGURE FLAG, SUPPLY ROUTE, DISP LOCATION, BC LETTER,
2230: 0003: \***     RECALL NUM, AUTHORISATION, SUPPLIER, RETURN METHOD, CARRIER, BIRD NUM,
2231: 0003: \***     REASON, WAREHOUSE ROUTE, UOD TYPE, REASON FOR DAMAGE, RECEIVING STORE,
2232: 0003: \***     DESTINATION, DATE UOD OPENED, DATE UOD DESPATCHED, TIME UOD
2233: 0003: \***     DESPATCHED, RECALL TYPE$, ITEM.BAR CODE FLAG, BOOTS/BAR CODE, QTY,       ! 1.4BG
2234: 0003: \***     ITEM UPDATED FLAG, RECORD DELIMITER, END OF RECORD MARKER
2235: 0003: \***     (ITEM/BAR CODE FLAG to ITEM UPDATED FLAG repeated NUM OF ITEMS times)
2236: 0003: \***
2237: 0003: \***  Transaction type 27 - End of LDT session
2238: 0003: \***     RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE, TIME,
2239: 0003: \***     DATE SESSION ENDED, TIME SESSION ENDED, RECORD DELIMITER,
2240: 0003: \***     END OF RECORD MARKER
2241: 0003: \***
2242: 0003: \***  Transaction type 28 - Cancelled Credit Claim
2243: 0003: \***     RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE, TIME,
2244: 0003: \***     CLAIM NUMBER, UOD NUM, NEW STATUS FLAG, RECORD DELIMITER,
2245: 0003: \***     END OF RECORD MARKER
2246: 0003: \***
2247: 0003: \***  Transaction type 29 - Zero price update
2248: 0003: \***     RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE, TIME,
2249: 0003: \***     CLAIM NUMBER, ITEM NUMBER, CLAIM VALUE, RECORD DELIMITER,
2250: 0003: \***     END OF RECORD MARKER
2251: 0003: \***
2252: 0003: \***  Transaction type 30 - CSR Issues
2253: 0003: \***     RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE, TIME,
2254: 0003: \***     BOOTS CODE, FIELD DELIMITER, QUANTITY, FIELD DELIMITER
2255: 0003: \***     EXPECTED DELIVERY DATE, RECORD DELIMITER, END OF RECORD MARKER
2256: 0003: \***
2257: 0003: \***  Transaction type 31 - Quasi Count
2258: 0003: \***     RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
2259: 0003: \***     TIME, LIST NUMBER, ITEM NUMBER, ITEM STATUS,ITEM CODE,
2260: 0003: \***     COUNT DATE, COUNT TIME, PRICE, FIELD DELIMITER, SHOP FLOOR COUNT,
2261: 0003: \***     FIELD DELIMITER, BACKROOM COUNT (PREV STOCK FIG), RECORD DELIMITER,
2262: 0003: \***      END OF REC MARKER
2263: 0003: \***
2264: 0003: \***  Transaction type 32 - Quasi Adjustment count
2265: 0003: \**      RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
2266: 0003: \***     TIME, LIST NUMBER, ITEM NUMBER, ITEM STATUS,ITEM CODE,
2267: 0003: \***     COUNT DATE, COUNT TIME, PRICE, FIELD DELIMITER, SHOP FLOOR COUNT,
2268: 0003: \***     FIELD DELIMITER, BACKROOM COUNT (PREV STOCK FIG), RECORD DELIMITER,
2269: 0003: \***     END OF REC MARKER
2270: 0003: \***
2271: 0003: \***  Transaction type 33 - +UOD Receiving
2272: 0003: \**      RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
2273: 0003: \***     TIME, UOD LICENCE PLATE, DESPATCH DATE, ACTION, ITEM COUNT,
2274: 0003: \***     for audit type+(ITEM CODE, BARCODE, DESPATCHED QTY, VARIANCE )
2275: 0003: \***     END OF REC MARKER
2276: 0003: \***
2277: 0003: \******************************************************************************
2278: 0003: 
2279: 0003:   STRING GLOBAL              \
2280: 0003:     STKMQ.FILE.NAME$,        \
2281: 0003:     STKMQ.RECORD$,           \ Used to store the whole record which is unstrung
2282: 0003:                              \ into the fields below
2283: 0003:     STKMQ.RECORD.DELIMITER$, \ 1 byte ASCII set to " (CHR$(34))
2284: 0003:     STKMQ.TRANS.TYPE$,       \ 1 byte UPD. 00 = Header record
2285: 0003:                              \             01 = W'house invoice delivery record
2286: 0003:                              \             02 = Delivery without invoice record
2287: 0003:                              \             03 = Stock out record
2288: 0003:                              \             04 = Stock count record
2289: 0003:                              \             17 = Delivery without confirmation
2290: 0003:                              \                  of Direct Order detail
2291: 0003:                              \             18 = Confirmed Dallas invoice record
2292: 0003:                              \             19 = Delivery without confirmation
2293: 0003:                              \                  of Direct Order header
2294: 0003:                              \             21 = UOD record
2295: 0003:                              \             23 = Item Level UOD record
2296: 0003:                              \             24 = Whole/Part consignment (R/ACC)
2297: 0003:                              \             25 = NS16 / Misc cont txn (R/ACC)
2298: 0003:                              \             26 = Data from LDT (R/ACC)
2299: 0003:                              \             27 = End of LDT session (R/ACC)
2300: 0003:                              \             28 = Canc. Credit Claim (R/ACC)
2301: 0003:                              \             29 = Zero price update (R/ACC)
2302: 0003:     STKMQ.FIELD.DELIMITER$,  \ 1 byte ASCII set to ; (CHR$(59))
2303: 0003:     STKMQ.CREATION.DATE$,    \ 3 byte UPD set to current date
2304: 0003:     STKMQ.CREATION.TIME$,    \ 3 byte UPD set to current time
2305: 0003:     STKMQ.CSR.MARKER$,       \ 1 byte ASCII. "Y" - This is a CSR Item      BSPK
2306: 0003:                              \               " " - This is not a CSR Item  BSPK
2307: 0003:     STKMQ.DATE$,             \ 3 byte UPD set to current date
2308: 0003:     STKMQ.TIME$,             \ 3 byte UPD set to current time
2309: 0003:     STKMQ.FSI$,              \ 1 byte ASCII
2310: 0003:     STKMQ.FOLIO.YEAR$,       \ 1 byte UPD
2311: 0003:     STKMQ.FOLIO.MONTH$,      \ 1 byte UPD
2312: 0003:     STKMQ.FOLIO.NUMBER$,     \ 2 bytes UPD
2313: 0003:     STKMQ.STORE.SUFFIX$,     \ 1 byte ASCII
2314: 0003:     STKMQ.ITEM.COUNT$,       \ 1 byte UPD between 1 and 17
2315: 0003:     STKMQ.BOOTS.CODE$,       \ 4 bytes UPD
2316: 0003:     STKMQ.ON.IDF.FLAG$,      \ 1 byte ASCII. Y = On IDF   N = Not on IDF
2317: 0003:     STKMQ.QUANTITY$,         \ variable length string equivalent to
2318: 0003:                              \ STR$(STKMQ.QUANTITY%)
2319: 0003:                              \ +ve indicates add to stock
2320: 0003:                              \ -ve indicates subtract from stock
2321: 0003:     STKMQ.REASON.CODE$,      \ 2 bytes UPD
2322: 0003:     STKMQ.STORE.RET.CODE$,   \ 2 bytes UPD
2323: 0003:     STKMQ.ENDREC.MARKER$,    \ 2 bytes ASCII set to XODOA
2324: 0003:     STKMQ.REASON$,           \ 1 byte ASCII. "I" = ineligible,
2325: 0003:                              \               "U" = unsuppliable,
2326: 0003:                              \               "Z" = deleted,
2327: 0003:                              \               " " = not removed.
2328: 0003:     STKMQ.CONCEPT.SEQUENCE$, \ 3 byte UPD. Concept group / sequence
2329: 0003:     STKMQ.INVOICE.DAY$,      \ 1 byte UPD
2330: 0003:     STKMQ.LIST.NUMBER$,      \ 4 byte ASCII
2331: 0003:     STKMQ.ITEM.NUMBER$,      \ 2 byte ASCII
2332: 0003:     STKMQ.ITEM.STATUS$,      \ 1 byte ASCII
2333: 0003:     STKMQ.COUNT.DATE$,       \ 3 byte UPD - YYMMDD
2334: 0003:     STKMQ.COUNT.TIME$,       \ 2 byte UPD - HHMM
2335: 0003:     STKMQ.PRICE$,            \ 5 byte UPD
2336: 0003:     STKMQ.SHOP.COUNT$,       \ variable ASCII
2337: 0003:     STKMQ.BKRM.COUNT$,       \ variable ASCII
2338: 0003:     STKMQ.LIST.STATUS$,      \ 1 byte ASCII
2339: 0003:     STKMQ.LEFT.TO.COUNT$,    \ variable ASCII
2340: 0003:     STKMQ.COUNT.BY.DATE$,    \ 3 bytes UPD
2341: 0003:     STKMQ.PRODUCT.GROUP$,    \ 3 bytes UPD
2342: 0003:     STKMQ.BC.LETTER$,        \ 1 byte ASCII
2343: 0003:     STKMQ.ORG.RECOUNT$,      \ VARIABLE ASCII
2344: 0003:     STKMQ.NEW.RECOUNT$,      \ VARIABLE ASCII
2345: 0003:     STKMQ.LIST.TYPE$,        \ 1 byte ASCII
2346: 0003:     STKMQ.COUNT.FLAG$,       \ 1 byte ASC from corrections file
2347: 0003:     STKMQ.STMVT.DATE$,       \ 3 bytes UPD
2348: 0003:     STKMQ.SUPPLIER.NO$,      \ 4 bytes UPD
2349: 0003:     STKMQ.ORDER.NO$,         \ 2 bytes UPD
2350: 0003:     STKMQ.ORDER.SFX$,        \ 1 byte ASCII
2351: 0003:     STKMQ.PAGE.NO$,          \ 1 byte UPD
2352: 0003:     STKMQ.ORDER.DATE$,       \ 3 bytes UPD
2353: 0003:     STKMQ.EXP.DELV.DATE$,    \ 3 bytes UPD
2354: 0003:     STKMQ.DALLAS.MKR$,       \ 1 byte ASCII DALLAS system marker
2355: 0003:                              \ 'Y' - invoice is from DALLAS system,
2356: 0003:                              \ 'N' - invoice is not from DALLAS system
2357: 0003:                              \ 'Q' - invoice contains quantity alterations
2358: 0003:     STKMQ.SOURCE$,           \ 1 byte ASCII Source flag
2359: 0003:                              \ 'S' - PSS65, 'P' - PDT, PSS57
2360: 0003:                              \ Transaction type 11 'S' - Stocktake else ' '
2361: 0003:     STKMQ.FLAG$,             \ Transaction type 11 'F' - First 'L' - Last or ' '
2362: 0003:     STKMQ.BAR.CODE$,         \ 6 bytes UPD
2363: 0003:     STKMQ.CODE.FLAG$,        \ 1 BYTE ASCII
2364: 0003:     STKMQ.QTY.GOOD$,         \ VARIABLE ASCII
2365: 0003:                              \ Quantity of singles booked in in good condition
2366: 0003:     STKMQ.QTY.BAD$,          \ VARIABLE ASCII
2367: 0003:                              \ Quantity of singles booked in in bad condition
2368: 0003:     STKMQ.QTY.STOLEN$,       \ VARIABLE ASCII
2369: 0003:                              \ Quantity of singles recognised as stolen
2370: 0003:     STKMQ.CONF.AMND.FLAG$,   \ 1 byte ASCII - Confirm/ Amend Flag
2371: 0003:                              \ 'C' - Order has been confirmed
2372: 0003:                              \ 'A' - Order has been amended
2373: 0003:                              \ ' ' - Nothing has been done to the order
2374: 0003:     STKMQ.START.TIME$,       \ 2 byte UPD (HHMM) time order started to be
2375: 0003:                              \ processed
2376: 0003:     STKMQ.END.TIME$,         \ 2 byte UPD (HHMM) time order was completed
2377: 0003:     STKMQ.SNGLS.ADDED$,      \ 2 byte UPD  Singles added to order
2378: 0003:     STKMQ.ITEMS.ADDED$,      \ 2 byte UPD  Items added to order
2379: 0003:     STKMQ.ITEMS.BOOKED$,     \ 2 byte UPD  Items booked in on the order
2380: 0003:     STKMQ.DIST.CENTRE$,      \ 1 byte UPD
2381: 0003:     STKMQ.WHSE.NUMBER$,      \ 1 byte UPD
2382: 0003:     STKMQ.STORE.NUMBER$,     \ 2 byte UPD
2383: 0003:     STKMQ.UOD.NUMBER$,       \ 3 byte UPD
2384: 0003:     STKMQ.STATUS$,           \ 1 byte ASCII
2385: 0003:                              \
2386: 0003:     STKMQ.CREDIT.CLAIM.NUM$, \ 4 byte UPD
2387: 0003:     STKMQ.CLAIM.TYPE$,       \ 1 byte ASC;  "M" = Missing,
2388: 0003:                              \              "E" = Excess,
2389: 0003:                              \              "R" = Repairs
2390: 0003:     STKMQ.SUPPLIER.NUM$,     \ 3 byte UPD
2391: 0003:     STKMQ.INVOICE.NUM$,      \*9 byte ASC
2392: 0003:     STKMQ.FOLIO.NUM$,        \ 3 byte UPD
2393: 0003:     STKMQ.BATCH.REF$,        \ 3 byte UPD
2394: 0003:     STKMQ.WHOLE.PART.CON$,   \ 1 byte ASC   "W" = Whole, "P" = Part
2395: 0003:     STKMQ.REPAIR.CATEGORY$,  \ 1 byte UPD;   1 = Plan4,
2396: 0003:                              \               2 = Estimate,
2397: 0003:                              \               3 = Boots guarantee,
2398: 0003:                              \               4 = Supplier guarantee,
2399: 0003:                              \               5 = Other guarantee,
2400: 0003:     STKMQ.REPAIR.NUM$,       \ 6 byte UPD
2401: 0003:     STKMQ.PLAN4.POLICY.NUM$, \ 6 byte UPD; (Only if repair cat is Plan4)
2402: 0003:     STKMQ.DDDA.DCDR.NUM$,    \ 4 byte UPD
2403: 0003:     STKMQ.DELIV.NOTE.NUM$,   \*9 byte ASC
2404: 0003:     STKMQ.NUM.CARTONS.RECEIV$,\1 byte UPD
2405: 0003:     STKMQ.ORDER.NUM$,        \*7 byte ASC
2406: 0003:     STKMQ.COMMENT$,          \*20 byte ASC
2407: 0003:     STKMQ.ITEM.BARCODE.FLAG$,\ 1 byte ASC;  "I" = Boots item code,
2408: 0003:                              \               "B" = Barcode.
2409: 0003:     STKMQ.ITEM.BARCODE$,     \ 7 byte UPD
2410: 0003:     STKMQ.ITEM.PRICE$,       \ 3 byte UPD;  Spaces.
2411: 0003:     STKMQ.AUTHORISATION$,    \ 15 byte ASC
2412: 0003:     STKMQ.ADJ.STOCK.FIGURE$, \ 1 byte ASC;  "Y" or "N"
2413: 0003:     STKMQ.RETURN.REASON$,    \ 1 byte UPD;  (See CCRSN file)
2414: 0003:     STKMQ.UOD.NUM$,          \ 7 byte UPD
2415: 0003:     STKMQ.UOD.STATUS$,       \ 1 byte ASC;  "O" = Open,
2416: 0003:                              \              "C" = Closed,
2417: 0003:                              \              "D" = Despatched
2418: 0003:     STKMQ.SUPPLY.ROUTE$,     \ 1 byte ASC
2419: 0003:     STKMQ.DISP.LOCATION$,    \ 1 byte ASC   "M" = MDS,
2420: 0003:                              \              "D" = Dispensary
2421: 0003:     STKMQ.RECALL.NUM$,       \ 8 byte ASC
2422: 0003:     STKMQ.SUPPLIER$,         \ 15 byte ASC
2423: 0003:     STKMQ.RETURN.METHOD$,    \ 1 byte UPD;   1 = Carrier,
2424: 0003:                              \               2 = BIRD,
2425: 0003:                              \               3 = Via D6,
2426: 0003:                              \               4 = Representative
2427: 0003:     STKMQ.CARRIER$,          \ 1 byte UPD;   1 = GPO,
2428: 0003:                              \               2 = Parcelforce,
2429: 0003:                              \               3 = Securicor,
2430: 0003:                              \               4 = Other
2431: 0003:     STKMQ.BIRD.NUM$,         \ 8 byte ASC
2432: 0003:     STKMQ.WAREHOUSE.ROUTE$,  \ 1 byte ASC   "R" = RDC,
2433: 0003:                              \              "C" = CSR
2434: 0003:     STKMQ.UOD.TYPE$,         \ 1 byte UPD;   1 = Travel Outer,
2435: 0003:                              \               2 = Town Tray,
2436: 0003:                              \               3 = Roll cage,
2437: 0003:                              \               4 = Other
2438: 0003:     STKMQ.DAMAGE.REASON$,    \ 1 byte UPD    1 = Bad packaging,
2439: 0003:                              \               2 = Poor handling
2440: 0003:     STKMQ.RECEIVING.STORE$,  \ 2 byte UPD
2441: 0003:     STKMQ.DESTINATION$,      \ 1 byte UPD    1 = Business Centre,
2442: 0003:                              \               2 = MTS,
2443: 0003:                              \               3 = Other
2444: 0003:     STKMQ.DATE.UOD.OPENED$,  \ 3 byte UPD
2445: 0003:     STKMQ.DATE.DESPATCHED$,  \ 3 byte UPD
2446: 0003:     STKMQ.TIME.DESPATCHED$,  \ 3 byte UPD
2447: 0003:     STKMQ.ITEM.UPDATED$,     \ 1 byte ASC
2448: 0003:     STKMQ.DATE.SESS.END$,    \ 3 byte UPD
2449: 0003:     STKMQ.TIME.SESS.END$,    \ 3 byte UPD
2450: 0003:     STKMQ.NEW.STATUS.FLAG$,  \ 1 byte ASC   "C" = Closed,
2451: 0003:                              \              "D" = Despatched,
2452: 0003:                              \              "X" = Cancelled
2453: 0003:     STKMQ.ITEM.NUM$,         \ 2 byte UPD   (CCITF key value)
2454: 0003:     STKMQ.CLAIM.VALUE$,      \ 3 byte UPD
2455: 0003:     STKMQ.CARTON.FLAG$,      \ 1 byte  ASCII - ' ' Old Process,             ! 1.3NWB
2456: 0003:                              \                 'N' Normal Book In           ! 1.3NWB
2457: 0003:                              \                 'A' Carton Audit Process     ! 1.3NWB
2458: 0003:                              \                 'E' Exception Process (nof)  ! 1.3NWB
2459: 0003:     STKMQ.CARTON.NO$,        \ 4 bytes UPD (0-9999)                         ! 1.3NWB
2460: 0003:     STKMQ.RECALL.TYPE$       ! 1 byte ASC   "B" = Batch Recall              ! 1.4BG
2461: 0003:                              !              "N" = Non-batch Recall          ! 1.4BG
2462: 0003:                              !              " " = Old Credit Claim          ! 1.4BG
2463: 0003: 
2464: 0003: !***********************************************************!* DC 1.6
2465: 0003: !* Added for +UOD Development                               !* DC 1.6
2466: 0003: !***********************************************************!* DC 1.6
2467: 0003:   STRING GLOBAL \                                           !* DC 1.6 
2468: 0003:     STKMQ.LICENCE.PLATE$, \                                 !* DC 1.6 
2469: 0003:     STKMQ.DESPATCH.DATE$, \                                 !* DC 1.6 
2470: 0003:     STKMQ.ACTION$, \                                        !* DC 1.6 
2471: 0003:     STKMQ.DELIVERY.DATE$, \                                 !* DC 1.6 
2472: 0003:     STKMQ.DELIVERY.TIME$, \                                 !* DC 1.6 
2473: 0003:     STKMQ.DRIVER.ID$, \                                     !* DC 1.6 
2474: 0003:     STKMQ.BOOKIN.DATE$, \                                   !* DC 1.8
2475: 0003:     STKMQ.BOOKIN.TIME$, \                                   !* DC 1.8 
2476: 0003:     STKMQ.OP.ID$, \                                         !* DC 1.6 
2477: 0003:     STKMQ.BOOKIN.METHOD$, \                                 !* DC 1.6 
2478: 0003:     STKMQ.BOOKIN.LEVEL$, \                                  !* DC 1.6 
2479: 0003:     STKMQ.GIT$, \                                           !* DC 1.6 
2480: 0003:     STKMQ.RESCAN$, \                                        !* DC 1.7
2481: 0003:     STKMQ.FILLER$                                           !* DC 1.6 
2482: 0003: 
2483: 0003:   INTEGER*2 GLOBAL           \                              !* DC 1.6 
2484: 0003:     STKMQ.SESS.NUM%,         \                              !* DC 1.6 
2485: 0003:     STKMQ.REPORT.NUM%                                       !* DC 1.6 
2486: 0003: !***********************************************************!* DC 1.6
2487: 0003: 
2488: 0003:     STRING GLOBAL                                                       \   !FMW
2489: 0003:         STKMQ.UOD.QTY$,         \                                       \   !FMW
2490: 0003:         STKMQ.CODE$(1),         \ Item Code                             \   !FMW
2491: 0003:         STKMQ.TYPE$(1),         \ Code type I = Item code               \   !FMW
2492: 0003:                                 \           B = Barcode                 \   !FMW
2493: 0003:         STKMQ.CSR.FLAG$(1),     \ CSR Flag                              \   !FMW
2494: 0003:         STKMQ.EAN.CODE$(1),     \ Barcode                               \   !FMW
2495: 0003:         STKMQ.QTY$(1),          \ Quantity                              \   !FMW
2496: 0003:         STKMQ.GOOD.QUAN$(1),    \ Good Quantity                         \   !FMW
2497: 0003:         STKMQ.DAM.QUAN$(1),     \ Damaged Quantity                      \   !FMW
2498: 0003:         STKMQ.STOL.QUAN$(1),    \ Stolen Quantity                       \   !FMW
2499: 0003:         STKMQ.PRICE.ARRAY$(1)   ! Retail Price                              !FMW
2500: 0003:                                                                             !FMW
2501: 0003:     INTEGER*2 GLOBAL                                                    \   !FMW
2502: 0003:         STKMQ.ITEM%             ! Count of items in a transaction           !FMW
2503: 0003: 
2504: 0003: %INCLUDE STOCKDEC.J86   ! Stock File
2505: 0003: \***********************************************************************
2506: 0003: \***********************************************************************
2507: 0003: \***
2508: 0003: \***    DESCRIPTION: Stock File
2509: 0003: \***                 Field Definitions         
2510: 0003: \***
2511: 0003: \***    FILE TYPE : Keyed
2512: 0003: \***
2513: 0003: \***********************************************************************
2514: 0003: \***
2515: 0003: \***    Version B.              Robert Cowey             21st Oct 1993
2516: 0003: \***    No changes to this file.
2517: 0003: \***
2518: 0003: \***    Version C.              Mark Walker              24th Jan 2014
2519: 0003: \***    F337 Centralised View of Stock
2520: 0003: \***    - Added sequence ID and item status fields.
2521: 0003: \***    - Minor formatting changes (uncommented).
2522: 0003: \***
2523: 0003: \***    Version D.              Mark Walker              15th Mar 2014
2524: 0003: \***    F337 Centralised View of Stock
2525: 0003: \***    Added next sequence ID field.
2526: 0003: \***
2527: 0003: \***    Version E.              Mark Walker               7th May 2014
2528: 0003: \***    F337 Centralised View of Stock
2529: 0003: \***    Added new 'stock flags' field for future use.
2530: 0003: \***
2531: 0003: \***********************************************************************
2532: 0003: \***********************************************************************
2533: 0003: 
2534: 0003: \***********************************************************************
2535: 0003: \***********************************************************************
2536: 0003: \***
2537: 0003: \***    File Record Layout
2538: 0003: \***
2539: 0003: \***    STOCK.BOOTS.CODE$            4 UPD  Item Code (Key)
2540: 0003: \***    STOCK.STOCK.FIG%             2 INT  Stock Figure
2541: 0003: \***    STOCK.LAST.COUNT%            2 INT  Last Count Quantity
2542: 0003: \***    STOCK.DATE.LAST.COUNT$       3 UPD  Date of Last Count
2543: 0003: \***    STOCK.DATE.LAST.MOVE$        3 UPD  Date of Last Movement
2544: 0003: \***    STOCK.LAST.REC%              2 INT  Last Receipt Quantity
2545: 0003: \***    STOCK.DATE.LAST.REC$         3 UPD  Date of Last Receipt
2546: 0003: \***    STOCK.DATE.LAST.GAP$         3 UPD  Date of Last Gap
2547: 0003: \***    STOCK.SID%                   4 INT  Sequence ID                     !CMW
2548: 0003: \***    STOCK.STATUS.1$              1 ASC  Item Status                     !CMW
2549: 0003: \***    STOCK.FLAGS%                 1 INT  Stock flags                     !EMW
2550: 0003: \***    STOCK.FILLER$                2 UPD  Filler                          !EMW
2551: 0003: \***
2552: 0003: \***********************************************************************
2553: 0003: \***********************************************************************
2554: 0003: 
2555: 0003:     INTEGER*1 GLOBAL                                                    \
2556: 0003:         STOCK.FLAGS%,                                                   \   !EMW
2557: 0003:         STOCK.RECL%
2558: 0003: 
2559: 0003:     INTEGER*2 GLOBAL                                                    \
2560: 0003:         STOCK.LAST.COUNT%,                                              \
2561: 0003:         STOCK.LAST.REC%,                                                \
2562: 0003:         STOCK.REPORT.NUM%,                                              \
2563: 0003:         STOCK.SESS.NUM%,                                                \
2564: 0003:         STOCK.STOCK.FIG%
2565: 0003: 
2566: 0003:     INTEGER*4 GLOBAL                                                    \   !CMW
2567: 0003:         STOCK.NEXT.SID%,                                                \   !DMW
2568: 0003:         STOCK.SID%                                                          !CMW
2569: 0003: 
2570: 0003:     STRING GLOBAL                                                       \
2571: 0003:         STOCK.BOOTS.CODE$,                                              \
2572: 0003:         STOCK.DATE.LAST.COUNT$,                                         \
2573: 0003:         STOCK.DATE.LAST.GAP$,                                           \
2574: 0003:         STOCK.DATE.LAST.MOVE$,                                          \
2575: 0003:         STOCK.DATE.LAST.REC$,                                           \
2576: 0003:         STOCK.FILE.NAME$,                                               \
2577: 0003:         STOCK.FILLER$,                                                  \
2578: 0003:         STOCK.STATUS.1$                                                     !CMW
2579: 0003: 
2580: 0003: %INCLUDE SUPPDEC.J86    ! Supplier File
2581: 0003: \*****************************************************************************
2582: 0003: \*****************************************************************************
2583: 0003: \***
2584: 0003: \***               %INCLUDE FOR SUPPARAM - FIELD DECLARATIONS
2585: 0003: \***                                  FILE REFERENCE PARAMETERS
2586: 0003: \***
2587: 0003: \***                      FILE TYPE    : DIRECT
2588: 0003: \***
2589: 0003: \***                      REFERENCE    : SUPPDEC.J86
2590: 0003: \***
2591: 0003: \***      Version A             Jamie Thorpe          17th Jan 2001
2592: 0003: \***
2593: 0003: \***      Version B             Brian Greenfield      5th Nov 2004
2594: 0003: \***
2595: 0003: \*****************************************************************************
2596: 0003: \*****************************************************************************
2597: 0003: 
2598: 0003:   STRING GLOBAL                    \
2599: 0003:      SUPPARAM.FILE.NAME$,          \
2600: 0003:      SUPPARAM.RECORD$,             \
2601: 0003:      SUPPARAM.ACTIVE.FLAG$,        \
2602: 0003:      SUPPARAM.LAST.SALE.CHECK$,    \
2603: 0003:      SUPPARAM.INITIAL.LOAD.CHECK$, \
2604: 0003:      SUPPARAM.INITIAL.LOAD.DATE$,  \
2605: 0003:      SUPPARAM.INC.DEC.FLAG$,       \
2606: 0003:      SUPPARAM.LAST.SALE.INC.CHECK$,\ ! BBG
2607: 0003:      SUPPARAM.FILLER$      
2608: 0003: 
2609: 0003:   INTEGER*2 GLOBAL                 \
2610: 0003:     SUPPARAM.REPORT.NUM%,          \
2611: 0003:     SUPPARAM.RECL%,                \
2612: 0003:     SUPPARAM.SESS.NUM%
2613: 0003: 
2614: 0003:   INTEGER*4 GLOBAL                 \
2615: 0003:     SUPPARAM.REC.NO%
2616: 0003: %INCLUDE WEEEDEC.J86    ! Waste Electrical & Electronic Equipment Update File
2617: 0003: REM \
2618: 0003: \******************************************************************************
2619: 0003: \******************************************************************************
2620: 0003: \***
2621: 0003: \***         %INCLUDE FOR WEEE UPDATE FILE - FIELD DECLARATIONS
2622: 0003: \***                                         FILE REFERENCE PARAMETERS
2623: 0003: \***
2624: 0003: \***               FILE TYPE    : Sequential
2625: 0003: \***
2626: 0003: \***               REFERENCE    : WEEEDEC.J86
2627: 0003: \***
2628: 0003: \***
2629: 0003: \*******************************************************************************
2630: 0003: \*******************************************************************************
2631: 0003: 
2632: 0003:   STRING GLOBAL           \
2633: 0003:     WEEE.ITEM.CODE$,       \    
2634: 0003:     WEEEUF.FILE.NAME$
2635: 0003: 
2636: 0003:   INTEGER*2 GLOBAL        \
2637: 0003:     WEEEUF.REPORT.NUM%,   \
2638: 0003:     WEEEUF.SESS.NUM%,     \ 
2639: 0003:     WEEEUF.RECL%
2640: 0003:   
2641: 0003:   INTEGER*4 GLOBAL        \
2642: 0003:     WEEE.ITEM.PRF.AMT%
2643: 0003:     
2644: 0003: 
2645: 0003: 
2646: 0003: 
2647: 0003: \*******************************************************************************
2648: 0003: \***
2649: 0003: \***    Included code defining function related global variables
2650: 0003: \***
2651: 0003: \***............................................................................
2652: 0003: %INCLUDE PSBF01G.J86    ! APPLICATION.LOG
2653: 0003: REM \
2654: 0003: \*******************************************************************************
2655: 0003: \*******************************************************************************
2656: 0003: \***
2657: 0003: \***       %INCLUDE FOR GLOBAL DEFINITIONS FOR FUNCTION APPLICATION.LOG
2658: 0003: \***
2659: 0003: \***                FUNCTION NUMBER    : PSBF01
2660: 0003: \***
2661: 0003: \***                REFERENCE          : PSBF01G.J86
2662: 0003: \***
2663: 0003: \***                DATE OF LAST AMENDMENT  - 27/2/86
2664: 0003: \***
2665: 0003: \***
2666: 0003: \*******************************************************************************
2667: 0003: 
2668: 0003:       INTEGER GLOBAL  F01.RETURN.CODE%
2669: 0003: 
2670: 0003: 
2671: 0003: %INCLUDE PSBF02G.J86    ! UPDATE.DATE                                ! 1.18 RC
2672: 0003: REM\
2673: 0003: \*******************************************************************************
2674: 0003: \*******************************************************************************
2675: 0003: \***
2676: 0003: \***        INCLUDE       : UPDATE.DATE globals
2677: 0003: \***
2678: 0003: \***        REFERENCE     : PSBF02G.J86
2679: 0003: \***
2680: 0003: \***        Version A     Bruce Scriver      4th March 1986
2681: 0003: \*** 
2682: 0003: \***        Version B     Andrew Wedgeworth   6th July 1992
2683: 0003: \***        Removal of return code field which no longer required.
2684: 0003: \***
2685: 0003: \*******************************************************************************
2686: 0003: \*******************************************************************************
2687: 0003: 
2688: 0003:       STRING   GLOBAL F02.DATE$
2689: 0003: 
2690: 0003:       ! 1 line deleted from here                                       ! BAW
2691: 0003: 
2692: 0003: %INCLUDE PSBF13G.J86    ! PSDATE
2693: 0003: REM\
2694: 0003: \*******************************************************************************
2695: 0003: \*******************************************************************************
2696: 0003: \***
2697: 0003: \***        INCLUDE       : PSDATE globals
2698: 0003: \***
2699: 0003: \***        REFERENCE     : PSBF13G.J86
2700: 0003: \***
2701: 0003: \***     VERSION A                                  Bruce Scriver  6th Mar 86             
2702: 0003: \***            
2703: 0003: \***     VERSION B                                  Janet Lawrence 17 Aug 90
2704: 0003: \***     Add global to be used to indicate whether or not the function should
2705: 0003: \***     log an event when an invalid date is passed to it.
2706: 0003: \***
2707: 0003: \***     VERSION C                               Andrew Wedgeworth 17 July 92
2708: 0003: \***     Return code removed as no longer required.
2709: 0003: \***
2710: 0003: \*******************************************************************************
2711: 0003: \*******************************************************************************
2712: 0003: 
2713: 0003:       STRING    GLOBAL F13.DAY$,			\
2714: 0003:                        F13.DISPLAY.MESSAGE$		! BJAL
2715: 0003: 
2716: 0003: 
2717: 0003: %INCLUDE PSBF18G.J86    ! CALCULATE BOOTS CHECK DIGIT          ! 1.19 RC (238)
2718: 0003: REM\
2719: 0003: \*******************************************************************************
2720: 0003: \*******************************************************************************
2721: 0003: \***
2722: 0003: \***        INCLUDE       : CALC.BOOTS.CODE.CHECK.DIGIT globals
2723: 0003: \***
2724: 0003: \***        REFERENCE     : PSBF18G.J86
2725: 0003: \***
2726: 0003: \***        Version A     Stephen Kelsey                  23rd March 1987
2727: 0003: \***
2728: 0003: \***        Version B     Andrew Wedgeworth                 7th July 1992
2729: 0003: \***        Removal of return code field which no longer required.
2730: 0003: \***
2731: 0003: \*******************************************************************************
2732: 0003: \*******************************************************************************
2733: 0003: 
2734: 0003:       STRING   GLOBAL F18.CHECK.DIGIT$
2735: 0003:     
2736: 0003:       ! 1 line deleted from here                                       ! BAW    
2737: 0003: 
2738: 0003: %INCLUDE PSBF19G.J86    ! UPDATE IRF GLOBALS
2739: 0003: REM \
2740: 0003: \*******************************************************************************
2741: 0003: \*******************************************************************************
2742: 0003: \***
2743: 0003: \***
2744: 0003: \***            INCLUDE       : UPDATE IRF globals
2745: 0003: \***
2746: 0003: \***            REFERENCE     : PSBF19G.J86
2747: 0003: \***
2748: 0003: \***      Version A              Richard Hopkinson            16th March 1988
2749: 0003: \***
2750: 0003: \***      Version B              Janet Lawrence               12th April 1989
2751: 0003: \***      Version letter incremented to match that of external defintion of 
2752: 0003: \***      function 19.  
2753: 0003: \***
2754: 0003: \***      Version C              Andrew Wedgeworth             21st July 1992
2755: 0003: \***      Return code field removed as no longer used.
2756: 0003: \***
2757: 0003: \***      Version F              Steve Perkins                 20th October 1993
2758: 0003: \***      Version letter updated to keep in line with PSBF19.BAS
2759: 0003: \***
2760: 0003: \***    REVISION 1.9.                ROBERT COWEY.                08 DEC 2003.
2761: 0003: \***    Changes for Deal Limit removal project.
2762: 0003: \***    Revision number updated to keep in step with PSBF19.BAS.
2763: 0003: \***    Declared variables for IRFDEX and F19.NODE.FILE...
2764: 0003: \***
2765: 0003: \*******************************************************************************
2766: 0003: \*******************************************************************************
2767: 0003: 
2768: 0003:       STRING   F19.RETURNED.STRING                                     ! CAW
2769: 0003:       STRING   F19.NODE.FILE.NAME$                                         ! 1.9 RC
2770: 0003: 
2771: 0003:       STRING   GLOBAL NODE.ID$
2772: 0003:       STRING   GLOBAL TIF.FULL$
2773: 0003:       STRING   GLOBAL TIF.OPEN.FLAG$
2774: 0003:       STRING   GLOBAL TMCF.FULL$
2775: 0003:       STRING   GLOBAL TMCF.OPEN.FLAG$
2776: 0003:       
2777: 0003:       INTEGER*2 GLOBAL F19.IRFDEX.SESS.NUM%                                ! 1.9 RC
2778: 0003:       
2779: 0003:       INTEGER*2 F19.NODE.REPORT.NUM%                                       ! 1.9 RC
2780: 0003:       INTEGER*2 F19.NODE.SESS.NUM%                                         ! 1.9 RC
2781: 0003: %INCLUDE PSBF20G.J86    ! Sess Num Utility
2782: 0003: REM\
2783: 0003: \*******************************************************************************
2784: 0003: \*******************************************************************************
2785: 0003: \***
2786: 0003: \***     %INCLUDE GLOBAL VARIABLE DEFINITIONS FOR SESS.NUM.UTILITY FUNCTION
2787: 0003: \***
2788: 0003: \***                       REFERENCE     : PSBF20G.J86
2789: 0003: \*** 
2790: 0003: \***     Version A              Bruce Scrive                   5th May 1988   
2791: 0003: \*** 
2792: 0003: \***     Version B              Robert Cowey                   7th May 1991
2793: 0003: \***     Global variable F20.INTEGER.FILE.NO% changed from one byte integer
2794: 0003: \***     to two byte integer.
2795: 0003: \***
2796: 0003: \***     Version D              Andrew Wedgeworth             1st July 1992
2797: 0003: \***     F20.RETURN.CODE% removed as it is no longer required.
2798: 0003: \***
2799: 0003: \*******************************************************************************
2800: 0003: \*******************************************************************************
2801: 0003: 
2802: 0003:       STRING    GLOBAL F20.FILE.NAME$,                                 \
2803: 0003:                        F20.STRING.FILE.NO$,                            \
2804: 0003:                        F20.TABLE.DIMENSIONED.FLAG$,                    \
2805: 0003:                        SESS.NUM.TABLE$(1)
2806: 0003: 
2807: 0003:       INTEGER*2 GLOBAL F20.INTEGER.FILE.NO%
2808: 0003: 
2809: 0003:       ! 1 line deleted from here                                       ! DAW 
2810: 0003: 
2811: 0003: %INCLUDE PSBUSEG.J86    ! Chain parameters
2812: 0003: \/*********************************************************************/ PSBUSEG
2813: 0003: \/*                                                                   */ PSBUSEG
2814: 0003: \/* PSBUSEG.J86  -  Definitions for Chain/Use with PSB Screen Program */ PSBUSEG
2815: 0003: \/* ----------------------------------------------------------------- */ PSBUSEG
2816: 0003: \/*                                                                   */ PSBUSEG
2817: 0003: \/*********************************************************************/ PSBUSEG
2818: 0003:                                                                        ! PSBUSEG
2819: 0003:         STRING GLOBAL  PSBCHN.PRG,      \ Program to chain to          ! PSBUSEG
2820: 0003:                        PSBCHN.OP,       \ Operator Id                  ! PSBUSEG
2821: 0003:                        PSBCHN.APP,      \ Program chained from         ! PSBUSEG
2822: 0003:                        PSBCHN.MENCON,   \ Menu Control                 ! PSBUSEG
2823: 0003:                        PSBCHN.U1,       \ User parameter               ! PSBUSEG
2824: 0003:                        PSBCHN.U2,       \ User parameter               ! PSBUSEG
2825: 0003:                        PSBCHN.U3        ! User parameter               ! PSBUSEG
2826: 0003:                                                                        ! PSBUSEG
2827: 0003: 
2828: 0003: 
2829: 0003: \*******************************************************************************
2830: 0003: \***    PSB2100 variables
2831: 0003: \***............................................................................
2832: 0003:     INTEGER*1 GLOBAL                        \
2833: 0003:         CIPPM.PRESENT,                      \                         ! 1.16 RC (226)
2834: 0003:         CURR.SORT.NEEDED,                   \                         ! 1.10 RC (113)
2835: 0003:         END.OF.IUF.FILE,                    \
2836: 0003:         FALSE,                              \
2837: 0003:         FILE.TIME.AFTER.6PM,                \                         ! 1.18 RC
2838: 0003:         FOUND,                              \
2839: 0003:         ITEM.PRE.PROCESSING.CHECK,          \
2840: 0003:         IUF.EXISTS,                         \
2841: 0003:         IUF.OPEN,                           \                         ! 1.6 RC (87)
2842: 0003:         IUF.OPEN.ERROR.REPORTED,            \                         ! 1.8 RC (8)
2843: 0003:         PRICE.CHANGE.TODAY,                 \                         ! 1.10 RC (113)
2844: 0003:         PROCESS.ITEM,                       \
2845: 0003:         SKIP.IUF.PROCESSING,                \                                   !1.6CSk
2846: 0003:         TRUE                                !
2847: 0003: 
2848: 0003:     INTEGER*2 GLOBAL                        \
2849: 0003:         BARCODE.COUNT%,                     \
2850: 0003:         CURR.PCR.COUNT%,                    \
2851: 0003:         CURR.SESS.NUM%,                     \
2852: 0003:         CURRENT.REPORT.NUM%,                \
2853: 0003:         ERROR.COUNT%,                       \
2854: 0003:         F20.INTEGER%,                       \
2855: 0003:         IUF.BACKUP.SESS.NUM%,               \
2856: 0003:         IUF.BATCH.COUNT%,                   \
2857: 0003:         MAX.BARCODES%,                      \
2858: 0003:         MAX.PRICE.CHANGES%,                 \
2859: 0003:         MESSAGE.NO%,                        \
2860: 0003:         NO.OF.CHLAMYDIA%,                   \                                   !1.6CSk
2861: 0003:         NO.OF.STATINS%,                     \                                   !1.6CSk
2862: 0003:         PREV.PCR.COUNT%,                    \
2863: 0003:         STATUS%,                            \                                   !1.6CSk
2864: 0003:         WEEE.ITEM.LIMIT%                    !
2865: 0003: 
2866: 0003:     INTEGER*4 GLOBAL                        \
2867: 0003:         ADXSERVE.RET.CODE%,                 \
2868: 0003:         ADXSERVE.RETURN.CODE%,              \
2869: 0003:         COUNT.ACTUAL%,                      \
2870: 0003:         COUNT.EXPECTED%,                    \
2871: 0003:         COUNT.RECORDS.IUF%,                 \
2872: 0003:         DIR.SESS.NUM%,                      \
2873: 0003:         IUF.BATCH.ITEM.TOTAL%,              \
2874: 0003:         IUF.BUFF.SIZE%,                     \
2875: 0003:         IUF.ITEM.BATCH.LIMIT%,              \
2876: 0003:         IUF.ITEM.SKIP%,                     \
2877: 0003:         IUF.J103.COUNT%,                    \
2878: 0003:         IUF.RECORD.COUNT%,                  \
2879: 0003:         LOG.BUFF.SIZE%,                     \
2880: 0003:         LOG.SESS.NUM%,                      \
2881: 0003:         NO.OF.BARCODE.RECS%,                \
2882: 0003:         NO.OF.NEW.PPF.ITEMS%,               \
2883: 0003:         NO.OF.OLD.PPF.ITEMS%,               \
2884: 0003:         NO.OF.OUT.PPF.ITEMS%,               \
2885: 0003:         NO.OF.PRICE.CHANGE.RECS%,           \
2886: 0003:         PERCENT.VAL%,                       \
2887: 0003:         PPFI.BUFF.SIZE%,                    \
2888: 0003:         PPFO.BUFF.SIZE%,                    \
2889: 0003:         PROGRESS.COUNT%,                    \
2890: 0003:         RC%,                                \
2891: 0003:         RECS.PER.5%,                        \
2892: 0003:         TOTAL.PPF.RECS%,                    \
2893: 0003:         WEEE.ITEM.COUNT%,                   \
2894: 0003:         WEEEUF.BUFF.SIZE%                   !
2895: 0003: 
2896: 0003:     STRING GLOBAL                           \
2897: 0003:         BARCODE.TABLE$(1),                  \
2898: 0003:         CHLAMYDIA.ID$(1),                   \                                   !1.6CSk
2899: 0003:         STATINS$(1),                        \                                   !1.6CSk
2900: 0003:         WEEEUF.TABLE$(1)                    !
2901: 0003: 
2902: 0003:     STRING GLOBAL                           \
2903: 0003:         ACD.FLAG$,                          \
2904: 0003:         APPLICATION.STATUS.INFO$,           \
2905: 0003:         BACKUP.SOURCE.FILE$,                \
2906: 0003:         CHLAM.TEMP$,                        \                                   !1.6CSk
2907: 0003:         CHLAMYDIA.LIST$,                    \                                   !1.6CSk
2908: 0003:         COMM.TAIL$,                         \
2909: 0003:         COMPARE$,                           \
2910: 0003:         CRLF$,                              \
2911: 0003:         CT.PARAMBLK$,                       \
2912: 0003:         CT.TIMEDATE.TABLE$,                 \
2913: 0003:         DEC.MESSAGE$,                       \
2914: 0003:         DIR.FILENAME$,                      \
2915: 0003:         DIR.RECORD$,                        \
2916: 0003:         ERROR$,                             \
2917: 0003:         EVENT.222.DATA$,                    \
2918: 0003:         EXP.REC.TYPE$,                      \
2919: 0003:         F13.INPUT.DATE$,                    \
2920: 0003:         F18.SOPTS.READ$,                    \                           ! 1.19 RC (238)
2921: 0003:         F20.FUNCTION$,                      \
2922: 0003:         F20.STRING$,                        \
2923: 0003:         FILE.DATE$,                         \
2924: 0003:         FILE.OPERATION$,                    \
2925: 0003:         FORM$,                              \
2926: 0003:         GCM.PG.LIST$,                       \  List of Gift Card mall   ! ACSk
2927: 0003:                                             \  Product Groups read in   ! ACSk
2928: 0003:                                             \  from BCF Rec: 22         ! ACSk
2929: 0003:         IUF.BACKUP.FILENAME$,               \
2930: 0003:         JOBSOK.FLAG$,                       \
2931: 0003:         LOG.FILENAME$,                      \
2932: 0003:         MODULE.NUMBER$,                     \
2933: 0003:         MSG$,                               \
2934: 0003:         PHASE$,                             \
2935: 0003:         PINFO.TABLE$,                       \
2936: 0003:         PREV.IUF.BOOTS.CODE$,               \
2937: 0003:         PREV.REC.TYPE$,                     \
2938: 0003:         PROCESSING.DATE$,                   \
2939: 0003:         PROG.NAME$,                         \
2940: 0003:         PSB20.PATH.NAME$,                   \
2941: 0003:         RETURN.FLAG$,                       \
2942: 0003:         RUN.DATE$,                          \
2943: 0003:         RUN.TIME$,                          \
2944: 0003:         SOFTS.REC.62$,                      \
2945: 0003:         STATIN.INDICATOR$,                  \                                   !1.6CSk
2946: 0003:         STKMQ.OPEN.FLAG$,                   \
2947: 0003:         STORE.NUMBER$,                      \
2948: 0003:         SUCCESS$,                           \
2949: 0003:         SVC.PARAM$,                         \
2950: 0003:         TODAY$,                             \
2951: 0003:         YESTERDAY.DDMMYY$,                  \                                   ! 1.18 RC
2952: 0003:         VAR.STRING.1$,                      \
2953: 0003:         VAR.STRING.2$                       !
2954: 0003: 
2955: 0003:     STRING GLOBAL                           \
2956: 0003:         CURR.AGE.RESTRICTION$,              \
2957: 0003:         CURR.BC.LETTER$,                    \
2958: 0003:         CURR.BLOCKED.FROM.SALE$,            \
2959: 0003:         CURR.BOOTS.CODE$,                   \
2960: 0003:         CURR.BOOTS.COM.EXTENDED$,           \
2961: 0003:         CURR.CONTAINS.ALCOHOL$,             \
2962: 0003:         CURR.CONTAINS.ASPIRIN$,             \
2963: 0003:         CURR.CONTAINS.EPHEDRINE$,           \
2964: 0003:         CURR.CONTAINS.IBUPROFEN$,           \
2965: 0003:         CURR.CONTAINS.NONSOLID.PAINKILLER$, \
2966: 0003:         CURR.CONTAINS.PARACETAMOL$,         \
2967: 0003:         CURR.CONTAINS.PSEUDOEPHEDRINE$,     \
2968: 0003:         CURR.CURRENT.PRICE$,                \
2969: 0003:         CURR.DATE.SENSITIVE$,               \
2970: 0003:         CURR.DISCOUNTABLE$,                 \ ! Reinstated original variable name ! 1.6 RC (21)
2971: 0003:         CURR.EARN.POINTS$,                  \
2972: 0003:         CURR.ENF.PRICE.ENTRY$,              \
2973: 0003:         CURR.ETHICAL.ACTIVE$,               \
2974: 0003:         CURR.ETHICAL.CLASS$,                \
2975: 0003:         CURR.ETHICAL.DESCRIPTION$,          \
2976: 0003:         CURR.ETHICAL.PACK.SIZE$,            \
2977: 0003:         CURR.GIFTCARD$,                     \
2978: 0003:         CURR.GIVEAWAY$,                     \
2979: 0003:         CURR.GRP.CODE.FLAG$,                \
2980: 0003:         CURR.GUARANTEE.LENGTH$,             \
2981: 0003:         CURR.INSURANCE$,                    \
2982: 0003:         CURR.ITEM.QTY$,                     \
2983: 0003:         CURR.OWN.BRAND$,                    \
2984: 0003:         CURR.PRIMARY.SUPPLIER$,             \
2985: 0003:         CURR.PROD.GRP$,                     \
2986: 0003:         CURR.REC.TYPE$,                     \
2987: 0003:         CURR.REDEEMABLE$,                   \
2988: 0003:         CURR.RESALEABLE$,                   \
2989: 0003:         CURR.RETURN.ROUTE$,                 \
2990: 0003:         CURR.RETURNABLE$,                   \
2991: 0003:         CURR.S.E.DESC$,                     \
2992: 0003:         CURR.SPECIAL.INSTRUCTION$,          \
2993: 0003:         CURR.STATUS.1$,                     \
2994: 0003:         CURR.STNDRD.DESC$,                  \
2995: 0003:         CURR.STOCK.SYSTEM.FLAG$,            \
2996: 0003:         CURR.SUPPLY.ROUTE$,                 \
2997: 0003:         CURR.TILL.DESC$,                    \
2998: 0003:         CURR.UNIT.MEASUREMENT$,             \
2999: 0003:         CURR.UNIT.NAME$,                    \
3000: 0003:         CURR.UNRESTRICTED.GROUP.CODE$       !
3001: 0003: 
3002: 0003:     STRING GLOBAL                           \
3003: 0003:         CURR.DATE.DUE$(1),                  \
3004: 0003:         CURR.INC.DEC.FLAG$(1),              \
3005: 0003:         CURR.MARKDOWN$(1),                  \
3006: 0003:         CURR.PRICE$(1),                     \
3007: 0003:         CURR.RPD.NO$(1),                    \
3008: 0003:         CURR.STATUS.FLAG$(1)                !
3009: 0003: 
3010: 0003:     STRING GLOBAL                           \
3011: 0003:         PREV.DATE.DUE$(1),                  \
3012: 0003:         PREV.INC.DEC.FLAG$(1),              \
3013: 0003:         PREV.MARKDOWN$(1),                  \
3014: 0003:         PREV.PRICE$(1),                     \
3015: 0003:         PREV.RPD.NO$(1),                    \
3016: 0003:         PREV.STATUS.FLAG$(1)                !
3017: 0003: 
3018: 0003:     STRING GLOBAL \                                            ! 1.10 RC (113)
3019: 0003:         SORT.TABLE$(1)                                         ! 1.10 RC (113)
3020: 0003: 
3021: 0003:     STRING GLOBAL                           \                           !HRN
3022: 0003:         CURR.GRP.NO$,                       \                           !HRN
3023: 0003:         CURR.RESTRICT.SALES.FLAG$           !                           !HRN
3024: 0003: 
3025: 0003: \*******************************************************************************
3026: 0003: \***
3027: 0003: \***    External functions
3028: 0003: \***
3029: 0003: \***............................................................................
3030: 0003: %INCLUDE ADXCOPY.J86    ! I.B.M. system subroutine for copying files
3031: 0003: \******************************************************************************
3032: 0003: \******************************************************************************
3033: 0003: \***                                                                        ***
3034: 0003: \***    %INCLUDE FOR SUBROUTINE ADXCOPYF (an I.B.M. system subroutine)      ***
3035: 0003: \***                                                                        ***
3036: 0003: \***         DATE WRITTEN  :  13th May 1988                                 ***
3037: 0003: \***                                                                        ***
3038: 0003: \******************************************************************************
3039: 0003: \******************************************************************************
3040: 0003: 
3041: 0003:    SUB  ADXCOPYF (RETC, INFILE, OUTFILE, OPT0, OPT1, OPT2) EXTERNAL
3042: 0003: 
3043: 0003:       INTEGER*4   RETC
3044: 0003:       STRING      INFILE, OUTFILE
3045: 0003:       INTEGER*2   OPT0, OPT1, OPT2
3046: 0003: 
3047: 0003:    END  SUB
3048: 0003: 
3049: 0003: %INCLUDE ADXSERVE.J86   ! I.B.M. system function to obtain Controller Info
3050: 0003: \******************************************************************************
3051: 0003: \******************************************************************************
3052: 0003: \***                                                                        ***
3053: 0003: \***    %INCLUDE FOR FUNCTION ADXSERVE (an I.B.M. system function)          ***
3054: 0003: \***                                                                        ***
3055: 0003: \***         AUTHOR        :  Bruce Scriver                                 ***
3056: 0003: \***                                                                        ***
3057: 0003: \***         DATE WRITTEN  :  14th March 1986                               ***
3058: 0003: \***                                                                        ***
3059: 0003: \***         DATE OF LAST REVISION  - 14th March 1986                       ***
3060: 0003: \***                                                                        ***
3061: 0003: \***                                                                        ***
3062: 0003: \******************************************************************************
3063: 0003: \******************************************************************************
3064: 0003: 
3065: 0003:    SUB ADXSERVE (RETURN.CODE%,                                                \
3066: 0003:                  ADX.FUNCTION%,                                               \
3067: 0003:                  ADX.PARM.1%,                                                 \
3068: 0003:                  ADX.PARM.2$)                                                 \
3069: 0003:    EXTERNAL
3070: 0003:   
3071: 0003:       STRING     ADX.PARM.2$
3072: 0003: 
3073: 0003:       INTEGER*2  ADX.FUNCTION%,                                               \
3074: 0003:                  ADX.PARM.1%
3075: 0003: 
3076: 0003:       INTEGER*4  RETURN.CODE%                                                 \
3077: 0003: 
3078: 0003:    END SUB     
3079: 0003: 
3080: 0003: %INCLUDE BCFEXT.J86     ! Boots Control File
3081: 0003: \*****************************************************************************
3082: 0003: \*****************************************************************************
3083: 0003: \***
3084: 0003: \***         FUNCTION DEFINITIONS FOR BOOTS CONTROL FILE
3085: 0003: \***
3086: 0003: \***                    REFERENCE : BCFEXTA.J86
3087: 0003: \***
3088: 0003: \***    Version A           Steve Windsor          5th Jan 1993
3089: 0003: \***
3090: 0003: \***    Version B           Michael J. Kelsall    14th Sep 1993
3091: 0003: \***    Code incremented to maintain consistency with other included code
3092: 0003: \***    for RETURNS/AUTOMATIC CREDIT CLAIMING system.
3093: 0003: \***
3094: 0003: \***    Version C           Stuart William McConnachie 23rd Jan 1995
3095: 0003: \***    Addition of TXR serial number as part of the TRANSACTION RETRIEVAL
3096: 0003: \***    project.
3097: 0003: \***
3098: 0003: \***    Version D           Stuart William McConnachie  7th June 1995
3099: 0003: \***    Converted calls to enable more than 1 record on the BCF.
3100: 0003: \***    The second record is to be used for the No7 customer card trial.
3101: 0003: \***
3102: 0003: \***    Revision 4.6            ROBERT COWEY.            19 MAY 2003.
3103: 0003: \***    Modifications for All Txn Data To CDAS project.
3104: 0003: \***    No changes to this file.
3105: 0003: \***
3106: 0003: \***    Revision 4.7            Julia Stones              9th July 2003
3107: 0003: \***    Modifications for New Lines Report project.
3108: 0003: \***    No changes to this file.
3109: 0003: \***
3110: 0003: \*****************************************************************************
3111: 0003: \*****************************************************************************
3112: 0003: 
3113: 0003:    FUNCTION BCF.SET EXTERNAL
3114: 0003:    END FUNCTION
3115: 0003: 
3116: 0003:   FUNCTION READ.BCF EXTERNAL
3117: 0003:    INTEGER*2 READ.BCF
3118: 0003:   END FUNCTION
3119: 0003: 
3120: 0003:   FUNCTION READ.BCF.LOCK EXTERNAL
3121: 0003:    INTEGER*2 READ.BCF.LOCK
3122: 0003:   END FUNCTION
3123: 0003: 
3124: 0003:   FUNCTION WRITE.BCF EXTERNAL
3125: 0003:    INTEGER*2 WRITE.BCF
3126: 0003:   END FUNCTION
3127: 0003: 
3128: 0003:   FUNCTION WRITE.BCF.UNLOCK EXTERNAL
3129: 0003:    INTEGER*2 WRITE.BCF.UNLOCK
3130: 0003:   END FUNCTION
3131: 0003: 
3132: 0003:   FUNCTION WRITE.HOLD.BCF.UNLOCK EXTERNAL
3133: 0003:    INTEGER*2 WRITE.HOLD.BCF.UNLOCK
3134: 0003:   END FUNCTION
3135: 0003: 
3136: 0003: %INCLUDE BTCMEM.J86     ! Controller CBASIC Memory Functions
3137: 0003: !********************************************************************
3138: 0003: !***
3139: 0003: !***    INCLUDED CODE:  BTCMEM.J86
3140: 0003: !***    AUTHOR:         Stuart William McConnachie
3141: 0003: !***    DATE:           26th February 2006
3142: 0003: !***
3143: 0003: !********************************************************************
3144: 0003: !***
3145: 0003: !***    Controller CBASIC Memory Functions
3146: 0003: !***
3147: 0003: !********************************************************************
3148: 0003: 
3149: 0003: !Get a single byte integer from a string offset
3150: 0003: FUNCTION GETN1 (S$, P%) EXTERNAL
3151: 0003:     STRING S$
3152: 0003:     INTEGER*2 P%
3153: 0003:     INTEGER*2 GETN1
3154: 0003: END FUNCTION
3155: 0003: 
3156: 0003: !Get a two byte integer from a string offset
3157: 0003: FUNCTION GETN2 (S$, P%) EXTERNAL
3158: 0003:     STRING S$
3159: 0003:     INTEGER*2 P%
3160: 0003:     INTEGER*2 GETN2
3161: 0003: END FUNCTION
3162: 0003: 
3163: 0003: !Get a four byte integer from a string offset
3164: 0003: FUNCTION GETN4 (S$, P%) EXTERNAL
3165: 0003:     STRING S$
3166: 0003:     INTEGER*2 P%
3167: 0003:     INTEGER*4 GETN4
3168: 0003: END FUNCTION
3169: 0003: 
3170: 0003: !Get a 10 byte CBASIC real from a string offset
3171: 0003: FUNCTION GETR10 (S$, P%) EXTERNAL
3172: 0003:     STRING S$
3173: 0003:     INTEGER*2 P%
3174: 0003:     REAL GETR10
3175: 0003: END FUNCTION
3176: 0003: 
3177: 0003: !Put a single byte integer into a string at offset
3178: 0003: FUNCTION PUTN1 (S$, P%, N%) EXTERNAL
3179: 0003:     STRING S$
3180: 0003:     INTEGER*2 P%
3181: 0003:     INTEGER*1 N%
3182: 0003:     INTEGER*1 PUTN1
3183: 0003: END FUNCTION
3184: 0003: 
3185: 0003: !Put a two byte integer into a string at offset
3186: 0003: FUNCTION PUTN2 (S$, P%, N%) EXTERNAL
3187: 0003:     STRING S$
3188: 0003:     INTEGER*2 P%
3189: 0003:     INTEGER*2 N%
3190: 0003:     INTEGER*1 PUTN2
3191: 0003: END FUNCTION
3192: 0003: 
3193: 0003: !Put a four byte integer into a string at offset
3194: 0003: FUNCTION PUTN4 (S$, P%, N%) EXTERNAL
3195: 0003:     STRING S$
3196: 0003:     INTEGER*2 P%
3197: 0003:     INTEGER*4 N%
3198: 0003:     INTEGER*1 PUTN4
3199: 0003: END FUNCTION
3200: 0003: 
3201: 0003: !Put a 10 byte CBASIC real into a string at offset
3202: 0003: FUNCTION PUTR10 (S$, P%, R) EXTERNAL
3203: 0003:     STRING S$
3204: 0003:     INTEGER*2 P%
3205: 0003:     REAL R
3206: 0003:     INTEGER*1 PUTR10
3207: 0003: END FUNCTION
3208: 0003: 
3209: 0003: !Peek a two byte integer from a memory address
3210: 0003: FUNCTION PEEKN2 (A%) EXTERNAL
3211: 0003:     INTEGER*4 A%
3212: 0003:     INTEGER*2 PEEKN2
3213: 0003: END FUNCTION
3214: 0003: 
3215: 0003: !Peek a four byte integer from a memory address
3216: 0003: FUNCTION PEEKN4 (A%) EXTERNAL
3217: 0003:     INTEGER*4 A%
3218: 0003:     INTEGER*4 PEEKN4
3219: 0003: END FUNCTION
3220: 0003: 
3221: 0003: !Peek a 10 byte CBASIC real from a memory address
3222: 0003: FUNCTION PEEKR10 (A%) EXTERNAL
3223: 0003:     INTEGER*4 A%
3224: 0003:     REAL PEEKR10
3225: 0003: END FUNCTION
3226: 0003: 
3227: 0003: !Poke a two byte integer to a memory address
3228: 0003: FUNCTION POKEN2 (A%, N%) EXTERNAL
3229: 0003:     INTEGER*4 A%
3230: 0003:     INTEGER*2 N%
3231: 0003:     INTEGER*1 POKEN2
3232: 0003: END FUNCTION
3233: 0003: 
3234: 0003: !Poke a four byte integer to a memory address
3235: 0003: FUNCTION POKEN4 (A%, N%) EXTERNAL
3236: 0003:     INTEGER*4 A%
3237: 0003:     INTEGER*4 N%
3238: 0003:     INTEGER*1 POKEN4
3239: 0003: END FUNCTION
3240: 0003: 
3241: 0003: !Poke a 10 byte CBASIC real to a memory address
3242: 0003: FUNCTION POKER10 (A%, R) EXTERNAL
3243: 0003:     INTEGER*4 A%
3244: 0003:     REAL R
3245: 0003:     INTEGER*1 POKER10
3246: 0003: END FUNCTION
3247: 0003: 
3248: 0003: %INCLUDE CIPPMEXT.J86
3249: 0003: \/******************************************************************/
3250: 0003: \/*                                                                */
3251: 0003: \/* CIPPM FILE EXTERNAL FUNCTION DEFNS                             */
3252: 0003: \/*                                                                */
3253: 0003: \/* REFERENCE   : CIPPMEXT.J86                                     */
3254: 0003: \/*                                                                */
3255: 0003: \/* VERSION A.          Neil Bennett.              16 APRIL 2007   */
3256: 0003: \/*                                                                */
3257: 0003: \/******************************************************************/
3258: 0003: 
3259: 0003:    FUNCTION CIPPM.SET EXTERNAL
3260: 0003:       INTEGER*1 CIPPM.SET
3261: 0003:    END FUNCTION
3262: 0003: 
3263: 0003:    FUNCTION READ.CIPPM EXTERNAL
3264: 0003:       INTEGER*2 READ.CIPPM
3265: 0003:    END FUNCTION
3266: 0003: 
3267: 0003:    FUNCTION WRITE.CIPPM EXTERNAL
3268: 0003:       INTEGER*2 WRITE.CIPPM
3269: 0003:    END FUNCTION
3270: 0003: 
3271: 0003: \/******************************************************************/
3272: 0003: %INCLUDE DRUGEXT.J86
3273: 0003: \*******************************************************************************
3274: 0003: \***                                                                         ***
3275: 0003: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE DRUG FILE                    ***
3276: 0003: \***                                                                         ***
3277: 0003: \***                       REFERENCE : DRUGEXT.J86                           ***
3278: 0003: \***                                                                         ***
3279: 0003: \***      Version A      Nalini Mathusoothanan                               ***
3280: 0003: \***                                                                         ***
3281: 0003: \*******************************************************************************
3282: 0003: 
3283: 0003:        FUNCTION DRUG.SET EXTERNAL
3284: 0003:        END FUNCTION
3285: 0003: 
3286: 0003:        FUNCTION READ.DRUG EXTERNAL
3287: 0003:           INTEGER*2 READ.DRUG
3288: 0003:        END FUNCTION
3289: 0003: 
3290: 0003: 
3291: 0003:        FUNCTION READ.DRUG.LOCK EXTERNAL
3292: 0003:           INTEGER*2 READ.DRUG.LOCK
3293: 0003:        END FUNCTION
3294: 0003: 
3295: 0003:        FUNCTION WRITE.DRUG EXTERNAL
3296: 0003:           INTEGER*2 WRITE.DRUG
3297: 0003:        END FUNCTION
3298: 0003: 
3299: 0003:        FUNCTION WRITE.DRUG.HOLD EXTERNAL
3300: 0003:           INTEGER*2 WRITE.DRUG.HOLD
3301: 0003:        END FUNCTION
3302: 0003: 
3303: 0003:        FUNCTION WRITE.DRUG.UNLOCK EXTERNAL
3304: 0003:           INTEGER*2 WRITE.DRUG.UNLOCK
3305: 0003:        END FUNCTION
3306: 0003: %INCLUDE IDFEXT.J86
3307: 0003: \*******************************************************************************
3308: 0003: \***                                                                         ***
3309: 0003: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE ITEM DESCRIPTION FILE        ***
3310: 0003: \***                                                                         ***
3311: 0003: \***                       REFERENCE : IDFEXT.J86                            ***
3312: 0003: \***                                                                         ***
3313: 0003: \***      Version A           Andrew Wedgeworth         9th July 1992        ***
3314: 0003: \***
3315: 0003: \***    VERSION C.              Robert Cowey.                       25 AUG 1993.
3316: 0003: \***    No changes to this file.
3317: 0003: \***
3318: 0003: \***   VERSION D               Nik Sen                 22nd December 1994
3319: 0003: \***   WRITE.IDF.HOLD added
3320: 0003: \***
3321: 0003: \*******************************************************************************
3322: 0003: 
3323: 0003:        FUNCTION IDF.SET EXTERNAL                                      
3324: 0003:        END FUNCTION                                                   
3325: 0003: 
3326: 0003: 
3327: 0003:        FUNCTION READ.IDF EXTERNAL                                     
3328: 0003:           INTEGER*2 READ.IDF                                          
3329: 0003:        END FUNCTION                                                   
3330: 0003: 
3331: 0003: 
3332: 0003:        FUNCTION READ.IDF.LOCK EXTERNAL                                
3333: 0003:           INTEGER*2 READ.IDF.LOCK                                     
3334: 0003:        END FUNCTION                                                   
3335: 0003: 
3336: 0003:        FUNCTION WRITE.IDF EXTERNAL
3337: 0003:           INTEGER*2 WRITE.IDF
3338: 0003:        END FUNCTION	       
3339: 0003: 
3340: 0003:        FUNCTION WRITE.IDF.HOLD EXTERNAL
3341: 0003:           INTEGER*2 WRITE.IDF.HOLD
3342: 0003:        END FUNCTION
3343: 0003: 
3344: 0003:        FUNCTION WRITE.IDF.UNLOCK EXTERNAL                                  
3345: 0003:           INTEGER*2 WRITE.IDF.UNLOCK                                      
3346: 0003:        END FUNCTION                                                   
3347: 0003: %INCLUDE IEFEXT.J86
3348: 0003: \*****************************************************************************
3349: 0003: \*****************************************************************************
3350: 0003: \***
3351: 0003: \***         EXTERNAL FUNCTION DEFINITIONS FOR IEF
3352: 0003: \***
3353: 0003: \***         REFERENCE: IEFEXT.J86
3354: 0003: \***
3355: 0003: \***    VERSION B.              ROBERT COWEY.                       21 OCT 1993.
3356: 0003: \***    No changes to this file.
3357: 0003: \***
3358: 0003: \*******************************************************************************
3359: 0003: \*******************************************************************************
3360: 0003: 
3361: 0003:    FUNCTION IEF.SET EXTERNAL
3362: 0003:    END FUNCTION
3363: 0003:    
3364: 0003:    FUNCTION READ.IEF EXTERNAL
3365: 0003:       INTEGER*2 READ.IEF
3366: 0003:    END FUNCTION
3367: 0003:    
3368: 0003:    FUNCTION WRITE.IEF EXTERNAL
3369: 0003:       INTEGER*2 WRITE.IEF
3370: 0003:    END FUNCTION
3371: 0003:    
3372: 0003:    
3373: 0003: %INCLUDE IEXEXT.J86
3374: 0003: \*******************************************************************************
3375: 0003: \***                                                                         ***
3376: 0003: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE IEX FILE                     ***
3377: 0003: \***                                                                         ***
3378: 0003: \***                       REFERENCE : IEXEXT.J86                            ***
3379: 0003: \***                                                                         ***
3380: 0003: \***      Version A      Nalini Mathusoothanan                               ***
3381: 0003: \***                                                                         ***
3382: 0003: \*******************************************************************************
3383: 0003: 
3384: 0003:        FUNCTION IEX.SET EXTERNAL
3385: 0003:        END FUNCTION
3386: 0003: 
3387: 0003:        FUNCTION READ.IEX EXTERNAL
3388: 0003:           INTEGER*2 READ.IEX
3389: 0003:        END FUNCTION
3390: 0003: 
3391: 0003:        FUNCTION READ.IEX.LOCK EXTERNAL
3392: 0003:           INTEGER*2 READ.IEX.LOCK
3393: 0003:        END FUNCTION
3394: 0003: 
3395: 0003:        FUNCTION WRITE.IEX EXTERNAL
3396: 0003:           INTEGER*2 WRITE.IEX
3397: 0003:        END FUNCTION
3398: 0003: 
3399: 0003:        FUNCTION WRITE.IEX.HOLD EXTERNAL
3400: 0003:           INTEGER*2 WRITE.IEX.HOLD
3401: 0003:        END FUNCTION
3402: 0003: 
3403: 0003:        FUNCTION WRITE.IEX.UNLOCK EXTERNAL
3404: 0003:           INTEGER*2 WRITE.IEX.UNLOCK
3405: 0003:        END FUNCTION
3406: 0003: %INCLUDE IRFEXT.J86
3407: 0003: \*********************************************************************************
3408: 0003: \***
3409: 0003: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE ITEM REFERENCE FILE
3410: 0003: \***
3411: 0003: \***                    REFERENCE : IRFEXT.J86
3412: 0003: \***
3413: 0003: \***      Version A          Andrew Wedgeworth        9th July 1992
3414: 0003: \***
3415: 0003: \***      Version B          Andrew Wedgeworth        14th December 1992
3416: 0003: \***      Version letter incremented to match other IRF code.
3417: 0003: \***
3418: 0003: \***      Version C           Steve Windsor        12.02.93
3419: 0003: \***      Added external reference to read the alternate IRF.
3420: 0003: \***
3421: 0003: \***      Version D           Steve Windsor        12.05.93
3422: 0003: \***      Added all external references that wre in the original FNS.
3423: 0003: \***
3424: 0003: \***      Version E           Steve Perkins        21.09.93
3425: 0003: \***      Deals project: Fields changed for new deals project
3426: 0003: \*** 
3427: 0003: \***      Version F           Mark Walker          5th January 1994
3428: 0003: \***      Version letter incremented to match other IRF code.           
3429: 0003: \***                                                                    
3430: 0003: \***      Version G     Stuart William McConnachie      11th February 2000
3431: 0003: \***      Converted IRF.INDICAT2$ to integer flag byte.
3432: 0003: \***
3433: 0003: \***      REVISION 1.6.               ROBERT COWEY.               9 JUL 2002.
3434: 0003: \***      Major changes to IRF layout for 2002 Deals Rewrite project.
3435: 0003: \***      No changes to this particular file for this revision.
3436: 0003: \***
3437: 0003: \***      REVISION 1.7.               ROBERT COWEY.               5 AUG 2002.
3438: 0003: \***      Further changes for 2002 Deals Rewrite project (PSBF19 related).
3439: 0003: \***      Defined new functions CONCAT.NEW.IRF.DATA$ and SPLIT.NEW.IRF.DATA$.
3440: 0003: \***
3441: 0003: \***      REVISION 1.8                ROBERT COWEY.              15 JUL 2003.
3442: 0003: \***      Usage of INDICAT0% bit-3 X'08' changed to Item Contains Alcohol.
3443: 0003: \***      No changes to this file other than description.
3444: 0003: \***      No changes to IRF file functions.
3445: 0003: \***
3446: 0003: \***      REVISION 1.9.      STUART WILLIAM MCCONNACHIE           22 OCT 2003.
3447: 0003: \***      Changes to remove limit of 3 deals per item.
3448: 0003: \***      No changes to this file.
3449: 0003: \***
3450: 0003: \***      REVISION 2.0.             ALAN CARR                      9 FEB 2006.
3451: 0003: \***      Add new IRF.INDICAT8% 1 byte, amend IRF.UNUSED$ from 3 to 2 bytes.
3452: 0003: \***      No changes to this file.
3453: 0003: \***
3454: 0003: \***..............................................................................
3455: 0003:    
3456: 0003:    FUNCTION IRF.SET EXTERNAL
3457: 0003:    END FUNCTION
3458: 0003: 
3459: 0003:   FUNCTION CONCAT.NEW.IRF.DATA$ EXTERNAL                                  ! 1.7 RC
3460: 0003:   END FUNCTION                                                            ! 1.7 RC
3461: 0003: 
3462: 0003:   FUNCTION SPLIT.NEW.IRF.DATA$ EXTERNAL                                   ! 1.7 RC
3463: 0003:   END FUNCTION                                                            ! 1.7 RC
3464: 0003:   
3465: 0003:   FUNCTION READ.IRF EXTERNAL
3466: 0003:    INTEGER*2 READ.IRF
3467: 0003:   END FUNCTION
3468: 0003: 
3469: 0003:   FUNCTION READ.IRF.ALT EXTERNAL
3470: 0003:    INTEGER*2 READ.IRF.ALT
3471: 0003:   END FUNCTION
3472: 0003: 
3473: 0003:   FUNCTION READ.IRF.LOCK EXTERNAL
3474: 0003:    INTEGER*2 READ.IRF.LOCK
3475: 0003:   END FUNCTION
3476: 0003: 
3477: 0003:   FUNCTION WRITE.IRF EXTERNAL
3478: 0003:    INTEGER*2 WRITE.IRF
3479: 0003:   END FUNCTION
3480: 0003: 
3481: 0003:   FUNCTION WRITE.IRF.UNLOCK EXTERNAL
3482: 0003:    INTEGER*2 WRITE.IRF.UNLOCK
3483: 0003:   END FUNCTION
3484: 0003: 
3485: 0003:   FUNCTION WRITE.IRF.HOLD EXTERNAL
3486: 0003:    INTEGER*2 WRITE.IRF.HOLD
3487: 0003:   END FUNCTION
3488: 0003: 
3489: 0003:   FUNCTION WRITE.IRF.HOLD.UNLOCK EXTERNAL
3490: 0003:    INTEGER*2 WRITE.IRF.HOLD.UNLOCK
3491: 0003:   END FUNCTION
3492: 0003: 
3493: 0003:   
3494: 0003: %INCLUDE ITGRPEXT.J86   ! IRF Attribute Extension File                  !HRN
3495: 0003: \***********************************************************************
3496: 0003: \***********************************************************************
3497: 0003: \***
3498: 0003: \***    DESCRIPTION: IRFITGRP (IRF Attribute Extension File)
3499: 0003: \***                 External File Function Definitions
3500: 0003: \***
3501: 0003: \***    FILE TYPE : Keyed
3502: 0003: \***
3503: 0003: \***********************************************************************
3504: 0003: \***
3505: 0003: \***    Version A.              Rejiya Nair             12th May 2016
3506: 0003: \***    PRJ1452 Restricting Item Sales
3507: 0003: \***    Initial version.
3508: 0003: \***
3509: 0003: \***********************************************************************
3510: 0003: \***********************************************************************
3511: 0003: 
3512: 0003: FUNCTION IRFITGRP.SET EXTERNAL
3513: 0003: END FUNCTION
3514: 0003: 
3515: 0003: FUNCTION READ.IRFITGRP EXTERNAL
3516: 0003:     INTEGER*2 READ.IRFITGRP
3517: 0003: END FUNCTION
3518: 0003: 
3519: 0003: FUNCTION READ.IRFITGRP.LOCK EXTERNAL
3520: 0003:     INTEGER*2 READ.IRFITGRP.LOCK
3521: 0003: END FUNCTION
3522: 0003: 
3523: 0003: FUNCTION WRITE.IRFITGRP EXTERNAL
3524: 0003:    INTEGER*2 WRITE.IRFITGRP
3525: 0003: END FUNCTION
3526: 0003: 
3527: 0003: FUNCTION WRITE.IRFITGRP.HOLD EXTERNAL
3528: 0003:    INTEGER*2 WRITE.IRFITGRP.HOLD
3529: 0003: END FUNCTION
3530: 0003: 
3531: 0003: FUNCTION WRITE.IRFITGRP.UNLOCK EXTERNAL
3532: 0003:    INTEGER*2 WRITE.IRFITGRP.UNLOCK
3533: 0003: END FUNCTION
3534: 0003: 
3535: 0003: FUNCTION WRITE.IRFITGRP.UNLOCK.HOLD EXTERNAL
3536: 0003:    INTEGER*2 WRITE.IRFITGRP.UNLOCK.HOLD
3537: 0003: END FUNCTION
3538: 0003: 
3539: 0003: %INCLUDE ISFEXT.J86
3540: 0003: \*******************************************************************************
3541: 0003: \***                                                                         ***
3542: 0003: \***             EXTERNAL FUNCTION DEFINITIONS FOR THE ISF                   ***
3543: 0003: \***                                                                         ***
3544: 0003: \***                       REFERENCE : ISFEXT.J86                            ***
3545: 0003: \***                                                                         ***
3546: 0003: \***        Version A         Andrew Wedgeworth     9th July 1992            ***
3547: 0003: \***                                                                         ***
3548: 0003: \***        Version B         Rebecca Dakin         8th August 1999          ***
3549: 0003: \***        Declare ISF.SET as external in line with changes to ISFFUN.BAS   ***
3550: 0003: \***                                                                         ***
3551: 0003: \*******************************************************************************
3552: 0003: 
3553: 0003:        FUNCTION ISF.SET EXTERNAL                                     
3554: 0003:           INTEGER*2 ISF.SET                                             ! BRD
3555: 0003:        END FUNCTION                                                   
3556: 0003: 
3557: 0003: 
3558: 0003:        FUNCTION READ.ISF EXTERNAL                                     
3559: 0003:           INTEGER*2 READ.ISF                                          
3560: 0003:        END FUNCTION                                                   
3561: 0003: 
3562: 0003: 
3563: 0003:        FUNCTION WRITE.ISF EXTERNAL                                     
3564: 0003:           INTEGER*2 WRITE.ISF                                          
3565: 0003:        END FUNCTION                                                   
3566: 0003: 
3567: 0003: 
3568: 0003: %INCLUDE IUFEXT.J86
3569: 0003: 
3570: 0003: \REM
3571: 0003: \*******************************************************************************
3572: 0003: \*******************************************************************************
3573: 0003: \***
3574: 0003: \***    %INCLUDE FOR ITEM UPDATE FILES EXTERNAL FUNCTIONS
3575: 0003: \***
3576: 0003: \***        REFERENCE   :   IUFEXT (J86)
3577: 0003: \***
3578: 0003: \***        FILE TYPE   :   Sequential
3579: 0003: \***
3580: 0003: \***    VERSION H.              ROBERT COWEY.                       24 AUG 1993.
3581: 0003: \***    Original version created from IUFFUNH.
3582: 0003: \***
3583: 0003: \***    VERSION I.              ROBERT COWEY.                       25 AUG 1993.
3584: 0003: \***    No changes to this file.
3585: 0003: \***
3586: 0003: \***    Version 1.4             Charles Skadorwa                   4th July 2011
3587: 0003: \***    CORE Heritage Stores Release 2 (Outbound) Project.
3588: 0003: \***    Removed WRITE.IUF
3589: 0003: \***    Added VALIDATE.IUF.HEADER.RECORD
3590: 0003: \***
3591: 0003: \***    VERSION 1.5.                ROBERT COWEY.                07 FEB 2012.
3592: 0003: \***    Changes creating PSB21.286 Core Release 2 version 1.5.
3593: 0003: \***    Corrected various defects but no code changes to this file.
3594: 0003: \***
3595: 0003: \*******************************************************************************
3596: 0003: \*******************************************************************************
3597: 0003: 
3598: 0003: 
3599: 0003: FUNCTION IUF.SET EXTERNAL
3600: 0003:     INTEGER*2 IUF.SET
3601: 0003: END FUNCTION
3602: 0003: 
3603: 0003: FUNCTION READ.IUF EXTERNAL
3604: 0003:     INTEGER*2 READ.IUF
3605: 0003: END FUNCTION
3606: 0003: 
3607: 0003: FUNCTION VALIDATE.IUF.HEADER.RECORD EXTERNAL
3608: 0003:     STRING VALIDATE.IUF.HEADER.RECORD
3609: 0003: END FUNCTION
3610: 0003: 
3611: 0003: %INCLUDE JOBOKEXT.J86
3612: 0003: \*****************************************************************************
3613: 0003: \*****************************************************************************
3614: 0003: \***
3615: 0003: \***         FUNCTION DEFINITIONS FOR JOBSOK
3616: 0003: \***
3617: 0003: \***                    REFERENCE : jobokexa.J86
3618: 0003: \***
3619: 0003: \***    Version A           Steve Windsor         5.2.93
3620: 0003: \***
3621: 0003: \***    Version B.              Robert Cowey.                       07 OCT 1993.
3622: 0003: \***    Defined JOBSOK.SET integer for use as a return code.
3623: 0003: \***
3624: 0003: \*******************************************************************************
3625: 0003: \*******************************************************************************
3626: 0003: 
3627: 0003:   FUNCTION JOBSOK.SET EXTERNAL
3628: 0003:    INTEGER*2 JOBSOK.SET                                                ! BRC
3629: 0003:   END FUNCTION
3630: 0003: 
3631: 0003:   FUNCTION READ.JOBSOK EXTERNAL
3632: 0003:    INTEGER*2 READ.JOBSOK
3633: 0003:   END FUNCTION
3634: 0003: 
3635: 0003:   FUNCTION WRITE.JOBSOK EXTERNAL
3636: 0003:    INTEGER*2 WRITE.JOBSOK
3637: 0003:   END FUNCTION
3638: 0003: 
3639: 0003: %INCLUDE LISTLIB.J86    ! UNLIMITED ARRAY ROUTINES
3640: 0003: \*****************************************************************************
3641: 0003: \***                                                                         *
3642: 0003: \***   4680 BASIC LIST                                                       *
3643: 0003: \***                                                                         *
3644: 0003: \***   Copyright (c) 2010 Stuart Highley                                     *
3645: 0003: \***   All rights reserved                                                   *
3646: 0003: \***                                                                         *
3647: 0003: \***   Provides a big string array of up to about 256,000,000 elements.      *
3648: 0003: \***   Currently only one list per program though.                           *
3649: 0003: \***                                                                         *
3650: 0003: \***                                                                         *
3651: 0003: \***                                                                         *
3652: 0003: \***   Reference : LISTLIB.J86                                               *
3653: 0003: \***                                                                         *
3654: 0003: \***   Version A      Stuart Highley       28th October 2010                 *
3655: 0003: \***                                                                         *
3656: 0003: \***   Version B      Tittoo Thomas        05th August  2011                 *
3657: 0003: \***      Cloned LISTLIB to support INTEGER*1, INTEGER*2 and INTEGER*4       *
3658: 0003: \***                                                                         *
3659: 0003: \*****************************************************************************
3660: 0003: 
3661: 0003: \*****************************************************************************
3662: 0003: \***                                                                         *
3663: 0003: \***    LIST.DIM                                                             *
3664: 0003: \***                                                                         *
3665: 0003: \***    Dimension the list up to 256,000,000 elements (16,000 * 16,000)      *
3666: 0003: \***    if you have the RAM available!                                       *
3667: 0003: \***                                                                         *
3668: 0003: \*****************************************************************************
3669: 0003: FUNCTION LIST.DIM(NEW.ELEMENTS%) EXTERNAL
3670: 0003:     INTEGER*4 NEW.ELEMENTS%
3671: 0003: END FUNCTION
3672: 0003: 
3673: 0003: \*****************************************************************************
3674: 0003: \***                                                                         *
3675: 0003: \***    LIST.SET                                                             *
3676: 0003: \***                                                                         *
3677: 0003: \***    Sets an element in the list to a given string.                       *
3678: 0003: \***                                                                         *
3679: 0003: \*****************************************************************************
3680: 0003: SUB LIST.SET(ELEMENT%, DATA$) EXTERNAL
3681: 0003:     INTEGER*4 ELEMENT%
3682: 0003:     STRING DATA$
3683: 0003: END SUB
3684: 0003: 
3685: 0003: \*****************************************************************************
3686: 0003: \***                                                                         *
3687: 0003: \***    LIST.GET                                                             *
3688: 0003: \***                                                                         *
3689: 0003: \***    Gets the string from a given element in the list.                    *
3690: 0003: \***                                                                         *
3691: 0003: \*****************************************************************************
3692: 0003: SUB LIST.GET(ELEMENT%, RETURNED.DATA$) EXTERNAL
3693: 0003:     INTEGER*4 ELEMENT%
3694: 0003:     STRING RETURNED.DATA$
3695: 0003: END SUB
3696: 0003: 
3697: 0003: \*****************************************************************************
3698: 0003: \***                                                                         *
3699: 0003: \***    I1.LIST.DIM                                                          *
3700: 0003: \***                                                                         *
3701: 0003: \***    Dimension the list up to 256,000,000 INTEGER*1 elements              *
3702: 0003: \***    i.e. (16,000 * 16,000) if you have the RAM available!                *
3703: 0003: \***                                                                         *
3704: 0003: \*****************************************************************************
3705: 0003: FUNCTION I1.LIST.DIM(NEW.ELEMENTS%) EXTERNAL                              !BTT
3706: 0003:     INTEGER*4 NEW.ELEMENTS%                                               !BTT
3707: 0003: END FUNCTION                                                              !BTT
3708: 0003: 
3709: 0003: \*****************************************************************************
3710: 0003: \***                                                                         *
3711: 0003: \***    I1.LIST.SET                                                          *
3712: 0003: \***                                                                         *
3713: 0003: \***    Sets an element in the list to a given INTEGER*1                     *
3714: 0003: \***                                                                         *
3715: 0003: \*****************************************************************************
3716: 0003: SUB I1.LIST.SET(ELEMENT%, DATA%) EXTERNAL                                 !BTT
3717: 0003:     INTEGER*4 ELEMENT%                                                    !BTT
3718: 0003:     INTEGER*1 DATA%                                                       !BTT
3719: 0003: END SUB                                                                   !BTT
3720: 0003: 
3721: 0003: \*****************************************************************************
3722: 0003: \***                                                                         *
3723: 0003: \***    I1.LIST.GET                                                          *
3724: 0003: \***                                                                         *
3725: 0003: \***    Gets the INTEGER*1 from a given element in the list.                 *
3726: 0003: \***                                                                         *
3727: 0003: \*****************************************************************************
3728: 0003: SUB I1.LIST.GET(ELEMENT%, RETURNED.DATA%) EXTERNAL                        !BTT
3729: 0003:     INTEGER*4 ELEMENT%                                                    !BTT
3730: 0003:     INTEGER*1 RETURNED.DATA%                                              !BTT
3731: 0003: END SUB                                                                   !BTT
3732: 0003: 
3733: 0003: \*****************************************************************************
3734: 0003: \***                                                                         *
3735: 0003: \***    I2.LIST.DIM                                                          *
3736: 0003: \***                                                                         *
3737: 0003: \***    Dimension the list up to 256,000,000 INTEGER*2 elements              *
3738: 0003: \***    i.e. (16,000 * 16,000) if you have the RAM available!                *
3739: 0003: \***                                                                         *
3740: 0003: \*****************************************************************************
3741: 0003: FUNCTION I2.LIST.DIM(NEW.ELEMENTS%) EXTERNAL                              !BTT
3742: 0003:     INTEGER*4 NEW.ELEMENTS%                                               !BTT
3743: 0003: END FUNCTION                                                              !BTT
3744: 0003: 
3745: 0003: \*****************************************************************************
3746: 0003: \***                                                                         *
3747: 0003: \***    I2.LIST.SET                                                          *
3748: 0003: \***                                                                         *
3749: 0003: \***    Sets an element in the list to a given INTEGER*2                     *
3750: 0003: \***                                                                         *
3751: 0003: \*****************************************************************************
3752: 0003: SUB I2.LIST.SET(ELEMENT%, DATA%) EXTERNAL                                 !BTT
3753: 0003:     INTEGER*4 ELEMENT%                                                    !BTT
3754: 0003:     INTEGER*2 DATA%                                                       !BTT
3755: 0003: END SUB                                                                   !BTT
3756: 0003: 
3757: 0003: \*****************************************************************************
3758: 0003: \***                                                                         *
3759: 0003: \***    I2.LIST.GET                                                          *
3760: 0003: \***                                                                         *
3761: 0003: \***    Gets the INTEGER*2 from a given element in the list.                 *
3762: 0003: \***                                                                         *
3763: 0003: \*****************************************************************************
3764: 0003: SUB I2.LIST.GET(ELEMENT%, RETURNED.DATA%) EXTERNAL                        !BTT
3765: 0003:     INTEGER*4 ELEMENT%                                                    !BTT
3766: 0003:     INTEGER*2 RETURNED.DATA%                                              !BTT
3767: 0003: END SUB                                                                   !BTT
3768: 0003: 
3769: 0003: \*****************************************************************************
3770: 0003: \***                                                                         *
3771: 0003: \***    I4.LIST.DIM                                                          *
3772: 0003: \***                                                                         *
3773: 0003: \***    Dimension the list up to 256,000,000 INTEGER*4 elements              *
3774: 0003: \***    i.e. (16,000 * 16,000) if you have the RAM available!                *
3775: 0003: \***                                                                         *
3776: 0003: \*****************************************************************************
3777: 0003: FUNCTION I4.LIST.DIM(NEW.ELEMENTS%) EXTERNAL                              !BTT
3778: 0003:     INTEGER*4 NEW.ELEMENTS%                                               !BTT
3779: 0003: END FUNCTION                                                              !BTT
3780: 0003: 
3781: 0003: \*****************************************************************************
3782: 0003: \***                                                                         *
3783: 0003: \***    I4.LIST.SET                                                          *
3784: 0003: \***                                                                         *
3785: 0003: \***    Sets an element in the list to a given INTEGER*4                     *
3786: 0003: \***                                                                         *
3787: 0003: \*****************************************************************************
3788: 0003: SUB I4.LIST.SET(ELEMENT%, DATA%) EXTERNAL                                 !BTT
3789: 0003:     INTEGER*4 ELEMENT%                                                    !BTT
3790: 0003:     INTEGER*4 DATA%                                                       !BTT
3791: 0003: END SUB                                                                   !BTT
3792: 0003: 
3793: 0003: \*****************************************************************************
3794: 0003: \***                                                                         *
3795: 0003: \***    I4.LIST.GET                                                          *
3796: 0003: \***                                                                         *
3797: 0003: \***    Gets the INTEGER*4 from a given element in the list.                 *
3798: 0003: \***                                                                         *
3799: 0003: \*****************************************************************************
3800: 0003: SUB I4.LIST.GET(ELEMENT%, RETURNED.DATA%) EXTERNAL                        !BTT
3801: 0003:     INTEGER*4 ELEMENT%                                                    !BTT
3802: 0003:     INTEGER*4 RETURNED.DATA%                                              !BTT
3803: 0003: END SUB                                                                   !BTT
3804: 0003: 
3805: 0003: %INCLUDE LOCALEXT.J86
3806: 0003: \***********************************************************************
3807: 0003: \***********************************************************************
3808: 0003: \***
3809: 0003: \***    DESCRIPTION: Local Price File
3810: 0003: \***                 External File Function Definitions
3811: 0003: \***
3812: 0003: \***    FILE TYPE : Keyed
3813: 0003: \***
3814: 0003: \***********************************************************************
3815: 0003: \***
3816: 0003: \***    Version A.              Paul Flanagan            1st Jul 1993
3817: 0003: \***    Initial version.
3818: 0003: \***
3819: 0003: \***    Version B.              Clive Norris            30th Nov 1993
3820: 0003: \***    Renamed to keep the versions in line.
3821: 0003: \***
3822: 0003: \***    Version C.              Mark Walker             29th Jun 2015
3823: 0003: \***    F392 Retail Stock 5
3824: 0003: \***    Added function WRITE.LOCAL.UNLOCK.HOLD
3825: 0003: \***
3826: 0003: \***********************************************************************
3827: 0003: \***********************************************************************
3828: 0003: 
3829: 0003: FUNCTION LOCAL.SET EXTERNAL
3830: 0003: END FUNCTION
3831: 0003: 
3832: 0003: FUNCTION READ.LOCAL EXTERNAL
3833: 0003:     INTEGER*2 READ.LOCAL
3834: 0003: END FUNCTION
3835: 0003: 
3836: 0003: FUNCTION READ.LOCAL.LOCK EXTERNAL
3837: 0003:     INTEGER*2 READ.LOCAL.LOCK
3838: 0003: END FUNCTION
3839: 0003: 
3840: 0003: FUNCTION WRITE.LOCAL EXTERNAL
3841: 0003:     INTEGER*2 WRITE.LOCAL
3842: 0003: END FUNCTION
3843: 0003: 
3844: 0003: FUNCTION WRITE.LOCAL.UNLOCK EXTERNAL
3845: 0003:     INTEGER*2 WRITE.LOCAL.UNLOCK
3846: 0003: END FUNCTION
3847: 0003: 
3848: 0003: FUNCTION WRITE.LOCAL.UNLOCK.HOLD EXTERNAL                                   !CMW
3849: 0003:     INTEGER*2 WRITE.LOCAL.UNLOCK.HOLD                                       !CMW
3850: 0003: END FUNCTION                                                                !CMW
3851: 0003: 
3852: 0003: %INCLUDE NLINEEXT.J86
3853: 0003: 
3854: 0003: \*****************************************************************************
3855: 0003: \*****************************************************************************
3856: 0003: \***
3857: 0003: \***        %INCLUDE FOR FILE HANDLING FUNCTIONS EXTERNAL DEFINITIONS
3858: 0003: \***
3859: 0003: \***                   FILE TYPE:  KEYED
3860: 0003: \***
3861: 0003: \***                   REFERENCE:  NLINEEXT.J86
3862: 0003: \***
3863: 0003: \***               DESCRIPTION:  NEWLINES - NEWLINES REPORT INFORMATION
3864: 0003: \***
3865: 0003: \***
3866: 0003: \***
3867: 0003: \***      VERSION 1 : Julia Stones             7th July 2003
3868: 0003: \***
3869: 0003: \***    REVISION 1.2.                ROBERT COWEY.               05 DEC 2003.
3870: 0003: \***    Changed NLINE reporting number from 660 to 670.
3871: 0003: \***    No code changes to this file.
3872: 0003: \***
3873: 0003: \*****************************************************************************
3874: 0003: \*****************************************************************************
3875: 0003: 
3876: 0003: 
3877: 0003:   FUNCTION NEWLINES.SET EXTERNAL
3878: 0003:      INTEGER*2 NEWLINES.SET
3879: 0003:   END FUNCTION
3880: 0003: 
3881: 0003: 
3882: 0003:   FUNCTION READ.NEWLINES EXTERNAL
3883: 0003:     INTEGER*2 READ.NEWLINES
3884: 0003:   END FUNCTION
3885: 0003: 
3886: 0003:   FUNCTION WRITE.NEWLINES EXTERNAL
3887: 0003:     INTEGER*2 WRITE.NEWLINES
3888: 0003:   END FUNCTION
3889: 0003: 
3890: 0003: %INCLUDE PGFEXT.J86
3891: 0003: 
3892: 0003: \REM
3893: 0003: \*******************************************************************************
3894: 0003: \*******************************************************************************
3895: 0003: \***
3896: 0003: \***    %INCLUDE FOR PRODUCT GROUP FILES EXTERNAL FUNCTIONS
3897: 0003: \***
3898: 0003: \***        REFERENCE   :   PGFDEC (J86)
3899: 0003: \***
3900: 0003: \***        FILE TYPE   :   Direct (PGF and PGFD)
3901: 0003: \***                        Keyed (PGFO)
3902: 0003: \***
3903: 0003: \***    VERSION B.              ROBERT COWEY.                       30 SEP 1993.
3904: 0003: \***    Created from PGFFUNB.
3905: 0003: \***
3906: 0003: \***    REVISION 1.2.           ROBERT COWEY.                       27 OCT 2003.
3907: 0003: \***    Defined WRITE.PGF function.
3908: 0003: \***
3909: 0003: \*******************************************************************************
3910: 0003: \*******************************************************************************
3911: 0003: 
3912: 0003: 
3913: 0003: FUNCTION PGF.SET EXTERNAL
3914: 0003:     INTEGER*2 PGF.SET
3915: 0003: END FUNCTION
3916: 0003: 
3917: 0003: FUNCTION READ.PGF EXTERNAL
3918: 0003:     INTEGER*2 READ.PGF
3919: 0003: END FUNCTION
3920: 0003: 
3921: 0003: FUNCTION WRITE.PGF EXTERNAL                                                ! 1.2 RC
3922: 0003:     INTEGER*2 WRITE.PGF                                                    ! 1.2 RC
3923: 0003: END FUNCTION                                                               ! 1.2 RC
3924: 0003: 
3925: 0003: FUNCTION READ.PGFDIR EXTERNAL
3926: 0003:     INTEGER*2 READ.PGFDIR
3927: 0003: END FUNCTION
3928: 0003: 
3929: 0003: FUNCTION WRITE.PGFDIR EXTERNAL
3930: 0003:     INTEGER*2 WRITE.PGFDIR
3931: 0003: END FUNCTION
3932: 0003: 
3933: 0003: FUNCTION READ.PGFO EXTERNAL
3934: 0003:     INTEGER*2 READ.PGFO
3935: 0003: END FUNCTION
3936: 0003: 
3937: 0003: FUNCTION WRITE.PGFO EXTERNAL
3938: 0003:     INTEGER*2 WRITE.PGFO
3939: 0003: END FUNCTION
3940: 0003: 
3941: 0003: %INCLUDE PPFEXT.J86
3942: 0003: 
3943: 0003: \REM
3944: 0003: \*******************************************************************************
3945: 0003: \*******************************************************************************
3946: 0003: \***
3947: 0003: \***    %INCLUDE FOR PENDING PRICES FILES EXTERNAL FUNCTIONS
3948: 0003: \***
3949: 0003: \***        REFERENCE   :   PPFEXT (J86)
3950: 0003: \***
3951: 0003: \***        FILE TYPE   :   Sequential
3952: 0003: \***
3953: 0003: \***    VERSION D.              ROBERT COWEY.                       23 AUG 1993.
3954: 0003: \***    Original version created from PPFFUND.
3955: 0003: \***
3956: 0003: \***    VERSION E.              STEVE PERKINS.                      22 OCT 1993.
3957: 0003: \***    Defined functions READ.PPFI.SHORT and PPFI.LOAD.FIELDS(RECORD$).
3958: 0003: \***
3959: 0003: \*******************************************************************************
3960: 0003: \*******************************************************************************
3961: 0003: 
3962: 0003: 
3963: 0003: FUNCTION PPFI.SET EXTERNAL
3964: 0003:     INTEGER*2 PPFI.SET
3965: 0003: END FUNCTION
3966: 0003: 
3967: 0003: FUNCTION PPFO.SET EXTERNAL
3968: 0003:     INTEGER*2 PPFO.SET
3969: 0003: END FUNCTION
3970: 0003: 
3971: 0003: FUNCTION READ.PPFI EXTERNAL
3972: 0003:     INTEGER*2 READ.PPFI
3973: 0003: END FUNCTION
3974: 0003: 
3975: 0003: FUNCTION READ.PPFI.SHORT EXTERNAL                                      ! ESP
3976: 0003:     INTEGER*2 READ.PPFI.SHORT                                          ! ESP
3977: 0003: END FUNCTION                                                           ! ESP
3978: 0003: 
3979: 0003: FUNCTION WRITE.PPFO EXTERNAL
3980: 0003:     INTEGER*2 WRITE.PPFO
3981: 0003: END FUNCTION
3982: 0003: 
3983: 0003: FUNCTION PPFI.LOAD.FIELDS(RECORD$) EXTERNAL                            ! ESP
3984: 0003:     STRING    RECORD$                                                  ! ESP
3985: 0003:     INTEGER*2 PPFI.LOAD.FIELDS                                         ! ESP
3986: 0003: END FUNCTION                                                           ! ESP
3987: 0003:  
3988: 0003: %INCLUDE PPFKEXT.J86
3989: 0003: \******************************************************************************
3990: 0003: \******************************************************************************
3991: 0003: \***
3992: 0003: \***    Pending Prices Keyed File (PPFK) external function definitions
3993: 0003: \***
3994: 0003: \******************************************************************************
3995: 0003: \***
3996: 0003: \***    Version 1.0             Mark Walker                 13th October 2011
3997: 0003: \***    Initial version.
3998: 0003: \***
3999: 0003: \***    VERSION 1.1.                ROBERT COWEY.                02 FEB 2012.
4000: 0003: \***    Changes creating PSB21.286 Core Release 2 version 1.5.
4001: 0003: \***    Defect 2678
4002: 0003: \***    Modified functions READ.PPFK and WRITE.PPFK.
4003: 0003: \***    No code changes to this file.
4004: 0003: \***
4005: 0003: \***    VERSION 1.2.                ROBERT COWEY.                01 MAR 2012.
4006: 0003: \***    Changes creating PSB21.286 Core Release 2 version 1.7.
4007: 0003: \***    Defect 53.
4008: 0003: \***    Modified function DELETE.PPFK.
4009: 0003: \***    No code changes to this file.
4010: 0003: \***
4011: 0003: \******************************************************************************
4012: 0003: \******************************************************************************
4013: 0003:     
4014: 0003:     FUNCTION PPFK.SET EXTERNAL
4015: 0003:     END FUNCTION
4016: 0003:     
4017: 0003:     FUNCTION READ.PPFK EXTERNAL
4018: 0003:     INTEGER*1 READ.PPFK
4019: 0003:     END FUNCTION
4020: 0003:     
4021: 0003:     FUNCTION WRITE.PPFK EXTERNAL
4022: 0003:     INTEGER*1 WRITE.PPFK
4023: 0003:     END FUNCTION
4024: 0003:     
4025: 0003:     FUNCTION DELETE.PPFK EXTERNAL
4026: 0003:     INTEGER*1 DELETE.PPFK
4027: 0003:     END FUNCTION
4028: 0003: 
4029: 0003: %INCLUDE RICFEXT.J86
4030: 0003: \******************************************************************************
4031: 0003: \******************************************************************************
4032: 0003: \***
4033: 0003: \***                     REDEEM ITEMS CHANGE FILE    
4034: 0003: \***                                                                
4035: 0003: \***                      REFERENCE : RICFEXT.J86 
4036: 0003: \***                                                                
4037: 0003: \***                      FILE TYPE : Direct               
4038: 0003: \***                                                                
4039: 0003: \***                                                                
4040: 0003: \***   Version A.              Jamie Thorpe                  1st July 1997
4041: 0003: \***   Original version.                                                    
4042: 0003: \***                                                                         
4043: 0003: \***                                                                       
4044: 0003: \******************************************************************************
4045: 0003: \******************************************************************************
4046: 0003: 
4047: 0003:   
4048: 0003: 
4049: 0003: FUNCTION RICF.SET EXTERNAL
4050: 0003: 
4051: 0003:     INTEGER*2 RICF.SET
4052: 0003:     
4053: 0003: END FUNCTION
4054: 0003: 
4055: 0003: 
4056: 0003: FUNCTION READ.RICF EXTERNAL
4057: 0003: 
4058: 0003:     INTEGER*2 READ.RICF
4059: 0003:     
4060: 0003: END FUNCTION                
4061: 0003: 
4062: 0003: FUNCTION WRITE.RICF EXTERNAL
4063: 0003:        
4064: 0003:      INTEGER*2 WRITE.RICF
4065: 0003: 
4066: 0003: END FUNCTION
4067: 0003: 
4068: 0003: 
4069: 0003: %INCLUDE SOFTSEXT.J86
4070: 0003: \*******************************************************************************
4071: 0003: \***                                                                         ***
4072: 0003: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE SOFTWARE STATUS FILE         ***
4073: 0003: \***                                                                         ***
4074: 0003: \***                     REFERENCE : SOFTSEXT.J86                            ***
4075: 0003: \***                                                                         ***
4076: 0003: \***      Version A         Andrew Wedgeworth          1st July 1992         ***
4077: 0003: \***
4078: 0003: \***   Version B
4079: 0003: \***                                                                      ***
4080: 0003: \***      Version C         Steve Wright               3rd May 1996          ***
4081: 0003: \***      Synchronise with function source.                                  ***
4082: 0003: \*******************************************************************************
4083: 0003: 
4084: 0003:       FUNCTION SOFTS.SET EXTERNAL 
4085: 0003:       END FUNCTION
4086: 0003:       
4087: 0003:       FUNCTION READ.SOFTS EXTERNAL
4088: 0003:           INTEGER*2 I%, READ.SOFTS
4089: 0003:       END FUNCTION	                   
4090: 0003: 
4091: 0003:       FUNCTION WRITE.SOFTS EXTERNAL
4092: 0003:           INTEGER*2 I%, WRITE.SOFTS
4093: 0003:       END FUNCTION
4094: 0003: 
4095: 0003: 
4096: 0003: %INCLUDE STKMQEXT.J86
4097: 0003: \*****************************************************************************
4098: 0003: \*****************************************************************************
4099: 0003: \***
4100: 0003: \***      EXTERNAL FUNCTION DEFINITIONS FOR STOCK MOVEMENT QUEUE FILE
4101: 0003: \***
4102: 0003: \***                      REFERENCE: STKMQEXT.J86
4103: 0003: \***
4104: 0003: \***       Version A            Les Cook                     8/9/92
4105: 0003: \***
4106: 0003: \***    VERSION F.              ROBERT COWEY.                       21 OCT 1993.
4107: 0003: \***    No changes to this file.
4108: 0003: \***
4109: 0003: \*******************************************************************************
4110: 0003: \*******************************************************************************
4111: 0003: 
4112: 0003:      FUNCTION STKMQ.SET EXTERNAL
4113: 0003:      END FUNCTION
4114: 0003:      
4115: 0003:      FUNCTION READ.STKMQ EXTERNAL
4116: 0003:         INTEGER*2 READ.STKMQ
4117: 0003:      END FUNCTION
4118: 0003:      
4119: 0003:      FUNCTION WRITE.STKMQ EXTERNAL
4120: 0003:         INTEGER*2 WRITE.STKMQ
4121: 0003:      END FUNCTION
4122: 0003:      
4123: 0003:      FUNCTION WRITE.HOLD.STKMQ EXTERNAL
4124: 0003:         INTEGER*2 WRITE.HOLD.STKMQ
4125: 0003:      END FUNCTION
4126: 0003:      
4127: 0003:      
4128: 0003:      
4129: 0003: %INCLUDE STOCKEXT.J86
4130: 0003: \***********************************************************************
4131: 0003: \***********************************************************************
4132: 0003: \***
4133: 0003: \***    DESCRIPTION: Stock File
4134: 0003: \***                 External File Function Definitions
4135: 0003: \***
4136: 0003: \***    FILE TYPE : Keyed
4137: 0003: \***
4138: 0003: \***********************************************************************
4139: 0003: \***
4140: 0003: \***    Version A.          Les Cook                     21st Aug 1992
4141: 0003: \***    Initial version.
4142: 0003: \***
4143: 0003: \***    Version B.          Robert Cowey                 21st Oct 1993
4144: 0003: \***    No changes to this file.
4145: 0003: \***
4146: 0003: \***    Version C.          Nik Sen                      22nd Dec 1994
4147: 0003: \***    WRITE.STOCK.HOLD added.
4148: 0003: \***
4149: 0003: \***    Version D.          Mark Walker                  23rd Jan 2014
4150: 0003: \***    F337 Centralised View of Stock
4151: 0003: \***    - Minor formatting changes (uncommented).
4152: 0003: \***
4153: 0003: \***********************************************************************
4154: 0003: \***********************************************************************
4155: 0003: 
4156: 0003: FUNCTION STOCK.SET EXTERNAL
4157: 0003: END FUNCTION
4158: 0003:    
4159: 0003: FUNCTION READ.STOCK EXTERNAL
4160: 0003:     INTEGER*2 READ.STOCK
4161: 0003: END FUNCTION
4162: 0003:    
4163: 0003: FUNCTION WRITE.STOCK EXTERNAL
4164: 0003:     INTEGER*2 WRITE.STOCK
4165: 0003: END FUNCTION
4166: 0003:    
4167: 0003: FUNCTION WRITE.STOCK.HOLD EXTERNAL
4168: 0003:     INTEGER*2 WRITE.STOCK.HOLD
4169: 0003: END FUNCTION
4170: 0003: 
4171: 0003: FUNCTION READ.STOCK.LOCK EXTERNAL
4172: 0003:     INTEGER*2 READ.STOCK.LOCK
4173: 0003: END FUNCTION
4174: 0003:    
4175: 0003: FUNCTION WRITE.STOCK.UNLOCK EXTERNAL
4176: 0003:     INTEGER*2 WRITE.STOCK.UNLOCK
4177: 0003: END FUNCTION
4178: 0003:    
4179: 0003: FUNCTION WRITE.STOCK.UNLOCK.HOLD EXTERNAL
4180: 0003:     INTEGER*2 WRITE.STOCK.UNLOCK.HOLD
4181: 0003: END FUNCTION
4182: 0003: 
4183: 0003: %INCLUDE SUPPEXT.J86
4184: 0003: \*****************************************************************************
4185: 0003: \*****************************************************************************
4186: 0003: \***
4187: 0003: \***         FUNCTION DEFINITIONS FOR SUPPRESS LABELS PARAMETER FILE.
4188: 0003: \***
4189: 0003: \***                    REFERENCE : SUPPEXT.J86
4190: 0003: \***
4191: 0003: \***    Version A           Jamie Thorpe             17th Jan 2001
4192: 0003: \***
4193: 0003: \*****************************************************************************
4194: 0003: \*****************************************************************************
4195: 0003: 
4196: 0003:    FUNCTION SUPPARAM.SET EXTERNAL
4197: 0003:    END FUNCTION
4198: 0003: 
4199: 0003:    FUNCTION READ.SUPPARAM EXTERNAL
4200: 0003:     INTEGER*2 READ.SUPPARAM
4201: 0003:    END FUNCTION
4202: 0003: 
4203: 0003:    FUNCTION WRITE.SUPPARAM EXTERNAL
4204: 0003:     INTEGER*2 WRITE.SUPPARAM
4205: 0003:    END FUNCTION  
4206: 0003: %INCLUDE WEEEEXT.J86
4207: 0003: 
4208: 0003: \*****************************************************************************
4209: 0003: \*****************************************************************************
4210: 0003: \***
4211: 0003: \***         EXTERNAL FUNCTION DEFINITIONS FOR WEEEUF
4212: 0003: \***
4213: 0003: \***         REFERENCE: WEEEEXT.J86
4214: 0003: \***
4215: 0003: \*******************************************************************************
4216: 0003: \*******************************************************************************
4217: 0003: 
4218: 0003:    FUNCTION WEEEUF.SET EXTERNAL
4219: 0003:    END FUNCTION
4220: 0003:    
4221: 0003:    FUNCTION READ.WEEEUF EXTERNAL
4222: 0003:       INTEGER*2 READ.WEEEUF
4223: 0003:    END FUNCTION
4224: 0003:    
4225: 0003: 
4226: 0003: 
4227: 0003: %INCLUDE PSBF01E.J86    ! APPLICATION.LOG
4228: 0003: REM \
4229: 0003: \*******************************************************************************
4230: 0003: \*******************************************************************************
4231: 0003: \***
4232: 0003: \***      %INCLUDE FOR EXTERNAL DEFINITION OF FUNCTION APPLICATION.LOG
4233: 0003: \***
4234: 0003: \***                      FUNCTION NUMBER   : PSBF01
4235: 0003: \***
4236: 0003: \***                    INCLUDE REFERENCE : PSBF01E.J86
4237: 0003: \*** 
4238: 0003: \***      Version B           Andrew Wedgeworth          1st July 1992
4239: 0003: \***      Three parameters which passed to the function have been removed.
4240: 0003: \***      APPLICATION.LOG has been added as a variable name (this holds the
4241: 0003: \***      return code).
4242: 0003: \***
4243: 0003: \*******************************************************************************
4244: 0003: 
4245: 0003: 
4246: 0003:    FUNCTION APPLICATION.LOG (MESSAGE.NO%,                                     \
4247: 0003:                              VAR.STRING.1$,                                   \
4248: 0003:                              VAR.STRING.2$,                                   \
4249: 0003:                              EVENT.NO%)  EXTERNAL
4250: 0003: 
4251: 0003:       INTEGER*1 EVENT.NO%
4252: 0003: 
4253: 0003:       INTEGER*2 APPLICATION.LOG,                                       \ GAW
4254: 0003:                 MESSAGE.NO%
4255: 0003: 
4256: 0003:       STRING VAR.STRING.1$,                                            \
4257: 0003:              VAR.STRING.2$
4258: 0003: 
4259: 0003:    END FUNCTION
4260: 0003: 
4261: 0003: \*******************************************************************************
4262: 0003: %INCLUDE PSBF02E.J86    ! UPDATE.DATE                          ! 1.18 RC
4263: 0003: REM\
4264: 0003: \*******************************************************************************
4265: 0003: \*******************************************************************************
4266: 0003: \***
4267: 0003: \***        INCLUDE       : UPDATE.DATE external definition
4268: 0003: \***        AUTHOR        : Bruce Scriver (Basic Code)
4269: 0003: \***        DATE WRITTEN  : 4th March 1986 (Basic Code)
4270: 0003: \***
4271: 0003: \***        REFERENCE     : PSBF02E.J86
4272: 0003: \***
4273: 0003: \***        Version A     Bruce Scriver          4th March 1986
4274: 0003: \***
4275: 0003: \***        Version B     Andrew Wedgeworth       6th July 1992
4276: 0003: \***        Removal of redundant parameters, and inclusion of UPDATE.DATE as
4277: 0003: \***        a variable to hold the return code.
4278: 0003: \***
4279: 0003: \*******************************************************************************
4280: 0003: \*******************************************************************************
4281: 0003: 
4282: 0003:    FUNCTION UPDATE.DATE (INCREMENT%)                                   \
4283: 0003:    EXTERNAL
4284: 0003:    ! 3 parameters removed from here                                    ! BAW
4285: 0003: 
4286: 0003:    ! 3 lines deleted from here                                         ! BAW
4287: 0003:    
4288: 0003:       INTEGER*2 UPDATE.DATE                                            ! BAW
4289: 0003: 
4290: 0003:       INTEGER*4 INCREMENT%
4291: 0003: 
4292: 0003:    END FUNCTION
4293: 0003: 
4294: 0003: %INCLUDE PSBF13E.J86    ! PSDATE
4295: 0003: REM\
4296: 0003: \*******************************************************************************
4297: 0003: \*******************************************************************************
4298: 0003: \***
4299: 0003: \***        INCLUDE       : PSDATE external definition
4300: 0003: \***
4301: 0003: \***        REFERENCE     : PSBF13E.J86
4302: 0003: \***
4303: 0003: \***        Version A     Bruce Scriver                6th March 1986
4304: 0003: \*** 
4305: 0003: \***        Version B     Andrew Wedgeworth            17th July 1992  
4306: 0003: \***        Redundant parameters removed and PSDATE defined as a variable
4307: 0003: \***        to hold the return code. 
4308: 0003: \***
4309: 0003: \*******************************************************************************
4310: 0003: \*******************************************************************************
4311: 0003: 
4312: 0003:    FUNCTION PSDATE (INPUT.DATE$)                                               \
4313: 0003:    EXTERNAL
4314: 0003: 
4315: 0003:      STRING    INPUT.DATE$                                                   
4316: 0003:    
4317: 0003:      INTEGER*2 PSDATE 
4318: 0003: 
4319: 0003:    END FUNCTION
4320: 0003: 
4321: 0003: %INCLUDE PSBF18E.J86    ! CALCULATE BOOTS CHECK DIGIT          ! 1.19 RC (238)
4322: 0003: REM\
4323: 0003: \*******************************************************************************
4324: 0003: \*******************************************************************************
4325: 0003: \***
4326: 0003: \***        INCLUDE       : CALC.BOOTS.CODE.CHECK.DIGIT external definition
4327: 0003: \***
4328: 0003: \***        REFERENCE     : PSBF18E.J86
4329: 0003: \***
4330: 0003: \***        Version A      Stephen Kelsey                   23rd March 1987 
4331: 0003: \***
4332: 0003: \***        Version B      Andrew Wedgeworth                  7th July 1992 
4333: 0003: \***        Removal of redundant parameters, and inclusion of function's 
4334: 0003: \***        name as a variable to hold the return code.
4335: 0003: \***
4336: 0003: \*******************************************************************************
4337: 0003: \*******************************************************************************
4338: 0003: 
4339: 0003:    FUNCTION CALC.BOOTS.CODE.CHECK.DIGIT (BOOTS.CODE.6.DIGIT$)          \ 
4340: 0003:    EXTERNAL
4341: 0003:    ! 3 parameters removed from here                                    ! BAW
4342: 0003: 
4343: 0003:    STRING BOOTS.CODE.6.DIGIT$
4344: 0003:    ! 3 variables deleted from here                                     ! BAW
4345: 0003:    
4346: 0003:    INTEGER* 2 CALC.BOOTS.CODE.CHECK.DIGIT                              ! BAW
4347: 0003:    
4348: 0003:    END FUNCTION
4349: 0003: 
4350: 0003: %INCLUDE PSBF19E.J86    ! UPDATE IRF EXTERNALS
4351: 0003: \*******************************************************************************! GCSk
4352: 0003: \*******************************************************************************! GCSk
4353: 0003: \***                                                                            ! GCSk
4354: 0003: \*** IMPORTANT                                                                  ! GCSk
4355: 0003: \*** =========                                                                  ! GCSk
4356: 0003: \***    All references to UPDT.IRF.UPDT have been commented out and replaced    ! GCSk
4357: 0003: \***    with UPDT.IRF.TIF.UPDT due to the following issue found post MCF:       ! GCSk
4358: 0003: \***                                                                            ! GCSk
4359: 0003: \***    Node ID check removed as it is preventing the TIF from being updated in ! GCSk
4360: 0003: \***    Single MCF controller stores ie. MCF has changed the single DE nodes    ! GCSk
4361: 0003: \***    to CE. This change should have been done as part of the MCF project,    ! GCSk
4362: 0003: \***    however, the Business were not willing to pay for the relinking and     ! GCSk
4363: 0003: \***    testing of some 200+ programs. There is a slight processing overhead    ! GCSk
4364: 0003: \***    in dual-MCF stores, since the TIF will now be updated in them as well,  ! GCSk
4365: 0003: \***    however the impact is small and TOF does not run in this environment.   ! GCSk
4366: 0003: \***                                                                            ! GCSk
4367: 0003: \***    If you wish to use the old UPDT.IRF.UPDT function then you will need to ! GCSk
4368: 0003: \***    either:                                                                 ! GCSk
4369: 0003: \***                                                                            ! GCSk
4370: 0003: \***          1. Check out the previous OBJs, PSBF19e.J86 and update the .INP   ! GCSk
4371: 0003: \***             and .MAK to include the functions PSBF19, PSBF41 & PSBF42      ! GCSk
4372: 0003: \***       or                                                                   ! GCSk
4373: 0003: \***          2. Check out the previous PSBF19e.J86 and function library:       ! GCSk
4374: 0003: \***             FUNLIB.L86                                                     ! GCSk
4375: 0003: \***                                                                            ! GCSk
4376: 0003: \*******************************************************************************! GCSk
4377: 0003: \*******************************************************************************! GCSk
4378: 0003: 
4379: 0003: REM \
4380: 0003: \*******************************************************************************
4381: 0003: \*******************************************************************************
4382: 0003: \***
4383: 0003: \***
4384: 0003: \***            INCLUDE       : IRF.UPDATE external definition
4385: 0003: \***
4386: 0003: \***            REFERENCE     : PSBF19E.J86
4387: 0003: \***
4388: 0003: \***      Version A      Richard Hopkinson                  16th March 1988
4389: 0003: \***
4390: 0003: \***      Version B      Janet Lawrence                     12th April 1989
4391: 0003: \***      Add extra parameter, IRF.LOCKED.FLAG$, to each function definition.
4392: 0003: \***
4393: 0003: \***      Version C      Andrew Wedgeworth                   21st July 1992
4394: 0003: \***      Redundant parameters removed (ie. BATCH.SCREEN.FLAG$,
4395: 0003: \***      MODULE.NUMBER$ and OPERATOR.NUMBER$).  Function names defined as
4396: 0003: \***      variables to hold the return code.
4397: 0003: \***
4398: 0003: \***      Version F     Steve Perkins                      20th October 1993
4399: 0003: \***      Version letter updated to keep in line with PSBF19.BAS
4400: 0003: \***
4401: 0003: \***    REVISION 1.9.                ROBERT COWEY.                08 DEC 2003.
4402: 0003: \***    Changes for Deal Limit removal project.
4403: 0003: \***    Revision number updated to keep in step with PSBF19.BAS.
4404: 0003: \***    No actual coding changes to this file.
4405: 0003: \***
4406: 0003: \***    Version G       Charles Skadorwa                   25th September 2013
4407: 0003: \***    F261 Gift Card Mall IIN Range Extension Project - Commented ! GCSk
4408: 0003: \***
4409: 0003: \*******************************************************************************
4410: 0003: \*******************************************************************************
4411: 0003: 
4412: 0003:    FUNCTION OPEN.IRF.UPDT (NEW.IRF.DATA$,                                  \
4413: 0003:                            ACD.FLAG$)                                      \
4414: 0003:    EXTERNAL
4415: 0003: 
4416: 0003:       STRING    ACD.FLAG$,                                                 \
4417: 0003:                 NEW.IRF.DATA$
4418: 0003: 
4419: 0003:       INTEGER*2 OPEN.IRF.UPDT                                          ! CAW
4420: 0003: 
4421: 0003:    END FUNCTION
4422: 0003: 
4423: 0003: 
4424: 0003:   !FUNCTION UPDT.IRF.UPDT (NEW.IRF.DATA$,                              ! GCSk
4425: 0003:    FUNCTION UPDT.IRF.TIF.UPDT (NEW.IRF.DATA$,                          \ ! GCSk
4426: 0003:                            ACD.FLAG$,                                  \
4427: 0003:                            IRF.LOCKED.FLAG$)                           \ BJAL
4428: 0003:    EXTERNAL
4429: 0003: 
4430: 0003:       STRING    ACD.FLAG$,                                             \
4431: 0003:                 IRF.LOCKED.FLAG$,                                      \ BJAL
4432: 0003:                 NEW.IRF.DATA$
4433: 0003: 
4434: 0003:      !INTEGER*2 UPDT.IRF.UPDT                                          ! CAW ! GCSk
4435: 0003:       INTEGER*2 UPDT.IRF.TIF.UPDT                                      ! GCSk
4436: 0003: 
4437: 0003:    END FUNCTION
4438: 0003: 
4439: 0003: 
4440: 0003:    FUNCTION CLOSE.IRF.UPDT (NEW.IRF.DATA$,                                 \
4441: 0003:                             ACD.FLAG$)                                     \
4442: 0003:    EXTERNAL
4443: 0003: 
4444: 0003:       STRING    ACD.FLAG$,                                                 \
4445: 0003:                 NEW.IRF.DATA$
4446: 0003: 
4447: 0003:       INTEGER*2 CLOSE.IRF.UPDT                                         ! CAW
4448: 0003: 
4449: 0003:    END FUNCTION
4450: 0003: 
4451: 0003: %INCLUDE PSBF20E.J86    ! SESSION NUMBER UTILITY
4452: 0003: REM\
4453: 0003: \*******************************************************************************
4454: 0003: \*******************************************************************************
4455: 0003: \***
4456: 0003: \***       %INCLUDE FOR EXTERNAL DEFINITION OF SESS.NUM.UTILITY
4457: 0003: \***
4458: 0003: \***                  REFERENCE     : PSBF20E.J86
4459: 0003: \***
4460: 0003: \***     VERSION C            Janet Smith                13th May 1992
4461: 0003: \***     Increased PASSED.INTEGER to 2 bytes to cater for more than
4462: 0003: \***     128 files.
4463: 0003: \***
4464: 0003: \***     VERSION D.           Andrew Wedgeworth          1st July 1992
4465: 0003: \***     Removal of redundant parameters and addition of SESS.NUM.UTILITY
4466: 0003: \***     as a variable.  This new variable contains the function's return
4467: 0003: \***     code.
4468: 0003: \***
4469: 0003: \*******************************************************************************
4470: 0003: \*******************************************************************************
4471: 0003: 
4472: 0003:    FUNCTION SESS.NUM.UTILITY (FUNCTION.FLAG$,                          \
4473: 0003:                               PASSED.INTEGER%,                         \
4474: 0003:                               PASSED.STRING$)                          \
4475: 0003:    EXTERNAL
4476: 0003: 
4477: 0003:    STRING    FUNCTION.FLAG$,                                           \
4478: 0003:              PASSED.STRING$
4479: 0003:    ! 3 variables removed from here                                     ! CAW
4480: 0003: 
4481: 0003: 
4482: 0003:    INTEGER*2 SESS.NUM.UTILITY,                                         \ CAW
4483: 0003:              PASSED.INTEGER%				               ! CJAS
4484: 0003: 
4485: 0003:    END FUNCTION
4486: 0003: 
4487: 0003: %INCLUDE PSBF24E.J86    ! STANDARD ERROR DETECTED
4488: 0003: REM \
4489: 0003: \*******************************************************************************
4490: 0003: \*******************************************************************************
4491: 0003: \***
4492: 0003: \***    %INCLUDE FOR EXTERNAL DEFINITION OF STANDARD.ERROR.DETECTED FUNCTION
4493: 0003: \***
4494: 0003: \***                      REFERENCE     : PSBF24E.J86
4495: 0003: \***
4496: 0003: \***    Version A                 Janet Smith                  13th May 1992
4497: 0003: \***
4498: 0003: \*******************************************************************************
4499: 0003: \*******************************************************************************
4500: 0003: 
4501: 0003:    FUNCTION STANDARD.ERROR.DETECTED(ERRN%,                 \
4502: 0003: 				    ERRFILE%,              \
4503: 0003: 				    ERRL%,                 \
4504: 0003: 				    ERR$)        EXTERNAL
4505: 0003: 				    
4506: 0003:           STRING    ERR$
4507: 0003: 
4508: 0003:           INTEGER*2 ERRFILE%,              \
4509: 0003: 	            ERRL%,                 \
4510: 0003: 		    STANDARD.ERROR.DETECTED
4511: 0003: 		    
4512: 0003:           INTEGER*4 ERRN%
4513: 0003: 	  		    
4514: 0003:    END FUNCTION
4515: 0003: 
4516: 0003: 
4517: 0003: %INCLUDE PSBF48E.J86    ! DEC API Logging
4518: 0003: \*******************************************************************************
4519: 0003: \*******************************************************************************
4520: 0003: \***
4521: 0003: \***      %INCLUDE FOR EXTERNAL DEFINITION OF DEC API FUNCTIONS                 ! CMW
4522: 0003: \***
4523: 0003: \***                    FUNCTION NUMBER   : PSBF48
4524: 0003: \***
4525: 0003: \***                    INCLUDE REFERENCE : PSBF48E.J86
4526: 0003: \***
4527: 0003: \***      Version A           Mark Goode          15 Oct 2010
4528: 0003: \***      Initial version.
4529: 0003: \***
4530: 0003: \***      Version B           Mark Goode          18 Feb 2011
4531: 0003: \***      Change request - CR002
4532: 0003: \***
4533: 0003: \***      Version C           Mark Walker         30 Jan 2012
4534: 0003: \***      Changed header comment to indicate what this code is actually for!
4535: 0003: \***
4536: 0003: \*******************************************************************************
4537: 0003: 
4538: 0003:     FUNCTION DECAPI.INIT EXTERNAL
4539: 0003:            INTEGER*2 DECAPI.INIT
4540: 0003:     END FUNCTION    
4541: 0003:     
4542: 0003:     FUNCTION DECAPI.CLOSE EXTERNAL
4543: 0003:             INTEGER*2 DECAPI.CLOSE
4544: 0003:     END FUNCTION
4545: 0003:     
4546: 0003:     FUNCTION DECAPI.SEND(MESSAGEID$,PAYLOAD$,COMMIT) EXTERNAL
4547: 0003:         INTEGER*2 DECAPI.SEND
4548: 0003:         STRING    MESSAGEID$
4549: 0003:         STRING    PAYLOAD$
4550: 0003:         STRING    COMMIT ! "" - NO "C" - YES 
4551: 0003:     END FUNCTION
4552: 0003: 
4553: 0003:     FUNCTION DECAPI.RECV EXTERNAL
4554: 0003:          STRING    DECAPI.RECV 
4555: 0003:     END FUNCTION
4556: 0003:      
4557: 0003:     FUNCTION DECAPI.RECV.RESPONSE.TIME EXTERNAL
4558: 0003:          STRING    DECAPI.RECV.RESPONSE.TIME
4559: 0003:     END FUNCTION
4560: 0003: 
4561: 0003:     FUNCTION DECAPI.COMMAND$(CMD$,DATA$) EXTERNAL
4562: 0003:         STRING DECAPI.COMMAND$
4563: 0003:         STRING CMD$
4564: 0003:         STRING DATA$
4565: 0003:     END FUNCTION
4566: 0003:     
4567: 0003:     FUNCTION DECAPI.EVENT(MESSAGEID$, DATA$, REASONCODE%) EXTERNAL   ! BMG
4568: 0003:         STRING    MESSAGEID$                                         ! BMG
4569: 0003:         STRING    DATA$                                              ! BMG
4570: 0003:         INTEGER*2 REASONCODE%                                        ! BMG
4571: 0003:     END FUNCTION                                                     ! BMG
4572: 0003: 
4573: 0003: 
4574: 0003: 
4575: 0003: \*******************************************************************************
4576: 0003: 
4577: 0003: 
4578: 0003: %INCLUDE CSORTDEC.J86   ! Assembler sort routine               ! 1.10 RC (113)
4579: 0003: FUNCTION CSORT(ARPTR%, ELEMENTS%) EXTERNAL
4580: 0003:     INTEGER*4 ARPTR%, ELEMENTS%, CSORT
4581: 0003: END FUNCTION
4582: 0003: 
4583: 0003: 
4584: 0003: SUB UPDATE.BCF EXTERNAL
4585: 0003: END SUB
4586: 0003: 
4587: 0003: FUNCTION CREATE.PPFK EXTERNAL
4588: 0003: INTEGER*1 CREATE.PPFK
4589: 0003: END FUNCTION
4590: 0003: 
4591: 0003: FUNCTION DESTROY.PPFK EXTERNAL
4592: 0003: INTEGER*1 DESTROY.PPFK
4593: 0003: END FUNCTION
4594: 0003: 
4595: 0003: SUB SEND.DEC.MESSAGE EXTERNAL
4596: 0003: END SUB
4597: 0003: 
4598: 0003: %INCLUDE ERRNH.J86
4599: 0003: \******************************************************************************
4600: 0003: \***
4601: 0003: \***	FUNCTION ERRNH
4602: 0003: \***
4603: 0003: \***	Convert the 4-byte error number to an 8-byte ASCII string
4604: 0003: \***
4605: 0003: \******************************************************************************
4606: 0003: 
4607: 0003: 	FUNCTION ERRNH PUBLIC
4608: 0027: 
4609: 0027: 	STRING			ERRNH,					\
4610: 0027: 				E$
4611: 0027: 
4612: 0027: 	INTEGER*2		I%
4613: 0027: 	INTEGER*4		H%
4614: 0027: 
4615: 0027: 	E$ = ""
4616: 003c: 	H% = ERRN
4617: 0056: 
4618: 0056: 	FOR I% = 28 TO 0 STEP -4
4619: 0066: 	    E$ = E$ + CHR$((SHIFT(H%,I%) AND 000FH) + 48)
4620: 00c2: 	NEXT I%
4621: 00da: 
4622: 00da: 	ERRNH = TRANSLATE$(E$,":;<=>?","ABCDEF")
4623: 0101: 
4624: 0101: 	END FUNCTION
4625: 011a: 
4626: 011a: \*******************************************************************************
4627: 011a: \***
4628: 011a: \***    PSB21 Functions
4629: 011a: \***
4630: 011a: \***............................................................................
4631: 011a: 
4632: 011a: \************************************************************************
4633: 011a: \***
4634: 011a: \*** Execute FlexOS supervisor commands
4635: 011a: \***
4636: 011a: \*************************************************************************
4637: 011a: FUNCTION FLEXOSSVC(COMMAND%, PARAM$) EXTERNAL
4638: 011a:       STRING PARAM$
4639: 011a:       INTEGER*2 COMMAND%, FLEXOSSVC
4640: 011a: END FUNCTION
4641: 011a: 
4642: 011a: 
4643: 011a: \*****************************************************************************
4644: 011a: \***
4645: 011a: \***    FUCTION CONTTIME (START.TIME, PARMBLK$, TIMEDATE.TABLE$) EXTERNAL
4646: 011a: \***
4647: 011a: \***    IBM assembler routine to obtain system time from Flex OS.
4648: 011a: \***
4649: 011a: \***    Initialise the following variables, once only, at start of program:
4650: 011a: \***    PARAMBLK$ = STRING$(20, CHR$(00H))
4651: 011a: \***    TIMEDATE.TABLE$ = STRING$(12, CHR$(00H))
4652: 011a: \***
4653: 011a: \***    Then each call to CONTTIME returns a time in milli-seconds.  The time
4654: 011a: \***    returned is the time since midnight, *LESS* START.TIME.
4655: 011a: \***    By passing in 0 as an initial value the current time can be obtained
4656: 011a: \***    as a starting point.  Then this value can be passed in to subsequent
4657: 011a: \***    calls to obtain an elapsed time.
4658: 011a: \***
4659: 011a: \***    The actual values returned in TIME.DATE.TABLE$ may be of interest:
4660: 011a: \***
4661: 011a: \***    00 - Year LSB       CCH
4662: 011a: \***    01 - Year MSB       07H = 1996    (i.e. hex, NOT packed)
4663: 011a: \***    02 - Month          0AH = October (i.e. hex, NOT packed)
4664: 011a: \***    03 - Day            12H = 18th    (i.e. hex, NOT packed)
4665: 011a: \***    04 - Time LSB
4666: 011a: \***    05 - Time           Milliseconds since midnight
4667: 011a: \***    06 - Time
4668: 011a: \***    07 - Time MSB
4669: 011a: \***    08 - Time Zone LSB  Minutes from Universal Coordinated Time!
4670: 011a: \***    09 - Time Zone MSB
4671: 011a: \***    0A - Day of Week    00H = Sunday ... 06H = Saturday
4672: 011a: \***    0B - 00H
4673: 011a: \***
4674: 011a: \*****************************************************************************
4675: 011a: 
4676: 011a: FUNCTION CONTTIME (START.TIME, PARMBLK$, TIMEDATE.TABLE$) EXTERNAL
4677: 011a:     STRING PARMBLK$, TIMEDATE.TABLE$
4678: 011a:     INTEGER*4 START.TIME, CONTTIME
4679: 011a: END FUNCTION
4680: 011a: 
4681: 011a: 
4682: 011a: 
4683: 011a: \*****************************************************************************
4684: 011a: \***
4685: 011a: \***    MILLI.TIME% function
4686: 011a: \***    Sets MILLI.TIME% to controller time since midnight in milli-seconds.
4687: 011a: \***    Integer format.
4688: 011a: \***
4689: 011a: \*****************************************************************************
4690: 011a: 
4691: 011a: FUNCTION MILLI.TIME%
4692: 013e: 
4693: 013e:     INTEGER*4 MILLI.TIME%
4694: 013e: 
4695: 013e:     MILLI.TIME% = CONTTIME(0, CT.PARAMBLK$, CT.TIMEDATE.TABLE$)
4696: 017a: 
4697: 017a: END FUNCTION
4698: 0194: 
4699: 0194: \*****************************************************************************
4700: 0194: \***
4701: 0194: \***    MILLI.TIME$ function
4702: 0194: \***    Sets MILLI.TIME$ to controller time since midnight in milli-seconds.
4703: 0194: \***    String format.
4704: 0194: \***
4705: 0194: \***..........................................................................
4706: 0194: 
4707: 0194: FUNCTION MILLI.TIME$
4708: 01b8: 
4709: 01b8:     STRING MILLI.TIME$
4710: 01b8: 
4711: 01b8:     MILLI.TIME$ = STR$(MILLI.TIME%)
4712: 01d7: 
4713: 01d7: END FUNCTION
4714: 01f0: 
4715: 01f0: 
4716: 01f0: \*****************************************************************************
4717: 01f0: \***
4718: 01f0: \***    HHMMSS.MMM$ function
4719: 01f0: \***    Converts time (parmed as milli-seconds since midnight) into
4720: 01f0: \***    an understandable HH:MM:SS.MMM format
4721: 01f0: \***
4722: 01f0: \*****************************************************************************
4723: 01f0: 
4724: 01f0: FUNCTION HHMMSS.MMM$(VAL%)
4725: 0214: 
4726: 0214:     STRING    HHMMSS.MMM$
4727: 0214:     STRING    WORK$
4728: 0214:     INTEGER*4 VAL%
4729: 0214: 
4730: 0214:     WORK$ = RIGHT$("000" + STR$(MOD(VAL%, 1000)) ,3)
4731: 0262:     VAL% = VAL% / 1000
4732: 027d: 
4733: 027d:     WORK$ = RIGHT$("00" + STR$(MOD(VAL%, 60)) ,2) + "." + WORK$
4734: 02e5:     VAL% = VAL% / 60
4735: 0300: 
4736: 0300:     WORK$ = RIGHT$("00" + STR$(MOD(VAL%, 60)) ,2) + ":" + WORK$
4737: 0368:     VAL% = VAL% / 60
4738: 0383: 
4739: 0383:     WORK$ = RIGHT$("00" + STR$(VAL%), 2) + ":" + WORK$
4740: 03e1: 
4741: 03e1:     HHMMSS.MMM$ = WORK$
4742: 03fb: 
4743: 03fb: END FUNCTION
4744: 0414: 
4745: 0414: 
4746: 0414: 
4747: 0414: \******************************************************************************
4748: 0414: \***
4749: 0414: \***    Format date    YYMMDD --> DD/MM/YYYY
4750: 0414: \***
4751: 0414: \******************************************************************************
4752: 0414: 
4753: 0414: FUNCTION FORMAT.DATE$ (FIELD$)
4754: 043d: 
4755: 043d:     STRING      FIELD$
4756: 043d:     STRING      FORMAT.DATE$
4757: 043d: 
4758: 043d:     FORMAT.DATE$ = MID$(FIELD$, 5, 2) + "/"   + \
4759: 049d:                    MID$(FIELD$, 3, 2) + "/20" + \
4760: 049d:                    MID$(FIELD$, 1, 2)
4761: 049d: 
4762: 049d: END FUNCTION
4763: 04bb: 
4764: 04bb: 
4765: 04bb: \******************************************************************************
4766: 04bb: \***
4767: 04bb: \***    Format Time      HHMMSS --> HH:MM
4768: 04bb: \***
4769: 04bb: \******************************************************************************
4770: 04bb: 
4771: 04bb: FUNCTION FORMAT.TIME$ (FIELD$)
4772: 04e4: 
4773: 04e4:     STRING      FIELD$
4774: 04e4:     STRING      FORMAT.TIME$
4775: 04e4: 
4776: 04e4: 
4777: 04e4:     FORMAT.TIME$ = MID$(FIELD$, 1, 2) +   \
4778: 0526:                    ":"                +   \
4779: 0526:                    MID$(FIELD$, 3, 2)
4780: 0526: 
4781: 0526: END FUNCTION
4782: 0544: 
4783: 0544: 
4784: 0544: 
4785: 0544: 
4786: 0544: 
4787: 0544: \*******************************************************************************
4788: 0544: \***
4789: 0544: \***    PSB21 Subroutines
4790: 0544: \***
4791: 0544: \***............................................................................
4792: 0544: 
4793: 0544: SUB PROCESS.IUF.ITEM EXTERNAL
4794: 0544: END SUB
4795: 0544: 
4796: 0544: SUB PROCESS.PGF EXTERNAL
4797: 0544: END SUB
4798: 0544: 
4799: 0544: SUB CHECK.PROCESS.PGF EXTERNAL                                   ! 1.20 RC (240)
4800: 0544: END SUB                                                          ! 1.20 RC (240)
4801: 0544: 
4802: 0544: SUB PROCESS.OLD.PPFI EXTERNAL
4803: 0544: END SUB
4804: 0544: 
4805: 0544: SUB CREATE.NEW.PPFI EXTERNAL
4806: 0544: END SUB
4807: 0544: 
4808: 0544: SUB PROGRAM.EXIT EXTERNAL
4809: 0544: END SUB
4810: 0544: 
4811: 0544: 
4812: 0544: \******************************************************************************
4813: 0544: \***
4814: 0544: \***   EXECUTE.SVC
4815: 0544: \***
4816: 0544: \******************************************************************************
4817: 0544: SUB EXECUTE.SVC
4818: 0568: 
4819: 0568:     SVC.PARAM$   = "                        "
4820: 057f:     PINFO.TABLE$  = "PSB21     " + CHR$(200) + STRING$(9,CHR$(00))
4821: 05ba:     PROG.NAME$   = PROG.NAME$ + CHR$(00)
4822: 05e2:     COMM.TAIL$   = COMM.TAIL$ + CHR$(00)
4823: 060a:     REM Build a COMMAND SVC on the FlexOS PROCESS table
4824: 060a:     CALL PUTN4(SVC.PARAM$,  0, 00000000H)
4825: 062f:     CALL PUTN4(SVC.PARAM$,  4, 00000000H)
4826: 0654:     CALL PUTN4(SVC.PARAM$,  8, SADD(PROG.NAME$) + 2)
4827: 0689:     CALL PUTN4(SVC.PARAM$, 12, SADD(COMM.TAIL$) + 2)
4828: 06be:     CALL PUTN4(SVC.PARAM$, 16, LEN(COMM.TAIL$) - 1)
4829: 06f2:     CALL PUTN4(SVC.PARAM$, 20, SADD(PINFO.TABLE$) + 2)
4830: 0727:     CALL PUTN4(SVC.PARAM$, 24, 00000000H)
4831: 074c:     CALL FLEXOSSVC(38, SVC.PARAM$)
4832: 0769: 
4833: 0769: END SUB
4834: 077d: 
4835: 077d: 
4836: 077d: 
4837: 077d: \*******************************************************************************
4838: 077d: \***
4839: 077d: \***    DO.MESSAGE
4840: 077d: \***
4841: 077d: \*******************************************************************************
4842: 077d: SUB DO.MESSAGE(MSG$, LOG%) PUBLIC
4843: 07a1: 
4844: 07a1:     INTEGER*1 LOG%  ! Output to Background screen if TRUE
4845: 07a1:     STRING    MSG$
4846: 07a1: 
4847: 07a1:     IF STATUS% = 1 THEN BEGIN
4848: 07b3:         PRINT HHMMSS.MMM$(MILLI.TIME%) + " " + MSG$
4849: 07f2:     ENDIF ELSE IF STATUS% = 2 THEN BEGIN
4850: 0804:         IF LOG% THEN BEGIN
4851: 0815:            CALL ADXSERVE (ADXSERVE.RET.CODE%,26,0,MSG$)
4852: 0850:         ENDIF
4853: 0858:     ENDIF
4854: 0860: 
4855: 0860:     MSG$ = HHMMSS.MMM$(MILLI.TIME%) + " " + MSG$ + CRLF$
4856: 08a5:     FORM$ = "C" + STR$(LEN(MSG$))
4857: 08dc:     WRITE FORM FORM$; # LOG.SESS.NUM%; MSG$
4858: 0911: 
4859: 0911: END SUB
4860: 0925: 
4861: 0925: 
4862: 0925: \******************************************************************************
4863: 0925: \***
4864: 0925: \***    OPEN.IUF
4865: 0925: \***
4866: 0925: \******************************************************************************
4867: 0925: \***
4868: 0925: \***    Opens the IUF
4869: 0925: \***
4870: 0925: \******************************************************************************
4871: 0925: 
4872: 0925: FUNCTION OPEN.IUF
4873: 0949: 
4874: 0949:     INTEGER*1 OPEN.IUF
4875: 0949: 
4876: 0949:     OPEN.IUF = 1
4877: 0955: 
4878: 0955:     IF SIZE(IUF.FILE.NAME$) > 0 THEN BEGIN
4879: 0987: 
4880: 0987:         FILE.OPERATION$ = "O"
4881: 099e:         CURRENT.REPORT.NUM% = IUF.REPORT.NUM%
4882: 09b4: 
4883: 09b4:         ! Open the IUF
4884: 09b4:         IF END # IUF.SESS.NUM% THEN IUF.OPEN.ERROR
4885: 09d0:         OPEN IUF.FILE.NAME$ AS IUF.SESS.NUM% BUFFSIZE 32256 LOCKED NOWRITE NODEL
4886: 09f9: 
4887: 09f9:         IUF.EXISTS = TRUE
4888: 0a0f:         IUF.OPEN = TRUE                                          ! 1.6 RC (87)
4889: 0a25:         OPEN.IUF   = 0
4890: 0a31: 
4891: 0a31:     ENDIF
4892: 0a39: 
4893: 0a39:     IUF.OPEN.ERROR:
4894: 0a49: 
4895: 0a49: END FUNCTION
4896: 0a60: 
4897: 0a60: 
4898: 0a60: \******************************************************************************
4899: 0a60: \***
4900: 0a60: \***    CLOSE.IUF
4901: 0a60: \***
4902: 0a60: \******************************************************************************
4903: 0a60: \***
4904: 0a60: \***    Closes the IUF
4905: 0a60: \***
4906: 0a60: \******************************************************************************
4907: 0a60: 
4908: 0a60: FUNCTION CLOSE.IUF ! Entire procedure new for Rv 1.6 RC          ! 1.6 RC (87)
4909: 0a84: 
4910: 0a84:     IF IUF.OPEN THEN BEGIN
4911: 0a96:         CLOSE IUF.SESS.NUM%
4912: 0aaa:         IUF.OPEN = FALSE
4913: 0ac0:     ENDIF
4914: 0ac8: 
4915: 0ac8: END FUNCTION
4916: 0adc: 
4917: 0adc: 
4918: 0adc: \*******************************************************************************
4919: 0adc: \***
4920: 0adc: \***    LOG.EVENT
4921: 0adc: \***    Writes details of Event to application event log.
4922: 0adc: \***
4923: 0adc: \***............................................................................
4924: 0adc: SUB LOG.EVENT(EVENT.NO%) PUBLIC
4925: 0b00: 
4926: 0b00:     INTEGER*1 EVENT.NO%
4927: 0b00: 
4928: 0b00:     VAR.STRING.2$ = " "
4929: 0b17: 
4930: 0b17:     IF EVENT.NO% = 8 THEN BEGIN
4931: 0b28:         ! Price mismatch on IUF/IRF. Item Refresh requested.
4932: 0b28:         VAR.STRING.1$ = PACK$("0" + CURR.BOOTS.CODE$) + PACK$("00000000")
4933: 0b7b: 
4934: 0b7b:     ENDIF ELSE IF EVENT.NO% = 13 THEN BEGIN
4935: 0b8c:         ! Unexpected record sequence (IUF)
4936: 0b8c:         VAR.STRING.1$ = CURR.BOOTS.CODE$ + EXP.REC.TYPE$ + CURR.REC.TYPE$
4937: 0bc6: 
4938: 0bc6:     ENDIF ELSE IF EVENT.NO% = 14 THEN BEGIN
4939: 0bd7:             VAR.STRING.1$ = "PGFWRK  "
4940: 0bf1: 
4941: 0bf1:     ENDIF ELSE IF EVENT.NO% = 15 THEN BEGIN
4942: 0c02:         ! Unexpected store number
4943: 0c02:         VAR.STRING.1$ = STORE.NUMBER$ + IUF.STORE.NUM$
4944: 0c2e:         ERROR$ = "9"  ! Unexpected Error
4945: 0c48:         !ERROR$ = "2"   ! Header problem
4946: 0c48: 
4947: 0c48:     ENDIF ELSE IF EVENT.NO% = 17 THEN BEGIN
4948: 0c59:         ! Unexpected record type
4949: 0c59:         VAR.STRING.1$ = STR$(PPFI.REPORT.NUM%) + PACK$("09999999")
4950: 0c95: 
4951: 0c95:     ENDIF ELSE IF EVENT.NO% = 18 THEN BEGIN
4952: 0ca6:         ! CM/CT Program Chaining Error
4953: 0ca6:          VAR.STRING.1$ = "B2100B20  "
4954: 0cc0: 
4955: 0cc0:     ENDIF ELSE IF EVENT.NO% = 21 THEN BEGIN
4956: 0cd4:         ! Incorrect BCF serial No / Date time stamp
4957: 0cd4:         IF IUF.NEW.FORMAT THEN BEGIN
4958: 0ce6:              VAR.STRING.1$ = PACK$(LEFT$((IUF.TIME.STAMP$ + STRING$(18,"0")),18))
4959: 0d3c:         ENDIF ELSE BEGIN
4960: 0d44:             VAR.STRING.1$ = PACK$(BCF.IUF.SERIAL.NO$ + IUF.SERIAL.NO$)
4961: 0d7a:         ENDIF
4962: 0d82:         !  Batch Already Processed, but still process Pending price file
4963: 0d82:        ERROR$ = "5"  ! Batch Already Processed
4964: 0d99:        JOBSOK.FLAG$ = "Y"
4965: 0db0:        CALL SEND.DEC.MESSAGE
4966: 0dbd:        ERROR$ = "0"  ! Reset status for next batch
4967: 0dd7: 
4968: 0dd7:     ENDIF ELSE IF EVENT.NO% = 23 THEN BEGIN
4969: 0de8:         ! General ADXSERVE call error
4970: 0de8:         VAR.STRING.1$ = \
4971: 0e5c:           RIGHT$("00000" + STR$(ADXSERVE.RETURN.CODE%),5) + \
4972: 0e5c:           PACK$("00000000") + "4"
4973: 0e5c: 
4974: 0e5c:     ENDIF ELSE IF EVENT.NO% = 57 THEN BEGIN
4975: 0e6d:         ! ADXCOPYF Error
4976: 0e6d:         VAR.STRING.1$ = RIGHT$(STR$(RC%),2) + BACKUP.SOURCE.FILE$
4977: 0ebe: 
4978: 0ebe:     ENDIF ELSE IF EVENT.NO% = 84 THEN BEGIN
4979: 0ecf:         ! Error occured in module 'n'
4980: 0ecf:         VAR.STRING.1$ = MODULE.NUMBER$ + RIGHT$("   " + PHASE$,3)
4981: 0f1b: 
4982: 0f1b:     ENDIF ELSE IF EVENT.NO% = 92 THEN BEGIN
4983: 0f2f:         ! Count Discrepancy
4984: 0f2f:         VAR.STRING.1$ = CHR$(SHIFT(CURRENT.REPORT.NUM%,8)) + \ ! Two byte integer byte
4985: 101d:                         CHR$(SHIFT(CURRENT.REPORT.NUM%,0)) + \ ! order reversed
4986: 101d:                         PACK$(RIGHT$("00000000" + STR$(COUNT.EXPECTED%),8)) + \
4987: 101d:                         PACK$(RIGHT$("00000000" + STR$(COUNT.ACTUAL%),8))
4988: 101d: 
4989: 101d:         ERROR$ = "3" ! Trailer problem
4990: 1037: 
4991: 1037:     ENDIF ELSE IF EVENT.NO% = 106 THEN BEGIN
4992: 104b:         ! IF END errors: Open/Read/Write/Delete/Create/Size
4993: 104b:         VAR.STRING.1$ = FILE.OPERATION$                +  \
4994: 10a9:                     CHR$(SHIFT(CURRENT.REPORT.NUM%,8)) +  \
4995: 10a9:                     CHR$(SHIFT(CURRENT.REPORT.NUM%,0))
4996: 10a9: 
4997: 10a9:         IF FILE.OPERATION$ = "O" AND CURRENT.REPORT.NUM% = IUF.REPORT.NUM% THEN BEGIN
4998: 10e9:             CALL DO.MESSAGE("PSB21 *** Item Update File missing", FALSE)
4999: 111d:             ! IUF file missing but still process Pending price file
5000: 111d:             JOBSOK.FLAG$ = "E"                                                         !1.6CSk
5001: 1134:             EXIT SUB
5002: 113f:         ENDIF
5003: 114a: 
5004: 114a: 
5005: 114a:     ENDIF ELSE IF EVENT.NO% = 222 THEN BEGIN
5006: 115b:         ! Log DEC API Message issue
5007: 115b:         VAR.STRING.1$ = EVENT.222.DATA$
5008: 117b: 
5009: 117b:     ENDIF ELSE BEGIN
5010: 1183:          VAR.STRING.1$ = "PSB21UNK"
5011: 119a:          VAR.STRING.2$ = "NOWN ERR"
5012: 11b1:          ERROR$        = "9"         ! Unexpected error
5013: 11c8:     ENDIF
5014: 11d0: 
5015: 11d0:     RC% = APPLICATION.LOG (MESSAGE.NO%,     \
5016: 1213:                            VAR.STRING.1$,   \
5017: 1213:                            VAR.STRING.2$,   \
5018: 1213:                            EVENT.NO%)
5019: 1213: 
5020: 1213:    IF CURRENT.REPORT.NUM% = IUF.REPORT.NUM% THEN BEGIN
5021: 122b:         CALL DO.MESSAGE("PSB21 *** LOG EVENT: " + STR$(EVENT.NO%) + \
5022: 1293:                         " at IUF Rec: " + STR$(COUNT.RECORDS.IUF%), FALSE)
5023: 1293:    ENDIF
5024: 129b: 
5025: 129b:    IF EVENT.NO% <> 84 THEN BEGIN ! Error occured in module 'n'                  !1.6CSk
5026: 12af:         ! Log an additonal Event 84 that will identify the Module and Phase     !1.6CSk
5027: 12af:         ! that the error occurred in. Useful for any errors that are raised     !1.6CSk
5028: 12af:         ! before the log file is created and written to.                        !1.6CSk
5029: 12af:         VAR.STRING.1$ = MODULE.NUMBER$ + RIGHT$("   " + PHASE$,3)               !1.6CSk
5030: 12f8:         VAR.STRING.2$ = ""                                                      !1.6CSk
5031: 130f:         RC% = APPLICATION.LOG (MESSAGE.NO%, VAR.STRING.1$, VAR.STRING.2$, 84)   !1.6CSk
5032: 134e:    ENDIF
5033: 1356: 
5034: 1356:    !-----------------------------------
5035: 1356:    ! Check to see if EVENT.NO% is FATAL
5036: 1356:    !-----------------------------------
5037: 1356:    IF ERROR$ = "9" THEN BEGIN
5038: 1374:          EVENT.NO% =  0      ! Override Event No.
5039: 1383:    ENDIF
5040: 138b: 
5041: 138b:    IF EVENT.NO% =   0 OR \   ! Unknown Event No.
5042: 1490:       EVENT.NO% =  15 OR \   ! Unexpected store number
5043: 1490:       EVENT.NO% =  23 OR \   ! General ADXSERVE call error
5044: 1490:       EVENT.NO% =  84 OR \   ! Fatal Error in Module + Phase
5045: 1490:       EVENT.NO% =  92 OR \   ! Incorrect Batch trailer Count
5046: 1490:      (EVENT.NO% = 106 AND (CURRENT.REPORT.NUM% = IUF.REPORT.NUM%     OR \
5047: 1490:                            CURRENT.REPORT.NUM% = JOBSOK.REPORT.NUM%  OR \
5048: 1490:                            CURRENT.REPORT.NUM% = PPFI.REPORT.NUM%    OR \
5049: 1490:                            CURRENT.REPORT.NUM% = PPFK.REPORT.NUM%    OR \
5050: 1490:                            CURRENT.REPORT.NUM% = PPFO.REPORT.NUM%    OR \
5051: 1490:                            CURRENT.REPORT.NUM% = BCF.REPORT.NUM%     OR \
5052: 1490:                            CURRENT.REPORT.NUM% = SOFTS.REPORT.NUM%)) THEN BEGIN
5053: 1490: 
5054: 1490:        CALL DO.MESSAGE("PSB21 *** FATAL ERROR - ABORTING ***", FALSE)
5055: 14c4:        JOBSOK.FLAG$ = "X"
5056: 14db:        CALL SEND.DEC.MESSAGE
5057: 14e8:        CALL CLOSE.IUF                                            ! 1.6 RC (87)
5058: 1502:        CALL PROGRAM.EXIT
5059: 150f:    ENDIF
5060: 1517: 
5061: 1517: END SUB
5062: 152b: 
5063: 152b: 
5064: 152b: \******************************************************************************
5065: 152b: \***
5066: 152b: \***    OLD.BATCH.FOUND
5067: 152b: \***
5068: 152b: \******************************************************************************
5069: 152b: \***
5070: 152b: \***    Checks previously processed batch references to determine whether
5071: 152b: \***    the current IUF batch has already been processed.
5072: 152b: \***
5073: 152b: \***    NOTE: Different processing is required for old and new IUF formats.
5074: 152b: \***
5075: 152b: \******************************************************************************
5076: 152b: 
5077: 152b: FUNCTION OLD.BATCH.FOUND
5078: 154f: 
5079: 154f:     INTEGER*1 OLD.BATCH.FOUND
5080: 154f: 
5081: 154f:     PHASE$ = "3.1"                                                              !1.6CSk
5082: 1566:     OLD.BATCH.FOUND = FALSE
5083: 1578: 
5084: 1578: 
5085: 1578:     IF IUF.NEW.FORMAT THEN BEGIN
5086: 158a:         CALL DO.MESSAGE("PSB21 3.1 - New IUF Format Detected", TRUE)
5087: 15c1:     ENDIF ELSE BEGIN
5088: 15c9:         CALL DO.MESSAGE("PSB21 3.1 - Old IUF Format Detected", TRUE)
5089: 15fd:         PHASE$ = "3.2"                                                          !1.6CSk
5090: 1614:         CALL DO.MESSAGE("PSB21 PHASE 3.2 - PROCESSING IUF", TRUE)
5091: 1648:     ENDIF
5092: 1650: 
5093: 1650:     !-----------------------------------------------------------------------------
5094: 1650:     ! If the BCF IUF timestamp is populated, then check the BCF and IUF serial
5095: 1650:     ! numbers otherwise ignore further checks ie. blank timestamp indicates that
5096: 1650:     ! it is the very first time its ran.
5097: 1650:     !-----------------------------------------------------------------------------
5098: 1650: 
5099: 1650:     IF NOT IUF.NEW.FORMAT THEN BEGIN
5100: 1665: 
5101: 1665:         IF BCF.IUF.SERIAL.NO$ >= IUF.SERIAL.NO$ THEN BEGIN
5102: 168d:             !-------------------------------- --------------------------------------
5103: 168d:             ! Check to see if IUF Serial No. has wrapped back round (within reason)
5104: 168d:             ! and raise error if IUF Serial No. or BCF Serial No. is outside limits.
5105: 168d:             !----------------------------------------------------------------------
5106: 168d: 
5107: 168d:             IF BCF.IUF.SERIAL.NO$ < "9990" OR    \
5108: 16e2:                    IUF.SERIAL.NO$ > "0010" THEN BEGIN
5109: 16e2:                 CALL DO.MESSAGE("*** WARNING: Old IUF Batch Serial No. " + \
5110: 1733:                                  IUF.SERIAL.NO$                                   + \
5111: 1733:                                  " BCF Serial No. "                               + \
5112: 1733:                                  BCF.IUF.SERIAL.NO$, FALSE)
5113: 1733: 
5114: 1733:                 OLD.BATCH.FOUND = TRUE
5115: 1745:                 CALL DO.MESSAGE("PSB21 *** ERROR: OLD Batch Already Processed", FALSE)
5116: 1779:                 CALL LOG.EVENT(21)
5117: 179d:             ENDIF
5118: 17a5:         ENDIF
5119: 17b0:     ENDIF ELSE BEGIN ! New Format
5120: 17b8: 
5121: 17b8:         IF LEFT$(BCF.IUF.DATETIMESTAMP$,1) <> " " THEN BEGIN
5122: 17f0: 
5123: 17f0:             IF BCF.IUF.DATETIMESTAMP$ >= IUF.TIME.STAMP$ THEN BEGIN
5124: 1815:                 OLD.BATCH.FOUND = TRUE
5125: 1827:                 CALL DO.MESSAGE("PSB21 *** ERROR: NEW Batch Already Processed", FALSE)
5126: 185b:                 CALL LOG.EVENT(21)
5127: 187f:             ENDIF
5128: 1887:         ENDIF
5129: 188f:     ENDIF
5130: 1897: 
5131: 1897: END FUNCTION
5132: 18ae: 
5133: 18ae: 
5134: 18ae: \******************************************************************************
5135: 18ae: \***
5136: 18ae: \***  DETERMINE.LOG.FILE
5137: 18ae: \***
5138: 18ae: \***  This routine determines which log file we need to log to. PSB21 will keep
5139: 18ae: \***  a daily audit log of update activity in rolling files PSB21MON.LOG to
5140: 18ae: \***  PSB21SUN.LOG. If todays log file does not exist or is last weeks, then it
5141: 18ae: \***  is created. If todays log file exists with todays date, then it is appended
5142: 18ae: \***  to.
5143: 18ae: \******************************************************************************
5144: 18ae: 
5145: 18ae: SUB DETERMINE.LOG.FILE
5146: 18d2: 
5147: 18d2:     PRINT "Determining Log File for day: " + F13.DAY$
5148: 18f9: 
5149: 18f9:     LOG.FILENAME$ = "ADXLXACN::D:\ADX_UDT1\PSB21" + F13.DAY$ + ".LOG"
5150: 1922:     DIR.FILENAME$ = "ADXLXACN::D:\ADX_UDT1\PSB21DIR"
5151: 1939:     PROG.NAME$    = "C:\ADX_SPGM\COMMAND.286"
5152: 1950:     COMM.TAIL$    = "-CDIR " + LOG.FILENAME$ + " > " + DIR.FILENAME$
5153: 1984:     CALL EXECUTE.SVC
5154: 1990: 
5155: 1990:     CALL SESS.NUM.UTILITY("O", 450, DIR.FILENAME$)   ! 450 = Use General Temp file Report Num
5156: 19b2:     DIR.SESS.NUM% = F20.INTEGER.FILE.NO%
5157: 19cf: 
5158: 19cf:     CALL SESS.NUM.UTILITY("O", 695, LOG.FILENAME$)   ! 695 = Use General Report Num
5159: 19f1:     LOG.SESS.NUM% = F20.INTEGER.FILE.NO%
5160: 1a0e: 
5161: 1a0e:     FOUND = FALSE
5162: 1a24:     FILE.OPERATION$ = "O"
5163: 1a3b:     CURRENT.REPORT.NUM% = 450
5164: 1a4c:     IF END # DIR.SESS.NUM% THEN JUMP.OUT
5165: 1a6d:     OPEN DIR.FILENAME$ AS DIR.SESS.NUM% BUFFSIZE 32256 LOCKED NOWRITE NODEL
5166: 1a9b: 
5167: 1a9b:     WHILE NOT FOUND ! Jumps out automatically if end-of-file reached
5168: 1aa6: 
5169: 1aa6:         IF END #DIR.SESS.NUM% THEN JUMP.OUT
5170: 1ac7:         READ #DIR.SESS.NUM%; DIR.RECORD$
5171: 1af2: 
5172: 1af2:         IF (LEFT$(DIR.RECORD$,2) <> "  ") THEN BEGIN
5173: 1b2a:             DIR.FILENAME$ = LEFT$(DIR.RECORD$,8   )   ! eg. PSB21FRI
5174: 1b51:             FILE.DATE$    =  MID$(DIR.RECORD$,24,10)  ! MM-DD-CCYY  nb. 1st digit of MM can be a space
5175: 1b78:             COMPARE$ = "PSB21" + F13.DAY$
5176: 1b9d: 
5177: 1b9d:             IF COMPARE$ = DIR.FILENAME$ THEN BEGIN
5178: 1bc5:                 FOUND = TRUE ! Log File already exists
5179: 1bdb:                 IF LEFT$(FILE.DATE$,1) = " " THEN BEGIN
5180: 1c10:                      FILE.DATE$ = "0" + RIGHT$(FILE.DATE$,9)
5181: 1c3c:                 ENDIF
5182: 1c44:                 FILE.TIME.AFTER.6PM = FALSE                          ! 1.18 RC (237)
5183: 1c5a:                 IF MID$(DIR.RECORD$,41, 1) = "p" \  ! pm             ! 1.18 RC (237)
5184: 1cee:                   AND VAL(MID$(DIR.RECORD$,36, 2)) >= 6 THEN BEGIN   ! 1.18 RC (237)
5185: 1cee:                     FILE.TIME.AFTER.6PM = TRUE                       ! 1.18 RC (237)
5186: 1d04:                 ENDIF                                                ! 1.18 RC (237)
5187: 1d0c:             ENDIF
5188: 1d14:         ENDIF
5189: 1d1c:     WEND
5190: 1d31: 
5191: 1d31:   JUMP.OUT:
5192: 1d41:   !--------
5193: 1d41: 
5194: 1d41:     CLOSE DIR.SESS.NUM%                                                                               !1.6CSk
5195: 1d5a: 
5196: 1d5a: 
5197: 1d5a: !---------------------------------------------------------------------------- ! 1.18 RC (237)
5198: 1d5a: !   Create, recreate or open log file                                         ! 1.18 RC (237)
5199: 1d5a: !   Pass these from the PPFK tables to the PREV tables                        ! 1.18 RC (237)
5200: 1d5a: !---------------------------------------------------------------------------- ! 1.18 RC (237)
5201: 1d5a: !   Remainder of this section re-structured/re-written for Rv 1.18 RC (237)   ! 1.18 RC (237)
5202: 1d5a: 
5203: 1d5a: !   PROCESSING.DATE$ date is passed to PSB21 from PSB20.
5204: 1d5a: !   It is set to tomorrows date if the system date is after 6pm
5205: 1d5a: !   (specifically if TIME$ > "1800" which incudes "180000").
5206: 1d5a: !   It is used to set the day component of LOG.FILENAME$ (via F13.DAY$).
5207: 1d5a: !   The log file for day "xxx" is PSB21xxx.LOG and is updated from 6pm
5208: 1d5a: !   prior to day "xxx" and up to 6pm on day "xxx"
5209: 1d5a: 
5210: 1d5a:     IF NOT FOUND THEN BEGIN                                                                     !
5211: 1d6f: !       Create log file as it does not exist at all
5212: 1d6f:         FILE.OPERATION$ = "C"
5213: 1d86:         PRINT "Creating new log file: " + LOG.FILENAME$
5214: 1dad:         CREATE POSFILE LOG.FILENAME$ AS LOG.SESS.NUM% BUFFSIZE LOG.BUFF.SIZE% UNLOCKED MIRRORED PERUPDATE   ! 1.4 RC
5215: 1de2:         EXIT SUB                                                            ! UNLOCKED to force physical    ! 1.4 RC
5216: 1ded:     ENDIF                                                                   ! write for each logical write  ! 1.4 RC
5217: 1df5: 
5218: 1df5:     TODAY$ = RUN.DATE$  ! YYMMDD
5219: 1e13: 
5220: 1e13:     F02.DATE$ EQ TODAY$ ! YYMMDD                                                             ! 1.18 RC (237)
5221: 1e31:     CALL UPDATE.DATE(-1)                                                                     ! 1.18 RC (237)
5222: 1e49:     YESTERDAY.DDMMYY$ = RIGHT$(F02.DATE$, 2) + MID$(F02.DATE$, 3, 2) + LEFT$(F02.DATE$, 2)   ! 1.18 RC (237)
5223: 1eaf: 
5224: 1eaf:     TODAY$ =   RIGHT$(TODAY$, 2) + MID$(TODAY$, 3, 2) + LEFT$(TODAY$, 2) ! DDMMYY
5225: 1f15:     FILE.DATE$ = MID$(FILE.DATE$, 4, 2) + RIGHT$("00" + LEFT$(FILE.DATE$, 2), 2) + RIGHT$(FILE.DATE$, 2) ! DDMMYY
5226: 1fa3: 
5227: 1fa3: !   At this point it is known a log file already exists for required day of week
5228: 1fa3: !   Check whether this log file relates to price change day currently being processed
5229: 1fa3: 
5230: 1fa3:     IF (     RUN.TIME$ >= "180000" \   ! Program running in evening before price change day
5231: 20bb:          AND FILE.DATE$ = TODAY$ \     ! Log file was last created/recreated/updated this evening
5232: 20bb:          AND FILE.TIME.AFTER.6PM ) \
5233: 20bb:       OR \
5234: 20bb:        (     RUN.TIME$ < "180000" \           ! Program running on day of price changes
5235: 20bb:          AND FILE.DATE$ = YESTERDAY.DDMMYY$ \ ! Log file was last created/recreated/updated yesterday evening
5236: 20bb:          AND FILE.TIME.AFTER.6PM ) \
5237: 20bb:       OR \
5238: 20bb:        (     RUN.TIME$ < "180000" \           ! Program running on day of price changes
5239: 20bb:         AND FILE.DATE$ = TODAY$) THEN BEGIN   ! Log file was last created/recreated/updated today
5240: 20bb: 
5241: 20bb: !         Append to existing log file recently updated for current PROCESSING.DATE$ day
5242: 20bb:           FILE.OPERATION$ = "O"
5243: 20d2:           PRINT "Appending to log file: " + COMPARE$
5244: 20f9:           OPEN LOG.FILENAME$ AS LOG.SESS.NUM% BUFFSIZE LOG.BUFF.SIZE% UNLOCKED APPEND               ! 1.4 RC
5245: 212f:           EXIT SUB                                                  ! UNLOCKED to force physical    ! 1.4 RC
5246: 213a:     ENDIF                                                           ! write for each logical write  ! 1.4 RC
5247: 2142: 
5248: 2142: !   At this point it is known a log file already exists for required day of week
5249: 2142: !   but does not contain any data for the price change day currently being processed
5250: 2142: 
5251: 2142: !   Re-create log file
5252: 2142:     FILE.OPERATION$ = "C"
5253: 2159:     PRINT "Re-creating log file: " + COMPARE$
5254: 2180:     CREATE POSFILE LOG.FILENAME$ AS LOG.SESS.NUM% BUFFSIZE LOG.BUFF.SIZE% UNLOCKED MIRRORED PERUPDATE   ! 1.4 RC
5255: 21b5:                                                                         ! UNLOCKED to force physical    ! 1.4 RC
5256: 21b5:                                                                         ! write for each logical write  ! 1.4 RC
5257: 21b5: 
5258: 21b5: !   Initial log file message moved to INITIALISATION                      ! 1.18 RC (237)
5259: 21b5: 
5260: 21b5: END SUB
5261: 21c9: 
5262: 21c9: 
5263: 21c9: \******************************************************************************
5264: 21c9: \***
5265: 21c9: \***  BACKUP.IUF.FILE
5266: 21c9: \***
5267: 21c9: \***  This routine maintains 7 days backups of IUF files: IUF.MON to IUF.SUN.
5268: 21c9: \***  Any existing backups will be overwritten.
5269: 21c9: \******************************************************************************
5270: 21c9: 
5271: 21c9: SUB BACKUP.IUF.FILE PUBLIC
5272: 21ed: 
5273: 21ed:     PHASE$ = "6.0"                                                                  !1.6CSk
5274: 2204:     CALL DO.MESSAGE("PSB21 PHASE 6", TRUE)
5275: 2238: 
5276: 2238: !   Ensure IUF is only backed up when processing was successful   ! 1.17 RC (230)
5277: 2238: !   (which at this point means JOBSOK.FLAG$ is still " " blank    ! 1.17 RC (230)
5278: 2238: !    prior to being changed to "E" within UPDATE.JOBSOK)          ! 1.17 RC (230)
5279: 2238: !   or IUF does not otherwise need to be re-processed             ! 1.17 RC (230)
5280: 2238: !   (which at this point means JOBSOK.FLAG$ is "Y")               ! 1.17 RC (230)
5281: 2238:     IF    JOBSOK.FLAG$ <> " " \                                   ! 1.17 RC (230)
5282: 228a:       AND JOBSOK.FLAG$ <> "Y" THEN BEGIN                          ! 1.17 RC (230)
5283: 228a:         EXIT SUB                                                  ! 1.17 RC (230)
5284: 2295:     ENDIF                                                         ! 1.17 RC (230)
5285: 229d: 
5286: 229d:     IF IUF.EXISTS \                                               ! 1.6 RC (87)
5287: 22bc:       AND NOT IUF.OPEN THEN BEGIN                                 ! 1.6 RC (87)
5288: 22bc: 
5289: 22bc:         PHASE$ = "6.1"                                                              !1.6CSk
5290: 22d3:         CALL DO.MESSAGE("PSB21 6.1  - Backing up IUF File to: IUFBK." + F13.DAY$, TRUE)
5291: 2315: 
5292: 2315:         RC% = OPEN.IUF
5293: 2333: 
5294: 2333:         IF RC% <> 0 THEN BEGIN
5295: 2355:             PHASE$ = "6.2"                                                          !1.6CSk
5296: 236c:             IF NOT IUF.OPEN.ERROR.REPORTED THEN BEGIN             ! 1.8 RC (8)
5297: 237e:                 CALL DO.MESSAGE("PSB21 6.2 *** ERROR: opening IUF for backup", FALSE)
5298: 23b2:                 !CALL LOG.EVENT(106)
5299: 23b2:                 IUF.OPEN.ERROR.REPORTED = TRUE                    ! 1.8 RC (8)
5300: 23c8:             ENDIF                                                 ! 1.8 RC (8)
5301: 23d0:             EXIT SUB
5302: 23db:         ENDIF
5303: 23e3: 
5304: 23e3:         IUF.BACKUP.FILENAME$ = "ADXLXACN::D:\ADX_UDT1\IUFBK." + F13.DAY$
5305: 2408: 
5306: 2408:         CALL SESS.NUM.UTILITY("O", 695, IUF.BACKUP.FILENAME$)   ! 695 = Use General Report Num
5307: 242a:         IUF.BACKUP.SESS.NUM% = F20.INTEGER.FILE.NO%
5308: 2440: 
5309: 2440: 
5310: 2440:         CALL ADXCOPYF(RC%, IUF.FILE.NAME$, IUF.BACKUP.FILENAME$,0,0,0)
5311: 248c: 
5312: 248c:         IF RC% <> 0 THEN BEGIN
5313: 24ae:             PHASE$ = "6.3"                                                          !1.6CSk
5314: 24c5:             CALL DO.MESSAGE("PSB21 6.3 *** ERROR copying IUF to " + \
5315: 2507:                             IUF.BACKUP.FILENAME$, TRUE)
5316: 2507:             BACKUP.SOURCE.FILE$ = "IUF     "
5317: 251e:             CALL LOG.EVENT(57)
5318: 2542:             EXIT SUB
5319: 254f:         ENDIF ELSE BEGIN
5320: 2557:             DELETE IUF.SESS.NUM%
5321: 256b:             CALL DO.MESSAGE("PSB21 IUF BACKUP - deleted IUF file", TRUE) ! 1.4 RC
5322: 259f:         ENDIF
5323: 25a7: 
5324: 25a7:         CALL DO.MESSAGE("PSB21 IUF BACKUP - Completed IUF Backup", TRUE) ! 1.4 RC
5325: 25dd: 
5326: 25dd:     ENDIF ELSE BEGIN
5327: 25e5: 
5328: 25e5:         CALL DO.MESSAGE("PSB21 IUF BACKUP - IUF missing / not processed", TRUE) ! 1.6 RC (50)
5329: 2619:         CALL DO.MESSAGE("PSB21 IUF BACKUP - No IUF backup made", TRUE)          ! 1.4 RC
5330: 264d: 
5331: 264d:     ENDIF
5332: 2655: 
5333: 2655: END SUB
5334: 2669: 
5335: 2669: 
5336: 2669: 
5337: 2669: 
5338: 2669: \******************************************************************************
5339: 2669: \***
5340: 2669: \***    SET.AND.ALLOCATE.FILE.SESSION.NUMBERS
5341: 2669: \***
5342: 2669: \******************************************************************************
5343: 2669: SUB SET.AND.ALLOCATE.FILE.SESSION.NUMBERS
5344: 268d: 
5345: 268d:     CALL BCF.SET
5346: 26a8:     CALL CIPPM.SET
5347: 26b5:     CALL DRUG.SET
5348: 26d0:     CALL IDF.SET
5349: 26eb:     CALL IEF.SET
5350: 2706:     CALL IEX.SET
5351: 2721:     CALL IRF.SET
5352: 273c:     CALL IRFITGRP.SET                                                   !HRN
5353: 2757:     CALL ISF.SET
5354: 2764:     CALL IUF.SET
5355: 2771:     CALL LOCAL.SET
5356: 278c:     CALL NEWLINES.SET
5357: 2799:     CALL PGF.SET
5358: 27a6:     CALL PPFI.SET
5359: 27b3:     CALL PPFK.SET
5360: 27ce:     CALL PPFO.SET
5361: 27db:     CALL RICF.SET
5362: 27e8:     CALL SOFTS.SET
5363: 2803:     CALL STKMQ.SET
5364: 281e:     CALL STOCK.SET
5365: 2839:     CALL SUPPARAM.SET
5366: 2854:     CALL WEEEUF.SET
5367: 286f: 
5368: 286f:     CALL SESS.NUM.UTILITY("O", BCF.REPORT.NUM%, BCF.FILE.NAME$)
5369: 2895:     BCF.SESS.NUM% = F20.INTEGER.FILE.NO%
5370: 28ab:     CALL SESS.NUM.UTILITY("O", CIPPM.REPORT.NUM%, CIPPM.FILE.NAME$)
5371: 28d1:     CIPPM.SESS.NUM% = F20.INTEGER.FILE.NO%
5372: 28e7:     CALL SESS.NUM.UTILITY("O", DRUG.REPORT.NUM%, DRUG.FILE.NAME$)
5373: 290d:     DRUG.SESS.NUM% = F20.INTEGER.FILE.NO%
5374: 2923:     CALL SESS.NUM.UTILITY("O", IDF.REPORT.NUM%, IDF.FILE.NAME$)
5375: 2949:     IDF.SESS.NUM% = F20.INTEGER.FILE.NO%
5376: 295f:     CALL SESS.NUM.UTILITY("O", IEF.REPORT.NUM%, IEF.FILE.NAME$)
5377: 2985:     IEF.SESS.NUM% = F20.INTEGER.FILE.NO%
5378: 299b:     CALL SESS.NUM.UTILITY("O", IEX.REPORT.NUM%, IEX.FILE.NAME$)
5379: 29c1:     IEX.SESS.NUM% = F20.INTEGER.FILE.NO%
5380: 29d7:     CALL SESS.NUM.UTILITY("O", IRF.REPORT.NUM%, IRF.FILE.NAME$)
5381: 29fd:     IRF.SESS.NUM% = F20.INTEGER.FILE.NO%
5382: 2a13:     CALL SESS.NUM.UTILITY("O", IRFDEX.REPORT.NUM%, IRFDEX.FILE.NAME$)  ! 1.21 RC (242)
5383: 2a39:     IRFDEX.SESS.NUM% = F20.INTEGER.FILE.NO%                            ! 1.21 RC (242)
5384: 2a4f:     CALL SESS.NUM.UTILITY("O", ISF.REPORT.NUM%, ISF.FILE.NAME$)
5385: 2a75:     ISF.SESS.NUM% = F20.INTEGER.FILE.NO%
5386: 2a8b:     CALL SESS.NUM.UTILITY("O", IUF.REPORT.NUM%, IUF.FILE.NAME$)
5387: 2ab1:     IUF.SESS.NUM% = F20.INTEGER.FILE.NO%
5388: 2ac7:     CALL SESS.NUM.UTILITY("O", LOCAL.REPORT.NUM%, LOCAL.FILE.NAME$)
5389: 2aed:     LOCAL.SESS.NUM% = F20.INTEGER.FILE.NO%
5390: 2b03:     CALL SESS.NUM.UTILITY("O", NEWLINES.REPORT.NUM%, NEWLINES.FILE.NAME$)
5391: 2b29:     NEWLINES.SESS.NUM% = F20.INTEGER.FILE.NO%
5392: 2b3f:     CALL SESS.NUM.UTILITY("O", PPFI.REPORT.NUM%, PPFI.FILE.NAME$)
5393: 2b65:     PPFI.SESS.NUM% = F20.INTEGER.FILE.NO%
5394: 2b7b:     CALL SESS.NUM.UTILITY("O", PGF.REPORT.NUM%, PGF.FILE.NAME$)
5395: 2ba1:     PGF.SESS.NUM% = F20.INTEGER.FILE.NO%
5396: 2bb7:     CALL SESS.NUM.UTILITY("O",PPFK.REPORT.NUM%,PPFK.FILE.NAME$)
5397: 2bdd:     PPFK.SESS.NUM% = F20.INTEGER.FILE.NO%
5398: 2bf3:     CALL SESS.NUM.UTILITY("O", PPFO.REPORT.NUM%, PPFO.FILE.NAME$)
5399: 2c19:     PPFO.SESS.NUM% = F20.INTEGER.FILE.NO%
5400: 2c2f:     CALL SESS.NUM.UTILITY("O", RICF.REPORT.NUM%, RICF.FILE.NAME$)
5401: 2c55:     RICF.SESS.NUM% = F20.INTEGER.FILE.NO%
5402: 2c6b:     CALL SESS.NUM.UTILITY("O", SOFTS.REPORT.NUM%, SOFTS.FILE.NAME$)
5403: 2c91:     SOFTS.SESS.NUM% = F20.INTEGER.FILE.NO%
5404: 2ca7:     CALL SESS.NUM.UTILITY("O", STKMQ.REPORT.NUM%, STKMQ.FILE.NAME$)
5405: 2ccd:     STKMQ.SESS.NUM% = F20.INTEGER.FILE.NO%
5406: 2ce3:     CALL SESS.NUM.UTILITY("O", STOCK.REPORT.NUM%, STOCK.FILE.NAME$)
5407: 2d09:     STOCK.SESS.NUM% = F20.INTEGER.FILE.NO%
5408: 2d1f:     CALL SESS.NUM.UTILITY("O", SUPPARAM.REPORT.NUM%, SUPPARAM.FILE.NAME$)
5409: 2d45:     SUPPARAM.SESS.NUM% = F20.INTEGER.FILE.NO%
5410: 2d5b:     CALL SESS.NUM.UTILITY("O", WEEEUF.REPORT.NUM%, WEEEUF.FILE.NAME$)
5411: 2d81:     WEEEUF.SESS.NUM% = F20.INTEGER.FILE.NO%
5412: 2d97:     CALL SESS.NUM.UTILITY("O",IRFITGRP.REPORT.NUM%,IRFITGRP.FILE.NAME$) !HRN
5413: 2dbd:     IRFITGRP.SESS.NUM% = F20.INTEGER.FILE.NO%                           !HRN
5414: 2dd3: 
5415: 2dd3: END SUB
5416: 2de7: 
5417: 2de7: 
5418: 2de7: \******************************************************************************
5419: 2de7: \***
5420: 2de7: \***   OPEN.FILES
5421: 2de7: \***
5422: 2de7: \******************************************************************************
5423: 2de7: SUB OPEN.FILES
5424: 2e0b: 
5425: 2e0b:     FILE.OPERATION$ = "O"
5426: 2e22: 
5427: 2e22: !   CURRENT.REPORT.NUM% = BCF.REPORT.NUM%                           ! 1.15 CSk
5428: 2e22: !   IF END # BCF.SESS.NUM% THEN OPEN.FILE.ERROR                     ! 1.15 CSk
5429: 2e22: !   OPEN BCF.FILE.NAME$ RECL BCF.RECL% AS BCF.SESS.NUM%             ! 1.15 CSk
5430: 2e22: 
5431: 2e22:     CURRENT.REPORT.NUM% = SOFTS.REPORT.NUM%
5432: 2e38:     IF END # SOFTS.SESS.NUM% THEN OPEN.FILE.ERROR
5433: 2e54:     OPEN SOFTS.FILE.NAME$ RECL SOFTS.RECL% AS SOFTS.SESS.NUM% NOWRITE NODEL
5434: 2e81: 
5435: 2e81:     CURRENT.REPORT.NUM% = CIPPM.REPORT.NUM%
5436: 2e97:     IF END # CIPPM.SESS.NUM% THEN CIPPMR.NOT.PRESENT                ! 1.16 RC (226)
5437: 2eb3:     OPEN CIPPM.FILE.NAME$ AS CIPPM.SESS.NUM% LOCKED
5438: 2eda:     CIPPM.PRESENT = TRUE                                            ! 1.16 RC (226)
5439: 2ef0: 
5440: 2ef0: CIPPMR.NOT.PRESENT: ! Store not on CIP                              ! 1.16 RC (226)
5441: 2f00: 
5442: 2f00:     CURRENT.REPORT.NUM% = DRUG.REPORT.NUM%
5443: 2f16:     IF END # DRUG.SESS.NUM% THEN OPEN.FILE.ERROR
5444: 2f32:     OPEN DRUG.FILE.NAME$ KEYED RECL DRUG.RECL% AS DRUG.SESS.NUM%
5445: 2f5e: 
5446: 2f5e:     CURRENT.REPORT.NUM% = IDF.REPORT.NUM%
5447: 2f74:     IF END # IDF.SESS.NUM% THEN OPEN.FILE.ERROR
5448: 2f90:     OPEN IDF.FILE.NAME$ KEYED RECL IDF.RECL% AS IDF.SESS.NUM%
5449: 2fbc: 
5450: 2fbc:     CURRENT.REPORT.NUM% = IEF.REPORT.NUM%
5451: 2fd2:     IF END # IEF.SESS.NUM% THEN OPEN.FILE.ERROR
5452: 2fee:     OPEN IEF.FILE.NAME$ KEYED RECL IEF.RECL% AS IEF.SESS.NUM%
5453: 301a: 
5454: 301a:     CURRENT.REPORT.NUM% = IEX.REPORT.NUM%
5455: 3030:     IF END # IEX.SESS.NUM% THEN OPEN.FILE.ERROR
5456: 304c:     OPEN IEX.FILE.NAME$ KEYED RECL IEX.RECL% AS IEX.SESS.NUM%
5457: 3078: 
5458: 3078:     CURRENT.REPORT.NUM% = IRF.REPORT.NUM%
5459: 308e:     IF END # IRF.SESS.NUM% THEN OPEN.FILE.ERROR
5460: 30aa:     OPEN IRF.FILE.NAME$ KEYED RECL IRF.RECL% AS IRF.SESS.NUM%
5461: 30d6: 
5462: 30d6:     IF OPEN.IRF.UPDT (NEW.IRF.DATA$,ACD.FLAG$) THEN BEGIN
5463: 3100:         GOTO OPEN.FILE.ERROR
5464: 310b:     ENDIF
5465: 3113: 
5466: 3113:     CURRENT.REPORT.NUM% = IRFDEX.REPORT.NUM%                           ! 1.21 RC (242)
5467: 3129:     IF END # IRFDEX.SESS.NUM% THEN OPEN.FILE.ERROR                     ! 1.21 RC (242)
5468: 3145:     OPEN IRFDEX.FILE.NAME$ KEYED RECL IRFDEX.RECL% AS IRFDEX.SESS.NUM% ! 1.21 RC (242)
5469: 3171: 
5470: 3171:     CURRENT.REPORT.NUM% = ISF.REPORT.NUM%
5471: 3187:     IF END # ISF.SESS.NUM% THEN OPEN.FILE.ERROR
5472: 31a3:     OPEN ISF.FILE.NAME$ KEYED RECL ISF.RECL% AS ISF.SESS.NUM%
5473: 31cf: 
5474: 31cf:     CURRENT.REPORT.NUM% = LOCAL.REPORT.NUM%
5475: 31e5:     IF END # LOCAL.SESS.NUM% THEN OPEN.FILE.ERROR
5476: 3201:     OPEN LOCAL.FILE.NAME$ KEYED RECL LOCAL.RECL% AS LOCAL.SESS.NUM%
5477: 322d: 
5478: 322d:     CURRENT.REPORT.NUM% = NEWLINES.REPORT.NUM%
5479: 3243:     IF END # NEWLINES.SESS.NUM% THEN OPEN.FILE.ERROR
5480: 325f:     OPEN NEWLINES.FILE.NAME$ KEYED RECL NEWLINES.RECL% AS NEWLINES.SESS.NUM%
5481: 328b: 
5482: 328b:     CURRENT.REPORT.NUM% = STOCK.REPORT.NUM%
5483: 32a1:     IF END # STOCK.SESS.NUM% THEN OPEN.FILE.ERROR
5484: 32bd:     OPEN STOCK.FILE.NAME$ KEYED RECL STOCK.RECL% AS STOCK.SESS.NUM%
5485: 32eb: 
5486: 32eb: 	
5487: 32eb: 	
5488: 32eb:     IRFITGRP.OPEN = FALSE                                               !HRN
5489: 3301:     CURRENT.REPORT.NUM% = IRFITGRP.REPORT.NUM%                          !HRN
5490: 3317:  
5491: 3317:     IF END #IRFITGRP.SESS.NUM% THEN OPEN.FILE.ERROR                     !HRN
5492: 3333: 	
5493: 3333: 	PRINT "FILE NAME" ;IRFITGRP.FILE.NAME$
5494: 3354: 	PRINT "RECORD LENGTH" ; IRFITGRP.RECL%
5495: 3371: 	PRINT " SESS NUM" ; IRFITGRP.SESS.NUM%
5496: 338e: 	PRINT "REPORT NUM" ; IRFITGRP.REPORT.NUM% 
5497: 33ab:     OPEN IRFITGRP.FILE.NAME$ KEYED RECL IRFITGRP.RECL% AS IRFITGRP.SESS.NUM%!HRN
5498: 33d7: 													  
5499: 33d7: 	 
5500: 33d7: 	
5501: 33d7:     IRFITGRP.OPEN = TRUE                                                !HRN
5502: 33ed: 
5503: 33ed:     EXIT SUB
5504: 33f7: 
5505: 33f7:  OPEN.FILE.ERROR:
5506: 3407:  
5507: 3407:     PRINT " I AM ERRORING"
5508: 3418: 
5509: 3418:     CALL LOG.EVENT(106)
5510: 343c: 
5511: 343c: END SUB
5512: 3450: 
5513: 3450: 
5514: 3450: \******************************************************************************
5515: 3450: \***
5516: 3450: \***  CREATE.FILES
5517: 3450: \***
5518: 3450: \******************************************************************************
5519: 3450: SUB CREATE.FILES
5520: 3474: 
5521: 3474:     CURRENT.REPORT.NUM% = RICF.REPORT.NUM%
5522: 348a:     CREATE POSFILE RICF.FILE.NAME$ DIRECT 0 RECL RICF.RECL% \
5523: 34bb:                     AS RICF.SESS.NUM% MIRRORED ATCLOSE
5524: 34bb: 
5525: 34bb: !   Line deleted                                               ! 1.13 RC (179)
5526: 34bb: 
5527: 34bb: END SUB
5528: 34cf: 
5529: 34cf: 
5530: 34cf: 
5531: 34cf: 
5532: 34cf: \******************************************************************************
5533: 34cf: \***
5534: 34cf: \***    GET.BCF.DETAILS
5535: 34cf: \***
5536: 34cf: \******************************************************************************
5537: 34cf: SUB GET.BCF.DETAILS
5538: 34f3: 
5539: 34f3:     INTEGER*2  BCF.REC22.OFFSET.COUNT% !Initial offset of           ! ACSk
5540: 34f3:                                        !BRCF record 22              ! ACSk
5541: 34f3:     STRING     DEFAULT.GCM.PG.NO$, \   !Default & Read Gift Card    ! ACSk
5542: 34f3:                READ.GCM.PG.NO$     !   !Mall Product Group Number   ! ACSk
5543: 34f3: 
5544: 34f3:     CALL DO.MESSAGE("PSB21 - GET.BCF.DETAILS", FALSE)
5545: 3527: 
5546: 3527:     FILE.OPERATION$ = "O"                                           ! 1.15 CSk
5547: 353e: 
5548: 353e:     CURRENT.REPORT.NUM% = BCF.REPORT.NUM%                           ! 1.15 CSk
5549: 3554:     IF END # BCF.SESS.NUM% THEN OPEN.BCF.ERROR                      ! 1.15 CSk
5550: 3570:     OPEN BCF.FILE.NAME$ RECL BCF.RECL% AS BCF.SESS.NUM%             ! 1.15 CSk
5551: 359c: 
5552: 359c:     !--------------------------------------------
5553: 359c:     ! Extact BCF.IUF.SERIAL.NO$ from BCF record 1
5554: 359c:     !--------------------------------------------
5555: 359c:     BCF.REC.NO% = 1
5556: 35b3:     RC% = READ.BCF
5557: 35ce:     IF RC% <> 0 THEN BEGIN
5558: 35ed:         CALL LOG.EVENT(106)
5559: 3611:     ENDIF
5560: 3619:     CALL DO.MESSAGE("PSB21 - BCF Rec  1 Serial No         : [" + BCF.IUF.SERIAL.NO$ + "]", FALSE)
5561: 365f: 
5562: 365f:     !-------------------------------------------------
5563: 365f:     ! Extact BCF.ECC.DATETIMESTAMP$ from BCF record 14
5564: 365f:     !-------------------------------------------------
5565: 365f:     BCF.REC.NO% = 14  !
5566: 3676:     RC% = READ.BCF
5567: 3691:     IF RC% <> 0 THEN BEGIN
5568: 36b0:         CALL LOG.EVENT(106)
5569: 36d4:     ENDIF
5570: 36dc:     CALL DO.MESSAGE("PSB21 - BCF Rec 14 ECC Date Timestamp: [" + BCF.FILLER.DATETIMESTAMP$ + "]", FALSE) !GMW
5571: 3722: 
5572: 3722:     !------------------------------------------                                          !1.6CSk
5573: 3722:     ! Extact Statins markers from BCF record 16                                          !1.6CSk
5574: 3722:     !------------------------------------------                                          !1.6CSk
5575: 3722:     BCF.REC.NO% = 16                                                                     !1.6CSk
5576: 3739:     RC% = READ.BCF                                                                       !1.6CSk
5577: 3754:     IF RC% <> 0 THEN BEGIN                                                               !1.6CSk
5578: 3773:          CALL LOG.EVENT(106)                                                             !1.6CSk
5579: 3797:     ENDIF                                                                                !1.6CSk
5580: 379f:     CALL DO.MESSAGE("PSB21 - BCF Rec 16 Statin markers: [" + BCF.RECORD$ + "]", FALSE)   !1.6CSk
5581: 37e5:                                                                                          !1.6CSk
5582: 37e5:     NO.OF.STATINS% = 0                                                                   !1.6CSk
5583: 37f6:     MATCH.COMMA%   = 1                                                                   !1.6CSk
5584: 3807:                                                                                          !1.6CSk
5585: 3807:     WHILE MATCH.COMMA% <> 0                                                              !1.6CSk
5586: 3811:         MATCH.COMMA% = MATCH(",", BCF.RECORD$,MATCH.COMMA% + 1)                          !1.6CSk
5587: 383d:         IF MATCH.COMMA% <> 0 THEN BEGIN                                                  !1.6CSk
5588: 384f:            NO.OF.STATINS% = NO.OF.STATINS% + 1                                           !1.6CSk
5589: 385e:         ENDIF                                                                            !1.6CSk
5590: 3866:     WEND                                                                                 !1.6CSk
5591: 3878:                                                                                          !1.6CSk
5592: 3878:     DIM STATINS$(NO.OF.STATINS%)                                                         !1.6CSk
5593: 38ac:                                                                                          !1.6CSk
5594: 38ac:     IF NO.OF.STATINS% > 0 THEN BEGIN                                                     !1.6CSk
5595: 38c1:                                                                                          !1.6CSk
5596: 38c1:         MATCH.POS1% = 1                                                                  !1.6CSk
5597: 38d2:                                                                                          !1.6CSk
5598: 38d2:         FOR J% = 1 TO NO.OF.STATINS%                                                     !1.6CSk
5599: 38e6:                                                                                          !1.6CSk
5600: 38e6:             IF MATCH.POS1% = 1 THEN BEGIN                                                !1.6CSk
5601: 38fb:                 MATCH.POS2% = MATCH(",",BCF.RECORD$,MATCH.POS1%)                         !1.6CSk
5602: 3925:                 IF MATCH.POS2% THEN BEGIN                                                !1.6CSk
5603: 3938:                      STATIN.INDICATOR$ = LEFT$(BCF.RECORD$,MATCH.POS2% - 1)              !1.6CSk
5604: 3966:                      MATCH.POS1% = MATCH.POS2% + 1                                       !1.6CSk
5605: 397f:                  ENDIF ELSE BEGIN                                                        !1.6CSk
5606: 3987:                      MATCH.POS1% = MATCH(" ", BCF.RECORD$, 1)                            !1.6CSk
5607: 39ac:                      STATIN.INDICATOR$ = LEFT$(BCF.RECORD$, MATCH.POS1%- 1)              !1.6CSk
5608: 39da:                  ENDIF                                                                   !1.6CSk
5609: 39e5:             ENDIF ELSE BEGIN                                                             !1.6CSk
5610: 39ed:                 MATCH.POS2% = MATCH(",",BCF.RECORD$,MATCH.POS1%)                         !1.6CSk
5611: 3a17:                 IF MATCH.POS2% <> 0 THEN BEGIN                                           !1.6CSk
5612: 3a29:                     STATIN.INDICATOR$ = MID$(BCF.RECORD$, MATCH.POS1%,     \             !1.6CSk
5613: 3a62:                          (MATCH.POS2% - MATCH.POS1%))                                    !1.6CSk
5614: 3a62:                     MATCH.POS1% = MATCH.POS2% + 1                                        !1.6CSk
5615: 3a7c:                ENDIF ELSE BEGIN                                                          !1.6CSk
5616: 3a84:                    STATIN.INDICATOR$ = RIGHT$(BCF.RECORD$,(LEN(BCF.RECORD$)\             !1.6CSk
5617: 3ac1:                          - MATCH.POS1%) + 1)                                             !1.6CSk
5618: 3ac1:                    MATCH.POS1% = MATCH(" ", STATIN.INDICATOR$, 1)                        !1.6CSk
5619: 3ae6:                    STATIN.INDICATOR$ = LEFT$(STATIN.INDICATOR$,MATCH.POS1%-1)            !1.6CSk
5620: 3b14:                ENDIF                                                                     !1.6CSk
5621: 3b1c:             ENDIF                                                                        !1.6CSk
5622: 3b24:                                                                                          !1.6CSk
5623: 3b24:             STATINS$(J%) = STATIN.INDICATOR$                                             !1.6CSk
5624: 3b53:                                                                                          !1.6CSk
5625: 3b53:         NEXT J%                                                                          !1.6CSk
5626: 3b7d:                                                                                          !1.6CSk
5627: 3b7d:     ENDIF                                                                                !1.6CSk
5628: 3b85:     !-----------------------------------------------------                               !1.6CSk
5629: 3b85:     ! Extact Chlamydia Test Kit markers from BCF record 18                               !1.6CSk
5630: 3b85:     !-----------------------------------------------------                               !1.6CSk
5631: 3b85:     BCF.REC.NO% = 18                                                                     !1.6CSk
5632: 3b9c:     RC% = READ.BCF                                                                       !1.6CSk
5633: 3bb7:     IF RC% <> 0 THEN BEGIN                                                               !1.6CSk
5634: 3bd6:          CALL LOG.EVENT(106)                                                             !1.6CSk
5635: 3bfa:     ENDIF                                                                                !1.6CSk
5636: 3c02:     CALL DO.MESSAGE("PSB21 - BCF Rec 18 Chlamydia Test Kit markers: [" + \               !1.6CSk
5637: 3c48:                      BCF.RECORD$ + "]", FALSE)                                           !1.6CSk
5638: 3c48:                                                                                          !1.6CSk
5639: 3c48:     CHLAMYDIA.LIST$ = BCF.RECORD$                                                        !1.6CSk
5640: 3c66:                                                                                          !1.6CSk
5641: 3c66:     NO.OF.CHLAMYDIA% = 0                                                                 !1.6CSk
5642: 3c77:     IF LEFT$(CHLAMYDIA.LIST$,1) <> " " THEN BEGIN                                        !1.6CSk
5643: 3caf:        MATCH.COMMA% = 1                                                                  !1.6CSk
5644: 3cc0:        WHILE MATCH.COMMA% <> 0                                                           !1.6CSk
5645: 3cca:           MATCH.COMMA% = MATCH(",", CHLAMYDIA.LIST$, MATCH.COMMA% + 1)                   !1.6CSk
5646: 3cf6:           NO.OF.CHLAMYDIA% = NO.OF.CHLAMYDIA% + 1                                        !1.6CSk
5647: 3d05:        WEND                                                                              !1.6CSk
5648: 3d17:                                                                                          !1.6CSk
5649: 3d17:        DIM CHLAMYDIA.ID$(NO.OF.CHLAMYDIA%)                                               !1.6CSk
5650: 3d4b:                                                                                          !1.6CSk
5651: 3d4b:     ENDIF                                                                                !1.6CSk
5652: 3d53:                                                                                          !1.6CSk
5653: 3d53:     IF NO.OF.CHLAMYDIA% > 0 THEN BEGIN                                                   !1.6CSk
5654: 3d68:        MATCH.POS1% = 1                                                                   !1.6CSk
5655: 3d79:                                                                                          !1.6CSk
5656: 3d79:        FOR J% = 1 TO NO.OF.CHLAMYDIA%                                                    !1.6CSk
5657: 3d8d:                                                                                          !1.6CSk
5658: 3d8d:          IF MATCH.POS1% = 1 THEN BEGIN                                                   !1.6CSk
5659: 3da2:             MATCH.POS2% = MATCH(",",CHLAMYDIA.LIST$,MATCH.POS1%)                         !1.6CSk
5660: 3dcc:             IF MATCH.POS2% THEN BEGIN                                                    !1.6CSk
5661: 3ddf:                CHLAM.TEMP$ = LEFT$(CHLAMYDIA.LIST$,MATCH.POS2% - 1)                      !1.6CSk
5662: 3e0d:                MATCH.POS1% = MATCH.POS2% + 1                                             !1.6CSk
5663: 3e26:             ENDIF ELSE BEGIN                                                             !1.6CSk
5664: 3e2e:                MATCH.POS1% = MATCH(" ", CHLAMYDIA.LIST$, 1)                              !1.6CSk
5665: 3e53:                CHLAM.TEMP$ = LEFT$(CHLAMYDIA.LIST$, MATCH.POS1% - 1)                     !1.6CSk
5666: 3e81:             ENDIF                                                                        !1.6CSk
5667: 3e8c:          ENDIF ELSE BEGIN                                                                !1.6CSk
5668: 3e94:             MATCH.POS2% = MATCH(",",CHLAMYDIA.LIST$,MATCH.POS1%)                         !1.6CSk
5669: 3ebe:             IF MATCH.POS2% <> 0 THEN BEGIN                                               !1.6CSk
5670: 3ed0:                CHLAM.TEMP$ = MID$(CHLAMYDIA.LIST$, MATCH.POS1%,  \                       !1.6CSk
5671: 3f09:                       (MATCH.POS2% - MATCH.POS1%))                                       !1.6CSk
5672: 3f09:                MATCH.POS1% = MATCH.POS2% + 1                                             !1.6CSk
5673: 3f23:             ENDIF ELSE BEGIN                                                             !1.6CSk
5674: 3f2b:                CHLAM.TEMP$ = RIGHT$(CHLAMYDIA.LIST$,(LEN(CHLAMYDIA.LIST$) \              !1.6CSk
5675: 3f68:                            - MATCH.POS1%) + 1)                                           !1.6CSk
5676: 3f68:                MATCH.POS1% = MATCH(" ", CHLAM.TEMP$, 1)                                  !1.6CSk
5677: 3f8d:                CHLAM.TEMP$ = LEFT$(CHLAM.TEMP$, MATCH.POS1% - 1)                         !1.6CSk
5678: 3fbb:             ENDIF                                                                        !1.6CSk
5679: 3fc3:          ENDIF                                                                           !1.6CSk
5680: 3fcb:                                                                                          !1.6CSk
5681: 3fcb:          CHLAMYDIA.ID$(J%) = CHLAM.TEMP$                                                 !1.6CSk
5682: 3ffa:                                                                                          !1.6CSk
5683: 3ffa:        NEXT J%                                                                           !1.6CSk
5684: 4024:                                                                                          !1.6CSk
5685: 4024:     ENDIF                                                                                !1.6CSk
5686: 402c:     !-----------------------------------------------------
5687: 402c:     ! Extact BCF.IUF.DATETIMESTAMP$ from BCF record 20
5688: 402c:     !-----------------------------------------------------
5689: 402c:     BCF.REC.NO% = 20
5690: 4043:     RC% = READ.BCF
5691: 405e:     IF RC% <> 0 THEN BEGIN
5692: 407d:         CALL LOG.EVENT(106)
5693: 40a1:     ENDIF
5694: 40a9:     CALL DO.MESSAGE("PSB21 - BCF Rec 20 Batch Timestamp   : [" + BCF.IUF.DATETIMESTAMP$ + "]", FALSE)
5695: 40ef:     !--------------------------------------------------------                  ! ACSk
5696: 40ef:     ! Extact Gift Card Mall Product Groups from BCF record 22                  ! ACSk
5697: 40ef:     !--------------------------------------------------------                  ! ACSk
5698: 40ef:     BCF.REC.NO% = 22                                                           ! ACSk
5699: 4106:     RC% = READ.BCF                                                             ! ACSk
5700: 4121:     IF RC% <> 0 THEN BEGIN                                                     ! ACSk
5701: 4140:         CALL LOG.EVENT(106)                                                    ! ACSk
5702: 4164:     ENDIF                                                                      ! ACSk
5703: 416c: 
5704: 416c:     BCF.REC22.OFFSET.COUNT% = 1                                                ! ACSk
5705: 417a:     GCM.PG.LIST$            = ""                                               ! ACSk
5706: 4191:     READ.GCM.PG.NO$         = ""                                               ! ACSk
5707: 41a6:     DEFAULT.GCM.PG.NO$      = "     "                                          ! ACSk
5708: 41bb: 
5709: 41bb:     !Loop continues until finds a space in the BCF.RECORD$                     ! ACSk
5710: 41bb:     WHILE BCF.REC22.OFFSET.COUNT% < BCF.REC22.REC.LEN%                         ! ACSk
5711: 41c6: 
5712: 41c6:         READ.GCM.PG.NO$ = MID$(BCF.RECORD$,              \                     ! ACSk
5713: 41f2:                             BCF.REC22.OFFSET.COUNT%,     \                     ! ACSk
5714: 41f2:                             BCF.REC22.PROD.GROUP.LEN%)   !                     ! ACSk
5715: 41f2: 
5716: 41f2:         IF READ.GCM.PG.NO$ = DEFAULT.GCM.PG.NO$ THEN BEGIN                     ! ACSk
5717: 4211:             !If a space is found, then set the loop exit condition             ! ACSk
5718: 4211:             BCF.REC22.REC.LEN% = BCF.REC22.OFFSET.COUNT%                       ! ACSk
5719: 4225: 
5720: 4225:         ENDIF ELSE BEGIN  !Space not found - add to list                       ! ACSk
5721: 422d: 
5722: 422d:             GCM.PG.LIST$ = GCM.PG.LIST$     + \                                ! ACSk
5723: 425a:                            READ.GCM.PG.NO$  + \                                ! ACSk
5724: 425a:                             ","               !                                ! ACSk
5725: 425a: 
5726: 425a:            BCF.REC22.OFFSET.COUNT% = BCF.REC22.OFFSET.COUNT%   + \             ! ACSk
5727: 426d:                                      BCF.REC22.PROD.GROUP.LEN%                 ! ACSk
5728: 426d:         ENDIF                                                                  ! ACSk
5729: 4275:     WEND                                                                       ! ACSk
5730: 428d: 
5731: 428d:     CALL DO.MESSAGE("PSB21 - BCF Rec 22 Gift Card Mall Product Groups: " + \   ! ACSk
5732: 42d7:                      "[" + GCM.PG.LIST$ + "]", FALSE)                          ! ACSk
5733: 42d7: 
5734: 42d7:     CLOSE BCF.SESS.NUM%                                             ! 1.15 CSk
5735: 42eb:     EXIT SUB                                                        ! 1.15 CSk
5736: 42f5: 
5737: 42f5: OPEN.BCF.ERROR:                                                     ! 1.15 CSk
5738: 4305: 
5739: 4305:     CALL LOG.EVENT(106)                                             ! 1.15 CSk
5740: 4329: 
5741: 4329: END SUB
5742: 433d: 
5743: 433d: 
5744: 433d: 
5745: 433d: \******************************************************************************
5746: 433d: \***
5747: 433d: \***    GET.SOFTS.DETAILS
5748: 433d: \***
5749: 433d: \******************************************************************************
5750: 433d: SUB GET.SOFTS.DETAILS
5751: 4361: 
5752: 4361:     SOFTS.REC.62$ = ""   ! Default if record not defined
5753: 4378:     SOFTS.REC.NUM% = 62  !MDM BLOCKED FROM SALE: RECALL IS INACTIVE;WITHDRAWN IS INACTIVE
5754: 438f:     RC% = READ.SOFTS
5755: 43aa: 
5756: 43aa:     IF RC% = 0 THEN BEGIN
5757: 43cc:         SOFTS.REC.62$ = SOFTS.RECORD$ ! For use later
5758: 43ea:         CALL DO.MESSAGE("PSB21 - SOFTS Record 62:", FALSE)
5759: 441e:         CALL DO.MESSAGE("PSB21 - [" + SOFTS.REC.62$ + "]", FALSE)
5760: 4466:     ENDIF ELSE BEGIN
5761: 446e:         CALL DO.MESSAGE("PSB21 *** ERROR: Unable to read SOFTS Record 62", FALSE)
5762: 44a2:         CALL LOG.EVENT(106)
5763: 44c6:     ENDIF
5764: 44ce: 
5765: 44ce:     CLOSE SOFTS.SESS.NUM%
5766: 44e2: 
5767: 44e2: END SUB
5768: 44f6: 
5769: 44f6: 
5770: 44f6: 
5771: 44f6: \******************************************************************************
5772: 44f6: \***
5773: 44f6: \***    CREATE.EMPTY.PPFK.KEYED.FILE
5774: 44f6: \***
5775: 44f6: \******************************************************************************
5776: 44f6: SUB CREATE.EMPTY.PPFK.KEYED.FILE
5777: 451a: 
5778: 451a:     RC% = CREATE.PPFK
5779: 4539: 
5780: 4539:     IF RC% <> 0 THEN BEGIN
5781: 4558:         ! Handle error - Could not create PPFK file
5782: 4558:         CALL DO.MESSAGE("PSB21 *** ERROR cannot create PPFK", FALSE)
5783: 458c:         FILE.OPERATION$ = "C"
5784: 45a3:         CALL LOG.EVENT(106)
5785: 45c7:     ENDIF
5786: 45cf: 
5787: 45cf: END SUB
5788: 45e3: 
5789: 45e3: 
5790: 45e3: 
5791: 45e3: \******************************************************************************
5792: 45e3: \***
5793: 45e3: \***    INITIALISATION
5794: 45e3: \***
5795: 45e3: \******************************************************************************
5796: 45e3: SUB INITIALISATION
5797: 4607: 
5798: 4607:     ON ERROR GOTO INIT.SUB.ERR
5799: 461c: 
5800: 461c:     MODULE.NUMBER$ = "0"                                                        !1.6CSk
5801: 4633:     PHASE$         = "000"                                                      !1.6CSk
5802: 464a: 
5803: 464a:     ERROR.COUNT% = 0
5804: 465b: 
5805: 465b:     ! Initialise CONTTIME variables
5806: 465b:     CT.PARAMBLK$       = STRING$(20, CHR$(00H))
5807: 467c:     CT.TIMEDATE.TABLE$ = STRING$(12, CHR$(00H))
5808: 469d: 
5809: 469d:     TRUE = -1
5810: 46ad:     FALSE = 0
5811: 46bd: 
5812: 46bd:     CRLF$ = CHR$(13) + CHR$(10)
5813: 46ec: 
5814: 46ec:     RUN.TIME$ = TIME$
5815: 4704:     RUN.DATE$ = DATE$
5816: 471c: 
5817: 471c:     IUF.BUFF.SIZE%    = 32256
5818: 4733:     LOG.BUFF.SIZE%    = 32256
5819: 474a:     PPFI.BUFF.SIZE%   = 32256
5820: 4761:     PPFO.BUFF.SIZE%   = 32256
5821: 4778:     WEEEUF.BUFF.SIZE% = 32256
5822: 478f: 
5823: 478f:     WEEE.ITEM.LIMIT%  = 16000
5824: 47a0: 
5825: 47a0:     MAX.PRICE.CHANGES% = 100
5826: 47b1:     MAX.BARCODES%      = 200
5827: 47c2: 
5828: 47c2:     IUF.ITEM.BATCH.LIMIT% = 250000 !         Maximum items which can be processed in an IUF batch.
5829: 47d9:                                    \         If value increased PPFK will need to be appropriately increased in size.
5830: 47d9:                                    \         This will also impact the W:\ RAM drive which would also need to increase in size.
5831: 47d9: 
5832: 47d9:     COUNT.RECORDS.IUF% = 0
5833: 47f0:     IUF.EXISTS         = FALSE
5834: 4806: 
5835: 4806:     PSB20.PATH.NAME$ = "C:\ADX_UPGM\PSB20.286"
5836: 481d: 
5837: 481d:     ERROR$ = "0"
5838: 4834: 
5839: 4834:     SKIP.IUF.PROCESSING = FALSE                                                 !1.6CSk
5840: 484a: 
5841: 484a:     ! Initialise STATUS% variable that is used by DO.MESSAGE                    !1.6CSk
5842: 484a:     CALL ADXSERVE (ADXSERVE.RET.CODE%,26,0,MSG$)                                !1.6CSk
5843: 4886:     IF ADXSERVE.RET.CODE% <> 0 THEN BEGIN                                       !1.6CSk
5844: 48a5:         STATUS% = 1 !FOREGROUND                                                 !1.6CSk
5845: 48b8:     ENDIF ELSE BEGIN                                                            !1.6CSk
5846: 48c0:         STATUS% = 2 !BACKGROUND                                                 !1.6CSk
5847: 48d1:     ENDIF                                                                       !1.6CSk
5848: 48d9: 
5849: 48d9:     USE PROCESSING.DATE$
5850: 48f6: 
5851: 48f6:  OVERRIDE.DATE:
5852: 4906:     ! Calculate Run date (and day of week)
5853: 4906:     F13.INPUT.DATE$ = PROCESSING.DATE$
5854: 4924:     RC% = PSDATE(F13.INPUT.DATE$)
5855: 494d: 
5856: 494d:     IF RC% <> 0 THEN BEGIN ! Event 18 already logged by PSBF13                  !1.6CSk
5857: 496c:         CALL DO.MESSAGE("PSB21 *** FATAL ERROR - PSDATE call returned " + \     !1.6CSk
5858: 49b7:                         "non-zero code: " + STR$(RC%), FALSE)                   !1.6CSk
5859: 49b7:         CALL LOG.EVENT(84)                                                      !1.6CSk
5860: 49db:     ENDIF                                                                       !1.6CSk
5861: 49e3: 
5862: 49e3:     CALL DETERMINE.LOG.FILE
5863: 49ef: 
5864: 49ef: !                   >1234567890123456789012345678901234567890123456<  46 character display ! 1.18 RC (237)
5865: 49ef:     CALL DO.MESSAGE("PSB21 PROGRAM START    Core Release 2    vI       04-11-2016", TRUE)  ! IRG
5866: 4a23:     WAIT ; 750 ! Allow message to be read                                                  ! 1.18 RC (237)
5867: 4a3a:     CALL DO.MESSAGE("============================================================", FALSE) ! 1.18 RC (237)
5868: 4a6e: 
5869: 4a6e:     !----------------------------
5870: 4a6e:     ! Set up JOBSOK File at start
5871: 4a6e:     !----------------------------
5872: 4a6e:     CALL JOBSOK.SET
5873: 4a7b:     FILE.OPERATION$ = "O"
5874: 4a92:     CALL SESS.NUM.UTILITY("O", JOBSOK.REPORT.NUM%, JOBSOK.FILE.NAME$)
5875: 4ab8:     JOBSOK.SESS.NUM% = F20.INTEGER.FILE.NO%
5876: 4ace: 
5877: 4ace:     CALL DO.MESSAGE("PSB21 Opening JOBSOK", FALSE)
5878: 4b02:     CURRENT.REPORT.NUM% = JOBSOK.REPORT.NUM%
5879: 4b18:     IF END # JOBSOK.SESS.NUM% THEN OPEN.JOBSOK.ERROR
5880: 4b34:     OPEN JOBSOK.FILE.NAME$ RECL JOBSOK.RECL% AS JOBSOK.SESS.NUM% LOCKED NODEL
5881: 4b61:     GOTO SKIP.JOSBOK
5882: 4b6b: 
5883: 4b6b:  OPEN.JOBSOK.ERROR:
5884: 4b7b:     CALL DO.MESSAGE("PSB21 *** ERROR - JOBSOK does not exist", FALSE)
5885: 4baf:     CALL LOG.EVENT(106)
5886: 4bd3: 
5887: 4bd3:  SKIP.JOSBOK:
5888: 4be3: 
5889: 4be3:     JOBSOK.FLAG$ = " "
5890: 4bfa: 
5891: 4bfa:     ! Get store no.
5892: 4bfa:     CALL ADXSERVE(ADXSERVE.RETURN.CODE%, 4, 0, APPLICATION.STATUS.INFO$)
5893: 4c36: 
5894: 4c36:     IF ADXSERVE.RETURN.CODE% <> 0 THEN BEGIN
5895: 4c55:         CALL LOG.EVENT(23)
5896: 4c79:     ENDIF
5897: 4c81: 
5898: 4c81:     STORE.NUMBER$ = LEFT$(APPLICATION.STATUS.INFO$,4)
5899: 4ca8: 
5900: 4ca8:     CALL DO.MESSAGE("PSB21 IUF Processing for Store: " + STORE.NUMBER$, FALSE)
5901: 4cea:     CALL DO.MESSAGE("PSB21 Initialisation", FALSE)
5902: 4d1e:     CALL DO.MESSAGE("PSB21 Passed PROCESSING.DATE$: " + FORMAT.DATE$(PROCESSING.DATE$), FALSE)
5903: 4d64:     CALL DO.MESSAGE("PSB21                     Day: " + F13.DAY$, FALSE)
5904: 4da6:     CALL DO.MESSAGE("PSB21 Actual Run Date        : " + FORMAT.DATE$(DATE$), FALSE)
5905: 4de6:     CALL DO.MESSAGE("PSB21            Time        : " + FORMAT.TIME$(RUN.TIME$), FALSE)
5906: 4e2c:     CALL DO.MESSAGE("PSB21 PHASE 0", FALSE)
5907: 4e60:     PHASE$ = "0.1"                                                          !1.6CSk
5908: 4e77:     CALL DO.MESSAGE("PSB21 0.1 - Set, open and create files", FALSE)
5909: 4eab: 
5910: 4eab:     CALL SET.AND.ALLOCATE.FILE.SESSION.NUMBERS
5911: 4eb7:     CALL OPEN.FILES
5912: 4ec3:     CALL CREATE.FILES
5913: 4ecf:     CALL GET.BCF.DETAILS
5914: 4edb:     CALL GET.SOFTS.DETAILS
5915: 4ee7: 
5916: 4ee7:     DIM CURR.RPD.NO$(PPFK.PCR.MAX%)
5917: 4f1b:     DIM CURR.DATE.DUE$(PPFK.PCR.MAX%)
5918: 4f4f:     DIM CURR.PRICE$(PPFK.PCR.MAX%)
5919: 4f83:     DIM CURR.INC.DEC.FLAG$(PPFK.PCR.MAX%)
5920: 4fb7:     DIM CURR.STATUS.FLAG$(PPFK.PCR.MAX%)
5921: 4feb:     DIM CURR.MARKDOWN$(PPFK.PCR.MAX%)
5922: 501f: 
5923: 501f:     DIM PREV.RPD.NO$(PPFK.PCR.MAX%)
5924: 5053:     DIM PREV.DATE.DUE$(PPFK.PCR.MAX%)
5925: 5087:     DIM PREV.PRICE$(PPFK.PCR.MAX%)
5926: 50bb:     DIM PREV.INC.DEC.FLAG$(PPFK.PCR.MAX%)
5927: 50ef:     DIM PREV.STATUS.FLAG$(PPFK.PCR.MAX%)
5928: 5123:     DIM PREV.MARKDOWN$(PPFK.PCR.MAX%)
5929: 5157: 
5930: 5157:     DIM SORT.TABLE$(PPFK.PCR.MAX%)                             ! 1.10 RC (113)
5931: 518b: 
5932: 518b:     !----------------------------------
5933: 518b:     ! Check IUF header record is valid
5934: 518b:     !----------------------------------
5935: 518b: 
5936: 518b:     IF VALIDATE.IUF.HEADER.RECORD <> "ACK" THEN BEGIN
5937: 51b4:     ! Log message against which field is invalid and stop application
5938: 51b4:        CALL DO.MESSAGE("PSB21 IUF header - program stopped: " +                    \
5939: 51f0:                        VALIDATE.IUF.HEADER.RECORD,FALSE)
5940: 51f0:       CURRENT.REPORT.NUM% = IUF.REPORT.NUM%
5941: 5206:       IF NOT MATCH("UNABLE TO OPEN",VALIDATE.IUF.HEADER.RECORD,1) THEN BEGIN
5942: 5230:           ERROR$ = "2" ! Header problem
5943: 5247:           JOBSOK.FLAG$ = "X"
5944: 525e:           IUF.EXISTS = TRUE
5945: 5274:           CALL SEND.DEC.MESSAGE
5946: 5281:           CALL PROGRAM.EXIT
5947: 5290:       ENDIF ELSE BEGIN
5948: 5298:           ERROR$ = "1" ! Missing IUF file
5949: 52af:       ENDIF
5950: 52b7:     ENDIF
5951: 52bf: 
5952: 52bf:     ! Create empty PPFK keyed file
5953: 52bf:     CALL CREATE.EMPTY.PPFK.KEYED.FILE
5954: 52cb: 
5955: 52cb: !   Call PSBF18 to read SOPTS and set F18.SOPTS.READ$ to "Y"  ! 1.19 RC
5956: 52cb:     RC% = CALC.BOOTS.CODE.CHECK.DIGIT("123456")               ! 1.19 RC
5957: 52ed: 
5958: 52ed: EXIT SUB
5959: 52f7: 
5960: 52f7: INIT.SUB.ERR:
5961: 5307: 
5962: 5307:     IF ERR = "NP" THEN BEGIN
5963: 532d:          PROCESSING.DATE$ = RUN.DATE$
5964: 534b:          RESUME OVERRIDE.DATE
5965: 5362:         !PRINT "Do NOT run from command mode"
5966: 5362:         !STOP
5967: 5362:     ENDIF
5968: 536a: 
5969: 536a: END SUB
5970: 537e: 
5971: 537e: \******************************************************************************
5972: 537e: \***
5973: 537e: \***  LOAD.WEEEUF.FILE.INTO.TABLE
5974: 537e: \***
5975: 537e: \***  This routine loads the entire WEEEUF file into a table - no need to sort
5976: 537e: \***  the table since the file is in ascending item code order.
5977: 537e: \***
5978: 537e: \******************************************************************************
5979: 537e: 
5980: 537e: SUB LOAD.WEEEUF.FILE.INTO.TABLE
5981: 53a2: 
5982: 53a2:     PHASE$ = "1.0"                                                              !1.6CSk
5983: 53b9:     CALL DO.MESSAGE("PSB21 PHASE 1", TRUE)
5984: 53ed:     CALL DO.MESSAGE("PSB21 1.0 - LOAD.WEEEUF.FILE.INTO.TABLE", TRUE)
5985: 5421: 
5986: 5421:     DIM WEEEUF.TABLE$(WEEE.ITEM.LIMIT%)
5987: 5455: 
5988: 5455:     WEEE.ITEM.COUNT% = 0
5989: 546c:     FILE.OPERATION$  = "O"
5990: 5483: 
5991: 5483:     IF END# WEEEUF.SESS.NUM% THEN NO.WEEEUF.FILE
5992: 549f:     OPEN WEEEUF.FILE.NAME$ AS WEEEUF.SESS.NUM% BUFFSIZE WEEEUF.BUFF.SIZE% NOWRITE NODEL
5993: 54d1: 
5994: 54d1:     RC% = READ.WEEEUF
5995: 54ec: 
5996: 54ec:     WHILE RC% = 0
5997: 54f7:         WEEE.ITEM.COUNT% = WEEE.ITEM.COUNT% + 1
5998: 5510: 
5999: 5510:         IF WEEE.ITEM.COUNT% <= WEEE.ITEM.LIMIT% THEN BEGIN
6000: 552d:             ! 7-digit Boots Item Code followed by 4-digit recycling fee
6001: 552d:             WEEEUF.TABLE$(WEEE.ITEM.COUNT%) = WEEE.ITEM.CODE$ + RIGHT$("0000" + STR$(WEEE.ITEM.PRF.AMT%), 4)
6002: 559c:         ENDIF
6003: 55a4: 
6004: 55a4:         RC% = READ.WEEEUF
6005: 55bf:     WEND
6006: 55e1: 
6007: 55e1:     IF WEEE.ITEM.COUNT% > WEEE.ITEM.LIMIT% THEN BEGIN
6008: 5601:         ! Should never reach this limit but added this check just in case.
6009: 5601:         CALL DO.MESSAGE("PSB21 *** ERROR: WEEE Item Limit exceeded. Item count: " + STR$(WEEE.ITEM.COUNT%), FALSE)
6010: 5648:         CALL DO.MESSAGE("           setting WEEE Item Limit to          : " + STR$(WEEE.ITEM.LIMIT%), FALSE)
6011: 568e:         WEEE.ITEM.COUNT% = WEEE.ITEM.LIMIT%
6012: 56ab:     ENDIF
6013: 56b3: 
6014: 56b3:     CLOSE WEEEUF.SESS.NUM%
6015: 56c7: 
6016: 56c7:  NO.WEEEUF.FILE:
6017: 56d7: 
6018: 56d7:     CALL DO.MESSAGE("PSB21 1.1 - "+ STR$(WEEE.ITEM.COUNT%) + " WEEE Items Loaded", TRUE)
6019: 572d: 
6020: 572d: END SUB
6021: 5741: 
6022: 5741: 
6023: 5741: \******************************************************************************
6024: 5741: \***
6025: 5741: \***    STORE.ITEM.DETAIL
6026: 5741: \***
6027: 5741: \******************************************************************************
6028: 5741: SUB STORE.ITEM.DETAIL
6029: 5765: 
6030: 5765:     !-----------------------------------------------------                    ! ACSk
6031: 5765:     ! If the item's product group is in the list of Gift                      ! ACSk
6032: 5765:     ! Card Mall product groups, then override the settings                    ! ACSk
6033: 5765:     !-----------------------------------------------------                    ! ACSk
6034: 5765:     IF MATCH(IUF.PROD.GRP$, GCM.PG.LIST$, 1) <> 0 THEN BEGIN                  ! ACSk
6035: 578f:         IUF.GIFTCARD$   = "Y"                                                 ! ACSk
6036: 57a6:        !IUF.RETURNABLE$ = "N"  ! Now set directly in UPDATE.IRF               ! BCSk
6037: 57a6:     ENDIF                                                                     ! ACSk
6038: 57ae: 
6039: 57ae:     CURR.AGE.RESTRICTION$              = IUF.AGE.RESTRICTION$
6040: 57cc:     CURR.BC.LETTER$                    = IUF.BC.LETTER$
6041: 57ea:     CURR.BLOCKED.FROM.SALE$            = IUF.BLOCKED.FROM.SALE$
6042: 5808:     CURR.BOOTS.CODE$                   = IUF.BOOTS.CODE$
6043: 5826:     CURR.BOOTS.COM.EXTENDED$           = IUF.BOOTS.COM.EXTENDED$
6044: 5844:     CURR.CONTAINS.ALCOHOL$             = IUF.CONTAINS.ALCOHOL$
6045: 5862:     CURR.CONTAINS.ASPIRIN$             = IUF.CONTAINS.ASPIRIN$
6046: 5880:     CURR.CONTAINS.EPHEDRINE$           = IUF.CONTAINS.EPHEDRINE$
6047: 589e:     CURR.CONTAINS.IBUPROFEN$           = IUF.CONTAINS.IBUPROFEN$
6048: 58bc:     CURR.CONTAINS.NONSOLID.PAINKILLER$ = IUF.CONTAINS.NONSOLID.PAINKILLER$
6049: 58da:     CURR.CONTAINS.PARACETAMOL$         = IUF.CONTAINS.PARACETAMOL$
6050: 58f8:     CURR.CONTAINS.PSEUDOEPHEDRINE$     = IUF.CONTAINS.PSEUDOEPHEDRINE$
6051: 5916:     CURR.CURRENT.PRICE$                = IUF.CURRENT.PRICE$
6052: 5934:     CURR.DATE.SENSITIVE$               = IUF.DATE.SENSITIVE$
6053: 5952:     CURR.DISCOUNTABLE$                 = IUF.DISCOUNTABLE$ ! Reinstated original variable name ! 1.6 RC (21)
6054: 5970:     CURR.EARN.POINTS$                  = IUF.EARN.POINTS$
6055: 598e:     CURR.ENF.PRICE.ENTRY$              = IUF.ENF.PRICE.ENTRY$
6056: 59ac:     CURR.ETHICAL.ACTIVE$               = IUF.ETHICAL.ACTIVE$
6057: 59ca:     CURR.ETHICAL.CLASS$                = IUF.ETHICAL.CLASS$
6058: 59e8:     CURR.ETHICAL.DESCRIPTION$          = IUF.ETHICAL.DESCRIPTION$
6059: 5a06:     CURR.ETHICAL.PACK.SIZE$            = IUF.ETHICAL.PACK.SIZE$
6060: 5a24:     CURR.GIFTCARD$                     = IUF.GIFTCARD$
6061: 5a42:     CURR.GIVEAWAY$                     = IUF.GIVEAWAY$
6062: 5a60:     CURR.GRP.CODE.FLAG$                = IUF.GRP.CODE.FLAG$
6063: 5a7e:     CURR.GRP.NO$                       = IUF.GRP.NO$                    !HRN
6064: 5a9c:     CURR.GUARANTEE.LENGTH$             = IUF.GUARANTEE.LENGTH$
6065: 5aba:     CURR.INSURANCE$                    = IUF.INSURANCE$
6066: 5ad8:     CURR.ITEM.QTY$                     = IUF.ITEM.QTY$
6067: 5af6:     CURR.OWN.BRAND$                    = IUF.OWN.BRAND$
6068: 5b14:     CURR.PRIMARY.SUPPLIER$             = IUF.PRIMARY.SUPPLIER$
6069: 5b32:     CURR.PROD.GRP$                     = IUF.PROD.GRP$
6070: 5b50:     CURR.REDEEMABLE$                   = IUF.REDEEMABLE$
6071: 5b6e:     CURR.RESALEABLE$                   = IUF.RESALEABLE$
6072: 5b8c:     CURR.RESTRICT.SALES.FLAG$          = IUF.RESTRICT.SALES.FLAG$       !HRN
6073: 5baa:     CURR.RETURN.ROUTE$                 = IUF.RETURN.ROUTE$
6074: 5bc8:     CURR.RETURNABLE$                   = IUF.RETURNABLE$
6075: 5be6:     CURR.S.E.DESC$                     = IUF.S.E.DESC$
6076: 5c04:     CURR.SPECIAL.INSTRUCTION$          = IUF.SPECIAL.INSTRUCTION$
6077: 5c22:     CURR.STATUS.1$                     = IUF.STATUS.1$
6078: 5c40:     CURR.STNDRD.DESC$                  = IUF.STNDRD.DESC$
6079: 5c5e:     CURR.STOCK.SYSTEM.FLAG$            = IUF.STOCK.SYSTEM.FLAG$
6080: 5c7c:     CURR.SUPPLY.ROUTE$                 = IUF.SUPPLY.ROUTE$
6081: 5c9a:     CURR.TILL.DESC$                    = IUF.TILL.DESC$
6082: 5cb8:     CURR.UNIT.MEASUREMENT$             = IUF.UNIT.MEASUREMENT$
6083: 5cd6:     CURR.UNIT.NAME$                    = IUF.UNIT.NAME$
6084: 5cf4:     CURR.UNRESTRICTED.GROUP.CODE$      = IUF.UNRESTRICTED.GROUP.CODE$
6085: 5d12: 
6086: 5d12: END SUB
6087: 5d26: 
6088: 5d26: \******************************************************************************
6089: 5d26: \***
6090: 5d26: \***    CHECK.IF.CURR.SORT.NEEDED(M%)
6091: 5d26: \***
6092: 5d26: \******************************************************************************
6093: 5d26: 
6094: 5d26: SUB CHECK.IF.CURR.SORT.NEEDED(M%) ! Entire procedure new for Rv 1.10 RC (113)
6095: 5d4a: 
6096: 5d4a:     INTEGER*2 M%
6097: 5d4a: 
6098: 5d4a: !   No need to sort CURR tables for single price change
6099: 5d4a:     IF M% <= 1 THEN BEGIN
6100: 5d5b:         EXIT SUB
6101: 5d66:     ENDIF
6102: 5d6e: 
6103: 5d6e: !   An items IUF price change records need to be in ascending  ! 1.12 RC (177)
6104: 5d6e: !   date-RPD order (latest last)                               ! 1.12 RC (177)
6105: 5d6e: 
6106: 5d6e: !   When an items current IUF price change record date-RPD is
6107: 5d6e: !   earlier than its previous IUF price change record date-RPD ! 1.12 RC (177)
6108: 5d6e: !   then the items IUF price change record data needs sorting
6109: 5d6e:     IF  CURR.DATE.DUE$(M%)    + CURR.RPD.NO$(M%) \
6110: 5e0a:       < CURR.DATE.DUE$(M% -1) + CURR.RPD.NO$(M% -1) THEN BEGIN ! 1.12 RC (177)
6111: 5e0a:         CURR.SORT.NEEDED = TRUE
6112: 5e20:     ENDIF
6113: 5e28: 
6114: 5e28: END SUB
6115: 5e3c: 
6116: 5e3c: 
6117: 5e3c: \******************************************************************************
6118: 5e3c: \***
6119: 5e3c: \***    STORE.PRICE.CHANGE(N%)
6120: 5e3c: \***
6121: 5e3c: \******************************************************************************
6122: 5e3c: SUB STORE.PRICE.CHANGE(N%)
6123: 5e60: 
6124: 5e60:     INTEGER*2 N%
6125: 5e60: 
6126: 5e60:     ! Add price change to the price change tables
6127: 5e60:     CURR.RPD.NO$(N%)       = PACK$("0" + IUF.RPD.NO$)
6128: 5e9f: !   Convert 8-digit IUF.RPD.DATE$ (ASCII) to 6-digit CURR.DATE.DUE$ (packed)  ! 1.6 RC (90)
6129: 5e9f:     CURR.DATE.DUE$(N%)     = RIGHT$(PACK$(IUF.RPD.DATE$),3)                   ! 1.6 RC (90)
6130: 5ee4:     CURR.PRICE$(N%)        = PACK$(IUF.NEW.PRICE$)
6131: 5f17:     CURR.INC.DEC.FLAG$(N%) = " "
6132: 5f3e:     CURR.STATUS.FLAG$(N%)  = " "
6133: 5f65:     CURR.MARKDOWN$(N%)     = IUF.MARKDOWN$
6134: 5f93: 
6135: 5f93:     IF UNPACK$(CURR.DATE.DUE$(N%)) = PROCESSING.DATE$ THEN BEGIN ! 1.10 RC (113)
6136: 5fdb:         PRICE.CHANGE.TODAY = TRUE                                ! 1.10 RC (113)
6137: 5ff1:     ENDIF                                                        ! 1.10 RC (113)
6138: 5ff9: 
6139: 5ff9:     CALL CHECK.IF.CURR.SORT.NEEDED(N%)                           ! 1.10 RC (113)
6140: 600d: 
6141: 600d: END SUB
6142: 6021: 
6143: 6021: 
6144: 6021: \******************************************************************************
6145: 6021: \***
6146: 6021: \***    STORE.EMERG.PRICE.CHANGE(N%)
6147: 6021: \***
6148: 6021: \******************************************************************************
6149: 6021: 
6150: 6021: SUB STORE.EMERG.PRICE.CHANGE(N%) PUBLIC ! Entire procedure new for Rv 1.10 RC (113)
6151: 6045:                                         ! Based on STORE.PRICE.CHANGE(N%)
6152: 6045:     INTEGER*2 N%
6153: 6045: 
6154: 6045: !   Add emergency price change to CURR (IUF) data tables
6155: 6045:     CURR.RPD.NO$(N%)       = PACK$("099999")
6156: 6071:     CURR.DATE.DUE$(N%)     = PACK$(PROCESSING.DATE$) ! From PSB20             !
6157: 60a4:     CURR.PRICE$(N%)        = PACK$(RIGHT$("00000000" + \
6158: 60f4:                                CURR.CURRENT.PRICE$, 8)) ! From IUF
6159: 60f4:     CURR.INC.DEC.FLAG$(N%) = " " ! PSB23 sets to Increase / Decrease
6160: 611b:     CURR.STATUS.FLAG$(N%)  = " " ! SEL not yet printed
6161: 6142:     CURR.MARKDOWN$(N%)     = "N" ! Markdown flag not used
6162: 6169: 
6163: 6169:     CALL CHECK.IF.CURR.SORT.NEEDED(N%)
6164: 617d: 
6165: 617d: END SUB
6166: 6191: 
6167: 6191: 
6168: 6191: \******************************************************************************
6169: 6191: \***
6170: 6191: \***    STORE.BARCODE
6171: 6191: \***
6172: 6191: \******************************************************************************
6173: 6191: \*** Add barcode to the barcode table but only if it doesn't match the Item Code
6174: 6191: \*** in the "I" Item record (excluding check digit). This is because the first
6175: 6191: \*** IDF barcode is ALWAYS the Boots Item Code (less check digit), so we ignore
6176: 6191: \*** it now instead of later.
6177: 6191: \***
6178: 6191: \******************************************************************************
6179: 6191: SUB STORE.BARCODE
6180: 61b5: 
6181: 61b5:     IF LEFT$(IUF.BAR.CODE$, 12) <> ("000000" + LEFT$(IUF.BOOTS.CODE$, 6)) THEN BEGIN
6182: 6206: 
6183: 6206:         BARCODE.COUNT% = BARCODE.COUNT% + 1
6184: 6215: 
6185: 6215:         BARCODE.TABLE$(BARCODE.COUNT%) = LEFT$(IUF.BAR.CODE$, 12) ! Remove Check Digit
6186: 624d: 
6187: 624d:     ENDIF
6188: 6255: 
6189: 6255: END SUB
6190: 6269: 
6191: 6269: 
6192: 6269: \******************************************************************************
6193: 6269: \***
6194: 6269: \***    DO.IUF.PROGRESS
6195: 6269: \***
6196: 6269: \******************************************************************************
6197: 6269: SUB DO.IUF.PROGRESS
6198: 628d: 
6199: 628d:     INTEGER*2 STEP%
6200: 628d: 
6201: 628d:     IF IUF.RECORD.COUNT% < 21 AND IUF.NEW.FORMAT THEN BEGIN
6202: 62b7:         STEP% = 100 / IUF.RECORD.COUNT%
6203: 62d3:     ENDIF ELSE BEGIN
6204: 62db:         STEP% = 5
6205: 62e9:     ENDIF
6206: 62f1: 
6207: 62f1:     IF IUF.NEW.FORMAT THEN BEGIN
6208: 6306:         PROGRESS.COUNT% = PROGRESS.COUNT% + 1
6209: 631f: 
6210: 631f:         IF PROGRESS.COUNT% >= RECS.PER.5% THEN BEGIN
6211: 6342: 
6212: 6342:             PHASE$ = "3.2"                                                      !1.6CSk
6213: 6359:             PERCENT.VAL% = PERCENT.VAL% + STEP%
6214: 637d:             IF IUF.NEW.FORMAT AND PERCENT.VAL% < 101 THEN BEGIN
6215: 63a9:                 CALL DO.MESSAGE("PSB21 PHASE 3.2 - PROCESS.IUF: " + STR$(PERCENT.VAL%) + "%", TRUE)
6216: 6401:             ENDIF ELSE BEGIN
6217: 6409:                 CALL DO.MESSAGE("PSB21 PHASE 3.2 - PROCESS.IUF: PROCESSING...", FALSE)
6218: 643d:             ENDIF
6219: 6445: 
6220: 6445:             PROGRESS.COUNT% = 0
6221: 645c:         ENDIF
6222: 6464:     ENDIF
6223: 646c: END SUB
6224: 6480: 
6225: 6480: 
6226: 6480: \******************************************************************************
6227: 6480: \***
6228: 6480: \***    UNEXPECTED.RECORD.TYPE
6229: 6480: \***
6230: 6480: \******************************************************************************
6231: 6480: \***
6232: 6480: \***    This subroutine logs an event and writes an entry to the Daily Log
6233: 6480: \***    file if an unrecognised or unexpected record type is found. It then
6234: 6480: \***    skips to the next Item, Trailer, Batch or End-Of-File.
6235: 6480: \***
6236: 6480: \******************************************************************************
6237: 6480: 
6238: 6480: SUB UNEXPECTED.RECORD.TYPE
6239: 64a4: 
6240: 64a4:     INTEGER*1   JUMP.OUT,    \
6241: 64a4:                 SKIPPED
6242: 64a4: 
6243: 64a4:     CALL DO.MESSAGE("PSB21 *** ERROR1: Unexpected IUF Rec Type: [" + \
6244: 64fa:                     IUF.REC.TYPE$ + "] at Rec: " + STR$(COUNT.RECORDS.IUF%), FALSE)
6245: 64fa: 
6246: 64fa: !   When unexpeted record type encountered on legacy IUF        ! 1.15 RC (223)
6247: 64fa: !   end program with JOBSOK.FLAG$ "X"                           ! 1.15 RC (223)
6248: 64fa:     IF NOT IUF.NEW.FORMAT THEN BEGIN ! Legacy IUF               ! 1.15 RC (223)
6249: 650c:        JOBSOK.FLAG$ = "X"                                       ! 1.15 RC (223)
6250: 6523: !      CALL SEND.DEC.MESSAGE ! No DEC message for legacy IUF    ! 1.15 RC (223)
6251: 6523:        CALL CLOSE.IUF                                           ! 1.15 RC (223)
6252: 653d:        CALL PROGRAM.EXIT                                        ! 1.15 RC (223)
6253: 654a:     ENDIF                                                       ! 1.15 RC (223)
6254: 6552: 
6255: 6552:     CALL DO.MESSAGE("PSB21 *** Skipping to next Item(I)/Trailer(T)/Batch(H)/End-Of-File", FALSE)
6256: 6586: 
6257: 6586:     IUF.J103.COUNT% = IUF.J103.COUNT% + 1
6258: 659f: 
6259: 659f:     SKIPPED  = FALSE
6260: 65b1:     JUMP.OUT = FALSE
6261: 65c3: 
6262: 65c3:     ! Get next IUF record
6263: 65c3:     RC% = READ.IUF
6264: 65de: 
6265: 65de:     ! IF we couldn't read the next IUF record
6266: 65de:     IF RC% <> 0 THEN BEGIN
6267: 65fd:         ! Handle error - Unexpected read error
6268: 65fd:         CALL DO.MESSAGE("PSB21 *** ERROR2: End of IUF File Found", FALSE)
6269: 6631:         CALL LOG.EVENT(106)
6270: 6655:     ENDIF
6271: 665d: 
6272: 665d:     COUNT.RECORDS.IUF% = COUNT.RECORDS.IUF% + 1
6273: 6676:     CALL DO.IUF.PROGRESS
6274: 6682: 
6275: 6682:     ! Continue reading until next Item(I), Trailer(T), Batch(H) or End-Of-File.
6276: 6682:     WHILE NOT JUMP.OUT
6277: 668d: 
6278: 668d:         IF IUF.REC.TYPE$ = "I"  OR \
6279: 6707:            IUF.REC.TYPE$ = "H"  OR \
6280: 6707:            IUF.REC.TYPE$ = "T" THEN BEGIN
6281: 6707: 
6282: 6707:             ! Jump out - found next Item/Header/EOF
6283: 6707:             SKIPPED = TRUE
6284: 6719:             JUMP.OUT = TRUE
6285: 672e:         ENDIF ELSE BEGIN
6286: 6736: 
6287: 6736:             RC% = READ.IUF
6288: 6751: 
6289: 6751:             ! IF we couldn't read the next IUF record
6290: 6751:             IF RC% <> 0 THEN BEGIN
6291: 6770:                 ! Handle error - Unexpected read error
6292: 6770:                 CALL DO.MESSAGE("PSB21 *** ERROR3: reading next IUF Record at: " + \
6293: 67b7:                          STR$(COUNT.RECORDS.IUF%), FALSE)
6294: 67b7:                 CALL LOG.EVENT(106)
6295: 67db:                 EXIT SUB
6296: 67e5:             ENDIF
6297: 67ed: 
6298: 67ed:             COUNT.RECORDS.IUF% = COUNT.RECORDS.IUF% + 1
6299: 6806:             CALL DO.IUF.PROGRESS
6300: 6812:         ENDIF
6301: 681a:     WEND
6302: 682c: 
6303: 682c:     PROCESS.ITEM = FALSE
6304: 6842: 
6305: 6842: END SUB
6306: 6856: 
6307: 6856: 
6308: 6856: \*******************************************************************************
6309: 6856: \***
6310: 6856: \*** VALIDATE.IUF.FIELDS
6311: 6856: \***
6312: 6856: \***
6313: 6856: \***   processing date.
6314: 6856: \***
6315: 6856: \*******************************************************************************
6316: 6856: SUB VALIDATE.IUF.FIELDS
6317: 687a: 
6318: 687a:      !Validate item record
6319: 687a:      IF IUF.REC.TYPE$ = "I" THEN BEGIN
6320: 689b: 
6321: 689b:          IF MATCH("!",IUF.BOOTS.CODE$,1) OR LEN(IUF.BOOTS.CODE$) <> 7 THEN BEGIN
6322: 68dc: 
6323: 68dc:              CALL DO.MESSAGE("PSB21 *** ERROR Record " + STR$(COUNT.RECORDS.IUF%)          +  \
6324: 694c:                              " 'I':" + "[" + IUF.BOOTS.CODE$ + "]"                         +  \
6325: 694c:                              ":Item Boots code not valid format",FALSE)
6326: 694c: 
6327: 694c:          ENDIF ELSE IF MATCH("!",IUF.PROD.GRP$,1) OR LEN(IUF.PROD.GRP$) <> 5 THEN BEGIN
6328: 6990: 
6329: 6990:              CALL DO.MESSAGE("PSB21 *** ERROR Record " + STR$(COUNT.RECORDS.IUF%)          +  \
6330: 6a13:                              " (item " + IUF.BOOTS.CODE$ + ")"                             +  \ ! 1.6 RC  Matrix 09
6331: 6a13:                              " 'I':" + "[" + IUF.PROD.GRP$ + "]"                           +  \
6332: 6a13:                              ":Item product group not valid format",FALSE)
6333: 6a13: 
6334: 6a13:          ENDIF ELSE IF MATCH("!",IUF.CURRENT.PRICE$,1) OR IUF.CURRENT.PRICE$ = ""   THEN BEGIN
6335: 6a5d: 
6336: 6a5d:              CALL DO.MESSAGE("PSB21 *** ERROR Record " + STR$(COUNT.RECORDS.IUF%)          +  \
6337: 6ae0:                              " (item " + IUF.BOOTS.CODE$ + ")"                             +  \ ! 1.6 RC  Matrix 17
6338: 6ae0:                              " 'I':" + "[" + IUF.CURRENT.PRICE$ + "]"                      +  \
6339: 6ae0:                              ":Item price not valid format",FALSE)
6340: 6ae0: 
6341: 6ae0:          ENDIF ELSE IF MATCH("#",IUF.BC.LETTER$,1) THEN BEGIN
6342: 6b05: 
6343: 6b05:              CALL DO.MESSAGE("PSB21 *** ERROR Record " + STR$(COUNT.RECORDS.IUF%)          +  \
6344: 6b88:                              " (item " + IUF.BOOTS.CODE$ + ")"                             +  \ ! 1.6 RC  Matrix 19
6345: 6b88:                              " 'I'" + "[" + IUF.BC.LETTER$ + "]"                           +  \
6346: 6b88:                              ":Item business centre letter not valid format",FALSE)
6347: 6b88: 
6348: 6b88:          ENDIF ELSE IF NOT MATCH(IUF.SUPPLY.ROUTE$,"WDB",1) THEN BEGIN
6349: 6bad: 
6350: 6bad:              CALL DO.MESSAGE("PSB21 *** ERROR Record " + STR$(COUNT.RECORDS.IUF%)          +  \
6351: 6c30:                              " (item " + IUF.BOOTS.CODE$ + ")"                             +  \ ! 1.6 RC  Matrix 07
6352: 6c30:                             " 'I' " + "[" + IUF.SUPPLY.ROUTE$ + "]"                        +  \
6353: 6c30:                              ":Item supply route not valid format",FALSE)
6354: 6c30: 
6355: 6c30:          ENDIF ELSE IF NOT MATCH(IUF.OWN.BRAND$,"NY",1) THEN BEGIN
6356: 6c55: 
6357: 6c55:              CALL DO.MESSAGE("PSB21 *** ERROR Record " + STR$(COUNT.RECORDS.IUF%)          +  \
6358: 6cd8:                              " (item " + IUF.BOOTS.CODE$ + ")"                             +  \ ! 1.6 RC  Matrix 15
6359: 6cd8:                              " 'I' " + "[" + IUF.OWN.BRAND$ + "]"                          +  \
6360: 6cd8:                              ":Item own brand flag not valid format",FALSE)
6361: 6cd8: 
6362: 6cd8:          ENDIF ELSE IF NOT MATCH(IUF.ENF.PRICE.ENTRY$,"NY",1) THEN BEGIN
6363: 6cfd: 
6364: 6cfd:              CALL DO.MESSAGE("PSB21 *** ERROR Record " + STR$(COUNT.RECORDS.IUF%)          +  \
6365: 6d80:                              " (item " + IUF.BOOTS.CODE$ + ")"                             +  \ ! 1.6 RC  Matrix 11
6366: 6d80:                              " 'I' " + "[" + IUF.ENF.PRICE.ENTRY$ + "]"                    +  \
6367: 6d80:                              ":Item enforced entry flag not valid format",FALSE)
6368: 6d80: 
6369: 6d80: !        ENDIF ELSE IF NOT MATCH(IUF.GRP.CODE.FLAG$,"NY",1) THEN BEGIN                          ! 1.6 RC
6370: 6d80: 
6371: 6d80: !            Should never arise ...                                                             ! 1.6 RC
6372: 6d80: !            READ.IUF sets IUF.GRP.CODE.FLAG" to "N" if it is not "Y"      ! 1.6 RC  Matrix 03  ! 1.6 RC
6373: 6d80: 
6374: 6d80: !            CALL DO.MESSAGE("PSB21 *** ERROR Record " + STR$(COUNT.RECORDS.IUF%)          +  \ ! 1.6 RC  Matrix 03
6375: 6d80: !                            " (item " + IUF.BOOTS.CODE$ + ")"                             +  \ ! 1.6 RC
6376: 6d80: !                            " 'I' " + "[" + IUF.GRP.CODE.FLAG$ + "]"                      +  \ ! 1.6 RC
6377: 6d80: !                            ":Item group code flag not valid format",FALSE)                    ! 1.6 RC
6378: 6d80: 
6379: 6d80:          ENDIF ELSE IF NOT MATCH(IUF.DATE.SENSITIVE$,"NY",1) THEN BEGIN
6380: 6da5: 
6381: 6da5:              CALL DO.MESSAGE("PSB21 *** ERROR Record " + STR$(COUNT.RECORDS.IUF%)          +  \
6382: 6e28:                              " (item " + IUF.BOOTS.CODE$ + ")"                             +  \ ! 1.6 RC  Matrix 23
6383: 6e28:                              " 'I' " + "[" + IUF.DATE.SENSITIVE$ + "]"                     +  \
6384: 6e28:                              ":Item date sensitive flag not valid format",FALSE)
6385: 6e28: 
6386: 6e28:          ENDIF ELSE IF NOT MATCH(IUF.CONTAINS.ALCOHOL$,"NY",1) THEN BEGIN
6387: 6e4d: 
6388: 6e4d:              CALL DO.MESSAGE("PSB21 *** ERROR Record " + STR$(COUNT.RECORDS.IUF%)          +  \
6389: 6ed0:                              " (item " + IUF.BOOTS.CODE$ + ")"                             +  \ ! 1.6 RC  Matrix 33
6390: 6ed0:                              " 'I' " + "[" + IUF.CONTAINS.ALCOHOL$ + "]"                   +  \
6391: 6ed0:                              ":Item alcohol flag not valid format",FALSE)
6392: 6ed0: 
6393: 6ed0:          ENDIF ELSE IF NOT MATCH(IUF.CONTAINS.PARACETAMOL$,"NY",1) THEN BEGIN
6394: 6ef5: 
6395: 6ef5:              CALL DO.MESSAGE("PSB21 *** ERROR Record " + STR$(COUNT.RECORDS.IUF%)          +  \
6396: 6f78:                              " (item " + IUF.BOOTS.CODE$ + ")"                             +  \ ! 1.6 RC  Matrix 34
6397: 6f78:                              " 'I' " + "[" + IUF.CONTAINS.PARACETAMOL$ + "]"               +  \
6398: 6f78:                              ":Item paracetamol flag not valid format",FALSE)
6399: 6f78: 
6400: 6f78:          ENDIF ELSE IF NOT MATCH(IUF.CONTAINS.ASPIRIN$,"NY",1) THEN BEGIN
6401: 6f9d: 
6402: 6f9d:              CALL DO.MESSAGE("PSB21 *** ERROR Record " + STR$(COUNT.RECORDS.IUF%)          +  \
6403: 7020:                              " (item " + IUF.BOOTS.CODE$ + ")"                             +  \ ! 1.6 RC  Matrix 35
6404: 7020:                              " 'I' " + "[" + IUF.CONTAINS.ASPIRIN$ + "]"                   +  \
6405: 7020:                              ":Item aspirins flag not valid format",FALSE)
6406: 7020: 
6407: 7020:          ENDIF ELSE IF NOT MATCH(IUF.CONTAINS.IBUPROFEN$,"NY",1) THEN BEGIN
6408: 7045: 
6409: 7045:              CALL DO.MESSAGE("PSB21 *** ERROR Record " + STR$(COUNT.RECORDS.IUF%)          +  \
6410: 70c8:                              " (item " + IUF.BOOTS.CODE$ + ")"                             +  \ ! 1.6 RC  Matrix 36
6411: 70c8:                              " 'I' " + "[" + IUF.CONTAINS.IBUPROFEN$ + "]"                 +  \
6412: 70c8:                              ":Item ibuprofen flag not valid format",FALSE)
6413: 70c8: 
6414: 70c8:          ENDIF ELSE IF NOT MATCH(IUF.CONTAINS.EPHEDRINE$,"NY",1) THEN BEGIN
6415: 70ed: 
6416: 70ed:              CALL DO.MESSAGE("PSB21 *** ERROR Record " + STR$(COUNT.RECORDS.IUF%)          +  \
6417: 7170:                              " (item " + IUF.BOOTS.CODE$ + ")"                             +  \ ! 1.6 RC  Matrix 37
6418: 7170:                              " 'I' " + "[" + IUF.CONTAINS.EPHEDRINE$ + "]"                 +  \
6419: 7170:                              ":Item ephedrine flag not valid format",FALSE)
6420: 7170: 
6421: 7170:          ENDIF ELSE IF NOT MATCH(IUF.CONTAINS.NONSOLID.PAINKILLER$,"NY",1) THEN BEGIN
6422: 7195: 
6423: 7195:              CALL DO.MESSAGE("PSB21 *** ERROR Record " + STR$(COUNT.RECORDS.IUF%)          +  \
6424: 7218:                              " (item " + IUF.BOOTS.CODE$ + ")"                             +  \ ! 1.6 RC  Matrix 39
6425: 7218:                              " 'I' " + "[" + IUF.CONTAINS.NONSOLID.PAINKILLER$ + "]"       +  \
6426: 7218:                              ":item non solid painkiller flag not valid format",FALSE)
6427: 7218: 
6428: 7218: !        Rejection of invalid IUF.UNRESTRICTED.GROUP.CODE$ (ie, not "N" or "Y") was             ! 1.6 RC (71b)
6429: 7218: !        previously removed and then re-instated (and corrected to remove the MATCH)            ! 1.6 RC (71b)
6430: 7218: 
6431: 7218: !        ENDIF ELSE IF NOT MATCH(IUF.UNRESTRICTED.GROUP.CODE$,"NY",1) THEN BEGIN                ! 1.6 RC (71)
6432: 7218: 
6433: 7218: !            Should never arise ...                                                             ! 1.6 RC (71)
6434: 7218: !            READ.IUF sets IUF.UNRESTRICTED.GROUP.CODE$ to "N" if it is not "Y"                 ! 1.6 RC (71)
6435: 7218: 
6436: 7218: !            CALL DO.MESSAGE("PSB21 *** ERROR Record " + STR$(COUNT.RECORDS.IUF%)          +  \ ! 1.6 RC (71)
6437: 7218: !                            " (item " + IUF.BOOTS.CODE$ + ")"                             +  \ ! 1.6 RC  Matrix 40
6438: 7218: !                            " 'I' " + "[" + IUF.UNRESTRICTED.GROUP.CODE$ + "]"            +  \ ! 1.6 RC (71)
6439: 7218: !                            ":Item unrestricted group flag not valid format",FALSE)
6440: 7218: 
6441: 7218:          ENDIF ELSE IF (    IUF.UNRESTRICTED.GROUP.CODE$ <> "N" \                               ! 1.6 RC (71b)
6442: 726d:                         AND IUF.UNRESTRICTED.GROUP.CODE$ <> "Y") THEN BEGIN                     ! 1.6 RC (71b)
6443: 726d: 
6444: 726d:              CALL DO.MESSAGE("PSB21 *** ERROR Record " + STR$(COUNT.RECORDS.IUF%)          +  \ ! 1.6 RC (71b)
6445: 72f0:                              " (item " + IUF.BOOTS.CODE$ + ")"                             +  \ ! 1.6 RC (71b) Matrix 40
6446: 72f0:                              " 'I' " + "[" + IUF.UNRESTRICTED.GROUP.CODE$ + "]"            +  \ ! 1.6 RC (71b)
6447: 72f0:                              ":Item unrestricted group flag not valid format",FALSE)
6448: 72f0: 
6449: 72f0:          ENDIF ELSE IF NOT MATCH(IUF.BOOTS.COM.EXTENDED$,"NY",1) THEN BEGIN
6450: 7315: 
6451: 7315:              CALL DO.MESSAGE("PSB21 *** ERROR Record " + STR$(COUNT.RECORDS.IUF%)          +  \
6452: 7398:                              " (item " + IUF.BOOTS.CODE$ + ")"                             +  \ ! 1.6 RC  Matrix 43
6453: 7398:                              " 'I' " + "[" + IUF.BOOTS.COM.EXTENDED$ + "]"                 +  \
6454: 7398:                              ":Item Boots.com extended flag not valid format",FALSE)
6455: 7398: 
6456: 7398:          ENDIF ELSE IF NOT MATCH(IUF.INSURANCE$,"NY",1) THEN BEGIN
6457: 73bd: 
6458: 73bd:              CALL DO.MESSAGE("PSB21 *** ERROR Record " + STR$(COUNT.RECORDS.IUF%)          +  \
6459: 743f:                              " (item " + IUF.BOOTS.CODE$ + ")"                             +  \ ! 1.6 RC  Matrix 44
6460: 743f:                              " 'I' " + "[" + IUF.INSURANCE$ + "]"                          +  \
6461: 743f:                              ":Item insurance flag not valid format",FALSE)
6462: 743f: 
6463: 743f:          ENDIF ELSE BEGIN
6464: 7447:              EXIT SUB
6465: 7452:          ENDIF
6466: 745a: 
6467: 745a:          IUF.J103.COUNT% = IUF.J103.COUNT% + 1
6468: 7473:          !Skip to next item
6469: 7473:          PROCESS.ITEM = FALSE
6470: 748c: 
6471: 748c:      !Validate Price record
6472: 748c:      ENDIF ELSE IF IUF.REC.TYPE$ = "P" THEN BEGIN
6473: 74ad: 
6474: 74ad:          IF PROCESS.ITEM THEN BEGIN
6475: 74c2: 
6476: 74c2:              IF MATCH("!",IUF.BOOTS.CODE$,1) OR LEN(IUF.BOOTS.CODE$) <> 7 THEN BEGIN
6477: 7503: 
6478: 7503:                  CALL DO.MESSAGE("PSB21 *** ERROR Record " + STR$(COUNT.RECORDS.IUF%)          +  \
6479: 7573:                                  " 'P' " + "[" + IUF.BOOTS.CODE$ + "]"                         +  \
6480: 7573:                                  ":Item Boots code not valid format",FALSE)
6481: 7573: 
6482: 7573:              ENDIF ELSE IF IUF.BOOTS.CODE$ <> CURR.BOOTS.CODE$ THEN BEGIN
6483: 7598: 
6484: 7598:                  CALL DO.MESSAGE("PSB21 *** ERROR Record " + STR$(COUNT.RECORDS.IUF%)          +  \
6485: 7608:                                  " 'P' " + "[" + IUF.BOOTS.CODE$ + "]"                         +  \
6486: 7608:                                  ":Item Boots code out of sequence",FALSE)
6487: 7608: 
6488: 7608:              ENDIF ELSE IF MATCH("!",IUF.RPD.DATE$,1) OR LEN(IUF.RPD.DATE$) <> 8  THEN BEGIN      !  1.1MG 1.3CSk
6489: 764c:                                                                                                   !
6490: 764c:                  CALL DO.MESSAGE("PSB21 *** ERROR Record " + STR$(COUNT.RECORDS.IUF%)          +  \
6491: 76cf:                                  " (item " + IUF.BOOTS.CODE$ + ")"                             +  \ ! 1.6 RC  Matrix 03
6492: 76cf:                                  " 'P' " + "[" + IUF.RPD.DATE$ + "]"                           +  \
6493: 76cf:                                  ":Item RPD date not valid format",FALSE)
6494: 76cf: 
6495: 76cf:              ENDIF ELSE IF LEN(IUF.RPD.NO$) <> 5 OR (VAL(IUF.RPD.NO$) < 10001 OR \
6496: 7776:                            VAL(IUF.RPD.NO$) > 99996)  THEN BEGIN
6497: 7776: 
6498: 7776:                  CALL DO.MESSAGE("PSB21 *** ERROR Record " + STR$(COUNT.RECORDS.IUF%)          +  \
6499: 77f9:                                  " (item " + IUF.BOOTS.CODE$ + ")"                             +  \ ! 1.6 RC  Matrix 04
6500: 77f9:                                  " 'P' " + "[" + IUF.RPD.NO$ + "]"                             +  \
6501: 77f9:                                  ":Item RPD number not valid format",FALSE)
6502: 77f9: 
6503: 77f9:              ENDIF ELSE IF MATCH("!",IUF.NEW.PRICE$,1) THEN BEGIN
6504: 781e: 
6505: 781e:                  CALL DO.MESSAGE("PSB21 *** ERROR Record " + STR$(COUNT.RECORDS.IUF%)          +  \
6506: 78a0:                                  " (item " + IUF.BOOTS.CODE$ + ")"                             +  \ ! 1.6 RC  Matrix 05
6507: 78a0:                                  " 'P' " + "[" + IUF.NEW.PRICE$ + "]"                          +  \
6508: 78a0:                                  ":Item new price not valid format",FALSE)
6509: 78a0: 
6510: 78a0:              ENDIF ELSE BEGIN
6511: 78a8: 
6512: 78a8: !               Keep IUF.RPD.DATE$ as 8-digits until loaded into CURR.DATE.DUE$ table        ! 1.6 RC (90)
6513: 78a8: ! 1.6 RC (90)   ! Reduced to 6 digits for processing                                         ! 1.6 RC (90)
6514: 78a8: ! 1.6 RC (90)   IUF.RPD.DATE$ = RIGHT$(IUF.RPD.DATE$,6)                                      ! 1.6 RC (90)
6515: 78a8:                 EXIT SUB
6516: 78b3:              ENDIF
6517: 78bb: 
6518: 78bb:              IUF.J103.COUNT% = IUF.J103.COUNT% + 1
6519: 78d4:              !Skip to next item
6520: 78d4:              PROCESS.ITEM = FALSE                                                                 !  1.1MG
6521: 78ea: 
6522: 78ea:          ENDIF
6523: 78f5: 
6524: 78f5:      !Validate Barcode record
6525: 78f5:      ENDIF ELSE IF IUF.REC.TYPE$ = "B" THEN BEGIN
6526: 7916: 
6527: 7916:          IF PROCESS.ITEM THEN BEGIN
6528: 792b: 
6529: 792b:              IF MATCH("!",IUF.BOOTS.CODE$,1) OR LEN(IUF.BOOTS.CODE$) <> 7 THEN BEGIN
6530: 796c: 
6531: 796c:                 CALL DO.MESSAGE("PSB21 *** ERROR Record " + STR$(COUNT.RECORDS.IUF%)          +  \
6532: 79dc:                                 " 'B' " + "[" + IUF.BOOTS.CODE$ + "]"                         +  \
6533: 79dc:                                 ":Item Boots code not valid format",FALSE)
6534: 79dc: 
6535: 79dc:              ENDIF ELSE IF IUF.BOOTS.CODE$ <> CURR.BOOTS.CODE$ THEN BEGIN
6536: 7a01:                 CALL DO.MESSAGE("PSB21 *** ERROR Record " + STR$(COUNT.RECORDS.IUF%)          +  \
6537: 7a71:                                 " 'B' " + "[" + IUF.BOOTS.CODE$ + "]"                         +  \
6538: 7a71:                                 ":Item Boots code out of sequence",FALSE)
6539: 7a71: 
6540: 7a71:              ENDIF ELSE IF MATCH("!",IUF.BAR.CODE$,1)  THEN BEGIN                             ! removed length validation
6541: 7a93: 
6542: 7a93:                 CALL DO.MESSAGE("PSB21 *** ERROR Record " + STR$(COUNT.RECORDS.IUF%)          +  \
6543: 7b02:                                 " 'B' " + "[" + IUF.BAR.CODE$ + "]"                           +  \
6544: 7b02:                                 ":Item bar code not valid format",FALSE)
6545: 7b02: 
6546: 7b02:              ENDIF ELSE BEGIN
6547: 7b0a:                  EXIT SUB
6548: 7b15:              ENDIF
6549: 7b1d: 
6550: 7b1d:              IUF.J103.COUNT% = IUF.J103.COUNT% + 1
6551: 7b36:              !Skip to next item
6552: 7b36:              PROCESS.ITEM = FALSE
6553: 7b4c: 
6554: 7b4c:          ENDIF
6555: 7b57: 
6556: 7b57:      !Validate header record fields
6557: 7b57:      ENDIF ELSE IF IUF.REC.TYPE$ = "H" THEN BEGIN
6558: 7b78: 
6559: 7b78:          !Validate store number format
6560: 7b78:          IF MATCH("!",IUF.STORE.NUM$,1) OR LEN(IUF.STORE.NUM$) <> 4 THEN BEGIN
6561: 7bb9: 
6562: 7bb9:               CALL DO.MESSAGE("PSB21 *** ERROR: Store number not valid format - Exit program",FALSE)
6563: 7bf0: 
6564: 7bf0:               !Validate Initial load flag
6565: 7bf0:          ENDIF ELSE IF NOT MATCH(IUF.INITIAL.LOAD$,"NY",1) THEN BEGIN
6566: 7c12: 
6567: 7c12:               CALL DO.MESSAGE("PSB21 *** ERROR: Initial load flag not valid format - Exit program",FALSE)
6568: 7c49: 
6569: 7c49:               !Validate Date TIme Stamp format
6570: 7c49:          ENDIF ELSE IF MATCH("!",IUF.TIME.STAMP$,1) OR LEN(IUF.TIME.STAMP$) <> 17 THEN BEGIN
6571: 7c8a: 
6572: 7c8a:               CALL DO.MESSAGE("PSB21 *** ERROR: Date Time Stamp not valid format - Exit program",FALSE)
6573: 7cc0: 
6574: 7cc0:          ENDIF ELSE BEGIN
6575: 7cc8:              EXIT SUB
6576: 7cd2:          ENDIF
6577: 7cda: 
6578: 7cda:          ERROR$ = "4"                             ! Header problem
6579: 7cf1: 
6580: 7cf1:          JOBSOK.FLAG$ = "X"                                           ! 1.4 RC
6581: 7d08:          CALL PROGRAM.EXIT
6582: 7d15: 
6583: 7d15:      ENDIF
6584: 7d1d: 
6585: 7d1d: END SUB
6586: 7d31: 
6587: 7d31: 
6588: 7d31: SUB REPORT.SKIPPED.ITEM.CODE
6589: 7d55: 
6590: 7d55:     CALL DO.MESSAGE("PSB21 *** ERROR: Skipped item was " + \
6591: 7de6:                                         MID$(IUF.BOOTS.CODE$,1,2) + "-" + \
6592: 7de6:                                         MID$(IUF.BOOTS.CODE$,3,2) + "-" + \
6593: 7de6:                                         MID$(IUF.BOOTS.CODE$,5,3) \
6594: 7de6:                                                                   ,FALSE)
6595: 7de6: 
6596: 7de6: END SUB
6597: 7dfa: 
6598: 7dfa: \*******************************************************************************
6599: 7dfa: \***
6600: 7dfa: \*** PROCESS.ITEM.CHECK
6601: 7dfa: \***
6602: 7dfa: \*******************************************************************************
6603: 7dfa: 
6604: 7dfa: SUB PROCESS.ITEM.CHECK
6605: 7e1e: 
6606: 7e1e:     INTEGER*4 GET.BATCH.NUMBER%
6607: 7e1e:     INTEGER*4 CHECK.ELEMENT%
6608: 7e1e: 
6609: 7e1e:     CHECK.ELEMENT% = VAL(LEFT$(IUF.BOOTS.CODE$,6))
6610: 7e4f: 
6611: 7e4f:     CALL I4.LIST.GET(CHECK.ELEMENT%, GET.BATCH.NUMBER%)
6612: 7e67: 
6613: 7e67:     IF IUF.BATCH.COUNT% < GET.BATCH.NUMBER% THEN BEGIN
6614: 7e81: 
6615: 7e81:        PROCESS.ITEM = FALSE
6616: 7e97: 
6617: 7e97:     ENDIF
6618: 7e9f: 
6619: 7e9f: END SUB
6620: 7eb3: 
6621: 7eb3: \*******************************************************************************
6622: 7eb3: \***
6623: 7eb3: \*** MAXIMUM.ITEM.LOG.MESSAGE
6624: 7eb3: \***
6625: 7eb3: \***
6626: 7eb3: \*******************************************************************************
6627: 7eb3: 
6628: 7eb3: SUB MAXIMUM.ITEM.LOG.MESSAGE
6629: 7ed7: 
6630: 7ed7:      CALL DO.MESSAGE("PSB21 Max items in batch reached"           +           \
6631: 7f41:                      " (> " + STR$(IUF.ITEM.BATCH.LIMIT%)         +           \
6632: 7f41:                      " items) from record " + STR$(COUNT.RECORDS.IUF%),FALSE)
6633: 7f41: 
6634: 7f41: END SUB
6635: 7f55: 
6636: 7f55: 
6637: 7f55: \******************************************************************************
6638: 7f55: \***
6639: 7f55: \***    UPDATE.SUPPARAM
6640: 7f55: \***
6641: 7f55: \******************************************************************************
6642: 7f55: \***
6643: 7f55: \***    This subroutine updates the SUPPARAM file.
6644: 7f55: \***    If batch was an initial load then open SUPPARAM and update the initial
6645: 7f55: \***    load date to today in order to configure label suppression.
6646: 7f55: \***
6647: 7f55: \******************************************************************************
6648: 7f55: SUB UPDATE.SUPPARAM
6649: 7f79: 
6650: 7f79:     FILE.OPERATION$ = "O"
6651: 7f90:     IF END #SUPPARAM.SESS.NUM% THEN SUPPARAM.FILE.ERROR
6652: 7fac:     OPEN SUPPARAM.FILE.NAME$ DIRECT RECL SUPPARAM.RECL% AS SUPPARAM.SESS.NUM%
6653: 7fd8: 
6654: 7fd8:     RC% = READ.SUPPARAM
6655: 7ff3: 
6656: 7ff3:     IF RC% <> 0 THEN BEGIN
6657: 8012:         CALL DO.MESSAGE("PSB21 *** ERROR Unable to read SUPPARAM file", FALSE)
6658: 8046:         CALL LOG.EVENT(106)
6659: 806d:     ENDIF ELSE BEGIN
6660: 8075:         SUPPARAM.INITIAL.LOAD.DATE$ = PROCESSING.DATE$
6661: 8093:         RC% = WRITE.SUPPARAM
6662: 80ae:         IF RC% <> 0 THEN BEGIN
6663: 80cd:             CALL DO.MESSAGE("PSB21 *** ERROR Unable to write to SUPPARAM file", FALSE)
6664: 8101:             CALL LOG.EVENT(106)
6665: 8125:         ENDIF
6666: 812d:     ENDIF
6667: 8135: 
6668: 8135:     CLOSE SUPPARAM.SESS.NUM%
6669: 8149:     EXIT SUB
6670: 8153: 
6671: 8153:  SUPPARAM.FILE.ERROR:
6672: 8163:     CALL DO.MESSAGE("PSB21 *** ERROR Unable to open SUPPARAM file", FALSE)
6673: 8197:     CALL LOG.EVENT(106)
6674: 81bb: 
6675: 81bb: END SUB
6676: 81cf: 
6677: 81cf: 
6678: 81cf: \******************************************************************************
6679: 81cf: \***
6680: 81cf: \***    SORT.CURR.TABLES
6681: 81cf: \***    Sorts CURR data tables into descending date-RPD order
6682: 81cf: \***
6683: 81cf: \******************************************************************************
6684: 81cf: 
6685: 81cf: SUB SORT.CURR.TABLES PUBLIC ! Entire procedure new for Rv 1.10 (113)
6686: 81f3: 
6687: 81f3:     INTEGER*2 SUB%
6688: 81f3:     INTEGER*2 SORT.LIMIT.SUB%
6689: 81f3: 
6690: 81f3: !   An items IUF price change records need to have ascending   ! 1.12 RC (177)
6691: 81f3: !   date-RPD order to facilitate merging into PPFI data.
6692: 81f3: !   Legacy M/F systems may currently transmit data in the      ! 1.12 RC (177)
6693: 81f3: !   opposite order however this is not fully certain.          ! 1.12 RC (177)
6694: 81f3: !   Core R2 (ECC format) IUF price changes will have no
6695: 81f3: !   sequencing.
6696: 81f3: 
6697: 81f3: !   Combine all CURR data tables into SORT.TABLE$ ready for sorting
6698: 81f3: 
6699: 81f3:     SUB% = 1
6700: 8201: 
6701: 8201:     WHILE SUB% <= CURR.PCR.COUNT%
6702: 820c:         SORT.TABLE$(SUB% -1) = \
6703: 82c7:           CURR.DATE.DUE$(SUB%)     + \ ! Major sort field - YYMMDD
6704: 82c7:           CURR.RPD.NO$(SUB%)       + \ ! Minor sort field - 6 digit RPD number
6705: 82c7:           CURR.PRICE$(SUB%)        + \
6706: 82c7:           CURR.INC.DEC.FLAG$(SUB%) + \
6707: 82c7:           CURR.STATUS.FLAG$(SUB%)  + \
6708: 82c7:           CURR.MARKDOWN$(SUB%)
6709: 82c7:         SUB% = SUB% + 1
6710: 82d3:     WEND
6711: 82eb: 
6712: 82eb:     SORT.LIMIT.SUB% = CURR.PCR.COUNT% - 1 ! Minus one because table
6713: 82fe:                                           ! entry zero used by CSORT
6714: 82fe: 
6715: 82fe: !   Sort SORT.TABLE by (ascending) date-RPD
6716: 82fe:     CALL CSORT (VARPTR(SORT.TABLE$(0)), SORT.LIMIT.SUB%)
6717: 832a: 
6718: 832a: !   Re-populate CURR tables from SORT.TABLE$ retaining new sort order       ! 1.12 RC (177)
6719: 832a: 
6720: 832a:     SUB% = 1
6721: 8338: 
6722: 8338:     WHILE SUB% <= CURR.PCR.COUNT%
6723: 8343:         CURR.DATE.DUE$(SUB%)     = MID$(SORT.TABLE$(SUB% - 1),  1, 3) ! 3 UPD   ! 1.12 RC (177)
6724: 8387:         CURR.RPD.NO$(SUB%)       = MID$(SORT.TABLE$(SUB% - 1),  4, 3) ! 3 UPD   ! 1.12 RC (177)
6725: 83cb:         CURR.PRICE$(SUB%)        = MID$(SORT.TABLE$(SUB% - 1),  7, 4) ! 4 UPD   ! 1.12 RC (177)
6726: 840f:         CURR.INC.DEC.FLAG$(SUB%) = MID$(SORT.TABLE$(SUB% - 1), 11, 1) ! 1 ASC   ! 1.12 RC (177)
6727: 8453:         CURR.STATUS.FLAG$(SUB%)  = MID$(SORT.TABLE$(SUB% - 1), 12, 1) ! 1 ASC   ! 1.12 RC (177)
6728: 8497:         CURR.MARKDOWN$(SUB%)     = MID$(SORT.TABLE$(SUB% - 1), 13, 1) ! 1 ASC   ! 1.12 RC (177)
6729: 84db:         SUB% = SUB% + 1
6730: 84e7:     WEND
6731: 84ff: 
6732: 84ff: !   Reset flag ready for use with next IUF item
6733: 84ff:     CURR.SORT.NEEDED = FALSE
6734: 8515: 
6735: 8515: END SUB
6736: 8529: 
6737: 8529: 
6738: 8529: \******************************************************************************
6739: 8529: \***
6740: 8529: \***    IUF.END.BATCH.PROCESSES                                    ! 1.11 RC (169)
6741: 8529: \***
6742: 8529: \******************************************************************************
6743: 8529: 
6744: 8529: SUB IUF.END.BATCH.PROCESSES PUBLIC                                 ! 1.11 RC (169)
6745: 854d: 
6746: 854d:     ! Builds a new PPFI file containing existing and new records   ! 1.11 RC (169)
6747: 854d:     CALL CREATE.NEW.PPFI                                           ! 1.11 RC (169)
6748: 855a: 
6749: 855a: !   Update of BCF positioned after trailer count confirmed okay    ! 1.17 RC (230)
6750: 855a: 
6751: 855a:     ! Check Trailer count                                          ! 1.3CSk
6752: 855a:     IF VAL(IUF.REC.COUNT$) <> COUNT.RECORDS.IUF% THEN BEGIN        ! 1.3CSk
6753: 8596:         CURRENT.REPORT.NUM% = IUF.REPORT.NUM%                      ! 1.3CSk
6754: 85ac:         COUNT.EXPECTED% = VAL(IUF.REC.COUNT$)                      ! 1.3CSk
6755: 85d3:         COUNT.ACTUAL% = COUNT.RECORDS.IUF%                         ! 1.3CSk
6756: 85ec:         CALL LOG.EVENT(92) ! Logs message to DEC                   ! 1.3CSk
6757: 8610:     ENDIF                                                          ! 1.17 RC (230)
6758: 8618: 
6759: 8618: !   Update BCF for batch processed                                 ! 1.17 RC (230)
6760: 8618:     CALL UPDATE.BCF                                                ! 1.17 RC (230)
6761: 8625: !   Send DEC message for batch processed.                          ! 1.17 RC (230)
6762: 8625:     CALL SEND.DEC.MESSAGE                                          ! 1.17 RC (230)
6763: 8632: 
6764: 8632: END SUB                                                            ! 1.11 RC (169)
6765: 8646: 
6766: 8646: 
6767: 8646: \******************************************************************************
6768: 8646: \***
6769: 8646: \***    PROCESS.IUF
6770: 8646: \***
6771: 8646: \******************************************************************************
6772: 8646: SUB PROCESS.IUF
6773: 866a: 
6774: 866a:     INTEGER*1   END.OF.IUF.BATCH
6775: 866a:     INTEGER*1   END.OF.IUF.ITEM
6776: 866a:     INTEGER*1   WRITE.LOG.MESSAGE
6777: 866a:     INTEGER*1   RC%
6778: 866a:     INTEGER*4   BATCH.IUF.ITEM.SKIP%
6779: 866a: 
6780: 866a:     PHASE$ = "3.0"                                                              !1.6CSk
6781: 8681:     CALL DO.MESSAGE("PSB21 PHASE 3", TRUE)
6782: 86b5: 
6783: 86b5: 
6784: 86b5:     IF SKIP.IUF.PROCESSING THEN BEGIN                                           !1.6CSk
6785: 86c7:         ! Once the system has switched over to NEW format IUF processing        !1.6CSk
6786: 86c7:         ! (signified by BCF Record 20 having a value), then OLD format          !1.6CSk
6787: 86c7:         ! IUF files will be skipped unless someone manually modifies the        !1.6CSk
6788: 86c7:         ! BCF Record 20 to spaces as part of the backout process.               !1.6CSk
6789: 86c7:                                                                                 !1.6CSk
6790: 86c7:         CALL DO.MESSAGE("PSB21 *** ERROR: old format IUF will NOT be " + \      !1.6CSk
6791: 8702:                         "processed", FALSE)                                     !1.6CSk
6792: 8702:                                                                                 !1.6CSk
6793: 8702:         EXIT SUB                                                                !1.6CSk
6794: 870d:                                                                                 !1.6CSk
6795: 870d:     ENDIF                                                                       !1.6CSk
6796: 8715: 
6797: 8715: 
6798: 8715:     ! Display progress in 10% increments
6799: 8715:     RECS.PER.5% = 0
6800: 872c:     !RECS.PER.5% = SIZE(IUF.FILE.NAME$) / 5 ! Rough estimate for no. of records
6801: 872c:     RECS.PER.5% = IUF.RECORD.COUNT% * 0.05
6802: 8769:     PROGRESS.COUNT% = 0
6803: 8780:     PERCENT.VAL%    = 0
6804: 8797:     IUF.BATCH.ITEM.TOTAL% = 0
6805: 87ae:     IUF.ITEM.SKIP% = 0
6806: 87c5:     IUF.BATCH.COUNT% = 0
6807: 87d6: 
6808: 87d6:     ! Open the IUF
6809: 87d6:     RC% = OPEN.IUF
6810: 87e5: 
6811: 87e5:     ! IF we couldn't open the IUF then there's no point continuing with processing, but still process pending price file.
6812: 87e5:     IF RC% <> 0 THEN BEGIN
6813: 87f7:         ! Handle error - Unexpected open error
6814: 87f7:         IF NOT IUF.OPEN.ERROR.REPORTED THEN BEGIN                 ! 1.8 RC (8)
6815: 8809:             CALL DO.MESSAGE("PSB21 *** ERROR4: opening IUF", FALSE)
6816: 883d:             IUF.OPEN.ERROR.REPORTED = TRUE                        ! 1.8 RC (8)
6817: 8853:         ENDIF                                                     ! 1.8 RC (8)
6818: 885b:         CURRENT.REPORT.NUM% = IUF.REPORT.NUM%
6819: 8871:         CALL LOG.EVENT(106)
6820: 8895:         CALL CREATE.NEW.PPFI
6821: 88a2:        EXIT SUB
6822: 88ad:     ENDIF
6823: 88b5: 
6824: 88b5:     END.OF.IUF.FILE = FALSE
6825: 88cb: 
6826: 88cb:     ! Get the very first IUF record
6827: 88cb:     RC% = READ.IUF
6828: 88db: 
6829: 88db:     ! IF we couldn't read the first IUF record
6830: 88db:     IF RC% <> 0 THEN BEGIN
6831: 88ed:         ! Handle error - Unexpected read error
6832: 88ed:         CALL DO.MESSAGE("PSB21 *** ERROR5: reading next IUF Record at: " + \
6833: 8934:                  STR$(COUNT.RECORDS.IUF%), FALSE)
6834: 8934:         CALL CLOSE.IUF                                           ! 1.6 RC (87)
6835: 894e:         CALL LOG.EVENT(106)
6836: 8972:         EXIT SUB
6837: 897d:     ENDIF
6838: 8985: 
6839: 8985:     ! CALL DO.IUF.PROGRESS
6840: 8985: 
6841: 8985:     ! WHILE end of file has not been reached
6842: 8985:     WHILE NOT END.OF.IUF.FILE
6843: 8990: 
6844: 8990:         CALL DO.MESSAGE("PSB21 3.0 - Start of IUF Batch found", TRUE)
6845: 89c4: 
6846: 89c4:         IUF.BATCH.COUNT% = IUF.BATCH.COUNT% + 1
6847: 89d3: 
6848: 89d3:         IF IUF.NEW.FORMAT THEN BEGIN
6849: 89e5:             CALL DO.MESSAGE("PSB21 BATCH = " + IUF.TIME.STAMP$, FALSE)
6850: 8a29:         ENDIF ELSE BEGIN
6851: 8a31:             CALL DO.MESSAGE("PSB21 BATCH = " + IUF.SERIAL.NO$, FALSE)
6852: 8a73:         ENDIF
6853: 8a7b: 
6854: 8a7b:         ! IF we have an IUF header record
6855: 8a7b:         IF IUF.REC.TYPE$ = "H" THEN BEGIN
6856: 8a9c: 
6857: 8a9c:             !Validate fields on the item record.
6858: 8a9c:             IF IUF.NEW.FORMAT THEN BEGIN
6859: 8aae:                 CALL VALIDATE.IUF.FIELDS
6860: 8aba:             ENDIF
6861: 8ac2: 
6862: 8ac2:             IF IUF.STORE.NUM$ <> STORE.NUMBER$ THEN BEGIN
6863: 8ae7:                 CALL DO.MESSAGE("PSB21 *** ERROR: Wrong Store No. " + IUF.STORE.NUM$, FALSE)
6864: 8b29:                 CALL LOG.EVENT(15)  ! abort whole batch of suite
6865: 8b4d:             ENDIF
6866: 8b55: 
6867: 8b55:             COUNT.RECORDS.IUF% = 1  ! Reset Batch Count
6868: 8b6c:             ! IF we've already processed this batch
6869: 8b6c:             IF OLD.BATCH.FOUND THEN BEGIN
6870: 8b7f: 
6871: 8b7f:                 ! WHILE end of batch has not been reached
6872: 8b7f:                 WHILE NOT (IUF.REC.TYPE$ = "T")
6873: 8b8a: 
6874: 8b8a:                     ! Read next IUF record
6875: 8b8a:                     RC% = READ.IUF
6876: 8b9a: 
6877: 8b9a:                     ! IF we've successfully read the next IUF record
6878: 8b9a:                     IF RC% = 0 THEN BEGIN
6879: 8ba9:                         ! Skip this record
6880: 8ba9:                         COUNT.RECORDS.IUF% = COUNT.RECORDS.IUF% + 1
6881: 8bc2:                         CALL DO.IUF.PROGRESS
6882: 8bd0:                     ENDIF ELSE BEGIN
6883: 8bd8:                         ! Handle error - Unexpected read error
6884: 8bd8:                         CALL DO.MESSAGE("PSB21 *** ERROR6: reading next IUF Record at: " + \
6885: 8c1f:                                  STR$(COUNT.RECORDS.IUF%), FALSE)
6886: 8c1f:                         CALL LOG.EVENT(106)
6887: 8c43:                     ENDIF
6888: 8c4b: 
6889: 8c4b:                 WEND
6890: 8c6c: 
6891: 8c6c:                 END.OF.IUF.BATCH = TRUE
6892: 8c81: 
6893: 8c81:             ENDIF ELSE BEGIN
6894: 8c89: 
6895: 8c89:                 END.OF.IUF.BATCH = FALSE
6896: 8c9b: 
6897: 8c9b:                 ! Read the next IUF record
6898: 8c9b:                 RC% = READ.IUF
6899: 8cab: 
6900: 8cab:                 ! IF we've successfully read the next IUF record
6901: 8cab:                 IF RC% = 0 THEN BEGIN
6902: 8cbd: 
6903: 8cbd:                     COUNT.RECORDS.IUF% = COUNT.RECORDS.IUF% + 1
6904: 8cd6:                     CALL DO.IUF.PROGRESS
6905: 8ce2:                     ! IF we have an IUF trailer record
6906: 8ce2:                     IF IUF.REC.TYPE$ = "T" THEN BEGIN
6907: 8d00: 
6908: 8d00:                         ! We must have an empty batch
6909: 8d00:                         END.OF.IUF.BATCH = TRUE
6910: 8d15: 
6911: 8d15:                     ENDIF ELSE IF IUF.REC.TYPE$ = "H" THEN BEGIN
6912: 8d33:                         ! Handle error - Double header?????????
6913: 8d33:                         CALL DO.MESSAGE("PSB21 *** ERROR7: reading IUF Record at: " + \
6914: 8d7a:                                  STR$(COUNT.RECORDS.IUF%), FALSE)
6915: 8d7a:                         CALL LOG.EVENT(106)
6916: 8d9e:                     ENDIF
6917: 8da8: 
6918: 8da8:                 ENDIF ELSE BEGIN
6919: 8db0:                     ! Handle error - Unexpected read error
6920: 8db0:                     !CALL DO.MESSAGE("PSB21 *** ERROR8: reading IUF Record at: " + \
6921: 8db0:                     !         STR$(COUNT.RECORDS.IUF%), FALSE)
6922: 8db0:                     !CALL LOG.EVENT(106)
6923: 8db0:                     CALL DO.MESSAGE("PSB21 *** ERROR: Missing Trailer", FALSE)
6924: 8de4:                     CALL LOG.EVENT(92)
6925: 8e08:                 ENDIF
6926: 8e10:             ENDIF
6927: 8e18:         ENDIF
6928: 8e20: 
6929: 8e20:         ! WHILE end of batch has not been reached
6930: 8e20:         WHILE NOT END.OF.IUF.BATCH
6931: 8e2b: 
6932: 8e2b:             END.OF.IUF.ITEM = FALSE
6933: 8e3d: 
6934: 8e3d:             ! Store the item code we're currently processing
6935: 8e3d:             CURR.BOOTS.CODE$ = IUF.BOOTS.CODE$
6936: 8e5b: 
6937: 8e5b:             ! WHILE we're processing records for the same item
6938: 8e5b:             WHILE NOT END.OF.IUF.ITEM
6939: 8e66: 
6940: 8e66: 
6941: 8e66:                 ! IF we have an IUF item detail record
6942: 8e66:                 IF IUF.REC.TYPE$ = "I" THEN BEGIN
6943: 8e87: 
6944: 8e87:                     PROCESS.ITEM = TRUE
6945: 8e9d:                     !Validate fields on the item record.
6946: 8e9d:                     IF IUF.NEW.FORMAT THEN BEGIN
6947: 8eaf:                         CALL VALIDATE.IUF.FIELDS
6948: 8ebb:                     ENDIF
6949: 8ec3:                     !If pre-processing done, check if item in this batch should be processed
6950: 8ec3:                     IF ITEM.PRE.PROCESSING.CHECK AND PROCESS.ITEM THEN BEGIN
6951: 8edb:                        CALL PROCESS.ITEM.CHECK
6952: 8ee7:                     ENDIF
6953: 8eef: 
6954: 8eef:                     ! Store the item details for later use
6955: 8eef:                     IF PROCESS.ITEM THEN CALL STORE.ITEM.DETAIL
6956: 8f05: 
6957: 8f05:                         IUF.BATCH.ITEM.TOTAL% =  IUF.BATCH.ITEM.TOTAL% + 1
6958: 8f1e: 
6959: 8f1e:                         IF IUF.BATCH.ITEM.TOTAL% > IUF.ITEM.BATCH.LIMIT% THEN BEGIN
6960: 8f41: 
6961: 8f41:                             !Only write out message once
6962: 8f41:                             IF NOT WRITE.LOG.MESSAGE THEN BEGIN
6963: 8f50:                                 CALL MAXIMUM.ITEM.LOG.MESSAGE
6964: 8f5c:                                 WRITE.LOG.MESSAGE = TRUE
6965: 8f6e:                             ENDIF
6966: 8f76:                             PROCESS.ITEM = FALSE
6967: 8f8c: 
6968: 8f8c:                             IUF.ITEM.SKIP%       = IUF.ITEM.SKIP% + 1
6969: 8fa5:                             BATCH.IUF.ITEM.SKIP% = BATCH.IUF.ITEM.SKIP% + 1
6970: 8fbe: 
6971: 8fbe:                         ENDIF
6972: 8fc6: 
6973: 8fc6:                     ! Read the next IUF record
6974: 8fc6:                     RC% = READ.IUF
6975: 8fd6: 
6976: 8fd6:                     ! IF we've successfully read the next IUF record
6977: 8fd6:                     IF RC% = 0 THEN BEGIN
6978: 8fe8: 
6979: 8fe8:                         COUNT.RECORDS.IUF% = COUNT.RECORDS.IUF% + 1
6980: 9001:                         CALL DO.IUF.PROGRESS
6981: 900d:                         CURR.PCR.COUNT% = 0
6982: 901e: 
6983: 901e:                         ! WHILE we still have price change records to process
6984: 901e:                         WHILE IUF.REC.TYPE$ = "P"
6985: 9029: 
6986: 9029:                             !Validate fields on the item record.
6987: 9029:                             IF IUF.NEW.FORMAT THEN BEGIN
6988: 903b:                                 CALL VALIDATE.IUF.FIELDS
6989: 9047:                             ENDIF
6990: 904f: 
6991: 904f: !                           Put RPD price change into CURR data tables  ! 1.10 RC (113)
6992: 904f: !                           Do not save an emergency 99999 RPD in this  ! 1.10 RC (113)
6993: 904f: !                           way as these are generated by PSB21 itself  ! 1.10 RC (113)
6994: 904f:                             IF IUF.RPD.NO$ <> "99999" THEN BEGIN  ! 1.9 RC (109)
6995: 906d: 
6996: 906d:                                 CURR.PCR.COUNT% = CURR.PCR.COUNT% + 1
6997: 907c: 
6998: 907c:                                 ! Store the price change for later use
6999: 907c:                                 CALL STORE.PRICE.CHANGE(CURR.PCR.COUNT%)
7000: 9091: 
7001: 9091:                             ENDIF                                 ! 1.9 RC (109)
7002: 9099: 
7003: 9099:                             ! Read the next IUF record
7004: 9099:                             RC% = READ.IUF
7005: 90a9: 
7006: 90a9:                             ! IF we've successfully read the next IUF record
7007: 90a9:                             IF RC% = 0 THEN BEGIN
7008: 90bb: 
7009: 90bb:                                 COUNT.RECORDS.IUF% = COUNT.RECORDS.IUF% + 1
7010: 90d4:                                 CALL DO.IUF.PROGRESS
7011: 90e0:                                 ! IF next record is NOT price change, barcode, item detail or trailer
7012: 90e0:                                 IF NOT (IUF.REC.TYPE$ = "P" OR  \
7013: 9182:                                         IUF.REC.TYPE$ = "B" OR  \
7014: 9182:                                         IUF.REC.TYPE$ = "I" OR  \
7015: 9182:                                         IUF.REC.TYPE$ = "T") THEN BEGIN
7016: 9182:                                     ! Handle error - Unexpected record type
7017: 9182:                                     CALL UNEXPECTED.RECORD.TYPE
7018: 918e:                                 ENDIF
7019: 9198: 
7020: 9198:                             ENDIF ELSE BEGIN
7021: 91a0:                                 ! Handle error - Unexpected read error
7022: 91a0:                                 CALL DO.MESSAGE("PSB21 *** ERROR9: reading IUF Record at: " + \
7023: 91e7:                                          STR$(COUNT.RECORDS.IUF%), FALSE)
7024: 91e7:                                 CALL LOG.EVENT(106)
7025: 920b:                             ENDIF
7026: 9213: 
7027: 9213:                         WEND
7028: 9234: 
7029: 9234:                         ! Initialise barcode index
7030: 9234:                         BARCODE.COUNT% = 0
7031: 9245:                         DIM BARCODE.TABLE$(MAX.BARCODES%)
7032: 9279: 
7033: 9279:                         ! WHILE we still have barcode records to process
7034: 9279:                         WHILE IUF.REC.TYPE$ = "B"
7035: 9284: 
7036: 9284:                             !Validate fields on the item record.
7037: 9284:                             IF IUF.NEW.FORMAT THEN BEGIN
7038: 9296:                                 CALL VALIDATE.IUF.FIELDS
7039: 92a2:                             ENDIF
7040: 92aa: 
7041: 92aa:                             ! Store the barcode for later use
7042: 92aa:                             CALL STORE.BARCODE
7043: 92b6: 
7044: 92b6:                             ! Read the next IUF record
7045: 92b6:                             RC% = READ.IUF
7046: 92c6: 
7047: 92c6:                             ! IF we've successfully read the next IUF record
7048: 92c6:                             IF RC% = 0 THEN BEGIN
7049: 92d8: 
7050: 92d8:                                 COUNT.RECORDS.IUF% = COUNT.RECORDS.IUF% + 1
7051: 92f1: 
7052: 92f1:                                 CALL DO.IUF.PROGRESS
7053: 92fd:                                 ! IF next record is NOT barcode, item detail or trailer
7054: 92fd:                                 IF NOT (IUF.REC.TYPE$ = "B" OR  \
7055: 9377:                                         IUF.REC.TYPE$ = "I" OR  \
7056: 9377:                                         IUF.REC.TYPE$ = "T") THEN BEGIN
7057: 9377:                                     ! Handle error - Unexpected record type
7058: 9377:                                     CALL UNEXPECTED.RECORD.TYPE
7059: 9383:                                 ENDIF
7060: 938d: 
7061: 938d:                             ENDIF ELSE BEGIN
7062: 9395:                                 CALL DO.MESSAGE("PSB21 *** ERROR: Missing Trailer", FALSE)
7063: 93c9:                                 CALL LOG.EVENT(92)
7064: 93ed:                             ENDIF
7065: 93f5: 
7066: 93f5:                         WEND
7067: 9418: 
7068: 9418:                     ENDIF ELSE BEGIN
7069: 9420:                         CALL DO.MESSAGE("PSB21 *** ERROR: Missing Trailer", FALSE)
7070: 9454:                         CALL LOG.EVENT(92)
7071: 9478:                     ENDIF
7072: 9482: 
7073: 9482:                 ENDIF ELSE BEGIN
7074: 948a:                     ! Handle error - Unexpected record type
7075: 948a:                     CALL UNEXPECTED.RECORD.TYPE
7076: 9496:                 ENDIF
7077: 949e: 
7078: 949e:                 ! IF IUF record is for a different item (or a header or trailer)
7079: 949e:                 IF CURR.BOOTS.CODE$ <> IUF.BOOTS.CODE$ OR   \
7080: 9522:                    IUF.REC.TYPE$ = "H" OR                   \
7081: 9522:                    IUF.REC.TYPE$ = "T" THEN BEGIN
7082: 9522: 
7083: 9522:                     ! At this point, we know we have every record for an item,
7084: 9522:                     ! so we can now go and do some stuff with it but only if we haven't
7085: 9522:                     ! detected a problem with any of the item's associated records.
7086: 9522:                     IF PROCESS.ITEM THEN BEGIN
7087: 9537: !                       At this point all the items IUF price  ! 1.10 RC (113)
7088: 9537: !                       changes are loaded into CURR table     ! 1.10 RC (113)
7089: 9537:                         CALL PROCESS.IUF.ITEM
7090: 9544: 
7091: 9544:                         !Item is configured as "Quantity Restricted"    !HRN
7092: 9544:                         IF CURR.RESTRICT.SALES.FLAG$ = "Y" THEN BEGIN   !HRN
7093: 9565: 
7094: 9565:                             IRFITGRP.ITEM.CODE$ = \                     !HRN
7095: 9591:                                         PACK$(LEFT$(CURR.BOOTS.CODE$,6))!HRN
7096: 9591: 
7097: 9591:                             IRFITGRP.GROUP.NO%  = VAL(CURR.GRP.NO$)     !HRN
7098: 95b2: 
7099: 95b2:                             !Write not successful                       !HRN
7100: 95b2:                             IF WRITE.IRFITGRP THEN BEGIN                !HRN
7101: 95c3:                                 CALL LOG.EVENT(106)                     !HRN
7102: 95e7:                             ENDIF                                       !HRN
7103: 95f2: 
7104: 95f2:                         ENDIF ELSE BEGIN !Not a Quantity Restricted Item!HRN
7105: 95fa: 
7106: 95fa:                             IRFITGRP.ITEM.CODE$ = \                     !HRN
7107: 9626:                                         PACK$(LEFT$(CURR.BOOTS.CODE$,6))!HRN
7108: 9626: 
7109: 9626:                             !Delete the Item record if found            !HRN
7110: 9626: 							
7111: 9626: 							print "value is " ;IRFITGRP.OPEN
7112: 9645:                             IF NOT READ.IRFITGRP THEN BEGIN             !HRN
7113: 9656:                                 DELREC IRFITGRP.SESS.NUM%;             \!HRN
7114: 9677:                                        IRFITGRP.ITEM.CODE$              !HRN
7115: 9677:                             ENDIF ELSE BEGIN                            !HRN
7116: 967f:                                 !Nothing to do                          !HRN
7117: 967f:                             ENDIF
7118: 9687:                         ENDIF                                           !HRN
7119: 968f: 
7120: 968f:                     ENDIF
7121: 9697: 
7122: 9697:                     END.OF.IUF.ITEM = TRUE
7123: 96a9:                 ENDIF
7124: 96b1: 
7125: 96b1:             WEND
7126: 96c3: 
7127: 96c3:             ! IF we have an IUF trailer record
7128: 96c3:             IF IUF.REC.TYPE$ = "T" THEN BEGIN
7129: 96e4:                 ! No more items left to process in this batch
7130: 96e4:                 END.OF.IUF.BATCH = TRUE
7131: 96f6:                 IUF.BATCH.ITEM.TOTAL% = 0
7132: 970d:                 WRITE.LOG.MESSAGE = FALSE
7133: 971f:                 PHASE$ = "3.3"                                                 !1.6CSk
7134: 9736:                 CALL DO.MESSAGE("PSB21 3.3 - End of IUF batch found", TRUE)
7135: 976a:                 IF BATCH.IUF.ITEM.SKIP% > 0 THEN BEGIN
7136: 9783:                     CALL DO.MESSAGE("PSB21 " + STR$(BATCH.IUF.ITEM.SKIP%) +    \
7137: 97d6:                                     " items skipped from batch", FALSE)
7138: 97d6:                     BATCH.IUF.ITEM.SKIP% = 0
7139: 97eb:                 ENDIF
7140: 97f3: 
7141: 97f3:                 CALL IUF.END.BATCH.PROCESSES                            ! 1.11 RC (169)
7142: 97ff: !                    Calls CREATE.NEW.PPFI to build new PPFI from PPFK  ! 1.11 RC (169)
7143: 97ff: !                    Calls UPDATE.BCF for batch processed               ! 1.11 RC (169)
7144: 97ff: !                    Checks IUF trailer count                           ! 1.11 RC (169)
7145: 97ff: !                    Send DEC message for batch processed.              ! 1.11 RC (169)
7146: 97ff: 
7147: 97ff:             ENDIF
7148: 9807: 
7149: 9807:         WEND
7150: 9819: 
7151: 9819:         ! IF we have an IUF trailer record
7152: 9819:         IF IUF.REC.TYPE$ = "T" THEN BEGIN
7153: 983a: 
7154: 983a:             IF IUF.NEW.FORMAT THEN BEGIN                                ! 1.11 RC (169)
7155: 984c:                 IF BCF.IUF.DATETIMESTAMP$ <> IUF.TIME.STAMP$ THEN BEGIN ! 1.11 RC (169)
7156: 9871:                     CALL IUF.END.BATCH.PROCESSES                        ! 1.11 RC (169)
7157: 987d:                 ENDIF                                                   ! 1.11 RC (169)
7158: 9887:             ENDIF ELSE BEGIN                                            ! 1.11 RC (169)
7159: 988f:                 IF BCF.IUF.SERIAL.NO$ <> IUF.SERIAL.NO$ THEN BEGIN      ! 1.11 RC (169)
7160: 98b4:                     CALL IUF.END.BATCH.PROCESSES                        ! 1.11 RC (169)
7161: 98c0:                 ENDIF                                                   ! 1.11 RC (169)
7162: 98c8:             ENDIF                                                       ! 1.11 RC (169)
7163: 98d0: 
7164: 98d0:             IF IUF.INITIAL.LOAD$ = "Y" THEN BEGIN
7165: 98ee:                 ! Label Suppression
7166: 98ee:                 CALL UPDATE.SUPPARAM
7167: 98fa:             ENDIF
7168: 9902: 
7169: 9902:             ! Read next IUF record
7170: 9902:             RC% = READ.IUF
7171: 9912: 
7172: 9912:             IF RC% = 0 THEN BEGIN
7173: 9921: 
7174: 9921:                 CALL DO.IUF.PROGRESS
7175: 992f:                 ! Should be a header for the next batch - we'll check later
7176: 992f:             ENDIF ELSE BEGIN
7177: 9937:                 END.OF.IUF.FILE = TRUE
7178: 994d:                 PHASE$ = "3.4"                                                 !1.6CSk
7179: 9964:                 CALL DO.MESSAGE("PSB21 3.4 - End of IUF file found", TRUE)
7180: 9998:             ENDIF
7181: 99a2: 
7182: 99a2:         ENDIF ELSE BEGIN
7183: 99aa:             ! Handle error - Unexpected record type
7184: 99aa:             CALL UNEXPECTED.RECORD.TYPE
7185: 99b6:         ENDIF
7186: 99be: 
7187: 99be:     WEND
7188: 99d3: 
7189: 99d3:     ! Close IUF
7190: 99d3:     CALL CLOSE.IUF                                               ! 1.6 RC (87)
7191: 99ed: 
7192: 99ed:     !Close IRFITGRP File                                                !HRN
7193: 99ed:     IF IRFITGRP.OPEN THEN BEGIN                                         !HRN
7194: 99ff: 	
7195: 99ff: 	
7196: 99ff:         CLOSE IRFITGRP.SESS.NUM%                                        !HRN
7197: 9a13:         IRFITGRP.OPEN = FALSE                                           !HRN
7198: 9a29:     ENDIF                                                               !HRN
7199: 9a31: 
7200: 9a31: END SUB
7201: 9a45: 
7202: 9a45: 
7203: 9a45: \*******************************************************************************
7204: 9a45: \***
7205: 9a45: \*** DELETE.PPFK.KEYED.FILE
7206: 9a45: \***
7207: 9a45: \***
7208: 9a45: \*******************************************************************************
7209: 9a45: 
7210: 9a45: SUB DELETE.PPFK.KEYED.FILE PUBLIC                              ! 1.13 RC (190)
7211: 9a69: 
7212: 9a69:     PHASE$ = "005"                                                              !1.6CSk
7213: 9a80:     CALL DO.MESSAGE("PSB21 PHASE 5", TRUE)
7214: 9ab4:     CALL DO.MESSAGE("PSB21 5.0 - Deleting PPFK File", TRUE)
7215: 9ae8: 
7216: 9ae8:     RC% = DESTROY.PPFK
7217: 9b07: 
7218: 9b07:     IF RC% <> 0 THEN BEGIN
7219: 9b26:         ! Handle error - Could not delete PPFK file
7220: 9b26:         CALL DO.MESSAGE("PSB21 *** ERROR cannot delete PPFK", FALSE)
7221: 9b5a:         CALL LOG.EVENT(106)
7222: 9b7e:     ENDIF
7223: 9b86: 
7224: 9b86: END SUB
7225: 9b9a: 
7226: 9b9a: \*******************************************************************************
7227: 9b9a: \***
7228: 9b9a: \*** IUF.PRE.PROCESSING
7229: 9b9a: \***
7230: 9b9a: \***
7231: 9b9a: \*******************************************************************************
7232: 9b9a: 
7233: 9b9a: SUB IUF.PRE.PROCESSING
7234: 9bbe: 
7235: 9bbe:     INTEGER*1 END.PRE.PROCESSING
7236: 9bbe:     INTEGER*2 NUMBER.OF.BATCHES%
7237: 9bbe:     INTEGER*4 UNIQUE.BATCH.NUMBER%
7238: 9bbe:     INTEGER*4 PREVIOUS.BATCH.NUMBER%
7239: 9bbe:     INTEGER*4 IUF.BOOTS.CODE%
7240: 9bbe: 
7241: 9bbe:     PHASE$ = "0.2"                                                              !1.6CSk
7242: 9bd5:     CALL DO.MESSAGE("PSB21 0.2 - Check if Pre-Processing of the IUF required ", FALSE)
7243: 9c09: 
7244: 9c09:     IF IUF.NEW.FORMAT THEN BEGIN
7245: 9c1e: 
7246: 9c1e:         CALL DO.MESSAGE("PSB21 - New IUF format. Start IUF Pre-Processing ", FALSE)
7247: 9c52: 
7248: 9c52:         !Read IUF records until end. If only one batch found end pre-processing
7249: 9c52: 
7250: 9c52:         ! Open the IUF
7251: 9c52:         RC% = OPEN.IUF
7252: 9c70: 
7253: 9c70:         ! IF we couldn't open the IUF then there's no point continuing
7254: 9c70:         IF RC% <> 0 THEN BEGIN
7255: 9c8f:             ! Handle error - Unexpected open error
7256: 9c8f:             IF NOT IUF.OPEN.ERROR.REPORTED THEN BEGIN             ! 1.8 RC (8)
7257: 9ca1:                 CALL DO.MESSAGE("PSB21 *** ERROR10: IUF PRE-PROCESSING. Unable to open IUF", FALSE) !1.3CSk
7258: 9cd5:                 IUF.OPEN.ERROR.REPORTED = TRUE                    ! 1.8 RC (8)
7259: 9ceb:             ENDIF                                                 ! 1.8 RC (8)
7260: 9cf3:             EXIT SUB
7261: 9cfe:         ENDIF
7262: 9d06: 
7263: 9d06:         ! Get the very first IUF record
7264: 9d06:         RC% = READ.IUF
7265: 9d21: 
7266: 9d21:         ! IF we couldn't read the first IUF record
7267: 9d21:         IF RC% <> 0 THEN BEGIN
7268: 9d43:             ! Handle error - Unexpected read error
7269: 9d43:             CALL DO.MESSAGE("PSB21 *** ERROR11: IUF PRE-PROCESSING. Reading next IUF Record at: " + \     !1.3CSk
7270: 9d8a:                      STR$(COUNT.RECORDS.IUF%), FALSE)
7271: 9d8a:             CALL CLOSE.IUF                                       ! 1.6 RC (87)
7272: 9da4:             CALL LOG.EVENT(106)
7273: 9dc8:             EXIT SUB
7274: 9dd3:         ENDIF
7275: 9ddb: 
7276: 9ddb:         !Create a million element Integer*4 array for IUF pre-processing                                  !1.6CSk
7277: 9ddb:         CALL I4.LIST.DIM(1000000)
7278: 9e01:         END.PRE.PROCESSING        = FALSE
7279: 9e13:         ITEM.PRE.PROCESSING.CHECK = FALSE
7280: 9e29:         UNIQUE.BATCH.NUMBER%      = 0
7281: 9e3e:         PREVIOUS.BATCH.NUMBER%    = 0
7282: 9e53:         NUMBER.OF.BATCHES%        = 0
7283: 9e61:         IUF.RECORD.COUNT%         = 0
7284: 9e78: 
7285: 9e78:         WHILE NOT END.PRE.PROCESSING
7286: 9e83: 
7287: 9e83:              IF IUF.REC.TYPE$ = "H" THEN BEGIN
7288: 9ea1: 
7289: 9ea1:                   NUMBER.OF.BATCHES%   = NUMBER.OF.BATCHES% + 1
7290: 9ead:                   UNIQUE.BATCH.NUMBER% = NUMBER.OF.BATCHES%
7291: 9ec4:                   IUF.RECORD.COUNT%    = IUF.RECORD.COUNT% + 1
7292: 9ee0: 
7293: 9ee0:              ENDIF ELSE IF IUF.REC.TYPE$ = "I" THEN BEGIN
7294: 9f01: 
7295: 9f01:                !Read and store items for each IUF batch in the pre-processing array.
7296: 9f01:                WHILE NOT (IUF.REC.TYPE$ = "T") AND NOT END.PRE.PROCESSING
7297: 9f0c: 
7298: 9f0c:                    IF RC% <> 0 THEN BEGIN
7299: 9f2b:                       ! end of file found
7300: 9f2b:                       END.PRE.PROCESSING = TRUE
7301: 9f40:                    ENDIF ELSE BEGIN
7302: 9f48:                        IF IUF.REC.TYPE$ = "I" THEN BEGIN
7303: 9f69:                            !Validate field does not contain non numeric values and length 7
7304: 9f69:                            IF NOT MATCH("!",IUF.BOOTS.CODE$,1) THEN BEGIN
7305: 9f8b:                                IF LEN(IUF.BOOTS.CODE$) = 7 THEN BEGIN
7306: 9fa9:                                    IUF.BOOTS.CODE% = VAL(LEFT$(IUF.BOOTS.CODE$,6))
7307: 9fda:                                    CALL I4.LIST.SET(IUF.BOOTS.CODE%, UNIQUE.BATCH.NUMBER%)
7308: 9ff2:                                ENDIF
7309: 9ffa:                            ENDIF
7310: a002:                        ENDIF
7311: a00a: 
7312: a00a:                        RC% = READ.IUF
7313: a025: 
7314: a025:                        IUF.RECORD.COUNT%    = IUF.RECORD.COUNT% + 1
7315: a03e: 
7316: a03e:                    ENDIF
7317: a046: 
7318: a046:                WEND
7319: a07b: 
7320: a07b:                IUF.RECORD.COUNT% = IUF.RECORD.COUNT% + 1
7321: a094: 
7322: a094:              ENDIF
7323: a09c: 
7324: a09c:              RC% = READ.IUF
7325: a0b7: 
7326: a0b7:              IF RC% <> 0 THEN BEGIN
7327: a0d6:                 ! end of file found
7328: a0d6:                 END.PRE.PROCESSING = TRUE
7329: a0e8:              ENDIF
7330: a0f0: 
7331: a0f0:         WEND
7332: a102: 
7333: a102:         CALL CLOSE.IUF                                           ! 1.6 RC (87)
7334: a11c: 
7335: a11c:         IF NUMBER.OF.BATCHES% > 1 THEN BEGIN
7336: a12b: 
7337: a12b:            ITEM.PRE.PROCESSING.CHECK = TRUE
7338: a141: 
7339: a141:         ENDIF
7340: a149: 
7341: a149:         CALL DO.MESSAGE("PSB21 - New IUF format. Completed IUF Pre-Processing ", FALSE)
7342: a180: 
7343: a180:     ! Old format no pre-processing required
7344: a180:     ENDIF ELSE BEGIN
7345: a188: 
7346: a188:         CALL DO.MESSAGE("PSB21 Old IUF format. No Pre-Processing required ", FALSE)
7347: a1bc: 
7348: a1bc:         IF LEFT$(BCF.IUF.DATETIMESTAMP$,1) <> " " THEN BEGIN                                          !1.6CSk
7349: a1f4:             CALL DO.MESSAGE("PSB21 *** ERROR: OLD format IUF detected. New format expected", FALSE)   !1.6CSk
7350: a228:             CALL DO.MESSAGE("PSB21            since BCF Rec 20 Batch Timestamp is set. To" , FALSE)   !1.6CSk
7351: a25c:             CALL DO.MESSAGE("PSB21            override, manually Set BCF Rec 20 to SPACES.", FALSE)   !1.6CSk
7352: a290:             SKIP.IUF.PROCESSING = TRUE                                                                !1.6CSk
7353: a2a6:             JOBSOK.FLAG$ = "X"                                                                        ! 1.7 RC
7354: a2bd:         ENDIF                                                                                         !1.6CSk
7355: a2c5: 
7356: a2c5:     ENDIF
7357: a2cd: 
7358: a2cd: END SUB
7359: a2e1: 
7360: a2e1: 
7361: a2e1: \*******************************************************************************
7362: a2e1: \*******************************************************************************
7363: a2e1: \*******************************************************************************
7364: a2e1: \*******************************************************************************
7365: a2e1: \***                                                                         ***
7366: a2e1: \***              S T A R T   O F   M A I N L I N E   C O D E                ***
7367: a2e1: \***                                                                         ***
7368: a2e1: \*******************************************************************************
7369: a2e1: \*******************************************************************************
7370: a2e1: \*******************************************************************************
7371: a2e1: \*******************************************************************************
7372: a2e1: 
7373: a2e1:     ON ERROR GOTO ERROR.DETECTED
7374: a310: 
7375: a310:     ! Initialise constants and static tables
7376: a310:     CALL INITIALISATION
7377: a31c: 
7378: a31c:     ! Pre-processing of the IUF file
7379: a31c:     CALL IUF.PRE.PROCESSING
7380: a328: 
7381: a328:     !Add all existing WEEEUF records into a table
7382: a328:     CALL LOAD.WEEEUF.FILE.INTO.TABLE
7383: a334: 
7384: a334:     ! Creates a new PGF using the file PGFDIR
7385: a334:     CALL PROCESS.PGF
7386: a341:     CALL CHECK.PROCESS.PGF ! PSB2102                           ! 1.20 RC (240)
7387: a34e: 
7388: a34e:     ! Add all existing PPFI records to a temporary keyed file
7389: a34e:     CALL PROCESS.OLD.PPFI
7390: a35b: 
7391: a35b:     ! Update item reference files for all items on the IUF
7392: a35b:     CALL PROCESS.IUF
7393: a367: 
7394: a367: !   Delete the PPFK file                                                    !GMW
7395: a367:     CALL DELETE.PPFK.KEYED.FILE ! Writes "PHASE 5"              ! 1.4 RC (190)
7396: a373: 
7397: a373:     ! Update JOBSOK, send message to DEC API and chain to PSB20
7398: a373:     CALL PROGRAM.EXIT
7399: a380: 
7400: a380:     STOP
7401: a38d: 
7402: a38d: \******************************************************************************
7403: a38d: \***
7404: a38d: \***    Main error handling routine
7405: a38d: \***
7406: a38d: \******************************************************************************
7407: a38d: ERROR.DETECTED:
7408: a39d: 
7409: a39d:     IF ERR = "CU" THEN RESUME
7410: a3d2: 
7411: a3d2:     IF ERR = "OE" AND ERRF% = 0 THEN RESUME
7412: a429: 
7413: a429:     PRINT ERR;ERRNH;" at line ";ERRL
7414: a45e:     PRINT "Got to IUF Record No: " + STR$(COUNT.RECORDS.IUF%)
7415: a48a: 
7416: a48a:     ERROR.COUNT% = ERROR.COUNT% + 1
7417: a499: 
7418: a499:     IF ERROR.COUNT% > 1 THEN BEGIN
7419: a4ab:         PRINT "ERROR.DETECTED hit for the 2nd time - STOPPING PROGRAM!"
7420: a4bc:         STOP
7421: a4c9:     ENDIF
7422: a4d1: 
7423: a4d1:     IF ERR = "CM" OR ERR = "CT" THEN BEGIN ! Chaining Error
7424: a530:         CALL LOG.EVENT(18)
7425: a554:         STOP
7426: a561:     ENDIF
7427: a569: 
7428: a569:     IF ERR = "SU" THEN BEGIN ! Array Subscript Error                                  ! 1.15 CSk
7429: a592:         PRINT "*** ERROR Subscript out of bounds error" + \                           ! 1.15 CSk
7430: a5b2:               " - STOPPING PROGRAM!"                                                  ! 1.15 CSk
7431: a5b2:         PRINT "*** ERROR Exceeded max no. of " + STR$(PPFK.PCR.MAX%) +  \             ! 1.15 CSk
7432: a5ec:               " price changes per item."                                              ! 1.15 CSk
7433: a5ec:         CALL DO.MESSAGE("*** ERROR Subscript out of bounds error" + \                 ! 1.15 CSk
7434: a627:                         " - STOPPING PROGRAM!", TRUE)                                 ! 1.15 CSk
7435: a627:         CALL DO.MESSAGE("*** ERROR Exceeded max no. of " + STR$(PPFK.PCR.MAX%) + \    ! 1.15 CSk
7436: a67c:                         " price changes per item.", TRUE)                             ! 1.15 CSk
7437: a67c:     ENDIF                                                                             ! 1.15 CSk
7438: a684: 
7439: a684:     RC% = STANDARD.ERROR.DETECTED (ERRN,  \
7440: a6bf:                                    ERRF%, \
7441: a6bf:                                    ERRL,  \
7442: a6bf:                                    ERR)
7443: a6bf: 
7444: a6bf:     JOBSOK.FLAG$ = "X"
7445: a6d6:     CALL PROGRAM.EXIT    ! If called by PSB20 then chain back to PSB20
7446: a6e8: 
7447: a6e8:     END
7448: a6e8: End of Compilation
