   1: 0000: \*******************************************************************************
   2: 0000: \*******************************************************************************
   3: 0000: \***
   4: 0000: \***
   5: 0000: \***            MODULE          :       PSBF48
   6: 0000: \***            AUTHOR          :       Mark Goode
   7: 0000: \***            DATE WRITTEN    :       October 2010
   8: 0000: \***
   9: 0000: \*******************************************************************************
  10: 0000: \***
  11: 0000: \***    VERSION A.           Mark Goode             15th October 2010
  12: 0000: \***    Initial version (Release 1 / 2).
  13: 0000: \***
  14: 0000: \***    VERSION B.           Mark Goode             31st January 2011
  15: 0000: \***    This version includes the service events logging requirements (Release 3).
  16: 0000: \***    This relates to change request - CR002
  17: 0000: \***    Service Event log record format:-
  18: 0000: \***       DECAPI.EVENT(MESSAGE ID, DATA, REASON CODE)
  19: 0000: \***
  20: 0000: \***    VERSION C.           Mark Goode             9th May 2011
  21: 0000: \***    This version contains changes relating to DEC release 3 after system testing.
  22: 0000: \***    Tidying up of the DEC API log file layout.
  23: 0000: \***
  24: 0000: \***    VERSION D.           Mark Goode             16th May 2011
  25: 0000: \***    The current solution for housekeeping of the  DQ file causes issues for
  26: 0000: \***    the DEC i.e. Process of exclusive locking in JAVA. Therefore, instead of waiting
  27: 0000: \***    the API will check for a trigger file. If available do not write to DQ file until
  28: 0000: \***    removed. To reduce the system impact on checking on trigger file, install a time period.
  29: 0000: \***    House keeping defaults off (99999999). 
  30: 0000: \***
  31: 0000: \***    VERSION E.           Mark Goode             18th May 2011
  32: 0000: \***    Include batching of real time messages. Now only open service event log
  33: 0000: \***    when required
  34: 0000: \***
  35: 0000: \***    VERSION F.           Mark Goode              16th June 2011
  36: 0000: \***    The first transaction of the day wakes up the DEC, which can take longer than
  37: 0000: \***    the 1000ms timeout for check connection, therefore socket may be open but message
  38: 0000: \***    not returned in time. MESSAGE.ARRAY changed to remove check connection message.
  39: 0000: \***    Refresh time stamp on retry.
  40: 0000: \***
  41: 0000: \***    VERSION G.           Mark Goode              29th June 2011
  42: 0000: \***    This version removes housekeeping code due to requirement change also
  43: 0000: \***    resolves isssues found during testing phase.
  44: 0000: \***
  45: 0000: \***    VERSION H.           Mark Goode              6th July 2011
  46: 0000: \***    Remove Payload time stamp and Housekeeping
  47: 0000: \***
  48: 0000: \***    VERSION I.           Mark Goode              18th October 2011
  49: 0000: \***    Defect 1809 - Improve the error trapping to catch file lock from a
  50: 0000: \***    java application. This will also resolve the API not attemping retry.
  51: 0000: \***
  52: 0000: \***    VERSION J.           Mark Goode              28th November 2011
  53: 0000: \***    Resolved issue with commit not being sent in DECAPI.SEND
  54: 0000: \***
  55: 0000: \***    VERSION K.           Mark Walker              24th January 2012
  56: 0000: \***    - Ignore close errors on the DQ file
  57: 0000: \***    - Make lock error handling specific to the DQ file
  58: 0000: \***    - Return OS error codes to calling program
  59: 0000: \***    - Steer clear of doing anything with the DQ pointer file. It also
  60: 0000: \***      uses a hardcoded session number already used by Sales Support.
  61: 0000: \***
  62: 0000: \***    VERSION L.           Mark Walker             15th February 2012
  63: 0000: \***    Changed the DAY$ function to calculate the day of the week
  64: 0000: \***    rather than using CONTTIME, as this function occasionally
  65: 0000: \***    fails causing the DEC API to crash.
  66: 0000: \***
  67: 0000: \***    VERSION M.           Brian Greenfield        19th February 2013
  68: 0000: \***    The queue filename is now DQ2nn.BIN. All references changed.
  69: 0000: \***    In OPEN.DQ(), remove the code that specifies the logical node on  
  70: 0000: \***    which to open/create the DEC queue file. For example, currently the   
  71: 0000: \***    file opened would be ADXLXAAN::D:\ADX_UDT1\DQCE.BIN, but the logical 
  72: 0000: \***    node can be removed i.e. D:\ADX_UDT1\DQ2CE.BIN. In addition, set the 
  73: 0000: \***    the distribution to 1 (local)
  74: 0000: \***    These changes are part of the FOD-226 DEC 2.0 project.
  75: 0000: \***
  76: 0000: \*******************************************************************************
  77: 0000: \*******************************************************************************
  78: 0000: 
  79: 0000: \*******************************************************************************
  80: 0000: \*******************************************************************************
  81: 0000: \***
  82: 0000: \***    Module Overview
  83: 0000: \***    ---------------
  84: 0000: \***
  85: 0000: \***    This function is the DEC API for 4690 controller application. The API
  86: 0000: \***    will allow access to the DEC for initialistaion, request and response, as
  87: 0000: \***    well as, closing session.
  88: 0000: \***
  89: 0000: \***        Command:      
  90: 0000: \***        Accepted calls to the DEC API
  91: 0000: \***        DECAPI.INIT                  - Initialise calling application socket to DEC 
  92: 0000: \***        DECAPI.CLOSE                 - Close socket connection to the DEC
  93: 0000: \***        DECAPI.SEND                  - Send payload using message type to DEC
  94: 0000: \***        DECAPI.RECV                  - Calling application requesting response from DEC
  95: 0000: \***        DECAPI.RECV.RESPONSE.TIME    - calling application request response time from last response
  96: 0000: \***        DECAPI.EVENT                 - Enables calling application to log Service Events
  97: 0000: \***        DECAPI.COMMAND               - General commands to the DEC via socket
  98: 0000: \***
  99: 0000: \***        
 100: 0000: \***         DEC API Return Codes
 101: 0000: \***        ----------------------
 102: 0000: \***         ACK 
 103: 0000: \***           00
 104: 0000: \***         NAK (INT)
 105: 0000: \***           nn - Where nn is the error code
 106: 0000: \***           01 - Time out
 107: 0000: \***           02 - Could not connect (DEC - Socket Adapter)
 108: 0000: \***           03 - No such message
 109: 0000: \***           04 - Request Socket closed
 110: 0000: \***           05 - Payload exceeds maximum length
 111: 0000: \***           06 - Could not connect (Issue with Node Queue file)
 112: 0000: \***           07 - API failed initialisation
 113: 0000: \***           08 - Unknown event reason code
 114: 0000: \***           09 - Housekeeping in progress
 115: 0000: \***           0A - Message not sent
 116: 0000: \***         NAK on DECAPI formatted as follows:
 117: 0000: \***         NAKnn (ASCII)
 118: 0000: \***           Where nn is the error code
 119: 0000: \***                 00 - Response not yet available
 120: 0000: \***                 01 - Time out
 121: 0000: \***                 02 - Invalid response
 122: 0000: \***                 03 - Incomplete message                         
 123: 0000: \***                 04 - Response Socket closed          
 124: 0000: \***
 125: 0000: \*******************************************************************************
 126: 0000: \*******************************************************************************
 127: 0000: 
 128: 0000: \*******************************************************************************
 129: 0000: \***
 130: 0000: \***    Function globals
 131: 0000: \***
 132: 0000: \*******************************************************************************
 133: 0000: 
 134: 0000: %INCLUDE PSBF01G.J86         ! Application Logging
 135: 0000: REM \
 136: 0000: \*******************************************************************************
 137: 0000: \*******************************************************************************
 138: 0000: \***
 139: 0000: \***       %INCLUDE FOR GLOBAL DEFINITIONS FOR FUNCTION APPLICATION.LOG
 140: 0000: \***
 141: 0000: \***                FUNCTION NUMBER    : PSBF01
 142: 0000: \***
 143: 0000: \***                REFERENCE          : PSBF01G.J86
 144: 0000: \***
 145: 0000: \***                DATE OF LAST AMENDMENT  - 27/2/86
 146: 0000: \***
 147: 0000: \***
 148: 0000: \*******************************************************************************
 149: 0000: 
 150: 0000:       INTEGER GLOBAL  F01.RETURN.CODE%
 151: 0000: 
 152: 0000: 
 153: 0000: %INCLUDE SOPTSDEC.J86        ! Store Options File
 154: 0000: REM \
 155: 0000: \******************************************************************************
 156: 0000: \******************************************************************************
 157: 0000: \***
 158: 0000: \***                 %INCLUDE FOR THE STORE OPTIONS FILE
 159: 0000: \***   
 160: 0000: \***                      FILE TYPE  :   Direct
 161: 0000: \***
 162: 0000: \***                      REFERENCE  :   SOPTSDEC.J86
 163: 0000: \***
 164: 0000: \***    Version A         Stuart William McConnachie      19th June 1995
 165: 0000: \***
 166: 0000: \******************************************************************************
 167: 0000: \*******************************************************************************
 168: 0000: 
 169: 0000:   STRING GLOBAL           \
 170: 0000:     SOPTS.RECORD$,        \           
 171: 0000:     SOPTS.SPACE$,         \           
 172: 0000:     SOPTS.FILE.NAME$
 173: 0000:     
 174: 0000:   INTEGER*2 GLOBAL        \
 175: 0000:     SOPTS.RECL%,          \            
 176: 0000:     SOPTS.REPORT.NUM%,    \      
 177: 0000:     SOPTS.SESS.NUM%
 178: 0000: 
 179: 0000:   INTEGER*4 GLOBAL        \
 180: 0000:     SOPTS.REC.NUM%
 181: 0000: 
 182: 0000: %INCLUDE DECCFDEC.J86        ! DEC Configuration file
 183: 0000: REM \
 184: 0000: \******************************************************************************
 185: 0000: \******************************************************************************
 186: 0000: \***
 187: 0000: \***                 %INCLUDE FOR THE DEC CONFIGURATION FILE
 188: 0000: \***   
 189: 0000: \***                      FILE TYPE  :   Direct
 190: 0000: \***
 191: 0000: \***                      REFERENCE  :   DECCFDEC.J86
 192: 0000: \***
 193: 0000: \***    Version A         Mark Goode      20th October 2010
 194: 0000: \***
 195: 0000: \******************************************************************************
 196: 0000: \*******************************************************************************
 197: 0000: 
 198: 0000:   STRING GLOBAL           \
 199: 0000:     DECCF.RECORD$,        \    
 200: 0000:     DECCF.MSGID$,         \    Message ID
 201: 0000:     DECCF.MSGNAME$,       \    Message Name
 202: 0000:     DECCF.DIRECTION$,     \    Message Direction
 203: 0000:     DECCF.TYPE$,          \    Queue / Topice i.e. "Q" / "T"
 204: 0000:     DECCF.QOS$,           \    Quality Of Service
 205: 0000:     DECCF.DELIVERY$,      \    "S" - Real Time "Q" - Write to queue file
 206: 0000:     DECCF.FILE.NAME$      !    DEC Configuration file name
 207: 0000:     
 208: 0000:   INTEGER*2 GLOBAL        \          
 209: 0000:     DECCF.RECL%,          \ 
 210: 0000:     DECCF.REPORT.NUM%,    \      
 211: 0000:     DECCF.SESS.NUM%
 212: 0000: 
 213: 0000:   INTEGER*4 GLOBAL        \
 214: 0000:     DECCF.REC.NUM%
 215: 0000: 
 216: 0000: %INCLUDE DECAPDEC.J86        ! Daily DEC API log file 
 217: 0000: REM \
 218: 0000: \******************************************************************************
 219: 0000: \******************************************************************************
 220: 0000: \***
 221: 0000: \***                 %INCLUDE FOR THE DAILY DEC API LOG FILE
 222: 0000: \***   
 223: 0000: \***                      FILE TYPE  :   Sequential
 224: 0000: \***
 225: 0000: \***                      REFERENCE  :   DECAPDEC.J86
 226: 0000: \***
 227: 0000: \***    Version A         Mark Goode      20th October 2010
 228: 0000: \***
 229: 0000: \******************************************************************************
 230: 0000: \*******************************************************************************
 231: 0000: 
 232: 0000:   STRING GLOBAL           \
 233: 0000:     DECAP.RECORD$,        \ 
 234: 0000:     DECAP.FILE.NAME$
 235: 0000:     
 236: 0000:   INTEGER*2 GLOBAL        \          
 237: 0000:     DECAP.REPORT.NUM%,    \      
 238: 0000:     DECAP.SESS.NUM%
 239: 0000: 
 240: 0000:   INTEGER*4 GLOBAL        \
 241: 0000:     DECAP.REC.NUM%
 242: 0000: 
 243: 0000: %INCLUDE DQDEC.J86           ! DQ queue files
 244: 0000: REM \
 245: 0000: \******************************************************************************
 246: 0000: \******************************************************************************
 247: 0000: \***
 248: 0000: \***                 %INCLUDE FOR THE DQ QUEUE FILE
 249: 0000: \***   
 250: 0000: \***                      FILE TYPE  :   Sequential
 251: 0000: \***
 252: 0000: \***                      REFERENCE  :   DQDEC.J86
 253: 0000: \***
 254: 0000: \***    Version A         Mark Goode      20th October 2010
 255: 0000: \***
 256: 0000: \******************************************************************************
 257: 0000: \*******************************************************************************
 258: 0000: 
 259: 0000:   STRING GLOBAL           \
 260: 0000:     DQ.MESSAGE$,          \
 261: 0000:     DQ.PAYLOAD$,          \ 
 262: 0000:     DQ.RECORD$,           \
 263: 0000:     DQ.ARRAY.RECORD$(1),  \  
 264: 0000:     DQ.FILE.NAME$
 265: 0000:     
 266: 0000:   INTEGER*2 GLOBAL        \
 267: 0000:     DQ.REC.NUM%,          \
 268: 0000:     DQ.ELEMENT%,          \
 269: 0000:     DQ.REPORT.NUM%,       \      
 270: 0000:     DQ.SESS.NUM%,         \
 271: 0000:     DQ1.SESS.NUM%
 272: 0000: 
 273: 0000: 
 274: 0000: %INCLUDE SERVLDEC.J86        ! Service event logs        ! BMG
 275: 0000: REM \
 276: 0000: \******************************************************************************
 277: 0000: \******************************************************************************
 278: 0000: \***
 279: 0000: \***                 %INCLUDE FOR THE SERVICE LOG FILE
 280: 0000: \***   
 281: 0000: \***                      FILE TYPE  :   Sequential
 282: 0000: \***
 283: 0000: \***                      REFERENCE  :   SERVLDEC.J86
 284: 0000: \***
 285: 0000: \***    Version A         Mark Goode      31st January 2011
 286: 0000: \***
 287: 0000: \******************************************************************************
 288: 0000: \*******************************************************************************
 289: 0000: 
 290: 0000:   STRING GLOBAL              \
 291: 0000:     SERVL.MESSAGE$,          \
 292: 0000:     SERVL.DATA$,             \ 
 293: 0000:     SERVL.RECORD$,           \
 294: 0000:     SERVL.ARRAY.RECORD$(1),  \  
 295: 0000:     SERVL.FILE.NAME$
 296: 0000:     
 297: 0000:   INTEGER*2 GLOBAL           \
 298: 0000:     SERVL.REC.NUM%,          \
 299: 0000:     SERVL.ELEMENT%,          \
 300: 0000:     SERVL.REPORT.NUM%,       \      
 301: 0000:     SERVL.SESS.NUM%,         \
 302: 0000:     SERVL1.SESS.NUM%
 303: 0000: 
 304: 0000: 
 305: 0000: 
 306: 0000: %INCLUDE PSBF13G.J86         ! PSDATE
 307: 0000: REM\
 308: 0000: \*******************************************************************************
 309: 0000: \*******************************************************************************
 310: 0000: \***
 311: 0000: \***        INCLUDE       : PSDATE globals
 312: 0000: \***
 313: 0000: \***        REFERENCE     : PSBF13G.J86
 314: 0000: \***
 315: 0000: \***     VERSION A                                  Bruce Scriver  6th Mar 86             
 316: 0000: \***            
 317: 0000: \***     VERSION B                                  Janet Lawrence 17 Aug 90
 318: 0000: \***     Add global to be used to indicate whether or not the function should
 319: 0000: \***     log an event when an invalid date is passed to it.
 320: 0000: \***
 321: 0000: \***     VERSION C                               Andrew Wedgeworth 17 July 92
 322: 0000: \***     Return code removed as no longer required.
 323: 0000: \***
 324: 0000: \*******************************************************************************
 325: 0000: \*******************************************************************************
 326: 0000: 
 327: 0000:       STRING    GLOBAL F13.DAY$,			\
 328: 0000:                        F13.DISPLAY.MESSAGE$		! BJAL
 329: 0000: 
 330: 0000: 
 331: 0000: %INCLUDE PSBUSEG.J86         ! Chain parameters
 332: 0000: \/*********************************************************************/ PSBUSEG
 333: 0000: \/*                                                                   */ PSBUSEG
 334: 0000: \/* PSBUSEG.J86  -  Definitions for Chain/Use with PSB Screen Program */ PSBUSEG
 335: 0000: \/* ----------------------------------------------------------------- */ PSBUSEG
 336: 0000: \/*                                                                   */ PSBUSEG
 337: 0000: \/*********************************************************************/ PSBUSEG
 338: 0000:                                                                        ! PSBUSEG
 339: 0000:         STRING GLOBAL  PSBCHN.PRG,      \ Program to chain to          ! PSBUSEG
 340: 0000:                        PSBCHN.OP,       \ Operator Id                  ! PSBUSEG
 341: 0000:                        PSBCHN.APP,      \ Program chained from         ! PSBUSEG
 342: 0000:                        PSBCHN.MENCON,   \ Menu Control                 ! PSBUSEG
 343: 0000:                        PSBCHN.U1,       \ User parameter               ! PSBUSEG
 344: 0000:                        PSBCHN.U2,       \ User parameter               ! PSBUSEG
 345: 0000:                        PSBCHN.U3        ! User parameter               ! PSBUSEG
 346: 0000:                                                                        ! PSBUSEG
 347: 0000: 
 348: 0000: 
 349: 0000: \*******************************************************************************
 350: 0000: \***
 351: 0000: \***    Globals
 352: 0000: \***
 353: 0000: \*******************************************************************************
 354: 0000: 
 355: 0000: STRING GLOBAL    CURRENT.CODE$
 356: 0000: STRING GLOBAL    FILE.OPERATION$
 357: 0000: STRING GLOBAL    DECAPI.CLIENT$
 358: 0000: STRING GLOBAL    ERR.CODE$                                                      ! KMW
 359: 0000: STRING GLOBAL    ERR.MSG$                                                       ! KMW
 360: 0000: INTEGER*1 GLOBAL DECAPI.MAX
 361: 0000: INTEGER*2 GLOBAL CURRENT.REPORT.NUM%
 362: 0000: INTEGER*4 GLOBAL TCPERRNO%
 363: 0000: 
 364: 0000: \*******************************************************************************
 365: 0000: \***
 366: 0000: \***    PSBF48 variables
 367: 0000: \***
 368: 0000: \*******************************************************************************
 369: 0000: 
 370: 0000: STRING CT.TIMEDATE.TABLE$
 371: 0000: STRING CT.PARAMBLK$
 372: 0000: 
 373: 0000: STRING CRTLF$
 374: 0000: STRING COMMA$
 375: 0000: STRING PIPE$
 376: 0000: STRING QUOTE$
 377: 0000: STRING AMPERSAND$
 378: 0000: STRING RECORD$
 379: 0000: STRING STATUS$
 380: 0000: STRING CLIENT.IP$
 381: 0000: STRING NODE.ID$
 382: 0000: STRING PRIMARY.DQ.EXTENSION$
 383: 0000: STRING ALTERNATE.IP$
 384: 0000: STRING ALTERNATE.DQ$
 385: 0000: STRING PRIMARY.IP$
 386: 0000: STRING RESPONSE.TIME
 387: 0000: STRING SECONDARY.IP$
 388: 0000: STRING DECCONF.RECORD$(1)
 389: 0000: STRING SERVL.LOG.RECORD$(1)            ! BMG
 390: 0000: STRING SELECTHANDLE$
 391: 0000: STRING SECONDARY.DQ.EXTENSION$
 392: 0000: STRING DEC.RESPONSE$
 393: 0000: STRING SOCKET.MESSAGE.ARRAY$(1)        ! EMG
 394: 0000: STRING TEST.RESPONSE$                  ! FMG
 395: 0000: 
 396: 0000: INTEGER*1 FALSE
 397: 0000: INTEGER*1 NAK
 398: 0000: INTEGER*1 FOUND
 399: 0000: INTEGER*1 MESSAGE.MATCH
 400: 0000: INTEGER*1 PHASE1.COMPLETED
 401: 0000: INTEGER*1 DEC.LOGSTATUS
 402: 0000: INTEGER*1 TRUE
 403: 0000: INTEGER*1 ACK
 404: 0000: INTEGER*1 PROBLEM.DQ
 405: 0000: INTEGER*1 LOG.FILE.OPEN
 406: 0000: INTEGER*1 SERVICE.FILE.OPEN            ! BMG
 407: 0000: !INTEGER*1 DQ.OPENED                   ! KMW
 408: 0000: INTEGER*1 WRITING.DETAIL
 409: 0000: INTEGER*1 QUEUE.FILE                   ! BMG
 410: 0000: INTEGER*1 HOUSE.KEEP.ACTIVE            ! DMG
 411: 0000: 
 412: 0000: INTEGER*2 DEC.PORT%                
 413: 0000: INTEGER*2 DEC.SOCKET.TIMEOUT%
 414: 0000: INTEGER*2 DEC.TRANSTATUS
 415: 0000: INTEGER*2 DEC.SERVICE.LOG              ! BMG
 416: 0000: INTEGER*2 I%, J%
 417: 0000: INTEGER*2 LOOP%
 418: 0000: INTEGER*2 SOCKET.RC%
 419: 0000: INTEGER*2 RECORD.LENGTH%
 420: 0000: INTEGER*2 REC.NUM%
 421: 0000: INTEGER*2 SOCKET.HANDLE%
 422: 0000: INTEGER*2 SOCKET.MESSAGE.COUNT%        ! EMG
 423: 0000: INTEGER*4 TIME.IN.MS%                  ! BMG
 424: 0000: 
 425: 0000: INTEGER*4 DEC.HOUSEKEEP.TIME%          ! DMG
 426: 0000: 
 427: 0000: 
 428: 0000: \*******************************************************************
 429: 0000: \***
 430: 0000: \***    External functions
 431: 0000: \***
 432: 0000: \********************************************************************
 433: 0000: 
 434: 0000: %INCLUDE BTCMEM.J86
 435: 0000: !********************************************************************
 436: 0000: !***
 437: 0000: !***    INCLUDED CODE:  BTCMEM.J86
 438: 0000: !***    AUTHOR:         Stuart William McConnachie
 439: 0000: !***    DATE:           26th February 2006
 440: 0000: !***
 441: 0000: !********************************************************************
 442: 0000: !***
 443: 0000: !***    Controller CBASIC Memory Functions
 444: 0000: !***
 445: 0000: !********************************************************************
 446: 0000: 
 447: 0000: !Get a single byte integer from a string offset
 448: 0000: FUNCTION GETN1 (S$, P%) EXTERNAL
 449: 0000:     STRING S$
 450: 0000:     INTEGER*2 P%
 451: 0000:     INTEGER*2 GETN1
 452: 0000: END FUNCTION
 453: 0000: 
 454: 0000: !Get a two byte integer from a string offset
 455: 0000: FUNCTION GETN2 (S$, P%) EXTERNAL
 456: 0000:     STRING S$
 457: 0000:     INTEGER*2 P%
 458: 0000:     INTEGER*2 GETN2
 459: 0000: END FUNCTION
 460: 0000: 
 461: 0000: !Get a four byte integer from a string offset
 462: 0000: FUNCTION GETN4 (S$, P%) EXTERNAL
 463: 0000:     STRING S$
 464: 0000:     INTEGER*2 P%
 465: 0000:     INTEGER*4 GETN4
 466: 0000: END FUNCTION
 467: 0000: 
 468: 0000: !Get a 10 byte CBASIC real from a string offset
 469: 0000: FUNCTION GETR10 (S$, P%) EXTERNAL
 470: 0000:     STRING S$
 471: 0000:     INTEGER*2 P%
 472: 0000:     REAL GETR10
 473: 0000: END FUNCTION
 474: 0000: 
 475: 0000: !Put a single byte integer into a string at offset
 476: 0000: FUNCTION PUTN1 (S$, P%, N%) EXTERNAL
 477: 0000:     STRING S$
 478: 0000:     INTEGER*2 P%
 479: 0000:     INTEGER*1 N%
 480: 0000:     INTEGER*1 PUTN1
 481: 0000: END FUNCTION
 482: 0000: 
 483: 0000: !Put a two byte integer into a string at offset
 484: 0000: FUNCTION PUTN2 (S$, P%, N%) EXTERNAL
 485: 0000:     STRING S$
 486: 0000:     INTEGER*2 P%
 487: 0000:     INTEGER*2 N%
 488: 0000:     INTEGER*1 PUTN2
 489: 0000: END FUNCTION
 490: 0000: 
 491: 0000: !Put a four byte integer into a string at offset
 492: 0000: FUNCTION PUTN4 (S$, P%, N%) EXTERNAL
 493: 0000:     STRING S$
 494: 0000:     INTEGER*2 P%
 495: 0000:     INTEGER*4 N%
 496: 0000:     INTEGER*1 PUTN4
 497: 0000: END FUNCTION
 498: 0000: 
 499: 0000: !Put a 10 byte CBASIC real into a string at offset
 500: 0000: FUNCTION PUTR10 (S$, P%, R) EXTERNAL
 501: 0000:     STRING S$
 502: 0000:     INTEGER*2 P%
 503: 0000:     REAL R
 504: 0000:     INTEGER*1 PUTR10
 505: 0000: END FUNCTION
 506: 0000: 
 507: 0000: !Peek a two byte integer from a memory address
 508: 0000: FUNCTION PEEKN2 (A%) EXTERNAL
 509: 0000:     INTEGER*4 A%
 510: 0000:     INTEGER*2 PEEKN2
 511: 0000: END FUNCTION
 512: 0000: 
 513: 0000: !Peek a four byte integer from a memory address
 514: 0000: FUNCTION PEEKN4 (A%) EXTERNAL
 515: 0000:     INTEGER*4 A%
 516: 0000:     INTEGER*4 PEEKN4
 517: 0000: END FUNCTION
 518: 0000: 
 519: 0000: !Peek a 10 byte CBASIC real from a memory address
 520: 0000: FUNCTION PEEKR10 (A%) EXTERNAL
 521: 0000:     INTEGER*4 A%
 522: 0000:     REAL PEEKR10
 523: 0000: END FUNCTION
 524: 0000: 
 525: 0000: !Poke a two byte integer to a memory address
 526: 0000: FUNCTION POKEN2 (A%, N%) EXTERNAL
 527: 0000:     INTEGER*4 A%
 528: 0000:     INTEGER*2 N%
 529: 0000:     INTEGER*1 POKEN2
 530: 0000: END FUNCTION
 531: 0000: 
 532: 0000: !Poke a four byte integer to a memory address
 533: 0000: FUNCTION POKEN4 (A%, N%) EXTERNAL
 534: 0000:     INTEGER*4 A%
 535: 0000:     INTEGER*4 N%
 536: 0000:     INTEGER*1 POKEN4
 537: 0000: END FUNCTION
 538: 0000: 
 539: 0000: !Poke a 10 byte CBASIC real to a memory address
 540: 0000: FUNCTION POKER10 (A%, R) EXTERNAL
 541: 0000:     INTEGER*4 A%
 542: 0000:     REAL R
 543: 0000:     INTEGER*1 POKER10
 544: 0000: END FUNCTION
 545: 0000: 
 546: 0000: %INCLUDE SOCKLIB.J86        ! CBASIC SOCKET LIBRIARY
 547: 0000: \*******************************************************************************
 548: 0000: \***
 549: 0000: \***   4680 BASIC SOCKETS INTERFACE EXTERNAL DECLARATIONS
 550: 0000: \***
 551: 0000: \***   Copyright (c) 2008, 2009 Stuart Highley
 552: 0000: \***   All rights reserved
 553: 0000: \***
 554: 0000: \***
 555: 0000: \***   Possible TCPIP return codes (in global TCPERRNO%):
 556: 0000: \***
 557: 0000: \***   EWOULDBLOCK     35              Operation would block             
 558: 0000: \***   EDEADLK         EWOULDBLOCK     ditto                             
 559: 0000: \***   EINPROGRESS     36              Operation now in progress         
 560: 0000: \***   EALREADY        37              Operation already in progress     
 561: 0000: \***   
 562: 0000: \***   Argument errors                                                   
 563: 0000: \***   ENOTSOCK        38              Socket operation on non-socket    
 564: 0000: \***   EDESTADDRREQ    39              Destination address required      
 565: 0000: \***   EMSGSIZE        40              Message too long                  
 566: 0000: \***   EPROTOTYPE      41              Protocol wrong type for socket    
 567: 0000: \***   ENOPROTOOPT     42              Protocol not available            
 568: 0000: \***   EPROTONOSUPPORT 43              Protocol not supported            
 569: 0000: \***   ESOCKTNOSUPPORT 44              Socket type not supported         
 570: 0000: \***   EOPNOTSUPP      45              Operation not supported on socket 
 571: 0000: \***   EPFNOSUPPORT    46              Protocol family not supported     
 572: 0000: \***   EAFNOSUPPORT    47              Address family not supported by   
 573: 0000: \***   protocol family                     
 574: 0000: \***   EADDRINUSE      48              Address already in use            
 575: 0000: \***   EADDRNOTAVAIL   49              Can't assign requested address    
 576: 0000: \***   
 577: 0000: \***   Operational errors                                                
 578: 0000: \***   ENETDOWN        50              Network is down                   
 579: 0000: \***   ENETUNREACH     51              Network is unreachable            
 580: 0000: \***   ENETRESET       52              Network dropped connection on reset 
 581: 0000: \***   ECONNABORTED    53              Software caused connection abort    
 582: 0000: \***   ECONNRESET      54              Connection reset by peer            
 583: 0000: \***   ENOBUFS         55              No buffer space available           
 584: 0000: \***   EISCONN         56              Socket is already connected         
 585: 0000: \***   ENOTCONN        57              Socket is not connected             
 586: 0000: \***   ESHUTDOWN       58              Can't send after socket shutdown    
 587: 0000: \***   ETOOMANYREFS    59              Too many references: can't splice   
 588: 0000: \***   ETIMEDOUT       60              Connection timed out                
 589: 0000: \***   ECONNREFUSED    61              Connection refused                  
 590: 0000: \***   
 591: 0000: \***   ELOOP           62              Too many levels of symbolic links   
 592: 0000: \***   ENAMETOOLONG    63              File name too long                  
 593: 0000: \***   
 594: 0000: \***   Should be rearranged                                                
 595: 0000: \***   EHOSTDOWN       64              Host is down                        
 596: 0000: \***   EHOSTUNREACH    65              No route to host                    
 597: 0000: \***   ENOTEMPTY       66              Directory not empty                 
 598: 0000: \***
 599: 0000: \*******************************************************************************
 600: 0000: 
 601: 0000: \*******************************************************************************
 602: 0000: \***
 603: 0000: \***   PUBLIC FUNCTIONS
 604: 0000: \***
 605: 0000: \*******************************************************************************
 606: 0000: 
 607: 0000: \*******************************************************************************
 608: 0000: \***   SOCK.INIT
 609: 0000: \***   Open the TCPIP device driver and dimension a table to hold sockets
 610: 0000: \***
 611: 0000: \***   NOTE: BUFFER.SIZE% is no longer used as buffer is always set to
 612: 0000: \***   31K. Parameter is left as UNUSED% to prevent link problems with legacy
 613: 0000: \***   applications.
 614: 0000: \*******************************************************************************
 615: 0000: FUNCTION SOCK.INIT(MAX.SOCKS%, UNUSED%) EXTERNAL                        !1.1SH
 616: 0000:     INTEGER*2 MAX.SOCKS%
 617: 0000:     INTEGER*2 UNUSED%                                                   !1.1SH
 618: 0000:     INTEGER*1 SOCK.INIT
 619: 0000: END FUNCTION
 620: 0000: 
 621: 0000: \*******************************************************************************
 622: 0000: \***   SOCK.SOCKET
 623: 0000: \***   Create a socket
 624: 0000: \*******************************************************************************
 625: 0000: \***
 626: 0000: \***  Domains: (only AF_INET is valid)
 627: 0000: \***  AF_UNSPEC       0               unspecified
 628: 0000: \***  AF_UNIX         1               local to host (pipes, portals)
 629: 0000: \***  AF_INET         2               internetwork: UDP, TCP, etc.
 630: 0000: \***  AF_IMPLINK      3               arpanet imp addresses
 631: 0000: \***  AF_PUP          4               pup protocols: e.g. BSP
 632: 0000: \***  AF_CHAOS        5               mit CHAOS protocols
 633: 0000: \***  AF_NS           6               XEROX NS protocols
 634: 0000: \***  AF_NBS          7               nbs protocols
 635: 0000: \***  AF_ECMA         8               european computer manufacturers
 636: 0000: \***  AF_DATAKIT      9               datakit protocols
 637: 0000: \***  AF_CCITT        10              CCITT protocols, X.25 etc
 638: 0000: \***  AF_SNA          11              IBM SNA
 639: 0000: \***  AF_DECnet       12              DECnet
 640: 0000: \***  AF_DLI          13              Direct data link interface
 641: 0000: \***  AF_LAT          14              LAT
 642: 0000: \***  AF_HYLINK       15              NSC Hyperchannel
 643: 0000: \***  AF_APPLETALK    16              Apple Talk
 644: 0000: \***
 645: 0000: \***  Valid types:
 646: 0000: \***  SOCK_STREAM     1               stream socket
 647: 0000: \***  SOCK_DGRAM      2               datagram socket
 648: 0000: \***  SOCK_RAW        3               raw-protocol interface
 649: 0000: \***  SOCK_RDM        4               reliably-delivered message
 650: 0000: \***  SOCK_SEQPACKET  5               sequenced packet stream
 651: 0000: 
 652: 0000: \*******************************************************************************
 653: 0000: 
 654: 0000: FUNCTION SOCK.SOCKET(DOMAIN%, TYPE%, PROTOCOL%) EXTERNAL
 655: 0000:     INTEGER*2 SOCK.SOCKET
 656: 0000:     INTEGER*2 DOMAIN%
 657: 0000:     INTEGER*2 TYPE%
 658: 0000:     INTEGER*2 PROTOCOL%
 659: 0000: END FUNCTION
 660: 0000: 
 661: 0000: \*******************************************************************************
 662: 0000: \***   SOCK.BIND
 663: 0000: \***   Bind to a particular port number
 664: 0000: \***   NOTE: Address is always set to INADDR_ANY in this implementation
 665: 0000: \*******************************************************************************
 666: 0000: 
 667: 0000: FUNCTION SOCK.BIND(HANDLE%, PORT%) EXTERNAL
 668: 0000:     STRING SOCKADDR.IN$
 669: 0000:     INTEGER*4 PORT%
 670: 0000:     INTEGER*2 HANDLE%
 671: 0000:     INTEGER*2 SOCK.BIND
 672: 0000: END FUNCTION
 673: 0000: 
 674: 0000: \*******************************************************************************
 675: 0000: \***   SOCK.CONNECT
 676: 0000: \***   Connect to a remote host
 677: 0000: \*******************************************************************************
 678: 0000: 
 679: 0000: FUNCTION SOCK.CONNECT(HANDLE%, IP.ADDRESS$, PORT%) EXTERNAL
 680: 0000:     STRING IP.ADDRESS$
 681: 0000:     INTEGER*4 PORT%
 682: 0000:     INTEGER*2 HANDLE%
 683: 0000:     INTEGER*2 SOCK.CONNECT
 684: 0000: END FUNCTION
 685: 0000: 
 686: 0000: \*******************************************************************************
 687: 0000: \***   SOCK.LISTEN
 688: 0000: \***   This call completes the binding necessary for a socket and creates a 
 689: 0000: \***   connection request queue for incoming requests.
 690: 0000: \*******************************************************************************
 691: 0000: 
 692: 0000: FUNCTION SOCK.LISTEN(HANDLE%, BACKLOG%) EXTERNAL
 693: 0000:     INTEGER*2 SOCK.LISTEN
 694: 0000:     INTEGER*2 HANDLE%
 695: 0000:     INTEGER*2 BACKLOG%
 696: 0000: END FUNCTION
 697: 0000: 
 698: 0000: \*******************************************************************************
 699: 0000: \***   SOCK.ACCEPT
 700: 0000: \***   Accepts a TCP connection request from a remote host.
 701: 0000: \*******************************************************************************
 702: 0000: 
 703: 0000: SUB SOCK.ACCEPT(MY.HANDLE%, CLIENT.HANDLE%, CLIENT.IP%, CLIENT.PORT%) EXTERNAL
 704: 0000:     INTEGER*4 CLIENT.IP%
 705: 0000:     INTEGER*2 SOCK.ACCEPT
 706: 0000:     INTEGER*2 MY.HANDLE%
 707: 0000:     INTEGER*2 CLIENT.PORT%
 708: 0000: END SUB
 709: 0000: 
 710: 0000: \*******************************************************************************
 711: 0000: \***   SOCK.SEND
 712: 0000: \***   Send a message to the remote host
 713: 0000: \*******************************************************************************
 714: 0000: \***
 715: 0000: \***   Flags:
 716: 0000: \***   MSG_OOB        01h  Sends out-of-band data on sockets that support it.
 717: 0000: \***                       Only SOCK_STREAM sockets created in the AF_INET 
 718: 0000: \***                       address family support out-of-band data.
 719: 0000: \***   MSG_DONTROUTE  04h  The SO_DONTROUTE option is turned on for the duration
 720: 0000: \***                       of the operation. Usually only diagnostic or routing
 721: 0000: \***                       programs use this.
 722: 0000: \***
 723: 0000: \*******************************************************************************
 724: 0000: 
 725: 0000: FUNCTION SOCK.SEND(HANDLE%, MSG$, FLAGS%) EXTERNAL
 726: 0000:     STRING MSG$
 727: 0000:     INTEGER*2 SOCK.SEND
 728: 0000:     INTEGER*2 HANDLE%
 729: 0000:     INTEGER*2 FLAGS%
 730: 0000: END FUNCTION
 731: 0000: 
 732: 0000: \*******************************************************************************
 733: 0000: \***   SOCK.RECV
 734: 0000: \***   Receive a message from the remote host
 735: 0000: \*******************************************************************************
 736: 0000: \***
 737: 0000: \***   Flags:
 738: 0000: \***   MSG_OOB        01h  Sends out-of-band data on sockets that support it.
 739: 0000: \***                       Only SOCK_STREAM sockets created in the AF_INET 
 740: 0000: \***                       address family support out-of-band data.
 741: 0000: \***   MSG_PEEK       02h  Peeks at the data present on the socket; the data is 
 742: 0000: \***                       returned but not consumed, so that a later receive
 743: 0000: \***                       operation sees the same data.
 744: 0000: \***
 745: 0000: \***   Returns:
 746: 0000: \***   0   : Good return code. The returned string's length indicates the actual
 747: 0000: \***         number of bytes read. If the returned string is null, then the 
 748: 0000: \***         remote session has closed the socket.
 749: 0000: \***   -ve : Error code
 750: 0000: \***
 751: 0000: \*******************************************************************************
 752: 0000: 
 753: 0000: SUB SOCK.RECV(HANDLE%, MSG$, FLAGS%, RC%) EXTERNAL
 754: 0000:     STRING MSG$
 755: 0000:     INTEGER*2 RC%
 756: 0000:     INTEGER*2 HANDLE%
 757: 0000:     INTEGER*2 FLAGS%
 758: 0000: END SUB
 759: 0000: 
 760: 0000: \*******************************************************************************
 761: 0000: \***   SOCK.CLOSE
 762: 0000: \***   Close a socket
 763: 0000: \*******************************************************************************
 764: 0000: 
 765: 0000: FUNCTION SOCK.CLOSE(HANDLE%) EXTERNAL
 766: 0000:     INTEGER*2 HANDLE%
 767: 0000:     INTEGER*2 SOCK.CLOSE
 768: 0000: END FUNCTION
 769: 0000: 
 770: 0000: 
 771: 0000: \*******************************************************************************
 772: 0000: \***   SOCK.ABORT
 773: 0000: \***   Abort a socket
 774: 0000: \*******************************************************************************
 775: 0000: 
 776: 0000: FUNCTION SOCK.ABORT(HANDLE%) EXTERNAL
 777: 0000:     INTEGER*2 HANDLE%
 778: 0000:     INTEGER*2 SOCK.ABORT
 779: 0000: END FUNCTION
 780: 0000: 
 781: 0000: \*******************************************************************************
 782: 0000: \***   SOCK.CLEANUP
 783: 0000: \***   Close all known sockets
 784: 0000: \*******************************************************************************
 785: 0000: 
 786: 0000: FUNCTION SOCK.CLEANUP EXTERNAL
 787: 0000:     INTEGER*2 SOCK.CLEANUP
 788: 0000: END FUNCTION
 789: 0000: 
 790: 0000:     
 791: 0000: \*******************************************************************************
 792: 0000: \***   SOCK.IOCTL
 793: 0000: \***   performs a special operation on a socket
 794: 0000: \*******************************************************************************
 795: 0000: \***
 796: 0000: \***   FIOASYNC (667Fh)   Sets or clears asynchronous input-output for a socket.
 797: 0000: \***   data is a pointer to an integer. If the integer is 0, asynchronous 
 798: 0000: \***   input-output on the socket is cleared. Otherwise, the socket is set for
 799: 0000: \***   asynchronous input-output.
 800: 0000: \***
 801: 0000: \***   FIONBIO (667Eh)    Sets or clears nonblocking input-output for a socket.
 802: 0000: \***   data is a pointer to an integer. If the integer is 0, nonblocking 
 803: 0000: \***   input-output on the socket is cleared. Otherwise, the socket is set for
 804: 0000: \***   nonblocking input-output.
 805: 0000: \***
 806: 0000: \***   FIONREAD (667Dh)   Gets the number of immediately readable bytes for the
 807: 0000: \***   socket. data is a pointer to an integer. Sets the value of the integer to
 808: 0000: \***   the number of immediately readable characters for the socket.
 809: 0000: \***
 810: 0000: \***   SIOCADDRT (7300h)  Adds a routing table entry. data is a pointer to a
 811: 0000: \***   rtentry structure, as defined in <NET\ROUTE.H>. The routing table entry,
 812: 0000: \***   passed as an argument, is added to the routing tables.
 813: 0000: \***
 814: 0000: \***   SIOCATMARK (7301h) Queries whether the current location in the data input
 815: 0000: \***   is pointing to out-of-band data. data is a pointer to an integer. Sets 
 816: 0000: \***   the argument to 1 if the socket points to a mark in the data stream for
 817: 0000: \***   out-of-band data. Otherwise, sets the argument to 0.
 818: 0000: \***
 819: 0000: \***   SIOCDARP (7302h)   Deletes an arp table entry. data is a pointer to a
 820: 0000: \***   arpreq as defined in <NET\IF_ARP.H>. The arp table entry passed as an
 821: 0000: \***   argument is deleted from the arp tables, if it exists. SIOCDELRT Deletes
 822: 0000: \***   a routing table entry. data is a pointer to a rtentry structure, as
 823: 0000: \***   defined in <NET\ROUTE.H>. If it exists, the routing table entry passed as
 824: 0000: \***   an argument is deleted from the routing tables.
 825: 0000: \***
 826: 0000: \***   SIOCGARP (7303h)   Gets the arp table entries. data is a pointer to an
 827: 0000: \***   arpreq, as defined in <NET\IF_ARP.H>. The arp table entry passed as an
 828: 0000: \***   argument is returned from the arp tables if it exists. SIOCGIFADDR Gets
 829: 0000: \***   the network interface address. data is a pointer to an ifreq structure,
 830: 0000: \***   as defined in <NET\IF.H>. The interface address is returned in the
 831: 0000: \***   argument.
 832: 0000: \***
 833: 0000: \***   SIOCGIFBRDADDR (7304h) Gets the network interface broadcast address. data
 834: 0000: \***   is a pointer to an ifreq structure, as defined in <NET\IF.H>. The
 835: 0000: \***   interface broadcast address is returned in the argument.
 836: 0000: \***
 837: 0000: \***   SIOCGIFCONF (7305h) Gets the network interface configuration. data is a 
 838: 0000: \***   pointer to an ifconf structure, as defined in <NET\IF.H>. The interface 
 839: 0000: \***   configuration is returned in the argument.
 840: 0000: \***
 841: 0000: \***   SIOCGIFDSTADDR (7306h) Gets the network interface destination address.
 842: 0000: \***   data is a pointer to an ifreq structure, as defined in <NET\IF.H>. The 
 843: 0000: \***   interface destination (point-to-point) address is returned in the
 844: 0000: \***   argument.
 845: 0000: \***
 846: 0000: \***   SIOCGIFFLAGS (7307h) Gets the network interface flags. data is a pointer 
 847: 0000: \***   to an ifreq structure, as defined in <NET\IF.H>. The interface flags are 
 848: 0000: \***   returned in the argument.
 849: 0000: \***
 850: 0000: \***   SIOCGIFMETRIC (7308h) Gets the network interface routing metric. data is 
 851: 0000: \***   a pointer to an ifreq structure, as defined in <NET\IF.H>. The interface 
 852: 0000: \***   routing metric is returned in the argument.
 853: 0000: \***   
 854: 0000: \***   SIOCGIFNETMASK (7309h) Gets the network interface network mask. data is a
 855: 0000: \***   pointer to an ifreq structure, as defined in <NET\IF.H>. The interface
 856: 0000: \***   network mask is returned in the argument.
 857: 0000: \***
 858: 0000: \***   SIOCSARP           Sets an arp table entry. data is a pointer to an 
 859: 0000: \***   arpreq as defined in <NET\IF_ARP.H>. The arp table entry passed as an
 860: 0000: \***   argument is added to the arp tables.
 861: 0000: \***
 862: 0000: \***   SIOCSIFADDR        Sets the network interface address. data is a pointer
 863: 0000: \***   to an ifreq structure, as defined in <NET\IF.H>. Sets the interface 
 864: 0000: \***   address to the value passed in the argument.
 865: 0000: \***
 866: 0000: \***   SIOCSIFBRDADDR     Sets the network interface broadcast address. data is
 867: 0000: \***   a pointer to an ifreq structure, as defined in <NET\IF.H>. Sets the 
 868: 0000: \***   interface broadcast address to the value passed in the argument.
 869: 0000: \***
 870: 0000: \***   SIOCSIFDSTADDR     Sets the network interface destination address. data 
 871: 0000: \***   is a pointer to an ifreq structure, as defined in <NET\IF.H>. Sets the 
 872: 0000: \***   interface destination (point-to-point) address to the value passed in the
 873: 0000: \***   argument.
 874: 0000: \***
 875: 0000: \***   SIOCSIFFLAGS       Sets the network interface flags. data is a pointer to 
 876: 0000: \***   an ifreq structure, as defined in <NET\IF.H>. Sets the interface flags to
 877: 0000: \***   the values passed in the argument.
 878: 0000: \***
 879: 0000: \***   SIOCSIFMETRIC      Sets the network interface routing metric. data is a 
 880: 0000: \***   pointer to an ifreq structure, as defined in <NET\IF.H>. Sets the 
 881: 0000: \***   interface routing metric to the value passed in the argument.
 882: 0000: \***
 883: 0000: \***   SIOCSIFNETMASK     Sets the network interface network mask. data is a 
 884: 0000: \***   pointer to an ifreq structure, as defined in <NET\IF.H>. Sets the 
 885: 0000: \***   interface network mask to the value passed in the argument.
 886: 0000: \***
 887: 0000: \*******************************************************************************
 888: 0000: 
 889: 0000: FUNCTION SOCK.IOCTL(HANDLE%, CMD%, DATA$) EXTERNAL
 890: 0000:     STRING DATA$
 891: 0000:     INTEGER*2 HANDLE%
 892: 0000:     INTEGER*2 SOCK.IOCTL
 893: 0000:     INTEGER*2 CMD%
 894: 0000: END FUNCTION
 895: 0000: 
 896: 0000: \*******************************************************************************
 897: 0000: \***   SOCK.DONT.BLOCK
 898: 0000: \***   User friendly entry point to set up non-blocking mode
 899: 0000: \*******************************************************************************
 900: 0000: 
 901: 0000: FUNCTION SOCK.DONT.BLOCK(HANDLE%) EXTERNAL
 902: 0000:     INTEGER*2 SOCK.DONT.BLOCK
 903: 0000:     INTEGER*2 HANDLE%
 904: 0000: END FUNCTION
 905: 0000:     
 906: 0000:     
 907: 0000: \*******************************************************************************
 908: 0000: \***   SOCK.SELECT
 909: 0000: \***   Monitor read, write, and exception status on a group of sockets.
 910: 0000: \***   Timeout is in milliseconds.
 911: 0000: \*******************************************************************************
 912: 0000: \***
 913: 0000: \***   Returns the number of ready sockets. The value -1 indicates an error, and
 914: 0000: \***   the value 0 indicates an expired time limit. If the return value is 
 915: 0000: \***   greater than 0, the socket numbers in s that were not ready are set to -1
 916: 0000: \***
 917: 0000: \*******************************************************************************
 918: 0000: 
 919: 0000: SUB SOCK.SELECT(HANDLE.LIST$, NUM.READ.SOCKS%, NUM.WRITE.SOCKS%, \
 920: 0000:                 NUM.EXCPT.SOCKS%, TIMEOUT%, RETURN.RC%) EXTERNAL
 921: 0000:     STRING HANDLE.LIST$
 922: 0000:     INTEGER*4 TIMEOUT%
 923: 0000:     INTEGER*2 NUM.READ.SOCKS%
 924: 0000:     INTEGER*2 NUM.WRITE.SOCKS%
 925: 0000:     INTEGER*2 NUM.EXCPT.SOCKS%
 926: 0000:     INTEGER*2 RETURN.RC%
 927: 0000: END SUB
 928: 0000: 
 929: 0000: %INCLUDE SOPTSEXT.J86       ! SOPTS
 930: 0000: \*******************************************************************************
 931: 0000: \***                                                                         ***
 932: 0000: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE STORE OPTIONS FILE           ***
 933: 0000: \***                                                                         ***
 934: 0000: \***                     REFERENCE : SOPTSEXT.J86                            ***
 935: 0000: \***                                                                         ***
 936: 0000: \***      Version A      Stuart William McConnachie      19th June 1995      ***
 937: 0000: \***                                                                         ***
 938: 0000: \*******************************************************************************
 939: 0000: 
 940: 0000:       FUNCTION SOPTS.SET EXTERNAL
 941: 0000:       END FUNCTION
 942: 0000:       
 943: 0000:       FUNCTION READ.SOPTS EXTERNAL
 944: 0000:          INTEGER*2 READ.SOPTS
 945: 0000:       END FUNCTION
 946: 0000: 
 947: 0000:       FUNCTION WRITE.SOPTS EXTERNAL
 948: 0000:          INTEGER*2 WRITE.SOPTS
 949: 0000:       END FUNCTION
 950: 0000: 
 951: 0000: %INCLUDE DECCFEXT.J86       ! DEC Configuration file
 952: 0000: \*******************************************************************************
 953: 0000: \***                                                                         ***
 954: 0000: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE DEC CONFIGURATION FILE       ***
 955: 0000: \***                                                                         ***
 956: 0000: \***                     REFERENCE : DECCFEXT.J86                            ***
 957: 0000: \***                                                                         ***
 958: 0000: \***      Version A      Mark Goode      20th October 2010                   ***
 959: 0000: \***                                                                         ***
 960: 0000: \*******************************************************************************
 961: 0000: 
 962: 0000:       FUNCTION DECCF.SET EXTERNAL
 963: 0000:       END FUNCTION
 964: 0000:       
 965: 0000:       FUNCTION READ.DECCF EXTERNAL
 966: 0000:          INTEGER*2 READ.DECCF
 967: 0000:       END FUNCTION
 968: 0000: 
 969: 0000:       FUNCTION WRITE.DECCF EXTERNAL
 970: 0000:          INTEGER*2 WRITE.DECCF
 971: 0000:       END FUNCTION
 972: 0000: 
 973: 0000: %INCLUDE DECAPEXT.J86       ! Daily DEC API log file 
 974: 0000: \*******************************************************************************
 975: 0000: \***                                                                         ***
 976: 0000: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE DAILY DEC API LOG FILE       ***
 977: 0000: \***                                                                         ***
 978: 0000: \***                     REFERENCE : DECAPEXT.J86                            ***
 979: 0000: \***                                                                         ***
 980: 0000: \***      Version A      Mark Goode      20th October 2010                   ***
 981: 0000: \***                                                                         ***
 982: 0000: \*******************************************************************************
 983: 0000: 
 984: 0000:       FUNCTION DECAP.SET EXTERNAL
 985: 0000:       END FUNCTION
 986: 0000:       
 987: 0000:       FUNCTION READ.DECAP EXTERNAL
 988: 0000:          INTEGER*2 READ.DECAP
 989: 0000:       END FUNCTION
 990: 0000: 
 991: 0000:       FUNCTION WRITE.DECAP EXTERNAL
 992: 0000:          INTEGER*2 WRITE.DECAP
 993: 0000:       END FUNCTION
 994: 0000: 
 995: 0000: %INCLUDE DQEXT.J86          ! DQ queue files
 996: 0000: \*******************************************************************************
 997: 0000: \***                                                                         ***
 998: 0000: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE DQ QUEUE FILE                ***
 999: 0000: \***                                                                         ***
1000: 0000: \***                     REFERENCE : DQEXT.J86                               ***
1001: 0000: \***                                                                         ***
1002: 0000: \***      Version A      Mark Goode      20th October 2010                   ***
1003: 0000: \***                                                                         ***
1004: 0000: \*******************************************************************************
1005: 0000: 
1006: 0000:       FUNCTION DQ.SET EXTERNAL
1007: 0000:       END FUNCTION
1008: 0000:       
1009: 0000:       FUNCTION READ.DQ EXTERNAL
1010: 0000:          INTEGER*2 READ.DQ
1011: 0000:       END FUNCTION
1012: 0000: 
1013: 0000:       FUNCTION WRITE.MATRIX.DQ EXTERNAL
1014: 0000:          INTEGER*2 WRITE.DQ
1015: 0000:       END FUNCTION
1016: 0000: 
1017: 0000: %INCLUDE SERVLEXT.J86       ! Service events log files      ! BMG
1018: 0000: \*******************************************************************************
1019: 0000: \***                                                                         ***
1020: 0000: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE SERVICE LOG EVENT FILE       ***
1021: 0000: \***                                                                         ***
1022: 0000: \***                     REFERENCE : SERVLEXT.J86                            ***
1023: 0000: \***                                                                         ***
1024: 0000: \***      Version A      Mark Goode      31st January 2011                   ***
1025: 0000: \***                                                                         ***
1026: 0000: \*******************************************************************************
1027: 0000: 
1028: 0000:       FUNCTION SERVL.SET EXTERNAL
1029: 0000:       END FUNCTION
1030: 0000:       
1031: 0000:       FUNCTION READ.SERVL EXTERNAL
1032: 0000:          INTEGER*2 READ.SERVL
1033: 0000:       END FUNCTION
1034: 0000: 
1035: 0000:       FUNCTION WRITE.MATRIX.SERVL EXTERNAL
1036: 0000:          INTEGER*2 WRITE.MATRIX.SERVL
1037: 0000:       END FUNCTION
1038: 0000: 
1039: 0000:       FUNCTION WRITE.SERVL EXTERNAL
1040: 0000:          INTEGER*2 WRITE.SERVL
1041: 0000:       END FUNCTION
1042: 0000: 
1043: 0000: %INCLUDE ADXSERVE.J86       ! ADXSERVE FUNCTION
1044: 0000: \******************************************************************************
1045: 0000: \******************************************************************************
1046: 0000: \***                                                                        ***
1047: 0000: \***    %INCLUDE FOR FUNCTION ADXSERVE (an I.B.M. system function)          ***
1048: 0000: \***                                                                        ***
1049: 0000: \***         AUTHOR        :  Bruce Scriver                                 ***
1050: 0000: \***                                                                        ***
1051: 0000: \***         DATE WRITTEN  :  14th March 1986                               ***
1052: 0000: \***                                                                        ***
1053: 0000: \***         DATE OF LAST REVISION  - 14th March 1986                       ***
1054: 0000: \***                                                                        ***
1055: 0000: \***                                                                        ***
1056: 0000: \******************************************************************************
1057: 0000: \******************************************************************************
1058: 0000: 
1059: 0000:    SUB ADXSERVE (RETURN.CODE%,                                                \
1060: 0000:                  ADX.FUNCTION%,                                               \
1061: 0000:                  ADX.PARM.1%,                                                 \
1062: 0000:                  ADX.PARM.2$)                                                 \
1063: 0000:    EXTERNAL
1064: 0000:   
1065: 0000:       STRING     ADX.PARM.2$
1066: 0000: 
1067: 0000:       INTEGER*2  ADX.FUNCTION%,                                               \
1068: 0000:                  ADX.PARM.1%
1069: 0000: 
1070: 0000:       INTEGER*4  RETURN.CODE%                                                 \
1071: 0000: 
1072: 0000:    END SUB     
1073: 0000: 
1074: 0000: %INCLUDE ADXFILE.J86        ! ADXFILES FUNCTION             ! DMG
1075: 0000: \******************************************************************************
1076: 0000: \******************************************************************************
1077: 0000: \***                                                                        ***
1078: 0000: \***   %INCLUDE FOR FUNCTION ADXFILES (an I.B.M. system function)           ***
1079: 0000: \***                                                                        ***
1080: 0000: \***         AUTHOR        :  Paul Bowers                                   ***
1081: 0000: \***                                                                        ***
1082: 0000: \***         DATE WRITTEN  :   5th May 1989                                 ***
1083: 0000: \***                                                                        ***
1084: 0000: \***         DATE OF LAST REVISION  -  5TH May 1989                         ***
1085: 0000: \***                                                                        ***
1086: 0000: \***    VERSION B       STUART WILLIAM MCCONNACHIE      3RD JULY 2004       ***
1087: 0000: \***    The third parameter is an integer, NOT a string value!              ***
1088: 0000: \***    The return code is a 4 byte integer (not a two byte)!               ***
1089: 0000: \***                                                                        ***
1090: 0000: \******************************************************************************
1091: 0000: \******************************************************************************
1092: 0000: 
1093: 0000:    SUB ADXFILES (RETURN.CODE%,                                                \
1094: 0000:                  ADX.FUNCTION%,                                               \
1095: 0000:                  ADX.PARM.1%,                                                 \
1096: 0000:                  ADX.PARM.1$)                                                 \
1097: 0000:    EXTERNAL
1098: 0000:   
1099: 0000:       STRING     ADX.PARM.2$                                                  !BSWM
1100: 0000: 
1101: 0000:       INTEGER*4  RETURN.CODE%                                                 !BSWM
1102: 0000:       
1103: 0000:       INTEGER*2  ADX.FUNCTION%                                                !BSWM
1104: 0000:       INTEGER*2  ADX.PARM.1%                                                  !BSWM
1105: 0000: 
1106: 0000: 
1107: 0000:    END SUB     
1108: 0000: 
1109: 0000: !%INCLUDE ERRNH.J86                                         ! KMW
1110: 0000:                                                             ! KMW
1111: 0000: !*********************************************************  ! KMW
1112: 0000: ! This function coverts the contents of ERRN to a four   *  ! KMW
1113: 0000: ! byte hex string.                                       *  ! KMW
1114: 0000: ! This is accomplished by adding x'30' to each nibble,   *  ! KMW
1115: 0000: ! building a string, and packing the results.            *  ! KMW
1116: 0000: ! Example ERRN = 80abcdefh, errnhex$ = 80abcdef          *  ! KMW
1117: 0000: !*********************************************************  ! KMW
1118: 0000: ! NOTE: Local copy of existing public function to avoid  *  ! KMW
1119: 0000: ! an additional depandancy for the DEC API               *  ! KMW
1120: 0000: !*********************************************************  ! KMW
1121: 0000: FUNCTION ERRNHEX$                                           ! KMW
1122: 0014: STRING ERRNHEX$,ERRFX$                                      ! KMW
1123: 0014: INTEGER*4 HX                                                ! KMW
1124: 0014: INTEGER*2 S,THE.SUM                                         ! KMW
1125: 0014: ERRFX$ = ""                                                 ! KMW
1126: 0021:  HX = ERRN                                                  ! KMW
1127: 0033: FOR S = 28 TO 0 STEP -4                                     ! KMW
1128: 003b: !                                                           ! KMW
1129: 003b:    ERRFX$ = ERRFX$ + CHR$((SHIFT(HX,S) AND 000Fh) + 48)     ! KMW
1130: 008f: NEXT S                                                      ! KMW
1131: 009f:    ERRNHEX$ = PACK$ (ERRFX$)                                ! KMW
1132: 00b6: END FUNCTION                                                ! KMW
1133: 00c7: 
1134: 00c7: \*****************************************************************************
1135: 00c7: \***
1136: 00c7: \***    FUCTION CONTTIME (START.TIME, PARMBLK$, TIMEDATE.TABLE$) EXTERNAL
1137: 00c7: \***
1138: 00c7: \***    IBM assembler routine to obtain system time from Flex OS.
1139: 00c7: \***
1140: 00c7: \***    Initialise the following variables, once only, at start of program:
1141: 00c7: \***    PARAMBLK$ = STRING$(20, CHR$(00H))
1142: 00c7: \***    TIMEDATE.TABLE$ = STRING$(12, CHR$(00H))
1143: 00c7: \***
1144: 00c7: \***    Then each call to CONTTIME returns a time in milli-seconds.  The time
1145: 00c7: \***    returned is the time since midnight, *LESS* START.TIME.
1146: 00c7: \***    By passing in 0 as an initial value the current time can be obtained
1147: 00c7: \***    as a starting point.  Then this value can be passed in to subsequent
1148: 00c7: \***    calls to obtain an elapsed time.
1149: 00c7: \***
1150: 00c7: \***    The actual values returned in TIME.DATE.TABLE$ may be of interest:
1151: 00c7: \***
1152: 00c7: \***    00 - Year LSB       CCH 
1153: 00c7: \***    01 - Year MSB       07H = 1996    (i.e. hex, NOT packed)
1154: 00c7: \***    02 - Month          0AH = October (i.e. hex, NOT packed)
1155: 00c7: \***    03 - Day            12H = 18th    (i.e. hex, NOT packed)
1156: 00c7: \***    04 - Time LSB
1157: 00c7: \***    05 - Time           Milliseconds since midnight
1158: 00c7: \***    06 - Time
1159: 00c7: \***    07 - Time MSB
1160: 00c7: \***    08 - Time Zone LSB  Minutes from Universal Coordinated Time!
1161: 00c7: \***    09 - Time Zone MSB
1162: 00c7: \***    0A - Day of Week    00H = Sunday ... 06H = Saturday
1163: 00c7: \***    0B - 00H
1164: 00c7: \***
1165: 00c7: \***
1166: 00c7: 
1167: 00c7: 
1168: 00c7: FUNCTION CONTTIME (START.TIME, PARMBLK$, TIMEDATE.TABLE$) EXTERNAL
1169: 00c7:     STRING PARMBLK$, TIMEDATE.TABLE$
1170: 00c7:     INTEGER*4 START.TIME, CONTTIME
1171: 00c7: END FUNCTION
1172: 00c7: 
1173: 00c7: \*****************************************************************************
1174: 00c7: \***
1175: 00c7: \***  routines
1176: 00c7: \***
1177: 00c7: \*****************************************************************************
1178: 00c7: \*****************************************************************************
1179: 00c7: \***
1180: 00c7: \***    MILLI.TIME% function
1181: 00c7: \***    Sets MILLI.TIME% to conroller time since midnight in milli-seconds.
1182: 00c7: \***    Integer format.
1183: 00c7: \***
1184: 00c7: \***..........................................................................
1185: 00c7: 
1186: 00c7: FUNCTION MILLI.TIME%
1187: 00db: 
1188: 00db:     INTEGER*4 MILLI.TIME%
1189: 00db:     STRING CT.PARAMBLK$, CT.TIMEDATE.TABLE$
1190: 00db: 
1191: 00db:     CT.PARAMBLK$       = STRING$(20, CHR$(00H)) 
1192: 00f2:     CT.TIMEDATE.TABLE$ = STRING$(12, CHR$(00H))
1193: 0109: 
1194: 0109:     MILLI.TIME% = CONTTIME(0, CT.PARAMBLK$, CT.TIMEDATE.TABLE$)
1195: 0137: 
1196: 0137: END FUNCTION
1197: 0149: 
1198: 0149: \*****************************************************************************
1199: 0149: \***
1200: 0149: \***    MILLI.TIME% function
1201: 0149: \***    Sets MILLI.TIME% to conroller time since midnight in milli-seconds.
1202: 0149: \***    Integer format.
1203: 0149: \***
1204: 0149: \***..........................................................................
1205: 0149: 
1206: 0149: FUNCTION TRIM.STRING(TEXT$)
1207: 0162: 
1208: 0162:     STRING TRIM.STRING
1209: 0162:     STRING TEXT$
1210: 0162:     INTEGER*2 LEN%
1211: 0162: 
1212: 0162:     LEN% = LEN(TEXT$)
1213: 0172: 
1214: 0172:     WHILE 1=1
1215: 0174: 
1216: 0174:      IF MID$(TEXT$,LEN%,1) = " " THEN BEGIN
1217: 019e:         TEXT$ = LEFT$(TEXT$,LEN%-1)
1218: 01ba:         LEN% = LEN% - 1
1219: 01c0:      ENDIF ELSE BEGIN
1220: 01c0:         GOTO DONE
1221: 01c2:      ENDIF
1222: 01c2: 
1223: 01c2:     WEND
1224: 01c4: 
1225: 01c4: DONE:
1226: 01c4:      TRIM.STRING = TEXT$
1227: 01d4: 
1228: 01d4: END FUNCTION
1229: 01ea: 
1230: 01ea: \***************************************************************************! LMW
1231: 01ea: \***    DAY.OF.WEEK                                                         ! LMW
1232: 01ea: \***************************************************************************! LMW
1233: 01ea: \***    Uses Zellers formula to calculate the day of the week               ! LMW
1234: 01ea: \***    for the date specified in the function parameter (in YYMMDD format) ! LMW
1235: 01ea: \***                                                                        ! LMW
1236: 01ea: \***    The basic mathematical formula is as follows:                       ! LMW
1237: 01ea: \***                                                                        ! LMW
1238: 01ea: \***        (     [ (m+1)26 ]       [ K ]   [ J ]      )                    ! LMW
1239: 01ea: \***    h = ( q + [---------] + K + [---] + [---] + 5J ) MOD 7              ! LMW
1240: 01ea: \***        (     [   10    ]       [ 4 ]   [ 4 ]      )                    ! LMW
1241: 01ea: \***                                                                        ! LMW
1242: 01ea: \***    where h = day of the week (0 = Saturday,...,6 = Friday)             ! LMW
1243: 01ea: \***          q = day of month                                              ! LMW
1244: 01ea: \***          m = month (3 = Mar, 4 = Apr,...,13 = Jan, 14 = Feb)           ! LMW
1245: 01ea: \***          K = the year of the century (e.g. if year 1985, K = 85)       ! LMW
1246: 01ea: \***          J = the century (e.g. if year is 1985, J = 19)                ! LMW
1247: 01ea: \***                                                                        ! LMW
1248: 01ea: \***    Note: There are a number of 'fudges' required for year 2000         ! LMW
1249: 01ea: \***          and also the months of January and February!                  ! LMW
1250: 01ea: \***                                                                        ! LMW
1251: 01ea: \***    The function returns an integer value where:                        ! LMW
1252: 01ea: \***        0 = Sun, 1 = Mon, 2 = Tue, 3 = Wed, 4 = Thu, 5 = Fri, 6 = Sat   ! LMW
1253: 01ea: \***                                                                        ! LMW
1254: 01ea: \************************************************************************** ! LMW
1255: 01ea: FUNCTION DAY.OF.WEEK(D$)                                                    ! LMW
1256: 0203:                                                                             ! LMW
1257: 0203:     STRING    D$                                                            ! LMW
1258: 0203:     STRING    YEAR$                                                         ! LMW
1259: 0203:     STRING    MONTH$                                                        ! LMW
1260: 0203:     STRING    DAY$                                                          ! LMW
1261: 0203:                                                                             ! LMW
1262: 0203:     INTEGER*1 DAY.OF.WEEK                                                   ! LMW
1263: 0203:     INTEGER*4 Q,D,H,J,K,Y,M,X                                               ! LMW
1264: 0203:     INTEGER*4 N1,N2,N3,N4,N5,N6                                             ! LMW
1265: 0203:                                                                             ! LMW
1266: 0203:     YEAR$  = LEFT$(D$,2)                                                    ! LMW
1267: 021b:     MONTH$ = MID$(D$,3,2)                                                   ! LMW
1268: 0233:     DAY$   = RIGHT$(D$,2)                                                   ! LMW
1269: 0249:                                                                             ! LMW
1270: 0249:     Y = VAL(YEAR$)                                                          ! LMW
1271: 0263:                                                                             ! LMW
1272: 0263:     ! IF month is January or Feruary                                        ! LMW
1273: 0263:     IF MONTH$ = "01" OR MONTH$ = "02" THEN BEGIN                            ! LMW
1274: 02a7:        Y = Y - 1                                                            ! LMW
1275: 02b8:     ENDIF                                                                   ! LMW
1276: 02b8:                                                                             ! LMW
1277: 02b8:     ! IF we are in the year 2000                                            ! LMW
1278: 02b8:     IF Y < 0 THEN BEGIN                                                     ! LMW
1279: 02c9:         Y = 99                                                              ! LMW
1280: 02d6:         J = 19                                                              ! LMW
1281: 02e5:     ENDIF ELSE BEGIN                                                        ! LMW
1282: 02e5:         ! If date is in current century                                     ! LMW
1283: 02e5:         IF Y < 85 THEN BEGIN                                                ! LMW
1284: 02f6:             J = 20                                                          ! LMW
1285: 0305:         ENDIF ELSE BEGIN                                                    ! LMW
1286: 0305:             J = 19                                                          ! LMW
1287: 0312:         ENDIF                                                               ! LMW
1288: 0312:     ENDIF                                                                   ! LMW
1289: 0312:                                                                             ! LMW
1290: 0312:     Q = VAL(DAY$)                                                           ! LMW
1291: 032c:     M = MOD((VAL(MONTH$)+9),12)+3                                           ! LMW
1292: 0378:     K = MOD(Y,100)                                                          ! LMW
1293: 0389:                                                                             ! LMW
1294: 0389:     X = 26*(M+1)                                                            ! LMW
1295: 03a5:                                                                             ! LMW
1296: 03a5:     N1 = Q                                                                  ! LMW
1297: 03b2:     N2 = INT(X/10)                                                          ! LMW
1298: 03e3:     N3 = K                                                                  ! LMW
1299: 03f0:     N4 = INT(K/4)                                                           ! LMW
1300: 0421:     N5 = INT(J/4)                                                           ! LMW
1301: 0452:     N6 = (5*J)                                                              ! LMW
1302: 0463:                                                                             ! LMW
1303: 0463:     X = N1+N2+N3+N4+N5+N6                                                   ! LMW
1304: 04a0:                                                                             ! LMW
1305: 04a0:     ! 0=Sunday..6=Saturday                                                  ! LMW
1306: 04a0:     H = MOD(X+6,7)                                                          ! LMW
1307: 04bc:                                                                             ! LMW
1308: 04bc:     DAY.OF.WEEK = H                                                         ! LMW
1309: 04c6:                                                                             ! LMW
1310: 04c6: END FUNCTION                                                                ! LMW
1311: 04da: 
1312: 04da: \*****************************************************************************
1313: 04da: \***
1314: 04da: \***    DAY function
1315: 04da: \***    Returns day of week.
1316: 04da: \***    00H = Sunday ... 06H = Saturday
1317: 04da: \***
1318: 04da: \***..........................................................................
1319: 04da: 
1320: 04da: FUNCTION DAY$
1321: 04ee: 
1322: 04ee: !!!!INTEGER*4 RC%                                                           ! LMW
1323: 04ee:     STRING  DAY$
1324: 04ee: !!!!STRING CT.PARAMBLK$, CT.TIMEDATE.TABLE$                                 ! LMW
1325: 04ee:     STRING  TODAYS.DATE$                                                    ! LMW
1326: 04ee: 
1327: 04ee: !!!!CT.PARAMBLK$       = STRING$(20, CHR$(00H))                             ! LMW
1328: 04ee: !!!!CT.TIMEDATE.TABLE$ = STRING$(12, CHR$(00H))                             ! LMW
1329: 04ee:                                                                             ! LMW
1330: 04ee: !!!!RC% = CONTTIME(0, CT.PARAMBLK$, CT.TIMEDATE.TABLE$)                     ! LMW
1331: 04ee:                                                                             ! LMW
1332: 04ee: !!!!DAY$ = MID$(CT.TIMEDATE.TABLE$,11,1)                                    ! LMW
1333: 04ee:                                                                             ! LMW
1334: 04ee:     TODAYS.DATE$ = DATE$                                                    ! LMW
1335: 04fc:                                                                             ! LMW
1336: 04fc:     DAY$ = CHR$(DAY.OF.WEEK(TODAYS.DATE$))                                  ! LMW
1337: 051c: 
1338: 051c: END FUNCTION
1339: 052d: 
1340: 052d: \*****************************************************************************
1341: 052d: \***
1342: 052d: \***    HHMMSS.MMM$ function
1343: 052d: \***    Converts time (parmed as milli-seconds since midnight) into 
1344: 052d: \***    an understandable HH:MM:SS.MMM format
1345: 052d: \***
1346: 052d: \***..........................................................................
1347: 052d: 
1348: 052d: FUNCTION HHMMSS.MMM$(VAL%)
1349: 0541: 
1350: 0541:     STRING    HHMMSS.MMM$
1351: 0541:     STRING    WORK$
1352: 0541:     INTEGER*4 VAL%
1353: 0541: 
1354: 0541:     WORK$ = RIGHT$("000" + STR$(MOD(VAL%, 1000)) ,3)
1355: 0587:     VAL% = VAL% / 1000
1356: 059a: 
1357: 059a:     WORK$ = RIGHT$("00" + STR$(MOD(VAL%, 60)) ,2) + "." + WORK$
1358: 05fa:     VAL% = VAL% / 60
1359: 060d: 
1360: 060d:     WORK$ = RIGHT$("00" + STR$(MOD(VAL%, 60)) ,2) + ":" + WORK$
1361: 066d:     VAL% = VAL% / 60
1362: 0680: 
1363: 0680:     WORK$ = RIGHT$("00" + STR$(VAL%), 2) + ":" + WORK$
1364: 06d6: 
1365: 06d6:     HHMMSS.MMM$ = WORK$
1366: 06e8: 
1367: 06e8: END FUNCTION
1368: 06f9: 
1369: 06f9: \*****************************************************************************
1370: 06f9: \***
1371: 06f9: \***    SOREC156
1372: 06f9: \***   
1373: 06f9: \***    Parser for SOPTS record 156
1374: 06f9: \***
1375: 06f9: \***
1376: 06f9: 
1377: 06f9: 
1378: 06f9: SUB SOREC156(IN$)
1379: 070d: 
1380: 070d:     INTEGER*2 NOS%
1381: 070d:     INTEGER*2 NOS1%
1382: 070d:     STRING    IN$
1383: 070d: 
1384: 070d:     ON ERROR GOTO ABORT.SUB
1385: 071a: 
1386: 071a:     NOS% = 1
1387: 0720:     DEC.PORT% = VAL(LEFT$(IN$, MATCH(",",IN$,NOS%)-1))
1388: 0757:     NOS1% = MATCH(",",IN$,MATCH(",",IN$,NOS%)+1)
1389: 0786:     PRIMARY.IP$ = MID$(IN$, MATCH(",",IN$,1) + 1, (NOS1%-1) - MATCH(",",IN$,MATCH(",",IN$,1)))
1390: 07e8:     NOS%  = MATCH(",",IN$,MATCH(",",IN$,NOS1%)+1)
1391: 0817:     SECONDARY.IP$ = MID$(IN$,MATCH(",",IN$,NOS1%) + 1,(NOS%-1) - MATCH(",",IN$,MATCH(",",IN$,NOS1%)))
1392: 087d:     NOS1% = MATCH(",",IN$,MATCH(",",IN$,NOS%))
1393: 08ab:     DEC.TRANSTATUS  = VAL(MID$(IN$,MATCH(",",IN$,NOS%) + 1,(NOS1%-1) - MATCH(",",IN$,MATCH(",",IN$,1))))
1394: 0913:     NOS%  = MATCH(",",IN$,MATCH(",",IN$,NOS1%)+1)
1395: 0942:     DEC.LOGSTATUS  = VAL(MID$(IN$,MATCH(",",IN$,NOS%) + 1,(NOS1%-1) - MATCH(",",IN$,MATCH(",",IN$,1))))
1396: 09ae:     NOS1%  = MATCH(",",IN$,MATCH(",",IN$,NOS%)+1)
1397: 09dd:     DEC.SOCKET.TIMEOUT% = VAL(MID$(IN$,MATCH(",",IN$,NOS1%) + 1,(NOS%-1) - MATCH(",",IN$,MATCH(",",IN$,1))))
1398: 0a49:     NOS%  = MATCH(",",IN$,MATCH(",",IN$,NOS1%)+1)                                                               ! BMG
1399: 0a78:     DEC.SERVICE.LOG = VAL(MID$(IN$,MATCH(",",IN$,NOS%) + 1,(NOS1%-1) - MATCH(",",IN$,MATCH(",",IN$,1))))        ! BMG
1400: 0ae4:     NOS1%  = MATCH(",",IN$,MATCH(",",IN$,NOS%)+1)
1401: 0b13:     DEC.HOUSEKEEP.TIME% = VAL(MID$(IN$,MATCH(",",IN$,NOS1%) + 1,(NOS%-1) - MATCH(",",IN$,MATCH(",",IN$,1))))    ! EMG
1402: 0b87:     ALTERNATE.IP$       =  SECONDARY.IP$
1403: 0b98: 
1404: 0b98: 
1405: 0b98:     EXIT SUB
1406: 0b9a: 
1407: 0b9a: ABORT.SUB:
1408: 0b9a: 
1409: 0b9a: END SUB
1410: 0ba6: 
1411: 0ba6: \*****************************************************************************                       ! BMG
1412: 0ba6: \***                                                                                                 ! BMG
1413: 0ba6: \***    MESSAGEID.MATCH                                                                              ! BMG
1414: 0ba6: \***                                                                                                 ! BMG
1415: 0ba6: \***    LOGGING                                                                                      ! BMG
1416: 0ba6: \***      TYPE 0 - DEBUG LOGGING                                                                     ! BMG
1417: 0ba6: \***      TYPE 1 - SERVICE EVENT LOGGING                                                             ! BMG
1418: 0ba6: \***..........................................................................                       ! BMG
1419: 0ba6:                                                                                                      ! BMG
1420: 0ba6:  SUB MESSAGEID.MATCH(ARG.MESSAGEID$,SERVICE.EVENT)                                                   ! BMG
1421: 0bba:                                                                                                      ! BMG
1422: 0bba:     STRING TEST.MESSAGE.NAME$                                                                        ! BMG
1423: 0bba:     STRING ARG.MESSAGEID$                                                                            ! BMG
1424: 0bba:     INTEGER*1 SERVICE.EVENT                                                                          ! BMG
1425: 0bba:                                                                                                      ! BMG
1426: 0bba:     TEST.MESSAGE.NAME$ = ""                                                                          ! BMG
1427: 0bc7:     DECCF.MSGNAME$     = ""                                                                          ! BMG
1428: 0bd6:     DECCF.DELIVERY$    = ""                                                                          ! BMG
1429: 0be5:                                                                                                      ! BMG
1430: 0be5:     LOOP% = 0                                                                                        ! BMG
1431: 0beb:     WHILE NOT FOUND !AND DECCONF.RECORD$(LOOP%) <> ""                                                ! BMG
1432: 0bee:                                                                                                      ! BMG
1433: 0bee:         IF MATCH(UCASE$(ARG.MESSAGEID$),UCASE$(DECCONF.RECORD$(LOOP%)),1) > 0 THEN BEGIN             ! BMG
1434: 0c40:            TEST.MESSAGE.NAME$ = MID$(DECCONF.RECORD$(LOOP%),21,30)                                   ! BMG
1435: 0c68:            IF  DQ.ELEMENT% = 0 OR SERVICE.EVENT THEN BEGIN                                           ! BMG
1436: 0c80:                DECCF.MSGNAME$ = TRIM.STRING(TEST.MESSAGE.NAME$) + PIPE$                              ! BMG
1437: 0cad:                MESSAGE.MATCH = NAK                                                                   ! BMG
1438: 0cb3:            ENDIF                                                                                     ! BMG
1439: 0cb3:            IF MATCH(DECCF.MSGNAME$,DQ.ARRAY.RECORD$(0),1) = 0 AND NOT SERVICE.EVENT THEN BEGIN       ! BMG
1440: 0cf1:               MESSAGE.MATCH = ACK                                                                    ! BMG
1441: 0cf7:               DECCF.DELIVERY$ = MID$(DECCONF.RECORD$(LOOP%),54,1)                                    ! BMG
1442: 0d21:               DECCF.MSGNAME$ = TRIM.STRING(TEST.MESSAGE.NAME$) + PIPE$                               ! BMG
1443: 0d4e:               FOUND = ACK                                                                            ! BMG
1444: 0d56:            ENDIF ELSE BEGIN                                                                          ! BMG
1445: 0d56:               MESSAGE.MATCH = ACK                                                                    ! BMG
1446: 0d5c:               FOUND = ACK                                                                            ! BMG
1447: 0d62:            ENDIF                                                                                     ! BMG
1448: 0d64:         ENDIF ELSE BEGIN                                                                             ! BMG
1449: 0d64:            LOOP% = LOOP% + 1                                                                         ! BMG
1450: 0d68:         ENDIF                                                                                        ! BMG
1451: 0d68:                                                                                                      ! BMG
1452: 0d68:     WEND                                                                                             ! BMG
1453: 0d72:                                                                                                      ! BMG
1454: 0d72: END SUB                                                                                              ! BMG
1455: 0d7e: 
1456: 0d7e: \*****************************************************************************
1457: 0d7e: \***
1458: 0d7e: \***    DECAPI.LOG                                                                                   ! BMG
1459: 0d7e: \***
1460: 0d7e: \***    LOGGING                                                                                      ! BMG
1461: 0d7e: \***      TYPE 0 - DEBUG LOGGING                                                                     ! BMG
1462: 0d7e: \***      TYPE 1 - SERVICE EVENT LOGGING                                                             ! BMG
1463: 0d7e: \***
1464: 0d7e: \***..........................................................................                       ! KMW
1465: 0d7e: 
1466: 0d7e: SUB DECAPI.LOG(LOG$,TYPE%)                                                                           ! BMG
1467: 0d92: 
1468: 0d92:     STRING    LOG$
1469: 0d92:     STRING    D$                    
1470: 0d92:     INTEGER*1 DECAPI.LOG
1471: 0d92:     INTEGER*1 RC%    
1472: 0d92:     INTEGER*2 TYPE%                                                                                  ! BMG
1473: 0d92:     INTEGER*4 TIME.CHECK%                                                                            ! BMG
1474: 0d92: 
1475: 0d92:     D$ = RIGHT$(DATE$,2)+"-"+MID$(DATE$,3,2)+"-"+LEFT$(DATE$,2)+" "+HHMMSS.MMM$(MILLI.TIME%)         ! BMG
1476: 0e20:           
1477: 0e20:     IF DEC.LOGSTATUS AND LOG.FILE.OPEN AND TYPE% = 0 THEN BEGIN                                      ! GMG ! BMG
1478: 0e3a:        ! Logging debug data                                                                          ! BMG
1479: 0e3a:        D$ = D$ + " - " + LOG$                                                                        ! BMG
1480: 0e5c:        DECAP.RECORD$ = D$                                                                            ! BMG
1481: 0e6f:        RC% = WRITE.DECAP                                                                             ! BMG
1482: 0e7a:     ENDIF ELSE IF DEC.SERVICE.LOG AND SERVICE.FILE.OPEN AND TYPE% = 1 THEN BEGIN                     ! GMG ! BMG
1483: 0e9e:        ! Logging service event data                                                                  ! GMG
1484: 0e9e:        SERVL.ARRAY.RECORD$(SERVL.ELEMENT%) = D$ + PIPE$ + LOG$                                       ! BMG
1485: 0ed7:        RC% = WRITE.MATRIX.SERVL                                                                      ! BMG
1486: 0edf:        SERVL.ELEMENT% = 0                                                                            ! BMG
1487: 0ee8:        DIM SERVL.ARRAY.RECORD$(1000)                                                                 ! BMG
1488: 0f10:     ENDIF
1489: 0f10: 
1490: 0f10: END SUB
1491: 0f1c: 
1492: 0f1c: \*****************************************************************************
1493: 0f1c: \***
1494: 0f1c: \***    OPEN.DQ
1495: 0f1c: \***   
1496: 0f1c: \***    Open correct DQ file depending on node
1497: 0f1c: \***
1498: 0f1c: \***..........................................................................
1499: 0f1c: 
1500: 0f1c: SUB OPEN.DQ(NAME$)
1501: 0f30: 
1502: 0f30:     STRING NAME$
1503: 0f30:     STRING NODE$
1504: 0f30:     STRING DIST$
1505: 0f30:     STRING TEMP$
1506: 0f30: 
1507: 0f30:    ON ERROR GOTO ABORT.FUNCTION
1508: 0f3d: 
1509: 0f3d:    PROBLEM.DQ = -1
1510: 0f42: 
1511: 0f42: !!!!IF DQ.OPENED THEN BEGIN                                                     ! KMW
1512: 0f42:    CLOSE DQ.SESS.NUM%
1513: 0f4e: !!!!!!!DQ.OPENED = NAK                                                          ! KMW
1514: 0f4e: !!!!ENDIF                                                                       ! KMW
1515: 0f4e: 
1516: 0f4e:     DQ.FILE.NAME$ = NAME$
1517: 0f63: 
1518: 0f63: !!! Remove code which uses logical node and replace with OPEN code              ! MBG
1519: 0f63: !!! below opens the local copy of the file                                      ! MBG
1520: 0f63: !!! IF MATCH("CE",NAME$,1) = 0 THEN BEGIN                                       ! MBG
1521: 0f63: !!!    NODE$ = "ADXLXACN::"                                                     ! MBG
1522: 0f63: !!!    IF END # DQ.SESS.NUM% THEN CREATE.DQ                                     ! MBG
1523: 0f63: !!!    OPEN NODE$ + NAME$ AS DQ.SESS.NUM% NOREAD NODEL APPEND                   ! MBG
1524: 0f63: !!! ENDIF ELSE BEGIN                                                            ! MBG
1525: 0f63: !!!    NODE$ = "ADXLXAAN::"                                                     ! MBG
1526: 0f63: !!!    IF END # DQ.SESS.NUM% THEN CREATE.DQ                                     ! MBG
1527: 0f63: !!!    OPEN NODE$ + NAME$ AS DQ.SESS.NUM% NOREAD NODEL APPEND                   ! MBG
1528: 0f63: !!! ENDIF                                                                       ! MBG
1529: 0f63:     IF END # DQ.SESS.NUM% THEN CREATE.DQ                                        ! MBG
1530: 0f77:     OPEN NAME$ AS DQ.SESS.NUM% NOREAD NODEL APPEND                              ! MBG
1531: 0f96:     GOTO SKIP.DQ                                                                ! MBG
1532: 0f98:      
1533: 0f98:     CREATE.DQ:
1534: 0f98:     CREATE POSFILE NAME$ AS DQ.SESS.NUM% LOCAL                                  ! MBG
1535: 0fb5:     
1536: 0fb5: !!!!IF MATCH("CF",NAME$,1) > 0 THEN BEGIN                                                       ! MBG
1537: 0fb5: !!!!!!!CREATE POSFILE NODE$ + NAME$ AS DQ.SESS.NUM% MIRRORED PERUPDATE                          ! MBG
1538: 0fb5: !!!!!!!CREATE POSFILE NODE$ + LEFT$(NAME$,2) + "CF" + RIGHT$(NAME$,6) AS 80 MIRRORED PERUPDATE  ! KMW
1539: 0fb5: !!!!!!!CLOSE 80                                                                                 ! KMW
1540: 0fb5: !!!!ENDIF ELSE BEGIN
1541: 0fb5: !!!!!!!CREATE POSFILE NODE$ + NAME$ AS DQ.SESS.NUM% COMPOUND PERUPDATE                          ! MBG
1542: 0fb5: !!!!!!!CREATE POSFILE NODE$ + LEFT$(NAME$,2) + "CF" + RIGHT$(NAME$,6) AS 80 COMPOUND PERUPDATE  ! KMW
1543: 0fb5: !!!!!!!CLOSE 80                                                                                 ! KMW
1544: 0fb5: !!!!ENDIF                                                                                       ! MBG
1545: 0fb5: 
1546: 0fb5: SKIP.DQ:
1547: 0fb5: 
1548: 0fb5:     PROBLEM.DQ = 0
1549: 0fba: !!!!DQ.OPENED = ACK                                                             ! KMW
1550: 0fba: 
1551: 0fba: LEAVE.SUB:
1552: 0fba: 
1553: 0fba:     EXIT SUB
1554: 0fbd:     
1555: 0fbd:  ABORT.FUNCTION:
1556: 0fbd: 
1557: 0fbd:     ! We don't care about close errors on the DQ file                           ! KMW
1558: 0fbd:     IF ERRF% = 1003 AND ERR = "CU" THEN RESUME                                  ! KMW
1559: 100c: 
1560: 100c:     IF ERR = "*I" THEN BEGIN
1561: 102a:        PROBLEM.DQ = -1                                                          ! BMG
1562: 1031:     ENDIF ELSE BEGIN
1563: 1031:         PROBLEM.DQ = 0
1564: 1036: !!!!!!!!DQ.OPENED = ACK                                                         ! KMW
1565: 1036:     ENDIF
1566: 1036: 
1567: 1036:     RESUME LEAVE.SUB
1568: 1045:     
1569: 1045: END SUB
1570: 1051: 
1571: 1051: \*****************************************************************************                          ! EMG
1572: 1051: \***                                                                                                    ! EMG
1573: 1051: \***    MESSAGE.ARRAY                                                                                   ! EMG
1574: 1051: \***                                                                                                    ! EMG
1575: 1051: \***    Process latest response and add to message array                                                ! EMG
1576: 1051: \***                                                                                                    ! EMG
1577: 1051: \***..........................................................................                          ! EMG
1578: 1051:                                                                                                         ! EMG
1579: 1051: FUNCTION MESSAGE.ARRAY(DEC.RESPONSE$)                                                                   ! EMG
1580: 106a:                                                                                                         ! EMG
1581: 106a:     STRING    DEC.RESPONSE$                                                                             ! EMG
1582: 106a:     STRING    MESSAGE.ARRAY                                                                             ! EMG
1583: 106a:     STRING    TEMP.MESSAGE.ARRAY$                                                                       ! EMG
1584: 106a:     INTEGER*2 OFFSET%                                                                                   ! EMG
1585: 106a:     INTEGER*2 COUNT%                                                                                    ! EMG
1586: 106a:     INTEGER*2 REMAIN%                                                                                   ! EMG
1587: 106a:     INTEGER*2 LOC%                                                                                      ! EMG
1588: 106a:                                                                                                         ! EMG
1589: 106a:     ON ERROR GOTO ABORT.FUNCTION                                                                        ! EMG
1590: 1077:                                                                                                         ! EMG
1591: 1077:     IF DEC.RESPONSE$ <> "NAK" THEN BEGIN                                                                ! EMG
1592: 108b:                                                                                                         ! EMG
1593: 108b:        ! If found remove late check connection response from DEC.RESPONSE$                              ! FMG
1594: 108b:        IF MATCH(TEST.RESPONSE$,DEC.RESPONSE$,1) THEN BEGIN                                              ! FMG
1595: 10a4:           DEC.RESPONSE$ = RIGHT$(DEC.RESPONSE$,LEN(DEC.RESPONSE$) - LEN(TEST.RESPONSE$))                ! FMG
1596: 10dc:        ENDIF                                                                                            ! FMG
1597: 10dc:        !Add responseS to array                                                                          ! EMG
1598: 10dc:        OFFSET% = 1                                                                                      ! EMG
1599: 10e2:                                                                                                         ! EMG
1600: 10e2:        LOC% = MATCH(CRTLF$,DEC.RESPONSE$,OFFSET%)                                                       ! EMG
1601: 10fc:                                                                                                         ! EMG
1602: 10fc:        WHILE MATCH(CRTLF$,DEC.RESPONSE$,OFFSET%)                                                        ! EMG
1603: 10fe:           SOCKET.MESSAGE.ARRAY$(SOCKET.MESSAGE.COUNT%) = MID$(DEC.RESPONSE$,OFFSET%,LOC% - OFFSET%)     ! EMG
1604: 112b:           SOCKET.MESSAGE.COUNT% = SOCKET.MESSAGE.COUNT% + 1                                             ! EMG
1605: 112f:           OFFSET% = LOC% + 2                                                                            ! EMG
1606: 1138:           LOC% = MATCH(CRTLF$,DEC.RESPONSE$,OFFSET%)                                                    ! EMG
1607: 114f:        WEND                                                                                             ! EMG
1608: 116a:                                                                                                         ! EMG
1609: 116a:     ENDIF                                                                                               ! EMG
1610: 116a:                                                                                                         ! EMG
1611: 116a:     MESSAGE.ARRAY = RIGHT$(SOCKET.MESSAGE.ARRAY$(0),LEN(SOCKET.MESSAGE.ARRAY$(0)) - 8)                  ! EMG
1612: 11ab:     RESPONSE.TIME = LEFT$(SOCKET.MESSAGE.ARRAY$(0),8)                                                   ! EMG
1613: 11d1:                                                                                                         ! EMG
1614: 11d1:     REMAIN% = SOCKET.MESSAGE.COUNT%                                                                     ! EMG
1615: 11d7:                                                                                                         ! EMG
1616: 11d7:     IF SOCKET.MESSAGE.ARRAY$(1) <> "" THEN BEGIN                                                        ! EMG
1617: 11f6:                                                                                                         ! EMG
1618: 11f6:        FOR COUNT% = 0 TO SOCKET.MESSAGE.COUNT% - 2                                                      ! EMG
1619: 11fe:            SOCKET.MESSAGE.ARRAY$(COUNT%) = SOCKET.MESSAGE.ARRAY$(COUNT% + 1)                            ! EMG
1620: 122b:            SOCKET.MESSAGE.ARRAY$(COUNT% + 1) = ""                                                       ! EMG
1621: 1246:        NEXT                                                                                             ! EMG
1622: 1259:        SOCKET.MESSAGE.COUNT% = SOCKET.MESSAGE.COUNT% - 1                                                ! EMG
1623: 125f:     ENDIF ELSE BEGIN                                                                                    ! EMG
1624: 125f:        SOCKET.MESSAGE.COUNT%    = 0                                                                     ! EMG
1625: 1265:        SOCKET.MESSAGE.ARRAY$(0) = ""                                                                    ! EMG
1626: 127d:     ENDIF                                                                                               ! EMG
1627: 127d:                                                                                                         ! EMG
1628: 127d:     CALL DECAPI.LOG(STR$(REMAIN%) + " MESSAGES AVAILABLE IN API QUEUE",0)                               ! EMG
1629: 12c6:                                                                                                         ! EMG
1630: 12c6: LEAVE.FUNCTION:                                                                                         ! EMG
1631: 12c6:                                                                                                         ! EMG
1632: 12c6:     EXIT FUNCTION                                                                                       ! EMG
1633: 12c8:                                                                                                         ! EMG
1634: 12c8: ABORT.FUNCTION:                                                                                         ! EMG
1635: 12c8:                                                                                                         ! EMG
1636: 12c8:     !Corrupt data - clean up                                                                            ! EMG
1637: 12c8:     SOCKET.MESSAGE.COUNT%    = 0                                                                        ! EMG
1638: 12ce:     DIM SOCKET.MESSAGE.ARRAY$(1000)                                                                     ! EMG
1639: 12f0:                                                                                                         ! EMG
1640: 12f0:     RESUME LEAVE.FUNCTION                                                                               ! EMG
1641: 12ff:                                                                                                         ! EMG
1642: 12ff: END FUNCTION                                                                                            ! EMG
1643: 1315: 
1644: 1315: 
1645: 1315: \*****************************************************************************
1646: 1315: \***
1647: 1315: \***    CHECK.PAYLOAD.AND.TRANSLATE
1648: 1315: \***
1649: 1315: \***    Check and translate payload
1650: 1315: \***
1651: 1315: \***..........................................................................
1652: 1315: 
1653: 1315: 
1654: 1315: FUNCTION CHECK.PAYLOAD.AND.TRANSLATE(A$,B$,C$)
1655: 1338: 
1656: 1338:     STRING CHECK.PAYLOAD.AND.TRANSLATE
1657: 1338:     STRING A$
1658: 1338:     STRING B$
1659: 1338:     STRING C$
1660: 1338:     INTEGER*2 NUM%
1661: 1338:     INTEGER*2 LOC%
1662: 1338: 
1663: 1338:     NUM% = 1
1664: 133e:     LOC% = MATCH(B$,A$,NUM%) 
1665: 1356:     !Translate B$ to C$;
1666: 1356:     WHILE LOC% <> 0 
1667: 1359: 
1668: 1359:        A$ = LEFT$(A$,LOC%-1) + C$ + RIGHT$(A$,len(A$)-((LOC%-1)+LEN(B$)))
1669: 13c1:        NUM% = LOC% + 1
1670: 13c8:        LOC% = MATCH(B$,A$,NUM%)
1671: 13dd:        
1672: 13dd:     WEND
1673: 13e7: 
1674: 13e7:     CHECK.PAYLOAD.AND.TRANSLATE = A$
1675: 13f7: 
1676: 13f7: END FUNCTION
1677: 1417: 
1678: 1417: 
1679: 1417: \********************************************************************
1680: 1417: \***
1681: 1417: \***   DEC.CONNECT
1682: 1417: \***   
1683: 1417: \***   Connect client to DEC via socket
1684: 1417: \***
1685: 1417: \********************************************************************
1686: 1417: 
1687: 1417: FUNCTION DEC.CONNECT(IP$,P%, TO%)
1688: 1430: 
1689: 1430:     STRING    IP$
1690: 1430:     STRING    TEMP$
1691: 1430:     STRING    TEST$
1692: 1430:     INTEGER*2 SH%
1693: 1430:     INTEGER*2 RC%
1694: 1430:     INTEGER*2 P%
1695: 1430:     INTEGER*2 TO%
1696: 1430:     INTEGER*2 DEC.CONNECT
1697: 1430: 
1698: 1430:     DEC.CONNECT = 1
1699: 1435:     RC% = SOCK.INIT(1, 32767)
1700: 1446:     SH% = SOCK.SOCKET(2,1,0)
1701: 1457: 
1702: 1457:   IF SH% <> -1 THEN BEGIN
1703: 145f:      !Setup Non-blocking mode i.e Do not wait for response from socket
1704: 145f:      CALL SOCK.DONT.BLOCK(SH%)
1705: 146a: 
1706: 146a:      !Connect to remote host (Time out read from EALSOPTS record 156)
1707: 146a:      SOCKET.RC% = SOCK.CONNECT(SH%,IP$,P%)
1708: 1485: 
1709: 1485:      !Socket operation in progress
1710: 1485:      IF SOCKET.RC% = -1 AND TCPERRNO% = 024H THEN BEGIN
1711: 14b3:         !
1712: 14b3:         TEMP$ = "00"
1713: 14c0:         CALL PUTN2(TEMP$, 0, SH%)
1714: 14d6:         ! Check if the socket is ready for use
1715: 14d6:         CALL SOCK.SELECT(TEMP$, 0, 1, 0, TO%, RC%)
1716: 1525:         CALL SOCK.RECV(SH%,TEST$,0,RC%)
1717: 154f:         IF RC% = 0 OR (RC% = -1 AND (TCPERRNO% = 3DH OR TCPERRNO% = 39H ))  THEN BEGIN
1718: 15a2:            ! Socket connection timed out on handle or connection failure. Abort socket and try secondary IP 
1719: 15a2:            DEC.CONNECT = RC%
1720: 15a8:            RC% = SOCK.ABORT(SOCKET.HANDLE%) 
1721: 15b6:            EXIT FUNCTION
1722: 15b8:         ENDIF
1723: 15b8: 
1724: 15b8:      ENDIF
1725: 15b8: 
1726: 15b8:   ENDIF
1727: 15b8: 
1728: 15b8:     DEC.CONNECT = SH%
1729: 15be: 
1730: 15be: END FUNCTION
1731: 15d2: 
1732: 15d2: \*****************************************************************************
1733: 15d2: \***
1734: 15d2: \***    FLEXOSSVC
1735: 15d2: \***   
1736: 15d2: \***    FLEXOS FUNCTION 
1737: 15d2: \***
1738: 15d2: \***..........................................................................
1739: 15d2: 
1740: 15d2: 
1741: 15d2:  FUNCTION FLEXOSSVC(COMMAND%, PARAM$) EXTERNAL
1742: 15d2:       STRING PARAM$
1743: 15d2:       INTEGER*2 COMMAND%, FLEXOSSVC
1744: 15d2: END FUNCTION
1745: 15d2: 
1746: 15d2: \*****************************************************************************
1747: 15d2: \***
1748: 15d2: \***    PROCESS.NAME$
1749: 15d2: \***   
1750: 15d2: \***    Get the calling applications name 
1751: 15d2: \***
1752: 15d2: \***..........................................................................
1753: 15d2: 
1754: 15d2: FUNCTION PROCESS.NAME$
1755: 15e6: 
1756: 15e6:     STRING    SVC.PARAM$
1757: 15e6:     STRING    PROCESS.TABLE$
1758: 15e6:     STRING    PROCESS.NAME$
1759: 15e6:     STRING    TEMP$
1760: 15e6:     STRING    NAME$
1761: 15e6:     INTEGER*2 LOOP%
1762: 15e6:     INTEGER*4 TABLE.SIZE%
1763: 15e6:     
1764: 15e6:     ON ERROR GOTO ABORT.FUNCTION                                                                                                         ! GMG
1765: 15f3:     
1766: 15f3:     SVC.PARAM$ = STRING$(28,"0")
1767: 1607:     PROCESS.TABLE$ = ""
1768: 1614:     TEMP$ = STRING$(60, CHR$(00H))
1769: 162b:     FOR LOOP% = 1 TO 200
1770: 1633:        PROCESS.TABLE$ = PROCESS.TABLE$ + TEMP$
1771: 164f:     NEXT
1772: 165e:     TABLE.SIZE% = LEN(PROCESS.TABLE$)
1773: 167d: 
1774: 167d:     CALL PUTN4(SVC.PARAM$,  0, 00000000H)
1775: 1697:     CALL PUTN4(SVC.PARAM$,  4, 00000000H)
1776: 16b1:     CALL PUTN4(SVC.PARAM$,  8, 00000000H)
1777: 16cb:     CALL PUTN4(SVC.PARAM$, 12, SADD(PROCESS.TABLE$) + 2)
1778: 16f2:     CALL PUTN4(SVC.PARAM$, 16, TABLE.SIZE%)
1779: 170c: 
1780: 170c:     \  REM Execute GET SVC
1781: 170c:     CALL FLEXOSSVC(0, SVC.PARAM$)
1782: 171e: 
1783: 171e:     NAME$ =  MID$(PROCESS.TABLE$,9,8) 
1784: 1738: 
1785: 1738:     IF MATCH(PACK$("00"),NAME$,1) THEN BEGIN                                                                                             ! GMG
1786: 1762:        NAME$ =  LEFT$(NAME$,MATCH(PACK$("00"),NAME$,1)-1)                                                                                ! GMG
1787: 179f:     ENDIF                                                                                                                                ! GMG
1788: 179f: 
1789: 179f:     PROCESS.NAME$ = NAME$                                                                                                                ! GMG
1790: 17b1: 
1791: 17b1: LEAVE.FUNCTION:                                                                                                                          ! GMG
1792: 17b1: 
1793: 17b1:     EXIT FUNCTION                                                                                                                        ! GMG
1794: 17b3: 
1795: 17b3: ABORT.FUNCTION:                                                                                                                          ! GMG
1796: 17b3: 
1797: 17b3:     PROCESS.NAME$ = ""                                                                                                                   ! GMG
1798: 17c1:     RESUME LEAVE.FUNCTION                                                                                                                ! GMG
1799: 17d0: 
1800: 17d0: END FUNCTION
1801: 17e1: 
1802: 17e1: \*******************************************************************************
1803: 17e1: \***
1804: 17e1: \***    SOCKET.INITIALISATION
1805: 17e1: \***
1806: 17e1: \*******************************************************************************
1807: 17e1: 
1808: 17e1: SUB SOCKET.INITIALISATION(LOST)
1809: 17f5: 
1810: 17f5:     STRING    A.IP$
1811: 17f5:     STRING    A.DQ$
1812: 17f5:     STRING    FIELD$
1813: 17f5:     STRING    ADX.DATA$
1814: 17f5:     STRING    TEST$
1815: 17f5:     INTEGER*2 NO%
1816: 17f5:     INTEGER*2 ADX.RC%
1817: 17f5:     INTEGER*2 LOST
1818: 17f5: 
1819: 17f5:     ! initialise variable and open files for socket initialisation
1820: 17f5: 
1821: 17f5:     NAK   = 0
1822: 17fa:     ACK   =  -1
1823: 17ff:     FOUND = NAK                                                                 
1824: 1805: !!!!DQ.OPENED = NAK                                                             ! KMW
1825: 1805: 
1826: 1805:     CRTLF$     = CHR$(0DH) + CHR$(0AH)
1827: 182a:     COMMA$     = CHR$(2CH)
1828: 183a:     QUOTE$     = CHR$(22H)
1829: 184a:     AMPERSAND$ = CHR$(26H)
1830: 185a:     PIPE$      = CHR$(07CH)
1831: 186a: 
1832: 186a:     TEST.RESPONSE$  = "NAKSA003,Check Connection,Check Connection" + CRTLF$                                                              ! FMG
1833: 1882: 
1834: 1882:     !------------------------------
1835: 1882:     ! Initialise CONTTIME variables
1836: 1882:     !------------------------------
1837: 1882: 
1838: 1882:     CT.PARAMBLK$       = STRING$(20, CHR$(00H))
1839: 1899:     CT.TIMEDATE.TABLE$ = STRING$(12, CHR$(00H))
1840: 18b0: 
1841: 18b0: 
1842: 18b0: 
1843: 18b0:     IF PHASE1.COMPLETED = 0 THEN BEGIN
1844: 18ba: 
1845: 18ba:         IF NOT LOST THEN BEGIN 
1846: 18c7:            DIM DECCONF.RECORD$(100)
1847: 18e8:            DIM SERVL.ARRAY.RECORD$(1000)                                                                                                 ! BMG
1848: 1910:            DIM DQ.ARRAY.RECORD$(1000)
1849: 1938:            DIM SOCKET.MESSAGE.ARRAY$(1000)                                                                                               ! EMG
1850: 195a: 
1851: 195a:            SOCKET.MESSAGE.COUNT% = 0                                                                                                     ! EMG
1852: 1960:            DQ.ELEMENT%           = 0                                                                                                    
1853: 1969:            SERVL.ELEMENT%        = 0                                                                                                     ! BMG   
1854: 1972:         ENDIF
1855: 1972: 
1856: 1972:         CALL ADXSERVE(ADX.RC%,                    \
1857: 19b3:                      4,                           \
1858: 19b3:                      0,                           \
1859: 19b3:                      ADX.DATA$)
1860: 19b3: 
1861: 19b3:         NODE.ID$ = MID$(ADX.DATA$,14,2)
1862: 19cd:         
1863: 19cd:        IF DECAPI.CLIENT$ = "" THEN BEGIN                                                                                                 ! BMG
1864: 19e3:           DECAPI.CLIENT$ = PROCESS.NAME$                                                                                                 ! BMG
1865: 19f2:        ENDIF                                                                                                                             ! BMG
1866: 19f2: 
1867: 19f2:         IF DECCF.REPORT.NUM%   = 0 THEN CALL DECCF.SET
1868: 1a0f:         IF DECAP.REPORT.NUM%   = 0 THEN CALL DECAP.SET
1869: 1a2c:         IF DQ.REPORT.NUM%      = 0 THEN CALL DQ.SET
1870: 1a49:         IF SOPTS.REPORT.NUM%   = 0 THEN CALL SOPTS.SET
1871: 1a66:         IF SERVL.SESS.NUM%     = 0 THEN CALL SERVL.SET                                                                                   ! BMG
1872: 1a83: 
1873: 1a83:         DECCF.SESS.NUM% = 1000
1874: 1a8c:         SOPTS.SESS.NUM% = 1001
1875: 1a95:         DECAP.SESS.NUM% = 1002
1876: 1a9e:         DQ.SESS.NUM%    = 1003
1877: 1aa7:         SERVL.SESS.NUM% = 1004                                                                                                           ! BMG
1878: 1ab0: 
1879: 1ab0:         SOCKET.HANDLE% = -1                                                                                                              ! BMG
1880: 1ab6:         QUEUE.FILE     = -1                                                                                                              ! BMG   
1881: 1abb: 
1882: 1abb:         IF END # DECCF.SESS.NUM% THEN ABORT.SUB                                                                                          ! BMG
1883: 1acf:         OPEN DECCF.FILE.NAME$ RECL DECCF.RECL% AS DECCF.SESS.NUM% NOWRITE NODEL
1884: 1af4: 
1885: 1af4:         CALL OPEN.DQ("D:\ADX_UDT1\DQ2" + NODE.ID$ + ".BIN")                                                                              ! MBG
1886: 1b29: 
1887: 1b29:         IF END # SOPTS.SESS.NUM% THEN SKIP.SOPTS.READ                                                                                     ! BMG 
1888: 1b3d:         OPEN SOPTS.FILE.NAME$ RECL SOPTS.RECL% AS SOPTS.SESS.NUM% NOWRITE NODEL                                                           ! BMG
1889: 1b62: 
1890: 1b62:         ! Read EALSOPTS record 156
1891: 1b62:   READ.SOPT:
1892: 1b62: 
1893: 1b62:         SOPTS.REC.NUM% = 156
1894: 1b71: 
1895: 1b71:         SOCKET.RC% = READ.SOPTS
1896: 1b79: 
1897: 1b79:         IF SOCKET.RC% = 0 THEN BEGIN                                                                                                      ! BMG
1898: 1b7e:            CALL SOREC156(SOPTS.RECORD$)                                                                                                   ! BMG
1899: 1b8b:         ENDIF                                                                                                                             ! BMG
1900: 1b8b: 
1901: 1b8b:         CLOSE SOPTS.SESS.NUM%
1902: 1b97: 
1903: 1b97: SKIP.SOPTS.READ:
1904: 1b97: 
1905: 1b97: 
1906: 1b97:     TEST$ = "ADXLXACN::D:\ADX_UDT1\DECAPIL" + STR$(VAL(UNPACK$(DAY$)))
1907: 1bd5: 
1908: 1bd5:     !OPEN DECAPI LOCAL FILE IF REQUIRED
1909: 1bd5:     IF DEC.LOGSTATUS AND NOT LOG.FILE.OPEN AND TEST$ <> DECAP.FILE.NAME$  THEN BEGIN
1910: 1c0c:        DECAP.FILE.NAME$ = "ADXLXACN::D:\ADX_UDT1\DECAPIL" + STR$(VAL(UNPACK$(DAY$)))
1911: 1c4c:        IF END # DECAP.SESS.NUM% THEN CREATE.DECAP
1912: 1c60:        OPEN DECAP.FILE.NAME$ AS DECAP.SESS.NUM% NOREAD NODEL APPEND 
1913: 1c80:        GOTO SKIP.DECAP
1914: 1c82:        CREATE.DECAP:
1915: 1c82:        CREATE POSFILE DECAP.FILE.NAME$ AS DECAP.SESS.NUM% MIRRORED PERUPDATE
1916: 1ca0:        CALL DECAPI.LOG(DECAP.FILE.NAME$ +" daily DECAPI file created",0)
1917: 1cde:        SKIP.DECAP:
1918: 1cde:        LOG.FILE.OPEN = ACK
1919: 1ce4:     ENDIF
1920: 1ce4: 
1921: 1ce4:     !OPEN SERVICE EVENT LOG FILE IF REQUIRED                                                                                              ! BMG
1922: 1ce4:     IF DEC.SERVICE.LOG AND NOT SERVICE.FILE.OPEN THEN BEGIN                                                                               ! BMG
1923: 1cf5:        SERVL.FILE.NAME$ = "ADXLXACN::D:\ADX_UDT1\SERVL" + NODE.ID$                                                                        ! BMG
1924: 1d0f:        IF END # SERVL.SESS.NUM% THEN CREATE.SERVL                                                                                         ! BMG
1925: 1d23:        OPEN SERVL.FILE.NAME$ AS SERVL.SESS.NUM% NOREAD NODEL APPEND                                                                       ! BMG
1926: 1d43:        GOTO SKIP.SERVL                                                                                                                    ! BMG
1927: 1d45:        CREATE.SERVL:                                                                                                                      ! BMG
1928: 1d45:        CREATE POSFILE SERVL.FILE.NAME$ AS SERVL.SESS.NUM% MIRRORED PERUPDATE                                                              ! BMG
1929: 1d63:        CALL DECAPI.LOG(SERVL.FILE.NAME$ + " service event log  file created",0)                                                           ! BMG
1930: 1da1:        SKIP.SERVL:                                                                                                                        ! BMG
1931: 1da1:        SERVICE.FILE.OPEN = ACK                                                                                                            ! EMG ! BMG
1932: 1da7:     ENDIF
1933: 1da7: 
1934: 1da7:         ! Read all DECCONF records and store in the DECCONF array
1935: 1da7:         CALL DECAPI.LOG("Read DEC configuration messages into memory",0)                                                                  ! BMG
1936: 1dd7:         LOOP% = 0
1937: 1ddd:         DECCF.REC.NUM% = 1
1938: 1dec:         WHILE 1=1
1939: 1dee: 
1940: 1dee:         IF READ.DECCF = 0 THEN BEGIN
1941: 1df8:             DECCONF.RECORD$(LOOP%) = DECCF.RECORD$
1942: 1e19:             LOOP% = LOOP% + 1
1943: 1e1d:             DECCF.REC.NUM% = DECCF.REC.NUM% + 1
1944: 1e30:          ENDIF ELSE BEGIN
1945: 1e30:           GOTO ALL.READ
1946: 1e32:          ENDIF
1947: 1e32: 
1948: 1e32:         WEND
1949: 1e34: 
1950: 1e34: ALL.READ:
1951: 1e34: 
1952: 1e34:         PHASE1.COMPLETED = ACK
1953: 1e3a: 
1954: 1e3a:         CLOSE DECCF.SESS.NUM%
1955: 1e46: 
1956: 1e46:         CLIENT.IP$           = PRIMARY.IP$
1957: 1e57:         ALTERNATE.IP$        = SECONDARY.IP$
1958: 1e68: 
1959: 1e68:         TIME.IN.MS% = MILLI.TIME%                                                                                                         ! BMG
1960: 1e79: 
1961: 1e79:     ENDIF
1962: 1e79: 
1963: 1e79:     ! Create application handle (SOCK_CONNECT)
1964: 1e79:     CALL DECAPI.LOG("Create socket for client",0)                                                                                         ! BMG
1965: 1ea9:     SOCKET.RC% = SOCK.INIT(1, 32767)
1966: 1eba: 
1967: 1eba:     CALL DECAPI.LOG("Attempt connection to DEC",0)                                                                                        ! BMG
1968: 1eea:     CALL DECAPI.LOG("Client:" + DECAPI.CLIENT$ + " Client_IP:" + CLIENT.IP$ + " Port_number:" + STR$(DEC.PORT%),0)                        ! BMG
1969: 1f43:     SOCKET.RC% = DEC.CONNECT(CLIENT.IP$, DEC.PORT%, DEC.SOCKET.TIMEOUT%)
1970: 1f5d: 
1971: 1f5d:     IF PROBLEM.DQ THEN BEGIN
1972: 1f64:        PROBLEM.DQ = 0                                                                                                                     ! BMG
1973: 1f69:        CALL DECAPI.LOG("API" + "EV00007" + PIPE$ + "Could not open / Create queue file for controller " + NODE.ID$,1)                     ! BMG
1974: 1fb6:     ENDIF ELSE BEGIN                                                                                                                      ! BMG
1975: 1fb6:        QUEUE.FILE = 0                                                                                                                     ! BMG
1976: 1fbb:     ENDIF
1977: 1fbb: 
1978: 1fbb:     IF SOCKET.RC% = -1 THEN BEGIN
1979: 1fc5: 
1980: 1fc5:        !Problem with connecting to Primary server, try secondary.
1981: 1fc5:        CALL DECAPI.LOG("Problem with connecting to server - "+CLIENT.IP$,0)                                                               ! BMG
1982: 2000:        CALL DECAPI.LOG("Try server - "+ALTERNATE.IP$,0)                                                                                   ! BMG
1983: 203b:        A.IP$ = CLIENT.IP$
1984: 204c:        CLIENT.IP$ = ALTERNATE.IP$ 
1985: 205d:        ALTERNATE.IP$ = A.IP$
1986: 206e:        ALTERNATE.DQ$ = A.DQ$
1987: 207f:        SOCKET.RC% = DEC.CONNECT(CLIENT.IP$, DEC.PORT%, DEC.SOCKET.TIMEOUT%)
1988: 2099:        IF SOCKET.RC% = -1 THEN BEGIN 
1989: 20a1:           CALL DECAPI.LOG("Problem with connecting to Secondary server",0)
1990: 20d1:           CALL DECAPI.LOG("Failure to connect. Return to Client with relevant",0)                                                         ! BMG
1991: 2101:           CALL DECAPI.LOG("Return code",0)                                                                                                ! BMG
1992: 2131:           CALL DECAPI.LOG("Socket handle for client ("+DECAPI.CLIENT$+") " + STR$(SOCKET.HANDLE%),0)                                      ! BMG
1993: 217e:           CALL DECAPI.LOG("API" + "EV00006" + PIPE$ + "Could not connect to socket adapter",1)                                            ! BMG
1994: 21c1:        ENDIF
1995: 21c3:        
1996: 21c3:     ENDIF ELSE BEGIN
1997: 21c3:           CALL DECAPI.LOG(".............SOCKET CONNECTED - AWAITING MESSAGES...............",0)                                           ! BMG
1998: 21f3:     ENDIF
1999: 21f3: 
2000: 21f3: ABORT.SUB:
2001: 21f3: 
2002: 21f3:     SOCKET.HANDLE% = SOCKET.RC%
2003: 21f9: 
2004: 21f9: END SUB
2005: 2205: 
2006: 2205: \*******************************************************************************
2007: 2205: \***
2008: 2205: \***    PROCESS.TEMP.FILE
2009: 2205: \***
2010: 2205: \*******************************************************************************
2011: 2205: !
2012: 2205: !
2013: 2205: !FUNCTION PROCESS.TEMP.FILE                                                                                                               ! GMG ! DMG
2014: 2205: !                                                                                                                                         ! GMG ! DMG
2015: 2205: !   STRING    FORM$                                                                                                                       ! GMG ! DMG
2016: 2205: !   STRING    DATA$                                                                                                                       ! GMG ! DMG
2017: 2205: !   STRING    NODE$                                                                                                                       ! GMG ! DMG
2018: 2205: !    INTEGER*1 RC%                                                                                                                        ! GMG ! DMG
2019: 2205: !   INTEGER*2 ARG.RETURN.CODE                                                                                                             ! GMG ! DMG
2020: 2205: !   INTEGER*2 PROCESS.TEMP.FILE                                                                                                           ! GMG ! DMG
2021: 2205: !   INTEGER*2 TEMP.SESS.NUM%                                                                                                              ! GMG ! DMG
2022: 2205: !   INTEGER*4 SIZE%                                                                                                                       ! GMG ! DMG
2023: 2205: !                                                                                                                                         ! DMG
2024: 2205: !   ARG.RETURN.CODE = 09H                                                                                                                 ! GMG ! DMG
2025: 2205: !                                                                                                                                         ! GMG ! DMG
2026: 2205: !   TEMP.SESS.NUM% = 1005                                                                                                                 ! GMG ! DMG
2027: 2205: !                                                                                                                                         ! GMG ! DMG
2028: 2205: !    ON ERROR GOTO ABORT.FUNCTION                                                                                                         ! GMG ! DMG
2029: 2205: !                                                                                                                                         ! GMG ! DMG
2030: 2205: !    !Open temp file locked and move data in to live queue file.                                                                          ! GMG ! DMG
2031: 2205: !    NODE$ = "ADXLXAAN::"                                                                                                                 ! GMG ! DMG
2032: 2205: !    IF NODE.ID$ <> "CE" THEN NODE$ = "ADXLXACN::"                                                                                        ! GMG ! DMG
2033: 2205: !    SIZE% = SIZE(NODE$ + "D:\ADX_UDT1\DQ" + NODE.ID$ + ".TMP")                                                                           ! GMG ! DMG
2034: 2205: !    IF SIZE% <> 0 THEN BEGIN                                                                                                             ! GMG ! DMG
2035: 2205: !       OPEN NODE$ + "D:\ADX_UDT1\DQ" + NODE.ID$ + ".TMP" AS TEMP.SESS.NUM% BUFFSIZE 32767 LOCKED NOWRITE                                 ! GMG ! DMG
2036: 2205: !       FORM$ = "C" + STR$(SIZE%)                                                                                                         ! GMG ! DMG
2037: 2205: !      READ FORM FORM$;# TEMP.SESS.NUM%;DATA$                                                                                             ! GMG ! DMG
2038: 2205: !       DELETE TEMP.SESS.NUM%                                                                                                             ! GMG ! DMG
2039: 2205: !       DQ.ARRAY.RECORD$(0) = DATA$                                                                                                       ! GMG ! DMG
2040: 2205: !       RC% = WRITE.MATRIX.DQ                                                                                                             ! GMG ! DMG
2041: 2205: !      DIM DQ.ARRAY.RECORD$(1000)                                                                                                         ! GMG ! DMG
2042: 2205: !       ARG.RETURN.CODE = 00H                                                                                                             ! GMG ! DMG
2043: 2205: !    ENDIF                                                                                                                                ! GMG ! DMG
2044: 2205: !                                                                                                                                         ! GMG ! DMG
2045: 2205: !    ABORT.FUNCTION:                                                                                                                      ! GMG ! DMG
2046: 2205: !                                                                                                                                         ! GMG ! DMG
2047: 2205: !    PROCESS.TEMP.FILE = ARG.RETURN.CODE                                                                                                  ! GMG ! DMG
2048: 2205: !                                                                                                                                         ! GMG ! DMG
2049: 2205: !END FUNCTION                                                                                                                             ! GMG ! DMG
2050: 2205:                                                                                                                                           ! GMG ! DMG
2051: 2205: \********************************************************************
2052: 2205: \********************************************************************
2053: 2205: \***
2054: 2205: \***    S T A R T   O F   F U N C T I O N S
2055: 2205: \***
2056: 2205: \********************************************************************
2057: 2205: \********************************************************************
2058: 2205: 
2059: 2205: \********************************************************************
2060: 2205: \***
2061: 2205: \***    DECAP.INIT()
2062: 2205: \***
2063: 2205: \********************************************************************
2064: 2205: 
2065: 2205: FUNCTION DECAPI.INIT PUBLIC
2066: 2219: 
2067: 2219:     INTEGER*1 ARG.RETURN.CODE 
2068: 2219:     INTEGER*2 DECAPI.INIT
2069: 2219: 
2070: 2219:     ARG.RETURN.CODE = 08h
2071: 221e:     
2072: 221e:     ON ERROR GOTO ABORT.FUNCTION
2073: 222b: 
2074: 222b:     CALL SOCKET.INITIALISATION(0)
2075: 2248: 
2076: 2248:     IF SOCKET.HANDLE% > 1 AND NOT QUEUE.FILE THEN BEGIN
2077: 225e:        ARG.RETURN.CODE = 0
2078: 2265:     ENDIF ELSE IF SOCKET.HANDLE% < 1 AND NOT QUEUE.FILE THEN BEGIN  
2079: 227b:        ARG.RETURN.CODE = 02h
2080: 2282:     ENDIF ELSE IF SOCKET.HANDLE% > 1 AND QUEUE.FILE THEN BEGIN
2081: 2294:        ARG.RETURN.CODE = 06h
2082: 229b:     ENDIF ELSE BEGIN
2083: 229b:        ARG.RETURN.CODE = 07h
2084: 22a0:     ENDIF 
2085: 22a0: 
2086: 22a0:     CALL DECAPI.LOG("API Initilisation - Return Code = " + STR$(ARG.RETURN.CODE),0)
2087: 22df: 
2088: 22df:   EXIT.FUNCTION:
2089: 22df: 
2090: 22df:     DECAPI.INIT = ARG.RETURN.CODE
2091: 22e6: 
2092: 22e6:     EXIT FUNCTION
2093: 22e8: 
2094: 22e8: ABORT.FUNCTION:
2095: 22e8: 
2096: 22e8:     RESUME EXIT.FUNCTION
2097: 22f7: 
2098: 22f7: END FUNCTION
2099: 2306: 
2100: 2306: \********************************************************************
2101: 2306: \***
2102: 2306: \***    DECAPI.CLOSE()
2103: 2306: \***
2104: 2306: \********************************************************************
2105: 2306: 
2106: 2306: FUNCTION DECAPI.CLOSE PUBLIC
2107: 231a: 
2108: 231a:     INTEGER*1 ARG.RETURN.CODE 
2109: 231a:     INTEGER*1 DECAPI.CLOSE
2110: 231a:     INTEGER*1 RC%
2111: 231a: 
2112: 231a:     ARG.RETURN.CODE = -1
2113: 231f: 
2114: 231f:     ON ERROR GOTO ABORT.FUNCTION
2115: 232c: 
2116: 232c:     SOCKET.RC% = SOCK.ABORT(SOCKET.HANDLE%)
2117: 233a: 
2118: 233a:     IF SOCKET.RC% = 0 THEN ARG.RETURN.CODE = 00H
2119: 2344: 
2120: 2344:     CALL DECAPI.LOG("DECAPI.CLOSE  - Attempt to close down socket handle",0)    ! BMG
2121: 2374:     CALL DECAPI.LOG("Client:" + DECAPI.CLIENT$ + "Socket_handle:" + \           ! KMW
2122: 23db:                     STR$(SOCKET.HANDLE%)+" Return_code:" + STR$(SOCKET.RC%),0)  ! KMW
2123: 23db:     CALL DECAPI.LOG("Close down files",0)                                       ! BMG
2124: 240b: 
2125: 240b: !!!!IF DQ.OPENED THEN BEGIN                                                     ! KMW
2126: 240b:        CLOSE DQ.SESS.NUM%                                                       ! GMG
2127: 2417: !!!!!!!DQ.OPENED = NAK                                                          ! KMW
2128: 2417: !!!!ENDIF                                                                       ! KMW
2129: 2417:                                                                                 ! GMG
2130: 2417:     IF LOG.FILE.OPEN THEN BEGIN                                                 ! GMG
2131: 241e:        CLOSE DECAP.SESS.NUM%                                                    ! GMG
2132: 242a:        LOG.FILE.OPEN = NAK                                                      ! GMG
2133: 2430:     ENDIF                                                                       ! GMG
2134: 2430:                                                                                 ! GMG
2135: 2430:     IF SERVICE.FILE.OPEN THEN BEGIN                                             ! GMG
2136: 2437:        CLOSE SERVL.SESS.NUM%                                                    ! GMG
2137: 2443:        SERVICE.FILE.OPEN = NAK                                                  ! GMG
2138: 2449:     ENDIF                                                                       ! GMG
2139: 2449:                                                                                 ! GMG
2140: 2449:     PHASE1.COMPLETED = NAK                                                      ! GMG
2141: 244f:                                                                                 ! GMG
2142: 244f:     DECAP.FILE.NAME$ = ""                                                       ! GMG
2143: 245e:                                                                                 ! GMG
2144: 245e:     ARG.RETURN.CODE  = 0                                                        ! GMG
2145: 2463: 
2146: 2463: EXIT.FUNCTION:
2147: 2463: 
2148: 2463:     DECAPI.CLOSE = ARG.RETURN.CODE
2149: 2469: 
2150: 2469:     EXIT FUNCTION    
2151: 246b: 
2152: 246b: ABORT.FUNCTION:
2153: 246b: 
2154: 246b:     ! We don't care about close errors on the DQ file                           ! KMW
2155: 246b:     IF ERRF% = 1003 AND ERR = "CU" THEN RESUME                                  ! KMW
2156: 24ba: 
2157: 24ba:     RESUME EXIT.FUNCTION
2158: 24c9: 
2159: 24c9: END FUNCTION
2160: 24d8: 
2161: 24d8: \********************************************************************
2162: 24d8: \***
2163: 24d8: \***    DECAPI.SEND (MESSAGE_ID, PAYLOAD)
2164: 24d8: \***
2165: 24d8: \********************************************************************
2166: 24d8: 
2167: 24d8: FUNCTION DECAPI.SEND(ARG.MESSAGEID$,ARG.PAYLOAD$,COMMIT) PUBLIC
2168: 24fb: 
2169: 24fb:     STRING    ARG.MESSAGEID$
2170: 24fb:     STRING    ARG.PAYLOAD$
2171: 24fb:     STRING    COMMIT
2172: 24fb:     STRING    PAYLOAD$
2173: 24fb:     STRING    FORMAT.REQUEST$
2174: 24fb:     STRING    TEST.MESSAGE.NAME$
2175: 24fb:     STRING    QUEUE.FILENAME$
2176: 24fb:     STRING    SEND$
2177: 24fb:     STRING    TIME.SENT$
2178: 24fb:     STRING    HEADER$
2179: 24fb:     INTEGER*1 ARG.RETURN.CODE
2180: 24fb:     INTEGER*1 GIVE.UP    
2181: 24fb:     INTEGER*2 DECAPI.SEND
2182: 24fb:     INTEGER*2 RC1%
2183: 24fb:     INTEGER*2 CNT%
2184: 24fb:     INTEGER*2 RETRY%
2185: 24fb:     INTEGER*4 PAYLOAD.LENGTH%
2186: 24fb:     INTEGER*4 MAX.LENGTH%
2187: 24fb:     INTEGER*4 TIME.SENT%
2188: 24fb:     INTEGER*4 RC%, PARAM1%    
2189: 24fb: 
2190: 24fb: 
2191: 24fb:     ARG.RETURN.CODE = 08h
2192: 2500:     RETRY%          = 0                            ! IMG
2193: 2506: 
2194: 2506:     ON ERROR GOTO ABORT.FUNCTION
2195: 2513: 
2196: 2513:     ERR.MSG$ = ""                                                               ! KMW
2197: 2522:     ERR.CODE$ = ""                                                              ! KMW
2198: 2531: 
2199: 2531:     IF DECAPI.MAX THEN BEGIN
2200: 253b:        MAX.LENGTH%     = 65535
2201: 254a:     ENDIF ELSE BEGIN
2202: 254a:        MAX.LENGTH%     = 32767
2203: 2557:     ENDIF
2204: 2557:     
2205: 2557:     PAYLOAD.LENGTH% = LEN(ARG.PAYLOAD$)
2206: 2574: 
2207: 2574:     IF PAYLOAD.LENGTH% < 0 THEN BEGIN
2208: 2585:        PAYLOAD.LENGTH% = 65535 - PAYLOAD.LENGTH%
2209: 2596:     ENDIF
2210: 2596: 
2211: 2596:  !   TIME.IN.MS% = MILLI.TIME%                                                                                                              ! GMG ! DMG
2212: 2596:  !                                                                                                                                          ! GMG ! DMG
2213: 2596:  !   IF TIME.IN.MS% > DEC.HOUSEKEEP.TIME%             AND \                                                                                 ! GMG ! DMG
2214: 2596:  !      TIME.IN.MS% < (DEC.HOUSEKEEP.TIME% + 1800000) AND \                                                                                 ! GMG ! DMG
2215: 2596:  !      NOT HOUSE.KEEP.ACTIVE THEN BEGIN                                                                                                    ! GMG ! DMG
2216: 2596:  !      HOUSE.KEEP.ACTIVE = ACK                                                                                                             ! GMG ! DMG
2217: 2596:  !      ! Restrict then close down queue file                                                                                               ! GMG ! DMG
2218: 2596:  !      CALL ADXFILES (RC%,1,PARAM1%,"D:\ADX_UDT1\DQ" + NODE.ID$ + ".BIN")                                                                  ! GMG ! EMG
2219: 2596:  !      CLOSE DQ.SESS.NUM%                                                                                                                  ! GMG ! DMG
2220: 2596:  !      DQ.OPENED = NAK                                                                                                                     ! GMG ! DMG
2221: 2596:  !      !Open temp file                                                                                                                     ! GMG ! DMG
2222: 2596:  !      CALL OPEN.DQ("D:\ADX_UDT1\DQ" + NODE.ID$ + ".TMP")                                                                                  ! GMG ! DMG
2223: 2596:  !   ENDIF ELSE IF HOUSE.KEEP.ACTIVE THEN BEGIN                                                                                             ! GMG ! DMG
2224: 2596:  !      HOUSE.KEEP.ACTIVE = NAK                                                                                                             ! GMG ! DMG
2225: 2596:  !      ! Restrict then close down temp queue file                                                                                          ! GMG ! DMG
2226: 2596:  !     CALL ADXFILES (RC%,1,PARAM1%,"D:\ADX_UDT1\DQ" + NODE.ID$ + ".TMP")                                                                   ! GMG ! EMG
2227: 2596:  !      CLOSE DQ.SESS.NUM%                                                                                                                  ! GMG ! DMG
2228: 2596:  !      DQ.OPENED = NAK                                                                                                                     ! GMG ! DMG
2229: 2596:  !      !Open temp file                                                                                                                     ! GMG ! DMG
2230: 2596:  !      CALL OPEN.DQ("D:\ADX_UDT1\DQ" + NODE.ID$ + ".BIN")                                                                                  ! GMG ! DMG
2231: 2596:  !      ARG.RETURN.CODE = PROCESS.TEMP.FILE                                                                                                 ! GMG ! DMG
2232: 2596:  !      IF ARG.RETURN.CODE <> 0 THEN BEGIN                                                                                                  ! GMG ! DMG
2233: 2596:  !         DECAPI.SEND = ARG.RETURN.CODE                                                                                                    ! GMG ! DMG
2234: 2596:  !         EXIT FUNCTION                                                                                                                    ! GMG ! DMG
2235: 2596:  !      ENDIF                                                                                                                               ! GMG ! DMG
2236: 2596:  !  ENDIF                                                                                                                                   ! GMG ! DMG
2237: 2596: 
2238: 2596: 
2239: 2596:     !Check message does not exceed maximum message length
2240: 2596:     IF PAYLOAD.LENGTH% > MAX.LENGTH% OR PAYLOAD.LENGTH% < 0 THEN BEGIN 
2241: 25c4:            ARG.RETURN.CODE = 05H 
2242: 25c9:            CALL DECAPI.LOG("Client:" + DECAPI.CLIENT$+" Socket_handle:" + STR$(SOCKET.HANDLE%)+" Message exceeds maximum message length",0) ! BMG
2243: 2628:     ENDIF ELSE BEGIN 
2244: 2628: 
2245: 2628:             !Check message_id is valid
2246: 2628:             CALL MESSAGEID.MATCH(ARG.MESSAGEID$,NAK)                                                                                        ! BMG
2247: 2638: 
2248: 2638:             IF FOUND AND MESSAGE.MATCH THEN BEGIN
2249: 2644: 
2250: 2644: 
2251: 2644:                 !DECCF.MSGNAME$ = ARG.MESSAGEID$ + PIPE$
2252: 2644:                 FOUND         = NAK
2253: 264a:                 MESSAGE.MATCH = NAK
2254: 2650: 
2255: 2650:                 IF DQ.ELEMENT% <> 0 AND COMMIT <> "C" THEN BEGIN  ! 
2256: 2685:                    DQ.ARRAY.RECORD$(DQ.ELEMENT%) =  ARG.PAYLOAD$
2257: 26a7:                    DQ.ELEMENT% = DQ.ELEMENT% + 1 
2258: 26ae:                    ARG.RETURN.CODE  = 00H
2259: 26b6:                 ENDIF ELSE BEGIN     
2260: 26b6:                    
2261: 26b6:                    DQ.ARRAY.RECORD$(DQ.ELEMENT%) = DQ.ARRAY.RECORD$(DQ.ELEMENT%) + ARG.PAYLOAD$
2262: 26f7:                    IF LEN(DQ.ARRAY.RECORD$(DQ.ELEMENT%)) > MAX.LENGTH% OR LEN(DQ.ARRAY.RECORD$(DQ.ELEMENT%)) < 0 THEN BEGIN
2263: 276d:                       DECAPI.SEND = ARG.RETURN.CODE
2264: 2774:                       EXIT FUNCTION 
2265: 2777:                    ENDIF
2266: 2777: 
2267: 2777:                    IF  COMMIT <> "C" THEN BEGIN 
2268: 2788:                        DQ.ELEMENT% = DQ.ELEMENT% + 1 
2269: 278f:                        ARG.RETURN.CODE  = 00H
2270: 2797:                    ENDIF ELSE BEGIN
2271: 2797: 
2272: 2797: 
2273: 2797:                        !Check if payload has any control characters which need translating before writing to queue file
2274: 2797:                        FOR LOOP% = 0 TO DQ.ELEMENT%
2275: 27a0:                            IF DEC.TRANSTATUS AND DECCF.DELIVERY$ <> "S"  THEN BEGIN
2276: 27cc:                               !CHECK FOR the following in payload and translate.
2277: 27cc:                                DQ.ARRAY.RECORD$(LOOP%) = CHECK.PAYLOAD.AND.TRANSLATE(DQ.ARRAY.RECORD$(LOOP%),AMPERSAND$,"&AMP;")
2278: 280e:                                DQ.ARRAY.RECORD$(LOOP%) = CHECK.PAYLOAD.AND.TRANSLATE(DQ.ARRAY.RECORD$(LOOP%),CRTLF$,"&CRTLF;")
2279: 2850:                                DQ.ARRAY.RECORD$(LOOP%) = CHECK.PAYLOAD.AND.TRANSLATE(DQ.ARRAY.RECORD$(LOOP%),PIPE$,"&PIPE;")
2280: 2892:                                DQ.ARRAY.RECORD$(LOOP%) = CHECK.PAYLOAD.AND.TRANSLATE(DQ.ARRAY.RECORD$(LOOP%),QUOTE$,"&QUOT;")
2281: 28d4:                            ENDIF
2282: 28d4:                        NEXT
2283: 28eb: 
2284: 28eb:                    !IF  DECCF.DELIVERY$ = "S" THEN BEGIN
2285: 28eb:                    !    TIME.SENT% = MILLI.TIME%                                                                                             ! HMG ! BMG
2286: 28eb:                    !    TIME.SENT$ = RIGHT$(STRING$(8,"0") + STR$(TIME.SENT%),8)                                                             ! HMG ! EMG
2287: 28eb:                    !    DQ.ARRAY.RECORD$(0) = DECCF.MSGNAME$ + TIME.SENT$ + DQ.ARRAY.RECORD$(0)                                              ! HMG ! BMG
2288: 28eb:                    !ENDIF ELSE BEGIN                                                                                                         ! HMG ! BMG
2289: 28eb:                    DQ.ARRAY.RECORD$(0) = DECCF.MSGNAME$ + DQ.ARRAY.RECORD$(0)                                                           ! BMG
2290: 2927:                    !ENDIF 
2291: 2927: 
2292: 2927:                        PAYLOAD.LENGTH% = LEN(DQ.ARRAY.RECORD$(0))+2
2293: 2955: 
2294: 2955:                        !Format message request
2295: 2955: 
2296: 2955:                        !Send message via the SOCKET
2297: 2955:                        IF  DECCF.DELIVERY$ = "S" THEN BEGIN 
2298: 296e:                            DQ.ARRAY.RECORD$(DQ.ELEMENT%) = DQ.ARRAY.RECORD$(DQ.ELEMENT%) + CRTLF$
2299: 29b1:                            SEND$ = ""
2300: 29be:                            FOR LOOP% = 0 TO DQ.ELEMENT%
2301: 29c7:                               !SOCK.SEND(HANDLE%, MSG$, FLAGS%)
2302: 29c7:                               CALL DECAPI.LOG("Attempt to send payload for "+DECCF.MSGNAME$,0 )                                             ! BMG
2303: 2a05:                               CALL DECAPI.LOG("Request = " + DQ.ARRAY.RECORD$(LOOP%),0)                                                     ! BMG
2304: 2a51:                               CALL DECAPI.LOG("Client:" + DECAPI.CLIENT$ + " Socket handle:" + STR$(SOCKET.HANDLE%),0)                      ! BMG 
2305: 2a9e:                               TIME.SENT% = MILLI.TIME%                                                                                      ! BMG
2306: 2aaf:                               RC1% = SOCK.SEND(SOCKET.HANDLE%,DQ.ARRAY.RECORD$(LOOP%), 0)                                               
2307: 2ad9:                               ! Return code matches data sent                                                                           
2308: 2ad9:                               SEND$ = STR$(LEN(DQ.ARRAY.RECORD$(LOOP%)))                                                                    ! BMG                                                        
2309: 2b0e:                               IF RC1% <> VAL(SEND$) THEN BEGIN                                                                          
2310: 2b34:                                  RC% = -1                                                                                               
2311: 2b43:                               ENDIF  ELSE BEGIN                                                                                         
2312: 2b43:                                RC% = 0                                                                                                  
2313: 2b50:                               ENDIF                                                                                                     
2314: 2b50:                            NEXT                                                                                                         
2315: 2b67: 
2316: 2b67:                            IF RC% = 0 THEN BEGIN
2317: 2b7a:                               !Message request sent successfully add to log file (if active) and return ACK to calling application
2318: 2b7a:                               CALL DECAPI.LOG("Message request sent successfully ("+SEND$+" Bytes)",0)                                      ! BMG
2319: 2bb9:                               ARG.RETURN.CODE  = 00H
2320: 2bc1:                            ENDIF ELSE BEGIN
2321: 2bc1:                               !Socket not connected. Attempt to reconnect to DEC and re-send message (Try 2 times then give up)
2322: 2bc1:                               IF RC% = -1 AND (TCPERRNO% = 039H OR TCPERRNO% = 035H OR TCPERRNO% = -1) THEN BEGIN
2323: 2c34: 
2324: 2c34:                                  CALL DECAPI.LOG("Socket not connected. Attempt to reconnect to DEC and re-send message",0)                 ! BMG
2325: 2c64:                                  CALL DECAPI.LOG("Client:" + DECAPI.CLIENT$+ " Socket_handle:" + STR$(SOCKET.HANDLE%)+" Return_code:" +     \ BMG
2326: 2cec:                                                   STR$(RC%)+" TCP_ERROR_NO:" + STR$(TCPERRNO%),0)                                           ! BMG                                 
2327: 2cec:                                  LOOP% = 0
2328: 2cf2:                                  CNT%  = 0
2329: 2cf8:                                  GIVE.UP = NAK
2330: 2cfe:                                  WHILE NOT GIVE.UP
2331: 2d01:                                       CALL SOCKET.INITIALISATION(-1)
2332: 2d1e:                                       !Failed to connect
2333: 2d1e:                                       IF SOCKET.HANDLE% = -1 THEN BEGIN
2334: 2d25:                                          ARG.RETURN.CODE  = 02H
2335: 2d2a:                                          IF LOOP% = 1 THEN BEGIN                                                                            ! BMG
2336: 2d31:                                             GIVE.UP = ACK
2337: 2d37:                                             !Service event - Failed to connect                                                              ! BMG                                                                                   ! BMG
2338: 2d37:                                          ENDIF                                                                                              ! BMG
2339: 2d37:                                          LOOP% = LOOP% + 1
2340: 2d3e:                                       ENDIF ELSE BEGIN
2341: 2d3e:                                           !TIME.SENT% = MILLI.TIME%                                                                         ! HMG ! BMG
2342: 2d3e:                                           !TIME.SENT$ = RIGHT$(STRING$(8,"0") + STR$(TIME.SENT%),8)                                         ! HMG ! EMG 
2343: 2d3e:                                           ! IF DQ.ELEMENT% = 0 THEN BEGIN                                                                   ! HMG 
2344: 2d3e:                                           !HEADER$ =  DECCF.MSGNAME$ + TIME.SENT$                                                           ! HMG !
2345: 2d3e:                                           !DQ.ARRAY.RECORD$(0) = HEADER$ + RIGHT$(DQ.ARRAY.RECORD$(0),LEN(DQ.ARRAY.RECORD$(0)) -            ! HMG  \
2346: 2d3e:                                           !                      LEN(HEADER$))                                                              ! HMG !                                                              !
2347: 2d3e:                                           ! ENDIF                                                                                           ! HMG !
2348: 2d3e:                                           !DQ.ARRAY.RECORD$(0) = DECCF.MSGNAME$ + STR$(TIME.SENT%) + DQ.ARRAY.RECORD$(0)                    ! HMG ! BMG                                                                                          !
2349: 2d3e:                                           FOR LOOP% = 0 TO DQ.ELEMENT%                                                                      ! HMG ! BMG
2350: 2d47:                                               CALL DECAPI.LOG("Request = " + DQ.ARRAY.RECORD$(LOOP%),0)                                     ! HMG ! 
2351: 2d93:                                               RC% = SOCK.SEND(SOCKET.HANDLE%,DQ.ARRAY.RECORD$(LOOP%), 0)
2352: 2dc6:                                           NEXT
2353: 2ddd:                                           GIVE.UP = ACK
2354: 2de3:                                           IF TCPERRNO% >= 0 THEN BEGIN
2355: 2df8:                                              !Message request sent successfully add to log file (if active) and return ACK to calling application
2356: 2df8:                                              GIVE.UP = ACK
2357: 2dfe:                                              ARG.RETURN.CODE  = 00H
2358: 2e05:                                           ENDIF ELSE BEGIN
2359: 2e05:                                               ARG.RETURN.CODE  = 02H
2360: 2e0a:                                               IF CNT% = 1 THEN GIVE.UP = ACK
2361: 2e17:                                               CNT% = CNT% + 1
2362: 2e1b:                                               CALL DECAPI.LOG("API" + "EV00006" + PIPE$ + "Could not connect to socket adapter",1)          ! BMG
2363: 2e5e:                                           ENDIF
2364: 2e5e:                                       ENDIF
2365: 2e5e:                                  WEND
2366: 2e68:                               ENDIF
2367: 2e68:                            ENDIF
2368: 2e68:                            FOUND = NAK
2369: 2e6e:                            SEND$ = ""
2370: 2e7b:                            CALL DECAPI.LOG("Client:" + DECAPI.CLIENT$+" Socket_handle:" + STR$(SOCKET.HANDLE%) +                            \ BMG
2371: 2f03:                                            " Return_code:" + STR$(RC%)+ " TCP_ERROR_NO:" + STR$(TCPERRNO%),0)                               ! BMG
2372: 2f03:                            CALL DECAPI.LOG("Message could not be sent",0)                
2373: 2f36:                            !ARG.RETURN.CODE  = 0AH                
2374: 2f36:                        ENDIF ELSE BEGIN                                                                  
2375: 2f36:                        DQ.WRITE:
2376: 2f36:                            !Send message to the queue file
2377: 2f36:                            CALL DECAPI.LOG("Send async message to "  + DQ.FILE.NAME$,0)                                                     ! BMG
2378: 2f74:                            RC% = WRITE.MATRIX.DQ
2379: 2f8e:                            IF RC% = 0 THEN BEGIN
2380: 2fa1:                               ARG.RETURN.CODE  = 00H
2381: 2fa6:                            ENDIF
2382: 2fa6:                            CALL DECAPI.LOG("Return code   - " + STR$(RC%),0)                                                                ! BMG
2383: 2fe6:                            CALL DECAPI.LOG("Write type    - " + DECCF.DELIVERY$,0)                                                          ! BMG
2384: 3024:                        ENDIF                                                                                                           
2385: 3024:                    ENDIF
2386: 3024:                 ENDIF
2387: 3026:             ENDIF ELSE BEGIN
2388: 3026: 
2389: 3026:                ARG.RETURN.CODE  = 03H
2390: 302b: 
2391: 302b:             ENDIF
2392: 302b:     ENDIF
2393: 302b: 
2394: 302b:     DECAPI.SEND = ARG.RETURN.CODE
2395: 3032: 
2396: 3032: ERROR.LEAVE.FUNCTION:
2397: 3032: 
2398: 3032:      IF COMMIT = "C" THEN BEGIN                                                                     ! JMG
2399: 3043:          DQ.ELEMENT% = 0
2400: 304c:          DIM DQ.ARRAY.RECORD$(1000)
2401: 3074:      ENDIF                                                                                          ! JMG
2402: 3074:      
2403: 3074:     EXIT FUNCTION
2404: 3077:     
2405: 3077: ABORT.FUNCTION:
2406: 3077: 
2407: 3077:   ! IF error on DQ file AND                                                                         ! KMW
2408: 3077:   !    cannot write AND                                                                             ! KMW
2409: 3077:   !    we've not had enough of retrying yet                                                         ! KMW
2410: 3077:   IF ERRF% = 1003 AND                       \                                                       ! KMW
2411: 317d:      ((ERR = "*I" OR ERRN = 80F306F0h) OR   \ File locked                                           ! KMW
2412: 317d:       (ERR = "WT" OR ERRN = 8020430Dh) OR   \ Cannot write                                          ! KMW
2413: 317d:       (ERR = "FU" OR ERRN = 00000022h)) AND \ File unavailable                                      ! KMW
2414: 317d:      RETRY% <> 5 THEN BEGIN                                                                         ! KMW
2415: 317d:      CALL DECAPI.LOG("File locked. Wait 5 seconds and try again. Attempt " + STR$(RETRY%+1),0)      ! IMG
2416: 31bc:      WAIT; 5000
2417: 31cb:      ! Attempt to re-acquire the DQ file                                                            ! KMW
2418: 31cb:      CALL OPEN.DQ("D:\ADX_UDT1\DQ2" + NODE.ID$ + ".BIN")                                            ! MBG
2419: 3200:      RETRY% = RETRY% + 1
2420: 3204:      RESUME DQ.WRITE                                                                                ! IMG
2421: 3215:   ENDIF ELSE BEGIN
2422: 3215:      ERR.MSG$ = ERR                                                                                 ! KMW
2423: 3225:      ERR.CODE$ = ERRNHEX$                                                                           ! KMW
2424: 3234:      CALL DECAPI.LOG("Problem with DECAPI.SEND.....",0)
2425: 3264:      DECAPI.SEND = -1
2426: 3269:      RESUME ERROR.LEAVE.FUNCTION
2427: 3278:  ENDIF
2428: 3278: 
2429: 3278: END FUNCTION  
2430: 3296:  
2431: 3296: \********************************************************************
2432: 3296: \***
2433: 3296: \***    DECAPI.RECV()
2434: 3296: \***
2435: 3296: \********************************************************************
2436: 3296: 
2437: 3296: FUNCTION DECAPI.RECV PUBLIC
2438: 32aa: 
2439: 32aa:     STRING    MSG$
2440: 32aa:     STRING    RES$
2441: 32aa:     STRING    RESPONSE$
2442: 32aa:     STRING    TEMP$
2443: 32aa:     
2444: 32aa:     STRING    ARG.RETURN.DATA$
2445: 32aa:     STRING    DECAPI.RECV
2446: 32aa:     INTEGER*1 ARG.RETURN.CODE
2447: 32aa:     INTEGER*1 PAYLOAD.COMPLETE 
2448: 32aa:     INTEGER*2 RETURN.CODE%
2449: 32aa:     INTEGER*2 RC%
2450: 32aa: 
2451: 32aa:     ARG.RETURN.CODE = 08H
2452: 32af: 
2453: 32af: 
2454: 32af:     ON ERROR GOTO ABORT.FUNCTION
2455: 32bc: 
2456: 32bc: 
2457: 32bc:         TEMP$ = "00" 
2458: 32c9:         MSG$  = ""
2459: 32d6:         RESPONSE.TIME = ""
2460: 32e3: 
2461: 32e3:         IF SOCKET.MESSAGE.ARRAY$(0) = "" THEN BEGIN                                                                                     ! EMG      
2462: 3305: 
2463: 3305:             CALL PUTN2(TEMP$, 0, SOCKET.HANDLE%)
2464: 331b: 
2465: 331b:             CALL SOCK.SELECT(TEMP$, 1, 0, 0, DEC.SOCKET.TIMEOUT%, RC%)
2466: 336a: 
2467: 336a:             IF RC% > 0 THEN BEGIN
2468: 3374: 
2469: 3374:                 IF GETN2(TEMP$,0) <> -1 THEN BEGIN 
2470: 338e: 
2471: 338e:                         PAYLOAD.COMPLETE = NAK
2472: 3394:                         RESPONSE$ = ""
2473: 33a1:                         WHILE NOT PAYLOAD.COMPLETE
2474: 33a4: 
2475: 33a4:                             !Request response from Socket handle
2476: 33a4:                             CALL SOCK.RECV(SOCKET.HANDLE%,RES$,0,RC%)
2477: 33ce:                             CALL DECAPI.LOG("Request response from Socket handle",0)                                                    ! BMG
2478: 33fe:                             CALL DECAPI.LOG("Client:" + DECAPI.CLIENT$+" Socket_handle:" +                                              \ BMG 
2479: 346a:                             STR$(SOCKET.HANDLE%)+" TCP_ERROR_NO:" + STR$(TCPERRNO%),0)                                                  ! BMG
2480: 346a:                             IF RC% = 0 THEN BEGIN
2481: 3474: 
2482: 3474:                                IF LEN(RES$) = 0 THEN BEGIN
2483: 3487:                                   !Session closed sockets. Exit to calling application
2484: 3487:                                   ARG.RETURN.CODE = 04H
2485: 348c:                                   CALL DECAPI.LOG("Session closed sockets. Exit to calling application",0)                              ! BMG     
2486: 34bc:                                   SOCKET.RC% = SOCK.ABORT(SOCKET.HANDLE%)
2487: 34ca:                                   ! Service event - session closed sockets                                                              ! BMG     
2488: 34ca:                                   RESPONSE$ = "NAK0"+STR$(ARG.RETURN.CODE)      
2489: 34e9:                                ENDIF ELSE BEGIN
2490: 34e9:                                  !Check all message received i.e. ends 0D0A
2491: 34e9:                                  IF LEFT$(RES$,3) = "NAK" THEN BEGIN
2492: 3516:                                     !Problem with received response
2493: 3516:                                     ARG.RETURN.CODE = 02H
2494: 351b:                                     CALL DECAPI.LOG("DEC Response = " + RESPONSE$,0)                                                    ! BMG  
2495: 3556:                                     CALL DECAPI.LOG("Problem with response   - NAKerrorcode,message,payload",0)                         ! BMG
2496: 3586:                                     CALL DECAPI.LOG(RES$,0)                                                                             ! BMG
2497: 35a7:                                     RESPONSE$ = "NAK0"+STR$(ARG.RETURN.CODE)                                                            ! BMG                 
2498: 35c6:                                  ENDIF ELSE BEGIN
2499: 35c6:                                      WHILE RIGHT$(RES$,2) <> CRTLF$ AND LEFT$(RES$,3) <> "NAK" AND RC% = 0
2500: 35c9:                                         RESPONSE$ = RESPONSE$ + RES$
2501: 35e5:                                         CALL DECAPI.LOG("RESPONSE      - ACK(" + STR$(LEN(RES$)) + " Bytes)",0)                         ! BMG
2502: 3642:                                         RES$ = ""
2503: 364f:                                         CALL SOCK.RECV(SOCKET.HANDLE%,RES$,0,RC%)
2504: 3679:                                      WEND
2505: 36fb:                                      IF RC% <> 0 THEN BEGIN
2506: 3702:                                         RESPONSE$ = "NAK0"+STR$(03H)
2507: 3722:                                      ENDIF ELSE BEGIN   
2508: 3722:                                          IF LEFT$(RES$,3) <> "NAK" THEN BEGIN
2509: 374f:                                             RESPONSE$ = RESPONSE$ + RES$
2510: 376b:                                         ! Request / response elapsed time                                                               ! BMG
2511: 376b:                                             IF DEC.TRANSTATUS THEN BEGIN
2512: 3776:                                                RESPONSE$ = CHECK.PAYLOAD.AND.TRANSLATE(RESPONSE$,"&AMP;",AMPERSAND$)
2513: 3797:                                                RESPONSE$ = CHECK.PAYLOAD.AND.TRANSLATE(RESPONSE$,"&CRTLF;",CRTLF$)
2514: 37b8:                                                RESPONSE$ = CHECK.PAYLOAD.AND.TRANSLATE(RESPONSE$,"&PIPE;",PIPE$)
2515: 37d9:                                                RESPONSE$ = CHECK.PAYLOAD.AND.TRANSLATE(RESPONSE$,"&QUOT;",QUOTE$)
2516: 37fa:                                             ENDIF
2517: 37fa:                                              RESPONSE$ = MESSAGE.ARRAY(RESPONSE$)                                                       ! EMG
2518: 380f:                                         ! Request / response elapsed time                                                               ! BMG
2519: 380f:                                             CALL DECAPI.LOG("DEC Response ("+ DECAPI.CLIENT$ + ") = " + RESPONSE$,0)                    ! BMG
2520: 3859:                                             CALL DECAPI.LOG("Socket response time  - " + RESPONSE.TIME + "ms",0)                        ! BMG
2521: 389b:                                          ENDIF ELSE BEGIN
2522: 389b:                                             !Problem with received response
2523: 389b:                                             CALL DECAPI.LOG("Problem with response - Client:" + DECAPI.CLIENT$+" Socket_handle:" +      \ BMG 
2524: 3921:                                                              STR$(SOCKET.HANDLE%)+ "Return code: " + STR$(RC%) + " TCP_ERROR_NO:" +     \ BMG
2525: 3921:                                                              STR$(TCPERRNO%),0)                                                         ! BMG
2526: 3921:                                             CALL DECAPI.LOG(RES$,0)                                                                     ! BMG        
2527: 3942:                                             ARG.RETURN.CODE = 02H                                                                       ! BMG
2528: 3947:                                             RESPONSE$ = "NAK0"+STR$(ARG.RETURN.CODE)                                                    ! BMG
2529: 3963:                                          ENDIF 
2530: 3963:                                      ENDIF
2531: 3963:                                  ENDIF    
2532: 3963:                                ENDIF     
2533: 3963:                             PAYLOAD.COMPLETE = ACK
2534: 396b:                             ENDIF ELSE BEGIN
2535: 396b:                                RESPONSE$ = "NAK00"
2536: 3978:                             ENDIF
2537: 3978:                         WEND
2538: 3982:                 ENDIF
2539: 3984:             ENDIF ELSE BEGIN
2540: 3984:                ARG.RETURN.CODE = 01H
2541: 3989:                RESPONSE$ = "NAK0"+STR$(ARG.RETURN.CODE)
2542: 39a5:                CALL DECAPI.LOG("No response Timed out  - Return Code " + STR$(RC%)  ,0)                                                 ! BMG
2543: 39e3:             ENDIF
2544: 39e3: 
2545: 39e3: 
2546: 39e3: 
2547: 39e3: RESUME.HERE:
2548: 39e5: 
2549: 39e5:        ENDIF ELSE BEGIN                                                                                                                 ! EMG
2550: 39e5:                                                                                                                                         ! EMG
2551: 39e5:            ! Pop next message from queue                                                                                                ! EMG
2552: 39e5:            RESPONSE$ = "NAK"                                                                                                            ! EMG
2553: 39f2:                                                                                                                                         ! EMG
2554: 39f2:        ENDIF                                                                                                                            ! EMG
2555: 39f2: 
2556: 39f2:         IF LEFT$(RESPONSE$,3) = "NAK" AND SOCKET.MESSAGE.ARRAY$(0) <> "" THEN BEGIN                                                     ! EMG
2557: 3a5a:            RESPONSE$ = MESSAGE.ARRAY("NAK")                                                                                             ! EMG           
2558: 3a6b:            CALL DECAPI.LOG("PASSING MESSAGE FROM INTERNAL API QUEUE",0)                                                                 ! EMG          
2559: 3a9b:            CALL DECAPI.LOG("API Queue Response = " + RESPONSE$,0)                                                                       ! EMG
2560: 3ad6:            CALL DECAPI.LOG("DEC Response ("+ DECAPI.CLIENT$ + ") = " + RESPONSE$,0)                                                     ! EMG
2561: 3b20:            CALL DECAPI.LOG("Socket response time  - " + RESPONSE.TIME + "ms",0)                                                         ! EMG
2562: 3b5f:         ENDIF                                                                                                                           ! EMG
2563: 3b5f: 
2564: 3b5f:         DECAPI.RECV = RESPONSE$
2565: 3b71: 
2566: 3b71:         EXIT FUNCTION
2567: 3b73: 
2568: 3b73: ABORT.FUNCTION:
2569: 3b73: 
2570: 3b73:         RESUME RESUME.HERE
2571: 3b82: 
2572: 3b82: END FUNCTION
2573: 3b93: 
2574: 3b93: \**************************************************************************************
2575: 3b93: \***                
2576: 3b93: \***    DECAPI.EVENT (ARG.MESSAGEID$, ARG.DATA$, ARG.REASONCODE%)                                                                       ! BMG
2577: 3b93: \***                                                                                                                                    ! BMG
2578: 3b93: \***    Status and accepted reason codes                                                                                                ! BMG
2579: 3b93: \***       REASONCODE%                  MEANING                                                                                         ! BMG
2580: 3b93: \***        EV00000                      Response not yet available                                                                     ! BMG
2581: 3b93: \***                                        No response from DEC                                                                        ! BMG
2582: 3b93: \***        EV00001                      Timed out waiting for response                                                                 ! BMG
2583: 3b93: \***                                        DATA$ relates to PAYLOAD                                                                    ! BMG
2584: 3b93: \***        EV00002                      Invalid payload                                                                                ! BMG
2585: 3b93: \***                                        Client received corrupt payload                                                             ! BMG
2586: 3b93: \***        EV00003                      Incomplete message                                                                             ! BMG
2587: 3b93: \***                                        Bad response from DEC                                                                       ! BMG
2588: 3b93: \***        EV00004                      DEC Socket closed                                                                              ! BMG
2589: 3b93: \***                                        DEC shut down socket                                                                        ! BMG
2590: 3b93: \***        EV00005                      Good(e) response                                                                               ! BMG
2591: 3b93: \***                                        DATA$ relates to request / response time                                                    ! BMG
2592: 3b93: \***        EV00006                      Socket down                                                                                    ! BMG
2593: 3b93: \***                                        Could not create socket connection                                                          ! BMG
2594: 3b93: \***        EV00007                      EPOS Queue file down                                                                           ! BMG
2595: 3b93: \***                                        Could not open the queue file                                                               ! BMG
2596: 3b93: \***
2597: 3b93: \***
2598: 3b93: \**************************************************************************************
2599: 3b93: 
2600: 3b93: FUNCTION DECAPI.EVENT (ARG.MESSAGEID$, ARG.DATA$, ARG.REASONCODE%) PUBLIC                                                               ! BMG
2601: 3bb1:                                                                                                                                         ! BMG
2602: 3bb1:     STRING    ARG.MESSAGEID$                                                                                                            ! BMG
2603: 3bb1:     STRING    ARG.DATA$                                                                                                                 ! BMG
2604: 3bb1:     STRING    EVENT.MESSAGE                                                                                                             ! BMG
2605: 3bb1:     INTEGER*1 DECAPI.EVENT                                                                                                              ! BMG
2606: 3bb1:     INTEGER*1 ARG.RETURN.CODE                                                                                                           ! BMG
2607: 3bb1:     INTEGER*1 RC%                                                                                                                       ! BMG
2608: 3bb1:     INTEGER*2 ARG.REASONCODE%                                                                                                           ! BMG
2609: 3bb1:                                                                                                                                         ! BMG
2610: 3bb1:     ARG.RETURN.CODE = -1                                                                                                                ! BMG
2611: 3bb6:                                                                                                                                         ! BMG
2612: 3bb6:       CALL MESSAGEID.MATCH(ARG.MESSAGEID$,ACK)                                                                                          ! BMG
2613: 3bc6:       IF FOUND AND MESSAGE.MATCH THEN BEGIN                                                                                             ! BMG
2614: 3bd2:          ARG.DATA$ = CHECK.PAYLOAD.AND.TRANSLATE(ARG.DATA$,"&PIPE;",PIPE$)                                                              ! BMG
2615: 3bf2:          CALL DECAPI.LOG("CLI" + STR$(ARG.REASONCODE%)+ PIPE$ + ARG.MESSAGEID$ + " "                                                    \ BMG
2616: 3c53:                         + ARG.DATA$,1)                                                                                                  ! BMG
2617: 3c53:          FOUND = NAK                                                                                                                    ! BMG
2618: 3c5b:       ENDIF ELSE BEGIN                                                                                                                  ! BMG
2619: 3c5b:          ARG.RETURN.CODE  = 03H                                                                                                         ! BMG
2620: 3c60:       ENDIF                                                                                                                             ! BMG
2621: 3c60:                                                                                                                                         ! BMG
2622: 3c60:     DECAPI.EVENT = ARG.RETURN.CODE                                                                                                      ! BMG
2623: 3c66:                                                                                                                                         ! BMG
2624: 3c66: END FUNCTION                                                                                                                            ! BMG
2625: 3c7f: 
2626: 3c7f: 
2627: 3c7f: \********************************************************************
2628: 3c7f: \***
2629: 3c7f: \***    DECAPI.COMMAND (COMMAND$, DATA$)
2630: 3c7f: \***
2631: 3c7f: \********************************************************************
2632: 3c7f: 
2633: 3c7f: FUNCTION DECAPI.COMMAND(ARG.COMMAND$,ARG.DATA$) PUBLIC
2634: 3c9d: 
2635: 3c9d:     STRING    ARG.COMMAND$
2636: 3c9d:     STRING    ARG.DATA$
2637: 3c9d:     INTEGER*1 DECAPI.COMMAND
2638: 3c9d:     INTEGER*1 ARG.RETURN.CODE 
2639: 3c9d:     INTEGER*1 RC% 
2640: 3c9d:     
2641: 3c9d:     ARG.RETURN.CODE = -1
2642: 3ca2:     
2643: 3ca2:     CALL MESSAGEID.MATCH(ARG.COMMAND$,NAK)                                                                                              ! BMG
2644: 3cb2: 
2645: 3cb2:     ! Check that not being used as DECAPI.SEND                                                                                          ! BMG
2646: 3cb2:     IF NOT FOUND THEN BEGIN                                                                                                             ! BMG
2647: 3cb9:        RC% = SOCK.SEND(SOCKET.HANDLE%,ARG.COMMAND$ + "|" + ARG.DATA$ + CRTLF$,0)                                                        ! BMG
2648: 3cf7:        IF LEN(ARG.COMMAND$ + "|" + ARG.DATA$ + CRTLF$) = RC% THEN BEGIN                                                                 ! BMG
2649: 3d23:           ARG.RETURN.CODE = 0                                                                                                           ! BMG
2650: 3d28:        ENDIF                                                                                                                            ! BMG
2651: 3d28:     ENDIF
2652: 3d28: 
2653: 3d28:     DECAPI.COMMAND = ARG.RETURN.CODE
2654: 3d2e: 
2655: 3d2e: END FUNCTION
2656: 3d47: 
2657: 3d47: 
2658: 3d47: \********************************************************************
2659: 3d47: \***
2660: 3d47: \***    DECAPI.RECV.RESPONSE.TIME
2661: 3d47: \***
2662: 3d47: \********************************************************************
2663: 3d47: 
2664: 3d47: FUNCTION DECAPI.RECV.RESPONSE.TIME PUBLIC
2665: 3d5b: 
2666: 3d5b:     STRING DECAPI.RECV.RESPONSE.TIME
2667: 3d5b: 
2668: 3d5b:     DECAPI.RECV.RESPONSE.TIME = RESPONSE.TIME
2669: 3d6d: 
2670: 3d6d: END FUNCTION 
2671: 3d7e: 
2672: 3d7e: End of Compilation
