   1: 0000: \*****************************************************************************
   2: 0000: \*****************************************************************************
   3: 0000: \***
   4: 0000: \***    PROGRAM  .....  MINPRINT
   5: 0000: \***    MODULE  ......  MINRFCNT.BAS
   6: 0000: \***
   7: 0000: \***    REVISION 1.0.           Arun Sudhakarannair             14th June 2012
   8: 0000: \***    Original version.
   9: 0000: \***
  10: 0000: \***    VERSION B (1.1)         Tittoo Thomas                   04th Sept 2012
  11: 0000: \***    Fixed to specify the date format in RFCNTLST header to DD/MM/YY.
  12: 0000: \***    (SFA defect ID 600)
  13: 0000: \***
  14: 0000: \***    VERSION C (1.2)         Charles Skadorwa (CCSk)         10th Sept 2012
  15: 0000: \***    SFA Defect 661 - Summary counts are not updated.
  16: 0000: \***    Corrected Summary headings: "User Generated Lists" and
  17: 0000: \***         "Support Office Lists" swapped around (in 2 places).
  18: 0000: \***    Corrected time separator from "." to ":".
  19: 0000: \***    Commented out redundant code (as set by file function) and
  20: 0000: \***         moved a static variable outside of a loop.
  21: 0000: \***
  22: 0000: \***    VERSION D (1.3)            Tittoo Thomas (DTT)          24th Sept 2012
  23: 0000: \***    SFA Defect 693, 694 - Operator name and list creation time not correct
  24: 0000: \***    Corrected Summary & Detail headings: "User Generated Lists" and
  25: 0000: \***         "Support Office Lists" swapped around (in 2 places).
  26: 0000: \***
  27: 0000: \***    VERSION E (1.4)            Tittoo Thomas (ETT)          02nd Nov 2012
  28: 0000: \***    SFA Defect 779 - Excluded lists with Zero items or currently "In Creation"
  29: 0000: \***    status.
  30: 0000: \***
  31: 0000: \***    Version F              Ranjith Gopalankutty(FRG)     10th Feb  2017
  32: 0000: \***    After 16A rollout MINPRINT is triggered after midnight as part of  
  33: 0000: \***    end of the day reset, there is a date check happens in MINRFCNT    
  34: 0000: \***    module before adding the records to RFCNTLST.DAY. Since the date   
  35: 0000: \***    match doesn't happen, records are being ignored and count list     
  36: 0000: \***    are not appearing in controller screen. Fix is to ensure the date  
  37: 0000: \***    parameter check is correct and record is added if the run is after 
  38: 0000: \***    mid night.                                                         
  39: 0000: \*****************************************************************************
  40: 0000: \***                                  OVERVIEW
  41: 0000: \***                                  ========
  42: 0000: \***    MINRFCNT takes data from CLILF and CLOLF and prepares RF Count report
  43: 0000: \***    (RFCNTLST.DAY). This report can be viewed both on the controller and
  44: 0000: \***    RF PPC/MC55 and POD MC55/MC70.
  45: 0000: \***
  46: 0000: \***    The report is split into 2 sections. The first part is a summary for
  47: 0000: \***    each count list type (Negative, User Generated and Support Office).
  48: 0000: \***    The second part gives details of which users performed the counts,
  49: 0000: \***    and whether the list was fully counted, part counted or not counted
  50: 0000: \***    at all.
  51: 0000: \***
  52: 0000: \*****************************************************************************
  53: 0000: \*****************************************************************************
  54: 0000: 
  55: 0000: \*****************************************************************************
  56: 0000: \***
  57: 0000: \***    DEC included code defining file related fields
  58: 0000: \***
  59: 0000: \***..........................................................................
  60: 0000: 
  61: 0000:     %INCLUDE   AFDEC.J86        ! GSA Authorisation File field declaration
  62: 0000: 
  63: 0000: \REM
  64: 0000: \*******************************************************************************
  65: 0000: \*******************************************************************************
  66: 0000: \***
  67: 0000: \***    %INCLUDE FOR GSA AUTHORISATION FILE VARIABLE DECLARATIONS
  68: 0000: \***
  69: 0000: \***        REFERENCE   :  AFDEC (J86)
  70: 0000: \***
  71: 0000: \***        FILE TYPE   :  Keyed
  72: 0000: \***
  73: 0000: \***    The GSA Authorisation File (EALAUTH.DAT) should not be confused with
  74: 0000: \***    the Operating System Authorisation File (ADXCSOUF.DAT).
  75: 0000: \***
  76: 0000: \***    VERSION A.              ROBERT COWEY.                       18 AUG 1992.
  77: 0000: \***    Original version created by merging AFFLDD and AFNUMD.
  78: 0000: \***
  79: 0000: \***    VERSION B.              Steve Windsor                          Nov 1992.
  80: 0000: \***    Addition of new fields for the CASTLE project.
  81: 0000: \***    Supervisor flag and operator model.
  82: 0000: \***
  83: 0000: \***    VERSION C.              ROBERT COWEY.                       03 MAR 1994.
  84: 0000: \***    Defined fields DATE.PSWD.CHANGE$, and MODEL.FLAGS.1% and ...2%.
  85: 0000: \***
  86: 0000: \***    VERSION D.             Mike Bishop                          30 JUN 2004
  87: 0000: \***    Defined field AF.STAFF.NUM$ AF.EMPLOYEE.FLAG$
  88: 0000: \***
  89: 0000: \***    VERSION E.             Alan Carr  (AJC)                      4 Oct 2004
  90: 0000: \***    Defined field AF.RECEIPT.NAME$
  91: 0000: \***
  92: 0000: \***    VERSION F.             Alan Carr  (AJC)                     31 Jan 2005
  93: 0000: \***    Defined field AF.GROUP.CODE$
  94: 0000: \***
  95: 0000: \***    REVISION 1.6.                ROBERT COWEY.                15 JUN 2009.
  96: 0000: \***    Changes for A9C POS improvements project.
  97: 0000: \***    Used up last available three bytes of EALAUTH user data by redefining 
  98: 0000: \***    remaining AF.USER$ variable as AF.BIRTH.DATE$.
  99: 0000: \***    See IBM manual "GSA Programming Guide" Appendix A-27 for file layout 
 100: 0000: \***    describing INDICAT flags (and position of original 20 bytes user data).
 101: 0000: \***
 102: 0000: \***    REVISION 1.7.                ROBERT COWEY.                22 JUN 2009.
 103: 0000: \***    Changes for A9C POS improvements project creating PSB99.286 Rv 1.8.
 104: 0000: \***    Defect 3247 - Redefined AF.BIRTH.DATE$ format as UPD-hex DDMCYY.
 105: 0000: \***    Description text change only - No code changes to this file.
 106: 0000: \***
 107: 0000: \*******************************************************************************
 108: 0000: \*******************************************************************************
 109: 0000: 
 110: 0000: 
 111: 0000:     STRING GLOBAL \
 112: 0000:         AF.BIRTH.DATE$,       \ ! 3 byte DDMCYY UPD/hex format         ! 1.7 RC
 113: 0000:                               \ ! M is month  A=Oct B=Nov C=Dec        ! 1.7 RC
 114: 0000:                               \ ! C is century  0=19xx 1=20xx          ! 1.7 RC
 115: 0000:         AF.DATE.PSWD.CHANGE$, \ ! 3 bytes UPD                          ! CRC
 116: 0000:         AF.FILE.NAME$, \
 117: 0000:         AF.FLAGS.01.12$, \      ! 15 bytes
 118: 0000:         AF.FLAGS.13.16$, \      ! 4 bytes
 119: 0000:         AF.OPERATOR.NAME$,\     ! 20 bytes
 120: 0000:         AF.OPERATOR.NO$, \      ! 4 byte UPD (key)
 121: 0000:         AF.OPTIONS.KEY$, \      ! 1 byte UPD
 122: 0000:         AF.PASSWORD$, \         ! 4 byte UPD
 123: 0000:         AF.RECEIPT.NAME$, \     ! 12 bytes                             ! AJC
 124: 0000:         AF.STAFF.NUM$, \         ! 4 byte UPD                          DMB
 125: 0000:         AF.EMPLOYEE.FLAG$, \     ! 1 byte UPD                          DMB
 126: 0000:         AF.GROUP.CODE$, \       ! 1  byte UPD                          AJC
 127: 0000: \       AF.USER$, \             ! 3  bytes                             ! 1.6 RC
 128: 0000:         AF.SUP.FLAG$, \         ! 1  byte                              BSJW
 129: 0000:         AF.OP.MODEL$            ! 3  bytes                             BSJW
 130: 0000: 
 131: 0000:     INTEGER*1 GLOBAL \
 132: 0000:         AF.INDICAT4%, \
 133: 0000:         AF.INDICAT5%, \
 134: 0000:         AF.INDICAT6%, \
 135: 0000:         AF.INDICAT7%, \
 136: 0000:         AF.INDICAT8%, \
 137: 0000:         AF.INDICAT9%, \
 138: 0000:         AF.INDICAT10%, \
 139: 0000:         AF.INDICAT11%, \
 140: 0000:         AF.INDICAT12%, \
 141: 0000:         AF.INDICAT13%, \
 142: 0000:         AF.INDICAT14%, \
 143: 0000:         AF.INDICAT15%, \
 144: 0000:         AF.INDICAT16%, \
 145: 0000:         AF.REPORT.NUM%
 146: 0000: 
 147: 0000:     INTEGER*2 GLOBAL \
 148: 0000:         AF.INDICAT1%, \
 149: 0000:         AF.INDICAT2%, \
 150: 0000:         AF.INDICAT3%, \
 151: 0000:         AF.MODEL.FLAGS.1%, \                                           ! CRC
 152: 0000:         AF.MODEL.FLAGS.2%, \                                           ! CRC
 153: 0000:         AF.RECL%, \
 154: 0000:         AF.SESS.NUM%
 155: 0000: 
 156: 0000:     %INCLUDE   CLILFDEC.J86     ! RF Count Lists File
 157: 0000: 
 158: 0000: \******************************************************************************\******************************************************************************
 159: 0000: \******************************************************************************
 160: 0000: \***
 161: 0000: \***         %INCLUDE FOR RF COUNT LISTS FILE FIELD DECLARATIONS
 162: 0000: \***
 163: 0000: \***               FILE TYPE    : KEYED
 164: 0000: \***
 165: 0000: \***               REFERENCE    : CLILFDEC.J86
 166: 0000: \***
 167: 0000: \***    VERSION A.              Nik Sen.                 13 October 1998
 168: 0000: \***                 New file for RF system. Holds count lists information.
 169: 0000: \***
 170: 0000: \***    VERSION B               Charles Skadorwa         22nd January 1999
 171: 0000: \***                 Head Office Sequence Number now held (from PIITM
 172: 0000: \***                 record) in order that a "complete" Type 13 transaction
 173: 0000: \***                 record is written to the STKMQ file. 
 174: 0000: \***
 175: 0000: \***    REVISION 1.4.            ROBERT COWEY.                  09 SEP 2003.
 176: 0000: \***    Changes for RF trial.
 177: 0000: \***    Removed redundant PVCS revision control block from top of code.
 178: 0000: \***    Recompiled to prevent future automatic recompiles.
 179: 0000: \***    No changes to actual code.
 180: 0000: \***
 181: 0000: \***    REVISION 1.5             ALAN CARR                      12 AUG 2004.
 182: 0000: \***    Changes for RF OSSR solution.
 183: 0000: \***    Added new fields for Off-Site StockRoom (OSSR) Basic Solution
 184: 0000: \***
 185: 0000: \***    REVISION 1.6             Mark Goode                     25th January 2005 
 186: 0000: \***
 187: 0000: \***    REVISION 1.7             Syam Jayan                     25th January 2012
 188: 0000: \***    The change is to rearrange/remove redundant fields and to add new
 189: 0000: \***    fields in CLILF Format as part of Stock file accuracy project
 190: 0000: \***
 191: 0000: \*******************************************************************************
 192: 0000: \*******************************************************************************
 193: 0000: 
 194: 0000: STRING GLOBAL                     \
 195: 0000:     CLILF.BOOTSCODE$,             \                                          ! 1.7 SJ
 196: 0000:     CLILF.COUNTED.STATUS$,        \ U-not counted, P-partially counted,      ! 1.7 SJ
 197: 0000:                                   \ C-counted                                ! 1.7 SJ
 198: 0000:     CLILF.DATE.LASTCNT$,          \ Date of Last Count field                 ! 1.7 SJ
 199: 0000:     CLILF.FILE.NAME$,             \                                          ! 1.7 SJ
 200: 0000:     CLILF.FILLER$(1),             \ Filler Array                             ! 1.7 SJ
 201: 0000:     CLILF.HO.SEQNO$,              \ Head Office Sequence No. from PIITM for  ! 1.7 SJ
 202: 0000:                                   \ Stock Support                            ! BCS ! 1.7 SJ
 203: 0000:     CLILF.ITEMSEQ$,               \ Item Sequence Number                     ! 1.7 SJ
 204: 0000:     CLILF.KEY$,                   \ LISTID + ITEMSEQ                         ! 1.7 SJ
 205: 0000:     CLILF.LISTID$,                \ List Number                              ! 1.7 SJ
 206: 0000:     CLILF.SPACE$                  ! Free space                               ! 1.7 SJ
 207: 0000:     !CLILF.BARCODE$,              \                                          ! 1.7 SJ
 208: 0000:     !CLILF.SELDESC$,              \ Shelf Edge Label Descriptor              ! 1.7 SJ
 209: 0000:     !CLILF.DEALMKR$,              \ Active Deal Marker                       ! 1.7 SJ
 210: 0000:     !CLILF.PRODGRP$,              \ Concept/Sequence Number                  ! 1.7 SJ
 211: 0000:     !CLILF.PRODGRPDESC$,          \ Product Group Descriptor                 ! 1.7 SJ 
 212: 0000:     !CLILF.BSCNT$,                \ Back Shop Counts                         ! 1.7 SJ
 213: 0000:     !CLILF.SFCNT$,                \ Shop Floor Counts                        ! 1.7 SJ
 214: 0000:     !CLILF.SALESSFCNT$,           \ Signed Sales at time of Shop Floor Count ! 1.7 SJ
 215: 0000:     !CLILF.SALEBSCNT$,            \ Sale at time of back shop count \ 1.5 AC ! 1.7 SJ
 216: 0000:     !CLILF.SALEOSSRCNT$,          \ Sale at time of OSSR count      \ 1.5 AC ! 1.7 SJ
 217: 0000:     !CLILF.OSSR.ITMSTKCNT$,       \ OSSR Item Stock count figure    \ 1.5 AC ! 1.7 SJ
 218: 0000:     !CLILF.TIMESFCNT$,            \ Time of Stock Floor count hh:mm \ 1.5 AC ! 1.7 SJ
 219: 0000:     !CLILF.TIMEBSCNT$,            \ Time of Back shop count hh:mm   \ 1.5 AC ! 1.7 SJ
 220: 0000:     !CLILF.TIMEOSSRCNT$,          \ Time of OSSR count hh:mm        \ 1.5 AC ! 1.7 SJ
 221: 0000: 
 222: 0000: INTEGER*4 GLOBAL                 \
 223: 0000:     CLILF.MODULE.ID%(1)          ! Planner ID Array (SRITL.POGDB%)           ! 1.7 SJ
 224: 0000: 
 225: 0000: INTEGER*2 GLOBAL                 \
 226: 0000:     CLILF.BSCNT%,                \ Main Backshop MBS Count                   ! 1.7 SJ
 227: 0000:     CLILF.BS.PEND.SA.CNT%,       \ Back Shop pending sales plan Count        ! 1.7 SJ
 228: 0000:     CLILF.COUNT%(1),             \ Count Array                               ! 1.7 SJ
 229: 0000:     CLILF.FILL.QUANTITY%(1),     \                                           ! 1.7 SJ
 230: 0000:     CLILF.OSSR.ITMSTKCNT%,       \ OSSR Item Stock count figure              ! 1.7 SJ
 231: 0000:     CLILF.OSSR.PEND.SA.CNT%,     \ OSSR pending sales plan Count field       ! 1.7 SJ
 232: 0000:     CLILF.RECL%,                 \                                           ! 1.7 SJ
 233: 0000:     CLILF.REPORT.NUM%,           \                                           ! 1.7 SJ
 234: 0000:     CLILF.SALESCNT%,             \ Sales count                               ! 1.7 SJ
 235: 0000:     CLILF.SESS.NUM%,             \ Clilf session number                      ! 1.7 SJ
 236: 0000:     CLILF.SFCNT%                 ! Shop floor count                          ! 1.7 SJ
 237: 0000:   
 238: 0000: INTEGER*1 GLOBAL                 \
 239: 0000:     CLILF.MODULE.SEQ%(1),        \ Module Seq Array (SRITL.MODULE.SEQ%)      ! 1.7 SJ
 240: 0000:     CLILF.REPEAT.CNT%(1)         ! Repeat Count Array (SRITL.REPEAT.CNT%)    ! 1.7 SJ
 241: 0000:     !CLILF.RECL%                 !                                           ! 1.7 SJ
 242: 0000: 
 243: 0000:     %INCLUDE   CLOLFDEC.J86     ! RF Count List Of Lists File
 244: 0000: 
 245: 0000: \******************************************************************************\******************************************************************************
 246: 0000: \******************************************************************************
 247: 0000: \***
 248: 0000: \***         %INCLUDE FOR RF LIST OF LISTS FILE FIELD DECLARATIONS
 249: 0000: \***
 250: 0000: \***               FILE TYPE    : DIRECT
 251: 0000: \***
 252: 0000: \***               REFERENCE    : CLOLFDEC.J86
 253: 0000: \***
 254: 0000: \***    VERSION A.           Nik Sen.               13 October 1998
 255: 0000: \***               New file for RF system. Holds list of counting lists. 
 256: 0000: \***
 257: 0000: \***    VERSION B            Charles Skadorwa        22nd January 1999
 258: 0000: \***               TOTAL.ITEMS added to keep track of total items in each list.
 259: 0000: \***                 
 260: 0000: \***    REVISION 1.4.            ROBERT COWEY.                  09 SEP 2003.
 261: 0000: \***    Changes for RF trial.
 262: 0000: \***    Removed redundant PVCS revision control block from top of code.
 263: 0000: \***    Recompiled to prevent future automatic recompiles.
 264: 0000: \***    No changes to actual code.
 265: 0000: \***
 266: 0000: \***    REVISION 1.5             ALAN CARR                     12 AUG 2004.
 267: 0000: \***    Changes for RF OSSR solution.
 268: 0000: \***    Added new flag "marked for OSSR count". This can be "Y" or "N"
 269: 0000: \***
 270: 0000: \***    REVISION 1.6            MARK GOODE                     5th January 2005.
 271: 0000: \***    Changes for RF OSSR WAN solution.
 272: 0000: \***    New field on the header record for remaining OSSR count figure and user ID
 273: 0000: \***
 274: 0000: \***    REVISION 1.7            SYAM JAYAN                     25th January 2012
 275: 0000: \***    The change is to rearrange/remove redundant fields and to add new
 276: 0000: \***    fields in CLOLF Format as part of Stock file accuracy project
 277: 0000: \***
 278: 0000: \*******************************************************************************
 279: 0000: \*******************************************************************************
 280: 0000: 
 281: 0000: STRING GLOBAL                   \
 282: 0000:     CLOLF.ACTIVE.STATUS$,       \                        ! 1.7 SJ
 283: 0000:     CLOLF.BULETT$,              \                        ! 1.7 SJ
 284: 0000:     CLOLF.CREATION.DATE$,       \Creation date           ! 1.7 SJ
 285: 0000:     CLOLF.CREATION.TIME$,       \Creation time           ! 1.7 SJ
 286: 0000:     CLOLF.CURRENT.LOCATION$,    \Current location        ! 1.7 SJ
 287: 0000:     CLOLF.EXPIRY.DATE$,         \Expiry date             ! 1.7 SJ
 288: 0000:     CLOLF.FILE.NAME$,           \                        ! 1.7 SJ
 289: 0000:     CLOLF.LISTID$,              \                        ! 1.7 SJ
 290: 0000:     CLOLF.LIST.NAME$,           \                        ! 1.7 SJ
 291: 0000:     CLOLF.LSTTYP$,              \                        ! 1.7 SJ
 292: 0000:     CLOLF.PICKER.USER.ID$,      \                        ! 1.7 SJ
 293: 0000:     CLOLF.PILST.ID$,            \                        ! 1.7 SJ
 294: 0000:     CLOLF.PICK.START.TIME$,     \Pick start time         ! 1.7 SJ
 295: 0000:     CLOLF.PICK.END.TIME$,       \Pick end time           ! 1.7 SJ
 296: 0000:     CLOLF.USERID$               ! 1.6 MG                 ! 1.7 SJ
 297: 0000:     !CLOLF.TOTAL.ITEMS$,        \ BCS                    ! 1.7 SJ
 298: 0000:     !CLOLF.SRITEMS$,            \                        ! 1.7 SJ
 299: 0000:     !CLOLF.BSITEMS$,            \                        ! 1.7 SJ
 300: 0000:     !CLOLF.BUNAME$,             \                        ! 1.7 SJ
 301: 0000:     !CLOLF.HOLISTID$,           \                        ! 1.7 SJ
 302: 0000:     !CLOLF.CNTDATE$,            \ 1.5 AC                 ! 1.7 SJ
 303: 0000:     !CLOLF.OSSR.FLAG$,          \ 1.5 AC                 ! 1.7 SJ
 304: 0000:     !CLOLF.OSSRITEMS$,          \ 1.6 MG                 ! 1.7 SJ
 305: 0000:   
 306: 0000: INTEGER*4 GLOBAL                \
 307: 0000:     CLOLF.RECORD.NUM%
 308: 0000: 
 309: 0000: INTEGER*2 GLOBAL                \
 310: 0000:     CLOLF.BSITEMS%,             \                        ! 1.7 SJ
 311: 0000:     CLOLF.OSSRITEMS%,           \                        ! 1.7 SJ
 312: 0000:     CLOLF.REPORT.NUM%,          \                        ! 1.7 SJ
 313: 0000:     CLOLF.SESS.NUM%,            \                        ! 1.7 SJ
 314: 0000:     CLOLF.SRITEMS%,             \                        ! 1.7 SJ
 315: 0000:     CLOLF.TOTAL.ITEMS%          !                        ! 1.7 SJ
 316: 0000:                                                   
 317: 0000: INTEGER*1 GLOBAL                \
 318: 0000:     CLOLF.RECL%         
 319: 0000: 
 320: 0000: 
 321: 0000: 
 322: 0000: \*****************************************************************************
 323: 0000: \***
 324: 0000: \***    Included code defining function related global variables
 325: 0000: \***
 326: 0000: \***..........................................................................
 327: 0000: 
 328: 0000:     %INCLUDE PSBF01G.J86        ! APPLICATION.LOG
 329: 0000: REM \
 330: 0000: \*******************************************************************************
 331: 0000: \*******************************************************************************
 332: 0000: \***
 333: 0000: \***       %INCLUDE FOR GLOBAL DEFINITIONS FOR FUNCTION APPLICATION.LOG
 334: 0000: \***
 335: 0000: \***                FUNCTION NUMBER    : PSBF01
 336: 0000: \***
 337: 0000: \***                REFERENCE          : PSBF01G.J86
 338: 0000: \***
 339: 0000: \***                DATE OF LAST AMENDMENT  - 27/2/86
 340: 0000: \***
 341: 0000: \***
 342: 0000: \*******************************************************************************
 343: 0000: 
 344: 0000:       INTEGER GLOBAL  F01.RETURN.CODE%
 345: 0000: 
 346: 0000: 
 347: 0000:     %INCLUDE PSBF02G.J86        ! UPDATE date variable                  ! FRG
 348: 0000: REM\
 349: 0000: \*******************************************************************************
 350: 0000: \*******************************************************************************
 351: 0000: \***
 352: 0000: \***        INCLUDE       : UPDATE.DATE globals
 353: 0000: \***
 354: 0000: \***        REFERENCE     : PSBF02G.J86
 355: 0000: \***
 356: 0000: \***        Version A     Bruce Scriver      4th March 1986
 357: 0000: \*** 
 358: 0000: \***        Version B     Andrew Wedgeworth   6th July 1992
 359: 0000: \***        Removal of return code field which no longer required.
 360: 0000: \***
 361: 0000: \*******************************************************************************
 362: 0000: \*******************************************************************************
 363: 0000: 
 364: 0000:       STRING   GLOBAL F02.DATE$
 365: 0000: 
 366: 0000:       ! 1 line deleted from here                                       ! BAW
 367: 0000: 
 368: 0000:     %INCLUDE PSBF14G.J86        ! SORT.TABLE globals
 369: 0000: REM\
 370: 0000: \*******************************************************************************
 371: 0000: \*******************************************************************************
 372: 0000: \***
 373: 0000: \***        INCLUDE       : SORT.TABLE globals
 374: 0000: \***
 375: 0000: \***        REFERENCE     : PSBF14G.J86
 376: 0000: \***
 377: 0000: \***        Version A     Bruce Scriver                3rd March 1986
 378: 0000: \*** 
 379: 0000: \***        Version B     Andrew Wedgeworth            17th July 1992
 380: 0000: \***        Removal of now redundant return code field.
 381: 0000: \***
 382: 0000: \*******************************************************************************
 383: 0000: \*******************************************************************************
 384: 0000: 
 385: 0000:       STRING   GLOBAL F14.TABLE$(1)
 386: 0000: 
 387: 0000: 
 388: 0000:     %INCLUDE PSBF20G.J86        ! Allocating Session Numbers            ! FRG
 389: 0000: REM\
 390: 0000: \*******************************************************************************
 391: 0000: \*******************************************************************************
 392: 0000: \***
 393: 0000: \***     %INCLUDE GLOBAL VARIABLE DEFINITIONS FOR SESS.NUM.UTILITY FUNCTION
 394: 0000: \***
 395: 0000: \***                       REFERENCE     : PSBF20G.J86
 396: 0000: \*** 
 397: 0000: \***     Version A              Bruce Scrive                   5th May 1988   
 398: 0000: \*** 
 399: 0000: \***     Version B              Robert Cowey                   7th May 1991
 400: 0000: \***     Global variable F20.INTEGER.FILE.NO% changed from one byte integer
 401: 0000: \***     to two byte integer.
 402: 0000: \***
 403: 0000: \***     Version D              Andrew Wedgeworth             1st July 1992
 404: 0000: \***     F20.RETURN.CODE% removed as it is no longer required.
 405: 0000: \***
 406: 0000: \*******************************************************************************
 407: 0000: \*******************************************************************************
 408: 0000: 
 409: 0000:       STRING    GLOBAL F20.FILE.NAME$,                                 \
 410: 0000:                        F20.STRING.FILE.NO$,                            \
 411: 0000:                        F20.TABLE.DIMENSIONED.FLAG$,                    \
 412: 0000:                        SESS.NUM.TABLE$(1)
 413: 0000: 
 414: 0000:       INTEGER*2 GLOBAL F20.INTEGER.FILE.NO%
 415: 0000: 
 416: 0000:       ! 1 line deleted from here                                       ! DAW 
 417: 0000: 
 418: 0000: 
 419: 0000: 
 420: 0000: \*****************************************************************************
 421: 0000: \***
 422: 0000: \***    Global variable definitions
 423: 0000: \***
 424: 0000: \***..........................................................................
 425: 0000: 
 426: 0000:     STRING GLOBAL               \
 427: 0000:         COMM.MODE.FLAG$,        \
 428: 0000:         CURRENT.CODE$,          \
 429: 0000:         FILE.OPERATION$,        \
 430: 0000:         REPORTING.STATUS$
 431: 0000: 
 432: 0000:     INTEGER*2 GLOBAL            \
 433: 0000:         CURRENT.REPORT.NUM%,    \
 434: 0000:         RFCNTLST.SESS.NUM%
 435: 0000: 
 436: 0000:     INTEGER*1 GLOBAL            \
 437: 0000:         FALSE,                  \
 438: 0000:         TRUE
 439: 0000: 
 440: 0000: \*****************************************************************************
 441: 0000: \***
 442: 0000: \***    Variable definitions
 443: 0000: \***
 444: 0000: \***..........................................................................
 445: 0000: 
 446: 0000:     STRING                      \
 447: 0000:         ADXSERVE.DATA$,         \
 448: 0000:         CURR.LIST.TYPE$,        \
 449: 0000:         CURRENT.TYPE$,          \
 450: 0000:         CURR.CNT.STATUS$,       \
 451: 0000:         CURR.RECORD$,           \
 452: 0000:         CURRENT.CODE.LOGGED$,   \
 453: 0000:         FUNCTION.FLAG$,         \
 454: 0000:         PASSED.STRING$,         \
 455: 0000:         PREV.TYPE$,             \
 456: 0000:         PREV.CNT.STATUS$,       \
 457: 0000:         RFCNTLST.FILE.NAME$,    \
 458: 0000:         RFCNTLST.RECORD$,       \
 459: 0000:         VAR.STRING.1$,          \
 460: 0000:         VAR.STRING.2$
 461: 0000: 
 462: 0000:     INTEGER*1                   \
 463: 0000:         COUNTER%,               \
 464: 0000:         ERROR.COUNT%
 465: 0000: 
 466: 0000:     INTEGER*2                   \
 467: 0000:         ADX.FUNCTION%,          \
 468: 0000:         ADX.INTEGER%,           \
 469: 0000:         CLOLF.NUMRECS%,         \
 470: 0000:         CLILF.COUNTER%,         \
 471: 0000:         CURR.RECORD.INDEX%,     \
 472: 0000:         EVENT.NUMBER%,          \
 473: 0000:         F14.LIMIT%,             \
 474: 0000:         F14TABLE.MAX.INDEX%,    \
 475: 0000:         FUNCTION.RETURN.CODE%,  \
 476: 0000:         ITEMS.NOT.COUNTED%,     \
 477: 0000:         LISTS.COUNTED.ARRAY%(1),\
 478: 0000:         MESSAGE.NUMBER%,        \
 479: 0000:         NUM.LISTS.ARRAY%(1),    \
 480: 0000:         PART.COUNT.ARRAY%(1),   \
 481: 0000:         PASSED.INTEGER%,        \
 482: 0000:         RC%,                    \
 483: 0000:         RFCNTLST.REPORT.NUM%,   \
 484: 0000:         UNCOUNTED.ARRAY%(1)
 485: 0000: 
 486: 0000:     INTEGER*4                   \
 487: 0000:         ADX.RETURN.CODE%
 488: 0000: 
 489: 0000: \*****************************************************************************
 490: 0000: \***
 491: 0000: \***    EXT included code defining file related external functions
 492: 0000: \***
 493: 0000: \***..........................................................................
 494: 0000: 
 495: 0000:     %INCLUDE AFEXT.J86          ! GSA Authorisation File function definition
 496: 0000: 
 497: 0000: \REM
 498: 0000: \*******************************************************************************
 499: 0000: \*******************************************************************************
 500: 0000: \***
 501: 0000: \***    %INCLUDE FOR GSA AUTHORISATION FILE EXTERNAL FUNCTIONS
 502: 0000: \***
 503: 0000: \***        REFERENCE   :  AFEXT (J86)
 504: 0000: \***
 505: 0000: \***        FILE TYPE   :  Keyed
 506: 0000: \***
 507: 0000: \***    The GSA Authorisation File (EALAUTH.DAT) should not be confused with
 508: 0000: \***    the Operating System Authorisation File (ADXCSOUF.DAT).
 509: 0000: \***
 510: 0000: \***    VERSION A.              ROBERT COWEY.                       18 AUG 1992.
 511: 0000: \***    Original version created from AFEXTA.
 512: 0000: \***
 513: 0000: \***    VERSION B.              Steve Windsor                       29 Dec 1992.
 514: 0000: \***    Version incremented to keep in line with other included code           
 515: 0000: \***
 516: 0000: \***    VERSION C.              ROBERT COWEY.                       03 MAR 1994.
 517: 0000: \***    No changes to this file.
 518: 0000: \***
 519: 0000: \***    REVISION 1.6.                ROBERT COWEY.                15 JUN 2009.
 520: 0000: \***    Changes for A9C POS improvements project.
 521: 0000: \***    Used up last available three bytes of EALAUTH user data by redefining 
 522: 0000: \***    remaining AF.USER$ variable as AF.BIRTH.DATE$.
 523: 0000: \***    No changes to this file.
 524: 0000: \***
 525: 0000: \***    REVISION 1.7.                ROBERT COWEY.                22 JUN 2009.
 526: 0000: \***    Changes for A9C POS improvements project creating PSB99.286 Rv 1.8.
 527: 0000: \***    Defect 3247 - Redefined AF.BIRTH.DATE$ format within AFDEC.J86.
 528: 0000: \***    Description text change only - No code changes to this file.
 529: 0000: \***
 530: 0000: \*******************************************************************************
 531: 0000: \*******************************************************************************
 532: 0000: 
 533: 0000: 
 534: 0000: FUNCTION AF.SET EXTERNAL
 535: 0000:     INTEGER*2 AF.SET
 536: 0000: END FUNCTION
 537: 0000: 
 538: 0000: 
 539: 0000: FUNCTION READ.AF EXTERNAL
 540: 0000:     INTEGER*2 READ.AF
 541: 0000: END FUNCTION
 542: 0000: 
 543: 0000: 
 544: 0000: FUNCTION READ.AF.LOCKED EXTERNAL
 545: 0000:     INTEGER*2 READ.AF.LOCKED
 546: 0000: END FUNCTION
 547: 0000: 
 548: 0000:   
 549: 0000: FUNCTION READ.AF.ABREV EXTERNAL
 550: 0000:     INTEGER*2 READ.AF.ABREV
 551: 0000: END FUNCTION
 552: 0000: 
 553: 0000: 
 554: 0000: FUNCTION READ.AF.ABREV.LOCKED EXTERNAL
 555: 0000:     INTEGER*2 READ.AF.ABREV.LOCKED
 556: 0000: END FUNCTION
 557: 0000: 
 558: 0000:   
 559: 0000: FUNCTION WRITE.AF.UNLOCK EXTERNAL
 560: 0000:     INTEGER*2 WRITE.AF.UNLOCK
 561: 0000: END FUNCTION
 562: 0000: 
 563: 0000: 
 564: 0000: FUNCTION WRITE.AF.ABREV EXTERNAL
 565: 0000:     INTEGER*2 WRITE.AF.ABREV
 566: 0000: END FUNCTION
 567: 0000: 
 568: 0000: 
 569: 0000: FUNCTION WRITE.AF.ABREV.UNLOCK EXTERNAL
 570: 0000:     INTEGER*2 WRITE.AF.ABREV.UNLOCK
 571: 0000: END FUNCTION
 572: 0000: 
 573: 0000:     %INCLUDE CLOLFEXT.J86       ! RF Count List Of Lists File
 574: 0000: 
 575: 0000: \******************************************************************************
 576: 0000: \******************************************************************************\*****************************************************************************
 577: 0000: \***
 578: 0000: \***           FUNCTION DEFINITIONS FOR THE RF COUNT LIST OF LISTS FILE
 579: 0000: \***
 580: 0000: \***           REFERENCE:   CLOLFEXT.J86
 581: 0000: \***
 582: 0000: \***           VERSION A         Nik Sen         13th October 1998
 583: 0000: \***
 584: 0000: \***    REVISION 1.4.            ROBERT COWEY.                  09 SEP 2003.
 585: 0000: \***    Changes for RF trial.
 586: 0000: \***    Removed redundant PVCS revision control block from top of code.
 587: 0000: \***    Recompiled to prevent future automatic recompiles.
 588: 0000: \***    No changes to actual code.
 589: 0000: \***
 590: 0000: \*******************************************************************************
 591: 0000: \*******************************************************************************
 592: 0000: 
 593: 0000:    FUNCTION CLOLF.SET EXTERNAL
 594: 0000:    END FUNCTION
 595: 0000:    
 596: 0000:    FUNCTION READ.CLOLF EXTERNAL
 597: 0000:       INTEGER*2 READ.CLOLF
 598: 0000:    END FUNCTION
 599: 0000:    
 600: 0000:    FUNCTION WRITE.CLOLF EXTERNAL
 601: 0000:       INTEGER*2 WRITE.CLOLF
 602: 0000:    END FUNCTION
 603: 0000:  
 604: 0000:     %INCLUDE CLILFEXT.J86       ! RF Count Lists File
 605: 0000:    
 606: 0000: \******************************************************************************
 607: 0000: \******************************************************************************\*****************************************************************************
 608: 0000: \***
 609: 0000: \***           FUNCTION DEFINITIONS FOR THE RF COUNT LISTS FILE
 610: 0000: \***
 611: 0000: \***           REFERENCE:   CLILFEXT.J86
 612: 0000: \***
 613: 0000: \***           VERSION A         Nik Sen         13th October 1998
 614: 0000: \***
 615: 0000: \***    REVISION 1.4.            ROBERT COWEY.                  09 SEP 2003.
 616: 0000: \***    Changes for RF trial.
 617: 0000: \***    Removed redundant PVCS revision control block from top of code.
 618: 0000: \***    Recompiled to prevent future automatic recompiles.
 619: 0000: \***    No changes to actual code.
 620: 0000: \***
 621: 0000: \*******************************************************************************
 622: 0000: \*******************************************************************************
 623: 0000: 
 624: 0000:    
 625: 0000:    FUNCTION CLILF.SET EXTERNAL
 626: 0000:    END FUNCTION
 627: 0000:    
 628: 0000:    FUNCTION READ.CLILF EXTERNAL
 629: 0000:       INTEGER*2 READ.CLILF
 630: 0000:    END FUNCTION
 631: 0000:    
 632: 0000:    FUNCTION WRITE.CLILF EXTERNAL
 633: 0000:       INTEGER*2 WRITE.CLILF
 634: 0000:    END FUNCTION
 635: 0000:  
 636: 0000: 
 637: 0000: \*****************************************************************************
 638: 0000: \***
 639: 0000: \***    Included code defining external Boots functions
 640: 0000: \***
 641: 0000: \***..........................................................................
 642: 0000: 
 643: 0000:     %INCLUDE ADXSERVE.J86       ! Message Logging
 644: 0000: \******************************************************************************
 645: 0000: \******************************************************************************
 646: 0000: \***                                                                        ***
 647: 0000: \***    %INCLUDE FOR FUNCTION ADXSERVE (an I.B.M. system function)          ***
 648: 0000: \***                                                                        ***
 649: 0000: \***         AUTHOR        :  Bruce Scriver                                 ***
 650: 0000: \***                                                                        ***
 651: 0000: \***         DATE WRITTEN  :  14th March 1986                               ***
 652: 0000: \***                                                                        ***
 653: 0000: \***         DATE OF LAST REVISION  - 14th March 1986                       ***
 654: 0000: \***                                                                        ***
 655: 0000: \***                                                                        ***
 656: 0000: \******************************************************************************
 657: 0000: \******************************************************************************
 658: 0000: 
 659: 0000:    SUB ADXSERVE (RETURN.CODE%,                                                \
 660: 0000:                  ADX.FUNCTION%,                                               \
 661: 0000:                  ADX.PARM.1%,                                                 \
 662: 0000:                  ADX.PARM.2$)                                                 \
 663: 0000:    EXTERNAL
 664: 0000:   
 665: 0000:       STRING     ADX.PARM.2$
 666: 0000: 
 667: 0000:       INTEGER*2  ADX.FUNCTION%,                                               \
 668: 0000:                  ADX.PARM.1%
 669: 0000: 
 670: 0000:       INTEGER*4  RETURN.CODE%                                                 \
 671: 0000: 
 672: 0000:    END SUB     
 673: 0000: 
 674: 0000:     %INCLUDE PSBF01E.J86        ! APPLICATION.LOG
 675: 0000: REM \
 676: 0000: \*******************************************************************************
 677: 0000: \*******************************************************************************
 678: 0000: \***
 679: 0000: \***      %INCLUDE FOR EXTERNAL DEFINITION OF FUNCTION APPLICATION.LOG
 680: 0000: \***
 681: 0000: \***                      FUNCTION NUMBER   : PSBF01
 682: 0000: \***
 683: 0000: \***                    INCLUDE REFERENCE : PSBF01E.J86
 684: 0000: \*** 
 685: 0000: \***      Version B           Andrew Wedgeworth          1st July 1992
 686: 0000: \***      Three parameters which passed to the function have been removed.
 687: 0000: \***      APPLICATION.LOG has been added as a variable name (this holds the
 688: 0000: \***      return code).
 689: 0000: \***
 690: 0000: \*******************************************************************************
 691: 0000: 
 692: 0000: 
 693: 0000:    FUNCTION APPLICATION.LOG (MESSAGE.NO%,                                     \
 694: 0000:                              VAR.STRING.1$,                                   \
 695: 0000:                              VAR.STRING.2$,                                   \
 696: 0000:                              EVENT.NO%)  EXTERNAL
 697: 0000: 
 698: 0000:       INTEGER*1 EVENT.NO%
 699: 0000: 
 700: 0000:       INTEGER*2 APPLICATION.LOG,                                       \ GAW
 701: 0000:                 MESSAGE.NO%
 702: 0000: 
 703: 0000:       STRING VAR.STRING.1$,                                            \
 704: 0000:              VAR.STRING.2$
 705: 0000: 
 706: 0000:    END FUNCTION
 707: 0000: 
 708: 0000: \*******************************************************************************
 709: 0000:     %INCLUDE PSBF02E.J86        ! Update Date External Function         ! FRG
 710: 0000: REM\
 711: 0000: \*******************************************************************************
 712: 0000: \*******************************************************************************
 713: 0000: \***
 714: 0000: \***        INCLUDE       : UPDATE.DATE external definition
 715: 0000: \***        AUTHOR        : Bruce Scriver (Basic Code)
 716: 0000: \***        DATE WRITTEN  : 4th March 1986 (Basic Code)
 717: 0000: \***
 718: 0000: \***        REFERENCE     : PSBF02E.J86
 719: 0000: \***
 720: 0000: \***        Version A     Bruce Scriver          4th March 1986
 721: 0000: \***
 722: 0000: \***        Version B     Andrew Wedgeworth       6th July 1992
 723: 0000: \***        Removal of redundant parameters, and inclusion of UPDATE.DATE as
 724: 0000: \***        a variable to hold the return code.
 725: 0000: \***
 726: 0000: \*******************************************************************************
 727: 0000: \*******************************************************************************
 728: 0000: 
 729: 0000:    FUNCTION UPDATE.DATE (INCREMENT%)                                   \
 730: 0000:    EXTERNAL
 731: 0000:    ! 3 parameters removed from here                                    ! BAW
 732: 0000: 
 733: 0000:    ! 3 lines deleted from here                                         ! BAW
 734: 0000:    
 735: 0000:       INTEGER*2 UPDATE.DATE                                            ! BAW
 736: 0000: 
 737: 0000:       INTEGER*4 INCREMENT%
 738: 0000: 
 739: 0000:    END FUNCTION
 740: 0000: 
 741: 0000:     %INCLUDE PSBF14E.J86        ! SORT.TABLE function definition
 742: 0000: REM\
 743: 0000: \*******************************************************************************
 744: 0000: \*******************************************************************************
 745: 0000: \***
 746: 0000: \***        INCLUDE       : SORT.TABLE external definition
 747: 0000: \***
 748: 0000: \***        REFERENCE     : PSBF14E.J86
 749: 0000: \***
 750: 0000: \***        Version A     Bruce Scriver                   3rd March 1986   
 751: 0000: \*** 
 752: 0000: \***        Version B     Andrew Wedgeworth               17th July 1992
 753: 0000: \***        Redundant function parameters removed.  SORT.TABLE defined as a
 754: 0000: \***        variable to hold the return code.
 755: 0000: \***
 756: 0000: \*******************************************************************************
 757: 0000: \*******************************************************************************
 758: 0000: 
 759: 0000:    FUNCTION SORT.TABLE (NUMBER.OF.ENTRIES%)                                    \
 760: 0000:    EXTERNAL
 761: 0000: 
 762: 0000:       INTEGER   NUMBER.OF.ENTRIES%,                                    \ BAW
 763: 0000:                 SORT.TABLE                 
 764: 0000: 
 765: 0000:    END FUNCTION
 766: 0000: 
 767: 0000:     %INCLUDE PSBF20E.J86        ! Allocating Session Numbers
 768: 0000: REM\
 769: 0000: \*******************************************************************************
 770: 0000: \*******************************************************************************
 771: 0000: \***
 772: 0000: \***       %INCLUDE FOR EXTERNAL DEFINITION OF SESS.NUM.UTILITY
 773: 0000: \***
 774: 0000: \***                  REFERENCE     : PSBF20E.J86
 775: 0000: \***
 776: 0000: \***     VERSION C            Janet Smith                13th May 1992
 777: 0000: \***     Increased PASSED.INTEGER to 2 bytes to cater for more than
 778: 0000: \***     128 files.
 779: 0000: \***
 780: 0000: \***     VERSION D.           Andrew Wedgeworth          1st July 1992
 781: 0000: \***     Removal of redundant parameters and addition of SESS.NUM.UTILITY
 782: 0000: \***     as a variable.  This new variable contains the function's return
 783: 0000: \***     code.
 784: 0000: \***
 785: 0000: \*******************************************************************************
 786: 0000: \*******************************************************************************
 787: 0000: 
 788: 0000:    FUNCTION SESS.NUM.UTILITY (FUNCTION.FLAG$,                          \
 789: 0000:                               PASSED.INTEGER%,                         \
 790: 0000:                               PASSED.STRING$)                          \
 791: 0000:    EXTERNAL
 792: 0000: 
 793: 0000:    STRING    FUNCTION.FLAG$,                                           \
 794: 0000:              PASSED.STRING$
 795: 0000:    ! 3 variables removed from here                                     ! CAW
 796: 0000: 
 797: 0000: 
 798: 0000:    INTEGER*2 SESS.NUM.UTILITY,                                         \ CAW
 799: 0000:              PASSED.INTEGER%				               ! CJAS
 800: 0000: 
 801: 0000:    END FUNCTION
 802: 0000: 
 803: 0000:     %INCLUDE PSBF24E.J86        ! STANDARD.ERROR.DETECTED
 804: 0000: REM \
 805: 0000: \*******************************************************************************
 806: 0000: \*******************************************************************************
 807: 0000: \***
 808: 0000: \***    %INCLUDE FOR EXTERNAL DEFINITION OF STANDARD.ERROR.DETECTED FUNCTION
 809: 0000: \***
 810: 0000: \***                      REFERENCE     : PSBF24E.J86
 811: 0000: \***
 812: 0000: \***    Version A                 Janet Smith                  13th May 1992
 813: 0000: \***
 814: 0000: \*******************************************************************************
 815: 0000: \*******************************************************************************
 816: 0000: 
 817: 0000:    FUNCTION STANDARD.ERROR.DETECTED(ERRN%,                 \
 818: 0000: 				    ERRFILE%,              \
 819: 0000: 				    ERRL%,                 \
 820: 0000: 				    ERR$)        EXTERNAL
 821: 0000: 				    
 822: 0000:           STRING    ERR$
 823: 0000: 
 824: 0000:           INTEGER*2 ERRFILE%,              \
 825: 0000: 	            ERRL%,                 \
 826: 0000: 		    STANDARD.ERROR.DETECTED
 827: 0000: 		    
 828: 0000:           INTEGER*4 ERRN%
 829: 0000: 	  		    
 830: 0000:    END FUNCTION
 831: 0000: 
 832: 0000: 
 833: 0000: 
 834: 0000: \*****************************************************************************
 835: 0000: \***
 836: 0000: \***    WRITE RFCNTLST
 837: 0000: \***    Detail      : This function writes data to the report file(RFCNTLST.DAY)
 838: 0000: \***                  The data which has to be written to report, is
 839: 0000: \***                  stored in the variable RFCNTLST.RECORD$ which inturn is
 840: 0000: \***                  written to the report file.
 841: 0000: \***                  This section also adds prefixes like "0M", "1M", "2M",
 842: 0000: \***                  "3M" or "4M" based on the heading types, which helps in
 843: 0000: \***                  formatting the report in a user friendly way in POD/PDT
 844: 0000: \***
 845: 0000: \***..........................................................................
 846: 0000: 
 847: 0000: FUNCTION WRITE.RFCNTLST (TYPE$)
 848: 0029: 
 849: 0029:     STRING TYPE$
 850: 0029: 
 851: 0029:     FILE.OPERATION$     = "W"
 852: 0040:     CURRENT.REPORT.NUM% = RFCNTLST.REPORT.NUM%
 853: 0052:     CURRENT.TYPE$ = TYPE$
 854: 0069: 
 855: 0069:     !If CURRENT.TYPE$ is "0M", "1M", "2M", "3M" or "4M" then
 856: 0069:     !    line starts with that corresponding letter
 857: 0069:     !If CURRENT.TYPE$ is "" then line starts with
 858: 0069:     !    previous type + D
 859: 0069:     !Eg: If PREV.TYPE$ = "1M" and CURRENT.TYPE$ = "" then
 860: 0069:     !    line starts with (1+1)D ie 2D
 861: 0069: 
 862: 0069:     IF CURRENT.TYPE$ = "0M" THEN BEGIN
 863: 0084:         RFCNTLST.RECORD$ = "0M" + RFCNTLST.RECORD$
 864: 00a4:         PREV.TYPE$ = CURRENT.TYPE$
 865: 00c0:     ENDIF ELSE IF CURRENT.TYPE$ = "1M" THEN BEGIN
 866: 00db:         RFCNTLST.RECORD$ = "1M" + RFCNTLST.RECORD$
 867: 00fb:         PREV.TYPE$ = CURRENT.TYPE$
 868: 0117:     ENDIF ELSE IF CURRENT.TYPE$ = "2M" THEN BEGIN
 869: 0132:         RFCNTLST.RECORD$ = "2M" + RFCNTLST.RECORD$
 870: 0152:         PREV.TYPE$ = CURRENT.TYPE$
 871: 016e:     ENDIF ELSE IF CURRENT.TYPE$ = "3M" THEN BEGIN
 872: 0189:         RFCNTLST.RECORD$ = "3M" + RFCNTLST.RECORD$
 873: 01a9:         PREV.TYPE$ = CURRENT.TYPE$
 874: 01c5:     ENDIF ELSE IF CURRENT.TYPE$ = "4M" THEN BEGIN
 875: 01e0:         RFCNTLST.RECORD$ = "4M" + RFCNTLST.RECORD$
 876: 0200:         PREV.TYPE$ = CURRENT.TYPE$
 877: 021c:     ENDIF ELSE IF CURRENT.TYPE$ = "" THEN BEGIN
 878: 0237:         RFCNTLST.RECORD$ =  STR$(VAL(LEFT$(PREV.TYPE$,1)) + 1 ) \
 879: 02a8:                             + "D" + RFCNTLST.RECORD$
 880: 02a8:     ENDIF
 881: 02b0: 
 882: 02b0:     WRITE # RFCNTLST.SESS.NUM% ;RFCNTLST.RECORD$
 883: 02d3: 
 884: 02d3: END FUNCTION
 885: 02ec: 
 886: 02ec: \******************************************************************************
 887: 02ec: \***
 888: 02ec: \***   Sub-Program : GET.OP.NAME
 889: 02ec: \***   Detail      : This function key read the EALAUTH and returns the
 890: 02ec: \***                 Operator Name corresponding to the Operator ID. IF an
 891: 02ec: \***                 Op Name is not obtained, the "**No Op name**      "
 892: 02ec: \***                 is returned
 893: 02ec: \******************************************************************************
 894: 02ec: 
 895: 02ec: FUNCTION GET.OP.NAME$
 896: 0310: 
 897: 0310:     STRING GET.OP.NAME$
 898: 0310:     GET.OP.NAME$ = "**No Op name**      "
 899: 0326: 
 900: 0326:     IF UNPACK$(AF.OPERATOR.NO$) <> "00000000" THEN BEGIN
 901: 035a:         RC% = READ.AF
 902: 036a:         IF RC% = 0 AND AF.OPERATOR.NAME$ <> "" THEN BEGIN
 903: 03a3:             !Op Name padded with space upto 20 Chars
 904: 03a3:             GET.OP.NAME$ = LEFT$(AF.OPERATOR.NAME$ +(STRING$(20," ")), 20)
 905: 03f1:         ENDIF
 906: 03f9:     ENDIF
 907: 0401: 
 908: 0401: END FUNCTION
 909: 041a: 
 910: 041a: \******************************************************************************
 911: 041a: \******************************************************************************
 912: 041a: \***
 913: 041a: \***        S T A R T    O F    SUB PROGRAM
 914: 041a: \***
 915: 041a: \******************************************************************************
 916: 041a: \******************************************************************************
 917: 041a: 
 918: 041a: SUB MINRFCNT PUBLIC
 919: 043e: 
 920: 043e:     ON ERROR GOTO ERROR.DETECTED:
 921: 0453: 
 922: 0453:     ADXSERVE.DATA$ = "*** Creating RFCNTLST.DAY report ***"
 923: 0468:     GOSUB DISPLAY.MESSAGE
 924: 047a: 
 925: 047a:     GOSUB INITIALISATION
 926: 048c:     GOSUB CREATE.RF.COUNT.DETAIL
 927: 049e:     GOSUB CREATE.RF.COUNT.SUMMARY
 928: 04b0:     GOSUB CREATE.RF.COUNT.REPORT
 929: 04c2: 
 930: 04c2: STOP.MINRFCNT:
 931: 04d2: 
 932: 04d2:     CLOSE CLOLF.SESS.NUM%
 933: 04e6:     CLOSE CLILF.SESS.NUM%
 934: 04fa:     CLOSE AF.SESS.NUM%
 935: 050e:     CLOSE RFCNTLST.SESS.NUM%
 936: 0522: 
 937: 0522:     GOSUB DEALLOCATE.SESSION.NUMBERS
 938: 0534: 
 939: 0534:     IF ERROR.COUNT% > 0 THEN BEGIN
 940: 0543:         ADXSERVE.DATA$ = "*** RFCNTLST.DAY report processing error ***"
 941: 0558:         GOSUB DISPLAY.MESSAGE
 942: 056c:     ENDIF ELSE BEGIN
 943: 0574:         ADXSERVE.DATA$ = "*** RFCNTLST.DAY report creation success ***"
 944: 0589:         GOSUB DISPLAY.MESSAGE
 945: 059b:         REPORTING.STATUS$ = "E"
 946: 05b2:     ENDIF
 947: 05ba: 
 948: 05ba:     EXIT SUB
 949: 05c5: 
 950: 05c5: \*****************************************************************************
 951: 05c5: \***
 952: 05c5: \***    INITIALISATION
 953: 05c5: \***    Detail        : Below mentioned are the main initialization done here.
 954: 05c5: \***                  1. Setting RFCNTLST.FILE.NAME$ and RFCNTLST.REPORT.NUM%
 955: 05c5: \***                  2. Initialise the F14.TABLE$ array
 956: 05c5: \***                  3. Initialise NUM.LISTS.ARRAY%, LISTS.COUNTED.ARRAY%,
 957: 05c5: \***                     PART.COUNT.ARRAY%, UNCOUNTED.ARRAY% array
 958: 05c5: \***                  4. Allocating Session Numbers
 959: 05c5: \***                  6. Opening Files
 960: 05c5: \***                  7. Creates the RFCNTLST file
 961: 05c5: \***
 962: 05c5: \***..........................................................................
 963: 05c5: 
 964: 05c5: INITIALISATION:
 965: 05d5: 
 966: 05d5:     ADXSERVE.DATA$ = "Initialisation - MINRFCNT"
 967: 05ea:     GOSUB DISPLAY.MESSAGE
 968: 05fc: 
 969: 05fc:     RFCNTLST.FILE.NAME$  = "ADXLXACN::D:/ADX_UDT1/RFCNTLST.DAY"
 970: 0611:     RFCNTLST.REPORT.NUM% = 426
 971: 061f:     FALSE = 0
 972: 062f:     TRUE  = -1
 973: 063f:     REPORTING.STATUS$ = "X"
 974: 0656: 
 975: 0656:     !Initializing the F14.TABLE$, NUM.LISTS.ARRAY%, LISTS.COUNTED.ARRAY%,
 976: 0656:     !PART.COUNT.ARRAY%, UNCOUNTED.ARRAY% arrays
 977: 0656:     F14.LIMIT% = 1000
 978: 0664:     DIM F14.TABLE$(F14.LIMIT%)
 979: 0695:     DIM NUM.LISTS.ARRAY%(1000)
 980: 06bf:     DIM LISTS.COUNTED.ARRAY%(1000)
 981: 06e9:     DIM PART.COUNT.ARRAY%(1000)
 982: 0713:     DIM UNCOUNTED.ARRAY%(1000)
 983: 073d: 
 984: 073d:     GOSUB ALLOCATE.SESSION.NUMBERS
 985: 074f:     GOSUB OPEN.FILES
 986: 0761: 
 987: 0761: RETURN
 988: 0771: 
 989: 0771: \*****************************************************************************
 990: 0771: \***
 991: 0771: \***    ALLOCATE.SESSION.NUMBERS
 992: 0771: \***    Detail        : Perform CALL.F20.SESS.NUM.UTILITY to allocate
 993: 0771: \***                    file session numbers for all files referenced
 994: 0771: \***                    by the program.
 995: 0771: \***
 996: 0771: \***..........................................................................
 997: 0771: 
 998: 0771: ALLOCATE.SESSION.NUMBERS:
 999: 0781: 
1000: 0781:     ADXSERVE.DATA$ = "Allocating Session numbers - MINRFCNT"
1001: 0796:     GOSUB DISPLAY.MESSAGE
1002: 07a8: 
1003: 07a8:     CALL CLOLF.SET
1004: 07c3:     CALL CLILF.SET
1005: 07de:     CALL AF.SET
1006: 07eb: 
1007: 07eb:     FUNCTION.FLAG$ EQ "O"
1008: 0800: 
1009: 0800:     PASSED.INTEGER% EQ CLOLF.REPORT.NUM%
1010: 0812:     PASSED.STRING$ EQ CLOLF.FILE.NAME$
1011: 082e:     GOSUB CALL.F20.SESS.NUM.UTILITY
1012: 0840:     CLOLF.SESS.NUM% EQ F20.INTEGER.FILE.NO%
1013: 0856: 
1014: 0856:     PASSED.INTEGER% EQ CLILF.REPORT.NUM%
1015: 0868:     PASSED.STRING$ EQ CLILF.FILE.NAME$
1016: 0884:     GOSUB CALL.F20.SESS.NUM.UTILITY
1017: 0896:     CLILF.SESS.NUM% EQ F20.INTEGER.FILE.NO%
1018: 08ac: 
1019: 08ac:     PASSED.INTEGER% EQ AF.REPORT.NUM%
1020: 08bf:     PASSED.STRING$ EQ AF.FILE.NAME$
1021: 08db:     GOSUB CALL.F20.SESS.NUM.UTILITY
1022: 08ed:     AF.SESS.NUM% EQ F20.INTEGER.FILE.NO%
1023: 0903: 
1024: 0903:     PASSED.INTEGER% EQ RFCNTLST.REPORT.NUM%
1025: 0911:     PASSED.STRING$ EQ RFCNTLST.FILE.NAME$
1026: 092a:     GOSUB CALL.F20.SESS.NUM.UTILITY
1027: 093c:     RFCNTLST.SESS.NUM% EQ F20.INTEGER.FILE.NO%
1028: 0952: 
1029: 0952:     ADXSERVE.DATA$ = "Session numbers allocating success - MINRFCNT"
1030: 0967:     GOSUB DISPLAY.MESSAGE
1031: 0979: 
1032: 0979: RETURN
1033: 0989: 
1034: 0989: \*****************************************************************************
1035: 0989: \***
1036: 0989: \***    CALL.F20.SESS.NUM.UTILITY:
1037: 0989: \***    Detail        : References SESS.NUM.UTILITY (F20) to create,
1038: 0989: \***                    read, or delete entry on Session Number Table as
1039: 0989: \***                    determined by FUNCTION.FLAG$ ("O" "R" "C").
1040: 0989: \***
1041: 0989: \***..........................................................................
1042: 0989: 
1043: 0989: CALL.F20.SESS.NUM.UTILITY:
1044: 0999: 
1045: 0999:     FUNCTION.RETURN.CODE% EQ    \
1046: 09c0:         SESS.NUM.UTILITY        \
1047: 09c0:         (FUNCTION.FLAG$,        \
1048: 09c0:         PASSED.INTEGER%,        \
1049: 09c0:         PASSED.STRING$)
1050: 09c0: 
1051: 09c0: RETURN
1052: 09d0: 
1053: 09d0: \*****************************************************************************
1054: 09d0: \***
1055: 09d0: \***    OPEN.FILES:
1056: 09d0: \***    Detail          :Opens CLOLF, CLILF and AF Files.
1057: 09d0: \***
1058: 09d0: \***..........................................................................
1059: 09d0: 
1060: 09d0: OPEN.FILES:
1061: 09e0: 
1062: 09e0:     FILE.OPERATION$     = "O"
1063: 09f7: 
1064: 09f7:     CURRENT.REPORT.NUM% = CLOLF.REPORT.NUM%
1065: 0a0d:     OPEN CLOLF.FILE.NAME$ DIRECT RECL CLOLF.RECL% AS CLOLF.SESS.NUM%
1066: 0a3b: 
1067: 0a3b:     CURRENT.REPORT.NUM% = CLILF.REPORT.NUM%
1068: 0a51:     OPEN CLILF.FILE.NAME$ KEYED RECL CLILF.RECL% AS CLILF.SESS.NUM%
1069: 0a7d: 
1070: 0a7d:     CURRENT.REPORT.NUM% = AF.REPORT.NUM%
1071: 0a94:     OPEN AF.FILE.NAME$ KEYED RECL AF.RECL%                          \
1072: 0ac1:          AS AF.SESS.NUM% NOWRITE NODEL
1073: 0ac1: 
1074: 0ac1:     CURRENT.REPORT.NUM% = RFCNTLST.REPORT.NUM%
1075: 0ad3:     OPEN RFCNTLST.FILE.NAME$ AS RFCNTLST.SESS.NUM% APPEND
1076: 0af7: 
1077: 0af7:     ADXSERVE.DATA$ = "Opened CLILF/CLOLF Backup Files - MINRFCNT"
1078: 0b0c:     GOSUB DISPLAY.MESSAGE
1079: 0b1e: 
1080: 0b1e: RETURN
1081: 0b2e: 
1082: 0b2e: \*****************************************************************************
1083: 0b2e: \***
1084: 0b2e: \***    CREATE.RF.COUNT.DETAIL:
1085: 0b2e: \***    Detail        : Below mentioned are the main process done here.
1086: 0b2e: \***                    1. Calculates number of CLOLF records
1087: 0b2e: \***                    2. Reads each CLOLF record and write the necessary
1088: 0b2e: \***                       data to F14.TABLE
1089: 0b2e: \***                    3. Reads CLILF records corresponding to CLOLF record
1090: 0b2e: \***                       and gets the details of items not counted in list
1091: 0b2e: \***                    4. Sort F14.TABLE
1092: 0b2e: \***
1093: 0b2e: \***..........................................................................
1094: 0b2e: 
1095: 0b2e: CREATE.RF.COUNT.DETAIL:
1096: 0b3e: 
1097: 0b3e:     ADXSERVE.DATA$ = "Processing CLOLF.BIN File - MINRFCNT"
1098: 0b53:     GOSUB DISPLAY.MESSAGE
1099: 0b65: 
1100: 0b65:     !Reading CLOLF and getting the number of records
1101: 0b65:     CLOLF.NUMRECS% = (SIZE(CLOLF.FILE.NAME$) / CLOLF.RECL%)
1102: 0b97:     CURR.RECORD.INDEX% = 1
1103: 0ba5: 
1104: 0ba5:     FOR CLOLF.RECORD.NUM% = 1 TO CLOLF.NUMRECS%
1105: 0bbf: 
1106: 0bbf:         FILE.OPERATION$     = "R"
1107: 0bd6:         CURRENT.REPORT.NUM% = CLOLF.REPORT.NUM%
1108: 0bec:         RC% = READ.CLOLF
1109: 0bfc: 
1110: 0bfc:         IF CLOLF.LSTTYP$ = "N" OR CLOLF.LSTTYP$ = "H" OR \
1111: 0c79:            CLOLF.LSTTYP$ = "U" THEN BEGIN
1112: 0c79: 
1113: 0c79:             !Setting CURR.LIST.TYPE$ for sorting purpose
1114: 0c79: !            IF CLOLF.LSTTYP$ = "N" THEN BEGIN                        ! CCsk
1115: 0c79: !                CURR.LIST.TYPE$ = "1"                                ! CCsk
1116: 0c79: !            ENDIF ELSE IF CLOLF.LSTTYP$ = "H" THEN BEGIN             ! CCsk
1117: 0c79: !                CURR.LIST.TYPE$ = "2"                                ! CCsk
1118: 0c79: !            ENDIF ELSE IF CLOLF.LSTTYP$ = "U" THEN BEGIN             ! CCsk
1119: 0c79: !                CURR.LIST.TYPE$ = "3"                                ! CCsk
1120: 0c79: !            ENDIF                                                    ! CCsk
1121: 0c79:             IF CLOLF.LSTTYP$ = "N" THEN BEGIN
1122: 0c97:                 CURR.LIST.TYPE$ = "1"
1123: 0cae:             ENDIF ELSE IF CLOLF.LSTTYP$ = "U" THEN BEGIN              ! CCsk
1124: 0ccc:                 CURR.LIST.TYPE$ = "2"
1125: 0ce3:             ENDIF ELSE IF CLOLF.LSTTYP$ = "H" THEN BEGIN              ! CCsk
1126: 0d01:                 CURR.LIST.TYPE$ = "3"
1127: 0d16:             ENDIF
1128: 0d1e: 
1129: 0d1e:             !Setting CURR.CNT.STATUS$ for sorting & filtering purpose
1130: 0d1e:             IF CLOLF.ACTIVE.STATUS$ = "C" THEN BEGIN
1131: 0d3c:                 CURR.CNT.STATUS$ = "1"
1132: 0d54:             ENDIF ELSE IF CLOLF.ACTIVE.STATUS$ = "P" THEN BEGIN
1133: 0d72:                 CURR.CNT.STATUS$ = "2"
1134: 0d89:             ENDIF ELSE IF CLOLF.ACTIVE.STATUS$ = "I" THEN BEGIN
1135: 0da7:                 CURR.CNT.STATUS$ = "3"
1136: 0dbe:             ENDIF ELSE IF CLOLF.ACTIVE.STATUS$ = " " THEN BEGIN       ! ETT
1137: 0ddc:                 CURR.CNT.STATUS$ = "4"                                ! ETT
1138: 0df1:             ENDIF
1139: 0df9: 
1140: 0df9:             ITEMS.NOT.COUNTED% = 0
1141: 0e07:             ADXSERVE.DATA$ = "Processing CLILF for CLOLF record " \
1142: 0e3e:                              + STR$(CLOLF.RECORD.NUM%) + " - MINRFCNT"
1143: 0e3e:             GOSUB DISPLAY.MESSAGE
1144: 0e50: 
1145: 0e50:             !Reading CLILF and getting the count of items with
1146: 0e50:             !CLILF.COUNTED.STATUS$ = "P" OR CLILF.COUNTED.STATUS$ = "U"
1147: 0e50:             !(Items not counted)
1148: 0e50: 
1149: 0e50:             CLILF.LISTID$  = CLOLF.LISTID$                                 ! CCSk
1150: 0e6e: 
1151: 0e6e:             FOR CLILF.COUNTER% = 1 TO CLOLF.TOTAL.ITEMS%
1152: 0e7f: 
1153: 0e7f:                 !CLILF.LISTID$  = CLOLF.LISTID$                            ! CCsk
1154: 0e7f:                 CLILF.ITEMSEQ$ = RIGHT$("000" + STR$(CLILF.COUNTER%),3)
1155: 0ec5:                 !FILE.OPERATION$     = "R"                                 ! CCSk
1156: 0ec5:                 !CURRENT.REPORT.NUM% = CLILF.REPORT.NUM%                   ! CCSk
1157: 0ec5:                 RC% = READ.CLILF
1158: 0ed5: 
1159: 0ed5:                 IF CLILF.COUNTED.STATUS$ = "P" OR \
1160: 0f27:                     CLILF.COUNTED.STATUS$ = "U" THEN BEGIN
1161: 0f27:                     ITEMS.NOT.COUNTED% = ITEMS.NOT.COUNTED% + 1
1162: 0f33:                 ENDIF
1163: 0f3b: 
1164: 0f3b:             NEXT CLILF.COUNTER%
1165: 0f5a: 
1166: 0f5a:             IF CLOLF.TOTAL.ITEMS% > 0 AND CURR.CNT.STATUS$ <> "4" THEN BEGIN   ! ETT
1167: 0f9c:                 CURR.RECORD$ =  CURR.LIST.TYPE$                             + \
1168: 10c2:                                 CURR.CNT.STATUS$                            + \
1169: 10c2:                                 UNPACK$(CLOLF.CREATION.DATE$)               + \
1170: 10c2:                                 UNPACK$(CLOLF.CREATION.TIME$)               + \
1171: 10c2:                                 CLOLF.PICKER.USER.ID$                       + \
1172: 10c2:                                 CLOLF.LISTID$                               + \
1173: 10c2:                                 RIGHT$("000" + STR$(CLOLF.TOTAL.ITEMS%), 3) + \
1174: 10c2:                                 UNPACK$(CLOLF.PICK.START.TIME$)             + \
1175: 10c2:                                 UNPACK$(CLOLF.PICK.END.TIME$)               + \
1176: 10c2:                                 CLOLF.USERID$ + \
1177: 10c2:                                 RIGHT$("000" + STR$(ITEMS.NOT.COUNTED%), 3)
1178: 10c2: 
1179: 10c2:                 F14.TABLE$(CURR.RECORD.INDEX%) = CURR.RECORD$
1180: 10eb:                 CURR.RECORD.INDEX% = CURR.RECORD.INDEX% + 1
1181: 10f7:             ENDIF                                                              ! ETT
1182: 10ff: 
1183: 10ff:             IF CURR.RECORD.INDEX% = F14.LIMIT% THEN BEGIN
1184: 1110: 
1185: 1110:                 !The F14.TABLE$ array has reached its max limit, hence stop
1186: 1110:                 !processing further CLOLF/CLILF and continue the report
1187: 1110:                 !generation
1188: 1110: 
1189: 1110:                 ADXSERVE.DATA$ = "F14.TABLE$ array limit exceeded, the program "
1190: 1125:                 GOSUB DISPLAY.MESSAGE
1191: 1137:                 ADXSERVE.DATA$ = "will not generate the complete report "
1192: 114c:                 GOSUB DISPLAY.MESSAGE
1193: 115e: 
1194: 115e:                 !Set the variables to exit both the FOR loop
1195: 115e:                 CLOLF.RECORD.NUM% = CLOLF.NUMRECS%
1196: 1177: 
1197: 1177:             ENDIF
1198: 117f:         ENDIF
1199: 1187:     NEXT CLOLF.RECORD.NUM%
1200: 11b8: 
1201: 11b8:     !Total no: of records in F14.TABLE$
1202: 11b8:     F14TABLE.MAX.INDEX% = CURR.RECORD.INDEX% - 1
1203: 11c7: 
1204: 11c7: !       F14.TABLE LAYOUT
1205: 11c7: !
1206: 11c7: !    |---------|-------|-----------|------------------------------------|
1207: 11c7: !    |   From  |  To   |   Length  |    Name                            |
1208: 11c7: !    |---------|-------|-----------|------------------------------------|
1209: 11c7: !    |   1     |  1    |   1       |    CURR.LIST.TYPE$                 |
1210: 11c7: !    |   2     |  2    |   1       |    CURR.CNT.STATUS$                |
1211: 11c7: !    |   3     |  8    |   6       |    UNPACK$(CLOLF.CREATION.DATE$)   |
1212: 11c7: !    |   9     |  12   |   4       |    UNPACK$(CLOLF.CREATION.TIME$)   |
1213: 11c7: !    |   13    |  15   |   3       |    CLOLF.PICKER.USER.ID$           |
1214: 11c7: !    |   16    |  18   |   3       |    CLOLF.LISTID$                   |
1215: 11c7: !    |   19    |  21   |   3       |    STR$(CLOLF.TOTAL.ITEMS%)        |
1216: 11c7: !    |   22    |  25   |   4       |    UNPACK$(CLOLF.PICK.START.TIME$) |
1217: 11c7: !    |   26    |  29   |   4       |    UNPACK$(CLOLF.PICK.END.TIME$)   |
1218: 11c7: !    |   30    |  32   |   3       |    CLOLF.USERID$                   |
1219: 11c7: !    |   33    |  35   |   3       |    STR$(ITEMS.NOT.COUNTED%)        |
1220: 11c7: !    |---------|-------|-----------|------------------------------------|
1221: 11c7: 
1222: 11c7:     !Sorting F14.TABLE$
1223: 11c7:     CALL SORT.TABLE (F14TABLE.MAX.INDEX%)
1224: 11da: 
1225: 11da: RETURN
1226: 11ea: 
1227: 11ea: \*****************************************************************************
1228: 11ea: \***
1229: 11ea: \***    CREATE.RF.COUNT.SUMMARY:
1230: 11ea: \***    Detail        : Below mentioned are the main process done here.
1231: 11ea: \***                    1. Initialise the arrays NUM.LISTS.ARRAY%,
1232: 11ea: \***                       LISTS.COUNTED.ARRAY%, PART.COUNT.ARRAY%,
1233: 11ea: \***                       UNCOUNTED.ARRAY%
1234: 11ea: \***                    2. Writes the date and time in the report
1235: 11ea: \***                    3. Processes F14.TABLE and checks the value of
1236: 11ea: \***                       CURR.CNT.STATUS$ and setting the arrays
1237: 11ea: \***                       NUM.LISTS.ARRAY%, LISTS.COUNTED.ARRAY%,
1238: 11ea: \***                       PART.COUNT.ARRAY%, UNCOUNTED.ARRAY%
1239: 11ea: \***                    4. Writes the details to the report
1240: 11ea: \***
1241: 11ea: \***..........................................................................
1242: 11ea: 
1243: 11ea: CREATE.RF.COUNT.SUMMARY:
1244: 11fa: 
1245: 11fa:     ADXSERVE.DATA$ = "Processing RF.COUNT.SUMMARY - MINRFCNT "
1246: 120f:     GOSUB DISPLAY.MESSAGE
1247: 1221: 
1248: 1221:     !Initialise the arrays NUM.LISTS.ARRAY%, LISTS.COUNTED.ARRAY%
1249: 1221:     !PART.COUNT.ARRAY%,UNCOUNTED.ARRAY%
1250: 1221: 
1251: 1221:     FOR COUNTER% = 1 TO 3
1252: 1231:         NUM.LISTS.ARRAY%(COUNTER%) = 0
1253: 124e:         LISTS.COUNTED.ARRAY%(COUNTER%) = 0
1254: 126b:         PART.COUNT.ARRAY%(COUNTER%) = 0
1255: 1288:         UNCOUNTED.ARRAY%(COUNTER%) = 0
1256: 12a5:     NEXT COUNTER%
1257: 12bf: 
1258: 12bf:     !Writes the date and time in the report
1259: 12bf: !    RFCNTLST.RECORD$  = RIGHT$(DATE$, 2)    + "/"  + \               !BTT
1260: 12bf: !                        MID$(DATE$,3,2)     + "/"  + \               !BTT
1261: 12bf: !                        "20" + LEFT$(DATE$, 2)     + \               !BTT
1262: 12bf: !                        " at " + MID$(TIME$,1,2)   + \               !BTT
1263: 12bf: !                        ":" + MID$(TIME$,3,2) + " "                  !BTT
1264: 12bf:     RFCNTLST.RECORD$  = " " + RIGHT$(DATE$, 2) + "/"    + \           !BTT
1265: 139d:                               MID$(DATE$,3,2)  + "/"    + \           !BTT
1266: 139d:                               LEFT$(DATE$, 2)  + " at " + \           !BTT
1267: 139d:                               MID$(TIME$,1,2)  + ":"    + \           !BTT
1268: 139d:                               MID$(TIME$,3,2)  + "  "                 !BTT
1269: 139d:     CALL WRITE.RFCNTLST("0M")
1270: 13be: 
1271: 13be:     RFCNTLST.RECORD$ = "Count List Summary  "
1272: 13d3:     CALL WRITE.RFCNTLST("1M")
1273: 13f4: 
1274: 13f4:     !Counter 1 to 3 is used for the three lists
1275: 13f4:     !Negative Lists,User Generated Lists,Support Office Lists
1276: 13f4: 
1277: 13f4:     FOR COUNTER% = 1 TO 3
1278: 1404: 
1279: 1404:         !Reading F14.TABLE one by one
1280: 1404:         FOR CURR.RECORD.INDEX% = 1 to F14TABLE.MAX.INDEX%
1281: 1415: 
1282: 1415:             !Checking each record corresponds to the list specified
1283: 1415:             !in COUNTER%
1284: 1415:             !Checking whether the list is created today or not
1285: 1415:             
1286: 1415:             ! Commented the line of code which checks the CLOLF creation    ! FRG
1287: 1415:             ! date against DATE$. After 16A MINPRINT gets triggered after   ! FRG
1288: 1415:             ! 12.00 clock, by which condition check always fails .          ! FRG
1289: 1415:             ! Amended the code so that, date$ is subtracted by one and      ! FRG
1290: 1415:             ! Checked against CLOLF creation                                ! FRG
1291: 1415: 
1292: 1415:             F02.DATE$ = DATE$                                               ! FRG
1293: 142d:             CALL UPDATE.DATE(-1)                                            ! FRG
1294: 1445: 
1295: 1445:             IF (LEFT$(F14.TABLE$(CURR.RECORD.INDEX%), 1) = STR$(COUNTER%))  \ FRG
1296: 14de:                 AND (UNPACK$(CLOLF.CREATION.DATE$) = F02.DATE$) THEN BEGIN  ! FRG
1297: 14de: 
1298: 14de:             !   AND (UNPACK$(CLOLF.CREATION.DATE$) = DATE$) THEN BEGIN      ! FRG  
1299: 14de: 
1300: 14de:                 NUM.LISTS.ARRAY%(COUNTER%) = NUM.LISTS.ARRAY%(COUNTER%) + 1
1301: 14f9: 
1302: 14f9:                 !Checking CURR.CNT.STATUS$ from F14.TABLE and getting the
1303: 14f9:                 !values in the arrays LISTS.COUNTED.ARRAY%, PART.COUNT.ARRAY%
1304: 14f9:                 !and UNCOUNTED.ARRAY%
1305: 14f9: 
1306: 14f9:                 IF MID$(F14.TABLE$(CURR.RECORD.INDEX%),2,1) = "1" THEN BEGIN
1307: 153c:                     LISTS.COUNTED.ARRAY%(COUNTER%) = LISTS.COUNTED.ARRAY%       \
1308: 155a:                                                      (COUNTER%) + 1
1309: 155a:                 ENDIF ELSE IF MID$(F14.TABLE$(CURR.RECORD.INDEX%),2,1) = "2"    \
1310: 159d:                               THEN BEGIN
1311: 159d:                     PART.COUNT.ARRAY%(COUNTER%) = PART.COUNT.ARRAY%(COUNTER%)   \
1312: 15ba:                                                   + 1
1313: 15ba:                 ENDIF ELSE IF MID$(F14.TABLE$(CURR.RECORD.INDEX%),2,1) = "3"    \
1314: 15fd:                               THEN BEGIN
1315: 15fd:                     UNCOUNTED.ARRAY%(COUNTER%) = UNCOUNTED.ARRAY%(COUNTER%) + 1
1316: 1618:                 ENDIF
1317: 1620: 
1318: 1620:             ENDIF
1319: 1628:         NEXT CURR.RECORD.INDEX%
1320: 1643: 
1321: 1643:         RFCNTLST.RECORD$ = "                    "
1322: 1658:         CALL WRITE.RFCNTLST ("")
1323: 1679: 
1324: 1679:         !Writing the data to the report
1325: 1679:         IF COUNTER% = 1 THEN BEGIN
1326: 1688:             RFCNTLST.RECORD$ = "Negative Lists      "
1327: 169f:         ENDIF ELSE IF COUNTER% = 2 THEN BEGIN
1328: 16ae:             !RFCNTLST.RECORD$ = "User Generated Lists"                   ! CCSk
1329: 16ae:             !RFCNTLST.RECORD$ = "Support Office Lists"                   ! CCSk ! DTT
1330: 16ae:             RFCNTLST.RECORD$ = "User Generated Lists"                    ! DTT
1331: 16c5:         ENDIF ELSE IF COUNTER% = 3 THEN BEGIN
1332: 16d4:             !RFCNTLST.RECORD$ = "Support Office Lists"                   ! CCSk
1333: 16d4:             !RFCNTLST.RECORD$ = "User Generated Lists"                   ! CCSk ! DTT
1334: 16d4:             RFCNTLST.RECORD$ = "Support Office Lists"                    ! DTT
1335: 16e9:         ENDIF
1336: 16f1:         CALL WRITE.RFCNTLST ("")
1337: 1712: 
1338: 1712:         RFCNTLST.RECORD$ = "Num Lists Today "                       + \
1339: 177c:                             RIGHT$( "   "                           + \
1340: 177c:                             STR$(NUM.LISTS.ARRAY%(COUNTER%)),3)     + \
1341: 177c:                             " "
1342: 177c:         CALL WRITE.RFCNTLST ("")
1343: 179d: 
1344: 179d:         RFCNTLST.RECORD$ = "Lists counted   "                       + \
1345: 1807:                             RIGHT$( "   "                           + \
1346: 1807:                             STR$(LISTS.COUNTED.ARRAY%(COUNTER%)),3) + \
1347: 1807:                             " "
1348: 1807:         CALL WRITE.RFCNTLST ("")
1349: 1828: 
1350: 1828:         RFCNTLST.RECORD$ = "Part counted    "                       + \
1351: 1892:                             RIGHT$( "   "                           + \
1352: 1892:                             STR$(PART.COUNT.ARRAY%(COUNTER%)),3)    + \
1353: 1892:                             " "
1354: 1892:         CALL WRITE.RFCNTLST ("")
1355: 18b3: 
1356: 18b3:         RFCNTLST.RECORD$ = "Lists uncounted "                       + \
1357: 191d:                             RIGHT$( "   "                           + \
1358: 191d:                             STR$(UNCOUNTED.ARRAY%(COUNTER%)),3)     + \
1359: 191d:                             " "
1360: 191d:         CALL WRITE.RFCNTLST ("")
1361: 193e: 
1362: 193e:     NEXT COUNTER%
1363: 1958: 
1364: 1958:     RFCNTLST.RECORD$ = "--------------------"
1365: 196d:     CALL WRITE.RFCNTLST ("")
1366: 198e: 
1367: 198e: RETURN
1368: 199e: 
1369: 199e: \*****************************************************************************
1370: 199e: \***
1371: 199e: \***    CREATE.RF.COUNT.REPORT:
1372: 199e: \***    Detail        : Below mentioned are the main process done here.
1373: 199e: \***                    1. If F14 TABLE has no records, write the blank records
1374: 199e: \***                       Counted Lists, Part Counted Lists and Uncounted Lists
1375: 199e: \***                    2. Process F14.TABLE and write the data to the report
1376: 199e: \***
1377: 199e: \***..........................................................................
1378: 199e: 
1379: 199e: CREATE.RF.COUNT.REPORT:
1380: 19ae: 
1381: 19ae:     ADXSERVE.DATA$ = "Processing RF.COUNT.REPORT - MINRFCNT "
1382: 19c3:     GOSUB DISPLAY.MESSAGE
1383: 19d5: 
1384: 19d5:     FOR COUNTER% = 1 TO 3
1385: 19e5: 
1386: 19e5:         IF COUNTER% = 1 THEN BEGIN
1387: 19f4:             RFCNTLST.RECORD$ = "Negative Lists      "
1388: 1a0b:         ENDIF ELSE IF COUNTER% = 2 THEN BEGIN
1389: 1a1a:             !RFCNTLST.RECORD$ = "User Generated Lists"                   ! CCSk
1390: 1a1a:             !RFCNTLST.RECORD$ = "Support Office Lists"                   ! CCSk ! DTT
1391: 1a1a:             RFCNTLST.RECORD$ = "User Generated Lists"                    ! DTT
1392: 1a31:         ENDIF ELSE IF COUNTER% = 3 THEN BEGIN
1393: 1a40:             !RFCNTLST.RECORD$ = "Support Office Lists"                   ! CCSk
1394: 1a40:             !RFCNTLST.RECORD$ = "User Generated Lists"                   ! CCSk ! DTT
1395: 1a40:             RFCNTLST.RECORD$ = "Support Office Lists"                    ! DTT
1396: 1a55:         ENDIF
1397: 1a5d:         CALL WRITE.RFCNTLST ("1M")
1398: 1a7e: 
1399: 1a7e:         !If F14 TABLE has no records, write the blank records
1400: 1a7e:         !Counted Lists, Part Counted Lists and Uncounted Lists
1401: 1a7e: 
1402: 1a7e:         IF F14TABLE.MAX.INDEX% = 1 THEN BEGIN
1403: 1a90:             RFCNTLST.RECORD$ = "Counted Lists       "
1404: 1aa5:             CALL WRITE.RFCNTLST ("2M")
1405: 1ac6:             RFCNTLST.RECORD$ = "Part Counted Lists  "
1406: 1adb:             CALL WRITE.RFCNTLST ("2M")
1407: 1afc:             RFCNTLST.RECORD$ = "Uncounted Lists     "
1408: 1b11:             CALL WRITE.RFCNTLST ("2M")
1409: 1b32:         ENDIF
1410: 1b3a: 
1411: 1b3a:         PREV.CNT.STATUS$ = " "
1412: 1b4f: 
1413: 1b4f:         !Reading F14.TABLE one by one
1414: 1b4f:         FOR CURR.RECORD.INDEX% = 1 TO F14TABLE.MAX.INDEX%
1415: 1b60: 
1416: 1b60:             !Checking each record corresponds to the list specified in
1417: 1b60:             !COUNTER% and CLOLF creation date matches with current date.
1418: 1b60: 
1419: 1b60:            ! Commented the line of code which checks the CLOLF creation    ! FRG
1420: 1b60:            ! date against DATE$. After 16A, MINPRINT gets triggered after  ! FRG
1421: 1b60:            ! 12.00 clock, due to that below date check condition fails     ! FRG
1422: 1b60:            ! and doesn't write to the RFCNTLST.DAY file                    ! FRG
1423: 1b60: 
1424: 1b60: 
1425: 1b60:             F02.DATE$ = DATE$                                              ! FRG
1426: 1b78:             CALL UPDATE.DATE(-1)                                           ! FRG
1427: 1b90: 
1428: 1b90:             IF (LEFT$(F14.TABLE$(CURR.RECORD.INDEX%), 1) = STR$(COUNTER%)) \ FRG
1429: 1c3b:                 AND (MID$(F14.TABLE$(CURR.RECORD.INDEX%),3,6) = F02.DATE$) \ FRG
1430: 1c3b:                 THEN BEGIN                                                 ! FRG
1431: 1c3b: 
1432: 1c3b:                !AND (MID$(F14.TABLE$(CURR.RECORD.INDEX%),3,6) = DATE$)     \ FRG
1433: 1c3b:                 
1434: 1c3b: 
1435: 1c3b:                 CURR.CNT.STATUS$ = MID$(F14.TABLE$(CURR.RECORD.INDEX%),2,1)
1436: 1c6e: 
1437: 1c6e:                 !Getting CURR.CNT.STATUS$ from F14.TABLE
1438: 1c6e:                 IF CURR.CNT.STATUS$ = "1" THEN BEGIN
1439: 1c8c: 
1440: 1c8c:                     !Checks the Current Status to verify that
1441: 1c8c:                     !    PREV.CNT.STATUS$ <> CURR.CNT.STATUS$
1442: 1c8c:                     !If PREV.CNT.STATUS$ <> CURR.CNT.STATUS$ then
1443: 1c8c:                     !    print the header
1444: 1c8c: 
1445: 1c8c:                     IF PREV.CNT.STATUS$ <> CURR.CNT.STATUS$ THEN BEGIN
1446: 1cab:                         RFCNTLST.RECORD$ = "Counted Lists       "
1447: 1cc0:                         CALL WRITE.RFCNTLST ("2M")
1448: 1ce1:                     ENDIF
1449: 1ce9: 
1450: 1ce9:                     !If the list is User generated list, write the time
1451: 1ce9:                     !and the user created the list in the report
1452: 1ce9: 
1453: 1ce9:                     IF COUNTER% = 2 THEN BEGIN
1454: 1cfb:                         AF.OPERATOR.NO$ = PACK$(RIGHT$(("00000000" +            \
1455: 1d5d:                                           MID$(F14.TABLE$(CURR.RECORD.INDEX%),  \
1456: 1d5d:                                           30,3)),8))
1457: 1d5d:                         CALL GET.OP.NAME$
1458: 1d69:                         RFCNTLST.RECORD$ = MID$(F14.TABLE$(CURR.RECORD.INDEX%), \
1459: 1df7:                                            9,2) + ":" +                         \    ! CCSK
1460: 1df7:                                            MID$(F14.TABLE$(CURR.RECORD.INDEX%), \
1461: 1df7:                                            11,2) + " " +                        \
1462: 1df7:                                            LEFT$(GET.OP.NAME$,14) ! OP NAME SET TO 14 CHARACTERS
1463: 1df7:                         CALL WRITE.RFCNTLST ("3M")
1464: 1e18:                     ENDIF
1465: 1e20: 
1466: 1e20:                     RFCNTLST.RECORD$ =  "List " +                               \
1467: 1edc:                                         MID$(F14.TABLE$(CURR.RECORD.INDEX%),    \
1468: 1edc:                                         16,3) + " " +                           \
1469: 1edc:                                         RIGHT$("   " + STR$(VAL(MID$(F14.TABLE$ \
1470: 1edc:                                         (CURR.RECORD.INDEX%),19,3))), 3) +      \
1471: 1edc:                                         " items  "
1472: 1edc:                     CALL WRITE.RFCNTLST ("")
1473: 1efd: 
1474: 1efd:                     RFCNTLST.RECORD$ =  "from " +                               \
1475: 1fd9:                                         MID$(F14.TABLE$(CURR.RECORD.INDEX%),    \
1476: 1fd9:                                         22,2) + ":" +                           \
1477: 1fd9:                                         MID$(F14.TABLE$(CURR.RECORD.INDEX%),    \
1478: 1fd9:                                         24,2) + " to " +                        \
1479: 1fd9:                                         MID$(F14.TABLE$(CURR.RECORD.INDEX%),    \
1480: 1fd9:                                         26,2) + ":" +                           \
1481: 1fd9:                                         MID$(F14.TABLE$(CURR.RECORD.INDEX%),    \
1482: 1fd9:                                         28,2) + " "
1483: 1fd9:                     CALL WRITE.RFCNTLST ("")
1484: 1ffa: 
1485: 1ffa:                     !Set the key for reading the EALAUTH
1486: 1ffa:                     AF.OPERATOR.NO$ = PACK$(RIGHT$(("00000000" + \
1487: 205c:                                       MID$(F14.TABLE$(CURR.RECORD.INDEX%),      \
1488: 205c:                                       13,3)),8))
1489: 205c:                     CALL GET.OP.NAME$
1490: 2068: 
1491: 2068:                     RFCNTLST.RECORD$ =  "By " + LEFT$(GET.OP.NAME$,17)
1492: 2098:                     CALL WRITE.RFCNTLST ("")
1493: 20b9:                     PREV.CNT.STATUS$ = CURR.CNT.STATUS$
1494: 20d5: 
1495: 20d5:                 ENDIF ELSE IF CURR.CNT.STATUS$ = "2" THEN BEGIN
1496: 20f3: 
1497: 20f3:                     IF PREV.CNT.STATUS$ = " " THEN BEGIN
1498: 210e:                         RFCNTLST.RECORD$ = "Counted Lists       "
1499: 2123:                         CALL WRITE.RFCNTLST ("2M")
1500: 2144:                     ENDIF
1501: 214c: 
1502: 214c:                     !Checks the Current Status to verify that
1503: 214c:                     !    PREV.CNT.STATUS$ <> CURR.CNT.STATUS$
1504: 214c:                     !If PREV.CNT.STATUS$ <> CURR.CNT.STATUS$ then
1505: 214c:                     !    print the header
1506: 214c: 
1507: 214c:                     IF PREV.CNT.STATUS$ <> CURR.CNT.STATUS$ THEN BEGIN
1508: 216b:                         RFCNTLST.RECORD$ = "Part Counted Lists  "
1509: 2180:                         CALL WRITE.RFCNTLST ("2M")
1510: 21a1:                     ENDIF
1511: 21a9: 
1512: 21a9:                     !If the list is User generated list, write the time
1513: 21a9:                     !and the user created the list in the report
1514: 21a9: 
1515: 21a9:                     IF COUNTER% = 2 THEN BEGIN
1516: 21bb:                         AF.OPERATOR.NO$ = PACK$(RIGHT$(("00000000" +            \
1517: 221d:                                           MID$(F14.TABLE$(CURR.RECORD.INDEX%),  \
1518: 221d:                                           30,3)),8))
1519: 221d:                         CALL GET.OP.NAME$
1520: 2229:                         RFCNTLST.RECORD$ = MID$(F14.TABLE$(CURR.RECORD.INDEX%), \
1521: 22b7:                                            9,2) + ":" +                         \      ! CCSK
1522: 22b7:                                            MID$(F14.TABLE$(CURR.RECORD.INDEX%), \
1523: 22b7:                                            11,2) + " " +                        \
1524: 22b7:                                            LEFT$(GET.OP.NAME$,14) ! OP NAME SET TO 14 CHARACTERS
1525: 22b7:                         CALL WRITE.RFCNTLST ("3M")
1526: 22d8:                     ENDIF
1527: 22e0: 
1528: 22e0:                     RFCNTLST.RECORD$ =  "List " +                               \
1529: 239c:                                         MID$(F14.TABLE$(CURR.RECORD.INDEX%),    \
1530: 239c:                                         16,3) + " " +                           \
1531: 239c:                                         RIGHT$("   "+ STR$(VAL(MID$(F14.TABLE$  \
1532: 239c:                                         (CURR.RECORD.INDEX%),19,3))), 3) +      \
1533: 239c:                                         " items  "
1534: 239c:                     CALL WRITE.RFCNTLST ("")
1535: 23bd: 
1536: 23bd:                     RFCNTLST.RECORD$ =  "Uncounted " + RIGHT$("   " +           \
1537: 2448:                                         STR$(VAL(MID$(F14.TABLE$                \
1538: 2448:                                         (CURR.RECORD.INDEX%),33,3))), 3) +      \
1539: 2448:                                         " items "
1540: 2448:                     CALL WRITE.RFCNTLST ("")
1541: 2469: 
1542: 2469:                     RFCNTLST.RECORD$ =  "from " + MID$(F14.TABLE$               \
1543: 2545:                                         (CURR.RECORD.INDEX%),22,2) +            \
1544: 2545:                                         ":" + MID$(F14.TABLE$                   \
1545: 2545:                                         (CURR.RECORD.INDEX%),24,2) +            \
1546: 2545:                                         + " to " + MID$(F14.TABLE$              \
1547: 2545:                                         (CURR.RECORD.INDEX%),26,2) +            \
1548: 2545:                                         ":" + MID$(F14.TABLE$                   \
1549: 2545:                                         (CURR.RECORD.INDEX%),28,2) + " "
1550: 2545:                     CALL WRITE.RFCNTLST ("")
1551: 2566: 
1552: 2566:                     !Set the key for reading the EALAUTH
1553: 2566:                     AF.OPERATOR.NO$ = PACK$(RIGHT$(("00000000" +                \
1554: 25c8:                                       MID$(F14.TABLE$(CURR.RECORD.INDEX%),      \
1555: 25c8:                                       13,3)),8))
1556: 25c8:                     CALL GET.OP.NAME$
1557: 25d4: 
1558: 25d4:                     RFCNTLST.RECORD$ =  "By " + LEFT$(GET.OP.NAME$,17)
1559: 2604:                     CALL WRITE.RFCNTLST ("")
1560: 2625:                     PREV.CNT.STATUS$ = CURR.CNT.STATUS$
1561: 2641: 
1562: 2641:                 ENDIF ELSE IF CURR.CNT.STATUS$ = "3" THEN BEGIN
1563: 265f: 
1564: 265f:                     IF PREV.CNT.STATUS$ = " " THEN BEGIN
1565: 267a:                         RFCNTLST.RECORD$ = "Counted Lists       "
1566: 268f:                         CALL WRITE.RFCNTLST ("2M")
1567: 26b0:                         RFCNTLST.RECORD$ = "Part Counted Lists  "
1568: 26c5:                         CALL WRITE.RFCNTLST ("2M")
1569: 26e8:                     ENDIF ELSE IF PREV.CNT.STATUS$ = "1" THEN BEGIN
1570: 2703:                         RFCNTLST.RECORD$ = "Part Counted Lists  "
1571: 2718:                         CALL WRITE.RFCNTLST ("2M")
1572: 2739:                     ENDIF
1573: 2741: 
1574: 2741:                     !Checks the Current Status to verify that
1575: 2741:                     !    PREV.CNT.STATUS$ <> CURR.CNT.STATUS$
1576: 2741:                     !If PREV.CNT.STATUS$ <> CURR.CNT.STATUS$ then
1577: 2741:                     !    print the header
1578: 2741: 
1579: 2741:                     IF PREV.CNT.STATUS$ <> CURR.CNT.STATUS$ THEN BEGIN
1580: 2760:                         RFCNTLST.RECORD$ = "Uncounted Lists     "
1581: 2775:                         CALL WRITE.RFCNTLST ("2M")
1582: 2796:                     ENDIF
1583: 279e: 
1584: 279e:                     !If the list is User generated list, write the time
1585: 279e:                     !and the user created the list in the report
1586: 279e: 
1587: 279e:                     IF COUNTER% = 2 THEN BEGIN
1588: 27b0:                         AF.OPERATOR.NO$ = PACK$(RIGHT$(("00000000" +            \
1589: 2812:                                           MID$(F14.TABLE$(CURR.RECORD.INDEX%),  \
1590: 2812:                                           30,3)),8))
1591: 2812:                         CALL GET.OP.NAME$
1592: 281e:                         RFCNTLST.RECORD$ = MID$(F14.TABLE$(CURR.RECORD.INDEX%), \
1593: 28ac:                                             9,2) + ":" +                        \     ! CCSK
1594: 28ac:                                            MID$(F14.TABLE$(CURR.RECORD.INDEX%), \
1595: 28ac:                                            11,2) + " " +                        \
1596: 28ac:                                            LEFT$(GET.OP.NAME$,14) ! OP NAME SET TO 14 CHARACTERS
1597: 28ac:                         CALL WRITE.RFCNTLST ("3M")
1598: 28cd:                     ENDIF
1599: 28d5: 
1600: 28d5:                     RFCNTLST.RECORD$ =  "List " + MID$(F14.TABLE$               \
1601: 2991:                                         (CURR.RECORD.INDEX%),16,3) +            \
1602: 2991:                                         " " + RIGHT$("   "  + STR$(VAL(MID$     \
1603: 2991:                                         (F14.TABLE$(CURR.RECORD.INDEX%),        \
1604: 2991:                                         19,3))), 3) + " items  "
1605: 2991:                     CALL WRITE.RFCNTLST ("")
1606: 29b2:                     PREV.CNT.STATUS$ = CURR.CNT.STATUS$
1607: 29cb: 
1608: 29cb:                 ENDIF
1609: 29d3:             ENDIF
1610: 29db:         NEXT CURR.RECORD.INDEX%
1611: 29f6: 
1612: 29f6:         !If PREV.CNT.STATUS$ = " " then write the three headers
1613: 29f6:         !    Counted Lists, Part Counted Lists, Uncounted Lists
1614: 29f6:         !If PREV.CNT.STATUS$ = "1" then write the two headers
1615: 29f6:         !    Part Counted Lists, Uncounted Lists
1616: 29f6:         !If PREV.CNT.STATUS$ = "2" then write the two headers
1617: 29f6:         !    Uncounted Lists
1618: 29f6: 
1619: 29f6:         IF PREV.CNT.STATUS$ = " " THEN BEGIN
1620: 2a14:             RFCNTLST.RECORD$ = "Counted Lists       "
1621: 2a29:             CALL WRITE.RFCNTLST ("2M")
1622: 2a4a:             RFCNTLST.RECORD$ = "Part Counted Lists  "
1623: 2a5f:             CALL WRITE.RFCNTLST ("2M")
1624: 2a80:             RFCNTLST.RECORD$ = "Uncounted Lists     "
1625: 2a95:             CALL WRITE.RFCNTLST ("2M")
1626: 2ab9:         ENDIF ELSE IF PREV.CNT.STATUS$ = "1" THEN BEGIN
1627: 2ad4:             RFCNTLST.RECORD$ = "Part Counted Lists  "
1628: 2ae9:             CALL WRITE.RFCNTLST ("2M")
1629: 2b0a:             RFCNTLST.RECORD$ = "Uncounted Lists     "
1630: 2b1f:             CALL WRITE.RFCNTLST ("2M")
1631: 2b42:         ENDIF ELSE IF PREV.CNT.STATUS$ = "2" THEN BEGIN
1632: 2b5d:             RFCNTLST.RECORD$ = "Uncounted Lists     "
1633: 2b72:             CALL WRITE.RFCNTLST ("2M")
1634: 2b93:         ENDIF
1635: 2b9b: 
1636: 2b9b:         RFCNTLST.RECORD$ = "--------------------"
1637: 2bb0:         CALL WRITE.RFCNTLST ("")
1638: 2bd1: 
1639: 2bd1:     NEXT COUNTER%
1640: 2beb: 
1641: 2beb:     RFCNTLST.RECORD$ = "   END OF REPORT    "
1642: 2c00:     CALL WRITE.RFCNTLST ("")
1643: 2c21: 
1644: 2c21: RETURN
1645: 2c31: 
1646: 2c31: \*****************************************************************************
1647: 2c31: \***
1648: 2c31: \***    DEALLOCATE.SESSION.NUMBERS
1649: 2c31: \***    Detail        : Perform CALL.F20.SESS.NUM.UTILITY to de-allocate file
1650: 2c31: \***                    session numbers from all files referenced by the
1651: 2c31: \***                    program.
1652: 2c31: \***
1653: 2c31: \***..........................................................................
1654: 2c31: 
1655: 2c31: DEALLOCATE.SESSION.NUMBERS:
1656: 2c41: 
1657: 2c41:     ADXSERVE.DATA$ = "Deallocating Session numbers - MINRFCNT"
1658: 2c56:     GOSUB DISPLAY.MESSAGE
1659: 2c68: 
1660: 2c68:     FUNCTION.FLAG$ EQ "C"
1661: 2c7d: 
1662: 2c7d:     PASSED.INTEGER% = CLOLF.SESS.NUM%
1663: 2c8f:     PASSED.STRING$ = ""
1664: 2ca4:     GOSUB CALL.F20.SESS.NUM.UTILITY
1665: 2cb6: 
1666: 2cb6:     PASSED.INTEGER% = CLILF.SESS.NUM%
1667: 2cc8:     PASSED.STRING$ = ""
1668: 2cdd:     GOSUB CALL.F20.SESS.NUM.UTILITY
1669: 2cef: 
1670: 2cef:     PASSED.INTEGER% = AF.SESS.NUM%
1671: 2d01:     PASSED.STRING$ = ""
1672: 2d16:     GOSUB CALL.F20.SESS.NUM.UTILITY
1673: 2d28: 
1674: 2d28:     PASSED.INTEGER% = RFCNTLST.SESS.NUM%
1675: 2d3a:     PASSED.STRING$ = ""
1676: 2d4f:     GOSUB CALL.F20.SESS.NUM.UTILITY
1677: 2d61: 
1678: 2d61:     ADXSERVE.DATA$ = "Session numbers deallocating success - MINRFCNT"
1679: 2d76:     GOSUB DISPLAY.MESSAGE
1680: 2d88: 
1681: 2d88: RETURN
1682: 2d98: 
1683: 2d98: \*****************************************************************************
1684: 2d98: \***
1685: 2d98: \***    Display background message
1686: 2d98: \***
1687: 2d98: \***..........................................................................
1688: 2d98: 
1689: 2d98: DISPLAY.MESSAGE:
1690: 2da8: 
1691: 2da8:     IF COMM.MODE.FLAG$ = "B" THEN BEGIN
1692: 2dc6:         ADX.INTEGER%  = 0
1693: 2dd4:         ADX.FUNCTION% = 26
1694: 2de2:         CALL ADXSERVE (ADX.RETURN.CODE%,     \
1695: 2e04:                        ADX.FUNCTION%,        \
1696: 2e04:                        ADX.INTEGER%,         \
1697: 2e04:                        ADXSERVE.DATA$)
1698: 2e04:     ENDIF ELSE BEGIN
1699: 2e0c:         PRINT ADXSERVE.DATA$
1700: 2e21:     ENDIF
1701: 2e29: 
1702: 2e29: RETURN
1703: 2e39: 
1704: 2e39: \*****************************************************************************
1705: 2e39: \***
1706: 2e39: \***    FORMAT.CURRENT.CODE:
1707: 2e39: \***    Detail        : Sets CURRENT.CODE.LOGGED$ for use with application
1708: 2e39: \***                    event log.
1709: 2e39: \***
1710: 2e39: \***..........................................................................
1711: 2e39: 
1712: 2e39: FORMAT.CURRENT.CODE:
1713: 2e49: 
1714: 2e49:     IF FILE.OPERATION$ EQ "C"                            \ ! Create
1715: 2e9b:       OR FILE.OPERATION$ EQ "O" THEN                     \ ! Open
1716: 2e9b:     BEGIN
1717: 2e9b:         CURRENT.CODE.LOGGED$ EQ PACK$("00000000000000")
1718: 2eb5:     ENDIF
1719: 2ebd: 
1720: 2ebd:     IF FILE.OPERATION$ EQ "R"                            \ ! Read
1721: 2f0f:       OR FILE.OPERATION$ EQ "W" THEN                     \ ! Write
1722: 2f0f:     BEGIN
1723: 2f0f:         CURRENT.CODE.LOGGED$ EQ RIGHT$(CURRENT.CODE$,7)
1724: 2f32:     ENDIF
1725: 2f3a: 
1726: 2f3a: RETURN
1727: 2f4a: 
1728: 2f4a: \*****************************************************************************
1729: 2f4a: \***
1730: 2f4a: \***    CALL.F01.APPLICATION.LOG:
1731: 2f4a: \***    Detail        : References APPLICATION.LOG (F01) to write details
1732: 2f4a: \***                    of event defined by EVENT.NUMBER% and VAR.STRING.1$
1733: 2f4a: \***                    to Application Event Log, and to display any message
1734: 2f4a: \***                    defined by MESSAGE.NUMBER% and VAR.STRING.2$.
1735: 2f4a: \***
1736: 2f4a: \***..........................................................................
1737: 2f4a: 
1738: 2f4a: CALL.F01.APPLICATION.LOG:
1739: 2f5a:     FUNCTION.RETURN.CODE% EQ    \
1740: 2f86:         APPLICATION.LOG         \
1741: 2f86:         (MESSAGE.NUMBER%,       \
1742: 2f86:         VAR.STRING.1$,          \
1743: 2f86:         VAR.STRING.2$,          \
1744: 2f86:         EVENT.NUMBER%)
1745: 2f86: RETURN
1746: 2f96: 
1747: 2f96: \*****************************************************************************
1748: 2f96: \***
1749: 2f96: \***    LOG.AN.EVENT.106:
1750: 2f96: \***    Detail        : Writes details of Event 106 to application event
1751: 2f96: \***                    log and displays message B501 (for file open errors)
1752: 2f96: \***                    or B514 (for other errors).
1753: 2f96: \***
1754: 2f96: \***..........................................................................
1755: 2f96: 
1756: 2f96: LOG.AN.EVENT.106:
1757: 2fa6: 
1758: 2fa6:     ADXSERVE.DATA$ = "LOG.AN.EVENT.106 File Op= " + FILE.OPERATION$
1759: 2fc9:     GOSUB DISPLAY.MESSAGE
1760: 2fdb: 
1761: 2fdb:     EVENT.NUMBER% EQ 106
1762: 2fe9:     GOSUB FORMAT.CURRENT.CODE
1763: 2ffb:     VAR.STRING.1$ EQ                         \ ! Application event log data
1764: 306a:         FILE.OPERATION$                    + \
1765: 306a:         CHR$(SHIFT(CURRENT.REPORT.NUM%,8)) + \ ! Two byte integer byte order
1766: 306a:         CHR$(SHIFT(CURRENT.REPORT.NUM%,0)) + \ ! reversed to give hex number
1767: 306a:         CURRENT.CODE.LOGGED$
1768: 306a: 
1769: 306a:     GOSUB CALL.F01.APPLICATION.LOG
1770: 307c: 
1771: 307c: RETURN
1772: 308c: 
1773: 308c: \*****************************************************************************
1774: 308c: \***
1775: 308c: \***    ERROR.DETECTED:
1776: 308c: \***    Detail        : Below mentioned are the main process done here.
1777: 308c: \***                    1. Increments ERROR.COUNT% by one for errors that
1778: 308c: \***                       are not handled
1779: 308c: \***                    2. Further errors within ERROR.DETECTED causing
1780: 308c: \***                       control to be passed here again result in this
1781: 308c: \***                       test being failed and the immediate diversion of
1782: 308c: \***                       program control to STOP.MINRFCNT
1783: 308c: \***
1784: 308c: \***..........................................................................
1785: 308c: 
1786: 308c: ERROR.DETECTED:
1787: 309c: 
1788: 309c:     IF ERR = "CU" THEN BEGIN
1789: 30c2:         ERROR.COUNT% = 0
1790: 30cf:         RESUME
1791: 30e6:     ENDIF
1792: 30ee: 
1793: 30ee:     IF CURRENT.REPORT.NUM% = RFCNTLST.REPORT.NUM% THEN BEGIN
1794: 3106:         IF FILE.OPERATION$ = "W" THEN BEGIN
1795: 3124:             ADXSERVE.DATA$ = "Error in writing to RFCNTLST.DAY file"
1796: 3139:             GOSUB DISPLAY.MESSAGE
1797: 314b:             GOSUB LOG.AN.EVENT.106
1798: 315d:             RESUME STOP.MINRFCNT
1799: 3177:         ENDIF ELSE IF FILE.OPERATION$ = "O" THEN BEGIN
1800: 3198:             CREATE RFCNTLST.FILE.NAME$ AS RFCNTLST.SESS.NUM%
1801: 31bc:             ADXSERVE.DATA$ = "Created RFCNTLST.DAY File" + STRING$(17, " ") + \
1802: 31ee:                              "- MINRFCNT "
1803: 31ee:             GOSUB DISPLAY.MESSAGE
1804: 3200:             RESUME
1805: 3217:         ENDIF
1806: 321f:     ENDIF
1807: 3227: 
1808: 3227:     IF FILE.OPERATION$ = "O" THEN BEGIN
1809: 3248:         ERROR.COUNT% = 0
1810: 3255:         IF CURRENT.REPORT.NUM% = CLOLF.REPORT.NUM% THEN BEGIN
1811: 326d:             ADXSERVE.DATA$ = "Error in opening CLOLF file"
1812: 3282:             GOSUB DISPLAY.MESSAGE
1813: 3294:             GOSUB LOG.AN.EVENT.106
1814: 32a6:             RESUME STOP.MINRFCNT
1815: 32c0:         ENDIF ELSE IF CURRENT.REPORT.NUM% = CLILF.REPORT.NUM% THEN BEGIN
1816: 32d8:             ADXSERVE.DATA$ = "Error in opening CLILF file"
1817: 32ed:             GOSUB DISPLAY.MESSAGE
1818: 32ff:             GOSUB LOG.AN.EVENT.106
1819: 3311:             RESUME STOP.MINRFCNT
1820: 332a:         ENDIF ELSE IF CURRENT.REPORT.NUM% = AF.REPORT.NUM% THEN BEGIN
1821: 3343:             ADXSERVE.DATA$ = "Error in opening EALAUTH file"
1822: 3358:             GOSUB DISPLAY.MESSAGE
1823: 336a:             RESUME
1824: 3381:         ENDIF
1825: 3389:     ENDIF
1826: 3391: 
1827: 3391:     FUNCTION.RETURN.CODE% EQ  \
1828: 33c1:     STANDARD.ERROR.DETECTED   \
1829: 33c1:     (ERRN,                    \
1830: 33c1:     ERRF%,                    \
1831: 33c1:     ERRL,                     \
1832: 33c1:     ERR)
1833: 33c1: 
1834: 33c1:     ERROR.COUNT% = ERROR.COUNT% + 1
1835: 33cd:     IF ERROR.COUNT% > 1 THEN BEGIN
1836: 33dc:         RESUME STOP.MINRFCNT
1837: 33f3:     ENDIF
1838: 33fb: 
1839: 33fb: END SUB
1840: 340f: 
1841: 340f: 
1842: 340f: End of Compilation
