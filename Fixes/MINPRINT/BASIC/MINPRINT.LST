   1: 0003: \*****************************************************************************
   2: 0003: \*****************************************************************************
   3: 0003: \***
   4: 0003: \***    PROGRAM  .....  MINPRINT
   5: 0003: \***    MODULE  ......  MINPRINT.BAS
   6: 0003: \***
   7: 0003: \***    REVISION 1.0.           ROBERT COWEY.                  01 NOV 1995.
   8: 0003: \***    Original version.
   9: 0003: \***
  10: 0003: \***    VERSION B (1.1)        Nik Sen                         06 FEB 1998
  11: 0003: \***    Re-written to use included code for file functions etc.
  12: 0003: \***
  13: 0003: \***    VERSION C              Nik Sen                         12 OCTOBER 1998
  14: 0003: \***    RF version. Changed to send count lists to RF files instead of
  15: 0003: \***    printing report if RF is active.
  16: 0003: \***
  17: 0003: \***    VERSION D              Charles Skadorwa                 7 DECEMBER 1998
  18: 0003: \***    Processing Statements added for debugging purposes.
  19: 0003: \***    RFSCF opened in NOWRITE NODEL mode instead of READONLY.
  20: 0003: \***    Check for List Driven Counting (RFSCF.ACTIVITY%) changed to check for
  21: 0003: \***    ASCII value "2" rather than bit value (& 64).
  22: 0003: \***
  23: 0003: \***    VERSION E              Charles Skadorwa                 15 January 1999
  24: 0003: \***    Program will now operate whether List Driven Counting is active or not.
  25: 0003: \***    Check removed from RF.PROCESS subroutine.
  26: 0003: \***
  27: 0003: \***    VERSION F              Charles Skadorwa                 18 January 1999
  28: 0003: \***    Items description now taken from the RPRPT file if one does not exist on
  29: 0003: \***    the ISF (this resulted in the item being ignored). In VALID.ITEM:,
  30: 0003: \***    IRF.DEAL.NUM$ should be initialised before the IRF is read,  otherwise
  31: 0003: \***    the next item will become a deal item if the previous one was!
  32: 0003: \***    CLILF size increased from 5,000 to 10,000 records to decrease chaining.
  33: 0003: \***    RFHOCNT.286 chained to if it is detected that MINPRINT is running outside
  34: 0003: \***    of normal hours (before 5pm or after 6am)- otherwise the Head Office
  35: 0003: \***    counts would be overwritten.
  36: 0003: \***    Barcode constructed from Boots Code if IDF barcode is null.
  37: 0003: \***    Initialise new CLILF field (CLILF.HO.SEQNO$)and CLOLF filed (CLOLF.TOTAL.ITEMS$).
  38: 0003: \***    Use pipe to instruct RF Server program (TRANSACT) to close down while
  39: 0003: \***    MINPRINT is executing (It will restart automatically at next signon).
  40: 0003: \***    If description not on ISF then description set to "X " in order that
  41: 0003: \***    TRANSACT will read the IDF and perform description formatting.
  42: 0003: \***
  43: 0003: \***    VERSION G              Julia Stones                  9th November 1999
  44: 0003: \***    Code removed that produced the RF report if RF was inactive on SOFTS
  45: 0003: \***    Please note that if RF is ACTIVE and DO MAIN gets set to 1 - before
  46: 0003: \***    changes were made this would have meant that the code would have
  47: 0003: \***    produced the RF report.  DO MAIN is not checked now and so the program
  48: 0003: \***    will just go into the termination part of the code.
  49: 0003: \***
  50: 0003: \***    VERSION H              Brian Greenfield              20th August 2003
  51: 0003: \***    Changes made for RF trial to accomodate IRF changes made in DEALS
  52: 0003: \***    rewrite.
  53: 0003: \***
  54: 0003: \***    REVISION 1.12.         ROBERT COWEY.                  09 SEP 2003.
  55: 0003: \***    Changes for RF trial.
  56: 0003: \***    Removed redundant PVCS revision control block from top of code.
  57: 0003: \***    Removed section of code at end of program that started RFHOCNT.
  58: 0003: \***    Corrected setting of HO.SEQNO within VALID.ITEMS routine.
  59: 0003: \***
  60: 0003: \***
  61: 0003: \***    VERSION I              Chris Combes (CC)            29th March 2004
  62: 0003: \***    Changes made to VALID.ITEM and CREATE.NEW.LIST procedures so lists are
  63: 0003: \***    divided into product groups rather than business units
  64: 0003: \***
  65: 0003: \***
  66: 0003: \***    Version J              Mark Goode                   17th September 2004
  67: 0003: \***    Changes made for OSSR Basic location project, additional information on
  68: 0003: \***    the CLILF/CLOLF files
  69: 0003: \***
  70: 0003: \***    Version K               Mark Goode                   14th January 2005
  71: 0003: \***    Changes made for OSSR WAN project, additioal information on the the CLOLF file.
  72: 0003: \***
  73: 0003: \***    Version L               Jamie Thorpe                 13th March 2006
  74: 0003: \***    Changes for Removal of RF Recounts project.This introduces the ability to
  75: 0003: \***    switch off the ability to perform recounts.
  76: 0003: \***
  77: 0003: \***    Version M               Jamie Thorpe                 4th April 2006
  78: 0003: \***    Updated the way that the CLOLF is initially created. This is to rectify
  79: 0003: \***    a hang reported in TRANSACT when it encounters 0 bytes in the file.
  80: 0003: \***
  81: 0003: \***    Version N              Charles Skadorwa              18th June 2009
  82: 0003: \***    CR006 - Change to ensure that if it is an MC70/POD store, then
  83: 0003: \***            processing will be identical to RF PPC processing. This is
  84: 0003: \***            achieved by checking SOFTS record 20 for " ACTIVE"
  85: 0003: \***
  86: 0003: \***    Version O              Arun Sudhakarannair           14th June 2012
  87: 0003: \***    The program is updated to support the following changes as part of
  88: 0003: \***    SFA Project
  89: 0003: \***        - Rerun and Rerun warning message
  90: 0003: \***              With the re-introduction of counts, it is important that
  91: 0003: \***              MINPRINT is not rerun without understanding what it will
  92: 0003: \***              do to the CLOLF.CLILF and the backups. Hence a new parameter
  93: 0003: \***              (RERUN) must be passed if run from command mode, with
  94: 0003: \***              help details. Format is "MINPRINT RERUN"
  95: 0003: \***        - Prepare a new RF Count report (RFCNTLST.DAY)
  96: 0003: \***              Report gives a summary for each count list type (Negative,
  97: 0003: \***              User Generated and Support Office) and also gives details
  98: 0003: \***              of which users performed the counts, and whether the list
  99: 0003: \***              was fully counted, part counted or not counted at all.
 100: 0003: \***        - For non RF/POD stores, create the CLOLF/CLILF
 101: 0003: \***              Currently, only RF/POD stores have the CLOLF/CLILF files
 102: 0003: \***              present. However as part of SFA, these files need creating
 103: 0003: \***              and populating like RF/POD stores
 104: 0003: \***        - Create daily backups of the CLOLF and CLILF files
 105: 0003: \***              Back up the CLOLF and CLILF files on a daily basis (rolling
 106: 0003: \***              7 days). Backup the files before RF.PROCESS subroutine is
 107: 0003: \***              called. The backup will be used to generate the weekly
 108: 0003: \***              store manager count report.
 109: 0003: \***        - Support the new CLOLF and CLILF formats
 110: 0003: \***        - Introduce a new OK file – MINOK.BIN
 111: 0003: \***              Introduce a new OK file to show success status of each step
 112: 0003: \***              of MINPRINT processing.
 113: 0003: \***
 114: 0003: \***    Version P              Bibin Thomas                  10th Aug 2012
 115: 0003: \***    Changes made to accommodate SFA CR7 requirements.
 116: 0003: \***    In case of a non trading day, MINPRINT is run any time b/w 21:05Hrs
 117: 0003: \***    and 00:30Hrs. So if MINPRINT is run after midnight, the program will
 118: 0003: \***    backup CLILF/CLOLF with Today's extension, where as it is actually
 119: 0003: \***    supposed to backup with yesterday's <DAY>.
 120: 0003: \***    Changes are made so that if MINPRINT is run after 00:00Hrs and before
 121: 0003: \***    04:00Hrs, CLILF/CLOLF is backed-up with file extension set to
 122: 0003: \***    yesterday, else with today.
 123: 0003: \***
 124: 0003: \***    Version Q              Charles Skadorwa (CCSk)       10th Sept 2012
 125: 0003: \***    SFA Defect 661 -  Summary counts are not updated.
 126: 0003: \***    Also corrected screen prompt from "u" to "you".
 127: 0003: \***
 128: 0003: \***    Version R              Tittoo Thomas (RTT)           21th Sept 2012
 129: 0003: \***    SFA Defect 688, 695 - Restricted multiple runs of MINPRINT in a day.
 130: 0003: \***    If MINPPRINT is found to have already run after 1200 noon the previous
 131: 0003: \***    day or before 12 noon today, the application stops without any further
 132: 0003: \***    processing.
 133: 0003: \***
 134: 0003: \*****************************************************************************
 135: 0003: \*****************************************************************************
 136: 0003: 
 137: 0003: 
 138: 0003: 
 139: 0003: 
 140: 0003: \*****************************************************************************
 141: 0003: \***
 142: 0003: \***    DEC included code defining file related fields
 143: 0003: \***
 144: 0003: \***..........................................................................
 145: 0003: 
 146: 0003:     %INCLUDE   RPRPTDEC.J86    ! Report file
 147: 0003: \*****************************************************************************
 148: 0003: \***                                                                         *
 149: 0003: \***           %INCLUDE FOR RPRPT - MINSITS RP REPORT FILE                         *
 150: 0003: \***                                                                         *
 151: 0003: \***                    - FIELD DECLARATIONS                                 *
 152: 0003: \***                    - FILE REFERENCE PARAMETERS                          *
 153: 0003: \***                                                                         *
 154: 0003: \***                    REFERENCE: RPRPTDEC.J86                              *
 155: 0003: \***                                                                         *
 156: 0003: \***           Version A      Nik Sen       24th February 1998                *
 157: 0003: \***                                                                         *
 158: 0003: \*****************************************************************************
 159: 0003: 
 160: 0003:    INTEGER*1 GLOBAL            \
 161: 0003:    RPRPT.SESS.NUM%
 162: 0003: 
 163: 0003:    INTEGER*2 GLOBAL            \   
 164: 0003:    RPRPT.REPORT.NUM%    
 165: 0003: 
 166: 0003:    STRING GLOBAL               \
 167: 0003:    RPRPT.FILE.NAME$
 168: 0003: 
 169: 0003:     %INCLUDE   PRINTDEC.J86    ! Printer
 170: 0003: 
 171: 0003: REM \
 172: 0003: \*******************************************************************************
 173: 0003: \*******************************************************************************
 174: 0003: \***
 175: 0003: \***    %INCLUDE FOR PRINT FILE VARIABLE DECLARATIONS
 176: 0003: \***
 177: 0003: \***        REFERENCE   :   PRINTDE (J86)
 178: 0003: \***
 179: 0003: \***        FILE TYPE   :   Printer / Labeller
 180: 0003: \***
 181: 0003: \***    VERSION A.              ANDREW WEDGEWORTH                   09 JUL 1992.
 182: 0003: \***    Original version created by merging PRINTFLG and PRINTNUG.
 183: 0003: \***
 184: 0003: \***    VERSION B.              UNKNOWN.                            ?? ??? 1992.
 185: 0003: \***    Changes unknown.             
 186: 0003: \***
 187: 0003: \***    VERSION C.              ROBERT COWEY.                       18 NOV 1992.
 188: 0003: \***    No changes made to this file.
 189: 0003: \***
 190: 0003: \***    Version D               Andrew Wedgeworth                 24th May 1992
 191: 0003: \***    Variable added to contain condensed print record length.
 192: 0003: \***
 193: 0003: \*******************************************************************************
 194: 0003: \*******************************************************************************
 195: 0003: 
 196: 0003: 
 197: 0003:     STRING GLOBAL \
 198: 0003:         PRINT.LINE$, \
 199: 0003:         PRINT.FILE.NAME$, \
 200: 0003:         SELF.LAN.NAME$, \
 201: 0003:         SELF.NOLAN.NAME$
 202: 0003: 
 203: 0003:     INTEGER*2 GLOBAL \
 204: 0003:         PRINT.CONDENSED.RECL%, \                                       ! DAW  
 205: 0003:         PRINT.SESS.NUM%, \
 206: 0003:         PRINT.REPORT.NUM%, \
 207: 0003:         PRINT.REPORT.RECL%, \
 208: 0003:         PRINT.SELF.RECL%
 209: 0003: 
 210: 0003:     %INCLUDE   SOFTSDEC.J86    ! SOFTSTAT                      CNS
 211: 0003: REM \
 212: 0003: \******************************************************************************
 213: 0003: \******************************************************************************
 214: 0003: \***
 215: 0003: \***                 %INCLUDE FOR THE SOFTWARE STATUS FILE
 216: 0003: \***   
 217: 0003: \***                      FILE TYPE  :   Direct
 218: 0003: \***
 219: 0003: \***                      REFERENCE  :   SOFTSDEC.J86
 220: 0003: \***
 221: 0003: \***	Version A	       Andrew Wedgeworth	      24th June 1992
 222: 0003: \***
 223: 0003: \******************************************************************************
 224: 0003: \*******************************************************************************
 225: 0003: 
 226: 0003:   STRING GLOBAL           \
 227: 0003:     SOFTS.RECORD$,        \           
 228: 0003:     SOFTS.SPACE$,         \           
 229: 0003:     SOFTS.FILE.NAME$    
 230: 0003:     
 231: 0003:   INTEGER*2 GLOBAL        \
 232: 0003:     SOFTS.RECL%,          \            
 233: 0003:     SOFTS.REPORT.NUM%,	  \      
 234: 0003:     SOFTS.SESS.NUM%
 235: 0003: 
 236: 0003:   INTEGER*4 GLOBAL        \
 237: 0003:     SOFTS.REC.NUM% 	         
 238: 0003:     %INCLUDE   RFSCFDEC.J86    ! RF Control File               CNS
 239: 0003: \******************************************************************************
 240: 0003: \******************************************************************************
 241: 0003: \***
 242: 0003: \***   $Workfile:   RFSCFDEC.J86  $
 243: 0003: \***
 244: 0003: \***   $Revision:   1.7  $
 245: 0003: \***
 246: 0003: \******************************************************************************
 247: 0003: \******************************************************************************
 248: 0003: \***
 249: 0003: \***
 250: 0003: \***
 251: 0003: \***
 252: 0003: \*****************************************************************************
 253: 0003: \*****************************************************************************
 254: 0003: \***
 255: 0003: \***               %INCLUDE FOR RFSCF - FIELD DECLARATIONS
 256: 0003: \***                                    FILE REFERENCE PARAMETERS
 257: 0003: \***
 258: 0003: \***                      FILE TYPE    : DIRECT
 259: 0003: \***
 260: 0003: \***                      REFERENCE    : RFSCFDEC
 261: 0003: \***
 262: 0003: \***           VERSION A : NIK SEN  5th October 1998
 263: 0003: \***
 264: 0003: \***
 265: 0003: \*******************************************************************************
 266: 0003: \*******************************************************************************
 267: 0003: \***           VERSIOB B       Mark Goode       23rd August 2004
 268: 0003: \***
 269: 0003: \***   Updated to reflect current RF version, also includes new fields for OSSR
 270: 0003: \*******************************************************************************
 271: 0003: \***           VERSION C       Jamie Thorpe      9th December 2004
 272: 0003: \***
 273: 0003: \***   Updated with record 3 variables.
 274: 0003: \*******************************************************************************
 275: 0003: \***           VERSION D       Jamie Thorpe     13th March 2006
 276: 0003: \***
 277: 0003: \***   Updated with record 1 variable.RFSCF.RECOUNT.DAYS.RETAIN%
 278: 0003: \*******************************************************************************
 279: 0003: \***           VERSION E       Peter Sserunkuma 28th September 2008
 280: 0003: \***
 281: 0003: \***   Added RFSCF.PLANNERS.ACTIVE$.  This was currently named
 282: 0003: \***   RFSCF.FILLER$ in record 1.
 283: 0003: \*******************************************************************************
 284: 0003: \***           VERSION F       Peter Sserunkuma   21st January 2009
 285: 0003: \***
 286: 0003: \***   Six new fields added to record 3 as part of SFSCF2 changes.
 287: 0003: \***   RFSCF.DIRECTS.ACTIVE$
 288: 0003: \***   RFSCF.ASN.ACTIVE$
 289: 0003: \***   RFSCF.POS.UOD.ACTIVE$
 290: 0003: \***   RFSCF.ONIGHT.DELIV$
 291: 0003: \***   RFSCF.ONIGHT.SCAN$
 292: 0003: \***   RFSCF.SCAN.BATCH$
 293: 0003: \*******************************************************************************
 294: 0003: \***           VERSION G       Tittoo Thomas          24th May 2012
 295: 0003: \***
 296: 0003: \***   Added RFSCF.PSP.LEAD.TIME$ in record 1, currently named RFSCF.FILLER$.
 297: 0003: \***   1 byte Packed and holds the number of days (usually 7 or 21 days). It
 298: 0003: \***   is used to indicate if a pending sales plan planner should be counted
 299: 0003: \***   if it becomes active in the next N days.
 300: 0003: \*******************************************************************************
 301: 0003: 
 302: 0003:   STRING GLOBAL                 \
 303: 0003:     RFSCF.ACTIVE$,              \ CJT
 304: 0003:     RFSCF.BCENTRES$,            \ CJT
 305: 0003:     RFSCF.CCHIST.NUM.DAYS$,     \CJT
 306: 0003:     RFSCF.FILE.NAME$,           \
 307: 0003:     RFSCF.FILLER$,              \
 308: 0003:     RFSCF.FILLER3$,             \ CJT
 309: 0003:     RFSCF.OSSRSTORE$,           \ BMG
 310: 0003:     RFSCF.PLANNERS.ACTIVE$,     \      !EPS
 311: 0003:     RFSCF.PSP.LEAD.TIME$,       \      !GTT
 312: 0003:     RFSCF.DIRECTS.ACTIVE$,      \      !FPS
 313: 0003:     RFSCF.ASN.ACTIVE$,          \      !FPS
 314: 0003:     RFSCF.POS.UOD.ACTIVE$,      \      !FPS
 315: 0003:     RFSCF.ONIGHT.DELIV$,        \      !FPS
 316: 0003:     RFSCF.ONIGHT.SCAN$,         \      !FPS
 317: 0003:     RFSCF.SCAN.BATCH.SIZE$             !FPS
 318: 0003: 
 319: 0003:   INTEGER*1 GLOBAL        \
 320: 0003:     RFSCF.ACTIVITY%,      \
 321: 0003:     RFSCF.EMUACTIVE%,     \
 322: 0003:     RFSCF.PRIMCURR%       ! BMG
 323: 0003: 
 324: 0003: 
 325: 0003:   INTEGER*2 GLOBAL        \
 326: 0003:     RFSCF.SESS.NUM%,      \
 327: 0003:     RFSCF.REPORT.NUM%,    \
 328: 0003:     RFSCF.RECL%,          \
 329: 0003:     RFSCF.PMEDTERM%,           \
 330: 0003:     RFSCF.QBUSTTERM%,          \
 331: 0003:     RFSCF.PMEDNEXTTXN%,        \
 332: 0003:     RFSCF.QBUSTNXTTXN%,        \
 333: 0003:     RFSCF.PCDATES%,            \
 334: 0003:     RFSCF.PCHKINC%,            \
 335: 0003:     RFSCF.HHTIPMIN%,           \
 336: 0003:     RFSCF.HHTIPMAX%,           \
 337: 0003:     RFSCF.RECOUNT.DAYS.RETAIN% ! DJT
 338: 0003: 
 339: 0003:   INTEGER*4 GLOBAL        \
 340: 0003:     RFSCF.REC.NUM%,       \
 341: 0003:     RFSCF.PMEDTXNCNT%,         \
 342: 0003:     RFSCF.PMEDQTY%,            \
 343: 0003:     RFSCF.QBUSTTXNCNT%,        \
 344: 0003:     RFSCF.QBUSTQTY%,           \
 345: 0003:     RFSCF.LDCPARM1%,           \
 346: 0003:     RFSCF.LDCPARM2%,           \
 347: 0003:     RFSCF.LDCPARM3%,           \
 348: 0003:     RFSCF.PCHKTARGET%,         \
 349: 0003:     RFSCF.CNTPCHK%,            \
 350: 0003:     RFSCF.PCHKUPPER%,          \
 351: 0003:     RFSCF.PCHKLOWER%,          \
 352: 0003:     RFSCF.PCHKDEFAULT%,        \
 353: 0003:     RFSCF.PCHKERRCNT%,         \
 354: 0003:     RFSCF.PCHKERRLST%,         \
 355: 0003:     RFSCF.EMUCNVFACT%          ! BMG
 356: 0003: 
 357: 0003: 
 358: 0003: 
 359: 0003: 
 360: 0003: 
 361: 0003: 
 362: 0003: 
 363: 0003: 
 364: 0003:     %INCLUDE   CLOLFDEC.J86    ! RF Count List Of Lists File   CNS
 365: 0003: 
 366: 0003: \******************************************************************************\******************************************************************************
 367: 0003: \******************************************************************************
 368: 0003: \***
 369: 0003: \***         %INCLUDE FOR RF LIST OF LISTS FILE FIELD DECLARATIONS
 370: 0003: \***
 371: 0003: \***               FILE TYPE    : DIRECT
 372: 0003: \***
 373: 0003: \***               REFERENCE    : CLOLFDEC.J86
 374: 0003: \***
 375: 0003: \***    VERSION A.           Nik Sen.               13 October 1998
 376: 0003: \***               New file for RF system. Holds list of counting lists. 
 377: 0003: \***
 378: 0003: \***    VERSION B            Charles Skadorwa        22nd January 1999
 379: 0003: \***               TOTAL.ITEMS added to keep track of total items in each list.
 380: 0003: \***                 
 381: 0003: \***    REVISION 1.4.            ROBERT COWEY.                  09 SEP 2003.
 382: 0003: \***    Changes for RF trial.
 383: 0003: \***    Removed redundant PVCS revision control block from top of code.
 384: 0003: \***    Recompiled to prevent future automatic recompiles.
 385: 0003: \***    No changes to actual code.
 386: 0003: \***
 387: 0003: \***    REVISION 1.5             ALAN CARR                     12 AUG 2004.
 388: 0003: \***    Changes for RF OSSR solution.
 389: 0003: \***    Added new flag "marked for OSSR count". This can be "Y" or "N"
 390: 0003: \***
 391: 0003: \***    REVISION 1.6            MARK GOODE                     5th January 2005.
 392: 0003: \***    Changes for RF OSSR WAN solution.
 393: 0003: \***    New field on the header record for remaining OSSR count figure and user ID
 394: 0003: \***
 395: 0003: \***    REVISION 1.7            SYAM JAYAN                     25th January 2012
 396: 0003: \***    The change is to rearrange/remove redundant fields and to add new
 397: 0003: \***    fields in CLOLF Format as part of Stock file accuracy project
 398: 0003: \***
 399: 0003: \*******************************************************************************
 400: 0003: \*******************************************************************************
 401: 0003: 
 402: 0003: STRING GLOBAL                   \
 403: 0003:     CLOLF.ACTIVE.STATUS$,       \                        ! 1.7 SJ
 404: 0003:     CLOLF.BULETT$,              \                        ! 1.7 SJ
 405: 0003:     CLOLF.CREATION.DATE$,       \Creation date           ! 1.7 SJ
 406: 0003:     CLOLF.CREATION.TIME$,       \Creation time           ! 1.7 SJ
 407: 0003:     CLOLF.CURRENT.LOCATION$,    \Current location        ! 1.7 SJ
 408: 0003:     CLOLF.EXPIRY.DATE$,         \Expiry date             ! 1.7 SJ
 409: 0003:     CLOLF.FILE.NAME$,           \                        ! 1.7 SJ
 410: 0003:     CLOLF.LISTID$,              \                        ! 1.7 SJ
 411: 0003:     CLOLF.LIST.NAME$,           \                        ! 1.7 SJ
 412: 0003:     CLOLF.LSTTYP$,              \                        ! 1.7 SJ
 413: 0003:     CLOLF.PICKER.USER.ID$,      \                        ! 1.7 SJ
 414: 0003:     CLOLF.PILST.ID$,            \                        ! 1.7 SJ
 415: 0003:     CLOLF.PICK.START.TIME$,     \Pick start time         ! 1.7 SJ
 416: 0003:     CLOLF.PICK.END.TIME$,       \Pick end time           ! 1.7 SJ
 417: 0003:     CLOLF.USERID$               ! 1.6 MG                 ! 1.7 SJ
 418: 0003:     !CLOLF.TOTAL.ITEMS$,        \ BCS                    ! 1.7 SJ
 419: 0003:     !CLOLF.SRITEMS$,            \                        ! 1.7 SJ
 420: 0003:     !CLOLF.BSITEMS$,            \                        ! 1.7 SJ
 421: 0003:     !CLOLF.BUNAME$,             \                        ! 1.7 SJ
 422: 0003:     !CLOLF.HOLISTID$,           \                        ! 1.7 SJ
 423: 0003:     !CLOLF.CNTDATE$,            \ 1.5 AC                 ! 1.7 SJ
 424: 0003:     !CLOLF.OSSR.FLAG$,          \ 1.5 AC                 ! 1.7 SJ
 425: 0003:     !CLOLF.OSSRITEMS$,          \ 1.6 MG                 ! 1.7 SJ
 426: 0003:   
 427: 0003: INTEGER*4 GLOBAL                \
 428: 0003:     CLOLF.RECORD.NUM%
 429: 0003: 
 430: 0003: INTEGER*2 GLOBAL                \
 431: 0003:     CLOLF.BSITEMS%,             \                        ! 1.7 SJ
 432: 0003:     CLOLF.OSSRITEMS%,           \                        ! 1.7 SJ
 433: 0003:     CLOLF.REPORT.NUM%,          \                        ! 1.7 SJ
 434: 0003:     CLOLF.SESS.NUM%,            \                        ! 1.7 SJ
 435: 0003:     CLOLF.SRITEMS%,             \                        ! 1.7 SJ
 436: 0003:     CLOLF.TOTAL.ITEMS%          !                        ! 1.7 SJ
 437: 0003:                                                   
 438: 0003: INTEGER*1 GLOBAL                \
 439: 0003:     CLOLF.RECL%         
 440: 0003: 
 441: 0003: 
 442: 0003:     %INCLUDE   CLILFDEC.J86    ! RF Count Lists File           CNS
 443: 0003: 
 444: 0003: \******************************************************************************\******************************************************************************
 445: 0003: \******************************************************************************
 446: 0003: \***
 447: 0003: \***         %INCLUDE FOR RF COUNT LISTS FILE FIELD DECLARATIONS
 448: 0003: \***
 449: 0003: \***               FILE TYPE    : KEYED
 450: 0003: \***
 451: 0003: \***               REFERENCE    : CLILFDEC.J86
 452: 0003: \***
 453: 0003: \***    VERSION A.              Nik Sen.                 13 October 1998
 454: 0003: \***                 New file for RF system. Holds count lists information.
 455: 0003: \***
 456: 0003: \***    VERSION B               Charles Skadorwa         22nd January 1999
 457: 0003: \***                 Head Office Sequence Number now held (from PIITM
 458: 0003: \***                 record) in order that a "complete" Type 13 transaction
 459: 0003: \***                 record is written to the STKMQ file. 
 460: 0003: \***
 461: 0003: \***    REVISION 1.4.            ROBERT COWEY.                  09 SEP 2003.
 462: 0003: \***    Changes for RF trial.
 463: 0003: \***    Removed redundant PVCS revision control block from top of code.
 464: 0003: \***    Recompiled to prevent future automatic recompiles.
 465: 0003: \***    No changes to actual code.
 466: 0003: \***
 467: 0003: \***    REVISION 1.5             ALAN CARR                      12 AUG 2004.
 468: 0003: \***    Changes for RF OSSR solution.
 469: 0003: \***    Added new fields for Off-Site StockRoom (OSSR) Basic Solution
 470: 0003: \***
 471: 0003: \***    REVISION 1.6             Mark Goode                     25th January 2005 
 472: 0003: \***
 473: 0003: \***    REVISION 1.7             Syam Jayan                     25th January 2012
 474: 0003: \***    The change is to rearrange/remove redundant fields and to add new
 475: 0003: \***    fields in CLILF Format as part of Stock file accuracy project
 476: 0003: \***
 477: 0003: \*******************************************************************************
 478: 0003: \*******************************************************************************
 479: 0003: 
 480: 0003: STRING GLOBAL                     \
 481: 0003:     CLILF.BOOTSCODE$,             \                                          ! 1.7 SJ
 482: 0003:     CLILF.COUNTED.STATUS$,        \ U-not counted, P-partially counted,      ! 1.7 SJ
 483: 0003:                                   \ C-counted                                ! 1.7 SJ
 484: 0003:     CLILF.DATE.LASTCNT$,          \ Date of Last Count field                 ! 1.7 SJ
 485: 0003:     CLILF.FILE.NAME$,             \                                          ! 1.7 SJ
 486: 0003:     CLILF.FILLER$(1),             \ Filler Array                             ! 1.7 SJ
 487: 0003:     CLILF.HO.SEQNO$,              \ Head Office Sequence No. from PIITM for  ! 1.7 SJ
 488: 0003:                                   \ Stock Support                            ! BCS ! 1.7 SJ
 489: 0003:     CLILF.ITEMSEQ$,               \ Item Sequence Number                     ! 1.7 SJ
 490: 0003:     CLILF.KEY$,                   \ LISTID + ITEMSEQ                         ! 1.7 SJ
 491: 0003:     CLILF.LISTID$,                \ List Number                              ! 1.7 SJ
 492: 0003:     CLILF.SPACE$                  ! Free space                               ! 1.7 SJ
 493: 0003:     !CLILF.BARCODE$,              \                                          ! 1.7 SJ
 494: 0003:     !CLILF.SELDESC$,              \ Shelf Edge Label Descriptor              ! 1.7 SJ
 495: 0003:     !CLILF.DEALMKR$,              \ Active Deal Marker                       ! 1.7 SJ
 496: 0003:     !CLILF.PRODGRP$,              \ Concept/Sequence Number                  ! 1.7 SJ
 497: 0003:     !CLILF.PRODGRPDESC$,          \ Product Group Descriptor                 ! 1.7 SJ 
 498: 0003:     !CLILF.BSCNT$,                \ Back Shop Counts                         ! 1.7 SJ
 499: 0003:     !CLILF.SFCNT$,                \ Shop Floor Counts                        ! 1.7 SJ
 500: 0003:     !CLILF.SALESSFCNT$,           \ Signed Sales at time of Shop Floor Count ! 1.7 SJ
 501: 0003:     !CLILF.SALEBSCNT$,            \ Sale at time of back shop count \ 1.5 AC ! 1.7 SJ
 502: 0003:     !CLILF.SALEOSSRCNT$,          \ Sale at time of OSSR count      \ 1.5 AC ! 1.7 SJ
 503: 0003:     !CLILF.OSSR.ITMSTKCNT$,       \ OSSR Item Stock count figure    \ 1.5 AC ! 1.7 SJ
 504: 0003:     !CLILF.TIMESFCNT$,            \ Time of Stock Floor count hh:mm \ 1.5 AC ! 1.7 SJ
 505: 0003:     !CLILF.TIMEBSCNT$,            \ Time of Back shop count hh:mm   \ 1.5 AC ! 1.7 SJ
 506: 0003:     !CLILF.TIMEOSSRCNT$,          \ Time of OSSR count hh:mm        \ 1.5 AC ! 1.7 SJ
 507: 0003: 
 508: 0003: INTEGER*4 GLOBAL                 \
 509: 0003:     CLILF.MODULE.ID%(1)          ! Planner ID Array (SRITL.POGDB%)           ! 1.7 SJ
 510: 0003: 
 511: 0003: INTEGER*2 GLOBAL                 \
 512: 0003:     CLILF.BSCNT%,                \ Main Backshop MBS Count                   ! 1.7 SJ
 513: 0003:     CLILF.BS.PEND.SA.CNT%,       \ Back Shop pending sales plan Count        ! 1.7 SJ
 514: 0003:     CLILF.COUNT%(1),             \ Count Array                               ! 1.7 SJ
 515: 0003:     CLILF.FILL.QUANTITY%(1),     \                                           ! 1.7 SJ
 516: 0003:     CLILF.OSSR.ITMSTKCNT%,       \ OSSR Item Stock count figure              ! 1.7 SJ
 517: 0003:     CLILF.OSSR.PEND.SA.CNT%,     \ OSSR pending sales plan Count field       ! 1.7 SJ
 518: 0003:     CLILF.RECL%,                 \                                           ! 1.7 SJ
 519: 0003:     CLILF.REPORT.NUM%,           \                                           ! 1.7 SJ
 520: 0003:     CLILF.SALESCNT%,             \ Sales count                               ! 1.7 SJ
 521: 0003:     CLILF.SESS.NUM%,             \ Clilf session number                      ! 1.7 SJ
 522: 0003:     CLILF.SFCNT%                 ! Shop floor count                          ! 1.7 SJ
 523: 0003:   
 524: 0003: INTEGER*1 GLOBAL                 \
 525: 0003:     CLILF.MODULE.SEQ%(1),        \ Module Seq Array (SRITL.MODULE.SEQ%)      ! 1.7 SJ
 526: 0003:     CLILF.REPEAT.CNT%(1)         ! Repeat Count Array (SRITL.REPEAT.CNT%)    ! 1.7 SJ
 527: 0003:     !CLILF.RECL%                 !                                           ! 1.7 SJ
 528: 0003: 
 529: 0003:     !%INCLUDE   ISFDEC.J86      ! Item Shelf Edge Label Descriptor File  CNS OAS
 530: 0003:     !%INCLUDE   IRFDEC.J86      ! Item Record File             CNS OAS
 531: 0003:     %INCLUDE   IDFDEC.J86      ! Item Data File                CNS
 532: 0003: REM \
 533: 0003: \******************************************************************************
 534: 0003: \******************************************************************************
 535: 0003: \***
 536: 0003: \***         %INCLUDE FOR ITEM DATA FILE - FIELD DECLARATIONS
 537: 0003: \***                                       FILE REFERENCE PARAMETERS
 538: 0003: \***
 539: 0003: \***                  FILE TYPE    : Keyed
 540: 0003: \***
 541: 0003: \***                  REFERENCE    : IDFDEC.J86
 542: 0003: \***
 543: 0003: \***         VERSION A : Andrew Wedgeworth  29th June 1992    
 544: 0003: \***
 545: 0003: \***    VERSION C.              Robert Cowey.                       25 AUG 1993.
 546: 0003: \***    Replaced un-used RANK$ with BSNS.CNTR$ and FILLER$.
 547: 0003: \***
 548: 0003: \***    VERSION D.              Andrew Wedgeworth               15th March 1995
 549: 0003: \***    Comments updated to reflect the fact that some bits on the file are
 550: 0003: \***    no longer used.
 551: 0003: \***
 552: 0003: \*******************************************************************************
 553: 0003: \*******************************************************************************
 554: 0003: 
 555: 0003:   STRING GLOBAL           \
 556: 0003:     IDF.FILE.NAME$,       \  
 557: 0003:     IDF.BOOTS.CODE$,      \ 4 byte UPD with check digit (key)
 558: 0003:     IDF.FIRST.BAR.CODE$,  \ 6 byte UPD without check digit
 559: 0003:     IDF.SECOND.BAR.CODE$, \ 6 byte UPD without check digit
 560: 0003:     IDF.NO.OF.BAR.CODES$, \ 2 byte UPD. Total number of bar codes for this item
 561: 0003:     IDF.PRODUCT.GRP$,     \ 3 byte UPD. The first two digits are the concept
 562: 0003:                           \ group and the last four the concept sequence
 563: 0003:     IDF.STNDRD.DESC$,     \ 24 bytes
 564: 0003:     IDF.STATUS.1$,        \ 1 byte, values B,C,D,P,X,Z and blank
 565: 0003:     IDF.INTRO.DATE$,      \ 3 byte UPD YYMMDD. Date first added to this file
 566: 0003:     IDF.BSNS.CNTR$,       \ 1 byte ASC. Business Centre ID letter      ! CRC
 567: 0003:     IDF.FILLER$,          \ 1 byte un-used                             ! CRC
 568: 0003:     IDF.PARENT.CODE$,     \ 4 byte UPD with check digit ; may be zero if no
 569: 0003:                           \ flashpacks, current IDF.BOOTS.CODE$ if parent line
 570: 0003:                           \ or Boots Code of parent line if a flashpack.
 571: 0003:     IDF.DATE.OF.LAST.SALE$! 3 byte UPD. Date of last sale.
 572: 0003: 
 573: 0003:   INTEGER*1 GLOBAL        \
 574: 0003:     IDF.BIT.FLAGS.1%,     \ 1 byte - bit values
 575: 0003:                           \ X"80"  - Group code flag
 576: 0003:                           \ X"40"  - Keylines flag
 577: 0003:                           \ X"20"  - Markdown flag
 578: 0003:                           \ X"10"  - Warehouse flag
 579: 0003:                           \ X"08"  - CSR flag
 580: 0003:                           \ X"04"  - Directs A flag
 581: 0003:                           \ X"02"  - Directs B flag
 582: 0003:                           \ X"01"  - Directs C flag
 583: 0003:     IDF.BIT.FLAGS.2%      \ 1 byte - bit values
 584: 0003:                           \ X"80"  - Own brand line flag
 585: 0003:                           \ X"40"  - Exclusive line flag
 586: 0003:                           \ X"20"  - Unused 
 587: 0003:                           \ X"10"  - Unused
 588: 0003:                           \ X"08"  - Stock system flag
 589: 0003:                           \ X"04"  - Pending count flag
 590: 0003:                           \ X"02"  - Reserved
 591: 0003:                           ! X"01"  - Reserved
 592: 0003: 
 593: 0003:   INTEGER*2 GLOBAL        \
 594: 0003:     IDF.RECL%,            \  
 595: 0003:     IDF.REPORT.NUM%,      \ 
 596: 0003:     IDF.SESS.NUM%
 597: 0003:     %INCLUDE   PGFDEC.J86      ! Product Group File            JMG
 598: 0003: 
 599: 0003: \REM
 600: 0003: \*******************************************************************************
 601: 0003: \*******************************************************************************
 602: 0003: \***
 603: 0003: \***    %INCLUDE FOR PRODUCT GROUP FILES VARIABLE DECLARATIONS
 604: 0003: \***
 605: 0003: \***        REFERENCE   :   PGFDEC (J86)
 606: 0003: \***
 607: 0003: \***        FILE TYPE   :   Direct (PGF and PGFD)
 608: 0003: \***                        Keyed (PGFO)
 609: 0003: \***
 610: 0003: \***    VERSION B.              ROBERT COWEY.                       30 SEP 1993.
 611: 0003: \***    Created by combining PGFDECA, PGFDFLDA, PGFOFLDA, PGFDNUMA and PGFONUMA.
 612: 0003: \***
 613: 0003: \***    REVISION 1.2.           ROBERT COWEY.                       27 OCT 2003.
 614: 0003: \***    Defined WRITE.PGF function.
 615: 0003: \***    No changes to this file.
 616: 0003: \***
 617: 0003: \***   Version C                Mark Goode                          21st December 2004
 618: 0003: \***   New field for Product groups marked as OSSR.
 619: 0003: \***   'Y' - OSSR Product group.
 620: 0003: \***   'N' - ' ' - Non-OSSR product group.
 621: 0003: \***
 622: 0003: \***    Version D               Tittoo Thomas                        2 SEP 2011
 623: 0003: \***    Changes to accomodate new csv format for PGDIR as part of
 624: 0003: \***    the Core Stores Release 2 project
 625: 0003: \***
 626: 0003: \*******************************************************************************
 627: 0003: \*******************************************************************************
 628: 0003: 
 629: 0003: 
 630: 0003: \*******************************************************************************
 631: 0003: \*******************************************************************************
 632: 0003: \***
 633: 0003: \***    OLD RECORD LAYOUT
 634: 0003: \***
 635: 0003: \***     1  3  UPD  PROD.GRP.NO$     Key
 636: 0003: \***     *  1  UPD  CON.GROUP$       Concept group
 637: 0003: \***     *  2  UPD  CON.SEQ$         Concept sequence
 638: 0003: \***     4 18  ASC  PROD.GRP.NAME$
 639: 0003: \***    22  1  ASC  SEL.FLAG$        "Y" Shelf edge labels not to be printed
 640: 0003: \***                                 "N" Shelf edge labels to be printed for
 641: 0003: \***                                     items in the product group
 642: 0003: \***    23  8  ASC  SPACE$
 643: 0003: \***
 644: 0003: \***    Record length 30
 645: 0003: \***
 646: 0003: \***    NEW CSV RECORD LAYOUT
 647: 0003: \***
 648: 0003: \***     1  ASC  REC.TYPE$        Hardcoded to 'P'
 649: 0003: \***     5  ASC  PROD.GRP.NO$     ccsss where,  cc is the Concept Group and
 650: 0003: \***                                            sss is the Sequence Number
 651: 0003: \***    18  ASC  PROD.GRP.NAME$
 652: 0003: \***     1  ASC  SEL.FLAG$        "Y" Shelf edge labels to be printed
 653: 0003: \***                              "N" Shelf edge labels not to be printed
 654: 0003: \***     1  UPD  OSSR.FLAG$       ALWAYS SET TO NULL - PLACEHOLDER ONLY
 655: 0003: \***
 656: 0003: \*******************************************************************************
 657: 0003: \*******************************************************************************
 658: 0003: \***
 659: 0003: \***    OTHER INFORMATION
 660: 0003: \***    Prefixes PGFDIR... and PGFO... are use for variables that are specific
 661: 0003: \***    to the direct (mainframe transmitted) of keyed (live store) usage of
 662: 0003: \***    the file.
 663: 0003: \***
 664: 0003: \*******************************************************************************
 665: 0003: \*******************************************************************************
 666: 0003: 
 667: 0003: 
 668: 0003:     STRING GLOBAL \
 669: 0003:         PGF.FILE.NAME$, \
 670: 0003:         PGF.PROD.GRP.NAME$, \
 671: 0003:         PGF.PROD.GRP.NO$, \
 672: 0003:         PGF.SEL.FLAG$, \
 673: 0003:         PGF.SPACE$, \
 674: 0003:         PGFDIR.FILE.NAME$, \
 675: 0003:         PGFDIR.REC.TYPE$, \                                             ! DTT
 676: 0003:         PGFO.FILE.NAME$,   \
 677: 0003:         PGF.OSSR.FLAG$
 678: 0003: 
 679: 0003:     INTEGER*2 GLOBAL \
 680: 0003:         PGF.RECL%, \
 681: 0003:         PGF.REPORT.NUM%, \
 682: 0003:         PGF.SESS.NUM%, \
 683: 0003:         PGFDIR.RECL%, \
 684: 0003:         PGFDIR.REPORT.NUM%, \
 685: 0003:         PGFDIR.SESS.NUM%, \
 686: 0003:         PGFO.RECL%, \
 687: 0003:         PGFO.REPORT.NUM%, \
 688: 0003:         PGFO.SESS.NUM%
 689: 0003: 
 690: 0003:     INTEGER*4 GLOBAL \
 691: 0003:         PGF.REC.NUM%, \
 692: 0003:         PGFDIR.REC.NO%
 693: 0003: 
 694: 0003:     %INCLUDE   MINLSDEC.J86    ! Minsits Recount Information   LJT
 695: 0003: 
 696: 0003: \*****************************************************************************
 697: 0003: \*****************************************************************************
 698: 0003: \***
 699: 0003: \***        %INCLUDE FIELD DECLARATIONS AND FILE REFERENCE PARAMETERS
 700: 0003: \***
 701: 0003: \***                   FILE TYPE:  KEYED
 702: 0003: \***
 703: 0003: \***                   REFERENCE:  MINLSDEC.J86
 704: 0003: \***
 705: 0003: \***              DESCRIPTION:  MINSITS RP - SCREEN COUNT INFORMATION
 706: 0003: \***
 707: 0003: \***
 708: 0003: \***
 709: 0003: \***      VERSION 1 : Julia Stones             8th January 1998  
 710: 0003: \***      
 711: 0003: \*****************************************************************************
 712: 0003: \*****************************************************************************
 713: 0003: 
 714: 0003: STRING GLOBAL   \
 715: 0003:    MINLS.FILE.NAME$,  \
 716: 0003:    MINLS.ITEM.CODE$,     \  4 byte UPD;  Record key
 717: 0003:    MINLS.RECOUNT.DATE$,  \  3 byte UPD;  YYMMDD      
 718: 0003:    MINLS.DISCREPANCY$,    \  3 byte UPD        
 719: 0003:    MINLS.COUNT.STATUS$     ! 1 byte ASCII 
 720: 0003: 
 721: 0003: INTEGER*2 GLOBAL  \
 722: 0003:    MINLS.RECL%,   \
 723: 0003:    MINLS.REPORT.NUM%,  \
 724: 0003:    MINLS.SESS.NUM%   !
 725: 0003: 
 726: 0003: 
 727: 0003: 
 728: 0003:     %INCLUDE   SRITLDEC.J86    ! Active Planner Details        OAS
 729: 0003: \********************************************************************
 730: 0003: \***      EXTERNAL FUNCTION DECLARATIONS FOR THE SRITL FILE
 731: 0003: \***      REFERENCE : SRITLDEC.J86
 732: 0003: \***      Version A           Neil Bennett            5th June 2006
 733: 0003: \***
 734: 0003: \********************************************************************
 735: 0003: 
 736: 0003:   INTEGER*1 GLOBAL        \
 737: 0003:     SRITL.RECORD.CHAIN%,  \ Chain Sequence
 738: 0003:     SRITL.MODULE.COUNT%,  \ Family hierarchy key level
 739: 0003:     SRITL.MODULE.SEQ%(1), \ Module sequence
 740: 0003:     SRITL.REPEAT.CNT%(1)  ! Repeat count
 741: 0003: 
 742: 0003:   INTEGER*2 GLOBAL        \
 743: 0003:     SRITL.CORE.COUNT%,    \ Sum of repeat count for core items
 744: 0003:     SRITL.MAX.MOD.KEYS%,  \ Maximum number of modules
 745: 0003:     SRITL.NON.CORE.CNT%,  \ Sum of repeat count for non core items
 746: 0003:     SRITL.SESS.NUM%,      \
 747: 0003:     SRITL.REPORT.NUM%,    \
 748: 0003:     SRITL.RECL%           !
 749: 0003: 
 750: 0003:   INTEGER*4 GLOBAL        \
 751: 0003:     SRITL.POGDB%(1)       ! Unique POG Database key
 752: 0003: 
 753: 0003:   STRING GLOBAL           \
 754: 0003:     SRITL.FILE.NAME$,     \ File name
 755: 0003:     SRITL.COPY.NAME$,     \ File name
 756: 0003:     SRITL.ITEM.CODE$,     \ Boots Item Code
 757: 0003:     SRITL.CORE.FLAG$(1),  \ Core/Non Core flag Y/N
 758: 0003:     SRITL.FILLER$         !
 759: 0003: 
 760: 0003: 
 761: 0003: 
 762: 0003: \*****************************************************************************
 763: 0003: \***
 764: 0003: \***    Included code defining function related global variables
 765: 0003: \***
 766: 0003: \***..........................................................................
 767: 0003: 
 768: 0003:     %INCLUDE PSBF01G.J86   !   APPLICATION.LOG
 769: 0003: REM \
 770: 0003: \*******************************************************************************
 771: 0003: \*******************************************************************************
 772: 0003: \***
 773: 0003: \***       %INCLUDE FOR GLOBAL DEFINITIONS FOR FUNCTION APPLICATION.LOG
 774: 0003: \***
 775: 0003: \***                FUNCTION NUMBER    : PSBF01
 776: 0003: \***
 777: 0003: \***                REFERENCE          : PSBF01G.J86
 778: 0003: \***
 779: 0003: \***                DATE OF LAST AMENDMENT  - 27/2/86
 780: 0003: \***
 781: 0003: \***
 782: 0003: \*******************************************************************************
 783: 0003: 
 784: 0003:       INTEGER GLOBAL  F01.RETURN.CODE%
 785: 0003: 
 786: 0003: 
 787: 0003:     %INCLUDE PSBF02G.J86   !   Update Date
 788: 0003: REM\
 789: 0003: \*******************************************************************************
 790: 0003: \*******************************************************************************
 791: 0003: \***
 792: 0003: \***        INCLUDE       : UPDATE.DATE globals
 793: 0003: \***
 794: 0003: \***        REFERENCE     : PSBF02G.J86
 795: 0003: \***
 796: 0003: \***        Version A     Bruce Scriver      4th March 1986
 797: 0003: \*** 
 798: 0003: \***        Version B     Andrew Wedgeworth   6th July 1992
 799: 0003: \***        Removal of return code field which no longer required.
 800: 0003: \***
 801: 0003: \*******************************************************************************
 802: 0003: \*******************************************************************************
 803: 0003: 
 804: 0003:       STRING   GLOBAL F02.DATE$
 805: 0003: 
 806: 0003:       ! 1 line deleted from here                                       ! BAW
 807: 0003: 
 808: 0003:     %INCLUDE PSBF06G.J86   !   Barcode check digit calculation  FCS
 809: 0003: REM\
 810: 0003: \*******************************************************************************
 811: 0003: \*******************************************************************************
 812: 0003: \***
 813: 0003: \***        INCLUDE       : CALC.BAR.CODE.CHECK.DIGIT globals
 814: 0003: \***
 815: 0003: \***        REFERENCE     : PSBF06G.J86
 816: 0003: \***
 817: 0003: \***        Version A     Bruce Scriver                 24th February 1986 
 818: 0003: \***
 819: 0003: \***        Version B     Andrew Wedgeworth                 15th July 1992
 820: 0003: \***        Removal of return code field which no longer required.
 821: 0003: \***
 822: 0003: \*******************************************************************************
 823: 0003: \*******************************************************************************
 824: 0003: 
 825: 0003:       STRING   GLOBAL F06.CHECK.DIGIT$
 826: 0003: 
 827: 0003: 
 828: 0003:     %INCLUDE PSBF20G.J86   !   ALLOCATE.DEALLOCATE.SESS.NUM
 829: 0003: REM\
 830: 0003: \*******************************************************************************
 831: 0003: \*******************************************************************************
 832: 0003: \***
 833: 0003: \***     %INCLUDE GLOBAL VARIABLE DEFINITIONS FOR SESS.NUM.UTILITY FUNCTION
 834: 0003: \***
 835: 0003: \***                       REFERENCE     : PSBF20G.J86
 836: 0003: \*** 
 837: 0003: \***     Version A              Bruce Scrive                   5th May 1988   
 838: 0003: \*** 
 839: 0003: \***     Version B              Robert Cowey                   7th May 1991
 840: 0003: \***     Global variable F20.INTEGER.FILE.NO% changed from one byte integer
 841: 0003: \***     to two byte integer.
 842: 0003: \***
 843: 0003: \***     Version D              Andrew Wedgeworth             1st July 1992
 844: 0003: \***     F20.RETURN.CODE% removed as it is no longer required.
 845: 0003: \***
 846: 0003: \*******************************************************************************
 847: 0003: \*******************************************************************************
 848: 0003: 
 849: 0003:       STRING    GLOBAL F20.FILE.NAME$,                                 \
 850: 0003:                        F20.STRING.FILE.NO$,                            \
 851: 0003:                        F20.TABLE.DIMENSIONED.FLAG$,                    \
 852: 0003:                        SESS.NUM.TABLE$(1)
 853: 0003: 
 854: 0003:       INTEGER*2 GLOBAL F20.INTEGER.FILE.NO%
 855: 0003: 
 856: 0003:       ! 1 line deleted from here                                       ! DAW 
 857: 0003: 
 858: 0003:     %INCLUDE PSBF13G.J86   !   To find the day of the week      OAS
 859: 0003: REM\
 860: 0003: \*******************************************************************************
 861: 0003: \*******************************************************************************
 862: 0003: \***
 863: 0003: \***        INCLUDE       : PSDATE globals
 864: 0003: \***
 865: 0003: \***        REFERENCE     : PSBF13G.J86
 866: 0003: \***
 867: 0003: \***     VERSION A                                  Bruce Scriver  6th Mar 86             
 868: 0003: \***            
 869: 0003: \***     VERSION B                                  Janet Lawrence 17 Aug 90
 870: 0003: \***     Add global to be used to indicate whether or not the function should
 871: 0003: \***     log an event when an invalid date is passed to it.
 872: 0003: \***
 873: 0003: \***     VERSION C                               Andrew Wedgeworth 17 July 92
 874: 0003: \***     Return code removed as no longer required.
 875: 0003: \***
 876: 0003: \*******************************************************************************
 877: 0003: \*******************************************************************************
 878: 0003: 
 879: 0003:       STRING    GLOBAL F13.DAY$,			\
 880: 0003:                        F13.DISPLAY.MESSAGE$		! BJAL
 881: 0003: 
 882: 0003: 
 883: 0003: 
 884: 0003: \*****************************************************************************
 885: 0003: \***
 886: 0003: \***    Global variable definitions
 887: 0003: \***
 888: 0003: \***..........................................................................
 889: 0003: 
 890: 0003:     STRING GLOBAL                           \
 891: 0003:         BATCH.SCREEN.FLAG$,                 \
 892: 0003:         COMM.MODE.FLAG$,                    \ OAS Set to B-Background  C-Foreground mode
 893: 0003:         CURRENT.CODE$,                      \
 894: 0003:         FILE.OPERATION$,                    \
 895: 0003:         MODULE.NUMBER$,                     \
 896: 0003:         OPERATOR.NUMBER$,                   \ OAS
 897: 0003:         REPORTING.STATUS$                   ! OAS
 898: 0003: 
 899: 0003:     INTEGER*2 GLOBAL                        \
 900: 0003:         CURRENT.REPORT.NUM%,                \
 901: 0003:         CURRENT.SESS.NUM%,                  \ OAS
 902: 0003:         FILE.RETURN.CODE%,                  \
 903: 0003:         FUNCTION.RETURN.CODE%
 904: 0003: 
 905: 0003:     INTEGER*1 GLOBAL                        \ OAS
 906: 0003:         TRUE,                               \ OAS
 907: 0003:         FALSE                               ! OAS
 908: 0003: 
 909: 0003: \*****************************************************************************
 910: 0003: \***
 911: 0003: \***    Variable definitions
 912: 0003: \***
 913: 0003: \***..........................................................................
 914: 0003: 
 915: 0003:     STRING                                  \ OAS
 916: 0003:         ADXSERVE.DATA$,                     \ DCS  \ OAS \ Holds display message
 917: 0003:        \ADXSTART.NAME$,                     \ OAS        \ Variable not used
 918: 0003:        \ADXSTART.PARM$,                     \ OAS        \ Variable not used
 919: 0003:        \ADXSTART.MESS$,                     \ OAS        \ Variable not used
 920: 0003:         BSNS.CNTR$,                         \ OAS
 921: 0003:        \COMMAND.STRING$,                    \ OAS        \ Variable not used
 922: 0003:         CLILF.DDD$,                         \ OAS
 923: 0003:         CLILF.BKUP.STATUS$,                 \ OAS
 924: 0003:         CLOLF.DDD$,                         \ OAS
 925: 0003:         CLOLF.BKUP.STATUS$,                 \ OAS
 926: 0003:         CLOLF.PGNAME$,                      \ ICC  \ OAS
 927: 0003:        \COMM.MODE.FLAG$,                    \ DCS  \ OAS \ MOVED TO TOP
 928: 0003:        \CRLF$,                              \ OAS        \ Variable not used
 929: 0003:         CURRENT.CODE.LOGGED$,               \ OAS
 930: 0003:         CURR.RUN.DAY$,                      \ RTT
 931: 0003:         FUNCTION.FLAG$,                     \ OAS
 932: 0003:         GET.DAY$,                           \ OAS
 933: 0003:        \GET.DATE$,                          \ OAS \ PBT
 934: 0003:         MINLS.HK.STATUS$,                   \ OAS
 935: 0003:         MINOK.FILE.NAME$,                   \ OAS
 936: 0003:         MINOK.FILLER$,                      \ RTT
 937: 0003:         MINOK.RECORD$,                      \ OAS
 938: 0003:         MINOK.RUN.DATE$,                    \ RTT
 939: 0003:         MINOK.RUN.TIME$,                    \ RTT
 940: 0003:         MINOK.TIME.STAMP$,                  \ RTT
 941: 0003:         MODULE$,                            \ OAS
 942: 0003:         OLD.BULETT$,                        \ CNS  \ OAS
 943: 0003:         OLD.PGNAME$,                        \ ICC  \ OAS
 944: 0003:         PASSED.STRING$,                     \ OAS
 945: 0003:         PIPE.OPEN$,                         \ FCS  \ OAS
 946: 0003:         PROGRAM$,                           \ OAS
 947: 0003:         QUOTES$,                            \ RTT
 948: 0003:         RESPONSE$,                          \ OAS
 949: 0003:         RPRPT.RECORD$,                      \ CNS  \ OAS
 950: 0003:        \RPRPT.REP.DATA$,                    \ OAS        \ Variable not used
 951: 0003:         TIME.NOW$,                          \ PBT
 952: 0003:         UPDATE.DATE$,                       \ CNS  \ OAS
 953: 0003:         VAR.STRING.1$,                      \ OAS
 954: 0003:         VAR.STRING.2$,                      \ OAS
 955: 0003:         YESTERDAY$                          ! RTT
 956: 0003: 
 957: 0003:     INTEGER*1                               \ OAS
 958: 0003:         COUNTER%,                           \ OAS
 959: 0003:         DO.MAIN,                            \ CNS  \ OAS
 960: 0003:         EOF,                                \ CNS  \ OAS
 961: 0003:         ERROR.COUNT%,                       \ OAS
 962: 0003:         EVENT.NUMBER%,                      \ OAS
 963: 0003:       \ LIST.ITEMS,                         \ CNS  \ OAS ! MOVED TO BOTTOM
 964: 0003:         MINPRINT.ALREADY.RUN%,              \ RTT
 965: 0003:         MINOK.ERROR.CHK%                    ! OAS
 966: 0003: 
 967: 0003:     INTEGER*2                               \ OAS
 968: 0003:         ADX.FUNCTION%,                      \ DCS  \ OAS
 969: 0003:         ADX.INTEGER%,                       \ DCS  \ OAS
 970: 0003:       \ CURRENT.SESS.NUM%,                  \ CNS  \ OAS ! MOVED TO TOP
 971: 0003:         LOOPCNT%,                           \ OAS
 972: 0003:         LIST.ITEMS,                         \ OAS
 973: 0003:         MESSAGE.NUMBER%,                    \ OAS
 974: 0003:         MINOK.REPORT.NUM%,                  \ OAS
 975: 0003:         MINOK.SESS.NUM%,                    \ OAS
 976: 0003:         PASSED.INTEGER%,                    \ OAS
 977: 0003:         RC%                                 ! OAS
 978: 0003:         !EVENT.NO%,                         ! FCS  \ OAS  \ Variable not used
 979: 0003:         !MESSAGE.NO%                        ! FCS  \ OAS  \ Variable not used
 980: 0003: 
 981: 0003:     INTEGER*4                               \ OAS
 982: 0003:         ADX.RETURN.CODE%,                   \ DCS  \ OAS
 983: 0003:         ADXCOPY.CHK%,                       \ OAS
 984: 0003:         FILE.SIZE%,                         \ OAS
 985: 0003:         RECORD.COUNT%                       ! OAS
 986: 0003:        !RPRPT.REC.MAX%,                     ! OAS         \ Variable not used
 987: 0003:        !RPRPT.REC.NUM%,                     ! OAS         \ Variable not used
 988: 0003:        !THE.TIME%                           ! FCS  \ OAS  \ Variable not used
 989: 0003: 
 990: 0003: \*****************************************************************************
 991: 0003: \***
 992: 0003: \***    EXT included code defining file related external functions
 993: 0003: \***
 994: 0003: \***..........................................................................
 995: 0003: 
 996: 0003:        %INCLUDE RPRPTEXT.J86
 997: 0003: \*****************************************************************************
 998: 0003: \***                                                                         *
 999: 0003: \*** EXTERNAL FUNCTION DEFINITIONS FOR THE MINSITS RP REPORT FILE            *
1000: 0003: \***                                                                         *
1001: 0003: \***                     REFERENCE : RPRPTEXT.J86                            *
1002: 0003: \***                                                                         *
1003: 0003: \***          Version A     Nik Sen            24th February 1998                *
1004: 0003: \***                                                                         *
1005: 0003: \*****************************************************************************
1006: 0003: 
1007: 0003:        FUNCTION RPRPT.SET EXTERNAL                                      
1008: 0003:        END FUNCTION                                                   
1009: 0003: 
1010: 0003:        %INCLUDE PRINTEXT.J86
1011: 0003: 
1012: 0003: REM \
1013: 0003: \*******************************************************************************
1014: 0003: \*******************************************************************************
1015: 0003: \***
1016: 0003: \***    %INCLUDE FOR PRINT FILE EXTERNAL FUNCTIONS
1017: 0003: \***
1018: 0003: \***        REFERENCE   :   PRINTEX (J86)
1019: 0003: \***
1020: 0003: \***        FILE TYPE   :   Printer / Labeller
1021: 0003: \***
1022: 0003: \***    VERSION A.              ANDREW WEDGEWORTH                   09 JUL 1992.
1023: 0003: \***    Original version created from PRINTEXG.
1024: 0003: \***
1025: 0003: \***    VERSION B.              UNKNOWN.                            ?? ??? 1992.
1026: 0003: \***    Changes unknown.
1027: 0003: \***
1028: 0003: \***    VERSION C.              ROBERT COWEY.                       18 NOV 1992.
1029: 0003: \***    Defined function variables for use as return codes.
1030: 0003: \***
1031: 0003: \***    Version C               Andrew Wedgeworth                 24th May 1992
1032: 0003: \***    Condensed print function added.
1033: 0003: \***
1034: 0003: \***    Version D               Stuart WIlliam McConnachie       31st July 2000.
1035: 0003: \***    Added function for PCL printing to LaserJet.
1036: 0003: \***
1037: 0003: \***    Version E               Charles Skadorwa                   4th Apr 2008.
1038: 0003: \***    Added parameter to WRITE.CONDENSED.PRINT function to
1039: 0003: \***    enable Alliance Pharmacy Brother Laser printers to print
1040: 0003: \***    in condensed mode.
1041: 0003: \***
1042: 0003: \***    Version F           Charles Skadorwa                       2nd Mar 2016.
1043: 0003: \***    It was found that certain reports would not print when stores
1044: 0003: \***    were converted to LAN attached printing.
1045: 0003: \***
1046: 0003: \***    Added new function: WRITE.PRINT.PLUS.LF based on WRITE.PRINT.
1047: 0003: \***    This adds a Line-Feed characters to every print line.
1048: 0003: \***
1049: 0003: \*******************************************************************************
1050: 0003: \*******************************************************************************
1051: 0003: 
1052: 0003: 
1053: 0003:     FUNCTION PRINT.SET EXTERNAL
1054: 0003:         INTEGER*2 PRINT.SET
1055: 0003:     END FUNCTION
1056: 0003: 
1057: 0003: 
1058: 0003:     FUNCTION WRITE.PRINT EXTERNAL
1059: 0003:        INTEGER*2 WRITE.PRINT
1060: 0003:     END FUNCTION
1061: 0003: 
1062: 0003: 
1063: 0003:     FUNCTION WRITE.PRINT.PLUS.LF EXTERNAL                               !FCS
1064: 0003:        INTEGER*2 WRITE.PRINT.PLUS.LF                                    !FCS
1065: 0003:     END FUNCTION                                                        !FCS
1066: 0003: 
1067: 0003: 
1068: 0003:     FUNCTION WRITE.CONDENSED.PRINT (AP.STORE) EXTERNAL                 ! ECSk
1069: 0003:        INTEGER*2 WRITE.CONDENSED.PRINT
1070: 0003:     END FUNCTION
1071: 0003: 
1072: 0003: 
1073: 0003:     FUNCTION WRITE.PCL.PRINT EXTERNAL                                  ! DSWM
1074: 0003:        INTEGER*2 WRITE.PCL.PRINT                                       ! DSWM
1075: 0003:     END FUNCTION                                                       ! DSWM
1076: 0003: 
1077: 0003: 
1078: 0003:     FUNCTION WRITE.LABEL EXTERNAL
1079: 0003:         INTEGER*2 WRITE.LABEL
1080: 0003:     END FUNCTION
1081: 0003: 
1082: 0003:        %INCLUDE SOFTSEXT.J86                                   ! CNS
1083: 0003: \*******************************************************************************
1084: 0003: \***                                                                         ***
1085: 0003: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE SOFTWARE STATUS FILE         ***
1086: 0003: \***                                                                         ***
1087: 0003: \***                     REFERENCE : SOFTSEXT.J86                            ***
1088: 0003: \***                                                                         ***
1089: 0003: \***      Version A         Andrew Wedgeworth          1st July 1992         ***
1090: 0003: \***
1091: 0003: \***   Version B
1092: 0003: \***                                                                      ***
1093: 0003: \***      Version C         Steve Wright               3rd May 1996          ***
1094: 0003: \***      Synchronise with function source.                                  ***
1095: 0003: \*******************************************************************************
1096: 0003: 
1097: 0003:       FUNCTION SOFTS.SET EXTERNAL 
1098: 0003:       END FUNCTION
1099: 0003:       
1100: 0003:       FUNCTION READ.SOFTS EXTERNAL
1101: 0003:           INTEGER*2 I%, READ.SOFTS
1102: 0003:       END FUNCTION	                   
1103: 0003: 
1104: 0003:       FUNCTION WRITE.SOFTS EXTERNAL
1105: 0003:           INTEGER*2 I%, WRITE.SOFTS
1106: 0003:       END FUNCTION
1107: 0003: 
1108: 0003: 
1109: 0003:        %INCLUDE RFSCFEXT.J86                                   ! CNS
1110: 0003: \******************************************************************************
1111: 0003: \******************************************************************************
1112: 0003: \***
1113: 0003: \***   $Workfile:   RFSCFEXT.J86  $
1114: 0003: \***
1115: 0003: \***   $Revision:   1.3  $
1116: 0003: \***
1117: 0003: \******************************************************************************
1118: 0003: \******************************************************************************
1119: 0003: \***
1120: 0003: \***
1121: 0003: \******************************************************************************
1122: 0003: \******************************************************************************
1123: 0003: \***
1124: 0003: \***                  FUNCTION DEFINITIONS FOR RFSCF
1125: 0003: \***
1126: 0003: \***                      REFERENCE    : RFSCFEXT
1127: 0003: \***
1128: 0003: \***           VERSION A : NIK SEN  5th October 1998
1129: 0003: \***
1130: 0003: \***
1131: 0003: \***   VERSION B             Mark Good
1132: 0003: \***   Added WRITE.RFSCF1
1133: 0003: \***
1134: 0003: \***   VERSION C             Jamie Thorpe
1135: 0003: \***   Added Read and Write dunctions for RFSCF record 3
1136: 0003: \***
1137: 0003: \***   VERSION D             Tittoo Thomas                         01 MAY 2013
1138: 0003: \***   Fixed READ and WRITE for RFSCF record 1 to have a return type set.
1139: 0003: \***
1140: 0003: \*****************************************************************************
1141: 0003: \*****************************************************************************
1142: 0003: 
1143: 0003:    FUNCTION RFSCF.SET EXTERNAL
1144: 0003:    END FUNCTION
1145: 0003: 
1146: 0003:    FUNCTION READ.RFSCF1 EXTERNAL
1147: 0003:       INTEGER*2 READ.RFSCF1            ! DTT
1148: 0003:    END FUNCTION
1149: 0003: 
1150: 0003:    FUNCTION WRITE.RFSCF1 EXTERNAL      ! BMG
1151: 0003:       INTEGER*2 WRITE.RFSCF1           ! DTT
1152: 0003:    END FUNCTION                        ! BMG
1153: 0003: 
1154: 0003:    FUNCTION READ.RFSCF3 EXTERNAL       ! CJT
1155: 0003:       INTEGER*2 READ.RFSCF3            ! CJT
1156: 0003:    END FUNCTION                        ! CJT
1157: 0003: 
1158: 0003:    FUNCTION WRITE.RFSCF3 EXTERNAL      ! CJT
1159: 0003:       INTEGER*2 WRITE.RFSCF3           ! CJT
1160: 0003:    END FUNCTION                        ! CJT
1161: 0003: 
1162: 0003:        %INCLUDE CLILFEXT.J86                                   ! CNS
1163: 0003:    
1164: 0003: \******************************************************************************
1165: 0003: \******************************************************************************\*****************************************************************************
1166: 0003: \***
1167: 0003: \***           FUNCTION DEFINITIONS FOR THE RF COUNT LISTS FILE
1168: 0003: \***
1169: 0003: \***           REFERENCE:   CLILFEXT.J86
1170: 0003: \***
1171: 0003: \***           VERSION A         Nik Sen         13th October 1998
1172: 0003: \***
1173: 0003: \***    REVISION 1.4.            ROBERT COWEY.                  09 SEP 2003.
1174: 0003: \***    Changes for RF trial.
1175: 0003: \***    Removed redundant PVCS revision control block from top of code.
1176: 0003: \***    Recompiled to prevent future automatic recompiles.
1177: 0003: \***    No changes to actual code.
1178: 0003: \***
1179: 0003: \*******************************************************************************
1180: 0003: \*******************************************************************************
1181: 0003: 
1182: 0003:    
1183: 0003:    FUNCTION CLILF.SET EXTERNAL
1184: 0003:    END FUNCTION
1185: 0003:    
1186: 0003:    FUNCTION READ.CLILF EXTERNAL
1187: 0003:       INTEGER*2 READ.CLILF
1188: 0003:    END FUNCTION
1189: 0003:    
1190: 0003:    FUNCTION WRITE.CLILF EXTERNAL
1191: 0003:       INTEGER*2 WRITE.CLILF
1192: 0003:    END FUNCTION
1193: 0003:  
1194: 0003:        %INCLUDE CLOLFEXT.J86                                   ! CNS
1195: 0003: 
1196: 0003: \******************************************************************************
1197: 0003: \******************************************************************************\*****************************************************************************
1198: 0003: \***
1199: 0003: \***           FUNCTION DEFINITIONS FOR THE RF COUNT LIST OF LISTS FILE
1200: 0003: \***
1201: 0003: \***           REFERENCE:   CLOLFEXT.J86
1202: 0003: \***
1203: 0003: \***           VERSION A         Nik Sen         13th October 1998
1204: 0003: \***
1205: 0003: \***    REVISION 1.4.            ROBERT COWEY.                  09 SEP 2003.
1206: 0003: \***    Changes for RF trial.
1207: 0003: \***    Removed redundant PVCS revision control block from top of code.
1208: 0003: \***    Recompiled to prevent future automatic recompiles.
1209: 0003: \***    No changes to actual code.
1210: 0003: \***
1211: 0003: \*******************************************************************************
1212: 0003: \*******************************************************************************
1213: 0003: 
1214: 0003:    FUNCTION CLOLF.SET EXTERNAL
1215: 0003:    END FUNCTION
1216: 0003:    
1217: 0003:    FUNCTION READ.CLOLF EXTERNAL
1218: 0003:       INTEGER*2 READ.CLOLF
1219: 0003:    END FUNCTION
1220: 0003:    
1221: 0003:    FUNCTION WRITE.CLOLF EXTERNAL
1222: 0003:       INTEGER*2 WRITE.CLOLF
1223: 0003:    END FUNCTION
1224: 0003:  
1225: 0003:        !%INCLUDE ISFEXT.J86                                    ! CNS !OAS
1226: 0003:        !%INCLUDE IRFEXT.J86                                    ! CNS !OAS
1227: 0003:        %INCLUDE IDFEXT.J86                                     ! CNS
1228: 0003: \*******************************************************************************
1229: 0003: \***                                                                         ***
1230: 0003: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE ITEM DESCRIPTION FILE        ***
1231: 0003: \***                                                                         ***
1232: 0003: \***                       REFERENCE : IDFEXT.J86                            ***
1233: 0003: \***                                                                         ***
1234: 0003: \***      Version A           Andrew Wedgeworth         9th July 1992        ***
1235: 0003: \***
1236: 0003: \***    VERSION C.              Robert Cowey.                       25 AUG 1993.
1237: 0003: \***    No changes to this file.
1238: 0003: \***
1239: 0003: \***   VERSION D               Nik Sen                 22nd December 1994
1240: 0003: \***   WRITE.IDF.HOLD added
1241: 0003: \***
1242: 0003: \*******************************************************************************
1243: 0003: 
1244: 0003:        FUNCTION IDF.SET EXTERNAL                                      
1245: 0003:        END FUNCTION                                                   
1246: 0003: 
1247: 0003: 
1248: 0003:        FUNCTION READ.IDF EXTERNAL                                     
1249: 0003:           INTEGER*2 READ.IDF                                          
1250: 0003:        END FUNCTION                                                   
1251: 0003: 
1252: 0003: 
1253: 0003:        FUNCTION READ.IDF.LOCK EXTERNAL                                
1254: 0003:           INTEGER*2 READ.IDF.LOCK                                     
1255: 0003:        END FUNCTION                                                   
1256: 0003: 
1257: 0003:        FUNCTION WRITE.IDF EXTERNAL
1258: 0003:           INTEGER*2 WRITE.IDF
1259: 0003:        END FUNCTION	       
1260: 0003: 
1261: 0003:        FUNCTION WRITE.IDF.HOLD EXTERNAL
1262: 0003:           INTEGER*2 WRITE.IDF.HOLD
1263: 0003:        END FUNCTION
1264: 0003: 
1265: 0003:        FUNCTION WRITE.IDF.UNLOCK EXTERNAL                                  
1266: 0003:           INTEGER*2 WRITE.IDF.UNLOCK                                      
1267: 0003:        END FUNCTION                                                   
1268: 0003:        %INCLUDE PGFEXT.J86                                     ! KMG
1269: 0003: 
1270: 0003: \REM
1271: 0003: \*******************************************************************************
1272: 0003: \*******************************************************************************
1273: 0003: \***
1274: 0003: \***    %INCLUDE FOR PRODUCT GROUP FILES EXTERNAL FUNCTIONS
1275: 0003: \***
1276: 0003: \***        REFERENCE   :   PGFDEC (J86)
1277: 0003: \***
1278: 0003: \***        FILE TYPE   :   Direct (PGF and PGFD)
1279: 0003: \***                        Keyed (PGFO)
1280: 0003: \***
1281: 0003: \***    VERSION B.              ROBERT COWEY.                       30 SEP 1993.
1282: 0003: \***    Created from PGFFUNB.
1283: 0003: \***
1284: 0003: \***    REVISION 1.2.           ROBERT COWEY.                       27 OCT 2003.
1285: 0003: \***    Defined WRITE.PGF function.
1286: 0003: \***
1287: 0003: \*******************************************************************************
1288: 0003: \*******************************************************************************
1289: 0003: 
1290: 0003: 
1291: 0003: FUNCTION PGF.SET EXTERNAL
1292: 0003:     INTEGER*2 PGF.SET
1293: 0003: END FUNCTION
1294: 0003: 
1295: 0003: FUNCTION READ.PGF EXTERNAL
1296: 0003:     INTEGER*2 READ.PGF
1297: 0003: END FUNCTION
1298: 0003: 
1299: 0003: FUNCTION WRITE.PGF EXTERNAL                                                ! 1.2 RC
1300: 0003:     INTEGER*2 WRITE.PGF                                                    ! 1.2 RC
1301: 0003: END FUNCTION                                                               ! 1.2 RC
1302: 0003: 
1303: 0003: FUNCTION READ.PGFDIR EXTERNAL
1304: 0003:     INTEGER*2 READ.PGFDIR
1305: 0003: END FUNCTION
1306: 0003: 
1307: 0003: FUNCTION WRITE.PGFDIR EXTERNAL
1308: 0003:     INTEGER*2 WRITE.PGFDIR
1309: 0003: END FUNCTION
1310: 0003: 
1311: 0003: FUNCTION READ.PGFO EXTERNAL
1312: 0003:     INTEGER*2 READ.PGFO
1313: 0003: END FUNCTION
1314: 0003: 
1315: 0003: FUNCTION WRITE.PGFO EXTERNAL
1316: 0003:     INTEGER*2 WRITE.PGFO
1317: 0003: END FUNCTION
1318: 0003: 
1319: 0003:        %INCLUDE MINLSEXT.J86   ! Minsits Recount Information   ! LJT
1320: 0003: 
1321: 0003: \*****************************************************************************
1322: 0003: \*****************************************************************************
1323: 0003: \***
1324: 0003: \***        %INCLUDE FOR FILE HANDLING FUNCTIONS EXTERNAL DEFINITIONS
1325: 0003: \***
1326: 0003: \***                   FILE TYPE:  KEYED
1327: 0003: \***
1328: 0003: \***                   REFERENCE:  MINLSEXT.J86
1329: 0003: \***
1330: 0003: \***	             DESCRIPTION:  MINSITS RP - SCREEN COUNT INFORMATION
1331: 0003: \***
1332: 0003: \***
1333: 0003: \***
1334: 0003: \***      VERSION 1 : Julia Stones             8th January 1998   
1335: 0003: \***      
1336: 0003: \*****************************************************************************
1337: 0003: \*****************************************************************************
1338: 0003: 
1339: 0003: 
1340: 0003:   FUNCTION MINLS.SET EXTERNAL
1341: 0003:      INTEGER*2 MINLS.SET
1342: 0003:   END FUNCTION
1343: 0003: 
1344: 0003: 
1345: 0003:   FUNCTION READ.MINLS EXTERNAL
1346: 0003:     INTEGER*2 READ.MINLS
1347: 0003:   END FUNCTION
1348: 0003:   
1349: 0003: 
1350: 0003:   FUNCTION READ.MINLS.LOCKED EXTERNAL
1351: 0003:     INTEGER*2 READ.MINLS.LOCKED
1352: 0003:   END FUNCTION  
1353: 0003: 
1354: 0003: 
1355: 0003:   FUNCTION WRITE.HOLD.MINLS EXTERNAL
1356: 0003:     INTEGER*2 WRITE.HOLD.MINLS
1357: 0003:   END FUNCTION
1358: 0003: 
1359: 0003: 
1360: 0003:   FUNCTION WRITE.UNLOCK.MINLS EXTERNAL
1361: 0003:     INTEGER*2 WRITE.UNLOCK.MINLS
1362: 0003:   END FUNCTION
1363: 0003: 
1364: 0003: 
1365: 0003:   FUNCTION WRITE.HOLD.UNLOCK.MINLS EXTERNAL
1366: 0003:     INTEGER*2 WRITE.HOLD.UNLOCK.MINLS
1367: 0003:   END FUNCTION
1368: 0003:   
1369: 0003: 
1370: 0003:   FUNCTION WRITE.MINLS EXTERNAL
1371: 0003:     INTEGER*2 WRITE.MINLS
1372: 0003:   END FUNCTION
1373: 0003: 
1374: 0003:        %INCLUDE PSBF13E.J86    ! To initialise day variable    ! OAS
1375: 0003: REM\
1376: 0003: \*******************************************************************************
1377: 0003: \*******************************************************************************
1378: 0003: \***
1379: 0003: \***        INCLUDE       : PSDATE external definition
1380: 0003: \***
1381: 0003: \***        REFERENCE     : PSBF13E.J86
1382: 0003: \***
1383: 0003: \***        Version A     Bruce Scriver                6th March 1986
1384: 0003: \*** 
1385: 0003: \***        Version B     Andrew Wedgeworth            17th July 1992  
1386: 0003: \***        Redundant parameters removed and PSDATE defined as a variable
1387: 0003: \***        to hold the return code. 
1388: 0003: \***
1389: 0003: \*******************************************************************************
1390: 0003: \*******************************************************************************
1391: 0003: 
1392: 0003:    FUNCTION PSDATE (INPUT.DATE$)                                               \
1393: 0003:    EXTERNAL
1394: 0003: 
1395: 0003:      STRING    INPUT.DATE$                                                   
1396: 0003:    
1397: 0003:      INTEGER*2 PSDATE 
1398: 0003: 
1399: 0003:    END FUNCTION
1400: 0003: 
1401: 0003:        %INCLUDE ADXCOPY.J86    ! To copy files                 ! OAS
1402: 0003: \******************************************************************************
1403: 0003: \******************************************************************************
1404: 0003: \***                                                                        ***
1405: 0003: \***    %INCLUDE FOR SUBROUTINE ADXCOPYF (an I.B.M. system subroutine)      ***
1406: 0003: \***                                                                        ***
1407: 0003: \***         DATE WRITTEN  :  13th May 1988                                 ***
1408: 0003: \***                                                                        ***
1409: 0003: \******************************************************************************
1410: 0003: \******************************************************************************
1411: 0003: 
1412: 0003:    SUB  ADXCOPYF (RETC, INFILE, OUTFILE, OPT0, OPT1, OPT2) EXTERNAL
1413: 0003: 
1414: 0003:       INTEGER*4   RETC
1415: 0003:       STRING      INFILE, OUTFILE
1416: 0003:       INTEGER*2   OPT0, OPT1, OPT2
1417: 0003: 
1418: 0003:    END  SUB
1419: 0003: 
1420: 0003:        %INCLUDE SRITLEXT.J86   ! Active Planner Details        ! OAS
1421: 0003: \********************************************************************
1422: 0003: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE SRITL FILE
1423: 0003: \***      REFERENCE : SRITLEXT.J86
1424: 0003: \***      Version A           Neil Bennett            7th July 2006
1425: 0003: \***
1426: 0003: \********************************************************************
1427: 0003: 
1428: 0003:        FUNCTION SRITL.SET EXTERNAL
1429: 0003:        END FUNCTION
1430: 0003: 
1431: 0003:        FUNCTION READ.SRITL EXTERNAL
1432: 0003:           INTEGER*2 READ.SRITL
1433: 0003:        END FUNCTION
1434: 0003: 
1435: 0003:        FUNCTION WRITE.SRITL EXTERNAL
1436: 0003:           INTEGER*2 WRITE.SRITL
1437: 0003:        END FUNCTION
1438: 0003: 
1439: 0003:         SUB MINRFCNT EXTERNAL                                   ! OAS
1440: 0003:         END SUB
1441: 0003: 
1442: 0003: \*****************************************************************************
1443: 0003: \***
1444: 0003: \***    Included code defining external Boots functions
1445: 0003: \***
1446: 0003: \***..........................................................................
1447: 0003: 
1448: 0003:     %INCLUDE PSBF01E.J86   !   APPLICATION.LOG
1449: 0003: REM \
1450: 0003: \*******************************************************************************
1451: 0003: \*******************************************************************************
1452: 0003: \***
1453: 0003: \***      %INCLUDE FOR EXTERNAL DEFINITION OF FUNCTION APPLICATION.LOG
1454: 0003: \***
1455: 0003: \***                      FUNCTION NUMBER   : PSBF01
1456: 0003: \***
1457: 0003: \***                    INCLUDE REFERENCE : PSBF01E.J86
1458: 0003: \*** 
1459: 0003: \***      Version B           Andrew Wedgeworth          1st July 1992
1460: 0003: \***      Three parameters which passed to the function have been removed.
1461: 0003: \***      APPLICATION.LOG has been added as a variable name (this holds the
1462: 0003: \***      return code).
1463: 0003: \***
1464: 0003: \*******************************************************************************
1465: 0003: 
1466: 0003: 
1467: 0003:    FUNCTION APPLICATION.LOG (MESSAGE.NO%,                                     \
1468: 0003:                              VAR.STRING.1$,                                   \
1469: 0003:                              VAR.STRING.2$,                                   \
1470: 0003:                              EVENT.NO%)  EXTERNAL
1471: 0003: 
1472: 0003:       INTEGER*1 EVENT.NO%
1473: 0003: 
1474: 0003:       INTEGER*2 APPLICATION.LOG,                                       \ GAW
1475: 0003:                 MESSAGE.NO%
1476: 0003: 
1477: 0003:       STRING VAR.STRING.1$,                                            \
1478: 0003:              VAR.STRING.2$
1479: 0003: 
1480: 0003:    END FUNCTION
1481: 0003: 
1482: 0003: \*******************************************************************************
1483: 0003:     %INCLUDE PSBF02E.J86   !   Update Date
1484: 0003: REM\
1485: 0003: \*******************************************************************************
1486: 0003: \*******************************************************************************
1487: 0003: \***
1488: 0003: \***        INCLUDE       : UPDATE.DATE external definition
1489: 0003: \***        AUTHOR        : Bruce Scriver (Basic Code)
1490: 0003: \***        DATE WRITTEN  : 4th March 1986 (Basic Code)
1491: 0003: \***
1492: 0003: \***        REFERENCE     : PSBF02E.J86
1493: 0003: \***
1494: 0003: \***        Version A     Bruce Scriver          4th March 1986
1495: 0003: \***
1496: 0003: \***        Version B     Andrew Wedgeworth       6th July 1992
1497: 0003: \***        Removal of redundant parameters, and inclusion of UPDATE.DATE as
1498: 0003: \***        a variable to hold the return code.
1499: 0003: \***
1500: 0003: \*******************************************************************************
1501: 0003: \*******************************************************************************
1502: 0003: 
1503: 0003:    FUNCTION UPDATE.DATE (INCREMENT%)                                   \
1504: 0003:    EXTERNAL
1505: 0003:    ! 3 parameters removed from here                                    ! BAW
1506: 0003: 
1507: 0003:    ! 3 lines deleted from here                                         ! BAW
1508: 0003:    
1509: 0003:       INTEGER*2 UPDATE.DATE                                            ! BAW
1510: 0003: 
1511: 0003:       INTEGER*4 INCREMENT%
1512: 0003: 
1513: 0003:    END FUNCTION
1514: 0003: 
1515: 0003:     %INCLUDE PSBF06E.J86   !   Barcode Check Digit Calculation   ! FCS ! OAS
1516: 0003: rem\
1517: 0003: \*******************************************************************************
1518: 0003: \*******************************************************************************
1519: 0003: \***
1520: 0003: \***
1521: 0003: \***         INCLUDE       : CALC.BAR.CODE.CHECK.DIGIT external definition
1522: 0003: \***
1523: 0003: \***         REFERENCE     : PSBF06E.J86
1524: 0003: \***
1525: 0003: \***         Version A     Bruce Scriver                  24th February 1986
1526: 0003: \***
1527: 0003: \***         Version B     Andrew Wedgeworth                  15th July 1992
1528: 0003: \***         Removal of redundant parameters, and inclusion of 
1529: 0003: \***         CALC.BAR.CODE.CHECK.DIGIT as a variable to hold the return code.
1530: 0003: \***
1531: 0003: \*******************************************************************************
1532: 0003: \*******************************************************************************
1533: 0003: 
1534: 0003:    FUNCTION CALC.BAR.CODE.CHECK.DIGIT (BAR.CODE.12$)                           \
1535: 0003:    EXTERNAL
1536: 0003:    ! 3 parameters removed from here                                    ! BAW
1537: 0003: 
1538: 0003:       STRING    BAR.CODE.12$
1539: 0003:    ! 3 variables removed from here                                     ! BAW
1540: 0003:    
1541: 0003:       INTEGER*2 CALC.BAR.CODE.CHECK.DIGIT                              ! BAW
1542: 0003:       
1543: 0003: 
1544: 0003:    END FUNCTION
1545: 0003: 
1546: 0003:     %INCLUDE PSBF08E.J86   !   Print Report Function
1547: 0003: rem\
1548: 0003: \*******************************************************************************
1549: 0003: \*******************************************************************************
1550: 0003: \***
1551: 0003: \***         INCLUDE       : PRINT.REPORT external definition
1552: 0003: \***
1553: 0003: \***         REFERENCE     : PSBF08E.J86
1554: 0003: \***
1555: 0003: \***         Version A     Bruce Scriver     27th February 1986
1556: 0003: \*** 
1557: 0003: \***         Version B     Andrew Wedgeworth      7th July 1992
1558: 0003: \***         Remove redundant parameters, and add PRINT.REPORT as a variable
1559: 0003: \***         to hold the return code.
1560: 0003: \*** 
1561: 0003: \***         Version C     Andrew Wedgeworth      24th May 1993
1562: 0003: \***         Extra parameter added to enable the printing of a condensed
1563: 0003: \***         report.
1564: 0003: \***
1565: 0003: \*******************************************************************************
1566: 0003: \*******************************************************************************
1567: 0003: 
1568: 0003:    FUNCTION PRINT.REPORT (SESSION.NUMBER%,CONDENSED.PRINT.FLAG$)       \ CAW
1569: 0003:    EXTERNAL
1570: 0003: 
1571: 0003:    STRING    CONDENSED.PRINT.FLAG$                                     ! CAW
1572: 0003:  
1573: 0003:    INTEGER   PRINT.REPORT,                                             \ BAW
1574: 0003:              SESSION.NUMBER%
1575: 0003: 
1576: 0003:    END FUNCTION
1577: 0003:     %INCLUDE PSBF20E.J86   !   ALLOCATE.DEALLOCATE.SESS.NUM
1578: 0003: REM\
1579: 0003: \*******************************************************************************
1580: 0003: \*******************************************************************************
1581: 0003: \***
1582: 0003: \***       %INCLUDE FOR EXTERNAL DEFINITION OF SESS.NUM.UTILITY
1583: 0003: \***
1584: 0003: \***                  REFERENCE     : PSBF20E.J86
1585: 0003: \***
1586: 0003: \***     VERSION C            Janet Smith                13th May 1992
1587: 0003: \***     Increased PASSED.INTEGER to 2 bytes to cater for more than
1588: 0003: \***     128 files.
1589: 0003: \***
1590: 0003: \***     VERSION D.           Andrew Wedgeworth          1st July 1992
1591: 0003: \***     Removal of redundant parameters and addition of SESS.NUM.UTILITY
1592: 0003: \***     as a variable.  This new variable contains the function's return
1593: 0003: \***     code.
1594: 0003: \***
1595: 0003: \*******************************************************************************
1596: 0003: \*******************************************************************************
1597: 0003: 
1598: 0003:    FUNCTION SESS.NUM.UTILITY (FUNCTION.FLAG$,                          \
1599: 0003:                               PASSED.INTEGER%,                         \
1600: 0003:                               PASSED.STRING$)                          \
1601: 0003:    EXTERNAL
1602: 0003: 
1603: 0003:    STRING    FUNCTION.FLAG$,                                           \
1604: 0003:              PASSED.STRING$
1605: 0003:    ! 3 variables removed from here                                     ! CAW
1606: 0003: 
1607: 0003: 
1608: 0003:    INTEGER*2 SESS.NUM.UTILITY,                                         \ CAW
1609: 0003:              PASSED.INTEGER%				               ! CJAS
1610: 0003: 
1611: 0003:    END FUNCTION
1612: 0003: 
1613: 0003:     %INCLUDE PSBF24E.J86   !   STANDARD.ERROR.DETECTED
1614: 0003: REM \
1615: 0003: \*******************************************************************************
1616: 0003: \*******************************************************************************
1617: 0003: \***
1618: 0003: \***    %INCLUDE FOR EXTERNAL DEFINITION OF STANDARD.ERROR.DETECTED FUNCTION
1619: 0003: \***
1620: 0003: \***                      REFERENCE     : PSBF24E.J86
1621: 0003: \***
1622: 0003: \***    Version A                 Janet Smith                  13th May 1992
1623: 0003: \***
1624: 0003: \*******************************************************************************
1625: 0003: \*******************************************************************************
1626: 0003: 
1627: 0003:    FUNCTION STANDARD.ERROR.DETECTED(ERRN%,                 \
1628: 0003: 				    ERRFILE%,              \
1629: 0003: 				    ERRL%,                 \
1630: 0003: 				    ERR$)        EXTERNAL
1631: 0003: 				    
1632: 0003:           STRING    ERR$
1633: 0003: 
1634: 0003:           INTEGER*2 ERRFILE%,              \
1635: 0003: 	            ERRL%,                 \
1636: 0003: 		    STANDARD.ERROR.DETECTED
1637: 0003: 		    
1638: 0003:           INTEGER*4 ERRN%
1639: 0003: 	  		    
1640: 0003:    END FUNCTION
1641: 0003: 
1642: 0003: 
1643: 0003:     %INCLUDE PSBF30E.J86   !   Process Keyed Record              ! LJT
1644: 0003: \*****************************************************************************
1645: 0003: \*****************************************************************************
1646: 0003: \***
1647: 0003: \***                 EXTERNAL FUNCTION DEFINITION PSBF30
1648: 0003: \***
1649: 0003: \*****************************************************************************
1650: 0003: \*****************************************************************************
1651: 0003: 
1652: 0003: \*****************************************************************************
1653: 0003: \*****************************************************************************
1654: 0003: \***
1655: 0003: \***   Version 96A              Mark Walker                31st May 1995
1656: 0003: \***   Original version.
1657: 0003: \***
1658: 0003: \***   Version B                Andrew Wedgeworth          17th March 1997
1659: 0003: \***   Added READONLY$ variable.  This parameter may be used to specify 
1660: 0003: \***   whether the file is to be opened with the READONLY option.
1661: 0003: \***
1662: 0003: \*****************************************************************************
1663: 0003: \*****************************************************************************
1664: 0003:  
1665: 0003:        FUNCTION PROCESS.KEYED.FILE(FILE.NAME$,                         \ 
1666: 0003:                                    REPORT.NUM%,                        \  
1667: 0003:                                    READONLY$) EXTERNAL
1668: 0003: 
1669: 0003:        STRING FILE.NAME$,READONLY$
1670: 0003:        INTEGER*2 PROCESS.KEYED.FILE,REPORT.NUM%
1671: 0003: 
1672: 0003:        END FUNCTION
1673: 0003: 
1674: 0003:     %INCLUDE ADXSERVE.J86  !   Message Logging                   ! DCS ! OAS
1675: 0003: \******************************************************************************
1676: 0003: \******************************************************************************
1677: 0003: \***                                                                        ***
1678: 0003: \***    %INCLUDE FOR FUNCTION ADXSERVE (an I.B.M. system function)          ***
1679: 0003: \***                                                                        ***
1680: 0003: \***         AUTHOR        :  Bruce Scriver                                 ***
1681: 0003: \***                                                                        ***
1682: 0003: \***         DATE WRITTEN  :  14th March 1986                               ***
1683: 0003: \***                                                                        ***
1684: 0003: \***         DATE OF LAST REVISION  - 14th March 1986                       ***
1685: 0003: \***                                                                        ***
1686: 0003: \***                                                                        ***
1687: 0003: \******************************************************************************
1688: 0003: \******************************************************************************
1689: 0003: 
1690: 0003:    SUB ADXSERVE (RETURN.CODE%,                                                \
1691: 0003:                  ADX.FUNCTION%,                                               \
1692: 0003:                  ADX.PARM.1%,                                                 \
1693: 0003:                  ADX.PARM.2$)                                                 \
1694: 0003:    EXTERNAL
1695: 0003:   
1696: 0003:       STRING     ADX.PARM.2$
1697: 0003: 
1698: 0003:       INTEGER*2  ADX.FUNCTION%,                                               \
1699: 0003:                  ADX.PARM.1%
1700: 0003: 
1701: 0003:       INTEGER*4  RETURN.CODE%                                                 \
1702: 0003: 
1703: 0003:    END SUB     
1704: 0003: 
1705: 0003:     %INCLUDE ADXSTART.J86  !   Chain to new program              ! FCS ! OAS
1706: 0003: \******************************************************************************
1707: 0003: \******************************************************************************
1708: 0003: \***                                                                        ***
1709: 0003: \***    %INCLUDE FOR FUNCTION ADXSTART (an I.B.M. system function)          ***
1710: 0003: \***                                                                        ***
1711: 0003: \***         AUTHOR        :  Barbara Holbrook                              ***
1712: 0003: \***                                                                        ***
1713: 0003: \***         DATE WRITTEN  :  26th June 1987                                ***
1714: 0003: \***                                                                        ***
1715: 0003: \***         DATE OF LAST REVISION  - 19th November 1987                    ***
1716: 0003: \***                                                                        ***
1717: 0003: \***                                                                        ***
1718: 0003: \******************************************************************************
1719: 0003: \******************************************************************************
1720: 0003: 
1721: 0003:    FUNCTION ADXSTART (ADX.NAME$,                                       \
1722: 0003:                       ADX.PARM$,                                       \
1723: 0003:                       ADX.MESS$)                                       \
1724: 0003:    EXTERNAL
1725: 0003: 
1726: 0003:       STRING     ADX.NAME$,                                            \
1727: 0003:                  ADX.PARM$,                                            \
1728: 0003:                  ADX.MESS$
1729: 0003: 
1730: 0003:       INTEGER*2  ADXSTART
1731: 0003: 
1732: 0003:    END FUNCTION
1733: 0003: 
1734: 0003:     %INCLUDE CMPDATE.J86   !   Date compare for Y2K compliance   ! IMG ! OAS
1735: 0003: !********************************************************************
1736: 0003: !***
1737: 0003: !***    INCLUDED CODE:  CMPDATE.J86
1738: 0003: !***    AUTHOR:         Stuart William McConnachie
1739: 0003: !***    DATE:           27th January 1997
1740: 0003: !***
1741: 0003: !********************************************************************
1742: 0003: !***   
1743: 0003: !***    Version B            Nik Sen                 30th March 1998
1744: 0003: !***    Changes to cope with a date of '000000' by replacing it with
1745: 0003: !***    '850101' before comparison. An all zero's date is valid in 
1746: 0003: !***    certain date fields and CMPDATE was returning the wrong result
1747: 0003: !***    when comparing with an actual date. Also change to cope with
1748: 0003: !***    dates of '999999' as some date fields are initialised to this
1749: 0003: !***    as a high value.
1750: 0003: !***
1751: 0003: !***    Version C    Stuart William McConnachie   20th December 1999
1752: 0003: !***    Improved function efficiency by changing tests for high and
1753: 0003: !***    low values, added above, to integers (rather than strings).
1754: 0003: !***    Also, using 850101 as a replacement for 000000, will not give
1755: 0003: !***    valid results after 350101 because of the 50 year wrap, so
1756: 0003: !***    corrected this.
1757: 0003: !***
1758: 0003: !***    Version D.  Stuart William McConnachie    26th February 2006
1759: 0003: !***    Place this code in it's own module in FUNLIB.  Make all
1760: 0003: !***    the functions herein EXTERNAL accordingly.
1761: 0003: !***
1762: 0003: !********************************************************************
1763: 0003: !***    
1764: 0003: !***    The following functions compare dates, checking for
1765: 0003: !***    century boundries.  Dates in the 50 years prior to the
1766: 0003: !***    compared date are less than the compared date, dates in
1767: 0003: !***    50 years after the compared date are greater than the
1768: 0003: !***    compared date.
1769: 0003: !***    Can handle dates in both packed and unpacked formats, or
1770: 0003: !***    a mixture of both.
1771: 0003: !***    In the case of a error, for example IH after detecting
1772: 0003: !***    illegal characters in VAL, the functions default to
1773: 0003: !***    comparing strings without testing for a change of century.
1774: 0003: !***
1775: 0003: !***    DATE.GT(DATE1$, DATE2$)  same as  DATE1$ >  DATE2$
1776: 0003: !***    DATE.GE(DATE1$, DATE2$)  same as  DATE1$ >= DATE2$
1777: 0003: !***    DATE.LT(DATE1$, DATE2$)  same as  DATE1$ <  DATE2$
1778: 0003: !***    DATE.LE(DATE1$, DATE2$)  same as  DATE1$ <= DATE2$
1779: 0003: !***
1780: 0003: !********************************************************************
1781: 0003: 
1782: 0003: FUNCTION DATE.GT(DATE1$, DATE2$) EXTERNAL                               !DSWM
1783: 0003:     STRING    DATE1$, DATE2$
1784: 0003:     INTEGER*1 DATE.GT
1785: 0003: END FUNCTION
1786: 0003: 
1787: 0003: 
1788: 0003: FUNCTION DATE.GE(DATE1$, DATE2$) EXTERNAL                               !DSWM
1789: 0003:     STRING    DATE1$, DATE2$
1790: 0003:     INTEGER*1 DATE.GE
1791: 0003: END FUNCTION
1792: 0003: 
1793: 0003: 
1794: 0003: FUNCTION DATE.LT(DATE1$, DATE2$) EXTERNAL                               !DSWM
1795: 0003:     STRING    DATE1$, DATE2$
1796: 0003:     INTEGER*1 DATE.LT
1797: 0003: END FUNCTION
1798: 0003: 
1799: 0003: 
1800: 0003: FUNCTION DATE.LE(DATE1$, DATE2$) EXTERNAL                               !DSWM
1801: 0003:     STRING    DATE1$, DATE2$
1802: 0003:     INTEGER*1 DATE.LE
1803: 0003: END FUNCTION
1804: 0003: 
1805: 0003:     %INCLUDE EALHSASC.J86  !                                           ! OAS
1806: 0003: \/* TIME STAMP BLOCK **********************************************
1807: 0003: \** END OF TIME STAMP BLOCK **************************************/
1808: 0003: !! THIS MODULE WAS CREATED BY APAR IR70269
1809: 0003: !*********************************************************************
1810: 0003: !
1811: 0003: ! ASSEMBLER SUBROUTNE DEFINITIONS
1812: 0003: !
1813: 0003: ! These definitions should be copied by any routine which wishes to
1814: 0003: ! use the performanced enhanced assembler routines.
1815: 0003: !
1816: 0003: !*********************************************************************
1817: 0003:  
1818: 0003: !*********************************************************************
1819: 0003: !
1820: 0003: ! SUBSTR
1821: 0003: !
1822: 0003: ! This routine performs a merge of two strings. String P3$, offset P4
1823: 0003: ! is merged into string P1$ offset P2 for a length of P5 bytes
1824: 0003: !
1825: 0003: ! CAUTION: P1$ must be long enough to totally contain P3$
1826: 0003: !
1827: 0003: ! NOTE: THE OFFSETS PASSED TO THIS ROUTINE ARE ZERO INDEXED
1828: 0003: !
1829: 0003: !*********************************************************************
1830: 0003:  
1831: 0003:  FUNCTION SUBSTR (P1$,P2,P3$,P4,P5) EXTERNAL
1832: 0003:  STRING P1$,P3$
1833: 0003:  INTEGER*2 P2,P4,P5
1834: 0003:  END FUNCTION
1835: 0003:  
1836: 0003: !*********************************************************************
1837: 0003: !
1838: 0003: ! GETN2/GETN4
1839: 0003: !
1840: 0003: ! These routines extract a two/four byte integer from a string.
1841: 0003: ! P2 is the offset within the string
1842: 0003: !
1843: 0003: ! NOTE: THE OFFSET PASSED TO THIS ROUTINE IS ZERO INDEXED
1844: 0003: !
1845: 0003: !*********************************************************************
1846: 0003:  
1847: 0003:  FUNCTION GETN2(P1$,P2) EXTERNAL
1848: 0003:  INTEGER*2 GETN2
1849: 0003:  STRING P1$
1850: 0003:  INTEGER*2 P2
1851: 0003:  END FUNCTION
1852: 0003:  
1853: 0003:  FUNCTION GETN4(P1$,P2) EXTERNAL
1854: 0003:  INTEGER*4 GETN4
1855: 0003:  STRING P1$
1856: 0003:  INTEGER*2 P2
1857: 0003:  END FUNCTION
1858: 0003:  
1859: 0003: !*********************************************************************
1860: 0003: !
1861: 0003: ! PUTN2/PUTN4
1862: 0003: !
1863: 0003: ! These routines insert a two/four byte integer into a string.
1864: 0003: ! P2 is the offset within the string and P3 is the source integer
1865: 0003: !
1866: 0003: ! NOTE: THE OFFSET PASSED TO THIS ROUTINE IS ZERO INDEXED
1867: 0003: !
1868: 0003: !*********************************************************************
1869: 0003:  
1870: 0003:  FUNCTION PUTN2(P1$,P2,P3) EXTERNAL
1871: 0003:  STRING P1$
1872: 0003:  INTEGER*2 P2,P3
1873: 0003:  END FUNCTION
1874: 0003:  
1875: 0003:  FUNCTION PUTN4(P1$,P2,P3) EXTERNAL
1876: 0003:  STRING P1$
1877: 0003:  INTEGER*2 P2
1878: 0003:  INTEGER*4 P3
1879: 0003:  END FUNCTION
1880: 0003:  
1881: 0003: !*********************************************************************
1882: 0003: !
1883: 0003: ! PACKBIN2/4
1884: 0003: !
1885: 0003: ! These routines take a packed decimal string and convert to integer
1886: 0003: ! (The equivalent of CBASIC INT%(VAL(UNPACK$())) )
1887: 0003: ! P1 is the source string, P2 the string offset and P3 the length
1888: 0003: !
1889: 0003: ! NOTE: THE OFFSET PASSED TO THIS ROUTINE IS ZERO INDEXED
1890: 0003: !
1891: 0003: !*********************************************************************
1892: 0003:  
1893: 0003:  FUNCTION PACKBIN2(P1$,P2,P3) EXTERNAL
1894: 0003:  INTEGER*2 PACKBIN2
1895: 0003:  STRING P1$
1896: 0003:  INTEGER*2 P2,P3
1897: 0003:  END FUNCTION
1898: 0003:  
1899: 0003:  FUNCTION PACKBIN4(P1$,P2,P3) EXTERNAL
1900: 0003:  INTEGER*4 PACKBIN4
1901: 0003:  STRING P1$
1902: 0003:  INTEGER*2 P2,P3
1903: 0003:  END FUNCTION
1904: 0003:  
1905: 0003: !*********************************************************************
1906: 0003: !
1907: 0003: ! ADDIN2/4
1908: 0003: !
1909: 0003: ! These routines add an integer into an integer which is imbedded within
1910: 0003: ! a string.  P1$ is the string containing at offset P2 the integer to be
1911: 0003: ! updated.  P3 is the integer to be added into P1$.
1912: 0003: !
1913: 0003: ! NOTE: THE OFFSET PASSED TO THIS ROUTINE IS ZERO INDEXED
1914: 0003: !
1915: 0003: !*********************************************************************
1916: 0003:  
1917: 0003:  FUNCTION ADDIN4(P1$,P2,P3) EXTERNAL
1918: 0003:  INTEGER*4 ADDIN4
1919: 0003:  STRING P1$
1920: 0003:  INTEGER*2 P2
1921: 0003:  INTEGER*4 P3
1922: 0003:  END FUNCTION
1923: 0003:  
1924: 0003:  FUNCTION ADDIN2(P1$,P2,P3) EXTERNAL
1925: 0003:  INTEGER*2 ADDIN2
1926: 0003:  STRING P1$
1927: 0003:  INTEGER*2 P2,P3
1928: 0003:  END FUNCTION
1929: 0003:  
1930: 0003: !*********************************************************************
1931: 0003: !
1932: 0003: ! MATCHB
1933: 0003: !
1934: 0003: ! This routine performs a fast match function when the string being
1935: 0003: ! searched for contains only a single character.  As with the MATCH
1936: 0003: ! function, P1$ is the character to be found, P2$ is the string to be
1937: 0003: ! searched, and P3 the offst at which to start the search.
1938: 0003: !
1939: 0003: !*********************************************************************
1940: 0003:  
1941: 0003:  FUNCTION MATCHB(P1$,P2$,P3) EXTERNAL
1942: 0003:  INTEGER*2 MATCHB
1943: 0003:  STRING P1$
1944: 0003:  STRING P2$
1945: 0003:  INTEGER*2 P3
1946: 0003:  END FUNCTION
1947: 0003:  
1948: 0003: \ REM!! *************************************************************!!
1949: 0003: \ REM!! PROCEDURE - CONVERT A PACKED DECIMAL DATA STRING TO A        !!
1950: 0003: \ REM!! 4 BYTE BINARY INTEGER REPRESENTED AS A STRING.               !!
1951: 0003: \ REM!! STRING "OUT$" MUST BE INITIALIZED BEFORE CALLING THE ROUTINE.!!
1952: 0003: \ REM!! *************************************************************!!
1953: 0003:  
1954: 0003: SUB UPDBIN4 (IN$,OUT$) EXTERNAL
1955: 0003: STRING IN$,OUT$
1956: 0003: END SUB
1957: 0003:  
1958: 0003: \ REM!! *************************************************************!!
1959: 0003: \ REM!! PROCEDURE - CONVERT A PACKED DECIMAL DATA STRING TO A        !!
1960: 0003: \ REM!! 3 BYTE BINARY INTEGER REPRESENTED AS A STRING.               !!
1961: 0003: \ REM!! STRING "OUT$" MUST BE INITIALIZED BEFORE CALLING THE ROUTINE.!!
1962: 0003: \ REM!! *************************************************************!!
1963: 0003:  
1964: 0003: SUB UPDBIN3 (IN$,OUT$) EXTERNAL
1965: 0003: STRING IN$,OUT$
1966: 0003: END SUB
1967: 0003:  
1968: 0003: \ REM!! *************************************************************!!
1969: 0003: \ REM!! PROCEDURE - CONVERT A PACKED DECIMAL DATA STRING TO A        !!
1970: 0003: \ REM!! 2 BYTE BINARY INTEGER REPRESENTED AS A STRING.               !!
1971: 0003: \ REM!! STRING "OUT$" MUST BE INITIALIZED BEFORE CALLING THE ROUTINE.!!
1972: 0003: \ REM!! *************************************************************!!
1973: 0003:  
1974: 0003: SUB UPDBIN2 (IN$,OUT$) EXTERNAL
1975: 0003: STRING IN$,OUT$
1976: 0003: END SUB
1977: 0003:  
1978: 0003: \ REM!! *************************************************************!!
1979: 0003: \ REM!! PROCEDURE - CONVERT A PACKED DECIMAL DATA STRING TO A        !!
1980: 0003: \ REM!! 1 BYTE BINARY INTEGER REPRESENTED AS A STRING.               !!
1981: 0003: \ REM!! STRING "OUT$" MUST BE INITIALIZED BEFORE CALLING THE ROUTINE.!!
1982: 0003: \ REM!! *************************************************************!!
1983: 0003:  
1984: 0003: SUB UPDBIN1 (IN$,OUT$) EXTERNAL
1985: 0003: STRING IN$,OUT$
1986: 0003: END SUB
1987: 0003:  
1988: 0003: \ REM!! *************************************************************!!
1989: 0003: \ REM!! PROCEDURE - CONVERT A PACKED DECIMAL DATA STRING TO A        !!
1990: 0003: \ REM!! 4 BYTE HEX REPRESENTATION OF A 2-BYTE INTEGER                !!
1991: 0003: \ REM!! STRING "OUT$" MUST BE INITIALIZED BEFORE CALLING THE ROUTINE.!!
1992: 0003: \ REM!! *************************************************************!!
1993: 0003:  
1994: 0003: SUB UPDHEX2 (IN$,OUT$) EXTERNAL
1995: 0003: STRING IN$,OUT$
1996: 0003: END SUB
1997: 0003:  
1998: 0003: \ REM!! *************************************************************!!
1999: 0003: \ REM!! PROCEDURE - CONVERT A PACKED DECIMAL DATA STRING TO A        !!
2000: 0003: \ REM!! 2 BYTE HEX REPRESENTATION OF A 1-BYTE INTEGER                !!
2001: 0003: \ REM!! STRING "OUT$" MUST BE INITIALIZED BEFORE CALLING THE ROUTINE.!!
2002: 0003: \ REM!! *************************************************************!!
2003: 0003:  
2004: 0003: SUB UPDHEX1 (IN$,OUT$) EXTERNAL
2005: 0003: STRING IN$,OUT$
2006: 0003: END SUB
2007: 0003:  
2008: 0003: \ REM!! *************************************************************!!
2009: 0003: \ REM!! PROCEDURE - CONVERT AN INPUT 4 BYTE INTEGER REPRESENTED AS A !!
2010: 0003: \ REM!! STRING TO A 2 BYTE BINARY INTEGER REPRESENTED AS A STRING    !!
2011: 0003: \ REM!! WHERE BOTH THE INPUT AND OUTPUT MAY BE IMBEDDED WITHIN THE   !!
2012: 0003: \ REM!! GIVEN STRING AT THE GIVEN OFFSET.                            !!
2013: 0003: \ REM!! STRING "OUT$" MUST BE INITIALIZED BEFORE CALLING THE ROUTINE.!!
2014: 0003: \ REM!!
2015: 0003: \ REM!! NOTE: THE OFFSETS PASSED TO THIS ROUTINE ARE UNIT INDEXED
2016: 0003: \ REM!! *************************************************************!!
2017: 0003:  
2018: 0003: SUB INTBIN2 (IN$,IN%,OUT$,OUT%) EXTERNAL
2019: 0003: STRING IN$,OUT$
2020: 0003: INTEGER IN%,OUT%
2021: 0003: END SUB
2022: 0003:  
2023: 0003: \ REM!! *************************************************************!!
2024: 0003: \ REM!! PROCEDURE - CONVERT AN INPUT 4 BYTE INTEGER REPRESENTED AS A !!
2025: 0003: \ REM!! STRING TO A 3 BYTE BINARY INTEGER REPRESENTED AS A STRING    !!
2026: 0003: \ REM!! WHERE BOTH THE INPUT AND OUTPUT MAY BE IMBEDDED WITHIN THE   !!
2027: 0003: \ REM!! GIVEN STRING AT THE GIVEN OFFSET.                            !!
2028: 0003: \ REM!! STRING "OUT$" MUST BE INITIALIZED BEFORE CALLING THE ROUTINE.!!
2029: 0003: \ REM!!
2030: 0003: \ REM!! NOTE: THE OFFSETS PASSED TO THIS ROUTINE ARE UNIT INDEXED
2031: 0003: \ REM!! *************************************************************!!
2032: 0003:  
2033: 0003: SUB INTBIN3 (IN$,IN%,OUT$,OUT%) EXTERNAL
2034: 0003: STRING IN$,OUT$
2035: 0003: INTEGER IN%,OUT%
2036: 0003: END SUB
2037: 0003:  
2038: 0003: \ REM!! *************************************************************!!
2039: 0003: \ REM!! PROCEDURE - CONVERT AN INPUT 4 BYTE INTEGER REPRESENTED AS A !!
2040: 0003: \ REM!! STRING TO A 4 BYTE BINARY INTEGER REPRESENTED AS A STRING    !!
2041: 0003: \ REM!! WHERE BOTH THE INPUT AND OUTPUT MAY BE IMBEDDED WITHIN THE   !!
2042: 0003: \ REM!! GIVEN STRING AT THE GIVEN OFFSET.                            !!
2043: 0003: \ REM!! STRING "OUT$" MUST BE INITIALIZED BEFORE CALLING THE ROUTINE.!!
2044: 0003: \ REM!!
2045: 0003: \ REM!! NOTE: THE OFFSETS PASSED TO THIS ROUTINE ARE UNIT INDEXED
2046: 0003: \ REM!! *************************************************************!!
2047: 0003:  
2048: 0003: SUB INTBIN4 (IN$,IN%,OUT$,OUT%) EXTERNAL
2049: 0003: STRING IN$,OUT$
2050: 0003: INTEGER IN%,OUT%
2051: 0003: END SUB
2052: 0003:  
2053: 0003: 
2054: 0003: !**********************************************************************! LJT
2055: 0003: !***                                                                   ! LJT
2056: 0003: !***      PROCESS.KEYED.RECORD$                                        ! LJT
2057: 0003: !***                                                                   ! LJT
2058: 0003: !***      'User exit' for PROCESS.KEYED.FILE (PSBF30)                  ! LJT
2059: 0003: !***                                                                   ! LJT
2060: 0003: !**********************************************************************! LJT
2061: 0003: 
2062: 0003: FUNCTION PROCESS.KEYED.RECORD$(RECORD$) PUBLIC                         ! LJT
2063: 002c: 
2064: 002c:     STRING PROCESS.KEYED.RECORD$,RECORD$                               ! LJT
2065: 002c: 
2066: 002c:        MINLS.ITEM.CODE$ = LEFT$(RECORD$,4)                             ! LJT
2067: 004e:        RC% = READ.MINLS                                                ! LJT
2068: 005e: 
2069: 005e:        F02.DATE$ = UNPACK$(MINLS.RECOUNT.DATE$)                        ! LJT
2070: 0081:        CALL UPDATE.DATE(RFSCF.RECOUNT.DAYS.RETAIN%)                    ! LJT
2071: 009b:        IF DATE.LE(F02.DATE$, DATE$) THEN BEGIN                         ! LJT
2072: 00c5:           DELREC MINLS.SESS.NUM%; MINLS.ITEM.CODE$                     ! LJT
2073: 00e4:           !Turn off PENDING COUNT flag on the IDF                      ! LJT
2074: 00e4:           IDF.BOOTS.CODE$ = MINLS.ITEM.CODE$                           ! LJT
2075: 0102:           RC% = READ.IDF                                               ! LJT
2076: 0112:           IF RC% = 0 THEN BEGIN                                        ! LJT
2077: 0121:           !Make sure the flag is set to on first                       ! LJT
2078: 0121:              IF (IDF.BIT.FLAGS.2% AND 00000100b) <> 0 THEN BEGIN       ! LJT
2079: 0136:              !It's on, so turn it off                                  ! LJT
2080: 0136:                  IDF.BIT.FLAGS.2% = (IDF.BIT.FLAGS.2% XOR 4)           ! LJT
2081: 014e:                  RC% = WRITE.IDF                                       ! LJT
2082: 015e:              ENDIF                                                     ! LJT
2083: 0166:           ENDIF                                                        ! LJT
2084: 016e:        ENDIF                                                           ! LJT
2085: 0176: 
2086: 0176:     PROCESS.KEYED.RECORD$ = RECORD$                                    ! LJT
2087: 018e: 
2088: 018e: END FUNCTION                                                           ! LJT
2089: 01ac: 
2090: 01ac: \*****************************************************************************
2091: 01ac: \***
2092: 01ac: \***    PROGRAM.CONTROL
2093: 01ac: \***
2094: 01ac: \***..........................................................................
2095: 01ac: 
2096: 01ac: 
2097: 01ac: MINPRINT.START:
2098: 01d6: 
2099: 01d6: 
2100: 01d6:     ON ERROR GOTO ERROR.DETECTED
2101: 01eb: 
2102: 01eb:     IF LEFT$(COMMAND$,8) = "BACKGRND" THEN BEGIN                       ! DCS ! OAS
2103: 0225:         COMM.MODE.FLAG$ = "B"                                          ! DCS ! OAS
2104: 023f:     ENDIF ELSE BEGIN                                                   ! OAS
2105: 0247:         COMM.MODE.FLAG$ = "C"                                          ! DCS ! OAS
2106: 025e:         IF LEFT$(COMMAND$,8) = "RERUN" THEN BEGIN                      ! OAS
2107: 029b: 
2108: 029b:             !MINPRINT will run with the help of SLEEPER program in     ! OAS
2109: 029b:             !background. If MINPRINT has to be run manually, then      ! OAS
2110: 029b:             !user has to enter the following parameters in command     ! OAS
2111: 029b:             !mode, "MINPRINT RERUN".                                   ! OAS
2112: 029b: 
2113: 029b:             GOSUB MINPRINT.HELP                                        ! OAS
2114: 02ad:             INPUT "Do you really want to run MINPRINT? (Y/N) ";RESPONSE$ ! OAS ! CCSk
2115: 02ce: 
2116: 02ce:             !If the user enters wrong option other than "Y", "N", "y"  ! OAS
2117: 02ce:             !or "n", program will ask the user to enter the correct    ! OAS
2118: 02ce:             !choice                                                    ! OAS
2119: 02ce: 
2120: 02ce:             WHILE ((RESPONSE$ <> "Y" ) AND    \                        ! OAS
2121: 02d8:                    (RESPONSE$ <> "y" ) AND    \                        ! OAS
2122: 02d8:                    (RESPONSE$ <> "N" ) AND    \                        ! OAS
2123: 02d8:                    (RESPONSE$ <> "n" ) )                               ! OAS
2124: 02d8: 
2125: 02d8:                 INPUT "Enter the correct option (Y/N) ";RESPONSE$      ! OAS
2126: 02f9:             WEND                                                       ! OAS
2127: 0392: 
2128: 0392:             !If the user response is "Y" or "y" then re-run MINPRINT   ! OAS
2129: 0392:             !If the user response is "N" or "n" then STOP the program  ! OAS
2130: 0392: 
2131: 0392:             IF ((RESPONSE$ = "Y") OR       \                           ! OAS
2132: 03de:                 (RESPONSE$ = "y")) THEN BEGIN                          ! OAS
2133: 03de: 
2134: 03de:                 ADXSERVE.DATA$ = "Re - running MINPRINT"               ! OAS
2135: 03f3:                 GOSUB DISPLAY.MESSAGE                                  ! OAS
2136: 0407: 
2137: 0407:             ENDIF ELSE IF ((RESPONSE$ = "N") OR \                      ! OAS
2138: 0453:                            (RESPONSE$ = "n")) THEN BEGIN               ! OAS
2139: 0453:                 STOP                                                   ! OAS
2140: 0460:             ENDIF                                                      ! OAS
2141: 046a: 
2142: 046a:         ENDIF ELSE BEGIN                                               ! OAS
2143: 0472: 
2144: 0472:             !If the user runs MINPRINT without any parameter,          ! OAS
2145: 0472:             !then the program will display the help details            ! OAS
2146: 0472: 
2147: 0472:             GOSUB MINPRINT.HELP                                        ! OAS
2148: 0484:             STOP                                                       ! OAS
2149: 0491:         ENDIF                                                          ! OAS
2150: 0499: 
2151: 0499:     ENDIF
2152: 04a1: 
2153: 04a1:     ADXSERVE.DATA$ = "MINPRINT has started"                            ! DCS
2154: 04b6:     GOSUB DISPLAY.MESSAGE                                              ! DCS
2155: 04c8: 
2156: 04c8:     GOSUB CREATE.MINOK.FILE                                            ! OAS
2157: 04da: 
2158: 04da:     IF MINPRINT.ALREADY.RUN% THEN BEGIN                                ! RTT
2159: 04e9:        ADXSERVE.DATA$ = "MINPRINT already run. " +                     \ RTT
2160: 0505:                         "Rerun will overwrite CLILF/CLOLF backups"     ! RTT
2161: 0505:        GOSUB DISPLAY.MESSAGE                                           ! RTT
2162: 0517:        GOSUB STOP.PROGRAM                                              ! RTT
2163: 0529:     ENDIF                                                              ! RTT
2164: 0531: 
2165: 0531:     !Processing of RFCNTLST.DAY report which is defined in MINRFCNT.BAS! OAS
2166: 0531:     GOSUB CALL.MINRFCNT                                                ! OAS
2167: 0543: 
2168: 0543:     GOSUB INITIALISATION
2169: 0555:     GOSUB GET.SOFTS
2170: 0567: 
2171: 0567:     DO.MAIN = 1                                                        ! CNS
2172: 0574: 
2173: 0574:     !If RF is ON, then will instruct RF server to close all files and  ! OAS
2174: 0574:     !backup the CLILF and CLOLF files else it will continue with the   ! OAS
2175: 0574:     !backup of CLILF/CLOLF files                                       ! OAS
2176: 0574: 
2177: 0574:     IF MATCH(" ACTIVE",SOFTS.RECORD$,1) THEN BEGIN                     ! NCS
2178: 0599:        ADXSERVE.DATA$ = "Detected RF / Network PDT  Store"             ! DCS ! NCS
2179: 05ae:        GOSUB DISPLAY.MESSAGE                                           ! DCS
2180: 05c0:        DO.MAIN = 0                                                     ! CNS
2181: 05cd: 
2182: 05cd:        \***********************************************************    ! FCS ! OAS
2183: 05cd:        \***                                                            ! OAS
2184: 05cd:        \***  Instruct the RF Server to close all files                 ! FCS ! OAS
2185: 05cd:        \***                                                            ! OAS
2186: 05cd:        \***********************************************************    ! FCS ! OAS
2187: 05cd: 
2188: 05cd:        IF END #64 THEN RFS.BYPASS                                      ! HBG
2189: 05e4:        OPEN "PI:rfscomms" AS 64                                        ! FCS
2190: 05ff:        PIPE.OPEN$ = "Y"                                                ! FCS
2191: 0614:        PRINT USING "&"; #64 ; "CLS*"                                   ! FCS
2192: 0637:        CLOSE 64                                                        ! FCS
2193: 0646:        PIPE.OPEN$ = "N"                                                ! FCS
2194: 065b:        ADXSERVE.DATA$ = "Waiting for RFS Close."                       ! FCS
2195: 0670:        GOSUB DISPLAY.MESSAGE                                           ! FCS
2196: 0682:        WAIT ;15000                                                     ! FCS
2197: 0699: 
2198: 0699:     ENDIF                                                              ! OAS
2199: 06a1: 
2200: 06a1: RFS.BYPASS:                                                            ! HBG
2201: 06b1:     GOSUB BACKUP.CLILF.CLOLF.FILES                                     ! OAS
2202: 06c3:     GOSUB RF.PROCESS                                                   ! CNS
2203: 06d5:     !Earlier, only RF/POD stores have the CLOLF/CLILF files present
2204: 06d5:     !(around 900 stores). All other stores are PDT stores and they do
2205: 06d5:     !not use the CLOLF/CLILF. However as part of SFA, these files need
2206: 06d5:     !creating and populating like RF/POD stores. Hence, removing the
2207: 06d5:     !seprate processing section for the ‘non RF’ stores
2208: 06d5: 
2209: 06d5:     !ENDIF ELSE BEGIN                                                  ! DCS ! OAS
2210: 06d5:     !  ADXSERVE.DATA$ = "Detected NON-RF Store"                        ! DCS ! NCS
2211: 06d5:     !  GOSUB DISPLAY.MESSAGE                                           ! DCS ! OAS
2212: 06d5:     !                                                                        ! OAS
2213: 06d5:     !  GOSUB PROCESS.RFSCF                                             ! LJT ! OAS
2214: 06d5:     !                                                                        ! OAS
2215: 06d5:     !  ADXSERVE.DATA$ = "Open MINLS file"                              ! LJT ! OAS
2216: 06d5:     !  GOSUB DISPLAY.MESSAGE                                           ! LJT ! OAS
2217: 06d5:     !  CURRENT.SESS.NUM% = MINLS.SESS.NUM%                             ! LJT ! OAS
2218: 06d5:     !  IF END #MINLS.SESS.NUM% THEN FILE.ERROR.EXIT                    ! LJT ! OAS
2219: 06d5:     !  OPEN MINLS.FILE.NAME$ KEYED RECL MINLS.RECL% AS MINLS.SESS.NUM% \ LJT ! OAS
2220: 06d5:     !                                                            NODEL ! LJT ! OAS
2221: 06d5:     !                                                                        ! OAS
2222: 06d5:     !  ADXSERVE.DATA$ = "Open IDF file"                                ! LJT ! OAS
2223: 06d5:     !  GOSUB DISPLAY.MESSAGE                                           ! LJT ! OAS
2224: 06d5:     !  CURRENT.SESS.NUM% = IDF.SESS.NUM%                               ! LJT ! OAS
2225: 06d5:     !  IF END #IDF.SESS.NUM% THEN FILE.ERROR.EXIT                      ! LJT ! OAS
2226: 06d5:     !  OPEN IDF.FILE.NAME$ KEYED RECL IDF.RECL% AS IDF.SESS.NUM%       \ LJT ! OAS
2227: 06d5:     !                                                           NODEL  ! LJT ! OAS
2228: 06d5:     !                                                                        ! OAS
2229: 06d5:     !  RC% = PROCESS.KEYED.FILE(MINLS.FILE.NAME$,MINLS.REPORT.NUM%,"N")! LJT ! OAS
2230: 06d5:     !                                                                        ! OAS
2231: 06d5:     !  CLOSE MINLS.SESS.NUM%                                           ! LJT ! OAS
2232: 06d5:     !ENDIF                                                             ! DCS ! OAS
2233: 06d5: 
2234: 06d5:     GOSUB WRITE.MINOK                                                  ! OAS
2235: 06e7: 
2236: 06e7:     GOSUB TERMINATION
2237: 06f9: 
2238: 06f9: 
2239: 06f9: STOP.PROGRAM:
2240: 0709: 
2241: 0709:     ADXSERVE.DATA$ = "--- MINPRINT has finished ---"                   ! DCS
2242: 071e:     GOSUB DISPLAY.MESSAGE                                              ! DCS
2243: 0730: 
2244: 0730: 
2245: 0730:     STOP
2246: 073d: 
2247: 073d: 
2248: 073d: \*****************************************************************************
2249: 073d: \***
2250: 073d: \***    MINPRINT.HELP
2251: 073d: \***
2252: 073d: \***..........................................................................
2253: 073d: 
2254: 073d: MINPRINT.HELP:
2255: 074d: 
2256: 074d:     PRINT "                         MINPRINT HELP                                       "! OAS
2257: 075e:     PRINT "                                                                             "! OAS
2258: 076f:     PRINT "This program requires the RERUN parameter to be entered for running          "! OAS
2259: 0780:     PRINT "from command mode. For a rerun, the complete program will run, and it        "! OAS
2260: 0791:     PRINT "must be noted that the following will take place:                            "! OAS
2261: 07a2:     PRINT "                                                                             "! OAS
2262: 07b3:     PRINT "-    backs up the CLOLF.BIN & CLILF.BIN count list files to CLOLF.nnn and    "! OAS
2263: 07c4:     PRINT "     CLILF.nnn where nnn is MON or TUE etc depending on todays date. This    "! OAS
2264: 07d5:     PRINT "     will overwrite any existing backup files which feed into the Weekly     "! OAS
2265: 07e6:     PRINT "     Count reporting                                                         "! OAS
2266: 07f7:     PRINT "-    creates empty CLOLF.BIN and CLILF.BIN files deleting any counts         "! OAS
2267: 0808:     PRINT "     currently on the files                                                  "! OAS
2268: 0819:     PRINT "-    it is recommended to manually backup all CLILF/CLOLF backups and BIN    "! OAS
2269: 082a:     PRINT "     before rerunning MINPRINT                                               "! OAS
2270: 083b:     PRINT "                                                                             "! OAS
2271: 084c: 
2272: 084c: RETURN
2273: 085c: 
2274: 085c: \*****************************************************************************
2275: 085c: \***
2276: 085c: \***    WRITE.MINOK
2277: 085c: \***
2278: 085c: \***..........................................................................
2279: 085c: 
2280: 085c: WRITE.MINOK:                                                            ! OAS
2281: 086c: 
2282: 086c:     ADXSERVE.DATA$ = "Updating MINOK file"                              ! OAS
2283: 0881:     GOSUB DISPLAY.MESSAGE                                               ! OAS
2284: 0893: 
2285: 0893:     FUNCTION.FLAG$ EQ "C"                                               ! OAS
2286: 08a8:     CURRENT.SESS.NUM% = MINOK.SESS.NUM%                                 ! OAS
2287: 08ba:     IF END #MINOK.SESS.NUM% THEN FILE.ERROR.EXIT                        ! OAS
2288: 08d3:     CREATE MINOK.FILE.NAME$ AS MINOK.SESS.NUM%                          ! OAS
2289: 08f4: 
2290: 08f4:     FILE.OPERATION$ = "W"                                               ! OAS
2291: 090b:     CURRENT.REPORT.NUM% = MINOK.REPORT.NUM%                             ! OAS
2292: 091d: 
2293: 091d:     MINOK.ERROR.CHK% = FALSE                                            ! OAS
2294: 092f: 
2295: 092f: !                             MINOK FILE FORMAT                                    ! OAS
2296: 092f: !                                                                                  ! OAS
2297: 092f: !   |--------------------------|-------------|---------------------------------|   ! OAS
2298: 092f: !   |Field Name                |  Field Type | Description                     |   ! OAS
2299: 092f: !   |--------------------------|-------------|---------------------------------|   ! OAS
2300: 092f: !   |Run date                  |  8 ASC      | CCYYMMDD                        |   ! OAS
2301: 092f: !   |Run time                  |  6 ASC      | HHMMSS                          |   ! OAS
2302: 092f: !   |Reporting status          |  1 ASC      | E = Report processing successful|   ! OAS
2303: 092f: !   |                          |             | X = Report processing failed    |   ! OAS
2304: 092f: !   |CLILF backup status       |  1 ASC      | E = Backup successful           |   ! OAS
2305: 092f: !   |                          |             | X = Backup failed               |   ! OAS
2306: 092f: !   |CLOLF backup status       |  1 ASC      | E = Backup successful           |   ! OAS
2307: 092f: !   |                          |             | X = Backup failed               |   ! OAS
2308: 092f: !   |MINLS housekeeping status |  1 ASC      | E = Processing successful       |   ! OAS
2309: 092f: !   |                          |             | X = Processing failed           |   ! OAS
2310: 092f: !   |Filler                    |  62 ASC     | Spaces                          |   ! OAS
2311: 092f: !   |--------------------------|-------------|---------------------------------|   ! OAS
2312: 092f: 
2313: 092f: !    WRITE #MINOK.SESS.NUM%;                             \               ! OAS  ! RTT
2314: 092f: !        LEFT$(MINOK.RECORD$, 14) +                      \               ! OAS  ! RTT
2315: 092f: !        REPORTING.STATUS$ +                             \               ! OAS  ! RTT
2316: 092f: !        CLILF.BKUP.STATUS$ +                            \               ! OAS  ! RTT
2317: 092f: !        CLOLF.BKUP.STATUS$ +                            \               ! OAS  ! RTT
2318: 092f: !        MINLS.HK.STATUS$ +                              \               ! OAS  ! RTT
2319: 092f: !        STRING$(62, " ")                                                ! OAS  ! RTT
2320: 092f: 
2321: 092f:     WRITE #MINOK.SESS.NUM%;                             \               ! RTT
2322: 0990:         MINOK.RUN.DATE$ +                               \               ! RTT
2323: 0990:         MINOK.RUN.TIME$ +                               \               ! RTT
2324: 0990:         REPORTING.STATUS$ +                             \               ! RTT
2325: 0990:         CLILF.BKUP.STATUS$ +                            \               ! RTT
2326: 0990:         CLOLF.BKUP.STATUS$ +                            \               ! RTT
2327: 0990:         MINLS.HK.STATUS$ +                              \               ! RTT
2328: 0990:         STRING$(62, " ")                                                ! RTT
2329: 0990: 
2330: 0990:        MINOK.ERROR.CHK% = TRUE                                          ! OAS
2331: 09a2: 
2332: 09a2: MINOK.ERROR:                                                            ! OAS
2333: 09b2: 
2334: 09b2:     IF MINOK.ERROR.CHK% = FALSE THEN BEGIN                              ! OAS
2335: 09c7: 
2336: 09c7:         ADXSERVE.DATA$ = "MINOK file not processed successfully - ERROR"! OAS
2337: 09dc:         GOSUB DISPLAY.MESSAGE                                           ! OAS
2338: 09f0: 
2339: 09f0:     ENDIF ELSE IF MINOK.ERROR.CHK% = TRUE THEN BEGIN                    ! OAS
2340: 0a05: 
2341: 0a05:         ADXSERVE.DATA$ = "MINOK file processed successfully"            ! OAS
2342: 0a1a:         GOSUB DISPLAY.MESSAGE                                           ! OAS
2343: 0a2c: 
2344: 0a2c:     ENDIF                                                               ! OAS
2345: 0a34: 
2346: 0a34:     CLOSE MINOK.SESS.NUM%                                               ! OAS
2347: 0a45: 
2348: 0a45: RETURN                                                                  ! OAS
2349: 0a55: 
2350: 0a55: \*****************************************************************************
2351: 0a55: \***
2352: 0a55: \***    INITIALISATION
2353: 0a55: \***
2354: 0a55: \***..........................................................................
2355: 0a55: 
2356: 0a55: 
2357: 0a55: INITIALISATION:
2358: 0a65: 
2359: 0a65: 
2360: 0a65:     ADXSERVE.DATA$ = "INITIALISATION"                                ! DCS
2361: 0a7a:     GOSUB DISPLAY.MESSAGE                                            ! DCS
2362: 0a8c:     GOSUB INITIALISE.VARIABLES
2363: 0a9e: 
2364: 0a9e:     GOSUB ALLOCATE.SESSION.NUMBERS
2365: 0ab0: 
2366: 0ab0: RETURN
2367: 0ac0: 
2368: 0ac0: 
2369: 0ac0: \*****************************************************************************
2370: 0ac0: \***
2371: 0ac0: \***    INITIALISATION SPECIFIC ROUTINES
2372: 0ac0: \***
2373: 0ac0: \***..........................................................................
2374: 0ac0: 
2375: 0ac0: 
2376: 0ac0: \*****************************************************************************
2377: 0ac0: \***
2378: 0ac0: \***    INITIALISE.VARIABLES
2379: 0ac0: \***    Sets program variables.
2380: 0ac0: \***
2381: 0ac0: \***..........................................................................
2382: 0ac0: 
2383: 0ac0: 
2384: 0ac0: INITIALISE.VARIABLES:
2385: 0ad0: 
2386: 0ad0:     ADXSERVE.DATA$ = "INITIALISE.VARIABLES"                            ! DCS
2387: 0ae5:     GOSUB DISPLAY.MESSAGE                                              ! DCS
2388: 0af7: 
2389: 0af7:     PROGRAM$           EQ "MINPRINT"
2390: 0b0c:     MODULE$            EQ "00"
2391: 0b21:     MODULE.NUMBER$     EQ  PROGRAM$ + MODULE$
2392: 0b47:     BATCH.SCREEN.FLAG$ EQ "B" ! Batch
2393: 0b5e: 
2394: 0b5e:     FALSE = 0                                                          ! OAS
2395: 0b6e:     TRUE  = -1                                                         ! OAS
2396: 0b7e: 
2397: 0b7e:     YESTERDAY$ = "      "                                              ! RTT
2398: 0b93: 
2399: 0b93:     CLILF.BKUP.STATUS$ = "X"                                           ! OAS
2400: 0ba8:     CLOLF.BKUP.STATUS$ = "X"                                           ! OAS
2401: 0bbd:     MINLS.HK.STATUS$   = "E"                                           ! OAS
2402: 0bd2: 
2403: 0bd2: RETURN
2404: 0be2: 
2405: 0be2: !!!**************************************************************************
2406: 0be2: !!!**************************************************************************
2407: 0be2: !!!
2408: 0be2: !!!   CALL.MINRFCNT
2409: 0be2: !!!
2410: 0be2: !!!   Call MINRFCNT module to write information to report file.
2411: 0be2: !!!
2412: 0be2: !!!**************************************************************************
2413: 0be2: 
2414: 0be2: CALL.MINRFCNT:
2415: 0bf2: 
2416: 0bf2:    CALL MINRFCNT
2417: 0bff: 
2418: 0bff: RETURN
2419: 0c0f: 
2420: 0c0f: \*****************************************************************************
2421: 0c0f: \***
2422: 0c0f: \***    ALLOCATE.SESSION.NUMBERS
2423: 0c0f: \***    Perform CALL.F20.SESS.NUM.UTILITY to allocate file session numbers
2424: 0c0f: \***    for all files referenced by the program.
2425: 0c0f: \***
2426: 0c0f: \***..........................................................................
2427: 0c0f: 
2428: 0c0f: 
2429: 0c0f: ALLOCATE.SESSION.NUMBERS:
2430: 0c1f: 
2431: 0c1f:     ADXSERVE.DATA$ = "ALLOCATE.SESSION.NUMBERS"                        ! DCS
2432: 0c34:     GOSUB DISPLAY.MESSAGE                                              ! DCS
2433: 0c46: 
2434: 0c46:     CALL RPRPT.SET
2435: 0c61:     CALL PRINT.SET
2436: 0c6e:     CALL SOFTS.SET                                                     ! CNS
2437: 0c89:     CALL RFSCF.SET                                                     ! CNS
2438: 0ca4:     CALL CLOLF.SET                                                     ! CNS
2439: 0cbf:     CALL CLILF.SET                                                     ! CNS
2440: 0cda:     !CALL ISF.SET                                                      ! CNS ! OAS
2441: 0cda:     !CALL IRF.SET                                                      ! CNS ! OAS
2442: 0cda:     CALL IDF.SET                                                       ! CNS
2443: 0cf5:     CALL PGF.SET                                                       ! KMG
2444: 0d02:     CALL MINLS.SET                                                     ! LJT
2445: 0d0f:     CALL SRITL.SET                                                     ! OAS
2446: 0d2a: 
2447: 0d2a:     FUNCTION.FLAG$ EQ "O"
2448: 0d3f: 
2449: 0d3f:     PASSED.INTEGER% EQ RPRPT.REPORT.NUM%
2450: 0d51:     PASSED.STRING$ EQ RPRPT.FILE.NAME$
2451: 0d6d:     GOSUB CALL.F20.SESS.NUM.UTILITY
2452: 0d7f:     RPRPT.SESS.NUM% EQ F20.INTEGER.FILE.NO%
2453: 0d95: 
2454: 0d95:     PASSED.INTEGER% = PRINT.REPORT.NUM%
2455: 0da7:     PASSED.STRING$ = PRINT.FILE.NAME$
2456: 0dc3:     GOSUB CALL.F20.SESS.NUM.UTILITY
2457: 0dd5:     PRINT.SESS.NUM% = F20.INTEGER.FILE.NO%
2458: 0deb: 
2459: 0deb:     PASSED.INTEGER% EQ SOFTS.REPORT.NUM%                               ! CNS
2460: 0dfd:     PASSED.STRING$ EQ SOFTS.FILE.NAME$                                 ! CNS
2461: 0e19:     GOSUB CALL.F20.SESS.NUM.UTILITY                                    ! CNS
2462: 0e2b:     SOFTS.SESS.NUM% EQ F20.INTEGER.FILE.NO%                            ! CNS
2463: 0e41: 
2464: 0e41:     PASSED.INTEGER% EQ RFSCF.REPORT.NUM%                               ! CNS
2465: 0e53:     PASSED.STRING$ EQ RFSCF.FILE.NAME$                                 ! CNS
2466: 0e6f:     GOSUB CALL.F20.SESS.NUM.UTILITY                                    ! CNS
2467: 0e81:     RFSCF.SESS.NUM% EQ F20.INTEGER.FILE.NO%                            ! CNS
2468: 0e97: 
2469: 0e97:     PASSED.INTEGER% EQ CLOLF.REPORT.NUM%                               ! CNS
2470: 0ea9:     PASSED.STRING$ EQ CLOLF.FILE.NAME$                                 ! CNS
2471: 0ec5:     GOSUB CALL.F20.SESS.NUM.UTILITY                                    ! CNS
2472: 0ed7:     CLOLF.SESS.NUM% EQ F20.INTEGER.FILE.NO%                            ! CNS
2473: 0eed: 
2474: 0eed:     PASSED.INTEGER% EQ CLILF.REPORT.NUM%                               ! CNS
2475: 0eff:     PASSED.STRING$ EQ CLILF.FILE.NAME$                                 ! CNS
2476: 0f1b:     GOSUB CALL.F20.SESS.NUM.UTILITY                                    ! CNS
2477: 0f2d:     CLILF.SESS.NUM% EQ F20.INTEGER.FILE.NO%                            ! CNS
2478: 0f43: 
2479: 0f43:     !Commenting the below as it is not required any more                     ! OAS
2480: 0f43:     !PASSED.INTEGER% EQ ISF.REPORT.NUM%                                ! CNS ! OAS
2481: 0f43:     !PASSED.STRING$ EQ ISF.FILE.NAME$                                  ! CNS ! OAS
2482: 0f43:     !GOSUB CALL.F20.SESS.NUM.UTILITY                                   ! CNS ! OAS
2483: 0f43:     !ISF.SESS.NUM% EQ F20.INTEGER.FILE.NO%                             ! CNS ! OAS
2484: 0f43: 
2485: 0f43:     !PASSED.INTEGER% EQ IRF.REPORT.NUM%                                ! CNS ! OAS
2486: 0f43:     !PASSED.STRING$ EQ IRF.FILE.NAME$                                  ! CNS ! OAS
2487: 0f43:     !GOSUB CALL.F20.SESS.NUM.UTILITY                                   ! CNS ! OAS
2488: 0f43:     !IRF.SESS.NUM% EQ F20.INTEGER.FILE.NO%                             ! CNS ! OAS
2489: 0f43: 
2490: 0f43:     PASSED.INTEGER% EQ IDF.REPORT.NUM%                                 ! CNS
2491: 0f55:     PASSED.STRING$ EQ IDF.FILE.NAME$                                   ! CNS
2492: 0f71:     GOSUB CALL.F20.SESS.NUM.UTILITY                                    ! CNS
2493: 0f83:     IDF.SESS.NUM% EQ F20.INTEGER.FILE.NO%                              ! CNS
2494: 0f99: 
2495: 0f99:     PASSED.INTEGER% EQ PGF.REPORT.NUM%                                 ! KMG
2496: 0fab:     PASSED.STRING$ EQ PGF.FILE.NAME$                                   ! KMG
2497: 0fc7:     GOSUB CALL.F20.SESS.NUM.UTILITY                                    ! KMG
2498: 0fd9:     PGF.SESS.NUM% EQ F20.INTEGER.FILE.NO%                              ! KMG
2499: 0fef: 
2500: 0fef:     PASSED.INTEGER% EQ MINLS.REPORT.NUM%                               ! LJT
2501: 1001:     PASSED.STRING$ EQ MINLS.FILE.NAME$                                 ! LJT
2502: 101d:     GOSUB CALL.F20.SESS.NUM.UTILITY                                    ! LJT
2503: 102f:     MINLS.SESS.NUM% EQ F20.INTEGER.FILE.NO%                            ! LJT
2504: 1045: 
2505: 1045:     PASSED.INTEGER% = SRITL.REPORT.NUM%                                ! OAS
2506: 1057:     PASSED.STRING$ = SRITL.FILE.NAME$                                  ! OAS
2507: 1073:     GOSUB CALL.F20.SESS.NUM.UTILITY                                    ! OAS
2508: 1085:     SRITL.SESS.NUM% = F20.INTEGER.FILE.NO%                             ! OAS
2509: 109b: 
2510: 109b:     ADXSERVE.DATA$ = "Session numbers allocated "                      ! DCS
2511: 10b0:     GOSUB DISPLAY.MESSAGE                                              ! DCS
2512: 10c2: 
2513: 10c2: RETURN
2514: 10d2: 
2515: 10d2: \*****************************************************************************
2516: 10d2: \***
2517: 10d2: \***    CREATE.MINOK.FILE
2518: 10d2: \***    Allocating Session number for MINOK file
2519: 10d2: \***    Creating MINOK File
2520: 10d2: \***    Writing initial values to the file
2521: 10d2: \***
2522: 10d2: \***..........................................................................
2523: 10d2: 
2524: 10d2: CREATE.MINOK.FILE:                                                     ! OAS
2525: 10e2: 
2526: 10e2:     ADXSERVE.DATA$ = "Creating MINOK File"                             ! OAS
2527: 10f7:     GOSUB DISPLAY.MESSAGE                                              ! OAS
2528: 1109: 
2529: 1109:     !Initialised a temporary report number for MINOK file              ! OAS
2530: 1109:     MINOK.REPORT.NUM% = 450                                            ! OAS
2531: 1117:     MINOK.FILE.NAME$ = "D:/ADX_UDT1/MINOK.BIN"                         ! OAS
2532: 112c: 
2533: 112c:     FUNCTION.FLAG$ EQ "O"                                              ! OAS
2534: 1141: 
2535: 1141:     PASSED.INTEGER% = MINOK.REPORT.NUM%                                ! OAS
2536: 114f:     PASSED.STRING$ = MINOK.FILE.NAME$                                  ! OAS
2537: 1168:     GOSUB CALL.F20.SESS.NUM.UTILITY                                    ! OAS
2538: 117a:     MINOK.SESS.NUM% = F20.INTEGER.FILE.NO%                             ! OAS
2539: 118c: 
2540: 118c:     FUNCTION.FLAG$ EQ "C"                                              ! OAS
2541: 11a1: 
2542: 11a1:     CURRENT.SESS.NUM% = MINOK.SESS.NUM%                                ! OAS
2543: 11b3: !    IF END #MINOK.SESS.NUM% THEN FILE.ERROR.EXIT                       ! OAS
2544: 11b3: 
2545: 11b3:     IF END #MINOK.SESS.NUM% THEN NO.PREV.RUN.DETAILS                   ! RTT
2546: 11cc:     OPEN MINOK.FILE.NAME$ AS MINOK.SESS.NUM%                           ! RTT
2547: 11ed: 
2548: 11ed:     IF END #MINOK.SESS.NUM% THEN NO.PREV.RUN.DETAILS                   ! RTT
2549: 1206:     READ FORM "C1,C8,C6,4C1,C62"; #MINOK.SESS.NUM%;                    \ RTT
2550: 126c:         QUOTES$,                                                       \ RTT
2551: 126c:         MINOK.RUN.DATE$,                                               \ RTT
2552: 126c:         MINOK.RUN.TIME$,                                               \ RTT
2553: 126c:         REPORTING.STATUS$,                                             \ RTT
2554: 126c:         CLILF.BKUP.STATUS$,                                            \ RTT
2555: 126c:         CLOLF.BKUP.STATUS$,                                            \ RTT
2556: 126c:         MINLS.HK.STATUS$,                                              \ RTT
2557: 126c:         MINOK.FILLER$                                                  ! RTT
2558: 126c: 
2559: 126c:     GOTO PROCESS.MINOK.RECORD                                          ! RTT
2560: 1276: 
2561: 1276: NO.PREV.RUN.DETAILS:                                                   ! RTT
2562: 1286: 
2563: 1286: PROCESS.MINOK.RECORD:                                                  ! RTT
2564: 1296: 
2565: 1296:     F02.DATE$ = DATE$                                                  ! RTT
2566: 12ae:     RC% = UPDATE.DATE(-1)                                              ! RTT
2567: 12c9:     YESTERDAY$ = F02.DATE$                                             ! RTT
2568: 12e5: 
2569: 12e5:     IF TIME$ > "120000" THEN BEGIN                                     ! RTT
2570: 130b:        CURR.RUN.DAY$ = DATE$ + "120000"                                ! RTT
2571: 1335:     ENDIF ELSE BEGIN                                                   ! RTT
2572: 133d:        CURR.RUN.DAY$ = YESTERDAY$ + "120000"                           ! RTT
2573: 135d:     ENDIF                                                              ! RTT
2574: 1365: 
2575: 1365:     MINOK.TIME.STAMP$ = RIGHT$(MINOK.RUN.DATE$,6) + MINOK.RUN.TIME$    ! RTT
2576: 139b: 
2577: 139b:     IF MINOK.TIME.STAMP$ > CURR.RUN.DAY$ THEN BEGIN                    ! RTT
2578: 13ba:        MINPRINT.ALREADY.RUN% = -1                                      ! RTT
2579: 13c7:     ENDIF                                                              ! RTT
2580: 13cf: 
2581: 13cf:     IF NOT MINPRINT.ALREADY.RUN% THEN BEGIN                            ! RTT
2582: 13e1:         MINOK.RUN.DATE$ = "20" + DATE$                                 ! RTT
2583: 13fe:         MINOK.RUN.TIME$ = TIME$                                        ! RTT
2584: 1414:         CLOSE MINOK.SESS.NUM%                                          ! RTT
2585: 1425:         CREATE MINOK.FILE.NAME$ AS MINOK.SESS.NUM%                     ! OAS
2586: 1446: 
2587: 1446: !        MINOK.RECORD$ = ("20" + DATE$) +               \               ! OAS ! RTT
2588: 1446: !                        TIME$ +                        \               ! OAS ! RTT
2589: 1446: !                        "XXXX" +                       \               ! OAS ! RTT
2590: 1446: !                        STRING$(62, " ")                               ! OAS ! RTT
2591: 1446: 
2592: 1446:         MINOK.RECORD$ = MINOK.RUN.DATE$ +               \              ! RTT
2593: 1479:                         MINOK.RUN.TIME$ +               \              ! RTT
2594: 1479:                         "XXXX" +                        \              ! RTT
2595: 1479:                         STRING$(62, " ")                               ! RTT
2596: 1479: 
2597: 1479:         WRITE #MINOK.SESS.NUM%; MINOK.RECORD$                          ! OAS
2598: 1499:     ENDIF                                                              ! RTT
2599: 14a1: 
2600: 14a1:     CLOSE MINOK.SESS.NUM%                                              ! OAS
2601: 14b2: 
2602: 14b2: RETURN                                                                 ! OAS
2603: 14c2: 
2604: 14c2: \*****************************************************************************
2605: 14c2: \***
2606: 14c2: \***    GET.SOFTS
2607: 14c2: \***
2608: 14c2: \***..........................................................................
2609: 14c2: 
2610: 14c2: GET.SOFTS:                                                             ! CNS
2611: 14d2: 
2612: 14d2:     ADXSERVE.DATA$ = "GET.SOFTS"                                       ! DCS
2613: 14e7:     GOSUB DISPLAY.MESSAGE                                              ! DCS
2614: 14f9: 
2615: 14f9:     FILE.OPERATION$ = "O"                                              ! CNS
2616: 1510:     CURRENT.REPORT.NUM% = SOFTS.REPORT.NUM%                            ! CNS
2617: 1526: 
2618: 1526:     CURRENT.SESS.NUM% = SOFTS.SESS.NUM%                                ! CNS
2619: 153c:     IF END # SOFTS.SESS.NUM% THEN FILE.ERROR.EXIT                      ! CNS
2620: 1558:     OPEN SOFTS.FILE.NAME$ DIRECT RECL SOFTS.RECL% \                      CNS
2621: 1585:       AS SOFTS.SESS.NUM% NOWRITE NODEL                                 ! CNS
2622: 1585: 
2623: 1585:     FILE.SIZE% = SIZE(SOFTS.FILE.NAME$)                                ! CNS
2624: 15aa: 
2625: 15aa:     IF FILE.SIZE% = 0 \ ! File is empty                                  CNS
2626: 15f0:        OR MOD(FILE.SIZE%,SOFTS.RECL%) <> 0 THEN \ ! File is corrupt      CNS
2627: 15f0:        BEGIN                                                           ! CNS
2628: 15f0:           ADXSERVE.DATA$ = "SOFTS file is corrupted"                   ! DCS
2629: 1605:           GOSUB DISPLAY.MESSAGE                                        ! DCS
2630: 1617:           FILE.OPERATION$ = "S"                                        ! CNS
2631: 162e:           GOTO FILE.ERROR.EXIT                                         ! CNS
2632: 1639:        ENDIF                                                           ! CNS
2633: 1641: 
2634: 1641:     SOFTS.REC.NUM% = FILE.SIZE% / SOFTS.RECL%                          ! CNS
2635: 1662: 
2636: 1662:     SOFTS.RECORD$ = ""                                                 ! CNS
2637: 1679: 
2638: 1679:     IF SOFTS.REC.NUM% >= 20 THEN BEGIN                                 ! CNS
2639: 1696:        SOFTS.REC.NUM% = 20                                             ! CNS
2640: 16ad:        RC% = READ.SOFTS                                                ! CNS
2641: 16bd:     ENDIF                                                              ! CNS
2642: 16c5: 
2643: 16c5:     CLOSE SOFTS.SESS.NUM%                                              ! CNS
2644: 16d9: 
2645: 16d9: RETURN                                                                 ! CNS
2646: 16e9: 
2647: 16e9: \*****************************************************************************
2648: 16e9: \***
2649: 16e9: \***    BACKUP OF CLILF AND CLOLF FILES AT EOD
2650: 16e9: \***
2651: 16e9: \***..........................................................................
2652: 16e9: 
2653: 16e9: BACKUP.CLILF.CLOLF.FILES:                                              ! OAS
2654: 16f9: 
2655: 16f9: !   GET.DATE$ = DATE$                                                  ! OAS ! PBT
2656: 16f9: 
2657: 16f9:     F02.DATE$ = DATE$                                                  ! PBT
2658: 1711:     TIME.NOW$ = TIME$                                                  ! PBT
2659: 1727:     IF TIME.NOW$ < "040000" THEN BEGIN                                 ! PBT
2660: 1742:         !If it comes here, we need to set yesterday as the backup file ! PBT
2661: 1742:         !extnesion.                                                    ! PBT
2662: 1742:         CALL UPDATE.DATE(-1) !FO2.DATE$ = FO2.DATE$ - 1Day             ! PBT
2663: 175a:     ENDIF                                                              ! PBT
2664: 1762: 
2665: 1762:     !Getting day using PSDATE FN                                       ! PBT
2666: 1762: !   CALL PSDATE(GET.DATE$)                                             ! OAS ! OBT
2667: 1762:     CALL PSDATE(F02.DATE$)                                             ! OBT
2668: 177d:     GET.DAY$ = F13.DAY$                                                ! OAS
2669: 1799: 
2670: 1799:     !First MINPRINT will backup CLILF.BIN. If CLILF backup is          ! OAS
2671: 1799:     !successful, then it will backup CLOLF.BIN                         ! OAS
2672: 1799: 
2673: 1799:     !Taking backup of CLILF.BIN                                        ! OAS
2674: 1799:     ADXSERVE.DATA$ = "Taking backup of CLILF.BIN"                      ! OAS
2675: 17ae:     GOSUB DISPLAY.MESSAGE                                              ! OAS
2676: 17c0: 
2677: 17c0:     CLILF.DDD$ = "D:\ADX_UDT1\CLILF." + GET.DAY$                       ! OAS
2678: 17e0:     CALL ADXCOPYF(ADXCOPY.CHK%,"D:\ADX_UDT1\CLILF.BIN",      \         ! OAS
2679: 1835:                                       CLILF.DDD$,0,1,0)                ! OAS
2680: 1835: 
2681: 1835:    !Checking whether backup is created or not while using ADXCOPY FN   ! OAS
2682: 1835:     IF ADXCOPY.CHK% = 0 THEN BEGIN                                     ! OAS
2683: 1853: 
2684: 1853:         ADXSERVE.DATA$ = "Backup of CLILF.BIN was completed successfully"    ! OAS
2685: 1868:         GOSUB DISPLAY.MESSAGE                                          ! OAS
2686: 187a: 
2687: 187a:         CLILF.BKUP.STATUS$ = "E"                                       ! OAS
2688: 188f: 
2689: 188f:         !Taking backup of CL0LF.BIN                                    ! OAS
2690: 188f:         ADXSERVE.DATA$ = "Taking backup of CLOLF.BIN"                  ! OAS
2691: 18a4:         GOSUB DISPLAY.MESSAGE                                          ! OAS
2692: 18b6: 
2693: 18b6:         CLOLF.DDD$ = "D:\ADX_UDT1\CLOLF." + GET.DAY$                   ! OAS
2694: 18d6:         CALL ADXCOPYF(ADXCOPY.CHK%,"D:\ADX_UDT1\CLOLF.BIN",  \         ! OAS
2695: 192b:                                           CLOLF.DDD$,0,1,0)            ! OAS
2696: 192b: 
2697: 192b:         !Checking whether backup is created using ADXCOPY FN           ! OAS
2698: 192b:         IF ADXCOPY.CHK% = 0 THEN BEGIN                                 ! OAS
2699: 1946: 
2700: 1946:            ADXSERVE.DATA$ = "Backup of CLOLF.BIN was completed successfully" ! OAS
2701: 195b:            GOSUB DISPLAY.MESSAGE                                       ! OAS
2702: 196d:            CLOLF.BKUP.STATUS$ = "E"                                    ! OAS
2703: 1984: 
2704: 1984:         ENDIF ELSE BEGIN                                               ! OAS
2705: 198c: 
2706: 198c:            ADXSERVE.DATA$ = "*****ERROR: Could not backup CLOLF.BIN*****"    ! OAS
2707: 19a1:            GOSUB DISPLAY.MESSAGE                                       ! OAS
2708: 19b3: 
2709: 19b3:         ENDIF                                                          ! OAS
2710: 19bd: 
2711: 19bd:     ENDIF ELSE BEGIN                                                   ! OAS
2712: 19c5: 
2713: 19c5:        ADXSERVE.DATA$ = "*****ERROR: Could not backup CLILF.BIN  *****"! OAS
2714: 19da:        GOSUB DISPLAY.MESSAGE                                           ! OAS
2715: 19ec: 
2716: 19ec:        ADXSERVE.DATA$ = "*****ERROR: So CLOLF.BIN backup not done*****"! OAS
2717: 1a01:        GOSUB DISPLAY.MESSAGE                                           ! OAS
2718: 1a13: 
2719: 1a13:     ENDIF                                                              ! OAS
2720: 1a1b: 
2721: 1a1b: RETURN                                                                 ! OAS
2722: 1a2b: 
2723: 1a2b: \*****************************************************************************
2724: 1a2b: \***
2725: 1a2b: \***    RF PROCESS
2726: 1a2b: \***
2727: 1a2b: \***    Open RFSCF
2728: 1a2b: \***    Read RFSCF
2729: 1a2b: \***    Create CLILF & CLOLF
2730: 1a2b: \***    Read through RPRPT and extract required information
2731: 1a2b: \***    Write to CLILF & CLOLF files
2732: 1a2b: \***..........................................................................
2733: 1a2b: 
2734: 1a2b: RF.PROCESS:                                                            ! CNS
2735: 1a3b: 
2736: 1a3b:       ADXSERVE.DATA$ = "RF.PROCESS"                                    ! DCS
2737: 1a50:       GOSUB DISPLAY.MESSAGE                                            ! DCS
2738: 1a62: 
2739: 1a62:       GOSUB PROCESS.RFSCF                                              ! LJT
2740: 1a74: 
2741: 1a74:       FILE.OPERATION$ = "O"                                            ! CNS
2742: 1a8b: 
2743: 1a8b:       IF RC% = 1 THEN BEGIN                                            ! CNS
2744: 1a9a:          DO.MAIN = 1                                                   ! CNS
2745: 1aa7:          GOTO END.RF.PROCESS                                           ! CNS
2746: 1ab2:       ENDIF                                                            ! CNS
2747: 1aba: 
2748: 1aba:       ADXSERVE.DATA$ = "Create CLILF file"                             ! DCS
2749: 1acf:       GOSUB DISPLAY.MESSAGE                                            ! DCS
2750: 1ae1:       CURRENT.SESS.NUM% = CLILF.SESS.NUM%                              ! CNS
2751: 1af7:       IF END# CLILF.SESS.NUM% THEN CREATE.ERROR                        ! CNS
2752: 1b13:       CREATE POSFILE CLILF.FILE.NAME$ KEYED 6,,,10000 RECL CLILF.RECL% \ FCS
2753: 1b4a:              AS CLILF.SESS.NUM% MIRRORED PERUPDATE                     ! CNS
2754: 1b4a: 
2755: 1b4a:       ADXSERVE.DATA$ = "Create CLOLF file"                             ! DCS
2756: 1b5f:       GOSUB DISPLAY.MESSAGE                                            ! DCS
2757: 1b71:       CURRENT.SESS.NUM% = CLOLF.SESS.NUM%                              ! CNS
2758: 1b87:       IF END# CLOLF.SESS.NUM% THEN CREATE.ERROR                        ! CNS
2759: 1ba3:       CREATE POSFILE CLOLF.FILE.NAME$ DIRECT 0 RECL CLOLF.RECL%        \ MJT
2760: 1bd6:              AS CLOLF.SESS.NUM% MIRRORED ATCLOSE                       ! CNS
2761: 1bd6: 
2762: 1bd6:       !Commenting the below section as it not required anymore
2763: 1bd6:       !ADXSERVE.DATA$ = "Open ISF file"                                ! DCS !OAS
2764: 1bd6:       !GOSUB DISPLAY.MESSAGE                                           ! DCS !OAS
2765: 1bd6:       !CURRENT.SESS.NUM% = ISF.SESS.NUM%                               ! CNS !OAS
2766: 1bd6:       !IF END #ISF.SESS.NUM% THEN FILE.ERROR.EXIT                      ! CNS !OAS
2767: 1bd6:       !OPEN ISF.FILE.NAME$ KEYED RECL ISF.RECL% AS ISF.SESS.NUM%       \ CNS !OAS
2768: 1bd6:       !   NOWRITE NODEL                                                ! CNS !OAS
2769: 1bd6: 
2770: 1bd6:       !ADXSERVE.DATA$ = "Open IRF file"                                ! DCS !OAS
2771: 1bd6:       !GOSUB DISPLAY.MESSAGE                                           ! DCS !OAS
2772: 1bd6:       !CURRENT.SESS.NUM% = IRF.SESS.NUM%                               ! CNS !OAS
2773: 1bd6:       !IF END #IRF.SESS.NUM% THEN FILE.ERROR.EXIT                      ! CNS !OAS
2774: 1bd6:       !OPEN IRF.FILE.NAME$ KEYED RECL IRF.RECL% AS IRF.SESS.NUM%       \ CNS !OAS
2775: 1bd6:       !   NOWRITE NODEL                                                ! CNS !OAS
2776: 1bd6: 
2777: 1bd6:       ADXSERVE.DATA$ = "Open IDF file"                                 ! DCS
2778: 1beb:       GOSUB DISPLAY.MESSAGE                                            ! DCS
2779: 1bfd:       CURRENT.SESS.NUM% = IDF.SESS.NUM%                                ! CNS
2780: 1c13:       IF END #IDF.SESS.NUM% THEN FILE.ERROR.EXIT                       ! CNS
2781: 1c2f:       OPEN IDF.FILE.NAME$ KEYED RECL IDF.RECL% AS IDF.SESS.NUM%        \ CNS
2782: 1c5c:          NODEL                                                         ! CNS
2783: 1c5c: 
2784: 1c5c:       ADXSERVE.DATA$ = "Open RPRPT file"                               ! DCS
2785: 1c71:       GOSUB DISPLAY.MESSAGE                                            ! DCS
2786: 1c83:       CURRENT.SESS.NUM% = RPRPT.SESS.NUM%                              ! CNS
2787: 1c9a:       IF END # RPRPT.SESS.NUM% THEN FILE.ERROR.EXIT                    ! CNS
2788: 1cb8: 
2789: 1cb8:       OPEN RPRPT.FILE.NAME$ AS RPRPT.SESS.NUM%                         ! CNS
2790: 1ce1: 
2791: 1ce1:       IF END #RPRPT.SESS.NUM% THEN RPRPT.EOF                           ! CNS
2792: 1cff: 
2793: 1cff:       ADXSERVE.DATA$ = "Open PGF file"                                 ! KMG
2794: 1d14:       GOSUB DISPLAY.MESSAGE                                            ! KMG
2795: 1d26:       CURRENT.SESS.NUM% = PGF.SESS.NUM%                                ! KMG
2796: 1d3c:       IF END #PGF.SESS.NUM% THEN FILE.ERROR.EXIT                       ! KMG
2797: 1d58:       OPEN PGF.FILE.NAME$ KEYED RECL PGF.RECL% AS PGF.SESS.NUM%        \ KMG
2798: 1d85:          NOWRITE NODEL                                                 ! KMG
2799: 1d85: 
2800: 1d85:       ADXSERVE.DATA$ = "Open MINLS file"                               ! LJT
2801: 1d9a:       GOSUB DISPLAY.MESSAGE                                            ! LJT
2802: 1dac:       CURRENT.SESS.NUM% = MINLS.SESS.NUM%                              ! LJT
2803: 1dc2:       IF END #MINLS.SESS.NUM% THEN FILE.ERROR.EXIT                     ! LJT
2804: 1dde:       OPEN MINLS.FILE.NAME$ KEYED RECL MINLS.RECL% AS MINLS.SESS.NUM%  ! LJT
2805: 1e0a: 
2806: 1e0a:       ADXSERVE.DATA$ = "Open SRITML file"                              ! OAS
2807: 1e1f:       GOSUB DISPLAY.MESSAGE                                            ! OAS
2808: 1e31:       CURRENT.SESS.NUM% = SRITL.SESS.NUM%                              ! OAS
2809: 1e47:       IF END #SRITL.SESS.NUM% THEN FILE.ERROR.EXIT                     ! OAS
2810: 1e63:       OPEN SRITL.FILE.NAME$ KEYED RECL SRITL.RECL% AS SRITL.SESS.NUM%  \ OAS
2811: 1e90:          NOWRITE NODEL
2812: 1e90: 
2813: 1e90:       ADXSERVE.DATA$ = "Set CLOLF/CLILF default values"                ! DCS
2814: 1ea5:       GOSUB DISPLAY.MESSAGE                                            ! DCS
2815: 1eb7:       EOF = 0                                                          ! CNS
2816: 1ec4: 
2817: 1ec4:      !OLD variables which are commented are put together,              ! OAS
2818: 1ec4:      !so that it can be taken out easily during the next release
2819: 1ec4:      !OLD.BULETT$ = " "                                                ! CNS ! OAS
2820: 1ec4:      !OLD.PGNAME$ = " "                                                ! ICC ! OAS
2821: 1ec4:      !CLOLF.CNTDATE$ = "19850101"                                      ! CNS ! OAS
2822: 1ec4:      !CLOLF.LISTID$ = "001"                                            ! CNS ! OAS
2823: 1ec4:      !CLOLF.HOLISTID$ = "0000"                                         ! CNS ! OAS
2824: 1ec4:      !CLOLF.OSSRITEMS$ = "000"                                         ! KMG ! OAS
2825: 1ec4:      !CLILF.BSCNT$ = "-001"                                            ! CNS ! OAS
2826: 1ec4:      !CLILF.SFCNT$ = "-001"                                            ! CNS ! OAS
2827: 1ec4:      !CLILF.SALESSFCNT$ = "0000"                                       ! CNS ! OAS
2828: 1ec4:      !CLILF.HO.SEQNO$   = "00"                                         ! FCS ! OAS
2829: 1ec4:      !CLILF.FILLER$ = "   "                                            ! CNS ! JMG
2830: 1ec4:      !CLILF.OSSR.ITMSTKCNT$ = "-001"                                   ! JMG ! OAS
2831: 1ec4:      !CLOLF.ACTIVE.STATUS$ = " "                                       ! CNS ! OAS
2832: 1ec4: 
2833: 1ec4:       LIST.ITEMS = 1                                                   ! CNS
2834: 1ed2:       CLOLF.LISTID$ = "001"                    !Set to one             !     ! OAS
2835: 1ee9:       CLOLF.USERID$ = "000"                    !Set to zero            ! KMG ! OAS
2836: 1f00:       CLOLF.LSTTYP$ = "R"                      !Recount List           ! CNS ! OAS
2837: 1f17:       CLOLF.BULETT$ = " "                      !Set to space           !     ! OAS
2838: 1f2e:       CLOLF.LIST.NAME$ = "Recount List                  "              !     ! OAS
2839: 1f45:       CLOLF.PICKER.USER.ID$ = "000"            !Initialise to zero     !     ! OAS
2840: 1f5c:       CLOLF.ACTIVE.STATUS$ = "I"               !Initial                !     ! OAS
2841: 1f73:       CLOLF.PILST.ID$ = "0000"                 !Set to zero            !     ! OAS
2842: 1f8a:       CLOLF.EXPIRY.DATE$ = PACK$("000000")     !Set to zero            !     ! OAS
2843: 1fa6:       CLOLF.PICK.START.TIME$ = PACK$("0000")   !Set to zero            !     ! OAS
2844: 1fc2:       CLOLF.PICK.END.TIME$ = PACK$("0000")     !Set to zero            !     ! OAS
2845: 1fde:       CLOLF.CURRENT.LOCATION$ = " "            !Set to space           !     ! OAS
2846: 1ff5: 
2847: 1ff5:       CLOLF.RECORD.NUM% = 1         !REC position to write to CLOLF    ! CNS
2848: 200c: 
2849: 200c:       CLILF.HO.SEQNO$   = "00"                 !Set to zero            !     ! OAS
2850: 2023:       CLILF.COUNTED.STATUS$ = "U"              !Not Counted            !     ! OAS
2851: 203a:       CLILF.DATE.LASTCNT$ = PACK$("000000")    !Set to zero            !     ! OAS
2852: 2056:       CLILF.SALESCNT% = 0                      !Set to zero            !     ! OAS
2853: 2067:       CLILF.BSCNT% = -1                        !Set to -1              !     ! OAS
2854: 2078:       CLILF.OSSR.ITMSTKCNT% = -1               !Set to -1              !     ! OAS
2855: 2089:       CLILF.BS.PEND.SA.CNT% = -1               !Set to -1              !     ! OAS
2856: 209a:       CLILF.OSSR.PEND.SA.CNT% = -1             !Set to -1              !     ! OAS
2857: 20ab:       CLILF.SFCNT% = -1                        !Set to -1              !     ! OAS
2858: 20bc:       CLILF.SPACE$ = STRING$(16," ")                                   !     ! OAS
2859: 20da: 
2860: 20da:       ADXSERVE.DATA$ = "Start of Report File processing"               ! DCS
2861: 20ef:       GOSUB DISPLAY.MESSAGE                                            ! DCS
2862: 2101: 
2863: 2101:       WHILE NOT EOF                                                    ! CNS
2864: 210c: 
2865: 210c:          READ #RPRPT.SESS.NUM%; RPRPT.RECORD$                          ! CNS
2866: 2132: 
2867: 2132:         !CLOLF.BULETT$ = LEFT$(RPRPT.RECORD$,1)                        ! CNS ! OAS
2868: 2132:         !Getting the Business Center letter                            ! OAS
2869: 2132:         BSNS.CNTR$ = LEFT$(RPRPT.RECORD$,1)                            ! OAS
2870: 2154: 
2871: 2154:         !IF CLOLF.BULETT$ >= "A" AND CLOLF.BULETT$ <= "Z" THEN BEGIN   ! CNS ! OAS
2872: 2154: 
2873: 2154:         IF BSNS.CNTR$ >= "A" AND BSNS.CNTR$ <= "Z" THEN BEGIN
2874: 21a3:            IF MID$(RPRPT.RECORD$,2,1) = " " THEN BEGIN                 ! CNS
2875: 21d8:               GOSUB EXTRACT.FIELDS                                     ! CNS
2876: 21ea:               !ISF.BOOTS.CODE$ = PACK$("0" + CLILF.BOOTSCODE$)         ! CNS ! OAS
2877: 21ea:               !ISF.S.E.DESC$ = "X "                                    ! HBG ! OAS
2878: 21ea:               !RC% = READ.ISF                                          ! CNS ! OAS
2879: 21ea: 
2880: 21ea:               !Removed the addition of "0" in CLILF.BOOTSCODE$ as      ! OAS
2881: 21ea:               !the new boots code contains 8 digits
2882: 21ea: 
2883: 21ea:               !MINLS.ITEM.CODE$ = PACK$("0" + CLILF.BOOTSCODE$)        ! LJT ! OAS
2884: 21ea:               MINLS.ITEM.CODE$ = PACK$(CLILF.BOOTSCODE$)               ! LJT ! OAS
2885: 220d: 
2886: 220d:               RC% = READ.MINLS                                         ! LJT
2887: 221d: 
2888: 221d:               IF RC% = 0 THEN BEGIN                                    ! LJT
2889: 222f:                  IF DATE.LE(UNPACK$(MINLS.RECOUNT.DATE$),DATE$)        \ LJT
2890: 2269:                     THEN BEGIN                                         ! LJT
2891: 2269:                     F02.DATE$ = UNPACK$(MINLS.RECOUNT.DATE$)           ! LJT
2892: 228c:                     CALL UPDATE.DATE(RFSCF.RECOUNT.DAYS.RETAIN%)       ! LJT
2893: 22a6: 
2894: 22a6:                     IF DATE.LE(F02.DATE$, DATE$) THEN BEGIN            ! LJT
2895: 22d0: 
2896: 22d0:                        !Setting FILE.OPERATION$ flag to "D" for        ! OAS
2897: 22d0:                        !catching any error while deleting the record   ! OAS
2898: 22d0: 
2899: 22d0:                        FILE.OPERATION$ = "D"                           ! OAS
2900: 22e7:                        DELREC MINLS.SESS.NUM%; MINLS.ITEM.CODE$        ! LJT
2901: 2306:                        FILE.OPERATION$ = " "                           ! OAS
2902: 231d: 
2903: 231d:                        !Turn off PENDING COUNT flag on the IDF         ! LJT
2904: 231d:                        IDF.BOOTS.CODE$ = MINLS.ITEM.CODE$              ! LJT
2905: 233b:                        RC% = READ.IDF                                  ! LJT
2906: 234b:                        IF RC% = 0 THEN BEGIN                           ! LJT
2907: 235a:                          !Make sure the flag is set to on first        ! LJT
2908: 235a:                          IF (IDF.BIT.FLAGS.2% AND 00000100b) <> 0      \ LJT
2909: 236f:                              THEN BEGIN                                ! LJT
2910: 236f:                              !It's on, so turn it off                  ! LJT
2911: 236f:                              IDF.BIT.FLAGS.2% = (IDF.BIT.FLAGS.2% XOR 4)!LJT
2912: 2387:                              RC% = WRITE.IDF                           ! LJT
2913: 2397:                          ENDIF                                         ! LJT
2914: 239f:                       ENDIF                                            ! LJT
2915: 23a9:                     ENDIF ELSE BEGIN                                   ! LJT
2916: 23b1:                        GOSUB VALID.ITEM                                ! CNS
2917: 23c3:                     ENDIF                                              ! LJT
2918: 23cb:                  ENDIF                                                 ! LJT
2919: 23d3:               ENDIF                                                    ! LJT
2920: 23db:            ENDIF                                                       ! CNS
2921: 23e3:         ENDIF                                                          ! OAS
2922: 23eb:         !ELSE BEGIN                                                    ! CNS ! OAS
2923: 23eb:         !   IF CLOLF.BULETT$ = "*" THEN BEGIN                          ! CNS ! OAS
2924: 23eb:         !      UPDATE.DATE$ = MID$(RPRPT.RECORD$,41,2)                 ! CNS ! OAS
2925: 23eb:         !      IF VAL(UPDATE.DATE$) > 85 THEN BEGIN                    ! CNS ! OAS
2926: 23eb:         !         UPDATE.DATE$ = "19" + UPDATE.DATE$                   ! CNS ! OAS
2927: 23eb:         !      ENDIF ELSE BEGIN                                        ! CNS ! OAS
2928: 23eb:         !         UPDATE.DATE$ = "20" + UPDATE.DATE$                   ! CNS ! OAS
2929: 23eb:         !      ENDIF                                                   ! CNS ! OAS
2930: 23eb:         !      CLOLF.CNTDATE$ = UPDATE.DATE$ +                         \ CNS ! OAS
2931: 23eb:         !                       MID$(RPRPT.RECORD$,38,2) +             \ CNS ! OAS
2932: 23eb:         !                       MID$(RPRPT.RECORD$,35,2)               ! CNS ! OAS
2933: 23eb:         !   ENDIF                                                      ! CNS ! OAS
2934: 23eb:         !ENDIF                                                         ! CNS ! OAS
2935: 23eb: 
2936: 23eb: 
2937: 23eb: RPRPT.EOF.RETURN:                                                      ! CNS
2938: 23fb: 
2939: 23fb:       WEND                                                             ! CNS
2940: 240d: 
2941: 240d:       ADXSERVE.DATA$ = "End of Report File processing"                 ! DCS
2942: 2422:       GOSUB DISPLAY.MESSAGE                                            ! DCS
2943: 2434: 
2944: 2434:       !GOSUB CREATE.NEW.LIST                                           ! CNS ! OAS
2945: 2434:       GOSUB CREATE.RECOUNT.LIST                                        ! OAS
2946: 2446: 
2947: 2446:       ADXSERVE.DATA$ = "Closing Files"                                 ! DCS
2948: 245b:       GOSUB DISPLAY.MESSAGE                                            ! DCS
2949: 246d: 
2950: 246d:       CLOSE RPRPT.SESS.NUM%                                            ! CNS
2951: 2483:       CLOSE CLILF.SESS.NUM%                                            ! CNS
2952: 2497:       CLOSE CLOLF.SESS.NUM%                                            ! CNS
2953: 24ab:       !CLOSE ISF.SESS.NUM%                                             ! CNS ! OAS
2954: 24ab:       !CLOSE IRF.SESS.NUM%                                             ! CNS ! OAS
2955: 24ab:       CLOSE IDF.SESS.NUM%                                              ! CNS
2956: 24bf:       CLOSE MINLS.SESS.NUM%                                            ! LJT
2957: 24d3:       CLOSE SRITL.SESS.NUM%                                            ! OAS
2958: 24e7:       ADXSERVE.DATA$ = "Files Closed"                                  ! DCS
2959: 24fc:       GOSUB DISPLAY.MESSAGE                                            ! DCS
2960: 250e: 
2961: 250e: END.RF.PROCESS:                                                        ! CNS
2962: 251e: 
2963: 251e: 
2964: 251e: RETURN                                                                 ! CNS
2965: 252e: 
2966: 252e: RPRPT.EOF:                                                             ! CNS
2967: 253e: 
2968: 253e:        EOF = 1                                                         ! CNS
2969: 254b:        GOTO RPRPT.EOF.RETURN                                           ! CNS
2970: 2556: 
2971: 2556: 
2972: 2556: RFSCF.OPEN.ERROR:                                                      ! CNS
2973: 2566: 
2974: 2566:        DO.MAIN = 1                                                     ! CNS
2975: 2573:        GOTO END.RF.PROCESS                                             ! CNS
2976: 257d: 
2977: 257d: \*****************************************************************************
2978: 257d: \***
2979: 257d: \***   PROCESS.RFSCF
2980: 257d: \***
2981: 257d: \***   This code was originally in RF.PROCESS, I've moved it into a subroutine
2982: 257d: \***   so that it can also be used if RF is inactive.
2983: 257d: \***
2984: 257d: \*****************************************************************************
2985: 257d: 
2986: 257d:       PROCESS.RFSCF:
2987: 258d: 
2988: 258d:       FILE.OPERATION$ = "O"                                            ! CNS
2989: 25a4: 
2990: 25a4:       ADXSERVE.DATA$ = "Open/Read/Close RFSCF file"                    ! DCS
2991: 25b9:       GOSUB DISPLAY.MESSAGE                                            ! DCS
2992: 25cb: 
2993: 25cb:       IF END #RFSCF.SESS.NUM% THEN RFSCF.OPEN.ERROR                    ! CNS
2994: 25e7:       CURRENT.SESS.NUM% = RFSCF.SESS.NUM%
2995: 25fd:       OPEN RFSCF.FILE.NAME$ DIRECT RECL RFSCF.RECL% AS RFSCF.SESS.NUM% \ DCS
2996: 262a:             NOWRITE NODEL                                              ! DCS
2997: 262a:       RC% = READ.RFSCF1                                                ! CNS
2998: 263a: 
2999: 263a:       CLOSE RFSCF.SESS.NUM%                                            ! CNS
3000: 264e: 
3001: 264e:       RETURN
3002: 265e: 
3003: 265e: \*****************************************************************************
3004: 265e: \***
3005: 265e: \***   EXTRACT FIELDS
3006: 265e: \***
3007: 265e: \*****************************************************************************
3008: 265e: EXTRACT.FIELDS:                                                        ! CNS
3009: 266e: 
3010: 266e:       !Below statements are commented out, since these are             ! OAS
3011: 266e:       !not present in the updated CLOLF file format                    ! OAS
3012: 266e:       !CLOLF.BUNAME$ = MID$(RPRPT.RECORD$,3,15)                        ! CNS ! OAS
3013: 266e:       !CLILF.PRODGRP$ = MID$(RPRPT.RECORD$,19,2) + "0" +               \ CNS ! OAS
3014: 266e:       !                 MID$(RPRPT.RECORD$,22,3)                       ! CNS ! OAS
3015: 266e:       !CLILF.PRODGRPDESC$ = MID$(RPRPT.RECORD$,28,12)                  ! CNS ! OAS
3016: 266e: 
3017: 266e:       !Adding zero to CLILF.BOOTSCODE$ to make it to 8 digit item code ! OAS
3018: 266e: 
3019: 266e:       CLILF.BOOTSCODE$ = "0" + MID$(RPRPT.RECORD$,48,2) +              \ CNS ! OAS
3020: 26d1:                          MID$(RPRPT.RECORD$,51,2) +                    \ CNS ! OAS
3021: 26d1:                          MID$(RPRPT.RECORD$,54,3)                      ! CNS ! OAS
3022: 26d1: 
3023: 26d1: RETURN                                                                 ! CNS
3024: 26e1: 
3025: 26e1: \*****************************************************************************
3026: 26e1: \***
3027: 26e1: \***   VALID ITEM
3028: 26e1: \***
3029: 26e1: \***   Extract information from IDF and IRF and write to CLILF
3030: 26e1: \***
3031: 26e1: \*****************************************************************************
3032: 26e1: VALID.ITEM:
3033: 26f1: 
3034: 26f1:        !The subroutine has undergone many changes as part of SFA project     ! OAS
3035: 26f1: 
3036: 26f1:        !CLOLF.PGNAME$ = CLILF.PRODGRPDESC$+"   "                       ! ICC ! OAS
3037: 26f1:        !IF CLOLF.PGNAME$<> OLD.PGNAME$ OR LIST.ITEMS > 30 THEN BEGIN   ! ICC ! OAS
3038: 26f1: 
3039: 26f1:        !The below IF condition is changed to restrict the                    ! OAS
3040: 26f1:        !list size to maximum of 999 records.                                 ! OAS
3041: 26f1:        !IF LIST.ITEMS > 30 THEN BEGIN                                        ! OAS
3042: 26f1:         IF LIST.ITEMS > 999 THEN BEGIN                                       ! OAS
3043: 2701:            GOSUB CREATE.RECOUNT.LIST                                   ! CNS ! OAS
3044: 2713:         ENDIF                                                          ! CNS ! OAS
3045: 271b: 
3046: 271b:        !CLILF.HO.SEQNO$ = RIGHT$(CLILF.ITEMSEQ$,2)                     ! 1.12 RC ! OAS
3047: 271b:        !CLILF.DEALMKR$ = "N"                                           ! CNS ! OAS
3048: 271b:        !CLILF.BARCODE$= RIGHT$("000000000000" + \
3049: 271b:        !                LEFT$(UNPACK$(IDF.BOOTS.CODE$),7),13)          ! FCS ! OAS
3050: 271b:        !CALL CALC.BAR.CODE.CHECK.DIGIT(RIGHT$(CLILF.BARCODE$,12))      ! FCS ! OAS
3051: 271b:        !CLILF.BARCODE$ = RIGHT$(CLILF.BARCODE$,12) + F06.CHECK.DIGIT$  ! FCS ! OAS
3052: 271b: 
3053: 271b:        CLILF.LISTID$ = CLOLF.LISTID$                                   ! CNS
3054: 2739:        CLILF.ITEMSEQ$  = RIGHT$("000" + STR$(LIST.ITEMS),3)            ! CNS
3055: 277f: 
3056: 277f:        !IDF.BOOTS.CODE$ = ISF.BOOTS.CODE$                              ! CNS ! OAS
3057: 277f:        !IDF.STNDRD.DESC$ = "UNKNOWN ITEM"                              ! FCS ! OAS
3058: 277f: 
3059: 277f:        !CLILF.DEALMKR is not present in the updated CLILF format.            ! OAS
3060: 277f:        !As CLILF.DEALMKR is not needed, the below code section is            ! OAS
3061: 277f:        !not required and hence commented                                     ! OAS
3062: 277f: 
3063: 277f:        !IRF.BAR.CODE$ = PACK$("000000000000000" + \
3064: 277f:        !                LEFT$(UNPACK$(IDF.BOOTS.CODE$),7))             ! FCS ! OAS
3065: 277f:        !RC% = READ.IDF                                                 ! CNS ! OAS
3066: 277f: 
3067: 277f:        !IF RC% = 0 THEN BEGIN
3068: 277f:          !CHECK TO SEE IF IDF HAS VALID EAN BARCODE TO REPLACE BTC BARCODE        ! FCS ! OAS
3069: 277f:          !IF IDF.FIRST.BAR.CODE$ <> PACK$("0000000000000000000000") THEN BEGIN    ! FCS ! OAS
3070: 277f:             !IF VAL(UNPACK$(IDF.NO.OF.BAR.CODES$)) > 1   \                        ! FCS ! OAS
3071: 277f:                !AND  (IDF.SECOND.BAR.CODE$ <> IRF.BAR.CODE$)  THEN BEGIN          ! FCS ! OAS
3072: 277f: 
3073: 277f:                !CALL CALC.BAR.CODE.CHECK.DIGIT(UNPACK$(IDF.SECOND.BAR.CODE$))     ! FCS ! OAS
3074: 277f: 
3075: 277f:                !CLILF.BARCODE$ = RIGHT$(UNPACK$(IDF.SECOND.BAR.CODE$) +  \        ! FCS ! OAS
3076: 277f:                !     F06.CHECK.DIGIT$,13)                                         ! FCS ! OAS
3077: 277f:                !IRF.BAR.CODE$ = PACK$("0000000000"+ UNPACK$(IDF.SECOND.BAR.CODE$))! FCS ! OAS
3078: 277f:             !ENDIF ELSE BEGIN                                                     ! FCS ! OAS
3079: 277f:                !CALL CALC.BAR.CODE.CHECK.DIGIT(UNPACK$(IDF.FIRST.BAR.CODE$))      ! FCS ! OAS
3080: 277f: 
3081: 277f:                !CLILF.BARCODE$ = RIGHT$(UNPACK$(IDF.FIRST.BAR.CODE$) +   \        ! FCS ! OAS
3082: 277f:                !     F06.CHECK.DIGIT$,13)                                         ! FCS ! OAS
3083: 277f:                !IRF.BAR.CODE$ = PACK$("0000000000"+ UNPACK$(IDF.FIRST.BAR.CODE$)) ! FCS ! OAS
3084: 277f:             !ENDIF                                                                ! FCS ! OAS
3085: 277f:          !ENDIF                                                                   ! FCS ! OAS
3086: 277f: 
3087: 277f: 
3088: 277f:          !RC% = READ.IRF                                               ! CNS ! OAS
3089: 277f:          !IF RC% = 0 THEN BEGIN                                        ! CNS ! OAS
3090: 277f:             !IF IRF.DEAL.NUM$(0) = PACK$("0000") AND \                 ! HBG ! OAS
3091: 277f:             !   IRF.DEAL.NUM$(1) = PACK$("0000") AND \                 ! HBG ! OAS
3092: 277f:             !   IRF.DEAL.NUM$(2) = PACK$("0000") THEN BEGIN            ! HBG ! OAS
3093: 277f:             !   CLILF.DEALMKR$ = "N"                                   ! HBG ! OAS
3094: 277f:             !ENDIF ELSE BEGIN                                          ! HBG ! OAS
3095: 277f:             !   CLILF.DEALMKR$ = "Y"                                   ! HBG ! OAS
3096: 277f:             !ENDIF                                                     ! HBG ! OAS
3097: 277f:          !ENDIF                                                        ! CNS ! OAS
3098: 277f:        !ENDIF                                                          ! CNS ! OAS
3099: 277f: 
3100: 277f:       ! If SEL description not available, use short one on IDF         ! HBG ! OAS
3101: 277f: 
3102: 277f:       !CLILF.SELDESC$ is not present in the updated CLILF format.            ! OAS
3103: 277f:       !The conditional statement given below is used to set the              ! OAS
3104: 277f:       !variable CLILF.SELDESC$.As CLILF.SELDESC$ is not needed,              ! OAS
3105: 277f:       !the below conditional statement is also commented.                    ! OAS
3106: 277f:       !IF UCASE$(LEFT$(ISF.S.E.DESC$,2)) = "X " OR \                   ! HBG ! OAS
3107: 277f:       !   ISF.S.E.DESC$ = STRING$(45," ") THEN BEGIN                   ! HBG ! OAS
3108: 277f:       !   CLILF.SELDESC$ = IDF.STNDRD.DESC$ + STRING$(21," ")!length 45! HBG ! OAS
3109: 277f:       !ENDIF ELSE BEGIN                                                ! HBG ! OAS
3110: 277f:       !   CLILF.SELDESC$ = ISF.S.E.DESC$                               ! CNS ! OAS
3111: 277f:       !ENDIF                                                           ! HBG ! OAS
3112: 277f: 
3113: 277f:        GOSUB PROCESS.SRITL   !To get the active planner details of an item   ! OAS
3114: 2791: 
3115: 2791:        CLILF.BOOTSCODE$ = PACK$(CLILF.BOOTSCODE$)                      ! OAS
3116: 27b4:        CURRENT.REPORT.NUM% = CLILF.REPORT.NUM%                         ! CNS
3117: 27ca:        FILE.OPERATION$ = "W"                                           ! CNS
3118: 27e1:        RC% = WRITE.CLILF                                               ! CNS
3119: 27f1:        IF RC% <> 0 THEN GOTO FILE.ERROR.EXIT                           ! CNS
3120: 2803: 
3121: 2803:        LIST.ITEMS = LIST.ITEMS + 1                                     ! CNS
3122: 280f: 
3123: 280f: RETURN
3124: 281f: 
3125: 281f: \*****************************************************************************
3126: 281f: \***
3127: 281f: \***   New functionality added -                                        ! OAS
3128: 281f: \***   PROCESS.SRITL
3129: 281f: \***   Extract information from SRITML (Active Planner Details)
3130: 281f: \***   for writing to CLILF
3131: 281f: \***
3132: 281f: \*****************************************************************************
3133: 281f: PROCESS.SRITL:
3134: 282f: 
3135: 282f:     !Initialising the details for each possible sales floor site        ! OAS
3136: 282f:     FOR COUNTER% = 0 TO 31                                              ! OAS
3137: 283f:         CLILF.MODULE.ID%(COUNTER%) = 0                                  ! OAS
3138: 2865:         CLILF.MODULE.SEQ%(COUNTER%) = 0                                 ! OAS
3139: 2884:         CLILF.REPEAT.CNT%(COUNTER%) = 0                                 ! OAS
3140: 28a3:         CLILF.COUNT%(COUNTER%) = -1                                     ! OAS
3141: 28c3:         CLILF.FILL.QUANTITY%(COUNTER%) = 0                              ! OAS
3142: 28e3:         CLILF.FILLER$(COUNTER%) = STRING$(4, " ")                       ! OAS
3143: 2910:     NEXT COUNTER%                                                       ! OAS
3144: 292a: 
3145: 292a:     !Populate the Planner ID,Module and REPEAT COUNT from SRITML        ! OAS
3146: 292a: 
3147: 292a:     !Item code without check digit                                      ! OAS
3148: 292a:     SRITL.ITEM.CODE$ = PACK$(MID$(CLILF.BOOTSCODE$,2, 6))               ! OAS
3149: 2956: 
3150: 2956:     SRITL.RECORD.CHAIN% = 0                                             ! OAS
3151: 2966:     RC% = READ.SRITL                                                    ! OAS
3152: 2976:     RECORD.COUNT% = 0                                                   ! OAS
3153: 298b: 
3154: 298b:     WHILE RC% = 0                                                       ! OAS
3155: 2996: 
3156: 2996:         !For each module key                                                   ! OAS
3157: 2996:         FOR LOOPCNT% = 0 TO SRITL.MAX.MOD.KEYS% - 1                            ! OAS
3158: 29a7:             IF SRITL.POGDB%(LOOPCNT%) AND     \                                ! OAS
3159: 2a01:                RECORD.COUNT% <= 32 THEN BEGIN                                  ! OAS
3160: 2a01:                !32 is the maximum limit in CLILF                               ! OAS
3161: 2a01:                 CLILF.MODULE.ID%(RECORD.COUNT%) = SRITL.POGDB%(LOOPCNT%)       ! OAS
3162: 2a3a:                 CLILF.MODULE.SEQ%(RECORD.COUNT%) = SRITL.MODULE.SEQ%(LOOPCNT%) ! OAS
3163: 2a76:                 CLILF.REPEAT.CNT%(RECORD.COUNT%) = SRITL.REPEAT.CNT%(LOOPCNT%) ! OAS
3164: 2ab2:                 RECORD.COUNT% = RECORD.COUNT% + 1                              ! OAS
3165: 2acd:             ENDIF ELSE BEGIN                                                   ! OAS
3166: 2ad5:                 LOOPCNT% = SRITL.MAX.MOD.KEYS%   !To quit the FOR Loop         ! OAS
3167: 2ae7:                 RC% = 1                          !To quit the While Loop       ! OAS
3168: 2af5:             ENDIF                                                              ! OAS
3169: 2afd:         NEXT LOOPCNT%                                                          ! OAS
3170: 2b1d: 
3171: 2b1d:         !Read the next record chain from SRITEM if the FOR loop         ! OAS
3172: 2b1d:         !is exited normally                                             ! OAS
3173: 2b1d: 
3174: 2b1d:         IF (RECORD.COUNT% <= 32) AND (RC% = 0) THEN BEGIN               ! OAS
3175: 2b4a:             !32 is the maximum limit in CLILF                           ! OAS
3176: 2b4a:             SRITL.RECORD.CHAIN% = SRITL.RECORD.CHAIN% + 1               ! OAS
3177: 2b59:             RC% = READ.SRITL                                            ! OAS
3178: 2b6c:         ENDIF ELSE IF RECORD.COUNT% > 32 THEN BEGIN                     ! OAS
3179: 2b85:             !CLILF cannot accomodate > 32                               ! OAS
3180: 2b85:             ADXSERVE.DATA$ = "Error: Item " + CLILF.BOOTSCODE$          ! OAS
3181: 2ba8:             GOSUB DISPLAY.MESSAGE                                       ! OAS
3182: 2bba:             ADXSERVE.DATA$ = "       CLILF can only accomodate 32 sites"! OAS
3183: 2bcf:             GOSUB DISPLAY.MESSAGE                                       ! OAS
3184: 2be1:         ENDIF                                                           ! OAS
3185: 2be9: 
3186: 2be9:     WEND                                                                ! OAS
3187: 2bfb: 
3188: 2bfb: RETURN                                                                  ! OAS
3189: 2c0b: 
3190: 2c0b: \*****************************************************************************
3191: 2c0b: \***
3192: 2c0b: \***   CREATE RECOUNT LIST                                             ! OAS - Changed the subroutine name
3193: 2c0b: \***
3194: 2c0b: \*****************************************************************************
3195: 2c0b: !Renamed the sub routine CREATE.NEW.LIST to CREATE.RECOUNT.LIST        ! OAS
3196: 2c0b: CREATE.RECOUNT.LIST:
3197: 2c1b:        !Grouping all the variables commented since they were not in    ! OAS
3198: 2c1b:        !the new CLOLF RECORD. Need to remove these in the next release ! OAS
3199: 2c1b:        !IF OLD.PGNAME$ <> " " THEN BEGIN                               ! ICC
3200: 2c1b:          !CLOLF.SRITEMS$ = RIGHT$("000" + STR$(LIST.ITEMS - 1),3)      ! CNS ! OAS
3201: 2c1b:          !ADXSERVE.DATA$ = "CREATE.NEW.LIST: " + CLOLF.LISTID$         ! DCS ! OAS
3202: 2c1b:          !CLOLF.BSITEMS$ = CLOLF.SRITEMS$                              ! CNS ! OAS
3203: 2c1b:          !CLOLF.TOTAL.ITEMS$ = CLOLF.SRITEMS$                          ! FCS ! OAS
3204: 2c1b:          !CLOLF.OSSRITEMS$ = CLOLF.SRITEMS$                            ! KMG ! OAS
3205: 2c1b:          !CLOLF.BULETT$ = OLD.BULETT$                                  ! CNS ! OAS
3206: 2c1b:          !CLOLF.PGNAME$ = OLD.PGNAME$                                  ! ICC
3207: 2c1b:          !CLOLF.BUNAME$ = CLOLF.PGNAME$                                ! ICC  - Assignment needed to BUNAME as 1
3208: 2c1b:                                                                        ! this is the var the WRITE.CLOLF
3209: 2c1b:                                                                        ! uses to write to the relevant part of
3210: 2c1b:                                                                        ! the CLOLF record
3211: 2c1b:         IF (LIST.ITEMS <= 1) THEN BEGIN \! If no list to populate      ! OAS
3212: 2c2a:             ADXSERVE.DATA$ = "No list to create"                       ! OAS
3213: 2c3f:             GOSUB DISPLAY.MESSAGE
3214: 2c54:         ENDIF \                                                        ! OAS
3215: 2c54:         ELSE BEGIN
3216: 2c5c:             ADXSERVE.DATA$ = "CLOLF.LISTID: " + CLOLF.LISTID$          ! OAS
3217: 2c7f:             GOSUB DISPLAY.MESSAGE                                      ! DCS
3218: 2c91:             CLOLF.TOTAL.ITEMS% = LIST.ITEMS - 1                        ! OAS
3219: 2ca4:             CLOLF.SRITEMS% = CLOLF.TOTAL.ITEMS%                        ! OAS
3220: 2cba:             CLOLF.BSITEMS% = CLOLF.TOTAL.ITEMS%                        ! OAS
3221: 2cd0:             CLOLF.OSSRITEMS% = CLOLF.TOTAL.ITEMS%                      ! OAS
3222: 2ce6:             CURRENT.REPORT.NUM% = CLOLF.REPORT.NUM%                    ! CNS
3223: 2cfc:             FILE.OPERATION$ = "W"                                      ! CNS
3224: 2d13:             CLOLF.CREATION.DATE$ = PACK$(DATE$)                        ! OAS
3225: 2d30:             CLOLF.CREATION.TIME$ = PACK$(LEFT$(TIME$,4))               ! OAS
3226: 2d61: 
3227: 2d61:             RC% = WRITE.CLOLF                                          ! CNS
3228: 2d71:             IF RC% <> 0 THEN GOTO FILE.ERROR.EXIT                      ! CNS
3229: 2d83: 
3230: 2d83:             !Grouping all the variables commented since they were not in the
3231: 2d83:             !new CLOLF RECORD. Need to remove these in the next release
3232: 2d83:             !CLOLF.OSSRITEMS$ = "000"                                  ! KMG ! OAS
3233: 2d83:             !CLOLF.BULETT$ = LEFT$(RPRPT.RECORD$,1)                    ! CNS ! OAS
3234: 2d83:             !CLOLF.PGNAME$ = MID$(RPRPT.RECORD$,28,12)+"   "           ! ICC ! OAS
3235: 2d83: 
3236: 2d83:             CLOLF.RECORD.NUM% = CLOLF.RECORD.NUM% + 1                  ! CNS
3237: 2d9c:             CLOLF.LISTID$ = RIGHT$("000" + STR$(VAL(CLOLF.LISTID$) + 1),3)!CNS
3238: 2e0c:             LIST.ITEMS = 1                                             ! CNS
3239: 2e1a: 
3240: 2e1a:         ENDIF
3241: 2e22:        !ENDIF                                                          ! CNS ! OAS
3242: 2e22: 
3243: 2e22:          !Commented since they were not in the new CLOLF RECORD.       ! OAS
3244: 2e22:          !Need to remove these in the next release                     ! OAS
3245: 2e22:          !OLD.BULETT$ = CLOLF.BULETT$                                  ! CNS ! OAS
3246: 2e22:          !OLD.PGNAME$ = CLOLF.PGNAME$                                  ! ICC ! OAS
3247: 2e22: 
3248: 2e22: RETURN
3249: 2e32: 
3250: 2e32: 
3251: 2e32: 
3252: 2e32: \*******************************************************************   ! OAS
3253: 2e32: \***    Display background message                                     ! OAS
3254: 2e32: \***................................................................   ! OAS
3255: 2e32: 
3256: 2e32: DISPLAY.MESSAGE:                                                       ! DCS
3257: 2e42:                                                                        ! DCS
3258: 2e42:      IF COMM.MODE.FLAG$ = "B" THEN BEGIN                               ! DCS
3259: 2e60:          ADX.INTEGER%  = 0                                             ! DCS
3260: 2e6e:          ADX.FUNCTION% = 26                                            ! DCS
3261: 2e7c:          CALL ADXSERVE (ADX.RETURN.CODE%,                              \ DCS
3262: 2e9e:                         ADX.FUNCTION%,                                 \ DCS
3263: 2e9e:                         ADX.INTEGER%,                                  \ DCS
3264: 2e9e:                         ADXSERVE.DATA$)                                ! DCS
3265: 2e9e:      ENDIF ELSE BEGIN                                                  ! DCS
3266: 2ea6:         PRINT ADXSERVE.DATA$                                           ! DCS
3267: 2ebb:      ENDIF                                                             ! DCS
3268: 2ec3: RETURN                                                                 ! DCS
3269: 2ed3: 
3270: 2ed3: \*****************************************************************************
3271: 2ed3: \***
3272: 2ed3: \***    TERMINATION
3273: 2ed3: \***
3274: 2ed3: \***..........................................................................
3275: 2ed3: 
3276: 2ed3: 
3277: 2ed3: TERMINATION:
3278: 2ee3: 
3279: 2ee3:     ADXSERVE.DATA$ = "TERMINATION"                                     ! DCS
3280: 2ef8:     GOSUB DISPLAY.MESSAGE                                              ! DCS
3281: 2f0a: 
3282: 2f0a:     GOSUB DEALLOCATE.SESSION.NUMBERS
3283: 2f1c: 
3284: 2f1c: RETURN
3285: 2f2c: 
3286: 2f2c: 
3287: 2f2c: 
3288: 2f2c: \*****************************************************************************
3289: 2f2c: \***
3290: 2f2c: \***    TERMINATION SPECIFIC ROUTINES
3291: 2f2c: \***
3292: 2f2c: \***..........................................................................
3293: 2f2c: 
3294: 2f2c: 
3295: 2f2c: \*****************************************************************************
3296: 2f2c: \***
3297: 2f2c: \***    DEALLOCATE.SESSION.NUMBERS
3298: 2f2c: \***    Perform CALL.F20.SESS.NUM.UTILITY to de-allocate file session numbers
3299: 2f2c: \***    from all files referenced by the program.
3300: 2f2c: \***
3301: 2f2c: \***..........................................................................
3302: 2f2c: 
3303: 2f2c: 
3304: 2f2c: DEALLOCATE.SESSION.NUMBERS:
3305: 2f3c: 
3306: 2f3c: 
3307: 2f3c:     ADXSERVE.DATA$ = "DEALLOCATE.SESSION.NUMBERS"                      ! DCS
3308: 2f51:     GOSUB DISPLAY.MESSAGE                                              ! DCS
3309: 2f63: 
3310: 2f63:     FUNCTION.FLAG$ EQ "C"
3311: 2f78: 
3312: 2f78:     PASSED.INTEGER% EQ RPRPT.SESS.NUM%
3313: 2f8b:     PASSED.STRING$ EQ ""
3314: 2fa0:     GOSUB CALL.F20.SESS.NUM.UTILITY
3315: 2fb2: 
3316: 2fb2:     PASSED.INTEGER% = PRINT.SESS.NUM%
3317: 2fc4:     PASSED.STRING$ = ""
3318: 2fd9:     GOSUB CALL.F20.SESS.NUM.UTILITY
3319: 2feb: 
3320: 2feb:     PASSED.INTEGER% = SOFTS.SESS.NUM%                                  ! CNS
3321: 2ffd:     PASSED.STRING$ = ""                                                ! CNS
3322: 3012:     GOSUB CALL.F20.SESS.NUM.UTILITY                                    ! CNS
3323: 3024: 
3324: 3024:     PASSED.INTEGER% = RFSCF.SESS.NUM%                                  ! CNS
3325: 3036:     PASSED.STRING$ = ""                                                ! CNS
3326: 304b:     GOSUB CALL.F20.SESS.NUM.UTILITY                                    ! CNS
3327: 305d: 
3328: 305d:     PASSED.INTEGER% = CLOLF.SESS.NUM%                                  ! CNS
3329: 306f:     PASSED.STRING$ = ""                                                ! CNS
3330: 3084:     GOSUB CALL.F20.SESS.NUM.UTILITY                                    ! CNS
3331: 3096: 
3332: 3096:     PASSED.INTEGER% = CLILF.SESS.NUM%                                  ! CNS
3333: 30a8:     PASSED.STRING$ = ""                                                ! CNS
3334: 30bd:     GOSUB CALL.F20.SESS.NUM.UTILITY                                    ! CNS
3335: 30cf: 
3336: 30cf:     !PASSED.INTEGER% = ISF.SESS.NUM%                                   ! CNS ! OAS
3337: 30cf:     !PASSED.STRING$ = ""                                               ! CNS ! OAS
3338: 30cf:     !GOSUB CALL.F20.SESS.NUM.UTILITY                                   ! CNS ! OAS
3339: 30cf: 
3340: 30cf:     !PASSED.INTEGER% = IRF.SESS.NUM%                                   ! CNS ! OAS
3341: 30cf:     !PASSED.STRING$ = ""                                               ! CNS ! OAS
3342: 30cf:     !GOSUB CALL.F20.SESS.NUM.UTILITY                                   ! CNS ! OAS
3343: 30cf: 
3344: 30cf:     PASSED.INTEGER% = IDF.SESS.NUM%                                    ! CNS
3345: 30e1:     PASSED.STRING$ = ""                                                ! CNS
3346: 30f6:     GOSUB CALL.F20.SESS.NUM.UTILITY                                    ! CNS
3347: 3108: 
3348: 3108:     PASSED.INTEGER% = MINLS.SESS.NUM%                                  ! LJT
3349: 311a:     PASSED.STRING$ = ""                                                ! LJT
3350: 312f:     GOSUB CALL.F20.SESS.NUM.UTILITY                                    ! LJT
3351: 3141: 
3352: 3141:     PASSED.INTEGER% = SRITL.SESS.NUM%                                  ! OAS
3353: 3153:     PASSED.STRING$ = ""                                                ! OAS
3354: 3168:     GOSUB CALL.F20.SESS.NUM.UTILITY                                    ! OAS
3355: 317a: 
3356: 317a:     PASSED.INTEGER% = MINOK.SESS.NUM%                                  ! OAS
3357: 3188:     PASSED.STRING$ = ""                                                ! OAS
3358: 319d:     GOSUB CALL.F20.SESS.NUM.UTILITY                                    ! OAS
3359: 31af: 
3360: 31af:     ADXSERVE.DATA$ = "Session numbers deallocated"                     ! DCS
3361: 31c4:     GOSUB DISPLAY.MESSAGE                                              ! DCS
3362: 31d6: 
3363: 31d6: RETURN
3364: 31e6: 
3365: 31e6: 
3366: 31e6: \*****************************************************************************
3367: 31e6: \***
3368: 31e6: \***    CHECK.FUNCTION.RETURN.CODE:
3369: 31e6: \***    If FUNCTION.RETURN.CODE% is zero ...
3370: 31e6: \***        By-passes rest of procedure.
3371: 31e6: \***    Displays error message on background screen.
3372: 31e6: \***    Stops program.
3373: 31e6: \***
3374: 31e6: \***..........................................................................
3375: 31e6: 
3376: 31e6: 
3377: 31e6: CHECK.FUNCTION.RETURN.CODE:
3378: 31f6: 
3379: 31f6:     IF FUNCTION.RETURN.CODE% EQ 0 THEN \
3380: 3208:         BEGIN
3381: 3208:         RETURN
3382: 3218:         ENDIF
3383: 3220: 
3384: 3220:     GOSUB STOP.PROGRAM
3385: 3232: 
3386: 3232: RETURN
3387: 3242: 
3388: 3242: 
3389: 3242: \*****************************************************************************
3390: 3242: \***
3391: 3242: \***    FORMAT.CURRENT.CODE:
3392: 3242: \***    Sets CURRENT.CODE.LOGGED$ for use with application event log.
3393: 3242: \***
3394: 3242: \***..........................................................................
3395: 3242: 
3396: 3242: 
3397: 3242: FORMAT.CURRENT.CODE:
3398: 3252: 
3399: 3252:     IF FILE.OPERATION$ EQ "C"                            \ ! Create
3400: 32a4:       OR FILE.OPERATION$ EQ "O" THEN                     \ ! Open
3401: 32a4:     BEGIN
3402: 32a4:         CURRENT.CODE.LOGGED$ EQ PACK$("00000000000000")
3403: 32be:     ENDIF
3404: 32c6: 
3405: 32c6:     IF FILE.OPERATION$ EQ "R"                            \ ! Read
3406: 3318:       OR FILE.OPERATION$ EQ "W" THEN                     \ ! Write
3407: 3318:     BEGIN
3408: 3318:         CURRENT.CODE.LOGGED$ EQ RIGHT$(CURRENT.CODE$,7)
3409: 333b:     ENDIF
3410: 3343: 
3411: 3343: RETURN
3412: 3353: 
3413: 3353: 
3414: 3353: 
3415: 3353: \*****************************************************************************
3416: 3353: \***
3417: 3353: \***    PROGRAM INDEPENDENT ROUTINES
3418: 3353: \***
3419: 3353: \***..........................................................................
3420: 3353: 
3421: 3353: 
3422: 3353: \*****************************************************************************
3423: 3353: \***
3424: 3353: \***    CALL.F01.APPLICATION.LOG:
3425: 3353: \***    References APPLICATION.LOG (F01) to write details of event defined
3426: 3353: \***    by EVENT.NUMBER% and VAR.STRING.1$ to Application Event Log, and to
3427: 3353: \***    display any message defined by MESSAGE.NUMBER% and VAR.STRING.2$.
3428: 3353: \***
3429: 3353: \***..........................................................................
3430: 3353: 
3431: 3353: 
3432: 3353: CALL.F01.APPLICATION.LOG:
3433: 3363: 
3434: 3363: 
3435: 3363:     FUNCTION.RETURN.CODE% EQ \
3436: 3393:       APPLICATION.LOG \
3437: 3393:        (MESSAGE.NUMBER%, \
3438: 3393:         VAR.STRING.1$, \
3439: 3393:         VAR.STRING.2$, \
3440: 3393:         EVENT.NUMBER%)
3441: 3393: 
3442: 3393:     GOSUB CHECK.FUNCTION.RETURN.CODE
3443: 33a5: 
3444: 33a5: RETURN
3445: 33b5: 
3446: 33b5: 
3447: 33b5: \*****************************************************************************
3448: 33b5: \***
3449: 33b5: \***    CALL.F20.SESS.NUM.UTILITY:
3450: 33b5: \***    References SESS.NUM.UTILITY (F20) to create, read, or delete entry on
3451: 33b5: \***    Session Number Table as determined by FUNCTION.FLAG$ ("O" "R" "C").
3452: 33b5: \***
3453: 33b5: \***..........................................................................
3454: 33b5: 
3455: 33b5: 
3456: 33b5: CALL.F20.SESS.NUM.UTILITY:
3457: 33c5: 
3458: 33c5: 
3459: 33c5:     FUNCTION.RETURN.CODE% EQ \
3460: 33f0:       SESS.NUM.UTILITY \
3461: 33f0:        (FUNCTION.FLAG$, \
3462: 33f0:         PASSED.INTEGER%, \
3463: 33f0:         PASSED.STRING$)
3464: 33f0: 
3465: 33f0:     GOSUB CHECK.FUNCTION.RETURN.CODE
3466: 3402: 
3467: 3402:     IF FUNCTION.FLAG$ = "R" THEN CURRENT.REPORT.NUM% = F20.INTEGER.FILE.NO% !HBG
3468: 342b: 
3469: 342b: RETURN
3470: 343b: 
3471: 343b: 
3472: 343b: \*****************************************************************************
3473: 343b: \***
3474: 343b: \***    LOG.AN.EVENT.106:
3475: 343b: \***    Writes details of Event 106 to application event log and displays
3476: 343b: \***    message B501 (for file open errors) or B514 (for other errors).
3477: 343b: \***
3478: 343b: \***..........................................................................
3479: 343b: 
3480: 343b: 
3481: 343b: LOG.AN.EVENT.106:
3482: 344b: 
3483: 344b: 
3484: 344b:     ADXSERVE.DATA$ = "LOG.AN.EVENT.106 File Op= " + FILE.OPERATION$    ! DCS
3485: 346e:     GOSUB DISPLAY.MESSAGE                                              ! DCS
3486: 3480: 
3487: 3480:     EVENT.NUMBER% EQ 106
3488: 348d: 
3489: 348d:     GOSUB FORMAT.CURRENT.CODE
3490: 349f: 
3491: 349f:     !OBTAIN REPORT NUMBER                                              ! HBG
3492: 349f:     FUNCTION.FLAG$ = "R"                                               ! HBG
3493: 34b4:     PASSED.INTEGER% = CURRENT.SESS.NUM%                                ! HBG
3494: 34c6:     GOSUB CALL.F20.SESS.NUM.UTILITY                                    ! HBG
3495: 34d8: 
3496: 34d8:     VAR.STRING.1$ EQ                         \ ! Application event log data
3497: 3547:         FILE.OPERATION$                    + \
3498: 3547:         CHR$(SHIFT(CURRENT.REPORT.NUM%,8)) + \ ! Two byte integer byte order
3499: 3547:         CHR$(SHIFT(CURRENT.REPORT.NUM%,0)) + \ ! reversed to give hex number
3500: 3547:         CURRENT.CODE.LOGGED$
3501: 3547: 
3502: 3547:     GOSUB CALL.F01.APPLICATION.LOG
3503: 3559: 
3504: 3559: RETURN
3505: 3569: 
3506: 3569: 
3507: 3569: 
3508: 3569: \*****************************************************************************
3509: 3569: \***
3510: 3569: \***    IF END # AND ERROR.DETECTED ROUTINES
3511: 3569: \***
3512: 3569: \***..........................................................................
3513: 3569: 
3514: 3569: 
3515: 3569: \******************************************************************************
3516: 3569: \***
3517: 3569: \***   CREATE.ERROR:
3518: 3569: \***
3519: 3569: \***   LOG an event 106
3520: 3569: \***
3521: 3569: \***   GOTO PROGRAM.EXIT
3522: 3569: \***
3523: 3569: \******************************************************************************
3524: 3569: 
3525: 3569: CREATE.ERROR:
3526: 3579: 
3527: 3579:        GOSUB LOG.AN.EVENT.106
3528: 358b: 
3529: 358b:        GOTO STOP.PROGRAM
3530: 3596: 
3531: 3596: \*****************************************************************************
3532: 3596: \***
3533: 3596: \***    FILE.ERROR.EXIT:
3534: 3596: \***    Logs events for specific file errors.
3535: 3596: \***    Formats error message and displays on background screen.
3536: 3596: \***    Logs an event 106.
3537: 3596: \***    Stops program.
3538: 3596: \***
3539: 3596: \***..........................................................................
3540: 3596: 
3541: 3596: 
3542: 3596: FILE.ERROR.EXIT:
3543: 35a6: 
3544: 35a6: 
3545: 35a6:     GOSUB FORMAT.CURRENT.CODE
3546: 35b8:     GOSUB LOG.AN.EVENT.106
3547: 35ca:     GOTO  STOP.PROGRAM
3548: 35d5: 
3549: 35d5: \*****************************************************************************
3550: 35d5: \***
3551: 35d5: \***    ERROR.DETECTED:
3552: 35d5: \***    Increments ERROR.COUNT% by one and tests it against values greater
3553: 35d5: \***    than one before any other commands executed.
3554: 35d5: \***    Further errors within ERROR.DETECTED causing control to be passed here
3555: 35d5: \***    again result in this test being failed and the immediate diversion of
3556: 35d5: \***    program control to STOP.PROGRAM.
3557: 35d5: \***    If no chaining parameters passed ...
3558: 35d5: \***        Diverts program control to OBTAIN.CHAIN.PARAMETERS.FROM.COMMAND
3559: 35d5: \***    References STANDARD.ERROR.DETECTED to log Event 101 and display
3560: 35d5: \***    message B550.
3561: 35d5: \***
3562: 35d5: \***..........................................................................
3563: 35d5: 
3564: 35d5: 
3565: 35d5: ERROR.DETECTED:
3566: 35e5: 
3567: 35e5:     ADXSERVE.DATA$ = "ERROR.DETECTED"                                  ! DCS
3568: 35fa:     GOSUB DISPLAY.MESSAGE                                              ! DCS
3569: 360c: 
3570: 360c:     ERROR.COUNT% EQ ERROR.COUNT% + 1
3571: 3618: 
3572: 3618:     IF ERROR.COUNT% GT 1 THEN \
3573: 3627:         BEGIN
3574: 3627:         RESUME STOP.PROGRAM
3575: 363e:         ENDIF
3576: 3646: 
3577: 3646:     IF FILE.OPERATION$ = "W" AND \                                     ! OAS
3578: 3683:        CURRENT.SESS.NUM% = MINOK.SESS.NUM% THEN BEGIN                  ! OAS
3579: 3683: 
3580: 3683:         ADXSERVE.DATA$ = "Error while writing to MINOK File"           ! OAS
3581: 3698:         GOSUB DISPLAY.MESSAGE                                          ! OAS
3582: 36aa:         ERROR.COUNT% = 0                                               ! OAS
3583: 36b7:         RESUME MINOK.ERROR                                             ! OAS
3584: 36ce: 
3585: 36ce:     ENDIF                                                              ! OAS
3586: 36d6: 
3587: 36d6:     !Setting MINLS HOUSEKEEPING FLAG to FALSE when there is an error   ! OAS
3588: 36d6:     !while deleting the record from the file                           ! OAS
3589: 36d6: 
3590: 36d6:     IF FILE.OPERATION$ = "D" THEN BEGIN                                ! OAS
3591: 36f4: 
3592: 36f4:         ADXSERVE.DATA$ = "Error while deleting MINLS record"           ! OAS
3593: 3709:         GOSUB DISPLAY.MESSAGE                                          ! OAS
3594: 371b:         MINLS.HK.STATUS$ = "X"                                         ! OAS
3595: 3730:         ERROR.COUNT% = 0                                               ! OAS
3596: 373d:         RESUME                                                         ! OAS
3597: 3754: 
3598: 3754:     ENDIF                                                              ! OAS
3599: 375c: 
3600: 375c: 
3601: 375c:     IF ERR = "OE" THEN BEGIN                                           ! CNS
3602: 3782:        IF CURRENT.SESS.NUM% = RFSCF.SESS.NUM% THEN BEGIN               ! CNS
3603: 379a:           ERROR.COUNT% = 0                                             ! CNS
3604: 37a7:           DO.MAIN = 1                                                  ! CNS
3605: 37b4:           RESUME END.RF.PROCESS                                        ! CNS
3606: 37cb:        ENDIF                                                           ! CNS
3607: 37d3:     ENDIF                                                              ! CNS
3608: 37db: 
3609: 37db:     IF ERR = "KF" AND CURRENT.SESS.NUM% = SRITL.SESS.NUM%             \! OAS
3610: 3827:       THEN BEGIN                                                       ! OAS
3611: 3827:       ERROR.COUNT% = 0                                                 ! OAS
3612: 3834:       RESUME                                                           ! OAS
3613: 384b:     ENDIF                                                              ! OAS
3614: 3853: 
3615: 3853:     IF ERR = "CU" AND CURRENT.SESS.NUM% = MINOK.SESS.NUM%             \! RTT
3616: 389c:       THEN BEGIN                                                       ! RTT
3617: 389c:       ERROR.COUNT% = 0                                                 ! RTT
3618: 38a9:       RESUME                                                           ! RTT
3619: 38c0:     ENDIF                                                              ! RTT
3620: 38c8: 
3621: 38c8:     FUNCTION.RETURN.CODE% EQ  \ OAS
3622: 38fc:       STANDARD.ERROR.DETECTED \
3623: 38fc:        (ERRN,                 \ OAS
3624: 38fc:         ERRF%,                \ OAS
3625: 38fc:         ERRL,                 \ OAS
3626: 38fc:         ERR)
3627: 38fc: 
3628: 38fc: RESUME STOP.PROGRAM
3629: 3918: 
3630: 3918: 
3631: 3918: \*****************************************************************************
3632: 3918: \*****************************************************************************
3633: 3918: \***
3634: 3918: \***    End of program MINPRINT
3635: 3918: \***
3636: 3918: \*****************************************************************************
3637: 3918: \*****************************************************************************
3638: 3918: 
3639: 3918: 
3640: 3918: 
3641: 3918: 
3642: 3918: End of Compilation
