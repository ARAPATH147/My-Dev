   1: 0000: 
   2: 0000: \*****************************************************************************
   3: 0000: \***
   4: 0000: \***      IRF - ITEM REFERENCE FILE - External functions
   5: 0000: \***
   6: 0000: \***      Reference : IRFFUN.BAS
   7: 0000: \***
   8: 0000: \***      Version A           Andrew Wedgeworth     9th July 1992
   9: 0000: \***
  10: 0000: \***      Version B           Steve Windsor        14th December 1992
  11: 0000: \***      Version letter incremented in line with other IRF code.
  12: 0000: \***
  13: 0000: \***      Version C           Steve Windsor         12.02.93
  14: 0000: \***      Added function to read the IRF ALT.
  15: 0000: \***
  16: 0000: \***      Version D           Steve Windsor         12.05.93
  17: 0000: \***      All IRF functions included.
  18: 0000: \***
  19: 0000: \***      Version E           Steve Perkins       20th September 1993
  20: 0000: \***      Deals project : Handling of Converted/Unconverted records
  21: 0000: \***      ++   Anything with 'Delete' after initials should be   ++
  22: 0000: \***      ++   deleted once the IRF has been converted in all    ++
  23: 0000: \***      ++   stores.                                           ++
  24: 0000: \***
  25: 0000: \***      Version F           Mark Walker            5th January 1994
  26: 0000: \***      If a read/write fails, set the CURRENT.CODE$ variable
  27: 0000: \***      to the current bar code.
  28: 0000: \***
  29: 0000: \***      Version 96A         Mark Walker               22nd May 1995
  30: 0000: \***      A new field IRF.POINTS% has replaced the existing
  31: 0000: \***      field IRF.FILLER$. Redundant deals code has been removed.
  32: 0000: \***
  33: 0000: \***      96A supplemental    David Smallwood           20th September 1995
  34: 0000: \***      IRF.RECORD$ initialised to "CONVERTED RECORD" for READ functions.
  35: 0000: \***      This is to enable programs that still refer to IRF.RECORD$
  36: 0000: \***      (e.g.PSS35) to function correctly.
  37: 0000: \***
  38: 0000: \***      Version G     Stuart William McConnachie      11th February 2000
  39: 0000: \***      Converted IRF.INDICAT2$ to integer flag byte.
  40: 0000: \***
  41: 0000: \***      REVISION 1.6.               ROBERT COWEY.               9 JUL 2002.
  42: 0000: \***      Major changes for 2002 Deals Rewrite project.
  43: 0000: \***      See IRFDEC.J86 for updated record layout.
  44: 0000: \***      Removed variables that are redundant or related to old deals system
  45: 0000: \***      from record (input and output) definitions ...
  46: 0000: \***      INDICAT2%, DEAL.NUM$, INDICAT4%, SALEQUAN$, DEAL.SAVING$, POINTS%
  47: 0000: \***      Defined new deal data (table) variables within record definitions ...
  48: 0000: \***      DEAL.DATA%(0-2)
  49: 0000: \***
  50: 0000: \***      Defined new function IRF.SPLIT.RECORD
  51: 0000: \***      Set variables that may be "retained" within programs to nulls X'00' ...
  52: 0000: \***      INDICAT2%, INDICAT4%, SALEQUAN$, POINTS%
  53: 0000: \***      Interpreted DEAL.DATA%(n) variables into sub-variables ...
  54: 0000: \***      DEAL.NUM$(0-2), LIST.ID%(0-2)
  55: 0000: \***
  56: 0000: \***      Defined new function IRF.CONCAT.RECORD
  57: 0000: \***      Recreated DEAL.DATA%(n) variables from (interpreted) sub-variables ...
  58: 0000: \***      DEAL.NUM$(0-2), LIST.ID%(0-2)
  59: 0000: \***
  60: 0000: \***      Avoided use of WHILE loop and subscript to keep code more readable
  61: 0000: \***      when handling DEAL.DATA%(n) related variables
  62: 0000: \***
  63: 0000: \***      REVISION 1.7.               ROBERT COWEY.               5 AUG 2002.
  64: 0000: \***      Further changes for 2002 Deals Rewrite project (PSBF19 related).
  65: 0000: \***      Included definition of external GETNn and PUTNn assembler functions.
  66: 0000: \***      Defined function CONCAT.NEW.IRF.DATA$ to combine individual IRF variables
  67: 0000: \***      into a single (record) string NEW.IRF.DATA$.
  68: 0000: \***      Defined function SPLIT.NEW.IRF.DATA$ to extract individual IRF variables
  69: 0000: \***      from (IRF record) string NEW.IRF.DATA$.
  70: 0000: \***
  71: 0000: \***      REVISION 1.8                ROBERT COWEY.              15 JUL 2003.
  72: 0000: \***      Usage of INDICAT0% bit-3 X'08' changed to Item Contains Alcohol.
  73: 0000: \***      No changes to this file other than description.
  74: 0000: \***      No changes to IRF file functions.
  75: 0000: \***
  76: 0000: \***      REVISION 1.9.     STUART WILLIAM MCCONNACHIE           22 OCT 2003.
  77: 0000: \***      Changes to remove limit of 3 deals per item.  Added code to access
  78: 0000: \***      aditional deals on the IRF Deal Extension file (IRFDEX).
  79: 0000: \***      SUPPLEMENTAL      ROBERT COWEY                         02 DEC 2003
  80: 0000: \***      Modified CONCAT.NEW.IRF.DATA$ and SPLIT.NEW.IRF.DATA$ to incorporate
  81: 0000: \***      new IRFDEX deal variables within NEW.IRF.DATA$ string used by PSBF19.
  82: 0000: \***      Modified READ.IRF.ALT to call READ.IRFDEX (to match other functions).
  83: 0000: \***      Changed IRFDEX report number from 663 to 673.
  84: 0000: \***
  85: 0000: \***      REVISION 2.0.             ALAN CARR                      9 FEB 2006.
  86: 0000: \***      Add new IRF.INDICAT8% 1 byte, amend IRF.UNUSED$ from 3 to 2 bytes.
  87: 0000: \***
  88: 0000: \***      REVISION 2.1              BRIAN GREENFIELD               14 May 2009
  89: 0000: \***      Chanegs to increase the number of deals from 10 to 40.
  90: 0000: \***      Converted two sections to loops to simplify the code.
  91: 0000: \***
  92: 0000: \***      REVISION 2.2              TITTOO THOMAS                  01 July 2011
  93: 0000: \***      The IRF.UNUSED field is disintegrated to 2 new indicator fields
  94: 0000: \***                      IRF.INDICAT9%   1 INT
  95: 0000: \***                      IRF.INDICAT10%  1 INT
  96: 0000: \***...............................................................................
  97: 0000: 
  98: 0000: 
  99: 0000:     STRING GLOBAL                     \
 100: 0000:         CURRENT.CODE$,                 \
 101: 0000:         FILLER$,                      \ 2.1 BG
 102: 0000:         FILE.OPERATION$
 103: 0000: 
 104: 0000:     INTEGER*2 GLOBAL                  \
 105: 0000:         CURRENT.REPORT.NUM%
 106: 0000: 
 107: 0000:     INTEGER*2 I%          ! Loop counter                                   ! 1.9 SM
 108: 0000:     INTEGER*2 OFFSET%     ! Offset value                                   ! 2.1 BG
 109: 0000:     INTEGER*2             \ IRF.DEAL.DATA%(n) variable defined locally     ! 1.6 RC
 110: 0000:         IRF.DEAL.DATA%(1) ! to keep underlying data invisible to programs  ! 1.6 RC
 111: 0000: 
 112: 0000: 
 113: 0000:     %INCLUDE IRFDEC.J86   ! IRF variable declarations
 114: 0000: 
 115: 0000: \**********************************************************************************
 116: 0000: \***
 117: 0000: \***       %INCLUDE FOR ITEM RECORD FILE - FIELD DECLARATIONS
 118: 0000: \***                                     - FILE REFERENCE PARAMETERS
 119: 0000: \***
 120: 0000: \***                      FILE TYPE    : Keyed
 121: 0000: \***
 122: 0000: \***                      REFERENCE    : IRFDEC.J86
 123: 0000: \***
 124: 0000: \***     Version A               Andrew Wedgeworth            29th June 1992
 125: 0000: \***
 126: 0000: \***     Version B               Andrew Wedgeworth        14th December 1992
 127: 0000: \***     Version letter incremented to match other IRF code.
 128: 0000: \***
 129: 0000: \***     Version C             Steve Windsor          12.02.93
 130: 0000: \***     Version letter incremented to match other IRF code.
 131: 0000: \***
 132: 0000: \***     Version D             Steve Windsor          12.05.93
 133: 0000: \***     Version letter incremented to match other IRF code.
 134: 0000: \***
 135: 0000: \***     Version E           Steve Perkins       20th September 1993
 136: 0000: \***     Deals project : Handling of Converted/Unconverted records
 137: 0000: \***     ++   Anything with 'Delete' after initials should be   ++
 138: 0000: \***     ++   deleted once the IRF has been converted in all    ++
 139: 0000: \***     ++   stores.                                           ++
 140: 0000: \***
 141: 0000: \***     Version F           Mark Walker            5th January 1994
 142: 0000: \***     Version letter incremented to match other IRF code.
 143: 0000: \***
 144: 0000: \***     Version 96A         Mark Walker               22nd May 1995
 145: 0000: \***     Definition for IRF.POINTS% added.
 146: 0000: \***
 147: 0000: \***                     Stuart McConnachie           12th June 1995
 148: 0000: \***     INDICAT3% comments added for discount/loyalty flags.
 149: 0000: \***
 150: 0000: \***     Version for 96C  Andrew Wedgeworth            22nd May 1996
 151: 0000: \***     Removed IRF.FILLER$ field, as this is now redundant.
 152: 0000: \***
 153: 0000: \***     Version G     Stuart William McConnachie      11th February 2000
 154: 0000: \***     Converted IRF.INDICAT2$ to integer flag byte.
 155: 0000: \***
 156: 0000: \***     REVISION 1.6.               ROBERT COWEY.               9 JUL 2002.
 157: 0000: \***     Major changes for 2002 Deals Rewrite project.
 158: 0000: \***     Incorporated up to date record layout to assist development work
 159: 0000: \***     (placed in the IRFDEC.J86 to make it visible from ...LST files).
 160: 0000: \***     Moved various comments against variables to record layout.
 161: 0000: \***     Relisted variables in alphabetical order.
 162: 0000: \***     Deleted redundant variables associated with the old deals system ...
 163: 0000: \***     DEAL.NUM$, DEAL.SAVING$
 164: 0000: \***     Retained variables that are otherwise redundant (to be set to null X'00'
 165: 0000: \***     within file functions) ...
 166: 0000: \***     INDICAT2%, INDICAT4%, SALEQUAN$, POINTS%
 167: 0000: \***     Defined variables to hold interpreted deals data for new deals system ...
 168: 0000: \***     DEAL.NUM$(n) and LIST.ID%(n) (where 'n' represents entry 0, 1 and 2).
 169: 0000: \***     These two variables are interpretations of DEAL.DATA% which is defined
 170: 0000: \***     locally within IRFFUN.BAS to keep underlying data invisible to programs.
 171: 0000: \***
 172: 0000: \***     REVISION 1.7                ROBERT COWEY.               5 AUG 2002.
 173: 0000: \***     Further changes for 2002 Deals Rewrite project (PSBF19 related).
 174: 0000: \***     Defined NEW.IRF.DATA$ as a global variable for use with new functions
 175: 0000: \***     CONCAT.NEW.IRF.DATA$ and SPLIT.NEW.IRF.DATA$.
 176: 0000: \***
 177: 0000: \***     REVISION 1.8                ROBERT COWEY.              15 JUL 2003.
 178: 0000: \***     Usage of INDICAT0% bit-3 X'08' changed to Item Contains Alcohol.
 179: 0000: \***     No changes to this file other than description.
 180: 0000: \***     No changes to IRF file functions.
 181: 0000: \***
 182: 0000: \***     REVISION 1.9.      STUART WILLIAM MCCONNACHIE           22 OCT 2003.
 183: 0000: \***     Changes to remove limit of 3 deals per item.
 184: 0000: \***     Declaration of new variables for IRF Deal Extension file (IRFDEX).
 185: 0000: \***
 186: 0000: \***     REVISION 2.0.            ALAN CARR                       9 FEB 2006.
 187: 0000: \***     Add new IRF.INDICAT8% 1 byte, amend IRF.UNUSED$ from 3 to 2 bytes.
 188: 0000: \***
 189: 0000: \***     REVISION 2.1              TITTOO THOMAS                  01 July 2011
 190: 0000: \***     The IRF.UNUSED field is disintegrated to 2 new indicator fields
 191: 0000: \***                      IRF.INDICAT9%   1 INT
 192: 0000: \***                      IRF.INDICAT10%  1 INT
 193: 0000: \***...............................................................................
 194: 0000: 
 195: 0000: 
 196: 0000: \**********************************************************************************
 197: 0000: \***
 198: 0000: \***    IRF RECORD LAYOUT - REVISION 1.7 - CORRECT FOR 2011 CORE Stores PROJECT
 199: 0000: \***
 200: 0000: \***     1 11  UPD  BAR.CODE$   Without check digit - File KEY
 201: 0000: \***    12  1  INT  INDICAT0%
 202: 0000: \***                    X"01" - Contains statins                           ! 2.2 TT
 203: 0000: \***                    X"02" - Item not priced (giveaway)
 204: 0000: \***                    X"04" - Item not returnable
 205: 0000: \***                    X"08" - Item contains alcohol
 206: 0000: \***                    X"10" - Blocked from sale                          ! 2.2 TT
 207: 0000: \***                    X"20" - Enforced price entry
 208: 0000: \***                    X"40" - Enforced quantity entry
 209: 0000: \***                    X"80" - Movement kept
 210: 0000: \***    13  1  INT  INDICAT1%
 211: 0000: \***                    X"01" - Asprin
 212: 0000: \***                    X"02" - Paracetamol
 213: 0000: \***                    X"04" - TPLU inclusion flag
 214: 0000: \***                    X"08" - Giftcard item                              ! 2.2 TT
 215: 0000: \***                    X"10" - Withdrawn Block from sale                  ! 2.2 TT
 216: 0000: \***                    X"20" - Non-solid dose painkiller                  ! 2.2 TT
 217: 0000: \***                    X"40" - Insurance policy item                      ! 2.2 TT
 218: 0000: \***                    X"80" - Ibuprofen
 219: 0000: \***    14  2  INT  DEAL.DATA%(0)   Interpreted into sub-variables ...
 220: 0000: \***                    X'3F' - into DEAL.NUM$(0) "0000" to "9999" (2 byte UPD)
 221: 0000: \***                    X'C0' - into LIST.ID%(0) X'00' X
 222: 0000: \***                                             X'01' A
 223: 0000: \***                                             X'10' B
 224: 0000: \***                                             X'11' C                   ! 1.9 RC
 225: 0000: \***    16  1  INT  INDICAT8%                                              ! 2.0 AJC
 226: 0000: \***                    X"01" - Chlamydia NHS test kit                     ! 2.2 TT
 227: 0000: \***                    X"02" - Chlamydia open sell test kit               ! 2.2 TT
 228: 0000: \***                    X"04" - Unrestricted group code                    ! 2.2 TT
 229: 0000: \***                    X"08" - Nightingale Till prompt                    ! 2.2 TT
 230: 0000: \***                    X"10" - Contains Ephedrine                         ! 2.2 TT
 231: 0000: \***                    X"60" -  X'00' - If also Blocked From Sale Recall, ! 2.2 TT
 232: 0000: \***                                        Emergency                      ! 2.2 TT
 233: 0000: \***                             X'00' - If NOT Blocked From Sale Recall,  ! 2.2 TT
 234: 0000: \***                                        No recall                      ! 2.2 TT
 235: 0000: \***                             X'20' 100% returns                        ! 2.2 TT
 236: 0000: \***                             X'40' Withdrawn recall                    ! 2.2 TT
 237: 0000: \***                             X'60' Reverse Logistics                   ! 2.2 TT
 238: 0000: \***                    X"80" - WEEE item flag                             ! 2.0 AJC
 239: 0000: \***    17  1  INT  INDICAT9%
 240: 0000: \***                    X'3F' - Disposal special instruction (0-63)
 241: 0000: \***                    X"40" - Resaleable Indicator
 242: 0000: \***                    X"80" - Boots.com Extended Indicator
 243: 0000: \***    18  1  INT  INDICAT10%
 244: 0000: \***                    X'07' - Age restrictions
 245: 0000: \***                             X'00' - No Age restriction
 246: 0000: \***                             X'01' - Age 12 or over
 247: 0000: \***                             X'02' - Age 15 or over
 248: 0000: \***                             X'03' - Age 16 or over
 249: 0000: \***                             X'04' - Age 18 or over
 250: 0000: \***                             X'05' - Age 21 or over
 251: 0000: \***                             X'06' - Reserved
 252: 0000: \***                             X'07' - Reserved
 253: 0000: \***                    X'38' - Ethical classification
 254: 0000: \***                             X'00' - No ethical classification
 255: 0000: \***                             X'08' - Pharmacy medicine (P)
 256: 0000: \***                             X'10' - General Sale License (GSL)
 257: 0000: \***                             X'18' - Prescription Only Medicine (POM)
 258: 0000: \***                             X'20' - Reserved
 259: 0000: \***                             X'28' - Reserved
 260: 0000: \***                             X'30' - Reserved
 261: 0000: \***                             X'38' - Reserved
 262: 0000: \***                    X'C0' - Returns route
 263: 0000: \***                             X'00' - Not Returnable (Destroy)
 264: 0000: \***                             X'40' - Returns & Recovery
 265: 0000: \***                             X'80' - Direct
 266: 0000: \***                             X'C0' - Semi-centralised
 267: 0000: \***    19  5  UPD  SALEPRIC$   Current price in pence
 268: 0000: \***    24  1  INT  INDICAT5%   Guarantee duration
 269: 0000: \***                    X'3F' - Lowest 6 bits indicate duration (1-63)
 270: 0000: \***                    X'40' - Contains Pseudoephedrine                   ! 2.2 TT
 271: 0000: \***                    X'80' - Guarantee Duration Type                    ! 2.2 TT
 272: 0000: \***                              (1 = Months, 0 = Years)                  ! 2.2 TT
 273: 0000: \***    25 18  ASC  ITEMNAME$   Description used by till
 274: 0000: \***    43  3  UPD  BOOTS.CODE$ Without check digit
 275: 0000: \***    46  2  INT  DEAL.DATA%(1)   Similar structure to DEAL.DATA%(0)
 276: 0000: \***    48  2  INT  DEAL.DATA%(2)   Similar structure to DEAL.DATA%(0)
 277: 0000: \***    50  1  INT  INDICAT3%
 278: 0000: \***                    X"01" - Discountexempt (item exempt from discount)
 279: 0000: \***                    X"02" - Boots brand item
 280: 0000: \***                    X"04" - Item redeemable for loyalty
 281: 0000: \***                    X"08" - Loyalty exempt (item exempt from loyalty)
 282: 0000: \***                    X"10" - **Redundant                                ! 2.2 TT
 283: 0000: \***                    X"20" - Local Price active
 284: 0000: \***                    X"40" - Stock system item
 285: 0000: \***                    X"80" - **Redundant                                ! 2.2 TT
 286: 0000: \***
 287: 0000: \***    Record Length 50
 288: 0000: \***
 289: 0000: \***
 290: 0000: \***    IRF DEAL EXTENSION RECORD LAYOUT ! 1.9 RC
 291: 0000: \***
 292: 0000: \***     1  3  UPD  BOOTS.CODE$
 293: 0000: \***     4  2  INT  IRF.DEAL.DATA%(3)   Similar structure to DEAL.DATA%(0)
 294: 0000: \***     6  2  INT  IRF.DEAL.DATA%(4)   Similar structure to DEAL.DATA%(0)
 295: 0000: \***     8  2  INT  IRF.DEAL.DATA%(5)   Similar structure to DEAL.DATA%(0)
 296: 0000: \***    10  2  INT  IRF.DEAL.DATA%(6)   Similar structure to DEAL.DATA%(0)
 297: 0000: \***    12  2  INT  IRF.DEAL.DATA%(7)   Similar structure to DEAL.DATA%(0)
 298: 0000: \***    14  2  INT  IRF.DEAL.DATA%(8)   Similar structure to DEAL.DATA%(0)
 299: 0000: \***    16  2  INT  IRF.DEAL.DATA%(9)   Similar structure to DEAL.DATA%(0)
 300: 0000: \***
 301: 0000: \***    Record Length 17
 302: 0000: \***
 303: 0000: \**********************************************************************************
 304: 0000: 
 305: 0000: 
 306: 0000:     STRING GLOBAL            \
 307: 0000:         IRF.ALT.FILE.NAME$,  \
 308: 0000:         IRF.BAR.CODE$,       \
 309: 0000:         IRF.BOOTS.CODE$,     \
 310: 0000:         IRF.DEAL.SAVING$,    \ 2 byte - deal saving amount (0 - œ99.99) ! ESP
 311: 0000:         IRF.DEPARTME$,       \ 3 byte UPD. Department number          ! ESP Delete
 312: 0000:         IRF.FILE.NAME$,      \
 313: 0000:         IRF.HOLDING.PRICE$,  \ 4 byte UPD. Current H.O. price in pence if a local
 314: 0000:                              \ price is in effect, zero otherwise.     ! ESP Delete
 315: 0000:         IRF.ITEMNAME$,       \
 316: 0000: \       IRF.MPGROUP$,        \ Removed SBH 31/1/96
 317: 0000:         IRF.RECORD$,         \                                         ! ESP Delete
 318: 0000:         IRF.SALEPRIC$,       \
 319: 0000:         IRF.SALEQUAN$,       \ Redundant (set to null within functions)    ! 1.6 RC
 320: 0000:         IRF.UNUSED$,         \                                                        ! 1.6 RC
 321: 0000:         NEW.IRF.DATA$        !                                             ! 1.7 RC
 322: 0000: 
 323: 0000:     STRING GLOBAL            \                                             ! 1.6 RC
 324: 0000:         IRF.DEAL.NUM$(1)                                                   ! 1.6 RC
 325: 0000: 
 326: 0000:     INTEGER*1 GLOBAL         \
 327: 0000:         IRF.DD.SUB%,         \ IRF.DEAL.DATA% subscript                    ! 1.6 RC
 328: 0000:         IRF.INDICAT0%,       \
 329: 0000:         IRF.INDICAT1%,       \
 330: 0000:         IRF.INDICAT2%,       \ Redundant (set to null within functions)    ! 1.6 RC
 331: 0000:         IRF.INDICAT3%,       \
 332: 0000:         IRF.INDICAT4%,       \ Redundant (set to null within functions)    ! 1.6 RC
 333: 0000:         IRF.INDICAT5%,       \                                             ! 2.0 AJC
 334: 0000:         IRF.INDICAT8%,       \                                             ! 2.0 AJC
 335: 0000:         IRF.INDICAT9%,       \                                             ! 2.2 TT
 336: 0000:         IRF.INDICAT10%                                                     ! 2.2 TT
 337: 0000: 
 338: 0000:     INTEGER*1 GLOBAL         \                                             ! 1.6 RC
 339: 0000:         IRF.LIST.ID%(1)                                                    ! 1.6 RC
 340: 0000: 
 341: 0000:     INTEGER*2 GLOBAL         \
 342: 0000:         IRF.ALT.REPORT.NUM%, \
 343: 0000:         IRF.ALT.SESS.NUM%,   \
 344: 0000:         IRF.POINTS%,         \ Redundant (set to null within functions)    ! 1.6 RC
 345: 0000:         IRF.RECL%,           \
 346: 0000:         IRF.REPORT.NUM%,     \
 347: 0000:         IRF.SESS.NUM%,       \
 348: 0000:         IRF.MAX.DEALS%       !                                             ! 1.9 SM
 349: 0000: 
 350: 0000:     STRING GLOBAL IRFDEX.FILE.NAME$                                        ! 1.9 SM
 351: 0000: 
 352: 0000:     INTEGER*2 GLOBAL IRFDEX.SESS.NUM%                                      ! 1.9 SM
 353: 0000:     INTEGER*2 GLOBAL IRFDEX.REPORT.NUM%                                    ! 1.9 SM
 354: 0000:     INTEGER*2 GLOBAL IRFDEX.RECL%                                          ! 1.9 SM
 355: 0000: 
 356: 0000: 
 357: 0000: !   INTEGER*2 GLOBAL      \ IRF.DEAL.DATA%(n) variables are defined locally  1.6 RC
 358: 0000: !       IRF.DEAL.DATA%(1) \ within IRFFUN.BAS to keep invisible to programs  1.6 RC
 359: 0000: 
 360: 0000: 
 361: 0000:     %INCLUDE EALHSASC.J86 ! External assembler function definitions        ! 1.7 RC
 362: 0000: \/* TIME STAMP BLOCK **********************************************
 363: 0000: \** END OF TIME STAMP BLOCK **************************************/
 364: 0000: !! THIS MODULE WAS CREATED BY APAR IR70269
 365: 0000: !*********************************************************************
 366: 0000: !
 367: 0000: ! ASSEMBLER SUBROUTNE DEFINITIONS
 368: 0000: !
 369: 0000: ! These definitions should be copied by any routine which wishes to
 370: 0000: ! use the performanced enhanced assembler routines.
 371: 0000: !
 372: 0000: !*********************************************************************
 373: 0000:  
 374: 0000: !*********************************************************************
 375: 0000: !
 376: 0000: ! SUBSTR
 377: 0000: !
 378: 0000: ! This routine performs a merge of two strings. String P3$, offset P4
 379: 0000: ! is merged into string P1$ offset P2 for a length of P5 bytes
 380: 0000: !
 381: 0000: ! CAUTION: P1$ must be long enough to totally contain P3$
 382: 0000: !
 383: 0000: ! NOTE: THE OFFSETS PASSED TO THIS ROUTINE ARE ZERO INDEXED
 384: 0000: !
 385: 0000: !*********************************************************************
 386: 0000:  
 387: 0000:  FUNCTION SUBSTR (P1$,P2,P3$,P4,P5) EXTERNAL
 388: 0000:  STRING P1$,P3$
 389: 0000:  INTEGER*2 P2,P4,P5
 390: 0000:  END FUNCTION
 391: 0000:  
 392: 0000: !*********************************************************************
 393: 0000: !
 394: 0000: ! GETN2/GETN4
 395: 0000: !
 396: 0000: ! These routines extract a two/four byte integer from a string.
 397: 0000: ! P2 is the offset within the string
 398: 0000: !
 399: 0000: ! NOTE: THE OFFSET PASSED TO THIS ROUTINE IS ZERO INDEXED
 400: 0000: !
 401: 0000: !*********************************************************************
 402: 0000:  
 403: 0000:  FUNCTION GETN2(P1$,P2) EXTERNAL
 404: 0000:  INTEGER*2 GETN2
 405: 0000:  STRING P1$
 406: 0000:  INTEGER*2 P2
 407: 0000:  END FUNCTION
 408: 0000:  
 409: 0000:  FUNCTION GETN4(P1$,P2) EXTERNAL
 410: 0000:  INTEGER*4 GETN4
 411: 0000:  STRING P1$
 412: 0000:  INTEGER*2 P2
 413: 0000:  END FUNCTION
 414: 0000:  
 415: 0000: !*********************************************************************
 416: 0000: !
 417: 0000: ! PUTN2/PUTN4
 418: 0000: !
 419: 0000: ! These routines insert a two/four byte integer into a string.
 420: 0000: ! P2 is the offset within the string and P3 is the source integer
 421: 0000: !
 422: 0000: ! NOTE: THE OFFSET PASSED TO THIS ROUTINE IS ZERO INDEXED
 423: 0000: !
 424: 0000: !*********************************************************************
 425: 0000:  
 426: 0000:  FUNCTION PUTN2(P1$,P2,P3) EXTERNAL
 427: 0000:  STRING P1$
 428: 0000:  INTEGER*2 P2,P3
 429: 0000:  END FUNCTION
 430: 0000:  
 431: 0000:  FUNCTION PUTN4(P1$,P2,P3) EXTERNAL
 432: 0000:  STRING P1$
 433: 0000:  INTEGER*2 P2
 434: 0000:  INTEGER*4 P3
 435: 0000:  END FUNCTION
 436: 0000:  
 437: 0000: !*********************************************************************
 438: 0000: !
 439: 0000: ! PACKBIN2/4
 440: 0000: !
 441: 0000: ! These routines take a packed decimal string and convert to integer
 442: 0000: ! (The equivalent of CBASIC INT%(VAL(UNPACK$())) )
 443: 0000: ! P1 is the source string, P2 the string offset and P3 the length
 444: 0000: !
 445: 0000: ! NOTE: THE OFFSET PASSED TO THIS ROUTINE IS ZERO INDEXED
 446: 0000: !
 447: 0000: !*********************************************************************
 448: 0000:  
 449: 0000:  FUNCTION PACKBIN2(P1$,P2,P3) EXTERNAL
 450: 0000:  INTEGER*2 PACKBIN2
 451: 0000:  STRING P1$
 452: 0000:  INTEGER*2 P2,P3
 453: 0000:  END FUNCTION
 454: 0000:  
 455: 0000:  FUNCTION PACKBIN4(P1$,P2,P3) EXTERNAL
 456: 0000:  INTEGER*4 PACKBIN4
 457: 0000:  STRING P1$
 458: 0000:  INTEGER*2 P2,P3
 459: 0000:  END FUNCTION
 460: 0000:  
 461: 0000: !*********************************************************************
 462: 0000: !
 463: 0000: ! ADDIN2/4
 464: 0000: !
 465: 0000: ! These routines add an integer into an integer which is imbedded within
 466: 0000: ! a string.  P1$ is the string containing at offset P2 the integer to be
 467: 0000: ! updated.  P3 is the integer to be added into P1$.
 468: 0000: !
 469: 0000: ! NOTE: THE OFFSET PASSED TO THIS ROUTINE IS ZERO INDEXED
 470: 0000: !
 471: 0000: !*********************************************************************
 472: 0000:  
 473: 0000:  FUNCTION ADDIN4(P1$,P2,P3) EXTERNAL
 474: 0000:  INTEGER*4 ADDIN4
 475: 0000:  STRING P1$
 476: 0000:  INTEGER*2 P2
 477: 0000:  INTEGER*4 P3
 478: 0000:  END FUNCTION
 479: 0000:  
 480: 0000:  FUNCTION ADDIN2(P1$,P2,P3) EXTERNAL
 481: 0000:  INTEGER*2 ADDIN2
 482: 0000:  STRING P1$
 483: 0000:  INTEGER*2 P2,P3
 484: 0000:  END FUNCTION
 485: 0000:  
 486: 0000: !*********************************************************************
 487: 0000: !
 488: 0000: ! MATCHB
 489: 0000: !
 490: 0000: ! This routine performs a fast match function when the string being
 491: 0000: ! searched for contains only a single character.  As with the MATCH
 492: 0000: ! function, P1$ is the character to be found, P2$ is the string to be
 493: 0000: ! searched, and P3 the offst at which to start the search.
 494: 0000: !
 495: 0000: !*********************************************************************
 496: 0000:  
 497: 0000:  FUNCTION MATCHB(P1$,P2$,P3) EXTERNAL
 498: 0000:  INTEGER*2 MATCHB
 499: 0000:  STRING P1$
 500: 0000:  STRING P2$
 501: 0000:  INTEGER*2 P3
 502: 0000:  END FUNCTION
 503: 0000:  
 504: 0000: \ REM!! *************************************************************!!
 505: 0000: \ REM!! PROCEDURE - CONVERT A PACKED DECIMAL DATA STRING TO A        !!
 506: 0000: \ REM!! 4 BYTE BINARY INTEGER REPRESENTED AS A STRING.               !!
 507: 0000: \ REM!! STRING "OUT$" MUST BE INITIALIZED BEFORE CALLING THE ROUTINE.!!
 508: 0000: \ REM!! *************************************************************!!
 509: 0000:  
 510: 0000: SUB UPDBIN4 (IN$,OUT$) EXTERNAL
 511: 0000: STRING IN$,OUT$
 512: 0000: END SUB
 513: 0000:  
 514: 0000: \ REM!! *************************************************************!!
 515: 0000: \ REM!! PROCEDURE - CONVERT A PACKED DECIMAL DATA STRING TO A        !!
 516: 0000: \ REM!! 3 BYTE BINARY INTEGER REPRESENTED AS A STRING.               !!
 517: 0000: \ REM!! STRING "OUT$" MUST BE INITIALIZED BEFORE CALLING THE ROUTINE.!!
 518: 0000: \ REM!! *************************************************************!!
 519: 0000:  
 520: 0000: SUB UPDBIN3 (IN$,OUT$) EXTERNAL
 521: 0000: STRING IN$,OUT$
 522: 0000: END SUB
 523: 0000:  
 524: 0000: \ REM!! *************************************************************!!
 525: 0000: \ REM!! PROCEDURE - CONVERT A PACKED DECIMAL DATA STRING TO A        !!
 526: 0000: \ REM!! 2 BYTE BINARY INTEGER REPRESENTED AS A STRING.               !!
 527: 0000: \ REM!! STRING "OUT$" MUST BE INITIALIZED BEFORE CALLING THE ROUTINE.!!
 528: 0000: \ REM!! *************************************************************!!
 529: 0000:  
 530: 0000: SUB UPDBIN2 (IN$,OUT$) EXTERNAL
 531: 0000: STRING IN$,OUT$
 532: 0000: END SUB
 533: 0000:  
 534: 0000: \ REM!! *************************************************************!!
 535: 0000: \ REM!! PROCEDURE - CONVERT A PACKED DECIMAL DATA STRING TO A        !!
 536: 0000: \ REM!! 1 BYTE BINARY INTEGER REPRESENTED AS A STRING.               !!
 537: 0000: \ REM!! STRING "OUT$" MUST BE INITIALIZED BEFORE CALLING THE ROUTINE.!!
 538: 0000: \ REM!! *************************************************************!!
 539: 0000:  
 540: 0000: SUB UPDBIN1 (IN$,OUT$) EXTERNAL
 541: 0000: STRING IN$,OUT$
 542: 0000: END SUB
 543: 0000:  
 544: 0000: \ REM!! *************************************************************!!
 545: 0000: \ REM!! PROCEDURE - CONVERT A PACKED DECIMAL DATA STRING TO A        !!
 546: 0000: \ REM!! 4 BYTE HEX REPRESENTATION OF A 2-BYTE INTEGER                !!
 547: 0000: \ REM!! STRING "OUT$" MUST BE INITIALIZED BEFORE CALLING THE ROUTINE.!!
 548: 0000: \ REM!! *************************************************************!!
 549: 0000:  
 550: 0000: SUB UPDHEX2 (IN$,OUT$) EXTERNAL
 551: 0000: STRING IN$,OUT$
 552: 0000: END SUB
 553: 0000:  
 554: 0000: \ REM!! *************************************************************!!
 555: 0000: \ REM!! PROCEDURE - CONVERT A PACKED DECIMAL DATA STRING TO A        !!
 556: 0000: \ REM!! 2 BYTE HEX REPRESENTATION OF A 1-BYTE INTEGER                !!
 557: 0000: \ REM!! STRING "OUT$" MUST BE INITIALIZED BEFORE CALLING THE ROUTINE.!!
 558: 0000: \ REM!! *************************************************************!!
 559: 0000:  
 560: 0000: SUB UPDHEX1 (IN$,OUT$) EXTERNAL
 561: 0000: STRING IN$,OUT$
 562: 0000: END SUB
 563: 0000:  
 564: 0000: \ REM!! *************************************************************!!
 565: 0000: \ REM!! PROCEDURE - CONVERT AN INPUT 4 BYTE INTEGER REPRESENTED AS A !!
 566: 0000: \ REM!! STRING TO A 2 BYTE BINARY INTEGER REPRESENTED AS A STRING    !!
 567: 0000: \ REM!! WHERE BOTH THE INPUT AND OUTPUT MAY BE IMBEDDED WITHIN THE   !!
 568: 0000: \ REM!! GIVEN STRING AT THE GIVEN OFFSET.                            !!
 569: 0000: \ REM!! STRING "OUT$" MUST BE INITIALIZED BEFORE CALLING THE ROUTINE.!!
 570: 0000: \ REM!!
 571: 0000: \ REM!! NOTE: THE OFFSETS PASSED TO THIS ROUTINE ARE UNIT INDEXED
 572: 0000: \ REM!! *************************************************************!!
 573: 0000:  
 574: 0000: SUB INTBIN2 (IN$,IN%,OUT$,OUT%) EXTERNAL
 575: 0000: STRING IN$,OUT$
 576: 0000: INTEGER IN%,OUT%
 577: 0000: END SUB
 578: 0000:  
 579: 0000: \ REM!! *************************************************************!!
 580: 0000: \ REM!! PROCEDURE - CONVERT AN INPUT 4 BYTE INTEGER REPRESENTED AS A !!
 581: 0000: \ REM!! STRING TO A 3 BYTE BINARY INTEGER REPRESENTED AS A STRING    !!
 582: 0000: \ REM!! WHERE BOTH THE INPUT AND OUTPUT MAY BE IMBEDDED WITHIN THE   !!
 583: 0000: \ REM!! GIVEN STRING AT THE GIVEN OFFSET.                            !!
 584: 0000: \ REM!! STRING "OUT$" MUST BE INITIALIZED BEFORE CALLING THE ROUTINE.!!
 585: 0000: \ REM!!
 586: 0000: \ REM!! NOTE: THE OFFSETS PASSED TO THIS ROUTINE ARE UNIT INDEXED
 587: 0000: \ REM!! *************************************************************!!
 588: 0000:  
 589: 0000: SUB INTBIN3 (IN$,IN%,OUT$,OUT%) EXTERNAL
 590: 0000: STRING IN$,OUT$
 591: 0000: INTEGER IN%,OUT%
 592: 0000: END SUB
 593: 0000:  
 594: 0000: \ REM!! *************************************************************!!
 595: 0000: \ REM!! PROCEDURE - CONVERT AN INPUT 4 BYTE INTEGER REPRESENTED AS A !!
 596: 0000: \ REM!! STRING TO A 4 BYTE BINARY INTEGER REPRESENTED AS A STRING    !!
 597: 0000: \ REM!! WHERE BOTH THE INPUT AND OUTPUT MAY BE IMBEDDED WITHIN THE   !!
 598: 0000: \ REM!! GIVEN STRING AT THE GIVEN OFFSET.                            !!
 599: 0000: \ REM!! STRING "OUT$" MUST BE INITIALIZED BEFORE CALLING THE ROUTINE.!!
 600: 0000: \ REM!!
 601: 0000: \ REM!! NOTE: THE OFFSETS PASSED TO THIS ROUTINE ARE UNIT INDEXED
 602: 0000: \ REM!! *************************************************************!!
 603: 0000:  
 604: 0000: SUB INTBIN4 (IN$,IN%,OUT$,OUT%) EXTERNAL
 605: 0000: STRING IN$,OUT$
 606: 0000: INTEGER IN%,OUT%
 607: 0000: END SUB
 608: 0000:  
 609: 0000:                           ! Includes all functions defined by EALGAADF.J86 ! 1.7.RC
 610: 0000: 
 611: 0000: FUNCTION IRF.SET PUBLIC
 612: 0014: 
 613: 0014:     IRF.REPORT.NUM%     =  7
 614: 001d:     IRF.ALT.REPORT.NUM% = 58
 615: 0026:     IRF.RECL%           = 50
 616: 002f:     IRF.FILE.NAME$      = "IRF"
 617: 003e:     IRF.ALT.FILE.NAME$  = "IRFALT"
 618: 004d: 
 619: 004d:     IRFDEX.REPORT.NUM%  = 673                                             ! 1.9 SM+RC
 620: 0056:     IRFDEX.RECL%        = 84                                              ! 1.9 SM 2.1 BG
 621: 005f:     IRFDEX.FILE.NAME$   = "IRFDEX"                                        ! 1.9 SM
 622: 006e: 
 623: 006e:     IRF.MAX.DEALS%      = 40                                              ! 1.9 SM 2.1 BG
 624: 0077:     DIM IRF.DEAL.DATA%(IRF.MAX.DEALS%-1) ! Entries used are 0 to 2        ! 1.6 RC 1.9 SM
 625: 009f:     DIM IRF.DEAL.NUM$(IRF.MAX.DEALS%-1)  ! Entries used are 0 to 2        ! 1.6 RC 1.9 SM
 626: 00cd:     DIM IRF.LIST.ID%(IRF.MAX.DEALS%-1)   ! Entries used are 0 to 2        ! 1.6 RC 1.9 SM
 627: 00fb: 
 628: 00fb: END FUNCTION
 629: 0107: 
 630: 0107: 
 631: 0107: \*******************************************************************************
 632: 0107: \***
 633: 0107: \***    IRF.SPLIT.RECORD
 634: 0107: \***    Interprets DEAL.DATA%(n) variables into sub-variables ...
 635: 0107: \***    DEAL.NUM$(0-2), LIST.ID%(0-2)
 636: 0107: \***    Sets variables that may be "retained" within programs to nulls X'00' ...
 637: 0107: \***    INDICAT2%, INDICAT4%, SALEQUAN$, POINTS%
 638: 0107: \***    The function is called immediately following a READ of the IRF.
 639: 0107: \***
 640: 0107: \***............................................................................
 641: 0107: 
 642: 0107: 
 643: 0107: FUNCTION IRF.SPLIT.RECORD ! Local to IRFFUN       ! Entire function new for 1.6 RC
 644: 011b: 
 645: 011b:     IRF.DD.SUB% = 0
 646: 0123: 
 647: 0123:     FOR I% = 0 TO IRF.MAX.DEALS% - 1                                    ! 1.9 SM
 648: 012c: 
 649: 012c:         IRF.DEAL.NUM$(I%) = PACK$(RIGHT$("0000"+                        \ 1.9 SM
 650: 018f:                               STR$(IRF.DEAL.DATA%(I%) AND 03FFFh),4))   ! 1.9 SM
 651: 018f:         IRF.LIST.ID%(I%) = SHIFT(IRF.DEAL.DATA%(I%),14) AND 03h         ! 1.9 SM
 652: 01e7: 
 653: 01e7:     NEXT I%                                                             ! 1.9 SM
 654: 01ff: 
 655: 01ff:     IRF.INDICAT2% = 0           ! Redundant variable
 656: 0207:     IRF.INDICAT4% = 0           ! Redundant variable
 657: 020f:     IRF.POINTS%   = 0           ! Redundant variable
 658: 0218:     IRF.SALEQUAN$ = PACK$("00") ! Redundant variable
 659: 022c: 
 660: 022c: END FUNCTION
 661: 0238: 
 662: 0238: 
 663: 0238: \*******************************************************************************
 664: 0238: \***
 665: 0238: \***    IRF.CONCAT.RECORD
 666: 0238: \***    Recreates DEAL.DATA%(n) variables from (interpreted) sub-variables ...
 667: 0238: \***    DEAL.NUM$(0-2), LIST.ID%(0-2).
 668: 0238: \***    The function is called immediately prior to a WRITE to the IRF.
 669: 0238: \***
 670: 0238: \***............................................................................
 671: 0238: 
 672: 0238: 
 673: 0238: FUNCTION IRF.CONCAT.RECORD ! Local to IRFFUN      ! Entire function new for 1.6 RC
 674: 024c: 
 675: 024c:     INTEGER*2 DEAL.NUM%                                                 ! 1.9 SM
 676: 024c: 
 677: 024c:     FOR I% = 0 TO IRF.MAX.DEALS% - 1                                    ! 1.9 SM
 678: 0255: 
 679: 0255:         DEAL.NUM% = VAL(UNPACK$(IRF.DEAL.NUM$(I%))) AND 03FFFh          ! 1.9 SM
 680: 02aa:         IF IRF.LIST.ID%(I%) AND 1 THEN BEGIN                            ! 1.9 SM
 681: 02c3:             DEAL.NUM% = DEAL.NUM% OR 04000h                             ! 1.9 SM
 682: 02cc:         ENDIF                                                           ! 1.9 SM
 683: 02cc:         IF IRF.LIST.ID%(I%) AND 2 THEN BEGIN                            ! 1.9 SM
 684: 02e5:             DEAL.NUM% = DEAL.NUM% OR 08000h                             ! 1.9 SM
 685: 02ee:         ENDIF                                                           ! 1.9 SM
 686: 02ee:         IRF.DEAL.DATA%(I%) = DEAL.NUM%                                  ! 1.9 SM
 687: 0303: 
 688: 0303:     NEXT I%                                                             ! 1.9 SM
 689: 031b: 
 690: 031b: END FUNCTION
 691: 0327: 
 692: 0327: 
 693: 0327: \********************************************************************************
 694: 0327: \***
 695: 0327: \***    CONCAT.NEW.IRF.DATA$
 696: 0327: \***    Sets NEW.IRF.DATA$ from individual IRF variables.
 697: 0327: \***    The function is typically called immediately prior to calling the
 698: 0327: \***    UPDT.IRF.UPDT function defined within PSBF19.
 699: 0327: \***
 700: 0327: \***.............................................................................
 701: 0327: 
 702: 0327: 
 703: 0327: FUNCTION CONCAT.NEW.IRF.DATA$ PUBLIC             ! Entire function new for 1.7 RC
 704: 033b: 
 705: 033b:     NEW.IRF.DATA$ =          \
 706: 0446:            IRF.BAR.CODE$   + \
 707: 0446:       CHR$(IRF.INDICAT0%)  + \
 708: 0446:       CHR$(IRF.INDICAT1%)  + \
 709: 0446:           "  "             + \ ! Reserves two bytes for IRF.DEAL.DATA%(0)
 710: 0446:       CHR$(IRF.INDICAT8%)  + \ ! New WEEE Item Flag                        ! 2.0 AC
 711: 0446: \!           IRF.UNUSED$     + \                                           ! 2.2 TT
 712: 0446:       CHR$(IRF.INDICAT9%)  + \                                             ! 2.2 TT
 713: 0446:       CHR$(IRF.INDICAT10%) + \                                             ! 2.2 TT
 714: 0446:            IRF.SALEPRIC$   + \
 715: 0446:       CHR$(IRF.INDICAT5%)  + \
 716: 0446:            IRF.ITEMNAME$   + \
 717: 0446:            IRF.BOOTS.CODE$ + \
 718: 0446:           "  "             + \ ! Reserves two bytes for IRF.DEAL.DATA%(1)
 719: 0446:           "  "             + \ ! Reserves two bytes for IRF.DEAL.DATA%(2)
 720: 0446:       CHR$(IRF.INDICAT3%)  + \                                             ! 1.9 RC
 721: 0446:       STRING$((IRF.MAX.DEALS% * 2) - 6, " ")                                ! 2.1 BG
 722: 0446: !          "  "             + \ ! Reserves two bytes for IRF.DEAL.DATA%(3)  ! 1.9 RC 2.1 BG
 723: 0446: !          "  "             + \ ! Reserves two bytes for IRF.DEAL.DATA%(4)  ! 1.9 RC 2.1 BG
 724: 0446: !          "  "             + \ ! Reserves two bytes for IRF.DEAL.DATA%(5)  ! 1.9 RC 2.1 BG
 725: 0446: !          "  "             + \ ! Reserves two bytes for IRF.DEAL.DATA%(6)  ! 1.9 RC 2.1 BG
 726: 0446: !          "  "             + \ ! Reserves two bytes for IRF.DEAL.DATA%(7)  ! 1.9 RC 2.1 BG
 727: 0446: !          "  "             + \ ! Reserves two bytes for IRF.DEAL.DATA%(8)  ! 1.9 RC 2.1 BG
 728: 0446: !          "  "                 ! Reserves two bytes for IRF.DEAL.DATA%(9)  ! 1.9 RC 2.1 BG
 729: 0446: 
 730: 0446:     CALL IRF.CONCAT.RECORD ! Sets local IRF.DEAL.DATA%(n) variables from global
 731: 0458:                            ! IRF.LIST.ID%(n) and IRF.DEAL.NUM$(n) variables
 732: 0458: 
 733: 0458:     CALL PUTN2 (NEW.IRF.DATA$, 13, IRF.DEAL.DATA%(0)) ! Inserts IRF.DEAL.DATA%(n)
 734: 048b:     CALL PUTN2 (NEW.IRF.DATA$, 45, IRF.DEAL.DATA%(1)) ! variables into string
 735: 04be:     CALL PUTN2 (NEW.IRF.DATA$, 47, IRF.DEAL.DATA%(2)) ! NEW.IRF.DATA$
 736: 04f1: !    CALL PUTN2 (NEW.IRF.DATA$, 50, IRF.DEAL.DATA%(3))                      ! 1.9 RC 2.1 BG
 737: 04f1: !    CALL PUTN2 (NEW.IRF.DATA$, 52, IRF.DEAL.DATA%(4))                      ! 1.9 RC 2.1 BG
 738: 04f1: !    CALL PUTN2 (NEW.IRF.DATA$, 54, IRF.DEAL.DATA%(5))                      ! 1.9 RC 2.1 BG
 739: 04f1: !    CALL PUTN2 (NEW.IRF.DATA$, 56, IRF.DEAL.DATA%(6))                      ! 1.9 RC 2.1 BG
 740: 04f1: !    CALL PUTN2 (NEW.IRF.DATA$, 58, IRF.DEAL.DATA%(7))                      ! 1.9 RC 2.1 BG
 741: 04f1: !    CALL PUTN2 (NEW.IRF.DATA$, 60, IRF.DEAL.DATA%(8))                      ! 1.9 RC 2.1 BG
 742: 04f1: !    CALL PUTN2 (NEW.IRF.DATA$, 62, IRF.DEAL.DATA%(9))                      ! 1.9 RC 2.1 BG
 743: 04f1: 
 744: 04f1:     OFFSET% = 50                                                            ! 2.1 BG
 745: 04f7:     FOR I% = 3 TO IRF.MAX.DEALS% - 1                                        ! 2.1 BG
 746: 04ff:         CALL PUTN2 (NEW.IRF.DATA$, OFFSET%, IRF.DEAL.DATA%(I%))             ! 2.1 BG
 747: 0536:         OFFSET% = OFFSET% + 2                                               ! 2.1 BG
 748: 053b:     NEXT I%                                                                 ! 2.1 BG
 749: 0550: 
 750: 0550: 
 751: 0550: END FUNCTION
 752: 0561: 
 753: 0561: 
 754: 0561: \********************************************************************************
 755: 0561: \***
 756: 0561: \***    SPLIT.NEW.IRF.DATA$
 757: 0561: \***    Sets individual IRF variables from NEW.IRF.DATA$
 758: 0561: \***    The function is typically called from within the UPDT.IRF.UPDT function
 759: 0561: \***    defined within PSBF19.
 760: 0561: \***
 761: 0561: \***.............................................................................
 762: 0561: 
 763: 0561: 
 764: 0561: FUNCTION SPLIT.NEW.IRF.DATA$ PUBLIC              ! Entire function new for 1.7 RC
 765: 0575: 
 766: 0575:     IRF.BAR.CODE$      =      MID$(NEW.IRF.DATA$, 1,11)
 767: 0594:     IRF.INDICAT0%      =  ASC(MID$(NEW.IRF.DATA$,12, 1))
 768: 05b7:     IRF.INDICAT1%      =  ASC(MID$(NEW.IRF.DATA$,13, 1))
 769: 05da: !   IRF.DEAL.DATA%(0) from    MID$(NEW.IRF.DATA$,14, 2)
 770: 05da:     IRF.INDICAT8%      =  ASC(MID$(NEW.IRF.DATA$,16, 1))                 ! 2.0 AC
 771: 05fd: !   IRF.UNUSED$        =      MID$(NEW.IRF.DATA$,17, 2)                  ! 2.0 AC 2.2 TT
 772: 05fd:     IRF.INDICAT9%      =  ASC(MID$(NEW.IRF.DATA$,17, 1))                 ! 2.2 TT
 773: 0620:     IRF.INDICAT10%     =  ASC(MID$(NEW.IRF.DATA$,18, 1))                 ! 2.2 TT
 774: 0643:     IRF.SALEPRIC$      =      MID$(NEW.IRF.DATA$,19, 5)
 775: 0662:     IRF.INDICAT5%      =  ASC(MID$(NEW.IRF.DATA$,24, 1))
 776: 0685:     IRF.ITEMNAME$      =      MID$(NEW.IRF.DATA$,25,18)
 777: 06a4:     IRF.BOOTS.CODE$    =      MID$(NEW.IRF.DATA$,43, 3)
 778: 06c3: !   IRF.DEAL.DATA%(1) from    MID$(NEW.IRF.DATA$,46, 2)
 779: 06c3: !   IRF.DEAL.DATA%(2) from    MID$(NEW.IRF.DATA$,48, 2)
 780: 06c3:     IRF.INDICAT3%      =  ASC(MID$(NEW.IRF.DATA$,50, 1))
 781: 06e6: 
 782: 06e6:     IRF.DEAL.DATA%(0) = GETN2 (NEW.IRF.DATA$, 13) ! Extracts IRF.DEAL.DATA%(n)
 783: 0711:     IRF.DEAL.DATA%(1) = GETN2 (NEW.IRF.DATA$, 45) ! variables from string
 784: 073c:     IRF.DEAL.DATA%(2) = GETN2 (NEW.IRF.DATA$, 47) ! NEW.IRF.DATA$
 785: 0767: !    IRF.DEAL.DATA%(3) = GETN2 (NEW.IRF.DATA$, 50)                       ! 1.9 RC 2.1 BG
 786: 0767: !    IRF.DEAL.DATA%(4) = GETN2 (NEW.IRF.DATA$, 52)                       ! 1.9 RC 2.1 BG
 787: 0767: !    IRF.DEAL.DATA%(5) = GETN2 (NEW.IRF.DATA$, 54)                       ! 1.9 RC 2.1 BG
 788: 0767: !    IRF.DEAL.DATA%(6) = GETN2 (NEW.IRF.DATA$, 56)                       ! 1.9 RC 2.1 BG
 789: 0767: !    IRF.DEAL.DATA%(7) = GETN2 (NEW.IRF.DATA$, 58)                       ! 1.9 RC 2.1 BG
 790: 0767: !    IRF.DEAL.DATA%(8) = GETN2 (NEW.IRF.DATA$, 60)                       ! 1.9 RC 2.1 BG
 791: 0767: !    IRF.DEAL.DATA%(9) = GETN2 (NEW.IRF.DATA$, 62)                       ! 1.9 RC 2.1 BG
 792: 0767: 
 793: 0767:     OFFSET% = 50                                                        ! 2.1 BG
 794: 076d:     FOR I% = 3 TO IRF.MAX.DEALS% - 1                                    ! 2.1 BG
 795: 0775:         IRF.DEAL.DATA%(I%) = GETN2 (NEW.IRF.DATA$, OFFSET%)             ! 2.1 BG
 796: 07a4:         OFFSET% = OFFSET% + 2                                           ! 2.1 BG
 797: 07a9:     NEXT I%                                                             ! 2.1 BG
 798: 07be: 
 799: 07be:     CALL IRF.SPLIT.RECORD ! Sets global IRF.LIST.ID%(n) and IRF.DEAL.NUM$(n)
 800: 07d0:                           ! variables from local IRF.DEAL.DATA%(n) variables
 801: 07d0: 
 802: 07d0: END FUNCTION
 803: 07e1: 
 804: 07e1: 
 805: 07e1: \----------------------------------------------------------------------------
 806: 07e1: 
 807: 07e1:     FUNCTION READ.IRFDEX                                                  ! 1.9 SM
 808: 07f5: 
 809: 07f5:     INTEGER*2 READ.IRFDEX                                                 ! 1.9 SM
 810: 07f5: 
 811: 07f5:     READ.IRFDEX = 1                                                       ! 1.9 SM
 812: 07fa: 
 813: 07fa:     IF IRFDEX.SESS.NUM% <> 0 AND                                          \ 1.9 SM
 814: 085a:        IRF.DEAL.DATA%(2) <> 0 AND                                         \ 1.9 SM
 815: 085a:        IRF.BOOTS.CODE$ <> PACK$("000000") THEN BEGIN                      ! 1.9 SM
 816: 085a: 
 817: 085a:         IF END #IRFDEX.SESS.NUM% THEN READ.IRFDEX.ERROR                   ! 1.9 SM
 818: 086e:         READ FORM "T4,37I2,C7"; #IRFDEX.SESS.NUM%                         \ 1.9 SM 2.1 BG
 819: 0b86:         KEY IRF.BOOTS.CODE$;                                              \ 1.9 SM
 820: 0b86:             IRF.DEAL.DATA%(3),                                            \ 1.9 SM
 821: 0b86:             IRF.DEAL.DATA%(4),                                            \ 1.9 SM
 822: 0b86:             IRF.DEAL.DATA%(5),                                            \ 1.9 SM
 823: 0b86:             IRF.DEAL.DATA%(6),                                            \ 1.9 SM
 824: 0b86:             IRF.DEAL.DATA%(7),                                            \ 1.9 SM
 825: 0b86:             IRF.DEAL.DATA%(8),                                            \ 1.9 SM
 826: 0b86:             IRF.DEAL.DATA%(9),                                            \ 1.9 SM 2.1 BG
 827: 0b86:             IRF.DEAL.DATA%(10),                                           \ 2.1 BG
 828: 0b86:             IRF.DEAL.DATA%(11),                                           \ 2.1 BG
 829: 0b86:             IRF.DEAL.DATA%(12),                                           \ 2.1 BG
 830: 0b86:             IRF.DEAL.DATA%(13),                                           \ 2.1 BG
 831: 0b86:             IRF.DEAL.DATA%(14),                                           \ 2.1 BG
 832: 0b86:             IRF.DEAL.DATA%(15),                                           \ 2.1 BG
 833: 0b86:             IRF.DEAL.DATA%(16),                                           \ 2.1 BG
 834: 0b86:             IRF.DEAL.DATA%(17),                                           \ 2.1 BG
 835: 0b86:             IRF.DEAL.DATA%(18),                                           \ 2.1 BG
 836: 0b86:             IRF.DEAL.DATA%(19),                                           \ 2.1 BG
 837: 0b86:             IRF.DEAL.DATA%(20),                                           \ 2.1 BG
 838: 0b86:             IRF.DEAL.DATA%(21),                                           \ 2.1 BG
 839: 0b86:             IRF.DEAL.DATA%(22),                                           \ 2.1 BG
 840: 0b86:             IRF.DEAL.DATA%(23),                                           \ 2.1 BG
 841: 0b86:             IRF.DEAL.DATA%(24),                                           \ 2.1 BG
 842: 0b86:             IRF.DEAL.DATA%(25),                                           \ 2.1 BG
 843: 0b86:             IRF.DEAL.DATA%(26),                                           \ 2.1 BG
 844: 0b86:             IRF.DEAL.DATA%(27),                                           \ 2.1 BG
 845: 0b86:             IRF.DEAL.DATA%(28),                                           \ 2.1 BG
 846: 0b86:             IRF.DEAL.DATA%(29),                                           \ 2.1 BG
 847: 0b86:             IRF.DEAL.DATA%(30),                                           \ 2.1 BG
 848: 0b86:             IRF.DEAL.DATA%(31),                                           \ 2.1 BG
 849: 0b86:             IRF.DEAL.DATA%(32),                                           \ 2.1 BG
 850: 0b86:             IRF.DEAL.DATA%(33),                                           \ 2.1 BG
 851: 0b86:             IRF.DEAL.DATA%(34),                                           \ 2.1 BG
 852: 0b86:             IRF.DEAL.DATA%(35),                                           \ 2.1 BG
 853: 0b86:             IRF.DEAL.DATA%(36),                                           \ 2.1 BG
 854: 0b86:             IRF.DEAL.DATA%(37),                                           \ 2.1 BG
 855: 0b86:             IRF.DEAL.DATA%(38),                                           \ 2.1 BG
 856: 0b86:             IRF.DEAL.DATA%(39),                                           \ 2.1 BG
 857: 0b86:             FILLER$                                                       ! 2.1 BG
 858: 0b86: 
 859: 0b86:     ENDIF ELSE BEGIN                                                      ! 1.9 SM
 860: 0b86: 
 861: 0b86: READ.IRFDEX.ERROR:                                                        ! 1.9 SM
 862: 0b86:         FOR I% = 3 TO IRF.MAX.DEALS% - 1                                  ! 1.9 SM
 863: 0b8e:             IRF.DEAL.DATA%(I%) = 0                                        ! 1.9 SM
 864: 0ba2:         NEXT I%                                                           ! 1.9 SM
 865: 0bb7: 
 866: 0bb7:     ENDIF                                                                 ! 1.9 SM
 867: 0bb7: 
 868: 0bb7:     READ.IRFDEX = 0                                                       ! 1.9 SM
 869: 0bbc:     EXIT FUNCTION                                                         ! 1.9 SM
 870: 0bbe: 
 871: 0bbe:     END FUNCTION                                                          ! 1.9 SM
 872: 0bcd: 
 873: 0bcd: \----------------------------------------------------------------------------
 874: 0bcd: 
 875: 0bcd:     FUNCTION WRITE.IRFDEX                                                 ! 1.9 SM
 876: 0be1: 
 877: 0be1:     INTEGER*2 WRITE.IRFDEX                                                ! 1.9 SM
 878: 0be1: 
 879: 0be1:     WRITE.IRFDEX = 1                                                      ! 1.9 SM
 880: 0be6: 
 881: 0be6:     IF IRFDEX.SESS.NUM% THEN BEGIN                                        ! 1.9 SM
 882: 0bf4: 
 883: 0bf4:         IF IRF.BAR.CODE$ = PACK$("0000000000000000")+IRF.BOOTS.CODE$ THEN BEGIN ! 1.9 SM
 884: 0c33: 
 885: 0c33:             IF IRF.DEAL.DATA%(3) <> 0 THEN BEGIN                          ! 1.9 SM
 886: 0c49: 
 887: 0c49:                 !Ensure filler is packed zero's.                          ! 2.1 BG
 888: 0c49:                 FILLER$ = PACK$("00000000000000")                         ! 2.1 BG
 889: 0c5d: 
 890: 0c5d:                 IF END #IRFDEX.SESS.NUM% THEN WRITE.IRFDEX.ERROR          ! 1.9 SM
 891: 0c71:                 WRITE FORM "C3,37I2,C7"; #IRFDEX.SESS.NUM%;               \ 1.9 SM 2.1 BG
 892: 0fae:                     IRF.BOOTS.CODE$,                                      \ 1.9 SM
 893: 0fae:                     IRF.DEAL.DATA%(3),                                    \ 1.9 SM
 894: 0fae:                     IRF.DEAL.DATA%(4),                                    \ 1.9 SM
 895: 0fae:                     IRF.DEAL.DATA%(5),                                    \ 1.9 SM
 896: 0fae:                     IRF.DEAL.DATA%(6),                                    \ 1.9 SM
 897: 0fae:                     IRF.DEAL.DATA%(7),                                    \ 1.9 SM
 898: 0fae:                     IRF.DEAL.DATA%(8),                                    \ 1.9 SM
 899: 0fae:                     IRF.DEAL.DATA%(9),                                    \ 1.9 SM 2.1 BG
 900: 0fae:                     IRF.DEAL.DATA%(10),                                   \ 2.1 BG
 901: 0fae:                     IRF.DEAL.DATA%(11),                                   \ 2.1 BG
 902: 0fae:                     IRF.DEAL.DATA%(12),                                   \ 2.1 BG
 903: 0fae:                     IRF.DEAL.DATA%(13),                                   \ 2.1 BG
 904: 0fae:                     IRF.DEAL.DATA%(14),                                   \ 2.1 BG
 905: 0fae:                     IRF.DEAL.DATA%(15),                                   \ 2.1 BG
 906: 0fae:                     IRF.DEAL.DATA%(16),                                   \ 2.1 BG
 907: 0fae:                     IRF.DEAL.DATA%(17),                                   \ 2.1 BG
 908: 0fae:                     IRF.DEAL.DATA%(18),                                   \ 2.1 BG
 909: 0fae:                     IRF.DEAL.DATA%(19),                                   \ 2.1 BG
 910: 0fae:                     IRF.DEAL.DATA%(20),                                   \ 2.1 BG
 911: 0fae:                     IRF.DEAL.DATA%(21),                                   \ 2.1 BG
 912: 0fae:                     IRF.DEAL.DATA%(22),                                   \ 2.1 BG
 913: 0fae:                     IRF.DEAL.DATA%(23),                                   \ 2.1 BG
 914: 0fae:                     IRF.DEAL.DATA%(24),                                   \ 2.1 BG
 915: 0fae:                     IRF.DEAL.DATA%(25),                                   \ 2.1 BG
 916: 0fae:                     IRF.DEAL.DATA%(26),                                   \ 2.1 BG
 917: 0fae:                     IRF.DEAL.DATA%(27),                                   \ 2.1 BG
 918: 0fae:                     IRF.DEAL.DATA%(28),                                   \ 2.1 BG
 919: 0fae:                     IRF.DEAL.DATA%(29),                                   \ 2.1 BG
 920: 0fae:                     IRF.DEAL.DATA%(30),                                   \ 2.1 BG
 921: 0fae:                     IRF.DEAL.DATA%(31),                                   \ 2.1 BG
 922: 0fae:                     IRF.DEAL.DATA%(32),                                   \ 2.1 BG
 923: 0fae:                     IRF.DEAL.DATA%(33),                                   \ 2.1 BG
 924: 0fae:                     IRF.DEAL.DATA%(34),                                   \ 2.1 BG
 925: 0fae:                     IRF.DEAL.DATA%(35),                                   \ 2.1 BG
 926: 0fae:                     IRF.DEAL.DATA%(36),                                   \ 2.1 BG
 927: 0fae:                     IRF.DEAL.DATA%(37),                                   \ 2.1 BG
 928: 0fae:                     IRF.DEAL.DATA%(38),                                   \ 2.1 BG
 929: 0fae:                     IRF.DEAL.DATA%(39),                                   \ 2.1 BG
 930: 0fae:                     FILLER$                                               ! 2.1 BG
 931: 0fae: 
 932: 0fae:             ENDIF ELSE BEGIN                                              ! 1.9 SM
 933: 0fae: 
 934: 0fae:                 IF END #IRFDEX.SESS.NUM% THEN NO.IRFDEX.RECORD            ! 1.9 SM
 935: 0fc2:                 DELREC IRFDEX.SESS.NUM%; IRF.BOOTS.CODE$                  ! 1.9 SM
 936: 0fd9: NO.IRFDEX.RECORD:                                                         ! 1.9 SM
 937: 0fd9:             ENDIF                                                         ! 1.9 SM
 938: 0fd9: 
 939: 0fd9:         ENDIF                                                             ! 1.9 SM
 940: 0fd9: 
 941: 0fd9:     ENDIF                                                                 ! 1.9 SM
 942: 0fd9: 
 943: 0fd9:     WRITE.IRFDEX = 0                                                      ! 1.9 SM
 944: 0fde:     EXIT FUNCTION                                                         ! 1.9 SM
 945: 0fe0: 
 946: 0fe0: WRITE.IRFDEX.ERROR:                                                       ! 1.9 SM
 947: 0fe0:     CURRENT.REPORT.NUM% = IRFDEX.REPORT.NUM%                              ! 1.9 SM
 948: 0fee:     FILE.OPERATION$ = "W"                                                 ! 1.9 SM
 949: 0ffd:     CURRENT.CODE$ = PACK$("00000000") + IRF.BOOTS.CODE$                   ! 1.9 SM
 950: 102a: 
 951: 102a:     EXIT FUNCTION                                                         ! 1.9 SM
 952: 102c: 
 953: 102c:     END FUNCTION                                                          ! 1.9 SM
 954: 103b: 
 955: 103b: \---------------------------------------------------------------------------------
 956: 103b: 
 957: 103b:   FUNCTION READ.IRF PUBLIC
 958: 104f: 
 959: 104f:    INTEGER*2 READ.IRF
 960: 104f: 
 961: 104f:    READ.IRF = 1
 962: 1054: 
 963: 1054:    IF END#IRF.SESS.NUM% THEN READ.IRF.ERROR
 964: 1068: 
 965: 1068:     READ FORM  "T12,2I1,I2,I1,2I1,C5,I1,C18,C3,I2,I2,I1"; \               ! 1.6.RC ! 2.0 AJC ! 2.2 TT
 966: 1139:          #IRF.SESS.NUM%                                             \ MW96A
 967: 1139:          KEY IRF.BAR.CODE$;                                         \
 968: 1139:              IRF.INDICAT0%,                                         \
 969: 1139:              IRF.INDICAT1%,                                         \
 970: 1139:              IRF.DEAL.DATA%(0),                                     \     ! 1.6 RC
 971: 1139:              IRF.INDICAT8%,                                         \     ! 2.0 AJC
 972: 1139: \!            IRF.UNUSED$,                                          \     ! 1.6 RC 2.2 TT
 973: 1139:              IRF.INDICAT9%,                                         \     ! 2.2 TT
 974: 1139:              IRF.INDICAT10%,                                        \     ! 2.2 TT
 975: 1139:              IRF.SALEPRIC$,                                         \
 976: 1139:              IRF.INDICAT5%,                                         \ SBH 31/1/96
 977: 1139:              IRF.ITEMNAME$,                                         \
 978: 1139:              IRF.BOOTS.CODE$,                                       \
 979: 1139:              IRF.DEAL.DATA%(1),                                     \     ! 1.6 RC
 980: 1139:              IRF.DEAL.DATA%(2),                                     \     ! 1.6 RC
 981: 1139:              IRF.INDICAT3%
 982: 1139: 
 983: 1139:     IF READ.IRFDEX THEN EXIT FUNCTION                                     ! 1.9 SM
 984: 1143: 
 985: 1143:     CALL IRF.SPLIT.RECORD                                                 ! 1.6 RC
 986: 1155: 
 987: 1155:     READ.IRF = 0
 988: 115a: 
 989: 115a:     IRF.RECORD$ = "CONVERTED RECORD"                                ! DS96A
 990: 1169: 
 991: 1169:    EXIT FUNCTION
 992: 116b: 
 993: 116b:    READ.IRF.ERROR:
 994: 116b: 
 995: 116b:    CURRENT.REPORT.NUM% = IRF.REPORT.NUM%
 996: 1179:    FILE.OPERATION$ = "R"
 997: 1188:    CURRENT.CODE$ = RIGHT$(IRF.BAR.CODE$,7)                          ! FMW
 998: 11a5: 
 999: 11a5:    EXIT FUNCTION
1000: 11a7:   END FUNCTION
1001: 11b6: 
1002: 11b6: \----------------------------------------------------------------------------
1003: 11b6: 
1004: 11b6:   FUNCTION READ.IRF.ALT PUBLIC
1005: 11ca: 
1006: 11ca:    INTEGER*2 I%                                                           ! 1.9 SM
1007: 11ca:    INTEGER*2 READ.IRF.ALT
1008: 11ca: 
1009: 11ca:    READ.IRF.ALT = 1
1010: 11cf: 
1011: 11cf:    IF END#IRF.ALT.SESS.NUM% THEN READ.IRF.ALT.ERROR
1012: 11e3: 
1013: 11e3:     READ FORM  "T12,2I1,I2,I1,2I1,C5,I1,C18,C3,I2,I2,I1"; \               ! 1.6.RC ! 2.0 AJC ! 2.2 TT
1014: 12b4:          #IRF.ALT.SESS.NUM%                                         \
1015: 12b4:          KEY IRF.BAR.CODE$;                                         \
1016: 12b4:              IRF.INDICAT0%,                                         \
1017: 12b4:              IRF.INDICAT1%,                                         \
1018: 12b4:              IRF.DEAL.DATA%(0),                                     \     ! 1.6 RC
1019: 12b4:              IRF.INDICAT8%,                                         \     ! 2.0 AJC
1020: 12b4: \!            IRF.UNUSED$,                                          \     ! 1.6 RC 2.2 TT
1021: 12b4:              IRF.INDICAT9%,                                         \     ! 2.2 TT
1022: 12b4:              IRF.INDICAT10%,                                        \     ! 2.2 TT
1023: 12b4:              IRF.SALEPRIC$,                                         \
1024: 12b4:              IRF.INDICAT5%,                                         \ SBH 31/1/96
1025: 12b4:              IRF.ITEMNAME$,                                         \
1026: 12b4:              IRF.BOOTS.CODE$,                                       \
1027: 12b4:              IRF.DEAL.DATA%(1),                                     \     ! 1.6 RC
1028: 12b4:              IRF.DEAL.DATA%(2),                                     \     ! 1.6 RC
1029: 12b4:              IRF.INDICAT3%
1030: 12b4: 
1031: 12b4:     IF READ.IRFDEX THEN EXIT FUNCTION                                     ! 1.9 RC
1032: 12be: 
1033: 12be: !   FOR I% = 3 TO IRF.MAX.DEALS% - 1                                      ! 1.9 SM-RC
1034: 12be: !       IRF.DEAL.DATA%(I%) = 0                                            ! 1.9 SM-RC
1035: 12be: !   NEXT I%                                                               ! 1.9 SM-RC
1036: 12be: 
1037: 12be:     CALL IRF.SPLIT.RECORD                                                 ! 1.6 RC
1038: 12d0: 
1039: 12d0:     READ.IRF.ALT = 0
1040: 12d5: 
1041: 12d5:     IRF.RECORD$ = "CONVERTED RECORD"                                ! DS96A
1042: 12e4: 
1043: 12e4:    EXIT FUNCTION
1044: 12e6: 
1045: 12e6:    READ.IRF.ALT.ERROR:
1046: 12e6: 
1047: 12e6:    CURRENT.REPORT.NUM% = IRF.ALT.REPORT.NUM%
1048: 12f4:    FILE.OPERATION$ = "R"
1049: 1303:    CURRENT.CODE$ = RIGHT$(IRF.BAR.CODE$,7)                          ! FMW
1050: 1320: 
1051: 1320:    EXIT FUNCTION
1052: 1322:   END FUNCTION
1053: 1331: 
1054: 1331: \----------------------------------------------------------------------------
1055: 1331: 
1056: 1331:   FUNCTION READ.IRF.LOCK PUBLIC
1057: 1345: 
1058: 1345:    INTEGER*2 READ.IRF.LOCK
1059: 1345: 
1060: 1345:    READ.IRF.LOCK = 1
1061: 134a: 
1062: 134a:    IF END#IRF.SESS.NUM% THEN READ.IRF.LOCK.ERROR
1063: 135e: 
1064: 135e:     READ FORM  "T12,2I1,I2,I1,2I1,C5,I1,C18,C3,I2,I2,I1"; \               ! 1.6.RC ! 2.0 AJC ! 2.2 TT
1065: 142f:          #IRF.SESS.NUM%                                             \ MW96A
1066: 142f:          AUTOLOCK                                                   \
1067: 142f:          KEY IRF.BAR.CODE$;                                         \
1068: 142f:              IRF.INDICAT0%,                                         \
1069: 142f:              IRF.INDICAT1%,                                         \
1070: 142f:              IRF.DEAL.DATA%(0),                                     \     ! 1.6 RC
1071: 142f:              IRF.INDICAT8%,                                         \     ! 2.0 AJC
1072: 142f: \!            IRF.UNUSED$,                                          \     ! 1.6 RC 2.2 TT
1073: 142f:              IRF.INDICAT9%,                                         \     ! 2.2 TT
1074: 142f:              IRF.INDICAT10%,                                        \     ! 2.2 TT
1075: 142f:              IRF.SALEPRIC$,                                         \
1076: 142f:              IRF.INDICAT5%,                                         \ SBH 31/1/96
1077: 142f:              IRF.ITEMNAME$,                                         \
1078: 142f:              IRF.BOOTS.CODE$,                                       \
1079: 142f:              IRF.DEAL.DATA%(1),                                     \     ! 1.6 RC
1080: 142f:              IRF.DEAL.DATA%(2),                                     \     ! 1.6 RC
1081: 142f:              IRF.INDICAT3%
1082: 142f: 
1083: 142f:     IF READ.IRFDEX THEN EXIT FUNCTION                                     ! 1.9 SM
1084: 1439: 
1085: 1439:     CALL IRF.SPLIT.RECORD                                                 ! 1.6 RC
1086: 144b: 
1087: 144b:     READ.IRF.LOCK = 0
1088: 1450: 
1089: 1450:     IRF.RECORD$ = "CONVERTED RECORD"                                ! DS96A
1090: 145f: 
1091: 145f:    EXIT FUNCTION
1092: 1461: 
1093: 1461:    READ.IRF.LOCK.ERROR:
1094: 1461: 
1095: 1461:    CURRENT.REPORT.NUM% = IRF.REPORT.NUM%
1096: 146f:    FILE.OPERATION$ = "R"
1097: 147e:    CURRENT.CODE$ = RIGHT$(IRF.BAR.CODE$,7)                          ! FMW
1098: 149b: 
1099: 149b:    EXIT FUNCTION
1100: 149d:   END FUNCTION
1101: 14ac: 
1102: 14ac: \----------------------------------------------------------------------------
1103: 14ac: 
1104: 14ac:   FUNCTION WRITE.IRF PUBLIC
1105: 14c0: 
1106: 14c0:    INTEGER*2 WRITE.IRF
1107: 14c0: 
1108: 14c0:     WRITE.IRF = 1
1109: 14c5: 
1110: 14c5:     CALL IRF.CONCAT.RECORD                                                ! 1.6 RC
1111: 14d7: 
1112: 14d7:     IF END#IRF.SESS.NUM% THEN WRITE.IRF.ERROR
1113: 14eb: 
1114: 14eb:     WRITE FORM "C11,2I1,I2,I1,2I1,C5,I1,C18,C3,I2,I2,I1"; \               ! 1.6 RC ! 2.0 AJC ! 2.2 TT
1115: 15de:           #IRF.SESS.NUM%;                                         \ 96AM
1116: 15de:              IRF.BAR.CODE$,                                       \ 96AMW
1117: 15de:              IRF.INDICAT0%,                                       \
1118: 15de:              IRF.INDICAT1%,                                       \
1119: 15de:              IRF.DEAL.DATA%(0),                                   \       ! 1.6 RC
1120: 15de:              IRF.INDICAT8%,                                       \       ! 2.0 AJC
1121: 15de: \!            IRF.UNUSED$,                                        \       ! 1.6 RC 2.2 TT
1122: 15de:              IRF.INDICAT9%,                                       \       ! 2.2 TT
1123: 15de:              IRF.INDICAT10%,                                      \       ! 2.2 TT
1124: 15de:              IRF.SALEPRIC$,                                       \
1125: 15de:              IRF.INDICAT5%,                                       \ SBH 31/1/96
1126: 15de:              IRF.ITEMNAME$,                                       \
1127: 15de:              IRF.BOOTS.CODE$,                                     \
1128: 15de:              IRF.DEAL.DATA%(1),                                   \       ! 1.6 RC
1129: 15de:              IRF.DEAL.DATA%(2),                                   \       ! 1.6 RC
1130: 15de:              IRF.INDICAT3%
1131: 15de: 
1132: 15de:     IF WRITE.IRFDEX THEN EXIT FUNCTION                                    ! 1.9 SM
1133: 15e8: 
1134: 15e8:     WRITE.IRF = 0
1135: 15ed: 
1136: 15ed:    EXIT FUNCTION
1137: 15ef: 
1138: 15ef:    WRITE.IRF.ERROR:
1139: 15ef: 
1140: 15ef:    CURRENT.REPORT.NUM% = IRF.REPORT.NUM%
1141: 15fd:    FILE.OPERATION$ = "W"
1142: 160c:    CURRENT.CODE$ = RIGHT$(IRF.BAR.CODE$,7)                        ! FMW
1143: 1629:    EXIT FUNCTION
1144: 162b: 
1145: 162b:   END FUNCTION
1146: 163a: 
1147: 163a: \----------------------------------------------------------------------------
1148: 163a: 
1149: 163a:   FUNCTION WRITE.IRF.UNLOCK PUBLIC
1150: 164e: 
1151: 164e:    INTEGER*2 WRITE.IRF.UNLOCK
1152: 164e: 
1153: 164e:     WRITE.IRF.UNLOCK = 1
1154: 1653: 
1155: 1653:     CALL IRF.CONCAT.RECORD                                                ! 1.6 RC
1156: 1665: 
1157: 1665:     IF END#IRF.SESS.NUM% THEN WRITE.IRF.UNLOCK.ERROR
1158: 1679: 
1159: 1679:     WRITE FORM "C11,2I1,I2,I1,2I1,C5,I1,C18,C3,I2,I2,I1"; \               ! 1.6 RC ! 2.0 AJC ! 2.2 TT
1160: 176c:          #IRF.SESS.NUM% AUTOUNLOCK;                               \ MW96A
1161: 176c:              IRF.BAR.CODE$,                                       \
1162: 176c:              IRF.INDICAT0%,                                       \
1163: 176c:              IRF.INDICAT1%,                                       \
1164: 176c:              IRF.DEAL.DATA%(0),                                   \       ! 1.6 RC
1165: 176c:              IRF.INDICAT8%,                                       \       ! 2.0 AJC
1166: 176c: \!            IRF.UNUSED$,                                        \       ! 1.6 RC 2.2 TT
1167: 176c:              IRF.INDICAT9%,                                       \       ! 2.2 TT
1168: 176c:              IRF.INDICAT10%,                                      \       ! 2.2 TT
1169: 176c:              IRF.SALEPRIC$,                                       \
1170: 176c:              IRF.INDICAT5%,                                       \ SBH 31/1/96
1171: 176c:              IRF.ITEMNAME$,                                       \
1172: 176c:              IRF.BOOTS.CODE$,                                     \
1173: 176c:              IRF.DEAL.DATA%(1),                                   \       ! 1.6 RC
1174: 176c:              IRF.DEAL.DATA%(2),                                   \       ! 1.6 RC
1175: 176c:              IRF.INDICAT3%
1176: 176c: 
1177: 176c:     IF WRITE.IRFDEX THEN EXIT FUNCTION                                    ! 1.9 SM
1178: 1776: 
1179: 1776:     WRITE.IRF.UNLOCK = 0
1180: 177b: 
1181: 177b:    EXIT FUNCTION
1182: 177d: 
1183: 177d:    WRITE.IRF.UNLOCK.ERROR:
1184: 177d: 
1185: 177d:    CURRENT.REPORT.NUM% = IRF.REPORT.NUM%
1186: 178b:    FILE.OPERATION$ = "W"
1187: 179a:    CURRENT.CODE$ = RIGHT$(IRF.BAR.CODE$,7)                        ! FMW
1188: 17b7: 
1189: 17b7:    EXIT FUNCTION
1190: 17b9: 
1191: 17b9:   END FUNCTION
1192: 17c8: 
1193: 17c8: \----------------------------------------------------------------------------
1194: 17c8: 
1195: 17c8:   FUNCTION WRITE.IRF.HOLD PUBLIC
1196: 17dc: 
1197: 17dc:    INTEGER*2 WRITE.IRF.HOLD
1198: 17dc: 
1199: 17dc:     WRITE.IRF.HOLD = 1
1200: 17e1: 
1201: 17e1:     CALL IRF.CONCAT.RECORD                                                ! 1.6 RC
1202: 17f3: 
1203: 17f3:      IF END#IRF.SESS.NUM% THEN WRITE.IRF.HOLD.ERROR
1204: 1807: 
1205: 1807:      WRITE FORM "C11,2I1,I2,I1,2I1,C5,I1,C18,C3,I2,I2,I1"; HOLD \         ! 1.6 RC ! 2.0 AJC ! 2.2 TT
1206: 18fa:              #IRF.SESS.NUM%;                                      \
1207: 18fa:              IRF.BAR.CODE$,                                       \
1208: 18fa:              IRF.INDICAT0%,                                       \
1209: 18fa:              IRF.INDICAT1%,                                       \
1210: 18fa:              IRF.DEAL.DATA%(0),                                   \       ! 1.6 RC
1211: 18fa:              IRF.INDICAT8%,                                       \       ! 2.0 AJC
1212: 18fa: \!            IRF.UNUSED$,                                        \       ! 1.6 RC 2.2 TT
1213: 18fa:              IRF.INDICAT9%,                                       \       ! 2.2 TT
1214: 18fa:              IRF.INDICAT10%,                                      \       ! 2.2 TT
1215: 18fa:              IRF.SALEPRIC$,                                       \
1216: 18fa:              IRF.INDICAT5%,                                       \ SBH 31/1/96
1217: 18fa:              IRF.ITEMNAME$,                                       \
1218: 18fa:              IRF.BOOTS.CODE$,                                     \
1219: 18fa:              IRF.DEAL.DATA%(1),                                   \       ! 1.6 RC
1220: 18fa:              IRF.DEAL.DATA%(2),                                   \       ! 1.6 RC
1221: 18fa:              IRF.INDICAT3%
1222: 18fa: 
1223: 18fa:     IF WRITE.IRFDEX THEN EXIT FUNCTION                                    ! 1.9 SM
1224: 1904: 
1225: 1904:     WRITE.IRF.HOLD = 0
1226: 1909: 
1227: 1909:    EXIT FUNCTION
1228: 190b: 
1229: 190b:    WRITE.IRF.HOLD.ERROR:
1230: 190b: 
1231: 190b:    CURRENT.REPORT.NUM% = IRF.REPORT.NUM%
1232: 1919:    FILE.OPERATION$ = "W"
1233: 1928:    CURRENT.CODE$ = RIGHT$(IRF.BAR.CODE$,7)                        ! FMW
1234: 1945: 
1235: 1945:    EXIT FUNCTION
1236: 1947: 
1237: 1947:   END FUNCTION
1238: 1956: 
1239: 1956: \----------------------------------------------------------------------------
1240: 1956: 
1241: 1956:   FUNCTION WRITE.IRF.HOLD.UNLOCK PUBLIC
1242: 196a: 
1243: 196a:    INTEGER*2 WRITE.IRF.HOLD.UNLOCK
1244: 196a: 
1245: 196a:    WRITE.IRF.HOLD.UNLOCK = 1
1246: 196f: 
1247: 196f:     CALL IRF.CONCAT.RECORD                                                ! 1.6 RC
1248: 1981: 
1249: 1981:     IF END#IRF.SESS.NUM% THEN WRITE.IRF.HOLD.UNLOCK.ERROR
1250: 1995: 
1251: 1995:     WRITE FORM "C11,2I1,I2,I1,2I1,C5,I1,C18,C3,I2,I2,I1"; HOLD \          ! 1.6 RC ! 2.0 AJC ! 2.2 TT
1252: 1a88:              #IRF.SESS.NUM% AUTOUNLOCK;                           \
1253: 1a88:              IRF.BAR.CODE$,                                       \
1254: 1a88:              IRF.INDICAT0%,                                       \
1255: 1a88:              IRF.INDICAT1%,                                       \
1256: 1a88:              IRF.DEAL.DATA%(0),                                   \       ! 1.6 RC
1257: 1a88:              IRF.INDICAT8%,                                       \       ! 2.0 AJC
1258: 1a88: \!            IRF.UNUSED$,                                        \       ! 1.6 RC 2.2 TT
1259: 1a88:              IRF.INDICAT9%,                                       \       ! 2.2 TT
1260: 1a88:              IRF.INDICAT10%,                                      \       ! 2.2 TT
1261: 1a88:              IRF.SALEPRIC$,                                       \
1262: 1a88:              IRF.INDICAT5%,                                       \ SBH 31/1/96
1263: 1a88:              IRF.ITEMNAME$,                                       \
1264: 1a88:              IRF.BOOTS.CODE$,                                     \
1265: 1a88:              IRF.DEAL.DATA%(1),                                   \       ! 1.6 RC
1266: 1a88:              IRF.DEAL.DATA%(2),                                   \       ! 1.6 RC
1267: 1a88:              IRF.INDICAT3%
1268: 1a88: 
1269: 1a88:     IF WRITE.IRFDEX THEN EXIT FUNCTION                                    ! 1.9 SM
1270: 1a92: 
1271: 1a92:     WRITE.IRF.HOLD.UNLOCK = 0
1272: 1a97: 
1273: 1a97:    EXIT FUNCTION
1274: 1a99: 
1275: 1a99:    WRITE.IRF.HOLD.UNLOCK.ERROR:
1276: 1a99: 
1277: 1a99:    CURRENT.REPORT.NUM% = IRF.REPORT.NUM%
1278: 1aa7:    FILE.OPERATION$ = "W"
1279: 1ab6:    CURRENT.CODE$ = RIGHT$(IRF.BAR.CODE$,7)                        ! FMW
1280: 1ad3: 
1281: 1ad3:    EXIT FUNCTION
1282: 1ad5: 
1283: 1ad5:   END FUNCTION
1284: 1ae4: 
1285: 1ae4: End of Compilation
