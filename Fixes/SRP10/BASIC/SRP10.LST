   1: 0000: \********************************************************************
   2: 0000: \********************************************************************
   3: 0000: \***
   4: 0000: \***
   5: 0000: \***            PROGRAM         :       SRP10
   6: 0000: \***            AUTHOR          :       Neil Bennett
   7: 0000: \***            DATE WRITTEN    :       June 2006
   8: 0000: \***
   9: 0000: \***            MODULE          :       SRP10.BAS
  10: 0000: \***
  11: 0000: \***
  12: 0000: \***    VERSION A.          NEIL BENNETT.           02 JUN 2006.
  13: 0000: \***    Initial version.
  14: 0000: \***
  15: 0000: \***    VERSION B.          Charles Skadorwa.       11 DEC 2008.
  16: 0000: \***    No. of records on SRSXF increased from 30,000 to 60,000
  17: 0000: \***    due to increase in Intactix data volumes for large stores
  18: 0000: \***    which caused keyed file insertion errors.
  19: 0000: \***
  20: 0000: \***    Version C.          Ranjith Gopalankutty      15 March 2016  
  21: 0000: \***    INV10004135 - While housekeeping the planner files, current  
  22: 0000: \***    deletion subroutine(POG.DEL) deletes only SRPOG,SRMOD and    
  23: 0000: \***    SRPDF and leaving behind SRSXF. File builds up over time     
  24: 0000: \***    and fails POGOK suite. POG.DEL will be changed to include    
  25: 0000: \***    SRSXF deletion, also existing deletion logic of SRMOD file   
  26: 0000: \***    is outdated which will be changed too. Starting 2015,        
  27: 0000: \***    refresh of planner has increased, so need to increase the    
  28: 0000: \***    file capacity of SRPOG,SRMOD,SRPDF and SRSXF to double of    
  29: 0000: \***    its current size                                             
  30: 0000: \***
  31: 0000: \***    Version D.          Ranjith Gopalankutty      30 June 2016   
  32: 0000: \***    Post 16A Desk started receiving failures whenever a POGIL    
  33: 0000: \***    is attempted for planner refresh. Its found that its due to  
  34: 0000: \***    change done as part of increasing the file size.the earlier  
  35: 0000: \***    commented line was ending with '\' and the new line started  
  36: 0000: \***    immediately after that. Which compiler taking as commented   
  37: 0000: \***    line too and failing while creating new file. Fixed that.    
  38: 0000: \********************************************************************
  39: 0000: \********************************************************************
  40: 0000: 
  41: 0000: \********************************************************************
  42: 0000: \********************************************************************
  43: 0000: \***
  44: 0000: \***    Module Overview
  45: 0000: \***    ---------------
  46: 0000: \***
  47: 0000: \***    This ADCS initiated program takes the Intactix Space and
  48: 0000: \***    Range store data and applies it to the in store POG and
  49: 0000: \***    module keyed files.
  50: 0000: \***
  51: 0000: \********************************************************************
  52: 0000: \********************************************************************
  53: 0000: 
  54: 0000: \********************************************************************
  55: 0000: \***
  56: 0000: \***    Function globals
  57: 0000: \***
  58: 0000: \********************************************************************
  59: 0000: 
  60: 0000: %INCLUDE PSBF01G.J86    !APPLICATION LOG
  61: 0000: REM \
  62: 0000: \*******************************************************************************
  63: 0000: \*******************************************************************************
  64: 0000: \***
  65: 0000: \***       %INCLUDE FOR GLOBAL DEFINITIONS FOR FUNCTION APPLICATION.LOG
  66: 0000: \***
  67: 0000: \***                FUNCTION NUMBER    : PSBF01
  68: 0000: \***
  69: 0000: \***                REFERENCE          : PSBF01G.J86
  70: 0000: \***
  71: 0000: \***                DATE OF LAST AMENDMENT  - 27/2/86
  72: 0000: \***
  73: 0000: \***
  74: 0000: \*******************************************************************************
  75: 0000: 
  76: 0000:       INTEGER GLOBAL  F01.RETURN.CODE%
  77: 0000: 
  78: 0000: 
  79: 0000: %INCLUDE PSBF20G.J86    !SESSION NUMBER UTILITY
  80: 0000: REM\
  81: 0000: \*******************************************************************************
  82: 0000: \*******************************************************************************
  83: 0000: \***
  84: 0000: \***     %INCLUDE GLOBAL VARIABLE DEFINITIONS FOR SESS.NUM.UTILITY FUNCTION
  85: 0000: \***
  86: 0000: \***                       REFERENCE     : PSBF20G.J86
  87: 0000: \*** 
  88: 0000: \***     Version A              Bruce Scrive                   5th May 1988   
  89: 0000: \*** 
  90: 0000: \***     Version B              Robert Cowey                   7th May 1991
  91: 0000: \***     Global variable F20.INTEGER.FILE.NO% changed from one byte integer
  92: 0000: \***     to two byte integer.
  93: 0000: \***
  94: 0000: \***     Version D              Andrew Wedgeworth             1st July 1992
  95: 0000: \***     F20.RETURN.CODE% removed as it is no longer required.
  96: 0000: \***
  97: 0000: \*******************************************************************************
  98: 0000: \*******************************************************************************
  99: 0000: 
 100: 0000:       STRING    GLOBAL F20.FILE.NAME$,                                 \
 101: 0000:                        F20.STRING.FILE.NO$,                            \
 102: 0000:                        F20.TABLE.DIMENSIONED.FLAG$,                    \
 103: 0000:                        SESS.NUM.TABLE$(1)
 104: 0000: 
 105: 0000:       INTEGER*2 GLOBAL F20.INTEGER.FILE.NO%
 106: 0000: 
 107: 0000:       ! 1 line deleted from here                                       ! DAW 
 108: 0000: 
 109: 0000: %INCLUDE POGDEDEC.J86
 110: 0000: \********************************************************************
 111: 0000: \***      EXTERNAL FUNCTION DECLARATIONS FOR THE POGDE FILE
 112: 0000: \***      REFERENCE : POGOKDEC.J86
 113: 0000: \***      Version A           Neil Bennett            6th June 2006
 114: 0000: \***
 115: 0000: \********************************************************************
 116: 0000: 
 117: 0000:   INTEGER*2 GLOBAL                \
 118: 0000:     POGDE.SESS.NUM%,              \
 119: 0000:     POGDE.REPORT.NUM%             !
 120: 0000: 
 121: 0000:   STRING GLOBAL                   \
 122: 0000:     POGDE.COPY.NAME$,             \
 123: 0000:     POGDE.FILE.NAME$,             \
 124: 0000:     POGDE.RCD$                    !
 125: 0000: %INCLUDE POGOKDEC.J86
 126: 0000: \********************************************************************
 127: 0000: \***      EXTERNAL FUNCTION DECLARATIONS FOR THE POGOK FILE
 128: 0000: \***      REFERENCE : POGOKDEC.J86
 129: 0000: \***      Version A           Neil Bennett            6th June 2006
 130: 0000: \***
 131: 0000: \********************************************************************
 132: 0000: 
 133: 0000:   INTEGER*1 GLOBAL                \
 134: 0000:     POGOK.PE10.RETCODE%,          \
 135: 0000:     POGOK.PE5.RETCODE%,           \
 136: 0000:     POGOK.PE6.RETCODE%,           \
 137: 0000:     POGOK.PE7.RETCODE%,           \
 138: 0000:     POGOK.PE4.RETCODE%,           \
 139: 0000:     POGOK.PE19.RETCODE%           !
 140: 0000: 
 141: 0000:   INTEGER*2 GLOBAL                \
 142: 0000:     POGOK.DAYS.TO.RETAIN%,        \
 143: 0000:     POGOK.SESS.NUM%,              \
 144: 0000:     POGOK.REPORT.NUM%,            \
 145: 0000:     POGOK.RECL%                   !
 146: 0000: 
 147: 0000:   INTEGER*4 GLOBAL                \
 148: 0000:     POGOK.SRD.REC.COUNT%,         \
 149: 0000:     POGOK.SRM.REC.COUNT%
 150: 0000: 
 151: 0000:   STRING GLOBAL                   \
 152: 0000:     POGOK.FILE.NAME$,             \
 153: 0000:     POGOK.SRD.SER.NO$,            \
 154: 0000:     POGOK.SRM.SER.NO$,            \
 155: 0000:     POGOK.SRD.DATE$,              \
 156: 0000:     POGOK.SRM.DATE$,              \
 157: 0000:     POGOK.RELOAD$,                \
 158: 0000:     POGOK.PE10.RUNFLAG$,          \
 159: 0000:     POGOK.PE5.RUNFLAG$,           \
 160: 0000:     POGOK.PE6.RUNFLAG$,           \
 161: 0000:     POGOK.PE7.RUNFLAG$,           \
 162: 0000:     POGOK.PE4.RUNFLAG$,           \
 163: 0000:     POGOK.FAILED.SRD.SER.NO$,     \
 164: 0000:     POGOK.FAILED.SRD.DATE$,       \
 165: 0000:     POGOK.FAILED.SRM.SER.NO$,     \
 166: 0000:     POGOK.FAILED.SRM.DATE$,       \
 167: 0000:     POGOK.PE10.RUNDATE$,          \
 168: 0000:     POGOK.PE5.RUNDATE$,           \
 169: 0000:     POGOK.PE6.RUNDATE$,           \
 170: 0000:     POGOK.PE7.RUNDATE$,           \
 171: 0000:     POGOK.PE4.RUNDATE$,           \
 172: 0000:     POGOK.PE19.RUNFLAG$,          \
 173: 0000:     POGOK.PE19.RUNDATE$,          \
 174: 0000:     POGOK.FILLER$                 !
 175: 0000: %INCLUDE SRPDFDEC.J86
 176: 0000: \********************************************************************
 177: 0000: \***      EXTERNAL FUNCTION DECLARATIONS FOR THE SRPDF FILE
 178: 0000: \***      REFERENCE : SRPDFDEC.J86
 179: 0000: \***      Version A           Neil Bennett          7th August 2006
 180: 0000: \***
 181: 0000: \********************************************************************
 182: 0000: 
 183: 0000:   INTEGER*2 GLOBAL        \
 184: 0000:     SRPDF.SESS.NUM%,      \
 185: 0000:     SRPDF.REPORT.NUM%,    \
 186: 0000:     SRPDF.RECL%           !
 187: 0000: 
 188: 0000:   INTEGER*4 GLOBAL        \
 189: 0000:     SRPDF.POGDB%          ! Unique POG Database key
 190: 0000: 
 191: 0000:   STRING GLOBAL           \
 192: 0000:     SRPDF.FILE.NAME$,     \ File name
 193: 0000:     SRPDF.SHRT.DESC$,     \ Medium descriptor (50)
 194: 0000:     SRPDF.FULL.DESC$,     \ Full descriptor (100)
 195: 0000:     SRPDF.FILLER$         !
 196: 0000: 
 197: 0000: 
 198: 0000: %INCLUDE SRPOGDEC.J86
 199: 0000: \********************************************************************
 200: 0000: \***      EXTERNAL FUNCTION DECLARATIONS FOR THE SRPOG FILE
 201: 0000: \***      REFERENCE : SRPOGDEC.J86
 202: 0000: \***      Version A           Neil Bennett            5th June 2006
 203: 0000: \***
 204: 0000: \********************************************************************
 205: 0000: 
 206: 0000:   INTEGER*1 GLOBAL        \
 207: 0000:     SRPOG.MODULE.COUNT%,  \ Number of modules comprising POG
 208: 0000:     SRPOG.KEY.LEVEL%,     \ Family hierarchy key level
 209: 0000:     SRPOG.LIVE.RPT.CNT%,  \ Computed Live repeat count (Unset -1)
 210: 0000:     SRPOG.PEND.RPT.CNT%   ! Computed pending repeat count (Unset -1)
 211: 0000: 
 212: 0000:   INTEGER*2 GLOBAL        \
 213: 0000:     SRPOG.SESS.NUM%,      \
 214: 0000:     SRPOG.REPORT.NUM%,    \
 215: 0000:     SRPOG.RECL%           !
 216: 0000: 
 217: 0000:   INTEGER*4 GLOBAL        \
 218: 0000:     SRPOG.POGDB%,         \ Unique POG Database key
 219: 0000:     SRPOG.CAT.DBKEY%,     \ Family hierarchy key
 220: 0000:     SRPOG.CAT1.ID%,       \ hierarchy key
 221: 0000:     SRPOG.CAT2.ID%,       \ hierarchy key
 222: 0000:     SRPOG.CAT3.ID%,       \ hierarchy key
 223: 0000:     SRPOG.POGID%          ! POG Identifier
 224: 0000: 
 225: 0000:   STRING GLOBAL           \
 226: 0000:     SRPOG.FILE.NAME$,     \ File name
 227: 0000:     SRPOG.COPY.NAME$,     \ File name
 228: 0000:     SRPOG.ACT.DATE$,      \ Activation Date YYYY MM DD
 229: 0000:     SRPOG.DEACT.DATE$,    \ Deactivation Date YYYY MM DD
 230: 0000:     SRPOG.DESCRIPTION$,   \ Truncated POG description (30)
 231: 0000:     SRPOG.PLANNER.FAMILY$,\ Truncated Planner Family description (30)
 232: 0000:     SRPOG.DATE.RPT.CNT$,  \ Date repeat count is valid YYYY MM DD
 233: 0000:     SRPOG.FILLER$         !
 234: 0000: 
 235: 0000: 
 236: 0000: %INCLUDE SRMODDEC.J86
 237: 0000: \********************************************************************
 238: 0000: \***      EXTERNAL FUNCTION DECLARATIONS FOR THE SRMOD FILE
 239: 0000: \***      REFERENCE : SRMODDEC.J86
 240: 0000: \***      Version A           Neil Bennett            5th June 2006
 241: 0000: \***
 242: 0000: \********************************************************************
 243: 0000: 
 244: 0000:   INTEGER*1 GLOBAL             \
 245: 0000:     SRMOD.FACINGS%(1),         \
 246: 0000:     SRMOD.MODULE.SEQ%,         \
 247: 0000:     SRMOD.RECORD.CHAIN%,       \
 248: 0000:     SRMOD.SHELF.NUM%(1)
 249: 0000: 
 250: 0000:   INTEGER*2 GLOBAL             \
 251: 0000:     SRMOD.ITEM.COUNT%,         \
 252: 0000:     SRMOD.MAX.ITEMS%,          \
 253: 0000:     SRMOD.MDQ%(1),             \
 254: 0000:     SRMOD.PSC%(1),             \
 255: 0000:     SRMOD.RECL%,               \
 256: 0000:     SRMOD.REPORT.NUM%,         \
 257: 0000:     SRMOD.SHELF.COUNT%,        \
 258: 0000:     SRMOD.SESS.NUM%
 259: 0000: 
 260: 0000:   INTEGER*4 GLOBAL             \
 261: 0000:     SRMOD.POGDB%
 262: 0000: 
 263: 0000:   STRING GLOBAL                \
 264: 0000:     SRMOD.ARRAY$,              \
 265: 0000:     SRMOD.COPY.NAME$,          \
 266: 0000:     SRMOD.DESCRIPTOR$,         \
 267: 0000:     SRMOD.FILE.NAME$,          \
 268: 0000:     SRMOD.ITEM.CODE$(1),       \
 269: 0000:     SRMOD.FILLER$
 270: 0000: %INCLUDE SRSXFDEC.J86
 271: 0000: \********************************************************************
 272: 0000: \***      EXTERNAL FUNCTION DECLARATIONS FOR THE SRSXF FILE
 273: 0000: \***      REFERENCE : SRSXFDEC.J86
 274: 0000: \***      Version A           Neil Bennett          7th August 2006
 275: 0000: \***
 276: 0000: \********************************************************************
 277: 0000: 
 278: 0000:   INTEGER*1 GLOBAL        \
 279: 0000:     SRSXF.MODULE.SEQ%,    \
 280: 0000:     SRSXF.SHELF.NO%,      \
 281: 0000:     SRSXF.NOTCH.NO%       !
 282: 0000: 
 283: 0000:   INTEGER*2 GLOBAL        \
 284: 0000:     SRSXF.SESS.NUM%,      \
 285: 0000:     SRSXF.REPORT.NUM%,    \
 286: 0000:     SRSXF.RECL%           !
 287: 0000: 
 288: 0000:   INTEGER*4 GLOBAL        \
 289: 0000:     SRSXF.POGDB%,         \
 290: 0000:     SRSXF.SHELF.KEY%      !
 291: 0000: 
 292: 0000:   STRING GLOBAL           \
 293: 0000:     SRSXF.FILE.NAME$,     \ File name
 294: 0000:     SRSXF.SHELF.DESC$,    \
 295: 0000:     SRSXF.FILLER$         !
 296: 0000: 
 297: 0000: 
 298: 0000: 
 299: 0000: \********************************************************************
 300: 0000: \***
 301: 0000: \***    SRP10 variables
 302: 0000: \***
 303: 0000: \********************************************************************
 304: 0000: 
 305: 0000:    STRING    GLOBAL CURRENT.CODE$
 306: 0000:    INTEGER*2 GLOBAL CURRENT.REPORT.NUM%
 307: 0000:    STRING    GLOBAL FILE.OPERATION$
 308: 0000:    STRING    GLOBAL SB.ACTION$
 309: 0000:    STRING    GLOBAL SB.FILE.NAME$
 310: 0000:    INTEGER*2 GLOBAL SB.INTEGER%
 311: 0000:    INTEGER*2 GLOBAL SB.FILE.REP.NUM%
 312: 0000:    INTEGER*2 GLOBAL SB.FILE.SESS.NUM%
 313: 0000:    STRING    GLOBAL SB.STRING$
 314: 0000: 
 315: 0000:    INTEGER*2 ARRAY.COUNT%                                               ! CRG
 316: 0000:    INTEGER*1 bg%
 317: 0000:    INTEGER*1 CHAIN.COUNT%                                               ! CRG
 318: 0000:    STRING    comm.tail$
 319: 0000:    INTEGER*1 eof%
 320: 0000:    STRING    err.cd$
 321: 0000:    INTEGER*2 event.no%
 322: 0000:    STRING    file$
 323: 0000:    STRING    file.no$
 324: 0000:    INTEGER*1 run.suite%
 325: 0000:    INTEGER*1 init.fail%
 326: 0000:    INTEGER*1 init.load%
 327: 0000:    INTEGER*2 it.ptr%
 328: 0000:    INTEGER*2 item.cnt%
 329: 0000:    INTEGER*1 last.notch%
 330: 0000:    INTEGER*1 last.shelf%
 331: 0000:    STRING    mess$
 332: 0000:    INTEGER*2 message.no%
 333: 0000:    INTEGER*1 mod.cnt%
 334: 0000:    INTEGER*1 no.file%
 335: 0000:    INTEGER*1 no.inp.file%
 336: 0000:    INTEGER*1 no.mod.file%
 337: 0000:    INTEGER*1 no.pog.file%
 338: 0000:    INTEGER*1 no.read%
 339: 0000:    STRING    parm$
 340: 0000:    STRING    POGDE.DATE$
 341: 0000:    INTEGER*2 POGDE.DTR%
 342: 0000:    INTEGER*4 POGDE.SER.NO%
 343: 0000:    INTEGER*2 rc%
 344: 0000:    INTEGER*4 rc4%
 345: 0000:    INTEGER*4 rec.cnt%
 346: 0000:    STRING    rectyp$
 347: 0000:    STRING    rundate$
 348: 0000:    INTEGER*2 shelf.cnt%
 349: 0000:    INTEGER*1 srmod.chg%
 350: 0000:    INTEGER*2 shelf.item.seq%
 351: 0000:    INTEGER*2 sit.cnt%
 352: 0000:    INTEGER*1 SRMOD.COUNT.LIMIT%                                         ! CRG
 353: 0000:    INTEGER*1 srp10.error%
 354: 0000:    INTEGER*1 srp10.event%
 355: 0000:    INTEGER*1 tlr.read%
 356: 0000:    INTEGER*4 tlr.cnt%
 357: 0000:    STRING    text$
 358: 0000:    STRING    var.string.1$
 359: 0000:    STRING    var.string.2$
 360: 0000:    STRING    work$
 361: 0000: 
 362: 0000: \********************************************************************
 363: 0000: \***
 364: 0000: \***    External functions
 365: 0000: \***
 366: 0000: \********************************************************************
 367: 0000: 
 368: 0000: %INCLUDE ADXSERVE.J86   !Controller Services
 369: 0000: \******************************************************************************
 370: 0000: \******************************************************************************
 371: 0000: \***                                                                        ***
 372: 0000: \***    %INCLUDE FOR FUNCTION ADXSERVE (an I.B.M. system function)          ***
 373: 0000: \***                                                                        ***
 374: 0000: \***         AUTHOR        :  Bruce Scriver                                 ***
 375: 0000: \***                                                                        ***
 376: 0000: \***         DATE WRITTEN  :  14th March 1986                               ***
 377: 0000: \***                                                                        ***
 378: 0000: \***         DATE OF LAST REVISION  - 14th March 1986                       ***
 379: 0000: \***                                                                        ***
 380: 0000: \***                                                                        ***
 381: 0000: \******************************************************************************
 382: 0000: \******************************************************************************
 383: 0000: 
 384: 0000:    SUB ADXSERVE (RETURN.CODE%,                                                \
 385: 0000:                  ADX.FUNCTION%,                                               \
 386: 0000:                  ADX.PARM.1%,                                                 \
 387: 0000:                  ADX.PARM.2$)                                                 \
 388: 0000:    EXTERNAL
 389: 0000:   
 390: 0000:       STRING     ADX.PARM.2$
 391: 0000: 
 392: 0000:       INTEGER*2  ADX.FUNCTION%,                                               \
 393: 0000:                  ADX.PARM.1%
 394: 0000: 
 395: 0000:       INTEGER*4  RETURN.CODE%                                                 \
 396: 0000: 
 397: 0000:    END SUB     
 398: 0000: 
 399: 0000: %INCLUDE PSBF01E.J86    !APPLICATION LOG
 400: 0000: REM \
 401: 0000: \*******************************************************************************
 402: 0000: \*******************************************************************************
 403: 0000: \***
 404: 0000: \***      %INCLUDE FOR EXTERNAL DEFINITION OF FUNCTION APPLICATION.LOG
 405: 0000: \***
 406: 0000: \***                      FUNCTION NUMBER   : PSBF01
 407: 0000: \***
 408: 0000: \***                    INCLUDE REFERENCE : PSBF01E.J86
 409: 0000: \*** 
 410: 0000: \***      Version B           Andrew Wedgeworth          1st July 1992
 411: 0000: \***      Three parameters which passed to the function have been removed.
 412: 0000: \***      APPLICATION.LOG has been added as a variable name (this holds the
 413: 0000: \***      return code).
 414: 0000: \***
 415: 0000: \*******************************************************************************
 416: 0000: 
 417: 0000: 
 418: 0000:    FUNCTION APPLICATION.LOG (MESSAGE.NO%,                                     \
 419: 0000:                              VAR.STRING.1$,                                   \
 420: 0000:                              VAR.STRING.2$,                                   \
 421: 0000:                              EVENT.NO%)  EXTERNAL
 422: 0000: 
 423: 0000:       INTEGER*1 EVENT.NO%
 424: 0000: 
 425: 0000:       INTEGER*2 APPLICATION.LOG,                                       \ GAW
 426: 0000:                 MESSAGE.NO%
 427: 0000: 
 428: 0000:       STRING VAR.STRING.1$,                                            \
 429: 0000:              VAR.STRING.2$
 430: 0000: 
 431: 0000:    END FUNCTION
 432: 0000: 
 433: 0000: \*******************************************************************************
 434: 0000: %INCLUDE PSBF20E.J86    !SESSION NUMBER UTILITY
 435: 0000: REM\
 436: 0000: \*******************************************************************************
 437: 0000: \*******************************************************************************
 438: 0000: \***
 439: 0000: \***       %INCLUDE FOR EXTERNAL DEFINITION OF SESS.NUM.UTILITY
 440: 0000: \***
 441: 0000: \***                  REFERENCE     : PSBF20E.J86
 442: 0000: \***
 443: 0000: \***     VERSION C            Janet Smith                13th May 1992
 444: 0000: \***     Increased PASSED.INTEGER to 2 bytes to cater for more than
 445: 0000: \***     128 files.
 446: 0000: \***
 447: 0000: \***     VERSION D.           Andrew Wedgeworth          1st July 1992
 448: 0000: \***     Removal of redundant parameters and addition of SESS.NUM.UTILITY
 449: 0000: \***     as a variable.  This new variable contains the function's return
 450: 0000: \***     code.
 451: 0000: \***
 452: 0000: \*******************************************************************************
 453: 0000: \*******************************************************************************
 454: 0000: 
 455: 0000:    FUNCTION SESS.NUM.UTILITY (FUNCTION.FLAG$,                          \
 456: 0000:                               PASSED.INTEGER%,                         \
 457: 0000:                               PASSED.STRING$)                          \
 458: 0000:    EXTERNAL
 459: 0000: 
 460: 0000:    STRING    FUNCTION.FLAG$,                                           \
 461: 0000:              PASSED.STRING$
 462: 0000:    ! 3 variables removed from here                                     ! CAW
 463: 0000: 
 464: 0000: 
 465: 0000:    INTEGER*2 SESS.NUM.UTILITY,                                         \ CAW
 466: 0000:              PASSED.INTEGER%				               ! CJAS
 467: 0000: 
 468: 0000:    END FUNCTION
 469: 0000: 
 470: 0000: %INCLUDE PSBF24E.J86    !STANDARD ERROR DETECTED
 471: 0000: REM \
 472: 0000: \*******************************************************************************
 473: 0000: \*******************************************************************************
 474: 0000: \***
 475: 0000: \***    %INCLUDE FOR EXTERNAL DEFINITION OF STANDARD.ERROR.DETECTED FUNCTION
 476: 0000: \***
 477: 0000: \***                      REFERENCE     : PSBF24E.J86
 478: 0000: \***
 479: 0000: \***    Version A                 Janet Smith                  13th May 1992
 480: 0000: \***
 481: 0000: \*******************************************************************************
 482: 0000: \*******************************************************************************
 483: 0000: 
 484: 0000:    FUNCTION STANDARD.ERROR.DETECTED(ERRN%,                 \
 485: 0000: 				    ERRFILE%,              \
 486: 0000: 				    ERRL%,                 \
 487: 0000: 				    ERR$)        EXTERNAL
 488: 0000: 				    
 489: 0000:           STRING    ERR$
 490: 0000: 
 491: 0000:           INTEGER*2 ERRFILE%,              \
 492: 0000: 	            ERRL%,                 \
 493: 0000: 		    STANDARD.ERROR.DETECTED
 494: 0000: 		    
 495: 0000:           INTEGER*4 ERRN%
 496: 0000: 	  		    
 497: 0000:    END FUNCTION
 498: 0000: 
 499: 0000: 
 500: 0000: 
 501: 0000: %INCLUDE BTCMEM.J86
 502: 0000: !********************************************************************
 503: 0000: !***
 504: 0000: !***    INCLUDED CODE:  BTCMEM.J86
 505: 0000: !***    AUTHOR:         Stuart William McConnachie
 506: 0000: !***    DATE:           26th February 2006
 507: 0000: !***
 508: 0000: !********************************************************************
 509: 0000: !***
 510: 0000: !***    Controller CBASIC Memory Functions
 511: 0000: !***
 512: 0000: !********************************************************************
 513: 0000: 
 514: 0000: !Get a single byte integer from a string offset
 515: 0000: FUNCTION GETN1 (S$, P%) EXTERNAL
 516: 0000:     STRING S$
 517: 0000:     INTEGER*2 P%
 518: 0000:     INTEGER*2 GETN1
 519: 0000: END FUNCTION
 520: 0000: 
 521: 0000: !Get a two byte integer from a string offset
 522: 0000: FUNCTION GETN2 (S$, P%) EXTERNAL
 523: 0000:     STRING S$
 524: 0000:     INTEGER*2 P%
 525: 0000:     INTEGER*2 GETN2
 526: 0000: END FUNCTION
 527: 0000: 
 528: 0000: !Get a four byte integer from a string offset
 529: 0000: FUNCTION GETN4 (S$, P%) EXTERNAL
 530: 0000:     STRING S$
 531: 0000:     INTEGER*2 P%
 532: 0000:     INTEGER*4 GETN4
 533: 0000: END FUNCTION
 534: 0000: 
 535: 0000: !Get a 10 byte CBASIC real from a string offset
 536: 0000: FUNCTION GETR10 (S$, P%) EXTERNAL
 537: 0000:     STRING S$
 538: 0000:     INTEGER*2 P%
 539: 0000:     REAL GETR10
 540: 0000: END FUNCTION
 541: 0000: 
 542: 0000: !Put a single byte integer into a string at offset
 543: 0000: FUNCTION PUTN1 (S$, P%, N%) EXTERNAL
 544: 0000:     STRING S$
 545: 0000:     INTEGER*2 P%
 546: 0000:     INTEGER*1 N%
 547: 0000:     INTEGER*1 PUTN1
 548: 0000: END FUNCTION
 549: 0000: 
 550: 0000: !Put a two byte integer into a string at offset
 551: 0000: FUNCTION PUTN2 (S$, P%, N%) EXTERNAL
 552: 0000:     STRING S$
 553: 0000:     INTEGER*2 P%
 554: 0000:     INTEGER*2 N%
 555: 0000:     INTEGER*1 PUTN2
 556: 0000: END FUNCTION
 557: 0000: 
 558: 0000: !Put a four byte integer into a string at offset
 559: 0000: FUNCTION PUTN4 (S$, P%, N%) EXTERNAL
 560: 0000:     STRING S$
 561: 0000:     INTEGER*2 P%
 562: 0000:     INTEGER*4 N%
 563: 0000:     INTEGER*1 PUTN4
 564: 0000: END FUNCTION
 565: 0000: 
 566: 0000: !Put a 10 byte CBASIC real into a string at offset
 567: 0000: FUNCTION PUTR10 (S$, P%, R) EXTERNAL
 568: 0000:     STRING S$
 569: 0000:     INTEGER*2 P%
 570: 0000:     REAL R
 571: 0000:     INTEGER*1 PUTR10
 572: 0000: END FUNCTION
 573: 0000: 
 574: 0000: !Peek a two byte integer from a memory address
 575: 0000: FUNCTION PEEKN2 (A%) EXTERNAL
 576: 0000:     INTEGER*4 A%
 577: 0000:     INTEGER*2 PEEKN2
 578: 0000: END FUNCTION
 579: 0000: 
 580: 0000: !Peek a four byte integer from a memory address
 581: 0000: FUNCTION PEEKN4 (A%) EXTERNAL
 582: 0000:     INTEGER*4 A%
 583: 0000:     INTEGER*4 PEEKN4
 584: 0000: END FUNCTION
 585: 0000: 
 586: 0000: !Peek a 10 byte CBASIC real from a memory address
 587: 0000: FUNCTION PEEKR10 (A%) EXTERNAL
 588: 0000:     INTEGER*4 A%
 589: 0000:     REAL PEEKR10
 590: 0000: END FUNCTION
 591: 0000: 
 592: 0000: !Poke a two byte integer to a memory address
 593: 0000: FUNCTION POKEN2 (A%, N%) EXTERNAL
 594: 0000:     INTEGER*4 A%
 595: 0000:     INTEGER*2 N%
 596: 0000:     INTEGER*1 POKEN2
 597: 0000: END FUNCTION
 598: 0000: 
 599: 0000: !Poke a four byte integer to a memory address
 600: 0000: FUNCTION POKEN4 (A%, N%) EXTERNAL
 601: 0000:     INTEGER*4 A%
 602: 0000:     INTEGER*4 N%
 603: 0000:     INTEGER*1 POKEN4
 604: 0000: END FUNCTION
 605: 0000: 
 606: 0000: !Poke a 10 byte CBASIC real to a memory address
 607: 0000: FUNCTION POKER10 (A%, R) EXTERNAL
 608: 0000:     INTEGER*4 A%
 609: 0000:     REAL R
 610: 0000:     INTEGER*1 POKER10
 611: 0000: END FUNCTION
 612: 0000: 
 613: 0000: %INCLUDE SRPEXT.J86
 614: 0000: \********************************************************************
 615: 0000: \***      Space and Range Planner Common Functions  (SRPFUN)
 616: 0000: \***      Version A           Neil Bennett          24.08.2006
 617: 0000: \***
 618: 0000: \....................................................................
 619: 0000: \***
 620: 0000: \***    GET.CATID Construct a 4 byte integer Category ID from 3
 621: 0000: \***              hierarchical (I4) keys supplied.
 622: 0000: \***
 623: 0000: \********************************************************************
 624: 0000: 
 625: 0000:    FUNCTION GET.CATID%(lev1%,lev2%,lev3%) EXTERNAL
 626: 0000: 
 627: 0000:     INTEGER*4 GET.CATID%
 628: 0000:     INTEGER*4 lev1%, lev2%, lev3%
 629: 0000: 
 630: 0000:    END FUNCTION
 631: 0000: 
 632: 0000: \********************************************************************
 633: 0000: %INCLUDE POGDEEXT.J86
 634: 0000: \********************************************************************
 635: 0000: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE POGDE FILE
 636: 0000: \***      REFERENCE : POGDEEXT.J86
 637: 0000: \***      Version A           Neil Bennett            8th June 2006
 638: 0000: \***
 639: 0000: \********************************************************************
 640: 0000: 
 641: 0000:        FUNCTION POGDE.SET EXTERNAL
 642: 0000:        END FUNCTION
 643: 0000: 
 644: 0000:        FUNCTION READ.POGDE EXTERNAL
 645: 0000:           INTEGER*2 READ.POGDE
 646: 0000:        END FUNCTION
 647: 0000: %INCLUDE POGOKEXT.J86
 648: 0000: \********************************************************************
 649: 0000: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE POGOK FILE
 650: 0000: \***      REFERENCE : POGOKEXT.J86
 651: 0000: \***      Version A           Neil Bennett            6th June 2006
 652: 0000: \***
 653: 0000: \********************************************************************
 654: 0000: 
 655: 0000:        FUNCTION POGOK.SET EXTERNAL
 656: 0000:        END FUNCTION
 657: 0000: 
 658: 0000:        FUNCTION READ.POGOK EXTERNAL
 659: 0000:           INTEGER*2 READ.POGOK
 660: 0000:        END FUNCTION
 661: 0000: 
 662: 0000:        FUNCTION READ.POGOK.LOCK EXTERNAL
 663: 0000:           INTEGER*2 READ.POGOK.LOCK
 664: 0000:        END FUNCTION
 665: 0000: 
 666: 0000:        FUNCTION WRITE.POGOK EXTERNAL
 667: 0000:           INTEGER*2 WRITE.POGOK
 668: 0000:        END FUNCTION
 669: 0000: 
 670: 0000:        FUNCTION WRITE.POGOK.UNLOCK EXTERNAL
 671: 0000:           INTEGER*2 WRITE.POGOK.UNLOCK
 672: 0000:        END FUNCTION
 673: 0000: 
 674: 0000:        FUNCTION CREATE.POGOK EXTERNAL
 675: 0000:           INTEGER*2 CREATE.POGOK
 676: 0000:        END FUNCTION
 677: 0000: %INCLUDE SRPDFEXT.J86
 678: 0000: \********************************************************************
 679: 0000: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE SRPDF FILE
 680: 0000: \***      REFERENCE : SRPDFEXT.J86
 681: 0000: \***      Version A           Neil Bennett          7th August 2006
 682: 0000: \***
 683: 0000: \********************************************************************
 684: 0000: 
 685: 0000:        FUNCTION SRPDF.SET EXTERNAL
 686: 0000:        END FUNCTION
 687: 0000: 
 688: 0000:        FUNCTION READ.SRPDF EXTERNAL
 689: 0000:           INTEGER*2 READ.SRPDF
 690: 0000:        END FUNCTION
 691: 0000: 
 692: 0000:        FUNCTION WRITE.SRPDF EXTERNAL
 693: 0000:           INTEGER*2 WRITE.SRPDF
 694: 0000:        END FUNCTION
 695: 0000: 
 696: 0000:        FUNCTION DELREC.SRPDF EXTERNAL
 697: 0000:           INTEGER*2 DELREC.SRPDF
 698: 0000:        END FUNCTION
 699: 0000: %INCLUDE SRPOGEXT.J86
 700: 0000: \********************************************************************
 701: 0000: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE SRPOG FILE
 702: 0000: \***      REFERENCE : SRPOGEXT.J86
 703: 0000: \***      Version A           Neil Bennett            5th June 2006
 704: 0000: \***
 705: 0000: \********************************************************************
 706: 0000: 
 707: 0000:        FUNCTION SRPOG.SET EXTERNAL
 708: 0000:        END FUNCTION
 709: 0000: 
 710: 0000:        FUNCTION READ.SRPOG EXTERNAL
 711: 0000:           INTEGER*2 READ.SRPOG
 712: 0000:        END FUNCTION
 713: 0000: 
 714: 0000:        FUNCTION WRITE.SRPOG EXTERNAL
 715: 0000:           INTEGER*2 WRITE.SRPOG
 716: 0000:        END FUNCTION
 717: 0000: 
 718: 0000:        FUNCTION DELREC.SRPOG EXTERNAL
 719: 0000:           INTEGER*2 DELREC.SRPOG
 720: 0000:        END FUNCTION
 721: 0000: %INCLUDE SRMODEXT.J86
 722: 0000: \********************************************************************
 723: 0000: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE SRMOD FILE
 724: 0000: \***      REFERENCE : SRMODEXT.J86
 725: 0000: \***      Version A           Neil Bennett            5th June 2006
 726: 0000: \***
 727: 0000: \********************************************************************
 728: 0000: 
 729: 0000:        FUNCTION SRMOD.SET EXTERNAL
 730: 0000:        END FUNCTION
 731: 0000: 
 732: 0000:        FUNCTION READ.SRMOD EXTERNAL
 733: 0000:           INTEGER*2 READ.SRMOD
 734: 0000:        END FUNCTION
 735: 0000: 
 736: 0000:        FUNCTION WRITE.SRMOD EXTERNAL
 737: 0000:           INTEGER*2 WRITE.SRMOD
 738: 0000:        END FUNCTION
 739: 0000: 
 740: 0000:        FUNCTION DELREC.SRMOD EXTERNAL
 741: 0000:           INTEGER*2 DELREC.SRMOD
 742: 0000:        END FUNCTION
 743: 0000: 
 744: 0000:        SUB SRMOD.SPLIT.SHELF.ITEM EXTERNAL
 745: 0000:        END SUB
 746: 0000: %INCLUDE SRSXFEXT.J86
 747: 0000: \********************************************************************
 748: 0000: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE SRSXF FILE
 749: 0000: \***      REFERENCE : SRSXFEXT.J86
 750: 0000: \***      Version A           Neil Bennett          7th August 2006
 751: 0000: \***
 752: 0000: \********************************************************************
 753: 0000: 
 754: 0000:        FUNCTION SRSXF.SET EXTERNAL
 755: 0000:        END FUNCTION
 756: 0000: 
 757: 0000:        FUNCTION READ.SRSXF EXTERNAL
 758: 0000:           INTEGER*2 READ.SRSXF
 759: 0000:        END FUNCTION
 760: 0000: 
 761: 0000:        FUNCTION WRITE.SRSXF EXTERNAL
 762: 0000:           INTEGER*2 WRITE.SRSXF
 763: 0000:        END FUNCTION
 764: 0000: 
 765: 0000:        FUNCTION DELREC.SRSXF EXTERNAL
 766: 0000:           INTEGER*2 DELREC.SRSXF
 767: 0000:        END FUNCTION
 768: 0000: 
 769: 0000:    FUNCTION ADXSTART(NAME$, PARM$, MESS$) EXTERNAL
 770: 0000:       INTEGER*2 ADXSTART
 771: 0000:       STRING    NAME$, PARM$, MESS$
 772: 0000:    END FUNCTION
 773: 0000: 
 774: 0000: \********************************************************************
 775: 0000: \***
 776: 0000: \***    SRP10 functions
 777: 0000: \***
 778: 0000: \********************************************************************
 779: 0000: 
 780: 0000: \********************************************************************
 781: 0000: \********************************************************************
 782: 0000: \***
 783: 0000: \***    S T A R T  O F  M A I N L I N E  C O D E
 784: 0000: \***
 785: 0000: \********************************************************************
 786: 0000: \********************************************************************
 787: 0000: 
 788: 0000:     ON ERROR GOTO ERROR.DETECTED
 789: 002f: 
 790: 002f: START.PROGRAM:
 791: 003f: 
 792: 003f:     mess$ = "Program started - Initialising ....."
 793: 0054:     GOSUB DISPLAY.MSG
 794: 0066:     GOSUB INITIALISATION
 795: 0078: 
 796: 0078:     IF NOT init.fail% THEN BEGIN
 797: 0087:        mess$ = "Processing S&R Change Delta File ..."
 798: 009c:        GOSUB DISPLAY.MSG
 799: 00ae:        GOSUB MAIN.PROCESS
 800: 00c0:     ENDIF
 801: 00c8: 
 802: 00c8: TIDY.END.PROG:
 803: 00d8: 
 804: 00d8:     IF run.suite% THEN BEGIN
 805: 00ea:        mess$ = "Updating run File and Tidy up ......"
 806: 00ff:        GOSUB DISPLAY.MSG
 807: 0111:        GOSUB UPDATE.RUN.FILE
 808: 0123:        mess$ = "Program Ended - Flag " + POGOK.PE10.RUNFLAG$        \
 809: 016e:              + " Code " + STR$(POGOK.PE10.RETCODE%) + " ......"
 810: 016e:     ENDIF ELSE BEGIN
 811: 0176:        mess$ = "Suite already processed today - Ending."
 812: 018b:     ENDIF
 813: 0193: 
 814: 0193:     GOSUB DISPLAY.MSG
 815: 01a5:     GOSUB TERMINATION
 816: 01b7: 
 817: 01b7: FATAL.END.PROG:
 818: 01c7: 
 819: 01c7:     IF err.cd$ <> "" THEN BEGIN
 820: 01e2: 
 821: 01e2:        mess$ = "Program Abended ERR >" + err.cd$ + "<"
 822: 0206:        GOSUB DISPLAY.MSG
 823: 0218: 
 824: 0218:     ENDIF
 825: 0220: 
 826: 0220: STOP
 827: 022d: 
 828: 022d: \********************************************************************
 829: 022d: \********************************************************************
 830: 022d: \***
 831: 022d: \***    S T A R T  O F  S U B R O U T I N E S
 832: 022d: \***
 833: 022d: \********************************************************************
 834: 022d: \********************************************************************
 835: 022d: 
 836: 022d: \********************************************************************
 837: 022d: \***
 838: 022d: \***    SUBROUTINE      :       MAIN.PROCESS
 839: 022d: \***
 840: 022d: \********************************************************************
 841: 022d: \***
 842: 022d: \***    READ sequentially through the POG Delta file
 843: 022d: \***
 844: 022d: \***    Process each record type
 845: 022d: \***
 846: 022d: \***    RETURN
 847: 022d: \***
 848: 022d: \********************************************************************
 849: 022d: 
 850: 022d: MAIN.PROCESS:
 851: 023d: 
 852: 023d:    mod.cnt%  = 0
 853: 024a:    sit.cnt%  = 0
 854: 0258:    eof%      = 0
 855: 0265: 
 856: 0265:    WHILE eof% = 0                                                    \
 857: 0270:      AND tlr.read% = 0                              ! Set in Init
 858: 0270: 
 859: 0270:       rc% = READ.POGDE
 860: 0280:       IF rc% <> 0 THEN BEGIN
 861: 028f:          eof% = 1
 862: 029f:       ENDIF ELSE BEGIN
 863: 02a7: 
 864: 02a7:          rectyp$ = UNPACK$(MID$(POGDE.RCD$,1,1))
 865: 02d1: 
 866: 02d1:          IF mod.cnt% <> 0 THEN BEGIN
 867: 02e3:             IF LEFT$(rectyp$,1) = "0"                               \
 868: 035a:             OR LEFT$(rectyp$,1) = "9" THEN BEGIN
 869: 035a:                IF mod.cnt% <> SRPOG.MODULE.COUNT% THEN BEGIN
 870: 036f:                   srp10.event% = 7
 871: 037c:                   GOSUB LOG.EVENT
 872: 038e:                   GOSUB WRITE.POG.FINAL
 873: 03a0:                ENDIF
 874: 03a8:                mod.cnt% = 0
 875: 03b5:             ENDIF
 876: 03bd:          ENDIF
 877: 03c5: 
 878: 03c5:          IF srmod.chg% > 0 THEN BEGIN
 879: 03d7:             IF LEFT$(rectyp$,1) <> "2" THEN BEGIN
 880: 0409:                srmod.chg% = 0
 881: 0416:                GOSUB WRITE.MODULE.FINAL
 882: 042a:             ENDIF ELSE IF item.cnt% <> 0                            \
 883: 0467:                       AND MOD(item.cnt%,                            \
 884: 0467:                               (SRMOD.MAX.ITEMS%)) = 0 THEN BEGIN
 885: 0467:                GOSUB WRITE.MODULE
 886: 0479:             ENDIF
 887: 0481:          ENDIF
 888: 0489: 
 889: 0489:          IF rectyp$ = "01" THEN BEGIN              ! POG Add
 890: 04a4:             rec.cnt% = rec.cnt% +1
 891: 04bd:             GOSUB POG.ADD
 892: 04d2:          ENDIF ELSE IF rectyp$ = "02" THEN BEGIN   ! POG Delete
 893: 04ed:             rec.cnt% = rec.cnt% +1
 894: 0506:             GOSUB POG.DEL
 895: 051b:          ENDIF ELSE IF rectyp$ = "03" THEN BEGIN   ! POG Change
 896: 0536:             rec.cnt% = rec.cnt% +1
 897: 054f:             GOSUB POG.ADD
 898: 0564:          ENDIF ELSE IF rectyp$ = "10" THEN BEGIN   ! Module Add
 899: 057f:             rec.cnt% = rec.cnt% +1
 900: 0598:             mod.cnt% = mod.cnt% +1
 901: 05a4:             GOSUB MOD.ADD
 902: 05b9:          ENDIF ELSE IF rectyp$ = "21" THEN BEGIN   ! Shelf/Item Add
 903: 05d4:             rec.cnt% = rec.cnt% +1
 904: 05ed:             GOSUB ITEM.ADD
 905: 0601:          ENDIF ELSE IF rectyp$ = "99" THEN BEGIN   ! Trailer Record
 906: 061c:             rec.cnt% = rec.cnt% +1
 907: 0635:             tlr.read% = 1
 908: 0642:             tlr.cnt% = GETN4(POGDE.RCD$,1)
 909: 066c:          ENDIF
 910: 0674: 
 911: 0674:       ENDIF
 912: 067c: 
 913: 067c:    WEND
 914: 06a3: 
 915: 06a3: RETURN
 916: 06b3: 
 917: 06b3: \********************************************************************
 918: 06b3: \***
 919: 06b3: \***    SUBROUTINE      :       POG.ADD
 920: 06b3: \***
 921: 06b3: \********************************************************************
 922: 06b3: \***
 923: 06b3: \***    Set SRPOG values from POGDE record
 924: 06b3: \***
 925: 06b3: \***    Write to SRPOG file
 926: 06b3: \***
 927: 06b3: \***    RETURN
 928: 06b3: \***
 929: 06b3: \********************************************************************
 930: 06b3: 
 931: 06b3: POG.ADD:
 932: 06c3: 
 933: 06c3: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
 934: 06c3: \* Set POGDB from delta file                                       *\
 935: 06c3: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
 936: 06c3: 
 937: 06c3:    SRPOG.POGDB%          = GETN4(POGDE.RCD$,  9    )
 938: 06ef: 
 939: 06ef: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
 940: 06ef: \* For POG change, read existing record and keep module count      *\
 941: 06ef: \*    (this will never be changed - delete POG and add POG used)   *\
 942: 06ef: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
 943: 06ef: 
 944: 06ef:    IF rectyp$ = "03" THEN BEGIN
 945: 070a:       rc% = READ.SRPOG
 946: 071a:       IF rc% <> 0 THEN BEGIN
 947: 0729:          SRPOG.MODULE.COUNT%   = GETN1(POGDE.RCD$,118    )
 948: 074d:       ENDIF
 949: 0757:    ENDIF ELSE BEGIN
 950: 075f:       SRPOG.MODULE.COUNT%   = GETN1(POGDE.RCD$,118    )
 951: 0783:    ENDIF
 952: 078b: 
 953: 078b: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
 954: 078b: \* Set remaining variables supplied in Delta file                  *\
 955: 078b: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
 956: 078b: 
 957: 078b:    SRPOG.POGID%          = GETN4(POGDE.RCD$,  1    )
 958: 07b7:    SRPOG.ACT.DATE$       =  MID$(POGDE.RCD$,  6,  4)
 959: 07de:    SRPOG.PLANNER.FAMILY$ =  MID$(POGDE.RCD$, 64, 30)
 960: 0805:       ! (Truncated from 50 bytes)
 961: 0805:    SRPOG.DEACT.DATE$     =  MID$(POGDE.RCD$,114,  4)
 962: 082c:    SRPOG.CAT1.ID%        = GETN4(POGDE.RCD$,119    )
 963: 0858:    SRPOG.CAT2.ID%        = GETN4(POGDE.RCD$,123    )
 964: 0884:    SRPOG.CAT3.ID%        = GETN4(POGDE.RCD$,127    )
 965: 08b0: 
 966: 08b0:    SRPDF.POGDB%          = SRPOG.POGDB%
 967: 08c9:    SRPDF.SHRT.DESC$      =  MID$(POGDE.RCD$, 14, 50)
 968: 08f0:    SRPDF.FULL.DESC$      =  MID$(POGDE.RCD$,132,100)
 969: 0918: 
 970: 0918: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
 971: 0918: \* Extract SRPOG.DESCRIPTION$ (30 bytes) from short decriptor      *\
 972: 0918: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
 973: 0918: 
 974: 0918:    SRPOG.DESCRIPTION$    = LEFT$(SRPDF.SHRT.DESC$, 30)
 975: 093f: 
 976: 093f: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
 977: 093f: \* Build SRPOG.CAT.DBKEY from category keys in Delta file          *\
 978: 093f: \* Set key level                                                   *\
 979: 093f: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
 980: 093f: 
 981: 093f:    IF SRPOG.CAT3.ID% <> 0 THEN BEGIN
 982: 095e:       SRPOG.KEY.LEVEL% = 3
 983: 0970:    ENDIF ELSE IF SRPOG.CAT2.ID% <> 0 THEN BEGIN
 984: 098f:       SRPOG.KEY.LEVEL% = 2
 985: 09a1:    ENDIF ELSE BEGIN
 986: 09a9:       SRPOG.KEY.LEVEL% = 1
 987: 09b9:    ENDIF
 988: 09c1: 
 989: 09c1:    SRPOG.CAT.DBKEY% = GET.CATID%(SRPOG.CAT1.ID%,                    \
 990: 0a01:                                  SRPOG.CAT2.ID%,                    \
 991: 0a01:                                  SRPOG.CAT3.ID%)
 992: 0a01: 
 993: 0a01: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
 994: 0a01: \* Set repeat count values to default unset                        *\
 995: 0a01: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
 996: 0a01: 
 997: 0a01:    SRPOG.LIVE.RPT.CNT% = -1
 998: 0a11:    SRPOG.DATE.RPT.CNT$ = PACK$("00000000")
 999: 0a2d:    SRPOG.PEND.RPT.CNT% = -1
1000: 0a3d: 
1001: 0a3d: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1002: 0a3d: \* Set filler                                                      *\
1003: 0a3d: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1004: 0a3d: 
1005: 0a3d:    SRPOG.FILLER$ = " "
1006: 0a54:    SRPDF.FILLER$ = STRING$(15," ")
1007: 0a72: 
1008: 0a72: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1009: 0a72: \* Write SRPOG record to file                                      *\
1010: 0a72: \* Write SRPDF record to file                                      *\
1011: 0a72: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1012: 0a72: 
1013: 0a72:    rc% = WRITE.SRPOG
1014: 0a82:    IF rc% <> 0 THEN BEGIN
1015: 0a91:       GOSUB FILE.ERROR
1016: 0aa3:    ENDIF
1017: 0aab:    rc% = WRITE.SRPDF
1018: 0abb:    IF rc% <> 0 THEN BEGIN
1019: 0aca:       GOSUB FILE.ERROR
1020: 0adc:    ENDIF
1021: 0ae4: 
1022: 0ae4: RETURN
1023: 0af4: 
1024: 0af4: \********************************************************************
1025: 0af4: \***
1026: 0af4: \***    SUBROUTINE      :       POG.DEL
1027: 0af4: \***
1028: 0af4: \********************************************************************
1029: 0af4: \***
1030: 0af4: \***    Build SRPOG key from POGDE record
1031: 0af4: \***
1032: 0af4: \***    Read record from SRPOG file
1033: 0af4: \***
1034: 0af4: \***    Delete record from SRPOG file (Ignore not found errors)
1035: 0af4: \***
1036: 0af4: \***    Delete child records from SRMOD using key + module count
1037: 0af4: \***
1038: 0af4: \***    Delete notch details from SRSXF for the modules                 ! CRG
1039: 0af4: \***
1040: 0af4: \***    RETURN
1041: 0af4: \***
1042: 0af4: \********************************************************************
1043: 0af4: 
1044: 0af4: POG.DEL:
1045: 0b04: 
1046: 0b04:    SRPOG.POGID%        = GETN4(POGDE.RCD$, 1)                           ! CRG
1047: 0b30:    SRPOG.POGDB%        = GETN4(POGDE.RCD$, 5)                           ! CRG
1048: 0b5c:    SRPOG.ACT.DATE$     = MID$(POGDE.RCD$,10, 4)                         ! CRG
1049: 0b83:    SRPDF.POGDB%        = SRPOG.POGDB%                                   ! CRG
1050: 0b9c:    SRSXF.POGDB%        = SRPOG.POGDB%                                   ! CRG
1051: 0bb5:    SRMOD.POGDB%        = SRPOG.POGDB%                                   ! CRG
1052: 0bce:    SRMOD.MODULE.SEQ%   = 0                                              ! CRG
1053: 0bde:    SRMOD.RECORD.CHAIN% = 0                                              ! CRG
1054: 0bee:    ARRAY.COUNT%        = 0                                              ! CRG
1055: 0bfc:    CHAIN.COUNT%        = 0                                              ! CRG
1056: 0c09:    
1057: 0c09:   ! Module count will be changing from planner to planner but           ! CRG
1058: 0c09:   ! Iteration has to happen 127 times. In the past, it is noticed that  ! CRG
1059: 0c09:   ! Module sequence number are not always incremented in order, it      ! CRG
1060: 0c09:   ! will be random (1,4,7 etc.) So below count will make sure that      ! CRG
1061: 0c09:   ! deletion covers the entire module range.                            ! CRG
1062: 0c09:   
1063: 0c09:    SRMOD.COUNT.LIMIT%  = 127                                            ! CRG
1064: 0c16:    
1065: 0c16:    RC% = DELREC.SRPOG                                                   ! CRG
1066: 0c26:    RC% = DELREC.SRPDF                                                   ! CRG
1067: 0c36: 
1068: 0c36:   ! Delete all the Module records and its chain records for this POG    ! CRG
1069: 0c36:   ! from SRMOD file and delete the corresponding shelf records from     ! CRG
1070: 0c36:   ! SRSXF file                                                          ! CRG
1071: 0c36: 
1072: 0c36:    WHILE SRMOD.MODULE.SEQ% >= 0 AND                      \              ! CRG
1073: 0c41:          SRMOD.MODULE.SEQ% <= SRMOD.COUNT.LIMIT%                        ! CRG
1074: 0c41: 
1075: 0c41:       !Read SRMOD File                                                  ! CRG
1076: 0c41:       RC% = READ.SRMOD                                                  ! CRG
1077: 0c51: 
1078: 0c51:       IF RC% = 0 THEN BEGIN                                             ! CRG
1079: 0c63: 
1080: 0c63:          !If module record is read successfully then, get its chain     ! CRG
1081: 0c63:          !records count                                                 ! CRG
1082: 0c63: 
1083: 0c63:          IF SRMOD.ITEM.COUNT% > SRMOD.MAX.ITEMS% THEN BEGIN             ! CRG
1084: 0c7b:             CHAIN.COUNT% = SRMOD.ITEM.COUNT% / SRMOD.MAX.ITEMS%         ! CRG
1085: 0c95:          ENDIF                                                          ! CRG
1086: 0c9d: 
1087: 0c9d:          !Assign the current SRMOD module sequence to SRSXF module      ! CRG
1088: 0c9d:          !sequence                                                      ! CRG
1089: 0c9d: 
1090: 0c9d:          SRSXF.MODULE.SEQ% = SRMOD.MODULE.SEQ%                          ! CRG
1091: 0cb3: 
1092: 0cb3:          WHILE SRMOD.RECORD.CHAIN% <= CHAIN.COUNT%                      ! CRG
1093: 0cbe: 
1094: 0cbe:             !Get the shelf numbers from SRSXF file for all module       ! CRG
1095: 0cbe:             !records and its chain records and delete them from         ! CRG
1096: 0cbe:             !SRSXF file                                                 ! CRG
1097: 0cbe: 
1098: 0cbe:             FOR ARRAY.COUNT% = 0 TO SRMOD.MAX.ITEMS% - 1                ! CRG
1099: 0cce:                SRSXF.SHELF.NO% = SRMOD.SHELF.NUM%(ARRAY.COUNT%)         ! CRG
1100: 0cf2:                !Ignore delete errors                                    ! CRG
1101: 0cf2:                RC% = DELREC.SRSXF                                       ! CRG
1102: 0d02:             NEXT ARRAY.COUNT%                                           ! CRG
1103: 0d1f: 
1104: 0d1f:     ! Delete errors will be ignored as iteration happens for 127 times  ! CRG
1105: 0d1f:     ! even if the module sequence numbers are less. This is done to     ! CRG
1106: 0d1f:     ! avoid dumping of the event log with error message                 ! CRG
1107: 0d1f: 
1108: 0d1f:             RC% = DELREC.SRMOD                                          ! CRG
1109: 0d2f: 
1110: 0d2f:             !Increment the chain number to read the next chain record   ! CRG
1111: 0d2f:             !or to exit from the while loop                             ! CRG
1112: 0d2f:             SRMOD.RECORD.CHAIN% = SRMOD.RECORD.CHAIN% + 1               ! CRG
1113: 0d3e: 
1114: 0d3e:             !Read and delete the chain records if any                   ! CRG
1115: 0d3e:             RC% = 1                                                     ! CRG
1116: 0d4c: 
1117: 0d4c:             WHILE (RC% = 1) AND (SRMOD.RECORD.CHAIN% <= CHAIN.COUNT%)   ! CRG
1118: 0d56:                RC% = READ.SRMOD                                         ! CRG
1119: 0d66:                IF RC% THEN BEGIN                                        ! CRG
1120: 0d76:                   SRMOD.RECORD.CHAIN% = SRMOD.RECORD.CHAIN% + 1         ! CRG
1121: 0d85:                ENDIF                                                    ! CRG
1122: 0d8d:             WEND                                                        ! CRG
1123: 0db6: 
1124: 0db6:          WEND                                                           ! CRG
1125: 0dce: 
1126: 0dce:       ENDIF                                                             ! CRG
1127: 0dd6: 
1128: 0dd6:       !Increment SRMOD module sequence to check for the next available  ! CRG
1129: 0dd6:       !module sequence in the SRMOD file                                ! CRG
1130: 0dd6:       SRMOD.MODULE.SEQ% = SRMOD.MODULE.SEQ% + 1                         ! CRG
1131: 0de5: 
1132: 0de5:       !Reset the chain numbers and chain count for next module record   ! CRG
1133: 0de5:       SRMOD.RECORD.CHAIN% = 0                                           ! CRG
1134: 0df5:       CHAIN.COUNT% = 0                                                  ! CRG
1135: 0e02:    WEND                                                                 ! CRG
1136: 0e31: 
1137: 0e31:    ! Below original subroutine will be commented out as current logic   ! CRG
1138: 0e31:    ! does not delete records from SRSXF file. Deletion engine is        ! CRG
1139: 0e31:    ! outdated ,it leaves behind many records untouched, and over time   ! CRG
1140: 0e31:    ! it piles up in the file and POGOK suite fails                      ! CRG
1141: 0e31: 
1142: 0e31: 
1143: 0e31:     
1144: 0e31: 
1145: 0e31:    ! rc% = READ.SRPOG                                                   ! CRG
1146: 0e31:    ! IF rc% = 0 THEN BEGIN                                              ! CRG
1147: 0e31:    !   rc% = DELREC.SRPOG                                               ! CRG
1148: 0e31:    !   SRMOD.POGDB% = SRPOG.POGDB%                                      ! CRG
1149: 0e31:    !   SRMOD.MODULE.SEQ% = 0                                            ! CRG
1150: 0e31:    !   SRMOD.RECORD.CHAIN% = 0                                          ! CRG
1151: 0e31:    !   WHILE SRMOD.MODULE.SEQ% <= SRPOG.MODULE.COUNT%                   ! CRG
1152: 0e31:    !      rc% = READ.SRMOD                                              ! CRG
1153: 0e31:    !      rc% = DELREC.SRMOD                                            ! CRG
1154: 0e31:    !      WHILE SRMOD.ITEM.COUNT% > 50                                  ! CRG
1155: 0e31:    !         SRMOD.RECORD.CHAIN% = SRMOD.RECORD.CHAIN% +1               ! CRG
1156: 0e31:    !         SRMOD.ITEM.COUNT% = SRMOD.ITEM.COUNT% -50                  ! CRG
1157: 0e31:    !         rc% = DELREC.SRMOD                                         ! CRG
1158: 0e31:    !      WEND                                                          ! CRG
1159: 0e31:    !      SRMOD.MODULE.SEQ% = SRMOD.MODULE.SEQ% +1                      ! CRG
1160: 0e31:    !      SRMOD.RECORD.CHAIN% = 0                                       ! CRG
1161: 0e31:    !   WEND                                                             ! CRG
1162: 0e31:    ! ENDIF                                                              ! CRG
1163: 0e31:    ! rc% = READ.SRPDF                                                   ! CRG
1164: 0e31:    ! IF rc% = 0 THEN BEGIN                                              ! CRG
1165: 0e31:    !    rc% = DELREC.SRPDF                                              ! CRG
1166: 0e31:    ! ENDIF                                                              ! CRG
1167: 0e31: 
1168: 0e31: RETURN
1169: 0e41: 
1170: 0e41: \********************************************************************
1171: 0e41: \***
1172: 0e41: \***    SUBROUTINE      :       MOD.ADD
1173: 0e41: \***
1174: 0e41: \********************************************************************
1175: 0e41: \***
1176: 0e41: \***    Set SRMOD values from POGDE record
1177: 0e41: \***
1178: 0e41: \***    Write to SRMOD file
1179: 0e41: \***
1180: 0e41: \***    RETURN
1181: 0e41: \***
1182: 0e41: \********************************************************************
1183: 0e41: 
1184: 0e41: MOD.ADD:
1185: 0e51: 
1186: 0e51:    srmod.chg%  =  1
1187: 0e5e:    item.cnt%   =  0
1188: 0e6c:    shelf.cnt%  =  0
1189: 0e7a:    last.shelf% = -1
1190: 0e87: 
1191: 0e87:    SRMOD.POGDB%           = GETN4(POGDE.RCD$, 5)
1192: 0eb3:    SRMOD.MODULE.SEQ%      = GETN1(POGDE.RCD$,13)
1193: 0ed7:    SRMOD.RECORD.CHAIN%    = 0
1194: 0ee7:    SRMOD.DESCRIPTOR$      = MID$ (POGDE.RCD$,15,30)
1195: 0f0e:    FOR it.ptr% = 0 TO (SRMOD.MAX.ITEMS% -1)
1196: 0f1f:       SRMOD.SHELF.NUM%(it.ptr%) = 0
1197: 0f3d:       SRMOD.FACINGS%(it.ptr%)   = 0
1198: 0f5b:       SRMOD.ITEM.CODE$(it.ptr%) = STRING$(3,CHR$(0))
1199: 0f8a:       SRMOD.MDQ%(it.ptr%)       = 0
1200: 0fa9:       SRMOD.PSC%(it.ptr%)       = 0
1201: 0fc8:    NEXT it.ptr%
1202: 0fe8:    it.ptr% = 0
1203: 0ff6:    SRMOD.SHELF.COUNT%     = GETN2(POGDE.RCD$,44)
1204: 101a:    SRMOD.ITEM.COUNT%      = 0
1205: 102b:    SRMOD.FILLER$          = STRING$(18," ")
1206: 1049: 
1207: 1049:    IF SRPOG.POGID% <> GETN4(POGDE.RCD$,1) THEN BEGIN
1208: 1083:       srp10.event% = 6
1209: 1090:       GOSUB LOG.EVENT
1210: 10a2:    ENDIF
1211: 10aa: 
1212: 10aa: RETURN
1213: 10ba: 
1214: 10ba: \********************************************************************
1215: 10ba: \***
1216: 10ba: \***    SUBROUTINE      :       ITEM.ADD
1217: 10ba: \***
1218: 10ba: \********************************************************************
1219: 10ba: \***
1220: 10ba: \***    Set SRMOD values from POGDE record
1221: 10ba: \***
1222: 10ba: \***    Write to SRMOD file
1223: 10ba: \***
1224: 10ba: \***    RETURN
1225: 10ba: \***
1226: 10ba: \********************************************************************
1227: 10ba: 
1228: 10ba: ITEM.ADD:
1229: 10ca: 
1230: 10ca:    IF last.shelf% <> GETN1(POGDE.RCD$,12)                           \
1231: 1129:    OR last.notch% <> GETN1(POGDE.RCD$, 1) THEN BEGIN
1232: 1129:       shelf.cnt%        = shelf.cnt% +1
1233: 1135:       last.shelf%       = GETN1(POGDE.RCD$,12)
1234: 1155:       last.notch%       = GETN1(POGDE.RCD$, 1)
1235: 1175:       SRSXF.POGDB%      = SRMOD.POGDB%
1236: 118e:       SRSXF.MODULE.SEQ% = SRMOD.MODULE.SEQ%
1237: 11a4:       SRSXF.SHELF.NO%   = GETN1(POGDE.RCD$,12)
1238: 11c8:       SRSXF.NOTCH.NO%   = GETN1(POGDE.RCD$, 1)
1239: 11ec:       SRSXF.SHELF.KEY%  = GETN4(POGDE.RCD$,13)
1240: 1218:       SRSXF.SHELF.DESC$ = STRING$(50,CHR$(0))
1241: 1239:       SRSXF.FILLER$     = "  "
1242: 1250:       rc% = WRITE.SRSXF
1243: 1260:       IF rc% <> 0 THEN BEGIN
1244: 126f:          GOSUB FILE.ERROR
1245: 1281:       ENDIF
1246: 1289:    ENDIF
1247: 1291: 
1248: 1291:    SRMOD.FACINGS%(it.ptr%)   = GETN1(POGDE.RCD$, 2)
1249: 12c9:    SRMOD.ITEM.CODE$(it.ptr%) = MID$ (POGDE.RCD$, 6, 3)
1250: 12fe:    SRMOD.MDQ%(it.ptr%)       = GETN2(POGDE.RCD$, 8)
1251: 1336:    SRMOD.PSC%(it.ptr%)       = GETN2(POGDE.RCD$,10)
1252: 136e:    SRMOD.SHELF.NUM%(it.ptr%) = GETN1(POGDE.RCD$,12)
1253: 13a6:    it.ptr%  = it.ptr% +1
1254: 13b2: 
1255: 13b2: \  shelf.item.seq%   = GETN2(POGDE.RCD$, 3)      ! not used ?
1256: 13b2:    item.cnt%         = item.cnt% +1
1257: 13be:    SRMOD.ITEM.COUNT% = item.cnt%
1258: 13d0: 
1259: 13d0: RETURN
1260: 13e0: 
1261: 13e0: \********************************************************************
1262: 13e0: \***
1263: 13e0: \***    SUBROUTINE      :       WRITE.MODULE
1264: 13e0: \***
1265: 13e0: \********************************************************************
1266: 13e0: \***
1267: 13e0: \***    Write to SRMOD file
1268: 13e0: \***
1269: 13e0: \***    Increment CHAIN sequence ready for possible next write
1270: 13e0: \***
1271: 13e0: \***    RETURN
1272: 13e0: \***
1273: 13e0: \********************************************************************
1274: 13e0: 
1275: 13e0: WRITE.MODULE:
1276: 13f0: 
1277: 13f0:    rc% = WRITE.SRMOD
1278: 1400:    IF rc% <> 0 THEN BEGIN
1279: 140f:       GOSUB FILE.ERROR
1280: 1421:    ENDIF
1281: 1429: 
1282: 1429:    FOR it.ptr% = 0 TO (SRMOD.MAX.ITEMS% -1)
1283: 143a:       SRMOD.SHELF.NUM%(it.ptr%) = 0
1284: 1458:       SRMOD.FACINGS%(it.ptr%)   = 0
1285: 1476:       SRMOD.ITEM.CODE$(it.ptr%) = STRING$(3,CHR$(0))
1286: 14a5:       SRMOD.MDQ%(it.ptr%)       = 0
1287: 14c4:       SRMOD.PSC%(it.ptr%)       = 0
1288: 14e3:    NEXT it.ptr%
1289: 1503:    it.ptr% = 0
1290: 1511: 
1291: 1511:    SRMOD.RECORD.CHAIN%    = SRMOD.RECORD.CHAIN% +1
1292: 1520: 
1293: 1520: RETURN
1294: 1530: 
1295: 1530: \********************************************************************
1296: 1530: \***
1297: 1530: \***    SUBROUTINE      :       WRITE.MODULE.FINAL
1298: 1530: \***
1299: 1530: \********************************************************************
1300: 1530: \***
1301: 1530: \***    Write to SRMOD file
1302: 1530: \***
1303: 1530: \***    Update previous records in chain with item count
1304: 1530: \***
1305: 1530: \***    RETURN
1306: 1530: \***
1307: 1530: \********************************************************************
1308: 1530: 
1309: 1530: WRITE.MODULE.FINAL:
1310: 1540: 
1311: 1540: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1312: 1540: \* Shelf count not set by host insert computed count               *\
1313: 1540: \* This is the count of shelves and/or notch changes within a shelf*\
1314: 1540: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1315: 1540: 
1316: 1540:    SRMOD.SHELF.COUNT% = shelf.cnt%
1317: 1552: 
1318: 1552: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1319: 1552: \* Write any outstanding items to file                             *\
1320: 1552: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1321: 1552: 
1322: 1552:    IF it.ptr% > 0 THEN BEGIN
1323: 1561:       GOSUB WRITE.MODULE
1324: 1573:    ENDIF
1325: 157b: 
1326: 157b: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1327: 157b: \* Decrement the chain pointer by 2 to point to last but 1 write   *\
1328: 157b: \*    as the last write would have had the correct item count      *\
1329: 157b: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1330: 157b: 
1331: 157b:    SRMOD.RECORD.CHAIN% = SRMOD.RECORD.CHAIN% -2
1332: 158b: 
1333: 158b: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1334: 158b: \* For each record back to the first, update the item count field  *\
1335: 158b: \* and the shelf count field.                                      *\
1336: 158b: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1337: 158b: 
1338: 158b:    WHILE SRMOD.RECORD.CHAIN% >= 0
1339: 1596:       rc% = READ.SRMOD
1340: 15a6:       IF rc% <> 0 THEN BEGIN
1341: 15b5:          GOSUB FILE.ERROR
1342: 15c7:       ENDIF
1343: 15cf:       SRMOD.ITEM.COUNT% = item.cnt%
1344: 15e1:       SRMOD.SHELF.COUNT% = shelf.cnt%
1345: 15f3:       rc% = WRITE.SRMOD
1346: 1603:       IF rc% <> 0 THEN BEGIN
1347: 1612:          GOSUB FILE.ERROR
1348: 1624:       ENDIF
1349: 162c:       SRMOD.RECORD.CHAIN% = SRMOD.RECORD.CHAIN% -1
1350: 163b:    WEND
1351: 1650: 
1352: 1650: RETURN
1353: 1660: 
1354: 1660: \********************************************************************
1355: 1660: \***
1356: 1660: \***    SUBROUTINE      :       WRITE.POG.FINAL
1357: 1660: \***
1358: 1660: \********************************************************************
1359: 1660: \***
1360: 1660: \***    Write to SRPOG file updating module count
1361: 1660: \***
1362: 1660: \***    RETURN
1363: 1660: \***
1364: 1660: \********************************************************************
1365: 1660: 
1366: 1660: WRITE.POG.FINAL:
1367: 1670: 
1368: 1670:    rc% = READ.SRPOG
1369: 1680:    IF rc% <> 0 THEN BEGIN
1370: 168f:       GOSUB FILE.ERROR
1371: 16a1:    ENDIF
1372: 16a9:    SRPOG.MODULE.COUNT% = mod.cnt%
1373: 16bb:    rc% = WRITE.SRPOG
1374: 16cb:    IF rc% <> 0 THEN BEGIN
1375: 16da:       GOSUB FILE.ERROR
1376: 16ec:    ENDIF
1377: 16f4: 
1378: 16f4: RETURN
1379: 1704: 
1380: 1704: \********************************************************************
1381: 1704: \***
1382: 1704: \***    SUBROUTINE      :       INITIALISATION
1383: 1704: \***
1384: 1704: \********************************************************************
1385: 1704: \***
1386: 1704: \***    Initialise main program variables
1387: 1704: \***
1388: 1704: \***    Allocate session numbers to files
1389: 1704: \***
1390: 1704: \***    OPEN required files
1391: 1704: \***
1392: 1704: \***    SET program started flag
1393: 1704: \***
1394: 1704: \***    Check run is valid
1395: 1704: \***
1396: 1704: \***    RETURN
1397: 1704: \***
1398: 1704: \********************************************************************
1399: 1704: 
1400: 1704: INITIALISATION:
1401: 1714: 
1402: 1714: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1403: 1714: \* Set program variables                                           *\
1404: 1714: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1405: 1714: 
1406: 1714:    bg%           = 0
1407: 1721:    init.fail%    = 0
1408: 172e:    rec.cnt%      = 0
1409: 1743:    srmod.chg%    = 0
1410: 1750:    srp10.error%  = 0
1411: 175d:    srp10.event%  = 0
1412: 176a:    tlr.cnt%      = 0
1413: 177f:    tlr.read%     = 0
1414: 178c:    comm.tail$    = COMMAND$
1415: 17a2: 
1416: 17a2:    IF LEFT$(comm.tail$, 8) = "BACKGRND" THEN BEGIN
1417: 17d4:       bg% = 1
1418: 17e1:       comm.tail$ = MID$(comm.tail$,10,LEN(comm.tail$) -9)
1419: 1813:    ENDIF
1420: 181b: 
1421: 181b: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1422: 181b: \* Set todays date YYYYMMDD                                        *\
1423: 181b: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1424: 181b: 
1425: 181b:    rundate$ = PACK$("20"+DATE$)
1426: 1842: 
1427: 1842: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1428: 1842: \* Allocate Session Numbers and Open Files                         *\
1429: 1842: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1430: 1842: 
1431: 1842:    GOSUB ALLOCATE.SESS.NUMS
1432: 1854: 
1433: 1854:    GOSUB OPEN.FILES
1434: 1866: 
1435: 1866: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1436: 1866: \* Set POGOK run flag                                              *\
1437: 1866: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1438: 1866: 
1439: 1866:    no.read% = 0
1440: 1873: retry1:
1441: 1883:    rc% = READ.POGOK.LOCK
1442: 1893:    IF rc% <> 0 THEN BEGIN
1443: 18a2:       GOSUB FILE.ERROR
1444: 18b4:       IF no.read% > 0 THEN GOTO retry1
1445: 18c5:    ENDIF
1446: 18cd: 
1447: 18cd:    run.suite% = 2
1448: 18da:    IF LEFT$(comm.tail$, 7) = "SLEEPER" THEN BEGIN
1449: 190f:       IF POGOK.PE10.RUNDATE$ = rundate$                             \
1450: 1965:      AND POGOK.PE10.RUNFLAG$ <> "X" THEN BEGIN
1451: 1965:          run.suite% = run.suite% -1
1452: 1973:       ENDIF ELSE BEGIN
1453: 197b:          POGOK.PE10.RUNFLAG$ = "S"
1454: 1992:       ENDIF
1455: 199a:       IF POGOK.PE5.RUNDATE$ = rundate$                              \
1456: 19f0:      AND POGOK.PE5.RUNFLAG$ <> "X" THEN BEGIN
1457: 19f0:          run.suite% = run.suite% -1
1458: 19fe:       ENDIF ELSE BEGIN
1459: 1a06:          GOSUB START.SRP5
1460: 1a18:       ENDIF
1461: 1a22:    ENDIF ELSE BEGIN
1462: 1a2a:       POGOK.PE10.RUNFLAG$ = "S"
1463: 1a41:       GOSUB START.SRP5
1464: 1a53:    ENDIF
1465: 1a5b: 
1466: 1a5b:    rc% = WRITE.POGOK.UNLOCK
1467: 1a6b:    IF rc% <> 0 THEN BEGIN
1468: 1a7a:       GOSUB FILE.ERROR
1469: 1a8c:    ENDIF
1470: 1a94: 
1471: 1a94:    IF NOT run.suite% THEN BEGIN
1472: 1aa3:       init.fail% = -1
1473: 1ab0:       RETURN
1474: 1ac0:    ENDIF
1475: 1ac8: 
1476: 1ac8: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1477: 1ac8: \* Read input file header record                                   *\
1478: 1ac8: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1479: 1ac8: 
1480: 1ac8:    IF NOT no.inp.file% THEN BEGIN
1481: 1ad7:       rc% = READ.POGDE
1482: 1ae7:       IF rc% <> 0 THEN BEGIN
1483: 1af6:          GOSUB FILE.ERROR
1484: 1b08:       ENDIF
1485: 1b10:    ENDIF
1486: 1b18: 
1487: 1b18: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1488: 1b18: \* Check for header record                                         *\
1489: 1b18: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1490: 1b18: 
1491: 1b18:    IF (NOT no.inp.file%)                                            \
1492: 1b74:   AND (UNPACK$(MID$(POGDE.RCD$,1,1)) = "00") THEN BEGIN
1493: 1b74:       rec.cnt% = rec.cnt% +1
1494: 1b8d:       POGDE.SER.NO% = GETN4(POGDE.RCD$,1)
1495: 1bb7:       POGDE.DATE$   = MID$(POGDE.RCD$,6,4)
1496: 1bdc:       POGDE.DTR%    = GETN2(POGDE.RCD$,9)
1497: 1bfc: 
1498: 1bfc: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1499: 1bfc: \* NOT rerun AND serial number and date are equal - Duplicate      *\
1500: 1bfc: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1501: 1bfc: 
1502: 1bfc:       IF LEFT$(comm.tail$, 5) <> "RERUN"                            \
1503: 1c76:      AND LEFT$(comm.tail$, 7) <> "SLEEPER" THEN BEGIN               !
1504: 1c76:          IF VAL(POGOK.SRD.SER.NO$) = POGDE.SER.NO%                  \
1505: 1ce5:         AND POGOK.SRD.DATE$ = POGDE.DATE$ THEN BEGIN
1506: 1ce5: 
1507: 1ce5:             ! Log event for duplicate
1508: 1ce5:             srp10.event% = 2
1509: 1cf2:             GOSUB LOG.EVENT
1510: 1d04: 
1511: 1d04:             srp10.error% = srp10.error% OR 08H
1512: 1d14: 
1513: 1d14:             init.fail% = 1
1514: 1d21: 
1515: 1d21:             RETURN
1516: 1d31: 
1517: 1d31:          ENDIF
1518: 1d39:       ENDIF
1519: 1d41: 
1520: 1d41: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1521: 1d41: \* serial number or date < reset file - Old data                   *\
1522: 1d41: \*    (allow for serial number rollover @ 9999)                    *\
1523: 1d41: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1524: 1d41: 
1525: 1d41:       rc% = VAL(POGOK.SRD.SER.NO$)
1526: 1d5e:       IF rc% = 9999 THEN rc% = 0
1527: 1d74: 
1528: 1d74:       IF rc% > GETN4(POGDE.RCD$,1)                                  \
1529: 1de6:       OR POGOK.SRD.DATE$ > MID$(POGDE.RCD$,6,4) THEN BEGIN
1530: 1de6: 
1531: 1de6:          srp10.event% = 3
1532: 1df3:          GOSUB LOG.EVENT
1533: 1e05: 
1534: 1e05:          srp10.error% = srp10.error% OR 04H
1535: 1e15: 
1536: 1e15:          init.fail% = 1
1537: 1e22: 
1538: 1e22:          RETURN
1539: 1e32: 
1540: 1e32:       ENDIF
1541: 1e3a: 
1542: 1e3a: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1543: 1e3a: \* Initial load                                                    *\
1544: 1e3a: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1545: 1e3a: 
1546: 1e3a:       IF MID$(POGDE.RCD$,12,1) = "I" THEN BEGIN
1547: 1e72: 
1548: 1e72:          init.load% = 1
1549: 1e7f: 
1550: 1e7f:          IF NOT no.pog.file% THEN BEGIN
1551: 1e91:             CLOSE SRPOG.SESS.NUM%
1552: 1ea5:             IF END #SRPOG.SESS.NUM% THEN NO.SRPOG.COPY
1553: 1ec1:             OPEN SRPOG.COPY.NAME$ AS SRPOG.SESS.NUM%
1554: 1ee8:             DELETE SRPOG.SESS.NUM%
1555: 1efc: NO.SRPOG.COPY:
1556: 1f0c:             rc% = RENAME(SRPOG.COPY.NAME$,SRPOG.FILE.NAME$)
1557: 1f32:          ENDIF
1558: 1f3a:          IF NOT no.mod.file% THEN BEGIN
1559: 1f4c:             CLOSE SRMOD.SESS.NUM%
1560: 1f60:             IF END #SRMOD.SESS.NUM% THEN NO.SRMOD.COPY
1561: 1f7c:             OPEN SRMOD.COPY.NAME$ AS SRMOD.SESS.NUM%
1562: 1fa3:             DELETE SRMOD.SESS.NUM%
1563: 1fb7: NO.SRMOD.COPY:
1564: 1fc7:             rc% = RENAME(SRMOD.COPY.NAME$,SRMOD.FILE.NAME$)
1565: 1fed:          ENDIF
1566: 1ff5: 
1567: 1ff5:          GOSUB CREATE.SRPOG
1568: 2007:          GOSUB CREATE.SRMOD
1569: 201c: 
1570: 201c: 
1571: 201c:       ENDIF ELSE IF MID$(POGDE.RCD$,12,1) = "D" THEN BEGIN
1572: 2054: 
1573: 2054: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1574: 2054: \* delta file and no existing                                      *\
1575: 2054: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1576: 2054: 
1577: 2054:          IF no.pog.file% OR no.mod.file% THEN BEGIN
1578: 2068: 
1579: 2068:             srp10.event% = 5
1580: 2075:             GOSUB LOG.EVENT
1581: 2087: 
1582: 2087:             srp10.error% = srp10.error% OR 10H
1583: 2097: 
1584: 2097:             IF NOT no.pog.file% THEN BEGIN
1585: 20a6:                DELETE SRPOG.SESS.NUM%
1586: 20ba:             ENDIF
1587: 20c2:             IF NOT no.mod.file% THEN BEGIN
1588: 20d1:                DELETE SRMOD.SESS.NUM%
1589: 20e5:             ENDIF
1590: 20ed: 
1591: 20ed:             GOSUB CREATE.SRPOG
1592: 20ff:             GOSUB CREATE.SRMOD
1593: 2111: 
1594: 2111:          ENDIF
1595: 2119: 
1596: 2119:       ENDIF
1597: 2124: 
1598: 2124:    ENDIF ELSE BEGIN
1599: 212c: 
1600: 212c: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1601: 212c: \* No header record or No input file                               *\
1602: 212c: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1603: 212c: 
1604: 212c:       srp10.event% = 1
1605: 2139:       GOSUB LOG.EVENT
1606: 214b: 
1607: 214b:       srp10.error% = srp10.error% OR 20H
1608: 215b:       init.fail% = 1
1609: 2168: 
1610: 2168:       IF no.pog.file% OR no.mod.file% THEN BEGIN
1611: 217c: 
1612: 217c:          IF NOT no.pog.file% THEN BEGIN
1613: 218b:             DELETE SRPOG.SESS.NUM%
1614: 219f:          ENDIF
1615: 21a7:          IF NOT no.mod.file% THEN BEGIN
1616: 21b6:             DELETE SRMOD.SESS.NUM%
1617: 21ca:          ENDIF
1618: 21d2: 
1619: 21d2:          GOSUB CREATE.SRPOG
1620: 21e4:          GOSUB CREATE.SRMOD
1621: 21f6: 
1622: 21f6:       ENDIF
1623: 21fe: 
1624: 21fe:    ENDIF
1625: 2206: 
1626: 2206: RETURN
1627: 2216: 
1628: 2216: \********************************************************************
1629: 2216: \***
1630: 2216: \***    SUBROUTINE      :       ALLOCATE.SESS.NUMS
1631: 2216: \***
1632: 2216: \********************************************************************
1633: 2216: \***
1634: 2216: \***    Allocate all session numbers
1635: 2216: \***
1636: 2216: \********************************************************************
1637: 2216: 
1638: 2216: ALLOCATE.SESS.NUMS:
1639: 2226: 
1640: 2226:     SB.ACTION$ = "O"
1641: 223d: 
1642: 223d:     SB.INTEGER% = POGDE.REPORT.NUM%
1643: 2253:     SB.STRING$  = POGDE.FILE.NAME$
1644: 2271:     GOSUB SB.FILE.UTILS
1645: 2283:     POGDE.SESS.NUM% = SB.FILE.SESS.NUM%
1646: 2299: 
1647: 2299:     SB.INTEGER% = POGOK.REPORT.NUM%
1648: 22af:     SB.STRING$  = POGOK.FILE.NAME$
1649: 22cd:     GOSUB SB.FILE.UTILS
1650: 22df:     POGOK.SESS.NUM% = SB.FILE.SESS.NUM%
1651: 22f5: 
1652: 22f5:     SB.INTEGER% = SRPOG.REPORT.NUM%
1653: 230b:     SB.STRING$  = SRPOG.FILE.NAME$
1654: 2329:     GOSUB SB.FILE.UTILS
1655: 233b:     SRPOG.SESS.NUM% = SB.FILE.SESS.NUM%
1656: 2351: 
1657: 2351:     SB.INTEGER% = SRMOD.REPORT.NUM%
1658: 2367:     SB.STRING$  = SRMOD.FILE.NAME$
1659: 2385:     GOSUB SB.FILE.UTILS
1660: 2397:     SRMOD.SESS.NUM% = SB.FILE.SESS.NUM%
1661: 23ad: 
1662: 23ad:     SB.INTEGER% = SRPDF.REPORT.NUM%
1663: 23c3:     SB.STRING$  = SRPDF.FILE.NAME$
1664: 23e1:     GOSUB SB.FILE.UTILS
1665: 23f3:     SRPDF.SESS.NUM% = SB.FILE.SESS.NUM%
1666: 2409: 
1667: 2409:     SB.INTEGER% = SRSXF.REPORT.NUM%
1668: 241f:     SB.STRING$  = SRSXF.FILE.NAME$
1669: 243d:     GOSUB SB.FILE.UTILS
1670: 244f:     SRSXF.SESS.NUM% = SB.FILE.SESS.NUM%
1671: 2465: 
1672: 2465: RETURN
1673: 2475: 
1674: 2475: \********************************************************************
1675: 2475: \***
1676: 2475: \***    SUBROUTINE      :       OPEN.FILES
1677: 2475: \***
1678: 2475: \********************************************************************
1679: 2475: \***
1680: 2475: \***    Open required files
1681: 2475: \***
1682: 2475: \********************************************************************
1683: 2475: 
1684: 2475: OPEN.FILES:
1685: 2485: 
1686: 2485:    CALL POGDE.SET
1687: 24a0:    CALL POGOK.SET
1688: 24bb:    CALL SRPDF.SET
1689: 24d6:    CALL SRPOG.SET
1690: 24f1:    CALL SRMOD.SET
1691: 250c:    CALL SRSXF.SET
1692: 2527: 
1693: 2527:    FILE.OPERATION$ = "O"
1694: 253e: 
1695: 253e:    no.inp.file% = 1
1696: 254b:    CURRENT.REPORT.NUM% = POGDE.REPORT.NUM%
1697: 2561:    IF END # POGDE.SESS.NUM% THEN pogde.open.err
1698: 257d:    rc4% = SIZE(POGDE.FILE.NAME$)
1699: 25a2:    rc%  = MOD(rc4%, 1024)
1700: 25ba:    IF rc% <> 0 THEN BEGIN
1701: 25cc:       mess$ = STRING$(1024 -rc%, " ")
1702: 25ee:       work$ = "C" + STR$(LEN(mess$))
1703: 2621:       OPEN POGDE.FILE.NAME$ AS POGDE.SESS.NUM% APPEND
1704: 2648:       WRITE FORM work$; #POGDE.SESS.NUM%; mess$
1705: 2673:       CLOSE POGDE.SESS.NUM%
1706: 2687:    ENDIF
1707: 268f: 
1708: 268f:    OPEN POGDE.FILE.NAME$ DIRECT RECL 1024 AS POGDE.SESS.NUM%        \
1709: 26b8:         NOWRITE NODEL
1710: 26b8:    no.inp.file% = 0
1711: 26c5: pogde.open.err:
1712: 26d5: 
1713: 26d5:    no.file% = 1
1714: 26e2:    CURRENT.REPORT.NUM% = POGOK.REPORT.NUM%
1715: 26f8:    IF END # POGOK.SESS.NUM% THEN pogok.open.err
1716: 2714:    OPEN POGOK.FILE.NAME$ DIRECT RECL POGOK.RECL% AS POGOK.SESS.NUM% \
1717: 2741:          NODEL
1718: 2741:    no.file% = 0
1719: 274e: pogok.open.err:
1720: 275e:    IF no.file% = 1 THEN BEGIN
1721: 276d:       rc% = CREATE.POGOK
1722: 277d:       IF rc% <> 0 THEN BEGIN
1723: 278c:          GOSUB CREATE.ERROR
1724: 279e:       ENDIF
1725: 27a6:    ENDIF
1726: 27ae: 
1727: 27ae:    no.pog.file% = 1
1728: 27bb:    CURRENT.REPORT.NUM% = SRPOG.REPORT.NUM%
1729: 27d1:    IF END # SRPOG.SESS.NUM% THEN srpog.open.err
1730: 27ed:    OPEN SRPOG.FILE.NAME$ KEYED RECL SRPOG.RECL% AS SRPOG.SESS.NUM%
1731: 2819:    no.pog.file% = 0
1732: 2826: srpog.open.err:
1733: 2836: 
1734: 2836:    no.mod.file% = 1
1735: 2843:    CURRENT.REPORT.NUM% = SRMOD.REPORT.NUM%
1736: 2859:    IF END # SRMOD.SESS.NUM% THEN srmod.open.err
1737: 2875:    OPEN SRMOD.FILE.NAME$ KEYED RECL SRMOD.RECL% AS SRMOD.SESS.NUM%
1738: 28a1:    no.mod.file% = 0
1739: 28ae: srmod.open.err:
1740: 28be: 
1741: 28be:    no.file% = 1
1742: 28cb:    CURRENT.REPORT.NUM% = SRPDF.REPORT.NUM%
1743: 28e1:    IF END # SRPDF.SESS.NUM% THEN srpdf.open.err
1744: 28fd:    OPEN SRPDF.FILE.NAME$ KEYED RECL SRPDF.RECL% AS SRPDF.SESS.NUM%
1745: 2929:    no.file% = 0
1746: 2936: srpdf.open.err:
1747: 2946:    IF no.file% = 1 THEN BEGIN
1748: 2955:       no.file% = 0
1749: 2962:       IF NOT no.inp.file% THEN BEGIN
1750: 2971:          FILE.OPERATION$ = "C"
1751: 2988:    ! Planner refresh from Inctactix has been increased over time so     ! CRG 
1752: 2988:    ! doubling the file capacity to double of its current size           ! CRG
1753: 2988:    
1754: 2988:    !      CREATE POSFILE SRPDF.FILE.NAME$ KEYED 4,,,3000                ! DRG
1755: 2988: 
1756: 2988:           CREATE POSFILE SRPDF.FILE.NAME$ KEYED 4,,,6000                \ CRG
1757: 29bf:                 RECL SRPDF.RECL% AS SRPDF.SESS.NUM% MIRRORED ATCLOSE
1758: 29bf:       ENDIF
1759: 29c7:    ENDIF
1760: 29cf: 
1761: 29cf:    no.file% = 1
1762: 29dc:    CURRENT.REPORT.NUM% = SRSXF.REPORT.NUM%
1763: 29f2:    IF END # SRSXF.SESS.NUM% THEN srsxf.open.err
1764: 2a0e:    OPEN SRSXF.FILE.NAME$ KEYED RECL SRSXF.RECL% AS SRSXF.SESS.NUM%
1765: 2a3a:    no.file% = 0
1766: 2a47: srsxf.open.err:
1767: 2a57:    IF no.file% = 1 THEN BEGIN
1768: 2a66:       no.file% = 0
1769: 2a73:       IF NOT no.inp.file% THEN BEGIN
1770: 2a82:          FILE.OPERATION$ = "C"
1771: 2a99: 
1772: 2a99:    ! Planner refresh from Inctactix has been increased over time so     ! CRG 
1773: 2a99:    ! increasing the file capacity to 1.5 times of its current size      ! CRG 
1774: 2a99: 
1775: 2a99:    !      CREATE POSFILE SRSXF.FILE.NAME$ KEYED 6,,,60000               ! DRG
1776: 2a99: 
1777: 2a99:           CREATE POSFILE SRSXF.FILE.NAME$ KEYED 6,,,90000               \ CRG
1778: 2ad0:                 RECL SRSXF.RECL% AS SRSXF.SESS.NUM% MIRRORED ATCLOSE
1779: 2ad0:       ENDIF
1780: 2ad8:    ENDIF
1781: 2ae0: 
1782: 2ae0: RETURN
1783: 2af0: 
1784: 2af0: \********************************************************************
1785: 2af0: \***
1786: 2af0: \***    SUBROUTINE      :       UPDATE.RUN.FILE
1787: 2af0: \***
1788: 2af0: \********************************************************************
1789: 2af0: \***
1790: 2af0: \***    READ POGOK Locked
1791: 2af0: \***
1792: 2af0: \***    Set up variables according to run results
1793: 2af0: \***
1794: 2af0: \***    WRITE POGOK Unlock
1795: 2af0: \***
1796: 2af0: \***    RETURN
1797: 2af0: \***
1798: 2af0: \********************************************************************
1799: 2af0: 
1800: 2af0: UPDATE.RUN.FILE:
1801: 2b00: 
1802: 2b00: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1803: 2b00: \* Set todays date YYYYMMDD (set again incase 24:00 passed)        *\
1804: 2b00: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1805: 2b00: 
1806: 2b00:    rundate$ = PACK$("20"+DATE$)
1807: 2b27: 
1808: 2b27: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1809: 2b27: \* Set error codes for incomplete Delta file                       *\
1810: 2b27: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1811: 2b27: 
1812: 2b27:    IF (srp10.error% AND 80H) = 80H                                  \
1813: 2b4b:   AND init.fail% = 0 THEN BEGIN
1814: 2b4b:       IF tlr.read% = 0 THEN BEGIN
1815: 2b5a:          srp10.error% = srp10.error% OR 02H
1816: 2b6c:       ENDIF ELSE IF tlr.cnt% <> rec.cnt% THEN BEGIN
1817: 2b87:          srp10.error% = srp10.error% OR 01H
1818: 2b97:       ENDIF
1819: 2b9f:    ENDIF
1820: 2ba7: 
1821: 2ba7: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1822: 2ba7: \* Read POGOK file - Retry if locked                               *\
1823: 2ba7: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1824: 2ba7: 
1825: 2ba7:    no.read% = 0
1826: 2bb4: retry2:
1827: 2bc4:    rc% = READ.POGOK.LOCK
1828: 2bd4:    IF rc% <> 0 THEN BEGIN
1829: 2be3:       GOSUB FILE.ERROR
1830: 2bf5:       IF no.read% > 0 THEN GOTO retry2
1831: 2c06:    ENDIF
1832: 2c0e: 
1833: 2c0e: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1834: 2c0e: \* Update POGOK based on run results                               *\
1835: 2c0e: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1836: 2c0e: 
1837: 2c0e:    IF init.load% THEN BEGIN
1838: 2c1d:       POGOK.RELOAD$ = "N"
1839: 2c34:    ENDIF
1840: 2c3c: 
1841: 2c3c:    POGOK.PE10.RUNDATE$ = rundate$
1842: 2c57:    IF (srp10.error% AND 20H) <> 0 THEN BEGIN
1843: 2c68:       ! Delta File not found or No header record
1844: 2c68:       POGOK.PE10.RUNFLAG$ = "Y"
1845: 2c7f:       POGOK.PE10.RETCODE% = 6
1846: 2c92:    ENDIF ELSE IF (srp10.error% AND 83H) <> 0 THEN BEGIN
1847: 2ca6:       ! Abend via Main error routine (80H)
1848: 2ca6:       ! Incorrect record count (01H) or No trailer record (02H)
1849: 2ca6:       srp10.event% = 4
1850: 2cb3:       GOSUB LOG.EVENT
1851: 2cc5:       POGOK.PE10.RUNFLAG$      = "X"
1852: 2cdc:       IF (srp10.error% AND 80H) = 80H THEN BEGIN
1853: 2ced:          POGOK.PE10.RETCODE% = 8
1854: 2cff:       ENDIF ELSE BEGIN
1855: 2d07:          POGOK.PE10.RETCODE% = (srp10.error% AND 03H)
1856: 2d1b:       ENDIF
1857: 2d23:       POGOK.SRD.REC.COUNT%     = rec.cnt%
1858: 2d3a:       POGOK.FAILED.SRD.SER.NO$ = RIGHT$("0000"                      \
1859: 2d82:                                       + STR$(POGDE.SER.NO%),4)
1860: 2d82:       POGOK.FAILED.SRD.DATE$   = POGDE.DATE$
1861: 2da0:    ENDIF ELSE IF (srp10.error% AND 04H) <> 0 THEN BEGIN
1862: 2db1:       ! Old data
1863: 2db1:       POGOK.PE10.RUNFLAG$ = "Y"
1864: 2dc8:       POGOK.PE10.RETCODE% = 3
1865: 2ddb:    ENDIF ELSE IF (srp10.error% AND 08H) <> 0 THEN BEGIN
1866: 2dec:       ! Already processed (Not 'RERUN')
1867: 2dec:       POGOK.PE10.RUNFLAG$ = "E"
1868: 2e03:       POGOK.PE10.RETCODE% = 4
1869: 2e16:    ENDIF ELSE IF (srp10.error% AND 10H) <> 0 THEN BEGIN
1870: 2e27:       ! Init Load expected - Delta received
1871: 2e27:       POGOK.PE10.RUNFLAG$ = "Y"
1872: 2e3e:       POGOK.PE10.RETCODE% = 5
1873: 2e4e:       POGOK.RELOAD$       = "Y"
1874: 2e67:    ENDIF ELSE BEGIN
1875: 2e6f:       ! No problems
1876: 2e6f:       POGOK.PE10.RUNFLAG$ = "E"
1877: 2e86:       POGOK.PE10.RETCODE% = 0
1878: 2e96:    ENDIF
1879: 2e9e: 
1880: 2e9e:    IF POGOK.PE10.RETCODE% = 0                                       \
1881: 2ecb:    OR POGOK.PE10.RETCODE% = 5 THEN BEGIN
1882: 2ecb:       POGOK.SRD.SER.NO$     = RIGHT$("0000"+STR$(POGDE.SER.NO%),4)
1883: 2f13:       POGOK.SRD.DATE$       = POGDE.DATE$
1884: 2f2e:       POGOK.SRD.REC.COUNT%  = rec.cnt%
1885: 2f45:       POGOK.DAYS.TO.RETAIN% = POGDE.DTR%
1886: 2f57:    ENDIF
1887: 2f5f: 
1888: 2f5f: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1889: 2f5f: \* Write to POGOK                                                  *\
1890: 2f5f: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1891: 2f5f: 
1892: 2f5f:    rc% = WRITE.POGOK.UNLOCK
1893: 2f6f:    IF rc% <> 0 THEN BEGIN
1894: 2f7e:       GOSUB FILE.ERROR
1895: 2f90:    ENDIF
1896: 2f98: 
1897: 2f98: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1898: 2f98: \* Delete copies of SRPOG/SRMOD if they exist (Not if abended)     *\
1899: 2f98: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1900: 2f98: 
1901: 2f98:    IF POGOK.PE10.RUNFLAG$ <> "X" THEN BEGIN
1902: 2fb9:       IF SIZE(SRPOG.COPY.NAME$) > 0 THEN BEGIN
1903: 2fe8:          CLOSE SRPOG.SESS.NUM%
1904: 2ffc:          OPEN SRPOG.COPY.NAME$ AS SRPOG.SESS.NUM%
1905: 3023:          DELETE SRPOG.SESS.NUM%
1906: 3037:       ENDIF
1907: 303f:       IF SIZE(SRMOD.COPY.NAME$) > 0 THEN BEGIN
1908: 306e:          CLOSE SRMOD.SESS.NUM%
1909: 3082:          OPEN SRMOD.COPY.NAME$ AS SRMOD.SESS.NUM%
1910: 30a9:          DELETE SRMOD.SESS.NUM%
1911: 30bd:       ENDIF
1912: 30c5:    ENDIF
1913: 30cd: 
1914: 30cd: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1915: 30cd: \* Delete old copy of delta file/ Save current (Not if abended)    *\
1916: 30cd: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1917: 30cd: 
1918: 30cd:    IF POGOK.PE10.RUNFLAG$ <> "X" THEN BEGIN
1919: 30ee:       IF SIZE(POGDE.COPY.NAME$) > 0 THEN BEGIN
1920: 311d:          CLOSE POGDE.SESS.NUM%
1921: 3131:          OPEN POGDE.COPY.NAME$ AS POGDE.SESS.NUM%
1922: 3158:          DELETE POGDE.SESS.NUM%
1923: 316c:       ENDIF
1924: 3174:       rc% = RENAME(POGDE.COPY.NAME$,POGDE.FILE.NAME$)
1925: 319a:    ENDIF
1926: 31a2: 
1927: 31a2: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1928: 31a2: \* Start - House keeping & Index Prime                             *\
1929: 31a2: \*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
1930: 31a2: 
1931: 31a2:    GOSUB START.SRP6
1932: 31b4: 
1933: 31b4: RETURN
1934: 31c4: 
1935: 31c4: \********************************************************************
1936: 31c4: \***
1937: 31c4: \***    SUBROUTINE      :       TERMINATION
1938: 31c4: \***
1939: 31c4: \********************************************************************
1940: 31c4: \***
1941: 31c4: \***    Deallocate all session numbers
1942: 31c4: \***
1943: 31c4: \***    CLOSE the required files
1944: 31c4: \***
1945: 31c4: \********************************************************************
1946: 31c4: 
1947: 31c4: TERMINATION:
1948: 31d4: 
1949: 31d4:     SB.ACTION$ = "C"
1950: 31eb:     SB.STRING$ = ""
1951: 3202: 
1952: 3202:     SB.INTEGER% = POGDE.SESS.NUM%
1953: 3218:     CLOSE SB.INTEGER%
1954: 322c:     GOSUB SB.FILE.UTILS
1955: 323e: 
1956: 323e:     SB.INTEGER% = POGOK.SESS.NUM%
1957: 3254:     CLOSE SB.INTEGER%
1958: 3268:     GOSUB SB.FILE.UTILS
1959: 327a: 
1960: 327a:     SB.INTEGER% = SRPDF.SESS.NUM%
1961: 3290:     CLOSE SB.INTEGER%
1962: 32a4:     GOSUB SB.FILE.UTILS
1963: 32b6: 
1964: 32b6:     SB.INTEGER% = SRPOG.SESS.NUM%
1965: 32cc:     CLOSE SB.INTEGER%
1966: 32e0:     GOSUB SB.FILE.UTILS
1967: 32f2: 
1968: 32f2:     SB.INTEGER% = SRMOD.SESS.NUM%
1969: 3308:     CLOSE SB.INTEGER%
1970: 331c:     GOSUB SB.FILE.UTILS
1971: 332e: 
1972: 332e:     SB.INTEGER% = SRSXF.SESS.NUM%
1973: 3344:     CLOSE SB.INTEGER%
1974: 3358:     GOSUB SB.FILE.UTILS
1975: 336a: 
1976: 336a: RETURN
1977: 337a: 
1978: 337a: \********************************************************************
1979: 337a: \***
1980: 337a: \***    SUBROUTINE      :       START.SRP5
1981: 337a: \***
1982: 337a: \********************************************************************
1983: 337a: 
1984: 337a: 
1985: 337a: START.SRP5:
1986: 338a: 
1987: 338a:    file$ = "ADX_UPGM:SRP05.286"
1988: 339f:    parm$ = comm.tail$
1989: 33b8:    text$ = "S&R MAPPING LOAD - Started by SRP10 -"                  \
1990: 3439:          + MID$(TIME$,1,2) + ":"                                    \
1991: 3439:          + MID$(TIME$,3,2) + ":"                                    \
1992: 3439:          + MID$(TIME$,5,2)                                          !
1993: 3439:    rc%   = ADXSTART(file$, parm$, text$)
1994: 3464:    IF rc% <> 0 THEN BEGIN
1995: 3473:       srp10.event% = 8
1996: 3480:       GOSUB LOG.EVENT
1997: 3492:    ENDIF
1998: 349a: 
1999: 349a: RETURN
2000: 34aa: 
2001: 34aa: \********************************************************************
2002: 34aa: \***
2003: 34aa: \***    SUBROUTINE      :       START.SRP6
2004: 34aa: \***
2005: 34aa: \********************************************************************
2006: 34aa: 
2007: 34aa: 
2008: 34aa: START.SRP6:
2009: 34ba: 
2010: 34ba:    file$ = "ADX_UPGM:SRP06.286"
2011: 34cf:    parm$ = comm.tail$
2012: 34e8:    text$ = "S&R Housekeeping + Index from SRP10 -"                  \
2013: 3569:          + MID$(TIME$,1,2) + ":"                                    \
2014: 3569:          + MID$(TIME$,3,2) + ":"                                    \
2015: 3569:          + MID$(TIME$,5,2)                                          !
2016: 3569:    rc%   = ADXSTART(file$, parm$, text$)
2017: 3594:    IF rc% <> 0 THEN BEGIN
2018: 35a3:       srp10.event% = 8
2019: 35b0:       GOSUB LOG.EVENT
2020: 35c2:    ENDIF
2021: 35ca: 
2022: 35ca: RETURN
2023: 35da: 
2024: 35da: \********************************************************************
2025: 35da: \***
2026: 35da: \***    SUBROUTINE      :       CREATE.SRPOG
2027: 35da: \***
2028: 35da: \********************************************************************
2029: 35da: 
2030: 35da: CREATE.SRPOG:
2031: 35ea: 
2032: 35ea:    IF END #SRPOG.SESS.NUM% THEN CREATE.ERROR
2033: 3606:    CURRENT.REPORT.NUM% = SRPOG.REPORT.NUM%
2034: 361c:    
2035: 361c:    ! Planner refresh from Inctactix has been increased over time so     ! CRG 
2036: 361c:    ! increasing the file capacity to double of its current size         ! CRG 
2037: 361c:    
2038: 361c:    ! CREATE POSFILE SRPOG.FILE.NAME$ KEYED 4,,,3000                     ! DRG
2039: 361c: 
2040: 361c:      CREATE POSFILE SRPOG.FILE.NAME$ KEYED 4,,,6000                   \ ! CRG
2041: 3653:           RECL SRPOG.RECL% AS SRPOG.SESS.NUM% MIRRORED ATCLOSE
2042: 3653: 
2043: 3653:    no.pog.file% = 0
2044: 3660: 
2045: 3660:    RETURN
2046: 3670: 
2047: 3670: \********************************************************************
2048: 3670: \***
2049: 3670: \***    SUBROUTINE      :       CREATE.SRMOD
2050: 3670: \***
2051: 3670: \********************************************************************
2052: 3670: 
2053: 3670: 
2054: 3670: CREATE.SRMOD:
2055: 3680: 
2056: 3680:    IF END #SRMOD.SESS.NUM% THEN CREATE.ERROR
2057: 369c:    CURRENT.REPORT.NUM% = SRMOD.REPORT.NUM%
2058: 36b2:    
2059: 36b2:    ! Planner refresh from inctactix has been increased over time so     ! CRG 
2060: 36b2:    ! increasing the file capacity to double of its current size         ! CRG 
2061: 36b2:    ! CREATE POSFILE SRMOD.FILE.NAME$ KEYED 6,,,4000                     ! DRG
2062: 36b2: 
2063: 36b2:      CREATE POSFILE SRMOD.FILE.NAME$ KEYED 6,,,8000                   \ ! CRG
2064: 36e9:           RECL SRMOD.RECL% AS SRMOD.SESS.NUM% MIRRORED ATCLOSE
2065: 36e9: 
2066: 36e9:    no.mod.file% = 0
2067: 36f6: 
2068: 36f6:    RETURN
2069: 3706: 
2070: 3706: \********************************************************************
2071: 3706: \***
2072: 3706: \***    SUBROUTINE      :       DISPLAY.MSG
2073: 3706: \***
2074: 3706: \********************************************************************
2075: 3706: 
2076: 3706: DISPLAY.MSG:
2077: 3716: 
2078: 3716:    mess$ = LEFT$(mess$ + STRING$(36," "), 36) + " "                 \
2079: 37db:          + MID$(TIME$,1,2) + ":"                                    \
2080: 37db:          + MID$(TIME$,3,2) + ":"                                    \
2081: 37db:          + MID$(TIME$,5,2)                                          !
2082: 37db: 
2083: 37db:    IF bg% = 1 THEN BEGIN
2084: 37ea:       CALL ADXSERVE (rc4%, 26, 0, mess$)
2085: 3824:    ENDIF ELSE BEGIN
2086: 382c:       PRINT mess$
2087: 3841:    ENDIF
2088: 3849: 
2089: 3849: RETURN
2090: 3859: 
2091: 3859: \********************************************************************
2092: 3859: \***
2093: 3859: \***    SUBROUTINE      :       LOG.EVENT
2094: 3859: \***
2095: 3859: \***    srp10.event% = 1 - Header not 1st record in Delta file
2096: 3859: \***                   2 - Duplicate Delta File
2097: 3859: \***                   3 - Old Delta File
2098: 3859: \***                   4 - Premature eof on Delta file
2099: 3859: \***                   5 - Delta received - no existing POG/MOD file
2100: 3859: \***                   6 - ID of module record <> ID of POG Header
2101: 3859: \***                   7 - POG module records < POG module count
2102: 3859: \***                   8 - ADXSTART error
2103: 3859: \***
2104: 3859: \********************************************************************
2105: 3859: 
2106: 3859: LOG.EVENT:
2107: 3869: 
2108: 3869:    IF srp10.event% <  1                                             \
2109: 3888:    OR srp10.event% >  8 THEN BEGIN
2110: 3888:       GOTO 0
2111: 3893:    ENDIF
2112: 389b: 
2113: 389b:    message.no%   = 0
2114: 38a9: 
2115: 38a9:    ON srp10.event% GOSUB 1, 2, 3, 4, 5, 6, 7, 8
2116: 38d1: 
2117: 38d1: 0:
2118: 38e1:    srp10.event% = 0
2119: 38ee: 
2120: 38ee: RETURN
2121: 38fe: 
2122: 38fe: 1:
2123: 390e:    event.no%     = 17
2124: 391c:    var.string.1$ = RIGHT$("000" + STR$(POGDE.REPORT.NUM%),3)        \
2125: 399d:                  + "00 " + LEFT$(rectyp$ + "   ",3)
2126: 399d:    var.string.2$ = ""
2127: 39b2:    GOTO LOG.IT
2128: 39bd: 
2129: 39bd: 2:
2130: 39cd:    event.no%     = 177
2131: 39db:    var.string.1$ = CHR$(SHIFT(POGDE.REPORT.NUM%,8))                 \
2132: 3a3b:                  + CHR$(SHIFT(POGDE.REPORT.NUM%,0))                 \
2133: 3a3b:                  + "D"
2134: 3a3b:    var.string.2$ = ""
2135: 3a50:    GOTO LOG.IT
2136: 3a5b: 
2137: 3a5b: 3:
2138: 3a6b:    event.no%     = 177
2139: 3a79:    var.string.1$ = CHR$(SHIFT(POGDE.REPORT.NUM%,8))                 \
2140: 3ad9:                  + CHR$(SHIFT(POGDE.REPORT.NUM%,0))                 \
2141: 3ad9:                  + "O"
2142: 3ad9:    var.string.2$ = ""
2143: 3aee:    GOTO LOG.IT
2144: 3af9: 
2145: 3af9: 4:
2146: 3b09:    ! (Serial number not logged)
2147: 3b09:    event.no%     = 92
2148: 3b17:    var.string.1$ = CHR$(SHIFT(POGDE.REPORT.NUM%,8))                 \
2149: 3bfd:                  + CHR$(SHIFT(POGDE.REPORT.NUM%,0))                 \
2150: 3bfd:                  + PACK$(RIGHT$("00000000" +STR$(tlr.cnt%),8))      \
2151: 3bfd:                  + PACK$(RIGHT$("00000000" +STR$(rec.cnt%),8))
2152: 3bfd:    var.string.2$ = ""
2153: 3c12:    GOTO LOG.IT
2154: 3c1d: 
2155: 3c1d: 5:
2156: 3c2d:    event.no%     = 178
2157: 3c3b:    IF no.pog.file% THEN BEGIN
2158: 3c4a:       work$ = "SRPOG"
2159: 3c61:    ENDIF ELSE BEGIN
2160: 3c69:       work$ = "     "
2161: 3c7e:    ENDIF
2162: 3c86:    IF no.mod.file% THEN BEGIN
2163: 3c95:       work$ = work$                                                 \
2164: 3cb7:             + "SRMOD"
2165: 3cb7:    ENDIF ELSE BEGIN
2166: 3cbf:       work$ = work$                                                 \
2167: 3cdf:             + "     "
2168: 3cdf:    ENDIF
2169: 3ce7:    var.string.1$ = work$
2170: 3d00:    var.string.2$ = ""
2171: 3d15:    work$         = ""
2172: 3d2a:    GOTO LOG.IT
2173: 3d35: 
2174: 3d35: 6:
2175: 3d45:    event.no%     = 181
2176: 3d53:    work$         = STRING$(8,CHR$(0))
2177: 3d72:    CALL PUTN4(work$,0,VAL(UNPACK$(MID$(POGDE.RCD$,2,3))))
2178: 3db1:    CALL PUTN4(work$,4,SRPOG.POGID%)
2179: 3dd6:    var.string.1$ = CHR$(SHIFT(POGDE.REPORT.NUM%,8))                 \
2180: 3e3a:                  + CHR$(SHIFT(POGDE.REPORT.NUM%,0))                 \
2181: 3e3a:                  + work$
2182: 3e3a:    var.string.2$ = ""
2183: 3e4f:    GOTO LOG.IT
2184: 3e5a: 
2185: 3e5a: 7:
2186: 3e6a:    event.no%     = 182
2187: 3e78:    work$     = STRING$(2,CHR$(0))
2188: 3e97:    CALL PUTN1(work$,0,mod.cnt%)
2189: 3eb6:    CALL PUTN1(work$,1,SRPOG.MODULE.COUNT%)
2190: 3ed9:    var.string.1$ = CHR$(SHIFT(POGDE.REPORT.NUM%,8))                 \
2191: 3f3d:                  + CHR$(SHIFT(POGDE.REPORT.NUM%,0))                 \
2192: 3f3d:                  + work$
2193: 3f3d:    var.string.2$ = ""
2194: 3f52:    GOTO LOG.IT
2195: 3f5c: 
2196: 3f5c: 8:
2197: 3f6c:    event.no%     =  42
2198: 3f7a:    var.string.1$ = STR$(rc%)
2199: 3f96:    var.string.2$ = ""
2200: 3fab: 
2201: 3fab: LOG.IT:
2202: 3fbb: 
2203: 3fbb:    CALL APPLICATION.LOG(message.no%,                                \
2204: 3fe4:                         var.string.1$,                              \
2205: 3fe4:                         var.string.2$,                              \
2206: 3fe4:                         event.no%)
2207: 3fe4: 
2208: 3fe4: RETURN
2209: 3ff4: 
2210: 3ff4: \********************************************************************
2211: 3ff4: \***
2212: 3ff4: \***    SUBROUTINE      :       SB.FILE.UTILS
2213: 3ff4: \***
2214: 3ff4: \********************************************************************
2215: 3ff4: \***
2216: 3ff4: \***      Allocate/report/de-allocate a file session number
2217: 3ff4: \***
2218: 3ff4: \********************************************************************
2219: 3ff4: \***
2220: 3ff4: \***      Parameters : 2 or 3 (depending on action)
2221: 3ff4: \***
2222: 3ff4: \***         SB.ACTION$  = "O" for allocate file session number
2223: 3ff4: \***                       "R" for report file session number
2224: 3ff4: \***                       "C" for de-allocate file session number
2225: 3ff4: \***
2226: 3ff4: \***         SB.INTEGER% = file reporting number for action "O" or
2227: 3ff4: \***                       file session number for actions "R" or "C"
2228: 3ff4: \***
2229: 3ff4: \***         SB.STRING$  = logical file name for action "O" or
2230: 3ff4: \***                       null ("") for action "R" and "C"
2231: 3ff4: \***
2232: 3ff4: \***      Output : 1 or 2 (depending on action)
2233: 3ff4: \***
2234: 3ff4: \***         SB.FILE.NAME$     = logical file name for action "R"
2235: 3ff4: \***
2236: 3ff4: \***         SB.FILE.SESS.NUM% = file session number for action "O"
2237: 3ff4: \***                             or undefined for action "C"
2238: 3ff4: \***         OR
2239: 3ff4: \***         SB.FILE.REP.NUM%  = file reporting number for action "R"
2240: 3ff4: \***                             or undefined for action "C"
2241: 3ff4: \***
2242: 3ff4: \********************************************************************
2243: 3ff4: 
2244: 3ff4: SB.FILE.UTILS:
2245: 4004: 
2246: 4004:     CALL SESS.NUM.UTILITY(SB.ACTION$, SB.INTEGER%, SB.STRING$)
2247: 4031: 
2248: 4031:     IF SB.ACTION$ = "O" THEN BEGIN
2249: 404f: 
2250: 404f:         SB.FILE.SESS.NUM% = F20.INTEGER.FILE.NO%
2251: 4067: 
2252: 4067:     ENDIF ELSE IF SB.ACTION$ = "R" THEN BEGIN
2253: 4085: 
2254: 4085:         SB.FILE.REP.NUM% = F20.INTEGER.FILE.NO%
2255: 409b:         SB.FILE.NAME$ = F20.FILE.NAME$
2256: 40b9: 
2257: 40b9:     ENDIF
2258: 40c1: 
2259: 40c1: RETURN
2260: 40d1: 
2261: 40d1: \********************************************************************
2262: 40d1: \***
2263: 40d1: \***    SUBROUTINE      :       CREATE.ERROR
2264: 40d1: \***
2265: 40d1: \********************************************************************
2266: 40d1: 
2267: 40d1: CREATE.ERROR:
2268: 40e1: 
2269: 40e1:    FILE.OPERATION$ = "C"
2270: 40f8: 
2271: 40f8:    GOSUB FILE.ERROR
2272: 410a: 
2273: 410a:    GOTO TIDY.END.PROG
2274: 4115: 
2275: 4115: RETURN
2276: 4125: 
2277: 4125: \********************************************************************
2278: 4125: \********************************************************************
2279: 4125: \***
2280: 4125: \***    E N D  O F  L O W  L E V E L  S U B R O U T I N E S
2281: 4125: \***
2282: 4125: \********************************************************************
2283: 4125: \********************************************************************
2284: 4125: 
2285: 4125: 
2286: 4125: \********************************************************************
2287: 4125: \********************************************************************
2288: 4125: \***
2289: 4125: \***    S T A R T  O F  E R R O R  R O U T I N E S
2290: 4125: \***
2291: 4125: \********************************************************************
2292: 4125: \********************************************************************
2293: 4125: \********************************************************************
2294: 4125: \***
2295: 4125: \***    ERROR ROUTINE   :       FILE.ERROR
2296: 4125: \***
2297: 4125: \********************************************************************
2298: 4125: 
2299: 4125: FILE.ERROR:
2300: 4135: 
2301: 4135:     IF SB.ACTION$ = "C" THEN RETURN             ! Ignore close errs
2302: 415b: 
2303: 415b:     event.no%   = 106
2304: 4169:     message.no% = 0
2305: 4177: 
2306: 4177:     file.no$ = CHR$(SHIFT(CURRENT.REPORT.NUM%,8)) +                 \
2307: 41c8:                CHR$(SHIFT(CURRENT.REPORT.NUM%,0))
2308: 41c8: 
2309: 41c8:     var.string.2$ = RIGHT$("000" + STR$(CURRENT.REPORT.NUM%),3)
2310: 4210: 
2311: 4210:     IF FILE.OPERATION$ = "R" THEN BEGIN
2312: 4231:         IF no.read% < 60                                             \
2313: 425c:        AND CURRENT.REPORT.NUM% = POGOK.REPORT.NUM% THEN BEGIN
2314: 425c:            WAIT ; 500
2315: 4273:            no.read% = no.read% +1
2316: 4281:         ENDIF ELSE BEGIN
2317: 4289:            var.string.2$ = var.string.2$                            \
2318: 42b5:                          + UNPACK$(CURRENT.CODE$)
2319: 42b5:         ENDIF
2320: 42bd:     ENDIF
2321: 42c5: 
2322: 42c5:     var.string.1$ = FILE.OPERATION$ +                               \
2323: 42fc:                     file.no$ +                                      \
2324: 42fc:                     PACK$(STRING$(12,"0"))
2325: 42fc: 
2326: 42fc:     CALL APPLICATION.LOG(message.no%,                               \
2327: 4325:                          var.string.1$,                             \
2328: 4325:                          var.string.2$,                             \
2329: 4325:                          event.no%)
2330: 4325: 
2331: 4325: RETURN
2332: 4335: 
2333: 4335: \********************************************************************
2334: 4335: \***
2335: 4335: \***    ERROR ROUTINE   :       ERROR.DETECTED
2336: 4335: \***
2337: 4335: \********************************************************************
2338: 4335: 
2339: 4335: ERROR.DETECTED:
2340: 4345: 
2341: 4345:     IF ERR = "OE" AND ERRF% = 0 THEN RESUME     ! Size errors
2342: 439c:     IF ERR = "CU" THEN RESUME
2343: 43d1: 
2344: 43d1:     CALL STANDARD.ERROR.DETECTED(ERRN,                              \
2345: 43fe:                                  ERRF%,                             \
2346: 43fe:                                  ERRL,                              \
2347: 43fe:                                  ERR)
2348: 43fe: 
2349: 43fe:     err.cd$ = ERR + " rec " + str$(rec.cnt%)
2350: 4433: 
2351: 4433:     IF (srp10.error% AND 80H) = 0 THEN BEGIN
2352: 4444:        srp10.error% = srp10.error% OR 80H
2353: 4454:        RESUME TIDY.END.PROG
2354: 446d:     ENDIF ELSE BEGIN
2355: 4475:        RESUME FATAL.END.PROG
2356: 448c:     ENDIF
2357: 4499: 
2358: 4499: END
2359: 4499: End of Compilation
