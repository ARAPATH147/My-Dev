   1: 0000: \******************************************************************************
   2: 0000: \******************************************************************************
   3: 0000: \***
   4: 0000: \***   $Workfile:   PSS3701.BAS  $
   5: 0000: \***
   6: 0000: \***   $Revision:   1.11  $
   7: 0000: \***
   8: 0000: \******************************************************************************
   9: 0000: \******************************************************************************
  10: 0000: \***
  11: 0000: \***   $Log:   V:/Archive/Basarch/pss3701.bav  $
  12: 0000: \***
  13: 0000: \***      Rev 1.11   09 Dec 2008 19:01:32   peter.sserunkuma
  14: 0000: \***   The open PLLDB statement record length
  15: 0000: \***   is now 164.  The change was in module
  16: 0000: \***   PSS3701.BAS
  17: 0000: \***
  18: 0000: \***
  19: 0000: \***      Rev 1.10   09 Feb 2007 14:43:38   paul.bowers
  20: 0000: \***   ASN directs in A7B
  21: 0000: \***
  22: 0000: \***      Rev 1.9   01 Mar 2005 11:33:50   dev07ps
  23: 0000: \***   Upwards TSF Fix.
  24: 0000: \***   Fix to Report & Session numbers.
  25: 0000: \***   Relinked with latest PLLOL object.
  26: 0000: \***   Removal of LSS specific code.
  27: 0000: \***   Fix to Stock Counting - moved to new program PDTSC.286 to solve PDT timeout when > 40 counts.
  28: 0000: \***
  29: 0000: \***
  30: 0000: \***      Rev 1.8   12 Jan 2005 12:20:50   dev88ps
  31: 0000: \***   Corrected so that old and new price checks
  32: 0000: \***   work in this release. Changes could be
  33: 0000: \***   removed in the future to get rid of the old
  34: 0000: \***   price check code. For A5A
  35: 0000: \***
  36: 0000: \***      Rev 1.7   07 Jan 2005 16:30:46   dev24ps
  37: 0000: \***   Fixed bug - Changed how CURRENT.STOCK figure calculated.
  38: 0000: \***
  39: 0000: \***      Rev 1.6   24 Dec 2004 13:04:08   dev07ps
  40: 0000: \***   A5A Shelf Monitor Project
  41: 0000: \***
  42: 0000: \***
  43: 0000: \***      Rev 1.5   30 Aug 1996 10:56:12   DEV20PS
  44: 0000: \***   Changes to 96D pilot problems.
  45: 0000: \***
  46: 0000: \***      Rev 1.4   21 May 1996 09:58:32   DEV20PS
  47: 0000: \***   Gap Monitor Changes
  48: 0000: \***
  49: 0000: \***      Rev 1.3   28 Jul 1995 13:28:18   DEVDSPS
  50: 0000: \***
  51: 0000: \***
  52: 0000: \***        Rev 1.3   16 Feb 1995 11:43:40   DEVDSPS
  53: 0000: \***   Update version number to 20 for CSRAF.
  54: 0000: \***
  55: 0000: \***      Rev 1.2   14 Feb 1995 11:43:40   NIK
  56: 0000: \***   Fixes to Boots Problems 1248, 1245, 1246, 1318, 1105
  57: 0000: \***
  58: 0000: \***      Rev 1.1   07 Oct 1994 15:51:24   DEVSPPS
  59: 0000: \***   Fixed PDT Support hang
  60: 0000: \***
  61: 0000: \******************************************************************************
  62: 0000: \******************************************************************************
  63: 0000: 
  64: 0000: \******************************************************************************
  65: 0000: \******************************************************************************
  66: 0000: \***                                                                        ***
  67: 0000: \***                                                                        ***
  68: 0000: \***           PROGRAM  :  PSS3701                                          ***
  69: 0000: \***                                                                        ***
  70: 0000: \***           AUTHOR   :  Janet Lawrence (Pseudocode / BASIC code)         ***
  71: 0000: \***                                                                        ***
  72: 0000: \***           DATE     :  9th August 1990                                  ***
  73: 0000: \***                                                                        ***
  74: 0000: \***                                                                        ***
  75: 0000: \***           Current version letter : M                                   ***
  76: 0000: \***                                                                        ***
  77: 0000: \***           Date of last amendment : 17th May 1994                       ***
  78: 0000: \***                                                                        ***
  79: 0000: \***                                                                        ***
  80: 0000: \******************************************************************************
  81: 0000: \******************************************************************************
  82: 0000: 
  83: 0000: \******************************************************************************
  84: 0000: \******************************************************************************
  85: 0000: \***                                                                        ***
  86: 0000: \***   O V E R V I E W                                                      ***
  87: 0000: \***                                                                        ***
  88: 0000: \***                                                                        ***
  89: 0000: \***   PSS37 - P.D.T Support Program.                                       ***
  90: 0000: \***                                                                        ***
  91: 0000: \***                                                                        ***
  92: 0000: \***   PSS37 is designed to run concurrently with PSS38. PSS38 handles      ***
  93: 0000: \***   all asyncronous communications with a connected PDT. All data        ***
  94: 0000: \***   sent by the PDT is passed to PSS37 via PSS38 by means of a 'pipe'.   ***
  95: 0000: \***   PSS37 validates the data sent to ensure the data has been sent in    ***
  96: 0000: \***   the correct sequence, has a valid format and is meaningful.          ***
  97: 0000: \***   There are basically two processes PSS37 performs ;                   ***
  98: 0000: \***   i)  takes counts from a PDT and puts them in the stock movement,     ***
  99: 0000: \***   ii) creates a file of lists requested by a PDT.                      ***
 100: 0000: \***                                                                        ***
 101: 0000: \***   This module was created to contain the bulk of the processing for    ***
 102: 0000: \***   the two new applications, CSR and PRICE CHECKING, introduced as      ***
 103: 0000: \***   part of the new EPOS-CSR link.                                       ***
 104: 0000: \***                                                                        ***
 105: 0000: \******************************************************************************
 106: 0000: \******************************************************************************
 107: 0000: 
 108: 0000: \******************************************************************************
 109: 0000: \******************************************************************************
 110: 0000: \***                                                                        ***
 111: 0000: \***   A M E N D M E N T S                                                  ***
 112: 0000: \***                                                                        ***
 113: 0000: \***   Version B : Gary Flood (Believe it or not!) 13/06/91                 ***
 114: 0000: \***   Details :   If manual count of item varies from original theoretical ***
 115: 0000: \***               stock by an amount which is more than 3 and more than    ***
 116: 0000: \***               30% of the original TS then set the count request flag   ***
 117: 0000: \***               on the CITEM file ON.                                    ***
 118: 0000: \***               This is a temporary change (ie. test is hard coded). The ***
 119: 0000: \***               test should be changed to be parameter driven from the   ***
 120: 0000: \***               BCSMF at the next opportunity.                           ***
 121: 0000: \***                                                                        ***
 122: 0000: \***   Version B : Paul Bowers    28/6/91   1/7/91                          ***
 123: 0000: \***   Details :   To correct the undo processing for override items not on ***
 124: 0000: \***               the CITEM file. preventing the program aborting back to  ***
 125: 0000: \***               Data state A.                                            ***
 126: 0000: \***               To prevent the program tring to DELETE the CSRWF when    ***
 127: 0000: \***               it has just already done so. and the file is no longer   ***
 128: 0000: \***               open.                                                    ***
 129: 0000: \***                                                                        ***
 130: 0000: \***   Version B : Paul Bowers   5/7/91                                     ***
 131: 0000: \***               To include a check date of last manual count to make sure***
 132: 0000: \***               you do not reject a manual count if it the initial count ***
 133: 0000: \***               In undo processing close the files if an error occurs    ***
 134: 0000: \***               which falls through a logs an event zero.                ***
 135: 0000: \***                                                                        ***
 136: 0000: \***   Version C : Paul Bowers 16/8/91                                      ***
 137: 0000: \***               To fix open problem 464. To prevent first link of an     ***
 138: 0000: \***               EPSOM line from ordering a full shelf when it becomes    ***
 139: 0000: \***               a CSR line.                                              ***
 140: 0000: \***                                                                        ***
 141: 0000: \***   Version D : Paul Bowers 1/10/91                                      ***
 142: 0000: \***               To include code to increment week4 sales by the value of ***
 143: 0000: \***               the order generated instead of PSC12 calculating it from ***
 144: 0000: \***               th CSRIMF which could include stock adjustments and make ***
 145: 0000: \***               the sales figure go nagative.                            ***
 146: 0000: \***               A consequence is that sales now reflect orders.          ***
 147: 0000: \***               To include code for a new CSR Audit file, for every PDT  ***
 148: 0000: \***               signon, failure, List Header send an entry to the Audit  ***
 149: 0000: \***               file.                                                    ***
 150: 0000: \***                                                                        ***
 151: 0000: \***   Version E : Steve Wright                        30th October 1991    ***
 152: 0000: \***               Amend background message routine                         ***
 153: 0000: \***                                                                        ***
 154: 0000: \***   Version F : Paul Bowers 8/1/92                                       ***
 155: 0000: \***               To remove the updating of WEEK 4 SALES to PSC12 where it ***
 156: 0000: \***               will now be incremented by the quantity delivered. Thus  ***
 157: 0000: \***               preventing item from going vulnerable incorrectly.       ***
 158: 0000: \***                                                                        ***
 159: 0000: \***   Version G : David Smallwood 24/3/92                                  ***
 160: 0000: \***               Update included code for flashpack (FPF).                ***
 161: 0000: \***               Invalid data states are now recorded as "*"              ***
 162: 0000: \***               Update included code for CSRWF                           ***
 163: 0000: \***               Also - change for CSR - restructure subroutine           ***
 164: 0000: \***               CHECK.FOR.CHANGE.OF.SALES.  For this change to           ***
 165: 0000: \***               be effective changes made in version C will be           ***
 166: 0000: \***               commented out.                                           ***
 167: 0000: \***                                                                        ***
 168: 0000: \***  Version H : Les Cook 30/10/92                                         ***
 169: 0000: \***              Included code streamlined.                                ***
 170: 0000: \***              Version created to solve memory problems by making        ***
 171: 0000: \***              PSS37 chain back to itself after each application.        ***
 172: 0000: \***              Also to fix problem B727.                                 ***
 173: 0000: \***                                                                        ***
 174: 0000: \***  Version I : Les Cook 12/11/92                                         ***
 175: 0000: \***              CSR lines linked for the first time which have an alloc.  ***
 176: 0000: \***              record on the IDSOF will have CIMF sales figures adjusted.***
 177: 0000: \***              IDSOF record then deleted.                                ***
 178: 0000: \***                                                                        ***
 179: 0000: \***  Version J : Les Cook 25/3/93                                          ***
 180: 0000: \***              Updated with UOD changes to included code.                ***
 181: 0000: \***              If program logs an ABORT FAIL error, it will also log     ***
 182: 0000: \***              instructions to reboot the PDT to the CSRAF.              ***
 183: 0000: \***                                                                        ***
 184: 0000: \***  Version Z : Paul Bowers  8/7/92; Les Cook 6/10/92                     ***
 185: 0000: \***              Emergency fix version for store 1801 Arnold and CD5 OS    ***
 186: 0000: \***              L.C.  increase wait time to 20secs (from 10 secs) in      ***
 187: 0000: \***              Mainline Code section and RECEIVED.CSR.EOT subroutine.    ***
 188: 0000: \***                                                                        ***
 189: 0000: \***  Version K : Michael J. Kelsall  11/10/93                              ***
 190: 0000: \***                Fix to Boots problem 1060, session numbers for CITEM and***
 191: 0000: \***                IDF hardcoded, changed to session number allocated to   ***
 192: 0000: \***                each file. (Part of the RETURNS/AUTO CREDIT CLAIMING    ***
 193: 0000: \***                SYSTEM).                                                ***
 194: 0000: \***              Addition of LDTAF coding for audit function.              ***
 195: 0000: \***                                                                        ***
 196: 0000: \***  Version L : Michael J. Kelsall  23/03/94                              ***
 197: 0000: \***              Change of LDTAF duration field from minutes to seconds.   ***
 198: 0000: \***                                                                        ***
 199: 0000: \***  Version M : Steven Goulding 2/6/94                                    ***
 200: 0000: \***              Recompile for version letter change in audit file         ***
 201: 0000: \***                                                                        ***
 202: 0000: \***                                                                        ***
 203: 0000: \***  REVISION 1.1      ROBERT COWEY / STEVE WRIGHT      6TH OCTOBER 1994   ***
 204: 0000: \***  Removed version letters from included code (not commented).           ***
 205: 0000: \***                                                                        ***
 206: 0000: \***   Version N (1.2)         Nik Sen                 26th January 1995    ***
 207: 0000: \***   Amended CSR EOT processing so that Receive.State is set to '?'       ***
 208: 0000: \***   which will force a restart when program returns to calling module.   ***
 209: 0000: \***   Added error trap for ownership differences on CSRWF delete. Returns  ***
 210: 0000: \***   to calling module and data state 'A'.                                ***
 211: 0000: \***   Changed code in CHECK.FP.SALES to read CIMF locked to fix Boots      ***
 212: 0000: \***   Problem 1105.                                                        ***
 213: 0000: \***   Changed SB.FILE.REP.NUM% to a 2 byte integer.                        ***
 214: 0000: \***                                                                        ***
 215: 0000: \***   REVISION 1.3      Stuart Highley                   10th April 1996   ***
 216: 0000: \***   Redirect gapped items (distinguished from price checked items due to ***
 217: 0000: \***   the price of the item being entered as 1p at the PDT) to a new file, ***
 218: 0000: \***   the Gapped Item Buffer File. Also, start the Gap Report application  ***
 219: 0000: \***   (PSS47).                                                             ***
 220: 0000: \***                                                                        ***
 221: 0000: \***   REVISION 1.4      Stuart Highley               29th September 1996   ***
 222: 0000: \***   Add a blank trailer record onto the end of each batch in the Gap     ***
 223: 0000: \***   Buffer File. This is so that the start of a new batch is known by    ***
 224: 0000: \***                                                                        ***
 225: 0000: \***   REVISION 1.5    Charles Skadorwa               25th October 2004     ***
 226: 0000: \***   Shelf Monitor Project changes.                                       ***
 227: 0000: \***                                                                        ***
 228: 0000: \***   REVISION 1.6    Mark Goode                     7th January 2004      ***
 229: 0000: \***   Changed how CURRENT.STOCK figure calculated.                         ***
 230: 0000: \***                                                                        ***
 231: 0000: \***   REVISION 1.7    Brian Greenfield             11th January 2005       ***
 232: 0000: \***   Fixes to allow old record type P and new record type P to both work. ***
 233: 0000: \***   The old record type P can be removed next time this module is        ***
 234: 0000: \***   altered.                                                             ***
 235: 0000: \***                                                                        ***
 236: 0000: \***   REVISION 1.8    Neil Bennett                 22nd December 2006      ***
 237: 0000: \***   Add ASN processing support.                                          ***
 238: 0000: \***   Remove CSR processing support.                                       ***
 239: 0000: \***                                                                        ***
 240: 0000: \***   REVISION 1.9    Peter Sserunkuma             09th December 2007      ***
 241: 0000: \***   PLLDB file record length has increased from 54 to 164.               ***
 242: 0000: \***                                                                        ***
 243: 0000: \***   REVISION 1.10   Tittoo Thomas                  11th August 2012      ***
 244: 0000: \***   PLLDB file record length has increased from 164 to 384 as part       ***
 245: 0000: \***   of SFA. (Fix for Stock File Accuracy QC defect - 444)                ***
 246: 0000: \***                                                                        ***
 247: 0000: \***   REVISION 1.11   Tittoo Thomas                  27th December 2012    ***
 248: 0000: \***   Included Application management WPI comments                         ***
 249: 0000: \***                                                                        ***
 250: 0000: \***   REVISION N      David Griffiths                5th July 2016         ***
 251: 0000: \***   Amendment made to make sure IMSTC is checked correctly for stock     ***
 252: 0000: \***   figure as scanning barcode did not find item.                        ***
 253: 0000: \***                                                                        ***
 254: 0000: \******************************************************************************
 255: 0000: \******************************************************************************
 256: 0000: 
 257: 0000: \******************************************************************************
 258: 0000: \******************************************************************************
 259: 0000: \***                                                                        ***
 260: 0000: \***   I N C L U D E S   A N D   V A R I A B L E S                          ***
 261: 0000: \***                                                                        ***
 262: 0000: \******************************************************************************
 263: 0000: \******************************************************************************
 264: 0000: 
 265: 0000:    %INCLUDE PSS37G.J86                                          ! LMJK
 266: 0000: \*****************************************************************************
 267: 0000: \*****************************************************************************
 268: 0000: \***                                                                       ***
 269: 0000: \***      G L O B A L   D E F I N I T I O N S   F O R   P S S 3 7          ***
 270: 0000: \***                                                                       ***
 271: 0000: \***           REFERENCE : PSS37G                                          ***
 272: 0000: \***                                                                       ***
 273: 0000: \***           VERSION E                                                   ***
 274: 0000: \***           5th November 1992                                           ***
 275: 0000: \***           Ver D.  Add support for ADXSERCL routine.                   ***
 276: 0000: \***           Ver E.  Add support for LDTBF                               ***
 277: 0000: \***                                                                       ***
 278: 0000: \***                                                                       ***
 279: 0000: \***           Version G                                                   ***
 280: 0000: \***           Add support for Returns/Automatic credit claiming           ***
 281: 0000: \***                                                                       ***
 282: 0000: \***           Version H  Michael J. Kelsall    24th March 1994.           ***
 283: 0000: \***           Add support for CCUPF                                       ***
 284: 0000: \***
 285: 0000: \***           REVISION 1.1  ROBERT COWEY / STEVE WRIGHT  6TH OCTOBER 1994
 286: 0000: \***           Removed version letters from included code (not commented).
 287: 0000: \***
 288: 0000: \***           REVISION 1.2  David Smallwood    26th May 1995
 289: 0000: \***           Add global variable ALLOW.CSR.PROCESSING.
 290: 0000: \***
 291: 0000: \***           REVISION 1.3  Stuart Highly      April 1996
 292: 0000: \***           Gap monitor changes
 293: 0000: \***
 294: 0000: \***           REVISION 1.4  David Smallwood    21st May 1996
 295: 0000: \***           Change global variable "NUM.OF.UODS%" to
 296: 0000: \***           "NUM.STATUS.O.C.X.UODS%".  Add variables "NUM.OF.CANCELLED.UODS%"
 297: 0000: \***           "NUM.OF.DESPATCHED.UODS%".  Add global variables for CCLAM.
 298: 0000: \***
 299: 0000: \***           REVISION 1.5  Nik Sen            30th June 1997
 300: 0000: \***           Add variables for SXTMP STKTK and STKBUF for stocktaking.
 301: 0000: \***
 302: 0000: \***           REVISION 1.6  David Artiss       23rd January 2001
 303: 0000: \***           Add new audit file STLDT
 304: 0000: \***
 305: 0000: \***           REVISION 1.7  Brian Greenfield   17th October 2002
 306: 0000: \***           Added LSSST and IMSTC for LSS stock counts.
 307: 0000: \***
 308: 0000: \***           REVISION 1.8  David Artiss       7th March 2003
 309: 0000: \***           Lots of file and field definitions added for BOL
 310: 0000: \***           stocktake changes.
 311: 0000: \***
 312: 0000: \***           REVISION 1.9  Brian Greenfield   18th July 2003
 313: 0000: \***           New file additions for Store Stock Counts
 314: 0000: \***
 315: 0000: \***           REVISION 2.0  Julia Stones      22nd October 2003
 316: 0000: \***           New file additions for SmartScript Pharmacy Stock system
 317: 0000: \***
 318: 0000: \***           REVISION 2.1  Julia Stones      12th November 2003
 319: 0000: \***           New file additions for Simplification of the credit claim system
 320: 0000: \***
 321: 0000: \***           REVISION 2.2 Julia Stones       12th March 2004
 322: 0000: \***           New file addition for Credit Claim rejection information
 323: 0000: \***
 324: 0000: \***           REVISION 2.3 Charles Skadorwa   10th November 2004
 325: 0000: \***           Shelf Monitor Project: add declarations for PLLOL & PLLDB files
 326: 0000: \***
 327: 0000: \***           REVISION 2.4 Brian Greenfield   11th January 2005
 328: 0000: \***           Fixes to allow old record type P and new record type P to both work.
 329: 0000: \***           The old record type P can be removed next time this module is
 330: 0000: \***           altered.
 331: 0000: \***
 332: 0000: \***           REVISION 2.5    Neil Bennett    22nd December 2006
 333: 0000: \***           Add ASN processing support.
 334: 0000: \***           Remove CSR processing support.
 335: 0000: \***
 336: 0000: \***           REVISION 2.6    Brian Greenfield 11th may 2007
 337: 0000: \***           Added recalls processing for A7C.
 338: 0000: \***
 339: 0000: \*****************************************************************************
 340: 0000: \*****************************************************************************
 341: 0000: 
 342: 0000: \*****************************************************************************
 343: 0000: \***   include global definitions for the following functions and procedures
 344: 0000: \***
 345: 0000: \***     APPLICATION.LOG              01
 346: 0000: \***     READ.NEXT.IEF                11
 347: 0000: \***     SORT.TABLE                   14
 348: 0000: \***     CONV.TO.HEX                  16
 349: 0000: \***     CONV.TO.STRING               17
 350: 0000: \***     SESS.NUM.UTILITY             20
 351: 0000: \***     CIMF
 352: 0000: \***     CITEM
 353: 0000: \***     CSR
 354: 0000: \***     CSRWF
 355: 0000: \***     CSRBF
 356: 0000: \***     FPF
 357: 0000: \***     IDF
 358: 0000: \***     IDSOF
 359: 0000: \***     INVOK
 360: 0000: \***     ONORD
 361: 0000: \***     PCHK
 362: 0000: \***     PIPEI
 363: 0000: \***     UNITS
 364: 0000: \***     STKMQ
 365: 0000: \***     BCSMF
 366: 0000: \***     IEF
 367: 0000: \***     DIRORD
 368: 0000: \***     DIRSUP
 369: 0000: \***     DIRWF
 370: 0000: \***     DIR
 371: 0000: \***     LDTBF
 372: 0000: \***     LDTCF
 373: 0000: \***     UOD
 374: 0000: \***     UODBF
 375: 0000: \***     UODTF
 376: 0000: \***     STKBF
 377: 0000: \***     SXTMP
 378: 0000: \***     STKTK
 379: 0000: \***     SSPSC
 380: 0000: \***     BTCS
 381: 0000: \***     PRINT
 382: 0000: \***     SOPTS
 383: 0000: \***     TSF
 384: 0000: \***     LOCAL
 385: 0000: \***
 386: 0000: \*****************************************************************************
 387: 0000: 
 388: 0000:  %INCLUDE PSBF01G.J86                     ! FLC
 389: 0000: REM \
 390: 0000: \*******************************************************************************
 391: 0000: \*******************************************************************************
 392: 0000: \***
 393: 0000: \***       %INCLUDE FOR GLOBAL DEFINITIONS FOR FUNCTION APPLICATION.LOG
 394: 0000: \***
 395: 0000: \***                FUNCTION NUMBER    : PSBF01
 396: 0000: \***
 397: 0000: \***                REFERENCE          : PSBF01G.J86
 398: 0000: \***
 399: 0000: \***                DATE OF LAST AMENDMENT  - 27/2/86
 400: 0000: \***
 401: 0000: \***
 402: 0000: \*******************************************************************************
 403: 0000: 
 404: 0000:       INTEGER GLOBAL  F01.RETURN.CODE%
 405: 0000: 
 406: 0000: 
 407: 0000:  %INCLUDE PSBF05G.J86                     ! 1.9BG
 408: 0000: REM\
 409: 0000: \*******************************************************************************
 410: 0000: \*******************************************************************************
 411: 0000: \***
 412: 0000: \***        INCLUDE       : CHECK.BOOTS.CODE globals
 413: 0000: \***
 414: 0000: \***        REFERENCE     : PSBF05G.J86
 415: 0000: \***
 416: 0000: \***        Version A      Bruce Scriver              25th February 1986
 417: 0000: \*** 
 418: 0000: \***        Version B      Andrew Wedgeworth              15th July 1992
 419: 0000: \***        Removal of return code field which no longer required.
 420: 0000: \***
 421: 0000: \*******************************************************************************
 422: 0000: \*******************************************************************************
 423: 0000: 
 424: 0000:       STRING   GLOBAL F05.VALID.CODE$
 425: 0000: 
 426: 0000: 
 427: 0000: !%INCLUDE PSBF06G.J86                     ! FLC
 428: 0000:  %INCLUDE PSBF11G.J86                     ! DLC
 429: 0000: REM \
 430: 0000: \*******************************************************************************
 431: 0000: \*******************************************************************************
 432: 0000: \***
 433: 0000: \***    %INCLUDE FOR GLOBALS DEFINITIONS FOR FUNCTION READ.NEXT.IEF
 434: 0000: \***
 435: 0000: \***            FUNCTION NUMBER    : PSBF11
 436: 0000: \***
 437: 0000: \***            REFERENCE          : PSBF11G.J86
 438: 0000: \***
 439: 0000: \***    Version B            Bruce Scriver             11th December 1986 
 440: 0000: \***
 441: 0000: \***    Version C            Andrew Wedgeworth             15th July 1992
 442: 0000: \***    Redundant return code field removed.
 443: 0000: \***
 444: 0000: \*******************************************************************************
 445: 0000: \*******************************************************************************
 446: 0000: 
 447: 0000:       STRING    GLOBAL  F11.ERROR.FLAG$,                               \ BBAAS
 448: 0000:                         F11.NEXT.BAR.CODE$                             ! BBAAS
 449: 0000: 
 450: 0000:       INTEGER*2 GLOBAL  F11.CURRENT.COUNT%
 451: 0000: 
 452: 0000: 
 453: 0000:  %INCLUDE PSBF14G.J86                     ! DLC
 454: 0000: REM\
 455: 0000: \*******************************************************************************
 456: 0000: \*******************************************************************************
 457: 0000: \***
 458: 0000: \***        INCLUDE       : SORT.TABLE globals
 459: 0000: \***
 460: 0000: \***        REFERENCE     : PSBF14G.J86
 461: 0000: \***
 462: 0000: \***        Version A     Bruce Scriver                3rd March 1986
 463: 0000: \*** 
 464: 0000: \***        Version B     Andrew Wedgeworth            17th July 1992
 465: 0000: \***        Removal of now redundant return code field.
 466: 0000: \***
 467: 0000: \*******************************************************************************
 468: 0000: \*******************************************************************************
 469: 0000: 
 470: 0000:       STRING   GLOBAL F14.TABLE$(1)
 471: 0000: 
 472: 0000: 
 473: 0000:  %INCLUDE PSBF16G.J86                     ! DLC
 474: 0000: REM\
 475: 0000: \*******************************************************************************
 476: 0000: \*******************************************************************************
 477: 0000: \***
 478: 0000: \***           %INCLUDE GLOBAL DEFINITIONS FOR CONV.TO.HEX FUNCTION
 479: 0000: \***
 480: 0000: \***                       REFERENCE     : PSBF16G.J86
 481: 0000: \*** 
 482: 0000: \***       Version A           Bruce Scriver            25th February 1986
 483: 0000: \***
 484: 0000: \***       Version B         Andrew Wedgeworth               2nd July 1992
 485: 0000: \***       Removal of now redundant F16.RETURN.CODE%.
 486: 0000: \***
 487: 0000: \*******************************************************************************
 488: 0000: \*******************************************************************************
 489: 0000: 
 490: 0000:       STRING   GLOBAL F16.HEX.STRING$
 491: 0000: 
 492: 0000:       ! 1 line deleted from here                                       ! BAW
 493: 0000:  %INCLUDE PSBF17G.J86                     ! DLC
 494: 0000: REM \
 495: 0000: \*******************************************************************************
 496: 0000: \*******************************************************************************
 497: 0000: \***
 498: 0000: \***
 499: 0000: \***        %INCLUDE GLOBAL DEFINITIONS FOR CONV.TO.STRING FUNCTION
 500: 0000: \***
 501: 0000: \***                    REFERENCE     : PSBF17G.J86
 502: 0000: \***
 503: 0000: \***        Version A         Bruce Scriver      24th February 1986
 504: 0000: \***
 505: 0000: \***        Version B       Andrew Wedgeworth         2nd July 1992
 506: 0000: \***        Removal of now redundant F17.RETURN.CODE%
 507: 0000: \***
 508: 0000: \*******************************************************************************
 509: 0000: \*******************************************************************************
 510: 0000: 
 511: 0000:       STRING   GLOBAL F17.RETURNED.STRING$
 512: 0000: 
 513: 0000:       ! 1 line deleted from here                                       ! BAW
 514: 0000: 
 515: 0000:  %INCLUDE PSBF18G.J86                     ! 1.8DA
 516: 0000: REM\
 517: 0000: \*******************************************************************************
 518: 0000: \*******************************************************************************
 519: 0000: \***
 520: 0000: \***        INCLUDE       : CALC.BOOTS.CODE.CHECK.DIGIT globals
 521: 0000: \***
 522: 0000: \***        REFERENCE     : PSBF18G.J86
 523: 0000: \***
 524: 0000: \***        Version A     Stephen Kelsey                  23rd March 1987
 525: 0000: \***
 526: 0000: \***        Version B     Andrew Wedgeworth                 7th July 1992
 527: 0000: \***        Removal of return code field which no longer required.
 528: 0000: \***
 529: 0000: \*******************************************************************************
 530: 0000: \*******************************************************************************
 531: 0000: 
 532: 0000:       STRING   GLOBAL F18.CHECK.DIGIT$
 533: 0000:     
 534: 0000:       ! 1 line deleted from here                                       ! BAW    
 535: 0000: 
 536: 0000:  %INCLUDE PSBF20G.J86                     ! DLC
 537: 0000: REM\
 538: 0000: \*******************************************************************************
 539: 0000: \*******************************************************************************
 540: 0000: \***
 541: 0000: \***     %INCLUDE GLOBAL VARIABLE DEFINITIONS FOR SESS.NUM.UTILITY FUNCTION
 542: 0000: \***
 543: 0000: \***                       REFERENCE     : PSBF20G.J86
 544: 0000: \*** 
 545: 0000: \***     Version A              Bruce Scrive                   5th May 1988   
 546: 0000: \*** 
 547: 0000: \***     Version B              Robert Cowey                   7th May 1991
 548: 0000: \***     Global variable F20.INTEGER.FILE.NO% changed from one byte integer
 549: 0000: \***     to two byte integer.
 550: 0000: \***
 551: 0000: \***     Version D              Andrew Wedgeworth             1st July 1992
 552: 0000: \***     F20.RETURN.CODE% removed as it is no longer required.
 553: 0000: \***
 554: 0000: \*******************************************************************************
 555: 0000: \*******************************************************************************
 556: 0000: 
 557: 0000:       STRING    GLOBAL F20.FILE.NAME$,                                 \
 558: 0000:                        F20.STRING.FILE.NO$,                            \
 559: 0000:                        F20.TABLE.DIMENSIONED.FLAG$,                    \
 560: 0000:                        SESS.NUM.TABLE$(1)
 561: 0000: 
 562: 0000:       INTEGER*2 GLOBAL F20.INTEGER.FILE.NO%
 563: 0000: 
 564: 0000:       ! 1 line deleted from here                                       ! DAW 
 565: 0000: 
 566: 0000:  %INCLUDE PSBF21G.J86                     ! 1.9BG
 567: 0000: REM\
 568: 0000: \*******************************************************************************
 569: 0000: \*******************************************************************************
 570: 0000: \***
 571: 0000: \***        INCLUDE       : CHECK.BAR.CODE globals
 572: 0000: \***
 573: 0000: \***        REFERENCE     : PSBF21G.J86
 574: 0000: \***
 575: 0000: \***        Version A     Bruce Scriver                  13th May 1988
 576: 0000: \***
 577: 0000: \***        Version B     Andrew Wedgeworth             21st July 1992
 578: 0000: \***        Return code removed as no longer used.
 579: 0000: \***
 580: 0000: \*******************************************************************************
 581: 0000: \*******************************************************************************
 582: 0000: 
 583: 0000:       STRING    GLOBAL F21.VALID.CODE.FLAG$
 584: 0000: 
 585: 0000: 
 586: 0000: 
 587: 0000: !%INCLUDE ASYNCNUB.J86                    ! FLC
 588: 0000:  %INCLUDE CHKBFDEC.J86                    ! DLC
 589: 0000: \******************************************************************************
 590: 0000: \***
 591: 0000: \***           %INCLUDE FOR CHKBF - PRICE CHECK BUFFER FILE
 592: 0000: \***
 593: 0000: \***                    - FIELD DECLARATIONS   
 594: 0000: \***                    - FILE REFERENCE PARAMETERS  
 595: 0000: \***  
 596: 0000: \***                    REFERENCE: CHKBFDEC.J86
 597: 0000: \***
 598: 0000: \******************************************************************************
 599: 0000: 
 600: 0000:    INTEGER*1 GLOBAL				\
 601: 0000: 	CHKBF.SESS.NUM%
 602: 0000: 
 603: 0000:    INTEGER*2 GLOBAL				\
 604: 0000: 	CHKBF.RECL%,                            \
 605: 0000:         CHKBF.REPORT.NUM% 	
 606: 0000: 
 607: 0000:    INTEGER*4 GLOBAL				\ DLC
 608: 0000:         CHKBF.POINTER%
 609: 0000: 	
 610: 0000:    STRING GLOBAL			\
 611: 0000: 	CHKBF.ITEM.CODE$,	\ 13 byte ASC - bar code, as passed from PDT
 612: 0000: 	CHKBF.PRICE$,		\  6 byte ASC - price, as passed from PDT 
 613: 0000: 	CHKBF.FILLER$,		\  1 byte ASC - spare
 614: 0000: 	CHKBF.FILE.NAME$
 615: 0000:  %INCLUDE GAPBFDEC.J86                    ! SDH !2.3CS !2.4BG
 616: 0000: \*****************************************************************************
 617: 0000: \***                                                                         *
 618: 0000: \***           %INCLUDE FOR GAPBF - GAP BUFFER FILE                          *
 619: 0000: \***                                                                         *
 620: 0000: \***                    - FIELD DECLARATIONS                                 *
 621: 0000: \***                    - FILE REFERENCE PARAMETERS                          *
 622: 0000: \***                                                                         *
 623: 0000: \***                    REFERENCE: GAPBFDEC.J86                              *
 624: 0000: \***                                                                         *
 625: 0000: \*****************************************************************************
 626: 0000: 
 627: 0000:    INTEGER*1 GLOBAL            \
 628: 0000:    GAPBF.SESS.NUM%
 629: 0000: 
 630: 0000:    INTEGER*2 GLOBAL            \   
 631: 0000:    GAPBF.REPORT.NUM%    
 632: 0000: 
 633: 0000:    STRING GLOBAL               \
 634: 0000:    GAPBF.BOOTS.CODE$,          \ 7 bytes ASC - Item code
 635: 0000:    GAPBF.FILE.NAME$
 636: 0000:  %INCLUDE PLLOLDEC.J86                    ! 2.3CS
 637: 0000: 
 638: 0000: \******************************************************************************
 639: 0000: \******************************************************************************
 640: 0000: \***
 641: 0000: \***         %INCLUDE FOR RF PICKING LIST OF LISTS FILE FIELD DECLARATIONS
 642: 0000: \***
 643: 0000: \***               FILE TYPE    : DIRECT
 644: 0000: \***
 645: 0000: \***               REFERENCE    : PLLOLDEC.J86
 646: 0000: \***
 647: 0000: \***    VERSION A.           Julia Stones.               11 August 2004
 648: 0000: \***               New file for RF system. Holds list of picking lists.
 649: 0000: \***
 650: 0000: \***    VERSION B            Mark Goode                  17th January 2005
 651: 0000: \***    Additional field required to state the lists status ('S' - Shelf Monitor
 652: 0000: \***    'F' - Fast Fill, 'O' - OSSR or 'E' - excess stock.
 653: 0000: \*******************************************************************************
 654: 0000: \*******************************************************************************
 655: 0000: 
 656: 0000: STRING GLOBAL                                                  \
 657: 0000:    PLLOL.FILE.NAME$,           \
 658: 0000:    PLLOL.LISTID$,              \ 3 bytes unpacked list ID
 659: 0000:    PLLOL.CREATOR.ID$,          \ 3 bytes unpacked Creator user ID
 660: 0000:    PLLOL.PICKER.ID$,           \ 3 bytes unpacked Picker user ID
 661: 0000:    PLLOL.ITEM.STATUS$,         \ 1 byte item status " "
 662: 0000:                                \                    "P" = Picked
 663: 0000:                                \                    "U" = Unpicked
 664: 0000:                                \                    "A" = List is active (someone is picking it)
 665: 0000:                                \                    "X" = List is cancelled
 666: 0000:    PLLOL.CREATE.DATE$,         \ 6 bytes unpacked create date YYMMDD
 667: 0000:    PLLOL.CREATE.TIME$,         \ 4 bytes unpacked create time HH:MM
 668: 0000:    PLLOL.PICK.START.TIME$,     \ 4 bytes unpacked pick start time HH:MM
 669: 0000:    PLLOL.PICK.END.TIME$,       \ 4 bytes unpacked pick end time HH:MM
 670: 0000:    PLLOL.ITEM.COUNT$,          \ 4 bytes unpacked item count (max number of items in list
 671: 0000:                                \                              duplicates will cobine to 1 record
 672: 0000:                                \                              on the PLLDB file)
 673: 0000:    PLLOL.OSSR.PICKING$,        \ 1 byte Marked for OSSR picking "Y" = marked for OSSR picking
 674: 0000:                                \                                "N" = not marked for OSSR picking
 675: 0000:    PLLOL.OSSR.STATUS$          ! 1 byte mark the status of the list.         ! BMG         
 676: 0000: 
 677: 0000: 
 678: 0000: INTEGER*4 GLOBAL               \
 679: 0000:        PLLOL.RECORD.NUM%
 680: 0000: 
 681: 0000: INTEGER*2 GLOBAL                \
 682: 0000:    PLLOL.REPORT.NUM%,           \
 683: 0000:    PLLOL.SESS.NUM%
 684: 0000: 
 685: 0000: 
 686: 0000: INTEGER*1 GLOBAL                \
 687: 0000:    PLLOL.RECL%
 688: 0000: 
 689: 0000: 
 690: 0000:  %INCLUDE PLLDBDEC.J86                    ! 2.3CS
 691: 0000: 
 692: 0000: \******************************************************************************
 693: 0000: \******************************************************************************
 694: 0000: \***
 695: 0000: \***         %INCLUDE FOR RF PICKING LIST ITEMS IN LISTS FILE FIELD DECLARATIONS
 696: 0000: \***
 697: 0000: \***               FILE TYPE    : KEYED
 698: 0000: \***
 699: 0000: \***               REFERENCE    : PLLDBDEC.J86
 700: 0000: \***
 701: 0000: \***    VERSION A.              Julia Stones.                   11th August 2004
 702: 0000: \***    New file for RF system. Holds picking list items in lists information.
 703: 0000: \***
 704: 0000: \***    VERSION B.              Mark Goode                     17th january 2005
 705: 0000: \***    Changes for OSSR WAN
 706: 0000: \***
 707: 0000: \***    VERSION C.              Charlies Skadorwa
 708: 0000: \***    Add Stock fig to filler space for PST47
 709: 0000: \***
 710: 0000: \***    VERSION D.              Mark Goode                      29th August 2008
 711: 0000: \***    Add new fields for Multi-site project
 712: 0000: \***
 713: 0000: \***    VERSION E.              Wasim Abdulkalam              11th November 2011
 714: 0000: \***    Added new fields for backshop and OSSR pending sales plan for Stock
 715: 0000: \***    file accuracy project
 716: 0000: \*******************************************************************************
 717: 0000: \*******************************************************************************
 718: 0000: 
 719: 0000: STRING GLOBAL                          \
 720: 0000:        PLLDB.FILE.NAME$,               \
 721: 0000:        PLLDB.KEY$,                     \ 6 bytes unpacked LISTID + ITEMSEQ
 722: 0000:        PLLDB.LISTID$,                  \ 3 bytes unpacked List Number
 723: 0000:        PLLDB.ITEMSEQ$,                 \ 3 bytes unpacked Item Sequence Number
 724: 0000:        PLLDB.BOOTSCODE$,               \ 4 bytes packed Boots item code including check digit
 725: 0000:        PLLDB.QTY.ONSHELF$,             \ 4 bytes unpacked Quantity on shelf
 726: 0000:        PLLDB.FILL.QTY$,                \ 4 bytes unpacked Fill quantity
 727: 0000:        PLLDB.GAPFILL.MRK$,             \ 1 byte ASC Gap/Fill marker "Y" = Gap created from Shelf monitor
 728: 0000:                                        \                            "N" = Fast Fill no TSF update
 729: 0000:        PLLDB.ITEM.STATUS$,             \ 1 byte ASC Item Status "U" = Unpicked, "P" = picked
 730: 0000:        PLLDB.STOCKROOM.CNT$,           \ 4 bytes unpacked Stock Room Count
 731: 0000:        PLLDB.SHELFMON.SALE.FIG$,       \ 4 bytes unpacked Sales figure at Shelf Monitoring
 732: 0000:        PLLDB.OSSR.FLAG$,               \ 1 bytes item OSSR flag   ! BMG
 733: 0000:      \!PLLDB.FILLER$,                  \ 7 byte filler            ! BMG !EWA
 734: 0000:        PLLDB.CNT.PENDSALES.BACKSHOP$,  \ 2 bytes packed backshop pending sales plan count      ! EWA
 735: 0000:        PLLDB.TIME.PENDSALES.BACKSHOP$, \ 2 bytes packed backshop pending sales plan count time ! EWA
 736: 0000:        PLLDB.CNT.PENDSALES.OSSR$,      \ 2 bytes packed OSSR pending sales plan count          ! EWA
 737: 0000:        PLLDB.TIME.PENDSALES.OSSR$,     \ 2 bytes packed OSSR pending sales plan count time     ! EWA
 738: 0000:        PLLDB.STKFIG.STOCKROOM$,        \ 4 bytes unpacked Sales figure at Shelf Monitoring
 739: 0000:                                        \ progam submitted for pint out
 740: 0000:        PLLDB.OSSR.CNT$,                \ 4 bytes unpacked OSSR item stock count figure
 741: 0000:        PLLDB.TIME.SHELFMON$,           \ 2 bytes packed Time of stock floor count hh:mm
 742: 0000:        PLLDB.TIME.BACKSHOP$,           \ 2 bytes packed Time of back shop count hh:mm
 743: 0000:        PLLDB.TIME.OSSR$,               \ 2 bytes packed Time of OSSR count hh:mm
 744: 0000:        PLLDB.BACKSHOP.SALE$,           \ 4 bytes unpacked Sale at time of backshop count
 745: 0000:        PLLDB.OSSR.SALE$,               \ 4 bytes unpacked Sale at time of OSSR count
 746: 0000:        PLLDB.MS.TABLE$,                \                                           ! DMG
 747: 0000:        PLLDB.MS.LOCATION.CNT$(1),      \ 2 byte packed multi-site location count   ! DMG
 748: 0000:        PLLDB.MS.SALES.FIG$(1),         \ 2 byte packed multi-site sales figure     ! DMG                                             ! CMG
 749: 0000:        PLLDB.MS.TIME.CNT$(1),          \ 2 byte packed multi-site time of count    ! DMG                                             ! CMG
 750: 0000:        PLLDB.MS.FILL.QTY$(1),          \ 2 byte packed multi-site fill quantity    ! DMG                                                        ! CMG
 751: 0000:        PLLDB.FILLER2$(1)               ! 2 byte filler                             ! DMG
 752: 0000: 
 753: 0000: INTEGER*2 GLOBAL                       \
 754: 0000:    PLLDB.REPORT.NUM%,                  \
 755: 0000:    PLLDB.SESS.NUM%
 756: 0000: 
 757: 0000: INTEGER*2 GLOBAL                       \
 758: 0000:    PLLDB.RECL%
 759: 0000: 
 760: 0000: 
 761: 0000: 
 762: 0000: \%INCLUDE CIMFDEC.J86                     ! DLC !2.5NWB
 763: 0000: \%INCLUDE CITEMDEC.J86                    ! DLC !2.5NWB
 764: 0000: \%INCLUDE CSRDEC.J86                      ! DLC !2.5NWB
 765: 0000: \%INCLUDE CSRWFDEC.J86                    ! DLC !2.5NWB
 766: 0000: \%INCLUDE CSRBFDEC.J86                    ! DLC !2.5NWB
 767: 0000: !%INCLUDE EPSOMDEC.J86                    ! FLC TEST
 768: 0000:  %INCLUDE FPFDEC.J86                      ! DLC
 769: 0000:  REM \
 770: 0000: \******************************************************************************
 771: 0000: \******************************************************************************
 772: 0000: \***
 773: 0000: \***         %INCLUDE FOR FLASHPACK / PARENT FILE FIELD DECLARATIONS
 774: 0000: \***
 775: 0000: \***               FILE TYPE    : Keyed
 776: 0000: \***
 777: 0000: \***               REFERENCE    : FPFDEC.J86
 778: 0000: \***
 779: 0000: \***         VERSION A : LES COOK  - 21/8/92
 780: 0000: \***
 781: 0000: \***    VERSION B.              ROBERT COWEY.                       21 OCT 1993.
 782: 0000: \***    No changes to this file.
 783: 0000: \***
 784: 0000: \***    VERSION C.              CLIVE NORRIS.                       17 JAN 1994.
 785: 0000: \***    No changes to this file. Version updated to keep in line 
 786: 0000: \***    with changes in FPFFUNC.BAS.
 787: 0000: \***
 788: 0000: \*******************************************************************************
 789: 0000: \*******************************************************************************
 790: 0000: 
 791: 0000:   STRING GLOBAL                  \
 792: 0000:     FPF.FILE.NAME$,              \
 793: 0000:     FPF.PARENT.CODE$,            \ 4 byte UPD with a check digit
 794: 0000:     FPF.CODE$(1),                \ 4 bytes upd first flashpack code of 10                 ! Boots code with a check digit 
 795: 0000:                                  \ (99999999 if no code) 
 796: 0000:     FPF.MULT.FACTOR$(1)          \ 2 bytes UPD multiplication factor for
 797: 0000:                   		 ! first flashpack code.
 798: 0000: 
 799: 0000:   INTEGER*2 GLOBAL        \
 800: 0000:     FPF.RECL%,            \
 801: 0000:     FPF.REPORT.NUM%,      \
 802: 0000:     FPF.SESS.NUM%,        \
 803: 0000:     MAX.FPF.CODES%
 804: 0000: 
 805: 0000:  %INCLUDE IDFDEC.J86                      ! FLC
 806: 0000: REM \
 807: 0000: \******************************************************************************
 808: 0000: \******************************************************************************
 809: 0000: \***
 810: 0000: \***         %INCLUDE FOR ITEM DATA FILE - FIELD DECLARATIONS
 811: 0000: \***                                       FILE REFERENCE PARAMETERS
 812: 0000: \***
 813: 0000: \***                  FILE TYPE    : Keyed
 814: 0000: \***
 815: 0000: \***                  REFERENCE    : IDFDEC.J86
 816: 0000: \***
 817: 0000: \***         VERSION A : Andrew Wedgeworth  29th June 1992    
 818: 0000: \***
 819: 0000: \***    VERSION C.              Robert Cowey.                       25 AUG 1993.
 820: 0000: \***    Replaced un-used RANK$ with BSNS.CNTR$ and FILLER$.
 821: 0000: \***
 822: 0000: \***    VERSION D.              Andrew Wedgeworth               15th March 1995
 823: 0000: \***    Comments updated to reflect the fact that some bits on the file are
 824: 0000: \***    no longer used.
 825: 0000: \***
 826: 0000: \*******************************************************************************
 827: 0000: \*******************************************************************************
 828: 0000: 
 829: 0000:   STRING GLOBAL           \
 830: 0000:     IDF.FILE.NAME$,       \  
 831: 0000:     IDF.BOOTS.CODE$,      \ 4 byte UPD with check digit (key)
 832: 0000:     IDF.FIRST.BAR.CODE$,  \ 6 byte UPD without check digit
 833: 0000:     IDF.SECOND.BAR.CODE$, \ 6 byte UPD without check digit
 834: 0000:     IDF.NO.OF.BAR.CODES$, \ 2 byte UPD. Total number of bar codes for this item
 835: 0000:     IDF.PRODUCT.GRP$,     \ 3 byte UPD. The first two digits are the concept
 836: 0000:                           \ group and the last four the concept sequence
 837: 0000:     IDF.STNDRD.DESC$,     \ 24 bytes
 838: 0000:     IDF.STATUS.1$,        \ 1 byte, values B,C,D,P,X,Z and blank
 839: 0000:     IDF.INTRO.DATE$,      \ 3 byte UPD YYMMDD. Date first added to this file
 840: 0000:     IDF.BSNS.CNTR$,       \ 1 byte ASC. Business Centre ID letter      ! CRC
 841: 0000:     IDF.FILLER$,          \ 1 byte un-used                             ! CRC
 842: 0000:     IDF.PARENT.CODE$,     \ 4 byte UPD with check digit ; may be zero if no
 843: 0000:                           \ flashpacks, current IDF.BOOTS.CODE$ if parent line
 844: 0000:                           \ or Boots Code of parent line if a flashpack.
 845: 0000:     IDF.DATE.OF.LAST.SALE$! 3 byte UPD. Date of last sale.
 846: 0000: 
 847: 0000:   INTEGER*1 GLOBAL        \
 848: 0000:     IDF.BIT.FLAGS.1%,     \ 1 byte - bit values
 849: 0000:                           \ X"80"  - Group code flag
 850: 0000:                           \ X"40"  - Keylines flag
 851: 0000:                           \ X"20"  - Markdown flag
 852: 0000:                           \ X"10"  - Warehouse flag
 853: 0000:                           \ X"08"  - CSR flag
 854: 0000:                           \ X"04"  - Directs A flag
 855: 0000:                           \ X"02"  - Directs B flag
 856: 0000:                           \ X"01"  - Directs C flag
 857: 0000:     IDF.BIT.FLAGS.2%      \ 1 byte - bit values
 858: 0000:                           \ X"80"  - Own brand line flag
 859: 0000:                           \ X"40"  - Exclusive line flag
 860: 0000:                           \ X"20"  - Unused 
 861: 0000:                           \ X"10"  - Unused
 862: 0000:                           \ X"08"  - Stock system flag
 863: 0000:                           \ X"04"  - Pending count flag
 864: 0000:                           \ X"02"  - Reserved
 865: 0000:                           ! X"01"  - Reserved
 866: 0000: 
 867: 0000:   INTEGER*2 GLOBAL        \
 868: 0000:     IDF.RECL%,            \  
 869: 0000:     IDF.REPORT.NUM%,      \ 
 870: 0000:     IDF.SESS.NUM%
 871: 0000:  %INCLUDE INVOKDEC.J86                    ! FLC
 872: 0000: \******************************************************************************
 873: 0000: \******************************************************************************
 874: 0000: \***
 875: 0000: \***   $Workfile:   INVOKDEC.J86  $
 876: 0000: \***
 877: 0000: \***   $Revision:   1.4  $
 878: 0000: \***
 879: 0000: \******************************************************************************
 880: 0000: \******************************************************************************
 881: 0000: \***
 882: 0000: \***   $Log:   V:\archive\j86\invokdec.j8v  $
 883: 0000: \***   
 884: 0000: \***      Rev 1.4   10 Feb 1998 14:11:36   DEV45PS
 885: 0000: \***   Added RP Delivery Days field
 886: 0000: \***   
 887: 0000: \***      Rev 1.3   09 Apr 1997 09:22:06   DEVAWPS
 888: 0000: \***   Added date of successful processing of Points
 889: 0000: \***   Events details.
 890: 0000: \***   
 891: 0000: \***      Rev 1.2   20 Dec 1994 11:02:52   DEVMJPS
 892: 0000: \***   CSR/2 Amendments - new fields added are 
 893: 0000: \***   PSC14 flag and Conversion Status flag 
 894: 0000: \***   
 895: 0000: \******************************************************************************
 896: 0000: \******************************************************************************
 897: 0000: REM \
 898: 0000: \******************************************************************************
 899: 0000: \******************************************************************************
 900: 0000: \***
 901: 0000: \***    FIELD DECLARATIONS AND FILE REFERENCE PARAMETERS FOR INVCE OK FILE 
 902: 0000: \***
 903: 0000: \***                     REFERENCE   : INVOKDEC.J86
 904: 0000: \***
 905: 0000: \***    Version A            Andrew Wedgeworth              3rd August 1992
 906: 0000: \***    
 907: 0000: \***    Version B            Stephen Kelsey                 12th October 1992
 908: 0000: \***    Include Direct Implementation Flag, PSC30 flag and date.
 909: 0000: \***
 910: 0000: \***    Version C            Les Cook                       15th February 1993
 911: 0000: \***    Include UOD Implementation Flag, UOD Booked in date, Previous serial
 912: 0000: \***    number and success flag.
 913: 0000: \***
 914: 0000: \***    Version D            David Smallwood                20th July 1994   
 915: 0000: \***    Include CSR PHASE1 transmission flag and CSR start method flag.
 916: 0000: \***    
 917: 0000: \***    Version E            Mick Bayliss                   19th Oct. 1994
 918: 0000: \***    New fields for CSR Phase 2 - PSC14 Flag and Conversion Status Flag.
 919: 0000: \***
 920: 0000: \***    Version F            Andrew Wedgeworth              27th March 1997
 921: 0000: \***    Added date of successful processing of Points Events details sent from 
 922: 0000: \***    the mainframe.
 923: 0000: \***
 924: 0000: \***    Version G            Nik Sen                        10th February 1998
 925: 0000: \***    Added parameter used by MINSITS RP to determine number of days to 
 926: 0000: \***    check for late delivery.
 927: 0000: \***
 928: 0000: \******************************************************************************
 929: 0000: \******************************************************************************
 930: 0000: 
 931: 0000: 
 932: 0000: \******************************************************************************
 933: 0000: \***
 934: 0000: \***   FILE REFERENCE PARAMETERS
 935: 0000: \***
 936: 0000: \******************************************************************************
 937: 0000: 
 938: 0000:   STRING GLOBAL           \
 939: 0000:     INVOK.FILE.NAME$
 940: 0000: 
 941: 0000:   INTEGER*2 GLOBAL        \
 942: 0000:     INVOK.SESS.NUM%,      \
 943: 0000:     INVOK.REPORT.NUM%
 944: 0000: 
 945: 0000: 
 946: 0000: \******************************************************************************
 947: 0000: \***
 948: 0000: \***   FIELD DECLARATIONS
 949: 0000: \***
 950: 0000: \******************************************************************************
 951: 0000: 
 952: 0000:   STRING GLOBAL                \
 953: 0000:     INVOK.SERIAL.NO$,          \ 5 bytes ASCII
 954: 0000:     INVOK.DATE$,               \ 3 bytes YYMMDD UPD
 955: 0000:     INVOK.SUCCESS.FLAG$,       \ 1 bytes ASCII
 956: 0000:     INVOK.STORE.NO$,           \ 4 bytes ASCII with leading zeroes
 957: 0000:     INVOK.INVENTORY.SRLNO$,    \ 5 bytes ASCII leading zeros
 958: 0000:     INVOK.INVENTORY.SUCCESS$,  \ 1 bytes ASCII 0=failed/1=success
 959: 0000:     INVOK.SALES.SRLNO$,        \ 5 bytes ASCII leading zeros
 960: 0000:     INVOK.SALES.SUCCESS$,      \ 1 bytes ASCII 0=failed/1=success
 961: 0000:     INVOK.NEW.LIST.SRLNO$,     \ 5 bytes ASCII
 962: 0000:     INVOK.NEW.LIST.SUCCESS$,   \ 1 bytes ASCII 0=failed/1=success
 963: 0000:     INVOK.CSR.DELIVERY.NO$,    \ 5 bytes ASCII				
 964: 0000:     INVOK.CSR.IDENT$,          \ 1 bytes ASCII value "Y" 		
 965: 0000:     INVOK.CSR.DELIVERY.DATE$,  \ 6 bytes ASCII YYMMDD			
 966: 0000:     INVOK.CSR.PSC11.FLAG$,     \ 1 bytes ASCII				
 967: 0000:     INVOK.CSR.PSC12.FLAG$,     \ 1 bytes ASCII				
 968: 0000:     INVOK.CSR.PSC13.FLAG$,     \ 1 bytes ASCII				
 969: 0000:     INVOK.CSR.PSC12.DAYS$,     \ 1 bytes UPD				
 970: 0000:     INVOK.PSS33.RUN.DATE$,     \ 3 bytes YYMMDD UPD                     
 971: 0000:     INVOK.PSS33.SUCCESS.FLAG$, \ 1 bytes ASCII 0=failed/1=success       
 972: 0000:     INVOK.DIR.IMPL.FLAG$,      \ 1 byte ASCII  1=phase 1 implemented   BSPK   
 973: 0000:                                \           blank=not yet implemented   BSPK 
 974: 0000:     INVOK.PSC30.RUN.DATE$,     \ 3 bytes YYMMDD UPD                    BSPK                     
 975: 0000:     INVOK.PSC30.SUCCESS.FLAG$, \ 1 bytes ASCII 0=failed/1=success      BSPK
 976: 0000:     INVOK.UOD.IMPL.FLAG$,      \ 1 byte ASCII 1=implemented            CLC
 977: 0000:     INVOK.LAST.UOD.DATE$,      \ 3 bytes UPD                           CLC
 978: 0000:     INVOK.PREV.SERIAL.NO$,     \ 5 bytes ASCII                         CLC
 979: 0000:     INVOK.PREV.SUCCESS.FLAG$,  \ 1 byte ASCII                          CLC
 980: 0000:     INVOK.SUPPRESS.EXCEP.REPORT$,     \ 1 byte ASCII Y/N               DDS
 981: 0000:     INVOK.CSR.STARTED.BY.SUP$,        \ 1 byte ASCII Y/N               DDS
 982: 0000:     INVOK.CSR.PSC14.FLAG$,            \ 1 byte ASCII S/E/X/Y           EMJB
 983: 0000:     INVOK.CSR.CONVERSION.STATUS.FLAG$,\ 1 byte ASCII P/S/X/C           EMJB
 984: 0000:     INVOK.PTS.EVENTS.OK.DATE$, \ 3 bytes UPD                           FAW
 985: 0000:     INVOK.RP.DAYS$,            \ 1 byte ASCII                          GNS
 986: 0000:     INVOK.FILLER$              ! 6 bytes spaces                        GNS
 987: 0000: 
 988: 0000:   INTEGER*2 GLOBAL        \
 989: 0000:     INVOK.RECL%
 990: 0000:  %INCLUDE ONORDDEC.J86                    ! DLC
 991: 0000: \******************************************************************************
 992: 0000: \******************************************************************************
 993: 0000: \***
 994: 0000: \***         %INCLUDE FOR CSR ON ORDER FILE - FIELD DECLARATIONS
 995: 0000: \***                                          FILE REFERENCE PARAMETERS
 996: 0000: \***
 997: 0000: \***               FILE TYPE    : Keyed     
 998: 0000: \***
 999: 0000: \***               REFERENCE    : ONORDDEC.J86
1000: 0000: \***
1001: 0000: \***               DATE OF LAST AMENDMENT -  09/10/92
1002: 0000: \***
1003: 0000: \******************************************************************************
1004: 0000: \*******************************************************************************
1005: 0000: 
1006: 0000:   STRING GLOBAL                  \
1007: 0000:     ONORD.FILE.NAME$,		 \
1008: 0000:     ONORD.KEY$,                  \ 12byte ASC
1009: 0000:     ONORD.ORDER.DATE$,           \ 6 byte ASC
1010: 0000:     ONORD.LIST.FREQ$,            \ 1 byte ASC
1011: 0000:     ONORD.UNIT.NO$,              \ 2 byte ASC 
1012: 0000:     ONORD.SEQ.NO$,               \ 3 byte ASC 
1013: 0000:     ONORD.HIGHEST.SEQ.NO$,       \ 3 byte ASC 
1014: 0000:     ONORD.FILLER$,               \
1015: 0000:     ONORD.ITEM.CODE$,            \ 7 byte ASC 
1016: 0000:     ONORD.QTY.1$,                \ 3 byte ASC
1017: 0000:     ONORD.QTY.2$,                \ 3 byte ASC 
1018: 0000:     ONORD.CSRITEM.UNDONE.FLAG$,  \ 1 byte ASC "Y" or "N"
1019: 0000:     ONORD.CSRIMF.UNDONE.FLAG$,   \ 1 byte ASC "Y" or "N" 
1020: 0000:     ONORD.DELETED.FLAG$          ! 1 byte ASC "Y" or "N" 
1021: 0000:     
1022: 0000:   INTEGER*2 GLOBAL		 \
1023: 0000:     ONORD.REPORT.NUM%,		 \
1024: 0000:     ONORD.RECL%,		 \
1025: 0000:     ONORD.SESS.NUM%  
1026: 0000:     
1027: 0000:  %INCLUDE PCHKDEC.J86                     ! DLC
1028: 0000: \******************************************************************************
1029: 0000: \******************************************************************************
1030: 0000: \***
1031: 0000: \***         %INCLUDE FOR PRICE CHECK FILE - FILE REFERENCE PARAMETERS
1032: 0000: \***
1033: 0000: \***               REFERENCE    : PCHKDEC.J86
1034: 0000: \***
1035: 0000: \******************************************************************************
1036: 0000: \*******************************************************************************
1037: 0000: 
1038: 0000:   STRING GLOBAL           \
1039: 0000:     PCHK.FILE.NAME$
1040: 0000: 
1041: 0000:   INTEGER*2 GLOBAL        \
1042: 0000:     PCHK.REPORT.NUM%,      \
1043: 0000:     PCHK.SESS.NUM%
1044: 0000:  %INCLUDE PIPEINUB.J86                    ! DLC
1045: 0000: 
1046: 0000: \******************************************************************************
1047: 0000: \******************************************************************************
1048: 0000: \***
1049: 0000: \***                   %INCLUDE FOR PSS38 INPUT PIPE
1050: 0000: \***
1051: 0000: \***                         LINK TYPE : PIPEI
1052: 0000: \***
1053: 0000: \***                     REFERENCE : PIPEINUM.J86
1054: 0000: \***
1055: 0000: \******************************************************************************
1056: 0000: \******************************************************************************
1057: 0000: 
1058: 0000:    STRING GLOBAL							\
1059: 0000: 	PIPEI.FILE.NAME$
1060: 0000: 	
1061: 0000:    INTEGER*1 GLOBAL							\
1062: 0000: 	PIPEI.REPORT.NUM%,						\
1063: 0000: 	PIPEI.SESS.NUM%
1064: 0000: !%INCLUDE PIPEONUB.J86                    ! FLC TEST
1065: 0000:  %INCLUDE UNITSDEC.J86                    ! DLC
1066: 0000: \******************************************************************************
1067: 0000: \******************************************************************************
1068: 0000: \***
1069: 0000: \***         %INCLUDE FOR UNITS - FILE REFERENCE PAREMETERS
1070: 0000: \***                              FIELD DECLARATIONS
1071: 0000: \***
1072: 0000: \***               REFERENCE    : UNITSDEC.J86
1073: 0000: \***
1074: 0000: \***
1075: 0000: \******************************************************************************
1076: 0000: \******************************************************************************
1077: 0000: 
1078: 0000:   STRING GLOBAL           \
1079: 0000:     UNITS.UNIT$,          \ 1  byte UPD (key)
1080: 0000:     UNITS.UNIT.NAME$,     \ 27 bytes ASCII
1081: 0000:     UNITS.BC.LETTER$,     \ 1  byte  ASCII
1082: 0000:     UNITS.FILLER$,        \ 6  bytes ASCII (spaces).
1083: 0000:     UNITS.FILE.NAME$
1084: 0000: 
1085: 0000:   INTEGER*2 GLOBAL        \
1086: 0000:     UNITS.REPORT.NUM%,    \ 
1087: 0000:     UNITS.RECL%,          \ 
1088: 0000:     UNITS.SESS.NUM%
1089: 0000:  %INCLUDE STKMQDEC.J86                    ! MMJK
1090: 0000: REM \
1091: 0000: \******************************************************************************
1092: 0000: \******************************************************************************
1093: 0000: \***
1094: 0000: \***      %INCLUDE FOR STOCK MOVEMENT QUEUE FILE FIELD DECLARATIONS
1095: 0000: \***                                             FILE REFERENCE PARAMETERS
1096: 0000: \***
1097: 0000: \***               FILE TYPE    : Sequential
1098: 0000: \***
1099: 0000: \***               REFERENCE    : STKMQDEC.J86
1100: 0000: \***
1101: 0000: \***      Version A.     L. Cook
1102: 0000: \***
1103: 0000: \***      Combined from STKMQNUE.J86 and STKMQFLE.J86
1104: 0000: \***
1105: 0000: \***      Version B.     S.P. Kelsey (CTG)            7th November
1106: 0000: \***      Include CSR Marker in the Type 1 and Type 18 transactions.
1107: 0000: \***
1108: 0000: \***      Version C.     S. Goulding                 8th March
1109: 0000: \***      Add fields for new tranctions types 21 & 23
1110: 0000: \***
1111: 0000: \***      Version D.     ???????????            ????????????
1112: 0000: \***      ????????????????????????????????????????????????????????
1113: 0000: \***
1114: 0000: \***      Version E.     Michael J. Kelsall           16th Dec 1993.
1115: 0000: \***      Addition of txn types, 24, 25, 26, 27 and 28. As part of the
1116: 0000: \***      RETURNS/AUTOMATIC CREDIT CLAIMING system.
1117: 0000: \***
1118: 0000: \***      Version 1.1    Michael J. Kelsall           10th Aug 1994.
1119: 0000: \***      Changes as part of R/ACC update to allow for zero price claim
1120: 0000: \***      processing. Addition of type 29 txn for this change.
1121: 0000: \***
1122: 0000: \***      Version 1.2    Nik Sen                       8th November 1994
1123: 0000: \***      Addition of transaction type 30 as oart of Epsom Life CSR Phase 2
1124: 0000: \***
1125: 0000: \***      Version 1.3    Neil Bennett                   2nd January 2007
1126: 0000: \***      Add ASN processing support. (Rec Type 17)
1127: 0000: \***
1128: 0000: \***      Version 1.4    Brian Greenfield               14th may 2007
1129: 0000: \***      Added STKMQ.RECALL.TYPE$ for use in A7C RECALLS - only type 26 records.
1130: 0000: \***
1131: 0000: \***      Version 1.5    Neil Bennett                  31st January 2008
1132: 0000: \***      Add STKMQ.FLAG$ for record type 11
1133: 0000: \***
1134: 0000: \***      Version 1.6    Dave Constable                5th September 2008
1135: 0000: \***      Add STKMQ.FLAG$ for record type 33
1136: 0000: \***
1137: 0000: \***      Version 1.7    Dave Constable                30th December 2008
1138: 0000: \***      Add STKMQ.RESCAN$ for record type 33
1139: 0000: \***
1140: 0000: \***      Version 1.8    Dave Constable                6th January 2009
1141: 0000: \***      Add Bookin date & time for record type 33
1142: 0000: \***
1143: 0000: \***      Version F      Mark Walker                      27th Mar 2014
1144: 0000: \***      F337 Centralised View of Stock
1145: 0000: \***      - Relocated STKMQ item processing variables to here.
1146: 0000: \***
1147: 0000: \******************************************************************************
1148: 0000: \*******************************************************************************
1149: 0000: \***
1150: 0000: \***  The length of the records on this file vary depending on the record
1151: 0000: \***  transaction type, but they all comprise combinations of the fields
1152: 0000: \***  defined below.
1153: 0000: \***
1154: 0000: \***  Transaction type 0 (Header record) - RECORD DELIMITER, TRANS TYPE,
1155: 0000: \***     FIELD DELIMITER, CREATION DATE, CREATION TIME, RECORD DELIMITER,
1156: 0000: \***     END OF RECORD MARKER.
1157: 0000: \***
1158: 0000: \***  Transaction type 1 - RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
1159: 0000: \***     TIME, FSI, FOLIO YEAR, FOLIO MONTH, FOLIO NUMBER, STORE SUFFIX,
1160: 0000: \***     COUNT OF ITEMS, INVOICE DAY,(FIELD DELIMITER, BOOTS CODE,
1161: 0000: \***     FIELD DELIMITER, QUANTITY, FIELD DELIMITER, CSR MARKER),
1162: 0000: \***     RECORD DELIMITER, END OF RECORD MARKER.
1163: 0000: \***     The fields within brackets are repeated as many times as count of items.
1164: 0000: \***
1165: 0000: \***  Transaction type 2 - RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
1166: 0000: \***     TIME, BOOTS CODE, FIELD DELIMITER, QUANTITY, RECORD DELIMITER,
1167: 0000: \***     END OF RECORD MARKER.
1168: 0000: \***
1169: 0000: \***  Transaction type 3 - RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
1170: 0000: \***     TIME, BOOTS CODE, FIELD DELIMITER, QUANTITY, FIELD DELIMITER,
1171: 0000: \***     REASON CODE, STORE/RETURN CODE, RECORD DELIMITER, END OF RECORD MARKER
1172: 0000: \***
1173: 0000: \***  Transaction type 4 - RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
1174: 0000: \***     TIME, BOOTS CODE, ON IDF FLAG, FIELD DELIMITER, QUANTITY,
1175: 0000: \***     RECORD DELIMITER, END OF RECORD MARKER
1176: 0000: \***
1177: 0000: \***  Transaction type 5 - RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
1178: 0000: \***     TIME, BOOTS CODE, COUNT FLAG, STOCK MOVEMENT DATE, FIELD DELIMITER,
1179: 0000: \***     QUANTITY, RECORD DELIMITER, END OF RECORD MARKER
1180: 0000: \***
1181: 0000: \***  Transaction type 6 - RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
1182: 0000: \***     TIME, BOOTS CODE, REASON (1 byte ASCII)
1183: 0000: \***     RECORD DELIMITER, END OF RECORD MARKER
1184: 0000: \***
1185: 0000: \***  Transaction type 7 - RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
1186: 0000: \***     TIME, BOOTS CODE, CONCEPT SEQUENCE
1187: 0000: \***     RECORD DELIMITER, END OF RECORD MARKER
1188: 0000: \***
1189: 0000: \***  Transaction type 8 - RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
1190: 0000: \***     TIME, PRODUCT GROUP, RECORD DELIMITER, END OF RECORD
1191: 0000: \***     MARKER
1192: 0000: \***
1193: 0000: \***  Transaction type 9 - RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
1194: 0000: \***     TIME, LIST NUMBER, ITEM NUMBER, LIST TYPE,
1195: 0000: \***     COUNT.BY.DATE, RECORD DELIMITER, END OF RECORD MARKER
1196: 0000: \***
1197: 0000: \***  Transaction type 10- RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
1198: 0000: \***     TIME, BOOTS CODE,
1199: 0000: \***     RECORD DELIMITER, END OF RECORD MARKER
1200: 0000: \***
1201: 0000: \***  Transaction type 11- RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
1202: 0000: \***     TIME, BOOTS CODE, FIELD DELIMITER, COUNT QUANTITY, FIELD DELIMITER(opt),
1203: 0000: \***     SOURCE(opt), FLAG(opt), RECORD DELIMITER, END OF RECORD MARKER
1204: 0000: \***
1205: 0000: \***  Transaction type 12- RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
1206: 0000: \***     TIME, BOOTS CODE,
1207: 0000: \***     RECORD DELIMITER, END OF RECORD MARKER
1208: 0000: \***
1209: 0000: \***  Transaction type 13- RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
1210: 0000: \***     TIME, LIST NUMBER, ITEM NUMBER, ITEM STATUS,ITEM CODE,
1211: 0000: \***     COUNT DATE, COUNT TIME, PRICE, FIELD DELIMITER, SHOP FLOOR COUNT,
1212: 0000: \***     FIELD DELIMITER, BACKROOM COUNT, RECORD DELIMITER, END OF REC MARKER
1213: 0000: \***
1214: 0000: \***  Transaction type 14- RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
1215: 0000: \***     TIME, LIST NUMBER, LIST STATUS, RECORD DELIMITER,
1216: 0000: \***     END OF RECORD MARKER
1217: 0000: \***
1218: 0000: \***  Transaction type 16- RECORD DELIMIER, TRANS TYPE, FIELD DELIMITER, DATE,
1219: 0000: \***     TIME, BC LETTER, FIELD DELIMITER, ORIGINAL RECOUNT
1220: 0000: \***     PERCENTAGE, FIELD DELIMITER, CHANGED RECOUNT PERCENTAGE,
1221: 0000: \***     RECORD DELIMITER, END OF RECORD DELIMITER
1222: 0000: \***
1223: 0000: \***  Transaction type 17- RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
1224: 0000: \***     TIME, SOURCE, SUPPLIER NUMBER, ORDER NUMBER, ORDER SUFFIX, PAGE
1225: 0000: \***     NUMBER, ITEM COUNT,
1226: 0000: \***     CARTON NUMBER, CARTON FLAG,                                        ! 1.3NWB
1227: 0000: \***     FIELD DELIMITER, ITEM CODE, BAR CODE,
1228: 0000: \***     QUANTITY - GOOD, FIELD DELIMITER, QUANTITY - DAMAGED, FIELD DELIMITER,
1229: 0000: \***     QUANTITY - STOLEN (the last 8 fields repeat ITEM COUNT times),
1230: 0000: \***     RECORD DELIMITER, END OF RECORD DELIMITER
1231: 0000: \***
1232: 0000: \***  Transaction type 18- RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
1233: 0000: \***     TIME, FOLIO IDENTIFIER, FOLIO YEAR, FOLIO MONTH, FOLIO NUMBER,
1234: 0000: \***     STORE SUFFIX, ITEM COUNT, INVOICE DAY, EXPECTED DATE OF DELIVERY,
1235: 0000: \***     DALLAS MARKER, FIELD DELIMITER, ITEM CODE, FIELD DELIMITER,
1236: 0000: \***     ORDER QUANTITY, FIELD DELIMITER, CSR MARKER,
1237: 0000: \***     (the last six fields repeat ITEM COUNT times),
1238: 0000: \***     RECORD DELIMITER, END OF RECORD DELIMITER
1239: 0000: \***
1240: 0000: \***  Transaction type 19- RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
1241: 0000: \***     TIME, SUPPLIER NUMBER, ORDER NUMBER, ORDER SUFFIX, CONFIRM/AMEND FLAG,
1242: 0000: \***     START TIME, END TIME, NO SINGLES ADDED, NO ITEMS ADDED, NO ITEMS
1243: 0000: \***     BOOKED IN, RECORD DELIMITER, END OF RECORD DELIMITER
1244: 0000: \***
1245: 0000: \***  Transaction type 21 - RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
1246: 0000: \***     TIME, DISTRIBUTION CENTRE, WAREHOUSE NUMBER, STORE NUMBER, UOD NUMBER,
1247: 0000: \***     STATUS, RECORD DELIMITER, END OF RECORD MARKER
1248: 0000: \***
1249: 0000: \***  Transaction type 23 - RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
1250: 0000: \***     TIME, DISTRIBUTION CENTRE, WAREHOUSE NUMBER, STORE NUMBER, UOD NUMBER,
1251: 0000: \***     STATUS, BOOTS/BAR CODE, BOOTS/BAR CODE FLAG, QUANTITY, FIELD DELIMITER
1252: 0000: \***     FSI,FOLIO YEAR, FOLIO MONTH, STORE SUFFIX, FOLIO NO, CSR MARKER
1253: 0000: \***     RECORD DELIMITER, END OF RECORD MARKER
1254: 0000: \***
1255: 0000: \***
1256: 0000: \***  RETURNS/AUTOMATIC CREDIT CLAIMING RECORD TYPES;
1257: 0000: \***
1258: 0000: \***  Transaction type 24 - Whole or Part consignment record
1259: 0000: \***     RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE, TIME,
1260: 0000: \***     CREDIT CLAIM NUM, BC LETTER, CLAIM TYPE, SUPPLIER NUM, INVOICE NUM,
1261: 0000: \***     FOLIO NUM, BATCH REF NUM, WHOLE/PART CONSIGNMENT, REPAIR CATEGORY,
1262: 0000: \***     REPAIR NUM, PLAN4 POLICY NUM, DDDA/DCDR NUM, DELIV NOTE NUM,
1263: 0000: \***     DELIV DATE, NUM OF CARTONS, ORDER NUM, COMMENT, NUM OF ITEMS,
1264: 0000: \***     ITEM/BAR CODE FLAG, BOOTS/BAR CODE, QTY, PRICE, RECORD DELIMITER,
1265: 0000: \***     END OF RECORD MARKER
1266: 0000: \***     (ITEM/BAR CODE FLAG to PRICE repeated NUM OF ITEMS times)
1267: 0000: \***
1268: 0000: \***  Transaction type 25 - Non-sales func 16 and Misc. txns from controller
1269: 0000: \***     RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE, TIME,
1270: 0000: \***     CREDIT CLAIM NUM, NUM OF ITEMS, AUTH CODE/CONTACT,
1271: 0000: \***     ADJUST STOCK FIGURE FLAG, REASON, ITEM/BAR CODE FLAG, BOOTS/BAR CODE,
1272: 0000: \***     QTY, PRICE, RECORD DELIMITER, END OF RECORD MARKER
1273: 0000: \***     (ITEM/BAR CODE FLAG to PRICE repeated NUM OF ITEMS times)
1274: 0000: \***
1275: 0000: \***  Transaction type 26 - Data from LDT
1276: 0000: \***     RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE, TIME, UOD NUM,
1277: 0000: \***     UOD STATUS, CREDIT CLAIM NUM, NUM OF ITEMS UPDATED, TOTAL QTY IN UOD,
1278: 0000: \***     ADJUST STOCK FIGURE FLAG, SUPPLY ROUTE, DISP LOCATION, BC LETTER,
1279: 0000: \***     RECALL NUM, AUTHORISATION, SUPPLIER, RETURN METHOD, CARRIER, BIRD NUM,
1280: 0000: \***     REASON, WAREHOUSE ROUTE, UOD TYPE, REASON FOR DAMAGE, RECEIVING STORE,
1281: 0000: \***     DESTINATION, DATE UOD OPENED, DATE UOD DESPATCHED, TIME UOD
1282: 0000: \***     DESPATCHED, RECALL TYPE$, ITEM.BAR CODE FLAG, BOOTS/BAR CODE, QTY,       ! 1.4BG
1283: 0000: \***     ITEM UPDATED FLAG, RECORD DELIMITER, END OF RECORD MARKER
1284: 0000: \***     (ITEM/BAR CODE FLAG to ITEM UPDATED FLAG repeated NUM OF ITEMS times)
1285: 0000: \***
1286: 0000: \***  Transaction type 27 - End of LDT session
1287: 0000: \***     RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE, TIME,
1288: 0000: \***     DATE SESSION ENDED, TIME SESSION ENDED, RECORD DELIMITER,
1289: 0000: \***     END OF RECORD MARKER
1290: 0000: \***
1291: 0000: \***  Transaction type 28 - Cancelled Credit Claim
1292: 0000: \***     RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE, TIME,
1293: 0000: \***     CLAIM NUMBER, UOD NUM, NEW STATUS FLAG, RECORD DELIMITER,
1294: 0000: \***     END OF RECORD MARKER
1295: 0000: \***
1296: 0000: \***  Transaction type 29 - Zero price update
1297: 0000: \***     RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE, TIME,
1298: 0000: \***     CLAIM NUMBER, ITEM NUMBER, CLAIM VALUE, RECORD DELIMITER,
1299: 0000: \***     END OF RECORD MARKER
1300: 0000: \***
1301: 0000: \***  Transaction type 30 - CSR Issues
1302: 0000: \***     RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE, TIME,
1303: 0000: \***     BOOTS CODE, FIELD DELIMITER, QUANTITY, FIELD DELIMITER
1304: 0000: \***     EXPECTED DELIVERY DATE, RECORD DELIMITER, END OF RECORD MARKER
1305: 0000: \***
1306: 0000: \***  Transaction type 31 - Quasi Count
1307: 0000: \***     RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
1308: 0000: \***     TIME, LIST NUMBER, ITEM NUMBER, ITEM STATUS,ITEM CODE,
1309: 0000: \***     COUNT DATE, COUNT TIME, PRICE, FIELD DELIMITER, SHOP FLOOR COUNT,
1310: 0000: \***     FIELD DELIMITER, BACKROOM COUNT (PREV STOCK FIG), RECORD DELIMITER,
1311: 0000: \***      END OF REC MARKER
1312: 0000: \***
1313: 0000: \***  Transaction type 32 - Quasi Adjustment count
1314: 0000: \**      RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
1315: 0000: \***     TIME, LIST NUMBER, ITEM NUMBER, ITEM STATUS,ITEM CODE,
1316: 0000: \***     COUNT DATE, COUNT TIME, PRICE, FIELD DELIMITER, SHOP FLOOR COUNT,
1317: 0000: \***     FIELD DELIMITER, BACKROOM COUNT (PREV STOCK FIG), RECORD DELIMITER,
1318: 0000: \***     END OF REC MARKER
1319: 0000: \***
1320: 0000: \***  Transaction type 33 - +UOD Receiving
1321: 0000: \**      RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
1322: 0000: \***     TIME, UOD LICENCE PLATE, DESPATCH DATE, ACTION, ITEM COUNT,
1323: 0000: \***     for audit type+(ITEM CODE, BARCODE, DESPATCHED QTY, VARIANCE )
1324: 0000: \***     END OF REC MARKER
1325: 0000: \***
1326: 0000: \******************************************************************************
1327: 0000: 
1328: 0000:   STRING GLOBAL              \
1329: 0000:     STKMQ.FILE.NAME$,        \
1330: 0000:     STKMQ.RECORD$,           \ Used to store the whole record which is unstrung
1331: 0000:                              \ into the fields below
1332: 0000:     STKMQ.RECORD.DELIMITER$, \ 1 byte ASCII set to " (CHR$(34))
1333: 0000:     STKMQ.TRANS.TYPE$,       \ 1 byte UPD. 00 = Header record
1334: 0000:                              \             01 = W'house invoice delivery record
1335: 0000:                              \             02 = Delivery without invoice record
1336: 0000:                              \             03 = Stock out record
1337: 0000:                              \             04 = Stock count record
1338: 0000:                              \             17 = Delivery without confirmation
1339: 0000:                              \                  of Direct Order detail
1340: 0000:                              \             18 = Confirmed Dallas invoice record
1341: 0000:                              \             19 = Delivery without confirmation
1342: 0000:                              \                  of Direct Order header
1343: 0000:                              \             21 = UOD record
1344: 0000:                              \             23 = Item Level UOD record
1345: 0000:                              \             24 = Whole/Part consignment (R/ACC)
1346: 0000:                              \             25 = NS16 / Misc cont txn (R/ACC)
1347: 0000:                              \             26 = Data from LDT (R/ACC)
1348: 0000:                              \             27 = End of LDT session (R/ACC)
1349: 0000:                              \             28 = Canc. Credit Claim (R/ACC)
1350: 0000:                              \             29 = Zero price update (R/ACC)
1351: 0000:     STKMQ.FIELD.DELIMITER$,  \ 1 byte ASCII set to ; (CHR$(59))
1352: 0000:     STKMQ.CREATION.DATE$,    \ 3 byte UPD set to current date
1353: 0000:     STKMQ.CREATION.TIME$,    \ 3 byte UPD set to current time
1354: 0000:     STKMQ.CSR.MARKER$,       \ 1 byte ASCII. "Y" - This is a CSR Item      BSPK
1355: 0000:                              \               " " - This is not a CSR Item  BSPK
1356: 0000:     STKMQ.DATE$,             \ 3 byte UPD set to current date
1357: 0000:     STKMQ.TIME$,             \ 3 byte UPD set to current time
1358: 0000:     STKMQ.FSI$,              \ 1 byte ASCII
1359: 0000:     STKMQ.FOLIO.YEAR$,       \ 1 byte UPD
1360: 0000:     STKMQ.FOLIO.MONTH$,      \ 1 byte UPD
1361: 0000:     STKMQ.FOLIO.NUMBER$,     \ 2 bytes UPD
1362: 0000:     STKMQ.STORE.SUFFIX$,     \ 1 byte ASCII
1363: 0000:     STKMQ.ITEM.COUNT$,       \ 1 byte UPD between 1 and 17
1364: 0000:     STKMQ.BOOTS.CODE$,       \ 4 bytes UPD
1365: 0000:     STKMQ.ON.IDF.FLAG$,      \ 1 byte ASCII. Y = On IDF   N = Not on IDF
1366: 0000:     STKMQ.QUANTITY$,         \ variable length string equivalent to
1367: 0000:                              \ STR$(STKMQ.QUANTITY%)
1368: 0000:                              \ +ve indicates add to stock
1369: 0000:                              \ -ve indicates subtract from stock
1370: 0000:     STKMQ.REASON.CODE$,      \ 2 bytes UPD
1371: 0000:     STKMQ.STORE.RET.CODE$,   \ 2 bytes UPD
1372: 0000:     STKMQ.ENDREC.MARKER$,    \ 2 bytes ASCII set to XODOA
1373: 0000:     STKMQ.REASON$,           \ 1 byte ASCII. "I" = ineligible,
1374: 0000:                              \               "U" = unsuppliable,
1375: 0000:                              \               "Z" = deleted,
1376: 0000:                              \               " " = not removed.
1377: 0000:     STKMQ.CONCEPT.SEQUENCE$, \ 3 byte UPD. Concept group / sequence
1378: 0000:     STKMQ.INVOICE.DAY$,      \ 1 byte UPD
1379: 0000:     STKMQ.LIST.NUMBER$,      \ 4 byte ASCII
1380: 0000:     STKMQ.ITEM.NUMBER$,      \ 2 byte ASCII
1381: 0000:     STKMQ.ITEM.STATUS$,      \ 1 byte ASCII
1382: 0000:     STKMQ.COUNT.DATE$,       \ 3 byte UPD - YYMMDD
1383: 0000:     STKMQ.COUNT.TIME$,       \ 2 byte UPD - HHMM
1384: 0000:     STKMQ.PRICE$,            \ 5 byte UPD
1385: 0000:     STKMQ.SHOP.COUNT$,       \ variable ASCII
1386: 0000:     STKMQ.BKRM.COUNT$,       \ variable ASCII
1387: 0000:     STKMQ.LIST.STATUS$,      \ 1 byte ASCII
1388: 0000:     STKMQ.LEFT.TO.COUNT$,    \ variable ASCII
1389: 0000:     STKMQ.COUNT.BY.DATE$,    \ 3 bytes UPD
1390: 0000:     STKMQ.PRODUCT.GROUP$,    \ 3 bytes UPD
1391: 0000:     STKMQ.BC.LETTER$,        \ 1 byte ASCII
1392: 0000:     STKMQ.ORG.RECOUNT$,      \ VARIABLE ASCII
1393: 0000:     STKMQ.NEW.RECOUNT$,      \ VARIABLE ASCII
1394: 0000:     STKMQ.LIST.TYPE$,        \ 1 byte ASCII
1395: 0000:     STKMQ.COUNT.FLAG$,       \ 1 byte ASC from corrections file
1396: 0000:     STKMQ.STMVT.DATE$,       \ 3 bytes UPD
1397: 0000:     STKMQ.SUPPLIER.NO$,      \ 4 bytes UPD
1398: 0000:     STKMQ.ORDER.NO$,         \ 2 bytes UPD
1399: 0000:     STKMQ.ORDER.SFX$,        \ 1 byte ASCII
1400: 0000:     STKMQ.PAGE.NO$,          \ 1 byte UPD
1401: 0000:     STKMQ.ORDER.DATE$,       \ 3 bytes UPD
1402: 0000:     STKMQ.EXP.DELV.DATE$,    \ 3 bytes UPD
1403: 0000:     STKMQ.DALLAS.MKR$,       \ 1 byte ASCII DALLAS system marker
1404: 0000:                              \ 'Y' - invoice is from DALLAS system,
1405: 0000:                              \ 'N' - invoice is not from DALLAS system
1406: 0000:                              \ 'Q' - invoice contains quantity alterations
1407: 0000:     STKMQ.SOURCE$,           \ 1 byte ASCII Source flag
1408: 0000:                              \ 'S' - PSS65, 'P' - PDT, PSS57
1409: 0000:                              \ Transaction type 11 'S' - Stocktake else ' '
1410: 0000:     STKMQ.FLAG$,             \ Transaction type 11 'F' - First 'L' - Last or ' '
1411: 0000:     STKMQ.BAR.CODE$,         \ 6 bytes UPD
1412: 0000:     STKMQ.CODE.FLAG$,        \ 1 BYTE ASCII
1413: 0000:     STKMQ.QTY.GOOD$,         \ VARIABLE ASCII
1414: 0000:                              \ Quantity of singles booked in in good condition
1415: 0000:     STKMQ.QTY.BAD$,          \ VARIABLE ASCII
1416: 0000:                              \ Quantity of singles booked in in bad condition
1417: 0000:     STKMQ.QTY.STOLEN$,       \ VARIABLE ASCII
1418: 0000:                              \ Quantity of singles recognised as stolen
1419: 0000:     STKMQ.CONF.AMND.FLAG$,   \ 1 byte ASCII - Confirm/ Amend Flag
1420: 0000:                              \ 'C' - Order has been confirmed
1421: 0000:                              \ 'A' - Order has been amended
1422: 0000:                              \ ' ' - Nothing has been done to the order
1423: 0000:     STKMQ.START.TIME$,       \ 2 byte UPD (HHMM) time order started to be
1424: 0000:                              \ processed
1425: 0000:     STKMQ.END.TIME$,         \ 2 byte UPD (HHMM) time order was completed
1426: 0000:     STKMQ.SNGLS.ADDED$,      \ 2 byte UPD  Singles added to order
1427: 0000:     STKMQ.ITEMS.ADDED$,      \ 2 byte UPD  Items added to order
1428: 0000:     STKMQ.ITEMS.BOOKED$,     \ 2 byte UPD  Items booked in on the order
1429: 0000:     STKMQ.DIST.CENTRE$,      \ 1 byte UPD
1430: 0000:     STKMQ.WHSE.NUMBER$,      \ 1 byte UPD
1431: 0000:     STKMQ.STORE.NUMBER$,     \ 2 byte UPD
1432: 0000:     STKMQ.UOD.NUMBER$,       \ 3 byte UPD
1433: 0000:     STKMQ.STATUS$,           \ 1 byte ASCII
1434: 0000:                              \
1435: 0000:     STKMQ.CREDIT.CLAIM.NUM$, \ 4 byte UPD
1436: 0000:     STKMQ.CLAIM.TYPE$,       \ 1 byte ASC;  "M" = Missing,
1437: 0000:                              \              "E" = Excess,
1438: 0000:                              \              "R" = Repairs
1439: 0000:     STKMQ.SUPPLIER.NUM$,     \ 3 byte UPD
1440: 0000:     STKMQ.INVOICE.NUM$,      \*9 byte ASC
1441: 0000:     STKMQ.FOLIO.NUM$,        \ 3 byte UPD
1442: 0000:     STKMQ.BATCH.REF$,        \ 3 byte UPD
1443: 0000:     STKMQ.WHOLE.PART.CON$,   \ 1 byte ASC   "W" = Whole, "P" = Part
1444: 0000:     STKMQ.REPAIR.CATEGORY$,  \ 1 byte UPD;   1 = Plan4,
1445: 0000:                              \               2 = Estimate,
1446: 0000:                              \               3 = Boots guarantee,
1447: 0000:                              \               4 = Supplier guarantee,
1448: 0000:                              \               5 = Other guarantee,
1449: 0000:     STKMQ.REPAIR.NUM$,       \ 6 byte UPD
1450: 0000:     STKMQ.PLAN4.POLICY.NUM$, \ 6 byte UPD; (Only if repair cat is Plan4)
1451: 0000:     STKMQ.DDDA.DCDR.NUM$,    \ 4 byte UPD
1452: 0000:     STKMQ.DELIV.NOTE.NUM$,   \*9 byte ASC
1453: 0000:     STKMQ.NUM.CARTONS.RECEIV$,\1 byte UPD
1454: 0000:     STKMQ.ORDER.NUM$,        \*7 byte ASC
1455: 0000:     STKMQ.COMMENT$,          \*20 byte ASC
1456: 0000:     STKMQ.ITEM.BARCODE.FLAG$,\ 1 byte ASC;  "I" = Boots item code,
1457: 0000:                              \               "B" = Barcode.
1458: 0000:     STKMQ.ITEM.BARCODE$,     \ 7 byte UPD
1459: 0000:     STKMQ.ITEM.PRICE$,       \ 3 byte UPD;  Spaces.
1460: 0000:     STKMQ.AUTHORISATION$,    \ 15 byte ASC
1461: 0000:     STKMQ.ADJ.STOCK.FIGURE$, \ 1 byte ASC;  "Y" or "N"
1462: 0000:     STKMQ.RETURN.REASON$,    \ 1 byte UPD;  (See CCRSN file)
1463: 0000:     STKMQ.UOD.NUM$,          \ 7 byte UPD
1464: 0000:     STKMQ.UOD.STATUS$,       \ 1 byte ASC;  "O" = Open,
1465: 0000:                              \              "C" = Closed,
1466: 0000:                              \              "D" = Despatched
1467: 0000:     STKMQ.SUPPLY.ROUTE$,     \ 1 byte ASC
1468: 0000:     STKMQ.DISP.LOCATION$,    \ 1 byte ASC   "M" = MDS,
1469: 0000:                              \              "D" = Dispensary
1470: 0000:     STKMQ.RECALL.NUM$,       \ 8 byte ASC
1471: 0000:     STKMQ.SUPPLIER$,         \ 15 byte ASC
1472: 0000:     STKMQ.RETURN.METHOD$,    \ 1 byte UPD;   1 = Carrier,
1473: 0000:                              \               2 = BIRD,
1474: 0000:                              \               3 = Via D6,
1475: 0000:                              \               4 = Representative
1476: 0000:     STKMQ.CARRIER$,          \ 1 byte UPD;   1 = GPO,
1477: 0000:                              \               2 = Parcelforce,
1478: 0000:                              \               3 = Securicor,
1479: 0000:                              \               4 = Other
1480: 0000:     STKMQ.BIRD.NUM$,         \ 8 byte ASC
1481: 0000:     STKMQ.WAREHOUSE.ROUTE$,  \ 1 byte ASC   "R" = RDC,
1482: 0000:                              \              "C" = CSR
1483: 0000:     STKMQ.UOD.TYPE$,         \ 1 byte UPD;   1 = Travel Outer,
1484: 0000:                              \               2 = Town Tray,
1485: 0000:                              \               3 = Roll cage,
1486: 0000:                              \               4 = Other
1487: 0000:     STKMQ.DAMAGE.REASON$,    \ 1 byte UPD    1 = Bad packaging,
1488: 0000:                              \               2 = Poor handling
1489: 0000:     STKMQ.RECEIVING.STORE$,  \ 2 byte UPD
1490: 0000:     STKMQ.DESTINATION$,      \ 1 byte UPD    1 = Business Centre,
1491: 0000:                              \               2 = MTS,
1492: 0000:                              \               3 = Other
1493: 0000:     STKMQ.DATE.UOD.OPENED$,  \ 3 byte UPD
1494: 0000:     STKMQ.DATE.DESPATCHED$,  \ 3 byte UPD
1495: 0000:     STKMQ.TIME.DESPATCHED$,  \ 3 byte UPD
1496: 0000:     STKMQ.ITEM.UPDATED$,     \ 1 byte ASC
1497: 0000:     STKMQ.DATE.SESS.END$,    \ 3 byte UPD
1498: 0000:     STKMQ.TIME.SESS.END$,    \ 3 byte UPD
1499: 0000:     STKMQ.NEW.STATUS.FLAG$,  \ 1 byte ASC   "C" = Closed,
1500: 0000:                              \              "D" = Despatched,
1501: 0000:                              \              "X" = Cancelled
1502: 0000:     STKMQ.ITEM.NUM$,         \ 2 byte UPD   (CCITF key value)
1503: 0000:     STKMQ.CLAIM.VALUE$,      \ 3 byte UPD
1504: 0000:     STKMQ.CARTON.FLAG$,      \ 1 byte  ASCII - ' ' Old Process,             ! 1.3NWB
1505: 0000:                              \                 'N' Normal Book In           ! 1.3NWB
1506: 0000:                              \                 'A' Carton Audit Process     ! 1.3NWB
1507: 0000:                              \                 'E' Exception Process (nof)  ! 1.3NWB
1508: 0000:     STKMQ.CARTON.NO$,        \ 4 bytes UPD (0-9999)                         ! 1.3NWB
1509: 0000:     STKMQ.RECALL.TYPE$       ! 1 byte ASC   "B" = Batch Recall              ! 1.4BG
1510: 0000:                              !              "N" = Non-batch Recall          ! 1.4BG
1511: 0000:                              !              " " = Old Credit Claim          ! 1.4BG
1512: 0000: 
1513: 0000: !***********************************************************!* DC 1.6
1514: 0000: !* Added for +UOD Development                               !* DC 1.6
1515: 0000: !***********************************************************!* DC 1.6
1516: 0000:   STRING GLOBAL \                                           !* DC 1.6 
1517: 0000:     STKMQ.LICENCE.PLATE$, \                                 !* DC 1.6 
1518: 0000:     STKMQ.DESPATCH.DATE$, \                                 !* DC 1.6 
1519: 0000:     STKMQ.ACTION$, \                                        !* DC 1.6 
1520: 0000:     STKMQ.DELIVERY.DATE$, \                                 !* DC 1.6 
1521: 0000:     STKMQ.DELIVERY.TIME$, \                                 !* DC 1.6 
1522: 0000:     STKMQ.DRIVER.ID$, \                                     !* DC 1.6 
1523: 0000:     STKMQ.BOOKIN.DATE$, \                                   !* DC 1.8
1524: 0000:     STKMQ.BOOKIN.TIME$, \                                   !* DC 1.8 
1525: 0000:     STKMQ.OP.ID$, \                                         !* DC 1.6 
1526: 0000:     STKMQ.BOOKIN.METHOD$, \                                 !* DC 1.6 
1527: 0000:     STKMQ.BOOKIN.LEVEL$, \                                  !* DC 1.6 
1528: 0000:     STKMQ.GIT$, \                                           !* DC 1.6 
1529: 0000:     STKMQ.RESCAN$, \                                        !* DC 1.7
1530: 0000:     STKMQ.FILLER$                                           !* DC 1.6 
1531: 0000: 
1532: 0000:   INTEGER*2 GLOBAL           \                              !* DC 1.6 
1533: 0000:     STKMQ.SESS.NUM%,         \                              !* DC 1.6 
1534: 0000:     STKMQ.REPORT.NUM%                                       !* DC 1.6 
1535: 0000: !***********************************************************!* DC 1.6
1536: 0000: 
1537: 0000:     STRING GLOBAL                                                       \   !FMW
1538: 0000:         STKMQ.UOD.QTY$,         \                                       \   !FMW
1539: 0000:         STKMQ.CODE$(1),         \ Item Code                             \   !FMW
1540: 0000:         STKMQ.TYPE$(1),         \ Code type I = Item code               \   !FMW
1541: 0000:                                 \           B = Barcode                 \   !FMW
1542: 0000:         STKMQ.CSR.FLAG$(1),     \ CSR Flag                              \   !FMW
1543: 0000:         STKMQ.EAN.CODE$(1),     \ Barcode                               \   !FMW
1544: 0000:         STKMQ.QTY$(1),          \ Quantity                              \   !FMW
1545: 0000:         STKMQ.GOOD.QUAN$(1),    \ Good Quantity                         \   !FMW
1546: 0000:         STKMQ.DAM.QUAN$(1),     \ Damaged Quantity                      \   !FMW
1547: 0000:         STKMQ.STOL.QUAN$(1),    \ Stolen Quantity                       \   !FMW
1548: 0000:         STKMQ.PRICE.ARRAY$(1)   ! Retail Price                              !FMW
1549: 0000:                                                                             !FMW
1550: 0000:     INTEGER*2 GLOBAL                                                    \   !FMW
1551: 0000:         STKMQ.ITEM%             ! Count of items in a transaction           !FMW
1552: 0000: 
1553: 0000:  %INCLUDE BCSMFDEC.J86                    ! FLC
1554: 0000: REM \
1555: 0000: \******************************************************************************
1556: 0000: \******************************************************************************
1557: 0000: \***
1558: 0000: \***   %INCLUDE FOR BUSINESS CENTRE SUPPLY METHOD FILE REFERENCE PARAMETERS
1559: 0000: \***                                              FIELD DECLARATIONS
1560: 0000: \***
1561: 0000: \***               REFERENCE    : BCSMFDEC.J86
1562: 0000: \***
1563: 0000: \***  Version A - L Cook
1564: 0000: \***  Copied from bcsmfnue.j86 and bcsmffle.j86
1565: 0000: \***
1566: 0000: \***  Version B - Les Cook
1567: 0000: \***  to include integer missed from bcsmfflf.j86 in error
1568: 0000: \***
1569: 0000: \******************************************************************************
1570: 0000: \*******************************************************************************
1571: 0000: 
1572: 0000:   STRING GLOBAL           \
1573: 0000:     BCSMF.FILE.NAME$,              \ 
1574: 0000:     BCSMF.FSI$,                    \ 1 byte ASCII folio series identifier (key)
1575: 0000:     BCSMF.NAME$,                   \ 14 bytes ASCII business centre name
1576: 0000:     BCSMF.PSEUDO.BUSINESS.CENTRE$, \ 1 byte flag "Y" = pseudo bc
1577: 0000:     BCSMF.FILLER$                  ! 3 bytes spaces
1578: 0000: 
1579: 0000:   INTEGER*1 GLOBAL          \
1580: 0000:     BCSMF.RECNT.LIMIT%,     \ percentage of recounts that may be generated
1581: 0000:     BCSMF.MIN.RECNT.LIMIT%, \ minimum limit
1582: 0000:     BCSMF.MAX.RECNT.LIMIT%, \ maximum limit
1583: 0000:     BCSMF.DISCRPNCY.CNT%,   \ used to calculate   
1584: 0000:     BCSMF.DISCRPNCY.PERCNT%,\ if recount
1585: 0000:     BCSMF.STK.CNT.LIMIT%,   \ is necessary
1586: 0000:     BCSMF.SEQUENCE.NO%,     \ used for displaying
1587: 0000:     BCSMF.NO.REPEAT.TICKETS% ! Number of repeat FALCONCRAFT tickets	! CLC
1588: 0000: 
1589: 0000:   INTEGER*2 GLOBAL        \
1590: 0000:     BCSMF.DISCRPNCY.VAL%,   \ (in pounds) used for determining recounts
1591: 0000:     BCSMF.MIN.LIST.NO%,     \ allowable range of 
1592: 0000:     BCSMF.MAX.LIST.NO%,     \ spare list numbers
1593: 0000:     BCSMF.RECL%,          \
1594: 0000:     BCSMF.SESS.NUM%,      \
1595: 0000:     BCSMF.REPORT.NUM%
1596: 0000:  %INCLUDE IEFDEC.J86                      ! DLC
1597: 0000: REM \
1598: 0000: \******************************************************************************
1599: 0000: \******************************************************************************
1600: 0000: \***
1601: 0000: \***         %INCLUDE FOR ITEM EAN CODES FILE - FIELD DECLARATIONS
1602: 0000: \***                                            FILE REFERENCE PARAMETERS
1603: 0000: \***
1604: 0000: \***               FILE TYPE    : Keyed
1605: 0000: \***
1606: 0000: \***               REFERENCE    : IEFDEC.J86
1607: 0000: \***
1608: 0000: \***    VERSION B.              ROBERT COWEY.                       21 OCT 1993.
1609: 0000: \***    No changes to this file.
1610: 0000: \***
1611: 0000: \*******************************************************************************
1612: 0000: \*******************************************************************************
1613: 0000: 
1614: 0000:   STRING GLOBAL                      \
1615: 0000:     IEF.FILE.NAME$,		     \
1616: 0000:     IEF.BOOTS.CODE.BAR.CODE$,        \ 9 byte UPD -                        BBAAS
1617: 0000:                                      \ 3 bytes UPD boots code              BBAAS   
1618: 0000:                                      \ + 6 UPD bar code,                   BBAAS
1619: 0000:                                      \ no check digits. (key)              BBAAS
1620: 0000:     IEF.NEXT.BAR.CODE$               ! 6 byte UPD without check digit
1621: 0000: 
1622: 0000:   INTEGER*2 GLOBAL        \
1623: 0000:     IEF.REPORT.NUM%,	  \
1624: 0000:     IEF.SESS.NUM%,	  \ 
1625: 0000:     IEF.RECL%
1626: 0000:  %INCLUDE DIRORDEC.J86                    ! DLC
1627: 0000: REM \
1628: 0000: \******************************************************************************
1629: 0000: \******************************************************************************
1630: 0000: \***
1631: 0000: \***     %INCLUDE FOR STORE DIRECT ORDERS FILE  - FIELD DECLARATIONS
1632: 0000: \***                                              FILE REFERENCE PARAMETERS
1633: 0000: \***
1634: 0000: \***               FILE TYPE    : Keyed
1635: 0000: \***
1636: 0000: \***               REFERENCE    : DIRORDEC.J86
1637: 0000: \***
1638: 0000: \***               DATE OF LAST AMENDMENT - 14/08/1992
1639: 0000: \***
1640: 0000: \***               VERSION A    : Les Cook    14th August 1992
1641: 0000: \***
1642: 0000: \***  VERSION B                 Neil Bennett                21st December 2006
1643: 0000: \***  New variable added to hold superceded flag for ASN Carton Support.
1644: 0000: \***
1645: 0000: \******************************************************************************
1646: 0000: \******************************************************************************
1647: 0000: 
1648: 0000:   STRING GLOBAL               \
1649: 0000:       DIRORD.FILE.NAME$,      \
1650: 0000:     DIRORD.RECKEY$,           \ 9 byte key which comprises the following fields
1651: 0000:     DIRORD.SUPPLIER$,         \ 3 bytes UPD (key)
1652: 0000:     DIRORD.ORDER.NO$,         \ 2 bytes UPD (key)
1653: 0000:     DIRORD.ORDER.SUF$,        \ 1 byte ASCII (key)
1654: 0000:     DIRORD.BUS.CENTRE$,       \ 1 byte ASCII (key)
1655: 0000:     DIRORD.SOURCE$,           \ 1 byte ASCII (key), 'D' if from PSS57
1656: 0000:                               \                     ' ' for head office order
1657: 0000:     DIRORD.PAGE.NO$,          \ 1 byte UPD (key)
1658: 0000:                               \
1659: 0000:     DIRORD.CONF.END.TIME$,    \ 2 bytes UPD - Ending time of last update
1660: 0000:     DIRORD.CONF.STRT.TIME$,   \ 2 bytes UPD - Starting time of last update
1661: 0000:     DIRORD.CONFIRM.DATE$,     \ 3 bytes UPD. YYMMDD - set to low values if
1662: 0000:                               \                       confirm flag is blank
1663: 0000:     DIRORD.CONFIRM.FLAG$,     \ 1 byte ASCII. C=Complete, A=Amended,
1664: 0000:                               \               blank = not confirmed
1665: 0000:     DIRORD.DRRF.LAST.DATE$,   \ 3 bytes UPD Date of last run
1666: 0000:     DIRORD.DRRF.LAST.TIME$,   \ 2 bytes UPD Time of last run
1667: 0000:     DIRORD.EXP.DELV.DATE$,    \ 3 bytes UPD. YYMMDD - Expected date of order's
1668: 0000:                               \                       delivery
1669: 0000:     DIRORD.FILLER1$,          \ 494 bytes ASCII set to spaces
1670: 0000:     DIRORD.FILLER2$,          \ 474 bytes ASCII set to spaces
1671: 0000:     DIRORD.FILLER3$,          \ 15 bytes ASCII set to spaces
1672: 0000:     DIRORD.ITEM.COUNT$,       \ 1 byte UPD  - Number of items on record
1673: 0000:     DIRORD.ITEM.DETAILS$(2),  \ 256 bytes containing the repeated item string
1674: 0000:                               \ details. The first dimension has 16 elements
1675: 0000:                               \ corresponding to lines on the invoice.  The
1676: 0000:                               \ second dimension has 4 elements:-
1677: 0000:                               \   1. Boots Code - 4 bytes UPD (0 if bar code
1678: 0000:                               \                                has no matching
1679: 0000:                               \                                Boots code on
1680: 0000:                               \                                file)
1681: 0000:                               \   2. Bar Code   - 6 bytes UPD
1682: 0000:                               \   2. Price      - 4 bytes UPD
1683: 0000:                               \   3. Filler     - 2 bytes ASCII spaces
1684: 0000:                               \ Any unused entries are set to spaces
1685: 0000:     DIRORD.NO.ITEMS.BOOKED$,  \ 2 bytes UPD - Total number of items booked in
1686: 0000:     DIRORD.NO.ITEMS.LST.BKD$, \ 2 bytes UPD - Number of items booked in during
1687: 0000:                               \               last date of update
1688: 0000:     DIRORD.NO.ORDER.ITEM$,    \ 2 bytes UPD - Total number of items in order
1689: 0000:     DIRORD.NO.ORDER.SNGL$,    \ 2 bytes UPD - Total single quantity in order
1690: 0000:     DIRORD.ON.SALE.DATE$,     \ 3 bytes UPD. YYMMDD - Date stock should be on
1691: 0000:                               \                       sale
1692: 0000:     DIRORD.ORDER.DATE$,       \ 3 bytes UPD. YYMMDD Date of order
1693: 0000:     DIRORD.SUPERCEDED$        ! 1 byte ASCII (Y/N) default to N             !BNWB
1694: 0000: 
1695: 0000:     INTEGER*2 GLOBAL       \
1696: 0000:       DIRORD.ITEM.QTY%(2), \ contains the repeated item integer details. The
1697: 0000:                            \ first dimension has 16 elements corresponding to
1698: 0000:                            \ lines on the invoice.  The second dimension has 7
1699: 0000:                            \ elements:-
1700: 0000:                            \   1. Quantity expected from order
1701: 0000:                            \   2. Quantity booked in in good condition
1702: 0000:                            \   3. Quantity booked in in damaged condition
1703: 0000:                            \   4. Quantity booked in as stolen
1704: 0000:                            \   5. Quantity last booked in in good condition
1705: 0000:                            \   6. Quantity last booked in in damaged condition
1706: 0000:                            \   7. Quantity last booked in as stolen
1707: 0000:                            \   Fields 2 to 4 are running totals, fields 5 to 7
1708: 0000:                            \   are the values associated with the confirm/amend
1709: 0000:                            \   date.
1710: 0000:       DIRORD.RECL%,        \
1711: 0000:       DIRORD.SESS.NUM%,    \
1712: 0000:       DIRORD.REPORT.NUM%
1713: 0000: 
1714: 0000:     INTEGER*4 GLOBAL       \
1715: 0000:       DIRORD.NO.RECS%
1716: 0000:  %INCLUDE DIRSUDEC.J86                    ! DLC
1717: 0000: REM \
1718: 0000: \******************************************************************************
1719: 0000: \******************************************************************************
1720: 0000: \***
1721: 0000: \***     %INCLUDE FOR STORE DIRECT SUPPLIER FILE FIELD DECLARATIONS
1722: 0000: \***                                             FILE REFERENCE PARAMETERS
1723: 0000: \***      
1724: 0000: \***               FILE TYPE    : Keyed
1725: 0000: \***
1726: 0000: \***               REFERENCE    : DIRSUDEC.J86
1727: 0000: \***
1728: 0000: \***     Version A - L Cook
1729: 0000: \***
1730: 0000: \***     Combined DIRSUFLA.J86 and DIRSUNUA.J86
1731: 0000: \***
1732: 0000: \***   Version B           Mark Goode          3rd December 2008
1733: 0000: \***   Add new fields for the +ve UOD project
1734: 0000: \***
1735: 0000: \******************************************************************************
1736: 0000: \******************************************************************************
1737: 0000: 
1738: 0000:   STRING GLOBAL            \
1739: 0000:     DIRSUP.FILE.NAME$,     \
1740: 0000:     DIRSUP.RECKEY$,        \ 4 byte key which comprises the following fields
1741: 0000:       DIRSUP.BUS.CENTRE$,  \ 1 byte ASCII (key)
1742: 0000:       DIRSUP.SUPPLIER.NO$, \ 3 bytes UPD (key)
1743: 0000:                            \
1744: 0000:     DIRSUP.SUPPLIER.NAME$, \ 10 byte ASCII
1745: 0000:     DIRSUP.LEAD.TIME.MON$, \ 2 bytes UPD. Lead time for MONDAY in days
1746: 0000:     DIRSUP.LEAD.TIME.TUE$, \ 2 bytes UPD. Lead time for TUESDAY in days
1747: 0000:     DIRSUP.LEAD.TIME.WED$, \ 2 bytes UPD. Lead time for WEDNESDAY in days
1748: 0000:     DIRSUP.LEAD.TIME.THU$, \ 2 bytes UPD. Lead time for THURSDAY in days
1749: 0000:     DIRSUP.LEAD.TIME.FRI$, \ 2 bytes UPD. Lead time for FRIDAY in days
1750: 0000:     DIRSUP.LAPSING.DAYS$,  \ 2 bytes UPD. Number of days before order lapses
1751: 0000:     DIRSUP.PART.ORDER.RULES$, \ 1 byte ASCII. A=Rest of order supplied, 
1752: 0000:                               \               N,Z=not supplied 
1753: 0000:     DIRSUP.MAX.CHECK.QTY$,    \ 2 bytes UPD.
1754: 0000:     DIRSUP.CHECK.QTY$,        \ 2 bytes UPD.
1755: 0000:     DIRSUP.DISCREPANCY.QTY$,  \ 2 bytes UPD.
1756: 0000:     DIRSUP.DISCREPANCY.PERC$, \ 2 bytes UPD. Discrepancy percentage
1757: 0000:     DIRSUP.ASN.FLAG$,         \ 1 byte ASCII. Identifies supplier as ASN or Directs   ! BMG
1758: 0000:     DIRSUP.STATIC.SUPPLIER$,  \ 1 byte ASCII. Identifies supplier as being static     ! BMG
1759: 0000:     DIRSUP.FILLER$          ! 3 bytes ASCII set to low values                         ! BMG
1760: 0000: 
1761: 0000:   INTEGER*2 GLOBAL        \
1762: 0000:     DIRSUP.RECL%,         \
1763: 0000:     DIRSUP.SESS.NUM%,     \
1764: 0000:     DIRSUP.REPORT.NUM%
1765: 0000:     
1766: 0000:   INTEGER*4 GLOBAL        \
1767: 0000:     DIRSUP.NO.RECS%  
1768: 0000:  %INCLUDE DIRWFDEC.J86                    ! DLC
1769: 0000: \******************************************************************************
1770: 0000: \******************************************************************************
1771: 0000: \***
1772: 0000: \***      %INCLUDE FOR DIRWF - DIRECT WORK FILE - FIELD DEFINITIONS
1773: 0000: \***                                              FILE REFERENCE PARAMETERS
1774: 0000: \***
1775: 0000: \***
1776: 0000: \***       REFERENCE: DIRWFDEC.J86
1777: 0000: \***
1778: 0000: \******************************************************************************
1779: 0000: \*******************************************************************************
1780: 0000: 
1781: 0000:   STRING GLOBAL								\
1782: 0000: 	DIRWF.FILE.NAME$,						\
1783: 0000: 	DIRWF.RECORD$
1784: 0000: 
1785: 0000:   INTEGER*2 GLOBAL							\
1786: 0000: 	DIRWF.RECL%,	          					\
1787: 0000: 	DIRWF.SESS.NUM%,						\
1788: 0000: 	DIRWF.REPORT.NUM%
1789: 0000:  %INCLUDE DIRECDEC.J86                    ! DLC
1790: 0000: \******************************************************************************
1791: 0000: \******************************************************************************
1792: 0000: \***
1793: 0000: \***         %INCLUDE FOR DIREC DUMMY FILE I/O SESSION NUMBER
1794: 0000: \***
1795: 0000: \***               REFERENCE    : DIRECDEC.J86
1796: 0000: \***
1797: 0000: \******************************************************************************
1798: 0000: \*******************************************************************************
1799: 0000: 
1800: 0000:   STRING GLOBAL           \
1801: 0000:     DIREC.FILE.NAME$
1802: 0000: 
1803: 0000:   INTEGER*2 GLOBAL        \
1804: 0000:     DIREC.REPORT.NUM%,      \
1805: 0000:     DIREC.SESS.NUM%
1806: 0000:  %INCLUDE LDTCFDEC.J86                    ! DLC
1807: 0000: \******************************************************************************
1808: 0000: \******************************************************************************
1809: 0000: \***
1810: 0000: \***      %INCLUDE FOR LDTCF - LDT CHECK FILE - FILE REFERENCE PARAMETERS
1811: 0000: \***                                            FIELD DEFINITIONS
1812: 0000: \***
1813: 0000: \***       REFERENCE: LDTCFDEC.J86
1814: 0000: \***
1815: 0000: \***
1816: 0000: \******************************************************************************
1817: 0000: \*******************************************************************************
1818: 0000: 
1819: 0000:    STRING GLOBAL							\
1820: 0000: 	LDTCF.FILE.NAME$,						\
1821: 0000: 	LDTCF.VERSION.NO$,                                              \
1822: 0000: 	LDTCF.VERSION.DATE$
1823: 0000: 	
1824: 0000:    INTEGER*2 GLOBAL							\
1825: 0000:         LDTCF.SESS.NUM%,						\
1826: 0000: 	LDTCF.REPORT.NUM%
1827: 0000:  %INCLUDE DRSMQDEC.J86                    ! DLC
1828: 0000: \******************************************************************************
1829: 0000: \******************************************************************************
1830: 0000: \***
1831: 0000: \***      %INCLUDE FOR DIRECTS TEMPORARY STOCK MOVEMENT QUEUE
1832: 0000: \***       FILE FIELD DECLARATIONS
1833: 0000: \***       FILE REFERENCE PARAMETERS
1834: 0000: \***
1835: 0000: \***               FILE TYPE    : Sequential
1836: 0000: \***
1837: 0000: \***               REFERENCE    : DRSMQDEC.J86
1838: 0000: \***
1839: 0000: \***
1840: 0000: \******************************************************************************
1841: 0000: \*******************************************************************************
1842: 0000: \***
1843: 0000: \***  The length of the records on this file vary depending on the record
1844: 0000: \***  transaction type, but they all comprise combinations of the fields
1845: 0000: \***  defined below.
1846: 0000: \***
1847: 0000: \***  Transaction type 17- RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
1848: 0000: \***     TIME, SOURCE, SUPPLIER NUMBER, ORDER NUMBER, ORDER SUFFIX, PAGE
1849: 0000: \***     NUMBER, ITEM COUNT, FIELD DELIMITER, ITEM CODE, BAR CODE,
1850: 0000: \***     QUANTITY - GOOD, FIELD DELIMITER, QUANTITY - DAMAGED, FIELD DELIMITER,
1851: 0000: \***     QUANTITY - STOLEN (the last 8 fields repeat ITEM COUNT times),
1852: 0000: \***     RECORD DELIMITER, END OF RECORD DELIMITER
1853: 0000: \***
1854: 0000: \***  Transaction type 19- RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
1855: 0000: \***     TIME, SUPPLIER NUMBER, ORDER NUMBER, ORDER SUFFIX, CONFIRM/AMEND FLAG,
1856: 0000: \***     START TIME, END TIME, NO SINGLES ADDED, NO ITEMS ADDED, NO ITEMS
1857: 0000: \***     BOOKED IN, RECORD DELIMITER, END OF RECORD DELIMITER
1858: 0000: \***
1859: 0000: \*******************************************************************************
1860: 0000: \***
1861: 0000: \***   REVISION 1.0     Neil Bennett                 2nd January 2007
1862: 0000: \***   Add ASN processing support.
1863: 0000: \***
1864: 0000: \*******************************************************************************
1865: 0000: 
1866: 0000:   STRING GLOBAL              \
1867: 0000:     DRSMQ.FILE.NAME$,        \
1868: 0000:     DRSMQ.RECORD$,           \ Used to store the whole record which is unstrung
1869: 0000:                              \ into the fields below
1870: 0000:     DRSMQ.RECORD.DELIMITER$, \ 1 byte ASCII set to " (CHR$(34))
1871: 0000:     DRSMQ.TRANS.TYPE$,       \ 1 byte UPD.
1872: 0000:                              \             17 = Delivery without confirmation
1873: 0000:                              \                  of Direct Order detail
1874: 0000:                              \             19 = Delivery without confirmation
1875: 0000:                              \                  of Direct Order header
1876: 0000:     DRSMQ.FIELD.DELIMITER$,  \ 1 byte ASCII set to ; (CHR$(59))
1877: 0000:     DRSMQ.DATE$,             \ 3 byte UPD set to current date
1878: 0000:     DRSMQ.TIME$,             \ 3 byte UPD set to current time
1879: 0000:     DRSMQ.ITEM.COUNT$,       \ 1 byte UPD between 1 and 17
1880: 0000:     DRSMQ.BOOTS.CODE$,       \ 4 bytes UPD
1881: 0000:     DRSMQ.QUANTITY$,         \ variable length string equivalent to
1882: 0000:                              \ STR$(DRSMQ.QUANTITY%)
1883: 0000:                              \ +ve indicates add to stock
1884: 0000:                              \ -ve indicates subtract from stock
1885: 0000:     DRSMQ.ENDREC.MARKER$,    \ 2 bytes ASCII set to XODOA
1886: 0000:     DRSMQ.SUPPLIER.NO$,      \ 4 bytes UPD
1887: 0000:     DRSMQ.ORDER.NO$,         \ 2 bytes UPD
1888: 0000:     DRSMQ.ORDER.SFX$,        \ 1 byte ASCII
1889: 0000:     DRSMQ.PAGE.NO$,          \ 1 byte UPD
1890: 0000:     DRSMQ.ORDER.DATE$,       \ 3 bytes UPD
1891: 0000:     DRSMQ.SOURCE$,           \ 1 byte ASCII Source flag
1892: 0000:                              \ 'S' - PSS65, 'P' - PDT, PSS57
1893: 0000:     DRSMQ.BAR.CODE$,         \ 6 bytes UPD
1894: 0000:     DRSMQ.QTY.GOOD$,         \ VARIABLE ASCII
1895: 0000:                              \ Quantity of singles booked in in good condition
1896: 0000:     DRSMQ.QTY.BAD$,          \ VARIABLE ASCII
1897: 0000:                              \ Quantity of singles booked in in bad condition
1898: 0000:     DRSMQ.QTY.STOLEN$,       \ VARIABLE ASCII
1899: 0000:                              \ Quantity of singles recognised as stolen
1900: 0000:     DRSMQ.CONF.AMND.FLAG$,   \ 1 byte ASCII - Confirm/ Amend Flag
1901: 0000:                              \ 'C' - Order has been confirmed
1902: 0000:                              \ 'A' - Order has been amended
1903: 0000:                              \ ' ' - Nothing has been done to the order
1904: 0000:     DRSMQ.START.TIME$,       \ 2 byte UPD (HHMM) time order started to be
1905: 0000:                              \ processed
1906: 0000:     DRSMQ.END.TIME$,         \ 2 byte UPD (HHMM) time order was completed
1907: 0000:     DRSMQ.SNGLS.ADDED$,      \ 5 bytes ASCII Singles added to order
1908: 0000:     DRSMQ.ITEMS.ADDED$,      \ 5 bytes ASCII Items added to order
1909: 0000:     DRSMQ.ITEMS.BOOKED$,     \ 5 bytes ASCII Items booked in on the order
1910: 0000:     DRSMQ.CARTON.FLAG$,      \ 1 byte  ASCII - ' ' Old Process,             ! 1.0NWB
1911: 0000:                              \                 'N' Normal Book In           ! 1.0NWB
1912: 0000:                              \                 'A' Carton Audit Process     ! 1.0NWB
1913: 0000:                              \                 'E' Exception Process (nof)  ! 1.0NWB
1914: 0000:     DRSMQ.CARTON.NO$         ! 4 bytes UPD (0-9999)                         ! 1.0NWB
1915: 0000: 
1916: 0000: 
1917: 0000:   INTEGER*2 GLOBAL           \
1918: 0000:     DRSMQ.SESS.NUM%,         \
1919: 0000:     DRSMQ.REPORT.NUM%
1920: 0000:  %INCLUDE LDTBFDEC.J86                    ! ELC
1921: 0000: \******************************************************************************
1922: 0000: \***
1923: 0000: \***           %INCLUDE FOR LDTBF - LDT STOCK BUFFER FILE
1924: 0000: \***
1925: 0000: \***                    - FIELD DECLARATIONS   
1926: 0000: \***                    - FILE REFERENCE PARAMETERS  
1927: 0000: \***  
1928: 0000: \***                    REFERENCE: LDTBFDEC.J86
1929: 0000: \***      
1930: 0000: \******************************************************************************
1931: 0000: \***
1932: 0000: \***     Version A:      Mike Kelsall      12th October 1992
1933: 0000: \***
1934: 0000: \***     Each order in the LDTBF is recorded in the following format:
1935: 0000: \***
1936: 0000: \***         Order Header  -  Record Identifier   2  ASC  "OH"
1937: 0000: \***                          Supplier Number     3  UPD
1938: 0000: \***                          Order Number        2  UPD
1939: 0000: \***                          Order Suffix        1  ASC   
1940: 0000: \*** 
1941: 0000: \***  (N x)  Order Record  -  Record Identifier   2  ASC  "OD"
1942: 0000: \***                          Boots/Bar code      6  UPD
1943: 0000: \***                          Damaged Quantity    2  INT
1944: 0000: \***                          Stolen Quantity     2  INT
1945: 0000: \*** 
1946: 0000: \***         Order Trailer -  Record Identifier   2  ASC  "OT"
1947: 0000: \***                          Number of items     2  INT 
1948: 0000: \***
1949: 0000: \***
1950: 0000: \***     Version B.          Stuart Highley            8th August 1997
1951: 0000: \***     Added fields: LDTBF.DATE$, LDTBF.START.TIME$, LDTBF.END.TIME$,
1952: 0000: \***                   LDTBF.LOGGED.QTY%
1953: 0000: \***
1954: 0000: \******************************************************************************
1955: 0000: 
1956: 0000: INTEGER*1 GLOBAL                 \
1957: 0000:                                  \
1958: 0000:            LDTBF.SESS.NUM% 
1959: 0000: 
1960: 0000: 
1961: 0000: INTEGER*2 GLOBAL                 \
1962: 0000:                                  \
1963: 0000:            LDTBF.RECL%,          \
1964: 0000:            LDTBF.REPORT.NUM%,    \
1965: 0000:                                  \
1966: 0000:            LDTBF.LOGGED.QTY%,    \  2 byte INT - Already logged qty    ! BSH
1967: 0000:            LDTBF.DAMAGED.QTY%,   \  2 byte INT - Damaged quantity, from LDT
1968: 0000:            LDTBF.STOLEN.QTY%,    \  2 byte INT - Stolen quantity, from LDT
1969: 0000:            LDTBF.GOOD.QTY%,      \  2 byte INT - Good quantity, from LDT
1970: 0000:            LDTBF.ORDERED.QTY%,   \  2 byte INT - Ordered quantity
1971: 0000:            LDTBF.NUM.OF.ITEMS%   !  2 byte INT - Number of items in order
1972: 0000:      
1973: 0000: 
1974: 0000: STRING GLOBAL                    \
1975: 0000:                                  \
1976: 0000:            LDTBF.FILE.NAME$,     \
1977: 0000:                                  \
1978: 0000:            LDTBF.RECORD.ID$,     \  2 byte ASC - Record Identifier
1979: 0000:            LDTBF.SUPPLIER.NUM$,  \  3 byte UPD - Supplier number, from LDT
1980: 0000:            LDTBF.ORDER.NUM$,     \  2 byte UPD - Order number, from LDT 
1981: 0000:            LDTBF.ORDER.SUFFIX$,  \  1 byte ASC - Order suffix, from LDT
1982: 0000:            LDTBF.DATE$,          \  3 byte UPD - Date booked in        ! BSH
1983: 0000:            LDTBF.START.TIME$,    \  2 byte UPD - Time started booking  ! BSH
1984: 0000:            LDTBF.END.TIME$,      \  2 byte UPD - Time ended booking    ! BSH
1985: 0000:            LDTBF.REF.CODE$       !  6 byte UPD - Boots/Bar code, from LDT
1986: 0000:  %INCLUDE IDSOFDEC.J86                    ! ELC
1987: 0000: REM \
1988: 0000: \******************************************************************************
1989: 0000: \******************************************************************************
1990: 0000: \***
1991: 0000: \***      %INCLUDE FOR CSR OUTSTANDING INITIAL STOCK QUANTITIES FILE
1992: 0000: \***                                             FIELD DECLARATIONS
1993: 0000: \***                                             FILE REFERENCE PARAMETERS
1994: 0000: \***
1995: 0000: \***               FILE TYPE    : Keyed
1996: 0000: \***
1997: 0000: \***               REFERENCE    : IDSOFFLD.J86
1998: 0000: \***
1999: 0000: \***      Version A.     Stephen Kelsey (CTG)               21st October 1992
2000: 0000: \***
2001: 0000: \******************************************************************************
2002: 0000: \*******************************************************************************
2003: 0000: 
2004: 0000:   STRING GLOBAL                  \
2005: 0000:     IDSOF.BC.LETTER$,            \ 1 byte UPD
2006: 0000:     IDSOF.EXP.DELV.DATE$,        \ 3 byte UPD YYMMDD
2007: 0000:     IDSOF.FILE.NAME$,            \
2008: 0000:     IDSOF.FILLER$,               \ 10 bytes ASC
2009: 0000:     IDSOF.ITEM.CODE$             ! 4 byte UPD
2010: 0000: 
2011: 0000:   INTEGER*2 GLOBAL               \
2012: 0000:     IDSOF.QUANTITY%,             \ Outstanding Stock Quantity
2013: 0000:     IDSOF.RECL%,                 \     
2014: 0000:     IDSOF.REPORT.NUM%,           \     
2015: 0000:     IDSOF.SESS.NUM% 
2016: 0000:     
2017: 0000:  %INCLUDE UODDEC.J86                      ! FLC
2018: 0000: \******************************************************************************
2019: 0000: \******************************************************************************
2020: 0000: \***
2021: 0000: \***         %INCLUDE FOR UOD DUMMY FILE I/O SESSION NUMBER
2022: 0000: \***
2023: 0000: \***               REFERENCE    : UODDEC.J86
2024: 0000: \***
2025: 0000: \******************************************************************************
2026: 0000: \*******************************************************************************
2027: 0000: 
2028: 0000:   STRING GLOBAL           \
2029: 0000:     UOD.FILE.NAME$
2030: 0000: 
2031: 0000:   INTEGER*2 GLOBAL        \
2032: 0000:     UOD.REPORT.NUM%,      \
2033: 0000:     UOD.SESS.NUM%
2034: 0000:  %INCLUDE UODBFDEC.J86                    ! FLC
2035: 0000: REM \
2036: 0000: \******************************************************************************
2037: 0000: \******************************************************************************
2038: 0000: \***
2039: 0000: \***      %INCLUDE FOR UOD BUFFER FILE FIELD DECLARATIONS
2040: 0000: \***                              FILE REFERENCE PARAMETERS
2041: 0000: \***
2042: 0000: \***               FILE TYPE    : Sequential
2043: 0000: \***
2044: 0000: \***               REFERENCE    : UODBFDEC.J86
2045: 0000: \***
2046: 0000: \***      Version A.     Michael Kelsall             8th February 1993
2047: 0000: \***
2048: 0000: \******************************************************************************
2049: 0000: \*******************************************************************************
2050: 0000: \***
2051: 0000: \***  The length of the records on this file vary depending on the record
2052: 0000: \***  transaction type, but they all comprise combinations of the fields
2053: 0000: \***  defined below.
2054: 0000: \***
2055: 0000: \***  Transaction type 0 (Header record) - RECORD DELIMITER, TRANS TYPE,       
2056: 0000: \***     FIELD DELIMITER, CREATION DATE, CREATION TIME, RECORD DELIMITER,
2057: 0000: \***     END OF RECORD MARKER.
2058: 0000: \***
2059: 0000: \***  Transaction type 21 - RECORD DELIMITER, TRANS TYPE, DATE, TIME, 
2060: 0000: \***     DISTRIBUTION CENTRE, WAREHOUSE NUMBER, STORE NUMBER, UOD NUMBER,
2061: 0000: \***     STATUS, RECORD DELIMITER, END OF RECORD MARKER
2062: 0000: \***
2063: 0000: \***  Transaction type 23 - RECORD DELIMITER, TRANS TYPE, DATE, TIME,
2064: 0000: \***     DISTRIBUTION CENTRE, WAREHOUSE NUMBER, STORE NUMBER, UOD NUMBER,
2065: 0000: \***     STATUS, BOOTS/BAR CODE, BOOTS/BAR CODE FLAG, QUANTITY, 
2066: 0000: \***     FIELD DELIMITER, FSI, FOLIO YEAR, FOLIO MONTH, STORE SUFFIX, 
2067: 0000: \***     FOLIO NO, RECORD DELIMITER, END OF RECORD MARKER
2068: 0000: \***
2069: 0000: \******************************************************************************
2070: 0000: 
2071: 0000:   STRING GLOBAL              \
2072: 0000:     UODBF.FILE.NAME$,	     \
2073: 0000:     UODBF.RECORD$,           \ Used to store the whole record which is unstrung
2074: 0000:                              \ into the fields below
2075: 0000:     UODBF.RECORD.DELIMITER$, \ 1 byte ASCII set to " (CHR$(34)) 
2076: 0000:     UODBF.FIELD.DELIMITER$,  \ 1 byte ASCII set to ; (CHR$(59))
2077: 0000:     UODBF.ENDREC.MARKER$,    \ 2 bytes ASCII set to 0D0Ah
2078: 0000:     UODBF.TRANS.TYPE$,       \ 1 byte UPD. 00 = Header record
2079: 0000: 			     \             21 = UOD record
2080: 0000: 			     \             23 = Item Level UOD record
2081: 0000:     UODBF.CREATION.DATE$,    \ 3 byte UPD set to current date
2082: 0000:     UODBF.CREATION.TIME$,    \ 3 byte UPD set to current time
2083: 0000:     UODBF.DATE$,             \ 3 byte UPD set to current date
2084: 0000:     UODBF.TIME$,             \ 3 byte UPD set to current time
2085: 0000:     UODBF.DIST.CENTRE$,      \ 1 byte UPD   
2086: 0000:     UODBF.WAREHOUSE.NUM$,    \ 1 byte UPD   
2087: 0000:     UODBF.STORE.NUM$,        \ 2 byte UPD
2088: 0000:     UODBF.UOD.NUMBER$,       \ 2 byte UPD
2089: 0000:     UODBF.STATUS$,           \ 1 byte ASC.  "B" = Booked in
2090: 0000:     			     \		    "M" = Missing
2091: 0000: 			     \		    "O" = Opened
2092: 0000: 			     \		    "P" = Picking checked
2093: 0000: 			     \		    "R" = Retro booked in
2094: 0000: 			     \		    "D" = Retrospective opened
2095: 0000: 			     \		    "G" = Retrospective checked
2096: 0000: 			     \		    "A" = Automatically booked in
2097: 0000:     UODBF.BOOTS.BAR.CODE$,   \ 6 byte UPD    
2098: 0000:     UODBF.BOOTS.BAR.CODE.FLAG$, \ 1 byte ASC
2099: 0000:     UODBF.FSI$,              \ 1 byte ASCII
2100: 0000:     UODBF.FOLIO.YEAR$,       \ 1 byte UPD
2101: 0000:     UODBF.FOLIO.MONTH$,      \ 1 byte UPD
2102: 0000:     UODBF.FOLIO.NUMBER$,     \ 2 bytes UPD
2103: 0000:     UODBF.STORE.SUFFIX$      ! 1 byte ASCII
2104: 0000: 
2105: 0000: 			     			     			     
2106: 0000:   INTEGER*2 GLOBAL	     \
2107: 0000:     UODBF.SESS.NUM%,         \
2108: 0000:     UODBF.REPORT.NUM%,	     \
2109: 0000:     UODBF.QUANTITY%
2110: 0000: 			     
2111: 0000:  %INCLUDE UODTFDEC.J86                    ! FLC
2112: 0000: \******************************************************************************
2113: 0000: \******************************************************************************
2114: 0000: \***
2115: 0000: \***      %INCLUDE FOR UODS TEMPORARY FILE
2116: 0000: \***       FILE FIELD DECLARATIONS
2117: 0000: \***       FILE REFERENCE PARAMETERS
2118: 0000: \***
2119: 0000: \***               FILE TYPE    : Sequential
2120: 0000: \***
2121: 0000: \***               REFERENCE    : UODTFDEC.J86
2122: 0000: \***
2123: 0000: \***
2124: 0000: \******************************************************************************
2125: 0000: \*******************************************************************************
2126: 0000: 
2127: 0000:   STRING GLOBAL              \
2128: 0000:     UODTF.FILE.NAME$,	     \
2129: 0000:     UODTF.RECORD$            ! Used to store the whole record 
2130: 0000: 			     			     			     
2131: 0000:   INTEGER*2 GLOBAL	     \
2132: 0000:     UODTF.SESS.NUM%,	     \
2133: 0000:     UODTF.REPORT.NUM%			     
2134: 0000: 			     
2135: 0000:  %INCLUDE PILSTDEC.J86                    ! FLC
2136: 0000: 
2137: 0000: \******************************************************************************
2138: 0000: \***
2139: 0000: \***      %INCLUDE FOR PILST - LIST OF LISTS FILE - FIELD DECLARATIONS
2140: 0000: \***                                                FILE REFERENCE PARAMETERS
2141: 0000: \***
2142: 0000: \***                           8th October 1992
2143: 0000: \***
2144: 0000: \******************************************************************************
2145: 0000: 
2146: 0000:    INTEGER*1 GLOBAL             	\
2147: 0000:         PILST.REPORT.NUM%,		\
2148: 0000: 	PILST.SESS.NUM%,		\
2149: 0000: 	PILST.ITEMS.IN.LIST%,		\ No of items in list
2150: 0000: 	PILST.TO.BE.COUNTED%		! No of items left to be counted
2151: 0000: 
2152: 0000:    INTEGER*2 GLOBAL			\
2153: 0000:         PILST.RECL%
2154: 0000: 
2155: 0000:    STRING GLOBAL			\
2156: 0000: 	PILST.FILE.NAME$,		\
2157: 0000: 	PILST.LIST.NUMBER$,		\ 4 byte - list number
2158: 0000: 	PILST.SPARE.LIST.NUMBER$,	\ 4 byte - spare list number
2159: 0000: 	PILST.LIST.NAME$,		\12 byte - list name
2160: 0000: 	PILST.BC.LETTER$,		\ 1 byte - business centre letter
2161: 0000: 	PILST.LIST.TYPE$,		\ 1 byte - list type :
2162: 0000: 					\    "R" = regular,
2163: 0000: 					\    "C" = CSR,
2164: 0000: 					\    "E" = exceptions.
2165: 0000: 	PILST.COUNT.BY.DATE$,		\ 3 byte UPD - count by date
2166: 0000: 	PILST.PRODUCT.GROUP$,		\ 3 byte UPD - product group
2167: 0000: 	PILST.COUNT.DATE$,		\ 3 byte UPD - scheduled count date
2168: 0000: 	PILST.LIST.STATUS$,		\ 1 byte - list status :
2169: 0000: 					\    "C" = to be counted,
2170: 0000: 					\    "R" = to be re-counted,
2171: 0000: 					\    "X" = cancelled,
2172: 0000: 					\    "F" = completed.
2173: 0000: 	PILST.RECOUNT.DATE$,		\ 3 byte UPD - scheduled re-count date
2174: 0000: 	PILST.RECOUNT.ALLOWED$,		\ 1 byte UPD - re-count allowed flag
2175: 0000: 	PILST.CPM.RUN.DATE$,		\ 3 byte UPD - cpm. run date
2176: 0000: 	PILST.PIPLN.RUN.OK$,	        \ 1 byte - PIPLN run ok flag "Y" / "N"
2177: 0000: 	PILST.HIGHEST.LIST.NO$,	        \ 4 byte - highest transmitted list no
2178: 0000:         PILST.DET.FILLER$,              \ 6 bytes
2179: 0000:         PILST.HDR.FILLER$               ! 24 bytes
2180: 0000: 	
2181: 0000:  %INCLUDE PIITMDEC.J86                    ! FLC
2182: 0000: 
2183: 0000: \******************************************************************************
2184: 0000: \***
2185: 0000: \***     %INCLUDE FOR PIITM - ITEM LIST FILE - FIELD DECLARATIONS
2186: 0000: \***                                           FILE REFERENCE PARAMETERS
2187: 0000: \***
2188: 0000: \***     REFERENCE: PIITMDEC.J86
2189: 0000: \***        
2190: 0000: \***                           8TH OCTOBER 1992
2191: 0000: \***
2192: 0000: \******************************************************************************
2193: 0000: 
2194: 0000:    INTEGER*1 GLOBAL							\
2195: 0000: 	PIITM.REPORT.NUM%,						\
2196: 0000: 	PIITM.SESS.NUM%
2197: 0000: 
2198: 0000:    INTEGER*2 GLOBAL			\
2199: 0000: 	PIITM.RECL%,			\
2200: 0000: 	PIITM.DISCREPANCY%,		\ discrepancy
2201: 0000: 	PIITM.DISCREPANCY.AMT%		! discrepancy amount
2202: 0000: 	
2203: 0000:    STRING GLOBAL			\
2204: 0000: 	PIITM.FILE.NAME$,		\
2205: 0000: 	PIITM.LIST.ITEM.KEY$,		\ 4 + 1 bytes - list no. & item no
2206: 0000: 	PIITM.LIST.NUMBER$,		\ 4 byte - list number
2207: 0000: 	PIITM.ITEM.NUMBER$,		\ 2 byte - item number
2208: 0000: 	PIITM.ITEM.CODE$,		\ 4 byte UPD - item code
2209: 0000: 	PIITM.ON.IDF$,			\ 1 byte - on IDF flag "Y" / "N"
2210: 0000: 	PIITM.ACTIVITY.FLAG$,		\ 1 byte - activity flag
2211: 0000: 	PIITM.CYCLE.LENGTH$,		\ 2 byte - count cycle length (weeks)
2212: 0000: 	PIITM.FAMILY.MARKER$,		\ 2 byte - family marker
2213: 0000: 	PIITM.MEMBERS$,			\ 2 byte - number of members
2214: 0000: 	PIITM.ELIGIBILITY.FLAG$,	\ 1 byte - eligibility flag
2215: 0000: 	PIITM.LIST.STATUS$,		\ 1 byte - list status :
2216: 0000: 					\    "C" = to be counted,
2217: 0000: 					\    "R" = to be re-counted,
2218: 0000: 					\    "D" = counted,
2219: 0000: 					\    "F" = completed,
2220: 0000: 					\    "X" = cancelled.
2221: 0000: 	PIITM.POTENTIAL.RECOUNT$,	\ 1 byte - potential recount flag :
2222: 0000: 					\    "0" = not a potential re-count,
2223: 0000: 					\    "1" = failed value test,
2224: 0000: 					\    "2" = failed percentage test.
2225: 0000:         PIITM.FILLER$                   ! 5 bytes
2226: 0000: 					
2227: 0000: !%INCLUDE PDTWFDEC.J86                    ! FLC
2228: 0000: !%INCLUDE IRFDEC.J86                      ! FLC TEST
2229: 0000: 
2230: 0000:  %INCLUDE CCUODDEC.J86                    ! GMJK
2231: 0000: 
2232: 0000: \*****************************************************************************
2233: 0000: \*****************************************************************************
2234: 0000: \***
2235: 0000: \***        %INCLUDE FIELD DECLARATIONS AND FILE REFERENCE PARAMETERS
2236: 0000: \***
2237: 0000: \***                   FILE TYPE:  KEYED
2238: 0000: \***
2239: 0000: \***                   REFERENCE:  CCUODDEC.J86
2240: 0000: \***
2241: 0000: \***                 DESCRIPTION:  RETURNS / AUTOMATIC CREDIT CLAIMING
2242: 0000: \***                   FILE OF OPEN/CLOSED UODS
2243: 0000: \***
2244: 0000: \***
2245: 0000: \***    VERSION A : Michael J. Kelsall      13th September 1993
2246: 0000: \***      
2247: 0000: \***    VERSION B : Mark Walker                   18th Jul 2015
2248: 0000: \***    F392 Retail Stock 5
2249: 0000: \***    Added CCUOD.RETRIEVAL.FLAG$ field to allow record to be
2250: 0000: \***    marked as processed.
2251: 0000: \***
2252: 0000: \*****************************************************************************
2253: 0000: \*****************************************************************************
2254: 0000: 
2255: 0000: STRING GLOBAL           \
2256: 0000:    CCUOD.FILE.NAME$,        \
2257: 0000:    CCUOD.UOD.NUM$,      \  7 byte UPD;  Record key
2258: 0000:    CCUOD.STATUS$,       \  1 byte ASC;  "O" = Open,
2259: 0000:                 \           "C" = Closed,
2260: 0000:                 \           "D" = Despatched,       
2261: 0000:                 \           "X" = Cancelled.
2262: 0000:    CCUOD.CREDIT.CLAIM.NUM$, \  4 byte UPD
2263: 0000:                 \  CCUOD.NUM.OF.ITEMS% here (I2)
2264: 0000:    CCUOD.SUPPLY.ROUTE$,     \  1 byte ASC;  "W" = Warehouse,
2265: 0000:                 \           "E" = EPSOM,
2266: 0000:                 \           "O" = Other Directs,
2267: 0000:                 \               "D" = Dispensary.
2268: 0000:    CCUOD.DISP.LOCATION$,    \  1 byte ASC   "M" = MDS, "D" = Dispensary.
2269: 0000:    CCUOD.BC.LETTER$,        \  1 byte ASC    
2270: 0000:    CCUOD.RECALL.NUM$,       \  8 byte ASC
2271: 0000:    CCUOD.AUTHORISATION$,    \ 15 byte ASC
2272: 0000:    CCUOD.SUPPLIER$,     \ 15 byte ASC
2273: 0000:    CCUOD.METHOD.OF.RETURN$, \  1 byte UPD;   1 = Carrier,
2274: 0000:                 \                2 = BIRD,
2275: 0000:                 \        3 = Via D6,
2276: 0000:                 \        4 = Representative.
2277: 0000:    CCUOD.CARRIER$,      \  1 byte UPD;   1 = GPO,
2278: 0000:                 \                2 = Parcelforce,
2279: 0000:                 \        3 = Securicor,
2280: 0000:                 \        4 = Other.
2281: 0000:    CCUOD.BIRD.NUM$,     \  8 byte ASC                   
2282: 0000:    CCUOD.REASON.NUM$,       \  1 byte UPD     (See CSRNS declaration)
2283: 0000:    CCUOD.RECEIVING.STORE$,  \  2 byte UPD    
2284: 0000:    CCUOD.DESTINATION$,      \  1 byte UPD    1 = Business Centre, 
2285: 0000:                 \            2 = MTS,
2286: 0000:                 \        3 = Pharmacy, 
2287: 0000:                 \        4 = Other.
2288: 0000:    CCUOD.WAREHOUSE.ROUTE$,  \  1 byte ASC   "R" = RDC, "C" = CSR.
2289: 0000:    CCUOD.UOD.TYPE$,     \  1 byte UPD    1 = Travel Outer,
2290: 0000:                 \        2 = Town tray,
2291: 0000:                 \        3 = Roll cage,
2292: 0000:                 \                4 = Other.
2293: 0000:    CCUOD.DAMAGE.REASON$,         \  1 byte UPD    1 = Bad packaging,    
2294: 0000:                 \        2 = Poor handling.
2295: 0000:    CCUOD.DATE.UOD.OPENED$,  \  3 byte UPD 
2296: 0000:    CCUOD.DATE.UOD.DESPATCHED$,  \  3 byte UPD
2297: 0000:    CCUOD.TIME.UOD.DESPATCHED$,  \  3 byte UPD
2298: 0000:    CCUOD.RETRIEVAL.FLAG$, \  1 byte ASC;  " " = to be retrieved             !BMW
2299: 0000:                           \               "N" = marked as processed         !BMW
2300: 0000:    CCUOD.FILLER$,       \ 19 byte ASC;   Spaces.
2301: 0000:                 \
2302: 0000:                 \
2303: 0000:                 \
2304: 0000:    CCUOD.HEADER$,       \   Hdr rec layout; (key of High values)
2305: 0000:    CCUOD.DATE.FILE.UPDATED$,    \  3 byte UPD (all 9's if empty file created)
2306: 0000:    CCUOD.TIME.FILE.UPDATED$,    \  3 byte UPD (all 9's if empty file created)
2307: 0000:    CCUOD.LDT.NUM$,      \  3 byte UPD (Zeros if no outstanding data
2308: 0000:                 \              to be processed by PSS35)
2309: 0000:    CCUOD.HEADER.FILLER$     ! 84 byte ASC;  Spaces.
2310: 0000: 
2311: 0000: 
2312: 0000: INTEGER*2 GLOBAL        \
2313: 0000:    CCUOD.RECL%,         \
2314: 0000:    CCUOD.REPORT.NUM%,       \
2315: 0000:    CCUOD.SESS.NUM%,     \
2316: 0000:                 \
2317: 0000:    CCUOD.NUM.OF.ITEMS%      ! 2 byte INT
2318: 0000: 
2319: 0000:  %INCLUDE CCLAMDEC.J86                    ! 1.4
2320: 0000: 
2321: 0000: \*****************************************************************************
2322: 0000: \*****************************************************************************
2323: 0000: \***
2324: 0000: \***        %INCLUDE FIELD DECLARATIONS AND FILE REFERENCE PARAMETERS
2325: 0000: \***
2326: 0000: \***                   FILE TYPE:  KEYED
2327: 0000: \***
2328: 0000: \***                   REFERENCE:  CCLAMDEC.J86
2329: 0000: \***
2330: 0000: \***	             DESCRIPTION:  RETURNS / AUTOMATIC CREDIT CLAIMING
2331: 0000: \***				   FILE OF CURRENT CREDIT CLAIMS
2332: 0000: \***
2333: 0000: \***
2334: 0000: \***      VERSION A : Michael J. Kelsall      16th December 1993
2335: 0000: \***      
2336: 0000: \*****************************************************************************
2337: 0000: \*****************************************************************************
2338: 0000: 
2339: 0000: STRING GLOBAL			\
2340: 0000:    CCLAM.FILE.NAME$,		\
2341: 0000:    CCLAM.CREDIT.CLAIM.NUM$,	\  4 byte UPD;   Record Key
2342: 0000:    CCLAM.UOD.NUM$,		\  7 byte UPD
2343: 0000:    				\  CCLAM.NUM.OF.ITEMS% here (I2)
2344: 0000:    CCLAM.SUPPLY.ROUTE$,		\  1 byte ASC;  "W" = Warehouse,
2345: 0000:    				\ 	        "E" = EPSOM,
2346: 0000: 				\	        "O" = Other Directs,
2347: 0000: 				\               "D" = Dispensary.
2348: 0000:    CCLAM.DISP.LOCATION$,	\  1 byte ASC   "M" = MDS, "D" = Dispensary.
2349: 0000:    CCLAM.BC.LETTER$,		\  1 byte ASC    
2350: 0000:    CCLAM.RECALL.NUM$,		\  8 byte ASC
2351: 0000:    CCLAM.AUTHORISATION$,	\ 15 byte ASC
2352: 0000:    CCLAM.SUPPLIER$,		\ 15 byte ASC
2353: 0000:    CCLAM.METHOD.OF.RETURN$,	\  1 byte UPD;   1 = Carrier,
2354: 0000:    				\                2 = BIRD,
2355: 0000: 				\	 	 3 = Via D6,
2356: 0000: 				\		 4 = Representative.
2357: 0000:    CCLAM.CARRIER$,		\  1 byte UPD;   1 = GPO,
2358: 0000:    				\                2 = Parcelforce,
2359: 0000: 				\	 	 3 = Securicor,
2360: 0000: 				\ 		 4 = Other.
2361: 0000:    CCLAM.BIRD.NUM$,		\  8 byte ASC					
2362: 0000:    CCLAM.REASON.NUM$,		\  1 byte UPD     (See CSRNS declaration)
2363: 0000:    CCLAM.RECEIVING.STORE$,	\  2 byte UPD    
2364: 0000:    CCLAM.DESTINATION$,		\  1 byte UPD    1 = Business Centre, 
2365: 0000:    				\	         2 = MTS,
2366: 0000:    				\		 3 = Pharmacy, 
2367: 0000: 				\		 4 = Other.
2368: 0000:    CCLAM.WAREHOUSE.ROUTE$,	\  1 byte ASC   "R" = RDC, "C" = CSR.
2369: 0000:    CCLAM.UOD.TYPE$,		\  1 byte UPD    1 = Travel Outer,
2370: 0000:    				\		 2 = Town tray,
2371: 0000: 				\		 3 = Roll cage,
2372: 0000: 				\     	         4 = Other.
2373: 0000:    CCLAM.DAMAGE.REASON$,        \  1 byte UPD    1 = Bad packaging,	
2374: 0000:    				\		 2 = Poor handling.
2375: 0000:    CCLAM.INVOICE.NUM$,		\* 9 byte ASC 
2376: 0000:    CCLAM.FOLIO.NUM$,		\  3 byte UPD
2377: 0000:    CCLAM.BATCH.REF$,		\  3 byte UPD
2378: 0000:    CCLAM.WHOLE.PART.CON$,       \  1 byte ASC   "W" = Whole, "P" = Part
2379: 0000:    CCLAM.REPAIR.CATEGORY$, 	\  1 byte UPD;   1 = Plan4,
2380: 0000:    				\   		 2 = Estimate,
2381: 0000: 				\		 3 = Boots guarantee,
2382: 0000: 				\		 4 = Supplier guarantee,
2383: 0000: 				\		 5 = Other guarantee,
2384: 0000:    CCLAM.REPAIR.NUM$,		\  6 byte UPD
2385: 0000:    CCLAM.PLAN4.POLICY.NUM$,	\  6 byte UPD 
2386: 0000:    CCLAM.DDDA.DCDR.NUM$,	\  4 byte UPD
2387: 0000:    CCLAM.DELIV.NOTE.NUM$,	\* 9 byte ASC
2388: 0000:    CCLAM.DELIV.DATE$,		\  3 byte UPD
2389: 0000:    CCLAM.NUM.CARTONS.RECEIV$,	\  1 byte UPD
2390: 0000:    CCLAM.ORDER.NUM$,		\  7 byte ASC
2391: 0000:    CCLAM.COMMENT$,  		\*20 byte ASC
2392: 0000:    CCLAM.DATE.OF.CLAIM$,	\  3 byte UPD;  Date of UOD despatch
2393: 0000:    CCLAM.TIME.OF.CLAIM$,	\  3 byte UPD;  Time of UOD despatch
2394: 0000:    CCLAM.RETRIEVAL.FLAG$,	\  1 byte ASC;  "Y", "N"  PSS35 sets to Y
2395: 0000:    				\                         PSB30 sets to N
2396: 0000:    CCLAM.CF.RPT.MARKER$,	\  1 byte ASC;  "Y"       PSS35 sets to Y
2397: 0000:    				\               "N"       PSS20 sets to N
2398: 0000:    CCLAM.CANC.MARKER$,		\  1 byte ASC;  Y or N
2399: 0000:    CCLAM.FILLER$		!  7 byte ASC;  Spaces.
2400: 0000: 
2401: 0000: 
2402: 0000: INTEGER*2 GLOBAL		\
2403: 0000:    CCLAM.RECL%,			\
2404: 0000:    CCLAM.REPORT.NUM%,		\
2405: 0000:    CCLAM.SESS.NUM%,		\
2406: 0000: 				\
2407: 0000:    CCLAM.NUM.OF.ITEMS%		!  2 byte INT
2408: 0000: 
2409: 0000:  %INCLUDE CCITMDEC.J86                    ! GMJK
2410: 0000: 
2411: 0000: \*****************************************************************************
2412: 0000: \*****************************************************************************
2413: 0000: \***
2414: 0000: \***        %INCLUDE FIELD DECLARATIONS AND FILE REFERENCE PARAMETERS
2415: 0000: \***
2416: 0000: \***                   FILE TYPE:  KEYED
2417: 0000: \***
2418: 0000: \***                   REFERENCE:  CCUODITM.J86
2419: 0000: \***
2420: 0000: \***	             DESCRIPTION:  RETURNS / AUTOMATIC CREDIT CLAIMING
2421: 0000: \***				   FILE OF ITEMS PER OPEN/CLOSED UOD
2422: 0000: \***
2423: 0000: \***
2424: 0000: \***      VERSION A : Michael J. Kelsall      13th September 1993
2425: 0000: \***      
2426: 0000: \*****************************************************************************
2427: 0000: \*****************************************************************************
2428: 0000: 
2429: 0000: STRING GLOBAL			\
2430: 0000:    CCITM.FILE.NAME$,		\
2431: 0000:    CCITM.KEY$,			\  Consists of next two fields;
2432: 0000:    CCITM.UOD.NUM$,		\  7 byte UPD
2433: 0000:    CCITM.ITEM.NUM$,		\  2 byte UPD
2434: 0000:    				\
2435: 0000:    CCITM.BOOTS.BAR.CODE.FLAG$,	\  1 byte ASC;  "I" = Boots code,
2436: 0000:    				\		"B" = Bar code.
2437: 0000:    CCITM.BOOTS.BAR.CODE$,	\  7 byte UPD
2438: 0000:    				\  CCITM.QTY% here (I2)
2439: 0000:    CCITM.FILLER$                !  4 byte ASC;  Spaces
2440: 0000:       				
2441: 0000: 
2442: 0000: INTEGER*2 GLOBAL		\
2443: 0000:    CCITM.RECL%,			\
2444: 0000:    CCITM.REPORT.NUM%,		\
2445: 0000:    CCITM.SESS.NUM%,		\
2446: 0000: 				\
2447: 0000:    CCITM.QTY%			!  2 byte INT
2448: 0000: 
2449: 0000:  %INCLUDE CCTRLDEC.J86                    ! GMJK
2450: 0000: 
2451: 0000: \*****************************************************************************
2452: 0000: \*****************************************************************************
2453: 0000: \***
2454: 0000: \***        %INCLUDE FIELD DECLARATIONS AND FILE REFERENCE PARAMETERS
2455: 0000: \***
2456: 0000: \***                   FILE TYPE:  DIRECT
2457: 0000: \***
2458: 0000: \***                   REFERENCE:  CCTRLDEC.J86
2459: 0000: \***
2460: 0000: \***	             DESCRIPTION:  RETURNS / AUTOMATIC CREDIT CLAIMING
2461: 0000: \***				   CREDIT CLAIMS CONTROL FILE
2462: 0000: \***
2463: 0000: \***
2464: 0000: \***      VERSION A : Michael J. Kelsall      14th September 1993
2465: 0000: \***      
2466: 0000: \*****************************************************************************
2467: 0000: \*****************************************************************************
2468: 0000: 
2469: 0000: STRING GLOBAL			\
2470: 0000:    CCTRL.FILE.NAME$,		\
2471: 0000:    CCTRL.RECORD$,		\
2472: 0000:    CCTRL.CREDIT.CLAIM.NUM$,	\  4 byte UPD
2473: 0000:    CCTRL.CREDIT.RPT.RUN.DATE$,	\  3 byte UPD
2474: 0000:    CCTRL.UOD.RPT.RUN.DATE$,	\  3 byte UPD
2475: 0000:    CCTRL.FILLER$		! 65 byte ASC;  Spaces
2476: 0000:    
2477: 0000: 
2478: 0000: INTEGER*2 GLOBAL		\
2479: 0000:    CCTRL.RECL%,			\
2480: 0000:    CCTRL.REPORT.NUM%,		\
2481: 0000:    CCTRL.SESS.NUM%,		\
2482: 0000:    CCTRL.REC.NUM%
2483: 0000: 
2484: 0000: INTEGER*4 GLOBAL		\
2485: 0000:    CCTRL.STAFF.SALES%		!  4 INT, total sales to store staff,
2486: 0000:    				!  stored as 5 byte UPD on file
2487: 0000: 
2488: 0000:  %INCLUDE CCTMPDEC.J86                    ! GMJK
2489: 0000: REM \
2490: 0000: \******************************************************************************
2491: 0000: \******************************************************************************
2492: 0000: \***
2493: 0000: \***      %INCLUDE FOR CREDIT CLAIMING TEMPORARY FILE FIELD DECLARATIONS
2494: 0000: \***                                             FILE REFERENCE PARAMETERS
2495: 0000: \***
2496: 0000: \***               FILE TYPE    : Sequential
2497: 0000: \***
2498: 0000: \***               REFERENCE    : CCTMPDEC.J86
2499: 0000: \***
2500: 0000: \***      Version A.     Michael J. Kelsall           30th September 1993.
2501: 0000: \***
2502: 0000: \***      Version 1.1    Brian Greenfield             14th May 2007
2503: 0000: \***      Added new variable CCTMP.RECALL.TYPE$ for A7C Recalls.
2504: 0000: \***
2505: 0000: \******************************************************************************
2506: 0000: \*******************************************************************************
2507: 0000: \***
2508: 0000: \***  The length of the records on this file vary depending on the record
2509: 0000: \***  transaction type, but they all comprise combinations of the fields
2510: 0000: \***  defined below.
2511: 0000: \***
2512: 0000: \***  RETURNS/AUTOMATIC CREDIT CLAIMING RECORD TYPES;
2513: 0000: \***
2514: 0000: \***  Transaction type 24 - Whole or Part consignment record
2515: 0000: \***     RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, CREDIT CLAIM NUM, 
2516: 0000: \***     BC LETTER, CLAIM TYPE, SUPPLIER NUM, INVOICE NUM, FOLIO NUM, 
2517: 0000: \***     BATCH REF NUM, REPAIR CATEGORY, REPAIR NUM, PLAN4 POLICY NUM, 
2518: 0000: \***     DDDA/DCDR NUM, DELIV NOTE NUM, DELIV DATE, NUM OF CARTONS, ORDER NUM,
2519: 0000: \***     NUM OF ITEMS, ITEM/BAR CODE FLAG, BOOTS/BAR CODE, QTY, PRICE, 
2520: 0000: \***     RECORD DELIMITER, END OF RECORD MARKER
2521: 0000: \***     (ITEM/BAR CODE FLAG to PRICE repeated NUM OF ITEMS times)
2522: 0000: \***
2523: 0000: \***  Transaction type 26 - Data from LDT
2524: 0000: \***     RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, UOD NUM, UOD STATUS, 
2525: 0000: \***     CREDIT CLAIM NUM, NUM OF ITEMS UPDATED, TOTAL QTY IN UOD, 
2526: 0000: \***     ADJUST STOCK FIGURE FLAG, SUPPLY ROUTE, DISP LOCATION, BC LETTER, 
2527: 0000: \***     RECALL NUM, AUTHORISATION, SUPPLIER, RETURN METHOD, CARRIER, BIRD NUM,
2528: 0000: \***     REASON, WAREHOUSE ROUTE, UOD TYPE, REASON FOR DAMAGE, RECEIVING STORE,
2529: 0000: \***     DESTINATION, DATE UOD OPENED, DATE UOD DESPATCHED, TIME UOD 
2530: 0000: \***     DESPATCHED, RECALL.TYPE$, ITEM.BAR CODE FLAG, BOOTS/BAR CODE, QTY,       ! 1.1BG
2531: 0000: \***     ITEM UPDATED FLAG, RECORD DELIMITER, END OF RECORD MARKER
2532: 0000: \***     (ITEM/BAR CODE FLAG to ITEM UPDATED FLAG repeated NUM OF ITEMS times)
2533: 0000: \***
2534: 0000: \***  Transaction type 28 - Cancelled Credit Claim
2535: 0000: \***     RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, CLAIM NUMBER, UOD
2536: 0000: \***     NUM, NEW STATUS FLAG, RECORD DELIMITER, END OF RECORD MARKER
2537: 0000: \***
2538: 0000: \******************************************************************************
2539: 0000: 
2540: 0000:   STRING GLOBAL              \
2541: 0000:     CCTMP.FILE.NAME$,        \
2542: 0000:     CCTMP.RECORD$,           \ Used to store the whole record which is unstrung
2543: 0000:                              \ into the fields below
2544: 0000:     CCTMP.RECORD.DELIMITER$, \ 1 byte ASCII set to " (CHR$(34)) 
2545: 0000:     CCTMP.TRANS.TYPE$,       \ 1 byte UPD. 24 = Whole/Part consignment (R/ACC)
2546: 0000:                  \             25 = NS16 / Misc cont txn (R/ACC)
2547: 0000:                  \             26 = Data from LDT (R/ACC)
2548: 0000:                  \             27 = End of LDT session (R/ACC)
2549: 0000:                  \         28 = Canc. Credit Claim (R/ACC)
2550: 0000:     CCTMP.FIELD.DELIMITER$,  \ 1 byte ASCII set to ; (CHR$(59))
2551: 0000:     CCTMP.ENDREC.MARKER$,    \ 2 bytes ASCII set to 0D0AH
2552: 0000:     CCTMP.BC.LETTER$,        \ 1 byte ASCII
2553: 0000:     CCTMP.CREDIT.CLAIM.NUM$, \ 4 byte UPD
2554: 0000:     CCTMP.NUM.ITEMS.UPDATED$,\ 4 byte ASCII
2555: 0000:     CCTMP.TOTAL.QTY.IN.UOD$, \ 4 byte ASCII
2556: 0000:     CCTMP.CLAIM.TYPE$,       \ 1 byte ASC;  "M" = Missing,
2557: 0000:                      \          "E" = Excess,
2558: 0000:                  \              "R" = Repairs
2559: 0000:     CCTMP.SUPPLIER.NUM$,     \ 3 byte UPD
2560: 0000:     CCTMP.INVOICE.NUM$,      \ 3 byte UPD 
2561: 0000:     CCTMP.FOLIO.NUM$,        \ 3 byte UPD
2562: 0000:     CCTMP.BATCH.REF$,        \ 3 byte UPD
2563: 0000:     CCTMP.REPAIR.CATEGORY$,  \ 1 byte UPD;   1 = Plan4,
2564: 0000:                  \           2 = Estimate,
2565: 0000:                  \           3 = Boots guarantee,
2566: 0000:                  \           4 = Supplier guarantee,
2567: 0000:                  \           5 = Other guarantee,
2568: 0000:     CCTMP.REPAIR.NUM$,       \ 4 byte UPD
2569: 0000:     CCTMP.PLAN4.POLICY.NUM$, \ 6 byte UPD; (Only if repair cat is Plan4)
2570: 0000:     CCTMP.DDDA.DCDR.NUM$,    \ 3 byte UPD
2571: 0000:     CCTMP.DELIV.NOTE.NUM$,   \ 3 byte UPD
2572: 0000:     CCTMP.NUM.CARTONS.RECEIV$,\1 byte UPD
2573: 0000:     CCTMP.ORDER.NUM$,        \ 3 byte UPD
2574: 0000:     CCTMP.ITEM.BARCODE.FLAG$,\ 1 byte ASC;  "I" = Boots item code,
2575: 0000:                  \              "B" = Barcode.
2576: 0000:     CCTMP.ITEM.BARCODE$,     \ 7 byte UPD
2577: 0000:     CCTMP.ITEM.PRICE$,       \ 3 byte UPD;  Spaces.
2578: 0000:     CCTMP.AUTHORISATION$,    \ 15 byte ASC
2579: 0000:     CCTMP.ADJ.STOCK.FIGURE$, \ 1 byte ASC  "Y" or "N"
2580: 0000:     CCTMP.RETURN.REASON$,    \ 1 byte UPD;  (See CCRSN file)
2581: 0000:     CCTMP.UOD.NUM$,      \ 7 byte UPD
2582: 0000:     CCTMP.UOD.STATUS$,       \ 1 byte ASC;  "O" = Open,
2583: 0000:                      \              "C" = Closed,
2584: 0000:                  \              "D" = Despatched
2585: 0000:     CCTMP.PREVIOUS.STATUS$,  \ 1 byte ASC   "O" = Open,
2586: 0000:                      \              "C" = Closed
2587: 0000:     CCTMP.SUPPLY.ROUTE$,     \ 1 byte ASC
2588: 0000:     CCTMP.DISP.LOCATION$,    \ 1 byte ASC   "M" = MDS,
2589: 0000:                      \              "D" = Dispensary
2590: 0000:     CCTMP.RECALL.NUM$,       \ 9 byte ASC 
2591: 0000:     CCTMP.SUPPLIER$,         \ 15 byte ASC
2592: 0000:     CCTMP.RETURN.METHOD$,    \ 1 byte UPD;   1 = Carrier,
2593: 0000:                      \           2 = BIRD,
2594: 0000:                  \               3 = Via D6,
2595: 0000:                  \               4 = Representative
2596: 0000:     CCTMP.CARRIER$,      \ 1 byte UPD;   1 = GPO,
2597: 0000:                      \               2 = Parcelforce,
2598: 0000:                  \               3 = Securicor,
2599: 0000:                  \               4 = Other
2600: 0000:     CCTMP.BIRD.NUM$,         \ 8 byte ASC
2601: 0000:     CCTMP.WAREHOUSE.ROUTE$,  \ 1 byte ASC   "R" = RDC,
2602: 0000:                      \          "C" = CSR
2603: 0000:     CCTMP.UOD.TYPE$,         \ 1 byte UPD;   1 = Travel Outer,
2604: 0000:                      \               2 = Town Tray,
2605: 0000:                  \               3 = Roll cage,
2606: 0000:                  \               4 = Other
2607: 0000:     CCTMP.DAMAGE.REASON$,    \ 1 byte UPD    1 = Bad packaging,
2608: 0000:                      \               2 = Poor handling
2609: 0000:     CCTMP.RECEIVING.STORE$,  \ 2 byte UPD
2610: 0000:     CCTMP.DESTINATION$,      \ 1 byte UPD    1 = Business Centre,
2611: 0000:                      \               2 = MTS,
2612: 0000:                  \               3 = Other
2613: 0000:     CCTMP.DATE.UOD.OPENED$,  \ 3 byte UPD
2614: 0000:     CCTMP.DATE.DESPATCHED$,  \ 3 byte UPD
2615: 0000:     CCTMP.TIME.DESPATCHED$,  \ 3 byte UPD
2616: 0000:     CCTMP.ITEM.UPDATED$,     \ 1 byte ASC
2617: 0000:     CCTMP.NEW.STATUS.FLAG$,  \ 1 byte ASC   "C" = Closed,
2618: 0000:                      \          "D" = Despatched,
2619: 0000:                  \          "X" = Cancelled
2620: 0000:     CCTMP.ITEM.QTY$,         \ 3 byte ASCII              
2621: 0000:     CCTMP.RECALL.TYPE$       ! 1 byte ASCII "B" = Batch Recall              ! 1.1BG
2622: 0000:                              !              "N" = Non-batch Recall          ! 1.1BG
2623: 0000:                              !              " " = Old Credit Claim          ! 1.1BG
2624: 0000:     
2625: 0000:                                                  
2626: 0000:   INTEGER*2 GLOBAL           \
2627: 0000:     CCTMP.SESS.NUM%,         \
2628: 0000:     CCTMP.REPORT.NUM%,       \
2629: 0000:                      \
2630: 0000:     CCTMP.NUM.OF.ITEMS%,     \
2631: 0000:     CCTMP.NUM.ITEMS.UPDATED%,\ 
2632: 0000:     CCTMP.TOTAL.QTY.IN.UOD%  !
2633: 0000:                          
2634: 0000:                  
2635: 0000:  %INCLUDE CCBUFDEC.J86                    ! GMJK
2636: 0000: REM \
2637: 0000: \******************************************************************************
2638: 0000: \******************************************************************************
2639: 0000: \***
2640: 0000: \***      %INCLUDE FOR CREDIT CLAIMING BUFFER FILE FIELD DECLARATIONS
2641: 0000: \***                                          FILE REFERENCE PARAMETERS
2642: 0000: \***
2643: 0000: \***               FILE TYPE    : Sequential
2644: 0000: \***
2645: 0000: \***               REFERENCE    : CCBUFDEC.J86
2646: 0000: \***
2647: 0000: \***      Version A.     Michael J. Kelsall           30th September 1993.
2648: 0000: \***
2649: 0000: \******************************************************************************
2650: 0000: \*******************************************************************************
2651: 0000: \***
2652: 0000: \***  The length of the records on this file vary depending on the record
2653: 0000: \***  transaction type, but they all comprise combinations of the fields
2654: 0000: \***  defined below.
2655: 0000: \***
2656: 0000: \***  RETURNS/AUTOMATIC CREDIT CLAIMING RECORD TYPES;
2657: 0000: \***
2658: 0000: \***  Transaction type 24 - Whole or Part consignment record
2659: 0000: \***     RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, CREDIT CLAIM NUM, 
2660: 0000: \***     BC LETTER, CLAIM TYPE, SUPPLIER NUM, INVOICE NUM, FOLIO NUM, 
2661: 0000: \***     BATCH REF NUM, REPAIR CATEGORY, REPAIR NUM, PLAN4 POLICY NUM, 
2662: 0000: \***     DDDA/DCDR NUM, DELIV NOTE NUM, DELIV DATE, NUM OF CARTONS, ORDER NUM,
2663: 0000: \***     NUM OF ITEMS, ITEM/BAR CODE FLAG, BOOTS/BAR CODE, QTY, PRICE, 
2664: 0000: \***     RECORD DELIMITER, END OF RECORD MARKER
2665: 0000: \***     (ITEM/BAR CODE FLAG to PRICE repeated NUM OF ITEMS times)
2666: 0000: \***
2667: 0000: \***  Transaction type 26 - Data from LDT
2668: 0000: \***     RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, UOD NUM, UOD STATUS, 
2669: 0000: \***     CREDIT CLAIM NUM, NUM OF ITEMS UPDATED, TOTAL QTY IN UOD, 
2670: 0000: \***     ADJUST STOCK FIGURE FLAG, SUPPLY ROUTE, DISP LOCATION, BC LETTER, 
2671: 0000: \***     RECALL NUM, AUTHORISATION, SUPPLIER, RETURN METHOD, CARRIER, BIRD NUM,
2672: 0000: \***     REASON, WAREHOUSE ROUTE, UOD TYPE, REASON FOR DAMAGE, RECEIVING STORE,
2673: 0000: \***     DESTINATION, DATE UOD OPENED, DATE UOD DESPATCHED, TIME UOD 
2674: 0000: \***     DESPATCHED, ITEM.BAR CODE FLAG, BOOTS/BAR CODE, QTY, ITEM UPDATED 
2675: 0000: \***     FLAG, RECORD DELIMITER, END OF RECORD MARKER
2676: 0000: \***     (ITEM/BAR CODE FLAG to ITEM UPDATED FLAG repeated NUM OF ITEMS times)
2677: 0000: \***
2678: 0000: \***  Transaction type 28 - Cancelled Credit Claim
2679: 0000: \***     RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, CLAIM NUMBER, UOD
2680: 0000: \***     NUM, NEW STATUS FLAG, RECORD DELIMITER, END OF RECORD MARKER
2681: 0000: \***
2682: 0000: \******************************************************************************
2683: 0000: 
2684: 0000:   STRING GLOBAL              \
2685: 0000:     CCBUF.FILE.NAME$,        \
2686: 0000:     CCBUF.RECORD$,           \ Used to store the whole record which is unstrung
2687: 0000:                              \ into the fields below
2688: 0000:     CCBUF.RECORD.DELIMITER$, \ 1 byte ASCII set to " (CHR$(34)) 
2689: 0000:     CCBUF.TRANS.TYPE$,       \ 1 byte UPD. 24 = Whole/Part consignment (R/ACC)
2690: 0000: 			     \             25 = NS16 / Misc cont txn (R/ACC)
2691: 0000: 			     \	           26 = Data from LDT (R/ACC)
2692: 0000: 			     \             27 = End of LDT session (R/ACC)
2693: 0000: 			     \		   28 = Canc. Credit Claim (R/ACC)
2694: 0000:     CCBUF.FIELD.DELIMITER$,  \ 1 byte ASCII set to ; (CHR$(59))
2695: 0000:     CCBUF.ENDREC.MARKER$,    \ 2 bytes ASCII set to XODOA
2696: 0000:     CCBUF.BC.LETTER$,        \ 1 byte ASCII
2697: 0000:     CCBUF.CREDIT.CLAIM.NUM$, \ 4 byte UPD
2698: 0000:     CCBUF.CLAIM.TYPE$,	     \ 1 byte ASC;  "M" = Missing,
2699: 0000:     			     \		    "E" = Excess,
2700: 0000: 			     \              "R" = Repairs
2701: 0000:     CCBUF.SUPPLIER.NUM$,     \ 3 byte UPD
2702: 0000:     CCBUF.INVOICE.NUM$,	     \ 3 byte UPD 
2703: 0000:     CCBUF.FOLIO.NUM$,	     \ 3 byte UPD
2704: 0000:     CCBUF.BATCH.REF$,	     \ 3 byte UPD
2705: 0000:     CCBUF.REPAIR.CATEGORY$,  \ 1 byte UPD;   1 = Plan4,
2706: 0000:    			     \ 		     2 = Estimate,
2707: 0000: 			     \		     3 = Boots guarantee,
2708: 0000: 			     \		     4 = Supplier guarantee,
2709: 0000: 			     \		     5 = Other guarantee,
2710: 0000:     CCBUF.REPAIR.NUM$,       \ 4 byte UPD
2711: 0000:     CCBUF.PLAN4.POLICY.NUM$, \ 6 byte UPD; (Only if repair cat is Plan4)
2712: 0000:     CCBUF.DDDA.DCDR.NUM$,    \ 3 byte UPD
2713: 0000:     CCBUF.DELIV.NOTE.NUM$,   \ 3 byte UPD
2714: 0000:     CCBUF.NUM.CARTONS.RECEIV$,\1 byte UPD
2715: 0000:     CCBUF.ORDER.NUM$,	     \ 3 byte UPD
2716: 0000:     CCBUF.ITEM.BARCODE.FLAG$,\ 1 byte ASC;  "I" = Boots item code,
2717: 0000:   			     \              "B" = Barcode.
2718: 0000:     CCBUF.ITEM.BARCODE$,     \ 7 byte UPD
2719: 0000:     CCBUF.ITEM.PRICE$,	     \ 3 byte UPD;  Spaces.
2720: 0000:     CCBUF.AUTHORISATION$,    \ 15 byte ASC
2721: 0000:     CCBUF.ADJ.STOCK.FIGURE$, \ 1 byte ASC;  "Y" or "N"
2722: 0000:     CCBUF.RETURN.REASON$,    \ 1 byte UPD;  (See CCRSN file)
2723: 0000:     CCBUF.UOD.NUM$,	     \ 7 byte UPD
2724: 0000:     CCBUF.UOD.STATUS$,	     \ 1 byte ASC;  "O" = Open,
2725: 0000:     			     \              "C" = Closed,
2726: 0000: 			     \              "D" = Despatched
2727: 0000:     CCBUF.SUPPLY.ROUTE$,     \ 1 byte ASC
2728: 0000:     CCBUF.DISP.LOCATION$,    \ 1 byte ASC   "M" = MDS,
2729: 0000:     			     \              "D" = Dispensary
2730: 0000:     CCBUF.RECALL.NUM$,       \ 9 byte ASC 
2731: 0000:     CCBUF.SUPPLIER$,	     \ 15 byte ASC
2732: 0000:     CCBUF.RETURN.METHOD$,    \ 1 byte UPD;   1 = Carrier,
2733: 0000:     			     \		     2 = BIRD,
2734: 0000: 			     \               3 = Via D6,
2735: 0000: 			     \               4 = Representative
2736: 0000:     CCBUF.CARRIER$,	     \ 1 byte UPD;   1 = GPO,
2737: 0000:     			     \               2 = Parcelforce,
2738: 0000: 			     \               3 = Securicor,
2739: 0000: 			     \               4 = Other
2740: 0000:     CCBUF.BIRD.NUM$,	     \ 8 byte ASC
2741: 0000:     CCBUF.WAREHOUSE.ROUTE$,  \ 1 byte ASC   "R" = RDC,
2742: 0000:     			     \  	    "C" = CSR
2743: 0000:     CCBUF.UOD.TYPE$,         \ 1 byte UPD;   1 = Travel Outer,
2744: 0000:     			     \               2 = Town Tray,
2745: 0000: 			     \               3 = Roll cage,
2746: 0000: 			     \               4 = Other
2747: 0000:     CCBUF.DAMAGE.REASON$,    \ 1 byte UPD    1 = Bad packaging,
2748: 0000:      			     \               2 = Poor handling
2749: 0000:     CCBUF.RECEIVING.STORE$,  \ 2 byte UPD
2750: 0000:     CCBUF.DESTINATION$,      \ 1 byte UPD    1 = Business Centre,
2751: 0000:     			     \               2 = MTS,
2752: 0000: 			     \               3 = Other
2753: 0000:     CCBUF.DATE.UOD.OPENED$,  \ 3 byte UPD
2754: 0000:     CCBUF.DATE.DESPATCHED$,  \ 3 byte UPD
2755: 0000:     CCBUF.TIME.DESPATCHED$,  \ 3 byte UPD
2756: 0000:     CCBUF.ITEM.UPDATED$,     \ 1 byte ASC
2757: 0000:     CCBUF.NEW.STATUS.FLAG$   \ 1 byte ASC   "C" = Closed,
2758: 0000:     			     \   	    "D" = Despatched,
2759: 0000: 			     !    	    "X" = Cancelled
2760: 0000:     
2761: 0000: 			     			     			     
2762: 0000:   INTEGER*2 GLOBAL           \
2763: 0000:     CCBUF.SESS.NUM%,         \
2764: 0000:     CCBUF.REPORT.NUM%,	     \
2765: 0000:     			     \
2766: 0000:     CCBUF.NUM.OF.ITEMS%,     \
2767: 0000:     CCBUF.NUM.ITEMS.UPDATED%,\
2768: 0000:     CCBUF.QTY%,		     \
2769: 0000:     CCBUF.TOTAL.QTY.IN.UOD%  !
2770: 0000:         			     
2771: 0000: 			     
2772: 0000:  %INCLUDE CCUPFDEC.J86                    ! HMJK
2773: 0000: 
2774: 0000: \*****************************************************************************
2775: 0000: \*****************************************************************************
2776: 0000: \***
2777: 0000: \***        %INCLUDE FIELD DECLARATIONS AND FILE REFERENCE PARAMETERS
2778: 0000: \***
2779: 0000: \***                   FILE TYPE:  KEYED
2780: 0000: \***
2781: 0000: \***                   REFERENCE:  CCUPFDEC.J86
2782: 0000: \***
2783: 0000: \***	             DESCRIPTION:  RETURNS / AUTOMATIC CREDIT CLAIMING
2784: 0000: \***				   UOD PROCESSED FILE
2785: 0000: \***
2786: 0000: \***
2787: 0000: \***      VERSION A : Michael J. Kelsall      14th March 1994
2788: 0000: \***      
2789: 0000: \*****************************************************************************
2790: 0000: \*****************************************************************************
2791: 0000: 
2792: 0000: STRING GLOBAL			\
2793: 0000:    CCUPF.FILE.NAME$,		\
2794: 0000:    CCUPF.UOD.NUM$,		\  7 byte UPD
2795: 0000:    CCUPF.CURRENT.STATUS$	!  1 byte ASC;  "C" = Closed,
2796: 0000:    				!               "D" - Despatched,
2797: 0000:    				!               "X" - Cancelled.
2798: 0000:       				
2799: 0000: 
2800: 0000: INTEGER*2 GLOBAL		\
2801: 0000:    CCUPF.RECL%,			\
2802: 0000:    CCUPF.REPORT.NUM%,		\
2803: 0000:    CCUPF.SESS.NUM%
2804: 0000: 
2805: 0000:  %INCLUDE CCWKFDEC.J86                    ! GMJK
2806: 0000: \******************************************************************************
2807: 0000: \******************************************************************************
2808: 0000: \***
2809: 0000: \***      %INCLUDE FOR RETURNS WORK FILE - FIELD DEFINITIONS
2810: 0000: \***                                       FILE REFERENCE PARAMETERS
2811: 0000: \***
2812: 0000: \***                  REFERENCE: CCWKFDEC.J86
2813: 0000: \***
2814: 0000: \***  Version A          Michael J. Kelsall              30th September 1993
2815: 0000: \***
2816: 0000: \******************************************************************************
2817: 0000: \*******************************************************************************
2818: 0000: 
2819: 0000:   STRING GLOBAL								\
2820: 0000: 	CCWKF.FILE.NAME$,						\
2821: 0000: 	CCWKF.RECORD$
2822: 0000: 
2823: 0000:   INTEGER*2 GLOBAL							\
2824: 0000: 	CCWKF.RECL%,	          					\
2825: 0000: 	CCWKF.SESS.NUM%,						\
2826: 0000: 	CCWKF.REPORT.NUM%
2827: 0000:  %INCLUDE CCDMYDEC.J86                    ! GMJK
2828: 0000: \******************************************************************************
2829: 0000: \******************************************************************************
2830: 0000: \***
2831: 0000: \***         %INCLUDE FOR RETURNS DUMMY FILE I/O SESSION NUMBER
2832: 0000: \***
2833: 0000: \***               REFERENCE    : CCDMYDEC.J86
2834: 0000: \***
2835: 0000: \***    Version A           Michael J. Kelsall          30th September 1993
2836: 0000: \***
2837: 0000: \******************************************************************************
2838: 0000: \*******************************************************************************
2839: 0000: 
2840: 0000:   STRING GLOBAL           \
2841: 0000:     CCDMY.FILE.NAME$
2842: 0000: 
2843: 0000:   INTEGER*2 GLOBAL        \
2844: 0000:     CCDMY.REPORT.NUM%,    \
2845: 0000:     CCDMY.SESS.NUM%
2846: 0000:  %INCLUDE LDTAFDEC.J86                    ! HMJK
2847: 0000: 
2848: 0000: \*****************************************************************************
2849: 0000: \*****************************************************************************
2850: 0000: \***
2851: 0000: \***        %INCLUDE FIELD DECLARATIONS AND FILE REFERENCE PARAMETERS
2852: 0000: \***
2853: 0000: \***                   FILE TYPE:  DIRECT
2854: 0000: \***
2855: 0000: \***                   REFERENCE:  LDTAFDEC.J86
2856: 0000: \***
2857: 0000: \***	             DESCRIPTION:  LDT / PDT SUPPORT LINK AUDIT FILE
2858: 0000: \***
2859: 0000: \***
2860: 0000: \***      VERSION A         Michael J. Kelsall       30th September 1993
2861: 0000: \***
2862: 0000: \***      VERSION B         Michael J. Kelsall       25th March 1994
2863: 0000: \***      Conversion of LDTAF link duration from minutes to seconds, requiring
2864: 0000: \***      4 byte integer to hold times >09:06:07 (= 32767 seconds)
2865: 0000: \***      
2866: 0000: \*****************************************************************************
2867: 0000: \*****************************************************************************
2868: 0000: 
2869: 0000:   STRING GLOBAL                 \
2870: 0000:     LDTAF.FILE.NAME$,		\
2871: 0000:     LDTAF.START.DATE$,		\ 3 byte UPD  (YYMMDD)
2872: 0000:     LDTAF.START.TIME$		! 3 byte UPD  (HHMMSS)
2873: 0000:     
2874: 0000: 
2875: 0000:   INTEGER*1 GLOBAL              \
2876: 0000:     LDTAF.LINK.TYPE%		!  1 - CSR file    (CSRWF size / num of UNITS)
2877: 0000: 				!  2 - PCHECK      (CHKBF size / null)
2878: 0000: 				!  3 - LDT PROG    (LDTPF size / null)
2879: 0000: 				!  4 - DIRECTS     (DRSMQ size / DIRWF size)
2880: 0000: 				!  5 - UOD         (UODTF size / null)
2881: 0000: 				!  6 - EPSOM req   (PDTWF size / null)
2882: 0000: 				!  7 - EPSOM lists (num of lists / null)
2883: 0000: 				!  8 - RETURNS UOD (CCTMP size / CCBUF size)
2884: 0000: 				!  9 - RETURNS req (CCWKF size / null)
2885: 0000: 				!  MSB ---> 0 = Port A , 1 = Port B. 
2886: 0000: 
2887: 0000:   INTEGER*2 GLOBAL              \
2888: 0000:     LDTAF.SESS.NUM%,            \
2889: 0000:     LDTAF.REPORT.NUM%,		\
2890: 0000:     LDTAF.RECL%
2891: 0000:     				
2892: 0000: 
2893: 0000:   INTEGER*4 GLOBAL              \
2894: 0000:     LDTAF.DATA.VOLUME.1%,	\
2895: 0000:     LDTAF.DATA.VOLUME.2%,	\
2896: 0000:     LDTAF.DURATION%    		! BMJK
2897: 0000:  %INCLUDE SOFTSDEC.J86                    ! GMJK
2898: 0000: REM \
2899: 0000: \******************************************************************************
2900: 0000: \******************************************************************************
2901: 0000: \***
2902: 0000: \***                 %INCLUDE FOR THE SOFTWARE STATUS FILE
2903: 0000: \***   
2904: 0000: \***                      FILE TYPE  :   Direct
2905: 0000: \***
2906: 0000: \***                      REFERENCE  :   SOFTSDEC.J86
2907: 0000: \***
2908: 0000: \***	Version A	       Andrew Wedgeworth	      24th June 1992
2909: 0000: \***
2910: 0000: \******************************************************************************
2911: 0000: \*******************************************************************************
2912: 0000: 
2913: 0000:   STRING GLOBAL           \
2914: 0000:     SOFTS.RECORD$,        \           
2915: 0000:     SOFTS.SPACE$,         \           
2916: 0000:     SOFTS.FILE.NAME$    
2917: 0000:     
2918: 0000:   INTEGER*2 GLOBAL        \
2919: 0000:     SOFTS.RECL%,          \            
2920: 0000:     SOFTS.REPORT.NUM%,	  \      
2921: 0000:     SOFTS.SESS.NUM%
2922: 0000: 
2923: 0000:   INTEGER*4 GLOBAL        \
2924: 0000:     SOFTS.REC.NUM% 	         
2925: 0000:  %INCLUDE STKBFDEC.J86                    ! 1.5
2926: 0000: \******************************************************************************
2927: 0000: \******************************************************************************
2928: 0000: \***
2929: 0000: \***   $Workfile:   STKBFDEC.J86  $
2930: 0000: \***
2931: 0000: \***   $Revision:   1.0  $
2932: 0000: \***
2933: 0000: \******************************************************************************
2934: 0000: \******************************************************************************
2935: 0000: \***
2936: 0000: \***   $Log:   V:\archive\j86\stkbfdec.j8v  $
2937: 0000: \***   
2938: 0000: \***      Rev 1.0   15 Jul 1997 14:20:36   DEV45PS
2939: 0000: \***    
2940: 0000: \***   
2941: 0000: \***      Rev 1.0   09 Jul 1997 11:04:52   DEV45PS
2942: 0000: \***   Stocktake System New Files
2943: 0000: \***   
2944: 0000: \******************************************************************************
2945: 0000: \******************************************************************************\******************************************************************************
2946: 0000: \******************************************************************************
2947: 0000: \***
2948: 0000: \***         %INCLUDE FOR STOCKTAKE BUFFER FILE FIELD DECLARATIONS
2949: 0000: \***
2950: 0000: \***               FILE TYPE    : DIRECT
2951: 0000: \***
2952: 0000: \***               REFERENCE    : STKBFDEC.J86
2953: 0000: \***
2954: 0000: \***    VERSION A.              Nik Sen.               19 Jun 1997.
2955: 0000: \***    New file for stocktaking system. Holds counts read from PDT.
2956: 0000: \***
2957: 0000: \*******************************************************************************
2958: 0000: \*******************************************************************************
2959: 0000: 
2960: 0000: STRING GLOBAL                                                  \
2961: 0000:    STKBF.FILE.NAME$,           \
2962: 0000:    STKBF.DATA$,                \
2963: 0000:    STKBF.STORE.NUMBER$,        \
2964: 0000:    STKBF.STOCKTAKER.NO$,       \
2965: 0000:    STKBF.DATE$,                \
2966: 0000:    STKBF.LOCATION$,            \
2967: 0000:    STKBF.ITEM.CODE$,           \
2968: 0000:    STKBF.QUANTITY$,            \
2969: 0000:    STKBF.PRICE$,               \
2970: 0000:    STKBF.RECORD.COUNT$,        \
2971: 0000:    STKBF.FILLER$
2972: 0000: 
2973: 0000: 
2974: 0000: INTEGER*4 GLOBAL               \
2975: 0000:    STKBF.RECORD.NUM%
2976: 0000: 
2977: 0000: INTEGER*2 GLOBAL                \
2978: 0000:    STKBF.REPORT.NUM%,           \
2979: 0000:    STKBF.SESS.NUM%             
2980: 0000: 
2981: 0000: 
2982: 0000: INTEGER*1 GLOBAL                \
2983: 0000:    STKBF.RECL%         
2984: 0000: 
2985: 0000: 
2986: 0000:  %INCLUDE SXTMPDEC.J86                    ! 1.5
2987: 0000: \******************************************************************************
2988: 0000: \******************************************************************************
2989: 0000: \***
2990: 0000: \***         %INCLUDE FOR TEMPORARY STOCKTAKE BUFFER FILE FIELD DECLARATIONS
2991: 0000: \***
2992: 0000: \***               FILE TYPE    : DIRECT
2993: 0000: \***
2994: 0000: \***               REFERENCE    : SXTMPDEC.J86
2995: 0000: \***
2996: 0000: \***    VERSION A.              Nik Sen.               30 Jun 1997.
2997: 0000: \***    New file for stocktaking system. Holds counts read from PDT.
2998: 0000: \***
2999: 0000: \***    VERSION B              Nik Sen                 23 September 1997
3000: 0000: \***    Removed record count as file converted from direct to sequential.
3001: 0000: \***
3002: 0000: \*******************************************************************************
3003: 0000: \*******************************************************************************
3004: 0000: 
3005: 0000: STRING GLOBAL                                                  \
3006: 0000:    SXTMP.FILE.NAME$,           \
3007: 0000:    SXTMP.DATA$,                \
3008: 0000:    SXTMP.STORE.NUMBER$,        \
3009: 0000:    SXTMP.STOCKTAKER.NO$,       \
3010: 0000:    SXTMP.DATE$,                \
3011: 0000:    SXTMP.LOCATION$,            \
3012: 0000:    SXTMP.ITEM.CODE$,           \
3013: 0000:    SXTMP.QUANTITY$,            \
3014: 0000:    SXTMP.PRICE$,               \
3015: 0000:    SXTMP.RECORD.COUNT$,        \
3016: 0000:    SXTMP.FILLER$
3017: 0000: 
3018: 0000: 
3019: 0000: INTEGER*2 GLOBAL                \
3020: 0000:    SXTMP.REPORT.NUM%,           \
3021: 0000:    SXTMP.SESS.NUM%             
3022: 0000: 
3023: 0000: 
3024: 0000: INTEGER*1 GLOBAL                \
3025: 0000:    SXTMP.RECL%         
3026: 0000: 
3027: 0000: 
3028: 0000:  %INCLUDE STKTKDEC.J86                    ! 1.5
3029: 0000: REM \
3030: 0000: \******************************************************************************
3031: 0000: \******************************************************************************
3032: 0000: \***
3033: 0000: \***         %INCLUDE FOR STOCKTAKE DUMMY FILE - FILE REFERENCE PARAMETERS
3034: 0000: \***
3035: 0000: \***               REFERENCE    : STKTKDEC.J86
3036: 0000: \***
3037: 0000: \******************************************************************************
3038: 0000: \*******************************************************************************
3039: 0000: 
3040: 0000:   STRING GLOBAL           \
3041: 0000:     STKTK.FILE.NAME$
3042: 0000: 
3043: 0000:   INTEGER*2 GLOBAL        \
3044: 0000:     STKTK.REPORT.NUM%,      \
3045: 0000:     STKTK.SESS.NUM%
3046: 0000:  %INCLUDE STLDTDEC.J86                    ! 1.6
3047: 0000: REM \
3048: 0000: \******************************************************************************
3049: 0000: \******************************************************************************
3050: 0000: \***
3051: 0000: \***            %INCLUDE FOR STLDT FILE VARIABLES
3052: 0000: \***
3053: 0000: \***                 FILE TYPE    : Direct
3054: 0000: \***
3055: 0000: \***                 REFERENCE    : STLDTDEC.J86
3056: 0000: \***
3057: 0000: \***       Version B          David Artiss      03/09/2002
3058: 0000: \***       Increase field from 2 to 2 bytes
3059: 0000: \***
3060: 0000: \******************************************************************************
3061: 0000: \*******************************************************************************
3062: 0000: 
3063: 0000:   STRING GLOBAL           \
3064: 0000:     STLDT.FILE.NAME$,     \
3065: 0000:     STLDT.RECORD$,        \ 25 bytes
3066: 0000:     STLDT.STORE$,         \ 4 bytes
3067: 0000:     STLDT.STOCKTAKER$,    \ 4 bytes
3068: 0000:     STLDT.LDT.SERIAL$,    \ 6 bytes
3069: 0000:     STLDT.DATE$,          \ 6 bytes DDMMYY
3070: 0000:     STLDT.TIME$,          \ 4 bytes HHMM
3071: 0000:     STLDT.CRLF$           \
3072: 0000: 
3073: 0000:   INTEGER*2 GLOBAL        \
3074: 0000:     STLDT.RECL%,          \
3075: 0000:     STLDT.SESS.NUM%,      \
3076: 0000:     STLDT.REPORT.NUM%     ! BDA
3077: 0000:      
3078: 0000:   INTEGER*4 GLOBAL        \
3079: 0000:     STLDT.RECORD.NUM%,    \
3080: 0000:     STLDT.COUNTS%,        \ BDA
3081: 0000:     STLDT.ITEMS%
3082: 0000:       
3083: 0000:  %INCLUDE STOCKDEC.J86                    ! 1.7BG
3084: 0000: \***********************************************************************
3085: 0000: \***********************************************************************
3086: 0000: \***
3087: 0000: \***    DESCRIPTION: Stock File
3088: 0000: \***                 Field Definitions         
3089: 0000: \***
3090: 0000: \***    FILE TYPE : Keyed
3091: 0000: \***
3092: 0000: \***********************************************************************
3093: 0000: \***
3094: 0000: \***    Version B.              Robert Cowey             21st Oct 1993
3095: 0000: \***    No changes to this file.
3096: 0000: \***
3097: 0000: \***    Version C.              Mark Walker              24th Jan 2014
3098: 0000: \***    F337 Centralised View of Stock
3099: 0000: \***    - Added sequence ID and item status fields.
3100: 0000: \***    - Minor formatting changes (uncommented).
3101: 0000: \***
3102: 0000: \***    Version D.              Mark Walker              15th Mar 2014
3103: 0000: \***    F337 Centralised View of Stock
3104: 0000: \***    Added next sequence ID field.
3105: 0000: \***
3106: 0000: \***    Version E.              Mark Walker               7th May 2014
3107: 0000: \***    F337 Centralised View of Stock
3108: 0000: \***    Added new 'stock flags' field for future use.
3109: 0000: \***
3110: 0000: \***********************************************************************
3111: 0000: \***********************************************************************
3112: 0000: 
3113: 0000: \***********************************************************************
3114: 0000: \***********************************************************************
3115: 0000: \***
3116: 0000: \***    File Record Layout
3117: 0000: \***
3118: 0000: \***    STOCK.BOOTS.CODE$            4 UPD  Item Code (Key)
3119: 0000: \***    STOCK.STOCK.FIG%             2 INT  Stock Figure
3120: 0000: \***    STOCK.LAST.COUNT%            2 INT  Last Count Quantity
3121: 0000: \***    STOCK.DATE.LAST.COUNT$       3 UPD  Date of Last Count
3122: 0000: \***    STOCK.DATE.LAST.MOVE$        3 UPD  Date of Last Movement
3123: 0000: \***    STOCK.LAST.REC%              2 INT  Last Receipt Quantity
3124: 0000: \***    STOCK.DATE.LAST.REC$         3 UPD  Date of Last Receipt
3125: 0000: \***    STOCK.DATE.LAST.GAP$         3 UPD  Date of Last Gap
3126: 0000: \***    STOCK.SID%                   4 INT  Sequence ID                     !CMW
3127: 0000: \***    STOCK.STATUS.1$              1 ASC  Item Status                     !CMW
3128: 0000: \***    STOCK.FLAGS%                 1 INT  Stock flags                     !EMW
3129: 0000: \***    STOCK.FILLER$                2 UPD  Filler                          !EMW
3130: 0000: \***
3131: 0000: \***********************************************************************
3132: 0000: \***********************************************************************
3133: 0000: 
3134: 0000:     INTEGER*1 GLOBAL                                                    \
3135: 0000:         STOCK.FLAGS%,                                                   \   !EMW
3136: 0000:         STOCK.RECL%
3137: 0000: 
3138: 0000:     INTEGER*2 GLOBAL                                                    \
3139: 0000:         STOCK.LAST.COUNT%,                                              \
3140: 0000:         STOCK.LAST.REC%,                                                \
3141: 0000:         STOCK.REPORT.NUM%,                                              \
3142: 0000:         STOCK.SESS.NUM%,                                                \
3143: 0000:         STOCK.STOCK.FIG%
3144: 0000: 
3145: 0000:     INTEGER*4 GLOBAL                                                    \   !CMW
3146: 0000:         STOCK.NEXT.SID%,                                                \   !DMW
3147: 0000:         STOCK.SID%                                                          !CMW
3148: 0000: 
3149: 0000:     STRING GLOBAL                                                       \
3150: 0000:         STOCK.BOOTS.CODE$,                                              \
3151: 0000:         STOCK.DATE.LAST.COUNT$,                                         \
3152: 0000:         STOCK.DATE.LAST.GAP$,                                           \
3153: 0000:         STOCK.DATE.LAST.MOVE$,                                          \
3154: 0000:         STOCK.DATE.LAST.REC$,                                           \
3155: 0000:         STOCK.FILE.NAME$,                                               \
3156: 0000:         STOCK.FILLER$,                                                  \
3157: 0000:         STOCK.STATUS.1$                                                     !CMW
3158: 0000: 
3159: 0000:  %INCLUDE IMSTCDEC.J86                    ! 1.7BG
3160: 0000: \***********************************************************************
3161: 0000: \***********************************************************************
3162: 0000: \***
3163: 0000: \***    DESCRIPTION: Item Movement & Stock File
3164: 0000: \***                 Field Definitions         
3165: 0000: \***
3166: 0000: \***    FILE TYPE : Keyed
3167: 0000: \***
3168: 0000: \***********************************************************************
3169: 0000: \***
3170: 0000: \***    Version A.          Les Cook                     21st Aug 1992
3171: 0000: \***    Initial version.
3172: 0000: \***
3173: 0000: \***    VERSION 1.1         Julia Stones                 13th Jun 2005
3174: 0000: \***    Added new external functions for
3175: 0000: \***        MIMSTC - merged IMSTC
3176: 0000: \***        CIMSTC - Copy of IMSTC
3177: 0000: \***        BIMSTC - Backup of IMSTC
3178: 0000: \***
3179: 0000: \***    Version C.          Mark Walker                  23rd Jan 2014
3180: 0000: \***    F337 Centralised View of Stock
3181: 0000: \***    - Added sequence ID field definition.
3182: 0000: \***    - Moved BIMST, CIMST and MIMST field definitions to separate
3183: 0000: \***      modules.
3184: 0000: \***    - Moved TIMST record length to TIMSTDEC.J86.
3185: 0000: \***    - Minor formatting changes (uncommented).
3186: 0000: \***
3187: 0000: \***    Version D.          Mark Walker                  30th Apr 2014
3188: 0000: \***    F337 Centralised View of Stock
3189: 0000: \***    QC599: Introduced item level TSL restart pointer to allow
3190: 0000: \***           Sales Support restart/recovery to continue processing
3191: 0000: \***           correctly from the next unprocessed item.
3192: 0000: \***
3193: 0000: \***********************************************************************
3194: 0000: \***********************************************************************
3195: 0000: 
3196: 0000: \***********************************************************************
3197: 0000: \***********************************************************************
3198: 0000: \***
3199: 0000: \***    File Record Layout
3200: 0000: \***
3201: 0000: \***    IMSTC.BAR.CODE$             11 UPD  Barcode (Key)
3202: 0000: \***    IMSTC.RESTART%               4 INT  IMSTC Restart pointer
3203: 0000: \***    IMSTC.NUMITEMS%              4 INT  Number of items sold
3204: 0000: \***    IMSTC.AMTSALE%               4 INT  Amount of items sold
3205: 0000: \***    IMSTC.TSL.RESTART%           4 INT  TSL Restart pointer             !DMW
3206: 0000: \***    IMSTC.STKMQ.RESTART%         4 INT  STKMQ Restart pointer
3207: 0000: \***    IMSTC.STATUS.FLAG$           1 ASC  Status flags
3208: 0000: \***    IMSTC.STOCK.FIGURE%          2 INT  Stock Figure
3209: 0000: \***    IMSTC.REASON.ITEM.REMOVED$   1 ASC  Deletion Reason
3210: 0000: \***    IMSTC.SID%                   4 INT  Sequence ID
3211: 0000: \***    IMSTC.FILLER$                1 UPD  Filler
3212: 0000: \***
3213: 0000: \***********************************************************************
3214: 0000: \***********************************************************************
3215: 0000: 
3216: 0000:     INTEGER*2 GLOBAL                                                    \
3217: 0000:         IMSTC.SESS.NUM%,                                                \
3218: 0000:         IMSTC.RECL%,                                                    \
3219: 0000:         IMSTC.REPORT.NUM%,                                              \
3220: 0000:         IMSTC.STOCK.FIGURE%
3221: 0000: 
3222: 0000:     INTEGER*4 GLOBAL                                                    \
3223: 0000:         IMSTC.AMTSALE%,                                                 \
3224: 0000:         IMSTC.NEXT.SID%,                                                \   !CMW
3225: 0000:         IMSTC.NUMITEMS%,                                                \
3226: 0000:         IMSTC.RESERVED%,                                                \
3227: 0000:         IMSTC.RESTART%,                                                 \
3228: 0000:         IMSTC.SID%,                                                     \   !CMW
3229: 0000:         IMSTC.STKMQ.RESTART%,                                           \
3230: 0000:         IMSTC.TSL.RESTART%                                                  !DMW
3231: 0000: 
3232: 0000:     STRING GLOBAL                                                       \
3233: 0000:         IMSTC.BAR.CODE$,                                                \
3234: 0000:         IMSTC.FILE.NAME$,                                               \
3235: 0000:         IMSTC.FILLER$,                                                  \
3236: 0000:         IMSTC.HOLD.PENDING$,                                            \
3237: 0000:         IMSTC.REASON.ITEM.REMOVED$,                                     \
3238: 0000:         IMSTC.STATUS.FLAG$
3239: 0000: 
3240: 0000:  %INCLUDE LSSSTDEC.J86                    ! 1.7BG
3241: 0000: REM \
3242: 0000: \******************************************************************************
3243: 0000: \******************************************************************************
3244: 0000: \***
3245: 0000: \***                 %INCLUDE FOR THE LSS STOCK COUNT FILE
3246: 0000: \***   
3247: 0000: \***                      FILE TYPE  :   Direct
3248: 0000: \***
3249: 0000: \***                      REFERENCE  :   LSSSTDEC.J86
3250: 0000: \***
3251: 0000: \***    Version A          Brian Greenfield          16th October 2002
3252: 0000: \***
3253: 0000: \******************************************************************************
3254: 0000: \*******************************************************************************
3255: 0000: 
3256: 0000:   STRING GLOBAL              \ 
3257: 0000:     LSSST.FILE.NAME$,        \
3258: 0000:     LSSST.IRF.BAR.CODE$,     \
3259: 0000:     LSSST.STOCK.BOOTS.CODE$, \
3260: 0000:     LSSST.STOCK.COUNT$,      \
3261: 0000:     LSSST.TSF$
3262: 0000:         
3263: 0000:   INTEGER*2 GLOBAL        \
3264: 0000:     LSSST.RECL%,          \            
3265: 0000:     LSSST.REPORT.NUM%,    \      
3266: 0000:     LSSST.SESS.NUM%
3267: 0000: 
3268: 0000:          
3269: 0000:  %INCLUDE SXTCFDEC.J86                    ! 1.8DA
3270: 0000: \******************************************************************************
3271: 0000: \******************************************************************************
3272: 0000: \***
3273: 0000: \***   $Workfile:   SXTCFDEC.J86  $
3274: 0000: \***
3275: 0000: \***   $Revision:   1.1  $
3276: 0000: \***
3277: 0000: \******************************************************************************
3278: 0000: \******************************************************************************
3279: 0000: \***
3280: 0000: \***   $Log:   V:\archive\j86\sxtcfdec.j8v  $
3281: 0000: \***   
3282: 0000: \***      Rev 1.1   07 Jan 1998 10:26:30   DEV69PS
3283: 0000: \***    
3284: 0000: \***   
3285: 0000: \***      Rev 1.0   15 Jul 1997 14:21:06   DEV45PS
3286: 0000: \***    
3287: 0000: \***   
3288: 0000: \***      Rev 1.1   15 Jul 1997 13:44:06   DEV45PS
3289: 0000: \***    
3290: 0000: \***   
3291: 0000: \***      Rev 1.0   09 Jul 1997 11:05:28   DEV45PS
3292: 0000: \***   Stocktake System New Files
3293: 0000: \***   
3294: 0000: \*** 
3295: 0000: \***   
3296: 0000: \******************************************************************************
3297: 0000: \******************************************************************************\*****************************************************************************
3298: 0000: \*****************************************************************************
3299: 0000: \***
3300: 0000: \***               %INCLUDE FOR SXTCF - FIELD DECLARATIONS
3301: 0000: \***                                    FILE REFERENCE PARAMETERS
3302: 0000: \***
3303: 0000: \***                      FILE TYPE    : DIRECT
3304: 0000: \***
3305: 0000: \***                      REFERENCE    : SXTCFDEC
3306: 0000: \***
3307: 0000: \***           VERSION A : NIK SEN  3rd July 1997
3308: 0000: \***
3309: 0000: \***
3310: 0000: 
3311: 0000: \*****************************************************************************
3312: 0000: \*****************************************************************************
3313: 0000: 
3314: 0000: 
3315: 0000:   STRING GLOBAL           \
3316: 0000:     SXTCF.FILE.NAME$
3317: 0000: 
3318: 0000:   INTEGER*1 GLOBAL        \
3319: 0000:     SXTCF.HEADER.EXPECTED%
3320: 0000: 
3321: 0000:   INTEGER*2 GLOBAL        \
3322: 0000:     SXTCF.SESS.NUM%,      \
3323: 0000:     SXTCF.REPORT.NUM%,    \
3324: 0000:     SXTCF.RECL%
3325: 0000: 
3326: 0000:   INTEGER*4 GLOBAL        \
3327: 0000:     SXTCF.REC.NUM%
3328: 0000: 
3329: 0000: 
3330: 0000:   INTEGER*4 GLOBAL                                   \
3331: 0000:             SXTCF.STKBF.POINTER%,                    \ Pointer to STKBF
3332: 0000:             SXTCF.ITEM.COUNT%,                       \ No of items processed
3333: 0000:             SXTCF.CURRENT.COUNT%                     ! Items in current batch
3334: 0000: 
3335: 0000: 
3336: 0000:   STRING GLOBAL                                 \
3337: 0000:        SXTCF.START.DATE$,                       \
3338: 0000:        SXTCF.START.TIME$,                       \
3339: 0000:        SXTCF.END.DATE$,                         \
3340: 0000:        SXTCF.END.TIME$,                         \
3341: 0000:        SXTCF.STOCKTAKE.IN.PROGRESS$,            \ Y=Yes; N=No; S=Stop; C=Complete 1 BYTE
3342: 0000:        SXTCF.STOCKTAKER$,                       \ Current Stocktaker
3343: 0000:        SXTCF.CUR.LOCATION$,                     \ Location code currently be processed ! 1.1
3344: 0000:        SXTCF.FILLER$                            \ 
3345: 0000: 
3346: 0000: 
3347: 0000:  %INCLUDE STKCFDEC.J86                    ! 1.8DA
3348: 0000: \******************************************************************************
3349: 0000: \******************************************************************************
3350: 0000: \***
3351: 0000: \***   $Workfile:   STKCFDEC.J86  $
3352: 0000: \***
3353: 0000: \***   $Revision:   1.2  $
3354: 0000: \***
3355: 0000: \******************************************************************************
3356: 0000: \******************************************************************************
3357: 0000: \***
3358: 0000: \***   $Log:   V:\archive\j86\stkcfdec.j8v  $
3359: 0000: \***   
3360: 0000: \***      Rev 1.2   03 Jul 1997 14:18:38   DEV45PS
3361: 0000: \***   Stocktake In Progress Flag Removed
3362: 0000: \***   
3363: 0000: \***      Rev 1.1   30 Jun 1997 15:29:04   DEV45PS
3364: 0000: \***   Added Stocktake In Progress flag
3365: 0000: \***   
3366: 0000: \******************************************************************************
3367: 0000: \******************************************************************************\*****************************************************************************
3368: 0000: \*****************************************************************************
3369: 0000: \***
3370: 0000: \***               %INCLUDE FOR STKCF - FIELD DECLARATIONS
3371: 0000: \***                                    FILE REFERENCE PARAMETERS
3372: 0000: \***
3373: 0000: \***                      FILE TYPE    : DIRECT
3374: 0000: \***
3375: 0000: \***                      REFERENCE    : STKCFDEA
3376: 0000: \***
3377: 0000: \***           VERSION A : STEVEN GOULDING  11.01.93
3378: 0000: \***
3379: 0000: \***
3380: 0000: \***           VERSION B        NIK SEN        5th June 1997
3381: 0000: \***           Added Stocktake.In.Progress flag.
3382: 0000: \***           
3383: 0000: \***           VERSION C        NIK SEN        3rd July 1997
3384: 0000: \***           Removed Stocktake.In.Progress flag. Now moved to Stocktake
3385: 0000: \***           Control File to prevent conflicts when STKCF is locked.
3386: 0000: \***
3387: 0000: \*****************************************************************************
3388: 0000: \*****************************************************************************
3389: 0000: 
3390: 0000: REM \
3391: 0000: 
3392: 0000:   STRING GLOBAL           \
3393: 0000:     STKCF.FILE.NAME$
3394: 0000: 
3395: 0000:   INTEGER*2 GLOBAL        \
3396: 0000:     STKCF.SESS.NUM%,      \
3397: 0000:     STKCF.REPORT.NUM%,    \
3398: 0000:     STKCF.RECL%
3399: 0000: 
3400: 0000:   INTEGER*4 GLOBAL        \
3401: 0000:     STKCF.REC.NUM%
3402: 0000: REM \
3403: 0000: 
3404: 0000: 
3405: 0000:   INTEGER*4 GLOBAL                                   \
3406: 0000:             STKCF.STKMQ.POINTER%,                    \ Pointer to STKMQ
3407: 0000:             STKCF.ITEM.COUNT%                        \ No of items processed
3408: 0000: 
3409: 0000:   INTEGER*2 GLOBAL                                   \
3410: 0000:             STKCF.STMVT.REC.CNT%                     \ No of recs on STMVT file
3411: 0000: 
3412: 0000:   INTEGER*1 GLOBAL                                   \
3413: 0000:             STKCF.PREV.PITRL.UPDATE%                 \ The HOUR of update
3414: 0000: 
3415: 0000:   STRING    GLOBAL                                   \ 1 BYTE
3416: 0000:             STKCF.STOCK.SUPPORT.STATUS$              \ Y = enabled
3417: 0000:                                                      \ N = disabled
3418: 0000:                                                      \ C = Not available to
3419: 0000:                                                      \         Screens
3420: 0000:                                                      \ T = Trailer written
3421: 0000:                                                      \ 1 - 7 According to
3422: 0000:                                                      \       which STKMQ backup
3423: 0000:                                                      \       done.
3424: 0000: 
3425: 0000:   STRING    GLOBAL                                   \
3426: 0000:   	    STKCF.LAST.DIRORD.BC$,	 	     \ Last BC processed
3427: 0000: 	    					     \ in type 17 (1 byte)
3428: 0000:   	    STKCF.LAST.DIRORD.SUPPLIER$,	     \ Last supplier processed
3429: 0000: 	    					     \ in type 17 (3 bytes UPD)
3430: 0000: 	    STKCF.LAST.DIRORD.ORDER.NO$,	     \ last order no processed
3431: 0000: 	    					     \ in type 17 (2 bytes UPD)
3432: 0000: 	    STKCF.LAST.DIRORD.ORDER.SUFFIX$,	     \ last order sfx processed
3433: 0000: 	    					     \ in type 17 (1 byte)
3434: 0000:   	    STKCF.LAST.DIRORD.REC.SOURCE$, 	     \ Last record source
3435: 0000: 	    					     \ in type 17 (1 byte)
3436: 0000:        STKCF.STK.FILE.AVAIL$,                   \ Y=Yes; N=No; 1 BYTE
3437: 0000:        STKCF.STOCK.TAKE.PROCESSING.REQUIRED$,   \ Y=Yes; N=No; 1 BYTE
3438: 0000:        STKCF.FILLER$                            \ 
3439: 0000: 
3440: 0000: 
3441: 0000:  %INCLUDE STKMFDEC.J86                    ! 1.8DA
3442: 0000: \******************************************************************************
3443: 0000: \******************************************************************************
3444: 0000: \***
3445: 0000: \***   $Workfile:   STKMFDEC.J86  $
3446: 0000: \***
3447: 0000: \***   $Revision:   1.0  $
3448: 0000: \***
3449: 0000: \******************************************************************************
3450: 0000: \******************************************************************************
3451: 0000: \***
3452: 0000: \***   $Log:   V:\archive\j86\stkmfdec.j8v  $
3453: 0000: \***   
3454: 0000: \***      Rev 1.0   15 Jul 1997 14:20:54   DEV45PS
3455: 0000: \***    
3456: 0000: \***   
3457: 0000: \***      Rev 1.0   09 Jul 1997 11:05:16   DEV45PS
3458: 0000: \***   Stocktake System New Files
3459: 0000: \***   
3460: 0000: \******************************************************************************
3461: 0000: \******************************************************************************\******************************************************************************
3462: 0000: \******************************************************************************
3463: 0000: \***
3464: 0000: \***  %INCLUDES FOR STOCKTAKE MAONFRAME TRANSMISSION FILE FIELD DECLARATIONS
3465: 0000: \***
3466: 0000: \***               FILE TYPE    : DIRECT
3467: 0000: \***
3468: 0000: \***               REFERENCE    : STKMFDEC.J86
3469: 0000: \***
3470: 0000: \***    VERSION A.              Nik Sen.               19 Jun 1997.
3471: 0000: \***    New file for stocktaking system. Holds stocktake data for 
3472: 0000: \***    transmission to the maonframe.
3473: 0000: \***
3474: 0000: \*******************************************************************************
3475: 0000: \*******************************************************************************
3476: 0000: 
3477: 0000: STRING GLOBAL                                                  \
3478: 0000:        STKMF.FILE.NAME$,               \
3479: 0000:        STKMF.DATA$,                    \
3480: 0000:        STKMF.STORE.NUMBER$,            \
3481: 0000:        STKMF.STOCKTAKER.NUM$,          \
3482: 0000:        STKMF.FILLER$,                  \
3483: 0000:        STKMF.DELIMITER$,               \
3484: 0000:        STKMF.DATE$,                    \
3485: 0000:        STKMF.LOCATION$,                \
3486: 0000:        STKMF.ITEM.CODE$,               \
3487: 0000:        STKMF.QUANTITY$,                \
3488: 0000:        STKMF.PRICE$,                   \
3489: 0000:        STKMF.RECORD.COUNT$
3490: 0000:                        
3491: 0000: INTEGER*4 GLOBAL               \
3492: 0000:        STKMF.RECORD.NUM%
3493: 0000: 
3494: 0000: INTEGER*2 GLOBAL                \
3495: 0000:    STKMF.REPORT.NUM%,           \
3496: 0000:    STKMF.SESS.NUM%             
3497: 0000: 
3498: 0000: 
3499: 0000: INTEGER*1 GLOBAL                \
3500: 0000:    STKMF.RECL%         
3501: 0000: 
3502: 0000: 
3503: 0000:  %INCLUDE STKRCDEC.J86                    ! 1.8DA
3504: 0000: \******************************************************************************
3505: 0000: \******************************************************************************
3506: 0000: \***
3507: 0000: \***   $Workfile:   STKRCDEC.J86  $
3508: 0000: \***
3509: 0000: \***   $Revision:   1.1  $
3510: 0000: \***
3511: 0000: \******************************************************************************
3512: 0000: \******************************************************************************
3513: 0000: \***
3514: 0000: \***   $Log:   V:\archive\j86\stkrcdec.j8v  $
3515: 0000: \***   
3516: 0000: \***      Rev 1.1   03 Feb 1998 10:06:02   DEV69PS
3517: 0000: \***    
3518: 0000: \***   
3519: 0000: \***      Rev 1.0   15 Jul 1997 14:20:58   DEV45PS
3520: 0000: \***    
3521: 0000: \***   
3522: 0000: \***      Rev 1.0   09 Jul 1997 11:05:22   DEV45PS
3523: 0000: \***   Stocktake System New Files
3524: 0000: \***   
3525: 0000: \******************************************************************************
3526: 0000: \******************************************************************************\******************************************************************************
3527: 0000: \******************************************************************************
3528: 0000: \***
3529: 0000: \***         %INCLUDE FOR STOCKTAKE RECOUNT FILE FIELD DECLARATIONS
3530: 0000: \***
3531: 0000: \***               FILE TYPE    : DIRECT
3532: 0000: \***
3533: 0000: \***               REFERENCE    : STKRCDEC.J86
3534: 0000: \***
3535: 0000: \***    VERSION A.              Nik Sen.               19 Jun 1997.
3536: 0000: \***    New file for stocktaking system. Holds all items where a recount
3537: 0000: \***    has occurred.
3538: 0000: \***
3539: 0000: \*******************************************************************************
3540: 0000: \*******************************************************************************
3541: 0000: 
3542: 0000: STRING GLOBAL                                                  \
3543: 0000:        STKRC.FILE.NAME$,               \
3544: 0000:        STKRC.ITEM.CODE$,               \
3545: 0000:        STKRC.ITEM.DESCRIPTION$,        \
3546: 0000:        STKRC.LOCATION$,                \
3547: 0000:        STKRC.INITIAL.QUANTITY$,        \
3548: 0000:        STKRC.INITIAL.STOCKTAKER$,      \
3549: 0000:        STKRC.FINAL.QUANTITY$,          \
3550: 0000:        STKRC.FINAL.STOCKTAKER$
3551: 0000: 
3552: 0000: INTEGER*4 GLOBAL               \     !1.1
3553: 0000:        STKRC.RECORD.NUM%
3554: 0000: 
3555: 0000: 
3556: 0000: INTEGER*2 GLOBAL                \
3557: 0000:    STKRC.REPORT.NUM%,           \
3558: 0000:    STKRC.SESS.NUM%             
3559: 0000: 
3560: 0000: 
3561: 0000: INTEGER*1 GLOBAL                \
3562: 0000:    STKRC.LOC.CNT%,              \     
3563: 0000:    STKRC.RECL%         
3564: 0000: 
3565: 0000: 
3566: 0000:  %INCLUDE XGCFDEC.J86                     ! 1.8DA
3567: 0000: \******************************************************************************
3568: 0000: \******************************************************************************
3569: 0000: \***
3570: 0000: \***         %INCLUDE FOR STOCKTAKE GROUP CODE FILE
3571: 0000: \***
3572: 0000: \***                  FILE TYPE    : Keyed
3573: 0000: \***
3574: 0000: \***                  REFERENCE    : XGCFDEC.J86
3575: 0000: \***
3576: 0000: \***    VERSION A               Steve Wright                        24 Aug 1999
3577: 0000: \***
3578: 0000: \*******************************************************************************
3579: 0000: \*******************************************************************************
3580: 0000: 
3581: 0000: STRING GLOBAL           \
3582: 0000:    XGCF.FILE.NAME$,     \
3583: 0000:    XGCF.PRODUCT.GRP$,   \  Redundant - key changed from product group to BC
3584: 0000:    XGCF.BAR.CODE$,      \
3585: 0000:    XGCF.BSNS.CNTR$,     \  New key - 1 byte business centre
3586: 0000:    XGCF.RSRVD$          !  New key - 2 byte filler, must be 0x0000 (set by function)
3587: 0000: 
3588: 0000: INTEGER*2 GLOBAL        \
3589: 0000:    XGCF.RECL%,          \  
3590: 0000:    XGCF.REPORT.NUM%,    \ 
3591: 0000:    XGCF.SESS.NUM%
3592: 0000:  %INCLUDE STKEXDEC.J86                    ! 1.8DA
3593: 0000: \******************************************************************************
3594: 0000: \******************************************************************************
3595: 0000: \***
3596: 0000: \***   $Workfile:   STKEXDEC.J86  $
3597: 0000: \***
3598: 0000: \***   $Revision:   1.1  $
3599: 0000: \***
3600: 0000: \******************************************************************************
3601: 0000: \******************************************************************************
3602: 0000: \***
3603: 0000: \***   $Log:   V:\archive\j86\stkexdec.j8v  $
3604: 0000: \***   
3605: 0000: \***      Rev 1.1   05 Aug 1997 13:49:18   DEV45PS
3606: 0000: \***   Added Reason Code
3607: 0000: \***   
3608: 0000: \***      Rev 1.0   15 Jul 1997 14:20:44   DEV45PS
3609: 0000: \***    
3610: 0000: \***   
3611: 0000: \***      Rev 1.0   09 Jul 1997 11:05:04   DEV45PS
3612: 0000: \***   Stocktake System New Files
3613: 0000: \***   
3614: 0000: \******************************************************************************
3615: 0000: \******************************************************************************\******************************************************************************
3616: 0000: \******************************************************************************
3617: 0000: \***
3618: 0000: \***         %INCLUDE FOR STOCKTAKE EXCEPTIONS FILE FIELD DECLARATIONS
3619: 0000: \***
3620: 0000: \***               FILE TYPE    : DIRECT
3621: 0000: \***
3622: 0000: \***               REFERENCE    : STKEXDEC.J86
3623: 0000: \***
3624: 0000: \***    VERSION A.              Nik Sen.               19 Jun 1997.
3625: 0000: \***    New file for stocktaking system. Holds all counted items which  
3626: 0000: \***    are not on the IDF.
3627: 0000: \***
3628: 0000: \***    VERSION B              Nik Sen                 5th August 1997
3629: 0000: \***    Added reason code.
3630: 0000: \***
3631: 0000: \*******************************************************************************
3632: 0000: \*******************************************************************************
3633: 0000: 
3634: 0000: STRING GLOBAL                                                  \
3635: 0000:    STKEX.FILE.NAME$,            \
3636: 0000:    STKEX.ITEM.CODE$,           \
3637: 0000:    STKEX.QUANTITY$,            \
3638: 0000:    STKEX.LOCATION$,            \
3639: 0000:    STKEX.STOCKTAKER.NUM$,      \
3640: 0000:    STKEX.REASON.CODE$
3641: 0000: 
3642: 0000: 
3643: 0000: INTEGER*4 GLOBAL               \
3644: 0000:        STKEX.RECORD.NUM%
3645: 0000: 
3646: 0000: INTEGER*2 GLOBAL                \
3647: 0000:    STKEX.REPORT.NUM%,           \
3648: 0000:    STKEX.SESS.NUM%             
3649: 0000: 
3650: 0000: 
3651: 0000: INTEGER*1 GLOBAL                \
3652: 0000:    STKEX.RECL%         
3653: 0000: 
3654: 0000: 
3655: 0000:  %INCLUDE STKIFDEC.J86                    ! 1.8DA
3656: 0000: \******************************************************************************
3657: 0000: \******************************************************************************
3658: 0000: \***
3659: 0000: \***   $Workfile:   STKIFDEC.J86  $
3660: 0000: \***
3661: 0000: \***   $Revision:   1.2  $
3662: 0000: \***
3663: 0000: \******************************************************************************
3664: 0000: \******************************************************************************
3665: 0000: \***
3666: 0000: \***   $Log:   V:\archive\j86\stkifdec.j8v  $
3667: 0000: \***   
3668: 0000: \***      Rev 1.2   21 Aug 1997 11:20:56   DEV45PS
3669: 0000: \***    
3670: 0000: \***   
3671: 0000: \***      Rev 1.1   19 Aug 1997 11:06:14   DEV45PS
3672: 0000: \***   Added Stocktake Transmission File Record Number Field
3673: 0000: \***   
3674: 0000: \***      Rev 1.0   15 Jul 1997 14:20:48   DEV45PS
3675: 0000: \***    
3676: 0000: \***   
3677: 0000: \***      Rev 1.0   09 Jul 1997 11:05:10   DEV45PS
3678: 0000: \***   Stocktake System New Files
3679: 0000: \***   
3680: 0000: \******************************************************************************
3681: 0000: \******************************************************************************\******************************************************************************
3682: 0000: \******************************************************************************
3683: 0000: \***
3684: 0000: \***         %INCLUDE FOR STOCKTAKE ITEM FILE FIELD DECLARATIONS
3685: 0000: \***
3686: 0000: \***               FILE TYPE    : KEYED
3687: 0000: \***
3688: 0000: \***               REFERENCE    : STKIFDEC.J86
3689: 0000: \***
3690: 0000: \***    VERSION A.              Nik Sen.               19 Jun 1997.
3691: 0000: \***    New file for stocktaking system. Holds information about all counted
3692: 0000: \***    items found on the STOCK and IDF files. Key is Boots Code + Location 
3693: 0000: \***
3694: 0000: \***    VERSION B               Nik Sen                19 August 1997
3695: 0000: \***    Added STKMF Record Number field.
3696: 0000: \***
3697: 0000: \*******************************************************************************
3698: 0000: \*******************************************************************************
3699: 0000: 
3700: 0000: STRING GLOBAL                                                  \
3701: 0000:        STKIF.FILE.NAME$,               \
3702: 0000:        STKIF.KEY$,                     \
3703: 0000:        STKIF.ITEM.CODE$,               \
3704: 0000:        STKIF.LOCATION$,                \
3705: 0000:        STKIF.BUSINESS.CENTRE$,         \
3706: 0000:        STKIF.GROUP.SEQUENCE$,          \
3707: 0000:        STKIF.QUANTITY$,                \
3708: 0000:        STKIF.DESCRIPTION$,             \
3709: 0000:        STKIF.STOCKTAKER.NUM$
3710: 0000: 
3711: 0000: 
3712: 0000: 
3713: 0000: INTEGER*2 GLOBAL                \
3714: 0000:    STKIF.REPORT.NUM%,           \
3715: 0000:    STKIF.SESS.NUM%             
3716: 0000: 
3717: 0000: 
3718: 0000: INTEGER*1 GLOBAL                \
3719: 0000:    STKIF.RECL%         
3720: 0000: 
3721: 0000: INTEGER*4 GLOBAL                \
3722: 0000:    STKIF.STKMF.RECORD.NUM%
3723: 0000: 
3724: 0000: 
3725: 0000: 
3726: 0000:  %INCLUDE LOCNTDEC.J86                    ! 1.8DA
3727: 0000: \******************************************************************************
3728: 0000: \******************************************************************************
3729: 0000: \***
3730: 0000: \***   $Workfile:   LOCNTDEC.J86  $
3731: 0000: \***
3732: 0000: \***   $Revision:   1.0  $
3733: 0000: \***
3734: 0000: \******************************************************************************
3735: 0000: \******************************************************************************
3736: 0000: \***
3737: 0000: \***   $Log:   V:\archive\j86\locntdec.j8v  $
3738: 0000: \***   
3739: 0000: \***      Rev 1.0   03 Feb 1998 10:07:40   DEV69PS
3740: 0000: \***    
3741: 0000: \***   
3742: 0000: \******************************************************************************
3743: 0000: \******************************************************************************
3744: 0000: \***
3745: 0000: \***         %INCLUDE FOR STOCKTAKE LOCATION COUNTERS (LOCCNT) DECLARATIONS
3746: 0000: \***
3747: 0000: \***               FILE TYPE    : DIRECT
3748: 0000: \***
3749: 0000: \***               REFERENCE    : LOCNTDEC.J86
3750: 0000: \***
3751: 0000: \***    VERSION A.              Johnnie Chan           6th Jan 1998
3752: 0000: \***    New file for stocktaking system. Holds all locations counted using
3753: 0000: \***    1st to 10000th record for S0000-S9999 and 10001st to 20000th record
3754: 0000: \***    for B0000-B9999.
3755: 0000: \***
3756: 0000: \*******************************************************************************
3757: 0000: \*******************************************************************************
3758: 0000: 
3759: 0000: STRING GLOBAL                           \
3760: 0000:        LOCCNT.FILE.NAME$
3761: 0000:        
3762: 0000: INTEGER*4 GLOBAL                        \
3763: 0000:        LOCCNT.RECORD.NUM%
3764: 0000: 
3765: 0000: 
3766: 0000: INTEGER*2 GLOBAL                        \
3767: 0000:        LOCCNT.REPORT.NUM%,              \
3768: 0000:        LOCCNT.SESS.NUM%             
3769: 0000: 
3770: 0000: 
3771: 0000: INTEGER*1 GLOBAL                        \
3772: 0000:        LOCCNT.LOCATION.COUNT%,          \
3773: 0000:        LOCCNT.RECL%         
3774: 0000: 
3775: 0000: 
3776: 0000:  %INCLUDE STKIGDEC.J86                    ! 1.8DA
3777: 0000: \******************************************************************************
3778: 0000: \******************************************************************************
3779: 0000: \***
3780: 0000: \***         %INCLUDE FOR STOCKTAKE ITEM GROUP FIELD DECLARATIONS
3781: 0000: \***
3782: 0000: \***               FILE TYPE    : DIRECT
3783: 0000: \***
3784: 0000: \***               REFERENCE    : STKIGDEC.J86
3785: 0000: \***
3786: 0000: \***    VERSION A.              Nik Sen.               17 Jun 1997.
3787: 0000: \***    New file for stocktaking system. Holds Business Centres, Concept
3788: 0000: \***    and product groups which define scope of stocktake.
3789: 0000: \***
3790: 0000: \*******************************************************************************
3791: 0000: \*******************************************************************************
3792: 0000: 
3793: 0000: STRING GLOBAL                                                  \
3794: 0000:    STKIG.FILE.NAME$,            \
3795: 0000:    STKIG.DATA$
3796: 0000: 
3797: 0000: INTEGER*4 GLOBAL               \
3798: 0000:    STKIG.RECORD.NUM%
3799: 0000: 
3800: 0000: INTEGER*2 GLOBAL                \
3801: 0000:    STKIG.REPORT.NUM%,           \
3802: 0000:    STKIG.SESS.NUM%             
3803: 0000: 
3804: 0000: 
3805: 0000: INTEGER*1 GLOBAL                \
3806: 0000:    STKIG.RECL%         
3807: 0000: 
3808: 0000: 
3809: 0000:  %INCLUDE STKTFDEC.J86                    ! 1.8DA
3810: 0000: \******************************************************************************
3811: 0000: \******************************************************************************
3812: 0000: \***
3813: 0000: \***   $Workfile:   STKTFDEC.J86  $
3814: 0000: \***
3815: 0000: \***   $Revision:   1.1  $
3816: 0000: \***
3817: 0000: \******************************************************************************
3818: 0000: \******************************************************************************
3819: 0000: \***
3820: 0000: \***   $Log:   V:\archive\j86\stktfdec.j8v  $
3821: 0000: \***   
3822: 0000: \***      Rev 1.1   15 Jul 1997 14:36:28   DEV45PS
3823: 0000: \***    
3824: 0000: \***   
3825: 0000: \***      Rev 1.0   15 Jul 1997 14:21:02   DEV45PS
3826: 0000: \***   Stocktake System New Files
3827: 0000: \***   
3828: 0000: \******************************************************************************
3829: 0000: \******************************************************************************\******************************************************************************
3830: 0000: \******************************************************************************
3831: 0000: \***
3832: 0000: \***         %INCLUDE FOR STOCKTAKE TOTALS FILE FIELD DECLARATIONS
3833: 0000: \***
3834: 0000: \***               FILE TYPE    : KEYED
3835: 0000: \***
3836: 0000: \***               REFERENCE    : STKTFDEC.J86
3837: 0000: \***
3838: 0000: \***    VERSION A.              Nik Sen.               15 July 1997.
3839: 0000: \***    New file for stocktaking system. Holds information about all counted
3840: 0000: \***    items found on the STOCK and IDF files. Key is Boots Code. 
3841: 0000: \***
3842: 0000: \*******************************************************************************
3843: 0000: \*******************************************************************************
3844: 0000: 
3845: 0000: STRING GLOBAL                                                  \
3846: 0000:        STKTF.FILE.NAME$,               \
3847: 0000:        STKTF.BOOTS.CODE$,              \
3848: 0000:        STKTF.BUSINESS.CENTRE$,         \
3849: 0000:        STKTF.GROUP.SEQUENCE$,          \
3850: 0000:        STKTF.QUANTITY$                
3851: 0000: 
3852: 0000: 
3853: 0000: 
3854: 0000: INTEGER*2 GLOBAL                \
3855: 0000:    STKTF.REPORT.NUM%,           \
3856: 0000:    STKTF.SESS.NUM%             
3857: 0000: 
3858: 0000: 
3859: 0000: INTEGER*1 GLOBAL                \
3860: 0000:    STKTF.RECL%         
3861: 0000: 
3862: 0000: 
3863: 0000:  %INCLUDE IRFDEC.J86                      ! 1.8DA
3864: 0000: 
3865: 0000: \**********************************************************************************
3866: 0000: \***
3867: 0000: \***       %INCLUDE FOR ITEM RECORD FILE - FIELD DECLARATIONS
3868: 0000: \***                                     - FILE REFERENCE PARAMETERS
3869: 0000: \***
3870: 0000: \***                      FILE TYPE    : Keyed
3871: 0000: \***
3872: 0000: \***                      REFERENCE    : IRFDEC.J86
3873: 0000: \***
3874: 0000: \***     Version A               Andrew Wedgeworth            29th June 1992
3875: 0000: \***
3876: 0000: \***     Version B               Andrew Wedgeworth        14th December 1992
3877: 0000: \***     Version letter incremented to match other IRF code.
3878: 0000: \***
3879: 0000: \***     Version C             Steve Windsor          12.02.93
3880: 0000: \***     Version letter incremented to match other IRF code.
3881: 0000: \***
3882: 0000: \***     Version D             Steve Windsor          12.05.93
3883: 0000: \***     Version letter incremented to match other IRF code.
3884: 0000: \***
3885: 0000: \***     Version E           Steve Perkins       20th September 1993
3886: 0000: \***     Deals project : Handling of Converted/Unconverted records
3887: 0000: \***     ++   Anything with 'Delete' after initials should be   ++
3888: 0000: \***     ++   deleted once the IRF has been converted in all    ++
3889: 0000: \***     ++   stores.                                           ++
3890: 0000: \***
3891: 0000: \***     Version F           Mark Walker            5th January 1994
3892: 0000: \***     Version letter incremented to match other IRF code.
3893: 0000: \***
3894: 0000: \***     Version 96A         Mark Walker               22nd May 1995
3895: 0000: \***     Definition for IRF.POINTS% added.
3896: 0000: \***
3897: 0000: \***                     Stuart McConnachie           12th June 1995
3898: 0000: \***     INDICAT3% comments added for discount/loyalty flags.
3899: 0000: \***
3900: 0000: \***     Version for 96C  Andrew Wedgeworth            22nd May 1996
3901: 0000: \***     Removed IRF.FILLER$ field, as this is now redundant.
3902: 0000: \***
3903: 0000: \***     Version G     Stuart William McConnachie      11th February 2000
3904: 0000: \***     Converted IRF.INDICAT2$ to integer flag byte.
3905: 0000: \***
3906: 0000: \***     REVISION 1.6.               ROBERT COWEY.               9 JUL 2002.
3907: 0000: \***     Major changes for 2002 Deals Rewrite project.
3908: 0000: \***     Incorporated up to date record layout to assist development work
3909: 0000: \***     (placed in the IRFDEC.J86 to make it visible from ...LST files).
3910: 0000: \***     Moved various comments against variables to record layout.
3911: 0000: \***     Relisted variables in alphabetical order.
3912: 0000: \***     Deleted redundant variables associated with the old deals system ...
3913: 0000: \***     DEAL.NUM$, DEAL.SAVING$
3914: 0000: \***     Retained variables that are otherwise redundant (to be set to null X'00'
3915: 0000: \***     within file functions) ...
3916: 0000: \***     INDICAT2%, INDICAT4%, SALEQUAN$, POINTS%
3917: 0000: \***     Defined variables to hold interpreted deals data for new deals system ...
3918: 0000: \***     DEAL.NUM$(n) and LIST.ID%(n) (where 'n' represents entry 0, 1 and 2).
3919: 0000: \***     These two variables are interpretations of DEAL.DATA% which is defined
3920: 0000: \***     locally within IRFFUN.BAS to keep underlying data invisible to programs.
3921: 0000: \***
3922: 0000: \***     REVISION 1.7                ROBERT COWEY.               5 AUG 2002.
3923: 0000: \***     Further changes for 2002 Deals Rewrite project (PSBF19 related).
3924: 0000: \***     Defined NEW.IRF.DATA$ as a global variable for use with new functions
3925: 0000: \***     CONCAT.NEW.IRF.DATA$ and SPLIT.NEW.IRF.DATA$.
3926: 0000: \***
3927: 0000: \***     REVISION 1.8                ROBERT COWEY.              15 JUL 2003.
3928: 0000: \***     Usage of INDICAT0% bit-3 X'08' changed to Item Contains Alcohol.
3929: 0000: \***     No changes to this file other than description.
3930: 0000: \***     No changes to IRF file functions.
3931: 0000: \***
3932: 0000: \***     REVISION 1.9.      STUART WILLIAM MCCONNACHIE           22 OCT 2003.
3933: 0000: \***     Changes to remove limit of 3 deals per item.
3934: 0000: \***     Declaration of new variables for IRF Deal Extension file (IRFDEX).
3935: 0000: \***
3936: 0000: \***     REVISION 2.0.            ALAN CARR                       9 FEB 2006.
3937: 0000: \***     Add new IRF.INDICAT8% 1 byte, amend IRF.UNUSED$ from 3 to 2 bytes.
3938: 0000: \***
3939: 0000: \***     REVISION 2.1              TITTOO THOMAS                  01 July 2011
3940: 0000: \***     The IRF.UNUSED field is disintegrated to 2 new indicator fields
3941: 0000: \***                      IRF.INDICAT9%   1 INT
3942: 0000: \***                      IRF.INDICAT10%  1 INT
3943: 0000: \***...............................................................................
3944: 0000: 
3945: 0000: 
3946: 0000: \**********************************************************************************
3947: 0000: \***
3948: 0000: \***    IRF RECORD LAYOUT - REVISION 1.7 - CORRECT FOR 2011 CORE Stores PROJECT
3949: 0000: \***
3950: 0000: \***     1 11  UPD  BAR.CODE$   Without check digit - File KEY
3951: 0000: \***    12  1  INT  INDICAT0%
3952: 0000: \***                    X"01" - Contains statins                           ! 2.2 TT
3953: 0000: \***                    X"02" - Item not priced (giveaway)
3954: 0000: \***                    X"04" - Item not returnable
3955: 0000: \***                    X"08" - Item contains alcohol
3956: 0000: \***                    X"10" - Blocked from sale                          ! 2.2 TT
3957: 0000: \***                    X"20" - Enforced price entry
3958: 0000: \***                    X"40" - Enforced quantity entry
3959: 0000: \***                    X"80" - Movement kept
3960: 0000: \***    13  1  INT  INDICAT1%
3961: 0000: \***                    X"01" - Asprin
3962: 0000: \***                    X"02" - Paracetamol
3963: 0000: \***                    X"04" - TPLU inclusion flag
3964: 0000: \***                    X"08" - Giftcard item                              ! 2.2 TT
3965: 0000: \***                    X"10" - Withdrawn Block from sale                  ! 2.2 TT
3966: 0000: \***                    X"20" - Non-solid dose painkiller                  ! 2.2 TT
3967: 0000: \***                    X"40" - Insurance policy item                      ! 2.2 TT
3968: 0000: \***                    X"80" - Ibuprofen
3969: 0000: \***    14  2  INT  DEAL.DATA%(0)   Interpreted into sub-variables ...
3970: 0000: \***                    X'3F' - into DEAL.NUM$(0) "0000" to "9999" (2 byte UPD)
3971: 0000: \***                    X'C0' - into LIST.ID%(0) X'00' X
3972: 0000: \***                                             X'01' A
3973: 0000: \***                                             X'10' B
3974: 0000: \***                                             X'11' C                   ! 1.9 RC
3975: 0000: \***    16  1  INT  INDICAT8%                                              ! 2.0 AJC
3976: 0000: \***                    X"01" - Chlamydia NHS test kit                     ! 2.2 TT
3977: 0000: \***                    X"02" - Chlamydia open sell test kit               ! 2.2 TT
3978: 0000: \***                    X"04" - Unrestricted group code                    ! 2.2 TT
3979: 0000: \***                    X"08" - Nightingale Till prompt                    ! 2.2 TT
3980: 0000: \***                    X"10" - Contains Ephedrine                         ! 2.2 TT
3981: 0000: \***                    X"60" -  X'00' - If also Blocked From Sale Recall, ! 2.2 TT
3982: 0000: \***                                        Emergency                      ! 2.2 TT
3983: 0000: \***                             X'00' - If NOT Blocked From Sale Recall,  ! 2.2 TT
3984: 0000: \***                                        No recall                      ! 2.2 TT
3985: 0000: \***                             X'20' 100% returns                        ! 2.2 TT
3986: 0000: \***                             X'40' Withdrawn recall                    ! 2.2 TT
3987: 0000: \***                             X'60' Reverse Logistics                   ! 2.2 TT
3988: 0000: \***                    X"80" - WEEE item flag                             ! 2.0 AJC
3989: 0000: \***    17  1  INT  INDICAT9%
3990: 0000: \***                    X'3F' - Disposal special instruction (0-63)
3991: 0000: \***                    X"40" - Resaleable Indicator
3992: 0000: \***                    X"80" - Boots.com Extended Indicator
3993: 0000: \***    18  1  INT  INDICAT10%
3994: 0000: \***                    X'07' - Age restrictions
3995: 0000: \***                             X'00' - No Age restriction
3996: 0000: \***                             X'01' - Age 12 or over
3997: 0000: \***                             X'02' - Age 15 or over
3998: 0000: \***                             X'03' - Age 16 or over
3999: 0000: \***                             X'04' - Age 18 or over
4000: 0000: \***                             X'05' - Age 21 or over
4001: 0000: \***                             X'06' - Reserved
4002: 0000: \***                             X'07' - Reserved
4003: 0000: \***                    X'38' - Ethical classification
4004: 0000: \***                             X'00' - No ethical classification
4005: 0000: \***                             X'08' - Pharmacy medicine (P)
4006: 0000: \***                             X'10' - General Sale License (GSL)
4007: 0000: \***                             X'18' - Prescription Only Medicine (POM)
4008: 0000: \***                             X'20' - Reserved
4009: 0000: \***                             X'28' - Reserved
4010: 0000: \***                             X'30' - Reserved
4011: 0000: \***                             X'38' - Reserved
4012: 0000: \***                    X'C0' - Returns route
4013: 0000: \***                             X'00' - Not Returnable (Destroy)
4014: 0000: \***                             X'40' - Returns & Recovery
4015: 0000: \***                             X'80' - Direct
4016: 0000: \***                             X'C0' - Semi-centralised
4017: 0000: \***    19  5  UPD  SALEPRIC$   Current price in pence
4018: 0000: \***    24  1  INT  INDICAT5%   Guarantee duration
4019: 0000: \***                    X'3F' - Lowest 6 bits indicate duration (1-63)
4020: 0000: \***                    X'40' - Contains Pseudoephedrine                   ! 2.2 TT
4021: 0000: \***                    X'80' - Guarantee Duration Type                    ! 2.2 TT
4022: 0000: \***                              (1 = Months, 0 = Years)                  ! 2.2 TT
4023: 0000: \***    25 18  ASC  ITEMNAME$   Description used by till
4024: 0000: \***    43  3  UPD  BOOTS.CODE$ Without check digit
4025: 0000: \***    46  2  INT  DEAL.DATA%(1)   Similar structure to DEAL.DATA%(0)
4026: 0000: \***    48  2  INT  DEAL.DATA%(2)   Similar structure to DEAL.DATA%(0)
4027: 0000: \***    50  1  INT  INDICAT3%
4028: 0000: \***                    X"01" - Discountexempt (item exempt from discount)
4029: 0000: \***                    X"02" - Boots brand item
4030: 0000: \***                    X"04" - Item redeemable for loyalty
4031: 0000: \***                    X"08" - Loyalty exempt (item exempt from loyalty)
4032: 0000: \***                    X"10" - **Redundant                                ! 2.2 TT
4033: 0000: \***                    X"20" - Local Price active
4034: 0000: \***                    X"40" - Stock system item
4035: 0000: \***                    X"80" - **Redundant                                ! 2.2 TT
4036: 0000: \***
4037: 0000: \***    Record Length 50
4038: 0000: \***
4039: 0000: \***
4040: 0000: \***    IRF DEAL EXTENSION RECORD LAYOUT ! 1.9 RC
4041: 0000: \***
4042: 0000: \***     1  3  UPD  BOOTS.CODE$
4043: 0000: \***     4  2  INT  IRF.DEAL.DATA%(3)   Similar structure to DEAL.DATA%(0)
4044: 0000: \***     6  2  INT  IRF.DEAL.DATA%(4)   Similar structure to DEAL.DATA%(0)
4045: 0000: \***     8  2  INT  IRF.DEAL.DATA%(5)   Similar structure to DEAL.DATA%(0)
4046: 0000: \***    10  2  INT  IRF.DEAL.DATA%(6)   Similar structure to DEAL.DATA%(0)
4047: 0000: \***    12  2  INT  IRF.DEAL.DATA%(7)   Similar structure to DEAL.DATA%(0)
4048: 0000: \***    14  2  INT  IRF.DEAL.DATA%(8)   Similar structure to DEAL.DATA%(0)
4049: 0000: \***    16  2  INT  IRF.DEAL.DATA%(9)   Similar structure to DEAL.DATA%(0)
4050: 0000: \***
4051: 0000: \***    Record Length 17
4052: 0000: \***
4053: 0000: \**********************************************************************************
4054: 0000: 
4055: 0000: 
4056: 0000:     STRING GLOBAL            \
4057: 0000:         IRF.ALT.FILE.NAME$,  \
4058: 0000:         IRF.BAR.CODE$,       \
4059: 0000:         IRF.BOOTS.CODE$,     \
4060: 0000:         IRF.DEAL.SAVING$,    \ 2 byte - deal saving amount (0 - 99.99) ! ESP
4061: 0000:         IRF.DEPARTME$,       \ 3 byte UPD. Department number          ! ESP Delete
4062: 0000:         IRF.FILE.NAME$,      \
4063: 0000:         IRF.HOLDING.PRICE$,  \ 4 byte UPD. Current H.O. price in pence if a local
4064: 0000:                              \ price is in effect, zero otherwise.     ! ESP Delete
4065: 0000:         IRF.ITEMNAME$,       \
4066: 0000: \       IRF.MPGROUP$,        \ Removed SBH 31/1/96
4067: 0000:         IRF.RECORD$,         \                                         ! ESP Delete
4068: 0000:         IRF.SALEPRIC$,       \
4069: 0000:         IRF.SALEQUAN$,       \ Redundant (set to null within functions)    ! 1.6 RC
4070: 0000:         IRF.UNUSED$,         \                                                        ! 1.6 RC
4071: 0000:         NEW.IRF.DATA$        !                                             ! 1.7 RC
4072: 0000: 
4073: 0000:     STRING GLOBAL            \                                             ! 1.6 RC
4074: 0000:         IRF.DEAL.NUM$(1)                                                   ! 1.6 RC
4075: 0000: 
4076: 0000:     INTEGER*1 GLOBAL         \
4077: 0000:         IRF.DD.SUB%,         \ IRF.DEAL.DATA% subscript                    ! 1.6 RC
4078: 0000:         IRF.INDICAT0%,       \
4079: 0000:         IRF.INDICAT1%,       \
4080: 0000:         IRF.INDICAT2%,       \ Redundant (set to null within functions)    ! 1.6 RC
4081: 0000:         IRF.INDICAT3%,       \
4082: 0000:         IRF.INDICAT4%,       \ Redundant (set to null within functions)    ! 1.6 RC
4083: 0000:         IRF.INDICAT5%,       \                                             ! 2.0 AJC
4084: 0000:         IRF.INDICAT8%,       \                                             ! 2.0 AJC
4085: 0000:         IRF.INDICAT9%,       \                                             ! 2.2 TT
4086: 0000:         IRF.INDICAT10%                                                     ! 2.2 TT
4087: 0000: 
4088: 0000:     INTEGER*1 GLOBAL         \                                             ! 1.6 RC
4089: 0000:         IRF.LIST.ID%(1)                                                    ! 1.6 RC
4090: 0000: 
4091: 0000:     INTEGER*2 GLOBAL         \
4092: 0000:         IRF.ALT.REPORT.NUM%, \
4093: 0000:         IRF.ALT.SESS.NUM%,   \
4094: 0000:         IRF.POINTS%,         \ Redundant (set to null within functions)    ! 1.6 RC
4095: 0000:         IRF.RECL%,           \
4096: 0000:         IRF.REPORT.NUM%,     \
4097: 0000:         IRF.SESS.NUM%,       \
4098: 0000:         IRF.MAX.DEALS%       !                                             ! 1.9 SM
4099: 0000: 
4100: 0000:     STRING GLOBAL IRFDEX.FILE.NAME$                                        ! 1.9 SM
4101: 0000: 
4102: 0000:     INTEGER*2 GLOBAL IRFDEX.SESS.NUM%                                      ! 1.9 SM
4103: 0000:     INTEGER*2 GLOBAL IRFDEX.REPORT.NUM%                                    ! 1.9 SM
4104: 0000:     INTEGER*2 GLOBAL IRFDEX.RECL%                                          ! 1.9 SM
4105: 0000: 
4106: 0000: 
4107: 0000: !   INTEGER*2 GLOBAL      \ IRF.DEAL.DATA%(n) variables are defined locally  1.6 RC
4108: 0000: !       IRF.DEAL.DATA%(1) \ within IRFFUN.BAS to keep invisible to programs  1.6 RC
4109: 0000: 
4110: 0000:  %INCLUDE STKDCDEC.J86                    ! 1.8DA
4111: 0000: \******************************************************************************
4112: 0000: \******************************************************************************
4113: 0000: \***
4114: 0000: \***   $Workfile:   STKDCDEC.J86  $
4115: 0000: \***
4116: 0000: \***   $Revision:   1.0  $
4117: 0000: \***
4118: 0000: \******************************************************************************
4119: 0000: \******************************************************************************
4120: 0000: \***
4121: 0000: \***   $Log:   V:\archive\j86\stkdcdec.j8v  $
4122: 0000: \***   
4123: 0000: \***      Rev 1.0   15 Jul 1997 14:20:40   DEV45PS
4124: 0000: \***    
4125: 0000: \***   
4126: 0000: \***      Rev 1.0   09 Jul 1997 11:04:58   DEV45PS
4127: 0000: \***   Stocktake System New Files
4128: 0000: \***   
4129: 0000: \******************************************************************************
4130: 0000: \******************************************************************************\******************************************************************************
4131: 0000: \******************************************************************************
4132: 0000: \***
4133: 0000: \***         %INCLUDE FOR STOCKTAKE DUMP CODEP FIELD DECLARATIONS
4134: 0000: \***
4135: 0000: \***               FILE TYPE    : DIRECT
4136: 0000: \***
4137: 0000: \***               REFERENCE    : STKDCDEC.J86
4138: 0000: \***
4139: 0000: \***    VERSION A.              Nik Sen.               19 Jun 1997.
4140: 0000: \***    New file for stocktaking system. Holds all items counted using
4141: 0000: \***    dump codes during the stocktake.
4142: 0000: \***
4143: 0000: \*******************************************************************************
4144: 0000: \*******************************************************************************
4145: 0000: 
4146: 0000: STRING GLOBAL                                                  \
4147: 0000:        STKDC.FILE.NAME$,               \
4148: 0000:        STKDC.DUMP.CODE$,               \
4149: 0000:        STKDC.QUANTITY$,                \
4150: 0000:        STKDC.PRICE$,                   \
4151: 0000:        STKDC.LOCATION$,                \
4152: 0000:        STKDC.STOCKTAKER.NUM$
4153: 0000:         
4154: 0000: INTEGER*4 GLOBAL               \
4155: 0000:        STKDC.RECORD.NUM%
4156: 0000: 
4157: 0000: 
4158: 0000: INTEGER*2 GLOBAL                \
4159: 0000:    STKDC.REPORT.NUM%,           \
4160: 0000:    STKDC.SESS.NUM%             
4161: 0000: 
4162: 0000: 
4163: 0000: INTEGER*1 GLOBAL                \
4164: 0000:    STKDC.RECL%         
4165: 0000: 
4166: 0000: 
4167: 0000:  %INCLUDE MINLSDEC.J86                    ! 1.9BG
4168: 0000: 
4169: 0000: \*****************************************************************************
4170: 0000: \*****************************************************************************
4171: 0000: \***
4172: 0000: \***        %INCLUDE FIELD DECLARATIONS AND FILE REFERENCE PARAMETERS
4173: 0000: \***
4174: 0000: \***                   FILE TYPE:  KEYED
4175: 0000: \***
4176: 0000: \***                   REFERENCE:  MINLSDEC.J86
4177: 0000: \***
4178: 0000: \***              DESCRIPTION:  MINSITS RP - SCREEN COUNT INFORMATION
4179: 0000: \***
4180: 0000: \***
4181: 0000: \***
4182: 0000: \***      VERSION 1 : Julia Stones             8th January 1998  
4183: 0000: \***      
4184: 0000: \*****************************************************************************
4185: 0000: \*****************************************************************************
4186: 0000: 
4187: 0000: STRING GLOBAL   \
4188: 0000:    MINLS.FILE.NAME$,  \
4189: 0000:    MINLS.ITEM.CODE$,     \  4 byte UPD;  Record key
4190: 0000:    MINLS.RECOUNT.DATE$,  \  3 byte UPD;  YYMMDD      
4191: 0000:    MINLS.DISCREPANCY$,    \  3 byte UPD        
4192: 0000:    MINLS.COUNT.STATUS$     ! 1 byte ASCII 
4193: 0000: 
4194: 0000: INTEGER*2 GLOBAL  \
4195: 0000:    MINLS.RECL%,   \
4196: 0000:    MINLS.REPORT.NUM%,  \
4197: 0000:    MINLS.SESS.NUM%   !
4198: 0000: 
4199: 0000: 
4200: 0000: 
4201: 0000:  %INCLUDE NEGSCDEC.J86                    ! 1.9BG
4202: 0000: 
4203: 0000: \*****************************************************************************
4204: 0000: \*****************************************************************************
4205: 0000: \***
4206: 0000: \***        %INCLUDE FIELD DECLARATIONS AND FILE REFERENCE PARAMETERS
4207: 0000: \***
4208: 0000: \***                   FILE TYPE:  KEYED
4209: 0000: \***
4210: 0000: \***                   REFERENCE:  NEGSCDEC.J86
4211: 0000: \***
4212: 0000: \***              DESCRIPTION:  CURRENT NEGATIVE STOCK COUNT INFORMATION
4213: 0000: \***
4214: 0000: \***
4215: 0000: \***
4216: 0000: \***      VERSION 1 : Julia Stones             15th July 1999  
4217: 0000: \***      
4218: 0000: \***    REVISION 1.2.            ROBERT COWEY.                  09 SEP 2003.
4219: 0000: \***    Changes for RF trial.
4220: 0000: \***    Recompiled to prevent future automatic recompiles.
4221: 0000: \***    No changes to actual code.
4222: 0000: \***
4223: 0000: \*****************************************************************************
4224: 0000: \*****************************************************************************
4225: 0000: 
4226: 0000: STRING GLOBAL   \
4227: 0000:    NEGSC.FILE.NAME$,  \
4228: 0000:    NEGSC.KEY$,   \      !  5 bytes UPD; 1 byte Record type 
4229: 0000:                         \                 Record type 01 item record
4230: 0000:                         \                 Record type 02 total count record
4231: 0000:                         \               4 bytes item code (set to zero's if
4232: 0000:                         \                 record type 02)
4233: 0000:    NEGSC.STATUS.1$      !  1 byte ASC
4234: 0000:                         !            'B' - Discontinued but still on display
4235: 0000:                         !            'C' - Cancel outstanding orders
4236: 0000:                         !            'D' - Discontinued and no longer on display
4237: 0000:                         !            'P' - Suspended (orders to Store)
4238: 0000:                         !            'X' - Deleted
4239: 0000:                         !            ' ' - No special Status (default value)
4240: 0000:   
4241: 0000: INTEGER*2 GLOBAL  \
4242: 0000:    NEGSC.RECL%,   \
4243: 0000:    NEGSC.REPORT.NUM%,  \
4244: 0000:    NEGSC.SESS.NUM%,    \
4245: 0000:    NEGSC.ITEM.TSF%,    \
4246: 0000:    NEGSC.NUMBER.OF.DAYS%   !
4247: 0000: 
4248: 0000: 
4249: 0000: 
4250: 0000:  %INCLUDE SSPSCDEC.J86                    ! 2.0JAS
4251: 0000: \*****************************************************************************
4252: 0000: \*****************************************************************************
4253: 0000: \***
4254: 0000: \***               %INCLUDE FOR SSPSCTRL - FIELD DECLARATIONS
4255: 0000: \***                                          FILE REFERENCE PARAMETERS
4256: 0000: \***
4257: 0000: \***                      FILE TYPE    : DIRECT
4258: 0000: \***
4259: 0000: \***                      REFERENCE    : SSPSCdea.J86
4260: 0000: \***
4261: 0000: \***    Version A               Julia Stones          23 Oct 2003
4262: 0000: \***
4263: 0000: \***
4264: 0000: \*****************************************************************************
4265: 0000: \*****************************************************************************
4266: 0000: 
4267: 0000: REM \
4268: 0000: 
4269: 0000:   STRING GLOBAL           \
4270: 0000:     SSPSCTRL.FILE.NAME$
4271: 0000: 
4272: 0000:   INTEGER*2 GLOBAL        \
4273: 0000:     SSPSCTRL.REPORT.NUM%,   \
4274: 0000:     SSPSCTRL.SESS.NUM%
4275: 0000: REM \
4276: 0000: 
4277: 0000:   STRING GLOBAL           \
4278: 0000:     SSPS.BTCSK.NUM$,      \ 3 byte, file ext number (000 - 999)
4279: 0000:     SSPS.BTCSF.NUM$,      \ 3 byte, file ext number (000 - 999)
4280: 0000:     SSPS.BTCSK.FTP$,      \ 3 byte, last file ext number sent to SMARTSCRIPT
4281: 0000:     SSPS.BTCSF.FTP$,      \ 3 byte, last file ext number sent to SMARTSCRIPT
4282: 0000:     SSPS.FILLER$          ! 68 byte, spaces
4283: 0000: 
4284: 0000:   INTEGER*2 GLOBAL        \
4285: 0000:     SSPSCTRL.RECL%
4286: 0000:  %INCLUDE BTCSDEC.J86                     ! 2.0JAS
4287: 0000: \*****************************************************************************
4288: 0000: \*****************************************************************************
4289: 0000: \***
4290: 0000: \***      %INCLUDE FOR BTCS FILE - FIELD DECLARATIONS
4291: 0000: \***                               FILE REFERENCE PARAMETERS
4292: 0000: \***
4293: 0000: \***      FILE TYPE    : DIRECT
4294: 0000: \***
4295: 0000: \***      REFERENCE    : BTCSDEC
4296: 0000: \***
4297: 0000: \***      VERSION A    : Julia Stones 22/10/03
4298: 0000: \***
4299: 0000: \*****************************************************************************
4300: 0000: \*****************************************************************************
4301: 0000: 
4302: 0000:     STRING GLOBAL        BTCS.FILE.NAME$
4303: 0000: 
4304: 0000: 
4305: 0000:     INTEGER*2 GLOBAL     BTCS.SESS.NUM%,        \
4306: 0000:                          BTCS.RECL%,            \
4307: 0000:                          BTCS.REPORT.NUM%
4308: 0000: 
4309: 0000: 
4310: 0000:     INTEGER*4 GLOBAL     BTCS.REC.NUM%
4311: 0000: 
4312: 0000: 
4313: 0000:     STRING GLOBAL        BTCS.RECORD$,           \ Whole record form file:
4314: 0000:                          BTCS.RECORD.TYPE$,      \ 1 ASC Type of record:
4315: 0000:                                                  \       "H" = header
4316: 0000:                                                  \       "D" = detail
4317: 0000:                                                  \       "T" = trailer
4318: 0000:                          BTCS.STORE.NUMBER$,     \ 4 ASC 4 digit Store number
4319: 0000:                          BTCS.STKTAKE.NUM$,      \ 4 ASC 4 digit Stock take number
4320: 0000:                          BTCS.DATE$,             \ 6 ASC Date YYMMDD
4321: 0000:                          BTCS.TIME$,             \ 6 ASC Time HHMMSS
4322: 0000:                          BTCS.DISP.AREA$,        \ 1 ASC M = MDS
4323: 0000:                                                  \       D = Dispensing
4324: 0000:                          BTCS.FILLER$,           \   ASC Set to spaces
4325: 0000:                          BTCS.NUM.RECORD$,       \ 4 ASC Record sequence number starting at 0001
4326: 0000:                          BTCS.ITEM.CODE$,        \13 ASC Item Code/PIP code
4327: 0000:                          BTCS.CODE.TYPE$,        \ 1 ASC E = EAN item code
4328: 0000:                                                  \       P = PIP code
4329: 0000:                          BTCS.PACK.QTY$,         \ 6 ASC Number of packs, bottles etc
4330: 0000:                          BTCS.DIS.UNIT.QTY$,     \ 4 ASC Dispensed unit quantity
4331: 0000:                          BTCS.RECORD.COUNT$,     \ 4 ASC Amount of records in file (inc header and trailer)
4332: 0000:                          BTCS.ENDREC$            \ 2 ASC ODOA
4333: 0000: 
4334: 0000:  %INCLUDE PRINTDEC.J86                    ! 2.0JAS
4335: 0000: 
4336: 0000: REM \
4337: 0000: \*******************************************************************************
4338: 0000: \*******************************************************************************
4339: 0000: \***
4340: 0000: \***    %INCLUDE FOR PRINT FILE VARIABLE DECLARATIONS
4341: 0000: \***
4342: 0000: \***        REFERENCE   :   PRINTDE (J86)
4343: 0000: \***
4344: 0000: \***        FILE TYPE   :   Printer / Labeller
4345: 0000: \***
4346: 0000: \***    VERSION A.              ANDREW WEDGEWORTH                   09 JUL 1992.
4347: 0000: \***    Original version created by merging PRINTFLG and PRINTNUG.
4348: 0000: \***
4349: 0000: \***    VERSION B.              UNKNOWN.                            ?? ??? 1992.
4350: 0000: \***    Changes unknown.             
4351: 0000: \***
4352: 0000: \***    VERSION C.              ROBERT COWEY.                       18 NOV 1992.
4353: 0000: \***    No changes made to this file.
4354: 0000: \***
4355: 0000: \***    Version D               Andrew Wedgeworth                 24th May 1992
4356: 0000: \***    Variable added to contain condensed print record length.
4357: 0000: \***
4358: 0000: \*******************************************************************************
4359: 0000: \*******************************************************************************
4360: 0000: 
4361: 0000: 
4362: 0000:     STRING GLOBAL \
4363: 0000:         PRINT.LINE$, \
4364: 0000:         PRINT.FILE.NAME$, \
4365: 0000:         SELF.LAN.NAME$, \
4366: 0000:         SELF.NOLAN.NAME$
4367: 0000: 
4368: 0000:     INTEGER*2 GLOBAL \
4369: 0000:         PRINT.CONDENSED.RECL%, \                                       ! DAW  
4370: 0000:         PRINT.SESS.NUM%, \
4371: 0000:         PRINT.REPORT.NUM%, \
4372: 0000:         PRINT.REPORT.RECL%, \
4373: 0000:         PRINT.SELF.RECL%
4374: 0000: 
4375: 0000:  %INCLUDE SOPTSDEC.J86                    ! 2.1JAS
4376: 0000: REM \
4377: 0000: \******************************************************************************
4378: 0000: \******************************************************************************
4379: 0000: \***
4380: 0000: \***                 %INCLUDE FOR THE STORE OPTIONS FILE
4381: 0000: \***   
4382: 0000: \***                      FILE TYPE  :   Direct
4383: 0000: \***
4384: 0000: \***                      REFERENCE  :   SOPTSDEC.J86
4385: 0000: \***
4386: 0000: \***    Version A         Stuart William McConnachie      19th June 1995
4387: 0000: \***
4388: 0000: \******************************************************************************
4389: 0000: \*******************************************************************************
4390: 0000: 
4391: 0000:   STRING GLOBAL           \
4392: 0000:     SOPTS.RECORD$,        \           
4393: 0000:     SOPTS.SPACE$,         \           
4394: 0000:     SOPTS.FILE.NAME$
4395: 0000:     
4396: 0000:   INTEGER*2 GLOBAL        \
4397: 0000:     SOPTS.RECL%,          \            
4398: 0000:     SOPTS.REPORT.NUM%,    \      
4399: 0000:     SOPTS.SESS.NUM%
4400: 0000: 
4401: 0000:   INTEGER*4 GLOBAL        \
4402: 0000:     SOPTS.REC.NUM%
4403: 0000: 
4404: 0000:  %INCLUDE TSFDEC.J86                      ! 2.1JAS
4405: 0000: \*****************************************************************************
4406: 0000: \*****************************************************************************
4407: 0000: \***
4408: 0000: \***      %INCLUDE FOR TERMINAL STATUS FILE - FIELD DECLARATIONS
4409: 0000: \***                                          FILE REFERENCE PARAMETERS
4410: 0000: \***
4411: 0000: \***                      FILE TYPE    : KEYED
4412: 0000: \***
4413: 0000: \***                      REFERENCE    : TSFDEC
4414: 0000: \***
4415: 0000: \***           VERSION A : STEVEN GOULDING              13.10.92
4416: 0000: \***
4417: 0000: \***           VERSION B : STEVE WINDSOR                15.09.93
4418: 0000: \***           Updated to keep in step.
4419: 0000: \***
4420: 0000: \***           VERSION C : STUART WILLIAM MCCONNACHIE   18.03.97
4421: 0000: \***           Added extra fields in user data.
4422: 0000: \*** 
4423: 0000: \***           VERSION D : REBECCA DAKIN                22.02.99
4424: 0000: \***           Added ACSALD.CUT.OFF, as part of Cash Accounting project.
4425: 0000: \***
4426: 0000: \***           VERSION E : AMY HOGGARD                  16.10.00
4427: 0000: \***           Added TILLBAG.CUT.OFF, as part of ECO project.
4428: 0000: \***
4429: 0000: \***           VERSION F : STUART WILLIAM MCCONNACHIE   20.05.05
4430: 0000: \***           Added "new" fields as no one else can be bothered.
4431: 0000: \***           Corrected offset bug of controller ID.
4432: 0000: \***
4433: 0000: \***           VERSION G : JAMIE THORPE                 05.10.05
4434: 0000: \***           Added new INVDUE.DATE record to the store record 
4435: 0000: \***           (for Zero TSF proj.)
4436: 0000: \***           This is the date that the most recent INVDUE file
4437: 0000: \***           was created.
4438: 0000: \***
4439: 0000: \***    VERSION H               Mark Walker                      3rd Nov 2014
4440: 0000: \***    F294 PCI Phase 1
4441: 0000: \***    Includes the following changes:
4442: 0000: \***    - Removed redundant 'smartcard software level' field.
4443: 0000: \***    - Extended TSF.INDICAT2% integer field from 1 to 2 bytes.
4444: 0000: \***
4445: 0000: \*****************************************************************************
4446: 0000: \*****************************************************************************
4447: 0000: 
4448: 0000:     STRING GLOBAL               \
4449: 0000:         TSF.FILE.NAME$,         \
4450: 0000:         TSF.REC$(1),            \ One dimensional array
4451: 0000:         TSF.SECTOR.FILLER$,     \
4452: 0000:         TSF.SECTOR.INFO$
4453: 0000:         
4454: 0000:     INTEGER*1 GLOBAL            \
4455: 0000:         TSF.REC.SUB%            ! Subscript used with TSF.REC array
4456: 0000: 
4457: 0000:     INTEGER*2 GLOBAL            \
4458: 0000:         TSF.SESS.NUM%,          \
4459: 0000:         TSF.RECL%,              \
4460: 0000:         TSF.REPORT.NUM%,        \
4461: 0000:         TSF.SECTOR.NUM%
4462: 0000: 
4463: 0000:     STRING GLOBAL               \
4464: 0000:         TSF.TERM.STORE$,        \ 2 byte UPD.Terminal number or 
4465: 0000:                                 \ 9999 for store (key)
4466: 0000:         TSF.TSL.NAME$,          \ 8 bytes. Most recent old TSL file
4467: 0000:         TSF.MONITOR$,           \ 2 byte UPD last monitoring terminal
4468: 0000:         TSF.TLOGFLAG$,          \ 1 byte, EALLGHC processed flag
4469: 0000:         TSF.OPERATOR$,          \ Operator number
4470: 0000:         TSF.TRANSNUM$,          \ Most recent transaction
4471: 0000:         TSF.RCPSTATUS$,         \ Store close requested through RCF                                                             
4472: 0000:         TSF.SIGN.OFF.DELAY$,    \ 1 byte PD counter to auto sign off    \  !CSWM
4473: 0000:         TSF.USER$,              \ User data
4474: 0000:         TSF.CONTROLLER$,        \ Controller ID
4475: 0000:         TSF.INVDUE.DATE$,       \ Creation date of the INVDUE
4476: 0000:                                 \ (Updated by PSS33)                    \   !GJT
4477: 0000:         TSF.SPACE$              ! 34 bytes or 14 bytes
4478: 0000: 
4479: 0000:     INTEGER*1 GLOBAL            \
4480: 0000:         TSF.INDICAT0%,          \ Indicator byte 0
4481: 0000:         TSF.INDICAT1%,          \ Indicator byte 1
4482: 0000: \       TSF.INDICAT2%,          \ Indicator byte 2                      \   !HMW
4483: 0000:         TSF.MTSL.CUT.OFF%,      \ MTSL cut-off required flag            \  !CSWM
4484: 0000:         TSF.CUSTD.CUT.OFF%,     \ CUSTD cut-off required flag           \  !CSWM
4485: 0000:         TSF.ACSAL.CUT.OFF%,     \ ACSAL cut-off required flag               !DRD
4486: 0000:         TSF.TILLBAG.CUT.OFF%    ! TILLBAG cut-off required flag             !EAH
4487: 0000:     
4488: 0000:     INTEGER*2 GLOBAL            \
4489: 0000: \       TSF.SC.LEVEL%           ! Smartcard software level              \   !HMW
4490: 0000:         TSF.INDICAT2%           ! Indicator flags 2                         !HMW
4491: 0000: 
4492: 0000:     INTEGER*4 GLOBAL            \
4493: 0000:         TSF.GROSSPOS,           \ Gross plus
4494: 0000:         TSF.GROSSNEG,           \ Gross minus
4495: 0000:         TSF.NETCASH,            \ Net cash
4496: 0000:         TSF.NETNCASH,           \ Net non-cash
4497: 0000:         TSF.AMTLOAN,            \ Loans
4498: 0000:         TSF.AMTPICKU,           \ Withdrawals
4499: 0000:         TSF.AMTCASHC,           \ Cash count
4500: 0000:         TSF.NETCCURR,           \ Net cash currency face value
4501: 0000:         TSF.NETCCCURR           ! Net cash count currency face value
4502: 0000: 
4503: 0000:  %INCLUDE LOCALDEC.J86                    ! 2.1JAS
4504: 0000: \***********************************************************************
4505: 0000: \***********************************************************************
4506: 0000: \***
4507: 0000: \***    DESCRIPTION: Local Price File
4508: 0000: \***                 Field Definitions
4509: 0000: \***
4510: 0000: \***    FILE TYPE : Keyed
4511: 0000: \***
4512: 0000: \***********************************************************************
4513: 0000: \***
4514: 0000: \***    Version A.          Paul Flanagan                1st Jul 1993
4515: 0000: \***    Initial version.
4516: 0000: \***
4517: 0000: \***    Version B.          Clive Norris                24th Nov 1993
4518: 0000: \***    AUTH.NUM$, STOCK.FIG$ and RETRIEVAL.FLAG$ replaced filler as
4519: 0000: \***    part of the RETURNS/AUTOMATIC CREDIT CLAIMING package.
4520: 0000: \***
4521: 0000: \***    Version C.          Mick Bayliss                 6th Dec 1994
4522: 0000: \***    Added missing field.
4523: 0000: \***
4524: 0000: \***    Version D.          Mark Walker                  1st Jul 2015
4525: 0000: \***    F392 Retail Stock 5
4526: 0000: \***    Added key length field.
4527: 0000: \***
4528: 0000: \***********************************************************************
4529: 0000: \***********************************************************************
4530: 0000: 
4531: 0000:     STRING GLOBAL             \
4532: 0000:         LOCAL.AUTH.NUM$,      \ 4 bytes UPD Auth'n number
4533: 0000:                               \             from Business Centre.
4534: 0000:         LOCAL.END.DATE$,      \ 3 bytes UPD yymmdd.
4535: 0000:         LOCAL.FILE.NAME$,     \
4536: 0000:         LOCAL.H.O.PRICE$,     \ 5 byte UPD.
4537: 0000:         LOCAL.HO.CHANGE$,     \ 3 bytes UPD. Date of HO price change
4538: 0000:                               \ (this will be zero if no change since
4539: 0000:                               \ local price was initiated).
4540: 0000:         LOCAL.ITEM.CODE$,     \ 4 bytes UPD (key) Boots code 
4541: 0000:                               \                   with check digit. 
4542: 0000:         LOCAL.OPERATOR$,      \ 4 bytes UPD operator id (when set up).
4543: 0000:         LOCAL.PRICE$,         \ 5 bytes UPD.
4544: 0000:         LOCAL.REASON$,        \ 4 byte ASCII 
4545: 0000:         LOCAL.RETRIEVAL.FLAG$,\ 1 byte ASC "Y" or "N"  
4546: 0000:         LOCAL.SPACE$,         \                                            !CMJB
4547: 0000:         LOCAL.START.DATE$,    \ 3 bytes UPD yymmdd. 
4548: 0000:         LOCAL.START.TIME$     ! 2 bytes UPD hhmm.
4549: 0000:         
4550: 0000:     INTEGER*2 GLOBAL          \
4551: 0000:         LOCAL.KEYL%,          \                                             !DMW
4552: 0000:         LOCAL.RECL%,          \
4553: 0000:         LOCAL.REPORT.NUM%,    \
4554: 0000:         LOCAL.SESS.NUM%,      \
4555: 0000:         LOCAL.STOCK.FIG%      !  No. of items authorised at the price.
4556: 0000: 
4557: 0000:  %INCLUDE CCREJDEC.J86                    ! 1.2JAS
4558: 0000: REM \
4559: 0000: \******************************************************************************
4560: 0000: \******************************************************************************
4561: 0000: \***
4562: 0000: \***      %INCLUDE FOR CREDIT CLAIMING REJECT FILE FIELD DECLARATIONS
4563: 0000: \***                                          FILE REFERENCE PARAMETERS
4564: 0000: \***
4565: 0000: \***               FILE TYPE    : Sequential
4566: 0000: \***
4567: 0000: \***               REFERENCE    : CCREJDEC.J86
4568: 0000: \***
4569: 0000: \***      Version A.     Julia Stones           11th March 2004.
4570: 0000: \***
4571: 0000: \******************************************************************************
4572: 0000: \*******************************************************************************
4573: 0000: \***
4574: 0000: \***
4575: 0000: \***
4576: 0000: \******************************************************************************
4577: 0000: 
4578: 0000:   STRING GLOBAL              \
4579: 0000:     CCREJ.FILE.NAME$,        \
4580: 0000:     CCREJC.FILE.NAME$,       \
4581: 0000:     CCREJP.FILE.NAME$,       \
4582: 0000:     CCREJ.RECORD$,           \ Used to store the whole record which is unstrung
4583: 0000:                              \ into the fields below
4584: 0000:     CCREJ.ENDREC.MARKER$,    \ 2 bytes ASCII set to XODOA
4585: 0000:     CCREJ.DATE$,             \ 8 byte ASCII
4586: 0000:     CCREJ.RETURN.REASON$,    \ 2 byte ASCII
4587: 0000:     CCREJ.BC.LETTER$,        \ 1 byte ASCII
4588: 0000:     CCREJ.UOD.NUM$,          \ 14 byte ASCII
4589: 0000:     CCREJ.ITEM.BARCODE.FLAG$,\ 1 byte ASC;  "I" = Boots item code,
4590: 0000:               \                             "B" = Barcode.
4591: 0000:     CCREJ.ITEM.BARCODE$,     \ 12 byte ASCII
4592: 0000:     CCREJ.DESC$,             \ 24 byte ASCII
4593: 0000:     CCREJ.ITEM.BC$,          \ 1 byte ASCII
4594: 0000:     CCREJ.ITEM.QTY$,         \ 4 byte ASCII
4595: 0000:     CCREJ.REJECT.REASON$     ! 1 byte ASCII "1" = Item not on file
4596: 0000:                              !              "2" = Credit Claim not allowed against this
4597: 0000:                              !                    Business Centre
4598: 0000:                              !              "3" = Item does not belong to Business Centre
4599: 0000:                              !                    being claimed against
4600: 0000: 
4601: 0000: 
4602: 0000:   INTEGER*2 GLOBAL           \
4603: 0000:     CCREJ.RECL%,             \
4604: 0000:     CCREJC.RECL%,            \
4605: 0000:     CCREJP.RECL%,            \
4606: 0000:     CCREJC.SESS.NUM%,        \
4607: 0000:     CCREJP.SESS.NUM%,        \
4608: 0000:     CCREJ.SESS.NUM%,         \
4609: 0000:     CCREJC.REPORT.NUM%,      \
4610: 0000:     CCREJP.REPORT.NUM%,      \
4611: 0000:     CCREJ.REPORT.NUM%
4612: 0000: 
4613: 0000: 
4614: 0000:  %INCLUDE RBDEC.J86                       ! 2.6BG
4615: 0000: \/******************************************************************/
4616: 0000: \/*                                                                */
4617: 0000: \/* Recalls Buffer FILE GLOBAL VARIABLE DECLARATIONS               */
4618: 0000: \/*                                                                */
4619: 0000: \/* REFERENCE   : RBDEC.J86                                        */
4620: 0000: \/*                                                                */
4621: 0000: \/* VERSION A.          Brian Greenfield        11th may 2007      */
4622: 0000: \/*                                                                */
4623: 0000: \/******************************************************************/
4624: 0000: 
4625: 0000:    STRING GLOBAL                \
4626: 0000:       RB.FILE.NAME$,            \
4627: 0000:                                 \
4628: 0000:       RB.RCD$,                  \  ? bytes  (25/14/12)
4629: 0000:       RB.REC.TYPE$,             \  1 byte   (H/D/T)
4630: 0000:       RB.REFERENCE$,            \  8 bytes
4631: 0000:       RB.LABEL$,                \ 14 bytes (8 bytes label type)
4632: 0000:                                 \          (6 bytes label number)
4633: 0000:       RB.ITEM.CODE$,            \  7 bytes (with check digit)
4634: 0000:       RB.STOCK.COUNT$,          \  4 bytes (1 - 9999)
4635: 0000:       RB.ITEM.COUNT$,           \  5 bytes (1 - 99999)
4636: 0000:       RB.RECORD.COUNT$          !  4 bytes (1 - 9999 inc header and trailer)
4637: 0000: 
4638: 0000:    INTEGER*2 GLOBAL             \
4639: 0000:       RB.REPORT.NUM%,           \
4640: 0000:       RB.SESS.NUM%              !
4641: 0000: 
4642: 0000: \/******************************************************************/
4643: 0000:  %INCLUDE REWKFDEC.J86                    ! 2.6BG
4644: 0000: \/******************************************************************/
4645: 0000: \/*                                                                */
4646: 0000: \/* Recalls Work FILE GLOBAL VARIABLE DECLARATIONS                 */
4647: 0000: \/*                                                                */
4648: 0000: \/* REFERENCE   : REWKFDEC.J86                                     */
4649: 0000: \/*                                                                */
4650: 0000: \/* VERSION A.          Brian Greenfield        11th may 2007      */
4651: 0000: \/*                                                                */
4652: 0000: \/* VERSION B.          Brian Greenfield        15th April 2008    */
4653: 0000: \/*                                                                */
4654: 0000: \/* VERSION C.          Brian Greenfield        6th May 2008       */
4655: 0000: \/*                                                                */
4656: 0000: \/******************************************************************/
4657: 0000: 
4658: 0000:    STRING GLOBAL                \
4659: 0000:       REWKF.FILE.NAME$,         \
4660: 0000:                                 \
4661: 0000:       REWKF.RCD$,               \  ? bytes  (25/47/8)
4662: 0000:       REWKF.REC.TYPE$,          \  1 byte   (H/D/T)
4663: 0000:       REWKF.REFERENCE$,         \  8 bytes
4664: 0000:       REWKF.LABEL$,             \ 14 bytes (8 bytes label type)
4665: 0000:                                 \          (6 bytes label number - zero's)
4666: 0000:       REWKF.BATCH.TYPE$,        \  1 byte  (E/F/R/S/W/X/I/C) !BBG
4667: 0000:       REWKF.MRQ$,               \  2 bytes ASCII !CBG
4668: 0000:       REWKF.DUE.BY.DATE$,       \  8 bytes (YYYYMMDD) !BBG
4669: 0000:       REWKF.BARCODE$,           \ 13 bytes (with check digit)
4670: 0000:       REWKF.ITEM.CODE$,         \  7 bytes (with check digit)
4671: 0000:       REWKF.DESCRIPTION$,       \ 20 bytes (truncated from the IDF)
4672: 0000:       REWKF.TSF$,               \  4 bytes (1 - 9999 or SPACES for recall types F, S, & X)
4673: 0000:       REWKF.ITEM.COUNT$         !  5 bytes (1 - 99999)
4674: 0000:       
4675: 0000:    INTEGER*2 GLOBAL             \
4676: 0000:       REWKF.REPORT.NUM%,        \
4677: 0000:       REWKF.SESS.NUM%           !
4678: 0000: 
4679: 0000: \/******************************************************************/
4680: 0000:  %INCLUDE RECALDEC.J86                    ! 2.6BG
4681: 0000: \******************************************************************************
4682: 0000: \******************************************************************************
4683: 0000: \***
4684: 0000: \***         INCLUDE FOR RECALLS.BIN DECLARATIONS
4685: 0000: \***
4686: 0000: \***               FILE TYPE    : Keyed
4687: 0000: \***
4688: 0000: \***               REFERENCE    : RECALDEC.J86
4689: 0000: \***
4690: 0000: \***    VERSION A               BRIAN GREENFIELD                    14th May 2007
4691: 0000: \***    Initial Version
4692: 0000: \***
4693: 0000: \***    Version B               BRIAN GREENFIELD                    20th June 2007
4694: 0000: \***    Altered due to a change in the file layout.
4695: 0000: \***
4696: 0000: \*******************************************************************************
4697: 0000: \*******************************************************************************
4698: 0000: 
4699: 0000:   STRING GLOBAL                \
4700: 0000:     RECALLS.FILE.NAME$,        \
4701: 0000:                                \
4702: 0000:     RECALLS.REFERENCE$,        \ 8 bytes UPD  - Key is reference + RECALLS.CHAIN%
4703: 0000:     RECALLS.TYPE$,             \ 1 byte  ASC  - E = Emergency
4704: 0000:                                \                F = Batch Emergency
4705: 0000:                                \                G = generic items not authorised for sale
4706: 0000:                                \                R = 100% Returns
4707: 0000:                                \                S = Batch 100% Returns
4708: 0000:                                \                W = Withdrawn
4709: 0000:                                \                X = batch Withdrawn
4710: 0000:     RECALLS.DESCRIPTION$,      \ 20 bytes ASC
4711: 0000:     RECALLS.LABEL.TYPE$,       \ 8 bytes ASC
4712: 0000:     RECALLS.SUPPLY.ROUTE$,     \ 1 byte ASC
4713: 0000:     RECALLS.REASON.CODE$,      \ 1 byte ASC
4714: 0000:     RECALLS.BC$,               \ 1 byte ASC
4715: 0000:     RECALLS.ACTIVE.DATE$,      \ 8 bytes ASC  - YYYYMMDD
4716: 0000:     RECALLS.DUE.BY.DATE$,      \ 8 bytes ASC  - YYYYMMDD
4717: 0000:     RECALLS.COMPLETION.DATE$,  \ 8 bytes ASC  - YYYYMMDD
4718: 0000:     RECALLS.STATUS$,           \ 1 byte ASC   - N = Not Actioned, A = Actioned, P = Partially Actioned
4719: 0000:     RECALLS.BATCH.NUM$,        \ 30 bytes ASC
4720: 0000:     RECALLS.ITEM.COUNT$,       \ 4 bytes ASC  - Total count of items in this recall
4721: 0000:                                \
4722: 0000:                                \ The following 8 bytes are repeated for the number of items in this part
4723: 0000:                                \ of the recall chain - up to 50 items per chain.
4724: 0000:     RECALLS.ITEM.CODE$(1),     \ 4 bytes PD   - 6 digit Item Code
4725: 0000:     RECALLS.ITEM.STOCK$(1),    \ 2 bytes PD   - SPACES if not yet actioned                         !BBG
4726: 0000:     RECALLS.SESS.STOCK$(1),    \ 2 bytes PD   - 4 digit session stock count - used only by the PPC !BBG
4727: 0000:     RECALLS.ITEM.UPT.FLAG$(1), \ 1 byte ASC   - used by the PPC only - Y = actioned, N - reset, space = unactioned
4728: 0000:                                \
4729: 0000:     RECALLS.FILLER$            !
4730: 0000:     
4731: 0000:   INTEGER*1 GLOBAL             \
4732: 0000:     RECALLS.CHAIN%
4733: 0000:     
4734: 0000:   INTEGER*2 GLOBAL             \
4735: 0000:     RECALLS.RECL%,             \
4736: 0000:     RECALLS.KEYL%,             \
4737: 0000:     RECALLS.REPORT.NUM%,       \
4738: 0000:     RECALLS.SESS.NUM%,         \
4739: 0000:     RECALLS.MAX.REC.ITEMS%
4740: 0000: 
4741: 0000: 
4742: 0000:  %INCLUDE DELVIDEC.J86                    ! 2.7SH
4743: 0000: \/******************************************************************/
4744: 0000: \/*                                                                */
4745: 0000: \/* DELVINDX FILE GLOBAl VARIABLE DECLARATIONS                     */
4746: 0000: \/*                                                                */
4747: 0000: \/* REFERENCE   : DELVIDEC.J86                                     */
4748: 0000: \/*                                                                */
4749: 0000: \/* VERSION A.          Stuart Highley              14 July 2008   */
4750: 0000: \/*                                                                */
4751: 0000: \/* VERSION B.          Stuart Highley               18 Dec 2008   */
4752: 0000: \/* Make file fixed rec length.                                    */
4753: 0000: \/******************************************************************/
4754: 0000: 
4755: 0000:    STRING GLOBAL                    \
4756: 0000:       DELVINDX.FILE.NAME$,          \
4757: 0000:       DELVINDX.FILLER$,             \
4758: 0000:       DELVINDX.ASN.NUM$,            \
4759: 0000:       DELVINDX.ASN.CARTON.COUNT$,   \
4760: 0000:       DELVINDX.UOD.LICENCE$,        \
4761: 0000:       DELVINDX.UOD.DESPATCH.DATE$,  \
4762: 0000:       DELVINDX.UOD.BOL.FLAG$,       \
4763: 0000:       DELVINDX.UOD.SEQ$,            \
4764: 0000:       DELVINDX.UOD.PARENT$,         \
4765: 0000:       DELVINDX.UOD.TYPE$,           \
4766: 0000:       DELVINDX.UOD.EXP.DEL.DATE$
4767: 0000: 
4768: 0000:    INTEGER*2 GLOBAL             \
4769: 0000:       DELVINDX.REPORT.NUM%,     \
4770: 0000:       DELVINDX.SESS.NUM%
4771: 0000: 
4772: 0000: \/******************************************************************/
4773: 0000:  %INCLUDE UODOTDEC.J86                    ! 2.7SH
4774: 0000: \*******************************************************************************
4775: 0000: \***
4776: 0000: \***    UOD Outers FILE GLOBAl VARIABLE DECLARATIONS
4777: 0000: \***
4778: 0000: \***    REFERENCE   : UODOTDEC.J86
4779: 0000: \***
4780: 0000: \***    VERSION A.              Stuart Highley                  14th Jul 2008
4781: 0000: \***
4782: 0000: \***    VERSION B.              Mark Goode                      10th Dec 2008
4783: 0000: \***    Add summary record read/write functionality.
4784: 0000: \***
4785: 0000: \***    REVISION 1.8.           Robert Cowey                    14th Jan 2009
4786: 0000: \***    Changes for 10A PosUOD fixes creating SSC04.286 Rv 1.3.
4787: 0000: \***    No new variables but defined new function UODOT.REC$.
4788: 0000: \***
4789: 0000: \***    VERSION C.              Mark Walker                     18th Feb 2015
4790: 0000: \***    F391 HUMSS UOD Messaging
4791: 0000: \***    Includes the following changes:
4792: 0000: \***    - Defined UOD number field.
4793: 0000: \***    - Various coding standards related changes (uncommented).
4794: 0000: \***
4795: 0000: \*******************************************************************************
4796: 0000: 
4797: 0000:     STRING GLOBAL                                                       \
4798: 0000:         UODOT.AUDIT.OP.ID$,                                             \
4799: 0000:         UODOT.BOOKED.DATE$,                                             \
4800: 0000:         UODOT.BOOKED.TIME$,                                             \
4801: 0000:         UODOT.CHILD.LICENCE$(1),                                        \
4802: 0000:         UODOT.CHILD.TYPE$(1),                                           \
4803: 0000:         UODOT.DESPATCH.DATE$,                                           \
4804: 0000:         UODOT.DRVR.DEL.DATE$,                                           \
4805: 0000:         UODOT.DRVR.DEL.TIME$,                                           \
4806: 0000:         UODOT.DRVR.ID$,                                                 \
4807: 0000:         UODOT.EST.DEL.DATE$,                                            \
4808: 0000:         UODOT.FILE.NAME$,                                               \
4809: 0000:         UODOT.FILLER$,                                                  \
4810: 0000:         UODOT.IMMEDIATE.PARENT$,                                        \
4811: 0000:         UODOT.LEVEL$,                                                   \
4812: 0000:         UODOT.LICENCE$,                                                 \
4813: 0000:         UODOT.OPEN.FLAG$,                                               \
4814: 0000:         UODOT.REASON$,                                                  \
4815: 0000:         UODOT.STATUS$,                                                  \
4816: 0000:         UODOT.STORE.OP.ID$,                                             \
4817: 0000:         UODOT.SUMMARY.STATUS$,                                          \   !BMG
4818: 0000:         UODOT.TYPE$,                                                    \
4819: 0000:         UODOT.ULTIMATE.PARENT$,                                         \
4820: 0000:         UODOT.UOD.NUMBER$,                                              \   !CMW
4821: 0000:         UODOT.WAREHOUSE.AREA$
4822: 0000: 
4823: 0000:     INTEGER*1 GLOBAL                                                    \
4824: 0000:         UODOT.BOL,                                                      \
4825: 0000:         UODOT.SDPD
4826: 0000: 
4827: 0000:     INTEGER*2 GLOBAL                                                    \
4828: 0000:         UODOT.AUDITED,                                                  \
4829: 0000:         UODOT.AUTO,                                                     \
4830: 0000:         UODOT.BOOKED,                                                   \
4831: 0000:         UODOT.CONTROLLER,                                               \
4832: 0000:         UODOT.GIT.MISMATCH,                                             \
4833: 0000:         UODOT.KEYL%,                                                    \
4834: 0000:         UODOT.MAX.CHILDREN%,                                            \
4835: 0000:         UODOT.MC70,                                                     \
4836: 0000:         UODOT.NUM.CHILDREN%,                                            \
4837: 0000:         UODOT.NUM.ITEMS%,                                               \
4838: 0000:         UODOT.PARTIAL,                                                  \
4839: 0000:         UODOT.PDT,                                                      \
4840: 0000:         UODOT.RECL%,                                                    \
4841: 0000:         UODOT.REPORT.NUM%,                                              \
4842: 0000:         UODOT.RF,                                                       \
4843: 0000:         UODOT.SEQ%,                                                     \
4844: 0000:         UODOT.SESS.NUM%,                                                \
4845: 0000:         UODOT.STOCK.UPDATED
4846: 0000: 
4847: 0000:  %INCLUDE AFDEC.J86                       ! 2.7SH
4848: 0000: 
4849: 0000: \REM
4850: 0000: \*******************************************************************************
4851: 0000: \*******************************************************************************
4852: 0000: \***
4853: 0000: \***    %INCLUDE FOR GSA AUTHORISATION FILE VARIABLE DECLARATIONS
4854: 0000: \***
4855: 0000: \***        REFERENCE   :  AFDEC (J86)
4856: 0000: \***
4857: 0000: \***        FILE TYPE   :  Keyed
4858: 0000: \***
4859: 0000: \***    The GSA Authorisation File (EALAUTH.DAT) should not be confused with
4860: 0000: \***    the Operating System Authorisation File (ADXCSOUF.DAT).
4861: 0000: \***
4862: 0000: \***    VERSION A.              ROBERT COWEY.                       18 AUG 1992.
4863: 0000: \***    Original version created by merging AFFLDD and AFNUMD.
4864: 0000: \***
4865: 0000: \***    VERSION B.              Steve Windsor                          Nov 1992.
4866: 0000: \***    Addition of new fields for the CASTLE project.
4867: 0000: \***    Supervisor flag and operator model.
4868: 0000: \***
4869: 0000: \***    VERSION C.              ROBERT COWEY.                       03 MAR 1994.
4870: 0000: \***    Defined fields DATE.PSWD.CHANGE$, and MODEL.FLAGS.1% and ...2%.
4871: 0000: \***
4872: 0000: \***    VERSION D.             Mike Bishop                          30 JUN 2004
4873: 0000: \***    Defined field AF.STAFF.NUM$ AF.EMPLOYEE.FLAG$
4874: 0000: \***
4875: 0000: \***    VERSION E.             Alan Carr  (AJC)                      4 Oct 2004
4876: 0000: \***    Defined field AF.RECEIPT.NAME$
4877: 0000: \***
4878: 0000: \***    VERSION F.             Alan Carr  (AJC)                     31 Jan 2005
4879: 0000: \***    Defined field AF.GROUP.CODE$
4880: 0000: \***
4881: 0000: \***    REVISION 1.6.                ROBERT COWEY.                15 JUN 2009.
4882: 0000: \***    Changes for A9C POS improvements project.
4883: 0000: \***    Used up last available three bytes of EALAUTH user data by redefining 
4884: 0000: \***    remaining AF.USER$ variable as AF.BIRTH.DATE$.
4885: 0000: \***    See IBM manual "GSA Programming Guide" Appendix A-27 for file layout 
4886: 0000: \***    describing INDICAT flags (and position of original 20 bytes user data).
4887: 0000: \***
4888: 0000: \***    REVISION 1.7.                ROBERT COWEY.                22 JUN 2009.
4889: 0000: \***    Changes for A9C POS improvements project creating PSB99.286 Rv 1.8.
4890: 0000: \***    Defect 3247 - Redefined AF.BIRTH.DATE$ format as UPD-hex DDMCYY.
4891: 0000: \***    Description text change only - No code changes to this file.
4892: 0000: \***
4893: 0000: \*******************************************************************************
4894: 0000: \*******************************************************************************
4895: 0000: 
4896: 0000: 
4897: 0000:     STRING GLOBAL \
4898: 0000:         AF.BIRTH.DATE$,       \ ! 3 byte DDMCYY UPD/hex format         ! 1.7 RC
4899: 0000:                               \ ! M is month  A=Oct B=Nov C=Dec        ! 1.7 RC
4900: 0000:                               \ ! C is century  0=19xx 1=20xx          ! 1.7 RC
4901: 0000:         AF.DATE.PSWD.CHANGE$, \ ! 3 bytes UPD                          ! CRC
4902: 0000:         AF.FILE.NAME$, \
4903: 0000:         AF.FLAGS.01.12$, \      ! 15 bytes
4904: 0000:         AF.FLAGS.13.16$, \      ! 4 bytes
4905: 0000:         AF.OPERATOR.NAME$,\     ! 20 bytes
4906: 0000:         AF.OPERATOR.NO$, \      ! 4 byte UPD (key)
4907: 0000:         AF.OPTIONS.KEY$, \      ! 1 byte UPD
4908: 0000:         AF.PASSWORD$, \         ! 4 byte UPD
4909: 0000:         AF.RECEIPT.NAME$, \     ! 12 bytes                             ! AJC
4910: 0000:         AF.STAFF.NUM$, \         ! 4 byte UPD                          DMB
4911: 0000:         AF.EMPLOYEE.FLAG$, \     ! 1 byte UPD                          DMB
4912: 0000:         AF.GROUP.CODE$, \       ! 1  byte UPD                          AJC
4913: 0000: \       AF.USER$, \             ! 3  bytes                             ! 1.6 RC
4914: 0000:         AF.SUP.FLAG$, \         ! 1  byte                              BSJW
4915: 0000:         AF.OP.MODEL$            ! 3  bytes                             BSJW
4916: 0000: 
4917: 0000:     INTEGER*1 GLOBAL \
4918: 0000:         AF.INDICAT4%, \
4919: 0000:         AF.INDICAT5%, \
4920: 0000:         AF.INDICAT6%, \
4921: 0000:         AF.INDICAT7%, \
4922: 0000:         AF.INDICAT8%, \
4923: 0000:         AF.INDICAT9%, \
4924: 0000:         AF.INDICAT10%, \
4925: 0000:         AF.INDICAT11%, \
4926: 0000:         AF.INDICAT12%, \
4927: 0000:         AF.INDICAT13%, \
4928: 0000:         AF.INDICAT14%, \
4929: 0000:         AF.INDICAT15%, \
4930: 0000:         AF.INDICAT16%, \
4931: 0000:         AF.REPORT.NUM%
4932: 0000: 
4933: 0000:     INTEGER*2 GLOBAL \
4934: 0000:         AF.INDICAT1%, \
4935: 0000:         AF.INDICAT2%, \
4936: 0000:         AF.INDICAT3%, \
4937: 0000:         AF.MODEL.FLAGS.1%, \                                           ! CRC
4938: 0000:         AF.MODEL.FLAGS.2%, \                                           ! CRC
4939: 0000:         AF.RECL%, \
4940: 0000:         AF.SESS.NUM%
4941: 0000: 
4942: 0000:  %INCLUDE UBDEC.J86                       ! 2.7SH
4943: 0000: \/******************************************************************/
4944: 0000: \/*                                                                */
4945: 0000: \/* UOD Banked FILE GLOBAL VARIABLE DECLARATIONS                   */
4946: 0000: \/*                                                                */
4947: 0000: \/* REFERENCE   : UBDEC.J86                                        */
4948: 0000: \/*                                                                */
4949: 0000: \/* VERSION A.          Stuart Highley            14 August 2008   */
4950: 0000: \/                                                                 */
4951: 0000: \/* VERSION B.          Charles Skadorwa          9 October 2008   */
4952: 0000: \/*                                                                */
4953: 0000: \/* VERSION C.          Stuart Highley            16 December 2008 */
4954: 0000: \/* Look carefully below and ye shall find my change.              */
4955: 0000: \/*                                                                */
4956: 0000: \/* VERSION D.          Mark Goode                22nd December 08 */
4957: 0000: \/* Changes to the fields on the audit record                      */
4958: 0000: \/******************************************************************/
4959: 0000: 
4960: 0000:    STRING GLOBAL                \
4961: 0000:       UB.TEMP.NAME$,            \
4962: 0000:       UB.FILE.NAME$,            \
4963: 0000:       UB.REC$,                  \
4964: 0000:       UB.REC.TYPE$,             \
4965: 0000:       UB.OP.ID$,                \
4966: 0000:       UB.METHOD$,               \
4967: 0000:       UB.REPORT.RQD$,           \
4968: 0000:       UB.LICENCE$,              \
4969: 0000:       UB.DESPATCH.DATE$,        \
4970: 0000:       UB.BOOKED.DATE$,          \
4971: 0000:       UB.BOOKED.TIME$,          \
4972: 0000:       UB.BOOK.TYPE$,            \
4973: 0000:       UB.BAR.CODE$,             \
4974: 0000:       UB.QTY$,                  \
4975: 0000:       UB.DRVR.ID$,              \
4976: 0000:       UB.DRVR.CHCK.DATE$,       \
4977: 0000:       UB.DRVR.CHCK.TIME$,       \
4978: 0000:       UB.DRVR.GIT.MATCH$,       \
4979: 0000:       UB.REC.COUNT$,            \
4980: 0000:       UB.ONIGHT.DELIVERY.TYPE$, \                                !BCSk
4981: 0000:       UB.DRIVER.CHECKIN.REQD$,  \                                !BCSk
4982: 0000:       UB.DRVR.REJECTED$,        \ "Y" or "N" on batch rec,       !CSH
4983: 0000:                                 \ " " on session rec             !CSH
4984: 0000:       UB.DRVR.CONFIRM.SCAN$,    \                                !BCSk
4985: 0000:       UB.BOOKED.STATUS$                                          !DMG
4986: 0000:       
4987: 0000:    INTEGER*2 GLOBAL             \
4988: 0000:       UB.RECL%,                 \
4989: 0000:       UB.REPORT.NUM%,           \
4990: 0000:       UB.SESS.NUM%
4991: 0000: 
4992: 0000: \/******************************************************************/
4993: 0000:  
4994: 0000: \*****************************************************************************
4995: 0000: \*****************************************************************************
4996: 0000: \***                                                                       ***
4997: 0000: \***      V A R I A B L E   D E C L A R A T I O N S                        ***
4998: 0000: \***                                                                       ***
4999: 0000: \*****************************************************************************
5000: 0000: \*****************************************************************************
5001: 0000: 
5002: 0000: INTEGER*1 GLOBAL                          \
5003: 0000:         ASN.ACTIVE%,                      \ 2.5NWB
5004: 0000:         BC.CHECK%(1),                     \ FLC
5005: 0000:         ERROR.COUNT%,                     \
5006: 0000:         REC.MAX%,                         \
5007: 0000:         LDT.TRANSMIT,                     \ HDS
5008: 0000:         NESTING.LEVEL%,                   \ FLC
5009: 0000:         TRUE,                             \ HDS
5010: 0000:         FALSE,                            \ HDS
5011: 0000:         PORT.EVENT%,                      \ FLC
5012: 0000:         RE.CHAIN,                         \ DSW
5013: 0000:         WARM.START,                       \ DSW
5014: 0000:         GAP,                              \ GMJK
5015: 0000:         CCBUF.ENTRY.REQUIRED,             \ GMJK
5016: 0000:         CCBUF.RECS.PRESENT,               \ GMJK
5017: 0000:         CCREJ.RECS.PRESENT,               \ 2.2JAS
5018: 0000:         DETAIL.RECORDS.RECEIVED,          \ GMJK
5019: 0000:         END.OF.CCTMP,                     \ GMJK
5020: 0000:         END.OF.FILE,                      \ GMJK
5021: 0000:         TABLE.FULL,                       \ GMJK
5022: 0000:         REWKF.RECS.PRESENT,               \ 2.6BG
5023: 0000:         ALL.PRODUCTS                      ! 1.8DA
5024: 0000: \       ALLOW.CSR.PROCESSING              ! 1.2 !2.5NWB
5025: 0000: 
5026: 0000: INTEGER*2 GLOBAL                          \
5027: 0000:         ACTUAL.NUM.OF.UODS%,              \ FLC
5028: 0000:         BTSCNT%,                          \2.3CS
5029: 0000:         EANCNT%,                          \2.3CS
5030: 0000:         COUNTED.ITEMS%,                   \ FLC
5031: 0000: \       CSR.ITEMS.COUNT%,                 \     !2.5NWB
5032: 0000:         CSR.AUDIT.SESS.NUM%,              \ CDS
5033: 0000:         CURRENT.REPORT.NUM%,              \ DLC
5034: 0000:         EXPECTED.NUM.OF.UODS%,            \ FLC
5035: 0000:         FILE.HEADER.LISTS%,               \ FLC
5036: 0000:         FILE.TRAILER.LISTS%,              \ FLC
5037: 0000:         FIRST.TIME,                       \ CDS
5038: 0000:         ORDERS.EXPECTED%,                 \ CDS
5039: 0000:         INT.DELAY%,                       \ FLC
5040: 0000:         ITEMS.BOOKED.IN%,                 \ CDS
5041: 0000:         ITEM.COUNT%,                      \ FLC
5042: 0000:         LINES.BOOKED.IN%,                 \ CDS
5043: 0000:         LINES.ADDED%,                     \ CDS
5044: 0000:         LINE.TOTAL%,                      \ CDS
5045: 0000:         LIST.COUNT%,                      \ FLC
5046: 0000:         LIST.TRAILER.ITEMS%,              \ FLC
5047: 0000:         ONORD.COUNT%,                     \
5048: 0000:         ORDERS.FOUND%,                    \ CDS
5049: 0000:         RC%,                              \ DLC
5050: 0000:         SINGLES.ADDED%,                   \ CDS
5051: 0000:         TYPE.17.WRITTEN,                  \ CDS
5052: 0000:         UOD.NUM.ITEMS%,                   \ FLC
5053: 0000:         ACTUAL.NUM%,                      \ GMJK
5054: 0000:         ACTUAL.UOD.ITEMS%,                \ GMJK
5055: 0000:         CURR.ITEM%,                       \ GMJK
5056: 0000:         CURR.REC%,                        \ GMJK
5057: 0000:         CURR.SUBSCRIPT%,                  \ GMJK
5058: 0000:         EXPECTED.NUM%,                    \ GMJK
5059: 0000:         FILE.NUM%,                        \ GMJK
5060: 0000:         ITEM.POS%,                        \ GMJK
5061: 0000:         MAX.TABLE.SIZE%,                  \ GMJK
5062: 0000:         NUM.BARCODES%,                    \ GMJK
5063: 0000:         NUM.BC.EXTRACTED%,                \ GMJK
5064: 0000:         NUM.ITEMS%,                       \ GMJK
5065: 0000:         NUM.STATUS.O.C.X.UODS%,           \ 1.4
5066: 0000:         NUM.OF.CANCELLED.UODS%,           \ 1.4
5067: 0000:         NUM.OF.DESPATCHED.UODS%,          \ 1.4
5068: 0000:         NUM.RECORDS%,                     \ GMJK
5069: 0000:         RECORD$,                          \ GMJK
5070: 0000:         REC.NUM%,                         \ GMJK
5071: 0000:         RECS.PER.SECTOR%,                 \ GMJK
5072: 0000:         BC%,CG%,PG%,                      \ 1.8DA
5073: 0000:         SECTOR%                           ! GMJK
5074: 0000: 
5075: 0000: INTEGER*4 GLOBAL                          \
5076: 0000:         LAST.ACTIVE%,                     \
5077: 0000:         LAST.STOCKTAKE%,                  \ 1.5
5078: 0000:         TIMEOUT.VALUE%                    ! FLC
5079: 0000: 
5080: 0000: 
5081: 0000: STRING GLOBAL                             \ for modules 00, 01 , 02 , 03 and 04
5082: 0000:         ACK$,                             \ 1.5
5083: 0000:         ALL.FILES.CLOSED$,                \
5084: 0000:         APPL$,                            \ FLC
5085: 0000:         APPLICATION.NO$,                  \
5086: 0000:         BAR.CODES$(1),                    \ FLC
5087: 0000:         BCSMF.RECORD$,                    \ GMJK
5088: 0000:         BOOKING.STARTED$,                 \ CDS
5089: 0000:         BOOKING.ENDED$,                   \ CDS
5090: 0000:         CCUOD.OPEN.FLAG$,                 \ GMJK
5091: 0000:         CCLAM.OPEN.FLAG$,                 \ 1.4
5092: 0000:         CCITM.OPEN.FLAG$,                 \ GMJK
5093: 0000:         CCTRL.OPEN.FLAG$,                 \ GMJK
5094: 0000:         CCDMY.OPEN.FLAG$,                 \ GMJK
5095: 0000:         CCTMP.OPEN.FLAG$,                 \ GMJK
5096: 0000:         CCBUF.OPEN.FLAG$,                 \ GMJK
5097: 0000:         CCUPF.OPEN.FLAG$,                 \ HMJK
5098: 0000:         CCWKF.OPEN.FLAG$,                 \ GMJK
5099: 0000:         STKRC.OPEN.FLAG$,                 \ 1.8DA
5100: 0000:         XGCF.OPEN.FLAG$,                  \ 1.8DA
5101: 0000:         STKEX.OPEN.FLAG$,                 \ 1.8DA
5102: 0000:         STKIF.OPEN.FLAG$,                 \ 1.8DA
5103: 0000:         LOCCNT.OPEN.FLAG$,                \ 1.8DA
5104: 0000:         STKTF.OPEN.FLAG$,                 \ 1.8DA
5105: 0000:         STKDC.OPEN.FLAG$,                 \ 1.8DA
5106: 0000: \       CSR.LIST.ALREADY.PROCESSED.FLAG$, \ !2.5NWB
5107: 0000: \       CSR.OPEN.FLAG$,                   \ !2.5NWB
5108: 0000:         CHKBF.OPEN.FLAG$,                 \ DSW
5109: 0000:         GAPBF.OPEN.FLAG$,                 \ SDH  2.3CS !2.4BG
5110: 0000:         PLLOL.OPEN.FLAG$,                 \ 2.3CS
5111: 0000:         PLLDB.OPEN.FLAG$,                 \ 2.3CS
5112: 0000:         PLLDB.TABLE$(1),                  \ 2.3CS
5113: 0000:         EAN.TABLE$(1),                    \ 2.3CS
5114: 0000: \       CITEM.OPEN.FLAG$,                 \ !2.5NWB
5115: 0000: \       CIMF.OPEN.FLAG$,                  \ !2.5NWB
5116: 0000: \       CSRWF.OPEN.FLAG$,                 \ !2.5NWB
5117: 0000: \       CSRBF.OPEN.FLAG$,                 \ !2.5NWB
5118: 0000:         CSR.AUDIT.FILE$,                  \ CDS
5119: 0000:         CSR.AUDIT.DATA$,                  \ CDS
5120: 0000:         CSR.AUDIT.OPEN.FLAG$,             \ CDS
5121: 0000:         CURR.LIST$,                       \ FLC
5122: 0000:         CURR.TERMINAL$,                   \
5123: 0000:         CURRENT.CODE$,                    \ DLC
5124: 0000:         DATA.IN$,                         \
5125: 0000:         DATE.TODAY$,                      \ FLC
5126: 0000:         STKMQ.OPEN.FLAG$,                 \ CDS
5127: 0000:         STLDT.OPEN.FLAG$,                 \ 1.6
5128: 0000:         BCSMF.OPEN.FLAG$,                 \ CDS
5129: 0000:         IEF.OPEN.FLAG$,                   \ CDS
5130: 0000:         DATA.FILES.REQ$,                  \ GMJK
5131: 0000:         DETAIL.RECORDS.RECEIVED$,         \ FLC
5132: 0000:         DIREC.OPEN.FLAG$,                 \ CDS
5133: 0000:         DIRORD.OPEN.FLAG$,                \ CDS
5134: 0000:         DIRSUP.OPEN.FLAG$,                \ CDS
5135: 0000:         DIRWF.OPEN.FLAG$,                 \ CDS
5136: 0000:         EPSOM.OPEN.FLAG$,                 \ FLC
5137: 0000:         LDTAF.OPEN.FLAG$,                 \ GMJK
5138: 0000:         LDTCF.OPEN.FLAG$,                 \ CDS
5139: 0000:         DRSMQ.OPEN.FLAG$,                 \ CDS
5140: 0000:         FILE.OPERATION$,                  \ DLC
5141: 0000: \       FIRST.CSR.LIST.FOR.PDT$,          \ 2.5NWB
5142: 0000:         FIRST.EOT.FOR.THIS.PDT$,          \
5143: 0000:         FIRST.ITEM.TO.BE.PROCESSED$,      \
5144: 0000:         FIRST.RETURN$,                    \ FLC
5145: 0000:         FPF.OPEN.FLAG$,                   \
5146: 0000:         HOLD.FLAG$,                       \
5147: 0000:         IDF.OPEN.FLAG$,                   \
5148: 0000:         IDSOF.OPEN.FLAG$,                 \ ELC
5149: 0000:         IRF.OPEN.FLAG$,                   \ FLC
5150: 0000:         IMSTC.OPEN.FLAG$,                 \1.7BG
5151: 0000:         LAST.ACTIVE.DATE$,                \
5152: 0000:         LAST.STOCKTAKE.DATE$,             \ 1.5
5153: 0000:         LAST.MESSAGE$,                    \
5154: 0000:         LOG.ON.DATE$,                     \ GMJK
5155: 0000:         LOG.ON.TIME$,                     \ GMJK
5156: 0000:         LDTBF.HEADER.WRITTEN$,            \ ELC
5157: 0000:         LDTBF.OPEN.FLAG$,                 \ ELC
5158: 0000:         LIST.ABANDONED$,                  \
5159: 0000:         LIST.BC$,                         \ FLC
5160: 0000:         LIST.TRANSMIT$(1),                \ FLC
5161: 0000:         LSSST.OPEN.FLAG$,                 \1.7BG
5162: 0000:         MONITORED.PORT$,                  \ DLC
5163: 0000:         NUM.SECTOR$,                      \ GMJK
5164: 0000:         ONORD.OPEN.FLAG$,                 \
5165: 0000:         ONORD.DELETED$(1),                \
5166: 0000:         ORDER.LINE.TABLE$(1),             \ CDS
5167: 0000:         PCHK.OPEN.FLAG$,                  \
5168: 0000:         PDT.ACTION$,                      \ FLC
5169: 0000:         PIITM.OPEN.FLAG$,                 \ FLC
5170: 0000:         PILST.OPEN.FLAG$,                 \ FLC
5171: 0000:         PIPE.OUT$,                        \
5172: 0000:         PDTWF.OPEN.FLAG$,                 \ FLC
5173: 0000:         PK2$,                             \
5174: 0000:         PK4$,                             \
5175: 0000:         PORT.STRING$,                     \
5176: 0000:         PREV.LOGGED.STATE$,               \ ELC
5177: 0000: \       PROCESS.CSR.WORKFILE$,            \ !2.5NWB
5178: 0000:         PSS38.STATUS$,                    \ FLC
5179: 0000:         RB.OPEN.FLAG$,                    \ 2.6BG
5180: 0000:         REWKF.OPEN.FLAG$,                 \ 2.6BG
5181: 0000:         RECALLS.OPEN.FLAG$,               \ 2.6BG
5182: 0000:         DELVINDX.OPEN.FLAG$,              \ 2.7SH
5183: 0000:         AF.OPEN.FLAG$,                    \ 2.7SH
5184: 0000:         UB.OPEN.FLAG$,                    \ 2.7SH
5185: 0000:         RECEIVE.STATE$,                   \
5186: 0000:         REQ.LIST.STORE$(1),               \ FLC
5187: 0000:         REQ.LIST.DATA$(1),                \ FLC
5188: 0000:         SAVED.ORDER.NO$,                  \ CDS
5189: 0000:         SAVED.ORDER.SUFFIX$,              \ CDS
5190: 0000:         SAVED.PAGE.NO$,                   \ CDS
5191: 0000:         SAVED.STORE.NUMBER$,              \ 1.8DA
5192: 0000:         SAVED.SUPPLIER.NO$,               \ CDS
5193: 0000:         SECTOR$,                          \ GMJK
5194: 0000:         SOFTS.OPEN.FLAG$,                 \ GMJK
5195: 0000:         SOH$,                             \ 1.5
5196: 0000:         STORED.UOD.HEADER$,               \ FLC
5197: 0000:         STORE.NUMBER$,                    \ 1.5
5198: 0000:         STOCK.OPEN.FLAG$,                 \1.7BG
5199: 0000:         STX$,                             \ FLC
5200: 0000:         STKBF.OPEN.FLAG$,                 \ 1.5
5201: 0000:         SXTMP.OPEN.FLAG$,                 \ 1.5
5202: 0000:         T.DATE$,                          \ 1.5
5203: 0000:         T.TIME$,                          \ 1.5
5204: 0000:         TEMP.TIME$,                       \ GMJK
5205: 0000:         TRAILER.LIST$,                    \ FLC
5206: 0000:         UOD.NUMBER$,                      \ FLC
5207: 0000:         UOD.NUM.ITEMS$,                   \ FLC
5208: 0000:         UOD.OPEN.FLAG$,                   \ FLC
5209: 0000:         UOD.STATUS.FLAG$,                 \ FLC
5210: 0000:         UODBF.OPEN.FLAG$,                 \ FLC
5211: 0000:         UODTF.OPEN.FLAG$,                 \ FLC
5212: 0000:         UNITS.OPEN.FLAG$
5213: 0000: 
5214: 0000: STRING GLOBAL                             \ GMJK
5215: 0000:         ITEM.STORAGE$,                    \ GMJK
5216: 0000:         ITEM.DESC.STORAGE$,               \ GMJK
5217: 0000:         BARCODE.DATA$,                    \ GMJK
5218: 0000:         BARCODE.INDEX$,                   \ GMJK
5219: 0000:         BARCODE.INDEX.STORAGE$,           \ GMJK
5220: 0000:         BARCODE.STORAGE$,                 \ GMJK
5221: 0000:         ITEM.DATA$,                       \ GMJK
5222: 0000:         ITEM.DATA.DESC$,                  \ GMJK
5223: 0000:         ITEM.POS.TABLE$(1),               \ GMJK
5224: 0000:         CCUOD.TABLE$(1),                  \ GMJK
5225: 0000:         CCLAM.TABLE$(1),                  \ 1.4
5226: 0000:         DATA.FILES.REQUIRED$,             \ GMJK
5227: 0000:         FINISH.DATE$,                     \ GMJK
5228: 0000:         FINISH.TIME$,                     \ GMJK
5229: 0000:         LDT.CCUOD.UPDATE.DATE$,           \ GMJK
5230: 0000:         LDT.CCUOD.UPDATE.TIME$,           \ GMJK
5231: 0000:         LDT.DATE.TIME$,                   \ GMJK
5232: 0000:         LDT.LAST.CLAIM.NUM$,              \ GMJK
5233: 0000:         STKCF.OPEN.FLAG$,                 \ 1.8DA
5234: 0000:         STKMF.OPEN.FLAG$,                 \ 1.8DA
5235: 0000:         CONCEPT.GROUPS$(1),               \ 1.8DA
5236: 0000:         PRODUCT.GROUPS$(1),               \ 1.8DA
5237: 0000:         BUSINESS.CENTRES$(1),             \ ! 1.8DA 2.1JAS
5238: 0000:         SOPTS.OPEN.FLAG$,                 \ ! 2.1JAS
5239: 0000:         LOCAL.OPEN.FLAG$,                 \ ! 2.1JAS
5240: 0000:         TSF.OPEN.FLAG$,                   \ ! 2.1JAS 2.2JAS
5241: 0000:         CCREJ.OPEN.FLAG$,                 \ 2.2JAS
5242: 0000:         CREDIT.CLAIM.FLAG$                ! 2.2JAS
5243: 0000: 
5244: 0000: 
5245: 0000: STRING GLOBAL                             \
5246: 0000:         BATCH.SCREEN.FLAG$,               \
5247: 0000:         EXP.STATES$,                      \
5248: 0000:         MODULE.NUMBER$,                   \
5249: 0000:         OPERATOR.ID$,                     \
5250: 0000:         STATE$,                           \
5251: 0000:         TRANS.FROM$,                      \
5252: 0000:         TRANS.TO$
5253: 0000: 
5254: 0000:  STRING GLOBAL                            \
5255: 0000:         REC.CHECK$(1),                    \
5256: 0000:         V.TAB$(1)
5257: 0000: 
5258: 0000: \*****************************************************************************
5259: 0000: \*****************************************************************************
5260: 0000: \***                                                                       ***
5261: 0000: \*** E X T E R N A L   F U N C T I O N   D E C L A R A T I O N S           ***
5262: 0000: \***                                                                       ***
5263: 0000: \*****************************************************************************
5264: 0000: \*****************************************************************************
5265: 0000: 
5266: 0000: \*****************************************************************************
5267: 0000: \***   include external definitions for the following functions
5268: 0000: \***
5269: 0000: \***     ADXERROR
5270: 0000: \***     ADXSERVE
5271: 0000: \***     ADXSERCL
5272: 0000: \***     APPLICATION.LOG             01
5273: 0000: \***     READ.NEXT.IEF               11
5274: 0000: \***     SORT.TABLE                  14
5275: 0000: \***     CONV.TO.HEX                 16
5276: 0000: \***     CONV.TO.STRING              17
5277: 0000: \***     SESS.NUM.UTILITY            20
5278: 0000: \***     STKMQ
5279: 0000: \***     BCSMF
5280: 0000: \***     IDF
5281: 0000: \***     INVOK
5282: 0000: \***     PCHK
5283: 0000: \***     UOD
5284: 0000: \***     UODBF
5285: 0000: \***     UODTF
5286: 0000: \***     STKBF
5287: 0000: \***     SXTMP
5288: 0000: \***     SSPSC
5289: 0000: \***     BTCS
5290: 0000: \***     PRINT
5291: 0000: \***     SOPTS
5292: 0000: \***     LOCAL
5293: 0000: \***
5294: 0000: \*****************************************************************************
5295: 0000: 
5296: 0000:  %INCLUDE ADXERROR.J86
5297: 0000: \******************************************************************************
5298: 0000: \******************************************************************************
5299: 0000: \***                                                                        ***
5300: 0000: \***    %INCLUDE FOR FUNCTION ADXERROR (an I.B.M. system function)          ***
5301: 0000: \***                                                                        ***
5302: 0000: \***         AUTHOR        :  Stephen Kelsey                                ***
5303: 0000: \***                                                                        ***
5304: 0000: \***         DATE WRITTEN  :  21st February 1986                            ***
5305: 0000: \***                                                                        ***
5306: 0000: \***         DATE OF LAST REVISION  - 21st February 1986                    ***
5307: 0000: \***                                                                        ***
5308: 0000: \***         VERSION B     :  Stuart William McConnachie  18th March 1997   ***
5309: 0000: \***    Define size of ADXERROR return value from function.  This change    ***
5310: 0000: \***    was introduced by IBM in the 4690 Programming Guide.  Not defining  ***
5311: 0000: \***    this variable can cause Memory Protection Violations at run time.   ***
5312: 0000: \***                                                                        ***
5313: 0000: \******************************************************************************
5314: 0000: \******************************************************************************
5315: 0000: 
5316: 0000:    FUNCTION ADXERROR (TERM%,                                                  \
5317: 0000:                       MSGGRP%,                                                \
5318: 0000:                       MSGNUM%,                                                \
5319: 0000:                       SEVERITY%,                                              \
5320: 0000:                       EVENT.NUM%,                                             \
5321: 0000:                       UNIQUE$) EXTERNAL
5322: 0000: 
5323: 0000:       INTEGER*2  MSGNUM%,                                                     \
5324: 0000:                  TERM%,                                                       \
5325: 0000:                  ADXERROR                                                     !BSWM
5326: 0000: 
5327: 0000:       INTEGER*1 EVENT.NUM%,                                                   \
5328: 0000:                 MSGGRP%,                                                      \
5329: 0000:                 SEVERITY%
5330: 0000: 
5331: 0000:       STRING  UNIQUE$
5332: 0000: 
5333: 0000:    END FUNCTION
5334: 0000: 
5335: 0000:  %INCLUDE ADXSERVE.J86
5336: 0000: \******************************************************************************
5337: 0000: \******************************************************************************
5338: 0000: \***                                                                        ***
5339: 0000: \***    %INCLUDE FOR FUNCTION ADXSERVE (an I.B.M. system function)          ***
5340: 0000: \***                                                                        ***
5341: 0000: \***         AUTHOR        :  Bruce Scriver                                 ***
5342: 0000: \***                                                                        ***
5343: 0000: \***         DATE WRITTEN  :  14th March 1986                               ***
5344: 0000: \***                                                                        ***
5345: 0000: \***         DATE OF LAST REVISION  - 14th March 1986                       ***
5346: 0000: \***                                                                        ***
5347: 0000: \***                                                                        ***
5348: 0000: \******************************************************************************
5349: 0000: \******************************************************************************
5350: 0000: 
5351: 0000:    SUB ADXSERVE (RETURN.CODE%,                                                \
5352: 0000:                  ADX.FUNCTION%,                                               \
5353: 0000:                  ADX.PARM.1%,                                                 \
5354: 0000:                  ADX.PARM.2$)                                                 \
5355: 0000:    EXTERNAL
5356: 0000:   
5357: 0000:       STRING     ADX.PARM.2$
5358: 0000: 
5359: 0000:       INTEGER*2  ADX.FUNCTION%,                                               \
5360: 0000:                  ADX.PARM.1%
5361: 0000: 
5362: 0000:       INTEGER*4  RETURN.CODE%                                                 \
5363: 0000: 
5364: 0000:    END SUB     
5365: 0000: 
5366: 0000:  %INCLUDE ADXSERCL.J86                    ! DSW
5367: 0000: SUB ADXSERCL EXTERNAL
5368: 0000: END SUB
5369: 0000:  %INCLUDE PSBF01E.J86                     ! DLC
5370: 0000: REM \
5371: 0000: \*******************************************************************************
5372: 0000: \*******************************************************************************
5373: 0000: \***
5374: 0000: \***      %INCLUDE FOR EXTERNAL DEFINITION OF FUNCTION APPLICATION.LOG
5375: 0000: \***
5376: 0000: \***                      FUNCTION NUMBER   : PSBF01
5377: 0000: \***
5378: 0000: \***                    INCLUDE REFERENCE : PSBF01E.J86
5379: 0000: \*** 
5380: 0000: \***      Version B           Andrew Wedgeworth          1st July 1992
5381: 0000: \***      Three parameters which passed to the function have been removed.
5382: 0000: \***      APPLICATION.LOG has been added as a variable name (this holds the
5383: 0000: \***      return code).
5384: 0000: \***
5385: 0000: \*******************************************************************************
5386: 0000: 
5387: 0000: 
5388: 0000:    FUNCTION APPLICATION.LOG (MESSAGE.NO%,                                     \
5389: 0000:                              VAR.STRING.1$,                                   \
5390: 0000:                              VAR.STRING.2$,                                   \
5391: 0000:                              EVENT.NO%)  EXTERNAL
5392: 0000: 
5393: 0000:       INTEGER*1 EVENT.NO%
5394: 0000: 
5395: 0000:       INTEGER*2 APPLICATION.LOG,                                       \ GAW
5396: 0000:                 MESSAGE.NO%
5397: 0000: 
5398: 0000:       STRING VAR.STRING.1$,                                            \
5399: 0000:              VAR.STRING.2$
5400: 0000: 
5401: 0000:    END FUNCTION
5402: 0000: 
5403: 0000: \*******************************************************************************
5404: 0000:  %INCLUDE PSBF05E.J86                     ! 1.9BG
5405: 0000: REM\
5406: 0000: \*******************************************************************************
5407: 0000: \*******************************************************************************
5408: 0000: \***
5409: 0000: \***        INCLUDE       : CHECK.BOOTS.CODE external definition
5410: 0000: \***
5411: 0000: \***        REFERENCE     : PSBF05E.J86
5412: 0000: \***
5413: 0000: \***        Version A       Bruce Scriver                  24th February 1986  
5414: 0000: \*** 
5415: 0000: \***        Version B       Andrew Wedgeworth                  15th July 1992 
5416: 0000: \***        Redundant parameters removed, and CHECK.BOOTS.CODE defined as a 
5417: 0000: \***        variable to hold the return code.  
5418: 0000: \***
5419: 0000: \*******************************************************************************
5420: 0000: \*******************************************************************************
5421: 0000: 
5422: 0000:    FUNCTION CHECK.BOOTS.CODE (BOOTS.CODE$)                                     \
5423: 0000:    EXTERNAL
5424: 0000:    ! 3 parameters removed from here                                    ! BAW   
5425: 0000: 
5426: 0000:       STRING BOOTS.CODE$
5427: 0000:    ! 3 variables removed from here                                     ! BAW
5428: 0000:    
5429: 0000:       INTEGER*2 CHECK.BOOTS.CODE                                       ! BAW
5430: 0000:    
5431: 0000: 
5432: 0000:    END FUNCTION
5433: 0000: 
5434: 0000: !%INCLUDE PSBF06E.J86                     ! FLC
5435: 0000:  %INCLUDE PSBF11E.J86                     ! DLC
5436: 0000: REM \
5437: 0000: \*******************************************************************************
5438: 0000: \*******************************************************************************
5439: 0000: \***
5440: 0000: \***    %INCLUDE FOR EXTERNAL DEFINITION OF FUNCTION READ.NEXT.IEF
5441: 0000: \***
5442: 0000: \***
5443: 0000: \***            FUNCTION NUMBER       : PSBF11
5444: 0000: \***
5445: 0000: \***            INCLUDE REFERENCE     : PSBF11E.J86
5446: 0000: \***
5447: 0000: \***            DATE OF LAST AMENDMENT -  3rd March 1986
5448: 0000: \***
5449: 0000: \***     Version B             Andrew Wedgeworth          15th July 1992
5450: 0000: \***     Removal of redundant function parameters.  READ.NEXT.IEF defined as
5451: 0000: \***     a variable to hold the return code.
5452: 0000: \***
5453: 0000: \*******************************************************************************
5454: 0000: \*******************************************************************************
5455: 0000: 
5456: 0000: REM \
5457: 0000: \*******************************************************************************
5458: 0000: \*******************************************************************************
5459: 0000: \***
5460: 0000: \***
5461: 0000: \***            FUNCTION OVERVIEW
5462: 0000: \***            -----------------
5463: 0000: \***
5464: 0000: \***   This function finds and retreives the next bar code in an IEF chain.
5465: 0000: \***   If the code found is the last code in the chain, the function checks that
5466: 0000: \***   the number of codes in the chain is equal to the expected number.  If it
5467: 0000: \***   is not, a message is displayed and logged.  If an error occurs in reading
5468: 0000: \***   the IEF, a message is displayed and logged, and the function returns to
5469: 0000: \***   the calling program with a return code of 1.
5470: 0000: \***
5471: 0000: \***
5472: 0000: \*******************************************************************************
5473: 0000: \*******************************************************************************
5474: 0000: 
5475: 0000:    FUNCTION READ.NEXT.IEF (LAST.BAR.CODE$,                             \
5476: 0000:                            TOTAL.COUNT%,                               \
5477: 0000:                            BOOTS.CODE$)  EXTERNAL
5478: 0000:    ! 3 parameters deleted from here                                    ! BAW			   
5479: 0000: 
5480: 0000:       STRING  BOOTS.CODE$,                                             \
5481: 0000:               LAST.BAR.CODE$
5482: 0000:       ! 3 variables removed from here                                  ! BAW
5483: 0000: 
5484: 0000:       INTEGER*2 READ.NEXT.IEF,                                         \ BAW
5485: 0000:                 TOTAL.COUNT%
5486: 0000:              
5487: 0000: 
5488: 0000: 
5489: 0000:    END FUNCTION
5490: 0000: 
5491: 0000: \*******************************************************************************
5492: 0000:  %INCLUDE PSBF14E.J86                     ! DLC
5493: 0000: REM\
5494: 0000: \*******************************************************************************
5495: 0000: \*******************************************************************************
5496: 0000: \***
5497: 0000: \***        INCLUDE       : SORT.TABLE external definition
5498: 0000: \***
5499: 0000: \***        REFERENCE     : PSBF14E.J86
5500: 0000: \***
5501: 0000: \***        Version A     Bruce Scriver                   3rd March 1986   
5502: 0000: \*** 
5503: 0000: \***        Version B     Andrew Wedgeworth               17th July 1992
5504: 0000: \***        Redundant function parameters removed.  SORT.TABLE defined as a
5505: 0000: \***        variable to hold the return code.
5506: 0000: \***
5507: 0000: \*******************************************************************************
5508: 0000: \*******************************************************************************
5509: 0000: 
5510: 0000:    FUNCTION SORT.TABLE (NUMBER.OF.ENTRIES%)                                    \
5511: 0000:    EXTERNAL
5512: 0000: 
5513: 0000:       INTEGER   NUMBER.OF.ENTRIES%,                                    \ BAW
5514: 0000:                 SORT.TABLE                 
5515: 0000: 
5516: 0000:    END FUNCTION
5517: 0000: 
5518: 0000:  %INCLUDE PSBF16E.J86                     ! DLC
5519: 0000: REM\
5520: 0000: \*******************************************************************************
5521: 0000: \*******************************************************************************
5522: 0000: \***
5523: 0000: \***       %INCLUDE FOR EXTERNAL DEFINITION OF CONV.TO.HEX FUNCTION
5524: 0000: \***
5525: 0000: \***                  REFERENCE     : PSBF16E.J86
5526: 0000: \***
5527: 0000: \***       Version A            Bruce Scriver          25th February 1986
5528: 0000: \***
5529: 0000: \***       Version B           Andrew Wedgeworth            2nd July 1992
5530: 0000: \***       Removal of redundant parameters, and CONV.TO.HEX defined as a 
5531: 0000: \***       variable to hold the return code. 
5532: 0000: \***
5533: 0000: \*******************************************************************************
5534: 0000: \*******************************************************************************
5535: 0000: 
5536: 0000:    FUNCTION CONV.TO.HEX (INTEGER4%)                                            \
5537: 0000:    EXTERNAL
5538: 0000:    ! 3 parameters removed from here                                    ! BAW
5539: 0000: 
5540: 0000:    ! 3 lines deleted from here                                         ! BAW
5541: 0000:    
5542: 0000:       INTEGER*2 CONV.TO.HEX                                            ! BAW
5543: 0000: 
5544: 0000:       INTEGER*4 INTEGER4%
5545: 0000: 
5546: 0000:    END FUNCTION
5547: 0000: 
5548: 0000:  %INCLUDE PSBF17E.J86                     ! DLC
5549: 0000: REM \
5550: 0000: \*******************************************************************************
5551: 0000: \*******************************************************************************
5552: 0000: \***
5553: 0000: \***
5554: 0000: \***       %INCLUDE FOR EXTERNAL DEFINITION OF CONV.TO.STRING FUNCTION
5555: 0000: \***
5556: 0000: \***                     REFERENCE     : PSBF17E.J86
5557: 0000: \***
5558: 0000: \***       Version A            Bruce Scriver       24th February 1986           
5559: 0000: \***
5560: 0000: \***       Version B          Andrew Wedgeworth          2nd July 1992
5561: 0000: \***       Redundant parameters removed, and the function's name is 
5562: 0000: \***       is defined as a variable to hold the return code. 
5563: 0000: \***
5564: 0000: \*******************************************************************************
5565: 0000: \*******************************************************************************
5566: 0000: 
5567: 0000:    FUNCTION CONV.TO.STRING (EVENT.NUMBER%,                                     \
5568: 0000:                             INTEGER4%)                                         \
5569: 0000:    EXTERNAL
5570: 0000: ! 3 parameters removed from here                                       ! BAW
5571: 0000: 
5572: 0000: ! 3 lines deleted from here                                            ! BAW
5573: 0000: 
5574: 0000:       INTEGER*1 EVENT.NUMBER%
5575: 0000: 
5576: 0000:       INTEGER*2 CONV.TO.STRING                                         ! BAW
5577: 0000: 
5578: 0000:       INTEGER*4 INTEGER4%
5579: 0000: 
5580: 0000:    END FUNCTION
5581: 0000: 
5582: 0000:  %INCLUDE PSBF18E.J86                     ! 1.8DA
5583: 0000: REM\
5584: 0000: \*******************************************************************************
5585: 0000: \*******************************************************************************
5586: 0000: \***
5587: 0000: \***        INCLUDE       : CALC.BOOTS.CODE.CHECK.DIGIT external definition
5588: 0000: \***
5589: 0000: \***        REFERENCE     : PSBF18E.J86
5590: 0000: \***
5591: 0000: \***        Version A      Stephen Kelsey                   23rd March 1987 
5592: 0000: \***
5593: 0000: \***        Version B      Andrew Wedgeworth                  7th July 1992 
5594: 0000: \***        Removal of redundant parameters, and inclusion of function's 
5595: 0000: \***        name as a variable to hold the return code.
5596: 0000: \***
5597: 0000: \*******************************************************************************
5598: 0000: \*******************************************************************************
5599: 0000: 
5600: 0000:    FUNCTION CALC.BOOTS.CODE.CHECK.DIGIT (BOOTS.CODE.6.DIGIT$)          \ 
5601: 0000:    EXTERNAL
5602: 0000:    ! 3 parameters removed from here                                    ! BAW
5603: 0000: 
5604: 0000:    STRING BOOTS.CODE.6.DIGIT$
5605: 0000:    ! 3 variables deleted from here                                     ! BAW
5606: 0000:    
5607: 0000:    INTEGER* 2 CALC.BOOTS.CODE.CHECK.DIGIT                              ! BAW
5608: 0000:    
5609: 0000:    END FUNCTION
5610: 0000: 
5611: 0000:  %INCLUDE PSBF20E.J86                     ! DLC
5612: 0000: REM\
5613: 0000: \*******************************************************************************
5614: 0000: \*******************************************************************************
5615: 0000: \***
5616: 0000: \***       %INCLUDE FOR EXTERNAL DEFINITION OF SESS.NUM.UTILITY
5617: 0000: \***
5618: 0000: \***                  REFERENCE     : PSBF20E.J86
5619: 0000: \***
5620: 0000: \***     VERSION C            Janet Smith                13th May 1992
5621: 0000: \***     Increased PASSED.INTEGER to 2 bytes to cater for more than
5622: 0000: \***     128 files.
5623: 0000: \***
5624: 0000: \***     VERSION D.           Andrew Wedgeworth          1st July 1992
5625: 0000: \***     Removal of redundant parameters and addition of SESS.NUM.UTILITY
5626: 0000: \***     as a variable.  This new variable contains the function's return
5627: 0000: \***     code.
5628: 0000: \***
5629: 0000: \*******************************************************************************
5630: 0000: \*******************************************************************************
5631: 0000: 
5632: 0000:    FUNCTION SESS.NUM.UTILITY (FUNCTION.FLAG$,                          \
5633: 0000:                               PASSED.INTEGER%,                         \
5634: 0000:                               PASSED.STRING$)                          \
5635: 0000:    EXTERNAL
5636: 0000: 
5637: 0000:    STRING    FUNCTION.FLAG$,                                           \
5638: 0000:              PASSED.STRING$
5639: 0000:    ! 3 variables removed from here                                     ! CAW
5640: 0000: 
5641: 0000: 
5642: 0000:    INTEGER*2 SESS.NUM.UTILITY,                                         \ CAW
5643: 0000:              PASSED.INTEGER%				               ! CJAS
5644: 0000: 
5645: 0000:    END FUNCTION
5646: 0000: 
5647: 0000:  %INCLUDE PSBF21E.J86                     ! 1.9BG
5648: 0000: REM\
5649: 0000: \*******************************************************************************
5650: 0000: \*******************************************************************************
5651: 0000: \***
5652: 0000: \***        INCLUDE       : CHECK.BAR.CODE external definition
5653: 0000: \***
5654: 0000: \***        REFERENCE     : PSBF21E.J86
5655: 0000: \***
5656: 0000: \***        Version A     Bruce Scriver                  13th May 1988
5657: 0000: \***
5658: 0000: \***        Version B     Andrew Wedgeworth             21st July 1992
5659: 0000: \***        Redundant function parameters removed.  CHECK.BAR.CODE defined as
5660: 0000: \***        a variable to hold the return code.
5661: 0000: \***
5662: 0000: \*******************************************************************************
5663: 0000: \*******************************************************************************
5664: 0000: 
5665: 0000:    FUNCTION CHECK.BAR.CODE (BAR.CODE$)                                 \
5666: 0000:    EXTERNAL
5667: 0000: 
5668: 0000:    STRING    BAR.CODE$
5669: 0000: 
5670: 0000:    INTEGER*2 CHECK.BAR.CODE                                            ! BAW
5671: 0000: 
5672: 0000:    END FUNCTION
5673: 0000: 
5674: 0000: 
5675: 0000:  %INCLUDE IDFEXT.J86                      ! FLC
5676: 0000: \*******************************************************************************
5677: 0000: \***                                                                         ***
5678: 0000: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE ITEM DESCRIPTION FILE        ***
5679: 0000: \***                                                                         ***
5680: 0000: \***                       REFERENCE : IDFEXT.J86                            ***
5681: 0000: \***                                                                         ***
5682: 0000: \***      Version A           Andrew Wedgeworth         9th July 1992        ***
5683: 0000: \***
5684: 0000: \***    VERSION C.              Robert Cowey.                       25 AUG 1993.
5685: 0000: \***    No changes to this file.
5686: 0000: \***
5687: 0000: \***   VERSION D               Nik Sen                 22nd December 1994
5688: 0000: \***   WRITE.IDF.HOLD added
5689: 0000: \***
5690: 0000: \*******************************************************************************
5691: 0000: 
5692: 0000:        FUNCTION IDF.SET EXTERNAL                                      
5693: 0000:        END FUNCTION                                                   
5694: 0000: 
5695: 0000: 
5696: 0000:        FUNCTION READ.IDF EXTERNAL                                     
5697: 0000:           INTEGER*2 READ.IDF                                          
5698: 0000:        END FUNCTION                                                   
5699: 0000: 
5700: 0000: 
5701: 0000:        FUNCTION READ.IDF.LOCK EXTERNAL                                
5702: 0000:           INTEGER*2 READ.IDF.LOCK                                     
5703: 0000:        END FUNCTION                                                   
5704: 0000: 
5705: 0000:        FUNCTION WRITE.IDF EXTERNAL
5706: 0000:           INTEGER*2 WRITE.IDF
5707: 0000:        END FUNCTION	       
5708: 0000: 
5709: 0000:        FUNCTION WRITE.IDF.HOLD EXTERNAL
5710: 0000:           INTEGER*2 WRITE.IDF.HOLD
5711: 0000:        END FUNCTION
5712: 0000: 
5713: 0000:        FUNCTION WRITE.IDF.UNLOCK EXTERNAL                                  
5714: 0000:           INTEGER*2 WRITE.IDF.UNLOCK                                      
5715: 0000:        END FUNCTION                                                   
5716: 0000: !%INCLUDE IRFEXT.J86                      ! FLC TEST
5717: 0000:  %INCLUDE STKMQEXT.J86                    ! GMJK
5718: 0000: \*****************************************************************************
5719: 0000: \*****************************************************************************
5720: 0000: \***
5721: 0000: \***      EXTERNAL FUNCTION DEFINITIONS FOR STOCK MOVEMENT QUEUE FILE
5722: 0000: \***
5723: 0000: \***                      REFERENCE: STKMQEXT.J86
5724: 0000: \***
5725: 0000: \***       Version A            Les Cook                     8/9/92
5726: 0000: \***
5727: 0000: \***    VERSION F.              ROBERT COWEY.                       21 OCT 1993.
5728: 0000: \***    No changes to this file.
5729: 0000: \***
5730: 0000: \*******************************************************************************
5731: 0000: \*******************************************************************************
5732: 0000: 
5733: 0000:      FUNCTION STKMQ.SET EXTERNAL
5734: 0000:      END FUNCTION
5735: 0000:      
5736: 0000:      FUNCTION READ.STKMQ EXTERNAL
5737: 0000:         INTEGER*2 READ.STKMQ
5738: 0000:      END FUNCTION
5739: 0000:      
5740: 0000:      FUNCTION WRITE.STKMQ EXTERNAL
5741: 0000:         INTEGER*2 WRITE.STKMQ
5742: 0000:      END FUNCTION
5743: 0000:      
5744: 0000:      FUNCTION WRITE.HOLD.STKMQ EXTERNAL
5745: 0000:         INTEGER*2 WRITE.HOLD.STKMQ
5746: 0000:      END FUNCTION
5747: 0000:      
5748: 0000:      
5749: 0000:      
5750: 0000:  %INCLUDE BCSMFEXT.J86                    ! FLC
5751: 0000: \*****************************************************************************
5752: 0000: \*****************************************************************************
5753: 0000: \***
5754: 0000: \***   EXTERNAL FUNCTION DEFINITIONS FOR BUSINESS CENTRE SUPPLY METHOD FILE
5755: 0000: \***
5756: 0000: \***               REFERENCE: BCSMFFUN.BAS
5757: 0000: \***
5758: 0000: \***        Version B           Les Cook              11/1/93
5759: 0000: \***
5760: 0000: \*****************************************************************************
5761: 0000: \*****************************************************************************
5762: 0000: 
5763: 0000:     FUNCTION BCSMF.SET EXTERNAL
5764: 0000:     END FUNCTION
5765: 0000:     
5766: 0000:     FUNCTION READ.BCSMF EXTERNAL
5767: 0000:        INTEGER*2 READ.BCSMF
5768: 0000:     END FUNCTION
5769: 0000:     
5770: 0000:     FUNCTION READ.BCSMF.LOCK EXTERNAL
5771: 0000:        INTEGER*2 READ.BCSMF.LOCK
5772: 0000:     END FUNCTION
5773: 0000:     
5774: 0000:     FUNCTION WRITE.BCSMF EXTERNAL
5775: 0000:        INTEGER*2 WRITE.BCSMF
5776: 0000:     END FUNCTION
5777: 0000:     
5778: 0000:     FUNCTION WRITE.BCSMF.UNLOCK EXTERNAL
5779: 0000:        INTEGER*2 WRITE.BCSMF.UNLOCK
5780: 0000:     END FUNCTION
5781: 0000:     
5782: 0000:     
5783: 0000:  %INCLUDE INVOKEXT.J86                    ! FLC
5784: 0000: \*******************************************************************************
5785: 0000: \***                                                                         ***
5786: 0000: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE INVCE OK FILE                ***
5787: 0000: \***                                                                         ***
5788: 0000: \***                     REFERENCE : INVOKEXT.J86                            ***
5789: 0000: \***                                                                         ***
5790: 0000: \***      Version A         Andrew Wedgeworth       3rd August 1992          ***
5791: 0000: \***                                                                         ***
5792: 0000: \***      Version B         Stephen Kelsey (CTG)    9th October 1992         ***
5793: 0000: \***          Add functions READ.INVOK.LOCKED and WRITE.INVOK.UNLOCK         ***
5794: 0000: \***                                                                         ***
5795: 0000: \*******************************************************************************
5796: 0000: 
5797: 0000: 
5798: 0000:       FUNCTION INVOK.SET EXTERNAL 
5799: 0000:       END FUNCTION
5800: 0000:       
5801: 0000:       FUNCTION READ.INVOK EXTERNAL
5802: 0000:          INTEGER*2 READ.INVOK
5803: 0000:       END FUNCTION	             
5804: 0000:       
5805: 0000:       FUNCTION READ.INVOK.LOCKED EXTERNAL                              ! BSPK
5806: 0000:          INTEGER*2 READ.INVOK.LOCKED                                   ! BSPK
5807: 0000:       END FUNCTION	                                               ! BSPK
5808: 0000:       
5809: 0000:       FUNCTION WRITE.INVOK.UNLOCK EXTERNAL                             ! BSPK
5810: 0000:          INTEGER*2 WRITE.INVOK.UNLOCK                                  ! BSPK
5811: 0000:       END FUNCTION	                                               ! BSPK
5812: 0000:  %INCLUDE PCHKEXT.J86                     ! DLC
5813: 0000: \*****************************************************************************
5814: 0000: \*****************************************************************************
5815: 0000: \***
5816: 0000: \***        EXTERNAL FUNCTION DEFINITIONS FOR PCHK
5817: 0000: \***
5818: 0000: \***        REFERENCE: PCHKEXT.J86
5819: 0000: \***
5820: 0000: \*****************************************************************************
5821: 0000: \*****************************************************************************
5822: 0000: 
5823: 0000: 
5824: 0000:    FUNCTION PCHK.SET EXTERNAL
5825: 0000:    END FUNCTION
5826: 0000:    
5827: 0000:    FUNCTION READ.PCHK EXTERNAL
5828: 0000:    END FUNCTION
5829: 0000:    
5830: 0000:    FUNCTION WRITE.PCHK EXTERNAL
5831: 0000:    END FUNCTION
5832: 0000:    
5833: 0000:    
5834: 0000: \%INCLUDE CSREXT.J86                      ! DLC !2.5NWB
5835: 0000:  %INCLUDE EPSOMEXT.J86                    ! DLC
5836: 0000: \*****************************************************************************
5837: 0000: \*****************************************************************************
5838: 0000: \***
5839: 0000: \***      EXTERNAL FUNCTION DEFINITIONS FOR EPSOM
5840: 0000: \***
5841: 0000: \***      REFERENCE: EPSOMEXT.J86
5842: 0000: \***
5843: 0000: \*****************************************************************************
5844: 0000: \*****************************************************************************
5845: 0000: 
5846: 0000: 
5847: 0000:    FUNCTION EPSOM.SET EXTERNAL
5848: 0000:    END FUNCTION
5849: 0000:    
5850: 0000:  %INCLUDE UNITSEXT.J86                    ! DLC
5851: 0000: \*****************************************************************************
5852: 0000: \*****************************************************************************
5853: 0000: \*** 
5854: 0000: \***        EXTERNAL FUNCTION DEFINITIONS FOR UNITS
5855: 0000: \***
5856: 0000: \***        REFERENCE:  UNITSEXT.J86
5857: 0000: \***
5858: 0000: \*****************************************************************************
5859: 0000: \*****************************************************************************
5860: 0000: 
5861: 0000:    FUNCTION UNITS.SET EXTERNAL
5862: 0000:    END FUNCTION
5863: 0000:    
5864: 0000:    FUNCTION READ.UNITS EXTERNAL
5865: 0000:       INTEGER*2 READ.UNITS
5866: 0000:    END FUNCTION
5867: 0000:    
5868: 0000:    FUNCTION READ.UNITS.LOCK EXTERNAL
5869: 0000:       INTEGER*2 READ.UNITS.LOCK
5870: 0000:    END FUNCTION
5871: 0000:    
5872: 0000:    FUNCTION WRITE.UNITS EXTERNAL
5873: 0000:       INTEGER*2 WRITE.UNITS
5874: 0000:    END FUNCTION
5875: 0000:    
5876: 0000:    FUNCTION WRITE.UNITS.UNLOCK EXTERNAL
5877: 0000:       INTEGER*2 WRITE.UNITS.UNLOCK
5878: 0000:    END FUNCTION
5879: 0000:    
5880: 0000:    
5881: 0000:    
5882: 0000:  %INCLUDE DIRECEXT.J86                    ! DLC
5883: 0000: \*****************************************************************************
5884: 0000: \*****************************************************************************
5885: 0000: \***
5886: 0000: \***       EXTERNAL FUNCTION DEFINITIONS FOR DIREC
5887: 0000: \***
5888: 0000: \***       REFERENCE: DIRECEXT.J86
5889: 0000: \***
5890: 0000: \*****************************************************************************
5891: 0000: \*****************************************************************************
5892: 0000: 
5893: 0000:    FUNCTION DIREC.SET EXTERNAL 
5894: 0000:    END FUNCTION
5895: 0000:    
5896: 0000:    
5897: 0000:  %INCLUDE LDTBFEXT.J86                    ! ELC
5898: 0000: \*******************************************************************************
5899: 0000: \***                                                                         
5900: 0000: \***         EXTERNAL FUNCTION DEFINITIONS FOR THE LDT BUFFER FILE          
5901: 0000: \***                                                                         
5902: 0000: \***                     REFERENCE : LDTBFEXT.J86                            
5903: 0000: \***                                                                         
5904: 0000: \***          Version B     Les Cook      4th November 1992               
5905: 0000: \***                                                                         
5906: 0000: \*******************************************************************************
5907: 0000: 
5908: 0000:        FUNCTION LDTBF.SET EXTERNAL                                      
5909: 0000:        END FUNCTION                                                   
5910: 0000: 
5911: 0000: 
5912: 0000:        FUNCTION READ.LDTBF EXTERNAL                                  
5913: 0000:           INTEGER*2 READ.LDTBF                                       
5914: 0000:        END FUNCTION                                                   
5915: 0000:        
5916: 0000:        FUNCTION WRITE.LDTBF EXTERNAL
5917: 0000:           INTEGER*2 WRITE.LDTBF
5918: 0000:        END FUNCTION
5919: 0000:  %INCLUDE UODEXT.J86                      ! FLC
5920: 0000: \*****************************************************************************
5921: 0000: \*****************************************************************************
5922: 0000: \***
5923: 0000: \***     EXTERNAL FUNCTION DEFINITIONS FOR UOD DUMMY FILE
5924: 0000: \***
5925: 0000: \***     REFERENCE: UODEXT.J86
5926: 0000: \***
5927: 0000: \*****************************************************************************
5928: 0000: \*****************************************************************************
5929: 0000: 
5930: 0000:    FUNCTION UOD.SET EXTERNAL
5931: 0000:    END FUNCTION
5932: 0000:    
5933: 0000:    
5934: 0000:  %INCLUDE UODBFEXT.J86                    ! FLC
5935: 0000: \*******************************************************************************
5936: 0000: \*******************************************************************************
5937: 0000: \***
5938: 0000: \***           UOD BUFFER FILE EXTERNAL FILE PUBLIC DEFINITIONS
5939: 0000: \***
5940: 0000: \***                    REFERENCE    : UODBFEXT.BAS
5941: 0000: \***
5942: 0000: \***    Version A.         Michael Kelsall              08th February 1993
5943: 0000: \***
5944: 0000: \*******************************************************************************
5945: 0000: \*******************************************************************************
5946: 0000: 
5947: 0000:  
5948: 0000:   FUNCTION UODBF.SET EXTERNAL
5949: 0000:       INTEGER*2 UODBF.SET
5950: 0000:   END FUNCTION
5951: 0000: 
5952: 0000: 
5953: 0000:   FUNCTION READ.UODBF EXTERNAL
5954: 0000:       INTEGER*2 READ.UODBF 
5955: 0000:   END FUNCTION
5956: 0000: 
5957: 0000:   
5958: 0000:   FUNCTION WRITE.UODBF EXTERNAL
5959: 0000:       INTEGER*2 WRITE.UODBF
5960: 0000:   END FUNCTION
5961: 0000: 
5962: 0000:   
5963: 0000:   FUNCTION WRITE.HOLD.UODBF EXTERNAL
5964: 0000:       INTEGER*2 WRITE.HOLD.UODBF						
5965: 0000:   END FUNCTION								
5966: 0000: 
5967: 0000:  %INCLUDE UODTFEXT.J86                    ! FLC
5968: 0000: \*****************************************************************************
5969: 0000: \*****************************************************************************
5970: 0000: \***
5971: 0000: \***        EXTERNAL FUNCTION DEFINITIONS FOR UODTF
5972: 0000: \***
5973: 0000: \***        REFERENCE:  UODTFEXT.J86
5974: 0000: \***
5975: 0000: \***        Version A         Les Cook         22/2/1993
5976: 0000: \***
5977: 0000: \*****************************************************************************
5978: 0000: \*****************************************************************************
5979: 0000: 
5980: 0000:    FUNCTION UODTF.SET EXTERNAL
5981: 0000:    END FUNCTION
5982: 0000:    
5983: 0000:    FUNCTION READ.UODTF EXTERNAL
5984: 0000:       INTEGER*2 READ.UODTF
5985: 0000:    END FUNCTION
5986: 0000:    
5987: 0000:    FUNCTION WRITE.UODTF EXTERNAL
5988: 0000:       INTEGER*2 WRITE.UODTF
5989: 0000:    END FUNCTION
5990: 0000:    
5991: 0000:    
5992: 0000:  %INCLUDE PILSTEXT.J86                    ! FLC
5993: 0000: \*****************************************************************************
5994: 0000: \*****************************************************************************
5995: 0000: \***
5996: 0000: \***     EXTERNAL FUNCTION DEFINITIONS FOR PILST
5997: 0000: \***
5998: 0000: \***     REFERENCE: PILSTEXT.J86
5999: 0000: \***
6000: 0000: \***     9th October 1992
6001: 0000: \***
6002: 0000: \*****************************************************************************
6003: 0000: \*****************************************************************************
6004: 0000: 
6005: 0000:    FUNCTION PILST.SET EXTERNAL
6006: 0000:    END FUNCTION
6007: 0000:    
6008: 0000:    FUNCTION READ.PILST EXTERNAL
6009: 0000:       INTEGER*2 READ.PILST
6010: 0000:    END FUNCTION
6011: 0000:    
6012: 0000:    FUNCTION READ.PILST.LOCK EXTERNAL
6013: 0000:       INTEGER*2 READ.PILST.LOCK
6014: 0000:    END FUNCTION
6015: 0000:    
6016: 0000:    FUNCTION WRITE.PILST EXTERNAL
6017: 0000:       INTEGER*2 WRITE.PILST
6018: 0000:    END FUNCTION
6019: 0000:    
6020: 0000:    FUNCTION WRITE.PILST.HOLD EXTERNAL
6021: 0000:       INTEGER*2 WRITE.PILST.HOLD
6022: 0000:    END FUNCTION
6023: 0000:    
6024: 0000:    FUNCTION WRITE.PILST.UNLOCK EXTERNAL
6025: 0000:       INTEGER*2 WRITE.PILST.UNLOCK
6026: 0000:    END FUNCTION
6027: 0000:    
6028: 0000:    
6029: 0000:  %INCLUDE PIITMEXT.J86                    ! FLC
6030: 0000: \*****************************************************************************
6031: 0000: \*****************************************************************************
6032: 0000: \***
6033: 0000: \***            EXTERNAL FUNCTION DEFINITIONS FOR PIITM
6034: 0000: \***
6035: 0000: \***            REFERENCE: PIITMEXT.J86
6036: 0000: \***
6037: 0000: \***            Les Cook 9/10/1992
6038: 0000: \***
6039: 0000: \*****************************************************************************
6040: 0000: \*****************************************************************************
6041: 0000: 
6042: 0000:    FUNCTION PIITM.SET EXTERNAL
6043: 0000:    END FUNCTION
6044: 0000:    
6045: 0000:    FUNCTION READ.PIITM EXTERNAL
6046: 0000:       INTEGER*2 READ.PIITM
6047: 0000:    END FUNCTION
6048: 0000:    
6049: 0000:    FUNCTION READ.PIITM.LOCK EXTERNAL
6050: 0000:       INTEGER*2 READ.PIITM.LOCK
6051: 0000:    END FUNCTION
6052: 0000:    
6053: 0000:    FUNCTION WRITE.PIITM EXTERNAL
6054: 0000:       INTEGER*2 WRITE.PIITM
6055: 0000:    END FUNCTION
6056: 0000:    
6057: 0000:    FUNCTION WRITE.PIITM.UNLOCK EXTERNAL
6058: 0000:       INTEGER*2 WRITE.PIITM.UNLOCK
6059: 0000:    END FUNCTION
6060: 0000:    
6061: 0000:    FUNCTION WRITE.PIITM.HOLD.UNLOCK EXTERNAL
6062: 0000:       INTEGER*2 WRITE.PIITM.HOLD.UNLOCK
6063: 0000:    END FUNCTION
6064: 0000:    
6065: 0000:    FUNCTION WRITE.PIITM.HOLD EXTERNAL
6066: 0000:       INTEGER*2 WRITE.PIITM.HOLD
6067: 0000:    END FUNCTION
6068: 0000:    
6069: 0000: !%INCLUDE PDTWFEXT.J86                    ! FLC
6070: 0000: 
6071: 0000:  %INCLUDE CCUODEXT.J86                    ! GMJK
6072: 0000: 
6073: 0000: \*****************************************************************************
6074: 0000: \*****************************************************************************
6075: 0000: \***
6076: 0000: \***        %INCLUDE FOR FILE HANDLING FUNCTIONS EXTERNAL DEFINITIONS
6077: 0000: \***
6078: 0000: \***                   FILE TYPE:  KEYED
6079: 0000: \***
6080: 0000: \***                   REFERENCE:  CCUODEXT.J86
6081: 0000: \***
6082: 0000: \***	             DESCRIPTION:  RETURNS / AUTOMATIC CREDIT CLAIMING
6083: 0000: \***				   FILE OF OPEN/CLOSED UODS
6084: 0000: \***
6085: 0000: \***
6086: 0000: \***      VERSION A : Michael J. Kelsall      13th September 1993
6087: 0000: \***      
6088: 0000: \*****************************************************************************
6089: 0000: \*****************************************************************************
6090: 0000: 
6091: 0000: 
6092: 0000:   FUNCTION CCUOD.SET EXTERNAL
6093: 0000:      INTEGER*2 CCUOD.SET
6094: 0000:   END FUNCTION
6095: 0000: 
6096: 0000: 
6097: 0000:   FUNCTION READ.CCUOD EXTERNAL
6098: 0000:     INTEGER*2 READ.CCUOD
6099: 0000:   END FUNCTION
6100: 0000:   
6101: 0000: 
6102: 0000:   FUNCTION READ.CCUOD.LOCKED EXTERNAL
6103: 0000:     INTEGER*2 READ.CCUOD.LOCKED
6104: 0000:   END FUNCTION  
6105: 0000: 
6106: 0000: 
6107: 0000:   FUNCTION WRITE.HOLD.CCUOD EXTERNAL
6108: 0000:     INTEGER*2 WRITE.HOLD.CCUOD
6109: 0000:   END FUNCTION
6110: 0000: 
6111: 0000: 
6112: 0000:   FUNCTION WRITE.UNLOCK.CCUOD EXTERNAL
6113: 0000:     INTEGER*2 WRITE.UNLOCK.CCUOD
6114: 0000:   END FUNCTION
6115: 0000: 
6116: 0000: 
6117: 0000:   FUNCTION WRITE.HOLD.UNLOCK.CCUOD EXTERNAL
6118: 0000:     INTEGER*2 WRITE.HOLD.UNLOCK.CCUOD
6119: 0000:   END FUNCTION
6120: 0000:   
6121: 0000: 
6122: 0000:   FUNCTION WRITE.CCUOD EXTERNAL
6123: 0000:     INTEGER*2 WRITE.CCUOD
6124: 0000:   END FUNCTION
6125: 0000: 
6126: 0000:  %INCLUDE CCLAMEXT.J86                    ! 1.4
6127: 0000: 
6128: 0000: \*****************************************************************************
6129: 0000: \*****************************************************************************
6130: 0000: \***
6131: 0000: \***        %INCLUDE FOR FILE HANDLING FUNCTIONS EXTERNAL DEFINITIONS
6132: 0000: \***
6133: 0000: \***                   FILE TYPE:  KEYED
6134: 0000: \***
6135: 0000: \***                   REFERENCE:  CCLAMEXT.J86
6136: 0000: \***
6137: 0000: \***	             DESCRIPTION:  RETURNS / AUTOMATIC CREDIT CLAIMING
6138: 0000: \***				   FILE OF CURRENT CREDIT CLAIMS
6139: 0000: \***
6140: 0000: \***
6141: 0000: \***      VERSION A : Michael J. Kelsall      14th September 1993
6142: 0000: \***      
6143: 0000: \*****************************************************************************
6144: 0000: \*****************************************************************************
6145: 0000: 
6146: 0000: 
6147: 0000:   FUNCTION CCLAM.SET EXTERNAL
6148: 0000:      INTEGER*2 CCLAM.SET
6149: 0000:   END FUNCTION
6150: 0000: 
6151: 0000: 
6152: 0000:   FUNCTION READ.CCLAM EXTERNAL
6153: 0000:     INTEGER*2 READ.CCLAM
6154: 0000:   END FUNCTION
6155: 0000:   
6156: 0000: 
6157: 0000:   FUNCTION READ.CCLAM.LOCKED EXTERNAL
6158: 0000:     INTEGER*2 READ.CCLAM.LOCKED
6159: 0000:   END FUNCTION  
6160: 0000: 
6161: 0000: 
6162: 0000:   FUNCTION WRITE.HOLD.CCLAM EXTERNAL
6163: 0000:     INTEGER*2 WRITE.HOLD.CCLAM
6164: 0000:   END FUNCTION
6165: 0000: 
6166: 0000: 
6167: 0000:   FUNCTION WRITE.UNLOCK.CCLAM EXTERNAL
6168: 0000:     INTEGER*2 WRITE.UNLOCK.CCLAM
6169: 0000:   END FUNCTION
6170: 0000: 
6171: 0000: 
6172: 0000:   FUNCTION WRITE.HOLD.UNLOCK.CCLAM EXTERNAL
6173: 0000:     INTEGER*2 WRITE.HOLD.UNLOCK.CCLAM
6174: 0000:   END FUNCTION
6175: 0000:   
6176: 0000: 
6177: 0000:   FUNCTION WRITE.CCLAM EXTERNAL
6178: 0000:     INTEGER*2 WRITE.CCLAM
6179: 0000:   END FUNCTION
6180: 0000: 
6181: 0000:  %INCLUDE CCITMEXT.J86                    ! GMJK
6182: 0000: 
6183: 0000: \*****************************************************************************
6184: 0000: \*****************************************************************************
6185: 0000: \***
6186: 0000: \***        %INCLUDE FOR FILE HANDLING FUNCTION EXTERNAL DECLARATIONS
6187: 0000: \***
6188: 0000: \***                   FILE TYPE:  KEYED
6189: 0000: \***
6190: 0000: \***                   REFERENCE:  CCITMEXT.J86
6191: 0000: \***
6192: 0000: \***	             DESCRIPTION:  RETURNS / AUTOMATIC CREDIT CLAIMING
6193: 0000: \***				   FILE OF ITEMS PER OPEN/CLOSED UODS
6194: 0000: \***
6195: 0000: \***
6196: 0000: \***      VERSION A : Michael J. Kelsall      13th September 1993
6197: 0000: \***      
6198: 0000: \*****************************************************************************
6199: 0000: \*****************************************************************************
6200: 0000: 
6201: 0000: 
6202: 0000:   FUNCTION CCITM.SET EXTERNAL
6203: 0000:      INTEGER*2 CCITM.SET
6204: 0000:   END FUNCTION
6205: 0000: 
6206: 0000: 
6207: 0000:   FUNCTION READ.CCITM EXTERNAL
6208: 0000:     INTEGER*2 READ.CCITM
6209: 0000:   END FUNCTION
6210: 0000:   
6211: 0000: 
6212: 0000:   FUNCTION READ.CCITM.LOCKED EXTERNAL
6213: 0000:     INTEGER*2 READ.CCITM.LOCKED
6214: 0000:   END FUNCTION  
6215: 0000: 
6216: 0000: 
6217: 0000:   FUNCTION WRITE.HOLD.CCITM EXTERNAL
6218: 0000:     INTEGER*2 WRITE.HOLD.CCITM
6219: 0000:   END FUNCTION
6220: 0000: 
6221: 0000: 
6222: 0000:   FUNCTION WRITE.UNLOCK.CCITM EXTERNAL
6223: 0000:     INTEGER*2 WRITE.UNLOCK.CCITM
6224: 0000:   END FUNCTION
6225: 0000: 
6226: 0000: 
6227: 0000:   FUNCTION WRITE.HOLD.UNLOCK.CCITM EXTERNAL
6228: 0000:     INTEGER*2 WRITE.HOLD.UNLOCK.CCITM
6229: 0000:   END FUNCTION
6230: 0000: 
6231: 0000: 
6232: 0000:   FUNCTION WRITE.CCITM EXTERNAL
6233: 0000:     INTEGER*2 WRITE.CCITM
6234: 0000:   END FUNCTION
6235: 0000: 
6236: 0000:  %INCLUDE CCTRLEXT.J86                    ! GMJK
6237: 0000: 
6238: 0000: \*****************************************************************************
6239: 0000: \*****************************************************************************
6240: 0000: \***
6241: 0000: \***        %INCLUDE FOR FILE HANDLING FUNCTIONS EXTERNAL DEFINITIONS
6242: 0000: \***
6243: 0000: \***                   FILE TYPE:  DIRECT
6244: 0000: \***
6245: 0000: \***                   REFERENCE:  CCTRLEXT.J86
6246: 0000: \***
6247: 0000: \***	             DESCRIPTION:  RETURNS / AUTOMATIC CREDIT CLAIMING
6248: 0000: \***				   CREDIT CLAIMS CONTROL FILE
6249: 0000: \***
6250: 0000: \***
6251: 0000: \***      VERSION A : Michael J. Kelsall      14th September 1993
6252: 0000: \***      
6253: 0000: \*****************************************************************************
6254: 0000: \*****************************************************************************
6255: 0000: 
6256: 0000: 
6257: 0000:   FUNCTION CCTRL.SET EXTERNAL
6258: 0000:      INTEGER*2 CCTRL.SET
6259: 0000:   END FUNCTION
6260: 0000: 
6261: 0000: 
6262: 0000:   FUNCTION READ.CCTRL EXTERNAL
6263: 0000:     INTEGER*2 READ.CCTRL
6264: 0000:   END FUNCTION
6265: 0000:   
6266: 0000: 
6267: 0000:   FUNCTION READ.CCTRL.LOCKED EXTERNAL
6268: 0000:     INTEGER*2 READ.CCTRL.LOCKED
6269: 0000:   END FUNCTION  
6270: 0000: 
6271: 0000: 
6272: 0000:   FUNCTION WRITE.HOLD.CCTRL EXTERNAL
6273: 0000:     INTEGER*2 WRITE.HOLD.CCTRL
6274: 0000:   END FUNCTION
6275: 0000: 
6276: 0000: 
6277: 0000:   FUNCTION WRITE.UNLOCK.CCTRL EXTERNAL
6278: 0000:     INTEGER*2 WRITE.UNLOCK.CCTRL
6279: 0000:   END FUNCTION
6280: 0000: 
6281: 0000: 
6282: 0000:   FUNCTION WRITE.HOLD.UNLOCK.CCTRL EXTERNAL
6283: 0000:     INTEGER*2 WRITE.HOLD.UNLOCK.CCTRL
6284: 0000:   END FUNCTION
6285: 0000:   
6286: 0000: 
6287: 0000:   FUNCTION WRITE.CCTRL EXTERNAL
6288: 0000:     INTEGER*2 WRITE.CCTRL
6289: 0000:   END FUNCTION
6290: 0000: 
6291: 0000:  %INCLUDE CCTMPEXT.J86                    ! GMJK
6292: 0000: \*******************************************************************************
6293: 0000: \*******************************************************************************
6294: 0000: \***
6295: 0000: \*** RETURNS / AUTOMATIC CREDIT CLAIMING FILE EXTERNAL FILE PUBLIC DEFINITIONS
6296: 0000: \***
6297: 0000: \***                    REFERENCE    : CCTMPEXT.BAS
6298: 0000: \***
6299: 0000: \***    Version A.         Michael Kelsall              30th September 1993
6300: 0000: \***
6301: 0000: \*******************************************************************************
6302: 0000: \*******************************************************************************
6303: 0000: 
6304: 0000:  
6305: 0000:   FUNCTION CCTMP.SET EXTERNAL
6306: 0000:       INTEGER*2 CCTMP.SET
6307: 0000:   END FUNCTION
6308: 0000: 
6309: 0000: 
6310: 0000:   FUNCTION READ.CCTMP EXTERNAL
6311: 0000:       INTEGER*2 READ.CCTMP 
6312: 0000:   END FUNCTION
6313: 0000: 
6314: 0000:   
6315: 0000:   FUNCTION WRITE.CCTMP EXTERNAL
6316: 0000:       INTEGER*2 WRITE.CCTMP
6317: 0000:   END FUNCTION
6318: 0000: 
6319: 0000:   
6320: 0000:   FUNCTION WRITE.HOLD.CCTMP EXTERNAL
6321: 0000:       INTEGER*2 WRITE.HOLD.CCTMP						
6322: 0000:   END FUNCTION								
6323: 0000: 
6324: 0000:  %INCLUDE CCBUFEXT.J86                    ! GMJK
6325: 0000: \*******************************************************************************
6326: 0000: \*******************************************************************************
6327: 0000: \***
6328: 0000: \*** RETURNS / AUTOMATIC CREDIT CLAIMING FILE EXTERNAL FILE PUBLIC DEFINITIONS
6329: 0000: \***
6330: 0000: \***                    REFERENCE    : CCBUFEXT.BAS
6331: 0000: \***
6332: 0000: \***    Version A.         Michael Kelsall              30th September 1993
6333: 0000: \***
6334: 0000: \*******************************************************************************
6335: 0000: \*******************************************************************************
6336: 0000: 
6337: 0000:  
6338: 0000:   FUNCTION CCBUF.SET EXTERNAL
6339: 0000:       INTEGER*2 CCBUF.SET
6340: 0000:   END FUNCTION
6341: 0000: 
6342: 0000: 
6343: 0000:   FUNCTION READ.CCBUF EXTERNAL
6344: 0000:       INTEGER*2 READ.CCBUF 
6345: 0000:   END FUNCTION
6346: 0000: 
6347: 0000:   
6348: 0000:   FUNCTION WRITE.CCBUF EXTERNAL
6349: 0000:       INTEGER*2 WRITE.CCBUF
6350: 0000:   END FUNCTION
6351: 0000: 
6352: 0000:   
6353: 0000:   FUNCTION WRITE.HOLD.CCBUF EXTERNAL
6354: 0000:       INTEGER*2 WRITE.HOLD.CCBUF						
6355: 0000:   END FUNCTION								
6356: 0000: 
6357: 0000:  %INCLUDE CCUPFEXT.J86                    ! HMJK
6358: 0000: 
6359: 0000: \*****************************************************************************
6360: 0000: \*****************************************************************************
6361: 0000: \***
6362: 0000: \***        %INCLUDE FOR FILE HANDLING FUNCTION EXTERNAL DECLARATIONS
6363: 0000: \***
6364: 0000: \***                   FILE TYPE:  KEYED
6365: 0000: \***
6366: 0000: \***                   REFERENCE:  CCUPFEXT.J86
6367: 0000: \***
6368: 0000: \***	             DESCRIPTION:  RETURNS / AUTOMATIC CREDIT CLAIMING
6369: 0000: \***				   UOD PROCESSED FILE 
6370: 0000: \***
6371: 0000: \***      VERSION A : Michael J. Kelsall      14th March 1994
6372: 0000: \***      
6373: 0000: \*****************************************************************************
6374: 0000: \*****************************************************************************
6375: 0000: 
6376: 0000: 
6377: 0000:   FUNCTION CCUPF.SET EXTERNAL
6378: 0000:      INTEGER*2 CCUPF.SET
6379: 0000:   END FUNCTION
6380: 0000: 
6381: 0000: 
6382: 0000:   FUNCTION READ.CCUPF EXTERNAL
6383: 0000:     INTEGER*2 READ.CCUPF
6384: 0000:   END FUNCTION
6385: 0000:   
6386: 0000: 
6387: 0000:   FUNCTION READ.CCUPF.LOCKED EXTERNAL
6388: 0000:     INTEGER*2 READ.CCUPF.LOCKED
6389: 0000:   END FUNCTION  
6390: 0000: 
6391: 0000: 
6392: 0000:   FUNCTION WRITE.HOLD.CCUPF EXTERNAL
6393: 0000:     INTEGER*2 WRITE.HOLD.CCUPF
6394: 0000:   END FUNCTION
6395: 0000: 
6396: 0000: 
6397: 0000:   FUNCTION WRITE.UNLOCK.CCUPF EXTERNAL
6398: 0000:     INTEGER*2 WRITE.UNLOCK.CCUPF
6399: 0000:   END FUNCTION
6400: 0000: 
6401: 0000: 
6402: 0000:   FUNCTION WRITE.HOLD.UNLOCK.CCUPF EXTERNAL
6403: 0000:     INTEGER*2 WRITE.HOLD.UNLOCK.CCUPF
6404: 0000:   END FUNCTION
6405: 0000: 
6406: 0000: 
6407: 0000:   FUNCTION WRITE.CCUPF EXTERNAL
6408: 0000:     INTEGER*2 WRITE.CCUPF
6409: 0000:   END FUNCTION
6410: 0000: 
6411: 0000:  %INCLUDE CCWKFEXT.J86                    ! GMJK
6412: 0000: \*****************************************************************************
6413: 0000: \*****************************************************************************
6414: 0000: \***
6415: 0000: \***       EXTERNAL FUNCTION DEFINTIONS FOR CCWKF - RETURNS WORK FILE
6416: 0000: \***
6417: 0000: \***                      REFERENCE: CCWKFEXT.J86
6418: 0000: \***
6419: 0000: \***    Version A          Michael J. Kelsall            30th September 1993
6420: 0000: \***
6421: 0000: \*****************************************************************************
6422: 0000: \*****************************************************************************
6423: 0000: 
6424: 0000:    FUNCTION CCWKF.SET EXTERNAL
6425: 0000:       INTEGER*2 CCWKF.SET
6426: 0000:    END FUNCTION
6427: 0000:    
6428: 0000:    FUNCTION READ.CCWKF EXTERNAL
6429: 0000:       INTEGER*2 READ.CCWKF
6430: 0000:    END FUNCTION
6431: 0000:    
6432: 0000:    FUNCTION WRITE.CCWKF EXTERNAL
6433: 0000:       INTEGER*2 WRITE.CCWKF
6434: 0000:    END FUNCTION
6435: 0000:    
6436: 0000:  %INCLUDE CCDMYEXT.J86                    ! GMJK
6437: 0000: \*****************************************************************************
6438: 0000: \*****************************************************************************
6439: 0000: \***
6440: 0000: \***        EXTERNAL FUNCTION DEFINITIONS FOR RETURNS DUMMY FILE
6441: 0000: \***
6442: 0000: \***                      REFERENCE: CCDMYEXT.J86
6443: 0000: \***
6444: 0000: \***    Version A       Michael J. Kelsall             30th September 1993
6445: 0000: \***
6446: 0000: \*****************************************************************************
6447: 0000: \*****************************************************************************
6448: 0000: 
6449: 0000:    FUNCTION CCDMY.SET EXTERNAL
6450: 0000:       INTEGER*2 CCDMY.SET
6451: 0000:    END FUNCTION
6452: 0000:    
6453: 0000:    
6454: 0000:  %INCLUDE LDTAFEXT.J86                    ! HMJK
6455: 0000: 
6456: 0000: \*****************************************************************************
6457: 0000: \*****************************************************************************
6458: 0000: \***
6459: 0000: \***        %INCLUDE FOR FILE HANDLING FUNCTIONS EXTERNAL DEFINITIONS
6460: 0000: \***
6461: 0000: \***                   FILE TYPE:  DIRECT
6462: 0000: \***
6463: 0000: \***                   REFERENCE:  LDTAFEXT.J86
6464: 0000: \***
6465: 0000: \***	             DESCRIPTION:  LDT / PDT SUPPORT LINK AUDIT FILE
6466: 0000: \***
6467: 0000: \***
6468: 0000: \***      VERSION A        Michael J. Kelsall        30th September 1993
6469: 0000: \*** 
6470: 0000: \***      VERSION B        Michael J. Kelsall        25th March 1994
6471: 0000: \***      No change to external definitions.
6472: 0000: \***      
6473: 0000: \*****************************************************************************
6474: 0000: \*****************************************************************************
6475: 0000: 
6476: 0000: 
6477: 0000:   FUNCTION LDTAF.SET EXTERNAL
6478: 0000:      INTEGER*2 LDTAF.SET
6479: 0000:   END FUNCTION
6480: 0000: 
6481: 0000: 
6482: 0000:   FUNCTION READ.LDTAF EXTERNAL
6483: 0000:     INTEGER*2 READ.LDTAF
6484: 0000:   END FUNCTION
6485: 0000:   
6486: 0000: 
6487: 0000:   FUNCTION WRITE.HOLD.LDTAF EXTERNAL
6488: 0000:     INTEGER*2 WRITE.HOLD.LDTAF
6489: 0000:   END FUNCTION
6490: 0000: 
6491: 0000: 
6492: 0000:   FUNCTION WRITE.LDTAF EXTERNAL
6493: 0000:     INTEGER*2 WRITE.LDTAF
6494: 0000:   END FUNCTION
6495: 0000: 
6496: 0000:  %INCLUDE SOFTSEXT.J86                    ! GMJK
6497: 0000: \*******************************************************************************
6498: 0000: \***                                                                         ***
6499: 0000: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE SOFTWARE STATUS FILE         ***
6500: 0000: \***                                                                         ***
6501: 0000: \***                     REFERENCE : SOFTSEXT.J86                            ***
6502: 0000: \***                                                                         ***
6503: 0000: \***      Version A         Andrew Wedgeworth          1st July 1992         ***
6504: 0000: \***
6505: 0000: \***   Version B
6506: 0000: \***                                                                      ***
6507: 0000: \***      Version C         Steve Wright               3rd May 1996          ***
6508: 0000: \***      Synchronise with function source.                                  ***
6509: 0000: \*******************************************************************************
6510: 0000: 
6511: 0000:       FUNCTION SOFTS.SET EXTERNAL 
6512: 0000:       END FUNCTION
6513: 0000:       
6514: 0000:       FUNCTION READ.SOFTS EXTERNAL
6515: 0000:           INTEGER*2 I%, READ.SOFTS
6516: 0000:       END FUNCTION	                   
6517: 0000: 
6518: 0000:       FUNCTION WRITE.SOFTS EXTERNAL
6519: 0000:           INTEGER*2 I%, WRITE.SOFTS
6520: 0000:       END FUNCTION
6521: 0000: 
6522: 0000: 
6523: 0000:  %INCLUDE STKBFEXT.J86                    ! 1.5
6524: 0000: \******************************************************************************
6525: 0000: \******************************************************************************
6526: 0000: \***
6527: 0000: \***   $Workfile:   STKBFEXT.J86  $
6528: 0000: \***
6529: 0000: \***   $Revision:   1.0  $
6530: 0000: \***
6531: 0000: \******************************************************************************
6532: 0000: \******************************************************************************
6533: 0000: \***
6534: 0000: \***   $Log:   V:\archive\j86\stkbfext.j8v  $
6535: 0000: \***   
6536: 0000: \***      Rev 1.0   15 Jul 1997 14:20:38   DEV45PS
6537: 0000: \***    
6538: 0000: \***   
6539: 0000: \***      Rev 1.0   09 Jul 1997 11:04:54   DEV45PS
6540: 0000: \***   Stocktake System New Files
6541: 0000: \***   
6542: 0000: \******************************************************************************
6543: 0000: \******************************************************************************\*****************************************************************************
6544: 0000: \***
6545: 0000: \***           FUNCTION DEFINITIONS FOR THE STOCKTAKE BUFFER FILE
6546: 0000: \***
6547: 0000: \***           REFERENCE:   STKBFEXT.J86
6548: 0000: \***
6549: 0000: \***           VERSION A         Nik Sen         19th June 1997
6550: 0000: \***
6551: 0000: \***
6552: 0000: \*******************************************************************************
6553: 0000: \*******************************************************************************
6554: 0000: 
6555: 0000:    FUNCTION STKBF.SET EXTERNAL
6556: 0000:    END FUNCTION
6557: 0000:    
6558: 0000:    FUNCTION READ.STKBF EXTERNAL
6559: 0000:       INTEGER*2 READ.STKBF
6560: 0000:    END FUNCTION
6561: 0000:    
6562: 0000:    FUNCTION WRITE.STKBF EXTERNAL
6563: 0000:       INTEGER*2 WRITE.STKBF
6564: 0000:    END FUNCTION
6565: 0000:  
6566: 0000:  %INCLUDE SXTMPEXT.J86                    ! 1.5
6567: 0000: \*****************************************************************************
6568: 0000: \***
6569: 0000: \***           FUNCTION DEFINITIONS FOR THE TEMPORARY STOCKTAKE BUFFER FILE
6570: 0000: \***
6571: 0000: \***           REFERENCE:   STKBFEXT.J86
6572: 0000: \***
6573: 0000: \***           VERSION A         Nik Sen         30th June 1997
6574: 0000: \***
6575: 0000: \***
6576: 0000: \*******************************************************************************
6577: 0000: \*******************************************************************************
6578: 0000: 
6579: 0000:    FUNCTION SXTMP.SET EXTERNAL
6580: 0000:    END FUNCTION
6581: 0000:    
6582: 0000:    FUNCTION READ.SXTMP EXTERNAL
6583: 0000:       INTEGER*2 READ.SXTMP
6584: 0000:    END FUNCTION
6585: 0000:    
6586: 0000:    FUNCTION WRITE.SXTMP EXTERNAL
6587: 0000:       INTEGER*2 WRITE.SXTMP
6588: 0000:    END FUNCTION
6589: 0000:  
6590: 0000:  %INCLUDE STKTKEXT.J86                    ! 1.5
6591: 0000: \*****************************************************************************
6592: 0000: \*****************************************************************************
6593: 0000: \***
6594: 0000: \***      EXTERNAL FUNCTION DEFINITIONS FOR STOCKTAKE
6595: 0000: \***
6596: 0000: \***      REFERENCE: STKTKEXT.J86
6597: 0000: \***
6598: 0000: \*****************************************************************************
6599: 0000: \*****************************************************************************
6600: 0000: 
6601: 0000: 
6602: 0000:    FUNCTION STKTK.SET EXTERNAL
6603: 0000:    END FUNCTION
6604: 0000:    
6605: 0000:  %INCLUDE STLDTEXT.J86                    ! 1.6
6606: 0000: \*****************************************************************************
6607: 0000: \*****************************************************************************
6608: 0000: \***
6609: 0000: \***                   FUNCTION DEFINITIONS FOR THE STLDT
6610: 0000: \***
6611: 0000: \***           Version A           David Artiss         20th December 2000
6612: 0000: \***
6613: 0000: \*****************************************************************************
6614: 0000: \*****************************************************************************
6615: 0000: 
6616: 0000:    FUNCTION STLDT.SET EXTERNAL
6617: 0000:    END FUNCTION
6618: 0000: 
6619: 0000:   FUNCTION READ.STLDT EXTERNAL
6620: 0000:    INTEGER*2 READ.STLDT
6621: 0000:   END FUNCTION
6622: 0000: 
6623: 0000:   FUNCTION WRITE.STLDT EXTERNAL
6624: 0000:    INTEGER*2 WRITE.STLDT
6625: 0000:   END FUNCTION
6626: 0000:  %INCLUDE SXTCFEXT.J86                    ! 1.8DA
6627: 0000: \******************************************************************************
6628: 0000: \******************************************************************************
6629: 0000: \***
6630: 0000: \***   $Workfile:   SXTCFEXT.J86  $
6631: 0000: \***
6632: 0000: \***   $Revision:   1.0  $
6633: 0000: \***
6634: 0000: \******************************************************************************
6635: 0000: \******************************************************************************
6636: 0000: \***
6637: 0000: \***   $Log:   V:\archive\j86\sxtcfext.j8v  $
6638: 0000: \***   
6639: 0000: \***      Rev 1.0   15 Jul 1997 14:21:08   DEV45PS
6640: 0000: \***    
6641: 0000: \***   
6642: 0000: \***      Rev 1.0   09 Jul 1997 11:05:30   DEV45PS
6643: 0000: \***   Stocktake System New Files
6644: 0000: \***   
6645: 0000: \******************************************************************************
6646: 0000: \******************************************************************************\*****************************************************************************
6647: 0000: \*****************************************************************************
6648: 0000: \***
6649: 0000: \***                  FUNCTION DEFINITIONS FOR SXTCF
6650: 0000: \***
6651: 0000: \***                      REFERENCE    : SXTCFEXA
6652: 0000: \***
6653: 0000: \***           VERSION A : NIK SEN  3rd July 1997
6654: 0000: \***
6655: 0000: \*****************************************************************************
6656: 0000: \*****************************************************************************
6657: 0000: 
6658: 0000:    FUNCTION SXTCF.SET EXTERNAL
6659: 0000:    END FUNCTION
6660: 0000: 
6661: 0000:   FUNCTION READ.SXTCF.LOCK EXTERNAL
6662: 0000:    INTEGER*1 READ.SXTCF.LOCK
6663: 0000:   END FUNCTION
6664: 0000: 
6665: 0000:   FUNCTION WRITE.SXTCF.UNLOCK EXTERNAL
6666: 0000:    INTEGER*1 WRITE.SXTCF.UNLOCK
6667: 0000:   END FUNCTION
6668: 0000: 
6669: 0000:   FUNCTION WRITE.SXTCF.UNLOCK.HOLD EXTERNAL
6670: 0000:    INTEGER*1 WRITE.SXTCF.UNLOCK.HOLD
6671: 0000:   END FUNCTION
6672: 0000: 
6673: 0000:   FUNCTION READ.SXTCF EXTERNAL
6674: 0000:    INTEGER*1 READ.SXTCF
6675: 0000:   END FUNCTION
6676: 0000: 
6677: 0000:   FUNCTION WRITE.SXTCF         EXTERNAL
6678: 0000:    INTEGER*1 WRITE.SXTCF        
6679: 0000:   END FUNCTION
6680: 0000: 
6681: 0000:  %INCLUDE STKCFEXT.J86                    ! 1.8DA
6682: 0000: \*****************************************************************************
6683: 0000: \*****************************************************************************
6684: 0000: \***
6685: 0000: \***                  FUNCTION DEFINITIONS FOR STKCF
6686: 0000: \***
6687: 0000: \***                      REFERENCE    : STKCFEXA
6688: 0000: \***
6689: 0000: \***           VERSION A : STEVEN GOULDING  11.01.93
6690: 0000: \***
6691: 0000: \*****************************************************************************
6692: 0000: \*****************************************************************************
6693: 0000: 
6694: 0000:    FUNCTION STKCF.SET EXTERNAL
6695: 0000:    END FUNCTION
6696: 0000: 
6697: 0000:   FUNCTION READ.STKCF.LOCK EXTERNAL
6698: 0000:    INTEGER*1 READ.STKCF.LOCK
6699: 0000:   END FUNCTION
6700: 0000: 
6701: 0000:   FUNCTION WRITE.STKCF.UNLOCK EXTERNAL
6702: 0000:    INTEGER*1 WRITE.STKCF.UNLOCK
6703: 0000:   END FUNCTION
6704: 0000: 
6705: 0000:   FUNCTION WRITE.STKCF.UNLOCK.HOLD EXTERNAL
6706: 0000:    INTEGER*1 WRITE.STKCF.UNLOCK.HOLD
6707: 0000:   END FUNCTION
6708: 0000: 
6709: 0000:   FUNCTION READ.STKCF EXTERNAL
6710: 0000:    INTEGER*1 READ.STKCF
6711: 0000:   END FUNCTION
6712: 0000: 
6713: 0000:   FUNCTION WRITE.STKCF         EXTERNAL
6714: 0000:    INTEGER*1 WRITE.STKCF        
6715: 0000:   END FUNCTION
6716: 0000: 
6717: 0000:  %INCLUDE STKMFEXT.J86                    ! 1.8DA
6718: 0000: \******************************************************************************
6719: 0000: \******************************************************************************
6720: 0000: \***
6721: 0000: \***   $Workfile:   STKMFEXT.J86  $
6722: 0000: \***
6723: 0000: \***   $Revision:   1.0  $
6724: 0000: \***
6725: 0000: \******************************************************************************
6726: 0000: \******************************************************************************
6727: 0000: \***
6728: 0000: \***   $Log:   V:\archive\j86\stkmfext.j8v  $
6729: 0000: \***   
6730: 0000: \***      Rev 1.0   15 Jul 1997 14:20:56   DEV45PS
6731: 0000: \***    
6732: 0000: \***   
6733: 0000: \***      Rev 1.0   09 Jul 1997 11:05:18   DEV45PS
6734: 0000: \***   Stocktake System New Files
6735: 0000: \***   
6736: 0000: \******************************************************************************
6737: 0000: \******************************************************************************\*****************************************************************************
6738: 0000: \***
6739: 0000: \***  FUNCTION DEFINITIONS FOR THE STOCKTAKE MAINFRAME TRANSMISSION FILE
6740: 0000: \***
6741: 0000: \***           REFERENCE:   STKMFEXT.J86
6742: 0000: \***
6743: 0000: \***           VERSION A         Nik Sen         19th June 1997
6744: 0000: \***
6745: 0000: \***
6746: 0000: \*******************************************************************************
6747: 0000: \*******************************************************************************
6748: 0000: 
6749: 0000:    FUNCTION STKMF.SET EXTERNAL
6750: 0000:    END FUNCTION
6751: 0000:    
6752: 0000:    FUNCTION READ.STKMF EXTERNAL
6753: 0000:       INTEGER*2 READ.STKMF
6754: 0000:    END FUNCTION
6755: 0000:    
6756: 0000:    FUNCTION WRITE.STKMF EXTERNAL
6757: 0000:       INTEGER*2 WRITE.STKMF
6758: 0000:    END FUNCTION
6759: 0000:  
6760: 0000:  %INCLUDE STKRCEXT.J86                    ! 1.8DA
6761: 0000: \******************************************************************************
6762: 0000: \******************************************************************************
6763: 0000: \***
6764: 0000: \***   $Workfile:   STKRCEXT.J86  $
6765: 0000: \***
6766: 0000: \***   $Revision:   1.0  $
6767: 0000: \***
6768: 0000: \******************************************************************************
6769: 0000: \******************************************************************************
6770: 0000: \***
6771: 0000: \***   $Log:   V:\archive\j86\stkrcext.j8v  $
6772: 0000: \***   
6773: 0000: \***      Rev 1.0   15 Jul 1997 14:21:00   DEV45PS
6774: 0000: \***    
6775: 0000: \***   
6776: 0000: \***      Rev 1.0   09 Jul 1997 11:05:24   DEV45PS
6777: 0000: \***   Stocktake System New Files
6778: 0000: \***   
6779: 0000: \******************************************************************************
6780: 0000: \******************************************************************************\*****************************************************************************
6781: 0000: \***
6782: 0000: \***           FUNCTION DEFINITIONS FOR THE STOCKTAKE RECOUNT FILE
6783: 0000: \***
6784: 0000: \***           REFERENCE:   STKRCEXT.J86
6785: 0000: \***
6786: 0000: \***           VERSION A         Nik Sen         19th June 1997
6787: 0000: \***
6788: 0000: \***
6789: 0000: \*******************************************************************************
6790: 0000: \*******************************************************************************
6791: 0000: 
6792: 0000:    FUNCTION STKRC.SET EXTERNAL
6793: 0000:    END FUNCTION
6794: 0000:    
6795: 0000:    FUNCTION READ.STKRC EXTERNAL
6796: 0000:       INTEGER*2 READ.STKRC
6797: 0000:    END FUNCTION
6798: 0000:    
6799: 0000:    FUNCTION WRITE.STKRC EXTERNAL
6800: 0000:       INTEGER*2 WRITE.STKRC
6801: 0000:    END FUNCTION
6802: 0000:  
6803: 0000:  %INCLUDE XGCFEXT.J86                     ! 1.8DA
6804: 0000: \******************************************************************************
6805: 0000: \******************************************************************************
6806: 0000: \***
6807: 0000: \***         %INCLUDE FOR STOCKTAKE GROUP CODE FILE
6808: 0000: \***
6809: 0000: \***                  FILE TYPE    : Keyed
6810: 0000: \***
6811: 0000: \***                  REFERENCE    : XGCFEXT.J86
6812: 0000: \***
6813: 0000: \***    VERSION A               Steve Wright                        24 Aug 1999
6814: 0000: \***
6815: 0000: \*******************************************************************************
6816: 0000: \*******************************************************************************
6817: 0000: 
6818: 0000: FUNCTION XGCF.SET EXTERNAL
6819: 0000: END FUNCTION
6820: 0000: 
6821: 0000: FUNCTION READ.XGCF EXTERNAL
6822: 0000:    INTEGER*2 READ.XGCF
6823: 0000: END FUNCTION
6824: 0000: 
6825: 0000: FUNCTION READ.XGCF.LOCK EXTERNAL
6826: 0000:    INTEGER*2 READ.XGCF.LOCK
6827: 0000: END FUNCTION
6828: 0000: 
6829: 0000: FUNCTION WRITE.XGCF EXTERNAL
6830: 0000:    INTEGER*2 WRITE.XGCF
6831: 0000: END FUNCTION
6832: 0000: 
6833: 0000: FUNCTION WRITE.XGCF.HOLD EXTERNAL
6834: 0000:    INTEGER*2 WRITE.XGCF.HOLD
6835: 0000: END FUNCTION
6836: 0000: 
6837: 0000: FUNCTION WRITE.XGCF.UNLOCK EXTERNAL
6838: 0000:    INTEGER*2 WRITE.XGCF.UNLOCK
6839: 0000: END FUNCTION
6840: 0000: 
6841: 0000:  %INCLUDE STKEXEXT.J86                    ! 1.8DA
6842: 0000: \******************************************************************************
6843: 0000: \******************************************************************************
6844: 0000: \***
6845: 0000: \***   $Workfile:   STKEXEXT.J86  $
6846: 0000: \***
6847: 0000: \***   $Revision:   1.0  $
6848: 0000: \***
6849: 0000: \******************************************************************************
6850: 0000: \******************************************************************************
6851: 0000: \***
6852: 0000: \***   $Log:   V:\archive\j86\stkexext.j8v  $
6853: 0000: \***   
6854: 0000: \***      Rev 1.0   15 Jul 1997 14:20:44   DEV45PS
6855: 0000: \***    
6856: 0000: \***   
6857: 0000: \***      Rev 1.0   09 Jul 1997 11:05:06   DEV45PS
6858: 0000: \***   Stocktake System New Files
6859: 0000: \***   
6860: 0000: \******************************************************************************
6861: 0000: \******************************************************************************\*****************************************************************************
6862: 0000: \***
6863: 0000: \***           FUNCTION DEFINITIONS FOR THE STOCKTAKE EXCEPTIONS FILE
6864: 0000: \***
6865: 0000: \***           REFERENCE:   STKEXEXT.J86
6866: 0000: \***
6867: 0000: \***           VERSION A         Nik Sen         19th June 1997
6868: 0000: \***
6869: 0000: \***
6870: 0000: \*******************************************************************************
6871: 0000: \*******************************************************************************
6872: 0000: 
6873: 0000:    FUNCTION STKEX.SET EXTERNAL
6874: 0000:    END FUNCTION
6875: 0000:    
6876: 0000:    FUNCTION READ.STKEX EXTERNAL
6877: 0000:       INTEGER*2 READ.STKEX
6878: 0000:    END FUNCTION
6879: 0000:    
6880: 0000:    FUNCTION WRITE.STKEX EXTERNAL
6881: 0000:       INTEGER*2 WRITE.STKEX
6882: 0000:    END FUNCTION
6883: 0000:  
6884: 0000:  %INCLUDE STKIFEXT.J86                    ! 1.8DA
6885: 0000: \******************************************************************************
6886: 0000: \******************************************************************************
6887: 0000: \***
6888: 0000: \***   $Workfile:   STKIFEXT.J86  $
6889: 0000: \***
6890: 0000: \***   $Revision:   1.0  $
6891: 0000: \***
6892: 0000: \******************************************************************************
6893: 0000: \******************************************************************************
6894: 0000: \***
6895: 0000: \***   $Log:   V:\archive\j86\stkifext.j8v  $
6896: 0000: \***   
6897: 0000: \***      Rev 1.0   15 Jul 1997 14:20:48   DEV45PS
6898: 0000: \***    
6899: 0000: \***   
6900: 0000: \***      Rev 1.0   09 Jul 1997 11:05:12   DEV45PS
6901: 0000: \***   Stocktake System New Files
6902: 0000: \***   
6903: 0000: \******************************************************************************
6904: 0000: \******************************************************************************\*****************************************************************************
6905: 0000: \***
6906: 0000: \***           FUNCTION DEFINITIONS FOR THE STOCKTAKE ITEM FILE
6907: 0000: \***
6908: 0000: \***           REFERENCE:   STKIFEXT.J86
6909: 0000: \***
6910: 0000: \***           VERSION A         Nik Sen         19th June 1997
6911: 0000: \***
6912: 0000: \***
6913: 0000: \*******************************************************************************
6914: 0000: \*******************************************************************************
6915: 0000: 
6916: 0000:    FUNCTION STKIF.SET EXTERNAL
6917: 0000:    END FUNCTION
6918: 0000:    
6919: 0000:    FUNCTION READ.STKIF EXTERNAL
6920: 0000:       INTEGER*2 READ.STKIF
6921: 0000:    END FUNCTION
6922: 0000:    
6923: 0000:    FUNCTION WRITE.STKIF EXTERNAL
6924: 0000:       INTEGER*2 WRITE.STKIF
6925: 0000:    END FUNCTION
6926: 0000:  
6927: 0000:  %INCLUDE LOCNTEXT.J86                    ! 1.8DA
6928: 0000: \******************************************************************************
6929: 0000: \******************************************************************************
6930: 0000: \***
6931: 0000: \***   $Workfile:   LOCNTEXT.J86  $
6932: 0000: \***
6933: 0000: \***   $Revision:   1.0  $
6934: 0000: \***
6935: 0000: \******************************************************************************
6936: 0000: \******************************************************************************
6937: 0000: \***
6938: 0000: \***   $Log:   V:\archive\j86\locntext.j8v  $
6939: 0000: \***   
6940: 0000: \***      Rev 1.0   03 Feb 1998 10:07:40   DEV69PS
6941: 0000: \***    
6942: 0000: \***   
6943: 0000: \******************************************************************************
6944: 0000: \******************************************************************************
6945: 0000: \***
6946: 0000: \***           FUNCTION DEFINITIONS FOR THE STOCKTAKE LOCATION COUNT FILE
6947: 0000: \***
6948: 0000: \***           REFERENCE:   LOCNTEXT.J86
6949: 0000: \***
6950: 0000: \***           VERSION A         Johnnie Chan    6th Jan 1998
6951: 0000: \***
6952: 0000: \***
6953: 0000: \*******************************************************************************
6954: 0000: \*******************************************************************************
6955: 0000: 
6956: 0000:    FUNCTION LOCCNT.SET EXTERNAL
6957: 0000:    END FUNCTION
6958: 0000:    
6959: 0000:    FUNCTION READ.LOCCNT EXTERNAL
6960: 0000:       INTEGER*2 READ.LOCCNT
6961: 0000:    END FUNCTION
6962: 0000:    
6963: 0000:    FUNCTION WRITE.LOCCNT EXTERNAL
6964: 0000:       INTEGER*2 WRITE.LOCCNT
6965: 0000:    END FUNCTION
6966: 0000: 
6967: 0000:    FUNCTION GET.LOCCNT.RECNUM(LOC.CODE$) EXTERNAL
6968: 0000:       INTEGER*4 GET.LOCCNT.RECNUM
6969: 0000:       STRING LOC.CODE$
6970: 0000:    END FUNCTION
6971: 0000:  
6972: 0000:  %INCLUDE STKIGEXT.J86                    ! 1.8DA
6973: 0000: \*****************************************************************************
6974: 0000: \***
6975: 0000: \***           FUNCTION DEFINITIONS FOR THE STOCKTAKE ITEM GROUP FILE
6976: 0000: \***
6977: 0000: \***           REFERENCE:   STKIGEXT.J86
6978: 0000: \***
6979: 0000: \***           VERSION A         Nik Sen         17th June 1997
6980: 0000: \***
6981: 0000: \***
6982: 0000: \*******************************************************************************
6983: 0000: \*******************************************************************************
6984: 0000: 
6985: 0000:    FUNCTION STKIG.SET EXTERNAL
6986: 0000:    END FUNCTION
6987: 0000:    
6988: 0000:    FUNCTION READ.STKIG EXTERNAL
6989: 0000:       INTEGER*2 READ.STKIG
6990: 0000:    END FUNCTION
6991: 0000:    
6992: 0000:    FUNCTION WRITE.STKIG EXTERNAL
6993: 0000:       INTEGER*2 WRITE.STKIG
6994: 0000:    END FUNCTION
6995: 0000:  
6996: 0000:  %INCLUDE STKTFEXT.J86                    ! 1.8DA
6997: 0000: \******************************************************************************
6998: 0000: \******************************************************************************
6999: 0000: \***
7000: 0000: \***   $Workfile:   STKTFEXT.J86  $
7001: 0000: \***
7002: 0000: \***   $Revision:   1.1  $
7003: 0000: \***
7004: 0000: \******************************************************************************
7005: 0000: \******************************************************************************
7006: 0000: \***
7007: 0000: \***   $Log:   V:\archive\j86\stktfext.j8v  $
7008: 0000: \***   
7009: 0000: \***      Rev 1.1   15 Jul 1997 14:36:30   DEV45PS
7010: 0000: \***    
7011: 0000: \***   
7012: 0000: \***      Rev 1.0   15 Jul 1997 14:21:04   DEV45PS
7013: 0000: \***   Stocktake System New Files
7014: 0000: \***   
7015: 0000: \******************************************************************************
7016: 0000: \******************************************************************************\*****************************************************************************
7017: 0000: \***
7018: 0000: \***           FUNCTION DEFINITIONS FOR THE STOCKTAKE TOTALS FILE
7019: 0000: \***
7020: 0000: \***           REFERENCE:   STKTFEXT.J86
7021: 0000: \***
7022: 0000: \***           VERSION A         Nik Sen         15th July 1997
7023: 0000: \***
7024: 0000: \***
7025: 0000: \*******************************************************************************
7026: 0000: \*******************************************************************************
7027: 0000: 
7028: 0000:    FUNCTION STKTF.SET EXTERNAL
7029: 0000:    END FUNCTION
7030: 0000:    
7031: 0000:    FUNCTION READ.STKTF EXTERNAL
7032: 0000:       INTEGER*2 READ.STKTF
7033: 0000:    END FUNCTION
7034: 0000:    
7035: 0000:    FUNCTION WRITE.STKTF EXTERNAL
7036: 0000:       INTEGER*2 WRITE.STKTF
7037: 0000:    END FUNCTION
7038: 0000:  
7039: 0000:  %INCLUDE IRFEXT.J86                      ! 1.8DA
7040: 0000: \*********************************************************************************
7041: 0000: \***
7042: 0000: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE ITEM REFERENCE FILE
7043: 0000: \***
7044: 0000: \***                    REFERENCE : IRFEXT.J86
7045: 0000: \***
7046: 0000: \***      Version A          Andrew Wedgeworth        9th July 1992
7047: 0000: \***
7048: 0000: \***      Version B          Andrew Wedgeworth        14th December 1992
7049: 0000: \***      Version letter incremented to match other IRF code.
7050: 0000: \***
7051: 0000: \***      Version C           Steve Windsor        12.02.93
7052: 0000: \***      Added external reference to read the alternate IRF.
7053: 0000: \***
7054: 0000: \***      Version D           Steve Windsor        12.05.93
7055: 0000: \***      Added all external references that wre in the original FNS.
7056: 0000: \***
7057: 0000: \***      Version E           Steve Perkins        21.09.93
7058: 0000: \***      Deals project: Fields changed for new deals project
7059: 0000: \*** 
7060: 0000: \***      Version F           Mark Walker          5th January 1994
7061: 0000: \***      Version letter incremented to match other IRF code.           
7062: 0000: \***                                                                    
7063: 0000: \***      Version G     Stuart William McConnachie      11th February 2000
7064: 0000: \***      Converted IRF.INDICAT2$ to integer flag byte.
7065: 0000: \***
7066: 0000: \***      REVISION 1.6.               ROBERT COWEY.               9 JUL 2002.
7067: 0000: \***      Major changes to IRF layout for 2002 Deals Rewrite project.
7068: 0000: \***      No changes to this particular file for this revision.
7069: 0000: \***
7070: 0000: \***      REVISION 1.7.               ROBERT COWEY.               5 AUG 2002.
7071: 0000: \***      Further changes for 2002 Deals Rewrite project (PSBF19 related).
7072: 0000: \***      Defined new functions CONCAT.NEW.IRF.DATA$ and SPLIT.NEW.IRF.DATA$.
7073: 0000: \***
7074: 0000: \***      REVISION 1.8                ROBERT COWEY.              15 JUL 2003.
7075: 0000: \***      Usage of INDICAT0% bit-3 X'08' changed to Item Contains Alcohol.
7076: 0000: \***      No changes to this file other than description.
7077: 0000: \***      No changes to IRF file functions.
7078: 0000: \***
7079: 0000: \***      REVISION 1.9.      STUART WILLIAM MCCONNACHIE           22 OCT 2003.
7080: 0000: \***      Changes to remove limit of 3 deals per item.
7081: 0000: \***      No changes to this file.
7082: 0000: \***
7083: 0000: \***      REVISION 2.0.             ALAN CARR                      9 FEB 2006.
7084: 0000: \***      Add new IRF.INDICAT8% 1 byte, amend IRF.UNUSED$ from 3 to 2 bytes.
7085: 0000: \***      No changes to this file.
7086: 0000: \***
7087: 0000: \***..............................................................................
7088: 0000:    
7089: 0000:    FUNCTION IRF.SET EXTERNAL
7090: 0000:    END FUNCTION
7091: 0000: 
7092: 0000:   FUNCTION CONCAT.NEW.IRF.DATA$ EXTERNAL                                  ! 1.7 RC
7093: 0000:   END FUNCTION                                                            ! 1.7 RC
7094: 0000: 
7095: 0000:   FUNCTION SPLIT.NEW.IRF.DATA$ EXTERNAL                                   ! 1.7 RC
7096: 0000:   END FUNCTION                                                            ! 1.7 RC
7097: 0000:   
7098: 0000:   FUNCTION READ.IRF EXTERNAL
7099: 0000:    INTEGER*2 READ.IRF
7100: 0000:   END FUNCTION
7101: 0000: 
7102: 0000:   FUNCTION READ.IRF.ALT EXTERNAL
7103: 0000:    INTEGER*2 READ.IRF.ALT
7104: 0000:   END FUNCTION
7105: 0000: 
7106: 0000:   FUNCTION READ.IRF.LOCK EXTERNAL
7107: 0000:    INTEGER*2 READ.IRF.LOCK
7108: 0000:   END FUNCTION
7109: 0000: 
7110: 0000:   FUNCTION WRITE.IRF EXTERNAL
7111: 0000:    INTEGER*2 WRITE.IRF
7112: 0000:   END FUNCTION
7113: 0000: 
7114: 0000:   FUNCTION WRITE.IRF.UNLOCK EXTERNAL
7115: 0000:    INTEGER*2 WRITE.IRF.UNLOCK
7116: 0000:   END FUNCTION
7117: 0000: 
7118: 0000:   FUNCTION WRITE.IRF.HOLD EXTERNAL
7119: 0000:    INTEGER*2 WRITE.IRF.HOLD
7120: 0000:   END FUNCTION
7121: 0000: 
7122: 0000:   FUNCTION WRITE.IRF.HOLD.UNLOCK EXTERNAL
7123: 0000:    INTEGER*2 WRITE.IRF.HOLD.UNLOCK
7124: 0000:   END FUNCTION
7125: 0000: 
7126: 0000:   
7127: 0000:  %INCLUDE STKDCEXT.J86                    ! 1.8DA
7128: 0000: \******************************************************************************
7129: 0000: \******************************************************************************
7130: 0000: \***
7131: 0000: \***   $Workfile:   STKDCEXT.J86  $
7132: 0000: \***
7133: 0000: \***   $Revision:   1.0  $
7134: 0000: \***
7135: 0000: \******************************************************************************
7136: 0000: \******************************************************************************
7137: 0000: \***
7138: 0000: \***   $Log:   V:\archive\j86\stkdcext.j8v  $
7139: 0000: \***   
7140: 0000: \***      Rev 1.0   15 Jul 1997 14:20:40   DEV45PS
7141: 0000: \***    
7142: 0000: \***   
7143: 0000: \***      Rev 1.0   09 Jul 1997 11:05:00   DEV45PS
7144: 0000: \***   Stocktake System New Files
7145: 0000: \***   
7146: 0000: \******************************************************************************
7147: 0000: \******************************************************************************\*****************************************************************************
7148: 0000: \***
7149: 0000: \***           FUNCTION DEFINITIONS FOR THE STOCKTAKE DUMP CODE FILE
7150: 0000: \***
7151: 0000: \***           REFERENCE:   STKDCEXT.J86
7152: 0000: \***
7153: 0000: \***           VERSION A         Nik Sen         19th June 1997
7154: 0000: \***
7155: 0000: \***
7156: 0000: \*******************************************************************************
7157: 0000: \*******************************************************************************
7158: 0000: 
7159: 0000:    FUNCTION STKDC.SET EXTERNAL
7160: 0000:    END FUNCTION
7161: 0000:    
7162: 0000:    FUNCTION READ.STKDC EXTERNAL
7163: 0000:       INTEGER*2 READ.STKDC
7164: 0000:    END FUNCTION
7165: 0000:    
7166: 0000:    FUNCTION WRITE.STKDC EXTERNAL
7167: 0000:       INTEGER*2 WRITE.STKDC
7168: 0000:    END FUNCTION
7169: 0000:  
7170: 0000:  %INCLUDE IMSTCEXT.J86                    ! 1.9BG
7171: 0000: \***********************************************************************
7172: 0000: \***********************************************************************
7173: 0000: \***
7174: 0000: \***    DESCRIPTION: Item Movement & Stock File
7175: 0000: \***                 External File Function Definitions
7176: 0000: \***
7177: 0000: \***    FILE TYPE : Keyed
7178: 0000: \***
7179: 0000: \***********************************************************************
7180: 0000: \***
7181: 0000: \***    Version A.          Les Cook                     21st Aug 1992
7182: 0000: \***    Initial version.
7183: 0000: \***
7184: 0000: \***    VERSION 1.1         Julia Stones                 13th Jun 2005
7185: 0000: \***    Added new external functions for
7186: 0000: \***        MIMSTC - merged IMSTC
7187: 0000: \***        CIMSTC - Copy of IMSTC
7188: 0000: \***        BIMSTC - Backup of IMSTC
7189: 0000: \***
7190: 0000: \***    Version C.          Mark Walker                  23rd Jan 2014
7191: 0000: \***    F337 Centralised View of Stock
7192: 0000: \***    - Moved BIMST, CIMST and MIMST external function definitions
7193: 0000: \***      to separate modules.
7194: 0000: \***    - Minor formatting changes (uncommented).
7195: 0000: \***
7196: 0000: \***********************************************************************
7197: 0000: \***********************************************************************
7198: 0000: 
7199: 0000: FUNCTION IMSTC.SET EXTERNAL
7200: 0000: END FUNCTION
7201: 0000: 
7202: 0000: FUNCTION READ.IMSTC EXTERNAL
7203: 0000:     INTEGER*2 READ.IMSTC
7204: 0000: END FUNCTION
7205: 0000: 
7206: 0000: FUNCTION READ.IMSTC.LOCK EXTERNAL
7207: 0000:     INTEGER*2 READ.IMSTC.LOCK
7208: 0000: END FUNCTION
7209: 0000: 
7210: 0000: FUNCTION WRITE.IMSTC EXTERNAL
7211: 0000:    INTEGER*2 WRITE.IMSTC
7212: 0000: END FUNCTION
7213: 0000: 
7214: 0000: FUNCTION WRITE.IMSTC.UNLOCK.HOLD EXTERNAL
7215: 0000:     INTEGER*2 WRITE.IMSTC.UNLOCK.HOLD
7216: 0000: END FUNCTION
7217: 0000: 
7218: 0000: FUNCTION WRITE.IMSTC.UNLOCK EXTERNAL
7219: 0000:    INTEGER*2 WRITE.IMSTC.UNLOCK
7220: 0000: END FUNCTION
7221: 0000: 
7222: 0000: FUNCTION WRITE.IMSTC.HOLD EXTERNAL
7223: 0000:    INTEGER*2 WRITE.IMSTC.HOLD
7224: 0000: END FUNCTION
7225: 0000: 
7226: 0000:  %INCLUDE STOCKEXT.J86                    ! 1.9BG
7227: 0000: \***********************************************************************
7228: 0000: \***********************************************************************
7229: 0000: \***
7230: 0000: \***    DESCRIPTION: Stock File
7231: 0000: \***                 External File Function Definitions
7232: 0000: \***
7233: 0000: \***    FILE TYPE : Keyed
7234: 0000: \***
7235: 0000: \***********************************************************************
7236: 0000: \***
7237: 0000: \***    Version A.          Les Cook                     21st Aug 1992
7238: 0000: \***    Initial version.
7239: 0000: \***
7240: 0000: \***    Version B.          Robert Cowey                 21st Oct 1993
7241: 0000: \***    No changes to this file.
7242: 0000: \***
7243: 0000: \***    Version C.          Nik Sen                      22nd Dec 1994
7244: 0000: \***    WRITE.STOCK.HOLD added.
7245: 0000: \***
7246: 0000: \***    Version D.          Mark Walker                  23rd Jan 2014
7247: 0000: \***    F337 Centralised View of Stock
7248: 0000: \***    - Minor formatting changes (uncommented).
7249: 0000: \***
7250: 0000: \***********************************************************************
7251: 0000: \***********************************************************************
7252: 0000: 
7253: 0000: FUNCTION STOCK.SET EXTERNAL
7254: 0000: END FUNCTION
7255: 0000:    
7256: 0000: FUNCTION READ.STOCK EXTERNAL
7257: 0000:     INTEGER*2 READ.STOCK
7258: 0000: END FUNCTION
7259: 0000:    
7260: 0000: FUNCTION WRITE.STOCK EXTERNAL
7261: 0000:     INTEGER*2 WRITE.STOCK
7262: 0000: END FUNCTION
7263: 0000:    
7264: 0000: FUNCTION WRITE.STOCK.HOLD EXTERNAL
7265: 0000:     INTEGER*2 WRITE.STOCK.HOLD
7266: 0000: END FUNCTION
7267: 0000: 
7268: 0000: FUNCTION READ.STOCK.LOCK EXTERNAL
7269: 0000:     INTEGER*2 READ.STOCK.LOCK
7270: 0000: END FUNCTION
7271: 0000:    
7272: 0000: FUNCTION WRITE.STOCK.UNLOCK EXTERNAL
7273: 0000:     INTEGER*2 WRITE.STOCK.UNLOCK
7274: 0000: END FUNCTION
7275: 0000:    
7276: 0000: FUNCTION WRITE.STOCK.UNLOCK.HOLD EXTERNAL
7277: 0000:     INTEGER*2 WRITE.STOCK.UNLOCK.HOLD
7278: 0000: END FUNCTION
7279: 0000: 
7280: 0000:  %INCLUDE MINLSEXT.J86                    ! 1.9BG
7281: 0000: 
7282: 0000: \*****************************************************************************
7283: 0000: \*****************************************************************************
7284: 0000: \***
7285: 0000: \***        %INCLUDE FOR FILE HANDLING FUNCTIONS EXTERNAL DEFINITIONS
7286: 0000: \***
7287: 0000: \***                   FILE TYPE:  KEYED
7288: 0000: \***
7289: 0000: \***                   REFERENCE:  MINLSEXT.J86
7290: 0000: \***
7291: 0000: \***	             DESCRIPTION:  MINSITS RP - SCREEN COUNT INFORMATION
7292: 0000: \***
7293: 0000: \***
7294: 0000: \***
7295: 0000: \***      VERSION 1 : Julia Stones             8th January 1998   
7296: 0000: \***      
7297: 0000: \*****************************************************************************
7298: 0000: \*****************************************************************************
7299: 0000: 
7300: 0000: 
7301: 0000:   FUNCTION MINLS.SET EXTERNAL
7302: 0000:      INTEGER*2 MINLS.SET
7303: 0000:   END FUNCTION
7304: 0000: 
7305: 0000: 
7306: 0000:   FUNCTION READ.MINLS EXTERNAL
7307: 0000:     INTEGER*2 READ.MINLS
7308: 0000:   END FUNCTION
7309: 0000:   
7310: 0000: 
7311: 0000:   FUNCTION READ.MINLS.LOCKED EXTERNAL
7312: 0000:     INTEGER*2 READ.MINLS.LOCKED
7313: 0000:   END FUNCTION  
7314: 0000: 
7315: 0000: 
7316: 0000:   FUNCTION WRITE.HOLD.MINLS EXTERNAL
7317: 0000:     INTEGER*2 WRITE.HOLD.MINLS
7318: 0000:   END FUNCTION
7319: 0000: 
7320: 0000: 
7321: 0000:   FUNCTION WRITE.UNLOCK.MINLS EXTERNAL
7322: 0000:     INTEGER*2 WRITE.UNLOCK.MINLS
7323: 0000:   END FUNCTION
7324: 0000: 
7325: 0000: 
7326: 0000:   FUNCTION WRITE.HOLD.UNLOCK.MINLS EXTERNAL
7327: 0000:     INTEGER*2 WRITE.HOLD.UNLOCK.MINLS
7328: 0000:   END FUNCTION
7329: 0000:   
7330: 0000: 
7331: 0000:   FUNCTION WRITE.MINLS EXTERNAL
7332: 0000:     INTEGER*2 WRITE.MINLS
7333: 0000:   END FUNCTION
7334: 0000: 
7335: 0000:  %INCLUDE NEGSCEXT.J86                    ! 1.9BG
7336: 0000: 
7337: 0000: \*****************************************************************************
7338: 0000: \*****************************************************************************
7339: 0000: \***
7340: 0000: \***        %INCLUDE FOR FILE HANDLING FUNCTIONS EXTERNAL DEFINITIONS
7341: 0000: \***
7342: 0000: \***                   FILE TYPE:  KEYED
7343: 0000: \***
7344: 0000: \***                   REFERENCE:  NEGSCEXT.J86
7345: 0000: \***
7346: 0000: \***                 DESCRIPTION:  CURRENT NEGATIVE STOCK COUNT INFORMATION
7347: 0000: \***
7348: 0000: \***
7349: 0000: \***
7350: 0000: \***      VERSION 1 : Julia Stones             15th July 1999   
7351: 0000: \***      
7352: 0000: \***    REVISION 1.2.            ROBERT COWEY.                  09 SEP 2003.
7353: 0000: \***    Changes for RF trial.
7354: 0000: \***    Recompiled to prevent future automatic recompiles.
7355: 0000: \***    No changes to actual code.
7356: 0000: \***
7357: 0000: \*****************************************************************************
7358: 0000: \*****************************************************************************
7359: 0000: 
7360: 0000: 
7361: 0000:   FUNCTION NEGSC.SET EXTERNAL
7362: 0000:      INTEGER*2 NEGSC.SET
7363: 0000:   END FUNCTION
7364: 0000: 
7365: 0000: 
7366: 0000:   FUNCTION READ.NEGSC EXTERNAL
7367: 0000:     INTEGER*2 READ.NEGSC
7368: 0000:   END FUNCTION
7369: 0000:   
7370: 0000: 
7371: 0000:   FUNCTION READ.NEGSC.LOCKED EXTERNAL
7372: 0000:     INTEGER*2 READ.NEGSC.LOCKED
7373: 0000:   END FUNCTION  
7374: 0000: 
7375: 0000: 
7376: 0000:   FUNCTION WRITE.HOLD.NEGSC EXTERNAL
7377: 0000:     INTEGER*2 WRITE.HOLD.NEGSC
7378: 0000:   END FUNCTION
7379: 0000: 
7380: 0000: 
7381: 0000:   FUNCTION WRITE.UNLOCK.NEGSC EXTERNAL
7382: 0000:     INTEGER*2 WRITE.UNLOCK.NEGSC
7383: 0000:   END FUNCTION
7384: 0000: 
7385: 0000: 
7386: 0000:   FUNCTION WRITE.HOLD.UNLOCK.NEGSC EXTERNAL
7387: 0000:     INTEGER*2 WRITE.HOLD.UNLOCK.NEGSC
7388: 0000:   END FUNCTION
7389: 0000:   
7390: 0000: 
7391: 0000:   FUNCTION WRITE.NEGSC EXTERNAL
7392: 0000:     INTEGER*2 WRITE.NEGSC
7393: 0000:   END FUNCTION
7394: 0000: 
7395: 0000:  %INCLUDE SSPSCEXT.J86                    ! 2.0JAS
7396: 0000: \*****************************************************************************
7397: 0000: \*****************************************************************************
7398: 0000: \***
7399: 0000: \***         FUNCTION DEFINITIONS FOR SSPSCTRL
7400: 0000: \***
7401: 0000: \***                    REFERENCE : SSPSCexa.J86
7402: 0000: \***
7403: 0000: \***    Version A           Julia Stones         23.10.2003
7404: 0000: \***
7405: 0000: \*******************************************************************************
7406: 0000: \*******************************************************************************
7407: 0000: 
7408: 0000:   FUNCTION SSPSCTRL.SET EXTERNAL
7409: 0000:    INTEGER*2 SSPSCTRL.SET
7410: 0000:   END FUNCTION
7411: 0000: 
7412: 0000:   FUNCTION READ.SSPSCTRL EXTERNAL
7413: 0000:    INTEGER*2 READ.SSPSCTRL
7414: 0000:   END FUNCTION
7415: 0000: 
7416: 0000:   FUNCTION READ.SSPSCTRL.LOCKED EXTERNAL
7417: 0000:    INTEGER*2 READ.SSPSCTRL.LOCKED
7418: 0000:   END FUNCTION
7419: 0000: 
7420: 0000:   FUNCTION WRITE.SSPSCTRL EXTERNAL
7421: 0000:    INTEGER*2 WRITE.SSPSCTRL
7422: 0000:   END FUNCTION
7423: 0000: 
7424: 0000:   FUNCTION WRITE.SSPSCTRL.UNLOCK EXTERNAL
7425: 0000:    INTEGER*2 WRITE.SSPSCTRL.UNLOCK
7426: 0000:   END FUNCTION
7427: 0000: 
7428: 0000:  %INCLUDE BTCSEXT.J86                     ! 2.0JAS
7429: 0000: \*****************************************************************************
7430: 0000: \*****************************************************************************
7431: 0000: \***
7432: 0000: \***         FUNCTION DEFINITIONS FOR BTCS FILE
7433: 0000: \***
7434: 0000: \***         REFERENCE    : BTCSEXT
7435: 0000: \***
7436: 0000: \***         VERSION A    : JULIA STONES 23/10/03
7437: 0000: \***
7438: 0000: \*****************************************************************************
7439: 0000: \*****************************************************************************
7440: 0000: 
7441: 0000:     FUNCTION BTCS.SET EXTERNAL
7442: 0000:     END FUNCTION
7443: 0000: 
7444: 0000:     FUNCTION READ.BTCS EXTERNAL
7445: 0000:     INTEGER*1 READ.BTCS
7446: 0000:     END FUNCTION
7447: 0000: 
7448: 0000:     FUNCTION READ.BTCS.LOCK EXTERNAL
7449: 0000:     INTEGER*1 READ.BTCS.LOCK
7450: 0000:     END FUNCTION
7451: 0000: 
7452: 0000:     FUNCTION WRITE.BTCS EXTERNAL
7453: 0000:     INTEGER*1 WRITE.BTCS
7454: 0000:     END FUNCTION
7455: 0000: 
7456: 0000:     FUNCTION WRITE.BTCS.UNLOCK EXTERNAL
7457: 0000:     INTEGER*1 WRITE.BTCS.UNLOCK
7458: 0000:     END FUNCTION
7459: 0000: 
7460: 0000:     FUNCTION WRITE.BTCS.UNLOCK.HOLD EXTERNAL
7461: 0000:     INTEGER*1 WRITE.BTCS.UNLOCK.HOLD
7462: 0000:     END FUNCTION
7463: 0000: 
7464: 0000:  %INCLUDE PRINTEXT.J86                    ! 2.0JAS
7465: 0000: 
7466: 0000: REM \
7467: 0000: \*******************************************************************************
7468: 0000: \*******************************************************************************
7469: 0000: \***
7470: 0000: \***    %INCLUDE FOR PRINT FILE EXTERNAL FUNCTIONS
7471: 0000: \***
7472: 0000: \***        REFERENCE   :   PRINTEX (J86)
7473: 0000: \***
7474: 0000: \***        FILE TYPE   :   Printer / Labeller
7475: 0000: \***
7476: 0000: \***    VERSION A.              ANDREW WEDGEWORTH                   09 JUL 1992.
7477: 0000: \***    Original version created from PRINTEXG.
7478: 0000: \***
7479: 0000: \***    VERSION B.              UNKNOWN.                            ?? ??? 1992.
7480: 0000: \***    Changes unknown.
7481: 0000: \***
7482: 0000: \***    VERSION C.              ROBERT COWEY.                       18 NOV 1992.
7483: 0000: \***    Defined function variables for use as return codes.
7484: 0000: \***
7485: 0000: \***    Version C               Andrew Wedgeworth                 24th May 1992
7486: 0000: \***    Condensed print function added.
7487: 0000: \***
7488: 0000: \***    Version D               Stuart WIlliam McConnachie       31st July 2000.
7489: 0000: \***    Added function for PCL printing to LaserJet.
7490: 0000: \***
7491: 0000: \***    Version E               Charles Skadorwa                   4th Apr 2008.
7492: 0000: \***    Added parameter to WRITE.CONDENSED.PRINT function to
7493: 0000: \***    enable Alliance Pharmacy Brother Laser printers to print
7494: 0000: \***    in condensed mode.
7495: 0000: \***
7496: 0000: \***    Version F           Charles Skadorwa                       2nd Mar 2016.
7497: 0000: \***    It was found that certain reports would not print when stores
7498: 0000: \***    were converted to LAN attached printing.
7499: 0000: \***
7500: 0000: \***    Added new function: WRITE.PRINT.PLUS.LF based on WRITE.PRINT.
7501: 0000: \***    This adds a Line-Feed characters to every print line.
7502: 0000: \***
7503: 0000: \*******************************************************************************
7504: 0000: \*******************************************************************************
7505: 0000: 
7506: 0000: 
7507: 0000:     FUNCTION PRINT.SET EXTERNAL
7508: 0000:         INTEGER*2 PRINT.SET
7509: 0000:     END FUNCTION
7510: 0000: 
7511: 0000: 
7512: 0000:     FUNCTION WRITE.PRINT EXTERNAL
7513: 0000:        INTEGER*2 WRITE.PRINT
7514: 0000:     END FUNCTION
7515: 0000: 
7516: 0000: 
7517: 0000:     FUNCTION WRITE.PRINT.PLUS.LF EXTERNAL                               !FCS
7518: 0000:        INTEGER*2 WRITE.PRINT.PLUS.LF                                    !FCS
7519: 0000:     END FUNCTION                                                        !FCS
7520: 0000: 
7521: 0000: 
7522: 0000:     FUNCTION WRITE.CONDENSED.PRINT (AP.STORE) EXTERNAL                 ! ECSk
7523: 0000:        INTEGER*2 WRITE.CONDENSED.PRINT
7524: 0000:     END FUNCTION
7525: 0000: 
7526: 0000: 
7527: 0000:     FUNCTION WRITE.PCL.PRINT EXTERNAL                                  ! DSWM
7528: 0000:        INTEGER*2 WRITE.PCL.PRINT                                       ! DSWM
7529: 0000:     END FUNCTION                                                       ! DSWM
7530: 0000: 
7531: 0000: 
7532: 0000:     FUNCTION WRITE.LABEL EXTERNAL
7533: 0000:         INTEGER*2 WRITE.LABEL
7534: 0000:     END FUNCTION
7535: 0000: 
7536: 0000:  %INCLUDE SOPTSEXT.J86                    ! 2.1JAS
7537: 0000: \*******************************************************************************
7538: 0000: \***                                                                         ***
7539: 0000: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE STORE OPTIONS FILE           ***
7540: 0000: \***                                                                         ***
7541: 0000: \***                     REFERENCE : SOPTSEXT.J86                            ***
7542: 0000: \***                                                                         ***
7543: 0000: \***      Version A      Stuart William McConnachie      19th June 1995      ***
7544: 0000: \***                                                                         ***
7545: 0000: \*******************************************************************************
7546: 0000: 
7547: 0000:       FUNCTION SOPTS.SET EXTERNAL
7548: 0000:       END FUNCTION
7549: 0000:       
7550: 0000:       FUNCTION READ.SOPTS EXTERNAL
7551: 0000:          INTEGER*2 READ.SOPTS
7552: 0000:       END FUNCTION
7553: 0000: 
7554: 0000:       FUNCTION WRITE.SOPTS EXTERNAL
7555: 0000:          INTEGER*2 WRITE.SOPTS
7556: 0000:       END FUNCTION
7557: 0000: 
7558: 0000:  %INCLUDE LOCALEXT.J86                    ! 2.1JAS
7559: 0000: \***********************************************************************
7560: 0000: \***********************************************************************
7561: 0000: \***
7562: 0000: \***    DESCRIPTION: Local Price File
7563: 0000: \***                 External File Function Definitions
7564: 0000: \***
7565: 0000: \***    FILE TYPE : Keyed
7566: 0000: \***
7567: 0000: \***********************************************************************
7568: 0000: \***
7569: 0000: \***    Version A.              Paul Flanagan            1st Jul 1993
7570: 0000: \***    Initial version.
7571: 0000: \***
7572: 0000: \***    Version B.              Clive Norris            30th Nov 1993
7573: 0000: \***    Renamed to keep the versions in line.
7574: 0000: \***
7575: 0000: \***    Version C.              Mark Walker             29th Jun 2015
7576: 0000: \***    F392 Retail Stock 5
7577: 0000: \***    Added function WRITE.LOCAL.UNLOCK.HOLD
7578: 0000: \***
7579: 0000: \***********************************************************************
7580: 0000: \***********************************************************************
7581: 0000: 
7582: 0000: FUNCTION LOCAL.SET EXTERNAL
7583: 0000: END FUNCTION
7584: 0000: 
7585: 0000: FUNCTION READ.LOCAL EXTERNAL
7586: 0000:     INTEGER*2 READ.LOCAL
7587: 0000: END FUNCTION
7588: 0000: 
7589: 0000: FUNCTION READ.LOCAL.LOCK EXTERNAL
7590: 0000:     INTEGER*2 READ.LOCAL.LOCK
7591: 0000: END FUNCTION
7592: 0000: 
7593: 0000: FUNCTION WRITE.LOCAL EXTERNAL
7594: 0000:     INTEGER*2 WRITE.LOCAL
7595: 0000: END FUNCTION
7596: 0000: 
7597: 0000: FUNCTION WRITE.LOCAL.UNLOCK EXTERNAL
7598: 0000:     INTEGER*2 WRITE.LOCAL.UNLOCK
7599: 0000: END FUNCTION
7600: 0000: 
7601: 0000: FUNCTION WRITE.LOCAL.UNLOCK.HOLD EXTERNAL                                   !CMW
7602: 0000:     INTEGER*2 WRITE.LOCAL.UNLOCK.HOLD                                       !CMW
7603: 0000: END FUNCTION                                                                !CMW
7604: 0000: 
7605: 0000:  %INCLUDE CCREJEXT.J86                    ! 2.2JAS
7606: 0000: \*******************************************************************************
7607: 0000: \*******************************************************************************
7608: 0000: \***
7609: 0000: \*** RETURNS / AUTOMATIC CREDIT CLAIMING FILE EXTERNAL FILE PUBLIC DEFINITIONS
7610: 0000: \***
7611: 0000: \***                    REFERENCE    : CCREJEXT.BAS
7612: 0000: \***
7613: 0000: \***    Version A.         Julia Stones              12th March 2004
7614: 0000: \***
7615: 0000: \*******************************************************************************
7616: 0000: \*******************************************************************************
7617: 0000: 
7618: 0000: 
7619: 0000:   FUNCTION CCREJ.SET EXTERNAL
7620: 0000:       INTEGER*2 CCREJ.SET
7621: 0000:   END FUNCTION
7622: 0000: 
7623: 0000:   FUNCTION CCREJC.SET EXTERNAL
7624: 0000:       INTEGER*2 CCREJC.SET
7625: 0000:   END FUNCTION
7626: 0000: 
7627: 0000:   FUNCTION CCREJP.SET EXTERNAL
7628: 0000:       INTEGER*2 CCREJP.SET
7629: 0000:   END FUNCTION
7630: 0000: 
7631: 0000:   FUNCTION READ.CCREJ EXTERNAL
7632: 0000:       INTEGER*2 READ.CCREJ
7633: 0000:   END FUNCTION
7634: 0000: 
7635: 0000:   FUNCTION READ.CCREJC EXTERNAL
7636: 0000:       INTEGER*2 READ.CCREJC
7637: 0000:   END FUNCTION
7638: 0000: 
7639: 0000:   FUNCTION READ.CCREJP EXTERNAL
7640: 0000:       INTEGER*2 READ.CCREJP
7641: 0000:   END FUNCTION
7642: 0000: 
7643: 0000:   FUNCTION WRITE.CCREJ EXTERNAL
7644: 0000:       INTEGER*2 WRITE.CCREJ
7645: 0000:   END FUNCTION
7646: 0000: 
7647: 0000:   FUNCTION WRITE.CCREJC EXTERNAL
7648: 0000:       INTEGER*2 WRITE.CCREJC
7649: 0000:   END FUNCTION
7650: 0000: 
7651: 0000:   FUNCTION WRITE.HOLD.CCREJ EXTERNAL
7652: 0000:       INTEGER*2 WRITE.HOLD.CCREJ
7653: 0000:   END FUNCTION
7654: 0000: 
7655: 0000:   FUNCTION WRITE.HOLD.CCREJC EXTERNAL
7656: 0000:       INTEGER*2 WRITE.HOLD.CCREJC
7657: 0000:   END FUNCTION
7658: 0000: 
7659: 0000:  %INCLUDE RBEXT.J86                       ! 2.6BG
7660: 0000: \/******************************************************************/
7661: 0000: \/*                                                                */
7662: 0000: \/* Recalls Buffer FILE EXTERNAL FUNCTION DEFNS                    */
7663: 0000: \/*                                                                */
7664: 0000: \/* REFERENCE   : RBEXT.J86                                        */
7665: 0000: \/*                                                                */
7666: 0000: \/* VERSION A.          Brian Greenield         11th May 2007      */
7667: 0000: \/*                                                                */
7668: 0000: \/******************************************************************/
7669: 0000: 
7670: 0000:    FUNCTION RB.SET EXTERNAL
7671: 0000:       INTEGER*1 RB.SET
7672: 0000:    END FUNCTION
7673: 0000: 
7674: 0000:    FUNCTION READ.RB EXTERNAL
7675: 0000:       INTEGER*2 READ.RB
7676: 0000:    END FUNCTION
7677: 0000: 
7678: 0000:    FUNCTION WRITE.RB EXTERNAL
7679: 0000:       INTEGER*2 WRITE.RB
7680: 0000:    END FUNCTION
7681: 0000: 
7682: 0000: \/******************************************************************/
7683: 0000:  %INCLUDE REWKFEXT.J86                    ! 2.6BG
7684: 0000: \/******************************************************************/
7685: 0000: \/*                                                                */
7686: 0000: \/* Recalls Work FILE EXTERNAL FUNCTION DEFNS                      */
7687: 0000: \/*                                                                */
7688: 0000: \/* REFERENCE   : REWKFEXT.J86                                     */
7689: 0000: \/*                                                                */
7690: 0000: \/* VERSION A.          Brian Greenield         11th May 2007      */
7691: 0000: \/*                                                                */
7692: 0000: \/******************************************************************/
7693: 0000: 
7694: 0000:    FUNCTION REWKF.SET EXTERNAL
7695: 0000:       INTEGER*1 REWKF.SET
7696: 0000:    END FUNCTION
7697: 0000: 
7698: 0000:    FUNCTION READ.REWKF EXTERNAL
7699: 0000:       INTEGER*2 READ.REWKF
7700: 0000:    END FUNCTION
7701: 0000: 
7702: 0000:    FUNCTION WRITE.REWKF EXTERNAL
7703: 0000:       INTEGER*2 WRITE.REWKF
7704: 0000:    END FUNCTION
7705: 0000: 
7706: 0000: \/******************************************************************/
7707: 0000:  %INCLUDE RECALEXT.J86                    ! 2.6BG
7708: 0000: \******************************************************************************
7709: 0000: \******************************************************************************
7710: 0000: \***
7711: 0000: \***                 FUNCTION DEFINITIONS FOR RECALLS.BIN
7712: 0000: \***
7713: 0000: \***                        REFERENCE: RECALFEXT.J86
7714: 0000: \***
7715: 0000: \***    VERSION A               BRIAN GREENFIELD                14th May 2007
7716: 0000: \***    Initial Version
7717: 0000: \***
7718: 0000: \***    Version B               CHARLES SKADORWA                26th June 2007
7719: 0000: \***    Added DELETE.RECALLS function.
7720: 0000: \***
7721: 0000: \*******************************************************************************
7722: 0000: \*******************************************************************************
7723: 0000: 
7724: 0000:    FUNCTION RECALLS.SET EXTERNAL
7725: 0000:       INTEGER*1 RECALLS.SET
7726: 0000:    END FUNCTION
7727: 0000:    
7728: 0000:    FUNCTION WRITE.RECALLS EXTERNAL
7729: 0000:       INTEGER*1 WRITE.RECALLS
7730: 0000:    END FUNCTION
7731: 0000:    
7732: 0000:    FUNCTION READ.RECALLS EXTERNAL
7733: 0000:       INTEGER*1 READ.RECALLS
7734: 0000:    END FUNCTION
7735: 0000:    
7736: 0000:   FUNCTION DELETE.RECALLS (KEY$) EXTERNAL
7737: 0000:       INTEGER*1 DELETE.RECALLS
7738: 0000:    END FUNCTION
7739: 0000:  %INCLUDE DELVIEXT.J86                    ! 2.7SH
7740: 0000: \/******************************************************************/
7741: 0000: \/*                                                                */
7742: 0000: \/* DELVINDX FILE EXTERNAL FUNCTION DEFNS                          */
7743: 0000: \/*                                                                */
7744: 0000: \/* REFERENCE   : DELVIEXT.J86                                     */
7745: 0000: \/*                                                                */
7746: 0000: \/* VERSION A.          Stuart Highley              14 July 2008   */
7747: 0000: \/*                                                                */
7748: 0000: \/******************************************************************/
7749: 0000: 
7750: 0000:    FUNCTION DELVINDX.SET EXTERNAL
7751: 0000:       INTEGER*1 DELVINDX.SET
7752: 0000:    END FUNCTION
7753: 0000: 
7754: 0000:    FUNCTION READ.DELVINDX EXTERNAL
7755: 0000:       INTEGER*2 READ.DELVINDX
7756: 0000:    END FUNCTION
7757: 0000: 
7758: 0000:    FUNCTION WRITE.DELVINDX EXTERNAL
7759: 0000:       INTEGER*2 WRITE.DELVINDX
7760: 0000:    END FUNCTION
7761: 0000: 
7762: 0000: \/******************************************************************/
7763: 0000:  %INCLUDE UODOTEXT.J86                    ! 2.7SH
7764: 0000: \/******************************************************************/
7765: 0000: \/*                                                                */
7766: 0000: \/* UOD Outers FILE EXTERNAL FUNCTION DEFNS                        */
7767: 0000: \/*                                                                */
7768: 0000: \/* REFERENCE   : UODOTEXT.J86                                     */
7769: 0000: \/*                                                                */
7770: 0000: \/* VERSION A.          Stuart Highley              14 July 2008   */
7771: 0000: \/*                                                                
7772: 0000: \/* REVISION 1.8.            ROBERT COWEY.            14 JAN 2009.
7773: 0000: \/* Changes for 10A PosUOD fixes creating SSC04.286 Rv 1.3.
7774: 0000: \/* Defined new function UODOT.REC$.
7775: 0000: \/*
7776: 0000: \/******************************************************************/
7777: 0000: 
7778: 0000:     FUNCTION UODOT.KEY$ EXTERNAL
7779: 0000:         STRING    UODOT.KEY$
7780: 0000:         STRING    WORK$
7781: 0000:     END FUNCTION
7782: 0000: 
7783: 0000:     FUNCTION UODOT.SET EXTERNAL
7784: 0000:         INTEGER*1 UODOT.SET
7785: 0000:     END FUNCTION
7786: 0000: 
7787: 0000:     FUNCTION READ.UODOT EXTERNAL
7788: 0000:         STRING    CHILD.LIST$
7789: 0000:         INTEGER*1 UODOT.INDICAT1%
7790: 0000:         INTEGER*2 UODOT.STATUS%
7791: 0000:         INTEGER*2 READ.UODOT
7792: 0000:         INTEGER*2 I%
7793: 0000:     END FUNCTION
7794: 0000: 
7795: 0000: 
7796: 0000:     FUNCTION READ.UODOT.ON.DESPATCH EXTERNAL
7797: 0000:         STRING TEMP$
7798: 0000:         INTEGER*2 RC%
7799: 0000:         INTEGER*2 READ.UODOT.ON.DESPATCH
7800: 0000:     END FUNCTION
7801: 0000: 
7802: 0000:     FUNCTION READ.UODOT.LOCK EXTERNAL
7803: 0000:         INTEGER*1 UODOT.INDICAT1%
7804: 0000:         INTEGER*2 UODOT.STATUS%
7805: 0000:         INTEGER*2 READ.UODOT.LOCK
7806: 0000:         INTEGER*2 I%
7807: 0000:         STRING    CHILD.LIST$
7808: 0000:     END FUNCTION
7809: 0000: 
7810: 0000:     FUNCTION WRITE.UODOT EXTERNAL
7811: 0000:         INTEGER*1 UODOT.INDICAT1%
7812: 0000:         INTEGER*2 UODOT.STATUS%
7813: 0000:         INTEGER*2 WRITE.UODOT
7814: 0000:         INTEGER*2 I%
7815: 0000:         STRING    CHILD.LIST$
7816: 0000:     END FUNCTION
7817: 0000: 
7818: 0000:     FUNCTION WRITE.UODOT.UNLOCK EXTERNAL
7819: 0000:         INTEGER*1 UODOT.INDICAT1%
7820: 0000:         INTEGER*2 UODOT.STATUS%
7821: 0000:         INTEGER*2 WRITE.UODOT.UNLOCK
7822: 0000:         INTEGER*2 I%
7823: 0000:         STRING    CHILD.LIST$
7824: 0000:     END FUNCTION
7825: 0000: 
7826: 0000: \/******************************************************************/
7827: 0000: 
7828: 0000:     FUNCTION DELETE.UODOT EXTERNAL
7829: 0000:         INTEGER*2 DELETE.UODOT
7830: 0000:     END FUNCTION
7831: 0000: 
7832: 0000: \/******************************************************************/
7833: 0000: 
7834: 0000:     FUNCTION UODOT.REC$ EXTERNAL                                      ! 1.8 RC
7835: 0000:         STRING UODOT.REC$                                             ! 1.8 RC
7836: 0000:     END FUNCTION                                                      ! 1.8 RC
7837: 0000: 
7838: 0000: 
7839: 0000:  %INCLUDE AFEXT.J86                       ! 2.7SH
7840: 0000: 
7841: 0000: \REM
7842: 0000: \*******************************************************************************
7843: 0000: \*******************************************************************************
7844: 0000: \***
7845: 0000: \***    %INCLUDE FOR GSA AUTHORISATION FILE EXTERNAL FUNCTIONS
7846: 0000: \***
7847: 0000: \***        REFERENCE   :  AFEXT (J86)
7848: 0000: \***
7849: 0000: \***        FILE TYPE   :  Keyed
7850: 0000: \***
7851: 0000: \***    The GSA Authorisation File (EALAUTH.DAT) should not be confused with
7852: 0000: \***    the Operating System Authorisation File (ADXCSOUF.DAT).
7853: 0000: \***
7854: 0000: \***    VERSION A.              ROBERT COWEY.                       18 AUG 1992.
7855: 0000: \***    Original version created from AFEXTA.
7856: 0000: \***
7857: 0000: \***    VERSION B.              Steve Windsor                       29 Dec 1992.
7858: 0000: \***    Version incremented to keep in line with other included code           
7859: 0000: \***
7860: 0000: \***    VERSION C.              ROBERT COWEY.                       03 MAR 1994.
7861: 0000: \***    No changes to this file.
7862: 0000: \***
7863: 0000: \***    REVISION 1.6.                ROBERT COWEY.                15 JUN 2009.
7864: 0000: \***    Changes for A9C POS improvements project.
7865: 0000: \***    Used up last available three bytes of EALAUTH user data by redefining 
7866: 0000: \***    remaining AF.USER$ variable as AF.BIRTH.DATE$.
7867: 0000: \***    No changes to this file.
7868: 0000: \***
7869: 0000: \***    REVISION 1.7.                ROBERT COWEY.                22 JUN 2009.
7870: 0000: \***    Changes for A9C POS improvements project creating PSB99.286 Rv 1.8.
7871: 0000: \***    Defect 3247 - Redefined AF.BIRTH.DATE$ format within AFDEC.J86.
7872: 0000: \***    Description text change only - No code changes to this file.
7873: 0000: \***
7874: 0000: \*******************************************************************************
7875: 0000: \*******************************************************************************
7876: 0000: 
7877: 0000: 
7878: 0000: FUNCTION AF.SET EXTERNAL
7879: 0000:     INTEGER*2 AF.SET
7880: 0000: END FUNCTION
7881: 0000: 
7882: 0000: 
7883: 0000: FUNCTION READ.AF EXTERNAL
7884: 0000:     INTEGER*2 READ.AF
7885: 0000: END FUNCTION
7886: 0000: 
7887: 0000: 
7888: 0000: FUNCTION READ.AF.LOCKED EXTERNAL
7889: 0000:     INTEGER*2 READ.AF.LOCKED
7890: 0000: END FUNCTION
7891: 0000: 
7892: 0000:   
7893: 0000: FUNCTION READ.AF.ABREV EXTERNAL
7894: 0000:     INTEGER*2 READ.AF.ABREV
7895: 0000: END FUNCTION
7896: 0000: 
7897: 0000: 
7898: 0000: FUNCTION READ.AF.ABREV.LOCKED EXTERNAL
7899: 0000:     INTEGER*2 READ.AF.ABREV.LOCKED
7900: 0000: END FUNCTION
7901: 0000: 
7902: 0000:   
7903: 0000: FUNCTION WRITE.AF.UNLOCK EXTERNAL
7904: 0000:     INTEGER*2 WRITE.AF.UNLOCK
7905: 0000: END FUNCTION
7906: 0000: 
7907: 0000: 
7908: 0000: FUNCTION WRITE.AF.ABREV EXTERNAL
7909: 0000:     INTEGER*2 WRITE.AF.ABREV
7910: 0000: END FUNCTION
7911: 0000: 
7912: 0000: 
7913: 0000: FUNCTION WRITE.AF.ABREV.UNLOCK EXTERNAL
7914: 0000:     INTEGER*2 WRITE.AF.ABREV.UNLOCK
7915: 0000: END FUNCTION
7916: 0000: 
7917: 0000:  %INCLUDE UBEXT.J86                       ! 2.7SH
7918: 0000: \/******************************************************************/
7919: 0000: \/*                                                                */
7920: 0000: \/* UOD Bookin FILE EXTERNAL FUNCTION DEFNS                        */
7921: 0000: \/*                                                                */
7922: 0000: \/* REFERENCE   : UBEXT.J86                                        */
7923: 0000: \/*                                                                */
7924: 0000: \/* VERSION A.          Stuart Highley            14 August 2008   */
7925: 0000: \/*                                                                */
7926: 0000: \/******************************************************************/
7927: 0000: 
7928: 0000:    FUNCTION UB.SET EXTERNAL
7929: 0000:       INTEGER*1 UB.SET
7930: 0000:    END FUNCTION
7931: 0000: 
7932: 0000:    FUNCTION READ.UB EXTERNAL
7933: 0000:       INTEGER*2 READ.UB
7934: 0000:    END FUNCTION
7935: 0000: 
7936: 0000:    FUNCTION WRITE.UB EXTERNAL
7937: 0000:       INTEGER*2 WRITE.UB
7938: 0000:    END FUNCTION
7939: 0000: 
7940: 0000: \/******************************************************************/
7941: 0000:  
7942: 0000: \*****************************************************************************
7943: 0000: \*****************************************************************************
7944: 0000: \***                                                                       ***
7945: 0000: \*** I N T E R N A L   F U N C T I O N   D E C L A R A T I O N S           ***
7946: 0000: \***                                                                       ***
7947: 0000: \***   - FN.SECONDS                                                        ***
7948: 0000: \***   - FN.Z.PACK                                                         ***
7949: 0000: \***   - FN.VALIDATE.DATA                                                  ***
7950: 0000: \***   - FN.CONV.TO.INTEGER (SIGNED)                                       ***
7951: 0000: \***                                                                       ***
7952: 0000: \*****************************************************************************
7953: 0000: \*****************************************************************************
7954: 0000: 
7955: 0000: \******************************************************************************
7956: 0000: \***
7957: 0000: \***   Function : FN.SECONDS( TIME.VALUE$ )
7958: 0000: \***
7959: 0000: \***   Purpose  : Convert passed TIME in format HHMMSS to seconds
7960: 0000: \***
7961: 0000: \***   Output   : = 4 byte integer
7962: 0000: \***
7963: 0000: \******************************************************************************
7964: 0000: 
7965: 0000:    FUNCTION FN.SECONDS( TIME.VALUE$ )
7966: 0029: 
7967: 0029:       STRING                                                                  \
7968: 0029:          TIME.VALUE$
7969: 0029:       INTEGER*4                                                               \
7970: 0029:          FN.SECONDS
7971: 0029: 
7972: 0029:       FN.SECONDS = VAL(MID$(TIME.VALUE$,1,2)) * 3600 +                        \
7973: 00fb:                    VAL(MID$(TIME.VALUE$,3,2)) * 60 +                          \
7974: 00fb:                    VAL(MID$(TIME.VALUE$,5,2))
7975: 00fb: 
7976: 00fb:    END FUNCTION
7977: 011a: 
7978: 011a: \******************************************************************************
7979: 011a: \***
7980: 011a: \***   Function : FN.Z.PACK( NUM.STRING$, LENGTH% )
7981: 011a: \***
7982: 011a: \***   Purpose  : Zero pack (to the left) NUM.STRING$ out to LENGTH%
7983: 011a: \***
7984: 011a: \******************************************************************************
7985: 011a: 
7986: 011a:    FUNCTION FN.Z.PACK(NUM.STRING$, LENGTH%)
7987: 0143: 
7988: 0143:       STRING                                                                 \
7989: 0143:          FN.Z.PACK,                                                          \
7990: 0143:          NUM.STRING$
7991: 0143:       INTEGER*2                                                              \
7992: 0143:          LENGTH%
7993: 0143: 
7994: 0143:       FN.Z.PACK = RIGHT$(STRING$(LENGTH%,"0")+NUM.STRING$,LENGTH%)
7995: 018c: 
7996: 018c:    END FUNCTION
7997: 01aa: 
7998: 01aa: \******************************************************************************
7999: 01aa: \***
8000: 01aa: \***   Function : FN.VALIDATE.DATA( RECORD$, FORMAT% )
8001: 01aa: \***
8002: 01aa: \***   Purpose  : Test received record RECORD$ is in correct format for
8003: 01aa: \***              data format FORMAT%
8004: 01aa: \***
8005: 01aa: \***   Output   : = 0 if RECORD$ does not conform to data format FORMAT%
8006: 01aa: \***              = 1 if RECORD$ does conform to data format FORMAT%
8007: 01aa: \***
8008: 01aa: \******************************************************************************
8009: 01aa: 
8010: 01aa:    FUNCTION FN.VALIDATE.DATA(RECORD$, FORMAT%)
8011: 01d3: 
8012: 01d3:       STRING                                                                  \
8013: 01d3:          CHECK$,                                                              \
8014: 01d3:          DATA$,                                                               \
8015: 01d3:          RECORD$,                                                             \
8016: 01d3:          TEST$,                                                               \
8017: 01d3:          TYPE$,                                                               \
8018: 01d3:          VALID.FLAG$
8019: 01d3:       INTEGER*1                                                               \
8020: 01d3:          FORMAT%,                                                             \
8021: 01d3:          FN.VALIDATE.DATA
8022: 01d3:       INTEGER*2                                                               \
8023: 01d3:          BYTE.PTR%,                                                           \
8024: 01d3:          CHECK.PTR%,                                                          \
8025: 01d3:          REC.LENGTH%
8026: 01d3: 
8027: 01d3:       REC.LENGTH% = LEN(RECORD$)
8028: 01eb:       IF REC.LENGTH% < 1                                                      \
8029: 0220:       OR FORMAT% < 1 OR FORMAT% > REC.MAX% THEN BEGIN                         \
8030: 0220:          FN.VALIDATE.DATA = 0
8031: 022c:          EXIT FUNCTION
8032: 0237:       ENDIF
8033: 023f: 
8034: 023f:       CHECK$ = REC.CHECK$(FORMAT%)
8035: 026a:       CHECK.PTR% = 1
8036: 0278:       BYTE.PTR% = 1
8037: 0286:       VALID.FLAG$ = "Y"
8038: 029b: 
8039: 029b:       WHILE BYTE.PTR% <= REC.LENGTH%                                          \
8040: 02a6:         AND CHECK.PTR% < LEN(CHECK$)
8041: 02a6: 
8042: 02a6:          TYPE$ = MID$(CHECK$, CHECK.PTR%, 1)
8043: 02ca:          DATA$ = MID$(CHECK$, CHECK.PTR%+1, 1)
8044: 02ef:          CHECK.PTR% = CHECK.PTR% + 2
8045: 02fc: 
8046: 02fc:          IF TYPE$ = "B" THEN BEGIN
8047: 0317:             IF MID$(RECORD$, BYTE.PTR%, 1) <> DATA$ THEN BEGIN
8048: 034d:                VALID.FLAG$ = "N"
8049: 0362:             ENDIF
8050: 036a:             BYTE.PTR% = BYTE.PTR% + 1
8051: 0376:          ENDIF
8052: 037e: 
8053: 037e:          IF TYPE$ = "N" THEN BEGIN
8054: 039c:             WHILE BYTE.PTR% <= REC.LENGTH% AND DATA$ <> CHR$(0)
8055: 03a7:                TEST$ = MID$(RECORD$, BYTE.PTR%, 1)
8056: 03c9:                IF (TEST$ < "0" OR TEST$ > "9")                               \
8057: 0484:               AND TEST$ <> "-" AND TEST$ <> "+"                              \
8058: 0484:               AND TEST$ <> "." THEN VALID.FLAG$ = "N"
8059: 0499:                BYTE.PTR% = BYTE.PTR% + 1
8060: 04a5:                DATA$ = CHR$(ASC(DATA$) - 1)
8061: 04ca:             WEND
8062: 050a:             IF BYTE.PTR% > REC.LENGTH%                                       \
8063: 0547:            AND DATA$ <> CHR$(0) THEN VALID.FLAG$ = "N"
8064: 055c:          ENDIF
8065: 0564: 
8066: 0564:          IF TYPE$ = "A" THEN BYTE.PTR% = BYTE.PTR% + ASC(DATA$)
8067: 0590: 
8068: 0590:       WEND
8069: 05c5: 
8070: 05c5:       IF CHECK.PTR% <= LEN(CHECK$) THEN VALID.FLAG$ = "N"
8071: 05ee: 
8072: 05ee:       IF VALID.FLAG$ = "Y" THEN BEGIN
8073: 0609:          FN.VALIDATE.DATA = 1
8074: 0615:          LAST.ACTIVE.DATE$ = DATE$
8075: 062d:          LAST.ACTIVE% = FN.SECONDS(TIME$)
8076: 0655:       ENDIF ELSE BEGIN
8077: 065d:          FN.VALIDATE.DATA = 0
8078: 0669:       ENDIF
8079: 0671: 
8080: 0671:    END FUNCTION
8081: 068d: 
8082: 068d: \******************************************************************************
8083: 068d: \***
8084: 068d: \***   Function : FN.CONV.TO.INTEGER( NUM.STRING$ )
8085: 068d: \***
8086: 068d: \***   Purpose  : Convert passed string to a 1, 2 or 4 byte (dependant on
8087: 068d: \***              length of passed string) signed integer.
8088: 068d: \***
8089: 068d: \***   Output   : = 1, 2 or 4 byte integer
8090: 068d: \***
8091: 068d: \******************************************************************************
8092: 068d: 
8093: 068d:    FUNCTION FN.CONV.TO.INTEGER( NUM.STRING$ )
8094: 06b6: 
8095: 06b6:       INTEGER*4                                                              \
8096: 06b6:          BYTE%,                                                              \
8097: 06b6:          BYTE.POS%,                                                          \
8098: 06b6:          BYTES%,                                                             \
8099: 06b6:          SIGN.BIT%
8100: 06b6:       REAL                                                                   \
8101: 06b6:          FN.CONV.TO.INTEGER,                                                 \
8102: 06b6:          NUMBER
8103: 06b6:       STRING                                                                 \
8104: 06b6:          NUM.STRING$
8105: 06b6: 
8106: 06b6:       BYTES% = LEN(NUM.STRING$)
8107: 06db:       NUMBER = 0
8108: 06f6:       FOR BYTE.POS% = 1 TO BYTES%
8109: 070e:          BYTE% = ASC(MID$(NUM.STRING$, BYTE.POS%, 1))
8110: 073f:          IF BYTE.POS% = BYTES% THEN BEGIN
8111: 075a:             SIGN.BIT% = BYTE% AND 80h
8112: 0773:             BYTE% = BYTE% AND (SIGN.BIT% XOR 0FFh)
8113: 079f:          ENDIF
8114: 07a7:          NUMBER = NUMBER + (100h ^ (BYTE.POS% - 1)) * BYTE%
8115: 07fd:       NEXT BYTE.POS%
8116: 082a:       IF SIGN.BIT% <> 0 THEN NUMBER = NUMBER - (80h * (100h ^ (BYTES% - 1)))
8117: 0893: 
8118: 0893:       FN.CONV.TO.INTEGER = NUMBER
8119: 08a9: 
8120: 08a9:    END FUNCTION
8121: 08c2: 
8122: 08c2: \******************************************************************************
8123: 08c2: \***
8124: 08c2: \***   Function : FN.ZERO.PL( TEXT$,
8125: 08c2: \***                          LENGTH% )
8126: 08c2: \***
8127: 08c2: \***   Purpose  : Zero pack, to the left, the passed string TEXT$ to the
8128: 08c2: \***              specified length.
8129: 08c2: \***
8130: 08c2: \******************************************************************************
8131: 08c2: 
8132: 08c2:    FUNCTION FN.ZERO.PL(TEXT$,LENGTH%)
8133: 08eb: 
8134: 08eb:       STRING    FN.ZERO.PL, TEXT$
8135: 08eb:       INTEGER*2 LENGTH%
8136: 08eb: 
8137: 08eb:       FN.ZERO.PL = RIGHT$( STRING$( LENGTH%, "0" ) + TEXT$ , LENGTH% )
8138: 0934: 
8139: 0934:    END FUNCTION
8140: 0952: 
8141: 0952: \*****************************************************************************
8142: 0952: \*****************************************************************************
8143: 0952: \***                                                                       ***
8144: 0952: \*** E N D   OF   G L O B A L   D E F N S   F O R   P S S 3 7              ***
8145: 0952: \***                                                                       ***
8146: 0952: \*****************************************************************************
8147: 0952: \*****************************************************************************
8148: 0952: 
8149: 0952: \******************************************************************************
8150: 0952: \***                                                                        ***
8151: 0952: \***   Function : FN.ROUND.DOWN (DATA%)                                     ***
8152: 0952: \***                                                                        ***
8153: 0952: \***   Purpose  : To round real numbers down to their nearest integer       ***
8154: 0952: \***                                                                        ***
8155: 0952: \***   Output   : The new value for the real number                         ***
8156: 0952: \***                                                                        ***
8157: 0952: \******************************************************************************
8158: 0952: 
8159: 0952: \  FUNCTION FN.ROUND.DOWN(DATA%)                                               !1.8NWB
8160: 0952: 
8161: 0952: \    INTEGER*2                                                        \        !1.8NWB
8162: 0952: \      TEMP.INT%                                                               !1.8NWB
8163: 0952: \    REAL                                                             \        !1.8NWB
8164: 0952: \      DATA%,                                                         \        !1.8NWB
8165: 0952: \      FN.ROUND.DOWN                                                           !1.8NWB
8166: 0952: 
8167: 0952: \    TEMP.INT% = DATA%                                                         !1.8NWB
8168: 0952: \    IF TEMP.INT% <> DATA% THEN                                       \        !1.8NWB
8169: 0952: \       IF TEMP.INT% > DATA% THEN                                     \        !1.8NWB
8170: 0952: \        TEMP.INT% = TEMP.INT% - 1                                             !1.8NWB
8171: 0952: \    FN.ROUND.DOWN = TEMP.INT%                                                 !1.8NWB
8172: 0952: 
8173: 0952: \  END FUNCTION                                                                !1.8NWB
8174: 0952: 
8175: 0952:    FUNCTION ADXSTART(NAME$, PARM$, MESS$) EXTERNAL
8176: 0952:       INTEGER*2 ADXSTART
8177: 0952:       STRING    NAME$, PARM$, MESS$
8178: 0952:    END FUNCTION
8179: 0952: 
8180: 0952:    %INCLUDE CHKBFEXT.J86                                    ! HLC
8181: 0952: \*******************************************************************************
8182: 0952: \***                                                                         ***
8183: 0952: \***          EXTERNAL FUNCTION DEFINITIONS FOR THE SITEM FILE               ***
8184: 0952: \***                                                                         ***
8185: 0952: \***                     REFERENCE : CHKBFEXT.J86                            ***
8186: 0952: \***                                                                         ***
8187: 0952: \***          Version A     Andrew Wedgeworth    9th July 1992               ***
8188: 0952: \***                                                                         ***
8189: 0952: \*******************************************************************************
8190: 0952: 
8191: 0952:        FUNCTION CHKBF.SET EXTERNAL                                      
8192: 0952:        END FUNCTION                                                   
8193: 0952: 
8194: 0952: 
8195: 0952:        FUNCTION READ.CHKBF EXTERNAL                                  
8196: 0952:           INTEGER*2 READ.CHKBF                                       
8197: 0952:        END FUNCTION                                                   
8198: 0952:        
8199: 0952:        FUNCTION WRITE.CHKBF EXTERNAL
8200: 0952:           INTEGER*2 WRITE.CHKBF
8201: 0952:        END FUNCTION
8202: 0952:    %INCLUDE GAPBFEXT.J86                                    ! 1.3 !1.5CS !1.7BG
8203: 0952: \*******************************************************************************
8204: 0952: \***                                                                         ***
8205: 0952: \***          EXTERNAL FUNCTION DEFINITIONS FOR THE GAP BUFFER FILE          ***
8206: 0952: \***                                                                         ***
8207: 0952: \***                     REFERENCE : GAPBFEXT.J86                            ***
8208: 0952: \***                                                                         ***
8209: 0952: \***          Version A     Stuart Highley    3rd April 1996                 ***
8210: 0952: \***                                                                         ***
8211: 0952: \*******************************************************************************
8212: 0952: 
8213: 0952:        FUNCTION GAPBF.SET EXTERNAL                                      
8214: 0952:        END FUNCTION                                                   
8215: 0952: 
8216: 0952:        FUNCTION READ.GAPBF EXTERNAL                                  
8217: 0952:           INTEGER*2 READ.GAPBF                                       
8218: 0952:        END FUNCTION                                                   
8219: 0952:        
8220: 0952:        FUNCTION WRITE.GAPBF EXTERNAL
8221: 0952:           INTEGER*2 WRITE.GAPBF
8222: 0952:        END FUNCTION
8223: 0952:    %INCLUDE PLLOLEXT.J86                                    !1.5CS
8224: 0952: 
8225: 0952: \******************************************************************************
8226: 0952: \******************************************************************************
8227: 0952: \***
8228: 0952: \***           FUNCTION DEFINITIONS FOR THE RF PICKING LIST OF LISTS FILE
8229: 0952: \***
8230: 0952: \***           REFERENCE:   PLLOLEXT.J86
8231: 0952: \***
8232: 0952: \***           VERSION A         Julia Stones         11th August 2004
8233: 0952: \***
8234: 0952: \***           VERSION B         Neil Bennett            3rd June 2009
8235: 0952: \***           Added functions for READ.PLLOL.LOCK and WRITE.PLLOL.UNLOCK
8236: 0952: \***
8237: 0952: \*******************************************************************************
8238: 0952: \*******************************************************************************
8239: 0952: 
8240: 0952:    FUNCTION PLLOL.SET EXTERNAL
8241: 0952:    END FUNCTION
8242: 0952: 
8243: 0952:    FUNCTION READ.PLLOL EXTERNAL
8244: 0952:       INTEGER*2 READ.PLLOL
8245: 0952:    END FUNCTION
8246: 0952: 
8247: 0952:    FUNCTION READ.PLLOL.LOCK EXTERNAL                                   ! BNB
8248: 0952:       INTEGER*2 READ.PLLOL.LOCK                                        ! BNB
8249: 0952:    END FUNCTION                                                        ! BNB
8250: 0952: 
8251: 0952:    FUNCTION WRITE.PLLOL EXTERNAL
8252: 0952:       INTEGER*2 WRITE.PLLOL
8253: 0952:    END FUNCTION
8254: 0952: 
8255: 0952:    FUNCTION WRITE.PLLOL.UNLOCK EXTERNAL                                ! BNB
8256: 0952:       INTEGER*2 WRITE.PLLOL.UNLOCK                                     ! BNB
8257: 0952:    END FUNCTION                                                        ! BNB
8258: 0952: 
8259: 0952:    %INCLUDE PLLDBEXT.J86                                    !1.5CS
8260: 0952: 
8261: 0952: \******************************************************************************
8262: 0952: \******************************************************************************
8263: 0952: \***
8264: 0952: \***           FUNCTION DEFINITIONS FOR THE RF PICKING LIST ITEMS IN LISTS FILE
8265: 0952: \***
8266: 0952: \***           REFERENCE:   PLLDBEXT.J86
8267: 0952: \***
8268: 0952: \***           VERSION A         Julia Stones         11th August 2004
8269: 0952: \***
8270: 0952: \***           VERSION B         Charles Skadorwa     15th February 2005
8271: 0952: \***               Added WRITE.BRIEF.PLLDB for Shelf Monitor Project.
8272: 0952: \***
8273: 0952: \***           VERSION C         Neil Bennett              3rd June 2009
8274: 0952: \***               Added functions for lock/unlock/hold.
8275: 0952: \***
8276: 0952: \*******************************************************************************
8277: 0952: \*******************************************************************************
8278: 0952: 
8279: 0952: 
8280: 0952:    FUNCTION PLLDB.SET EXTERNAL
8281: 0952:    END FUNCTION
8282: 0952: 
8283: 0952:    FUNCTION READ.PLLDB EXTERNAL
8284: 0952:       INTEGER*2 READ.PLLDB
8285: 0952:    END FUNCTION
8286: 0952: 
8287: 0952:    FUNCTION READ.PLLDB.LOCK EXTERNAL             ! CNB
8288: 0952:       INTEGER*2 READ.PLLDB.LOCK                  ! CNB
8289: 0952:    END FUNCTION                                  ! CNB
8290: 0952: 
8291: 0952:    FUNCTION WRITE.PLLDB EXTERNAL
8292: 0952:       INTEGER*2 WRITE.PLLDB
8293: 0952:    END FUNCTION
8294: 0952: 
8295: 0952:    FUNCTION WRITE.PLLDB.UNLOCK EXTERNAL          ! CNB
8296: 0952:       INTEGER*2 WRITE.PLLDB.UNLOCK               ! CNB
8297: 0952:    END FUNCTION                                  ! CNB
8298: 0952: 
8299: 0952:    FUNCTION DELREC.PLLDB EXTERNAL
8300: 0952:       INTEGER*2 DELREC.PLLDB
8301: 0952:    END FUNCTION
8302: 0952: 
8303: 0952:    FUNCTION WRITE.BRIEF.PLLDB EXTERNAL           ! BCS
8304: 0952:       INTEGER*2 WRITE.BRIEF.PLLDB                ! BCS
8305: 0952:    END FUNCTION                                  ! BCS
8306: 0952: 
8307: 0952: \  %INCLUDE CIMFEXT.J86                                     ! HLC              !1.8NWB
8308: 0952: \  %INCLUDE CITEMEXT.J86                                    ! HLC              !1.8NWB
8309: 0952: \  %INCLUDE CSRBFEXT.J86                                    ! HLC              !1.8NWB
8310: 0952: \  %INCLUDE CSRWFEXT.J86                                    ! HLC              !1.8NWB
8311: 0952: \  %INCLUDE FPFEXT.J86                                      ! HLC              !1.8NWB
8312: 0952: \  %INCLUDE ONORDEXT.J86                                    ! HLC              !1.8NWB
8313: 0952: \  %INCLUDE IDSOFEXT.J86                                    ! ILC              !1.8NWB
8314: 0952: 
8315: 0952:    SUB PSS3701 PUBLIC
8316: 0976: 
8317: 0976: INTEGER*1                                                   \
8318: 0976:       CURR.SESS.NUM%,                                       \
8319: 0976: \     FLASHPACK%,                                           \                  !1.8NWB
8320: 0976: \     IDF.FOUND%,                                           \1.5CS             !1.8NWB
8321: 0976: \     IMSTC.FOUND%,                                         \1.5CS             !1.8NWB
8322: 0976: \     MASK%,                                                \1.5CS             !1.8NWB
8323: 0976:       OLD.PCHECK.RECORD%,                                   \1.7BG
8324: 0976:       PORT.EVENT%,                                          \
8325: 0976:       SB.EVENT.NO%,                                         \
8326: 0976:       SB.FILE.SESS.NUM%,                                    \
8327: 0976:       SB.INTEGER%,                                          \
8328: 0976:       SMON.NEW.LIST.CREATED,                                \1.5CS
8329: 0976: \     STOCK.FOUND%,                                         \1.5CS             !1.8NWB
8330: 0976:       GAP.RECORD.EXISTS                                    ! 1.4 !1.7BG
8331: 0976: 
8332: 0976: INTEGER*2                                                   \
8333: 0976: \        COUNT1%,                                           \                  !1.8NWB
8334: 0976: \        COUNT2%,                                           \                  !1.8NWB
8335: 0976: \        CURRENT.HEADER.RECORD.NO%,                         \                  !1.8NWB
8336: 0976: \        FP.NUMITEM%,                                       \                  !1.8NWB
8337: 0976: \        I%,                                                \                  !1.8NWB
8338: 0976:          MESSAGE.NO%,                                       \
8339: 0976: \        NUMBER.OF.RECORDS%,                                \                  !1.8NWB
8340: 0976: \        ONORD.SEQ.NO%,                                     \                  !1.8NWB
8341: 0976: \        POSITION%,                                         \                  !1.8NWB
8342: 0976: \        PROMOTIONAL.SA%,                                   \                  !1.8NWB
8343: 0976: \        SECTOR.COUNT%,                                     \                  !1.8NWB
8344: 0976: \        START.TIME%,                                       \ JLC              !1.8NWB
8345: 0976: \        TEMP%,                                             \ NNS              !1.8NWB
8346: 0976:          WS.NEW.LISTID%,                                    \1.5CS
8347: 0976:          WS.SEQ.NO%,                                        \1.5CS
8348: 0976:          X%,                                                \1.5CS
8349: 0976:          Y%,                                                \1.5CS
8350: 0976:          SB.FILE.REP.NUM%                                   ! NNS
8351: 0976: 
8352: 0976: INTEGER*4                                                   \
8353: 0976:          ADX.RET.CODE%                                      !
8354: 0976: \        QTY%                                                                  !1.8NWB
8355: 0976: 
8356: 0976: \REAL                                                       \                  !1.8NWB
8357: 0976: \        ADJUST.PARENT.SALES%,                              \                  !1.8NWB
8358: 0976: \        CSRWF.QTY.1%,                                      \                  !1.8NWB
8359: 0976: \        CSRWF.QTY.2%,                                      \                  !1.8NWB
8360: 0976: \        CSRWF.QTY.2.IN.SINGLES%,                           \                  !1.8NWB
8361: 0976: \        MULTIPLICATION.FACTOR%,                            \                  !1.8NWB
8362: 0976: \        PROMOTIONAL.MF%,                                   \                  !1.8NWB
8363: 0976: \        THEORETICAL.STOCK%,                                \                  !1.8NWB
8364: 0976: \        TOTAL.SA%,                                         \                  !1.8NWB
8365: 0976: \        TOTAL.SALES%,                                      \                  !1.8NWB
8366: 0976: \        COUNT.DISCREPANCY%                                 ! AGEF             !1.8NWB
8367: 0976: 
8368: 0976: STRING                                                      \
8369: 0976: \     ALTER.DATE.OF.COUNT$,                                 \                  !1.8NWB
8370: 0976: \     ALTER.UNIT$,                                          \                  !1.8NWB
8371: 0976:       BOOTS.CODE$,                                          \ 1.5CS
8372: 0976: \     CALC.FAMILY.FIGS$,                                    \                  !1.8NWB
8373: 0976: \     CITEM.RECORD$,                                        \                  !1.8NWB
8374: 0976: \     CITEM.SECTOR.ALTERED$,                                \                  !1.8NWB
8375: 0976:       CURRENT.KEY$,                                         \
8376: 0976:       CURRENT.STOCK$,                                       \ 1.5CS
8377: 0976:       EAN.BARCODE$,                                         \ 1.5CS
8378: 0976: \     END.OF.CITEM$,                                        \                  !1.8NWB
8379: 0976: \     END.OF.CSRBF$,                                        \                  !1.8NWB
8380: 0976: \     END.OF.CSRWF$,                                        \                  !1.8NWB
8381: 0976: \     END.OF.ONORD$,                                        \                  !1.8NWB
8382: 0976: \     END.OF.UNITS$,                                        \                  !1.8NWB
8383: 0976: \     FILLER$,                                              \                  !1.8NWB
8384: 0976: \     FIND.ITEM.ON.IDF$,                                    \                  !1.8NWB
8385: 0976: \     FIND.ITEM.ON.CIMF$,                                   \                  !1.8NWB
8386: 0976: \     FIRST.LINK.FLAG$,                                     \ CPAB             !1.8NWB
8387: 0976: \     HOLD.FLAG$,                                           \                  !1.8NWB
8388: 0976:       ITEM.FOUND.IN.TABLE$,                                 \ !1.5CS
8389: 0976: \     ITEM.FOUND.ON.IDF$,                                   \                  !1.8NWB
8390: 0976: \     ITEM.FOUND.ON.CIMF$,                                  \                  !1.8NWB
8391: 0976: \     ITEM.FOUND.ON.CITEM$,                                 \                  !1.8NWB
8392: 0976: \     ITEM.FOUND.ON.FPF$,                                   \                  !1.8NWB
8393: 0976: \     LOCATION$,                                            \                  !1.8NWB
8394: 0976: \     MANUAL.COUNT$,                                        \ ILC              !1.8NWB
8395: 0976: \     ONORD.MATCH.FOUND$,                                   \                  !1.8NWB
8396: 0976: \     ONORD.RECORD$,                                        \                  !1.8NWB
8397: 0976:       PACKED.BOOTS.CODE$,                                   \ 1.5CS
8398: 0976: \     PARENT.CODE$,                                         \                  !1.8NWB
8399: 0976: \     PART.KEY$,                                            \                  !1.8NWB
8400: 0976: \     PDT.SHELF.ALLOC$,                                     \                  !1.8NWB
8401: 0976: \     PROCESSING.WORKFILE$,                                 \                  !1.8NWB
8402: 0976: \     PROMOTION.DONE$,                                      \                  !1.8NWB
8403: 0976: \     RECORD.TYPE$,                                         \                  !1.8NWB
8404: 0976:       SB.ACTION$,                                           \
8405: 0976:       SB.ERRF$,                                             \
8406: 0976:       SB.ERRL$,                                             \
8407: 0976:       SB.ERRS$,                                             \
8408: 0976:       SB.MESSAGE$,                                          \
8409: 0976:       SB.UNIQUE$,                                           \
8410: 0976:       SB.STRING$,                                           \
8411: 0976:       TEMP.STATE$,                                          \
8412: 0976:       UNIQUE.2$,                                            \
8413: 0976: \     UNITS.RECORD$,                                        \                  !1.8NWB
8414: 0976: \     WS.TOTAL.ESA$,                                        \                  !1.8NWB
8415: 0976: \     WS.TOTAL.ON.ORDER$,                                   \                  !1.8NWB
8416: 0976: \     WS.ON.ORDER.TODAY$,                                   \                  !1.8NWB
8417: 0976: \     WS.ON.ORDER.IN.THIS.PDT$,                             \                  !1.8NWB
8418: 0976: \     WS.DATE.OF.LAST.MANUAL.COUNT$,                        \                  !1.8NWB
8419: 0976: \     WS.SHELF.ALLOCATION$,                                 \                  !1.8NWB
8420: 0976: \     WS.UNIT$,                                             \                  !1.8NWB
8421: 0976: \     WS.LIST.FREQUENCY$,                                   \                  !1.8NWB
8422: 0976: \     WS.SALES.SIGN.FLAG$,                                  \ DPAB             !1.8NWB
8423: 0976: \     WS.COUNT.REQUEST.FLAG$,                               \ AGEF             !1.8NWB
8424: 0976: \     WS.WEEK4.SALES$,                                      \ DPAB             !1.8NWB
8425: 0976:       WS.STRING$                                            ! 1.5CS
8426: 0976: \     WRITE.HOLD.CITEM.CIMF$                                                   !1.8NWB
8427: 0976: 
8428: 0976: \******************************************************************************
8429: 0976: \******************************************************************************
8430: 0976: \***                                                                        ***
8431: 0976: \***   M A I N L I N E   C O D E                                            ***
8432: 0976: \***                                                                        ***
8433: 0976: \******************************************************************************
8434: 0976: \******************************************************************************
8435: 0976: 
8436: 0976: \******************************************************************************
8437: 0976: \***
8438: 0976: \***   for any errors, pass control to ERROR.DETECTED
8439: 0976: \***
8440: 0976: \***   if this module has been called in order to process the workfile
8441: 0976: \***          then do so
8442: 0976: \***
8443: 0976: \***   pass control to the appropriate section of code, depending upon
8444: 0976: \***   the value of RECEIVE.STATE$
8445: 0976: \***
8446: 0976: \***   MODULE.EXIT:
8447: 0976: \***     return to calling module
8448: 0976: \***
8449: 0976: \***   PROGRAM.EXIT:
8450: 0976: \***     stop
8451: 0976: \***
8452: 0976: \******************************************************************************
8453: 0976: 
8454: 0976: ON ERROR GOTO ERROR.DETECTED
8455: 098b: 
8456: 098b: \     LOCATION$ = ""                                                           !1.8NWB
8457: 098b: \     IF PROCESS.CSR.WORKFILE$ = "Y" THEN BEGIN                                !1.8NWB
8458: 098b: \        GOSUB OPEN.FILES.FOR.CSR                                              !1.8NWB
8459: 098b: \      CURR.SESS.NUM% = CSRWF.SESS.NUM%                                        !1.8NWB
8460: 098b: \      IF END #CSRWF.SESS.NUM% THEN OPEN.ERROR                                 !1.8NWB
8461: 098b: \      OPEN CSRWF.FILE.NAME$ DIRECT RECL CSRWF.RECL% AS CSRWF.SESS.NUM%        !1.8NWB
8462: 098b: \      CSRWF.OPEN.FLAG$ = "Y"                                                  !1.8NWB
8463: 098b: \        GOSUB PROCESS.CSR.WORKFILE                                            !1.8NWB
8464: 098b: \      GOSUB RELEASE.PDT                                                       !1.8NWB
8465: 098b: \      WAIT ;20000                                                   ! ZLC     !1.8NWB
8466: 098b: \        IF CSRWF.OPEN.FLAG$ = "Y" THEN BEGIN                        ! BPAB    !1.8NWB
8467: 098b: \         IF END #CSRWF.SESS.NUM% THEN DELETE.ERROR                  ! ASW     !1.8NWB
8468: 098b: \           DELETE CSRWF.SESS.NUM%                                   ! ASW     !1.8NWB
8469: 098b: \           CSRWF.OPEN.FLAG$ = "N"                                   ! ASW     !1.8NWB
8470: 098b: \      ENDIF                                                         ! BPAB    !1.8NWB
8471: 098b: \      GOTO MODULE.EXIT                                                        !1.8NWB
8472: 098b: \     ENDIF                                                                    !1.8NWB
8473: 098b: 
8474: 098b: \     IF MATCH(RECEIVE.STATE$,"MOPQ",1) > 0 THEN BEGIN                         !1.8NWB
8475: 098b:       IF MATCH(RECEIVE.STATE$,"OPQ",1) > 0 THEN BEGIN                          !1.8NWB
8476: 09b1:          ON (ASC(RECEIVE.STATE$) - ASC("N")) GOSUB                   \         !1.8NWB
8477: 09f6: \              RECEIVED.CSR.TABLE.REQUEST,                           \         !1.8NWB
8478: 09f6: \              MODULE.EXIT,                                          \         !1.8NWB
8479: 09f6:                RECEIVED.PCHECK.HEADER,                               \
8480: 09f6:                RECEIVED.PCHECK.RECORD,                               \
8481: 09f6:                RECEIVED.PCHECK.TRAILER
8482: 09f6:        GOTO MODULE.EXIT
8483: 0a00:       ENDIF
8484: 0a08: 
8485: 0a08: \    IF FIRST.EOT.FOR.THIS.PDT$ = "N" THEN BEGIN                               !1.8NWB
8486: 0a08: \       GOSUB RECEIVED.CSR.EOT                                                 !1.8NWB
8487: 0a08: \       GOTO MODULE.EXIT                                                       !1.8NWB
8488: 0a08: \    ENDIF                                                                     !1.8NWB
8489: 0a08: 
8490: 0a08: \     CURR.SESS.NUM% = CSRBF.SESS.NUM%                                         !1.8NWB
8491: 0a08: \     IF END #CSRBF.SESS.NUM% THEN OPEN.ERROR                                  !1.8NWB
8492: 0a08: \     OPEN CSRBF.FILE.NAME$ AS CSRBF.SESS.NUM% NOWRITE NODEL                   !1.8NWB
8493: 0a08: \     CSRBF.OPEN.FLAG$ = "Y"                                                   !1.8NWB
8494: 0a08: \     CURRENT.KEY$ = ""                                                        !1.8NWB
8495: 0a08: \     RC% = READ.CSRBF                                               ! HLC     !1.8NWB
8496: 0a08: \     IF RC% = 1 THEN GOTO READ.ERROR                                ! HLC     !1.8NWB
8497: 0a08: \     END.OF.CSRBF$ = "N"                                                      !1.8NWB
8498: 0a08: \     WHILE END.OF.CSRBF$ = "N"                                                !1.8NWB
8499: 0a08: \        GOSUB DETERMINE.DATA.TYPE                                             !1.8NWB
8500: 0a08: \      IF MATCH(RECEIVE.STATE$,"JKLN",1) > 0 THEN BEGIN                        !1.8NWB
8501: 0a08: \           ON ((ASC(RECEIVE.STATE$)) - ASC("I")) GOSUB              \         !1.8NWB
8502: 0a08: \                 RECEIVED.CSR.LIST.HEADER,                          \         !1.8NWB
8503: 0a08: \                 RECEIVED.CSR.LIST.RECORD,                          \         !1.8NWB
8504: 0a08: \                 RECEIVED.CSR.LIST.TRAILER,                         \         !1.8NWB
8505: 0a08: \                 MODULE.EXIT,                                       \         !1.8NWB
8506: 0a08: \                 RECEIVED.CSR.EOT                                             !1.8NWB
8507: 0a08: \          RC% = READ.CSRBF                                          ! HLC     !1.8NWB
8508: 0a08: \         IF RC% = 1 THEN GOTO END.OF.CSRBF                          ! HLC     !1.8NWB
8509: 0a08: \      END.OF.CSRBF.RETURN:                                                    !1.8NWB
8510: 0a08: \        ENDIF ELSE BEGIN                                                      !1.8NWB
8511: 0a08: \           END.OF.CSRBF$ = "Y"                                                !1.8NWB
8512: 0a08: \        ENDIF                                                                 !1.8NWB
8513: 0a08: \     WEND                                                                     !1.8NWB
8514: 0a08: 
8515: 0a08: !      CSRBF.OPEN.FLAG$ = "N"        ! moved after the delete command  ILC
8516: 0a08: \     IF END #CSRBF.SESS.NUM% THEN DELETE.ERROR                                !1.8NWB
8517: 0a08: \     DELETE CSRBF.SESS.NUM%                                                   !1.8NWB
8518: 0a08: \     CSRBF.OPEN.FLAG$ = "N"                                         ! ILC     !1.8NWB
8519: 0a08: 
8520: 0a08: MODULE.EXIT:
8521: 0a18: 
8522: 0a18: \  PROCESS.CSR.WORKFILE$ = "N"                                                 !1.8NWB
8523: 0a18:    EXIT SUB
8524: 0a23: 
8525: 0a23: PROGRAM.EXIT:
8526: 0a33: 
8527: 0a33:    STOP
8528: 0a40: 
8529: 0a40: \END.OF.CSRBF:                                                                 !1.8NWB
8530: 0a40: \  END.OF.CSRBF$ = "Y"                                                         !1.8NWB
8531: 0a40: \GOTO END.OF.CSRBF.RETURN                                                      !1.8NWB
8532: 0a40: 
8533: 0a40: 
8534: 0a40: \******************************************************************************
8535: 0a40: \******************************************************************************
8536: 0a40: \***                                                                        ***
8537: 0a40: \***   S U B R O U T I N E S                                                ***
8538: 0a40: \***                                                                        ***
8539: 0a40: \******************************************************************************
8540: 0a40: \******************************************************************************
8541: 0a40: 
8542: 0a40: \******************************************************************************
8543: 0a40: \***
8544: 0a40: \***   RECEIVED.CSR.LIST.HEADER:                            STATE : J
8545: 0a40: \***
8546: 0a40: \***      if received data is not valid then set the RECEIVE.STATE$ to "*" and
8547: 0a40: \***      return
8548: 0a40: \***
8549: 0a40: \***      if this is the first CSR list since the logon then
8550: 0a40: \***         gosub OPEN.CSR.FILES
8551: 0a40: \***
8552: 0a40: \***      look for a match for this list on the ON ORDER file
8553: 0a40: \***      ie.  see if this list has already been processed
8554: 0a40: \***
8555: 0a40: \***      if a match is found
8556: 0a40: \***         gosub DUPLICATE.LIST.FOUND
8557: 0a40: \***
8558: 0a40: \***      write a header record to CSRWF
8559: 0a40: \***
8560: 0a40: \***   RETURN
8561: 0a40: \***
8562: 0a40: \******************************************************************************
8563: 0a40: 
8564: 0a40: \  RECEIVED.CSR.LIST.HEADER:                                                   !1.8NWB
8565: 0a40: 
8566: 0a40: \     SB.MESSAGE$ = "PDT Support - CSR Header Unbuffered"                      !1.8NWB
8567: 0a40: \     GOSUB SB.BG.MESSAGE                                                      !1.8NWB
8568: 0a40: 
8569: 0a40: \     IF FN.VALIDATE.DATA(CSRBF.DATA$, 9) = 0 THEN BEGIN                       !1.8NWB
8570: 0a40: \        RECEIVE.STATE$ = "*"                                           ! GDS  !1.8NWB
8571: 0a40: \        RETURN                                                                !1.8NWB
8572: 0a40: \     ENDIF                                                                    !1.8NWB
8573: 0a40: 
8574: 0a40: \     CSR.LIST.ALREADY.PROCESSED.FLAG$ = "N"                                   !1.8NWB
8575: 0a40: 
8576: 0a40: \     IF FIRST.CSR.LIST.FOR.PDT$ = "Y" THEN BEGIN                              !1.8NWB
8577: 0a40: \        GOSUB OPEN.FILES.FOR.CSR                                              !1.8NWB
8578: 0a40: \        CURR.SESS.NUM% = CSRWF.SESS.NUM%                                      !1.8NWB
8579: 0a40: \        IF END #CSRWF.SESS.NUM% THEN CREATE.ERROR                             !1.8NWB
8580: 0a40: \        CREATE CSRWF.FILE.NAME$ DIRECT RECL CSRWF.RECL% AS CSRWF.SESS.NUM%    !1.8NWB
8581: 0a40: \        CSRWF.OPEN.FLAG$ = "Y"                                                !1.8NWB
8582: 0a40: \        PROCESS.CSR.WORKFILE$ = "Y"                                           !1.8NWB
8583: 0a40: \        CSRWF.RECORD.NO% = 1                                                  !1.8NWB
8584: 0a40: \        CURRENT.KEY$ = ""                                                     !1.8NWB
8585: 0a40: \        CSRWF.DELETE.FLAG$ = "Y"                                              !1.8NWB
8586: 0a40: \        RC% = WRITE.CSRWF                                              ! HLC  !1.8NWB
8587: 0a40: \        IF RC% = 1 THEN GOTO WRITE.ERROR                               ! HLC  !1.8NWB
8588: 0a40: \     ENDIF                                                                    !1.8NWB
8589: 0a40: 
8590: 0a40: \     GOSUB LOOK.FOR.MATCH.ON.ONORDER                                          !1.8NWB
8591: 0a40: 
8592: 0a40: \     IF ONORD.MATCH.FOUND$ = "Y" THEN BEGIN                                   !1.8NWB
8593: 0a40: \        GOSUB DUPLICATE.LIST.FOUND                                            !1.8NWB
8594: 0a40: \     ENDIF                                                                    !1.8NWB
8595: 0a40: 
8596: 0a40: \     GOSUB WRITE.WORKFILE.HEADER                                              !1.8NWB
8597: 0a40: 
8598: 0a40: \  RETURN                                                                      !1.8NWB
8599: 0a40: 
8600: 0a40: \******************************************************************************
8601: 0a40: \***
8602: 0a40: \***   RECEIVED.CSR.LIST.RECORD:                            STATE : K
8603: 0a40: \***
8604: 0a40: \***      if this list has been abandoned THEN
8605: 0a40: \***         return
8606: 0a40: \***
8607: 0a40: \***      increment the number of items read from this list
8608: 0a40: \***
8609: 0a40: \***      if this list has already been processed and therefore written
8610: 0a40: \***             to the ONORDER file
8611: 0a40: \***         gosub OUTPUT.CSR.RECORD.FROM.ONORDER
8612: 0a40: \***         return
8613: 0a40: \***
8614: 0a40: \***      if received data is not valid then set the RECEIVE.STATE$ to "*" and
8615: 0a40: \***      return
8616: 0a40: \***
8617: 0a40: \***      note whether or not this is a zero override
8618: 0a40: \***
8619: 0a40: \***      gosub FIND.ITEM.ON.FILES (looks on CITEM, CIMF and IDF)
8620: 0a40: \***
8621: 0a40: \***      find the parent for the family (the item passed should have been the
8622: 0a40: \***      parent, but processing will continue for the family if it wasn't)
8623: 0a40: \***      provided that this is not a non-zero override
8624: 0a40: \***
8625: 0a40: \***      gosub UPDATE.CITEM.AS.REQUIRED
8626: 0a40: \***
8627: 0a40: \***      if this is a manual count (ie. on a manually counted list and
8628: 0a40: \***                this particular item has been counted) then
8629: 0a40: \***         gosub UPDATE.SALES.USING.MANUAL.COUNT
8630: 0a40: \***
8631: 0a40: \***      if item has been found on all files
8632: 0a40: \***         gosub CALC.ORDER.FOR.VALID.ITEM
8633: 0a40: \***      else gosub CALC.ORDER.FOR.INVALID.ITEM
8634: 0a40: \***
8635: 0a40: \***      gosub WRITE.ORDER
8636: 0a40: \***
8637: 0a40: \***   RETURN
8638: 0a40: \***
8639: 0a40: \******************************************************************************
8640: 0a40: 
8641: 0a40: \  RECEIVED.CSR.LIST.RECORD:                                                   !1.8NWB
8642: 0a40: 
8643: 0a40: 
8644: 0a40: \     IF LIST.ABANDONED$ = "Y" THEN RETURN                                     !1.8NWB
8645: 0a40: 
8646: 0a40: \     ALTER.DATE.OF.COUNT$ = "N"                                               !1.8NWB
8647: 0a40: \     ALTER.UNIT$ = "N"                                                        !1.8NWB
8648: 0a40: \     CSR.ITEMS.COUNT% = CSR.ITEMS.COUNT% + 1                                  !1.8NWB
8649: 0a40: 
8650: 0a40: \     IF CSR.LIST.ALREADY.PROCESSED.FLAG$ = "Y" THEN BEGIN                     !1.8NWB
8651: 0a40: \        GOSUB OUTPUT.CSR.RECORD.FROM.ONORDER                                  !1.8NWB
8652: 0a40: \        RETURN                                                                !1.8NWB
8653: 0a40: \     ENDIF                                                                    !1.8NWB
8654: 0a40: 
8655: 0a40: \     IF LEFT$(CSRBF.DATA$,2) = "XU" THEN BEGIN                                !1.8NWB
8656: 0a40: \        RECORD.TYPE$ = "UNCOUNTED"                                            !1.8NWB
8657: 0a40: \        IF FN.VALIDATE.DATA(CSRBF.DATA$, 10) = 0 THEN BEGIN                   !1.8NWB
8658: 0a40: \           RECEIVE.STATE$ = "*"                                        ! GDS  !1.8NWB
8659: 0a40: \           RETURN                                                             !1.8NWB
8660: 0a40: \        ENDIF                                                                 !1.8NWB
8661: 0a40: \     ENDIF                                                                    !1.8NWB
8662: 0a40: 
8663: 0a40: \     IF LEFT$(CSRBF.DATA$,2) = "XM" THEN BEGIN                                !1.8NWB
8664: 0a40: \        RECORD.TYPE$ = "MANUAL"                                               !1.8NWB
8665: 0a40: \        IF FN.VALIDATE.DATA(CSRBF.DATA$, 11) = 0 THEN BEGIN                   !1.8NWB
8666: 0a40: \           RECEIVE.STATE$ = "*"                                        ! GDS  !1.8NWB
8667: 0a40: \           RETURN                                                             !1.8NWB
8668: 0a40: \        ENDIF                                                                 !1.8NWB
8669: 0a40: \     ENDIF                                                                    !1.8NWB
8670: 0a40: 
8671: 0a40: \     IF LEFT$(CSRBF.DATA$,2) = "XO" THEN BEGIN                                !1.8NWB
8672: 0a40: \        RECORD.TYPE$ = "OVERRIDE"                                             !1.8NWB
8673: 0a40: \        IF FN.VALIDATE.DATA(CSRBF.DATA$, 12) = 0 THEN BEGIN                   !1.8NWB
8674: 0a40: \           RECEIVE.STATE$ = "*"                                        ! GDS  !1.8NWB
8675: 0a40: \           RETURN                                                             !1.8NWB
8676: 0a40: \        ENDIF                                                                 !1.8NWB
8677: 0a40: \     ENDIF                                                                    !1.8NWB
8678: 0a40: 
8679: 0a40: \     IF RECORD.TYPE$ = "OVERRIDE" THEN BEGIN                                  !1.8NWB
8680: 0a40: \        IF VAL(MID$(CSRBF.DATA$,10,3)) = 0 THEN BEGIN                         !1.8NWB
8681: 0a40: \           CSRWF.ZERO.OVERRIDE.FLAG$ = "Y"                                    !1.8NWB
8682: 0a40: \        ENDIF ELSE BEGIN                                                      !1.8NWB
8683: 0a40: \           CSRWF.ZERO.OVERRIDE.FLAG$ = "N"                                    !1.8NWB
8684: 0a40: \        ENDIF                                                                 !1.8NWB
8685: 0a40: \     ENDIF                                                                    !1.8NWB
8686: 0a40: 
8687: 0a40: \     FIND.ITEM.ON.IDF$ = "Y"                                                  !1.8NWB
8688: 0a40: \     FIND.ITEM.ON.CIMF$ = "Y"                                                 !1.8NWB
8689: 0a40: \     CITEM.BOOTS.CODE$ = PACK$("0" + MID$(CSRBF.DATA$,3,7))                   !1.8NWB
8690: 0a40: \     PARENT.CODE$ = CITEM.BOOTS.CODE$                                         !1.8NWB
8691: 0a40: \     CIMF.BOOTS.CODE$ = PACK$("00" + MID$(CSRBF.DATA$,3,6))                   !1.8NWB
8692: 0a40: \     IDF.BOOTS.CODE$ = CITEM.BOOTS.CODE$                                      !1.8NWB
8693: 0a40: 
8694: 0a40: \     GOSUB FIND.ITEM.ON.FILES                                                 !1.8NWB
8695: 0a40: 
8696: 0a40: \     IF ITEM.FOUND.ON.IDF$ = "Y" AND ITEM.FOUND.ON.CIMF$ = "Y"         \      !1.8NWB
8697: 0a40: \     AND ITEM.FOUND.ON.CITEM$ = "Y" THEN BEGIN                                !1.8NWB
8698: 0a40: \        IF RECORD.TYPE$ <> "OVERRIDE"                                  \      !1.8NWB
8699: 0a40: \        OR (RECORD.TYPE$ = "OVERRIDE"                                  \      !1.8NWB
8700: 0a40: \        AND CSRWF.ZERO.OVERRIDE.FLAG$ = "Y") THEN BEGIN                       !1.8NWB
8701: 0a40: \           GOSUB GET.PARENT.OF.FAMILY                                         !1.8NWB
8702: 0a40: \        ENDIF                                                                 !1.8NWB
8703: 0a40: \     ENDIF                                                                    !1.8NWB
8704: 0a40: 
8705: 0a40: \     GOSUB MOVE.CITEM.TO.WS                                                   !1.8NWB
8706: 0a40: 
8707: 0a40: \     GOSUB UPDATE.CITEM.AS.REQUIRED                                           !1.8NWB
8708: 0a40: 
8709: 0a40: \     IF ITEM.FOUND.ON.CITEM$ = "Y"                                     \      !1.8NWB
8710: 0a40: \     AND ITEM.FOUND.ON.CIMF$ = "Y" THEN BEGIN                                 !1.8NWB
8711: 0a40: \        IF RECORD.TYPE$ = "MANUAL"                                     \      !1.8NWB
8712: 0a40: \        AND MID$(CSRBF.DATA$,14,6) <> "XXXXXX" THEN BEGIN                     !1.8NWB
8713: 0a40: \           GOSUB UPDATE.SALES.USING.MANUAL.COUNT                              !1.8NWB
8714: 0a40: \        ENDIF                                                                 !1.8NWB
8715: 0a40: \     ENDIF                                                                    !1.8NWB
8716: 0a40: 
8717: 0a40: \     IF ITEM.FOUND.ON.IDF$ = "Y"                                       \      !1.8NWB
8718: 0a40: \     AND ITEM.FOUND.ON.CIMF$ = "Y"                                     \      !1.8NWB
8719: 0a40: \     AND ITEM.FOUND.ON.CITEM$ = "Y" THEN BEGIN                                !1.8NWB
8720: 0a40: \        GOSUB CALC.ORDER.FOR.VALID.ITEM                                       !1.8NWB
8721: 0a40: \     ENDIF ELSE BEGIN                                                         !1.8NWB
8722: 0a40: \        GOSUB CALC.ORDER.FOR.INVALID.ITEM                                     !1.8NWB
8723: 0a40: \     ENDIF                                                                    !1.8NWB
8724: 0a40: 
8725: 0a40: \     GOSUB WRITE.ORDER                                                        !1.8NWB
8726: 0a40: 
8727: 0a40: \  RETURN                                                                      !1.8NWB
8728: 0a40: 
8729: 0a40: \******************************************************************************
8730: 0a40: \***
8731: 0a40: \***   RECEIVED.CSR.LIST.TRAILER:                           STATE : L
8732: 0a40: \***
8733: 0a40: \***      if received data is not valid then set the RECEIVE.STATE$ to "*" and
8734: 0a40: \***      return
8735: 0a40: \***
8736: 0a40: \***      if list has been abandoned then return
8737: 0a40: \***
8738: 0a40: \***      check the record count against the program count - if they do
8739: 0a40: \***      not match then abandon processing of this list
8740: 0a40: \***
8741: 0a40: \***      write a trailer to CSRWF
8742: 0a40: \***
8743: 0a40: \***   RETURN
8744: 0a40: \***
8745: 0a40: \******************************************************************************
8746: 0a40: 
8747: 0a40: \  RECEIVED.CSR.LIST.TRAILER:                                                  !1.8NWB
8748: 0a40: 
8749: 0a40: \     SB.MESSAGE$ = "PDT Support - CSR Trailer Unbuffered"                     !1.8NWB
8750: 0a40: \     GOSUB SB.BG.MESSAGE                                                      !1.8NWB
8751: 0a40: 
8752: 0a40: \     IF FN.VALIDATE.DATA(CSRBF.DATA$, 13) = 0 THEN BEGIN                      !1.8NWB
8753: 0a40: \        RECEIVE.STATE$ = "*"                                           ! GDS  !1.8NWB
8754: 0a40: \        RETURN                                                                !1.8NWB
8755: 0a40: \     ENDIF                                                                    !1.8NWB
8756: 0a40: 
8757: 0a40: \     IF LIST.ABANDONED$ = "Y" THEN BEGIN                                      !1.8NWB
8758: 0a40: \        LIST.ABANDONED$ = "N"                                                 !1.8NWB
8759: 0a40: \        RETURN                                                                !1.8NWB
8760: 0a40: \     ENDIF                                                                    !1.8NWB
8761: 0a40: 
8762: 0a40: \     IF CSR.ITEMS.COUNT% <> VAL(MID$(CSRBF.DATA$,3,3)) THEN BEGIN             !1.8NWB
8763: 0a40: \        GOSUB ABANDON.THIS.LIST                                               !1.8NWB
8764: 0a40: \        RETURN                                                                !1.8NWB
8765: 0a40: \     ENDIF                                                                    !1.8NWB
8766: 0a40: 
8767: 0a40: \     GOSUB WRITE.WORKFILE.TRAILER                                             !1.8NWB
8768: 0a40: 
8769: 0a40: \  RETURN                                                                      !1.8NWB
8770: 0a40: 
8771: 0a40: \******************************************************************************
8772: 0a40: \***
8773: 0a40: \***   RECEIVED.CSR.TABLE.REQUEST:                          STATE : M
8774: 0a40: \***
8775: 0a40: \***      if received data is not valid then set the RECEIVE.STATE$ to "*" and
8776: 0a40: \***      return
8777: 0a40: \***
8778: 0a40: \***      open the UNITS file and write a record (BC letter, unit number)
8779: 0a40: \***      to a table for each unit read (reading directly)
8780: 0a40: \***      close UNITS and sort the table
8781: 0a40: \***      write a record to PSS38 for each record on the table
8782: 0a40: \***      write a trailer to PSS38 containing a count of records sent
8783: 0a40: \***
8784: 0a40: \***   RETURN
8785: 0a40: \***
8786: 0a40: \******************************************************************************
8787: 0a40: 
8788: 0a40: \  RECEIVED.CSR.TABLE.REQUEST:                                                 !1.8NWB
8789: 0a40: 
8790: 0a40: \     SB.MESSAGE$ = "PDT Support - CSR Table request received"                 !1.8NWB
8791: 0a40: \     GOSUB SB.BG.MESSAGE                                                      !1.8NWB
8792: 0a40: 
8793: 0a40: \     IF FN.VALIDATE.DATA(DATA.IN$, 14) = 0 THEN BEGIN                         !1.8NWB
8794: 0a40: \        RECEIVE.STATE$ = "*"                                           ! GDS  !1.8NWB
8795: 0a40: \        RETURN                                                                !1.8NWB
8796: 0a40: \     ENDIF                                                                    !1.8NWB
8797: 0a40: 
8798: 0a40: \     DIM F14.TABLE$(40)                                                       !1.8NWB
8799: 0a40: 
8800: 0a40: \     CURR.SESS.NUM% = UNITS.SESS.NUM%                                         !1.8NWB
8801: 0a40: \     IF END #UNITS.SESS.NUM% THEN OPEN.ERROR                                  !1.8NWB
8802: 0a40: \     OPEN UNITS.FILE.NAME$ DIRECT RECL 512 AS UNITS.SESS.NUM% NOWRITE NODEL   !1.8NWB
8803: 0a40: \     UNITS.OPEN.FLAG$ = "Y"                                                   !1.8NWB
8804: 0a40: 
8805: 0a40: \     END.OF.UNITS$ = "N"                                                      !1.8NWB
8806: 0a40: 
8807: 0a40: \     NUMBER.OF.RECORDS% = 0                                                   !1.8NWB
8808: 0a40: \     SECTOR.COUNT% = 2                                                        !1.8NWB
8809: 0a40: \     CURRENT.KEY$ ="SECTOR"                                                   !1.8NWB
8810: 0a40: \     IF END #UNITS.SESS.NUM% THEN READ.ERROR                                  !1.8NWB
8811: 0a40: \     READ FORM "C4,C508"; #UNITS.SESS.NUM%, SECTOR.COUNT%;             \      !1.8NWB
8812: 0a40: \          FILLER$, UNITS.RECORD$                                              !1.8NWB
8813: 0a40: 
8814: 0a40: \     WHILE END.OF.UNITS$ = "N"                                                !1.8NWB
8815: 0a40: \        POSITION% = 1                                                         !1.8NWB
8816: 0a40: \        WHILE POSITION% < 480 AND NUMBER.OF.RECORDS% < 40 AND          \      !1.8NWB
8817: 0a40: \        MID$(UNITS.RECORD$,POSITION%,4) <> PACK$("00000000")                  !1.8NWB
8818: 0a40: \           NUMBER.OF.RECORDS% = NUMBER.OF.RECORDS% + 1                        !1.8NWB
8819: 0a40: \           F14.TABLE$(NUMBER.OF.RECORDS%) =                            \      !1.8NWB
8820: 0a40: \              MID$(UNITS.RECORD$,POSITION% + 31,1) +                   \      !1.8NWB
8821: 0a40: \              UNPACK$(MID$(UNITS.RECORD$,POSITION%,1))                        !1.8NWB
8822: 0a40: \           POSITION% = POSITION% + 32                                         !1.8NWB
8823: 0a40: \        WEND                                                                  !1.8NWB
8824: 0a40: \        SECTOR.COUNT% = SECTOR.COUNT% + 1                                     !1.8NWB
8825: 0a40: \        CURR.SESS.NUM% = UNITS.SESS.NUM%                                      !1.8NWB
8826: 0a40: \        IF END #UNITS.SESS.NUM% THEN END.OF.UNITS                             !1.8NWB
8827: 0a40: \        READ FORM "C4,C508"; #UNITS.SESS.NUM%, SECTOR.COUNT%;          \      !1.8NWB
8828: 0a40: \           FILLER$,UNITS.RECORD$                                              !1.8NWB
8829: 0a40: \        TABLE.REQUEST.CONTINUE:                                               !1.8NWB
8830: 0a40: \     WEND                                                                     !1.8NWB
8831: 0a40: 
8832: 0a40: \     CLOSE UNITS.SESS.NUM%                                                    !1.8NWB
8833: 0a40: \     UNITS.OPEN.FLAG$ = "N"                                                   !1.8NWB
8834: 0a40: 
8835: 0a40: \     RC% = SORT.TABLE(NUMBER.OF.RECORDS%)                                     !1.8NWB
8836: 0a40: \     IF RC% > 0 THEN GOTO PROGRAM.EXIT                                        !1.8NWB
8837: 0a40: 
8838: 0a40: \     PIPE.OUT$ = "L" + "XS"                                                   !1.8NWB
8839: 0a40: \     FOR I% = 1 TO NUMBER.OF.RECORDS%                                         !1.8NWB
8840: 0a40: \        PIPE.OUT$ = PIPE.OUT$ + F14.TABLE$(I%)                                !1.8NWB
8841: 0a40: \     NEXT I%                                                                  !1.8NWB
8842: 0a40: \     GOSUB SEND.TO.PSS38                                                      !1.8NWB
8843: 0a40: 
8844: 0a40: \     PIPE.OUT$ = "L" + "XZ" + CURR.TERMINAL$ +                         \      !1.8NWB
8845: 0a40: \                 RIGHT$("000" + STR$(NUMBER.OF.RECORDS%),3)                   !1.8NWB
8846: 0a40: \     GOSUB SEND.TO.PSS38                                                      !1.8NWB
8847: 0a40: 
8848: 0a40: \  RETURN                                                                      !1.8NWB
8849: 0a40: 
8850: 0a40: \  END.OF.UNITS:                                                               !1.8NWB
8851: 0a40: \     END.OF.UNITS$ = "Y"                                                      !1.8NWB
8852: 0a40: \  GOTO TABLE.REQUEST.CONTINUE                                                 !1.8NWB
8853: 0a40: 
8854: 0a40: 
8855: 0a40: \******************************************************************************
8856: 0a40: \***
8857: 0a40: \***   RECEIVED.CSR.EOT:                                    STATE : N
8858: 0a40: \***
8859: 0a40: \***      if this is not the first EOT for this list then goto SECOND.EOT
8860: 0a40: \***
8861: 0a40: \***      if received data is not valid then set the RECEIVE.STATE$ to "*" and
8862: 0a40: \***      return
8863: 0a40: \***
8864: 0a40: \***      if the count or terminal number are incorrect then abandon processing
8865: 0a40: \***
8866: 0a40: \***      write an EOT record to CSRWF
8867: 0a40: \***
8868: 0a40: \***      close the CSRWF, release the PDT and send a
8869: 0a40: \***       request to PSS38 to write it out and return
8870: 0a40: \***
8871: 0a40: \***   SECOND.EOT:
8872: 0a40: \***
8873: 0a40: \***      open the CSRWF and change the delete flag on the first record to "N"
8874: 0a40: \***
8875: 0a40: \***      gosub PROCESS.CSR.WORKFILE
8876: 0a40: \***
8877: 0a40: \***      release CSR file
8878: 0a40: \***
8879: 0a40: \***   RETURN
8880: 0a40: \***
8881: 0a40: \******************************************************************************
8882: 0a40: 
8883: 0a40: \  RECEIVED.CSR.EOT:                                                           !1.8NWB
8884: 0a40: 
8885: 0a40: \     IF FIRST.EOT.FOR.THIS.PDT$ = "N" THEN GOTO SECOND.EOT                    !1.8NWB
8886: 0a40: 
8887: 0a40: \     FIRST.EOT.FOR.THIS.PDT$ = "N"                                            !1.8NWB
8888: 0a40: 
8889: 0a40: \     SB.MESSAGE$ = "PDT Support - CSR EOT received"                           !1.8NWB
8890: 0a40: \     GOSUB SB.BG.MESSAGE                                                      !1.8NWB
8891: 0a40: 
8892: 0a40: \     IF FN.VALIDATE.DATA(CSRBF.DATA$, 15) = 0 THEN BEGIN                      !1.8NWB
8893: 0a40: \        RECEIVE.STATE$ = "*"                                           ! GDS  !1.8NWB
8894: 0a40: \        RETURN                                                                !1.8NWB
8895: 0a40: \     ENDIF                                                                    !1.8NWB
8896: 0a40: 
8897: 0a40: \     IF CURR.TERMINAL$ <> MID$(CSRBF.DATA$,3,6)                        \      !1.8NWB
8898: 0a40: \     OR CSRWF.LIST.COUNT$ <> MID$(CSRBF.DATA$,9,3) THEN BEGIN                 !1.8NWB
8899: 0a40: \        SB.EVENT.NO% = 0                                               ! DPAB !1.8NWB
8900: 0a40: \        SB.UNIQUE$ = "ABORT FAIL"                                      ! DPAB !1.8NWB
8901: 0a40: \        GOSUB SB.LOG.AN.EVENT                                          ! DPAB !1.8NWB
8902: 0a40: \        CSR.AUDIT.DATA$ = "[PORT " + MONITORED.PORT$ + "] PDT " +      \ JLC  !1.8NWB
8903: 0a40: \                    "contains corrupt data and will " +                \ JLC  !1.8NWB
8904: 0a40: \                    "require a REBOOT before re-linking."              ! JLC  !1.8NWB
8905: 0a40: \        GOSUB LOG.TO.AUDIT.FILE                                        ! JLC  !1.8NWB
8906: 0a40: \        CSRWF.RECORD.NO% = 1                                                  !1.8NWB
8907: 0a40: \        CSRWF.DELETE.FLAG$ = "Y"                                              !1.8NWB
8908: 0a40: \        CURR.SESS.NUM% = CSRWF.SESS.NUM%                                      !1.8NWB
8909: 0a40: \        RC% = WRITE.CSRWF                                              ! HLC  !1.8NWB
8910: 0a40: \        IF RC% = 1 THEN GOTO WRITE.ERROR                               ! HLC  !1.8NWB
8911: 0a40: \        CSRWF.OPEN.FLAG$ = "N"                                                !1.8NWB
8912: 0a40: \        IF END #CSRWF.SESS.NUM% THEN DELETE.ERROR                             !1.8NWB
8913: 0a40: \        DELETE CSRWF.SESS.NUM%                                                !1.8NWB
8914: 0a40: \        PROCESS.CSR.WORKFILE$ = "N"                                           !1.8NWB
8915: 0a40: \        GOSUB RELEASE.PDT                                                     !1.8NWB
8916: 0a40: \        RECEIVE.STATE$ = "*"                                           ! GDS  !1.8NWB
8917: 0a40: \        RETURN                                                                !1.8NWB
8918: 0a40: \     ENDIF                                                                    !1.8NWB
8919: 0a40: 
8920: 0a40: \     GOSUB WRITE.WORKFILE.EOT                                                 !1.8NWB
8921: 0a40: 
8922: 0a40: \     CSRWF.RECORD.NO% = 1                                                     !1.8NWB
8923: 0a40: \     CURRENT.KEY$ = ""                                                        !1.8NWB
8924: 0a40: \     CURR.SESS.NUM% = CSRWF.SESS.NUM%                                         !1.8NWB
8925: 0a40: \     RC% = READ.CSRWF                                                  ! HLC  !1.8NWB
8926: 0a40: \     IF RC% = 1 THEN GOTO READ.ERROR                                   ! HLC  !1.8NWB
8927: 0a40: \     CSRWF.DELETE.FLAG$ = "N"                                                 !1.8NWB
8928: 0a40: \     RC% = WRITE.CSRWF                                                 ! HLC  !1.8NWB
8929: 0a40: \     IF RC% = 1 THEN GOTO WRITE.ERROR                                  ! HLC  !1.8NWB
8930: 0a40: \     CLOSE CSRWF.SESS.NUM%                                                    !1.8NWB
8931: 0a40: \     CSRWF.OPEN.FLAG$ = "N"                                                   !1.8NWB
8932: 0a40: 
8933: 0a40: ! added next line
8934: 0a40: \     GOSUB PROCESS.CSR.WORKFILE                                        ! ASW  !1.8NWB
8935: 0a40: \     GOSUB RELEASE.PDT                                                        !1.8NWB
8936: 0a40: \     GOSUB TRANSMIT.CSR.FILE.TO.PDT                                           !1.8NWB
8937: 0a40: 
8938: 0a40: \     GOTO END.OF.EOT                                                          !1.8NWB
8939: 0a40: 
8940: 0a40: \  SECOND.EOT:                                                                 !1.8NWB
8941: 0a40: 
8942: 0a40: \     SB.MESSAGE$ = "PDT Support - CSR Data transmitted"                       !1.8NWB
8943: 0a40: \     GOSUB SB.BG.MESSAGE                                                      !1.8NWB
8944: 0a40: 
8945: 0a40: \     LDTAF.LINK.TYPE% = 1                                              ! KMJK !1.8NWB
8946: 0a40: \     IF MONITORED.PORT$ = "B" THEN LDTAF.LINK.TYPE% =                  \ KMJK !1.8NWB
8947: 0a40: \        (LDTAF.LINK.TYPE% OR 80H)                                      ! KMJK !1.8NWB
8948: 0a40: \     LDTAF.START.DATE$ = PACK$(LOG.ON.DATE$)                           ! KMJK !1.8NWB
8949: 0a40: \     LDTAF.START.TIME$ = PACK$(LOG.ON.TIME$)                           ! KMJK !1.8NWB
8950: 0a40: \     TEMP.TIME$ = TIME$                                                ! LMJK !1.8NWB
8951: 0a40: \     LDTAF.DURATION% =                                                 \ LMJK !1.8NWB
8952: 0a40: \        ( (VAL(LEFT$ (TEMP.TIME$,2))*3600) +                           \ LMJK !1.8NWB
8953: 0a40: \          (VAL(MID$  (TEMP.TIME$,3,2))*60) +                           \ LMJK !1.8NWB
8954: 0a40: \          (VAL(RIGHT$(TEMP.TIME$,2))) ) -                              \ LMJK !1.8NWB
8955: 0a40: \        ( (VAL(UNPACK$(LEFT$ (LDTAF.START.TIME$,1)))*3600)+            \ LMJK !1.8NWB
8956: 0a40: \          (VAL(UNPACK$(MID$  (LDTAF.START.TIME$,2,1)))*60)+            \ LMJK !1.8NWB
8957: 0a40: \          (VAL(UNPACK$(RIGHT$(LDTAF.START.TIME$,1)))) )                ! LMJK !1.8NWB
8958: 0a40: \     LDTAF.DATA.VOLUME.1% = 0                                          ! KMJK !1.8NWB
8959: 0a40: \     LDTAF.DATA.VOLUME.1% = SIZE (CSRWF.FILE.NAME$)                    ! KMJK !1.8NWB
8960: 0a40: \     LDTAF.DATA.VOLUME.2% = NUMBER.OF.RECORDS%                         ! KMJK !1.8NWB
8961: 0a40: \     GOSUB LOG.TO.LDTAF.FILE                                           ! KMJK !1.8NWB
8962: 0a40: 
8963: 0a40: \     CLOSE CSR.SESS.NUM%                                                      !1.8NWB
8964: 0a40: \     CSR.OPEN.FLAG$ = "N"                                                     !1.8NWB
8965: 0a40: 
8966: 0a40: \     IF CSRWF.OPEN.FLAG$ = "Y" THEN BEGIN                              ! ILC  !1.8NWB
8967: 0a40: ! WAIT;20000 REMOVED FROM HERE
8968: 0a40: \        IF END #CSRWF.SESS.NUM% THEN DELETE.ERROR                      ! ILC  !1.8NWB
8969: 0a40: \        DELETE CSRWF.SESS.NUM%                                         ! ILC  !1.8NWB
8970: 0a40: \        CSRWF.OPEN.FLAG$ = "N"                                         ! ILC  !1.8NWB
8971: 0a40: \     ENDIF                                                             ! ILC  !1.8NWB
8972: 0a40: 
8973: 0a40: \     RE.CHAIN = TRUE                                                   ! NNS  !1.8NWB
8974: 0a40: \     RECEIVE.STATE$ = "?"                                              ! NNS  !1.8NWB
8975: 0a40: 
8976: 0a40: \  END.OF.EOT:                                                                 !1.8NWB
8977: 0a40: \  RETURN                                                                      !1.8NWB
8978: 0a40: 
8979: 0a40: \******************************************************************************
8980: 0a40: \******************************************************************************
8981: 0a40: \***
8982: 0a40: \***   C S R    S U B R O U T I N E S
8983: 0a40: \***
8984: 0a40: \******************************************************************************
8985: 0a40: \******************************************************************************
8986: 0a40: 
8987: 0a40: \******************************************************************************
8988: 0a40: \***
8989: 0a40: \***   OPEN.FILES.FOR.CSR:
8990: 0a40: \***
8991: 0a40: \***      open any files required for CSR processing
8992: 0a40: \***      and create the CSRWF
8993: 0a40: \***
8994: 0a40: \***   RETURN
8995: 0a40: \***
8996: 0a40: \******************************************************************************
8997: 0a40: 
8998: 0a40: \  OPEN.FILES.FOR.CSR:                                                         !1.8NWB
8999: 0a40: 
9000: 0a40: \     FIRST.CSR.LIST.FOR.PDT$ = "N"                                            !1.8NWB
9001: 0a40: \     CSRWF.LIST.COUNT$ = "000"                                                !1.8NWB
9002: 0a40: 
9003: 0a40: \     CURR.SESS.NUM% = IDF.SESS.NUM%                                           !1.8NWB
9004: 0a40: \     IF END #IDF.SESS.NUM% THEN OPEN.ERROR                                    !1.8NWB
9005: 0a40: \     OPEN IDF.FILE.NAME$ KEYED RECL IDF.RECL% AS IDF.SESS.NUM%          \     !1.8NWB
9006: 0a40: \          NOWRITE NODEL                                                       !1.8NWB
9007: 0a40: \     IDF.OPEN.FLAG$ = "Y"                                                     !1.8NWB
9008: 0a40: 
9009: 0a40: \     CURR.SESS.NUM% = CIMF.SESS.NUM%                                          !1.8NWB
9010: 0a40: \     IF END #CIMF.SESS.NUM% THEN OPEN.ERROR                                   !1.8NWB
9011: 0a40: \     OPEN CIMF.FILE.NAME$ KEYED RECL CIMF.RECL% AS CIMF.SESS.NUM%       \     !1.8NWB
9012: 0a40: \        NODEL                                                                 !1.8NWB
9013: 0a40: \     CIMF.OPEN.FLAG$ = "Y"                                                    !1.8NWB
9014: 0a40: 
9015: 0a40: \     CURR.SESS.NUM% = CITEM.SESS.NUM%                                         !1.8NWB
9016: 0a40: \     IF END #CITEM.SESS.NUM% THEN OPEN.ERROR                                  !1.8NWB
9017: 0a40: \     OPEN CITEM.FILE.NAME$ KEYED RECL CITEM.RECL% AS CITEM.SESS.NUM%    \     !1.8NWB
9018: 0a40: \        NODEL                                                                 !1.8NWB
9019: 0a40: \     CITEM.OPEN.FLAG$ = "Y"                                                   !1.8NWB
9020: 0a40: 
9021: 0a40: \     CURR.SESS.NUM% = ONORD.SESS.NUM%                                         !1.8NWB
9022: 0a40: \     IF END #ONORD.SESS.NUM% THEN OPEN.ERROR                                  !1.8NWB
9023: 0a40: \     OPEN ONORD.FILE.NAME$ KEYED RECL ONORD.RECL% AS ONORD.SESS.NUM%    \     !1.8NWB
9024: 0a40: \          NODEL                                                               !1.8NWB
9025: 0a40: \     ONORD.OPEN.FLAG$ = "Y"                                                   !1.8NWB
9026: 0a40: 
9027: 0a40: \     CURR.SESS.NUM% = FPF.SESS.NUM%                                           !1.8NWB
9028: 0a40: \     IF END #FPF.SESS.NUM% THEN OPEN.ERROR                                    !1.8NWB
9029: 0a40: \     OPEN FPF.FILE.NAME$ KEYED RECL FPF.RECL% AS FPF.SESS.NUM%          \     !1.8NWB
9030: 0a40: \          NODEL                                                               !1.8NWB
9031: 0a40: \     FPF.OPEN.FLAG$ = "Y"                                                     !1.8NWB
9032: 0a40: 
9033: 0a40: \     CURR.SESS.NUM% = IDSOF.SESS.NUM%                                  ! ILC  !1.8NWB
9034: 0a40: \     IF END #IDSOF.SESS.NUM% THEN OPEN.ERROR                           ! ILC  !1.8NWB
9035: 0a40: \     OPEN IDSOF.FILE.NAME$ KEYED RECL IDSOF.RECL% AS IDSOF.SESS.NUM%   \ ILC  !1.8NWB
9036: 0a40: \          NODEL                                                        ! ILC  !1.8NWB
9037: 0a40: \     IDSOF.OPEN.FLAG$ = "Y"                                            ! ILC  !1.8NWB
9038: 0a40: 
9039: 0a40: \     RETURN.FROM.IDSOF.OPEN.ERROR:                                            !1.8NWB
9040: 0a40: 
9041: 0a40: \  RETURN                                                                      !1.8NWB
9042: 0a40: 
9043: 0a40: \******************************************************************************
9044: 0a40: \***
9045: 0a40: \***   LOOK.FOR.MATCH.ON.ONORDER:
9046: 0a40: \***
9047: 0a40: \***      look for a match on order date, list frequency and unit number
9048: 0a40: \***      on ONORD
9049: 0a40: \***
9050: 0a40: \***   RETURN
9051: 0a40: \***
9052: 0a40: \******************************************************************************
9053: 0a40: 
9054: 0a40: \  LOOK.FOR.MATCH.ON.ONORDER:                                                  !1.8NWB
9055: 0a40: 
9056: 0a40: \     CSRWF.HD.ONORDER.UPDATED.FLAG$ = "N"                                     !1.8NWB
9057: 0a40: \     CSRWF.UNPROCESS.FLAG$ = "N"                                              !1.8NWB
9058: 0a40: \     ONORD.ORDER.DATE$ = DATE$                                                !1.8NWB
9059: 0a40: \     ONORD.LIST.FREQ$ = MID$(CSRBF.DATA$,3,1)                                 !1.8NWB
9060: 0a40: \     ONORD.UNIT.NO$ = MID$(CSRBF.DATA$,4,2)                                   !1.8NWB
9061: 0a40: \     ONORD.SEQ.NO$ = "000"                                                    !1.8NWB
9062: 0a40: \     CURRENT.KEY$ = LEFT$(ONORD.ORDER.DATE$ + ONORD.LIST.FREQ$ +       \      !1.8NWB
9063: 0a40: \                 ONORD.UNIT.NO$ + ONORD.SEQ.NO$,8)                            !1.8NWB
9064: 0a40: \     ONORD.MATCH.FOUND$ = "N"                                                 !1.8NWB
9065: 0a40: \     RC% = READ.ONORDER                                                ! HLC  !1.8NWB
9066: 0a40: \     IF RC% = 1 THEN GOTO ONORDER.MATCH.CONTINUE                       ! HLC  !1.8NWB
9067: 0a40: \     ONORD.MATCH.FOUND$ = "Y"                                                 !1.8NWB
9068: 0a40: 
9069: 0a40: \  ONORDER.MATCH.CONTINUE:                                                     !1.8NWB
9070: 0a40: 
9071: 0a40: \  RETURN                                                                      !1.8NWB
9072: 0a40: 
9073: 0a40: \******************************************************************************
9074: 0a40: \***
9075: 0a40: \***   DUPLICATE.LIST.FOUND:
9076: 0a40: \***
9077: 0a40: \***      If the list for which a duplicate has been found is a non-override
9078: 0a40: \***        set flags to indicate that this list is already processed, else
9079: 0a40: \***        if this is an override list, set a flag to indicate that the
9080: 0a40: \***        original list of this number needs "unprocessing"
9081: 0a40: \***
9082: 0a40: \***   RETURN
9083: 0a40: \***
9084: 0a40: \******************************************************************************
9085: 0a40: 
9086: 0a40: \  DUPLICATE.LIST.FOUND:                                                       !1.8NWB
9087: 0a40: 
9088: 0a40: \     IF VAL(ONORD.UNIT.NO$) < 50 THEN BEGIN                                   !1.8NWB
9089: 0a40: \      CSR.LIST.ALREADY.PROCESSED.FLAG$ = "Y"                                  !1.8NWB
9090: 0a40: \      CSRWF.HD.ONORDER.UPDATED.FLAG$ = "Y"                                    !1.8NWB
9091: 0a40: \      ENDIF ELSE BEGIN                                                        !1.8NWB
9092: 0a40: \      CSRWF.UNPROCESS.FLAG$ = "Y"                                             !1.8NWB
9093: 0a40: \      ENDIF                                                                   !1.8NWB
9094: 0a40: 
9095: 0a40: \  RETURN                                                                      !1.8NWB
9096: 0a40: 
9097: 0a40: \******************************************************************************
9098: 0a40: \***
9099: 0a40: \***   WRITE.WORKFILE.HEADER:
9100: 0a40: \***
9101: 0a40: \***   RETURN
9102: 0a40: \***
9103: 0a40: \******************************************************************************
9104: 0a40: 
9105: 0a40: \  WRITE.WORKFILE.HEADER:                                                      !1.8NWB
9106: 0a40: 
9107: 0a40: \     CSRWF.RECORD.TYPE$ = "XH"                                                !1.8NWB
9108: 0a40: \     CSR.ITEMS.COUNT% = 0                                                     !1.8NWB
9109: 0a40: \     CSRWF.LIST.COUNT$ = RIGHT$("000" + STR$(VAL(CSRWF.LIST.COUNT$) + 1),3)   !1.8NWB
9110: 0a40: \     CSRWF.RECORD.NO% = CSRWF.RECORD.NO% + 1                                  !1.8NWB
9111: 0a40: \     CURRENT.HEADER.RECORD.NO% = CSRWF.RECORD.NO%                             !1.8NWB
9112: 0a40: \     CSRWF.LIST.FREQ$ = ONORD.LIST.FREQ$                                      !1.8NWB
9113: 0a40: \     CSRWF.UNIT.NO$ = ONORD.UNIT.NO$                                          !1.8NWB
9114: 0a40: \     CSRWF.ORDER.DATE$ = DATE$                                                !1.8NWB
9115: 0a40: \     CSRWF.ORDER.TIME$ = LEFT$(TIME$,4)                                       !1.8NWB
9116: 0a40: \     CURRENT.KEY$ = ""                                                        !1.8NWB
9117: 0a40: \     CURR.SESS.NUM% = CSRWF.SESS.NUM%                                         !1.8NWB
9118: 0a40: \     RC% = WRITE.CSRWF                                                 ! HLC  !1.8NWB
9119: 0a40: \     IF RC% = 1 THEN GOTO WRITE.ERROR                                  ! HLC  !1.8NWB
9120: 0a40: 
9121: 0a40: \  RETURN                                                                      !1.8NWB
9122: 0a40: 
9123: 0a40: \******************************************************************************
9124: 0a40: \***
9125: 0a40: \***   WRITE.WORKFILE.TRAILER:
9126: 0a40: \***
9127: 0a40: \***   RETURN
9128: 0a40: \***
9129: 0a40: \******************************************************************************
9130: 0a40: 
9131: 0a40: \  WRITE.WORKFILE.TRAILER:                                                     !1.8NWB
9132: 0a40: 
9133: 0a40: \     CSRWF.RECORD.TYPE$ = "XT"                                                !1.8NWB
9134: 0a40: \     CSRWF.ITEM.COUNT$ = RIGHT$("000" + STR$(CSR.ITEMS.COUNT%),3)             !1.8NWB
9135: 0a40: \     CSRWF.RECORD.NO% = CSRWF.RECORD.NO% + 1                                  !1.8NWB
9136: 0a40: \     CURRENT.KEY$ = ""                                                        !1.8NWB
9137: 0a40: \     CURR.SESS.NUM% = CSRWF.SESS.NUM%                                         !1.8NWB
9138: 0a40: \     RC% = WRITE.CSRWF                                                 ! HLC  !1.8NWB
9139: 0a40: \     IF RC% = 1 THEN GOTO WRITE.ERROR                                  ! HLC  !1.8NWB
9140: 0a40: 
9141: 0a40: \  RETURN                                                                      !1.8NWB
9142: 0a40: 
9143: 0a40: \******************************************************************************
9144: 0a40: \***
9145: 0a40: \***   WRITE.WORKFILE.EOT:
9146: 0a40: \***
9147: 0a40: \***   RETURN
9148: 0a40: \***
9149: 0a40: \******************************************************************************
9150: 0a40: 
9151: 0a40: \  WRITE.WORKFILE.EOT:                                                         !1.8NWB
9152: 0a40: 
9153: 0a40: \     CSRWF.RECORD.TYPE$ = "XZ"                                                !1.8NWB
9154: 0a40: \     CSRWF.TERMINAL.NO$ = CURR.TERMINAL$                                      !1.8NWB
9155: 0a40: \     CSRWF.RECORD.NO% = CSRWF.RECORD.NO% + 1                                  !1.8NWB
9156: 0a40: \     CURRENT.KEY$ = ""                                                        !1.8NWB
9157: 0a40: \     CURR.SESS.NUM% = CSRWF.SESS.NUM%                                         !1.8NWB
9158: 0a40: \     RC% = WRITE.CSRWF                                                 ! HLC  !1.8NWB
9159: 0a40: \     IF RC% = 1 THEN GOTO WRITE.ERROR                                  ! HLC  !1.8NWB
9160: 0a40: \  RETURN                                                                      !1.8NWB
9161: 0a40: 
9162: 0a40: \******************************************************************************
9163: 0a40: \***
9164: 0a40: \***   OUTPUT.CSR.RECORD.FROM.ONORDER:
9165: 0a40: \***
9166: 0a40: \***      for a list which has already been processed, the data for the
9167: 0a40: \***      workfile CSRWF will be taken from a record on ONORDER rather
9168: 0a40: \***      than from the data coming in from the PDT.
9169: 0a40: \***      If the data from ONORD differs from that from the PDT (ie. not
9170: 0a40: \***      the same Boots code) or the number of records for this list on
9171: 0a40: \***      ONORD does not match that from the PDT then the entire list
9172: 0a40: \***      will be abandoned.
9173: 0a40: \***
9174: 0a40: \***   RETURN
9175: 0a40: \***
9176: 0a40: \******************************************************************************
9177: 0a40: 
9178: 0a40: \  OUTPUT.CSR.RECORD.FROM.ONORDER:                                             !1.8NWB
9179: 0a40: 
9180: 0a40: \     ONORD.SEQ.NO$ = RIGHT$("000" + STR$(VAL(ONORD.SEQ.NO$) + 1),3)           !1.8NWB
9181: 0a40: \     IF ONORD.SEQ.NO$ > ONORD.HIGHEST.SEQ.NO$ THEN BEGIN                      !1.8NWB
9182: 0a40: \        GOSUB ABANDON.THIS.LIST                                               !1.8NWB
9183: 0a40: \     ENDIF                                                                    !1.8NWB
9184: 0a40: 
9185: 0a40: \     CURR.SESS.NUM% = ONORD.SESS.NUM%                                         !1.8NWB
9186: 0a40: \     CURRENT.KEY$ = ONORD.ORDER.DATE$ + ONORD.LIST.FREQ$ +             \      !1.8NWB
9187: 0a40: \                    ONORD.UNIT.NO$ + ONORD.SEQ.NO$                            !1.8NWB
9188: 0a40: \     RC% = READ.ONORDER                                                ! HLC  !1.8NWB
9189: 0a40: \     IF RC% = 1 THEN GOTO NOT.ON.ONORD                                 ! HLC  !1.8NWB
9190: 0a40: \     CSRWF.RECORD.TYPE$ = "XC"                                                !1.8NWB
9191: 0a40: \     CSRWF.QTY.1$ = ONORD.QTY.1$                                              !1.8NWB
9192: 0a40: \     CSRWF.QTY.2$ = ONORD.QTY.2$                                              !1.8NWB
9193: 0a40: \     CSRWF.P.ITEM.CODE$ = PACK$("0" + ONORD.ITEM.CODE$)                       !1.8NWB
9194: 0a40: \     CSRWF.QTY.2.IN.SINGLES$ = "000"                                          !1.8NWB
9195: 0a40: \     CSRWF.CSRITEM.UPDATED.FLAG$ = "Y"                                        !1.8NWB
9196: 0a40: \     CSRWF.CSRIMF.UPDATED.FLAG$ = "Y"                                         !1.8NWB
9197: 0a40: \     CSRWF.ONORDER.UPDATED.FLAG$ = "Y"                                        !1.8NWB
9198: 0a40: \     CURR.SESS.NUM% = CSRWF.SESS.NUM%                                         !1.8NWB
9199: 0a40: \     CURRENT.KEY$ = ""                                                        !1.8NWB
9200: 0a40: \     CSRWF.RECORD.NO% = CSRWF.RECORD.NO% + 1                                  !1.8NWB
9201: 0a40: \     RC% = WRITE.CSRWF                                                 ! HLC  !1.8NWB
9202: 0a40: \     IF RC% = 1 THEN GOTO WRITE.ERROR                                  ! HLC  !1.8NWB
9203: 0a40: 
9204: 0a40: \  NOT.ON.ONORD.RETURN:                                                        !1.8NWB
9205: 0a40: \  RETURN                                                                      !1.8NWB
9206: 0a40: 
9207: 0a40: \  NOT.ON.ONORD:                                                               !1.8NWB
9208: 0a40: \     GOSUB ABANDON.THIS.LIST                                                  !1.8NWB
9209: 0a40: \  GOTO NOT.ON.ONORD.RETURN                                                    !1.8NWB
9210: 0a40: 
9211: 0a40: \******************************************************************************
9212: 0a40: \***
9213: 0a40: \***   FIND.ITEM.ON.FILES:
9214: 0a40: \***
9215: 0a40: \***      look for the item in question on the CITEM, CIMF and IDF
9216: 0a40: \***      (if not found on any one of these, a proper order quantity
9217: 0a40: \***       cannot be calculated : zero will be ordered unless the order
9218: 0a40: \***       was a non-zero override, in which case the amount requested
9219: 0a40: \***       will be ordered.)
9220: 0a40: \***
9221: 0a40: \***   RETURN
9222: 0a40: \***
9223: 0a40: \******************************************************************************
9224: 0a40: 
9225: 0a40: \  FIND.ITEM.ON.FILES:                                                         !1.8NWB
9226: 0a40: 
9227: 0a40: \     ITEM.FOUND.ON.CITEM$ = "N"                                               !1.8NWB
9228: 0a40: \     ITEM.FOUND.ON.CIMF$ = "N"                                                !1.8NWB
9229: 0a40: \     ITEM.FOUND.ON.IDF$ = "N"                                                 !1.8NWB
9230: 0a40: \     LOCATION$ = "FINDITEM"                                                   !1.8NWB
9231: 0a40: 
9232: 0a40: \     CURR.SESS.NUM% = CITEM.SESS.NUM%                                         !1.8NWB
9233: 0a40: \     CURRENT.KEY$ = CITEM.BOOTS.CODE$                                         !1.8NWB
9234: 0a40: \     RC% = READ.CITEM                                          ! HLC          !1.8NWB
9235: 0a40: \     IF RC% = 1 THEN GOTO READ.ERROR                              ! HLC       !1.8NWB
9236: 0a40: \     ITEM.FOUND.ON.CITEM$ = "Y"                                               !1.8NWB
9237: 0a40: 
9238: 0a40: \     FIRST.LINK.FLAG$ = "N"                                    ! CPAB         !1.8NWB
9239: 0a40: \     IF CITEM.SHELF.ALLOCATION$ = PACK$("????") THEN BEGIN            ! CPAB  !1.8NWB
9240: 0a40: \        FIRST.LINK.FLAG$ = "Y"                                    ! CPAB      !1.8NWB
9241: 0a40: \     ENDIF                                                 ! CPAB             !1.8NWB
9242: 0a40: 
9243: 0a40: \     IF FIND.ITEM.ON.CIMF$ = "Y" THEN BEGIN                                   !1.8NWB
9244: 0a40: \        CURRENT.KEY$ = CIMF.BOOTS.CODE$                                       !1.8NWB
9245: 0a40: \        CURR.SESS.NUM% = CIMF.SESS.NUM%                                       !1.8NWB
9246: 0a40: \        RC% = READ.CIMF                                    ! HLC              !1.8NWB
9247: 0a40: \        IF RC% = 1 THEN GOTO READ.ERROR                        ! HLC          !1.8NWB
9248: 0a40: \      ADJUST.PARENT.SALES% = 0                                                !1.8NWB
9249: 0a40: \        ITEM.FOUND.ON.CIMF$ = "Y"                                             !1.8NWB
9250: 0a40: \     ENDIF                                                                    !1.8NWB
9251: 0a40: 
9252: 0a40: \     IF FIND.ITEM.ON.IDF$ = "Y" THEN BEGIN                                    !1.8NWB
9253: 0a40: \        CURRENT.KEY$ = IDF.BOOTS.CODE$                                        !1.8NWB
9254: 0a40: \        CURR.SESS.NUM% = IDF.SESS.NUM%                                        !1.8NWB
9255: 0a40: \        RC% = READ.IDF                                          ! HLC         !1.8NWB
9256: 0a40: \        IF RC% = 1 THEN GOTO READ.ERROR                        ! HLC          !1.8NWB
9257: 0a40: \        ITEM.FOUND.ON.IDF$ = "Y"                                              !1.8NWB
9258: 0a40: \     ENDIF                                                                    !1.8NWB
9259: 0a40: 
9260: 0a40: \  FIND.ITEM.ON.FILES.CONTINUE:                                                !1.8NWB
9261: 0a40: \     LOCATION$ = ""                                                           !1.8NWB
9262: 0a40: 
9263: 0a40: \  RETURN                                                                      !1.8NWB
9264: 0a40: 
9265: 0a40: \******************************************************************************
9266: 0a40: \***
9267: 0a40: \***   CALC.ORDER.FOR.INVALID.ITEM:
9268: 0a40: \***
9269: 0a40: \***      if a proper order quantity cannot be calculated
9270: 0a40: \***      zero will be ordered unless the order
9271: 0a40: \***      was a non-zero override, in which case the amount requested
9272: 0a40: \***      will be ordered.
9273: 0a40: \***
9274: 0a40: \***   RETURN
9275: 0a40: \***
9276: 0a40: \******************************************************************************
9277: 0a40: 
9278: 0a40: \  CALC.ORDER.FOR.INVALID.ITEM:                                                !1.8NWB
9279: 0a40: 
9280: 0a40: \     CSRWF.ONORDER.UPDATED.FLAG$ = "N"                                        !1.8NWB
9281: 0a40: \     CSRWF.CSRIMF.UPDATED.FLAG$ = "Y"                                         !1.8NWB
9282: 0a40: \     CSRWF.CSRITEM.UPDATED.FLAG$ = "Y"                                        !1.8NWB
9283: 0a40: 
9284: 0a40: \     IF RECORD.TYPE$ = "UNCOUNTED"                              \             !1.8NWB
9285: 0a40: \     OR RECORD.TYPE$ = "MANUAL" THEN BEGIN                                    !1.8NWB
9286: 0a40: \        CSRWF.P.ITEM.CODE$ = PACK$("0" + MID$(CSRBF.DATA$,3,7))               !1.8NWB
9287: 0a40: \        CSRWF.QTY.1$ = "000"                                                  !1.8NWB
9288: 0a40: \        CSRWF.QTY.2$ = "000"                                                  !1.8NWB
9289: 0a40: \        CSRWF.QTY.2.IN.SINGLES$ = "000"                                       !1.8NWB
9290: 0a40: \     ENDIF ELSE BEGIN                                                         !1.8NWB
9291: 0a40: \        CSRWF.ITEM.CODE$ = MID$(CSRBF.DATA$,3,7)                              !1.8NWB
9292: 0a40: \        CSRWF.QTY.1$ = MID$(CSRBF.DATA$,10,3)                                 !1.8NWB
9293: 0a40: \        CSRWF.QTY.2$ = "000"                                                  !1.8NWB
9294: 0a40: \        CSRWF.QTY.2.IN.SINGLES$ = "000"                                       !1.8NWB
9295: 0a40: \        CSRWF.QTY.2.IN.SINGLES% = 0                                           !1.8NWB
9296: 0a40: \     ENDIF                                                                    !1.8NWB
9297: 0a40: 
9298: 0a40: \  RETURN                                                                      !1.8NWB
9299: 0a40: 
9300: 0a40: \******************************************************************************
9301: 0a40: \***
9302: 0a40: \***   UPDATE.CITEM.AS.REQUIRED:
9303: 0a40: \***
9304: 0a40: \***      if this is a parent item with SA <> high-values and SA not
9305: 0a40: \***         equal to that just received from the PDT then
9306: 0a40: \***         update the SA and the sales
9307: 0a40: \***
9308: 0a40: \***      if the unit number for this item does not equal that of the list
9309: 0a40: \***        received from the PDT then update the unit number
9310: 0a40: \***
9311: 0a40: \***
9312: 0a40: \***   RETURN
9313: 0a40: \***
9314: 0a40: \******************************************************************************
9315: 0a40: 
9316: 0a40: \  UPDATE.CITEM.AS.REQUIRED:                                                   !1.8NWB
9317: 0a40: 
9318: 0a40: \     WRITE.HOLD.CITEM.CIMF$ = "N"                                             !1.8NWB
9319: 0a40: \     PDT.SHELF.ALLOC$ = PACK$("0" + MID$(CSRBF.DATA$,10,3))                   !1.8NWB
9320: 0a40: \     IF ITEM.FOUND.ON.CIMF$ = "Y"                              \              !1.8NWB
9321: 0a40: \     AND ITEM.FOUND.ON.CITEM$ = "Y" THEN BEGIN                                !1.8NWB
9322: 0a40: \        IF LEFT$(CSRBF.DATA$,2) <> "XO"                        \              !1.8NWB
9323: 0a40: \        AND WS.SHELF.ALLOCATION$ <> PDT.SHELF.ALLOC$ THEN BEGIN               !1.8NWB
9324: 0a40: \           GOSUB CHECK.FOR.CHANGE.OF.SALES                                    !1.8NWB
9325: 0a40: \           GOSUB CHECK.FOR.ALLOCATED.STOCK                     ! ILC          !1.8NWB
9326: 0a40: \           WS.SHELF.ALLOCATION$ = PDT.SHELF.ALLOC$                            !1.8NWB
9327: 0a40: \        ENDIF                                                                 !1.8NWB
9328: 0a40: \     ENDIF                                                                    !1.8NWB
9329: 0a40: 
9330: 0a40: \     IF ITEM.FOUND.ON.CITEM$ = "Y"                             \              !1.8NWB
9331: 0a40: \     AND RECORD.TYPE$ <> "OVERRIDE" THEN BEGIN                                !1.8NWB
9332: 0a40: \        IF WS.UNIT$ <> PACK$(CSRWF.UNIT.NO$)                   \              !1.8NWB
9333: 0a40: \        OR WS.LIST.FREQUENCY$ <> PACK$("0" + CSRWF.LIST.FREQ$) THEN BEGIN     !1.8NWB
9334: 0a40: \           ALTER.UNIT$ = "Y"                                                  !1.8NWB
9335: 0a40: \           WS.UNIT$ = PACK$(CSRWF.UNIT.NO$)                                   !1.8NWB
9336: 0a40: \           WS.LIST.FREQUENCY$ = PACK$("0" + CSRWF.LIST.FREQ$)                 !1.8NWB
9337: 0a40: \        ENDIF                                                                 !1.8NWB
9338: 0a40: \     ENDIF                                                                    !1.8NWB
9339: 0a40: 
9340: 0a40: 
9341: 0a40: \  RETURN                                                                      !1.8NWB
9342: 0a40: 
9343: 0a40: \******************************************************************************
9344: 0a40: \***
9345: 0a40: \***   CHECK.FOR.CHANGE.OF.SALES:
9346: 0a40: \***
9347: 0a40: \***   if the shelf allocation has changed value (but not from
9348: 0a40: \***   high values) then it will be necessary to alter the sales
9349: 0a40: \***   figure by the same amount
9350: 0a40: \***
9351: 0a40: \***   RETURN
9352: 0a40: \***
9353: 0a40: \******************************************************************************
9354: 0a40: 
9355: 0a40: \  CHECK.FOR.CHANGE.OF.SALES:                                                  !1.8NWB
9356: 0a40: 
9357: 0a40: \     IF WS.SHELF.ALLOCATION$ = PACK$("????") THEN BEGIN                ! GDS  !1.8NWB
9358: 0a40: \        WS.SHELF.ALLOCATION$ = PACK$("0000")                           ! GDS  !1.8NWB
9359: 0a40: \        WS.COUNT.REQUEST.FLAG$ = "Y"                                   ! GDS  !1.8NWB
9360: 0a40: \     ENDIF                                                                    !1.8NWB
9361: 0a40: 
9362: 0a40: \     ADJUST.PARENT.SALES% = VAL(UNPACK$(PDT.SHELF.ALLOC$)) -           \ GDS  !1.8NWB
9363: 0a40: \                            VAL(UNPACK$(WS.SHELF.ALLOCATION$))         ! GDS  !1.8NWB
9364: 0a40: \     WRITE.HOLD.CITEM.CIMF$ = "Y"                                      ! GDS  !1.8NWB
9365: 0a40: 
9366: 0a40: \  RETURN                                                                      !1.8NWB
9367: 0a40: 
9368: 0a40: \*****************************************************************************
9369: 0a40: \***
9370: 0a40: \***    CHECK.FOR.ALLOCATED.STOCK:
9371: 0a40: \***
9372: 0a40: \***          read IDSOF using CITEM boots code as key
9373: 0a40: \***
9374: 0a40: \***          If a record was found then subtract IDSOF outstanding quantity
9375: 0a40: \***          from ADJUST.PARENT.SALES and delete IDSOF record.
9376: 0a40: \***
9377: 0a40: \*****************************************************************************
9378: 0a40: 
9379: 0a40: \  CHECK.FOR.ALLOCATED.STOCK:                                           ! ILC  !1.8NWB
9380: 0a40: 
9381: 0a40: \     IF IDSOF.OPEN.FLAG$ = "Y" THEN BEGIN                              ! ILC  !1.8NWB
9382: 0a40: \        IDSOF.ITEM.CODE$ = CITEM.BOOTS.CODE$                           ! ILC  !1.8NWB
9383: 0a40: \        RC% = READ.IDSOF                                               ! ILC  !1.8NWB
9384: 0a40: \        IF RC% = 1 THEN RETURN                                         ! ILC  !1.8NWB
9385: 0a40: 
9386: 0a40: \        ADJUST.PARENT.SALES% = ADJUST.PARENT.SALES% - IDSOF.QUANTITY%  ! ILC  !1.8NWB
9387: 0a40: 
9388: 0a40: \        IF END #IDSOF.SESS.NUM% THEN DELETE.ERROR                      ! ILC  !1.8NWB
9389: 0a40: \        DELREC IDSOF.SESS.NUM%; IDSOF.ITEM.CODE$                       ! ILC  !1.8NWB
9390: 0a40: 
9391: 0a40: \        RETURN.FROM.IDSOF.DELETE.ERROR:                                ! ILC  !1.8NWB
9392: 0a40: \     ENDIF                                                             ! ILC  !1.8NWB
9393: 0a40: 
9394: 0a40: \  RETURN                                                               ! ILC  !1.8NWB
9395: 0a40: 
9396: 0a40: \******************************************************************************
9397: 0a40: \***
9398: 0a40: \***   UPDATE.SALES.USING.MANUAL.COUNT:
9399: 0a40: \***
9400: 0a40: \***       get the theoretical stock for the family
9401: 0a40: \***
9402: 0a40: \***       if there is a multipack count (in COUNT2) then convert this to
9403: 0a40: \***       singles and add it into count 1
9404: 0a40: \***
9405: 0a40: \***       alter sales of the parent by the difference between COUNT1 and
9406: 0a40: \***       the family's theoretical stock
9407: 0a40: \***
9408: 0a40: \***       mark this item as having had its theoretical stock updated, and
9409: 0a40: \***       add it to the table to have its orders for days previous to today
9410: 0a40: \***       deleted
9411: 0a40: \***
9412: 0a40: \***   RETURN
9413: 0a40: \***
9414: 0a40: \******************************************************************************
9415: 0a40: 
9416: 0a40: \  UPDATE.SALES.USING.MANUAL.COUNT:                                            !1.8NWB
9417: 0a40: 
9418: 0a40: \     IF IDSOF.OPEN.FLAG$ = "Y" THEN BEGIN                                     !1.8NWB
9419: 0a40: \        IDSOF.ITEM.CODE$ = CITEM.BOOTS.CODE$                                  !1.8NWB
9420: 0a40: \        RC% = READ.IDSOF                                                      !1.8NWB
9421: 0a40: \        IF RC% = 1 THEN GOTO NOT.ON.IDSOF                                     !1.8NWB
9422: 0a40: 
9423: 0a40: \        MANUAL.COUNT$ = "Y"                                                   !1.8NWB
9424: 0a40: \        IF END # IDSOF.SESS.NUM% THEN DELETE.ERROR                            !1.8NWB
9425: 0a40: \        DELREC IDSOF.SESS.NUM%; IDSOF.ITEM.CODE$                              !1.8NWB
9426: 0a40: 
9427: 0a40: \        RETURN.FROM.IDSOF.DELETE.ERROR.2:                                     !1.8NWB
9428: 0a40: \        NOT.ON.IDSOF:                                                         !1.8NWB
9429: 0a40: \     ENDIF                                                                    !1.8NWB
9430: 0a40: 
9431: 0a40: \     WS.COUNT.REQUEST.FLAG$ = "N"                                      ! BPAB !1.8NWB
9432: 0a40: \     IF CITEM.DATE.OF.LAST.MANUAL.COUNT$ = PACK$("000000") THEN BEGIN  ! BPAB !1.8NWB
9433: 0a40: \        WS.COUNT.REQUEST.FLAG$ = "I"                                   ! BPAB !1.8NWB
9434: 0a40: \     ENDIF                                                             ! BPAB !1.8NWB
9435: 0a40: 
9436: 0a40: \     GOSUB CALC.THEORETICAL.STOCK.FOR.FAMILY                                  !1.8NWB
9437: 0a40: 
9438: 0a40: \     COUNT1% = VAL(MID$(CSRBF.DATA$,14,3))                                    !1.8NWB
9439: 0a40: \     COUNT2% = VAL(MID$(CSRBF.DATA$,17,3))                                    !1.8NWB
9440: 0a40: 
9441: 0a40: \     IF MID$(CSRBF.DATA$,13,1) = "J" AND COUNT2% > 0 THEN BEGIN               !1.8NWB
9442: 0a40: \        COUNT1% = COUNT1% + COUNT2% * MULTIPLICATION.FACTOR%                  !1.8NWB
9443: 0a40: \        COUNT2% = 0                                                           !1.8NWB
9444: 0a40: \     ENDIF                                                                    !1.8NWB
9445: 0a40: 
9446: 0a40: \     IF ITEM.FOUND.ON.FPF$ = "Y"                                       \      !1.8NWB
9447: 0a40: \     AND CIMF.BOOTS.CODE$ <>                                           \      !1.8NWB
9448: 0a40: \        PACK$("00" + MID$(UNPACK$(FPF.PARENT.CODE$),2,6)) THEN BEGIN          !1.8NWB
9449: 0a40: \        CIMF.BOOTS.CODE$ =                                             \      !1.8NWB
9450: 0a40: \            PACK$("00" + MID$(UNPACK$(FPF.PARENT.CODE$),2,6))                 !1.8NWB
9451: 0a40: \        CURR.SESS.NUM% = CIMF.SESS.NUM%                                       !1.8NWB
9452: 0a40: \        CURRENT.KEY$ = CIMF.BOOTS.CODE$                                       !1.8NWB
9453: 0a40: \        RC% = READ.CIMF                                                ! HLC  !1.8NWB
9454: 0a40: \        IF RC% = 1 THEN GOTO READ.ERROR                                ! HLC  !1.8NWB
9455: 0a40: \     ENDIF                                                                    !1.8NWB
9456: 0a40: 
9457: 0a40: \     ADJUST.PARENT.SALES% = ADJUST.PARENT.SALES% -                     \      !1.8NWB
9458: 0a40: \                            COUNT1% + THEORETICAL.STOCK% -             \      !1.8NWB
9459: 0a40: \                      VAL(UNPACK$(WS.TOTAL.ON.ORDER$)) +               \      !1.8NWB
9460: 0a40: \                      VAL(UNPACK$(WS.ON.ORDER.TODAY$))                        !1.8NWB
9461: 0a40: 
9462: 0a40: \     COUNT.DISCREPANCY% = ABS(THEORETICAL.STOCK% - COUNT1%)            ! AGEF !1.8NWB
9463: 0a40: \     IF WS.COUNT.REQUEST.FLAG$ <> "I" THEN BEGIN                       ! BPAB !1.8NWB
9464: 0a40: \       IF COUNT.DISCREPANCY% > 3 THEN BEGIN                            ! AGEF !1.8NWB
9465: 0a40: \         IF THEORETICAL.STOCK% = 0 THEN BEGIN                          ! AGEF !1.8NWB
9466: 0a40: \           WS.COUNT.REQUEST.FLAG$ = "Y"                                ! AGEF !1.8NWB
9467: 0a40: \         ENDIF ELSE BEGIN                                              ! AGEF !1.8NWB
9468: 0a40: \           IF (COUNT.DISCREPANCY% / THEORETICAL.STOCK%) > 0.3 THEN BEGIN      !1.8NWB
9469: 0a40: \             WS.COUNT.REQUEST.FLAG$ = "Y"                              ! AGEF !1.8NWB
9470: 0a40: \           ENDIF                                                       ! AGEF !1.8NWB
9471: 0a40: \         ENDIF                                                         ! AGEF !1.8NWB
9472: 0a40: \       ENDIF                                                           ! AGEF !1.8NWB
9473: 0a40: \     ENDIF                                                             ! BPAB !1.8NWB
9474: 0a40: 
9475: 0a40: \     WS.TOTAL.ON.ORDER$ = WS.ON.ORDER.TODAY$                                  !1.8NWB
9476: 0a40: \     WS.DATE.OF.LAST.MANUAL.COUNT$ = PACK$(DATE$)                             !1.8NWB
9477: 0a40: \     ALTER.DATE.OF.COUNT$ = "Y"                                               !1.8NWB
9478: 0a40: \     WRITE.HOLD.CITEM.CIMF$ = "Y"                                             !1.8NWB
9479: 0a40: 
9480: 0a40: \  RETURN                                                                      !1.8NWB
9481: 0a40: 
9482: 0a40: \******************************************************************************
9483: 0a40: \***
9484: 0a40: \***   CALC.THEORETICAL.STOCK.FOR.FAMILY:
9485: 0a40: \***
9486: 0a40: \***     TS = SA + total ESA - sales + on order - on order today + init.stock
9487: 0a40: \***
9488: 0a40: \***     calculate the theoretical stock for the parent
9489: 0a40: \***     for each flashpack, add in the theoretical stock for the flashpack
9490: 0a40: \***   RETURN
9491: 0a40: \***
9492: 0a40: \******************************************************************************
9493: 0a40: 
9494: 0a40: \  CALC.THEORETICAL.STOCK.FOR.FAMILY:                                          !1.8NWB
9495: 0a40: 
9496: 0a40: \     LOCATION$ = "CALCTS"                                                     !1.8NWB
9497: 0a40: \     ITEM.FOUND.ON.FPF$ = "N"                                                 !1.8NWB
9498: 0a40: \     FLASHPACK% = 0                                                           !1.8NWB
9499: 0a40: \     IF FPF.PARENT.CODE$ <> PACK$("00000000") THEN BEGIN                      !1.8NWB
9500: 0a40: \        CURR.SESS.NUM% = FPF.SESS.NUM%                                        !1.8NWB
9501: 0a40: \        CURRENT.KEY$ = FPF.PARENT.CODE$                                       !1.8NWB
9502: 0a40: \        RC% = READ.FPF                                                 ! HLC  !1.8NWB
9503: 0a40: \        IF RC% = 1 THEN GOTO CALC.TS.CONTINUE                          ! HLC  !1.8NWB
9504: 0a40: \        ITEM.FOUND.ON.FPF$ = "Y"                                              !1.8NWB
9505: 0a40: \     ENDIF                                                                    !1.8NWB
9506: 0a40: 
9507: 0a40: \  CALC.TS.CONTINUE:                                                           !1.8NWB
9508: 0a40: 
9509: 0a40: \     THEORETICAL.STOCK% = VAL(UNPACK$(WS.SHELF.ALLOCATION$)) +         \      !1.8NWB
9510: 0a40: \                          VAL(UNPACK$(WS.TOTAL.ESA$)) -                \      !1.8NWB
9511: 0a40: \                          CIMF.NUMITEM% - ADJUST.PARENT.SALES% +       \      !1.8NWB
9512: 0a40: \                          VAL(UNPACK$(WS.TOTAL.ON.ORDER$)) -           \      !1.8NWB
9513: 0a40: \                          VAL(UNPACK$(WS.ON.ORDER.TODAY$)) +           \      !1.8NWB
9514: 0a40: \                          VAL(UNPACK$(CITEM.INITIAL.DISPLAY.STOCK$))          !1.8NWB
9515: 0a40: 
9516: 0a40: \     IF ITEM.FOUND.ON.FPF$ = "N" THEN RETURN                                  !1.8NWB
9517: 0a40: 
9518: 0a40: \     MULTIPLICATION.FACTOR% = 1                                               !1.8NWB
9519: 0a40: \     FLASHPACK% = 1                                                           !1.8NWB
9520: 0a40: \     WHILE FLASHPACK% < 11 AND FPF.CODE$(FLASHPACK%) <> PACK$("99999999")     !1.8NWB
9521: 0a40: \        CITEM.BOOTS.CODE$ = FPF.CODE$(FLASHPACK%)                             !1.8NWB
9522: 0a40: \        MULTIPLICATION.FACTOR% =                                       \      !1.8NWB
9523: 0a40: \            VAL(UNPACK$(FPF.MULT.FACTOR$(FLASHPACK%))) / 10                   !1.8NWB
9524: 0a40: \        CIMF.BOOTS.CODE$ =                                             \      !1.8NWB
9525: 0a40: \            PACK$("00" + MID$(UNPACK$(FPF.CODE$(FLASHPACK%)),2,6))            !1.8NWB
9526: 0a40: \      CURR.SESS.NUM% = CITEM.SESS.NUM%                                        !1.8NWB
9527: 0a40: \      CURRENT.KEY$ = CITEM.BOOTS.CODE$                                        !1.8NWB
9528: 0a40: \      RC% = READ.CITEM                                    ! HLC               !1.8NWB
9529: 0a40: \      IF RC% = 1 THEN GOTO NEXT.FLASHPACK                        ! HLC        !1.8NWB
9530: 0a40: \      CURR.SESS.NUM% = CIMF.SESS.NUM%                                         !1.8NWB
9531: 0a40: \      CURRENT.KEY$ = CIMF.BOOTS.CODE$                                         !1.8NWB
9532: 0a40: \      RC% = READ.CIMF                                    ! HLC                !1.8NWB
9533: 0a40: \        IF RC% = 1 THEN GOTO NEXT.FLASHPACK                        ! HLC      !1.8NWB
9534: 0a40: \      THEORETICAL.STOCK% = THEORETICAL.STOCK% +                  \            !1.8NWB
9535: 0a40: \                             (VAL(UNPACK$(CITEM.TOTAL.ESA$)) -       \        !1.8NWB
9536: 0a40: \                             CIMF.NUMITEM% +                           \      !1.8NWB
9537: 0a40: \                       VAL(UNPACK$(CITEM.TOTAL.ON.ORDER$)) -      \           !1.8NWB
9538: 0a40: \                       VAL(UNPACK$(CITEM.ON.ORDER.TODAY$)) +     \            !1.8NWB
9539: 0a40: \                   VAL(UNPACK$(CITEM.INITIAL.DISPLAY.STOCK$))) * \            !1.8NWB
9540: 0a40: \                       MULTIPLICATION.FACTOR%                                 !1.8NWB
9541: 0a40: \        IF CITEM.ON.ORDER.TODAY$ <> CITEM.TOTAL.ON.ORDER$ THEN BEGIN          !1.8NWB
9542: 0a40: \         CIMF.NUMITEM% = CIMF.NUMITEM% +                         \            !1.8NWB
9543: 0a40: \                     VAL(UNPACK$(CITEM.ON.ORDER.TODAY$)) -      \             !1.8NWB
9544: 0a40: \                     VAL(UNPACK$(CITEM.TOTAL.ON.ORDER$))                      !1.8NWB
9545: 0a40: \         CURR.SESS.NUM% = CIMF.SESS.NUM%                                      !1.8NWB
9546: 0a40: \         CURRENT.KEY$ = CIMF.BOOTS.CODE$                                      !1.8NWB
9547: 0a40: \         RC% = WRITE.CIMF.HOLD                              ! HLC             !1.8NWB
9548: 0a40: \           IF RC% = 1 THEN GOTO WRITE.ERROR                        ! HLC      !1.8NWB
9549: 0a40: \         CITEM.TOTAL.ON.ORDER$ = CITEM.ON.ORDER.TODAY$                        !1.8NWB
9550: 0a40: \         CURR.SESS.NUM% = CITEM.SESS.NUM%                                     !1.8NWB
9551: 0a40: \         CURRENT.KEY$ = CITEM.BOOTS.CODE$                                     !1.8NWB
9552: 0a40: \         RC% = WRITE.CITEM.HOLD                               ! HLC           !1.8NWB
9553: 0a40: \           IF RC% = 1 THEN GOTO WRITE.ERROR                        ! HLC      !1.8NWB
9554: 0a40: \      ENDIF                                                                   !1.8NWB
9555: 0a40: \     NEXT.FLASHPACK:                                                          !1.8NWB
9556: 0a40: \        FLASHPACK% = FLASHPACK% + 1                                           !1.8NWB
9557: 0a40: \     WEND                                                                     !1.8NWB
9558: 0a40: 
9559: 0a40: \     LOCATION$ = ""                                                           !1.8NWB
9560: 0a40: 
9561: 0a40: \  RETURN                                                                      !1.8NWB
9562: 0a40: 
9563: 0a40: \******************************************************************************
9564: 0a40: \***
9565: 0a40: \***   CALC.ORDER.FOR.VALID.ITEM:
9566: 0a40: \***
9567: 0a40: \***      at this point any manual counts will have been processed, and all
9568: 0a40: \***      counts can be calculated using the controller figures only.
9569: 0a40: \***
9570: 0a40: \***      if this is a non-zero override then order the amount requested
9571: 0a40: \***
9572: 0a40: \***      otherwise order = sales - total onorder - onorder in this PDT
9573: 0a40: \***      or, if a family, gosub CALCULATE.FAMILY.FIGURES
9574: 0a40: \***
9575: 0a40: \***   RETURN
9576: 0a40: \***
9577: 0a40: \******************************************************************************
9578: 0a40: 
9579: 0a40: \  CALC.ORDER.FOR.VALID.ITEM:                                                  !1.8NWB
9580: 0a40: 
9581: 0a40: \     CSRWF.QTY.1$ = "000"                                                     !1.8NWB
9582: 0a40: \     CSRWF.QTY.2$ = "000"                                                     !1.8NWB
9583: 0a40: \     CSRWF.QTY.2.IN.SINGLES$ = "000"                                          !1.8NWB
9584: 0a40: \     CSRWF.QTY.1% = 0                                                         !1.8NWB
9585: 0a40: \     CSRWF.QTY.2% = 0                                                         !1.8NWB
9586: 0a40: \     CSRWF.QTY.2.IN.SINGLES% = 0                                              !1.8NWB
9587: 0a40: 
9588: 0a40: \     CSRWF.ONORDER.UPDATED.FLAG$ = "N"                                        !1.8NWB
9589: 0a40: \     CSRWF.CSRIMF.UPDATED.FLAG$ = "N"                                         !1.8NWB
9590: 0a40: \     CSRWF.CSRITEM.UPDATED.FLAG$ = "N"                                        !1.8NWB
9591: 0a40: 
9592: 0a40: \     IF RECORD.TYPE$ = "OVERRIDE" THEN BEGIN                                  !1.8NWB
9593: 0a40: \        CSRWF.RECORD.TYPE$ = "XO"                                             !1.8NWB
9594: 0a40: \        CSRWF.ITEM.CODE$ = MID$(CSRBF.DATA$,3,7)                              !1.8NWB
9595: 0a40: \      IF CSRWF.ZERO.OVERRIDE.FLAG$ = "N" THEN BEGIN                           !1.8NWB
9596: 0a40: \           CSRWF.QTY.1$ = MID$(CSRBF.DATA$,10,3)                              !1.8NWB
9597: 0a40: \         RETURN                                                               !1.8NWB
9598: 0a40: \      ENDIF ELSE BEGIN                                                        !1.8NWB
9599: 0a40: \         IF WS.SHELF.ALLOCATION$ = PACK$("????") THEN BEGIN                   !1.8NWB
9600: 0a40: \            CSRWF.QTY.1$ = "000"                                              !1.8NWB
9601: 0a40: \            RETURN                                                            !1.8NWB
9602: 0a40: \         ENDIF                                                                !1.8NWB
9603: 0a40: \      ENDIF                                                                   !1.8NWB
9604: 0a40: \     ENDIF                                                                    !1.8NWB
9605: 0a40: 
9606: 0a40: \     IF (RECORD.TYPE$ = "UNCOUNTED" OR RECORD.TYPE$ = "MANUAL")      \        !1.8NWB
9607: 0a40: \     OR (RECORD.TYPE$ = "OVERRIDE"                              \             !1.8NWB
9608: 0a40: \     AND CSRWF.ZERO.OVERRIDE.FLAG$ = "Y")  THEN BEGIN                         !1.8NWB
9609: 0a40: \        IF FPF.PARENT.CODE$ <> PACK$("00000000") THEN BEGIN                   !1.8NWB
9610: 0a40: \         GOSUB CALCULATE.FAMILY.FIGURES                                       !1.8NWB
9611: 0a40: \        ENDIF ELSE BEGIN                                                      !1.8NWB
9612: 0a40: \         CSRWF.QTY.1% = CIMF.NUMITEM% + ADJUST.PARENT.SALES% -      \         !1.8NWB
9613: 0a40: \                        VAL(UNPACK$(WS.TOTAL.ON.ORDER$)) -            \       !1.8NWB
9614: 0a40: \                      VAL(UNPACK$(WS.ON.ORDER.IN.THIS.PDT$))                  !1.8NWB
9615: 0a40: \         CSRWF.QTY.1$ = RIGHT$("000" + STR$(CSRWF.QTY.1%),3)                  !1.8NWB
9616: 0a40: \         TOTAL.SA% = VAL(UNPACK$(WS.SHELF.ALLOCATION$)) +            \        !1.8NWB
9617: 0a40: \                 VAL(UNPACK$(WS.TOTAL.ESA$))                                  !1.8NWB
9618: 0a40: \         IF CSRWF.QTY.1% > TOTAL.SA% THEN BEGIN                               !1.8NWB
9619: 0a40: \            CSRWF.QTY.1% = TOTAL.SA%                                          !1.8NWB
9620: 0a40: \            CSRWF.QTY.1$ = RIGHT$("000" + STR$(CSRWF.QTY.1%),3)               !1.8NWB
9621: 0a40: \           ENDIF                                                              !1.8NWB
9622: 0a40: \        ENDIF                                                                 !1.8NWB
9623: 0a40:        ! following check commented out to allow a full shelf order for  GDS
9624: 0a40:          ! items switching from EPSOM to CSR.                             GDS
9625: 0a40:          !IF RECORD.TYPE$ = "UNCOUNTED"                               \ CPAB
9626: 0a40:        !   AND FIRST.LINK.FLAG$ = "Y" THEN BEGIN                   ! CPAB
9627: 0a40:        !   CSRWF.QTY.1$ = "000"                              ! CPAB
9628: 0a40:        !ENDIF                                                ! CPAB
9629: 0a40: \     ENDIF                                                                    !1.8NWB
9630: 0a40: 
9631: 0a40: \     CSRWF.P.ITEM.CODE$ = PARENT.CODE$                                        !1.8NWB
9632: 0a40: 
9633: 0a40: \     IF CSRWF.QTY.1% < 0 THEN CSRWF.QTY.1$ = "000"                            !1.8NWB
9634: 0a40: 
9635: 0a40: \  RETURN                                                                      !1.8NWB
9636: 0a40: 
9637: 0a40: \******************************************************************************
9638: 0a40: \***
9639: 0a40: \***   GET.PARENT.OF.FAMILY:
9640: 0a40: \***
9641: 0a40: \***      use the IDF to determine the parent of any item
9642: 0a40: \***      if the item was a flashpack, read the CITEM and CIMF for
9643: 0a40: \***      the parent item
9644: 0a40: \***
9645: 0a40: \***   RETURN
9646: 0a40: \***
9647: 0a40: \******************************************************************************
9648: 0a40: 
9649: 0a40: \  GET.PARENT.OF.FAMILY:                                                       !1.8NWB
9650: 0a40: 
9651: 0a40: \     IF IDF.PARENT.CODE$ = PACK$("00000000") THEN BEGIN                       !1.8NWB
9652: 0a40: \        FPF.PARENT.CODE$ = PACK$("00000000")                                  !1.8NWB
9653: 0a40: \      RETURN                                                                  !1.8NWB
9654: 0a40: \     ENDIF                                                                    !1.8NWB
9655: 0a40: 
9656: 0a40: \     IF IDF.PARENT.CODE$ = IDF.BOOTS.CODE$ THEN BEGIN                         !1.8NWB
9657: 0a40: \        FPF.PARENT.CODE$ = IDF.BOOTS.CODE$                                    !1.8NWB
9658: 0a40: \      RETURN                                                                  !1.8NWB
9659: 0a40: \     ENDIF                                                                    !1.8NWB
9660: 0a40: 
9661: 0a40: \     LOCATION$ = "FPFPROC"                                                    !1.8NWB
9662: 0a40: \     ITEM.FOUND.ON.CITEM$ = "N"                                               !1.8NWB
9663: 0a40: \     ITEM.FOUND.ON.CIMF$ = "N"                                                !1.8NWB
9664: 0a40: \     FPF.PARENT.CODE$ = IDF.PARENT.CODE$                                      !1.8NWB
9665: 0a40: \     PARENT.CODE$ = FPF.PARENT.CODE$                                          !1.8NWB
9666: 0a40: \     CITEM.BOOTS.CODE$ = IDF.PARENT.CODE$                                     !1.8NWB
9667: 0a40: \     CIMF.BOOTS.CODE$ = PACK$("00" + MID$(UNPACK$(IDF.PARENT.CODE$),2,6))     !1.8NWB
9668: 0a40: \     CURR.SESS.NUM% = CITEM.SESS.NUM%                                         !1.8NWB
9669: 0a40: \     CURRENT.KEY$ = CITEM.BOOTS.CODE$                                         !1.8NWB
9670: 0a40: \     RC% = READ.CITEM                                          ! HLC          !1.8NWB
9671: 0a40: \     IF RC% = 1 THEN GOTO READ.ERROR                              ! HLC       !1.8NWB
9672: 0a40: \     ITEM.FOUND.ON.CITEM$ = "Y"                                               !1.8NWB
9673: 0a40: \     CURR.SESS.NUM% = CIMF.SESS.NUM%                                          !1.8NWB
9674: 0a40: \     CURRENT.KEY$ = CIMF.BOOTS.CODE$                                          !1.8NWB
9675: 0a40: \     RC% = READ.CIMF                                          ! HLC           !1.8NWB
9676: 0a40: \     IF RC% = 1 THEN GOTO READ.ERROR                              ! HLC       !1.8NWB
9677: 0a40: \     ITEM.FOUND.ON.CIMF$ = "Y"                                                !1.8NWB
9678: 0a40: \     LOCATION$ = ""                                                           !1.8NWB
9679: 0a40: \  FIND.PARENT.RETURN:                                                         !1.8NWB
9680: 0a40: \  RETURN                                                                      !1.8NWB
9681: 0a40: 
9682: 0a40: \  FIND.PARENT.CONTINUE:                                                       !1.8NWB
9683: 0a40: \     LOCATION$ = ""                                                           !1.8NWB
9684: 0a40: \  GOTO FIND.PARENT.RETURN                                                     !1.8NWB
9685: 0a40: 
9686: 0a40: \******************************************************************************
9687: 0a40: \***
9688: 0a40: \***   CALCULATE.FAMILY.FIGURES:
9689: 0a40: \***
9690: 0a40: \***      calculate the order quantity using just the parent
9691: 0a40: \***
9692: 0a40: \***      for each flashpack item found on both CIMF and CITEM
9693: 0a40: \***         increment the order quantity using the figures for the FP
9694: 0a40: \***
9695: 0a40: \***         if a qty 2 is expected then use the first item on promotion
9696: 0a40: \***         to calculate the wants (in "packets", not singles) for that
9697: 0a40: \***         item
9698: 0a40: \***
9699: 0a40: \***         keep a running total of sales and of ESA
9700: 0a40: \***
9701: 0a40: \***      ensure that the order quantity does not exceed the total shelf
9702: 0a40: \***      allocation available to this family
9703: 0a40: \***
9704: 0a40: \***      if qty 2 is -ve or greater than the shelf allocation for the
9705: 0a40: \***         item in question then adjust it and place the difference
9706: 0a40: \***         (adjusted by MF) in the qty for rest of family (qty 1)
9707: 0a40: \***
9708: 0a40: \***      if qty 1 is -ve then, if qty 2 has been used, qty 2 will be reduced
9709: 0a40: \***         to reflect the overstock of the other members of the family,
9710: 0a40: \***         and qty 1 will be set to 0.  (If this means that qty 2 has
9711: 0a40: \***         become negative, which implies that the figures for this family
9712: 0a40: \***         are incorrect, then it will be set to 0.)
9713: 0a40: \***         This situation could arise following a transmission failure of
9714: 0a40: \***         the deliveries file.
9715: 0a40: \***
9716: 0a40: \***   RETURN
9717: 0a40: \***
9718: 0a40: \******************************************************************************
9719: 0a40: 
9720: 0a40: \  CALCULATE.FAMILY.FIGURES:                                                   !1.8NWB
9721: 0a40: 
9722: 0a40: \     LOCATION$ = "FAMFIGS"                                                    !1.8NWB
9723: 0a40: \     FLASHPACK% = 0                                                           !1.8NWB
9724: 0a40: \     ITEM.FOUND.ON.FPF$ = "N"                                                 !1.8NWB
9725: 0a40: \     CURR.SESS.NUM% = FPF.SESS.NUM%                                           !1.8NWB
9726: 0a40: \     CURRENT.KEY$ = FPF.PARENT.CODE$                                          !1.8NWB
9727: 0a40: \     RC% = READ.FPF                                          ! HLC            !1.8NWB
9728: 0a40: \     IF RC% = 1 THEN GOTO CALC.FAMILY.FIGURES.CONTINUE                  ! HLC !1.8NWB
9729: 0a40: \     ITEM.FOUND.ON.FPF$ = "Y"                                                 !1.8NWB
9730: 0a40: 
9731: 0a40: \  CALC.FAMILY.FIGURES.CONTINUE:                                               !1.8NWB
9732: 0a40: 
9733: 0a40: \     CSRWF.QTY.1% = CIMF.NUMITEM% + ADJUST.PARENT.SALES% -              \     !1.8NWB
9734: 0a40: \               VAL(UNPACK$(WS.TOTAL.ON.ORDER$)) -                  \          !1.8NWB
9735: 0a40: \               VAL(UNPACK$(WS.ON.ORDER.IN.THIS.PDT$))                         !1.8NWB
9736: 0a40: 
9737: 0a40: \     TOTAL.SALES% = CIMF.NUMITEM% + ADJUST.PARENT.SALES%                      !1.8NWB
9738: 0a40: \     TOTAL.SA% = VAL(UNPACK$(WS.SHELF.ALLOCATION$)) +                  \      !1.8NWB
9739: 0a40: \                 VAL(UNPACK$(WS.TOTAL.ESA$))                                  !1.8NWB
9740: 0a40: 
9741: 0a40: \     IF ITEM.FOUND.ON.FPF$ = "N" THEN BEGIN                                   !1.8NWB
9742: 0a40: \        IF CSRWF.QTY.1% > TOTAL.SA% THEN CSRWF.QTY.1% = TOTAL.SA%             !1.8NWB
9743: 0a40: \        CSRWF.QTY.1$ = RIGHT$("000" + STR$(CSRWF.QTY.1%), 3)                  !1.8NWB
9744: 0a40: \        CSRWF.QTY.2$ = RIGHT$("000" + STR$(CSRWF.QTY.2%), 3)                  !1.8NWB
9745: 0a40: \        RETURN                                                                !1.8NWB
9746: 0a40: \     ENDIF                                                                    !1.8NWB
9747: 0a40: 
9748: 0a40: \     PROMOTION.DONE$ = "N"                                                    !1.8NWB
9749: 0a40: \     PROMOTIONAL.SA% = 0                                                      !1.8NWB
9750: 0a40: \     PROMOTIONAL.MF% = 1                                                      !1.8NWB
9751: 0a40: \     FLASHPACK% = 1                                                           !1.8NWB
9752: 0a40: 
9753: 0a40: \     WHILE FLASHPACK% < 11 AND      FPF.CODE$(FLASHPACK%) <> PACK$("99999999")!1.8NWB
9754: 0a40: \      CITEM.BOOTS.CODE$ = FPF.CODE$(FLASHPACK%)                               !1.8NWB
9755: 0a40: \      CIMF.BOOTS.CODE$ =                                     \                !1.8NWB
9756: 0a40: \            PACK$("00" + MID$(UNPACK$(FPF.CODE$(FLASHPACK%)),2,6))            !1.8NWB
9757: 0a40: \      CURR.SESS.NUM% = CITEM.SESS.NUM%                                        !1.8NWB
9758: 0a40: \      CURRENT.KEY$ = CITEM.BOOTS.CODE$                                        !1.8NWB
9759: 0a40: \      RC% = READ.CITEM                                    ! HLC               !1.8NWB
9760: 0a40: \        IF RC% = 1 THEN GOTO CALC.FAMILY.FIGURES.CONTINUE2            ! HLC   !1.8NWB
9761: 0a40: \      IF ALTER.UNIT$ = "Y"                                    \ DPAB          !1.8NWB
9762: 0a40: \      OR ALTER.DATE.OF.COUNT$ = "Y" THEN BEGIN                                !1.8NWB
9763: 0a40: \           CITEM.UNIT$ = WS.UNIT$                                             !1.8NWB
9764: 0a40: \         CITEM.LIST.FREQUENCY$ = WS.LIST.FREQUENCY$                           !1.8NWB
9765: 0a40: \         CITEM.DATE.OF.LAST.MANUAL.COUNT$ =                         \         !1.8NWB
9766: 0a40: \                        WS.DATE.OF.LAST.MANUAL.COUNT$                         !1.8NWB
9767: 0a40: \         RC% = WRITE.CITEM                                    ! HLC           !1.8NWB
9768: 0a40: \           IF RC% = 1 THEN GOTO WRITE.ERROR                        ! HLC      !1.8NWB
9769: 0a40: \      ENDIF                                                                   !1.8NWB
9770: 0a40: \      CURR.SESS.NUM% = CIMF.SESS.NUM%                                         !1.8NWB
9771: 0a40: \      CURRENT.KEY$ = CIMF.BOOTS.CODE$                                         !1.8NWB
9772: 0a40: \      RC% = READ.CIMF                                    ! HLC                !1.8NWB
9773: 0a40: \        IF RC% = 1 THEN GOTO CALC.FAMILY.FIGURES.CONTINUE2            ! HLC   !1.8NWB
9774: 0a40: \      FP.NUMITEM% = CIMF.NUMITEM%                                             !1.8NWB
9775: 0a40: \      MULTIPLICATION.FACTOR% =                              \                 !1.8NWB
9776: 0a40: \             VAL(UNPACK$(FPF.MULT.FACTOR$(FLASHPACK%))) / 10                  !1.8NWB
9777: 0a40: \      GOSUB CHECK.FP.SALES                                                    !1.8NWB
9778: 0a40: \      IF CITEM.TOTAL.ESA$ <> PACK$("0000")                        \           !1.8NWB
9779: 0a40: \      AND (RECORD.TYPE$ = "UNCOUNTED" OR RECORD.TYPE$ = "MANUAL")      \      !1.8NWB
9780: 0a40: \      AND (MID$(CSRBF.DATA$,13,1) = "N"                        \              !1.8NWB
9781: 0a40: \      OR MID$(CSRBF.DATA$,13,1) = "J")                        \               !1.8NWB
9782: 0a40: \      AND PROMOTION.DONE$ = "N" THEN BEGIN                                    !1.8NWB
9783: 0a40: \           PROMOTION.DONE$ = "Y"                                              !1.8NWB
9784: 0a40: \         CSRWF.QTY.2% = FP.NUMITEM% -                         \               !1.8NWB
9785: 0a40: \                        VAL(UNPACK$(CITEM.TOTAL.ON.ORDER$))                   !1.8NWB
9786: 0a40: \         PROMOTIONAL.SA% = VAL(UNPACK$(CITEM.TOTAL.ESA$))                     !1.8NWB
9787: 0a40: \         PROMOTIONAL.MF% = MULTIPLICATION.FACTOR%                             !1.8NWB
9788: 0a40: \         CSRWF.QTY.2.IN.SINGLES% =                              \             !1.8NWB
9789: 0a40: \               CSRWF.QTY.2% * MULTIPLICATION.FACTOR%                          !1.8NWB
9790: 0a40: \           CSRWF.QTY.2.IN.SINGLES% = FN.ROUND.DOWN(CSRWF.QTY.2.IN.SINGLES%)   !1.8NWB
9791: 0a40: \        ENDIF ELSE BEGIN                                                      !1.8NWB
9792: 0a40: \           CSRWF.QTY.1% = CSRWF.QTY.1% +                         \            !1.8NWB
9793: 0a40: \                          (FP.NUMITEM% * MULTIPLICATION.FACTOR%) -      \     !1.8NWB
9794: 0a40: \                        VAL(UNPACK$(CITEM.TOTAL.ON.ORDER$)) -        \        !1.8NWB
9795: 0a40: \                      VAL(UNPACK$(CITEM.ON.ORDER.IN.THIS.PDT$))               !1.8NWB
9796: 0a40: \           CSRWF.QTY.1% = FN.ROUND.DOWN(CSRWF.QTY.1%)                         !1.8NWB
9797: 0a40: \      ENDIF                                                                   !1.8NWB
9798: 0a40: \        TOTAL.SALES% = TOTAL.SALES% + FP.NUMITEM% * MULTIPLICATION.FACTOR%    !1.8NWB
9799: 0a40: \      TOTAL.SALES% = FN.ROUND.DOWN(TOTAL.SALES%)                              !1.8NWB
9800: 0a40: \      TOTAL.SA% = TOTAL.SA% +                              \                  !1.8NWB
9801: 0a40: \                VAL(UNPACK$(CITEM.TOTAL.ESA$)) *                  \           !1.8NWB
9802: 0a40: \                MULTIPLICATION.FACTOR%                                        !1.8NWB
9803: 0a40: \        TOTAL.SA% = FN.ROUND.DOWN(TOTAL.SA%)                                  !1.8NWB
9804: 0a40: \     CALC.FAMILY.FIGURES.CONTINUE2:                                           !1.8NWB
9805: 0a40: \      FLASHPACK% = FLASHPACK% + 1                                             !1.8NWB
9806: 0a40: \     WEND                                                                     !1.8NWB
9807: 0a40: \     LOCATION$ = ""                                                           !1.8NWB
9808: 0a40: 
9809: 0a40: \     IF CSRWF.QTY.1% > TOTAL.SA% THEN BEGIN                                   !1.8NWB
9810: 0a40: \      CSRWF.QTY.1% = TOTAL.SA%                                                !1.8NWB
9811: 0a40: \     ENDIF                                                                    !1.8NWB
9812: 0a40: 
9813: 0a40: \     IF CSRWF.QTY.2% < 0 THEN BEGIN                                           !1.8NWB
9814: 0a40: \        CSRWF.QTY.1% = CSRWF.QTY.1% + CSRWF.QTY.2.IN.SINGLES%                 !1.8NWB
9815: 0a40: \      CSRWF.QTY.2% = 0                                                        !1.8NWB
9816: 0a40: \      CSRWF.QTY.2.IN.SINGLES% = 0                                             !1.8NWB
9817: 0a40: \     ENDIF ELSE BEGIN                                                         !1.8NWB
9818: 0a40: \        IF CSRWF.QTY.2% > PROMOTIONAL.SA% THEN BEGIN                          !1.8NWB
9819: 0a40: \         CSRWF.QTY.1% = CSRWF.QTY.1% +                        \               !1.8NWB
9820: 0a40: \                        (CSRWF.QTY.2% - PROMOTIONAL.SA%) *            \       !1.8NWB
9821: 0a40: \                    PROMOTIONAL.MF%                                           !1.8NWB
9822: 0a40: \           CSRWF.QTY.2% = PROMOTIONAL.SA%                                     !1.8NWB
9823: 0a40: \           CSRWF.QTY.2.IN.SINGLES% = PROMOTIONAL.SA% * PROMOTIONAL.MF%        !1.8NWB
9824: 0a40: \         CSRWF.QTY.2.IN.SINGLES% = FN.ROUND.DOWN(CSRWF.QTY.2.IN.SINGLES%)     !1.8NWB
9825: 0a40: \      ENDIF                                                                   !1.8NWB
9826: 0a40: \     ENDIF                                                                    !1.8NWB
9827: 0a40: 
9828: 0a40: \     IF CSRWF.QTY.1% < 0 AND PROMOTION.DONE$ = "Y" THEN BEGIN                 !1.8NWB
9829: 0a40: \        CSRWF.QTY.2% = CSRWF.QTY.2% + (CSRWF.QTY.1% / PROMOTIONAL.MF%)        !1.8NWB
9830: 0a40: \      CSRWF.QTY.2% = FN.ROUND.DOWN(CSRWF.QTY.2%)                              !1.8NWB
9831: 0a40: \      CSRWF.QTY.1% = 0                                                        !1.8NWB
9832: 0a40: \      IF CSRWF.QTY.2% < 0 THEN CSRWF.QTY.2% = 0                               !1.8NWB
9833: 0a40: \     ENDIF                                                                    !1.8NWB
9834: 0a40: 
9835: 0a40: \     CSRWF.QTY.1$ = RIGHT$("000" + STR$(CSRWF.QTY.1%),3)                      !1.8NWB
9836: 0a40: \     CSRWF.QTY.2$ = RIGHT$("000" + STR$(CSRWF.QTY.2%),3)                      !1.8NWB
9837: 0a40: \     CSRWF.QTY.2.IN.SINGLES$ =                                    \           !1.8NWB
9838: 0a40: \                        RIGHT$("000" + STR$(CSRWF.QTY.2.IN.SINGLES%),3)       !1.8NWB
9839: 0a40: \     LOCATION$ = ""                                                           !1.8NWB
9840: 0a40: 
9841: 0a40: \  RETURN                                                                      !1.8NWB
9842: 0a40: 
9843: 0a40: \******************************************************************************
9844: 0a40: \***
9845: 0a40: \***   CHECK.FP.SALES:
9846: 0a40: \***
9847: 0a40: \***     if the sales for this flashpack exceed the space available to it
9848: 0a40: \***        (which will be 0 unless the item is on promotion) then the
9849: 0a40: \***        sales for the flashpack will be set equal to the shelf alloc.
9850: 0a40: \***        The extra sales will be added to the sales for the parent.
9851: 0a40: \***
9852: 0a40: \***   RETURN
9853: 0a40: \***
9854: 0a40: \******************************************************************************
9855: 0a40: 
9856: 0a40: \CHECK.FP.SALES:                                                               !1.8NWB
9857: 0a40: 
9858: 0a40: \      IF CIMF.NUMITEM% > VAL(UNPACK$(CITEM.TOTAL.ESA$)) THEN BEGIN            !1.8NWB
9859: 0a40: \         RC% = READ.CIMF.LOCK                                         ! NNS   !1.8NWB
9860: 0a40: \         IF RC% = 1 THEN GOTO READ.ERROR                              ! NNS   !1.8NWB
9861: 0a40: \         ADJUST.PARENT.SALES% = ADJUST.PARENT.SALES% +                \       !1.8NWB
9862: 0a40: \                                (CIMF.NUMITEM% -                      \       !1.8NWB
9863: 0a40: \                                VAL(UNPACK$(CITEM.TOTAL.ESA$))) *     \       !1.8NWB
9864: 0a40: \                                MULTIPLICATION.FACTOR%                        !1.8NWB
9865: 0a40: \         ADJUST.PARENT.SALES% = FN.ROUND.DOWN(ADJUST.PARENT.SALES%)           !1.8NWB
9866: 0a40: \         CIMF.NUMITEM% = VAL(UNPACK$(CITEM.TOTAL.ESA$))                       !1.8NWB
9867: 0a40: \         CURR.SESS.NUM% = CIMF.SESS.NUM%                                      !1.8NWB
9868: 0a40: \         RC% = WRITE.CIMF.HOLD.UNLOCK                                 ! NNS   !1.8NWBLC
9869: 0a40: \         IF RC% = 1 THEN GOTO WRITE.ERROR                             ! HLC   !1.8NWB
9870: 0a40: \         CIMF.BOOTS.CODE$ =                                           \       !1.8NWB
9871: 0a40: \            PACK$("00" + MID$(UNPACK$(FPF.PARENT.CODE$),2,6))                 !1.8NWB
9872: 0a40: \         CURRENT.KEY$ = CIMF.BOOTS.CODE$                                      !1.8NWB
9873: 0a40: \         RC% = READ.CIMF.LOCK                                         ! HLC   !1.8NWB
9874: 0a40: \         IF RC% = 1 THEN GOTO READ.ERROR                              ! HLC   !1.8NWB
9875: 0a40: \         CIMF.NUMITEM% = CIMF.NUMITEM% + ADJUST.PARENT.SALES%                 !1.8NWB
9876: 0a40: \         RC% = WRITE.CIMF.HOLD.UNLOCK                                 ! HLC   !1.8NWB
9877: 0a40: \         IF RC% = 1 THEN GOTO WRITE.ERROR                             ! HLC   !1.8NWB
9878: 0a40: \         ADJUST.PARENT.SALES% = 0                                             !1.8NWB
9879: 0a40: \      ENDIF                                                                   !1.8NWB
9880: 0a40: 
9881: 0a40: \RETURN                                                                        !1.8NWB
9882: 0a40: 
9883: 0a40: \******************************************************************************
9884: 0a40: \***
9885: 0a40: \***   WRITE.ORDER:
9886: 0a40: \***
9887: 0a40: \***     prepare either an "XO" (override) or "XC" (counted) record for the
9888: 0a40: \***     workfile
9889: 0a40: \***
9890: 0a40: \***     update the "on order in this pdt" figure and write
9891: 0a40: \***     the new record to the workfile
9892: 0a40: \***
9893: 0a40: \***   RETURN
9894: 0a40: \***
9895: 0a40: \******************************************************************************
9896: 0a40: 
9897: 0a40: \  WRITE.ORDER:                                                                !1.8NWB
9898: 0a40: 
9899: 0a40: \     IF RECORD.TYPE$ = "OVERRIDE" THEN      BEGIN                             !1.8NWB
9900: 0a40: \        CSRWF.RECORD.TYPE$ = "XO"                                             !1.8NWB
9901: 0a40: \     ENDIF ELSE BEGIN                                                         !1.8NWB
9902: 0a40: \        CSRWF.RECORD.TYPE$ = "XC"                                             !1.8NWB
9903: 0a40: \     ENDIF                                                                    !1.8NWB
9904: 0a40: 
9905: 0a40: \     WS.ON.ORDER.IN.THIS.PDT$ = PACK$(RIGHT$("0000" +                  \      !1.8NWB
9906: 0a40: \                        STR$(VAL(CSRWF.QTY.1$) +            \                 !1.8NWB
9907: 0a40: \                          VAL(CSRWF.QTY.2.IN.SINGLES$) +       \              !1.8NWB
9908: 0a40: \                  VAL(UNPACK$(WS.ON.ORDER.IN.THIS.PDT$))),4))                 !1.8NWB
9909: 0a40: 
9910: 0a40: \     IF ITEM.FOUND.ON.CITEM$ = "Y" THEN BEGIN                                 !1.8NWB
9911: 0a40: \        CURR.SESS.NUM% = CITEM.SESS.NUM%                                      !1.8NWB
9912: 0a40: \        CITEM.BOOTS.CODE$ = PARENT.CODE$                                      !1.8NWB
9913: 0a40: \      CIMF.BOOTS.CODE$ = PACK$("0" + LEFT$(UNPACK$(PARENT.CODE$),7))          !1.8NWB
9914: 0a40: \        CURRENT.KEY$ = PARENT.CODE$                                           !1.8NWB
9915: 0a40: \      RC% = READ.CITEM.LOCK                                    ! HLC          !1.8NWB
9916: 0a40: \        IF RC% = 1 THEN GOTO READ.ERROR                        ! HLC          !1.8NWB
9917: 0a40: \        GOSUB MOVE.WS.TO.CITEM                                                !1.8NWB
9918: 0a40: \        IF WRITE.HOLD.CITEM.CIMF$ = "N" THEN BEGIN                            !1.8NWB
9919: 0a40: \           RC% = WRITE.CITEM.UNLOCK                              ! HLC        !1.8NWB
9920: 0a40: \           IF RC% = 1 THEN GOTO WRITE.ERROR                        ! HLC      !1.8NWB
9921: 0a40: \        ENDIF ELSE BEGIN                                                      !1.8NWB
9922: 0a40: \           RC% = WRITE.CITEM.HOLD.UNLOCK                        ! HLC         !1.8NWB
9923: 0a40: \         IF RC% = 1 THEN GOTO WRITE.ERROR                        ! HLC        !1.8NWB
9924: 0a40: \         CURR.SESS.NUM% = CIMF.SESS.NUM%                                      !1.8NWB
9925: 0a40: \         CURRENT.KEY$ = CIMF.BOOTS.CODE$                                      !1.8NWB
9926: 0a40: \         RC% = READ.CIMF.LOCK                              ! HLC              !1.8NWB
9927: 0a40: \         IF RC% = 1 THEN GOTO READ.ERROR                        ! HLC         !1.8NWB
9928: 0a40: \         CIMF.NUMITEM% = CIMF.NUMITEM% + ADJUST.PARENT.SALES%                 !1.8NWB
9929: 0a40: \         RC% = WRITE.CIMF.HOLD.UNLOCK                        ! HLC            !1.8NWB
9930: 0a40: \         IF RC% = 1 THEN GOTO WRITE.ERROR                        ! HLC        !1.8NWB
9931: 0a40: \         ADJUST.PARENT.SALES% = 0                                             !1.8NWB
9932: 0a40: \      ENDIF                                                                   !1.8NWB
9933: 0a40: \     ENDIF                                                                    !1.8NWB
9934: 0a40: 
9935: 0a40: \     CURR.SESS.NUM% = CSRWF.SESS.NUM%                                         !1.8NWB
9936: 0a40: \     CURRENT.KEY$ = ""                                                        !1.8NWB
9937: 0a40: \     CSRWF.RECORD.NO% = CSRWF.RECORD.NO% + 1                                  !1.8NWB
9938: 0a40: \     RC% = WRITE.CSRWF                                          ! HLC         !1.8NWB
9939: 0a40: \     IF RC% = 1 THEN GOTO WRITE.ERROR                              ! HLC      !1.8NWB
9940: 0a40: 
9941: 0a40: \  RETURN                                                                      !1.8NWB
9942: 0a40: 
9943: 0a40: \******************************************************************************
9944: 0a40: \***
9945: 0a40: \***   MOVE.CITEM.TO.WS:
9946: 0a40: \***
9947: 0a40: \***      save any values from CITEM which may alter in WS variables
9948: 0a40: \***
9949: 0a40: \***   RETURN
9950: 0a40: \***
9951: 0a40: \******************************************************************************
9952: 0a40: 
9953: 0a40: \  MOVE.CITEM.TO.WS:                                                           !1.8NWB
9954: 0a40: 
9955: 0a40: \     WS.TOTAL.ESA$ = CITEM.TOTAL.ESA$                                         !1.8NWB
9956: 0a40: \     WS.TOTAL.ON.ORDER$ = CITEM.TOTAL.ON.ORDER$                               !1.8NWB
9957: 0a40: \     WS.DATE.OF.LAST.MANUAL.COUNT$ = CITEM.DATE.OF.LAST.MANUAL.COUNT$         !1.8NWB
9958: 0a40: \     WS.SHELF.ALLOCATION$ = CITEM.SHELF.ALLOCATION$                           !1.8NWB
9959: 0a40: \     WS.UNIT$ = CITEM.UNIT$                                                   !1.8NWB
9960: 0a40: \     WS.LIST.FREQUENCY$ = CITEM.LIST.FREQUENCY$                               !1.8NWB
9961: 0a40: \     WS.SALES.SIGN.FLAG$ = CITEM.SALES.SIGN.FLAG$                   ! DPAB    !1.8NWB
9962: 0a40: \     WS.ON.ORDER.TODAY$ = CITEM.ON.ORDER.TODAY$                               !1.8NWB
9963: 0a40: \     WS.ON.ORDER.IN.THIS.PDT$ = CITEM.ON.ORDER.IN.THIS.PDT$                   !1.8NWB
9964: 0a40: \     WS.COUNT.REQUEST.FLAG$ = CITEM.COUNT.REQUEST.FLAG$            ! AGEF     !1.8NWB
9965: 0a40: \     WS.WEEK4.SALES$ = CITEM.WEEK.4.SALES$                        ! DPAB      !1.8NWB
9966: 0a40: 
9967: 0a40: \  RETURN                                                                      !1.8NWB
9968: 0a40: 
9969: 0a40: \******************************************************************************
9970: 0a40: \***
9971: 0a40: \***   MOVE.WS.TO.CITEM:
9972: 0a40: \***
9973: 0a40: \***      restore all WS values to CITEM
9974: 0a40: \***
9975: 0a40: \***   RETURN
9976: 0a40: \***
9977: 0a40: \******************************************************************************
9978: 0a40: 
9979: 0a40: \  MOVE.WS.TO.CITEM:                                                           !1.8NWB
9980: 0a40: 
9981: 0a40: \     CITEM.TOTAL.ESA$ = WS.TOTAL.ESA$                                         !1.8NWB
9982: 0a40: \     CITEM.TOTAL.ON.ORDER$ = WS.TOTAL.ON.ORDER$                               !1.8NWB
9983: 0a40: \     CITEM.DATE.OF.LAST.MANUAL.COUNT$ = WS.DATE.OF.LAST.MANUAL.COUNT$         !1.8NWB
9984: 0a40: \     CITEM.SHELF.ALLOCATION$ = WS.SHELF.ALLOCATION$                           !1.8NWB
9985: 0a40: \     CITEM.UNIT$ = WS.UNIT$                                                   !1.8NWB
9986: 0a40: \     CITEM.LIST.FREQUENCY$ = WS.LIST.FREQUENCY$                               !1.8NWB
9987: 0a40: \     CITEM.SALES.SIGN.FLAG$ = WS.SALES.SIGN.FLAG$                   ! DPAB    !1.8NWB
9988: 0a40: \     CITEM.ON.ORDER.TODAY$ = WS.ON.ORDER.TODAY$                               !1.8NWB
9989: 0a40: \     CITEM.ON.ORDER.IN.THIS.PDT$ = WS.ON.ORDER.IN.THIS.PDT$                   !1.8NWB
9990: 0a40: \     CITEM.COUNT.REQUEST.FLAG$ = WS.COUNT.REQUEST.FLAG$            ! AGEF     !1.8NWB
9991: 0a40: \     CITEM.WEEK.4.SALES$ = WS.WEEK4.SALES$                        ! DPAB      !1.8NWB
9992: 0a40: 
9993: 0a40: \  RETURN                                                                      !1.8NWB
9994: 0a40: 
9995: 0a40: \******************************************************************************
9996: 0a40: \***
9997: 0a40: \***   ABANDON.THIS.LIST:
9998: 0a40: \***
9999: 0a40: \***      sets all records for this list from the workfile to low values
10000: 0a40: \***      and resets the record pointer to overwrite them with the next list
10001: 0a40: \***      (if any - if not, the records of low values will be ignored when the
10002: 0a40: \***      workfile is processed)
10003: 0a40: \***      also decrement the "on order for this PDT" figure from CSRITEM
10004: 0a40: \***
10005: 0a40: \***   RETURN
10006: 0a40: \***
10007: 0a40: \******************************************************************************
10008: 0a40: 
10009: 0a40: \  ABANDON.THIS.LIST:                                                          !1.8NWB
10010: 0a40: 
10011: 0a40: 
10012: 0a40: \     LIST.ABANDONED$ = "Y"                                                    !1.8NWB
10013: 0a40: 
10014: 0a40: !      CSRWF.LIST.COUNT$ = RIGHT$("000" + STR$(VAL(CSRWF.LIST.COUNT$) - 1),3)
10015: 0a40: \     CSRWF.RECORD.NO% = CURRENT.HEADER.RECORD.NO%                             !1.8NWB
10016: 0a40: \     CURR.SESS.NUM% = CSRWF.SESS.NUM%                                         !1.8NWB
10017: 0a40: \     CURRENT.KEY$ = ""                                                        !1.8NWB
10018: 0a40: \     RC% = READ.CSRWF                                          ! HLC          !1.8NWB
10019: 0a40: \     IF RC% = 1 THEN GOTO READ.ERROR                              ! HLC       !1.8NWB
10020: 0a40: \     CSRWF.RECORD$ = PACK$(STRING$(48,"0"))                                   !1.8NWB
10021: 0a40: \     IF END #CSRWF.SESS.NUM% THEN WRITE.ERROR                                 !1.8NWB
10022: 0a40: \     WRITE FORM "C24"; #CSRWF.SESS.NUM%, CSRWF.RECORD.NO%; CSRWF.RECORD$      !1.8NWB
10023: 0a40: 
10024: 0a40: \     END.OF.CSRWF$ = "N"                                                      !1.8NWB
10025: 0a40: \     WHILE END.OF.CSRWF$ = "N"                                                !1.8NWB
10026: 0a40: \        CURR.SESS.NUM% = CSRWF.SESS.NUM%                                      !1.8NWB
10027: 0a40: \      CURRENT.KEY$ = ""                                                       !1.8NWB
10028: 0a40: \      RC% = READ.CSRWF                                    ! HLC               !1.8NWB
10029: 0a40: \      IF RC% = 1 THEN GOTO END.OF.CSRWF1                        ! HLC         !1.8NWB
10030: 0a40: \      IF CSRWF.RECORD$ = PACK$(STRING$(48," ")) THEN GOTO END.OF.CSRWF1       !1.8NWB
10031: 0a40: \      IF CSRWF.RECORD.TYPE$ = "XC" THEN BEGIN                                 !1.8NWB
10032: 0a40: \         CITEM.BOOTS.CODE$ = CSRWF.P.ITEM.CODE$                               !1.8NWB
10033: 0a40: \         CSRWF.QTY.1% = VAL(CSRWF.QTY.1$) +                         \         !1.8NWB
10034: 0a40: \                        VAL(CSRWF.QTY.2.IN.SINGLES$)                          !1.8NWB
10035: 0a40: \      ENDIF ELSE BEGIN                                                        !1.8NWB
10036: 0a40: \         CITEM.BOOTS.CODE$ = PACK$("0" + CSRWF.ITEM.CODE$)                    !1.8NWB
10037: 0a40: \         CSRWF.QTY.1% = VAL(CSRWF.QTY.1$)                                     !1.8NWB
10038: 0a40: \      ENDIF                                                                   !1.8NWB
10039: 0a40: \      CURR.SESS.NUM% = CITEM.SESS.NUM%                                        !1.8NWB
10040: 0a40: \      CURRENT.KEY$ = CITEM.BOOTS.CODE$                                        !1.8NWB
10041: 0a40: \      RC% = READ.CITEM.LOCK                                    ! HLC          !1.8NWB
10042: 0a40: \      IF RC% = 1 THEN GOTO READ.ERROR                        ! HLC            !1.8NWB
10043: 0a40: \      IF VAL(UNPACK$(CITEM.ON.ORDER.IN.THIS.PDT$)) >=            \            !1.8NWB
10044: 0a40: \                                   CSRWF.QTY.1% THEN BEGIN                    !1.8NWB
10045: 0a40: \           CITEM.ON.ORDER.IN.THIS.PDT$ = PACK$(RIGHT$("0000" +            \   !1.8NWB
10046: 0a40: \              STR$(VAL(UNPACK$(CITEM.ON.ORDER.IN.THIS.PDT$)) -            \   !1.8NWB
10047: 0a40: \            CSRWF.QTY.1%),4))                                                 !1.8NWB
10048: 0a40: \      ENDIF ELSE BEGIN                                                        !1.8NWB
10049: 0a40: \         CITEM.ON.ORDER.IN.THIS.PDT$ = PACK$("0000")                          !1.8NWB
10050: 0a40: \      ENDIF                                                                   !1.8NWB
10051: 0a40: \      RC% = WRITE.CITEM.UNLOCK                               ! HLC            !1.8NWB
10052: 0a40: \      IF RC% = 1 THEN GOTO WRITE.ERROR                        ! HLC           !1.8NWB
10053: 0a40: \      CURR.SESS.NUM% = CSRWF.SESS.NUM%                                        !1.8NWB
10054: 0a40: \      CURRENT.KEY$ = ""                                                       !1.8NWB
10055: 0a40: \        CSRWF.RECORD$ = PACK$(STRING$(48,"0"))                                !1.8NWB
10056: 0a40: \        IF END #CSRWF.SESS.NUM% THEN WRITE.ERROR                              !1.8NWB
10057: 0a40: \        WRITE FORM "C24"; #CSRWF.SESS.NUM%, CSRWF.RECORD.NO%; CSRWF.RECORD$   !1.8NWB
10058: 0a40: \     ABANDON.LIST.CONTINUE:                                                   !1.8NWB
10059: 0a40: \     WEND                                                                     !1.8NWB
10060: 0a40: 
10061: 0a40: \     CSRWF.RECORD.NO% = CURRENT.HEADER.RECORD.NO% - 1                         !1.8NWB
10062: 0a40: 
10063: 0a40: \  RETURN                                                                      !1.8NWB
10064: 0a40: 
10065: 0a40: \  END.OF.CSRWF1:                                                              !1.8NWB
10066: 0a40: \     END.OF.CSRWF$ = "Y"                                                      !1.8NWB
10067: 0a40: \  GOTO ABANDON.LIST.CONTINUE                                                  !1.8NWB
10068: 0a40: 
10069: 0a40: \******************************************************************************
10070: 0a40: \***
10071: 0a40: \***   PROCESS.CSR.WORKFILE:
10072: 0a40: \***
10073: 0a40: \***     at this point the PDT has indicated that it has received all the lists
10074: 0a40: \***     successfully, and the data in CSRWF can be used to update the
10075: 0a40: \***     files.
10076: 0a40: \***     if the DELETE flag is already set off then the file can be deleted.
10077: 0a40: \***     the DELETE flag on the first record of the file will be set off -
10078: 0a40: \***     ie. until the CSRWF has been successfully processed this file must
10079: 0a40: \***     not be deleted
10080: 0a40: \***     read through the file:
10081: 0a40: \***        "unprocess" any lists which require it
10082: 0a40: \***        update the ONORDER file and CSRITEM (on order totals) and
10083: 0a40: \***        the CSRIMF figure if this is a non-zero override order
10084: 0a40: \***     Because it is already too late to do anything about the lists, as
10085: 0a40: \***     they are already in the PDT, this file will not be checked for
10086: 0a40: \***     completeness; each record will be processed as best it can.
10087: 0a40: \***
10088: 0a40: \***   RETURN
10089: 0a40: \***
10090: 0a40: \******************************************************************************
10091: 0a40: 
10092: 0a40: \  PROCESS.CSR.WORKFILE:                                                       !1.8NWB
10093: 0a40: 
10094: 0a40: \     SB.MESSAGE$ = "PDT Support - CSR files being updated"                    !1.8NWB
10095: 0a40: \     GOSUB SB.BG.MESSAGE                                                      !1.8NWB
10096: 0a40: 
10097: 0a40: \     CURR.SESS.NUM% = CSRWF.SESS.NUM%                                         !1.8NWB
10098: 0a40: \     CURRENT.KEY$ = ""                                                        !1.8NWB
10099: 0a40: 
10100: 0a40: \     IF CSRWF.OPEN.FLAG$ <> "Y" THEN BEGIN                                    !1.8NWB
10101: 0a40: \        CURR.SESS.NUM% = CSRWF.SESS.NUM%                                      !1.8NWB
10102: 0a40: \        IF END #CSRWF.SESS.NUM% THEN OPEN.ERROR                               !1.8NWB
10103: 0a40: \        OPEN CSRWF.FILE.NAME$ DIRECT RECL CSRWF.RECL% AS CSRWF.SESS.NUM%      !1.8NWB
10104: 0a40: \        CSRWF.OPEN.FLAG$ = "Y"                                                !1.8NWB
10105: 0a40: \     ENDIF                                                                    !1.8NWB
10106: 0a40: 
10107: 0a40: \     CSRWF.RECORD.NO% = 1                                                     !1.8NWB
10108: 0a40: \     CURRENT.KEY$ = ""                                                        !1.8NWB
10109: 0a40: \     CURR.SESS.NUM% = CSRWF.SESS.NUM%                                         !1.8NWB
10110: 0a40: \     RC% = READ.CSRWF                                          ! HLC          !1.8NWB
10111: 0a40: \     IF RC% = 1 THEN GOTO READ.ERROR                              ! HLC       !1.8NWB
10112: 0a40: 
10113: 0a40: \     IF CSRWF.DELETE.FLAG$ = "Y" THEN BEGIN                                   !1.8NWB
10114: 0a40: \        CSRWF.OPEN.FLAG$ = "N"                                                !1.8NWB
10115: 0a40: \        IF END #CSRWF.SESS.NUM% THEN DELETE.ERROR                             !1.8NWB
10116: 0a40: \        DELETE CSRWF.SESS.NUM%                                                !1.8NWB
10117: 0a40: \      PROCESS.CSR.WORKFILE$ = "N"                                             !1.8NWB
10118: 0a40: \      RETURN                                                                  !1.8NWB
10119: 0a40: \     ENDIF                                                                    !1.8NWB
10120: 0a40: 
10121: 0a40: \     CSRWF.RECORD.NO% = CSRWF.RECORD.NO% + 1                                  !1.8NWB
10122: 0a40: \     CURRENT.KEY$ = ""                                                        !1.8NWB
10123: 0a40: \     CURR.SESS.NUM% = CSRWF.SESS.NUM%                                         !1.8NWB
10124: 0a40: \     RC% = READ.CSRWF                                           ! HLC         !1.8NWB
10125: 0a40: \     IF RC% = 1 THEN GOTO READ.ERROR                              ! HLC       !1.8NWB
10126: 0a40: 
10127: 0a40: \     PROCESSING.WORKFILE$ = "Y"                                               !1.8NWB
10128: 0a40: \     END.OF.CSRWF$ = "N"                                                      !1.8NWB
10129: 0a40: \     WHILE END.OF.CSRWF$ <> "Y"                                               !1.8NWB
10130: 0a40: \        IF CSRWF.RECORD.TYPE$ = "XH" THEN BEGIN                               !1.8NWB
10131: 0a40: \           FIRST.ITEM.TO.BE.PROCESSED$ = "Y"                                  !1.8NWB
10132: 0a40: \         IF CSRWF.UNPROCESS.FLAG$ = "Y" THEN      BEGIN                       !1.8NWB
10133: 0a40: \            GOSUB UNPROCESS.THIS.LIST                                         !1.8NWB
10134: 0a40: \         ENDIF                                                                !1.8NWB
10135: 0a40: \      ENDIF                                                                   !1.8NWB
10136: 0a40: \      IF CSRWF.RECORD.TYPE$ = "XC"                              \             !1.8NWB
10137: 0a40: \      OR CSRWF.RECORD.TYPE$ = "XO" THEN BEGIN                                 !1.8NWB
10138: 0a40: \         GOSUB SET.UP.ITEM.CODE                                               !1.8NWB
10139: 0a40: \         GOSUB UPDATE.CITEM                                                   !1.8NWB
10140: 0a40: \         IF CSRWF.CSRITEM.UPDATED.FLAG$ <> "Y" THEN BEGIN                     !1.8NWB
10141: 0a40: \               CSRWF.CSRITEM.UPDATED.FLAG$ = "Y"                              !1.8NWB
10142: 0a40: \            GOSUB UPDATE.CSRWF                                                !1.8NWB
10143: 0a40: \         ENDIF                                                                !1.8NWB
10144: 0a40: \         GOSUB UPDATE.ONORDER                                                 !1.8NWB
10145: 0a40: \         IF CSRWF.ONORDER.UPDATED.FLAG$ <> "Y" THEN BEGIN                     !1.8NWB
10146: 0a40: \            CSRWF.ONORDER.UPDATED.FLAG$ = "Y"                                 !1.8NWB
10147: 0a40: \            GOSUB UPDATE.CSRWF                                                !1.8NWB
10148: 0a40: \         ENDIF                                                                !1.8NWB
10149: 0a40: \      ENDIF                                                                   !1.8NWB
10150: 0a40: \  NEXT.ITEM:                                                                  !1.8NWB
10151: 0a40: \      CSRWF.RECORD.NO% = CSRWF.RECORD.NO% + 1                                 !1.8NWB
10152: 0a40: \      CURR.SESS.NUM% = CSRWF.SESS.NUM%                                        !1.8NWB
10153: 0a40: \      CURRENT.KEY$ = ""                                                       !1.8NWB
10154: 0a40: \      RC% = READ.CSRWF                                    ! HLC               !1.8NWB
10155: 0a40: \      IF RC% = 1 THEN GOTO END.OF.CSRWF                        ! HLC          !1.8NWB
10156: 0a40: \     PROCESS.CSRWF.CONTINUE:                                                  !1.8NWB
10157: 0a40: \     WEND                                                                     !1.8NWB
10158: 0a40: \     PROCESSING.WORKFILE$ = "N"                                               !1.8NWB
10159: 0a40: 
10160: 0a40: \     CSRWF.RECORD.NO% = 1                                                     !1.8NWB
10161: 0a40: \     CSRWF.DELETE.FLAG$ = "Y"                                                 !1.8NWB
10162: 0a40: \     CURR.SESS.NUM% = CSRWF.SESS.NUM%                                         !1.8NWB
10163: 0a40: \     CURRENT.KEY$ = ""                                                        !1.8NWB
10164: 0a40: \     RC% = WRITE.CSRWF                                          ! HLC         !1.8NWB
10165: 0a40: \     IF RC% = 1 THEN GOTO WRITE.ERROR                              ! HLC      !1.8NWB
10166: 0a40: 
10167: 0a40: !      IF END #CSRWF.SESS.NUM% THEN DELETE.ERROR                  ! ASW
10168: 0a40: !      DELETE CSRWF.SESS.NUM%                                    ! ASW
10169: 0a40: !      CSRWF.OPEN.FLAG$ = "N"                                    ! ASW
10170: 0a40: \     PROCESS.CSR.WORKFILE$ = "N"                                              !1.8NWB
10171: 0a40: 
10172: 0a40: \     CLOSE IDF.SESS.NUM%                                                      !1.8NWB
10173: 0a40: \     IDF.OPEN.FLAG$ = "N"                                                     !1.8NWB
10174: 0a40: \     CLOSE CITEM.SESS.NUM%                                                    !1.8NWB
10175: 0a40: \     CITEM.OPEN.FLAG$ = "N"                                                   !1.8NWB
10176: 0a40: \     CLOSE CIMF.SESS.NUM%                                                     !1.8NWB
10177: 0a40: \     CIMF.OPEN.FLAG$ = "N"                                                    !1.8NWB
10178: 0a40: \     CLOSE ONORD.SESS.NUM%                                                    !1.8NWB
10179: 0a40: \     ONORD.OPEN.FLAG$ = "N"                                                   !1.8NWB
10180: 0a40: \     CLOSE FPF.SESS.NUM%                                                      !1.8NWB
10181: 0a40: \     FPF.OPEN.FLAG$ = "N"                                                     !1.8NWB
10182: 0a40: \     CLOSE IDSOF.SESS.NUM%                                    ! ILC           !1.8NWB
10183: 0a40: \     IDSOF.OPEN.FLAG$ = "N"                                    ! ILC          !1.8NWB
10184: 0a40: 
10185: 0a40: \     PROCESS.CSR.WORKFILE$ = "N"                                              !1.8NWB
10186: 0a40: 
10187: 0a40: \  RETURN                                                                      !1.8NWB
10188: 0a40: 
10189: 0a40: \  END.OF.CSRWF:                                                               !1.8NWB
10190: 0a40: \     END.OF.CSRWF$ = "Y"                                                      !1.8NWB
10191: 0a40: \  GOTO PROCESS.CSRWF.CONTINUE                                                 !1.8NWB
10192: 0a40: 
10193: 0a40: \******************************************************************************
10194: 0a40: \***
10195: 0a40: \***   SET.UP.ITEM.CODE:
10196: 0a40: \***
10197: 0a40: \***      set up the CITEM item code from data on the record from CSRWF,
10198: 0a40: \***      according to the record type
10199: 0a40: \***
10200: 0a40: \***   RETURN
10201: 0a40: \***
10202: 0a40: \******************************************************************************
10203: 0a40: 
10204: 0a40: \  SET.UP.ITEM.CODE:                                                           !1.8NWB
10205: 0a40: 
10206: 0a40: \     IF LEFT$(CSRWF.RECORD$,2) = "XO" THEN BEGIN                              !1.8NWB
10207: 0a40: \        CITEM.BOOTS.CODE$ = PACK$("0" + CSRWF.ITEM.CODE$)                     !1.8NWB
10208: 0a40: \     ENDIF ELSE BEGIN                                                         !1.8NWB
10209: 0a40: \        CITEM.BOOTS.CODE$ = CSRWF.P.ITEM.CODE$                                !1.8NWB
10210: 0a40: \     ENDIF                                                                    !1.8NWB
10211: 0a40: 
10212: 0a40: \  RETURN                                                                      !1.8NWB
10213: 0a40: 
10214: 0a40: \******************************************************************************
10215: 0a40: \***
10216: 0a40: \***   UNPROCESS.THIS.LIST:
10217: 0a40: \***
10218: 0a40: \***      from the header record on ONORDER for this list, save the highest
10219: 0a40: \***      sequence number used.
10220: 0a40: \***      for each record ONORDER for this list,
10221: 0a40: \***         decrement the onorder totals (today and total) on CSRITEM
10222: 0a40: \***         delete the ONORDER record
10223: 0a40: \***      delete the header record and set the CSRWF unprocess flag off
10224: 0a40: \***
10225: 0a40: \***   RETURN
10226: 0a40: \***
10227: 0a40: \******************************************************************************
10228: 0a40: 
10229: 0a40: \  UNPROCESS.THIS.LIST:                                                        !1.8NWB
10230: 0a40: 
10231: 0a40: \     LOCATION$ = "UNPROC"                                                     !1.8NWB
10232: 0a40: \     ONORD.ORDER.DATE$ = CSRWF.ORDER.DATE$                                    !1.8NWB
10233: 0a40: \     ONORD.LIST.FREQ$ = CSRWF.LIST.FREQ$                                      !1.8NWB
10234: 0a40: \     ONORD.UNIT.NO$ = CSRWF.UNIT.NO$                                          !1.8NWB
10235: 0a40: \     ONORD.SEQ.NO$ = "000"                                                    !1.8NWB
10236: 0a40: \     PART.KEY$ = ONORD.ORDER.DATE$ +                              \           !1.8NWB
10237: 0a40: \                   ONORD.LIST.FREQ$ +                              \          !1.8NWB
10238: 0a40: \               ONORD.UNIT.NO$                                                 !1.8NWB
10239: 0a40: \     CURR.SESS.NUM% = ONORD.SESS.NUM%                                         !1.8NWB
10240: 0a40: \     CURRENT.KEY$ = PART.KEY$ + ONORD.SEQ.NO$                                 !1.8NWB
10241: 0a40: \     RC% = READ.ONORDER                                    ! HLC              !1.8NWB
10242: 0a40: \     IF RC% = 1 THEN GOTO READ.ERROR                              ! HLC       !1.8NWB
10243: 0a40: \                                                                              !1.8NWB
10244: 0a40: \     FOR I% = 1 TO VAL(ONORD.HIGHEST.SEQ.NO$)                                 !1.8NWB
10245: 0a40: \        ONORD.SEQ.NO$ = RIGHT$("000" + STR$(I%),3)                            !1.8NWB
10246: 0a40: \      CURRENT.KEY$ = PART.KEY$ + ONORD.SEQ.NO$                                !1.8NWB
10247: 0a40: \      RC% = READ.ONORDER                                    ! HLC             !1.8NWB
10248: 0a40: \      IF RC% = 1 THEN GOTO READ.ERROR                        ! HLC            !1.8NWB
10249: 0a40: \      IF ONORD.CSRITEM.UNDONE.FLAG$ = "N" THEN BEGIN                          !1.8NWB
10250: 0a40: \         ONORD.CSRITEM.UNDONE.FLAG$ = "Y"                                     !1.8NWB
10251: 0a40: \         RC% = WRITE.ONORDER.HOLD                              ! HLC          !1.8NWB
10252: 0a40: \         IF RC% = 1 THEN GOTO WRITE.ERROR                        ! HLC        !1.8NWB
10253: 0a40: \         GOSUB UNDO.CSRITEM                                                   !1.8NWB
10254: 0a40: \      ENDIF                                                                   !1.8NWB
10255: 0a40: \      CURRENT.KEY$ = PART.KEY$ + ONORD.SEQ.NO$                                !1.8NWB
10256: 0a40: \      IF END #ONORD.SESS.NUM% THEN DELETE.ERROR                               !1.8NWB
10257: 0a40: \            DELREC ONORD.SESS.NUM%; PART.KEY$ + ONORD.SEQ.NO$                 !1.8NWB
10258: 0a40: \  UNPROCESS.LIST.CONTINUE:                                                    !1.8NWB
10259: 0a40: \     NEXT I%                                                                  !1.8NWB
10260: 0a40: \     CURRENT.KEY$ = PART.KEY$ + "000"                                         !1.8NWB
10261: 0a40: \     IF END #ONORD.SESS.NUM% THEN DELETE.ERROR                                !1.8NWB
10262: 0a40: \     DELREC ONORD.SESS.NUM%; PART.KEY$ + "000"                                !1.8NWB
10263: 0a40: \     CSRWF.UNPROCESS.FLAG$ = "N"                                              !1.8NWB
10264: 0a40: \     CURR.SESS.NUM% = CSRWF.SESS.NUM%                                         !1.8NWB
10265: 0a40: \     CURRENT.KEY$ = ""                                                        !1.8NWB
10266: 0a40: \     RC% = WRITE.CSRWF                                          ! HLC         !1.8NWB
10267: 0a40: \     IF RC% = 1 THEN GOTO WRITE.ERROR                              ! HLC      !1.8NWB
10268: 0a40: \     LOCATION$ = ""                                                           !1.8NWB
10269: 0a40: 
10270: 0a40: \  RETURN                                                                      !1.8NWB
10271: 0a40: 
10272: 0a40: \******************************************************************************
10273: 0a40: \***
10274: 0a40: \***   UNDO.CSRITEM:
10275: 0a40: \***
10276: 0a40: \***      decrement on order total and on order today by the amount
10277: 0a40: \***      originally ordered
10278: 0a40: \***
10279: 0a40: \***   RETURN
10280: 0a40: \***
10281: 0a40: \******************************************************************************
10282: 0a40: 
10283: 0a40: \  UNDO.CSRITEM:                                                               !1.8NWB
10284: 0a40: 
10285: 0a40: \     CITEM.BOOTS.CODE$ = PACK$("0" + ONORD.ITEM.CODE$)                        !1.8NWB
10286: 0a40: \     CURRENT.KEY$ = CITEM.BOOTS.CODE$                                         !1.8NWB
10287: 0a40: \     CURR.SESS.NUM% = CITEM.SESS.NUM%                                         !1.8NWB
10288: 0a40: \     RC% = READ.CITEM.LOCK                                    ! HLC           !1.8NWB
10289: 0a40: \     IF RC% = 1 THEN GOTO READ.ERROR                              ! HLC       !1.8NWB
10290: 0a40: 
10291: 0a40: \     TEMP% = VAL(UNPACK$(CITEM.ON.ORDER.TODAY$))                              !1.8NWB
10292: 0a40: \     TEMP% = TEMP% - VAL(ONORD.QTY.1$)                                        !1.8NWB
10293: 0a40: \     CITEM.ON.ORDER.TODAY$ = PACK$(RIGHT$("0000" + STR$(TEMP%),4))            !1.8NWB
10294: 0a40: 
10295: 0a40: \     RC% = WRITE.CITEM.HOLD.UNLOCK                              ! HLC         !1.8NWB
10296: 0a40: \     IF RC% = 1 THEN GOTO WRITE.ERROR                              ! HLC      !1.8NWB
10297: 0a40: 
10298: 0a40: \  UNDO.CSRITEM.CONTINUE:                                    ! BPAB            !1.8NWB
10299: 0a40: 
10300: 0a40: \  RETURN                                                                      !1.8NWB
10301: 0a40: 
10302: 0a40: \******************************************************************************
10303: 0a40: \***
10304: 0a40: \***   UPDATE.CITEM:
10305: 0a40: \***
10306: 0a40: \***     decrement the onorder in this PDT figure (but not below 0)
10307: 0a40: \***     increment on order today and on order total by the amount ordered
10308: 0a40: \***
10309: 0a40: \***   RETURN
10310: 0a40: \***
10311: 0a40: \******************************************************************************
10312: 0a40: 
10313: 0a40: \  UPDATE.CITEM:                                                               !1.8NWB
10314: 0a40: 
10315: 0a40: \     IF CSRWF.CSRITEM.UPDATED.FLAG$ = "Y" THEN RETURN                         !1.8NWB
10316: 0a40: 
10317: 0a40: \     CURRENT.KEY$ = CITEM.BOOTS.CODE$                                         !1.8NWB
10318: 0a40: \     CURR.SESS.NUM% = CITEM.SESS.NUM%                                         !1.8NWB
10319: 0a40: \     RC% = READ.CITEM.LOCK                                    ! HLC           !1.8NWB
10320: 0a40: \     IF RC% = 1 THEN GOTO NOT.ON.CITEM                              ! HLC     !1.8NWB
10321: 0a40: 
10322: 0a40: \     QTY% = VAL(CSRWF.QTY.1$) + VAL(CSRWF.QTY.2.IN.SINGLES$)                  !1.8NWB
10323: 0a40: \     CITEM.ON.ORDER.IN.THIS.PDT$ = PACK$("0000")                              !1.8NWB
10324: 0a40: 
10325: 0a40: \     TEMP% = VAL(UNPACK$(CITEM.ON.ORDER.TODAY$)) + QTY%                       !1.8NWB
10326: 0a40: \     CITEM.ON.ORDER.TODAY$ = PACK$(RIGHT$("0000" + STR$(TEMP%), 4))      ! DSW!1.8NWB
10327: 0a40: 
10328: 0a40: \     TEMP% = VAL(UNPACK$(CITEM.TOTAL.ON.ORDER$)) + QTY%                       !1.8NWB
10329: 0a40: \     CITEM.TOTAL.ON.ORDER$ = PACK$(RIGHT$("0000" + STR$(TEMP%), 4))      ! DSW!1.8NWB
10330: 0a40: 
10331: 0a40: \     CURR.SESS.NUM% = CITEM.SESS.NUM%                                         !1.8NWB
10332: 0a40: \     CURRENT.KEY$ = CITEM.BOOTS.CODE$                                         !1.8NWB
10333: 0a40: \     RC% = WRITE.CITEM.HOLD.UNLOCK                              ! HLC         !1.8NWB
10334: 0a40: \     IF RC% = 1 THEN GOTO WRITE.ERROR                              ! HLC      !1.8NWB
10335: 0a40: 
10336: 0a40: \  NOT.ON.CITEM.RETURN:                                                        !1.8NWB
10337: 0a40: \  RETURN                                                                      !1.8NWB
10338: 0a40: 
10339: 0a40: \  NOT.ON.CITEM:                                                               !1.8NWB
10340: 0a40: \     CSRWF.CSRITEM.UPDATED.FLAG$ = "Y"                                        !1.8NWB
10341: 0a40: \  GOTO NOT.ON.CITEM.RETURN                                                    !1.8NWB
10342: 0a40: 
10343: 0a40: \******************************************************************************
10344: 0a40: \***
10345: 0a40: \***   UPDATE.CSRWF:
10346: 0a40: \***
10347: 0a40: \***   RETURN
10348: 0a40: \***
10349: 0a40: \******************************************************************************
10350: 0a40: 
10351: 0a40: \  UPDATE.CSRWF:                                                               !1.8NWB
10352: 0a40: 
10353: 0a40: \     CURR.SESS.NUM% = CSRWF.SESS.NUM%                                         !1.8NWB
10354: 0a40: \     CURRENT.KEY$ = ""                                                        !1.8NWB
10355: 0a40: \     RC% = WRITE.CSRWF.HOLD                                    ! HLC          !1.8NWB
10356: 0a40: \     IF RC% = 1 THEN GOTO WRITE.ERROR                              ! HLC      !1.8NWB
10357: 0a40: 
10358: 0a40: \  RETURN                                                                      !1.8NWB
10359: 0a40: 
10360: 0a40: \******************************************************************************
10361: 0a40: \***
10362: 0a40: \***   UPDATE.ONORDER:
10363: 0a40: \***
10364: 0a40: \***   RETURN
10365: 0a40: \***
10366: 0a40: \******************************************************************************
10367: 0a40: 
10368: 0a40: \  UPDATE.ONORDER:                                                             !1.8NWB
10369: 0a40: 
10370: 0a40: \     IF FIRST.ITEM.TO.BE.PROCESSED$ = "Y" THEN BEGIN                          !1.8NWB
10371: 0a40: \        FIRST.ITEM.TO.BE.PROCESSED$ = "N"                                     !1.8NWB
10372: 0a40: \        ONORD.ORDER.DATE$ = CSRWF.ORDER.DATE$                                 !1.8NWB
10373: 0a40: \        ONORD.LIST.FREQ$ = CSRWF.LIST.FREQ$                                   !1.8NWB
10374: 0a40: \        ONORD.UNIT.NO$ = CSRWF.UNIT.NO$                                       !1.8NWB
10375: 0a40: \        ONORD.SEQ.NO$ = "000"                                                 !1.8NWB
10376: 0a40: \      PART.KEY$ = DATE$ + ONORD.LIST.FREQ$ +                          \       !1.8NWB
10377: 0a40: \                           ONORD.UNIT.NO$                                     !1.8NWB
10378: 0a40: \        ONORD.SEQ.NO% = 0                                                     !1.8NWB
10379: 0a40: \     ENDIF                                                                    !1.8NWB
10380: 0a40: 
10381: 0a40: \     ONORD.SEQ.NO% = ONORD.SEQ.NO% + 1                                        !1.8NWB
10382: 0a40: \     ONORD.SEQ.NO$ = RIGHT$("000" + STR$(ONORD.SEQ.NO%),3)                    !1.8NWB
10383: 0a40: 
10384: 0a40: \     IF CSRWF.HD.ONORDER.UPDATED.FLAG$ = "Y"                        \ BGEF    !1.8NWB
10385: 0a40: \     OR CSRWF.ONORDER.UPDATED.FLAG$ = "Y" THEN RETURN                  ! BGEF !1.8NWB
10386: 0a40: 
10387: 0a40: \     GOSUB SET.UP.ITEM.CODE                                                   !1.8NWB
10388: 0a40: \     ONORD.ITEM.CODE$ = RIGHT$(UNPACK$(CITEM.BOOTS.CODE$),7)                  !1.8NWB
10389: 0a40: \     ONORD.QTY.1$ = CSRWF.QTY.1$                                              !1.8NWB
10390: 0a40: \     ONORD.QTY.2$ = CSRWF.QTY.2$                                              !1.8NWB
10391: 0a40: \     ONORD.CSRITEM.UNDONE.FLAG$ = "N"                                         !1.8NWB
10392: 0a40: \     IF RECORD.TYPE$ = "OVERRIDE"                              \              !1.8NWB
10393: 0a40: \     AND CSRWF.ZERO.OVERRIDE.FLAG$ = "N" THEN BEGIN                           !1.8NWB
10394: 0a40: \        ONORD.CSRIMF.UNDONE.FLAG$ = "N"                                       !1.8NWB
10395: 0a40: \     ENDIF ELSE BEGIN                                                         !1.8NWB
10396: 0a40: \        ONORD.CSRIMF.UNDONE.FLAG$ = "Y"                                       !1.8NWB
10397: 0a40: \     ENDIF                                                                    !1.8NWB
10398: 0a40: \     ONORD.DELETED.FLAG$ = "N"                                                !1.8NWB
10399: 0a40: \     CURR.SESS.NUM% = ONORD.SESS.NUM%                                         !1.8NWB
10400: 0a40: \     CURRENT.KEY$ = PART.KEY$ + ONORD.SEQ.NO$                                 !1.8NWB
10401: 0a40: \     RC% = WRITE.ONORDER                                      ! HLC           !1.8NWB
10402: 0a40: \     IF RC% = 1 THEN GOTO WRITE.ERROR                              ! HLC      !1.8NWB
10403: 0a40: 
10404: 0a40: \     ONORD.HIGHEST.SEQ.NO$ = RIGHT$("000" + STR$(ONORD.SEQ.NO%),3)            !1.8NWB
10405: 0a40: \     ONORD.SEQ.NO$ = "000"                                                    !1.8NWB
10406: 0a40: \     CURRENT.KEY$ = PART.KEY$ + ONORD.SEQ.NO$                                 !1.8NWB
10407: 0a40: \     RC% = WRITE.ONORDER.HOLD                                    ! HLC        !1.8NWB
10408: 0a40: \     IF RC% = 1 THEN GOTO WRITE.ERROR                              ! HLC      !1.8NWB
10409: 0a40: 
10410: 0a40: \  RETURN                                                                      !1.8NWB
10411: 0a40: 
10412: 0a40: \******************************************************************************
10413: 0a40: \******************************************************************************
10414: 0a40: \***
10415: 0a40: \***   P R I C E C H E C K I N G     S U B R O U T I N E S
10416: 0a40: \***
10417: 0a40: \******************************************************************************
10418: 0a40: \******************************************************************************
10419: 0a40: 
10420: 0a40: \******************************************************************************
10421: 0a40: \***
10422: 0a40: \***   RECEIVED.PCHECK.HEADER:                            STATE : O
10423: 0a40: \***
10424: 0a40: \***      if received data is not valid then set the RECEIVE.STATE$ to "*" and
10425: 0a40: \***      return
10426: 0a40: \***
10427: 0a40: \***      open CHKBF file and append data if it exists, otherwise create CHKBF
10428: 0a40: \***
10429: 0a40: \***   RETURN
10430: 0a40: \***
10431: 0a40: \******************************************************************************
10432: 0a40: 
10433: 0a40:    RECEIVED.PCHECK.HEADER:
10434: 0a50: 
10435: 0a50:       SB.MESSAGE$ = "PDT Support - PCHECK header received"
10436: 0a65:       GOSUB SB.BG.MESSAGE
10437: 0a77: 
10438: 0a77:       IF FN.VALIDATE.DATA(DATA.IN$, 16) = 0 THEN BEGIN
10439: 0a99:          RECEIVE.STATE$ = "*"                                           ! GDS
10440: 0ab0:          RETURN
10441: 0ac0:       ENDIF
10442: 0ac8: 
10443: 0ac8:       IF GAPBF.OPEN.FLAG$ <> "Y" THEN BEGIN                             ! 1.3 !1.7BG
10444: 0ae9:          CURR.SESS.NUM% = GAPBF.SESS.NUM%                               ! 1.3 !1.7BG
10445: 0afb:          IF END #GAPBF.SESS.NUM% THEN CREATE.GAPBF                      ! 1.3 !1.7BG
10446: 0b19:          OPEN GAPBF.FILE.NAME$ AS GAPBF.SESS.NUM% APPEND                ! 1.3 !1.7BG
10447: 0b42:          GOTO GAPBF.OPENED.OK                                           ! 1.3 !1.7BG
10448: 0b4c:          CREATE.GAPBF:                                                  ! 1.3 !1.7BG
10449: 0b5c:          IF END #GAPBF.SESS.NUM% THEN CREATE.ERROR                      ! 1.3 !1.7BG
10450: 0b7a:          CREATE GAPBF.FILE.NAME$ AS GAPBF.SESS.NUM%                     ! 1.3 !1.7BG
10451: 0ba3:          GAPBF.OPENED.OK:                                               ! 1.3 !1.7BG
10452: 0bb3:          GAPBF.OPEN.FLAG$ = "Y"                                         ! 1.3 !1.7BG
10453: 0bca:          ALL.FILES.CLOSED$ = "N"                                        ! 1.3 !1.7BG
10454: 0be1:       ENDIF                                                                   !1.7BG
10455: 0be9: 
10456: 0be9:                                                                             !1.5CS
10457: 0be9:       BTSCNT% = 0                                                           !1.5CS
10458: 0bfa:       EANCNT% = 0                                                           !1.5CS
10459: 0c0b: 
10460: 0c0b:       IF IRF.OPEN.FLAG$ <> "Y" THEN BEGIN                                   !1.5CS
10461: 0c29:          CURR.SESS.NUM% = IRF.SESS.NUM%                                     !1.5CS
10462: 0c3b:          IF END #IRF.SESS.NUM% THEN OPEN.ERROR                              !1.5CS
10463: 0c57:          OPEN IRF.FILE.NAME$ KEYED RECL IRF.RECL% AS IRF.SESS.NUM%          \1.5CS
10464: 0c84:               NOWRITE NODEL                                                 !1.5CS
10465: 0c84:          IRF.OPEN.FLAG$ = "Y"                                               !1.5CS
10466: 0c9b:       ENDIF                                                                 !1.5CS
10467: 0ca3:                                                                             !1.5CS
10468: 0ca3:       IF PLLOL.OPEN.FLAG$ <> "Y" THEN BEGIN                                 !1.5CS
10469: 0cc4:          CURR.SESS.NUM% = PLLOL.SESS.NUM%                                   !1.5CS
10470: 0cd6:          IF END # PLLOL.SESS.NUM% THEN CREATE.PLLOL                         !1.5CS
10471: 0cf2:          OPEN PLLOL.FILE.NAME$ DIRECT RECL PLLOL.RECL% AS PLLOL.SESS.NUM% NODEL    !1.5CS
10472: 0d21:          GOTO PLLOL.OPENED.OK                                               !1.5CS
10473: 0d2c:                                                                             !1.5CS
10474: 0d2c:        CREATE.PLLOL:                                                        !1.5CS
10475: 0d3c:        !------------                                                        !1.5CS
10476: 0d3c:          IF END #PLLOL.SESS.NUM% THEN CREATE.ERROR                          !1.5CS
10477: 0d58:          CREATE POSFILE "PLLOL" DIRECT 0 RECL 34 AS PLLOL.SESS.NUM% MIRRORED PERUPDATE !1.5CS
10478: 0d7d:          CLOSE PLLOL.SESS.NUM%                                              !1.5CS
10479: 0d91:          OPEN "PLLOL" DIRECT RECL 34 AS PLLOL.SESS.NUM%                     !1.5CS
10480: 0db1:          PLLOL.RECORD.NUM% = 1                                              !1.5CS
10481: 0dc8:          PLLOL.LISTID$          = "000"                                     !1.5CS
10482: 0ddf:          PLLOL.CREATOR.ID$      = "   "                                     !1.5CS
10483: 0df6:          PLLOL.PICKER.ID$       = "   "                                     !1.5CS
10484: 0e0d:          PLLOL.ITEM.STATUS$     = " "                                       !1.5CS
10485: 0e24:          PLLOL.CREATE.DATE$     = DATE$                                     !1.5CS
10486: 0e3c:          PLLOL.CREATE.TIME$     = LEFT$(TIME$,4)                            !1.5CS
10487: 0e68:          PLLOL.PICK.START.TIME$ = "    "                                    !1.5CS
10488: 0e7f:          PLLOL.PICK.END.TIME$   = "    "                                    !1.5CS
10489: 0e96:          PLLOL.ITEM.COUNT$      = "    "                                    !1.5CS
10490: 0ead:          PLLOL.OSSR.PICKING$    = " "                                       !1.5CS
10491: 0ec4:                                                                             !1.5CS
10492: 0ec4:          RC% = WRITE.PLLOL                                                  !1.5CS
10493: 0ed8:          IF RC% = 1 THEN GOTO WRITE.ERROR                                   !1.5CS
10494: 0eed:                                                                             !1.5CS
10495: 0eed:        PLLOL.OPENED.OK:                                                     !1.5CS
10496: 0efd:        !---------------                                                     !1.5CS
10497: 0efd:          PLLOL.OPEN.FLAG$ = "Y"                                             !1.5CS
10498: 0f14:          IF PLLDB.OPEN.FLAG$ <> "Y" THEN BEGIN                              !1.5CS
10499: 0f35:              CURR.SESS.NUM% = PLLDB.SESS.NUM%                               !1.5CS
10500: 0f47:              IF END # PLLDB.SESS.NUM% THEN CREATE.PLLDB                     !1.5CS
10501: 0f63: !             OPEN "PLLDB" KEYED RECL 164 AS PLLDB.SESS.NUM% NODEL           !1.5CS 1.8PJS !1.10TT
10502: 0f63: !             OPEN "PLLDB" KEYED RECL 384 AS PLLDB.SESS.NUM% NODEL           !1.10TT !1.11TT
10503: 0f63:              OPEN PLLDB.FILE.NAME$ KEYED RECL PLLDB.RECL% AS                \1.11TT
10504: 0f90:                               PLLDB.SESS.NUM% NODEL                         !1.11TT
10505: 0f90:              GOTO PLLDB.OPENED.OK                                           !1.5CS
10506: 0f9a:                                                                             !1.5CS
10507: 0f9a:            CREATE.PLLDB:                                                    !1.5CS
10508: 0faa:            !------------                                                    !1.5CS
10509: 0faa:              IF END #PLLDB.SESS.NUM% THEN CREATE.ERROR                      !1.5CS
10510: 0fc6: !             CREATE POSFILE "PLLDB" KEYED 6,553,4,10000 RECL 164 AS PLLDB.SESS.NUM% MIRRORED PERUPDATE  !1.5CS 1.8PJS ! 1.11TT
10511: 0fc6:              CREATE POSFILE PLLDB.FILE.NAME$ KEYED 6,,,16000 \               1.11TT
10512: 0ffd:                    RECL PLLDB.RECL% AS PLLDB.SESS.NUM% MIRRORED PERUPDATE   !1.11TT
10513: 0ffd:          ENDIF                                                              !1.5CS
10514: 1005:                                                                             !1.5CS
10515: 1005:        PLLDB.OPENED.OK:                                                     !1.5CS
10516: 1018:        !--------------                                                      !1.5CS
10517: 1018:       ENDIF ELSE BEGIN                                                  ! 1.3
10518: 1020:          IF PCHK.OPEN.FLAG$ = "Y" THEN BEGIN                            ! 1.3
10519: 103e:             CLOSE PCHK.SESS.NUM%                                        ! 1.3
10520: 1052:             PCHK.OPEN.FLAG$ = "N"                                       ! 1.3
10521: 1069:          ENDIF                                                          ! 1.3
10522: 1071:          RECEIVE.STATE$ = "*"                                           ! 1.3
10523: 1088:          RETURN                                                         ! 1.3
10524: 1098:       ENDIF                                                             ! 1.3
10525: 10a0: 
10526: 10a0:       SMON.NEW.LIST.CREATED = FALSE                                     !1.5CS
10527: 10b2: 
10528: 10b2:       IF CHKBF.OPEN.FLAG$ <> "Y" THEN BEGIN
10529: 10d3:          CURR.SESS.NUM% = CHKBF.SESS.NUM%
10530: 10e5:          IF END #CHKBF.SESS.NUM% THEN CREATE.CHKBF
10531: 1103:          OPEN CHKBF.FILE.NAME$ DIRECT RECL CHKBF.RECL%                  \ HLC
10532: 1131:             AS CHKBF.SESS.NUM%                                          ! HLC
10533: 1131:          CHKBF.POINTER% = (SIZE(CHKBF.FILE.NAME$) / CHKBF.RECL%) + 1    ! HLC
10534: 116d:          GOTO CHKBF.OPENED.OK                                           ! HLC
10535: 1177:          CREATE.CHKBF:                                                  ! HLC
10536: 1187:          IF END #CHKBF.SESS.NUM% THEN CREATE.ERROR
10537: 11a5:          CREATE CHKBF.FILE.NAME$ DIRECT RECL CHKBF.RECL%                \
10538: 11d3:             AS CHKBF.SESS.NUM%
10539: 11d3:          CHKBF.POINTER% = 1                                             ! HLC
10540: 11ea:          CHKBF.OPENED.OK:                                               ! HLC
10541: 11fa:          CHKBF.OPEN.FLAG$ = "Y"
10542: 1211:          ALL.FILES.CLOSED$ = "N"
10543: 122a:       ENDIF ELSE BEGIN
10544: 1232:          IF PCHK.OPEN.FLAG$ = "Y" THEN BEGIN
10545: 1250:             CLOSE PCHK.SESS.NUM%
10546: 1264:             PCHK.OPEN.FLAG$ = "N"
10547: 127b:          ENDIF
10548: 1283:          RECEIVE.STATE$ = "*"                                           ! GDS
10549: 129a:       ENDIF
10550: 12a2: 
10551: 12a2:    RETURN
10552: 12b2: 
10553: 12b2: \******************************************************************************
10554: 12b2: \***
10555: 12b2: \***   RECEIVED.PCHECK.RECORD:                              STATE : P
10556: 12b2: \***
10557: 12b2: \***      if received data is not valid then set the RECEIVE.STATE$ to "*" and
10558: 12b2: \***      return
10559: 12b2: \***
10560: 12b2: \***      check CHKBF file is open, if ok...
10561: 12b2: \***      ...write a record to the CHKBF file for each record received
10562: 12b2: \***
10563: 12b2: \***   RETURN
10564: 12b2: \***
10565: 12b2: \******************************************************************************
10566: 12b2: 
10567: 12b2:    RECEIVED.PCHECK.RECORD:
10568: 12c2: 
10569: 12c2:       SB.MESSAGE$ = "PDT Support - PCHECK record received"
10570: 12d7:       GOSUB SB.BG.MESSAGE
10571: 12e9: 
10572: 12e9:       IF LEN(DATA.IN$) = 21 THEN BEGIN                                        !1.7BG
10573: 1307:          !Check against old style record layout                               !1.7BG
10574: 1307:          IF FN.VALIDATE.DATA(DATA.IN$, 17) = 0 THEN BEGIN
10575: 1329:                RECEIVE.STATE$ = "*"                                           ! GDS
10576: 1340:                RETURN
10577: 1350:          ENDIF
10578: 1358:          OLD.PCHECK.RECORD% = TRUE                                            !1.7BG
10579: 136c:       ENDIF ELSE BEGIN                                                        !1.7BG
10580: 1374:          !Check against new style record layout                               !1.7BG
10581: 1374:          IF FN.VALIDATE.DATA(DATA.IN$, 54) = 0 THEN BEGIN                     !1.7BG
10582: 1396:             RECEIVE.STATE$ = "*"                                              !1.7BG
10583: 13ad:             RETURN                                                            !1.7BG
10584: 13bd:          ENDIF                                                                !1.7BG
10585: 13c5:          OLD.PCHECK.RECORD% = FALSE                                           !1.7BG
10586: 13d7:       ENDIF                                                                   !1.7BG
10587: 13df: 
10588: 13df:       IF MID$(DATA.IN$, 16, 6) = "000001" THEN BEGIN                    ! 1.3
10589: 1417: 
10590: 1417:          IF OLD.PCHECK.RECORD% THEN BEGIN                                     !1.7BG
10591: 1429: 
10592: 1429:             CURR.SESS.NUM% = GAPBF.SESS.NUM%
10593: 143b:             IF GAPBF.OPEN.FLAG$ = "Y" THEN BEGIN                        ! 1.3 !1.7BG
10594: 145c:                GAPBF.BOOTS.CODE$ = MID$(DATA.IN$, 3, 13)                ! 1.3 !1.7BG
10595: 1483:                RC% = WRITE.GAPBF                                        ! 1.3 !1.7BG
10596: 1497:                IF RC% = 1 THEN BEGIN                                    ! 1.3 !1.7BG
10597: 14a9:                   GOTO WRITE.ERROR                                      ! 1.3 !1.7BG
10598: 14b6:                ENDIF ELSE BEGIN                                         ! 1.4 !1.7BG
10599: 14be:                   GAP.RECORD.EXISTS = TRUE                              ! 1.4 !1.7BG
10600: 14d0:                ENDIF                                                    ! 1.3 !1.7BG
10601: 14da:             ENDIF ELSE BEGIN                                            ! 1.3 !1.7BG
10602: 14e2:                RECEIVE.STATE$ = "*"                                     ! 1.3 !1.7BG
10603: 14f9:             ENDIF                                                       ! 1.3 !1.7BG
10604: 1504: 
10605: 1504:          ENDIF ELSE BEGIN
10606: 150c: 
10607: 150c:             IF SMON.NEW.LIST.CREATED = FALSE THEN BEGIN                           !1.5CS
10608: 1524:                PLLDB.OPEN.FLAG$ = "Y"                                             !1.5CS
10609: 153b:                ALL.FILES.CLOSED$ = "N"                                            !1.5CS
10610: 1552:                WS.SEQ.NO% = 0                                                     !1.5CS
10611: 1560:                !-----------------------------------------------------             !1.5CS
10612: 1560:                ! Generate New List ID record in PLLOL & update header             !1.5CS
10613: 1560:                ! New record offset + 1 as header is record 1.                     !1.5CS
10614: 1560:                !-----------------------------------------------------             !1.5CS
10615: 1560:                PLLOL.RECORD.NUM% = 1                                              !1.5CS
10616: 1577:                RC% = READ.PLLOL                                                   !1.5CS
10617: 158b:                IF RC% = 1 THEN GOTO READ.ERROR                                    !1.5CS
10618: 15a0:                WS.NEW.LISTID% = VAL(PLLOL.LISTID$) + 1                            !1.5CS
10619: 15e0:                PLLOL.LISTID$ = RIGHT$("000" + STR$(WS.NEW.LISTID%),3)             !1.5CS
10620: 1626:                PLLOL.RECORD.NUM% = 1                                              !1.5CS
10621: 163d:                RC% = WRITE.PLLOL                                                  !1.5CS
10622: 1651:                IF RC% = 1 THEN GOTO WRITE.ERROR                                   !1.5CS
10623: 1666:                ! Record 6-digit PDT No. in Creator & Picker variables             !1.5CS
10624: 1666:                PLLOL.CREATOR.ID$      = LEFT$(CURR.TERMINAL$, 3)                  !1.5CS
10625: 168d:                PLLOL.PICKER.ID$       = RIGHT$(CURR.TERMINAL$, 3)                 !1.5CS
10626: 16b2:                PLLOL.ITEM.STATUS$     = " "                                       !1.5CS
10627: 16c9:                PLLOL.CREATE.DATE$     = DATE$                                     !1.5CS
10628: 16e1:                PLLOL.CREATE.TIME$     = LEFT$(TIME$,4)                            !1.5CS
10629: 170d:                PLLOL.PICK.START.TIME$ = "0000"                                    !1.5CS
10630: 1724:                PLLOL.PICK.END.TIME$   = "0000"                                    !1.5CS
10631: 173b:                PLLOL.ITEM.COUNT$      = "0000"                                    !1.5CS
10632: 1752:                PLLOL.OSSR.PICKING$    = "Y"                                       !1.5CS
10633: 1769:                PLLOL.RECORD.NUM% = WS.NEW.LISTID% + 1                             !1.5CS
10634: 1783:                RC% = WRITE.PLLOL                                                  !1.5CS
10635: 1797:                IF RC% = 1 THEN GOTO WRITE.ERROR                                   !1.5CS
10636: 17ac: 
10637: 17ac:                SMON.NEW.LIST.CREATED = TRUE                                       !1.5CS
10638: 17be:             ENDIF
10639: 17c6: 
10640: 17c6:             CURR.SESS.NUM% = PLLDB.SESS.NUM%                                                   !1.5CS
10641: 17d8:             IF PLLDB.OPEN.FLAG$ = "Y" THEN BEGIN                                               !1.5CS
10642: 17f9:                                                                                                !1.5CS
10643: 17f9:                 !------------------------------                                                !1.5CS
10644: 17f9:                 ! Add Boots Items to BTS table                                                 !1.5CS
10645: 17f9:                 !------------------------------                                                !1.5CS
10646: 17f9:                 WS.SEQ.NO% = WS.SEQ.NO% + 1                                                    !1.5CS
10647: 1805:                 PLLDB.LISTID$ = PLLOL.LISTID$                                                  !1.5CS
10648: 1823:                 PLLDB.ITEMSEQ$ = RIGHT$("000" + STR$(WS.SEQ.NO%),3)                            !1.5CS
10649: 1869:                 PLLDB.QTY.ONSHELF$ = "0" + MID$(DATA.IN$, 22, 3)                               !1.5CS
10650: 1897:                 PLLDB.FILL.QTY$    = "0" + MID$(DATA.IN$, 25, 3)                               !1.5CS
10651: 18c5: 
10652: 18c5:                 ! If non-Boots Code, lookup barcode on IRF to                                  !1.5CS
10653: 18c5:                 ! obtain it and calculate the check digit                                      !1.5CS
10654: 18c5:                 IRF.BAR.CODE$ = PACK$("0000000000" + MID$(DATA.IN$, 3, 12))                    !1.5CS
10655: 18fd:                 CURR.SESS.NUM% = IRF.SESS.NUM%                                                 !1.5CS
10656: 190f:                 RC% = READ.IRF                                                                 !1.5CS
10657: 1923: 
10658: 1923:                 IF RC% <> 0 THEN BEGIN                                                         !1.5CS
10659: 1938:                     ! Item not setup on system, so set Boots Item Code to all 9's              !1.5CS
10660: 1938:                     ! & insert barcode into unused PLLDB vaiables in order that                !1.5CS
10661: 1938:                     ! it can be reported as NOT ON FILE by PST47                               !1.5CS
10662: 1938:                     BTSCNT% = BTSCNT% + 1                                                      !1.5CS
10663: 1947:                     PLLDB.TABLE$(BTSCNT%) = PLLDB.LISTID$ + PLLDB.ITEMSEQ$ + PACK$("99999999") + \ !1.5CS
10664: 1a35:                               PLLDB.QTY.ONSHELF$  +  PLLDB.FILL.QTY$                       + \ !1.5CS
10665: 1a35:                               "YU00000000" + MID$(DATA.IN$, 3,  4) + MID$(DATA.IN$, 7,  4) + \ !1.5CS
10666: 1a35:                               MID$(DATA.IN$, 11, 4) + MID$(DATA.IN$, 15, 1)                + \ !1.5CS
10667: 1a35:                               "0000000000000"                                                  !1.5CS
10668: 1a35:                 ENDIF ELSE BEGIN                                                               !1.5CS
10669: 1a3d:                     ! Obtain current stock figure for use later - we need to know the amount   !1.5CS
10670: 1a3d:                     ! of stock that has moved between counting & updating later.               !1.5CS
10671: 1a3d:                     GOSUB GET.IMSTC.SALES.FIGURE                                               !1.5CS
10672: 1a4f:                     PLLDB.SHELFMON.SALE.FIG$ = RIGHT$("0000" + CURRENT.STOCK$, 4)              !1.5CS
10673: 1a87:                     BOOTS.CODE$  = UNPACK$(IRF.BOOTS.CODE$)                                    !1.5CS
10674: 1aa8:                     EAN.BARCODE$ = UNPACK$(IRF.BAR.CODE$)                                      !1.5CS
10675: 1ac9:                     RC% = CALC.BOOTS.CODE.CHECK.DIGIT(BOOTS.CODE$)                             !1.5CS
10676: 1ae8:                     IF RC% <> 0 THEN GOTO PROGRAM.EXIT                                         !1.5CS
10677: 1afd: 
10678: 1afd:                     PACKED.BOOTS.CODE$ = PACK$(RIGHT$("00000000" + BOOTS.CODE$ + F18.CHECK.DIGIT$, 8))!1.5CS
10679: 1b43:                     WS.STRING$= PLLDB.LISTID$ + PLLDB.ITEMSEQ$ + PACKED.BOOTS.CODE$              +  \ !1.5CS
10680: 1b9e:                               PLLDB.QTY.ONSHELF$  +  PLLDB.FILL.QTY$  +  "YU0000"         +  \ !1.5CS
10681: 1b9e:                               PLLDB.SHELFMON.SALE.FIG$ + "00000000000000000000000000"          !1.5CS
10682: 1b9e:                                                                                             !1.5CS
10683: 1b9e:                     IF EAN.BARCODE$ = ("0000000000000000" + BOOTS.CODE$) THEN BEGIN            !1.5CS
10684: 1bcc:                         ! Boots Code - add stright to table. Can ONLY be one instance since    !1.5CS
10685: 1bcc:                         ! PDT merges same codes together ie. NO lookup required.               !1.5CS
10686: 1bcc:                         BTSCNT% = BTSCNT% + 1                                                  !1.5CS
10687: 1bdb:                         PLLDB.TABLE$(BTSCNT%)= WS.STRING$                                      !1.5CS
10688: 1c09:                     ENDIF ELSE BEGIN                                                           !1.5CS
10689: 1c11:                         WS.SEQ.NO% = WS.SEQ.NO% - 1    ! Only increase for PLLDB Entries       !1.5CS
10690: 1c1d:                         EANCNT% = EANCNT% + 1                                                  !1.5CS
10691: 1c2c:                         EAN.TABLE$(EANCNT%) = PLLDB.LISTID$ + "999" + RIGHT$(WS.STRING$, 48)   !1.5CS
10692: 1c71:                     ENDIF                                                                      !1.5CS
10693: 1c79:                 ENDIF                                                                          !1.5CS
10694: 1c83:             ENDIF ELSE BEGIN                                               ! 1.3
10695: 1c8b:                RECEIVE.STATE$ = "*"                                        ! 1.3
10696: 1ca2:             ENDIF                                                          ! 1.3
10697: 1caa: 
10698: 1caa:          ENDIF                                                                                 !1.7BG
10699: 1cb5: 
10700: 1cb5:       ENDIF ELSE BEGIN                                                  ! 1.3
10701: 1cbd:          CURR.SESS.NUM% = CHKBF.SESS.NUM%                               ! 1.3
10702: 1ccf:          IF CHKBF.OPEN.FLAG$ = "Y" THEN BEGIN
10703: 1cf0:             CHKBF.ITEM.CODE$ = MID$(DATA.IN$, 3, 13)
10704: 1d17:             CHKBF.PRICE$ = MID$(DATA.IN$, 16, 6)
10705: 1d3e:             CHKBF.FILLER$ = " "
10706: 1d55:             RC% = WRITE.CHKBF                                           ! HLC
10707: 1d69:             IF RC% = 1 THEN GOTO WRITE.ERROR                            ! HLC
10708: 1d7e:             CHKBF.POINTER% = CHKBF.POINTER% + 1                         ! HLC
10709: 1d99:          ENDIF ELSE BEGIN
10710: 1da1:             RECEIVE.STATE$ = "*"                                        ! GDS
10711: 1db8:          ENDIF
10712: 1dc0:       ENDIF                                                             ! 1.3
10713: 1dc8: 
10714: 1dc8:    RETURN
10715: 1dd8: 
10716: 1dd8: \******************************************************************************
10717: 1dd8: \***
10718: 1dd8: \***   RECEIVED.PCHECK.TRAILER:                             STATE : Q
10719: 1dd8: \***
10720: 1dd8: \***      if received data is not valid then set the RECEIVE.STATE$ to "*" and
10721: 1dd8: \***      return
10722: 1dd8: \***
10723: 1dd8: \***      if already received pcheck header etc. then send trailer back to
10724: 1dd8: \***      PDT, close buffer file and kick-off price check processing
10725: 1dd8: \***
10726: 1dd8: \***   RETURN
10727: 1dd8: \***
10728: 1dd8: \******************************************************************************
10729: 1dd8: 
10730: 1dd8: 
10731: 1dd8:    RECEIVED.PCHECK.TRAILER:
10732: 1de8: 
10733: 1de8:       SB.MESSAGE$ = "PDT Support - PCHECK trailer received"
10734: 1dfd:       GOSUB SB.BG.MESSAGE
10735: 1e0f: 
10736: 1e0f:       IF FN.VALIDATE.DATA(DATA.IN$, 18) = 0 THEN BEGIN
10737: 1e31:          RECEIVE.STATE$ = "*"                                           ! GDS
10738: 1e48:          RETURN
10739: 1e58:       ENDIF
10740: 1e60: 
10741: 1e60:       IF OLD.PCHECK.RECORD% THEN BEGIN                                             !1.7BG
10742: 1e72: 
10743: 1e72:          IF CHKBF.OPEN.FLAG$ = "Y" AND GAPBF.OPEN.FLAG$ = "Y" THEN BEGIN   ! 1.4   !1.7BG
10744: 1ec7:             PIPE.OUT$ = "L" + DATA.IN$                                             !1.7BG
10745: 1eec:             GOSUB SEND.TO.PSS38                                                    !1.7BG
10746: 1efe: 
10747: 1efe:             LDTAF.LINK.TYPE% = 2                                            ! KMJK !1.7BG
10748: 1f0e:             IF MONITORED.PORT$ = "B" THEN LDTAF.LINK.TYPE% =                \ KMJK !1.7BG
10749: 1f3c:                (LDTAF.LINK.TYPE% OR 80H)                                    ! KMJK !1.7BG
10750: 1f44:             LDTAF.START.DATE$ = PACK$(LOG.ON.DATE$)                         ! KMJK !1.7BG
10751: 1f67:             LDTAF.START.TIME$ = PACK$(LOG.ON.TIME$)                         ! KMJK !1.7BG
10752: 1f8a:             TEMP.TIME$ = TIME$                                              ! LMJK !1.7BG
10753: 1fa2:             LDTAF.DURATION% = ( (VAL(LEFT$(TEMP.TIME$,2))*3600) +           \ LMJK !1.7BG
10754: 218e:                                 (VAL(MID$(TEMP.TIME$,3,2))*60)  +           \ LMJK !1.7BG
10755: 218e:                                  VAL(RIGHT$(TEMP.TIME$,2)) ) -              \ LMJK !1.7BG
10756: 218e:                           ( (VAL(UNPACK$(LEFT$(LDTAF.START.TIME$,1)))*3600)+\ LMJK !1.7BG
10757: 218e:                             (VAL(UNPACK$(MID$(LDTAF.START.TIME$,2,1)))*60)+ \ LMJK !1.7BG
10758: 218e:                              VAL(UNPACK$(RIGHT$(LDTAF.START.TIME$,1))) )    ! LMJK !1.7BG
10759: 218e:             LDTAF.DATA.VOLUME.1% = 0                                        ! KMJK !1.7BG
10760: 21a5:             LDTAF.DATA.VOLUME.1% = SIZE (CHKBF.FILE.NAME$)                  ! KMJK !1.7BG
10761: 21cc:             LDTAF.DATA.VOLUME.2% = 0                                        ! KMJK !1.7BG
10762: 21e3:             GOSUB LOG.TO.LDTAF.FILE                                         ! KMJK !1.7BG
10763: 21f5: 
10764: 21f5:             CURR.SESS.NUM% = GAPBF.SESS.NUM%                                ! 1.4  !1.7BG
10765: 2207:             GAPBF.BOOTS.CODE$ = ""                                          ! 1.4  !1.7BG
10766: 221e:             RC% = WRITE.GAPBF                                               ! 1.4  !1.7BG
10767: 2232:             IF RC% = 1 THEN GOTO WRITE.ERROR                                ! 1.4  !1.7BG
10768: 2247: 
10769: 2247:             CLOSE IRF.SESS.NUM%                                                    !1.7BG
10770: 225b:             IRF.OPEN.FLAG$="N"                                                     !1.7BG
10771: 2272:             CLOSE PLLOL.SESS.NUM%                                                  !1.7BG
10772: 2286:             PLLOL.OPEN.FLAG$ = "N"                                                 !1.7BG
10773: 229d:             CLOSE PLLDB.SESS.NUM%                                                  !1.7BG
10774: 22b1:             PLLDB.OPEN.FLAG$ = "N"                                                 !1.7BG
10775: 22c8:             CLOSE CHKBF.SESS.NUM%                                                  !1.7BG
10776: 22de:             CHKBF.OPEN.FLAG$ = "N"                                                 !1.7BG
10777: 22f5:             CLOSE GAPBF.SESS.NUM%                                           ! 1.3  !1.7BG
10778: 230b:             GAPBF.OPEN.FLAG$ = "N"                                          ! 1.3  !1.7BG
10779: 2322:             CLOSE PCHK.SESS.NUM%                                                   !1.7BG
10780: 2336:             PCHK.OPEN.FLAG$ = "N"                                                  !1.7BG
10781: 234d: 
10782: 234d:             IF SIZE(GAPBF.FILE.NAME$) <> 0 AND                              \ 1.3  !1.7BG
10783: 237d:             GAP.RECORD.EXISTS THEN BEGIN                                    ! 1.4  !1.7BG
10784: 237d:                ADX.RET.CODE% = ADXSTART("ADX_UPGM:PSS47.286",               \ 1.3  !1.7BG
10785: 23ac:                                MONITORED.PORT$,                             \ 1.3  !1.7BG
10786: 23ac:                                "Gap Report Processing")                     ! 1.3  !1.7BG
10787: 23ac:             ENDIF                                                           ! 1.3  !1.7BG
10788: 23b4:             IF SIZE(CHKBF.FILE.NAME$) <> 0 THEN BEGIN                       ! 1.3  !1.7BG
10789: 23da:                ADX.RET.CODE% = ADXSTART("ADX_UPGM:PSS43.286",               \      !1.7BG
10790: 2409:                                MONITORED.PORT$,                             \      !1.7BG
10791: 2409:                                "Price Check Processing")                           !1.7BG
10792: 2409:             ENDIF                                                           ! 1.3  !1.7BG
10793: 2411: 
10794: 2411:             RE.CHAIN = TRUE                                                 ! HLC  !1.7BG
10795: 2427:             RECEIVE.STATE$ = "?"                                            ! HLC  !1.7BG
10796: 2440:          ENDIF ELSE BEGIN                                                          !1.7BG
10797: 2448:             RECEIVE.STATE$ = "*"                                            ! GDS  !1.7BG
10798: 245f:          ENDIF                                                                     !1.7BG
10799: 246a: 
10800: 246a:       ENDIF ELSE BEGIN                                                             !1.7BG
10801: 2472: 
10802: 2472:          !-----------------------------------------------------             !1.5CS
10803: 2472:          ! Update PLLOL New List record with number of items &              !1.5CS
10804: 2472:          ! Set list status to active.                                       !1.5CS
10805: 2472:          !-----------------------------------------------------             !1.5CS
10806: 2472:          PLLOL.RECORD.NUM% = WS.NEW.LISTID% + 1                             !1.5CS
10807: 248c: 
10808: 248c:          IF SMON.NEW.LIST.CREATED THEN BEGIN                                !1.5CS
10809: 249e: 
10810: 249e:              FOR Y%=1 TO EANCNT%                                                        !1.5CS
10811: 24af: 
10812: 24af:                  ITEM.FOUND.IN.TABLE$ = "N"                                                 !1.5CS
10813: 24c4: 
10814: 24c4:                  ! Merge EAN Table with PLLDB Table                                         !1.5CS
10815: 24c4:                  ! If match then merge counts else add to end of list                       !1.5CS
10816: 24c4:                  FOR X%=1 TO BTSCNT%                                                        !1.5CS
10817: 24d5:                      IF MID$(EAN.TABLE$(Y%),7,4) = MID$(PLLDB.TABLE$(X%),7,4) THEN BEGIN    !1.5CS
10818: 2539:                          ! Amalgamate Shelf and Fill Quantities into existing record        !1.5CS
10819: 2539:                          PLLDB.TABLE$(X%) =  LEFT$(PLLDB.TABLE$(X%),10)                 + \ !1.5CS
10820: 270c:                            RIGHT$("0000" + STR$( VAL(MID$(PLLDB.TABLE$(X%), 11, 4))     + \ !1.5CS
10821: 270c:                                            VAL(MID$(EAN.TABLE$(Y%),11,4))), 4)          + \ !1.5CS
10822: 270c:                            RIGHT$("0000" + STR$( VAL(MID$(PLLDB.TABLE$(X%), 15, 4))     + \ !1.5CS
10823: 270c:                                            VAL(MID$(EAN.TABLE$(Y%),15,4))), 4)          + \ !1.5CS
10824: 270c:                            RIGHT$(PLLDB.TABLE$(X%),36)                                      !1.5CS
10825: 270c: 
10826: 270c:                          X% = BTSCNT% + 1    ! Exit Loop                                    !1.5CS
10827: 271f:                          ITEM.FOUND.IN.TABLE$ = "Y"                                         !1.5CS
10828: 2734:                      ENDIF                                                                  !1.5CS
10829: 273c:                  NEXT X%                                                                    !1.5CS
10830: 275b: 
10831: 275b:                  IF ITEM.FOUND.IN.TABLE$ = "N" THEN BEGIN                                   !1.5CS
10832: 2779: 
10833: 2779:                      WS.SEQ.NO% = WS.SEQ.NO% + 1                                            !1.5CS
10834: 2785:                      PLLDB.ITEMSEQ$ = RIGHT$("000" + STR$(WS.SEQ.NO%),3)                    !1.5CS
10835: 27cb:                      BTSCNT% = BTSCNT% + 1                                                  !1.5CS
10836: 27da:                      PLLDB.TABLE$(BTSCNT%) = PLLDB.LISTID$ + PLLDB.ITEMSEQ$ + RIGHT$(EAN.TABLE$(Y%), 48)   !1.5CS
10837: 2837:                  ENDIF                                                                      !1.5CS
10838: 283f:              NEXT Y%                                                                        !1.5CS
10839: 285e: 
10840: 285e:              FOR X%=1 TO BTSCNT%                                            !1.5CS
10841: 286e:                 PLLDB.KEY$ = PLLDB.TABLE$(X%)                               !1.5CS
10842: 289a:                 RC% = WRITE.BRIEF.PLLDB                                     !1.5CS
10843: 28ae:                 IF RC% = 1 THEN GOTO WRITE.ERROR                            !1.5CS
10844: 28c3:              NEXT X%                                                        !1.5CS
10845: 28df: 
10846: 28df:              RC% = READ.PLLOL                                               !1.5CS
10847: 28f3:              IF RC% = 1 THEN GOTO READ.ERROR                                !1.5CS
10848: 2908: 
10849: 2908:              PLLOL.ITEM.COUNT$  = RIGHT$("0000" + STR$(WS.SEQ.NO%),4)        !1.5CS
10850: 294e:              PLLOL.ITEM.STATUS$ = "A"                                        !1.5CS
10851: 2965: 
10852: 2965:              RC% = WRITE.PLLOL                                               !1.5CS
10853: 2979:              IF RC% = 1 THEN GOTO WRITE.ERROR                                !1.5CS
10854: 298e:           ENDIF                                                              !1.5CS
10855: 2996: 
10856: 2996:           IF CHKBF.OPEN.FLAG$ = "Y" AND PLLOL.OPEN.FLAG$ = "Y" THEN BEGIN   ! 1.4  !1.5CS
10857: 29eb:             PIPE.OUT$ = "L" + DATA.IN$
10858: 2a10:             GOSUB SEND.TO.PSS38
10859: 2a22: 
10860: 2a22:             LDTAF.LINK.TYPE% = 2                                            ! KMJK
10861: 2a32:             IF MONITORED.PORT$ = "B" THEN LDTAF.LINK.TYPE% =                \ KMJK
10862: 2a60:                (LDTAF.LINK.TYPE% OR 80H)                                    ! KMJK
10863: 2a68:             LDTAF.START.DATE$ = PACK$(LOG.ON.DATE$)                         ! KMJK
10864: 2a8b:             LDTAF.START.TIME$ = PACK$(LOG.ON.TIME$)                         ! KMJK
10865: 2aae:             TEMP.TIME$ = TIME$                                              ! LMJK
10866: 2ac6:             LDTAF.DURATION% = ( (VAL(LEFT$(TEMP.TIME$,2))*3600) +           \ LMJK
10867: 2cb2:                                 (VAL(MID$(TEMP.TIME$,3,2))*60)  +           \ LMJK
10868: 2cb2:                                  VAL(RIGHT$(TEMP.TIME$,2)) ) -              \ LMJK
10869: 2cb2:                           ( (VAL(UNPACK$(LEFT$(LDTAF.START.TIME$,1)))*3600)+\ LMJK
10870: 2cb2:                             (VAL(UNPACK$(MID$(LDTAF.START.TIME$,2,1)))*60)+ \ LMJK
10871: 2cb2:                              VAL(UNPACK$(RIGHT$(LDTAF.START.TIME$,1))) )    ! LMJK
10872: 2cb2:             LDTAF.DATA.VOLUME.1% = 0                                        ! KMJK
10873: 2cc9:             LDTAF.DATA.VOLUME.1% = SIZE (CHKBF.FILE.NAME$)                  ! KMJK
10874: 2cf0:             LDTAF.DATA.VOLUME.2% = 0                                        ! KMJK
10875: 2d07:             GOSUB LOG.TO.LDTAF.FILE                                         ! KMJK
10876: 2d19: 
10877: 2d19:             CLOSE IRF.SESS.NUM%                                             !1.5CS
10878: 2d2d:             IRF.OPEN.FLAG$="N"                                              !1.5CS
10879: 2d44:             CLOSE CHKBF.SESS.NUM%
10880: 2d5a:             CHKBF.OPEN.FLAG$ = "N"
10881: 2d71:             CLOSE PLLOL.SESS.NUM%                                           !1.5CS
10882: 2d85:             PLLOL.OPEN.FLAG$ = "N"                                          !1.5CS
10883: 2d9c:             CLOSE PLLDB.SESS.NUM%                                           !1.5CS
10884: 2db0:             PLLDB.OPEN.FLAG$ = "N"                                          !1.5CS
10885: 2dc7:             CLOSE PCHK.SESS.NUM%
10886: 2ddb:             PCHK.OPEN.FLAG$ = "N"
10887: 2df2:             CLOSE GAPBF.SESS.NUM%                                                  !1.7BG
10888: 2e08:             GAPBF.OPEN.FLAG$ = "N"                                                 !1.7BG
10889: 2e1f: 
10890: 2e1f:             IF BTSCNT% > 0 THEN BEGIN                                       ! 1.4  !1.5CS
10891: 2e31:                ADX.RET.CODE% = ADXSTART("ADX_UPGM:PST47.286",               \ 1.3  !1.5CS
10892: 2e60:                                PLLOL.LISTID$,                               \ 1.5CS
10893: 2e60:                                "Gap Report Processing")                     ! 1.3
10894: 2e60:             ENDIF                                                           ! 1.3
10895: 2e68:             IF SIZE(CHKBF.FILE.NAME$) <> 0 THEN BEGIN                       ! 1.3
10896: 2e8e:                ADX.RET.CODE% = ADXSTART("ADX_UPGM:PSS43.286",               \
10897: 2ebd:                                MONITORED.PORT$,                             \
10898: 2ebd:                                "Price Check Processing")
10899: 2ebd:             ENDIF                                                           ! 1.3
10900: 2ec5: 
10901: 2ec5:             RE.CHAIN = TRUE                                                 ! HLC
10902: 2edb:             RECEIVE.STATE$ = "?"                                            ! HLC
10903: 2ef4:          ENDIF ELSE BEGIN
10904: 2efc:             RECEIVE.STATE$ = "*"                                            ! GDS
10905: 2f13:          ENDIF
10906: 2f1b: 
10907: 2f1b:       ENDIF                                                                        !1.7BG
10908: 2f23: 
10909: 2f23:    RETURN
10910: 2f33: 
10911: 2f33: 
10912: 2f33: \******************************************************************************
10913: 2f33: \***                                                                    1.5CS
10914: 2f33: \***   GET.IMSTC.SALES.FIGURE:
10915: 2f33: \***
10916: 2f33: \******************************************************************************
10917: 2f33: 
10918: 2f33: GET.IMSTC.SALES.FIGURE:
10919: 2f43: 
10920: 2f43:     CURRENT.STOCK$ = ""
10921: 2f58: 
10922: 2f58:     CURRENT.REPORT.NUM% = IMSTC.REPORT.NUM%
10923: 2f6e:     IF IMSTC.OPEN.FLAG$ <> "Y" THEN BEGIN
10924: 2f8c:         IF END #IMSTC.SESS.NUM% THEN OPEN.ERROR
10925: 2fa8:         OPEN IMSTC.FILE.NAME$ KEYED RECL IMSTC.RECL% AS IMSTC.SESS.NUM% NOWRITE NODEL
10926: 2fd5:     ENDIF
10927: 2fdd: 
10928: 2fdd:     !IMSTC.BAR.CODE$ = PACK$(RIGHT$(STRING$(22,"0") + LEFT$(BOOTS.CODE$,6),22))
10929: 2fdd:     !IMSTC.BAR.CODE$ = IRF.BAR.CODE$                                    ! NDG
10930: 2fdd:     IMSTC.BAR.CODE$ = RIGHT$(PACK$(STRING$(22,"0")) + \                 ! NDG
10931: 303a:                           IRF.BOOTS.CODE$,11)                           ! NDG
10932: 303a:     RC% EQ READ.IMSTC      
10933: 304e:     CLOSE IMSTC.SESS.NUM%
10934: 3062:     IMSTC.OPEN.FLAG$ = "N"
10935: 3079: 
10936: 3079:     IF RC% EQ 0 THEN BEGIN ! FOUND AN IMSTC RECORD
10937: 308b:        IF (ASC(IMSTC.STATUS.FLAG$) AND 10000000b) = 0 THEN BEGIN
10938: 30ab:           ! NOT A STOCKED ITEM
10939: 30ab:           RETURN
10940: 30bb:        ENDIF
10941: 30c3:        ! IMSTC.STOCK.FIGURE% is stock fig - sales
10942: 30c3:        CURRENT.STOCK$ EQ STR$(IMSTC.NUMITEMS% / 100 )     ! 1.6
10943: 30ea:     ENDIF
10944: 30f2: 
10945: 30f2: RETURN
10946: 3102: 
10947: 3102: \******************************************************************************
10948: 3102: \***
10949: 3102: \***   LOG.TO.AUDIT.FILE
10950: 3102: \***
10951: 3102: \******************************************************************************
10952: 3102: 
10953: 3102: \  LOG.TO.AUDIT.FILE:                                                   ! JLC  !1.8NWB
10954: 3102: 
10955: 3102: \       IF CSR.AUDIT.OPEN.FLAG$ = "N" THEN BEGIN                        ! JLC  !1.8NWB
10956: 3102: \          IF END #CSR.AUDIT.SESS.NUM% THEN CREATE.AUDIT.FILE           ! JLC  !1.8NWB
10957: 3102: \          OPEN CSR.AUDIT.FILE$ AS CSR.AUDIT.SESS.NUM% APPEND           ! JLC  !1.8NWB
10958: 3102: \          CSR.AUDIT.OPEN.FLAG$ = "Y"                                   ! JLC  !1.8NWB
10959: 3102: \       ENDIF                                                           ! JLC  !1.8NWB
10960: 3102: 
10961: 3102: \       PRINT USING "&"; #CSR.AUDIT.SESS.NUM%;CSR.AUDIT.DATA$           ! JLC  !1.8NWB
10962: 3102: \       IF LEFT$(APPL$,4) = "LOAD" THEN BEGIN                           ! JLC  !1.8NWB
10963: 3102: \          CLOSE CSR.AUDIT.SESS.NUM%                                    ! JLC  !1.8NWB
10964: 3102: \          CSR.AUDIT.OPEN.FLAG$ = "N"                                   ! JLC  !1.8NWB
10965: 3102: \       ENDIF                                                           ! JLC  !1.8NWB
10966: 3102: 
10967: 3102: \  RETURN                                                               ! JLC  !1.8NWB
10968: 3102: 
10969: 3102: \  CREATE.AUDIT.FILE:                                                   ! JLC  !1.8NWB
10970: 3102: 
10971: 3102: \       CREATE CSR.AUDIT.FILE$ AS CSR.AUDIT.SESS.NUM%                   ! JLC  !1.8NWB
10972: 3102: \       CSR.AUDIT.OPEN.FLAG$ = "Y"                                      ! JLC  !1.8NWB
10973: 3102: \       PRINT USING "&"; #CSR.AUDIT.SESS.NUM%;                          \ JLC  !1.8NWB
10974: 3102: \       "                          LDT/PDT Tracking Log"                ! JLC  !1.8NWB
10975: 3102: \       PRINT USING "&"; #CSR.AUDIT.SESS.NUM%;" "                       ! JLC  !1.8NWB
10976: 3102: \       PRINT USING "&"; #CSR.AUDIT.SESS.NUM%;"File Creation Date " +   \ JLC  !1.8NWB
10977: 3102: \         LEFT$(DATE$,2) + "/" + MID$(DATE$,3,2) + "/" + RIGHT$(DATE$,2)! JLC  !1.8NWB
10978: 3102: \       PRINT USING "&"; #CSR.AUDIT.SESS.NUM%;"Currently executing " +  \ JLC  !1.8NWB
10979: 3102: \         "PSS37 version 20, Created on 27th July 1995    "             ! 1.3  !1.8NWB
10980: 3102: \       PRINT USING "&"; #CSR.AUDIT.SESS.NUM%;" "                       ! JLC  !1.8NWB
10981: 3102: \       PRINT USING "&"; #CSR.AUDIT.SESS.NUM%;" "                       ! JLC  !1.8NWB
10982: 3102: 
10983: 3102: \       PRINT USING "&"; #CSR.AUDIT.SESS.NUM%;CSR.AUDIT.DATA$           ! JLC  !1.8NWB
10984: 3102: 
10985: 3102: \RETURN                                                                 ! JLC  !1.8NWB
10986: 3102: 
10987: 3102: \******************************************************************************
10988: 3102: \***
10989: 3102: \***   LOG.TO.LDTAF.FILE
10990: 3102: \***
10991: 3102: \******************************************************************************
10992: 3102: 
10993: 3102:    LOG.TO.LDTAF.FILE:                                                  ! KMJK
10994: 3112: 
10995: 3112:       CURRENT.KEY$ = ""                                                ! KMJK
10996: 3127:       CURR.SESS.NUM% = LDTAF.SESS.NUM%                                 ! KMJK
10997: 3139:         IF LDTAF.OPEN.FLAG$ = "N" THEN BEGIN                           ! KMJK
10998: 3157:            IF END #LDTAF.SESS.NUM% THEN CREATE.LDTAF.FILE              ! KMJK
10999: 3173:            OPEN LDTAF.FILE.NAME$ AS LDTAF.SESS.NUM% APPEND             ! KMJK
11000: 319a:            LDTAF.OPEN.FLAG$ = "Y"                                      ! KMJK
11001: 31b1:         ENDIF                                                          ! KMJK
11002: 31b9:         IF LDTAF.LINK.TYPE% <> 0 THEN                                  \ KMJK
11003: 31cb:         IF WRITE.LDTAF THEN GOTO WRITE.ERROR                           ! KMJK
11004: 31df:       LDTAF.LINK.TYPE% = 0                                             ! KMJK
11005: 31ef:       LDTAF.OPEN.FLAG$ = "N"                                           ! KMJK
11006: 3206:       CLOSE LDTAF.SESS.NUM%                                            ! KMJK
11007: 321a: 
11008: 321a:    RETURN                                                              ! KMJK
11009: 322a: 
11010: 322a:    CREATE.LDTAF.FILE:                                                  ! KMJK
11011: 323a: 
11012: 323a:       IF END #LDTAF.SESS.NUM% THEN CREATE.ERROR                        ! KMJK
11013: 3256:         CREATE POSFILE LDTAF.FILE.NAME$ AS LDTAF.SESS.NUM%             \ KMJK
11014: 327c:         MIRRORED ATCLOSE                                               ! KMJK
11015: 327c:         LDTAF.OPEN.FLAG$ = "Y"                                         ! KMJK
11016: 3293:         IF LDTAF.LINK.TYPE% <> 0 THEN                                  \ KMJK
11017: 32a5:         IF WRITE.LDTAF THEN GOTO WRITE.ERROR                           ! KMJK
11018: 32b9:       LDTAF.LINK.TYPE% = 0                                             ! KMJK
11019: 32c9:       LDTAF.OPEN.FLAG$ = "N"                                           ! KMJK
11020: 32e0:       CLOSE LDTAF.SESS.NUM%                                            ! KMJK
11021: 32f4: 
11022: 32f4:    RETURN                                                              ! KMJK
11023: 3304: 
11024: 3304: \******************************************************************************
11025: 3304: \******************************************************************************
11026: 3304: \***
11027: 3304: \***   P D T    S U B R O U T I N E S
11028: 3304: \***
11029: 3304: \******************************************************************************
11030: 3304: \******************************************************************************
11031: 3304: 
11032: 3304: \******************************************************************************
11033: 3304: \***
11034: 3304: \***   DETERMINE.DATA.TYPE:
11035: 3304: \***
11036: 3304: \***      set RECEIVE.STATE$ depending on record received (DATA.IN$),
11037: 3304: \***      decode is follows ;
11038: 3304: \***      1st 2 chars = "XH"                              - state "J"
11039: 3304: \***      1st 2 chars = "XM"                              - state "K"
11040: 3304: \***      1st 2 chars = "XU"                              - state "K"
11041: 3304: \***      1st 2 chars = "XO"                              - state "K"
11042: 3304: \***      1st 2 chars = "XT"                              - state "L"
11043: 3304: \***      1st 2 chars = "XZ"                              - state "N"
11044: 3304: \***      any record that does not satisfy any of the above conditions will
11045: 3304: \***      be given a state of "*" (invalid record)
11046: 3304: \***
11047: 3304: \***   RETURN
11048: 3304: \***
11049: 3304: \******************************************************************************
11050: 3304: 
11051: 3304: \  DETERMINE.DATA.TYPE:                                                        !1.8NWB
11052: 3304: 
11053: 3304: \     IF LEFT$(CSRBF.DATA$,2) = "XH" THEN BEGIN                                !1.8NWB
11054: 3304: \        RECEIVE.STATE$ = "J"                                                  !1.8NWB
11055: 3304: \      RETURN                                                                  !1.8NWB
11056: 3304: \     ENDIF                                                                    !1.8NWB
11057: 3304: 
11058: 3304: \     IF LEFT$(CSRBF.DATA$,2) = "XM" THEN BEGIN                                !1.8NWB
11059: 3304: \        RECEIVE.STATE$ = "K"                                                  !1.8NWB
11060: 3304: \      RETURN                                                                  !1.8NWB
11061: 3304: \     ENDIF                                                                    !1.8NWB
11062: 3304: 
11063: 3304: \     IF LEFT$(CSRBF.DATA$,2) = "XU" THEN BEGIN                                !1.8NWB
11064: 3304: \        RECEIVE.STATE$ = "K"                                                  !1.8NWB
11065: 3304: \      RETURN                                                                  !1.8NWB
11066: 3304: \     ENDIF                                                                    !1.8NWB
11067: 3304: 
11068: 3304: \     IF LEFT$(CSRBF.DATA$,2) = "XO" THEN BEGIN                                !1.8NWB
11069: 3304: \        RECEIVE.STATE$ = "K"                                                  !1.8NWB
11070: 3304: \      RETURN                                                                  !1.8NWB
11071: 3304: \     ENDIF                                                                    !1.8NWB
11072: 3304: 
11073: 3304: \     IF LEFT$(CSRBF.DATA$,2) = "XT" THEN BEGIN                                !1.8NWB
11074: 3304: \        RECEIVE.STATE$ = "L"                                                  !1.8NWB
11075: 3304: \      RETURN                                                                  !1.8NWB
11076: 3304: \     ENDIF                                                                    !1.8NWB
11077: 3304: 
11078: 3304: \     IF LEFT$(CSRBF.DATA$,2) = "XZ" THEN BEGIN                                !1.8NWB
11079: 3304: \        RECEIVE.STATE$ = "N"                                                  !1.8NWB
11080: 3304: \      RETURN                                                                  !1.8NWB
11081: 3304: \     ENDIF                                                                    !1.8NWB
11082: 3304: 
11083: 3304: \     RECEIVE.STATE$ = "*"                                              ! GDS  !1.8NWB
11084: 3304: 
11085: 3304: \  RETURN                                                                      !1.8NWB
11086: 3304: 
11087: 3304: \******************************************************************************
11088: 3304: \***
11089: 3304: \***   SEND.TO.PSS38:
11090: 3304: \***
11091: 3304: \***      transmit data to PSS38 (data contained in PIPE.OUT$)
11092: 3304: \***
11093: 3304: \***   RETURN
11094: 3304: \***
11095: 3304: \******************************************************************************
11096: 3304: 
11097: 3304:    SEND.TO.PSS38:
11098: 3314: 
11099: 3314:       IF END# PIPEI.SESS.NUM% THEN WRITE.ERROR
11100: 3332:       CURR.SESS.NUM% = PIPEI.SESS.NUM%
11101: 3344:       WRITE# PIPEI.SESS.NUM%; PIPE.OUT$
11102: 336c: 
11103: 336c:    RETURN
11104: 337c: 
11105: 337c: \******************************************************************************
11106: 337c: \***
11107: 337c: \***   RELEASE.PDT:
11108: 337c: \***
11109: 337c: \***      send a release PDT command to PSS38
11110: 337c: \***
11111: 337c: \***   RETURN
11112: 337c: \***
11113: 337c: \******************************************************************************
11114: 337c: 
11115: 337c: \  RELEASE.PDT:                                                                !1.8NWB
11116: 337c: 
11117: 337c: \     PIPE.OUT$ = "HN"                                                         !1.8NWB
11118: 337c: \     GOSUB SEND.TO.PSS38                                                      !1.8NWB
11119: 337c: \     HOLD.FLAG$ = "N"                                                         !1.8NWB
11120: 337c: 
11121: 337c: \  RETURN                                                                      !1.8NWB
11122: 337c: 
11123: 337c: \******************************************************************************
11124: 337c: \***
11125: 337c: \***   TRANSMIT.CSR.FILE.TO.PDT:
11126: 337c: \***
11127: 337c: \***     send instruction to PSS38 to request transmission of CSRWF to PDT
11128: 337c: \***
11129: 337c: \***   RETURN
11130: 337c: \***
11131: 337c: \******************************************************************************
11132: 337c: 
11133: 337c: \  TRANSMIT.CSR.FILE.TO.PDT:                                                   !1.8NWB
11134: 337c: 
11135: 337c: \     PIPE.OUT$ = "C"                                                          !1.8NWB
11136: 337c: \     GOSUB SEND.TO.PSS38                                                      !1.8NWB
11137: 337c: 
11138: 337c: \     SB.MESSAGE$ = "PDT Support - Waiting for CSR E.O.T"                      !1.8NWB
11139: 337c: \     GOSUB SB.BG.MESSAGE                                                      !1.8NWB
11140: 337c: 
11141: 337c: \  RETURN                                                                      !1.8NWB
11142: 337c: 
11143: 337c: \******************************************************************************
11144: 337c: \******************************************************************************
11145: 337c: \***                                                                        ***
11146: 337c: \***                                                                        ***
11147: 337c: \***   L O W   L E V E L   S U B R O U T I N E S                            ***
11148: 337c: \***                                                                        ***
11149: 337c: \***                                                                        ***
11150: 337c: \***   - SB.FILE.UTILS                                                      ***
11151: 337c: \***   - SB.BG.MESSAGE                                                      ***
11152: 337c: \***   - SB.LOG.AN.EVENT                                                    ***
11153: 337c: \***   - SB.FORMAT.ERROR.DATA                                               ***
11154: 337c: \***   - SB.FILE.OPEN.ERROR                                                 ***
11155: 337c: \***   - SB.FILE.READ.ERROR                                                 ***
11156: 337c: \***   - SB.FILE.WRITE.ERROR                                                ***
11157: 337c: \***                                                                        ***
11158: 337c: \******************************************************************************
11159: 337c: \******************************************************************************
11160: 337c: 
11161: 337c: \******************************************************************************
11162: 337c: \***
11163: 337c: \***   Subroutine : SB.FILE.UTILS
11164: 337c: \***
11165: 337c: \***   Purpose    : Allocate / report / de-allocate a file session number
11166: 337c: \***
11167: 337c: \***   Parameters : 2 or 3 (depending on action)
11168: 337c: \***
11169: 337c: \***      SB.ACTION$  = "O" for allocate file session number
11170: 337c: \***                    "R" for report file session number
11171: 337c: \***                    "C" for de-allocate file session number
11172: 337c: \***      SB.INTEGER% = file reporting number for action "O" or
11173: 337c: \***                  = file session number for actions "R" or "C"
11174: 337c: \***
11175: 337c: \***      SB.STRING$  = logical file name for action "O" or
11176: 337c: \***                    null ("") for actions "R" and "C"
11177: 337c: \***
11178: 337c: \***   Output     : 1 or 2 (depending on action)
11179: 337c: \***      SB.FILE.SESS.NUM% = file session number for action "O" or
11180: 337c: \***                          undefined for action "C"
11181: 337c: \***      or
11182: 337c: \***      SB.FILE.REP.NUM%  = file reporting number for action "R" or
11183: 337c: \***                          undefined for action "C"
11184: 337c: \***
11185: 337c: \***   Error action : log event 48 and end program
11186: 337c: \***
11187: 337c: \******************************************************************************
11188: 337c: 
11189: 337c:    SB.FILE.UTILS:
11190: 338c: 
11191: 338c:       RC% = SESS.NUM.UTILITY(SB.ACTION$,                        \
11192: 33b8:                        SB.INTEGER%,                        \
11193: 33b8:                        SB.STRING$ )
11194: 33b8: 
11195: 33b8:       IF RC% <> 0 THEN BEGIN
11196: 33ca:          SB.EVENT.NO% = 48
11197: 33d7:        SB.UNIQUE$ = FN.Z.PACK(STR$(F20.INTEGER.FILE.NO%), 10)
11198: 3408:        SB.MESSAGE$ = "SESSION NUMBER ALLOCATION ROUTINE FAILED"
11199: 341d:        GOSUB SB.LOG.AN.EVENT
11200: 342f:        GOTO PROGRAM.EXIT
11201: 343a:       ENDIF
11202: 3442: 
11203: 3442:       IF SB.ACTION$ = "O" THEN                                    \
11204: 345d:          SB.FILE.SESS.NUM% = F20.INTEGER.FILE.NO%
11205: 346f:       IF SB.ACTION$ = "R" OR SB.ACTION$ = "D" THEN BEGIN               ! NNS
11206: 34bb:          SB.FILE.REP.NUM% = F20.INTEGER.FILE.NO%
11207: 34cd:          SB.ERRF$ = CHR$(SHIFT(SB.FILE.REP.NUM%,8)) +                  \ NNS
11208: 3516:                     CHR$(SHIFT(SB.FILE.REP.NUM%,0))                    ! NNS
11209: 3516:       ENDIF                                                            ! NNS
11210: 351e: 
11211: 351e: 
11212: 351e:    RETURN
11213: 352e: 
11214: 352e: \******************************************************************************
11215: 352e: \***
11216: 352e: \***   Subroutine : SB.BG.MESSAGE
11217: 352e: \***
11218: 352e: \***   Purpose    : Display a message to the background screen
11219: 352e: \***
11220: 352e: \***   Parameters : 1
11221: 352e: \***
11222: 352e: \***      SB.MESSAGE$ = message to be displayed (message will be truncated to
11223: 352e: \***                    46 characters if the message is longer than 46 chars)
11224: 352e: \***                    Minus the port letter.
11225: 352e: \***
11226: 352e: \***   Output     : 1
11227: 352e: \***      SB.MESSAGE$ = null
11228: 352e: \***
11229: 352e: \***   Error action : log an event 23 and end program
11230: 352e: \***
11231: 352e: \******************************************************************************
11232: 352e: 
11233: 352e:    SB.BG.MESSAGE:
11234: 353e: 
11235: 353e:       IF SB.MESSAGE$ = LAST.MESSAGE$ THEN RETURN
11236: 3568:       LAST.MESSAGE$ = SB.MESSAGE$                              ! ESW
11237: 3583: 
11238: 3583:       SB.MESSAGE$ = MONITORED.PORT$ + ": " + SB.MESSAGE$
11239: 35ae:       SB.MESSAGE$ = LEFT$(SB.MESSAGE$ + STRING$(46, " "), 46)            ! ESW
11240: 35f8:       CALL ADXSERVE( ADX.RET.CODE%, 26, 0, SB.MESSAGE$)
11241: 3630: 
11242: 3630:       IF ADX.RET.CODE% <> 0 THEN BEGIN
11243: 364b:          SB.EVENT.NO% = 23
11244: 3658:        SB.UNIQUE$ = FN.Z.PACK(STR$(ADX.RET.CODE%),5) + "04   "
11245: 3699:        SB.MESSAGE$ = ""
11246: 36ae:        GOSUB SB.LOG.AN.EVENT
11247: 36c0:       ENDIF
11248: 36c8: 
11249: 36c8:       SB.MESSAGE$ = ""
11250: 36dd: 
11251: 36dd:    RETURN
11252: 36ed: 
11253: 36ed: \******************************************************************************
11254: 36ed: \***
11255: 36ed: \***   Subroutine : SB.LOG.AN.EVENT
11256: 36ed: \***
11257: 36ed: \***   Purpose    : General routine to log an event using passed data. If
11258: 36ed: \***                program has been started manually for a re-run then also
11259: 36ed: \***                display a message on the background screen.
11260: 36ed: \***                The event will be preceded by one indicating the port
11261: 36ed: \***                being monitored by the program in error.
11262: 36ed: \***
11263: 36ed: \***   Parameters : 2
11264: 36ed: \***
11265: 36ed: \***      SB.EVENT.NO% = number of event to be logged
11266: 36ed: \***      SB.UNIQUE$   = 10 byte block of data unique to event
11267: 36ed: \***
11268: 36ed: \***   Output     : none
11269: 36ed: \***
11270: 36ed: \***   Error action : none
11271: 36ed: \***
11272: 36ed: \******************************************************************************
11273: 36ed: 
11274: 36ed:    SB.LOG.AN.EVENT:
11275: 36fd: 
11276: 36fd:       MESSAGE.NO% = 0
11277: 370b:       UNIQUE.2$ = ""
11278: 3720: 
11279: 3720:       PORT.STRING$ = "PORT : " + MONITORED.PORT$ + "  "
11280: 3749:       PORT.EVENT% = 75
11281: 3756: 
11282: 3756:       RC% = APPLICATION.LOG(MESSAGE.NO%,                        \
11283: 3789:                       PORT.STRING$,                                  \
11284: 3789:                       UNIQUE.2$,                              \
11285: 3789:                       PORT.EVENT% )
11286: 3789: 
11287: 3789:       RC% = APPLICATION.LOG(MESSAGE.NO%,                        \
11288: 37b9:                       SB.UNIQUE$,                              \
11289: 37b9:                       UNIQUE.2$,                              \
11290: 37b9:                       SB.EVENT.NO% )
11291: 37b9: 
11292: 37b9:    RETURN
11293: 37c9: 
11294: 37c9: \******************************************************************************
11295: 37c9: \***
11296: 37c9: \***   Subroutine : SB.FORMAT.ERROR.DATA
11297: 37c9: \***
11298: 37c9: \***   Purpose    : General routine to format the common error reporting
11299: 37c9: \***                data
11300: 37c9: \***
11301: 37c9: \***   Parameters : 0
11302: 37c9: \***
11303: 37c9: \***   Output     :
11304: 37c9: \***      SB.ERRS$   = ERRN converted to a 4 byte string
11305: 37c9: \***      SB.ERRL$   = ERRL zero packed up to 6 bytes
11306: 37c9: \***      SB.ERRF$   = ERRF converted to a reporting number (1 byte)
11307: 37c9: \***
11308: 37c9: \***   Error action : if hex conversion or string conversion fails then the
11309: 37c9: \***                  program ends
11310: 37c9: \***
11311: 37c9: \******************************************************************************
11312: 37c9: 
11313: 37c9:    SB.FORMAT.ERROR.DATA:
11314: 37d9: 
11315: 37d9:       RC% = CONV.TO.HEX( ERRN )
11316: 37f9:       IF RC% <> 0 THEN                                          \
11317: 380b:          GOTO PROGRAM.EXIT
11318: 3816: 
11319: 3816:       RC% = CONV.TO.STRING(0,                                    \
11320: 383a:                      ERRN )
11321: 383a:       IF RC% <> 0 THEN                                          \
11322: 384c:          GOTO PROGRAM.EXIT
11323: 3857:       SB.ERRS$ = F17.RETURNED.STRING$
11324: 3873: 
11325: 3873:       SB.ERRL$ = FN.Z.PACK(STR$(ERRL), 6)
11326: 38a2:       SB.ACTION$ = "R" : SB.INTEGER% = ERRF% : SB.STRING$ = ""
11327: 38cc:       GOSUB SB.FILE.UTILS
11328: 38de: 
11329: 38de:    RETURN
11330: 38ee: 
11331: 38ee: \******************************************************************************
11332: 38ee: \***
11333: 38ee: \***   Subroutine : SB.FILE.OPEN.ERROR
11334: 38ee: \***
11335: 38ee: \***   Purpose    : Log an event 6 with unique data indicating an error has
11336: 38ee: \***                occurred whilst attempting to open a file.
11337: 38ee: \***
11338: 38ee: \***   Parameters : 1
11339: 38ee: \***
11340: 38ee: \***      CURR.SESS.NUM% = file session number of the file that caused the
11341: 38ee: \***                       error, this is used to look-up the file reporting
11342: 38ee: \***                       number that is logged in the event's unique data.
11343: 38ee: \***
11344: 38ee: \***   Output     : none
11345: 38ee: \***
11346: 38ee: \***   Error action : none
11347: 38ee: \***
11348: 38ee: \******************************************************************************
11349: 38ee: 
11350: 38ee:    SB.FILE.OPEN.ERROR:
11351: 38fe: 
11352: 38fe:       SB.ACTION$ = "R"
11353: 3913:       SB.INTEGER% = CURR.SESS.NUM%
11354: 3921:       SB.STRING$ = ""
11355: 3936:       GOSUB SB.FILE.UTILS
11356: 3948:       SB.EVENT.NO% = 6
11357: 3955:       SB.UNIQUE$ = "O" + SB.ERRF$ + PACK$(STRING$(15,"0"))             ! NNS
11358: 3985:       GOSUB SB.LOG.AN.EVENT
11359: 3997: 
11360: 3997:    RETURN
11361: 39a7: 
11362: 39a7: \******************************************************************************
11363: 39a7: \***
11364: 39a7: \***   Subroutine : SB.FILE.READ.ERROR
11365: 39a7: \***
11366: 39a7: \***   Purpose    : Log an event 6 with unique data indicating an error has
11367: 39a7: \***                occurred whilst attempting to read a file.
11368: 39a7: \***
11369: 39a7: \***   Parameters : 2
11370: 39a7: \***
11371: 39a7: \***      CURR.SESS.NUM%  = file session number of the file that caused the
11372: 39a7: \***                        error, this is used to look-up the file reporting
11373: 39a7: \***                        number that is logged in the event's unique data.
11374: 39a7: \***      CURRENT.KEY$    = value of key used to try to read from file.
11375: 39a7: \***
11376: 39a7: \***   Output     : none
11377: 39a7: \***
11378: 39a7: \***   Error action : none
11379: 39a7: \***
11380: 39a7: \******************************************************************************
11381: 39a7: 
11382: 39a7: 
11383: 39a7:   SB.FILE.READ.ERROR:
11384: 39b7: 
11385: 39b7:       SB.ACTION$ = "R"
11386: 39cc:       SB.INTEGER% = CURR.SESS.NUM%
11387: 39da:       SB.STRING$ = ""
11388: 39ef:       GOSUB SB.FILE.UTILS
11389: 3a01:       SB.EVENT.NO% = 6
11390: 3a0e:       IF CURRENT.KEY$ <> "SECTOR" THEN                              \
11391: 3a29:          SB.UNIQUE$ = "R" +                                    \
11392: 3a59:          SB.ERRF$ +                                                    \ NNS
11393: 3a59:        FN.Z.PACK(CURRENT.KEY$,8)                              \
11394: 3a59:       ELSE                                                \
11395: 3a61:          SB.UNIQUE$ = "R" +                                    \
11396: 3a89:          SB.ERRF$ +                                                    \ NNS
11397: 3a89:        CURRENT.KEY$
11398: 3a91: ! do not log an error if the read is of the CITEM or the IDF
11399: 3a91: \     IF SB.FILE.REP.NUM% = IDF.REPORT.NUM% OR                         \ KMJK  !1.8NWB
11400: 3a91: \        SB.FILE.REP.NUM% = CITEM.REPORT.NUM% THEN RETURN            ! KMJK    !1.8NWB
11401: 3a91:       GOSUB SB.LOG.AN.EVENT
11402: 3aa3: 
11403: 3aa3:    RETURN
11404: 3ab3: 
11405: 3ab3: \******************************************************************************
11406: 3ab3: \***
11407: 3ab3: \***   Subroutine : SB.FILE.WRITE.ERROR
11408: 3ab3: \***
11409: 3ab3: \***   Purpose    : Log an event 6 with unique data indicating an error has
11410: 3ab3: \***                occurred whilst attempting to write a file.
11411: 3ab3: \***
11412: 3ab3: \***   Parameters : 2
11413: 3ab3: \***
11414: 3ab3: \***      CURR.SESS.NUM%  = file session number of the file that caused the
11415: 3ab3: \***                        error, this is used to look-up the file reporting
11416: 3ab3: \***                        number that is logged in the event's unique data.
11417: 3ab3: \***    CURRENT.KEY$    = value of key used to try to write to file.
11418: 3ab3: \***
11419: 3ab3: \***   Output     : none
11420: 3ab3: \***
11421: 3ab3: \***   Error action : none
11422: 3ab3: \***
11423: 3ab3: \******************************************************************************
11424: 3ab3: 
11425: 3ab3:    SB.FILE.WRITE.ERROR:
11426: 3ac3: 
11427: 3ac3:       SB.ACTION$ = "R"
11428: 3ad8:       SB.INTEGER% = CURR.SESS.NUM%
11429: 3ae6:       SB.STRING$ = ""
11430: 3afb:       GOSUB SB.FILE.UTILS
11431: 3b0d:       SB.EVENT.NO% = 6
11432: 3b1a:       IF CURRENT.KEY$ <> "SECTOR" THEN BEGIN
11433: 3b35:          SB.UNIQUE$ = "W" + SB.ERRF$ +                                 \ NNS
11434: 3b65:        FN.Z.PACK(CURRENT.KEY$,8)
11435: 3b65:       ENDIF ELSE BEGIN
11436: 3b6d:          SB.UNIQUE$ = "W" + SB.ERRF$ + CURRENT.KEY$                    ! NNS
11437: 3b95:       ENDIF
11438: 3b9d:       GOSUB SB.LOG.AN.EVENT
11439: 3baf: 
11440: 3baf:    RETURN
11441: 3bbf: 
11442: 3bbf: \******************************************************************************
11443: 3bbf: \***
11444: 3bbf: \***   Subroutine : SB.FILE.DELETE.ERROR
11445: 3bbf: \***
11446: 3bbf: \***   Purpose    : Log an event 6 with unique data indicating an error has
11447: 3bbf: \***                occurred whilst attempting to delete a file.
11448: 3bbf: \***
11449: 3bbf: \***   Parameters : 2
11450: 3bbf: \***
11451: 3bbf: \***      CURR.SESS.NUM%  = file session number of the file that caused the
11452: 3bbf: \***                        error, this is used to look-up the file reporting
11453: 3bbf: \***                        number that is logged in the event's unique data.
11454: 3bbf: \***      CURRENT.KEY$    = value of key used to try to delete to file.
11455: 3bbf: \***
11456: 3bbf: \***   Output     : none
11457: 3bbf: \***
11458: 3bbf: \***   Error action : none
11459: 3bbf: \***
11460: 3bbf: \******************************************************************************
11461: 3bbf: 
11462: 3bbf:    SB.FILE.DELETE.ERROR:
11463: 3bcf: 
11464: 3bcf:       SB.ACTION$ = "D"
11465: 3be4:       SB.INTEGER% = CURR.SESS.NUM%
11466: 3bf2:       SB.STRING$ = ""
11467: 3c07:       GOSUB SB.FILE.UTILS
11468: 3c19:       SB.EVENT.NO% = 6
11469: 3c26:       SB.UNIQUE$ = "D" + SB.ERRF$ + CURRENT.KEY$                       ! NNS
11470: 3c4e:       GOSUB SB.LOG.AN.EVENT
11471: 3c60: 
11472: 3c60:    RETURN
11473: 3c70: 
11474: 3c70: \******************************************************************************
11475: 3c70: \***
11476: 3c70: \***   Subroutine : SB.FILE.CREATE.ERROR
11477: 3c70: \***
11478: 3c70: \***   Purpose    : Log an event 6 with unique data indicating an error has
11479: 3c70: \***                occurred whilst attempting to create a file.
11480: 3c70: \***
11481: 3c70: \***   Parameters : 2
11482: 3c70: \***
11483: 3c70: \***      CURR.SESS.NUM%  = file session number of the file that caused the
11484: 3c70: \***                        error, this is used to look-up the file reporting
11485: 3c70: \***                        number that is logged in the event's unique data.
11486: 3c70: \***
11487: 3c70: \***   Output     : none
11488: 3c70: \***
11489: 3c70: \***   Error action : none
11490: 3c70: \***
11491: 3c70: \******************************************************************************
11492: 3c70: 
11493: 3c70:    SB.FILE.CREATE.ERROR:
11494: 3c80: 
11495: 3c80:       SB.ACTION$ = "R"
11496: 3c95:       SB.INTEGER% = CURR.SESS.NUM%
11497: 3ca3:       SB.STRING$ = ""
11498: 3cb8:       GOSUB SB.FILE.UTILS
11499: 3cca:       SB.EVENT.NO% = 6
11500: 3cd7:       SB.UNIQUE$ = "C" + SB.ERRF$                                      ! NNS
11501: 3cf7:       GOSUB SB.LOG.AN.EVENT
11502: 3d09: 
11503: 3d09:    RETURN
11504: 3d19: 
11505: 3d19: \******************************************************************************
11506: 3d19: \******************************************************************************
11507: 3d19: \***                                                                        ***
11508: 3d19: \***                                                                        ***
11509: 3d19: \***   E R R O R   H A N D L I N G                                          ***
11510: 3d19: \***                                                                        ***
11511: 3d19: \***                                                                        ***
11512: 3d19: \******************************************************************************
11513: 3d19: \******************************************************************************
11514: 3d19: 
11515: 3d19: \******************************************************************************
11516: 3d19: \***
11517: 3d19: \***   OPEN.ERROR:
11518: 3d19: \***
11519: 3d19: \***      log an event 6 (open error)
11520: 3d19: \***      set RECEIVE.STATE$ to "*"
11521: 3d19: \***
11522: 3d19: \***      if the source of the error is known then return to one of the
11523: 3d19: \***      specified return points so the program does not end
11524: 3d19: \***
11525: 3d19: \***   GOTO MODULE.EXIT (no return is possible)
11526: 3d19: \***
11527: 3d19: \******************************************************************************
11528: 3d19: 
11529: 3d19:    OPEN.ERROR:
11530: 3d29: 
11531: 3d29:       TEMP.STATE$ = RECEIVE.STATE$
11532: 3d45:       GOSUB SB.FILE.OPEN.ERROR
11533: 3d57: \     IF CURR.SESS.NUM% = IDSOF.SESS.NUM% THEN BEGIN                  ! ILC    !1.8NWB
11534: 3d57: \        GOTO RETURN.FROM.IDSOF.OPEN.ERROR                        ! ILC        !1.8NWB
11535: 3d57: \     ENDIF                                                ! ILC               !1.8NWB
11536: 3d57:       RECEIVE.STATE$ = "*"                                              ! GDS
11537: 3d6e: 
11538: 3d6e:    GOTO MODULE.EXIT
11539: 3d79: 
11540: 3d79: \******************************************************************************
11541: 3d79: \***
11542: 3d79: \***   READ.ERROR:
11543: 3d79: \***
11544: 3d79: \***      log an event 6 (read error)
11545: 3d79: \***      set RECEIVE.STATE$ to "*"
11546: 3d79: \***      if the source of the error is known then return to one of the
11547: 3d79: \***      specified return points so the program does not end
11548: 3d79: \***
11549: 3d79: \***   GOTO MODULE.EXIT (no return is possible)
11550: 3d79: \***
11551: 3d79: \******************************************************************************
11552: 3d79: 
11553: 3d79:    READ.ERROR:
11554: 3d89: 
11555: 3d89:       TEMP.STATE$ = RECEIVE.STATE$
11556: 3da5:       GOSUB SB.FILE.READ.ERROR
11557: 3db7: 
11558: 3db7: \     IF LOCATION$ = "CALCTS"                                    \             !1.8NWB
11559: 3db7: \     AND CURR.SESS.NUM% = FPF.SESS.NUM% THEN BEGIN                            !1.8NWB
11560: 3db7: \        GOTO CALC.TS.CONTINUE                                                 !1.8NWB
11561: 3db7: \     ENDIF                                                                    !1.8NWB
11562: 3db7: 
11563: 3db7: 
11564: 3db7: \     IF LOCATION$ = "FINDITEM" THEN BEGIN                        ! BPAB       !1.8NWB
11565: 3db7: \        GOTO FIND.ITEM.ON.FILES.CONTINUE                                      !1.8NWB
11566: 3db7: \     ENDIF                                                                    !1.8NWB
11567: 3db7: 
11568: 3db7: \     IF LOCATION$ = "FPFPROC"                                    \            !1.8NWB
11569: 3db7: \     AND (CURR.SESS.NUM% = CITEM.SESS.NUM%                        \           !1.8NWB
11570: 3db7: \     OR CURR.SESS.NUM% = CIMF.SESS.NUM%) THEN BEGIN                           !1.8NWB
11571: 3db7: \        GOTO FIND.PARENT.CONTINUE                                             !1.8NWB
11572: 3db7: \     ENDIF                                                                    !1.8NWB
11573: 3db7: 
11574: 3db7: \     IF LOCATION$ = "FAMFIGS" THEN BEGIN                                      !1.8NWB
11575: 3db7: \        IF CURR.SESS.NUM% = FPF.SESS.NUM% THEN BEGIN                          !1.8NWB
11576: 3db7: \           GOTO CALC.FAMILY.FIGURES.CONTINUE                                  !1.8NWB
11577: 3db7: \        ENDIF ELSE BEGIN                                                      !1.8NWB
11578: 3db7: \           IF CURR.SESS.NUM% = CITEM.SESS.NUM%                        \       !1.8NWB
11579: 3db7: \           OR CURR.SESS.NUM% = CIMF.SESS.NUM% THEN BEGIN                      !1.8NWB
11580: 3db7: \              GOTO CALC.FAMILY.FIGURES.CONTINUE2                              !1.8NWB
11581: 3db7: \         ENDIF                                                                !1.8NWB
11582: 3db7: \      ENDIF                                                                   !1.8NWB
11583: 3db7: \     ENDIF                                                                    !1.8NWB
11584: 3db7: 
11585: 3db7: \     IF LOCATION$ = "UNPROC" AND CSRWF.UNPROCESS.FLAG$ = "Y"            \     !1.8NWB
11586: 3db7: \     AND ONORD.SEQ.NO$ <> "000"                              \                !1.8NWB
11587: 3db7: \     AND CURR.SESS.NUM% = ONORD.SESS.NUM% THEN BEGIN                          !1.8NWB
11588: 3db7: \        GOTO UNPROCESS.LIST.CONTINUE                                          !1.8NWB
11589: 3db7: \     ENDIF                                                                    !1.8NWB
11590: 3db7: 
11591: 3db7: \     IF LOCATION$ = "UNPROC" AND CSRWF.UNPROCESS.FLAG$ = "Y"            \ BPAB!1.8NWB
11592: 3db7: \     AND ONORD.SEQ.NO$ <> "000"                              \ BPAB           !1.8NWB
11593: 3db7: \     AND CURR.SESS.NUM% = CITEM.SESS.NUM% THEN BEGIN                  ! BPAB  !1.8NWB
11594: 3db7: \        GOTO UNDO.CSRITEM.CONTINUE                                ! BPAB      !1.8NWB
11595: 3db7: \     ENDIF                                                ! BPAB              !1.8NWB
11596: 3db7: 
11597: 3db7:       RECEIVE.STATE$ = "*"                                    ! GDS
11598: 3dce: 
11599: 3dce:       SB.EVENT.NO% = 0
11600: 3ddb: \     SB.UNIQUE$ = LEFT$(LOCATION$ + STRING$(10, " "), 10)                     !1.8NWB
11601: 3ddb:       SB.UNIQUE$ = LEFT$(            STRING$(10, " "), 10)                     !1.8NWB
11602: 3e0b:       SB.MESSAGE$ = "MOD 1 READ ERROR COULD NOT BE HANDLED"
11603: 3e20:       GOSUB SB.LOG.AN.EVENT
11604: 3e32: 
11605: 3e32:       GOTO MODULE.EXIT
11606: 3e3d: 
11607: 3e3d: \******************************************************************************
11608: 3e3d: \***
11609: 3e3d: \***   WRITE.ERROR:
11610: 3e3d: \***
11611: 3e3d: \***      log an event 6 (write error)
11612: 3e3d: \***      set RECEIVE.STATE$ to "*"
11613: 3e3d: \***
11614: 3e3d: \***      if the source of the error is known then return to one of the
11615: 3e3d: \***      specified return points so the program does not end
11616: 3e3d: \***
11617: 3e3d: \***   GOTO MODULE.EXIT (no return is possible)
11618: 3e3d: \***
11619: 3e3d: \******************************************************************************
11620: 3e3d: 
11621: 3e3d:    WRITE.ERROR:
11622: 3e4d: 
11623: 3e4d:       TEMP.STATE$ = RECEIVE.STATE$
11624: 3e69:       GOSUB SB.FILE.WRITE.ERROR
11625: 3e7b:       RECEIVE.STATE$ = "*"                                              ! GDS
11626: 3e92: 
11627: 3e92:    GOTO MODULE.EXIT
11628: 3e9d: 
11629: 3e9d: \******************************************************************************
11630: 3e9d: \***
11631: 3e9d: \***   DELETE.ERROR:
11632: 3e9d: \***
11633: 3e9d: \***      log an event 6 (delete error)
11634: 3e9d: \***      set RECEIVE.STATE$ to "*"
11635: 3e9d: \***
11636: 3e9d: \***      if the source of the error is known then return to one of the
11637: 3e9d: \***      specified return points so the program does not end
11638: 3e9d: \***
11639: 3e9d: \***   GOTO MODULE.EXIT (no return is possible)
11640: 3e9d: \***
11641: 3e9d: \******************************************************************************
11642: 3e9d: 
11643: 3e9d:    DELETE.ERROR:
11644: 3ead: 
11645: 3ead:       TEMP.STATE$ = RECEIVE.STATE$
11646: 3ec9:       GOSUB SB.FILE.DELETE.ERROR
11647: 3edb: \     IF CURR.SESS.NUM% = IDSOF.SESS.NUM% THEN BEGIN                  ! ILC    !1.8NWB
11648: 3edb: \        IF MANUAL.COUNT$ = "Y" THEN BEGIN                        ! ILC        !1.8NWB
11649: 3edb: \         GOTO RETURN.FROM.IDSOF.DELETE.ERROR.2                  ! ILC         !1.8NWB
11650: 3edb: \         MANUAL.COUNT$ = "N"                                    ! ILC         !1.8NWB
11651: 3edb: \      ENDIF ELSE BEGIN                                    ! ILC               !1.8NWB
11652: 3edb: \         GOTO RETURN.FROM.IDSOF.DELETE.ERROR                        ! ILC     !1.8NWB
11653: 3edb: \      ENDIF                                                ! ILC              !1.8NWB
11654: 3edb: \     ENDIF                                                ! ILC               !1.8NWB
11655: 3edb:       RECEIVE.STATE$ = "*"                                              ! GDS
11656: 3ef2: 
11657: 3ef2:    GOTO MODULE.EXIT
11658: 3efd: 
11659: 3efd: \******************************************************************************
11660: 3efd: \***
11661: 3efd: \***   CREATE.ERROR:
11662: 3efd: \***
11663: 3efd: \***      log an event 6 (create error)
11664: 3efd: \***      set RECEIVE.STATE$ to "*"
11665: 3efd: \***
11666: 3efd: \***      if the source of the error is known then return to one of the
11667: 3efd: \***      specified return points so the program does not end
11668: 3efd: \***
11669: 3efd: \***   GOTO MODULE.EXIT (no return is possible)
11670: 3efd: \***
11671: 3efd: \******************************************************************************
11672: 3efd: 
11673: 3efd:    CREATE.ERROR:
11674: 3f0d: 
11675: 3f0d:       TEMP.STATE$ = RECEIVE.STATE$
11676: 3f29:       GOSUB SB.FILE.CREATE.ERROR
11677: 3f3b:       RECEIVE.STATE$ = "*"                                              ! GDS
11678: 3f52: 
11679: 3f52:    GOTO MODULE.EXIT
11680: 3f5d: 
11681: 3f5d: \******************************************************************************
11682: 3f5d: \***
11683: 3f5d: \***   ERROR.DETECTED:
11684: 3f5d: \***
11685: 3f5d: \***      if an error has occurred after a 'fatal' error then quit program
11686: 3f5d: \***
11687: 3f5d: \***      increment ERROR.COUNT%
11688: 3f5d: \***      NOTE : all returns from error detected should decrement the
11689: 3f5d: \***             variable ERROR.COUNT% and exit using the RESUME command
11690: 3f5d: \***      if ERROR.COUNT% > 1 then end program (error within error detected)
11691: 3f5d: \***
11692: 3f5d: \***   If the CSR workfile cannot be deleted then resume retry for 5 seconds.
11693: 3f5d: \***
11694: 3f5d: \***      if the CSR workfile does not exist then resume
11695: 3f5d: \***
11696: 3f5d: \***      set-up common error reporting information
11697: 3f5d: \***
11698: 3f5d: \***      if the error is an access conflict on CSR, EPSOM or PCHK files then
11699: 3f5d: \***          resume at FILE.CONFLICT
11700: 3f5d: \***
11701: 3f5d: \***      if unable to open PSS38 communication pipes then
11702: 3f5d: \***         wait 3 seconds then retry
11703: 3f5d: \***      endif
11704: 3f5d: \***
11705: 3f5d: \***      if an access conflict occurs on a session then retry
11706: 3f5d: \***
11707: 3f5d: \***      if error is invalid characters in VAL() then
11708: 3f5d: \***         store RECEIVE.STATE$
11709: 3f5d: \***         set RECEIVE.STATE$ to "*"
11710: 3f5d: \***         use stored receive state variable to decide where to resume
11711: 3f5d: \***      endif
11712: 3f5d: \***
11713: 3f5d: \***      if error is out of memory then log an event, using ADXERROR and
11714: 3f5d: \***      quit program
11715: 3f5d: \***
11716: 3f5d: \***      log an event 1
11717: 3f5d: \***
11718: 3f5d: \***   resume MODULE.EXIT
11719: 3f5d: \***
11720: 3f5d: \******************************************************************************
11721: 3f5d: 
11722: 3f5d: ERROR.DETECTED:
11723: 3f6d: 
11724: 3f6d:    IF ERR = "CU" OR ERR = "DF" THEN RESUME
11725: 3fdb: 
11726: 3fdb:    IF (ERRN = 00000052h) AND (LDTAF.LINK.TYPE%<>0) THEN RESUME             ! MMJK
11727: 4020: 
11728: 4020:    ERROR.COUNT% = ERROR.COUNT% + 1
11729: 402f:    IF ERROR.COUNT% > 1 THEN RESUME PROGRAM.EXIT
11730: 4050: 
11731: 4050:    GOSUB SB.FORMAT.ERROR.DATA
11732: 4062: 
11733: 4062: \  IF ERRN = 80204001H AND SB.FILE.REP.NUM% = CSRWF.REPORT.NUM% THEN BEGIN ! NN!1.8NWB
11734: 4062: \     ERROR.COUNT% = ERROR.COUNT% - 1                                  ! NNS   !1.8NWB
11735: 4062: \     RECEIVE.STATE$ = "*"                                             ! NNS   !1.8NWB
11736: 4062: \     RESUME MODULE.EXIT                                               ! NNS   !1.8NWB
11737: 4062: \  ENDIF                                                               ! NNS   !1.8NWB
11738: 4062: 
11739: 4062: 
11740: 4062:    IF (ERRN AND 0000FFFFh) = 400Ch THEN BEGIN
11741: 409c:       ERROR.COUNT% = ERROR.COUNT% - 1
11742: 40ab:       RESUME RETRY
11743: 40c2:    ENDIF
11744: 40ca: 
11745: 40ca:    IF ERR = "OM" THEN BEGIN
11746: 40f0:       CALL ADXERROR(0, 74, 0, 3, 1, SB.UNIQUE$ )
11747: 4118:       ERROR.COUNT% = ERROR.COUNT% - 1
11748: 4127:       RESUME PROGRAM.EXIT
11749: 413e:    ENDIF
11750: 4146: 
11751: 4146:    SB.EVENT.NO% = 101
11752: 4153:    SB.UNIQUE$ = SB.ERRS$ + SB.ERRF$ +                               \ KMJK
11753: 41b3:                 PACK$(RIGHT$(STRING$(8,"0")+SB.ERRL$,8))            ! KMJK
11754: 41b3:    GOSUB SB.LOG.AN.EVENT
11755: 41c5: 
11756: 41c5:    ERROR.COUNT% = ERROR.COUNT% - 1
11757: 41d4:    RECEIVE.STATE$ = "*"                                                 ! GDS
11758: 41eb:    RESUME MODULE.EXIT
11759: 4202: 
11760: 4202: END SUB
11761: 4216: End of Compilation
