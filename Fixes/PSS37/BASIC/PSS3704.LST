   1: 0000: \******************************************************************************
   2: 0000: \******************************************************************************
   3: 0000: \***
   4: 0000: \***   $Workfile:   PSS3704.bas  $
   5: 0000: \***
   6: 0000: \***   $Revision:   1.18  $
   7: 0000: \***
   8: 0000: \******************************************************************************
   9: 0000: \******************************************************************************
  10: 0000: \***
  11: 0000: \***   $Log:   V:/Archive/Basarch/PSS3704.bav  $
  12: 0000: \***   
  13: 0000: \***      Rev 1.18   02 Jul 2007 12:44:48   greenfield.brian
  14: 0000: \***   Changes for A7C Recalls.
  15: 0000: \***   
  16: 0000: \***      Rev 1.17   24 Dec 2004 13:04:44   dev07ps
  17: 0000: \***   A5A Shelf Monitor Project
  18: 0000: \***   
  19: 0000: \***   
  20: 0000: \***      Rev 1.16   20 Apr 2004 13:51:52   devjsps
  21: 0000: \***   Changes to Goods Out functionality 
  22: 0000: \***   as part of A4D package upgrade
  23: 0000: \***
  24: 0000: \***      Rev 1.15   20 Feb 2004 11:26:32   devjsps
  25: 0000: \***   Code change for goods out functionality
  26: 0000: \***   If item qty * item price > 999999 then the item
  27: 0000: \***   will be split into individual records
  28: 0000: \***
  29: 0000: \***      Rev 1.14   16 Dec 2003 09:09:42   devjsps
  30: 0000: \***   Program updated to add Pharmacy Smartscript
  31: 0000: \***   Stock count changes and Credit Claim changes.
  32: 0000: \***   David Artiss has also added Stock takings changes
  33: 0000: \***   to PSB3704.BAS
  34: 0000: \***
  35: 0000: \***      Rev 1.13   09 Jul 2003 11:17:08   dev38ps
  36: 0000: \***   Ensure LOCCNT is opened whether it's a normal stocktake or BOL one.
  37: 0000: \***
  38: 0000: \***      Rev 1.11   29 Oct 2002 08:37:26   dev38ps
  39: 0000: \***   Improved stocktaking auditing
  40: 0000: \***
  41: 0000: \***      Rev 1.10   12 Oct 2001 12:03:56   DEV38PS
  42: 0000: \***   Added LDT audit file processing
  43: 0000: \***
  44: 0000: \***      Rev 1.9   08 Apr 1998 11:08:14   DEV45PS
  45: 0000: \***   Changes to cope with dates of '000000' and '999999' and to include revised CMPDATE
  46: 0000: \***
  47: 0000: \***      Rev 1.8   05 Feb 1998 11:58:26   DEV45PS
  48: 0000: \***
  49: 0000: \***
  50: 0000: \***      Rev 1.7   07 Oct 1997 14:01:52   DEV45PS
  51: 0000: \***   Changed quantity & price on STKBF to unpacked
  52: 0000: \***
  53: 0000: \***      Rev 1.6   25 Sep 1997 13:22:30   DEV45PS
  54: 0000: \***   Increased processing speed of data from stocktake PDT. Also now sends acknowledgement back to PDT after transmission.
  55: 0000: \***
  56: 0000: \***      Rev 1.5   10 Sep 1997 11:44:38   DEV45PS
  57: 0000: \***   Changes For Stocktake System - Processes transmissions from stocktake PDT's
  58: 0000: \***
  59: 0000: \***      Rev 1.4   17 Jul 1996 11:03:56   DEVDSPS
  60: 0000: \***   ECC enhancements - Download despatched UODs to LDT.
  61: 0000: \***
  62: 0000: \***      Rev 1.3   15 Feb 1995 12:57:56   NIK
  63: 0000: \***   Additional Returns Amendment.
  64: 0000: \***
  65: 0000: \***
  66: 0000: \***      Rev 1.2   14 Feb 1995 11:44:38   NIK
  67: 0000: \***   Fixes to Boots Problems 1248, 1245, 1246, 1318, 1105
  68: 0000: \***
  69: 0000: \***      Rev 1.1   07 Oct 1994 15:51:44   DEVSPPS
  70: 0000: \***   Fixed PDT Support hang
  71: 0000: \***
  72: 0000: \******************************************************************************
  73: 0000: \******************************************************************************
  74: 0000: 
  75: 0000: \******************************************************************************
  76: 0000: \******************************************************************************
  77: 0000: \***                                                                        ***
  78: 0000: \***                                                                        ***
  79: 0000: \***           PROGRAM  :  PSS3704                                          ***
  80: 0000: \***                                                                        ***
  81: 0000: \***           AUTHOR   :  Michael J. Kelsall                               ***
  82: 0000: \***                                                                        ***
  83: 0000: \***           DATE     :  04th October 1993                                ***
  84: 0000: \***                                                                        ***
  85: 0000: \***                                                                        ***
  86: 0000: \***           Current version letter : B                                   ***
  87: 0000: \***                                                                        ***
  88: 0000: \***           Date of last update:  17th May 1994  Michael J. Kelsall      ***
  89: 0000: \***                                                                        ***
  90: 0000: \***                                                                        ***
  91: 0000: \******************************************************************************
  92: 0000: \******************************************************************************
  93: 0000: 
  94: 0000: \******************************************************************************
  95: 0000: \******************************************************************************
  96: 0000: \***                                                                        ***
  97: 0000: \***   O V E R V I E W                                                      ***
  98: 0000: \***                                                                        ***
  99: 0000: \***                                                                        ***
 100: 0000: \***   PSS37 - P.D.T. / L.D.T. Support Program.                             ***
 101: 0000: \***                                                                        ***
 102: 0000: \***                                                                        ***
 103: 0000: \***   PSS37 is designed to run concurrently with PSS38. PSS38 handles      ***
 104: 0000: \***   all asyncronous communications with a connected PDT/LDT. All data    ***
 105: 0000: \***   sent by the PDT/LDT is passed to PSS37 via PSS38 by means of a pipe. ***
 106: 0000: \***   PSS37 validates the data sent to ensure the data has been sent in    ***
 107: 0000: \***   the correct sequence, has a valid format and is meaningful.          ***
 108: 0000: \***                                                                        ***
 109: 0000: \***                                                                        ***
 110: 0000: \***   This module was created to handle the RETURNS/AUTOMATIC CREDIT       ***
 111: 0000: \***   CLAIMING processing. This application will allow a user to transfer  ***
 112: 0000: \***   RETURNS data captured via the LDT. This information will then be     ***
 113: 0000: \***   used to update relevent controller files, including the generation   ***
 114: 0000: \***   of stock movements that will be processed by Stock Support.            ***
 115: 0000: \***   The application will also provide the ability to download current    ***
 116: 0000: \***   versions of the RETURNS data files contained within the CCUOD and    ***
 117: 0000: \***   CCITM files.                                                         ***
 118: 0000: \***                                                                        ***
 119: 0000: \******************************************************************************
 120: 0000: \******************************************************************************
 121: 0000: 
 122: 0000: \******************************************************************************
 123: 0000: \******************************************************************************
 124: 0000: \***                                                                        ***
 125: 0000: \***    A M E N D M E N T S                                                 ***
 126: 0000: \***                                                                        ***
 127: 0000: \***    Version A (Supplemental)  David Smallwood         13 January 1994   ***
 128: 0000: \***    Change to processing flow - only write CCTMP to STKMQ after         ***
 129: 0000: \***    LDT has completed housekeeping.                                     ***
 130: 0000: \***                                                                        ***
 131: 0000: \***    Version B  Michael J. Kelsall                     23rd March 1994   ***
 132: 0000: \***    Changes required due to modifications to system;                    ***
 133: 0000: \***    - Change to throw out UOD records if the current status of the UOD  ***
 134: 0000: \***       (as per the CCUPF) has changed since the data was down loaded to ***
 135: 0000: \***       the LDT, this can occur if two LDTs log on one immediately after ***
 136: 0000: \***       the other and they have different updates made against the same  ***
 137: 0000: \***       UOD's.                                                           ***
 138: 0000: \***    - Removal of CCTRL locked access to prevent access conflicts.       ***
 139: 0000: \***    - Changes to process four digit quantity fields from the LDT as     ***
 140: 0000: \***       opposed to the original three digits.                            ***
 141: 0000: \***    - Change to remove reseting of item index against items within a    ***
 142: 0000: \***       UOD. This value should be sequential throughout all the items    ***
 143: 0000: \***       passed to the LDT via the LDTWF.                                 ***
 144: 0000: \***    - Change to pass the UOD index before the Item index in the data    ***
 145: 0000: \***    - Change to pass only item codes for any closed UOD's, Barcodes     ***
 146: 0000: \***       do not need to be sent to the LDT                                ***
 147: 0000: \***    - Change to add primer UOD records to the CCUPF to prevent          ***
 148: 0000: \***       duplicate processing if transmission fails.                      ***
 149: 0000: \***       (Primer record in CCUPF will be based on 00000000hhmmss).        ***
 150: 0000: \***    - Change to sort Barcodes sent to LDT using UOD and item pos table  ***
 151: 0000: \***       as well as the barcode table.                                    ***
 152: 0000: \***    - Change to re-create CCUPF if data file loss detected.             ***
 153: 0000: \***                                                                        ***
 154: 0000: \***    Version B (Supplemental)  Michael J. Kelsall      03rd June 1994    ***
 155: 0000: \***    - Change to prevent update of LDT number on CCUOD if all records    ***
 156: 0000: \***       in CCTMP are suppressed and hence type 27 will also be           ***
 157: 0000: \***       suppressed.                                                      ***
 158: 0000: \***                                                                        ***
 159: 0000: \***    Version B (Supplemental)  Michael J. Kelsall      15th June 1994    ***
 160: 0000: \***    - Change to correct problem in CCWKF creation routine; Problem      ***
 161: 0000: \***       appears during processing of excessive number of items resulting ***
 162: 0000: \***       in failure of LEN command (returns 2INT therefore result turns   ***
 163: 0000: \***       negative if string longer than 32767 characters!)                ***
 164: 0000: \***
 165: 0000: \***    REVISION 1.1     ROBERT COWEY / STEVE WRIGHT      6TH OCTOBER 1994
 166: 0000: \***    Removed version letters from included code (notcommented).
 167: 0000: \***
 168: 0000: \***    Version C              Nik Sen                 3rd February 1995
 169: 0000: \***    Change to fix Boots Problem 1318 (duplicate returns information
 170: 0000: \***    being written to Stock Movement Queue). Transfer of CCTMP to
 171: 0000: \***    STKMQ now takes place after End Of Transmission received.
 172: 0000: \***    CCUPF no longer updated by primer UOD's.
 173: 0000: \***
 174: 0000: \***    Version 1.4            David Smallwood        21st May 1996
 175: 0000: \***    Change to transmit all despatched UODs to LDT as well as open
 176: 0000: \***    and closed UODs.  Despatched UODs taken from CCLAM file.  This
 177: 0000: \***    change is part of ECC enhancements and will help prevent duplicate
 178: 0000: \***    claims returning to the centre.
 179: 0000: \***
 180: 0000: \***    Version 1.5            Nik Sen                 30th June 1997
 181: 0000: \***    Added data states p,q,r for stocktake processing.
 182: 0000: \***
 183: 0000: \***    Version 1.6            Nik Sen                 22nd September 1997
 184: 0000: \***    Changed copy of stocktake temporary file to buffer file to speed it up.
 185: 0000: \***
 186: 0000: \***    Version 1.7            Nik Sen                 7th October 1997
 187: 0000: \***    Fixed pilot problem - data now written to STKBF unpacked.
 188: 0000: \***
 189: 0000: \***    Version 1.8            Nik Sen                 19th November 1997
 190: 0000: \***    Y2000 changes. Date comparisons in RECEIVED.RETURNS.FILE.ID.
 191: 0000: \***
 192: 0000: \***    Version 1.9            Nik Sen                 10th December 1997
 193: 0000: \***    Changes to accept altered file format from stocktake PDT.
 194: 0000: \***
 195: 0000: \***    Version 1.10           Nik Sen                 1st April 1998
 196: 0000: \***    Changed Y2000 code to cope with dates of '000000'. (Yes really even
 197: 0000: \***    though it is April 1st).
 198: 0000: \***
 199: 0000: \***    Version 1.11           David Artiss            23rd January 2001
 200: 0000: \***    Added stocktake audit file STLDT - details of stocktaking transmissions
 201: 0000: \***    written to it for confirmation purposes.
 202: 0000: \***
 203: 0000: \***    Version 1.12           David Artiss            5th September 2002
 204: 0000: \***    Moved the writing to the STLDT file so it only updates after a
 205: 0000: \***    totally successful transmission.
 206: 0000: \***
 207: 0000: \***    Version 1.13           David Artiss                7th March 2003
 208: 0000: \***    Added new processing to allow stocktake PDTs with other stores
 209: 0000: \***    data to be transmitted and sent straight to the appropriate
 210: 0000: \***    mainframe file.
 211: 0000: \***
 212: 0000: \***    Version 1.14           David Artiss                 23rd May 2003
 213: 0000: \***    Ensure LOCCNT is opened whether it's a normal stocktake or BOL one.
 214: 0000: \***
 215: 0000: \***    Version 1.15           David Artiss                25th July 2003
 216: 0000: \***    Decimal places are now written to STLDT.
 217: 0000: \***
 218: 0000: \***    Version 1.16           Julia Stones                14th November 2003
 219: 0000: \***    As part of the Simplification of the Credit Claiming project a new
 220: 0000: \***    Option has been added to the PDT/LDT STOCKROOM Menu
 221: 0000: \***    Option 3 Credit Claiming
 222: 0000: \***    The existing Goods Out Data States will be used.  The only change to
 223: 0000: \***    these being Data State (g) (Received Returns File ID). This will
 224: 0000: \***    contain an extra 1 byte ASCII field, set to either "G" Goods out or
 225: 0000: \***    "O" Credit Claiming.
 226: 0000: \***    Code has been added to this module to process the new credit Claiming
 227: 0000: \***    data and write out a stock movement type 25.
 228: 0000: \***    If any items have been rejected then a report will be printed directly
 229: 0000: \***    onto the printer
 230: 0000: \***
 231: 0000: \***    Version 1.17         Julia Stones                 17th February 2004
 232: 0000: \***    As part of the stock loss investigation it was found that when an
 233: 0000: \***    electronic credit claim was made and the item qty * item price exceeded
 234: 0000: \***    £9,999.99 the most significant digits above this value are lost.
 235: 0000: \***    The problem is with the CCITF.BIN file, this can only hold a 3 byte UPD
 236: 0000: \***    value.  When Stock support updates the CCITF it calculates the total item
 237: 0000: \***    value and when this is then written to the CCITF file anything above £9,999.99
 238: 0000: \***    is lost (the stock movement record is OK as this holds the individual item price)
 239: 0000: \***    The code for Other Credit Claim is being changed to check the value of
 240: 0000: \***    the item qty * item price, if this exceeds £9,999.99 then this item will
 241: 0000: \***    be split into individual items.  (Goods out is not being changed)
 242: 0000: \***
 243: 0000: \***    Version 1.18        Julia Stones                  12th March 2004
 244: 0000: \***    Added code to write out rejection information to the new CCREJ file
 245: 0000: \***    where a Goods out transmission or Other Credit Claim transmission has
 246: 0000: \***    been performed and items are removed from the claim as they are either
 247: 0000: \***    for an invalid business centre or the item does not exist on both the
 248: 0000: \***    IDF and IRF.
 249: 0000: \***    Items not on file has been commmented out (may only be a requirement
 250: 0000: \***    if all items in all Stores project is initiated).
 251: 0000: \***    Goods Out transmission will only reject items where the item business
 252: 0000: \***    centre does not match the claim business centre if the rejection flag
 253: 0000: \***    on softs is set to all (the right most value on CREDIT.CLAIM.FLAG$) = "Y"
 254: 0000: \***    Removed all the code for writing out to the rejection report and the
 255: 0000: \***    printing of the rejection report.
 256: 0000: \***    Upon the end of a Goods Out or Other Credit claim transmission if there
 257: 0000: \***    are any records in the CCREJ file then ADXSTART new program PSS25 to print
 258: 0000: \***    the rejection report (the rejection report must print before any advice
 259: 0000: \***    of contents reports are produced.
 260: 0000: \***
 261: 0000: \***    Version 1.19        Charles Skadorwa                  2nd November 2004
 262: 0000: \***    Increased CCLAM table size from 400 to 1600 in  
 263: 0000: \***    subroutine: DIRECT.EXTRACT.CCLAM.KEYS
 264: 0000: \***    Store 7 West Hallam (warehouse) have exceeded the old limit due to an 
 265: 0000: \***    increase in claiming (inter-store transfer of stock). This prevented 
 266: 0000: \***    the PDT's working when using Goods Out.
 267: 0000: \***
 268: 0000: \***    Version 1.20        Brian Greenfield                  14th may 2007
 269: 0000: \***    Added CCTMP.RECALL.TYPE$ for use with A7C Recalls - only used for
 270: 0000: \***    type 26 record when written to the STKMQ.
 271: 0000: \******************************************************************************
 272: 0000: \******************************************************************************
 273: 0000: 
 274: 0000: \******************************************************************************
 275: 0000: \******************************************************************************
 276: 0000: \***                                                                        ***
 277: 0000: \***   I N C L U D E S   A N D   V A R I A B L E S                          ***
 278: 0000: \***                                                                        ***
 279: 0000: \******************************************************************************
 280: 0000: \******************************************************************************
 281: 0000: 
 282: 0000:    INTEGER*1 GLOBAL STOCKTAKING.ALTERNATIVE.STORE                      ! 1.13DA
 283: 0000: 
 284: 0000:    %INCLUDE PSS37G.J86                                                 ! BMJK
 285: 0000: \*****************************************************************************
 286: 0000: \*****************************************************************************
 287: 0000: \***                                                                       ***
 288: 0000: \***      G L O B A L   D E F I N I T I O N S   F O R   P S S 3 7          ***
 289: 0000: \***                                                                       ***
 290: 0000: \***           REFERENCE : PSS37G                                          ***
 291: 0000: \***                                                                       ***
 292: 0000: \***           VERSION E                                                   ***
 293: 0000: \***           5th November 1992                                           ***
 294: 0000: \***           Ver D.  Add support for ADXSERCL routine.                   ***
 295: 0000: \***           Ver E.  Add support for LDTBF                               ***
 296: 0000: \***                                                                       ***
 297: 0000: \***                                                                       ***
 298: 0000: \***           Version G                                                   ***
 299: 0000: \***           Add support for Returns/Automatic credit claiming           ***
 300: 0000: \***                                                                       ***
 301: 0000: \***           Version H  Michael J. Kelsall    24th March 1994.           ***
 302: 0000: \***           Add support for CCUPF                                       ***
 303: 0000: \***
 304: 0000: \***           REVISION 1.1  ROBERT COWEY / STEVE WRIGHT  6TH OCTOBER 1994
 305: 0000: \***           Removed version letters from included code (not commented).
 306: 0000: \***
 307: 0000: \***           REVISION 1.2  David Smallwood    26th May 1995
 308: 0000: \***           Add global variable ALLOW.CSR.PROCESSING.
 309: 0000: \***
 310: 0000: \***           REVISION 1.3  Stuart Highly      April 1996
 311: 0000: \***           Gap monitor changes
 312: 0000: \***
 313: 0000: \***           REVISION 1.4  David Smallwood    21st May 1996
 314: 0000: \***           Change global variable "NUM.OF.UODS%" to
 315: 0000: \***           "NUM.STATUS.O.C.X.UODS%".  Add variables "NUM.OF.CANCELLED.UODS%"
 316: 0000: \***           "NUM.OF.DESPATCHED.UODS%".  Add global variables for CCLAM.
 317: 0000: \***
 318: 0000: \***           REVISION 1.5  Nik Sen            30th June 1997
 319: 0000: \***           Add variables for SXTMP STKTK and STKBUF for stocktaking.
 320: 0000: \***
 321: 0000: \***           REVISION 1.6  David Artiss       23rd January 2001
 322: 0000: \***           Add new audit file STLDT
 323: 0000: \***
 324: 0000: \***           REVISION 1.7  Brian Greenfield   17th October 2002
 325: 0000: \***           Added LSSST and IMSTC for LSS stock counts.
 326: 0000: \***
 327: 0000: \***           REVISION 1.8  David Artiss       7th March 2003
 328: 0000: \***           Lots of file and field definitions added for BOL
 329: 0000: \***           stocktake changes.
 330: 0000: \***
 331: 0000: \***           REVISION 1.9  Brian Greenfield   18th July 2003
 332: 0000: \***           New file additions for Store Stock Counts
 333: 0000: \***
 334: 0000: \***           REVISION 2.0  Julia Stones      22nd October 2003
 335: 0000: \***           New file additions for SmartScript Pharmacy Stock system
 336: 0000: \***
 337: 0000: \***           REVISION 2.1  Julia Stones      12th November 2003
 338: 0000: \***           New file additions for Simplification of the credit claim system
 339: 0000: \***
 340: 0000: \***           REVISION 2.2 Julia Stones       12th March 2004
 341: 0000: \***           New file addition for Credit Claim rejection information
 342: 0000: \***
 343: 0000: \***           REVISION 2.3 Charles Skadorwa   10th November 2004
 344: 0000: \***           Shelf Monitor Project: add declarations for PLLOL & PLLDB files
 345: 0000: \***
 346: 0000: \***           REVISION 2.4 Brian Greenfield   11th January 2005
 347: 0000: \***           Fixes to allow old record type P and new record type P to both work.
 348: 0000: \***           The old record type P can be removed next time this module is
 349: 0000: \***           altered.
 350: 0000: \***
 351: 0000: \***           REVISION 2.5    Neil Bennett    22nd December 2006
 352: 0000: \***           Add ASN processing support.
 353: 0000: \***           Remove CSR processing support.
 354: 0000: \***
 355: 0000: \***           REVISION 2.6    Brian Greenfield 11th may 2007
 356: 0000: \***           Added recalls processing for A7C.
 357: 0000: \***
 358: 0000: \*****************************************************************************
 359: 0000: \*****************************************************************************
 360: 0000: 
 361: 0000: \*****************************************************************************
 362: 0000: \***   include global definitions for the following functions and procedures
 363: 0000: \***
 364: 0000: \***     APPLICATION.LOG              01
 365: 0000: \***     READ.NEXT.IEF                11
 366: 0000: \***     SORT.TABLE                   14
 367: 0000: \***     CONV.TO.HEX                  16
 368: 0000: \***     CONV.TO.STRING               17
 369: 0000: \***     SESS.NUM.UTILITY             20
 370: 0000: \***     CIMF
 371: 0000: \***     CITEM
 372: 0000: \***     CSR
 373: 0000: \***     CSRWF
 374: 0000: \***     CSRBF
 375: 0000: \***     FPF
 376: 0000: \***     IDF
 377: 0000: \***     IDSOF
 378: 0000: \***     INVOK
 379: 0000: \***     ONORD
 380: 0000: \***     PCHK
 381: 0000: \***     PIPEI
 382: 0000: \***     UNITS
 383: 0000: \***     STKMQ
 384: 0000: \***     BCSMF
 385: 0000: \***     IEF
 386: 0000: \***     DIRORD
 387: 0000: \***     DIRSUP
 388: 0000: \***     DIRWF
 389: 0000: \***     DIR
 390: 0000: \***     LDTBF
 391: 0000: \***     LDTCF
 392: 0000: \***     UOD
 393: 0000: \***     UODBF
 394: 0000: \***     UODTF
 395: 0000: \***     STKBF
 396: 0000: \***     SXTMP
 397: 0000: \***     STKTK
 398: 0000: \***     SSPSC
 399: 0000: \***     BTCS
 400: 0000: \***     PRINT
 401: 0000: \***     SOPTS
 402: 0000: \***     TSF
 403: 0000: \***     LOCAL
 404: 0000: \***
 405: 0000: \*****************************************************************************
 406: 0000: 
 407: 0000:  %INCLUDE PSBF01G.J86                     ! FLC
 408: 0000: REM \
 409: 0000: \*******************************************************************************
 410: 0000: \*******************************************************************************
 411: 0000: \***
 412: 0000: \***       %INCLUDE FOR GLOBAL DEFINITIONS FOR FUNCTION APPLICATION.LOG
 413: 0000: \***
 414: 0000: \***                FUNCTION NUMBER    : PSBF01
 415: 0000: \***
 416: 0000: \***                REFERENCE          : PSBF01G.J86
 417: 0000: \***
 418: 0000: \***                DATE OF LAST AMENDMENT  - 27/2/86
 419: 0000: \***
 420: 0000: \***
 421: 0000: \*******************************************************************************
 422: 0000: 
 423: 0000:       INTEGER GLOBAL  F01.RETURN.CODE%
 424: 0000: 
 425: 0000: 
 426: 0000:  %INCLUDE PSBF05G.J86                     ! 1.9BG
 427: 0000: REM\
 428: 0000: \*******************************************************************************
 429: 0000: \*******************************************************************************
 430: 0000: \***
 431: 0000: \***        INCLUDE       : CHECK.BOOTS.CODE globals
 432: 0000: \***
 433: 0000: \***        REFERENCE     : PSBF05G.J86
 434: 0000: \***
 435: 0000: \***        Version A      Bruce Scriver              25th February 1986
 436: 0000: \*** 
 437: 0000: \***        Version B      Andrew Wedgeworth              15th July 1992
 438: 0000: \***        Removal of return code field which no longer required.
 439: 0000: \***
 440: 0000: \*******************************************************************************
 441: 0000: \*******************************************************************************
 442: 0000: 
 443: 0000:       STRING   GLOBAL F05.VALID.CODE$
 444: 0000: 
 445: 0000: 
 446: 0000: !%INCLUDE PSBF06G.J86                     ! FLC
 447: 0000:  %INCLUDE PSBF11G.J86                     ! DLC
 448: 0000: REM \
 449: 0000: \*******************************************************************************
 450: 0000: \*******************************************************************************
 451: 0000: \***
 452: 0000: \***    %INCLUDE FOR GLOBALS DEFINITIONS FOR FUNCTION READ.NEXT.IEF
 453: 0000: \***
 454: 0000: \***            FUNCTION NUMBER    : PSBF11
 455: 0000: \***
 456: 0000: \***            REFERENCE          : PSBF11G.J86
 457: 0000: \***
 458: 0000: \***    Version B            Bruce Scriver             11th December 1986 
 459: 0000: \***
 460: 0000: \***    Version C            Andrew Wedgeworth             15th July 1992
 461: 0000: \***    Redundant return code field removed.
 462: 0000: \***
 463: 0000: \*******************************************************************************
 464: 0000: \*******************************************************************************
 465: 0000: 
 466: 0000:       STRING    GLOBAL  F11.ERROR.FLAG$,                               \ BBAAS
 467: 0000:                         F11.NEXT.BAR.CODE$                             ! BBAAS
 468: 0000: 
 469: 0000:       INTEGER*2 GLOBAL  F11.CURRENT.COUNT%
 470: 0000: 
 471: 0000: 
 472: 0000:  %INCLUDE PSBF14G.J86                     ! DLC
 473: 0000: REM\
 474: 0000: \*******************************************************************************
 475: 0000: \*******************************************************************************
 476: 0000: \***
 477: 0000: \***        INCLUDE       : SORT.TABLE globals
 478: 0000: \***
 479: 0000: \***        REFERENCE     : PSBF14G.J86
 480: 0000: \***
 481: 0000: \***        Version A     Bruce Scriver                3rd March 1986
 482: 0000: \*** 
 483: 0000: \***        Version B     Andrew Wedgeworth            17th July 1992
 484: 0000: \***        Removal of now redundant return code field.
 485: 0000: \***
 486: 0000: \*******************************************************************************
 487: 0000: \*******************************************************************************
 488: 0000: 
 489: 0000:       STRING   GLOBAL F14.TABLE$(1)
 490: 0000: 
 491: 0000: 
 492: 0000:  %INCLUDE PSBF16G.J86                     ! DLC
 493: 0000: REM\
 494: 0000: \*******************************************************************************
 495: 0000: \*******************************************************************************
 496: 0000: \***
 497: 0000: \***           %INCLUDE GLOBAL DEFINITIONS FOR CONV.TO.HEX FUNCTION
 498: 0000: \***
 499: 0000: \***                       REFERENCE     : PSBF16G.J86
 500: 0000: \*** 
 501: 0000: \***       Version A           Bruce Scriver            25th February 1986
 502: 0000: \***
 503: 0000: \***       Version B         Andrew Wedgeworth               2nd July 1992
 504: 0000: \***       Removal of now redundant F16.RETURN.CODE%.
 505: 0000: \***
 506: 0000: \*******************************************************************************
 507: 0000: \*******************************************************************************
 508: 0000: 
 509: 0000:       STRING   GLOBAL F16.HEX.STRING$
 510: 0000: 
 511: 0000:       ! 1 line deleted from here                                       ! BAW
 512: 0000:  %INCLUDE PSBF17G.J86                     ! DLC
 513: 0000: REM \
 514: 0000: \*******************************************************************************
 515: 0000: \*******************************************************************************
 516: 0000: \***
 517: 0000: \***
 518: 0000: \***        %INCLUDE GLOBAL DEFINITIONS FOR CONV.TO.STRING FUNCTION
 519: 0000: \***
 520: 0000: \***                    REFERENCE     : PSBF17G.J86
 521: 0000: \***
 522: 0000: \***        Version A         Bruce Scriver      24th February 1986
 523: 0000: \***
 524: 0000: \***        Version B       Andrew Wedgeworth         2nd July 1992
 525: 0000: \***        Removal of now redundant F17.RETURN.CODE%
 526: 0000: \***
 527: 0000: \*******************************************************************************
 528: 0000: \*******************************************************************************
 529: 0000: 
 530: 0000:       STRING   GLOBAL F17.RETURNED.STRING$
 531: 0000: 
 532: 0000:       ! 1 line deleted from here                                       ! BAW
 533: 0000: 
 534: 0000:  %INCLUDE PSBF18G.J86                     ! 1.8DA
 535: 0000: REM\
 536: 0000: \*******************************************************************************
 537: 0000: \*******************************************************************************
 538: 0000: \***
 539: 0000: \***        INCLUDE       : CALC.BOOTS.CODE.CHECK.DIGIT globals
 540: 0000: \***
 541: 0000: \***        REFERENCE     : PSBF18G.J86
 542: 0000: \***
 543: 0000: \***        Version A     Stephen Kelsey                  23rd March 1987
 544: 0000: \***
 545: 0000: \***        Version B     Andrew Wedgeworth                 7th July 1992
 546: 0000: \***        Removal of return code field which no longer required.
 547: 0000: \***
 548: 0000: \*******************************************************************************
 549: 0000: \*******************************************************************************
 550: 0000: 
 551: 0000:       STRING   GLOBAL F18.CHECK.DIGIT$
 552: 0000:     
 553: 0000:       ! 1 line deleted from here                                       ! BAW    
 554: 0000: 
 555: 0000:  %INCLUDE PSBF20G.J86                     ! DLC
 556: 0000: REM\
 557: 0000: \*******************************************************************************
 558: 0000: \*******************************************************************************
 559: 0000: \***
 560: 0000: \***     %INCLUDE GLOBAL VARIABLE DEFINITIONS FOR SESS.NUM.UTILITY FUNCTION
 561: 0000: \***
 562: 0000: \***                       REFERENCE     : PSBF20G.J86
 563: 0000: \*** 
 564: 0000: \***     Version A              Bruce Scrive                   5th May 1988   
 565: 0000: \*** 
 566: 0000: \***     Version B              Robert Cowey                   7th May 1991
 567: 0000: \***     Global variable F20.INTEGER.FILE.NO% changed from one byte integer
 568: 0000: \***     to two byte integer.
 569: 0000: \***
 570: 0000: \***     Version D              Andrew Wedgeworth             1st July 1992
 571: 0000: \***     F20.RETURN.CODE% removed as it is no longer required.
 572: 0000: \***
 573: 0000: \*******************************************************************************
 574: 0000: \*******************************************************************************
 575: 0000: 
 576: 0000:       STRING    GLOBAL F20.FILE.NAME$,                                 \
 577: 0000:                        F20.STRING.FILE.NO$,                            \
 578: 0000:                        F20.TABLE.DIMENSIONED.FLAG$,                    \
 579: 0000:                        SESS.NUM.TABLE$(1)
 580: 0000: 
 581: 0000:       INTEGER*2 GLOBAL F20.INTEGER.FILE.NO%
 582: 0000: 
 583: 0000:       ! 1 line deleted from here                                       ! DAW 
 584: 0000: 
 585: 0000:  %INCLUDE PSBF21G.J86                     ! 1.9BG
 586: 0000: REM\
 587: 0000: \*******************************************************************************
 588: 0000: \*******************************************************************************
 589: 0000: \***
 590: 0000: \***        INCLUDE       : CHECK.BAR.CODE globals
 591: 0000: \***
 592: 0000: \***        REFERENCE     : PSBF21G.J86
 593: 0000: \***
 594: 0000: \***        Version A     Bruce Scriver                  13th May 1988
 595: 0000: \***
 596: 0000: \***        Version B     Andrew Wedgeworth             21st July 1992
 597: 0000: \***        Return code removed as no longer used.
 598: 0000: \***
 599: 0000: \*******************************************************************************
 600: 0000: \*******************************************************************************
 601: 0000: 
 602: 0000:       STRING    GLOBAL F21.VALID.CODE.FLAG$
 603: 0000: 
 604: 0000: 
 605: 0000: 
 606: 0000: !%INCLUDE ASYNCNUB.J86                    ! FLC
 607: 0000:  %INCLUDE CHKBFDEC.J86                    ! DLC
 608: 0000: \******************************************************************************
 609: 0000: \***
 610: 0000: \***           %INCLUDE FOR CHKBF - PRICE CHECK BUFFER FILE
 611: 0000: \***
 612: 0000: \***                    - FIELD DECLARATIONS   
 613: 0000: \***                    - FILE REFERENCE PARAMETERS  
 614: 0000: \***  
 615: 0000: \***                    REFERENCE: CHKBFDEC.J86
 616: 0000: \***
 617: 0000: \******************************************************************************
 618: 0000: 
 619: 0000:    INTEGER*1 GLOBAL				\
 620: 0000: 	CHKBF.SESS.NUM%
 621: 0000: 
 622: 0000:    INTEGER*2 GLOBAL				\
 623: 0000: 	CHKBF.RECL%,                            \
 624: 0000:         CHKBF.REPORT.NUM% 	
 625: 0000: 
 626: 0000:    INTEGER*4 GLOBAL				\ DLC
 627: 0000:         CHKBF.POINTER%
 628: 0000: 	
 629: 0000:    STRING GLOBAL			\
 630: 0000: 	CHKBF.ITEM.CODE$,	\ 13 byte ASC - bar code, as passed from PDT
 631: 0000: 	CHKBF.PRICE$,		\  6 byte ASC - price, as passed from PDT 
 632: 0000: 	CHKBF.FILLER$,		\  1 byte ASC - spare
 633: 0000: 	CHKBF.FILE.NAME$
 634: 0000:  %INCLUDE GAPBFDEC.J86                    ! SDH !2.3CS !2.4BG
 635: 0000: \*****************************************************************************
 636: 0000: \***                                                                         *
 637: 0000: \***           %INCLUDE FOR GAPBF - GAP BUFFER FILE                          *
 638: 0000: \***                                                                         *
 639: 0000: \***                    - FIELD DECLARATIONS                                 *
 640: 0000: \***                    - FILE REFERENCE PARAMETERS                          *
 641: 0000: \***                                                                         *
 642: 0000: \***                    REFERENCE: GAPBFDEC.J86                              *
 643: 0000: \***                                                                         *
 644: 0000: \*****************************************************************************
 645: 0000: 
 646: 0000:    INTEGER*1 GLOBAL            \
 647: 0000:    GAPBF.SESS.NUM%
 648: 0000: 
 649: 0000:    INTEGER*2 GLOBAL            \   
 650: 0000:    GAPBF.REPORT.NUM%    
 651: 0000: 
 652: 0000:    STRING GLOBAL               \
 653: 0000:    GAPBF.BOOTS.CODE$,          \ 7 bytes ASC - Item code
 654: 0000:    GAPBF.FILE.NAME$
 655: 0000:  %INCLUDE PLLOLDEC.J86                    ! 2.3CS
 656: 0000: 
 657: 0000: \******************************************************************************
 658: 0000: \******************************************************************************
 659: 0000: \***
 660: 0000: \***         %INCLUDE FOR RF PICKING LIST OF LISTS FILE FIELD DECLARATIONS
 661: 0000: \***
 662: 0000: \***               FILE TYPE    : DIRECT
 663: 0000: \***
 664: 0000: \***               REFERENCE    : PLLOLDEC.J86
 665: 0000: \***
 666: 0000: \***    VERSION A.           Julia Stones.               11 August 2004
 667: 0000: \***               New file for RF system. Holds list of picking lists.
 668: 0000: \***
 669: 0000: \***    VERSION B            Mark Goode                  17th January 2005
 670: 0000: \***    Additional field required to state the lists status ('S' - Shelf Monitor
 671: 0000: \***    'F' - Fast Fill, 'O' - OSSR or 'E' - excess stock.
 672: 0000: \*******************************************************************************
 673: 0000: \*******************************************************************************
 674: 0000: 
 675: 0000: STRING GLOBAL                                                  \
 676: 0000:    PLLOL.FILE.NAME$,           \
 677: 0000:    PLLOL.LISTID$,              \ 3 bytes unpacked list ID
 678: 0000:    PLLOL.CREATOR.ID$,          \ 3 bytes unpacked Creator user ID
 679: 0000:    PLLOL.PICKER.ID$,           \ 3 bytes unpacked Picker user ID
 680: 0000:    PLLOL.ITEM.STATUS$,         \ 1 byte item status " "
 681: 0000:                                \                    "P" = Picked
 682: 0000:                                \                    "U" = Unpicked
 683: 0000:                                \                    "A" = List is active (someone is picking it)
 684: 0000:                                \                    "X" = List is cancelled
 685: 0000:    PLLOL.CREATE.DATE$,         \ 6 bytes unpacked create date YYMMDD
 686: 0000:    PLLOL.CREATE.TIME$,         \ 4 bytes unpacked create time HH:MM
 687: 0000:    PLLOL.PICK.START.TIME$,     \ 4 bytes unpacked pick start time HH:MM
 688: 0000:    PLLOL.PICK.END.TIME$,       \ 4 bytes unpacked pick end time HH:MM
 689: 0000:    PLLOL.ITEM.COUNT$,          \ 4 bytes unpacked item count (max number of items in list
 690: 0000:                                \                              duplicates will cobine to 1 record
 691: 0000:                                \                              on the PLLDB file)
 692: 0000:    PLLOL.OSSR.PICKING$,        \ 1 byte Marked for OSSR picking "Y" = marked for OSSR picking
 693: 0000:                                \                                "N" = not marked for OSSR picking
 694: 0000:    PLLOL.OSSR.STATUS$          ! 1 byte mark the status of the list.         ! BMG         
 695: 0000: 
 696: 0000: 
 697: 0000: INTEGER*4 GLOBAL               \
 698: 0000:        PLLOL.RECORD.NUM%
 699: 0000: 
 700: 0000: INTEGER*2 GLOBAL                \
 701: 0000:    PLLOL.REPORT.NUM%,           \
 702: 0000:    PLLOL.SESS.NUM%
 703: 0000: 
 704: 0000: 
 705: 0000: INTEGER*1 GLOBAL                \
 706: 0000:    PLLOL.RECL%
 707: 0000: 
 708: 0000: 
 709: 0000:  %INCLUDE PLLDBDEC.J86                    ! 2.3CS
 710: 0000: 
 711: 0000: \******************************************************************************
 712: 0000: \******************************************************************************
 713: 0000: \***
 714: 0000: \***         %INCLUDE FOR RF PICKING LIST ITEMS IN LISTS FILE FIELD DECLARATIONS
 715: 0000: \***
 716: 0000: \***               FILE TYPE    : KEYED
 717: 0000: \***
 718: 0000: \***               REFERENCE    : PLLDBDEC.J86
 719: 0000: \***
 720: 0000: \***    VERSION A.              Julia Stones.                   11th August 2004
 721: 0000: \***    New file for RF system. Holds picking list items in lists information.
 722: 0000: \***
 723: 0000: \***    VERSION B.              Mark Goode                     17th january 2005
 724: 0000: \***    Changes for OSSR WAN
 725: 0000: \***
 726: 0000: \***    VERSION C.              Charlies Skadorwa
 727: 0000: \***    Add Stock fig to filler space for PST47
 728: 0000: \***
 729: 0000: \***    VERSION D.              Mark Goode                      29th August 2008
 730: 0000: \***    Add new fields for Multi-site project
 731: 0000: \***
 732: 0000: \***    VERSION E.              Wasim Abdulkalam              11th November 2011
 733: 0000: \***    Added new fields for backshop and OSSR pending sales plan for Stock
 734: 0000: \***    file accuracy project
 735: 0000: \*******************************************************************************
 736: 0000: \*******************************************************************************
 737: 0000: 
 738: 0000: STRING GLOBAL                          \
 739: 0000:        PLLDB.FILE.NAME$,               \
 740: 0000:        PLLDB.KEY$,                     \ 6 bytes unpacked LISTID + ITEMSEQ
 741: 0000:        PLLDB.LISTID$,                  \ 3 bytes unpacked List Number
 742: 0000:        PLLDB.ITEMSEQ$,                 \ 3 bytes unpacked Item Sequence Number
 743: 0000:        PLLDB.BOOTSCODE$,               \ 4 bytes packed Boots item code including check digit
 744: 0000:        PLLDB.QTY.ONSHELF$,             \ 4 bytes unpacked Quantity on shelf
 745: 0000:        PLLDB.FILL.QTY$,                \ 4 bytes unpacked Fill quantity
 746: 0000:        PLLDB.GAPFILL.MRK$,             \ 1 byte ASC Gap/Fill marker "Y" = Gap created from Shelf monitor
 747: 0000:                                        \                            "N" = Fast Fill no TSF update
 748: 0000:        PLLDB.ITEM.STATUS$,             \ 1 byte ASC Item Status "U" = Unpicked, "P" = picked
 749: 0000:        PLLDB.STOCKROOM.CNT$,           \ 4 bytes unpacked Stock Room Count
 750: 0000:        PLLDB.SHELFMON.SALE.FIG$,       \ 4 bytes unpacked Sales figure at Shelf Monitoring
 751: 0000:        PLLDB.OSSR.FLAG$,               \ 1 bytes item OSSR flag   ! BMG
 752: 0000:      \!PLLDB.FILLER$,                  \ 7 byte filler            ! BMG !EWA
 753: 0000:        PLLDB.CNT.PENDSALES.BACKSHOP$,  \ 2 bytes packed backshop pending sales plan count      ! EWA
 754: 0000:        PLLDB.TIME.PENDSALES.BACKSHOP$, \ 2 bytes packed backshop pending sales plan count time ! EWA
 755: 0000:        PLLDB.CNT.PENDSALES.OSSR$,      \ 2 bytes packed OSSR pending sales plan count          ! EWA
 756: 0000:        PLLDB.TIME.PENDSALES.OSSR$,     \ 2 bytes packed OSSR pending sales plan count time     ! EWA
 757: 0000:        PLLDB.STKFIG.STOCKROOM$,        \ 4 bytes unpacked Sales figure at Shelf Monitoring
 758: 0000:                                        \ progam submitted for pint out
 759: 0000:        PLLDB.OSSR.CNT$,                \ 4 bytes unpacked OSSR item stock count figure
 760: 0000:        PLLDB.TIME.SHELFMON$,           \ 2 bytes packed Time of stock floor count hh:mm
 761: 0000:        PLLDB.TIME.BACKSHOP$,           \ 2 bytes packed Time of back shop count hh:mm
 762: 0000:        PLLDB.TIME.OSSR$,               \ 2 bytes packed Time of OSSR count hh:mm
 763: 0000:        PLLDB.BACKSHOP.SALE$,           \ 4 bytes unpacked Sale at time of backshop count
 764: 0000:        PLLDB.OSSR.SALE$,               \ 4 bytes unpacked Sale at time of OSSR count
 765: 0000:        PLLDB.MS.TABLE$,                \                                           ! DMG
 766: 0000:        PLLDB.MS.LOCATION.CNT$(1),      \ 2 byte packed multi-site location count   ! DMG
 767: 0000:        PLLDB.MS.SALES.FIG$(1),         \ 2 byte packed multi-site sales figure     ! DMG                                             ! CMG
 768: 0000:        PLLDB.MS.TIME.CNT$(1),          \ 2 byte packed multi-site time of count    ! DMG                                             ! CMG
 769: 0000:        PLLDB.MS.FILL.QTY$(1),          \ 2 byte packed multi-site fill quantity    ! DMG                                                        ! CMG
 770: 0000:        PLLDB.FILLER2$(1)               ! 2 byte filler                             ! DMG
 771: 0000: 
 772: 0000: INTEGER*2 GLOBAL                       \
 773: 0000:    PLLDB.REPORT.NUM%,                  \
 774: 0000:    PLLDB.SESS.NUM%
 775: 0000: 
 776: 0000: INTEGER*2 GLOBAL                       \
 777: 0000:    PLLDB.RECL%
 778: 0000: 
 779: 0000: 
 780: 0000: 
 781: 0000: \%INCLUDE CIMFDEC.J86                     ! DLC !2.5NWB
 782: 0000: \%INCLUDE CITEMDEC.J86                    ! DLC !2.5NWB
 783: 0000: \%INCLUDE CSRDEC.J86                      ! DLC !2.5NWB
 784: 0000: \%INCLUDE CSRWFDEC.J86                    ! DLC !2.5NWB
 785: 0000: \%INCLUDE CSRBFDEC.J86                    ! DLC !2.5NWB
 786: 0000: !%INCLUDE EPSOMDEC.J86                    ! FLC TEST
 787: 0000:  %INCLUDE FPFDEC.J86                      ! DLC
 788: 0000:  REM \
 789: 0000: \******************************************************************************
 790: 0000: \******************************************************************************
 791: 0000: \***
 792: 0000: \***         %INCLUDE FOR FLASHPACK / PARENT FILE FIELD DECLARATIONS
 793: 0000: \***
 794: 0000: \***               FILE TYPE    : Keyed
 795: 0000: \***
 796: 0000: \***               REFERENCE    : FPFDEC.J86
 797: 0000: \***
 798: 0000: \***         VERSION A : LES COOK  - 21/8/92
 799: 0000: \***
 800: 0000: \***    VERSION B.              ROBERT COWEY.                       21 OCT 1993.
 801: 0000: \***    No changes to this file.
 802: 0000: \***
 803: 0000: \***    VERSION C.              CLIVE NORRIS.                       17 JAN 1994.
 804: 0000: \***    No changes to this file. Version updated to keep in line 
 805: 0000: \***    with changes in FPFFUNC.BAS.
 806: 0000: \***
 807: 0000: \*******************************************************************************
 808: 0000: \*******************************************************************************
 809: 0000: 
 810: 0000:   STRING GLOBAL                  \
 811: 0000:     FPF.FILE.NAME$,              \
 812: 0000:     FPF.PARENT.CODE$,            \ 4 byte UPD with a check digit
 813: 0000:     FPF.CODE$(1),                \ 4 bytes upd first flashpack code of 10                 ! Boots code with a check digit 
 814: 0000:                                  \ (99999999 if no code) 
 815: 0000:     FPF.MULT.FACTOR$(1)          \ 2 bytes UPD multiplication factor for
 816: 0000:                   		 ! first flashpack code.
 817: 0000: 
 818: 0000:   INTEGER*2 GLOBAL        \
 819: 0000:     FPF.RECL%,            \
 820: 0000:     FPF.REPORT.NUM%,      \
 821: 0000:     FPF.SESS.NUM%,        \
 822: 0000:     MAX.FPF.CODES%
 823: 0000: 
 824: 0000:  %INCLUDE IDFDEC.J86                      ! FLC
 825: 0000: REM \
 826: 0000: \******************************************************************************
 827: 0000: \******************************************************************************
 828: 0000: \***
 829: 0000: \***         %INCLUDE FOR ITEM DATA FILE - FIELD DECLARATIONS
 830: 0000: \***                                       FILE REFERENCE PARAMETERS
 831: 0000: \***
 832: 0000: \***                  FILE TYPE    : Keyed
 833: 0000: \***
 834: 0000: \***                  REFERENCE    : IDFDEC.J86
 835: 0000: \***
 836: 0000: \***         VERSION A : Andrew Wedgeworth  29th June 1992    
 837: 0000: \***
 838: 0000: \***    VERSION C.              Robert Cowey.                       25 AUG 1993.
 839: 0000: \***    Replaced un-used RANK$ with BSNS.CNTR$ and FILLER$.
 840: 0000: \***
 841: 0000: \***    VERSION D.              Andrew Wedgeworth               15th March 1995
 842: 0000: \***    Comments updated to reflect the fact that some bits on the file are
 843: 0000: \***    no longer used.
 844: 0000: \***
 845: 0000: \*******************************************************************************
 846: 0000: \*******************************************************************************
 847: 0000: 
 848: 0000:   STRING GLOBAL           \
 849: 0000:     IDF.FILE.NAME$,       \  
 850: 0000:     IDF.BOOTS.CODE$,      \ 4 byte UPD with check digit (key)
 851: 0000:     IDF.FIRST.BAR.CODE$,  \ 6 byte UPD without check digit
 852: 0000:     IDF.SECOND.BAR.CODE$, \ 6 byte UPD without check digit
 853: 0000:     IDF.NO.OF.BAR.CODES$, \ 2 byte UPD. Total number of bar codes for this item
 854: 0000:     IDF.PRODUCT.GRP$,     \ 3 byte UPD. The first two digits are the concept
 855: 0000:                           \ group and the last four the concept sequence
 856: 0000:     IDF.STNDRD.DESC$,     \ 24 bytes
 857: 0000:     IDF.STATUS.1$,        \ 1 byte, values B,C,D,P,X,Z and blank
 858: 0000:     IDF.INTRO.DATE$,      \ 3 byte UPD YYMMDD. Date first added to this file
 859: 0000:     IDF.BSNS.CNTR$,       \ 1 byte ASC. Business Centre ID letter      ! CRC
 860: 0000:     IDF.FILLER$,          \ 1 byte un-used                             ! CRC
 861: 0000:     IDF.PARENT.CODE$,     \ 4 byte UPD with check digit ; may be zero if no
 862: 0000:                           \ flashpacks, current IDF.BOOTS.CODE$ if parent line
 863: 0000:                           \ or Boots Code of parent line if a flashpack.
 864: 0000:     IDF.DATE.OF.LAST.SALE$! 3 byte UPD. Date of last sale.
 865: 0000: 
 866: 0000:   INTEGER*1 GLOBAL        \
 867: 0000:     IDF.BIT.FLAGS.1%,     \ 1 byte - bit values
 868: 0000:                           \ X"80"  - Group code flag
 869: 0000:                           \ X"40"  - Keylines flag
 870: 0000:                           \ X"20"  - Markdown flag
 871: 0000:                           \ X"10"  - Warehouse flag
 872: 0000:                           \ X"08"  - CSR flag
 873: 0000:                           \ X"04"  - Directs A flag
 874: 0000:                           \ X"02"  - Directs B flag
 875: 0000:                           \ X"01"  - Directs C flag
 876: 0000:     IDF.BIT.FLAGS.2%      \ 1 byte - bit values
 877: 0000:                           \ X"80"  - Own brand line flag
 878: 0000:                           \ X"40"  - Exclusive line flag
 879: 0000:                           \ X"20"  - Unused 
 880: 0000:                           \ X"10"  - Unused
 881: 0000:                           \ X"08"  - Stock system flag
 882: 0000:                           \ X"04"  - Pending count flag
 883: 0000:                           \ X"02"  - Reserved
 884: 0000:                           ! X"01"  - Reserved
 885: 0000: 
 886: 0000:   INTEGER*2 GLOBAL        \
 887: 0000:     IDF.RECL%,            \  
 888: 0000:     IDF.REPORT.NUM%,      \ 
 889: 0000:     IDF.SESS.NUM%
 890: 0000:  %INCLUDE INVOKDEC.J86                    ! FLC
 891: 0000: \******************************************************************************
 892: 0000: \******************************************************************************
 893: 0000: \***
 894: 0000: \***   $Workfile:   INVOKDEC.J86  $
 895: 0000: \***
 896: 0000: \***   $Revision:   1.4  $
 897: 0000: \***
 898: 0000: \******************************************************************************
 899: 0000: \******************************************************************************
 900: 0000: \***
 901: 0000: \***   $Log:   V:\archive\j86\invokdec.j8v  $
 902: 0000: \***   
 903: 0000: \***      Rev 1.4   10 Feb 1998 14:11:36   DEV45PS
 904: 0000: \***   Added RP Delivery Days field
 905: 0000: \***   
 906: 0000: \***      Rev 1.3   09 Apr 1997 09:22:06   DEVAWPS
 907: 0000: \***   Added date of successful processing of Points
 908: 0000: \***   Events details.
 909: 0000: \***   
 910: 0000: \***      Rev 1.2   20 Dec 1994 11:02:52   DEVMJPS
 911: 0000: \***   CSR/2 Amendments - new fields added are 
 912: 0000: \***   PSC14 flag and Conversion Status flag 
 913: 0000: \***   
 914: 0000: \******************************************************************************
 915: 0000: \******************************************************************************
 916: 0000: REM \
 917: 0000: \******************************************************************************
 918: 0000: \******************************************************************************
 919: 0000: \***
 920: 0000: \***    FIELD DECLARATIONS AND FILE REFERENCE PARAMETERS FOR INVCE OK FILE 
 921: 0000: \***
 922: 0000: \***                     REFERENCE   : INVOKDEC.J86
 923: 0000: \***
 924: 0000: \***    Version A            Andrew Wedgeworth              3rd August 1992
 925: 0000: \***    
 926: 0000: \***    Version B            Stephen Kelsey                 12th October 1992
 927: 0000: \***    Include Direct Implementation Flag, PSC30 flag and date.
 928: 0000: \***
 929: 0000: \***    Version C            Les Cook                       15th February 1993
 930: 0000: \***    Include UOD Implementation Flag, UOD Booked in date, Previous serial
 931: 0000: \***    number and success flag.
 932: 0000: \***
 933: 0000: \***    Version D            David Smallwood                20th July 1994   
 934: 0000: \***    Include CSR PHASE1 transmission flag and CSR start method flag.
 935: 0000: \***    
 936: 0000: \***    Version E            Mick Bayliss                   19th Oct. 1994
 937: 0000: \***    New fields for CSR Phase 2 - PSC14 Flag and Conversion Status Flag.
 938: 0000: \***
 939: 0000: \***    Version F            Andrew Wedgeworth              27th March 1997
 940: 0000: \***    Added date of successful processing of Points Events details sent from 
 941: 0000: \***    the mainframe.
 942: 0000: \***
 943: 0000: \***    Version G            Nik Sen                        10th February 1998
 944: 0000: \***    Added parameter used by MINSITS RP to determine number of days to 
 945: 0000: \***    check for late delivery.
 946: 0000: \***
 947: 0000: \******************************************************************************
 948: 0000: \******************************************************************************
 949: 0000: 
 950: 0000: 
 951: 0000: \******************************************************************************
 952: 0000: \***
 953: 0000: \***   FILE REFERENCE PARAMETERS
 954: 0000: \***
 955: 0000: \******************************************************************************
 956: 0000: 
 957: 0000:   STRING GLOBAL           \
 958: 0000:     INVOK.FILE.NAME$
 959: 0000: 
 960: 0000:   INTEGER*2 GLOBAL        \
 961: 0000:     INVOK.SESS.NUM%,      \
 962: 0000:     INVOK.REPORT.NUM%
 963: 0000: 
 964: 0000: 
 965: 0000: \******************************************************************************
 966: 0000: \***
 967: 0000: \***   FIELD DECLARATIONS
 968: 0000: \***
 969: 0000: \******************************************************************************
 970: 0000: 
 971: 0000:   STRING GLOBAL                \
 972: 0000:     INVOK.SERIAL.NO$,          \ 5 bytes ASCII
 973: 0000:     INVOK.DATE$,               \ 3 bytes YYMMDD UPD
 974: 0000:     INVOK.SUCCESS.FLAG$,       \ 1 bytes ASCII
 975: 0000:     INVOK.STORE.NO$,           \ 4 bytes ASCII with leading zeroes
 976: 0000:     INVOK.INVENTORY.SRLNO$,    \ 5 bytes ASCII leading zeros
 977: 0000:     INVOK.INVENTORY.SUCCESS$,  \ 1 bytes ASCII 0=failed/1=success
 978: 0000:     INVOK.SALES.SRLNO$,        \ 5 bytes ASCII leading zeros
 979: 0000:     INVOK.SALES.SUCCESS$,      \ 1 bytes ASCII 0=failed/1=success
 980: 0000:     INVOK.NEW.LIST.SRLNO$,     \ 5 bytes ASCII
 981: 0000:     INVOK.NEW.LIST.SUCCESS$,   \ 1 bytes ASCII 0=failed/1=success
 982: 0000:     INVOK.CSR.DELIVERY.NO$,    \ 5 bytes ASCII				
 983: 0000:     INVOK.CSR.IDENT$,          \ 1 bytes ASCII value "Y" 		
 984: 0000:     INVOK.CSR.DELIVERY.DATE$,  \ 6 bytes ASCII YYMMDD			
 985: 0000:     INVOK.CSR.PSC11.FLAG$,     \ 1 bytes ASCII				
 986: 0000:     INVOK.CSR.PSC12.FLAG$,     \ 1 bytes ASCII				
 987: 0000:     INVOK.CSR.PSC13.FLAG$,     \ 1 bytes ASCII				
 988: 0000:     INVOK.CSR.PSC12.DAYS$,     \ 1 bytes UPD				
 989: 0000:     INVOK.PSS33.RUN.DATE$,     \ 3 bytes YYMMDD UPD                     
 990: 0000:     INVOK.PSS33.SUCCESS.FLAG$, \ 1 bytes ASCII 0=failed/1=success       
 991: 0000:     INVOK.DIR.IMPL.FLAG$,      \ 1 byte ASCII  1=phase 1 implemented   BSPK   
 992: 0000:                                \           blank=not yet implemented   BSPK 
 993: 0000:     INVOK.PSC30.RUN.DATE$,     \ 3 bytes YYMMDD UPD                    BSPK                     
 994: 0000:     INVOK.PSC30.SUCCESS.FLAG$, \ 1 bytes ASCII 0=failed/1=success      BSPK
 995: 0000:     INVOK.UOD.IMPL.FLAG$,      \ 1 byte ASCII 1=implemented            CLC
 996: 0000:     INVOK.LAST.UOD.DATE$,      \ 3 bytes UPD                           CLC
 997: 0000:     INVOK.PREV.SERIAL.NO$,     \ 5 bytes ASCII                         CLC
 998: 0000:     INVOK.PREV.SUCCESS.FLAG$,  \ 1 byte ASCII                          CLC
 999: 0000:     INVOK.SUPPRESS.EXCEP.REPORT$,     \ 1 byte ASCII Y/N               DDS
1000: 0000:     INVOK.CSR.STARTED.BY.SUP$,        \ 1 byte ASCII Y/N               DDS
1001: 0000:     INVOK.CSR.PSC14.FLAG$,            \ 1 byte ASCII S/E/X/Y           EMJB
1002: 0000:     INVOK.CSR.CONVERSION.STATUS.FLAG$,\ 1 byte ASCII P/S/X/C           EMJB
1003: 0000:     INVOK.PTS.EVENTS.OK.DATE$, \ 3 bytes UPD                           FAW
1004: 0000:     INVOK.RP.DAYS$,            \ 1 byte ASCII                          GNS
1005: 0000:     INVOK.FILLER$              ! 6 bytes spaces                        GNS
1006: 0000: 
1007: 0000:   INTEGER*2 GLOBAL        \
1008: 0000:     INVOK.RECL%
1009: 0000:  %INCLUDE ONORDDEC.J86                    ! DLC
1010: 0000: \******************************************************************************
1011: 0000: \******************************************************************************
1012: 0000: \***
1013: 0000: \***         %INCLUDE FOR CSR ON ORDER FILE - FIELD DECLARATIONS
1014: 0000: \***                                          FILE REFERENCE PARAMETERS
1015: 0000: \***
1016: 0000: \***               FILE TYPE    : Keyed     
1017: 0000: \***
1018: 0000: \***               REFERENCE    : ONORDDEC.J86
1019: 0000: \***
1020: 0000: \***               DATE OF LAST AMENDMENT -  09/10/92
1021: 0000: \***
1022: 0000: \******************************************************************************
1023: 0000: \*******************************************************************************
1024: 0000: 
1025: 0000:   STRING GLOBAL                  \
1026: 0000:     ONORD.FILE.NAME$,		 \
1027: 0000:     ONORD.KEY$,                  \ 12byte ASC
1028: 0000:     ONORD.ORDER.DATE$,           \ 6 byte ASC
1029: 0000:     ONORD.LIST.FREQ$,            \ 1 byte ASC
1030: 0000:     ONORD.UNIT.NO$,              \ 2 byte ASC 
1031: 0000:     ONORD.SEQ.NO$,               \ 3 byte ASC 
1032: 0000:     ONORD.HIGHEST.SEQ.NO$,       \ 3 byte ASC 
1033: 0000:     ONORD.FILLER$,               \
1034: 0000:     ONORD.ITEM.CODE$,            \ 7 byte ASC 
1035: 0000:     ONORD.QTY.1$,                \ 3 byte ASC
1036: 0000:     ONORD.QTY.2$,                \ 3 byte ASC 
1037: 0000:     ONORD.CSRITEM.UNDONE.FLAG$,  \ 1 byte ASC "Y" or "N"
1038: 0000:     ONORD.CSRIMF.UNDONE.FLAG$,   \ 1 byte ASC "Y" or "N" 
1039: 0000:     ONORD.DELETED.FLAG$          ! 1 byte ASC "Y" or "N" 
1040: 0000:     
1041: 0000:   INTEGER*2 GLOBAL		 \
1042: 0000:     ONORD.REPORT.NUM%,		 \
1043: 0000:     ONORD.RECL%,		 \
1044: 0000:     ONORD.SESS.NUM%  
1045: 0000:     
1046: 0000:  %INCLUDE PCHKDEC.J86                     ! DLC
1047: 0000: \******************************************************************************
1048: 0000: \******************************************************************************
1049: 0000: \***
1050: 0000: \***         %INCLUDE FOR PRICE CHECK FILE - FILE REFERENCE PARAMETERS
1051: 0000: \***
1052: 0000: \***               REFERENCE    : PCHKDEC.J86
1053: 0000: \***
1054: 0000: \******************************************************************************
1055: 0000: \*******************************************************************************
1056: 0000: 
1057: 0000:   STRING GLOBAL           \
1058: 0000:     PCHK.FILE.NAME$
1059: 0000: 
1060: 0000:   INTEGER*2 GLOBAL        \
1061: 0000:     PCHK.REPORT.NUM%,      \
1062: 0000:     PCHK.SESS.NUM%
1063: 0000:  %INCLUDE PIPEINUB.J86                    ! DLC
1064: 0000: 
1065: 0000: \******************************************************************************
1066: 0000: \******************************************************************************
1067: 0000: \***
1068: 0000: \***                   %INCLUDE FOR PSS38 INPUT PIPE
1069: 0000: \***
1070: 0000: \***                         LINK TYPE : PIPEI
1071: 0000: \***
1072: 0000: \***                     REFERENCE : PIPEINUM.J86
1073: 0000: \***
1074: 0000: \******************************************************************************
1075: 0000: \******************************************************************************
1076: 0000: 
1077: 0000:    STRING GLOBAL							\
1078: 0000: 	PIPEI.FILE.NAME$
1079: 0000: 	
1080: 0000:    INTEGER*1 GLOBAL							\
1081: 0000: 	PIPEI.REPORT.NUM%,						\
1082: 0000: 	PIPEI.SESS.NUM%
1083: 0000: !%INCLUDE PIPEONUB.J86                    ! FLC TEST
1084: 0000:  %INCLUDE UNITSDEC.J86                    ! DLC
1085: 0000: \******************************************************************************
1086: 0000: \******************************************************************************
1087: 0000: \***
1088: 0000: \***         %INCLUDE FOR UNITS - FILE REFERENCE PAREMETERS
1089: 0000: \***                              FIELD DECLARATIONS
1090: 0000: \***
1091: 0000: \***               REFERENCE    : UNITSDEC.J86
1092: 0000: \***
1093: 0000: \***
1094: 0000: \******************************************************************************
1095: 0000: \******************************************************************************
1096: 0000: 
1097: 0000:   STRING GLOBAL           \
1098: 0000:     UNITS.UNIT$,          \ 1  byte UPD (key)
1099: 0000:     UNITS.UNIT.NAME$,     \ 27 bytes ASCII
1100: 0000:     UNITS.BC.LETTER$,     \ 1  byte  ASCII
1101: 0000:     UNITS.FILLER$,        \ 6  bytes ASCII (spaces).
1102: 0000:     UNITS.FILE.NAME$
1103: 0000: 
1104: 0000:   INTEGER*2 GLOBAL        \
1105: 0000:     UNITS.REPORT.NUM%,    \ 
1106: 0000:     UNITS.RECL%,          \ 
1107: 0000:     UNITS.SESS.NUM%
1108: 0000:  %INCLUDE STKMQDEC.J86                    ! MMJK
1109: 0000: REM \
1110: 0000: \******************************************************************************
1111: 0000: \******************************************************************************
1112: 0000: \***
1113: 0000: \***      %INCLUDE FOR STOCK MOVEMENT QUEUE FILE FIELD DECLARATIONS
1114: 0000: \***                                             FILE REFERENCE PARAMETERS
1115: 0000: \***
1116: 0000: \***               FILE TYPE    : Sequential
1117: 0000: \***
1118: 0000: \***               REFERENCE    : STKMQDEC.J86
1119: 0000: \***
1120: 0000: \***      Version A.     L. Cook
1121: 0000: \***
1122: 0000: \***      Combined from STKMQNUE.J86 and STKMQFLE.J86
1123: 0000: \***
1124: 0000: \***      Version B.     S.P. Kelsey (CTG)            7th November
1125: 0000: \***      Include CSR Marker in the Type 1 and Type 18 transactions.
1126: 0000: \***
1127: 0000: \***      Version C.     S. Goulding                 8th March
1128: 0000: \***      Add fields for new tranctions types 21 & 23
1129: 0000: \***
1130: 0000: \***      Version D.     ???????????            ????????????
1131: 0000: \***      ????????????????????????????????????????????????????????
1132: 0000: \***
1133: 0000: \***      Version E.     Michael J. Kelsall           16th Dec 1993.
1134: 0000: \***      Addition of txn types, 24, 25, 26, 27 and 28. As part of the
1135: 0000: \***      RETURNS/AUTOMATIC CREDIT CLAIMING system.
1136: 0000: \***
1137: 0000: \***      Version 1.1    Michael J. Kelsall           10th Aug 1994.
1138: 0000: \***      Changes as part of R/ACC update to allow for zero price claim
1139: 0000: \***      processing. Addition of type 29 txn for this change.
1140: 0000: \***
1141: 0000: \***      Version 1.2    Nik Sen                       8th November 1994
1142: 0000: \***      Addition of transaction type 30 as oart of Epsom Life CSR Phase 2
1143: 0000: \***
1144: 0000: \***      Version 1.3    Neil Bennett                   2nd January 2007
1145: 0000: \***      Add ASN processing support. (Rec Type 17)
1146: 0000: \***
1147: 0000: \***      Version 1.4    Brian Greenfield               14th may 2007
1148: 0000: \***      Added STKMQ.RECALL.TYPE$ for use in A7C RECALLS - only type 26 records.
1149: 0000: \***
1150: 0000: \***      Version 1.5    Neil Bennett                  31st January 2008
1151: 0000: \***      Add STKMQ.FLAG$ for record type 11
1152: 0000: \***
1153: 0000: \***      Version 1.6    Dave Constable                5th September 2008
1154: 0000: \***      Add STKMQ.FLAG$ for record type 33
1155: 0000: \***
1156: 0000: \***      Version 1.7    Dave Constable                30th December 2008
1157: 0000: \***      Add STKMQ.RESCAN$ for record type 33
1158: 0000: \***
1159: 0000: \***      Version 1.8    Dave Constable                6th January 2009
1160: 0000: \***      Add Bookin date & time for record type 33
1161: 0000: \***
1162: 0000: \***      Version F      Mark Walker                      27th Mar 2014
1163: 0000: \***      F337 Centralised View of Stock
1164: 0000: \***      - Relocated STKMQ item processing variables to here.
1165: 0000: \***
1166: 0000: \******************************************************************************
1167: 0000: \*******************************************************************************
1168: 0000: \***
1169: 0000: \***  The length of the records on this file vary depending on the record
1170: 0000: \***  transaction type, but they all comprise combinations of the fields
1171: 0000: \***  defined below.
1172: 0000: \***
1173: 0000: \***  Transaction type 0 (Header record) - RECORD DELIMITER, TRANS TYPE,
1174: 0000: \***     FIELD DELIMITER, CREATION DATE, CREATION TIME, RECORD DELIMITER,
1175: 0000: \***     END OF RECORD MARKER.
1176: 0000: \***
1177: 0000: \***  Transaction type 1 - RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
1178: 0000: \***     TIME, FSI, FOLIO YEAR, FOLIO MONTH, FOLIO NUMBER, STORE SUFFIX,
1179: 0000: \***     COUNT OF ITEMS, INVOICE DAY,(FIELD DELIMITER, BOOTS CODE,
1180: 0000: \***     FIELD DELIMITER, QUANTITY, FIELD DELIMITER, CSR MARKER),
1181: 0000: \***     RECORD DELIMITER, END OF RECORD MARKER.
1182: 0000: \***     The fields within brackets are repeated as many times as count of items.
1183: 0000: \***
1184: 0000: \***  Transaction type 2 - RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
1185: 0000: \***     TIME, BOOTS CODE, FIELD DELIMITER, QUANTITY, RECORD DELIMITER,
1186: 0000: \***     END OF RECORD MARKER.
1187: 0000: \***
1188: 0000: \***  Transaction type 3 - RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
1189: 0000: \***     TIME, BOOTS CODE, FIELD DELIMITER, QUANTITY, FIELD DELIMITER,
1190: 0000: \***     REASON CODE, STORE/RETURN CODE, RECORD DELIMITER, END OF RECORD MARKER
1191: 0000: \***
1192: 0000: \***  Transaction type 4 - RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
1193: 0000: \***     TIME, BOOTS CODE, ON IDF FLAG, FIELD DELIMITER, QUANTITY,
1194: 0000: \***     RECORD DELIMITER, END OF RECORD MARKER
1195: 0000: \***
1196: 0000: \***  Transaction type 5 - RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
1197: 0000: \***     TIME, BOOTS CODE, COUNT FLAG, STOCK MOVEMENT DATE, FIELD DELIMITER,
1198: 0000: \***     QUANTITY, RECORD DELIMITER, END OF RECORD MARKER
1199: 0000: \***
1200: 0000: \***  Transaction type 6 - RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
1201: 0000: \***     TIME, BOOTS CODE, REASON (1 byte ASCII)
1202: 0000: \***     RECORD DELIMITER, END OF RECORD MARKER
1203: 0000: \***
1204: 0000: \***  Transaction type 7 - RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
1205: 0000: \***     TIME, BOOTS CODE, CONCEPT SEQUENCE
1206: 0000: \***     RECORD DELIMITER, END OF RECORD MARKER
1207: 0000: \***
1208: 0000: \***  Transaction type 8 - RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
1209: 0000: \***     TIME, PRODUCT GROUP, RECORD DELIMITER, END OF RECORD
1210: 0000: \***     MARKER
1211: 0000: \***
1212: 0000: \***  Transaction type 9 - RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
1213: 0000: \***     TIME, LIST NUMBER, ITEM NUMBER, LIST TYPE,
1214: 0000: \***     COUNT.BY.DATE, RECORD DELIMITER, END OF RECORD MARKER
1215: 0000: \***
1216: 0000: \***  Transaction type 10- RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
1217: 0000: \***     TIME, BOOTS CODE,
1218: 0000: \***     RECORD DELIMITER, END OF RECORD MARKER
1219: 0000: \***
1220: 0000: \***  Transaction type 11- RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
1221: 0000: \***     TIME, BOOTS CODE, FIELD DELIMITER, COUNT QUANTITY, FIELD DELIMITER(opt),
1222: 0000: \***     SOURCE(opt), FLAG(opt), RECORD DELIMITER, END OF RECORD MARKER
1223: 0000: \***
1224: 0000: \***  Transaction type 12- RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
1225: 0000: \***     TIME, BOOTS CODE,
1226: 0000: \***     RECORD DELIMITER, END OF RECORD MARKER
1227: 0000: \***
1228: 0000: \***  Transaction type 13- RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
1229: 0000: \***     TIME, LIST NUMBER, ITEM NUMBER, ITEM STATUS,ITEM CODE,
1230: 0000: \***     COUNT DATE, COUNT TIME, PRICE, FIELD DELIMITER, SHOP FLOOR COUNT,
1231: 0000: \***     FIELD DELIMITER, BACKROOM COUNT, RECORD DELIMITER, END OF REC MARKER
1232: 0000: \***
1233: 0000: \***  Transaction type 14- RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
1234: 0000: \***     TIME, LIST NUMBER, LIST STATUS, RECORD DELIMITER,
1235: 0000: \***     END OF RECORD MARKER
1236: 0000: \***
1237: 0000: \***  Transaction type 16- RECORD DELIMIER, TRANS TYPE, FIELD DELIMITER, DATE,
1238: 0000: \***     TIME, BC LETTER, FIELD DELIMITER, ORIGINAL RECOUNT
1239: 0000: \***     PERCENTAGE, FIELD DELIMITER, CHANGED RECOUNT PERCENTAGE,
1240: 0000: \***     RECORD DELIMITER, END OF RECORD DELIMITER
1241: 0000: \***
1242: 0000: \***  Transaction type 17- RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
1243: 0000: \***     TIME, SOURCE, SUPPLIER NUMBER, ORDER NUMBER, ORDER SUFFIX, PAGE
1244: 0000: \***     NUMBER, ITEM COUNT,
1245: 0000: \***     CARTON NUMBER, CARTON FLAG,                                        ! 1.3NWB
1246: 0000: \***     FIELD DELIMITER, ITEM CODE, BAR CODE,
1247: 0000: \***     QUANTITY - GOOD, FIELD DELIMITER, QUANTITY - DAMAGED, FIELD DELIMITER,
1248: 0000: \***     QUANTITY - STOLEN (the last 8 fields repeat ITEM COUNT times),
1249: 0000: \***     RECORD DELIMITER, END OF RECORD DELIMITER
1250: 0000: \***
1251: 0000: \***  Transaction type 18- RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
1252: 0000: \***     TIME, FOLIO IDENTIFIER, FOLIO YEAR, FOLIO MONTH, FOLIO NUMBER,
1253: 0000: \***     STORE SUFFIX, ITEM COUNT, INVOICE DAY, EXPECTED DATE OF DELIVERY,
1254: 0000: \***     DALLAS MARKER, FIELD DELIMITER, ITEM CODE, FIELD DELIMITER,
1255: 0000: \***     ORDER QUANTITY, FIELD DELIMITER, CSR MARKER,
1256: 0000: \***     (the last six fields repeat ITEM COUNT times),
1257: 0000: \***     RECORD DELIMITER, END OF RECORD DELIMITER
1258: 0000: \***
1259: 0000: \***  Transaction type 19- RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
1260: 0000: \***     TIME, SUPPLIER NUMBER, ORDER NUMBER, ORDER SUFFIX, CONFIRM/AMEND FLAG,
1261: 0000: \***     START TIME, END TIME, NO SINGLES ADDED, NO ITEMS ADDED, NO ITEMS
1262: 0000: \***     BOOKED IN, RECORD DELIMITER, END OF RECORD DELIMITER
1263: 0000: \***
1264: 0000: \***  Transaction type 21 - RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
1265: 0000: \***     TIME, DISTRIBUTION CENTRE, WAREHOUSE NUMBER, STORE NUMBER, UOD NUMBER,
1266: 0000: \***     STATUS, RECORD DELIMITER, END OF RECORD MARKER
1267: 0000: \***
1268: 0000: \***  Transaction type 23 - RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
1269: 0000: \***     TIME, DISTRIBUTION CENTRE, WAREHOUSE NUMBER, STORE NUMBER, UOD NUMBER,
1270: 0000: \***     STATUS, BOOTS/BAR CODE, BOOTS/BAR CODE FLAG, QUANTITY, FIELD DELIMITER
1271: 0000: \***     FSI,FOLIO YEAR, FOLIO MONTH, STORE SUFFIX, FOLIO NO, CSR MARKER
1272: 0000: \***     RECORD DELIMITER, END OF RECORD MARKER
1273: 0000: \***
1274: 0000: \***
1275: 0000: \***  RETURNS/AUTOMATIC CREDIT CLAIMING RECORD TYPES;
1276: 0000: \***
1277: 0000: \***  Transaction type 24 - Whole or Part consignment record
1278: 0000: \***     RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE, TIME,
1279: 0000: \***     CREDIT CLAIM NUM, BC LETTER, CLAIM TYPE, SUPPLIER NUM, INVOICE NUM,
1280: 0000: \***     FOLIO NUM, BATCH REF NUM, WHOLE/PART CONSIGNMENT, REPAIR CATEGORY,
1281: 0000: \***     REPAIR NUM, PLAN4 POLICY NUM, DDDA/DCDR NUM, DELIV NOTE NUM,
1282: 0000: \***     DELIV DATE, NUM OF CARTONS, ORDER NUM, COMMENT, NUM OF ITEMS,
1283: 0000: \***     ITEM/BAR CODE FLAG, BOOTS/BAR CODE, QTY, PRICE, RECORD DELIMITER,
1284: 0000: \***     END OF RECORD MARKER
1285: 0000: \***     (ITEM/BAR CODE FLAG to PRICE repeated NUM OF ITEMS times)
1286: 0000: \***
1287: 0000: \***  Transaction type 25 - Non-sales func 16 and Misc. txns from controller
1288: 0000: \***     RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE, TIME,
1289: 0000: \***     CREDIT CLAIM NUM, NUM OF ITEMS, AUTH CODE/CONTACT,
1290: 0000: \***     ADJUST STOCK FIGURE FLAG, REASON, ITEM/BAR CODE FLAG, BOOTS/BAR CODE,
1291: 0000: \***     QTY, PRICE, RECORD DELIMITER, END OF RECORD MARKER
1292: 0000: \***     (ITEM/BAR CODE FLAG to PRICE repeated NUM OF ITEMS times)
1293: 0000: \***
1294: 0000: \***  Transaction type 26 - Data from LDT
1295: 0000: \***     RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE, TIME, UOD NUM,
1296: 0000: \***     UOD STATUS, CREDIT CLAIM NUM, NUM OF ITEMS UPDATED, TOTAL QTY IN UOD,
1297: 0000: \***     ADJUST STOCK FIGURE FLAG, SUPPLY ROUTE, DISP LOCATION, BC LETTER,
1298: 0000: \***     RECALL NUM, AUTHORISATION, SUPPLIER, RETURN METHOD, CARRIER, BIRD NUM,
1299: 0000: \***     REASON, WAREHOUSE ROUTE, UOD TYPE, REASON FOR DAMAGE, RECEIVING STORE,
1300: 0000: \***     DESTINATION, DATE UOD OPENED, DATE UOD DESPATCHED, TIME UOD
1301: 0000: \***     DESPATCHED, RECALL TYPE$, ITEM.BAR CODE FLAG, BOOTS/BAR CODE, QTY,       ! 1.4BG
1302: 0000: \***     ITEM UPDATED FLAG, RECORD DELIMITER, END OF RECORD MARKER
1303: 0000: \***     (ITEM/BAR CODE FLAG to ITEM UPDATED FLAG repeated NUM OF ITEMS times)
1304: 0000: \***
1305: 0000: \***  Transaction type 27 - End of LDT session
1306: 0000: \***     RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE, TIME,
1307: 0000: \***     DATE SESSION ENDED, TIME SESSION ENDED, RECORD DELIMITER,
1308: 0000: \***     END OF RECORD MARKER
1309: 0000: \***
1310: 0000: \***  Transaction type 28 - Cancelled Credit Claim
1311: 0000: \***     RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE, TIME,
1312: 0000: \***     CLAIM NUMBER, UOD NUM, NEW STATUS FLAG, RECORD DELIMITER,
1313: 0000: \***     END OF RECORD MARKER
1314: 0000: \***
1315: 0000: \***  Transaction type 29 - Zero price update
1316: 0000: \***     RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE, TIME,
1317: 0000: \***     CLAIM NUMBER, ITEM NUMBER, CLAIM VALUE, RECORD DELIMITER,
1318: 0000: \***     END OF RECORD MARKER
1319: 0000: \***
1320: 0000: \***  Transaction type 30 - CSR Issues
1321: 0000: \***     RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE, TIME,
1322: 0000: \***     BOOTS CODE, FIELD DELIMITER, QUANTITY, FIELD DELIMITER
1323: 0000: \***     EXPECTED DELIVERY DATE, RECORD DELIMITER, END OF RECORD MARKER
1324: 0000: \***
1325: 0000: \***  Transaction type 31 - Quasi Count
1326: 0000: \***     RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
1327: 0000: \***     TIME, LIST NUMBER, ITEM NUMBER, ITEM STATUS,ITEM CODE,
1328: 0000: \***     COUNT DATE, COUNT TIME, PRICE, FIELD DELIMITER, SHOP FLOOR COUNT,
1329: 0000: \***     FIELD DELIMITER, BACKROOM COUNT (PREV STOCK FIG), RECORD DELIMITER,
1330: 0000: \***      END OF REC MARKER
1331: 0000: \***
1332: 0000: \***  Transaction type 32 - Quasi Adjustment count
1333: 0000: \**      RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
1334: 0000: \***     TIME, LIST NUMBER, ITEM NUMBER, ITEM STATUS,ITEM CODE,
1335: 0000: \***     COUNT DATE, COUNT TIME, PRICE, FIELD DELIMITER, SHOP FLOOR COUNT,
1336: 0000: \***     FIELD DELIMITER, BACKROOM COUNT (PREV STOCK FIG), RECORD DELIMITER,
1337: 0000: \***     END OF REC MARKER
1338: 0000: \***
1339: 0000: \***  Transaction type 33 - +UOD Receiving
1340: 0000: \**      RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
1341: 0000: \***     TIME, UOD LICENCE PLATE, DESPATCH DATE, ACTION, ITEM COUNT,
1342: 0000: \***     for audit type+(ITEM CODE, BARCODE, DESPATCHED QTY, VARIANCE )
1343: 0000: \***     END OF REC MARKER
1344: 0000: \***
1345: 0000: \******************************************************************************
1346: 0000: 
1347: 0000:   STRING GLOBAL              \
1348: 0000:     STKMQ.FILE.NAME$,        \
1349: 0000:     STKMQ.RECORD$,           \ Used to store the whole record which is unstrung
1350: 0000:                              \ into the fields below
1351: 0000:     STKMQ.RECORD.DELIMITER$, \ 1 byte ASCII set to " (CHR$(34))
1352: 0000:     STKMQ.TRANS.TYPE$,       \ 1 byte UPD. 00 = Header record
1353: 0000:                              \             01 = W'house invoice delivery record
1354: 0000:                              \             02 = Delivery without invoice record
1355: 0000:                              \             03 = Stock out record
1356: 0000:                              \             04 = Stock count record
1357: 0000:                              \             17 = Delivery without confirmation
1358: 0000:                              \                  of Direct Order detail
1359: 0000:                              \             18 = Confirmed Dallas invoice record
1360: 0000:                              \             19 = Delivery without confirmation
1361: 0000:                              \                  of Direct Order header
1362: 0000:                              \             21 = UOD record
1363: 0000:                              \             23 = Item Level UOD record
1364: 0000:                              \             24 = Whole/Part consignment (R/ACC)
1365: 0000:                              \             25 = NS16 / Misc cont txn (R/ACC)
1366: 0000:                              \             26 = Data from LDT (R/ACC)
1367: 0000:                              \             27 = End of LDT session (R/ACC)
1368: 0000:                              \             28 = Canc. Credit Claim (R/ACC)
1369: 0000:                              \             29 = Zero price update (R/ACC)
1370: 0000:     STKMQ.FIELD.DELIMITER$,  \ 1 byte ASCII set to ; (CHR$(59))
1371: 0000:     STKMQ.CREATION.DATE$,    \ 3 byte UPD set to current date
1372: 0000:     STKMQ.CREATION.TIME$,    \ 3 byte UPD set to current time
1373: 0000:     STKMQ.CSR.MARKER$,       \ 1 byte ASCII. "Y" - This is a CSR Item      BSPK
1374: 0000:                              \               " " - This is not a CSR Item  BSPK
1375: 0000:     STKMQ.DATE$,             \ 3 byte UPD set to current date
1376: 0000:     STKMQ.TIME$,             \ 3 byte UPD set to current time
1377: 0000:     STKMQ.FSI$,              \ 1 byte ASCII
1378: 0000:     STKMQ.FOLIO.YEAR$,       \ 1 byte UPD
1379: 0000:     STKMQ.FOLIO.MONTH$,      \ 1 byte UPD
1380: 0000:     STKMQ.FOLIO.NUMBER$,     \ 2 bytes UPD
1381: 0000:     STKMQ.STORE.SUFFIX$,     \ 1 byte ASCII
1382: 0000:     STKMQ.ITEM.COUNT$,       \ 1 byte UPD between 1 and 17
1383: 0000:     STKMQ.BOOTS.CODE$,       \ 4 bytes UPD
1384: 0000:     STKMQ.ON.IDF.FLAG$,      \ 1 byte ASCII. Y = On IDF   N = Not on IDF
1385: 0000:     STKMQ.QUANTITY$,         \ variable length string equivalent to
1386: 0000:                              \ STR$(STKMQ.QUANTITY%)
1387: 0000:                              \ +ve indicates add to stock
1388: 0000:                              \ -ve indicates subtract from stock
1389: 0000:     STKMQ.REASON.CODE$,      \ 2 bytes UPD
1390: 0000:     STKMQ.STORE.RET.CODE$,   \ 2 bytes UPD
1391: 0000:     STKMQ.ENDREC.MARKER$,    \ 2 bytes ASCII set to XODOA
1392: 0000:     STKMQ.REASON$,           \ 1 byte ASCII. "I" = ineligible,
1393: 0000:                              \               "U" = unsuppliable,
1394: 0000:                              \               "Z" = deleted,
1395: 0000:                              \               " " = not removed.
1396: 0000:     STKMQ.CONCEPT.SEQUENCE$, \ 3 byte UPD. Concept group / sequence
1397: 0000:     STKMQ.INVOICE.DAY$,      \ 1 byte UPD
1398: 0000:     STKMQ.LIST.NUMBER$,      \ 4 byte ASCII
1399: 0000:     STKMQ.ITEM.NUMBER$,      \ 2 byte ASCII
1400: 0000:     STKMQ.ITEM.STATUS$,      \ 1 byte ASCII
1401: 0000:     STKMQ.COUNT.DATE$,       \ 3 byte UPD - YYMMDD
1402: 0000:     STKMQ.COUNT.TIME$,       \ 2 byte UPD - HHMM
1403: 0000:     STKMQ.PRICE$,            \ 5 byte UPD
1404: 0000:     STKMQ.SHOP.COUNT$,       \ variable ASCII
1405: 0000:     STKMQ.BKRM.COUNT$,       \ variable ASCII
1406: 0000:     STKMQ.LIST.STATUS$,      \ 1 byte ASCII
1407: 0000:     STKMQ.LEFT.TO.COUNT$,    \ variable ASCII
1408: 0000:     STKMQ.COUNT.BY.DATE$,    \ 3 bytes UPD
1409: 0000:     STKMQ.PRODUCT.GROUP$,    \ 3 bytes UPD
1410: 0000:     STKMQ.BC.LETTER$,        \ 1 byte ASCII
1411: 0000:     STKMQ.ORG.RECOUNT$,      \ VARIABLE ASCII
1412: 0000:     STKMQ.NEW.RECOUNT$,      \ VARIABLE ASCII
1413: 0000:     STKMQ.LIST.TYPE$,        \ 1 byte ASCII
1414: 0000:     STKMQ.COUNT.FLAG$,       \ 1 byte ASC from corrections file
1415: 0000:     STKMQ.STMVT.DATE$,       \ 3 bytes UPD
1416: 0000:     STKMQ.SUPPLIER.NO$,      \ 4 bytes UPD
1417: 0000:     STKMQ.ORDER.NO$,         \ 2 bytes UPD
1418: 0000:     STKMQ.ORDER.SFX$,        \ 1 byte ASCII
1419: 0000:     STKMQ.PAGE.NO$,          \ 1 byte UPD
1420: 0000:     STKMQ.ORDER.DATE$,       \ 3 bytes UPD
1421: 0000:     STKMQ.EXP.DELV.DATE$,    \ 3 bytes UPD
1422: 0000:     STKMQ.DALLAS.MKR$,       \ 1 byte ASCII DALLAS system marker
1423: 0000:                              \ 'Y' - invoice is from DALLAS system,
1424: 0000:                              \ 'N' - invoice is not from DALLAS system
1425: 0000:                              \ 'Q' - invoice contains quantity alterations
1426: 0000:     STKMQ.SOURCE$,           \ 1 byte ASCII Source flag
1427: 0000:                              \ 'S' - PSS65, 'P' - PDT, PSS57
1428: 0000:                              \ Transaction type 11 'S' - Stocktake else ' '
1429: 0000:     STKMQ.FLAG$,             \ Transaction type 11 'F' - First 'L' - Last or ' '
1430: 0000:     STKMQ.BAR.CODE$,         \ 6 bytes UPD
1431: 0000:     STKMQ.CODE.FLAG$,        \ 1 BYTE ASCII
1432: 0000:     STKMQ.QTY.GOOD$,         \ VARIABLE ASCII
1433: 0000:                              \ Quantity of singles booked in in good condition
1434: 0000:     STKMQ.QTY.BAD$,          \ VARIABLE ASCII
1435: 0000:                              \ Quantity of singles booked in in bad condition
1436: 0000:     STKMQ.QTY.STOLEN$,       \ VARIABLE ASCII
1437: 0000:                              \ Quantity of singles recognised as stolen
1438: 0000:     STKMQ.CONF.AMND.FLAG$,   \ 1 byte ASCII - Confirm/ Amend Flag
1439: 0000:                              \ 'C' - Order has been confirmed
1440: 0000:                              \ 'A' - Order has been amended
1441: 0000:                              \ ' ' - Nothing has been done to the order
1442: 0000:     STKMQ.START.TIME$,       \ 2 byte UPD (HHMM) time order started to be
1443: 0000:                              \ processed
1444: 0000:     STKMQ.END.TIME$,         \ 2 byte UPD (HHMM) time order was completed
1445: 0000:     STKMQ.SNGLS.ADDED$,      \ 2 byte UPD  Singles added to order
1446: 0000:     STKMQ.ITEMS.ADDED$,      \ 2 byte UPD  Items added to order
1447: 0000:     STKMQ.ITEMS.BOOKED$,     \ 2 byte UPD  Items booked in on the order
1448: 0000:     STKMQ.DIST.CENTRE$,      \ 1 byte UPD
1449: 0000:     STKMQ.WHSE.NUMBER$,      \ 1 byte UPD
1450: 0000:     STKMQ.STORE.NUMBER$,     \ 2 byte UPD
1451: 0000:     STKMQ.UOD.NUMBER$,       \ 3 byte UPD
1452: 0000:     STKMQ.STATUS$,           \ 1 byte ASCII
1453: 0000:                              \
1454: 0000:     STKMQ.CREDIT.CLAIM.NUM$, \ 4 byte UPD
1455: 0000:     STKMQ.CLAIM.TYPE$,       \ 1 byte ASC;  "M" = Missing,
1456: 0000:                              \              "E" = Excess,
1457: 0000:                              \              "R" = Repairs
1458: 0000:     STKMQ.SUPPLIER.NUM$,     \ 3 byte UPD
1459: 0000:     STKMQ.INVOICE.NUM$,      \*9 byte ASC
1460: 0000:     STKMQ.FOLIO.NUM$,        \ 3 byte UPD
1461: 0000:     STKMQ.BATCH.REF$,        \ 3 byte UPD
1462: 0000:     STKMQ.WHOLE.PART.CON$,   \ 1 byte ASC   "W" = Whole, "P" = Part
1463: 0000:     STKMQ.REPAIR.CATEGORY$,  \ 1 byte UPD;   1 = Plan4,
1464: 0000:                              \               2 = Estimate,
1465: 0000:                              \               3 = Boots guarantee,
1466: 0000:                              \               4 = Supplier guarantee,
1467: 0000:                              \               5 = Other guarantee,
1468: 0000:     STKMQ.REPAIR.NUM$,       \ 6 byte UPD
1469: 0000:     STKMQ.PLAN4.POLICY.NUM$, \ 6 byte UPD; (Only if repair cat is Plan4)
1470: 0000:     STKMQ.DDDA.DCDR.NUM$,    \ 4 byte UPD
1471: 0000:     STKMQ.DELIV.NOTE.NUM$,   \*9 byte ASC
1472: 0000:     STKMQ.NUM.CARTONS.RECEIV$,\1 byte UPD
1473: 0000:     STKMQ.ORDER.NUM$,        \*7 byte ASC
1474: 0000:     STKMQ.COMMENT$,          \*20 byte ASC
1475: 0000:     STKMQ.ITEM.BARCODE.FLAG$,\ 1 byte ASC;  "I" = Boots item code,
1476: 0000:                              \               "B" = Barcode.
1477: 0000:     STKMQ.ITEM.BARCODE$,     \ 7 byte UPD
1478: 0000:     STKMQ.ITEM.PRICE$,       \ 3 byte UPD;  Spaces.
1479: 0000:     STKMQ.AUTHORISATION$,    \ 15 byte ASC
1480: 0000:     STKMQ.ADJ.STOCK.FIGURE$, \ 1 byte ASC;  "Y" or "N"
1481: 0000:     STKMQ.RETURN.REASON$,    \ 1 byte UPD;  (See CCRSN file)
1482: 0000:     STKMQ.UOD.NUM$,          \ 7 byte UPD
1483: 0000:     STKMQ.UOD.STATUS$,       \ 1 byte ASC;  "O" = Open,
1484: 0000:                              \              "C" = Closed,
1485: 0000:                              \              "D" = Despatched
1486: 0000:     STKMQ.SUPPLY.ROUTE$,     \ 1 byte ASC
1487: 0000:     STKMQ.DISP.LOCATION$,    \ 1 byte ASC   "M" = MDS,
1488: 0000:                              \              "D" = Dispensary
1489: 0000:     STKMQ.RECALL.NUM$,       \ 8 byte ASC
1490: 0000:     STKMQ.SUPPLIER$,         \ 15 byte ASC
1491: 0000:     STKMQ.RETURN.METHOD$,    \ 1 byte UPD;   1 = Carrier,
1492: 0000:                              \               2 = BIRD,
1493: 0000:                              \               3 = Via D6,
1494: 0000:                              \               4 = Representative
1495: 0000:     STKMQ.CARRIER$,          \ 1 byte UPD;   1 = GPO,
1496: 0000:                              \               2 = Parcelforce,
1497: 0000:                              \               3 = Securicor,
1498: 0000:                              \               4 = Other
1499: 0000:     STKMQ.BIRD.NUM$,         \ 8 byte ASC
1500: 0000:     STKMQ.WAREHOUSE.ROUTE$,  \ 1 byte ASC   "R" = RDC,
1501: 0000:                              \              "C" = CSR
1502: 0000:     STKMQ.UOD.TYPE$,         \ 1 byte UPD;   1 = Travel Outer,
1503: 0000:                              \               2 = Town Tray,
1504: 0000:                              \               3 = Roll cage,
1505: 0000:                              \               4 = Other
1506: 0000:     STKMQ.DAMAGE.REASON$,    \ 1 byte UPD    1 = Bad packaging,
1507: 0000:                              \               2 = Poor handling
1508: 0000:     STKMQ.RECEIVING.STORE$,  \ 2 byte UPD
1509: 0000:     STKMQ.DESTINATION$,      \ 1 byte UPD    1 = Business Centre,
1510: 0000:                              \               2 = MTS,
1511: 0000:                              \               3 = Other
1512: 0000:     STKMQ.DATE.UOD.OPENED$,  \ 3 byte UPD
1513: 0000:     STKMQ.DATE.DESPATCHED$,  \ 3 byte UPD
1514: 0000:     STKMQ.TIME.DESPATCHED$,  \ 3 byte UPD
1515: 0000:     STKMQ.ITEM.UPDATED$,     \ 1 byte ASC
1516: 0000:     STKMQ.DATE.SESS.END$,    \ 3 byte UPD
1517: 0000:     STKMQ.TIME.SESS.END$,    \ 3 byte UPD
1518: 0000:     STKMQ.NEW.STATUS.FLAG$,  \ 1 byte ASC   "C" = Closed,
1519: 0000:                              \              "D" = Despatched,
1520: 0000:                              \              "X" = Cancelled
1521: 0000:     STKMQ.ITEM.NUM$,         \ 2 byte UPD   (CCITF key value)
1522: 0000:     STKMQ.CLAIM.VALUE$,      \ 3 byte UPD
1523: 0000:     STKMQ.CARTON.FLAG$,      \ 1 byte  ASCII - ' ' Old Process,             ! 1.3NWB
1524: 0000:                              \                 'N' Normal Book In           ! 1.3NWB
1525: 0000:                              \                 'A' Carton Audit Process     ! 1.3NWB
1526: 0000:                              \                 'E' Exception Process (nof)  ! 1.3NWB
1527: 0000:     STKMQ.CARTON.NO$,        \ 4 bytes UPD (0-9999)                         ! 1.3NWB
1528: 0000:     STKMQ.RECALL.TYPE$       ! 1 byte ASC   "B" = Batch Recall              ! 1.4BG
1529: 0000:                              !              "N" = Non-batch Recall          ! 1.4BG
1530: 0000:                              !              " " = Old Credit Claim          ! 1.4BG
1531: 0000: 
1532: 0000: !***********************************************************!* DC 1.6
1533: 0000: !* Added for +UOD Development                               !* DC 1.6
1534: 0000: !***********************************************************!* DC 1.6
1535: 0000:   STRING GLOBAL \                                           !* DC 1.6 
1536: 0000:     STKMQ.LICENCE.PLATE$, \                                 !* DC 1.6 
1537: 0000:     STKMQ.DESPATCH.DATE$, \                                 !* DC 1.6 
1538: 0000:     STKMQ.ACTION$, \                                        !* DC 1.6 
1539: 0000:     STKMQ.DELIVERY.DATE$, \                                 !* DC 1.6 
1540: 0000:     STKMQ.DELIVERY.TIME$, \                                 !* DC 1.6 
1541: 0000:     STKMQ.DRIVER.ID$, \                                     !* DC 1.6 
1542: 0000:     STKMQ.BOOKIN.DATE$, \                                   !* DC 1.8
1543: 0000:     STKMQ.BOOKIN.TIME$, \                                   !* DC 1.8 
1544: 0000:     STKMQ.OP.ID$, \                                         !* DC 1.6 
1545: 0000:     STKMQ.BOOKIN.METHOD$, \                                 !* DC 1.6 
1546: 0000:     STKMQ.BOOKIN.LEVEL$, \                                  !* DC 1.6 
1547: 0000:     STKMQ.GIT$, \                                           !* DC 1.6 
1548: 0000:     STKMQ.RESCAN$, \                                        !* DC 1.7
1549: 0000:     STKMQ.FILLER$                                           !* DC 1.6 
1550: 0000: 
1551: 0000:   INTEGER*2 GLOBAL           \                              !* DC 1.6 
1552: 0000:     STKMQ.SESS.NUM%,         \                              !* DC 1.6 
1553: 0000:     STKMQ.REPORT.NUM%                                       !* DC 1.6 
1554: 0000: !***********************************************************!* DC 1.6
1555: 0000: 
1556: 0000:     STRING GLOBAL                                                       \   !FMW
1557: 0000:         STKMQ.UOD.QTY$,         \                                       \   !FMW
1558: 0000:         STKMQ.CODE$(1),         \ Item Code                             \   !FMW
1559: 0000:         STKMQ.TYPE$(1),         \ Code type I = Item code               \   !FMW
1560: 0000:                                 \           B = Barcode                 \   !FMW
1561: 0000:         STKMQ.CSR.FLAG$(1),     \ CSR Flag                              \   !FMW
1562: 0000:         STKMQ.EAN.CODE$(1),     \ Barcode                               \   !FMW
1563: 0000:         STKMQ.QTY$(1),          \ Quantity                              \   !FMW
1564: 0000:         STKMQ.GOOD.QUAN$(1),    \ Good Quantity                         \   !FMW
1565: 0000:         STKMQ.DAM.QUAN$(1),     \ Damaged Quantity                      \   !FMW
1566: 0000:         STKMQ.STOL.QUAN$(1),    \ Stolen Quantity                       \   !FMW
1567: 0000:         STKMQ.PRICE.ARRAY$(1)   ! Retail Price                              !FMW
1568: 0000:                                                                             !FMW
1569: 0000:     INTEGER*2 GLOBAL                                                    \   !FMW
1570: 0000:         STKMQ.ITEM%             ! Count of items in a transaction           !FMW
1571: 0000: 
1572: 0000:  %INCLUDE BCSMFDEC.J86                    ! FLC
1573: 0000: REM \
1574: 0000: \******************************************************************************
1575: 0000: \******************************************************************************
1576: 0000: \***
1577: 0000: \***   %INCLUDE FOR BUSINESS CENTRE SUPPLY METHOD FILE REFERENCE PARAMETERS
1578: 0000: \***                                              FIELD DECLARATIONS
1579: 0000: \***
1580: 0000: \***               REFERENCE    : BCSMFDEC.J86
1581: 0000: \***
1582: 0000: \***  Version A - L Cook
1583: 0000: \***  Copied from bcsmfnue.j86 and bcsmffle.j86
1584: 0000: \***
1585: 0000: \***  Version B - Les Cook
1586: 0000: \***  to include integer missed from bcsmfflf.j86 in error
1587: 0000: \***
1588: 0000: \******************************************************************************
1589: 0000: \*******************************************************************************
1590: 0000: 
1591: 0000:   STRING GLOBAL           \
1592: 0000:     BCSMF.FILE.NAME$,              \ 
1593: 0000:     BCSMF.FSI$,                    \ 1 byte ASCII folio series identifier (key)
1594: 0000:     BCSMF.NAME$,                   \ 14 bytes ASCII business centre name
1595: 0000:     BCSMF.PSEUDO.BUSINESS.CENTRE$, \ 1 byte flag "Y" = pseudo bc
1596: 0000:     BCSMF.FILLER$                  ! 3 bytes spaces
1597: 0000: 
1598: 0000:   INTEGER*1 GLOBAL          \
1599: 0000:     BCSMF.RECNT.LIMIT%,     \ percentage of recounts that may be generated
1600: 0000:     BCSMF.MIN.RECNT.LIMIT%, \ minimum limit
1601: 0000:     BCSMF.MAX.RECNT.LIMIT%, \ maximum limit
1602: 0000:     BCSMF.DISCRPNCY.CNT%,   \ used to calculate   
1603: 0000:     BCSMF.DISCRPNCY.PERCNT%,\ if recount
1604: 0000:     BCSMF.STK.CNT.LIMIT%,   \ is necessary
1605: 0000:     BCSMF.SEQUENCE.NO%,     \ used for displaying
1606: 0000:     BCSMF.NO.REPEAT.TICKETS% ! Number of repeat FALCONCRAFT tickets	! CLC
1607: 0000: 
1608: 0000:   INTEGER*2 GLOBAL        \
1609: 0000:     BCSMF.DISCRPNCY.VAL%,   \ (in pounds) used for determining recounts
1610: 0000:     BCSMF.MIN.LIST.NO%,     \ allowable range of 
1611: 0000:     BCSMF.MAX.LIST.NO%,     \ spare list numbers
1612: 0000:     BCSMF.RECL%,          \
1613: 0000:     BCSMF.SESS.NUM%,      \
1614: 0000:     BCSMF.REPORT.NUM%
1615: 0000:  %INCLUDE IEFDEC.J86                      ! DLC
1616: 0000: REM \
1617: 0000: \******************************************************************************
1618: 0000: \******************************************************************************
1619: 0000: \***
1620: 0000: \***         %INCLUDE FOR ITEM EAN CODES FILE - FIELD DECLARATIONS
1621: 0000: \***                                            FILE REFERENCE PARAMETERS
1622: 0000: \***
1623: 0000: \***               FILE TYPE    : Keyed
1624: 0000: \***
1625: 0000: \***               REFERENCE    : IEFDEC.J86
1626: 0000: \***
1627: 0000: \***    VERSION B.              ROBERT COWEY.                       21 OCT 1993.
1628: 0000: \***    No changes to this file.
1629: 0000: \***
1630: 0000: \*******************************************************************************
1631: 0000: \*******************************************************************************
1632: 0000: 
1633: 0000:   STRING GLOBAL                      \
1634: 0000:     IEF.FILE.NAME$,		     \
1635: 0000:     IEF.BOOTS.CODE.BAR.CODE$,        \ 9 byte UPD -                        BBAAS
1636: 0000:                                      \ 3 bytes UPD boots code              BBAAS   
1637: 0000:                                      \ + 6 UPD bar code,                   BBAAS
1638: 0000:                                      \ no check digits. (key)              BBAAS
1639: 0000:     IEF.NEXT.BAR.CODE$               ! 6 byte UPD without check digit
1640: 0000: 
1641: 0000:   INTEGER*2 GLOBAL        \
1642: 0000:     IEF.REPORT.NUM%,	  \
1643: 0000:     IEF.SESS.NUM%,	  \ 
1644: 0000:     IEF.RECL%
1645: 0000:  %INCLUDE DIRORDEC.J86                    ! DLC
1646: 0000: REM \
1647: 0000: \******************************************************************************
1648: 0000: \******************************************************************************
1649: 0000: \***
1650: 0000: \***     %INCLUDE FOR STORE DIRECT ORDERS FILE  - FIELD DECLARATIONS
1651: 0000: \***                                              FILE REFERENCE PARAMETERS
1652: 0000: \***
1653: 0000: \***               FILE TYPE    : Keyed
1654: 0000: \***
1655: 0000: \***               REFERENCE    : DIRORDEC.J86
1656: 0000: \***
1657: 0000: \***               DATE OF LAST AMENDMENT - 14/08/1992
1658: 0000: \***
1659: 0000: \***               VERSION A    : Les Cook    14th August 1992
1660: 0000: \***
1661: 0000: \***  VERSION B                 Neil Bennett                21st December 2006
1662: 0000: \***  New variable added to hold superceded flag for ASN Carton Support.
1663: 0000: \***
1664: 0000: \******************************************************************************
1665: 0000: \******************************************************************************
1666: 0000: 
1667: 0000:   STRING GLOBAL               \
1668: 0000:       DIRORD.FILE.NAME$,      \
1669: 0000:     DIRORD.RECKEY$,           \ 9 byte key which comprises the following fields
1670: 0000:     DIRORD.SUPPLIER$,         \ 3 bytes UPD (key)
1671: 0000:     DIRORD.ORDER.NO$,         \ 2 bytes UPD (key)
1672: 0000:     DIRORD.ORDER.SUF$,        \ 1 byte ASCII (key)
1673: 0000:     DIRORD.BUS.CENTRE$,       \ 1 byte ASCII (key)
1674: 0000:     DIRORD.SOURCE$,           \ 1 byte ASCII (key), 'D' if from PSS57
1675: 0000:                               \                     ' ' for head office order
1676: 0000:     DIRORD.PAGE.NO$,          \ 1 byte UPD (key)
1677: 0000:                               \
1678: 0000:     DIRORD.CONF.END.TIME$,    \ 2 bytes UPD - Ending time of last update
1679: 0000:     DIRORD.CONF.STRT.TIME$,   \ 2 bytes UPD - Starting time of last update
1680: 0000:     DIRORD.CONFIRM.DATE$,     \ 3 bytes UPD. YYMMDD - set to low values if
1681: 0000:                               \                       confirm flag is blank
1682: 0000:     DIRORD.CONFIRM.FLAG$,     \ 1 byte ASCII. C=Complete, A=Amended,
1683: 0000:                               \               blank = not confirmed
1684: 0000:     DIRORD.DRRF.LAST.DATE$,   \ 3 bytes UPD Date of last run
1685: 0000:     DIRORD.DRRF.LAST.TIME$,   \ 2 bytes UPD Time of last run
1686: 0000:     DIRORD.EXP.DELV.DATE$,    \ 3 bytes UPD. YYMMDD - Expected date of order's
1687: 0000:                               \                       delivery
1688: 0000:     DIRORD.FILLER1$,          \ 494 bytes ASCII set to spaces
1689: 0000:     DIRORD.FILLER2$,          \ 474 bytes ASCII set to spaces
1690: 0000:     DIRORD.FILLER3$,          \ 15 bytes ASCII set to spaces
1691: 0000:     DIRORD.ITEM.COUNT$,       \ 1 byte UPD  - Number of items on record
1692: 0000:     DIRORD.ITEM.DETAILS$(2),  \ 256 bytes containing the repeated item string
1693: 0000:                               \ details. The first dimension has 16 elements
1694: 0000:                               \ corresponding to lines on the invoice.  The
1695: 0000:                               \ second dimension has 4 elements:-
1696: 0000:                               \   1. Boots Code - 4 bytes UPD (0 if bar code
1697: 0000:                               \                                has no matching
1698: 0000:                               \                                Boots code on
1699: 0000:                               \                                file)
1700: 0000:                               \   2. Bar Code   - 6 bytes UPD
1701: 0000:                               \   2. Price      - 4 bytes UPD
1702: 0000:                               \   3. Filler     - 2 bytes ASCII spaces
1703: 0000:                               \ Any unused entries are set to spaces
1704: 0000:     DIRORD.NO.ITEMS.BOOKED$,  \ 2 bytes UPD - Total number of items booked in
1705: 0000:     DIRORD.NO.ITEMS.LST.BKD$, \ 2 bytes UPD - Number of items booked in during
1706: 0000:                               \               last date of update
1707: 0000:     DIRORD.NO.ORDER.ITEM$,    \ 2 bytes UPD - Total number of items in order
1708: 0000:     DIRORD.NO.ORDER.SNGL$,    \ 2 bytes UPD - Total single quantity in order
1709: 0000:     DIRORD.ON.SALE.DATE$,     \ 3 bytes UPD. YYMMDD - Date stock should be on
1710: 0000:                               \                       sale
1711: 0000:     DIRORD.ORDER.DATE$,       \ 3 bytes UPD. YYMMDD Date of order
1712: 0000:     DIRORD.SUPERCEDED$        ! 1 byte ASCII (Y/N) default to N             !BNWB
1713: 0000: 
1714: 0000:     INTEGER*2 GLOBAL       \
1715: 0000:       DIRORD.ITEM.QTY%(2), \ contains the repeated item integer details. The
1716: 0000:                            \ first dimension has 16 elements corresponding to
1717: 0000:                            \ lines on the invoice.  The second dimension has 7
1718: 0000:                            \ elements:-
1719: 0000:                            \   1. Quantity expected from order
1720: 0000:                            \   2. Quantity booked in in good condition
1721: 0000:                            \   3. Quantity booked in in damaged condition
1722: 0000:                            \   4. Quantity booked in as stolen
1723: 0000:                            \   5. Quantity last booked in in good condition
1724: 0000:                            \   6. Quantity last booked in in damaged condition
1725: 0000:                            \   7. Quantity last booked in as stolen
1726: 0000:                            \   Fields 2 to 4 are running totals, fields 5 to 7
1727: 0000:                            \   are the values associated with the confirm/amend
1728: 0000:                            \   date.
1729: 0000:       DIRORD.RECL%,        \
1730: 0000:       DIRORD.SESS.NUM%,    \
1731: 0000:       DIRORD.REPORT.NUM%
1732: 0000: 
1733: 0000:     INTEGER*4 GLOBAL       \
1734: 0000:       DIRORD.NO.RECS%
1735: 0000:  %INCLUDE DIRSUDEC.J86                    ! DLC
1736: 0000: REM \
1737: 0000: \******************************************************************************
1738: 0000: \******************************************************************************
1739: 0000: \***
1740: 0000: \***     %INCLUDE FOR STORE DIRECT SUPPLIER FILE FIELD DECLARATIONS
1741: 0000: \***                                             FILE REFERENCE PARAMETERS
1742: 0000: \***      
1743: 0000: \***               FILE TYPE    : Keyed
1744: 0000: \***
1745: 0000: \***               REFERENCE    : DIRSUDEC.J86
1746: 0000: \***
1747: 0000: \***     Version A - L Cook
1748: 0000: \***
1749: 0000: \***     Combined DIRSUFLA.J86 and DIRSUNUA.J86
1750: 0000: \***
1751: 0000: \***   Version B           Mark Goode          3rd December 2008
1752: 0000: \***   Add new fields for the +ve UOD project
1753: 0000: \***
1754: 0000: \******************************************************************************
1755: 0000: \******************************************************************************
1756: 0000: 
1757: 0000:   STRING GLOBAL            \
1758: 0000:     DIRSUP.FILE.NAME$,     \
1759: 0000:     DIRSUP.RECKEY$,        \ 4 byte key which comprises the following fields
1760: 0000:       DIRSUP.BUS.CENTRE$,  \ 1 byte ASCII (key)
1761: 0000:       DIRSUP.SUPPLIER.NO$, \ 3 bytes UPD (key)
1762: 0000:                            \
1763: 0000:     DIRSUP.SUPPLIER.NAME$, \ 10 byte ASCII
1764: 0000:     DIRSUP.LEAD.TIME.MON$, \ 2 bytes UPD. Lead time for MONDAY in days
1765: 0000:     DIRSUP.LEAD.TIME.TUE$, \ 2 bytes UPD. Lead time for TUESDAY in days
1766: 0000:     DIRSUP.LEAD.TIME.WED$, \ 2 bytes UPD. Lead time for WEDNESDAY in days
1767: 0000:     DIRSUP.LEAD.TIME.THU$, \ 2 bytes UPD. Lead time for THURSDAY in days
1768: 0000:     DIRSUP.LEAD.TIME.FRI$, \ 2 bytes UPD. Lead time for FRIDAY in days
1769: 0000:     DIRSUP.LAPSING.DAYS$,  \ 2 bytes UPD. Number of days before order lapses
1770: 0000:     DIRSUP.PART.ORDER.RULES$, \ 1 byte ASCII. A=Rest of order supplied, 
1771: 0000:                               \               N,Z=not supplied 
1772: 0000:     DIRSUP.MAX.CHECK.QTY$,    \ 2 bytes UPD.
1773: 0000:     DIRSUP.CHECK.QTY$,        \ 2 bytes UPD.
1774: 0000:     DIRSUP.DISCREPANCY.QTY$,  \ 2 bytes UPD.
1775: 0000:     DIRSUP.DISCREPANCY.PERC$, \ 2 bytes UPD. Discrepancy percentage
1776: 0000:     DIRSUP.ASN.FLAG$,         \ 1 byte ASCII. Identifies supplier as ASN or Directs   ! BMG
1777: 0000:     DIRSUP.STATIC.SUPPLIER$,  \ 1 byte ASCII. Identifies supplier as being static     ! BMG
1778: 0000:     DIRSUP.FILLER$          ! 3 bytes ASCII set to low values                         ! BMG
1779: 0000: 
1780: 0000:   INTEGER*2 GLOBAL        \
1781: 0000:     DIRSUP.RECL%,         \
1782: 0000:     DIRSUP.SESS.NUM%,     \
1783: 0000:     DIRSUP.REPORT.NUM%
1784: 0000:     
1785: 0000:   INTEGER*4 GLOBAL        \
1786: 0000:     DIRSUP.NO.RECS%  
1787: 0000:  %INCLUDE DIRWFDEC.J86                    ! DLC
1788: 0000: \******************************************************************************
1789: 0000: \******************************************************************************
1790: 0000: \***
1791: 0000: \***      %INCLUDE FOR DIRWF - DIRECT WORK FILE - FIELD DEFINITIONS
1792: 0000: \***                                              FILE REFERENCE PARAMETERS
1793: 0000: \***
1794: 0000: \***
1795: 0000: \***       REFERENCE: DIRWFDEC.J86
1796: 0000: \***
1797: 0000: \******************************************************************************
1798: 0000: \*******************************************************************************
1799: 0000: 
1800: 0000:   STRING GLOBAL								\
1801: 0000: 	DIRWF.FILE.NAME$,						\
1802: 0000: 	DIRWF.RECORD$
1803: 0000: 
1804: 0000:   INTEGER*2 GLOBAL							\
1805: 0000: 	DIRWF.RECL%,	          					\
1806: 0000: 	DIRWF.SESS.NUM%,						\
1807: 0000: 	DIRWF.REPORT.NUM%
1808: 0000:  %INCLUDE DIRECDEC.J86                    ! DLC
1809: 0000: \******************************************************************************
1810: 0000: \******************************************************************************
1811: 0000: \***
1812: 0000: \***         %INCLUDE FOR DIREC DUMMY FILE I/O SESSION NUMBER
1813: 0000: \***
1814: 0000: \***               REFERENCE    : DIRECDEC.J86
1815: 0000: \***
1816: 0000: \******************************************************************************
1817: 0000: \*******************************************************************************
1818: 0000: 
1819: 0000:   STRING GLOBAL           \
1820: 0000:     DIREC.FILE.NAME$
1821: 0000: 
1822: 0000:   INTEGER*2 GLOBAL        \
1823: 0000:     DIREC.REPORT.NUM%,      \
1824: 0000:     DIREC.SESS.NUM%
1825: 0000:  %INCLUDE LDTCFDEC.J86                    ! DLC
1826: 0000: \******************************************************************************
1827: 0000: \******************************************************************************
1828: 0000: \***
1829: 0000: \***      %INCLUDE FOR LDTCF - LDT CHECK FILE - FILE REFERENCE PARAMETERS
1830: 0000: \***                                            FIELD DEFINITIONS
1831: 0000: \***
1832: 0000: \***       REFERENCE: LDTCFDEC.J86
1833: 0000: \***
1834: 0000: \***
1835: 0000: \******************************************************************************
1836: 0000: \*******************************************************************************
1837: 0000: 
1838: 0000:    STRING GLOBAL							\
1839: 0000: 	LDTCF.FILE.NAME$,						\
1840: 0000: 	LDTCF.VERSION.NO$,                                              \
1841: 0000: 	LDTCF.VERSION.DATE$
1842: 0000: 	
1843: 0000:    INTEGER*2 GLOBAL							\
1844: 0000:         LDTCF.SESS.NUM%,						\
1845: 0000: 	LDTCF.REPORT.NUM%
1846: 0000:  %INCLUDE DRSMQDEC.J86                    ! DLC
1847: 0000: \******************************************************************************
1848: 0000: \******************************************************************************
1849: 0000: \***
1850: 0000: \***      %INCLUDE FOR DIRECTS TEMPORARY STOCK MOVEMENT QUEUE
1851: 0000: \***       FILE FIELD DECLARATIONS
1852: 0000: \***       FILE REFERENCE PARAMETERS
1853: 0000: \***
1854: 0000: \***               FILE TYPE    : Sequential
1855: 0000: \***
1856: 0000: \***               REFERENCE    : DRSMQDEC.J86
1857: 0000: \***
1858: 0000: \***
1859: 0000: \******************************************************************************
1860: 0000: \*******************************************************************************
1861: 0000: \***
1862: 0000: \***  The length of the records on this file vary depending on the record
1863: 0000: \***  transaction type, but they all comprise combinations of the fields
1864: 0000: \***  defined below.
1865: 0000: \***
1866: 0000: \***  Transaction type 17- RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
1867: 0000: \***     TIME, SOURCE, SUPPLIER NUMBER, ORDER NUMBER, ORDER SUFFIX, PAGE
1868: 0000: \***     NUMBER, ITEM COUNT, FIELD DELIMITER, ITEM CODE, BAR CODE,
1869: 0000: \***     QUANTITY - GOOD, FIELD DELIMITER, QUANTITY - DAMAGED, FIELD DELIMITER,
1870: 0000: \***     QUANTITY - STOLEN (the last 8 fields repeat ITEM COUNT times),
1871: 0000: \***     RECORD DELIMITER, END OF RECORD DELIMITER
1872: 0000: \***
1873: 0000: \***  Transaction type 19- RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, DATE,
1874: 0000: \***     TIME, SUPPLIER NUMBER, ORDER NUMBER, ORDER SUFFIX, CONFIRM/AMEND FLAG,
1875: 0000: \***     START TIME, END TIME, NO SINGLES ADDED, NO ITEMS ADDED, NO ITEMS
1876: 0000: \***     BOOKED IN, RECORD DELIMITER, END OF RECORD DELIMITER
1877: 0000: \***
1878: 0000: \*******************************************************************************
1879: 0000: \***
1880: 0000: \***   REVISION 1.0     Neil Bennett                 2nd January 2007
1881: 0000: \***   Add ASN processing support.
1882: 0000: \***
1883: 0000: \*******************************************************************************
1884: 0000: 
1885: 0000:   STRING GLOBAL              \
1886: 0000:     DRSMQ.FILE.NAME$,        \
1887: 0000:     DRSMQ.RECORD$,           \ Used to store the whole record which is unstrung
1888: 0000:                              \ into the fields below
1889: 0000:     DRSMQ.RECORD.DELIMITER$, \ 1 byte ASCII set to " (CHR$(34))
1890: 0000:     DRSMQ.TRANS.TYPE$,       \ 1 byte UPD.
1891: 0000:                              \             17 = Delivery without confirmation
1892: 0000:                              \                  of Direct Order detail
1893: 0000:                              \             19 = Delivery without confirmation
1894: 0000:                              \                  of Direct Order header
1895: 0000:     DRSMQ.FIELD.DELIMITER$,  \ 1 byte ASCII set to ; (CHR$(59))
1896: 0000:     DRSMQ.DATE$,             \ 3 byte UPD set to current date
1897: 0000:     DRSMQ.TIME$,             \ 3 byte UPD set to current time
1898: 0000:     DRSMQ.ITEM.COUNT$,       \ 1 byte UPD between 1 and 17
1899: 0000:     DRSMQ.BOOTS.CODE$,       \ 4 bytes UPD
1900: 0000:     DRSMQ.QUANTITY$,         \ variable length string equivalent to
1901: 0000:                              \ STR$(DRSMQ.QUANTITY%)
1902: 0000:                              \ +ve indicates add to stock
1903: 0000:                              \ -ve indicates subtract from stock
1904: 0000:     DRSMQ.ENDREC.MARKER$,    \ 2 bytes ASCII set to XODOA
1905: 0000:     DRSMQ.SUPPLIER.NO$,      \ 4 bytes UPD
1906: 0000:     DRSMQ.ORDER.NO$,         \ 2 bytes UPD
1907: 0000:     DRSMQ.ORDER.SFX$,        \ 1 byte ASCII
1908: 0000:     DRSMQ.PAGE.NO$,          \ 1 byte UPD
1909: 0000:     DRSMQ.ORDER.DATE$,       \ 3 bytes UPD
1910: 0000:     DRSMQ.SOURCE$,           \ 1 byte ASCII Source flag
1911: 0000:                              \ 'S' - PSS65, 'P' - PDT, PSS57
1912: 0000:     DRSMQ.BAR.CODE$,         \ 6 bytes UPD
1913: 0000:     DRSMQ.QTY.GOOD$,         \ VARIABLE ASCII
1914: 0000:                              \ Quantity of singles booked in in good condition
1915: 0000:     DRSMQ.QTY.BAD$,          \ VARIABLE ASCII
1916: 0000:                              \ Quantity of singles booked in in bad condition
1917: 0000:     DRSMQ.QTY.STOLEN$,       \ VARIABLE ASCII
1918: 0000:                              \ Quantity of singles recognised as stolen
1919: 0000:     DRSMQ.CONF.AMND.FLAG$,   \ 1 byte ASCII - Confirm/ Amend Flag
1920: 0000:                              \ 'C' - Order has been confirmed
1921: 0000:                              \ 'A' - Order has been amended
1922: 0000:                              \ ' ' - Nothing has been done to the order
1923: 0000:     DRSMQ.START.TIME$,       \ 2 byte UPD (HHMM) time order started to be
1924: 0000:                              \ processed
1925: 0000:     DRSMQ.END.TIME$,         \ 2 byte UPD (HHMM) time order was completed
1926: 0000:     DRSMQ.SNGLS.ADDED$,      \ 5 bytes ASCII Singles added to order
1927: 0000:     DRSMQ.ITEMS.ADDED$,      \ 5 bytes ASCII Items added to order
1928: 0000:     DRSMQ.ITEMS.BOOKED$,     \ 5 bytes ASCII Items booked in on the order
1929: 0000:     DRSMQ.CARTON.FLAG$,      \ 1 byte  ASCII - ' ' Old Process,             ! 1.0NWB
1930: 0000:                              \                 'N' Normal Book In           ! 1.0NWB
1931: 0000:                              \                 'A' Carton Audit Process     ! 1.0NWB
1932: 0000:                              \                 'E' Exception Process (nof)  ! 1.0NWB
1933: 0000:     DRSMQ.CARTON.NO$         ! 4 bytes UPD (0-9999)                         ! 1.0NWB
1934: 0000: 
1935: 0000: 
1936: 0000:   INTEGER*2 GLOBAL           \
1937: 0000:     DRSMQ.SESS.NUM%,         \
1938: 0000:     DRSMQ.REPORT.NUM%
1939: 0000:  %INCLUDE LDTBFDEC.J86                    ! ELC
1940: 0000: \******************************************************************************
1941: 0000: \***
1942: 0000: \***           %INCLUDE FOR LDTBF - LDT STOCK BUFFER FILE
1943: 0000: \***
1944: 0000: \***                    - FIELD DECLARATIONS   
1945: 0000: \***                    - FILE REFERENCE PARAMETERS  
1946: 0000: \***  
1947: 0000: \***                    REFERENCE: LDTBFDEC.J86
1948: 0000: \***      
1949: 0000: \******************************************************************************
1950: 0000: \***
1951: 0000: \***     Version A:      Mike Kelsall      12th October 1992
1952: 0000: \***
1953: 0000: \***     Each order in the LDTBF is recorded in the following format:
1954: 0000: \***
1955: 0000: \***         Order Header  -  Record Identifier   2  ASC  "OH"
1956: 0000: \***                          Supplier Number     3  UPD
1957: 0000: \***                          Order Number        2  UPD
1958: 0000: \***                          Order Suffix        1  ASC   
1959: 0000: \*** 
1960: 0000: \***  (N x)  Order Record  -  Record Identifier   2  ASC  "OD"
1961: 0000: \***                          Boots/Bar code      6  UPD
1962: 0000: \***                          Damaged Quantity    2  INT
1963: 0000: \***                          Stolen Quantity     2  INT
1964: 0000: \*** 
1965: 0000: \***         Order Trailer -  Record Identifier   2  ASC  "OT"
1966: 0000: \***                          Number of items     2  INT 
1967: 0000: \***
1968: 0000: \***
1969: 0000: \***     Version B.          Stuart Highley            8th August 1997
1970: 0000: \***     Added fields: LDTBF.DATE$, LDTBF.START.TIME$, LDTBF.END.TIME$,
1971: 0000: \***                   LDTBF.LOGGED.QTY%
1972: 0000: \***
1973: 0000: \******************************************************************************
1974: 0000: 
1975: 0000: INTEGER*1 GLOBAL                 \
1976: 0000:                                  \
1977: 0000:            LDTBF.SESS.NUM% 
1978: 0000: 
1979: 0000: 
1980: 0000: INTEGER*2 GLOBAL                 \
1981: 0000:                                  \
1982: 0000:            LDTBF.RECL%,          \
1983: 0000:            LDTBF.REPORT.NUM%,    \
1984: 0000:                                  \
1985: 0000:            LDTBF.LOGGED.QTY%,    \  2 byte INT - Already logged qty    ! BSH
1986: 0000:            LDTBF.DAMAGED.QTY%,   \  2 byte INT - Damaged quantity, from LDT
1987: 0000:            LDTBF.STOLEN.QTY%,    \  2 byte INT - Stolen quantity, from LDT
1988: 0000:            LDTBF.GOOD.QTY%,      \  2 byte INT - Good quantity, from LDT
1989: 0000:            LDTBF.ORDERED.QTY%,   \  2 byte INT - Ordered quantity
1990: 0000:            LDTBF.NUM.OF.ITEMS%   !  2 byte INT - Number of items in order
1991: 0000:      
1992: 0000: 
1993: 0000: STRING GLOBAL                    \
1994: 0000:                                  \
1995: 0000:            LDTBF.FILE.NAME$,     \
1996: 0000:                                  \
1997: 0000:            LDTBF.RECORD.ID$,     \  2 byte ASC - Record Identifier
1998: 0000:            LDTBF.SUPPLIER.NUM$,  \  3 byte UPD - Supplier number, from LDT
1999: 0000:            LDTBF.ORDER.NUM$,     \  2 byte UPD - Order number, from LDT 
2000: 0000:            LDTBF.ORDER.SUFFIX$,  \  1 byte ASC - Order suffix, from LDT
2001: 0000:            LDTBF.DATE$,          \  3 byte UPD - Date booked in        ! BSH
2002: 0000:            LDTBF.START.TIME$,    \  2 byte UPD - Time started booking  ! BSH
2003: 0000:            LDTBF.END.TIME$,      \  2 byte UPD - Time ended booking    ! BSH
2004: 0000:            LDTBF.REF.CODE$       !  6 byte UPD - Boots/Bar code, from LDT
2005: 0000:  %INCLUDE IDSOFDEC.J86                    ! ELC
2006: 0000: REM \
2007: 0000: \******************************************************************************
2008: 0000: \******************************************************************************
2009: 0000: \***
2010: 0000: \***      %INCLUDE FOR CSR OUTSTANDING INITIAL STOCK QUANTITIES FILE
2011: 0000: \***                                             FIELD DECLARATIONS
2012: 0000: \***                                             FILE REFERENCE PARAMETERS
2013: 0000: \***
2014: 0000: \***               FILE TYPE    : Keyed
2015: 0000: \***
2016: 0000: \***               REFERENCE    : IDSOFFLD.J86
2017: 0000: \***
2018: 0000: \***      Version A.     Stephen Kelsey (CTG)               21st October 1992
2019: 0000: \***
2020: 0000: \******************************************************************************
2021: 0000: \*******************************************************************************
2022: 0000: 
2023: 0000:   STRING GLOBAL                  \
2024: 0000:     IDSOF.BC.LETTER$,            \ 1 byte UPD
2025: 0000:     IDSOF.EXP.DELV.DATE$,        \ 3 byte UPD YYMMDD
2026: 0000:     IDSOF.FILE.NAME$,            \
2027: 0000:     IDSOF.FILLER$,               \ 10 bytes ASC
2028: 0000:     IDSOF.ITEM.CODE$             ! 4 byte UPD
2029: 0000: 
2030: 0000:   INTEGER*2 GLOBAL               \
2031: 0000:     IDSOF.QUANTITY%,             \ Outstanding Stock Quantity
2032: 0000:     IDSOF.RECL%,                 \     
2033: 0000:     IDSOF.REPORT.NUM%,           \     
2034: 0000:     IDSOF.SESS.NUM% 
2035: 0000:     
2036: 0000:  %INCLUDE UODDEC.J86                      ! FLC
2037: 0000: \******************************************************************************
2038: 0000: \******************************************************************************
2039: 0000: \***
2040: 0000: \***         %INCLUDE FOR UOD DUMMY FILE I/O SESSION NUMBER
2041: 0000: \***
2042: 0000: \***               REFERENCE    : UODDEC.J86
2043: 0000: \***
2044: 0000: \******************************************************************************
2045: 0000: \*******************************************************************************
2046: 0000: 
2047: 0000:   STRING GLOBAL           \
2048: 0000:     UOD.FILE.NAME$
2049: 0000: 
2050: 0000:   INTEGER*2 GLOBAL        \
2051: 0000:     UOD.REPORT.NUM%,      \
2052: 0000:     UOD.SESS.NUM%
2053: 0000:  %INCLUDE UODBFDEC.J86                    ! FLC
2054: 0000: REM \
2055: 0000: \******************************************************************************
2056: 0000: \******************************************************************************
2057: 0000: \***
2058: 0000: \***      %INCLUDE FOR UOD BUFFER FILE FIELD DECLARATIONS
2059: 0000: \***                              FILE REFERENCE PARAMETERS
2060: 0000: \***
2061: 0000: \***               FILE TYPE    : Sequential
2062: 0000: \***
2063: 0000: \***               REFERENCE    : UODBFDEC.J86
2064: 0000: \***
2065: 0000: \***      Version A.     Michael Kelsall             8th February 1993
2066: 0000: \***
2067: 0000: \******************************************************************************
2068: 0000: \*******************************************************************************
2069: 0000: \***
2070: 0000: \***  The length of the records on this file vary depending on the record
2071: 0000: \***  transaction type, but they all comprise combinations of the fields
2072: 0000: \***  defined below.
2073: 0000: \***
2074: 0000: \***  Transaction type 0 (Header record) - RECORD DELIMITER, TRANS TYPE,       
2075: 0000: \***     FIELD DELIMITER, CREATION DATE, CREATION TIME, RECORD DELIMITER,
2076: 0000: \***     END OF RECORD MARKER.
2077: 0000: \***
2078: 0000: \***  Transaction type 21 - RECORD DELIMITER, TRANS TYPE, DATE, TIME, 
2079: 0000: \***     DISTRIBUTION CENTRE, WAREHOUSE NUMBER, STORE NUMBER, UOD NUMBER,
2080: 0000: \***     STATUS, RECORD DELIMITER, END OF RECORD MARKER
2081: 0000: \***
2082: 0000: \***  Transaction type 23 - RECORD DELIMITER, TRANS TYPE, DATE, TIME,
2083: 0000: \***     DISTRIBUTION CENTRE, WAREHOUSE NUMBER, STORE NUMBER, UOD NUMBER,
2084: 0000: \***     STATUS, BOOTS/BAR CODE, BOOTS/BAR CODE FLAG, QUANTITY, 
2085: 0000: \***     FIELD DELIMITER, FSI, FOLIO YEAR, FOLIO MONTH, STORE SUFFIX, 
2086: 0000: \***     FOLIO NO, RECORD DELIMITER, END OF RECORD MARKER
2087: 0000: \***
2088: 0000: \******************************************************************************
2089: 0000: 
2090: 0000:   STRING GLOBAL              \
2091: 0000:     UODBF.FILE.NAME$,	     \
2092: 0000:     UODBF.RECORD$,           \ Used to store the whole record which is unstrung
2093: 0000:                              \ into the fields below
2094: 0000:     UODBF.RECORD.DELIMITER$, \ 1 byte ASCII set to " (CHR$(34)) 
2095: 0000:     UODBF.FIELD.DELIMITER$,  \ 1 byte ASCII set to ; (CHR$(59))
2096: 0000:     UODBF.ENDREC.MARKER$,    \ 2 bytes ASCII set to 0D0Ah
2097: 0000:     UODBF.TRANS.TYPE$,       \ 1 byte UPD. 00 = Header record
2098: 0000: 			     \             21 = UOD record
2099: 0000: 			     \             23 = Item Level UOD record
2100: 0000:     UODBF.CREATION.DATE$,    \ 3 byte UPD set to current date
2101: 0000:     UODBF.CREATION.TIME$,    \ 3 byte UPD set to current time
2102: 0000:     UODBF.DATE$,             \ 3 byte UPD set to current date
2103: 0000:     UODBF.TIME$,             \ 3 byte UPD set to current time
2104: 0000:     UODBF.DIST.CENTRE$,      \ 1 byte UPD   
2105: 0000:     UODBF.WAREHOUSE.NUM$,    \ 1 byte UPD   
2106: 0000:     UODBF.STORE.NUM$,        \ 2 byte UPD
2107: 0000:     UODBF.UOD.NUMBER$,       \ 2 byte UPD
2108: 0000:     UODBF.STATUS$,           \ 1 byte ASC.  "B" = Booked in
2109: 0000:     			     \		    "M" = Missing
2110: 0000: 			     \		    "O" = Opened
2111: 0000: 			     \		    "P" = Picking checked
2112: 0000: 			     \		    "R" = Retro booked in
2113: 0000: 			     \		    "D" = Retrospective opened
2114: 0000: 			     \		    "G" = Retrospective checked
2115: 0000: 			     \		    "A" = Automatically booked in
2116: 0000:     UODBF.BOOTS.BAR.CODE$,   \ 6 byte UPD    
2117: 0000:     UODBF.BOOTS.BAR.CODE.FLAG$, \ 1 byte ASC
2118: 0000:     UODBF.FSI$,              \ 1 byte ASCII
2119: 0000:     UODBF.FOLIO.YEAR$,       \ 1 byte UPD
2120: 0000:     UODBF.FOLIO.MONTH$,      \ 1 byte UPD
2121: 0000:     UODBF.FOLIO.NUMBER$,     \ 2 bytes UPD
2122: 0000:     UODBF.STORE.SUFFIX$      ! 1 byte ASCII
2123: 0000: 
2124: 0000: 			     			     			     
2125: 0000:   INTEGER*2 GLOBAL	     \
2126: 0000:     UODBF.SESS.NUM%,         \
2127: 0000:     UODBF.REPORT.NUM%,	     \
2128: 0000:     UODBF.QUANTITY%
2129: 0000: 			     
2130: 0000:  %INCLUDE UODTFDEC.J86                    ! FLC
2131: 0000: \******************************************************************************
2132: 0000: \******************************************************************************
2133: 0000: \***
2134: 0000: \***      %INCLUDE FOR UODS TEMPORARY FILE
2135: 0000: \***       FILE FIELD DECLARATIONS
2136: 0000: \***       FILE REFERENCE PARAMETERS
2137: 0000: \***
2138: 0000: \***               FILE TYPE    : Sequential
2139: 0000: \***
2140: 0000: \***               REFERENCE    : UODTFDEC.J86
2141: 0000: \***
2142: 0000: \***
2143: 0000: \******************************************************************************
2144: 0000: \*******************************************************************************
2145: 0000: 
2146: 0000:   STRING GLOBAL              \
2147: 0000:     UODTF.FILE.NAME$,	     \
2148: 0000:     UODTF.RECORD$            ! Used to store the whole record 
2149: 0000: 			     			     			     
2150: 0000:   INTEGER*2 GLOBAL	     \
2151: 0000:     UODTF.SESS.NUM%,	     \
2152: 0000:     UODTF.REPORT.NUM%			     
2153: 0000: 			     
2154: 0000:  %INCLUDE PILSTDEC.J86                    ! FLC
2155: 0000: 
2156: 0000: \******************************************************************************
2157: 0000: \***
2158: 0000: \***      %INCLUDE FOR PILST - LIST OF LISTS FILE - FIELD DECLARATIONS
2159: 0000: \***                                                FILE REFERENCE PARAMETERS
2160: 0000: \***
2161: 0000: \***                           8th October 1992
2162: 0000: \***
2163: 0000: \******************************************************************************
2164: 0000: 
2165: 0000:    INTEGER*1 GLOBAL             	\
2166: 0000:         PILST.REPORT.NUM%,		\
2167: 0000: 	PILST.SESS.NUM%,		\
2168: 0000: 	PILST.ITEMS.IN.LIST%,		\ No of items in list
2169: 0000: 	PILST.TO.BE.COUNTED%		! No of items left to be counted
2170: 0000: 
2171: 0000:    INTEGER*2 GLOBAL			\
2172: 0000:         PILST.RECL%
2173: 0000: 
2174: 0000:    STRING GLOBAL			\
2175: 0000: 	PILST.FILE.NAME$,		\
2176: 0000: 	PILST.LIST.NUMBER$,		\ 4 byte - list number
2177: 0000: 	PILST.SPARE.LIST.NUMBER$,	\ 4 byte - spare list number
2178: 0000: 	PILST.LIST.NAME$,		\12 byte - list name
2179: 0000: 	PILST.BC.LETTER$,		\ 1 byte - business centre letter
2180: 0000: 	PILST.LIST.TYPE$,		\ 1 byte - list type :
2181: 0000: 					\    "R" = regular,
2182: 0000: 					\    "C" = CSR,
2183: 0000: 					\    "E" = exceptions.
2184: 0000: 	PILST.COUNT.BY.DATE$,		\ 3 byte UPD - count by date
2185: 0000: 	PILST.PRODUCT.GROUP$,		\ 3 byte UPD - product group
2186: 0000: 	PILST.COUNT.DATE$,		\ 3 byte UPD - scheduled count date
2187: 0000: 	PILST.LIST.STATUS$,		\ 1 byte - list status :
2188: 0000: 					\    "C" = to be counted,
2189: 0000: 					\    "R" = to be re-counted,
2190: 0000: 					\    "X" = cancelled,
2191: 0000: 					\    "F" = completed.
2192: 0000: 	PILST.RECOUNT.DATE$,		\ 3 byte UPD - scheduled re-count date
2193: 0000: 	PILST.RECOUNT.ALLOWED$,		\ 1 byte UPD - re-count allowed flag
2194: 0000: 	PILST.CPM.RUN.DATE$,		\ 3 byte UPD - cpm. run date
2195: 0000: 	PILST.PIPLN.RUN.OK$,	        \ 1 byte - PIPLN run ok flag "Y" / "N"
2196: 0000: 	PILST.HIGHEST.LIST.NO$,	        \ 4 byte - highest transmitted list no
2197: 0000:         PILST.DET.FILLER$,              \ 6 bytes
2198: 0000:         PILST.HDR.FILLER$               ! 24 bytes
2199: 0000: 	
2200: 0000:  %INCLUDE PIITMDEC.J86                    ! FLC
2201: 0000: 
2202: 0000: \******************************************************************************
2203: 0000: \***
2204: 0000: \***     %INCLUDE FOR PIITM - ITEM LIST FILE - FIELD DECLARATIONS
2205: 0000: \***                                           FILE REFERENCE PARAMETERS
2206: 0000: \***
2207: 0000: \***     REFERENCE: PIITMDEC.J86
2208: 0000: \***        
2209: 0000: \***                           8TH OCTOBER 1992
2210: 0000: \***
2211: 0000: \******************************************************************************
2212: 0000: 
2213: 0000:    INTEGER*1 GLOBAL							\
2214: 0000: 	PIITM.REPORT.NUM%,						\
2215: 0000: 	PIITM.SESS.NUM%
2216: 0000: 
2217: 0000:    INTEGER*2 GLOBAL			\
2218: 0000: 	PIITM.RECL%,			\
2219: 0000: 	PIITM.DISCREPANCY%,		\ discrepancy
2220: 0000: 	PIITM.DISCREPANCY.AMT%		! discrepancy amount
2221: 0000: 	
2222: 0000:    STRING GLOBAL			\
2223: 0000: 	PIITM.FILE.NAME$,		\
2224: 0000: 	PIITM.LIST.ITEM.KEY$,		\ 4 + 1 bytes - list no. & item no
2225: 0000: 	PIITM.LIST.NUMBER$,		\ 4 byte - list number
2226: 0000: 	PIITM.ITEM.NUMBER$,		\ 2 byte - item number
2227: 0000: 	PIITM.ITEM.CODE$,		\ 4 byte UPD - item code
2228: 0000: 	PIITM.ON.IDF$,			\ 1 byte - on IDF flag "Y" / "N"
2229: 0000: 	PIITM.ACTIVITY.FLAG$,		\ 1 byte - activity flag
2230: 0000: 	PIITM.CYCLE.LENGTH$,		\ 2 byte - count cycle length (weeks)
2231: 0000: 	PIITM.FAMILY.MARKER$,		\ 2 byte - family marker
2232: 0000: 	PIITM.MEMBERS$,			\ 2 byte - number of members
2233: 0000: 	PIITM.ELIGIBILITY.FLAG$,	\ 1 byte - eligibility flag
2234: 0000: 	PIITM.LIST.STATUS$,		\ 1 byte - list status :
2235: 0000: 					\    "C" = to be counted,
2236: 0000: 					\    "R" = to be re-counted,
2237: 0000: 					\    "D" = counted,
2238: 0000: 					\    "F" = completed,
2239: 0000: 					\    "X" = cancelled.
2240: 0000: 	PIITM.POTENTIAL.RECOUNT$,	\ 1 byte - potential recount flag :
2241: 0000: 					\    "0" = not a potential re-count,
2242: 0000: 					\    "1" = failed value test,
2243: 0000: 					\    "2" = failed percentage test.
2244: 0000:         PIITM.FILLER$                   ! 5 bytes
2245: 0000: 					
2246: 0000: !%INCLUDE PDTWFDEC.J86                    ! FLC
2247: 0000: !%INCLUDE IRFDEC.J86                      ! FLC TEST
2248: 0000: 
2249: 0000:  %INCLUDE CCUODDEC.J86                    ! GMJK
2250: 0000: 
2251: 0000: \*****************************************************************************
2252: 0000: \*****************************************************************************
2253: 0000: \***
2254: 0000: \***        %INCLUDE FIELD DECLARATIONS AND FILE REFERENCE PARAMETERS
2255: 0000: \***
2256: 0000: \***                   FILE TYPE:  KEYED
2257: 0000: \***
2258: 0000: \***                   REFERENCE:  CCUODDEC.J86
2259: 0000: \***
2260: 0000: \***                 DESCRIPTION:  RETURNS / AUTOMATIC CREDIT CLAIMING
2261: 0000: \***                   FILE OF OPEN/CLOSED UODS
2262: 0000: \***
2263: 0000: \***
2264: 0000: \***    VERSION A : Michael J. Kelsall      13th September 1993
2265: 0000: \***      
2266: 0000: \***    VERSION B : Mark Walker                   18th Jul 2015
2267: 0000: \***    F392 Retail Stock 5
2268: 0000: \***    Added CCUOD.RETRIEVAL.FLAG$ field to allow record to be
2269: 0000: \***    marked as processed.
2270: 0000: \***
2271: 0000: \*****************************************************************************
2272: 0000: \*****************************************************************************
2273: 0000: 
2274: 0000: STRING GLOBAL           \
2275: 0000:    CCUOD.FILE.NAME$,        \
2276: 0000:    CCUOD.UOD.NUM$,      \  7 byte UPD;  Record key
2277: 0000:    CCUOD.STATUS$,       \  1 byte ASC;  "O" = Open,
2278: 0000:                 \           "C" = Closed,
2279: 0000:                 \           "D" = Despatched,       
2280: 0000:                 \           "X" = Cancelled.
2281: 0000:    CCUOD.CREDIT.CLAIM.NUM$, \  4 byte UPD
2282: 0000:                 \  CCUOD.NUM.OF.ITEMS% here (I2)
2283: 0000:    CCUOD.SUPPLY.ROUTE$,     \  1 byte ASC;  "W" = Warehouse,
2284: 0000:                 \           "E" = EPSOM,
2285: 0000:                 \           "O" = Other Directs,
2286: 0000:                 \               "D" = Dispensary.
2287: 0000:    CCUOD.DISP.LOCATION$,    \  1 byte ASC   "M" = MDS, "D" = Dispensary.
2288: 0000:    CCUOD.BC.LETTER$,        \  1 byte ASC    
2289: 0000:    CCUOD.RECALL.NUM$,       \  8 byte ASC
2290: 0000:    CCUOD.AUTHORISATION$,    \ 15 byte ASC
2291: 0000:    CCUOD.SUPPLIER$,     \ 15 byte ASC
2292: 0000:    CCUOD.METHOD.OF.RETURN$, \  1 byte UPD;   1 = Carrier,
2293: 0000:                 \                2 = BIRD,
2294: 0000:                 \        3 = Via D6,
2295: 0000:                 \        4 = Representative.
2296: 0000:    CCUOD.CARRIER$,      \  1 byte UPD;   1 = GPO,
2297: 0000:                 \                2 = Parcelforce,
2298: 0000:                 \        3 = Securicor,
2299: 0000:                 \        4 = Other.
2300: 0000:    CCUOD.BIRD.NUM$,     \  8 byte ASC                   
2301: 0000:    CCUOD.REASON.NUM$,       \  1 byte UPD     (See CSRNS declaration)
2302: 0000:    CCUOD.RECEIVING.STORE$,  \  2 byte UPD    
2303: 0000:    CCUOD.DESTINATION$,      \  1 byte UPD    1 = Business Centre, 
2304: 0000:                 \            2 = MTS,
2305: 0000:                 \        3 = Pharmacy, 
2306: 0000:                 \        4 = Other.
2307: 0000:    CCUOD.WAREHOUSE.ROUTE$,  \  1 byte ASC   "R" = RDC, "C" = CSR.
2308: 0000:    CCUOD.UOD.TYPE$,     \  1 byte UPD    1 = Travel Outer,
2309: 0000:                 \        2 = Town tray,
2310: 0000:                 \        3 = Roll cage,
2311: 0000:                 \                4 = Other.
2312: 0000:    CCUOD.DAMAGE.REASON$,         \  1 byte UPD    1 = Bad packaging,    
2313: 0000:                 \        2 = Poor handling.
2314: 0000:    CCUOD.DATE.UOD.OPENED$,  \  3 byte UPD 
2315: 0000:    CCUOD.DATE.UOD.DESPATCHED$,  \  3 byte UPD
2316: 0000:    CCUOD.TIME.UOD.DESPATCHED$,  \  3 byte UPD
2317: 0000:    CCUOD.RETRIEVAL.FLAG$, \  1 byte ASC;  " " = to be retrieved             !BMW
2318: 0000:                           \               "N" = marked as processed         !BMW
2319: 0000:    CCUOD.FILLER$,       \ 19 byte ASC;   Spaces.
2320: 0000:                 \
2321: 0000:                 \
2322: 0000:                 \
2323: 0000:    CCUOD.HEADER$,       \   Hdr rec layout; (key of High values)
2324: 0000:    CCUOD.DATE.FILE.UPDATED$,    \  3 byte UPD (all 9's if empty file created)
2325: 0000:    CCUOD.TIME.FILE.UPDATED$,    \  3 byte UPD (all 9's if empty file created)
2326: 0000:    CCUOD.LDT.NUM$,      \  3 byte UPD (Zeros if no outstanding data
2327: 0000:                 \              to be processed by PSS35)
2328: 0000:    CCUOD.HEADER.FILLER$     ! 84 byte ASC;  Spaces.
2329: 0000: 
2330: 0000: 
2331: 0000: INTEGER*2 GLOBAL        \
2332: 0000:    CCUOD.RECL%,         \
2333: 0000:    CCUOD.REPORT.NUM%,       \
2334: 0000:    CCUOD.SESS.NUM%,     \
2335: 0000:                 \
2336: 0000:    CCUOD.NUM.OF.ITEMS%      ! 2 byte INT
2337: 0000: 
2338: 0000:  %INCLUDE CCLAMDEC.J86                    ! 1.4
2339: 0000: 
2340: 0000: \*****************************************************************************
2341: 0000: \*****************************************************************************
2342: 0000: \***
2343: 0000: \***        %INCLUDE FIELD DECLARATIONS AND FILE REFERENCE PARAMETERS
2344: 0000: \***
2345: 0000: \***                   FILE TYPE:  KEYED
2346: 0000: \***
2347: 0000: \***                   REFERENCE:  CCLAMDEC.J86
2348: 0000: \***
2349: 0000: \***	             DESCRIPTION:  RETURNS / AUTOMATIC CREDIT CLAIMING
2350: 0000: \***				   FILE OF CURRENT CREDIT CLAIMS
2351: 0000: \***
2352: 0000: \***
2353: 0000: \***      VERSION A : Michael J. Kelsall      16th December 1993
2354: 0000: \***      
2355: 0000: \*****************************************************************************
2356: 0000: \*****************************************************************************
2357: 0000: 
2358: 0000: STRING GLOBAL			\
2359: 0000:    CCLAM.FILE.NAME$,		\
2360: 0000:    CCLAM.CREDIT.CLAIM.NUM$,	\  4 byte UPD;   Record Key
2361: 0000:    CCLAM.UOD.NUM$,		\  7 byte UPD
2362: 0000:    				\  CCLAM.NUM.OF.ITEMS% here (I2)
2363: 0000:    CCLAM.SUPPLY.ROUTE$,		\  1 byte ASC;  "W" = Warehouse,
2364: 0000:    				\ 	        "E" = EPSOM,
2365: 0000: 				\	        "O" = Other Directs,
2366: 0000: 				\               "D" = Dispensary.
2367: 0000:    CCLAM.DISP.LOCATION$,	\  1 byte ASC   "M" = MDS, "D" = Dispensary.
2368: 0000:    CCLAM.BC.LETTER$,		\  1 byte ASC    
2369: 0000:    CCLAM.RECALL.NUM$,		\  8 byte ASC
2370: 0000:    CCLAM.AUTHORISATION$,	\ 15 byte ASC
2371: 0000:    CCLAM.SUPPLIER$,		\ 15 byte ASC
2372: 0000:    CCLAM.METHOD.OF.RETURN$,	\  1 byte UPD;   1 = Carrier,
2373: 0000:    				\                2 = BIRD,
2374: 0000: 				\	 	 3 = Via D6,
2375: 0000: 				\		 4 = Representative.
2376: 0000:    CCLAM.CARRIER$,		\  1 byte UPD;   1 = GPO,
2377: 0000:    				\                2 = Parcelforce,
2378: 0000: 				\	 	 3 = Securicor,
2379: 0000: 				\ 		 4 = Other.
2380: 0000:    CCLAM.BIRD.NUM$,		\  8 byte ASC					
2381: 0000:    CCLAM.REASON.NUM$,		\  1 byte UPD     (See CSRNS declaration)
2382: 0000:    CCLAM.RECEIVING.STORE$,	\  2 byte UPD    
2383: 0000:    CCLAM.DESTINATION$,		\  1 byte UPD    1 = Business Centre, 
2384: 0000:    				\	         2 = MTS,
2385: 0000:    				\		 3 = Pharmacy, 
2386: 0000: 				\		 4 = Other.
2387: 0000:    CCLAM.WAREHOUSE.ROUTE$,	\  1 byte ASC   "R" = RDC, "C" = CSR.
2388: 0000:    CCLAM.UOD.TYPE$,		\  1 byte UPD    1 = Travel Outer,
2389: 0000:    				\		 2 = Town tray,
2390: 0000: 				\		 3 = Roll cage,
2391: 0000: 				\     	         4 = Other.
2392: 0000:    CCLAM.DAMAGE.REASON$,        \  1 byte UPD    1 = Bad packaging,	
2393: 0000:    				\		 2 = Poor handling.
2394: 0000:    CCLAM.INVOICE.NUM$,		\* 9 byte ASC 
2395: 0000:    CCLAM.FOLIO.NUM$,		\  3 byte UPD
2396: 0000:    CCLAM.BATCH.REF$,		\  3 byte UPD
2397: 0000:    CCLAM.WHOLE.PART.CON$,       \  1 byte ASC   "W" = Whole, "P" = Part
2398: 0000:    CCLAM.REPAIR.CATEGORY$, 	\  1 byte UPD;   1 = Plan4,
2399: 0000:    				\   		 2 = Estimate,
2400: 0000: 				\		 3 = Boots guarantee,
2401: 0000: 				\		 4 = Supplier guarantee,
2402: 0000: 				\		 5 = Other guarantee,
2403: 0000:    CCLAM.REPAIR.NUM$,		\  6 byte UPD
2404: 0000:    CCLAM.PLAN4.POLICY.NUM$,	\  6 byte UPD 
2405: 0000:    CCLAM.DDDA.DCDR.NUM$,	\  4 byte UPD
2406: 0000:    CCLAM.DELIV.NOTE.NUM$,	\* 9 byte ASC
2407: 0000:    CCLAM.DELIV.DATE$,		\  3 byte UPD
2408: 0000:    CCLAM.NUM.CARTONS.RECEIV$,	\  1 byte UPD
2409: 0000:    CCLAM.ORDER.NUM$,		\  7 byte ASC
2410: 0000:    CCLAM.COMMENT$,  		\*20 byte ASC
2411: 0000:    CCLAM.DATE.OF.CLAIM$,	\  3 byte UPD;  Date of UOD despatch
2412: 0000:    CCLAM.TIME.OF.CLAIM$,	\  3 byte UPD;  Time of UOD despatch
2413: 0000:    CCLAM.RETRIEVAL.FLAG$,	\  1 byte ASC;  "Y", "N"  PSS35 sets to Y
2414: 0000:    				\                         PSB30 sets to N
2415: 0000:    CCLAM.CF.RPT.MARKER$,	\  1 byte ASC;  "Y"       PSS35 sets to Y
2416: 0000:    				\               "N"       PSS20 sets to N
2417: 0000:    CCLAM.CANC.MARKER$,		\  1 byte ASC;  Y or N
2418: 0000:    CCLAM.FILLER$		!  7 byte ASC;  Spaces.
2419: 0000: 
2420: 0000: 
2421: 0000: INTEGER*2 GLOBAL		\
2422: 0000:    CCLAM.RECL%,			\
2423: 0000:    CCLAM.REPORT.NUM%,		\
2424: 0000:    CCLAM.SESS.NUM%,		\
2425: 0000: 				\
2426: 0000:    CCLAM.NUM.OF.ITEMS%		!  2 byte INT
2427: 0000: 
2428: 0000:  %INCLUDE CCITMDEC.J86                    ! GMJK
2429: 0000: 
2430: 0000: \*****************************************************************************
2431: 0000: \*****************************************************************************
2432: 0000: \***
2433: 0000: \***        %INCLUDE FIELD DECLARATIONS AND FILE REFERENCE PARAMETERS
2434: 0000: \***
2435: 0000: \***                   FILE TYPE:  KEYED
2436: 0000: \***
2437: 0000: \***                   REFERENCE:  CCUODITM.J86
2438: 0000: \***
2439: 0000: \***	             DESCRIPTION:  RETURNS / AUTOMATIC CREDIT CLAIMING
2440: 0000: \***				   FILE OF ITEMS PER OPEN/CLOSED UOD
2441: 0000: \***
2442: 0000: \***
2443: 0000: \***      VERSION A : Michael J. Kelsall      13th September 1993
2444: 0000: \***      
2445: 0000: \*****************************************************************************
2446: 0000: \*****************************************************************************
2447: 0000: 
2448: 0000: STRING GLOBAL			\
2449: 0000:    CCITM.FILE.NAME$,		\
2450: 0000:    CCITM.KEY$,			\  Consists of next two fields;
2451: 0000:    CCITM.UOD.NUM$,		\  7 byte UPD
2452: 0000:    CCITM.ITEM.NUM$,		\  2 byte UPD
2453: 0000:    				\
2454: 0000:    CCITM.BOOTS.BAR.CODE.FLAG$,	\  1 byte ASC;  "I" = Boots code,
2455: 0000:    				\		"B" = Bar code.
2456: 0000:    CCITM.BOOTS.BAR.CODE$,	\  7 byte UPD
2457: 0000:    				\  CCITM.QTY% here (I2)
2458: 0000:    CCITM.FILLER$                !  4 byte ASC;  Spaces
2459: 0000:       				
2460: 0000: 
2461: 0000: INTEGER*2 GLOBAL		\
2462: 0000:    CCITM.RECL%,			\
2463: 0000:    CCITM.REPORT.NUM%,		\
2464: 0000:    CCITM.SESS.NUM%,		\
2465: 0000: 				\
2466: 0000:    CCITM.QTY%			!  2 byte INT
2467: 0000: 
2468: 0000:  %INCLUDE CCTRLDEC.J86                    ! GMJK
2469: 0000: 
2470: 0000: \*****************************************************************************
2471: 0000: \*****************************************************************************
2472: 0000: \***
2473: 0000: \***        %INCLUDE FIELD DECLARATIONS AND FILE REFERENCE PARAMETERS
2474: 0000: \***
2475: 0000: \***                   FILE TYPE:  DIRECT
2476: 0000: \***
2477: 0000: \***                   REFERENCE:  CCTRLDEC.J86
2478: 0000: \***
2479: 0000: \***	             DESCRIPTION:  RETURNS / AUTOMATIC CREDIT CLAIMING
2480: 0000: \***				   CREDIT CLAIMS CONTROL FILE
2481: 0000: \***
2482: 0000: \***
2483: 0000: \***      VERSION A : Michael J. Kelsall      14th September 1993
2484: 0000: \***      
2485: 0000: \*****************************************************************************
2486: 0000: \*****************************************************************************
2487: 0000: 
2488: 0000: STRING GLOBAL			\
2489: 0000:    CCTRL.FILE.NAME$,		\
2490: 0000:    CCTRL.RECORD$,		\
2491: 0000:    CCTRL.CREDIT.CLAIM.NUM$,	\  4 byte UPD
2492: 0000:    CCTRL.CREDIT.RPT.RUN.DATE$,	\  3 byte UPD
2493: 0000:    CCTRL.UOD.RPT.RUN.DATE$,	\  3 byte UPD
2494: 0000:    CCTRL.FILLER$		! 65 byte ASC;  Spaces
2495: 0000:    
2496: 0000: 
2497: 0000: INTEGER*2 GLOBAL		\
2498: 0000:    CCTRL.RECL%,			\
2499: 0000:    CCTRL.REPORT.NUM%,		\
2500: 0000:    CCTRL.SESS.NUM%,		\
2501: 0000:    CCTRL.REC.NUM%
2502: 0000: 
2503: 0000: INTEGER*4 GLOBAL		\
2504: 0000:    CCTRL.STAFF.SALES%		!  4 INT, total sales to store staff,
2505: 0000:    				!  stored as 5 byte UPD on file
2506: 0000: 
2507: 0000:  %INCLUDE CCTMPDEC.J86                    ! GMJK
2508: 0000: REM \
2509: 0000: \******************************************************************************
2510: 0000: \******************************************************************************
2511: 0000: \***
2512: 0000: \***      %INCLUDE FOR CREDIT CLAIMING TEMPORARY FILE FIELD DECLARATIONS
2513: 0000: \***                                             FILE REFERENCE PARAMETERS
2514: 0000: \***
2515: 0000: \***               FILE TYPE    : Sequential
2516: 0000: \***
2517: 0000: \***               REFERENCE    : CCTMPDEC.J86
2518: 0000: \***
2519: 0000: \***      Version A.     Michael J. Kelsall           30th September 1993.
2520: 0000: \***
2521: 0000: \***      Version 1.1    Brian Greenfield             14th May 2007
2522: 0000: \***      Added new variable CCTMP.RECALL.TYPE$ for A7C Recalls.
2523: 0000: \***
2524: 0000: \******************************************************************************
2525: 0000: \*******************************************************************************
2526: 0000: \***
2527: 0000: \***  The length of the records on this file vary depending on the record
2528: 0000: \***  transaction type, but they all comprise combinations of the fields
2529: 0000: \***  defined below.
2530: 0000: \***
2531: 0000: \***  RETURNS/AUTOMATIC CREDIT CLAIMING RECORD TYPES;
2532: 0000: \***
2533: 0000: \***  Transaction type 24 - Whole or Part consignment record
2534: 0000: \***     RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, CREDIT CLAIM NUM, 
2535: 0000: \***     BC LETTER, CLAIM TYPE, SUPPLIER NUM, INVOICE NUM, FOLIO NUM, 
2536: 0000: \***     BATCH REF NUM, REPAIR CATEGORY, REPAIR NUM, PLAN4 POLICY NUM, 
2537: 0000: \***     DDDA/DCDR NUM, DELIV NOTE NUM, DELIV DATE, NUM OF CARTONS, ORDER NUM,
2538: 0000: \***     NUM OF ITEMS, ITEM/BAR CODE FLAG, BOOTS/BAR CODE, QTY, PRICE, 
2539: 0000: \***     RECORD DELIMITER, END OF RECORD MARKER
2540: 0000: \***     (ITEM/BAR CODE FLAG to PRICE repeated NUM OF ITEMS times)
2541: 0000: \***
2542: 0000: \***  Transaction type 26 - Data from LDT
2543: 0000: \***     RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, UOD NUM, UOD STATUS, 
2544: 0000: \***     CREDIT CLAIM NUM, NUM OF ITEMS UPDATED, TOTAL QTY IN UOD, 
2545: 0000: \***     ADJUST STOCK FIGURE FLAG, SUPPLY ROUTE, DISP LOCATION, BC LETTER, 
2546: 0000: \***     RECALL NUM, AUTHORISATION, SUPPLIER, RETURN METHOD, CARRIER, BIRD NUM,
2547: 0000: \***     REASON, WAREHOUSE ROUTE, UOD TYPE, REASON FOR DAMAGE, RECEIVING STORE,
2548: 0000: \***     DESTINATION, DATE UOD OPENED, DATE UOD DESPATCHED, TIME UOD 
2549: 0000: \***     DESPATCHED, RECALL.TYPE$, ITEM.BAR CODE FLAG, BOOTS/BAR CODE, QTY,       ! 1.1BG
2550: 0000: \***     ITEM UPDATED FLAG, RECORD DELIMITER, END OF RECORD MARKER
2551: 0000: \***     (ITEM/BAR CODE FLAG to ITEM UPDATED FLAG repeated NUM OF ITEMS times)
2552: 0000: \***
2553: 0000: \***  Transaction type 28 - Cancelled Credit Claim
2554: 0000: \***     RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, CLAIM NUMBER, UOD
2555: 0000: \***     NUM, NEW STATUS FLAG, RECORD DELIMITER, END OF RECORD MARKER
2556: 0000: \***
2557: 0000: \******************************************************************************
2558: 0000: 
2559: 0000:   STRING GLOBAL              \
2560: 0000:     CCTMP.FILE.NAME$,        \
2561: 0000:     CCTMP.RECORD$,           \ Used to store the whole record which is unstrung
2562: 0000:                              \ into the fields below
2563: 0000:     CCTMP.RECORD.DELIMITER$, \ 1 byte ASCII set to " (CHR$(34)) 
2564: 0000:     CCTMP.TRANS.TYPE$,       \ 1 byte UPD. 24 = Whole/Part consignment (R/ACC)
2565: 0000:                  \             25 = NS16 / Misc cont txn (R/ACC)
2566: 0000:                  \             26 = Data from LDT (R/ACC)
2567: 0000:                  \             27 = End of LDT session (R/ACC)
2568: 0000:                  \         28 = Canc. Credit Claim (R/ACC)
2569: 0000:     CCTMP.FIELD.DELIMITER$,  \ 1 byte ASCII set to ; (CHR$(59))
2570: 0000:     CCTMP.ENDREC.MARKER$,    \ 2 bytes ASCII set to 0D0AH
2571: 0000:     CCTMP.BC.LETTER$,        \ 1 byte ASCII
2572: 0000:     CCTMP.CREDIT.CLAIM.NUM$, \ 4 byte UPD
2573: 0000:     CCTMP.NUM.ITEMS.UPDATED$,\ 4 byte ASCII
2574: 0000:     CCTMP.TOTAL.QTY.IN.UOD$, \ 4 byte ASCII
2575: 0000:     CCTMP.CLAIM.TYPE$,       \ 1 byte ASC;  "M" = Missing,
2576: 0000:                      \          "E" = Excess,
2577: 0000:                  \              "R" = Repairs
2578: 0000:     CCTMP.SUPPLIER.NUM$,     \ 3 byte UPD
2579: 0000:     CCTMP.INVOICE.NUM$,      \ 3 byte UPD 
2580: 0000:     CCTMP.FOLIO.NUM$,        \ 3 byte UPD
2581: 0000:     CCTMP.BATCH.REF$,        \ 3 byte UPD
2582: 0000:     CCTMP.REPAIR.CATEGORY$,  \ 1 byte UPD;   1 = Plan4,
2583: 0000:                  \           2 = Estimate,
2584: 0000:                  \           3 = Boots guarantee,
2585: 0000:                  \           4 = Supplier guarantee,
2586: 0000:                  \           5 = Other guarantee,
2587: 0000:     CCTMP.REPAIR.NUM$,       \ 4 byte UPD
2588: 0000:     CCTMP.PLAN4.POLICY.NUM$, \ 6 byte UPD; (Only if repair cat is Plan4)
2589: 0000:     CCTMP.DDDA.DCDR.NUM$,    \ 3 byte UPD
2590: 0000:     CCTMP.DELIV.NOTE.NUM$,   \ 3 byte UPD
2591: 0000:     CCTMP.NUM.CARTONS.RECEIV$,\1 byte UPD
2592: 0000:     CCTMP.ORDER.NUM$,        \ 3 byte UPD
2593: 0000:     CCTMP.ITEM.BARCODE.FLAG$,\ 1 byte ASC;  "I" = Boots item code,
2594: 0000:                  \              "B" = Barcode.
2595: 0000:     CCTMP.ITEM.BARCODE$,     \ 7 byte UPD
2596: 0000:     CCTMP.ITEM.PRICE$,       \ 3 byte UPD;  Spaces.
2597: 0000:     CCTMP.AUTHORISATION$,    \ 15 byte ASC
2598: 0000:     CCTMP.ADJ.STOCK.FIGURE$, \ 1 byte ASC  "Y" or "N"
2599: 0000:     CCTMP.RETURN.REASON$,    \ 1 byte UPD;  (See CCRSN file)
2600: 0000:     CCTMP.UOD.NUM$,      \ 7 byte UPD
2601: 0000:     CCTMP.UOD.STATUS$,       \ 1 byte ASC;  "O" = Open,
2602: 0000:                      \              "C" = Closed,
2603: 0000:                  \              "D" = Despatched
2604: 0000:     CCTMP.PREVIOUS.STATUS$,  \ 1 byte ASC   "O" = Open,
2605: 0000:                      \              "C" = Closed
2606: 0000:     CCTMP.SUPPLY.ROUTE$,     \ 1 byte ASC
2607: 0000:     CCTMP.DISP.LOCATION$,    \ 1 byte ASC   "M" = MDS,
2608: 0000:                      \              "D" = Dispensary
2609: 0000:     CCTMP.RECALL.NUM$,       \ 9 byte ASC 
2610: 0000:     CCTMP.SUPPLIER$,         \ 15 byte ASC
2611: 0000:     CCTMP.RETURN.METHOD$,    \ 1 byte UPD;   1 = Carrier,
2612: 0000:                      \           2 = BIRD,
2613: 0000:                  \               3 = Via D6,
2614: 0000:                  \               4 = Representative
2615: 0000:     CCTMP.CARRIER$,      \ 1 byte UPD;   1 = GPO,
2616: 0000:                      \               2 = Parcelforce,
2617: 0000:                  \               3 = Securicor,
2618: 0000:                  \               4 = Other
2619: 0000:     CCTMP.BIRD.NUM$,         \ 8 byte ASC
2620: 0000:     CCTMP.WAREHOUSE.ROUTE$,  \ 1 byte ASC   "R" = RDC,
2621: 0000:                      \          "C" = CSR
2622: 0000:     CCTMP.UOD.TYPE$,         \ 1 byte UPD;   1 = Travel Outer,
2623: 0000:                      \               2 = Town Tray,
2624: 0000:                  \               3 = Roll cage,
2625: 0000:                  \               4 = Other
2626: 0000:     CCTMP.DAMAGE.REASON$,    \ 1 byte UPD    1 = Bad packaging,
2627: 0000:                      \               2 = Poor handling
2628: 0000:     CCTMP.RECEIVING.STORE$,  \ 2 byte UPD
2629: 0000:     CCTMP.DESTINATION$,      \ 1 byte UPD    1 = Business Centre,
2630: 0000:                      \               2 = MTS,
2631: 0000:                  \               3 = Other
2632: 0000:     CCTMP.DATE.UOD.OPENED$,  \ 3 byte UPD
2633: 0000:     CCTMP.DATE.DESPATCHED$,  \ 3 byte UPD
2634: 0000:     CCTMP.TIME.DESPATCHED$,  \ 3 byte UPD
2635: 0000:     CCTMP.ITEM.UPDATED$,     \ 1 byte ASC
2636: 0000:     CCTMP.NEW.STATUS.FLAG$,  \ 1 byte ASC   "C" = Closed,
2637: 0000:                      \          "D" = Despatched,
2638: 0000:                  \          "X" = Cancelled
2639: 0000:     CCTMP.ITEM.QTY$,         \ 3 byte ASCII              
2640: 0000:     CCTMP.RECALL.TYPE$       ! 1 byte ASCII "B" = Batch Recall              ! 1.1BG
2641: 0000:                              !              "N" = Non-batch Recall          ! 1.1BG
2642: 0000:                              !              " " = Old Credit Claim          ! 1.1BG
2643: 0000:     
2644: 0000:                                                  
2645: 0000:   INTEGER*2 GLOBAL           \
2646: 0000:     CCTMP.SESS.NUM%,         \
2647: 0000:     CCTMP.REPORT.NUM%,       \
2648: 0000:                      \
2649: 0000:     CCTMP.NUM.OF.ITEMS%,     \
2650: 0000:     CCTMP.NUM.ITEMS.UPDATED%,\ 
2651: 0000:     CCTMP.TOTAL.QTY.IN.UOD%  !
2652: 0000:                          
2653: 0000:                  
2654: 0000:  %INCLUDE CCBUFDEC.J86                    ! GMJK
2655: 0000: REM \
2656: 0000: \******************************************************************************
2657: 0000: \******************************************************************************
2658: 0000: \***
2659: 0000: \***      %INCLUDE FOR CREDIT CLAIMING BUFFER FILE FIELD DECLARATIONS
2660: 0000: \***                                          FILE REFERENCE PARAMETERS
2661: 0000: \***
2662: 0000: \***               FILE TYPE    : Sequential
2663: 0000: \***
2664: 0000: \***               REFERENCE    : CCBUFDEC.J86
2665: 0000: \***
2666: 0000: \***      Version A.     Michael J. Kelsall           30th September 1993.
2667: 0000: \***
2668: 0000: \******************************************************************************
2669: 0000: \*******************************************************************************
2670: 0000: \***
2671: 0000: \***  The length of the records on this file vary depending on the record
2672: 0000: \***  transaction type, but they all comprise combinations of the fields
2673: 0000: \***  defined below.
2674: 0000: \***
2675: 0000: \***  RETURNS/AUTOMATIC CREDIT CLAIMING RECORD TYPES;
2676: 0000: \***
2677: 0000: \***  Transaction type 24 - Whole or Part consignment record
2678: 0000: \***     RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, CREDIT CLAIM NUM, 
2679: 0000: \***     BC LETTER, CLAIM TYPE, SUPPLIER NUM, INVOICE NUM, FOLIO NUM, 
2680: 0000: \***     BATCH REF NUM, REPAIR CATEGORY, REPAIR NUM, PLAN4 POLICY NUM, 
2681: 0000: \***     DDDA/DCDR NUM, DELIV NOTE NUM, DELIV DATE, NUM OF CARTONS, ORDER NUM,
2682: 0000: \***     NUM OF ITEMS, ITEM/BAR CODE FLAG, BOOTS/BAR CODE, QTY, PRICE, 
2683: 0000: \***     RECORD DELIMITER, END OF RECORD MARKER
2684: 0000: \***     (ITEM/BAR CODE FLAG to PRICE repeated NUM OF ITEMS times)
2685: 0000: \***
2686: 0000: \***  Transaction type 26 - Data from LDT
2687: 0000: \***     RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, UOD NUM, UOD STATUS, 
2688: 0000: \***     CREDIT CLAIM NUM, NUM OF ITEMS UPDATED, TOTAL QTY IN UOD, 
2689: 0000: \***     ADJUST STOCK FIGURE FLAG, SUPPLY ROUTE, DISP LOCATION, BC LETTER, 
2690: 0000: \***     RECALL NUM, AUTHORISATION, SUPPLIER, RETURN METHOD, CARRIER, BIRD NUM,
2691: 0000: \***     REASON, WAREHOUSE ROUTE, UOD TYPE, REASON FOR DAMAGE, RECEIVING STORE,
2692: 0000: \***     DESTINATION, DATE UOD OPENED, DATE UOD DESPATCHED, TIME UOD 
2693: 0000: \***     DESPATCHED, ITEM.BAR CODE FLAG, BOOTS/BAR CODE, QTY, ITEM UPDATED 
2694: 0000: \***     FLAG, RECORD DELIMITER, END OF RECORD MARKER
2695: 0000: \***     (ITEM/BAR CODE FLAG to ITEM UPDATED FLAG repeated NUM OF ITEMS times)
2696: 0000: \***
2697: 0000: \***  Transaction type 28 - Cancelled Credit Claim
2698: 0000: \***     RECORD DELIMITER, TRANS TYPE, FIELD DELIMITER, CLAIM NUMBER, UOD
2699: 0000: \***     NUM, NEW STATUS FLAG, RECORD DELIMITER, END OF RECORD MARKER
2700: 0000: \***
2701: 0000: \******************************************************************************
2702: 0000: 
2703: 0000:   STRING GLOBAL              \
2704: 0000:     CCBUF.FILE.NAME$,        \
2705: 0000:     CCBUF.RECORD$,           \ Used to store the whole record which is unstrung
2706: 0000:                              \ into the fields below
2707: 0000:     CCBUF.RECORD.DELIMITER$, \ 1 byte ASCII set to " (CHR$(34)) 
2708: 0000:     CCBUF.TRANS.TYPE$,       \ 1 byte UPD. 24 = Whole/Part consignment (R/ACC)
2709: 0000: 			     \             25 = NS16 / Misc cont txn (R/ACC)
2710: 0000: 			     \	           26 = Data from LDT (R/ACC)
2711: 0000: 			     \             27 = End of LDT session (R/ACC)
2712: 0000: 			     \		   28 = Canc. Credit Claim (R/ACC)
2713: 0000:     CCBUF.FIELD.DELIMITER$,  \ 1 byte ASCII set to ; (CHR$(59))
2714: 0000:     CCBUF.ENDREC.MARKER$,    \ 2 bytes ASCII set to XODOA
2715: 0000:     CCBUF.BC.LETTER$,        \ 1 byte ASCII
2716: 0000:     CCBUF.CREDIT.CLAIM.NUM$, \ 4 byte UPD
2717: 0000:     CCBUF.CLAIM.TYPE$,	     \ 1 byte ASC;  "M" = Missing,
2718: 0000:     			     \		    "E" = Excess,
2719: 0000: 			     \              "R" = Repairs
2720: 0000:     CCBUF.SUPPLIER.NUM$,     \ 3 byte UPD
2721: 0000:     CCBUF.INVOICE.NUM$,	     \ 3 byte UPD 
2722: 0000:     CCBUF.FOLIO.NUM$,	     \ 3 byte UPD
2723: 0000:     CCBUF.BATCH.REF$,	     \ 3 byte UPD
2724: 0000:     CCBUF.REPAIR.CATEGORY$,  \ 1 byte UPD;   1 = Plan4,
2725: 0000:    			     \ 		     2 = Estimate,
2726: 0000: 			     \		     3 = Boots guarantee,
2727: 0000: 			     \		     4 = Supplier guarantee,
2728: 0000: 			     \		     5 = Other guarantee,
2729: 0000:     CCBUF.REPAIR.NUM$,       \ 4 byte UPD
2730: 0000:     CCBUF.PLAN4.POLICY.NUM$, \ 6 byte UPD; (Only if repair cat is Plan4)
2731: 0000:     CCBUF.DDDA.DCDR.NUM$,    \ 3 byte UPD
2732: 0000:     CCBUF.DELIV.NOTE.NUM$,   \ 3 byte UPD
2733: 0000:     CCBUF.NUM.CARTONS.RECEIV$,\1 byte UPD
2734: 0000:     CCBUF.ORDER.NUM$,	     \ 3 byte UPD
2735: 0000:     CCBUF.ITEM.BARCODE.FLAG$,\ 1 byte ASC;  "I" = Boots item code,
2736: 0000:   			     \              "B" = Barcode.
2737: 0000:     CCBUF.ITEM.BARCODE$,     \ 7 byte UPD
2738: 0000:     CCBUF.ITEM.PRICE$,	     \ 3 byte UPD;  Spaces.
2739: 0000:     CCBUF.AUTHORISATION$,    \ 15 byte ASC
2740: 0000:     CCBUF.ADJ.STOCK.FIGURE$, \ 1 byte ASC;  "Y" or "N"
2741: 0000:     CCBUF.RETURN.REASON$,    \ 1 byte UPD;  (See CCRSN file)
2742: 0000:     CCBUF.UOD.NUM$,	     \ 7 byte UPD
2743: 0000:     CCBUF.UOD.STATUS$,	     \ 1 byte ASC;  "O" = Open,
2744: 0000:     			     \              "C" = Closed,
2745: 0000: 			     \              "D" = Despatched
2746: 0000:     CCBUF.SUPPLY.ROUTE$,     \ 1 byte ASC
2747: 0000:     CCBUF.DISP.LOCATION$,    \ 1 byte ASC   "M" = MDS,
2748: 0000:     			     \              "D" = Dispensary
2749: 0000:     CCBUF.RECALL.NUM$,       \ 9 byte ASC 
2750: 0000:     CCBUF.SUPPLIER$,	     \ 15 byte ASC
2751: 0000:     CCBUF.RETURN.METHOD$,    \ 1 byte UPD;   1 = Carrier,
2752: 0000:     			     \		     2 = BIRD,
2753: 0000: 			     \               3 = Via D6,
2754: 0000: 			     \               4 = Representative
2755: 0000:     CCBUF.CARRIER$,	     \ 1 byte UPD;   1 = GPO,
2756: 0000:     			     \               2 = Parcelforce,
2757: 0000: 			     \               3 = Securicor,
2758: 0000: 			     \               4 = Other
2759: 0000:     CCBUF.BIRD.NUM$,	     \ 8 byte ASC
2760: 0000:     CCBUF.WAREHOUSE.ROUTE$,  \ 1 byte ASC   "R" = RDC,
2761: 0000:     			     \  	    "C" = CSR
2762: 0000:     CCBUF.UOD.TYPE$,         \ 1 byte UPD;   1 = Travel Outer,
2763: 0000:     			     \               2 = Town Tray,
2764: 0000: 			     \               3 = Roll cage,
2765: 0000: 			     \               4 = Other
2766: 0000:     CCBUF.DAMAGE.REASON$,    \ 1 byte UPD    1 = Bad packaging,
2767: 0000:      			     \               2 = Poor handling
2768: 0000:     CCBUF.RECEIVING.STORE$,  \ 2 byte UPD
2769: 0000:     CCBUF.DESTINATION$,      \ 1 byte UPD    1 = Business Centre,
2770: 0000:     			     \               2 = MTS,
2771: 0000: 			     \               3 = Other
2772: 0000:     CCBUF.DATE.UOD.OPENED$,  \ 3 byte UPD
2773: 0000:     CCBUF.DATE.DESPATCHED$,  \ 3 byte UPD
2774: 0000:     CCBUF.TIME.DESPATCHED$,  \ 3 byte UPD
2775: 0000:     CCBUF.ITEM.UPDATED$,     \ 1 byte ASC
2776: 0000:     CCBUF.NEW.STATUS.FLAG$   \ 1 byte ASC   "C" = Closed,
2777: 0000:     			     \   	    "D" = Despatched,
2778: 0000: 			     !    	    "X" = Cancelled
2779: 0000:     
2780: 0000: 			     			     			     
2781: 0000:   INTEGER*2 GLOBAL           \
2782: 0000:     CCBUF.SESS.NUM%,         \
2783: 0000:     CCBUF.REPORT.NUM%,	     \
2784: 0000:     			     \
2785: 0000:     CCBUF.NUM.OF.ITEMS%,     \
2786: 0000:     CCBUF.NUM.ITEMS.UPDATED%,\
2787: 0000:     CCBUF.QTY%,		     \
2788: 0000:     CCBUF.TOTAL.QTY.IN.UOD%  !
2789: 0000:         			     
2790: 0000: 			     
2791: 0000:  %INCLUDE CCUPFDEC.J86                    ! HMJK
2792: 0000: 
2793: 0000: \*****************************************************************************
2794: 0000: \*****************************************************************************
2795: 0000: \***
2796: 0000: \***        %INCLUDE FIELD DECLARATIONS AND FILE REFERENCE PARAMETERS
2797: 0000: \***
2798: 0000: \***                   FILE TYPE:  KEYED
2799: 0000: \***
2800: 0000: \***                   REFERENCE:  CCUPFDEC.J86
2801: 0000: \***
2802: 0000: \***	             DESCRIPTION:  RETURNS / AUTOMATIC CREDIT CLAIMING
2803: 0000: \***				   UOD PROCESSED FILE
2804: 0000: \***
2805: 0000: \***
2806: 0000: \***      VERSION A : Michael J. Kelsall      14th March 1994
2807: 0000: \***      
2808: 0000: \*****************************************************************************
2809: 0000: \*****************************************************************************
2810: 0000: 
2811: 0000: STRING GLOBAL			\
2812: 0000:    CCUPF.FILE.NAME$,		\
2813: 0000:    CCUPF.UOD.NUM$,		\  7 byte UPD
2814: 0000:    CCUPF.CURRENT.STATUS$	!  1 byte ASC;  "C" = Closed,
2815: 0000:    				!               "D" - Despatched,
2816: 0000:    				!               "X" - Cancelled.
2817: 0000:       				
2818: 0000: 
2819: 0000: INTEGER*2 GLOBAL		\
2820: 0000:    CCUPF.RECL%,			\
2821: 0000:    CCUPF.REPORT.NUM%,		\
2822: 0000:    CCUPF.SESS.NUM%
2823: 0000: 
2824: 0000:  %INCLUDE CCWKFDEC.J86                    ! GMJK
2825: 0000: \******************************************************************************
2826: 0000: \******************************************************************************
2827: 0000: \***
2828: 0000: \***      %INCLUDE FOR RETURNS WORK FILE - FIELD DEFINITIONS
2829: 0000: \***                                       FILE REFERENCE PARAMETERS
2830: 0000: \***
2831: 0000: \***                  REFERENCE: CCWKFDEC.J86
2832: 0000: \***
2833: 0000: \***  Version A          Michael J. Kelsall              30th September 1993
2834: 0000: \***
2835: 0000: \******************************************************************************
2836: 0000: \*******************************************************************************
2837: 0000: 
2838: 0000:   STRING GLOBAL								\
2839: 0000: 	CCWKF.FILE.NAME$,						\
2840: 0000: 	CCWKF.RECORD$
2841: 0000: 
2842: 0000:   INTEGER*2 GLOBAL							\
2843: 0000: 	CCWKF.RECL%,	          					\
2844: 0000: 	CCWKF.SESS.NUM%,						\
2845: 0000: 	CCWKF.REPORT.NUM%
2846: 0000:  %INCLUDE CCDMYDEC.J86                    ! GMJK
2847: 0000: \******************************************************************************
2848: 0000: \******************************************************************************
2849: 0000: \***
2850: 0000: \***         %INCLUDE FOR RETURNS DUMMY FILE I/O SESSION NUMBER
2851: 0000: \***
2852: 0000: \***               REFERENCE    : CCDMYDEC.J86
2853: 0000: \***
2854: 0000: \***    Version A           Michael J. Kelsall          30th September 1993
2855: 0000: \***
2856: 0000: \******************************************************************************
2857: 0000: \*******************************************************************************
2858: 0000: 
2859: 0000:   STRING GLOBAL           \
2860: 0000:     CCDMY.FILE.NAME$
2861: 0000: 
2862: 0000:   INTEGER*2 GLOBAL        \
2863: 0000:     CCDMY.REPORT.NUM%,    \
2864: 0000:     CCDMY.SESS.NUM%
2865: 0000:  %INCLUDE LDTAFDEC.J86                    ! HMJK
2866: 0000: 
2867: 0000: \*****************************************************************************
2868: 0000: \*****************************************************************************
2869: 0000: \***
2870: 0000: \***        %INCLUDE FIELD DECLARATIONS AND FILE REFERENCE PARAMETERS
2871: 0000: \***
2872: 0000: \***                   FILE TYPE:  DIRECT
2873: 0000: \***
2874: 0000: \***                   REFERENCE:  LDTAFDEC.J86
2875: 0000: \***
2876: 0000: \***	             DESCRIPTION:  LDT / PDT SUPPORT LINK AUDIT FILE
2877: 0000: \***
2878: 0000: \***
2879: 0000: \***      VERSION A         Michael J. Kelsall       30th September 1993
2880: 0000: \***
2881: 0000: \***      VERSION B         Michael J. Kelsall       25th March 1994
2882: 0000: \***      Conversion of LDTAF link duration from minutes to seconds, requiring
2883: 0000: \***      4 byte integer to hold times >09:06:07 (= 32767 seconds)
2884: 0000: \***      
2885: 0000: \*****************************************************************************
2886: 0000: \*****************************************************************************
2887: 0000: 
2888: 0000:   STRING GLOBAL                 \
2889: 0000:     LDTAF.FILE.NAME$,		\
2890: 0000:     LDTAF.START.DATE$,		\ 3 byte UPD  (YYMMDD)
2891: 0000:     LDTAF.START.TIME$		! 3 byte UPD  (HHMMSS)
2892: 0000:     
2893: 0000: 
2894: 0000:   INTEGER*1 GLOBAL              \
2895: 0000:     LDTAF.LINK.TYPE%		!  1 - CSR file    (CSRWF size / num of UNITS)
2896: 0000: 				!  2 - PCHECK      (CHKBF size / null)
2897: 0000: 				!  3 - LDT PROG    (LDTPF size / null)
2898: 0000: 				!  4 - DIRECTS     (DRSMQ size / DIRWF size)
2899: 0000: 				!  5 - UOD         (UODTF size / null)
2900: 0000: 				!  6 - EPSOM req   (PDTWF size / null)
2901: 0000: 				!  7 - EPSOM lists (num of lists / null)
2902: 0000: 				!  8 - RETURNS UOD (CCTMP size / CCBUF size)
2903: 0000: 				!  9 - RETURNS req (CCWKF size / null)
2904: 0000: 				!  MSB ---> 0 = Port A , 1 = Port B. 
2905: 0000: 
2906: 0000:   INTEGER*2 GLOBAL              \
2907: 0000:     LDTAF.SESS.NUM%,            \
2908: 0000:     LDTAF.REPORT.NUM%,		\
2909: 0000:     LDTAF.RECL%
2910: 0000:     				
2911: 0000: 
2912: 0000:   INTEGER*4 GLOBAL              \
2913: 0000:     LDTAF.DATA.VOLUME.1%,	\
2914: 0000:     LDTAF.DATA.VOLUME.2%,	\
2915: 0000:     LDTAF.DURATION%    		! BMJK
2916: 0000:  %INCLUDE SOFTSDEC.J86                    ! GMJK
2917: 0000: REM \
2918: 0000: \******************************************************************************
2919: 0000: \******************************************************************************
2920: 0000: \***
2921: 0000: \***                 %INCLUDE FOR THE SOFTWARE STATUS FILE
2922: 0000: \***   
2923: 0000: \***                      FILE TYPE  :   Direct
2924: 0000: \***
2925: 0000: \***                      REFERENCE  :   SOFTSDEC.J86
2926: 0000: \***
2927: 0000: \***	Version A	       Andrew Wedgeworth	      24th June 1992
2928: 0000: \***
2929: 0000: \******************************************************************************
2930: 0000: \*******************************************************************************
2931: 0000: 
2932: 0000:   STRING GLOBAL           \
2933: 0000:     SOFTS.RECORD$,        \           
2934: 0000:     SOFTS.SPACE$,         \           
2935: 0000:     SOFTS.FILE.NAME$    
2936: 0000:     
2937: 0000:   INTEGER*2 GLOBAL        \
2938: 0000:     SOFTS.RECL%,          \            
2939: 0000:     SOFTS.REPORT.NUM%,	  \      
2940: 0000:     SOFTS.SESS.NUM%
2941: 0000: 
2942: 0000:   INTEGER*4 GLOBAL        \
2943: 0000:     SOFTS.REC.NUM% 	         
2944: 0000:  %INCLUDE STKBFDEC.J86                    ! 1.5
2945: 0000: \******************************************************************************
2946: 0000: \******************************************************************************
2947: 0000: \***
2948: 0000: \***   $Workfile:   STKBFDEC.J86  $
2949: 0000: \***
2950: 0000: \***   $Revision:   1.0  $
2951: 0000: \***
2952: 0000: \******************************************************************************
2953: 0000: \******************************************************************************
2954: 0000: \***
2955: 0000: \***   $Log:   V:\archive\j86\stkbfdec.j8v  $
2956: 0000: \***   
2957: 0000: \***      Rev 1.0   15 Jul 1997 14:20:36   DEV45PS
2958: 0000: \***    
2959: 0000: \***   
2960: 0000: \***      Rev 1.0   09 Jul 1997 11:04:52   DEV45PS
2961: 0000: \***   Stocktake System New Files
2962: 0000: \***   
2963: 0000: \******************************************************************************
2964: 0000: \******************************************************************************\******************************************************************************
2965: 0000: \******************************************************************************
2966: 0000: \***
2967: 0000: \***         %INCLUDE FOR STOCKTAKE BUFFER FILE FIELD DECLARATIONS
2968: 0000: \***
2969: 0000: \***               FILE TYPE    : DIRECT
2970: 0000: \***
2971: 0000: \***               REFERENCE    : STKBFDEC.J86
2972: 0000: \***
2973: 0000: \***    VERSION A.              Nik Sen.               19 Jun 1997.
2974: 0000: \***    New file for stocktaking system. Holds counts read from PDT.
2975: 0000: \***
2976: 0000: \*******************************************************************************
2977: 0000: \*******************************************************************************
2978: 0000: 
2979: 0000: STRING GLOBAL                                                  \
2980: 0000:    STKBF.FILE.NAME$,           \
2981: 0000:    STKBF.DATA$,                \
2982: 0000:    STKBF.STORE.NUMBER$,        \
2983: 0000:    STKBF.STOCKTAKER.NO$,       \
2984: 0000:    STKBF.DATE$,                \
2985: 0000:    STKBF.LOCATION$,            \
2986: 0000:    STKBF.ITEM.CODE$,           \
2987: 0000:    STKBF.QUANTITY$,            \
2988: 0000:    STKBF.PRICE$,               \
2989: 0000:    STKBF.RECORD.COUNT$,        \
2990: 0000:    STKBF.FILLER$
2991: 0000: 
2992: 0000: 
2993: 0000: INTEGER*4 GLOBAL               \
2994: 0000:    STKBF.RECORD.NUM%
2995: 0000: 
2996: 0000: INTEGER*2 GLOBAL                \
2997: 0000:    STKBF.REPORT.NUM%,           \
2998: 0000:    STKBF.SESS.NUM%             
2999: 0000: 
3000: 0000: 
3001: 0000: INTEGER*1 GLOBAL                \
3002: 0000:    STKBF.RECL%         
3003: 0000: 
3004: 0000: 
3005: 0000:  %INCLUDE SXTMPDEC.J86                    ! 1.5
3006: 0000: \******************************************************************************
3007: 0000: \******************************************************************************
3008: 0000: \***
3009: 0000: \***         %INCLUDE FOR TEMPORARY STOCKTAKE BUFFER FILE FIELD DECLARATIONS
3010: 0000: \***
3011: 0000: \***               FILE TYPE    : DIRECT
3012: 0000: \***
3013: 0000: \***               REFERENCE    : SXTMPDEC.J86
3014: 0000: \***
3015: 0000: \***    VERSION A.              Nik Sen.               30 Jun 1997.
3016: 0000: \***    New file for stocktaking system. Holds counts read from PDT.
3017: 0000: \***
3018: 0000: \***    VERSION B              Nik Sen                 23 September 1997
3019: 0000: \***    Removed record count as file converted from direct to sequential.
3020: 0000: \***
3021: 0000: \*******************************************************************************
3022: 0000: \*******************************************************************************
3023: 0000: 
3024: 0000: STRING GLOBAL                                                  \
3025: 0000:    SXTMP.FILE.NAME$,           \
3026: 0000:    SXTMP.DATA$,                \
3027: 0000:    SXTMP.STORE.NUMBER$,        \
3028: 0000:    SXTMP.STOCKTAKER.NO$,       \
3029: 0000:    SXTMP.DATE$,                \
3030: 0000:    SXTMP.LOCATION$,            \
3031: 0000:    SXTMP.ITEM.CODE$,           \
3032: 0000:    SXTMP.QUANTITY$,            \
3033: 0000:    SXTMP.PRICE$,               \
3034: 0000:    SXTMP.RECORD.COUNT$,        \
3035: 0000:    SXTMP.FILLER$
3036: 0000: 
3037: 0000: 
3038: 0000: INTEGER*2 GLOBAL                \
3039: 0000:    SXTMP.REPORT.NUM%,           \
3040: 0000:    SXTMP.SESS.NUM%             
3041: 0000: 
3042: 0000: 
3043: 0000: INTEGER*1 GLOBAL                \
3044: 0000:    SXTMP.RECL%         
3045: 0000: 
3046: 0000: 
3047: 0000:  %INCLUDE STKTKDEC.J86                    ! 1.5
3048: 0000: REM \
3049: 0000: \******************************************************************************
3050: 0000: \******************************************************************************
3051: 0000: \***
3052: 0000: \***         %INCLUDE FOR STOCKTAKE DUMMY FILE - FILE REFERENCE PARAMETERS
3053: 0000: \***
3054: 0000: \***               REFERENCE    : STKTKDEC.J86
3055: 0000: \***
3056: 0000: \******************************************************************************
3057: 0000: \*******************************************************************************
3058: 0000: 
3059: 0000:   STRING GLOBAL           \
3060: 0000:     STKTK.FILE.NAME$
3061: 0000: 
3062: 0000:   INTEGER*2 GLOBAL        \
3063: 0000:     STKTK.REPORT.NUM%,      \
3064: 0000:     STKTK.SESS.NUM%
3065: 0000:  %INCLUDE STLDTDEC.J86                    ! 1.6
3066: 0000: REM \
3067: 0000: \******************************************************************************
3068: 0000: \******************************************************************************
3069: 0000: \***
3070: 0000: \***            %INCLUDE FOR STLDT FILE VARIABLES
3071: 0000: \***
3072: 0000: \***                 FILE TYPE    : Direct
3073: 0000: \***
3074: 0000: \***                 REFERENCE    : STLDTDEC.J86
3075: 0000: \***
3076: 0000: \***       Version B          David Artiss      03/09/2002
3077: 0000: \***       Increase field from 2 to 2 bytes
3078: 0000: \***
3079: 0000: \******************************************************************************
3080: 0000: \*******************************************************************************
3081: 0000: 
3082: 0000:   STRING GLOBAL           \
3083: 0000:     STLDT.FILE.NAME$,     \
3084: 0000:     STLDT.RECORD$,        \ 25 bytes
3085: 0000:     STLDT.STORE$,         \ 4 bytes
3086: 0000:     STLDT.STOCKTAKER$,    \ 4 bytes
3087: 0000:     STLDT.LDT.SERIAL$,    \ 6 bytes
3088: 0000:     STLDT.DATE$,          \ 6 bytes DDMMYY
3089: 0000:     STLDT.TIME$,          \ 4 bytes HHMM
3090: 0000:     STLDT.CRLF$           \
3091: 0000: 
3092: 0000:   INTEGER*2 GLOBAL        \
3093: 0000:     STLDT.RECL%,          \
3094: 0000:     STLDT.SESS.NUM%,      \
3095: 0000:     STLDT.REPORT.NUM%     ! BDA
3096: 0000:      
3097: 0000:   INTEGER*4 GLOBAL        \
3098: 0000:     STLDT.RECORD.NUM%,    \
3099: 0000:     STLDT.COUNTS%,        \ BDA
3100: 0000:     STLDT.ITEMS%
3101: 0000:       
3102: 0000:  %INCLUDE STOCKDEC.J86                    ! 1.7BG
3103: 0000: \***********************************************************************
3104: 0000: \***********************************************************************
3105: 0000: \***
3106: 0000: \***    DESCRIPTION: Stock File
3107: 0000: \***                 Field Definitions         
3108: 0000: \***
3109: 0000: \***    FILE TYPE : Keyed
3110: 0000: \***
3111: 0000: \***********************************************************************
3112: 0000: \***
3113: 0000: \***    Version B.              Robert Cowey             21st Oct 1993
3114: 0000: \***    No changes to this file.
3115: 0000: \***
3116: 0000: \***    Version C.              Mark Walker              24th Jan 2014
3117: 0000: \***    F337 Centralised View of Stock
3118: 0000: \***    - Added sequence ID and item status fields.
3119: 0000: \***    - Minor formatting changes (uncommented).
3120: 0000: \***
3121: 0000: \***    Version D.              Mark Walker              15th Mar 2014
3122: 0000: \***    F337 Centralised View of Stock
3123: 0000: \***    Added next sequence ID field.
3124: 0000: \***
3125: 0000: \***    Version E.              Mark Walker               7th May 2014
3126: 0000: \***    F337 Centralised View of Stock
3127: 0000: \***    Added new 'stock flags' field for future use.
3128: 0000: \***
3129: 0000: \***********************************************************************
3130: 0000: \***********************************************************************
3131: 0000: 
3132: 0000: \***********************************************************************
3133: 0000: \***********************************************************************
3134: 0000: \***
3135: 0000: \***    File Record Layout
3136: 0000: \***
3137: 0000: \***    STOCK.BOOTS.CODE$            4 UPD  Item Code (Key)
3138: 0000: \***    STOCK.STOCK.FIG%             2 INT  Stock Figure
3139: 0000: \***    STOCK.LAST.COUNT%            2 INT  Last Count Quantity
3140: 0000: \***    STOCK.DATE.LAST.COUNT$       3 UPD  Date of Last Count
3141: 0000: \***    STOCK.DATE.LAST.MOVE$        3 UPD  Date of Last Movement
3142: 0000: \***    STOCK.LAST.REC%              2 INT  Last Receipt Quantity
3143: 0000: \***    STOCK.DATE.LAST.REC$         3 UPD  Date of Last Receipt
3144: 0000: \***    STOCK.DATE.LAST.GAP$         3 UPD  Date of Last Gap
3145: 0000: \***    STOCK.SID%                   4 INT  Sequence ID                     !CMW
3146: 0000: \***    STOCK.STATUS.1$              1 ASC  Item Status                     !CMW
3147: 0000: \***    STOCK.FLAGS%                 1 INT  Stock flags                     !EMW
3148: 0000: \***    STOCK.FILLER$                2 UPD  Filler                          !EMW
3149: 0000: \***
3150: 0000: \***********************************************************************
3151: 0000: \***********************************************************************
3152: 0000: 
3153: 0000:     INTEGER*1 GLOBAL                                                    \
3154: 0000:         STOCK.FLAGS%,                                                   \   !EMW
3155: 0000:         STOCK.RECL%
3156: 0000: 
3157: 0000:     INTEGER*2 GLOBAL                                                    \
3158: 0000:         STOCK.LAST.COUNT%,                                              \
3159: 0000:         STOCK.LAST.REC%,                                                \
3160: 0000:         STOCK.REPORT.NUM%,                                              \
3161: 0000:         STOCK.SESS.NUM%,                                                \
3162: 0000:         STOCK.STOCK.FIG%
3163: 0000: 
3164: 0000:     INTEGER*4 GLOBAL                                                    \   !CMW
3165: 0000:         STOCK.NEXT.SID%,                                                \   !DMW
3166: 0000:         STOCK.SID%                                                          !CMW
3167: 0000: 
3168: 0000:     STRING GLOBAL                                                       \
3169: 0000:         STOCK.BOOTS.CODE$,                                              \
3170: 0000:         STOCK.DATE.LAST.COUNT$,                                         \
3171: 0000:         STOCK.DATE.LAST.GAP$,                                           \
3172: 0000:         STOCK.DATE.LAST.MOVE$,                                          \
3173: 0000:         STOCK.DATE.LAST.REC$,                                           \
3174: 0000:         STOCK.FILE.NAME$,                                               \
3175: 0000:         STOCK.FILLER$,                                                  \
3176: 0000:         STOCK.STATUS.1$                                                     !CMW
3177: 0000: 
3178: 0000:  %INCLUDE IMSTCDEC.J86                    ! 1.7BG
3179: 0000: \***********************************************************************
3180: 0000: \***********************************************************************
3181: 0000: \***
3182: 0000: \***    DESCRIPTION: Item Movement & Stock File
3183: 0000: \***                 Field Definitions         
3184: 0000: \***
3185: 0000: \***    FILE TYPE : Keyed
3186: 0000: \***
3187: 0000: \***********************************************************************
3188: 0000: \***
3189: 0000: \***    Version A.          Les Cook                     21st Aug 1992
3190: 0000: \***    Initial version.
3191: 0000: \***
3192: 0000: \***    VERSION 1.1         Julia Stones                 13th Jun 2005
3193: 0000: \***    Added new external functions for
3194: 0000: \***        MIMSTC - merged IMSTC
3195: 0000: \***        CIMSTC - Copy of IMSTC
3196: 0000: \***        BIMSTC - Backup of IMSTC
3197: 0000: \***
3198: 0000: \***    Version C.          Mark Walker                  23rd Jan 2014
3199: 0000: \***    F337 Centralised View of Stock
3200: 0000: \***    - Added sequence ID field definition.
3201: 0000: \***    - Moved BIMST, CIMST and MIMST field definitions to separate
3202: 0000: \***      modules.
3203: 0000: \***    - Moved TIMST record length to TIMSTDEC.J86.
3204: 0000: \***    - Minor formatting changes (uncommented).
3205: 0000: \***
3206: 0000: \***    Version D.          Mark Walker                  30th Apr 2014
3207: 0000: \***    F337 Centralised View of Stock
3208: 0000: \***    QC599: Introduced item level TSL restart pointer to allow
3209: 0000: \***           Sales Support restart/recovery to continue processing
3210: 0000: \***           correctly from the next unprocessed item.
3211: 0000: \***
3212: 0000: \***********************************************************************
3213: 0000: \***********************************************************************
3214: 0000: 
3215: 0000: \***********************************************************************
3216: 0000: \***********************************************************************
3217: 0000: \***
3218: 0000: \***    File Record Layout
3219: 0000: \***
3220: 0000: \***    IMSTC.BAR.CODE$             11 UPD  Barcode (Key)
3221: 0000: \***    IMSTC.RESTART%               4 INT  IMSTC Restart pointer
3222: 0000: \***    IMSTC.NUMITEMS%              4 INT  Number of items sold
3223: 0000: \***    IMSTC.AMTSALE%               4 INT  Amount of items sold
3224: 0000: \***    IMSTC.TSL.RESTART%           4 INT  TSL Restart pointer             !DMW
3225: 0000: \***    IMSTC.STKMQ.RESTART%         4 INT  STKMQ Restart pointer
3226: 0000: \***    IMSTC.STATUS.FLAG$           1 ASC  Status flags
3227: 0000: \***    IMSTC.STOCK.FIGURE%          2 INT  Stock Figure
3228: 0000: \***    IMSTC.REASON.ITEM.REMOVED$   1 ASC  Deletion Reason
3229: 0000: \***    IMSTC.SID%                   4 INT  Sequence ID
3230: 0000: \***    IMSTC.FILLER$                1 UPD  Filler
3231: 0000: \***
3232: 0000: \***********************************************************************
3233: 0000: \***********************************************************************
3234: 0000: 
3235: 0000:     INTEGER*2 GLOBAL                                                    \
3236: 0000:         IMSTC.SESS.NUM%,                                                \
3237: 0000:         IMSTC.RECL%,                                                    \
3238: 0000:         IMSTC.REPORT.NUM%,                                              \
3239: 0000:         IMSTC.STOCK.FIGURE%
3240: 0000: 
3241: 0000:     INTEGER*4 GLOBAL                                                    \
3242: 0000:         IMSTC.AMTSALE%,                                                 \
3243: 0000:         IMSTC.NEXT.SID%,                                                \   !CMW
3244: 0000:         IMSTC.NUMITEMS%,                                                \
3245: 0000:         IMSTC.RESERVED%,                                                \
3246: 0000:         IMSTC.RESTART%,                                                 \
3247: 0000:         IMSTC.SID%,                                                     \   !CMW
3248: 0000:         IMSTC.STKMQ.RESTART%,                                           \
3249: 0000:         IMSTC.TSL.RESTART%                                                  !DMW
3250: 0000: 
3251: 0000:     STRING GLOBAL                                                       \
3252: 0000:         IMSTC.BAR.CODE$,                                                \
3253: 0000:         IMSTC.FILE.NAME$,                                               \
3254: 0000:         IMSTC.FILLER$,                                                  \
3255: 0000:         IMSTC.HOLD.PENDING$,                                            \
3256: 0000:         IMSTC.REASON.ITEM.REMOVED$,                                     \
3257: 0000:         IMSTC.STATUS.FLAG$
3258: 0000: 
3259: 0000:  %INCLUDE LSSSTDEC.J86                    ! 1.7BG
3260: 0000: REM \
3261: 0000: \******************************************************************************
3262: 0000: \******************************************************************************
3263: 0000: \***
3264: 0000: \***                 %INCLUDE FOR THE LSS STOCK COUNT FILE
3265: 0000: \***   
3266: 0000: \***                      FILE TYPE  :   Direct
3267: 0000: \***
3268: 0000: \***                      REFERENCE  :   LSSSTDEC.J86
3269: 0000: \***
3270: 0000: \***    Version A          Brian Greenfield          16th October 2002
3271: 0000: \***
3272: 0000: \******************************************************************************
3273: 0000: \*******************************************************************************
3274: 0000: 
3275: 0000:   STRING GLOBAL              \ 
3276: 0000:     LSSST.FILE.NAME$,        \
3277: 0000:     LSSST.IRF.BAR.CODE$,     \
3278: 0000:     LSSST.STOCK.BOOTS.CODE$, \
3279: 0000:     LSSST.STOCK.COUNT$,      \
3280: 0000:     LSSST.TSF$
3281: 0000:         
3282: 0000:   INTEGER*2 GLOBAL        \
3283: 0000:     LSSST.RECL%,          \            
3284: 0000:     LSSST.REPORT.NUM%,    \      
3285: 0000:     LSSST.SESS.NUM%
3286: 0000: 
3287: 0000:          
3288: 0000:  %INCLUDE SXTCFDEC.J86                    ! 1.8DA
3289: 0000: \******************************************************************************
3290: 0000: \******************************************************************************
3291: 0000: \***
3292: 0000: \***   $Workfile:   SXTCFDEC.J86  $
3293: 0000: \***
3294: 0000: \***   $Revision:   1.1  $
3295: 0000: \***
3296: 0000: \******************************************************************************
3297: 0000: \******************************************************************************
3298: 0000: \***
3299: 0000: \***   $Log:   V:\archive\j86\sxtcfdec.j8v  $
3300: 0000: \***   
3301: 0000: \***      Rev 1.1   07 Jan 1998 10:26:30   DEV69PS
3302: 0000: \***    
3303: 0000: \***   
3304: 0000: \***      Rev 1.0   15 Jul 1997 14:21:06   DEV45PS
3305: 0000: \***    
3306: 0000: \***   
3307: 0000: \***      Rev 1.1   15 Jul 1997 13:44:06   DEV45PS
3308: 0000: \***    
3309: 0000: \***   
3310: 0000: \***      Rev 1.0   09 Jul 1997 11:05:28   DEV45PS
3311: 0000: \***   Stocktake System New Files
3312: 0000: \***   
3313: 0000: \*** 
3314: 0000: \***   
3315: 0000: \******************************************************************************
3316: 0000: \******************************************************************************\*****************************************************************************
3317: 0000: \*****************************************************************************
3318: 0000: \***
3319: 0000: \***               %INCLUDE FOR SXTCF - FIELD DECLARATIONS
3320: 0000: \***                                    FILE REFERENCE PARAMETERS
3321: 0000: \***
3322: 0000: \***                      FILE TYPE    : DIRECT
3323: 0000: \***
3324: 0000: \***                      REFERENCE    : SXTCFDEC
3325: 0000: \***
3326: 0000: \***           VERSION A : NIK SEN  3rd July 1997
3327: 0000: \***
3328: 0000: \***
3329: 0000: 
3330: 0000: \*****************************************************************************
3331: 0000: \*****************************************************************************
3332: 0000: 
3333: 0000: 
3334: 0000:   STRING GLOBAL           \
3335: 0000:     SXTCF.FILE.NAME$
3336: 0000: 
3337: 0000:   INTEGER*1 GLOBAL        \
3338: 0000:     SXTCF.HEADER.EXPECTED%
3339: 0000: 
3340: 0000:   INTEGER*2 GLOBAL        \
3341: 0000:     SXTCF.SESS.NUM%,      \
3342: 0000:     SXTCF.REPORT.NUM%,    \
3343: 0000:     SXTCF.RECL%
3344: 0000: 
3345: 0000:   INTEGER*4 GLOBAL        \
3346: 0000:     SXTCF.REC.NUM%
3347: 0000: 
3348: 0000: 
3349: 0000:   INTEGER*4 GLOBAL                                   \
3350: 0000:             SXTCF.STKBF.POINTER%,                    \ Pointer to STKBF
3351: 0000:             SXTCF.ITEM.COUNT%,                       \ No of items processed
3352: 0000:             SXTCF.CURRENT.COUNT%                     ! Items in current batch
3353: 0000: 
3354: 0000: 
3355: 0000:   STRING GLOBAL                                 \
3356: 0000:        SXTCF.START.DATE$,                       \
3357: 0000:        SXTCF.START.TIME$,                       \
3358: 0000:        SXTCF.END.DATE$,                         \
3359: 0000:        SXTCF.END.TIME$,                         \
3360: 0000:        SXTCF.STOCKTAKE.IN.PROGRESS$,            \ Y=Yes; N=No; S=Stop; C=Complete 1 BYTE
3361: 0000:        SXTCF.STOCKTAKER$,                       \ Current Stocktaker
3362: 0000:        SXTCF.CUR.LOCATION$,                     \ Location code currently be processed ! 1.1
3363: 0000:        SXTCF.FILLER$                            \ 
3364: 0000: 
3365: 0000: 
3366: 0000:  %INCLUDE STKCFDEC.J86                    ! 1.8DA
3367: 0000: \******************************************************************************
3368: 0000: \******************************************************************************
3369: 0000: \***
3370: 0000: \***   $Workfile:   STKCFDEC.J86  $
3371: 0000: \***
3372: 0000: \***   $Revision:   1.2  $
3373: 0000: \***
3374: 0000: \******************************************************************************
3375: 0000: \******************************************************************************
3376: 0000: \***
3377: 0000: \***   $Log:   V:\archive\j86\stkcfdec.j8v  $
3378: 0000: \***   
3379: 0000: \***      Rev 1.2   03 Jul 1997 14:18:38   DEV45PS
3380: 0000: \***   Stocktake In Progress Flag Removed
3381: 0000: \***   
3382: 0000: \***      Rev 1.1   30 Jun 1997 15:29:04   DEV45PS
3383: 0000: \***   Added Stocktake In Progress flag
3384: 0000: \***   
3385: 0000: \******************************************************************************
3386: 0000: \******************************************************************************\*****************************************************************************
3387: 0000: \*****************************************************************************
3388: 0000: \***
3389: 0000: \***               %INCLUDE FOR STKCF - FIELD DECLARATIONS
3390: 0000: \***                                    FILE REFERENCE PARAMETERS
3391: 0000: \***
3392: 0000: \***                      FILE TYPE    : DIRECT
3393: 0000: \***
3394: 0000: \***                      REFERENCE    : STKCFDEA
3395: 0000: \***
3396: 0000: \***           VERSION A : STEVEN GOULDING  11.01.93
3397: 0000: \***
3398: 0000: \***
3399: 0000: \***           VERSION B        NIK SEN        5th June 1997
3400: 0000: \***           Added Stocktake.In.Progress flag.
3401: 0000: \***           
3402: 0000: \***           VERSION C        NIK SEN        3rd July 1997
3403: 0000: \***           Removed Stocktake.In.Progress flag. Now moved to Stocktake
3404: 0000: \***           Control File to prevent conflicts when STKCF is locked.
3405: 0000: \***
3406: 0000: \*****************************************************************************
3407: 0000: \*****************************************************************************
3408: 0000: 
3409: 0000: REM \
3410: 0000: 
3411: 0000:   STRING GLOBAL           \
3412: 0000:     STKCF.FILE.NAME$
3413: 0000: 
3414: 0000:   INTEGER*2 GLOBAL        \
3415: 0000:     STKCF.SESS.NUM%,      \
3416: 0000:     STKCF.REPORT.NUM%,    \
3417: 0000:     STKCF.RECL%
3418: 0000: 
3419: 0000:   INTEGER*4 GLOBAL        \
3420: 0000:     STKCF.REC.NUM%
3421: 0000: REM \
3422: 0000: 
3423: 0000: 
3424: 0000:   INTEGER*4 GLOBAL                                   \
3425: 0000:             STKCF.STKMQ.POINTER%,                    \ Pointer to STKMQ
3426: 0000:             STKCF.ITEM.COUNT%                        \ No of items processed
3427: 0000: 
3428: 0000:   INTEGER*2 GLOBAL                                   \
3429: 0000:             STKCF.STMVT.REC.CNT%                     \ No of recs on STMVT file
3430: 0000: 
3431: 0000:   INTEGER*1 GLOBAL                                   \
3432: 0000:             STKCF.PREV.PITRL.UPDATE%                 \ The HOUR of update
3433: 0000: 
3434: 0000:   STRING    GLOBAL                                   \ 1 BYTE
3435: 0000:             STKCF.STOCK.SUPPORT.STATUS$              \ Y = enabled
3436: 0000:                                                      \ N = disabled
3437: 0000:                                                      \ C = Not available to
3438: 0000:                                                      \         Screens
3439: 0000:                                                      \ T = Trailer written
3440: 0000:                                                      \ 1 - 7 According to
3441: 0000:                                                      \       which STKMQ backup
3442: 0000:                                                      \       done.
3443: 0000: 
3444: 0000:   STRING    GLOBAL                                   \
3445: 0000:   	    STKCF.LAST.DIRORD.BC$,	 	     \ Last BC processed
3446: 0000: 	    					     \ in type 17 (1 byte)
3447: 0000:   	    STKCF.LAST.DIRORD.SUPPLIER$,	     \ Last supplier processed
3448: 0000: 	    					     \ in type 17 (3 bytes UPD)
3449: 0000: 	    STKCF.LAST.DIRORD.ORDER.NO$,	     \ last order no processed
3450: 0000: 	    					     \ in type 17 (2 bytes UPD)
3451: 0000: 	    STKCF.LAST.DIRORD.ORDER.SUFFIX$,	     \ last order sfx processed
3452: 0000: 	    					     \ in type 17 (1 byte)
3453: 0000:   	    STKCF.LAST.DIRORD.REC.SOURCE$, 	     \ Last record source
3454: 0000: 	    					     \ in type 17 (1 byte)
3455: 0000:        STKCF.STK.FILE.AVAIL$,                   \ Y=Yes; N=No; 1 BYTE
3456: 0000:        STKCF.STOCK.TAKE.PROCESSING.REQUIRED$,   \ Y=Yes; N=No; 1 BYTE
3457: 0000:        STKCF.FILLER$                            \ 
3458: 0000: 
3459: 0000: 
3460: 0000:  %INCLUDE STKMFDEC.J86                    ! 1.8DA
3461: 0000: \******************************************************************************
3462: 0000: \******************************************************************************
3463: 0000: \***
3464: 0000: \***   $Workfile:   STKMFDEC.J86  $
3465: 0000: \***
3466: 0000: \***   $Revision:   1.0  $
3467: 0000: \***
3468: 0000: \******************************************************************************
3469: 0000: \******************************************************************************
3470: 0000: \***
3471: 0000: \***   $Log:   V:\archive\j86\stkmfdec.j8v  $
3472: 0000: \***   
3473: 0000: \***      Rev 1.0   15 Jul 1997 14:20:54   DEV45PS
3474: 0000: \***    
3475: 0000: \***   
3476: 0000: \***      Rev 1.0   09 Jul 1997 11:05:16   DEV45PS
3477: 0000: \***   Stocktake System New Files
3478: 0000: \***   
3479: 0000: \******************************************************************************
3480: 0000: \******************************************************************************\******************************************************************************
3481: 0000: \******************************************************************************
3482: 0000: \***
3483: 0000: \***  %INCLUDES FOR STOCKTAKE MAONFRAME TRANSMISSION FILE FIELD DECLARATIONS
3484: 0000: \***
3485: 0000: \***               FILE TYPE    : DIRECT
3486: 0000: \***
3487: 0000: \***               REFERENCE    : STKMFDEC.J86
3488: 0000: \***
3489: 0000: \***    VERSION A.              Nik Sen.               19 Jun 1997.
3490: 0000: \***    New file for stocktaking system. Holds stocktake data for 
3491: 0000: \***    transmission to the maonframe.
3492: 0000: \***
3493: 0000: \*******************************************************************************
3494: 0000: \*******************************************************************************
3495: 0000: 
3496: 0000: STRING GLOBAL                                                  \
3497: 0000:        STKMF.FILE.NAME$,               \
3498: 0000:        STKMF.DATA$,                    \
3499: 0000:        STKMF.STORE.NUMBER$,            \
3500: 0000:        STKMF.STOCKTAKER.NUM$,          \
3501: 0000:        STKMF.FILLER$,                  \
3502: 0000:        STKMF.DELIMITER$,               \
3503: 0000:        STKMF.DATE$,                    \
3504: 0000:        STKMF.LOCATION$,                \
3505: 0000:        STKMF.ITEM.CODE$,               \
3506: 0000:        STKMF.QUANTITY$,                \
3507: 0000:        STKMF.PRICE$,                   \
3508: 0000:        STKMF.RECORD.COUNT$
3509: 0000:                        
3510: 0000: INTEGER*4 GLOBAL               \
3511: 0000:        STKMF.RECORD.NUM%
3512: 0000: 
3513: 0000: INTEGER*2 GLOBAL                \
3514: 0000:    STKMF.REPORT.NUM%,           \
3515: 0000:    STKMF.SESS.NUM%             
3516: 0000: 
3517: 0000: 
3518: 0000: INTEGER*1 GLOBAL                \
3519: 0000:    STKMF.RECL%         
3520: 0000: 
3521: 0000: 
3522: 0000:  %INCLUDE STKRCDEC.J86                    ! 1.8DA
3523: 0000: \******************************************************************************
3524: 0000: \******************************************************************************
3525: 0000: \***
3526: 0000: \***   $Workfile:   STKRCDEC.J86  $
3527: 0000: \***
3528: 0000: \***   $Revision:   1.1  $
3529: 0000: \***
3530: 0000: \******************************************************************************
3531: 0000: \******************************************************************************
3532: 0000: \***
3533: 0000: \***   $Log:   V:\archive\j86\stkrcdec.j8v  $
3534: 0000: \***   
3535: 0000: \***      Rev 1.1   03 Feb 1998 10:06:02   DEV69PS
3536: 0000: \***    
3537: 0000: \***   
3538: 0000: \***      Rev 1.0   15 Jul 1997 14:20:58   DEV45PS
3539: 0000: \***    
3540: 0000: \***   
3541: 0000: \***      Rev 1.0   09 Jul 1997 11:05:22   DEV45PS
3542: 0000: \***   Stocktake System New Files
3543: 0000: \***   
3544: 0000: \******************************************************************************
3545: 0000: \******************************************************************************\******************************************************************************
3546: 0000: \******************************************************************************
3547: 0000: \***
3548: 0000: \***         %INCLUDE FOR STOCKTAKE RECOUNT FILE FIELD DECLARATIONS
3549: 0000: \***
3550: 0000: \***               FILE TYPE    : DIRECT
3551: 0000: \***
3552: 0000: \***               REFERENCE    : STKRCDEC.J86
3553: 0000: \***
3554: 0000: \***    VERSION A.              Nik Sen.               19 Jun 1997.
3555: 0000: \***    New file for stocktaking system. Holds all items where a recount
3556: 0000: \***    has occurred.
3557: 0000: \***
3558: 0000: \*******************************************************************************
3559: 0000: \*******************************************************************************
3560: 0000: 
3561: 0000: STRING GLOBAL                                                  \
3562: 0000:        STKRC.FILE.NAME$,               \
3563: 0000:        STKRC.ITEM.CODE$,               \
3564: 0000:        STKRC.ITEM.DESCRIPTION$,        \
3565: 0000:        STKRC.LOCATION$,                \
3566: 0000:        STKRC.INITIAL.QUANTITY$,        \
3567: 0000:        STKRC.INITIAL.STOCKTAKER$,      \
3568: 0000:        STKRC.FINAL.QUANTITY$,          \
3569: 0000:        STKRC.FINAL.STOCKTAKER$
3570: 0000: 
3571: 0000: INTEGER*4 GLOBAL               \     !1.1
3572: 0000:        STKRC.RECORD.NUM%
3573: 0000: 
3574: 0000: 
3575: 0000: INTEGER*2 GLOBAL                \
3576: 0000:    STKRC.REPORT.NUM%,           \
3577: 0000:    STKRC.SESS.NUM%             
3578: 0000: 
3579: 0000: 
3580: 0000: INTEGER*1 GLOBAL                \
3581: 0000:    STKRC.LOC.CNT%,              \     
3582: 0000:    STKRC.RECL%         
3583: 0000: 
3584: 0000: 
3585: 0000:  %INCLUDE XGCFDEC.J86                     ! 1.8DA
3586: 0000: \******************************************************************************
3587: 0000: \******************************************************************************
3588: 0000: \***
3589: 0000: \***         %INCLUDE FOR STOCKTAKE GROUP CODE FILE
3590: 0000: \***
3591: 0000: \***                  FILE TYPE    : Keyed
3592: 0000: \***
3593: 0000: \***                  REFERENCE    : XGCFDEC.J86
3594: 0000: \***
3595: 0000: \***    VERSION A               Steve Wright                        24 Aug 1999
3596: 0000: \***
3597: 0000: \*******************************************************************************
3598: 0000: \*******************************************************************************
3599: 0000: 
3600: 0000: STRING GLOBAL           \
3601: 0000:    XGCF.FILE.NAME$,     \
3602: 0000:    XGCF.PRODUCT.GRP$,   \  Redundant - key changed from product group to BC
3603: 0000:    XGCF.BAR.CODE$,      \
3604: 0000:    XGCF.BSNS.CNTR$,     \  New key - 1 byte business centre
3605: 0000:    XGCF.RSRVD$          !  New key - 2 byte filler, must be 0x0000 (set by function)
3606: 0000: 
3607: 0000: INTEGER*2 GLOBAL        \
3608: 0000:    XGCF.RECL%,          \  
3609: 0000:    XGCF.REPORT.NUM%,    \ 
3610: 0000:    XGCF.SESS.NUM%
3611: 0000:  %INCLUDE STKEXDEC.J86                    ! 1.8DA
3612: 0000: \******************************************************************************
3613: 0000: \******************************************************************************
3614: 0000: \***
3615: 0000: \***   $Workfile:   STKEXDEC.J86  $
3616: 0000: \***
3617: 0000: \***   $Revision:   1.1  $
3618: 0000: \***
3619: 0000: \******************************************************************************
3620: 0000: \******************************************************************************
3621: 0000: \***
3622: 0000: \***   $Log:   V:\archive\j86\stkexdec.j8v  $
3623: 0000: \***   
3624: 0000: \***      Rev 1.1   05 Aug 1997 13:49:18   DEV45PS
3625: 0000: \***   Added Reason Code
3626: 0000: \***   
3627: 0000: \***      Rev 1.0   15 Jul 1997 14:20:44   DEV45PS
3628: 0000: \***    
3629: 0000: \***   
3630: 0000: \***      Rev 1.0   09 Jul 1997 11:05:04   DEV45PS
3631: 0000: \***   Stocktake System New Files
3632: 0000: \***   
3633: 0000: \******************************************************************************
3634: 0000: \******************************************************************************\******************************************************************************
3635: 0000: \******************************************************************************
3636: 0000: \***
3637: 0000: \***         %INCLUDE FOR STOCKTAKE EXCEPTIONS FILE FIELD DECLARATIONS
3638: 0000: \***
3639: 0000: \***               FILE TYPE    : DIRECT
3640: 0000: \***
3641: 0000: \***               REFERENCE    : STKEXDEC.J86
3642: 0000: \***
3643: 0000: \***    VERSION A.              Nik Sen.               19 Jun 1997.
3644: 0000: \***    New file for stocktaking system. Holds all counted items which  
3645: 0000: \***    are not on the IDF.
3646: 0000: \***
3647: 0000: \***    VERSION B              Nik Sen                 5th August 1997
3648: 0000: \***    Added reason code.
3649: 0000: \***
3650: 0000: \*******************************************************************************
3651: 0000: \*******************************************************************************
3652: 0000: 
3653: 0000: STRING GLOBAL                                                  \
3654: 0000:    STKEX.FILE.NAME$,            \
3655: 0000:    STKEX.ITEM.CODE$,           \
3656: 0000:    STKEX.QUANTITY$,            \
3657: 0000:    STKEX.LOCATION$,            \
3658: 0000:    STKEX.STOCKTAKER.NUM$,      \
3659: 0000:    STKEX.REASON.CODE$
3660: 0000: 
3661: 0000: 
3662: 0000: INTEGER*4 GLOBAL               \
3663: 0000:        STKEX.RECORD.NUM%
3664: 0000: 
3665: 0000: INTEGER*2 GLOBAL                \
3666: 0000:    STKEX.REPORT.NUM%,           \
3667: 0000:    STKEX.SESS.NUM%             
3668: 0000: 
3669: 0000: 
3670: 0000: INTEGER*1 GLOBAL                \
3671: 0000:    STKEX.RECL%         
3672: 0000: 
3673: 0000: 
3674: 0000:  %INCLUDE STKIFDEC.J86                    ! 1.8DA
3675: 0000: \******************************************************************************
3676: 0000: \******************************************************************************
3677: 0000: \***
3678: 0000: \***   $Workfile:   STKIFDEC.J86  $
3679: 0000: \***
3680: 0000: \***   $Revision:   1.2  $
3681: 0000: \***
3682: 0000: \******************************************************************************
3683: 0000: \******************************************************************************
3684: 0000: \***
3685: 0000: \***   $Log:   V:\archive\j86\stkifdec.j8v  $
3686: 0000: \***   
3687: 0000: \***      Rev 1.2   21 Aug 1997 11:20:56   DEV45PS
3688: 0000: \***    
3689: 0000: \***   
3690: 0000: \***      Rev 1.1   19 Aug 1997 11:06:14   DEV45PS
3691: 0000: \***   Added Stocktake Transmission File Record Number Field
3692: 0000: \***   
3693: 0000: \***      Rev 1.0   15 Jul 1997 14:20:48   DEV45PS
3694: 0000: \***    
3695: 0000: \***   
3696: 0000: \***      Rev 1.0   09 Jul 1997 11:05:10   DEV45PS
3697: 0000: \***   Stocktake System New Files
3698: 0000: \***   
3699: 0000: \******************************************************************************
3700: 0000: \******************************************************************************\******************************************************************************
3701: 0000: \******************************************************************************
3702: 0000: \***
3703: 0000: \***         %INCLUDE FOR STOCKTAKE ITEM FILE FIELD DECLARATIONS
3704: 0000: \***
3705: 0000: \***               FILE TYPE    : KEYED
3706: 0000: \***
3707: 0000: \***               REFERENCE    : STKIFDEC.J86
3708: 0000: \***
3709: 0000: \***    VERSION A.              Nik Sen.               19 Jun 1997.
3710: 0000: \***    New file for stocktaking system. Holds information about all counted
3711: 0000: \***    items found on the STOCK and IDF files. Key is Boots Code + Location 
3712: 0000: \***
3713: 0000: \***    VERSION B               Nik Sen                19 August 1997
3714: 0000: \***    Added STKMF Record Number field.
3715: 0000: \***
3716: 0000: \*******************************************************************************
3717: 0000: \*******************************************************************************
3718: 0000: 
3719: 0000: STRING GLOBAL                                                  \
3720: 0000:        STKIF.FILE.NAME$,               \
3721: 0000:        STKIF.KEY$,                     \
3722: 0000:        STKIF.ITEM.CODE$,               \
3723: 0000:        STKIF.LOCATION$,                \
3724: 0000:        STKIF.BUSINESS.CENTRE$,         \
3725: 0000:        STKIF.GROUP.SEQUENCE$,          \
3726: 0000:        STKIF.QUANTITY$,                \
3727: 0000:        STKIF.DESCRIPTION$,             \
3728: 0000:        STKIF.STOCKTAKER.NUM$
3729: 0000: 
3730: 0000: 
3731: 0000: 
3732: 0000: INTEGER*2 GLOBAL                \
3733: 0000:    STKIF.REPORT.NUM%,           \
3734: 0000:    STKIF.SESS.NUM%             
3735: 0000: 
3736: 0000: 
3737: 0000: INTEGER*1 GLOBAL                \
3738: 0000:    STKIF.RECL%         
3739: 0000: 
3740: 0000: INTEGER*4 GLOBAL                \
3741: 0000:    STKIF.STKMF.RECORD.NUM%
3742: 0000: 
3743: 0000: 
3744: 0000: 
3745: 0000:  %INCLUDE LOCNTDEC.J86                    ! 1.8DA
3746: 0000: \******************************************************************************
3747: 0000: \******************************************************************************
3748: 0000: \***
3749: 0000: \***   $Workfile:   LOCNTDEC.J86  $
3750: 0000: \***
3751: 0000: \***   $Revision:   1.0  $
3752: 0000: \***
3753: 0000: \******************************************************************************
3754: 0000: \******************************************************************************
3755: 0000: \***
3756: 0000: \***   $Log:   V:\archive\j86\locntdec.j8v  $
3757: 0000: \***   
3758: 0000: \***      Rev 1.0   03 Feb 1998 10:07:40   DEV69PS
3759: 0000: \***    
3760: 0000: \***   
3761: 0000: \******************************************************************************
3762: 0000: \******************************************************************************
3763: 0000: \***
3764: 0000: \***         %INCLUDE FOR STOCKTAKE LOCATION COUNTERS (LOCCNT) DECLARATIONS
3765: 0000: \***
3766: 0000: \***               FILE TYPE    : DIRECT
3767: 0000: \***
3768: 0000: \***               REFERENCE    : LOCNTDEC.J86
3769: 0000: \***
3770: 0000: \***    VERSION A.              Johnnie Chan           6th Jan 1998
3771: 0000: \***    New file for stocktaking system. Holds all locations counted using
3772: 0000: \***    1st to 10000th record for S0000-S9999 and 10001st to 20000th record
3773: 0000: \***    for B0000-B9999.
3774: 0000: \***
3775: 0000: \*******************************************************************************
3776: 0000: \*******************************************************************************
3777: 0000: 
3778: 0000: STRING GLOBAL                           \
3779: 0000:        LOCCNT.FILE.NAME$
3780: 0000:        
3781: 0000: INTEGER*4 GLOBAL                        \
3782: 0000:        LOCCNT.RECORD.NUM%
3783: 0000: 
3784: 0000: 
3785: 0000: INTEGER*2 GLOBAL                        \
3786: 0000:        LOCCNT.REPORT.NUM%,              \
3787: 0000:        LOCCNT.SESS.NUM%             
3788: 0000: 
3789: 0000: 
3790: 0000: INTEGER*1 GLOBAL                        \
3791: 0000:        LOCCNT.LOCATION.COUNT%,          \
3792: 0000:        LOCCNT.RECL%         
3793: 0000: 
3794: 0000: 
3795: 0000:  %INCLUDE STKIGDEC.J86                    ! 1.8DA
3796: 0000: \******************************************************************************
3797: 0000: \******************************************************************************
3798: 0000: \***
3799: 0000: \***         %INCLUDE FOR STOCKTAKE ITEM GROUP FIELD DECLARATIONS
3800: 0000: \***
3801: 0000: \***               FILE TYPE    : DIRECT
3802: 0000: \***
3803: 0000: \***               REFERENCE    : STKIGDEC.J86
3804: 0000: \***
3805: 0000: \***    VERSION A.              Nik Sen.               17 Jun 1997.
3806: 0000: \***    New file for stocktaking system. Holds Business Centres, Concept
3807: 0000: \***    and product groups which define scope of stocktake.
3808: 0000: \***
3809: 0000: \*******************************************************************************
3810: 0000: \*******************************************************************************
3811: 0000: 
3812: 0000: STRING GLOBAL                                                  \
3813: 0000:    STKIG.FILE.NAME$,            \
3814: 0000:    STKIG.DATA$
3815: 0000: 
3816: 0000: INTEGER*4 GLOBAL               \
3817: 0000:    STKIG.RECORD.NUM%
3818: 0000: 
3819: 0000: INTEGER*2 GLOBAL                \
3820: 0000:    STKIG.REPORT.NUM%,           \
3821: 0000:    STKIG.SESS.NUM%             
3822: 0000: 
3823: 0000: 
3824: 0000: INTEGER*1 GLOBAL                \
3825: 0000:    STKIG.RECL%         
3826: 0000: 
3827: 0000: 
3828: 0000:  %INCLUDE STKTFDEC.J86                    ! 1.8DA
3829: 0000: \******************************************************************************
3830: 0000: \******************************************************************************
3831: 0000: \***
3832: 0000: \***   $Workfile:   STKTFDEC.J86  $
3833: 0000: \***
3834: 0000: \***   $Revision:   1.1  $
3835: 0000: \***
3836: 0000: \******************************************************************************
3837: 0000: \******************************************************************************
3838: 0000: \***
3839: 0000: \***   $Log:   V:\archive\j86\stktfdec.j8v  $
3840: 0000: \***   
3841: 0000: \***      Rev 1.1   15 Jul 1997 14:36:28   DEV45PS
3842: 0000: \***    
3843: 0000: \***   
3844: 0000: \***      Rev 1.0   15 Jul 1997 14:21:02   DEV45PS
3845: 0000: \***   Stocktake System New Files
3846: 0000: \***   
3847: 0000: \******************************************************************************
3848: 0000: \******************************************************************************\******************************************************************************
3849: 0000: \******************************************************************************
3850: 0000: \***
3851: 0000: \***         %INCLUDE FOR STOCKTAKE TOTALS FILE FIELD DECLARATIONS
3852: 0000: \***
3853: 0000: \***               FILE TYPE    : KEYED
3854: 0000: \***
3855: 0000: \***               REFERENCE    : STKTFDEC.J86
3856: 0000: \***
3857: 0000: \***    VERSION A.              Nik Sen.               15 July 1997.
3858: 0000: \***    New file for stocktaking system. Holds information about all counted
3859: 0000: \***    items found on the STOCK and IDF files. Key is Boots Code. 
3860: 0000: \***
3861: 0000: \*******************************************************************************
3862: 0000: \*******************************************************************************
3863: 0000: 
3864: 0000: STRING GLOBAL                                                  \
3865: 0000:        STKTF.FILE.NAME$,               \
3866: 0000:        STKTF.BOOTS.CODE$,              \
3867: 0000:        STKTF.BUSINESS.CENTRE$,         \
3868: 0000:        STKTF.GROUP.SEQUENCE$,          \
3869: 0000:        STKTF.QUANTITY$                
3870: 0000: 
3871: 0000: 
3872: 0000: 
3873: 0000: INTEGER*2 GLOBAL                \
3874: 0000:    STKTF.REPORT.NUM%,           \
3875: 0000:    STKTF.SESS.NUM%             
3876: 0000: 
3877: 0000: 
3878: 0000: INTEGER*1 GLOBAL                \
3879: 0000:    STKTF.RECL%         
3880: 0000: 
3881: 0000: 
3882: 0000:  %INCLUDE IRFDEC.J86                      ! 1.8DA
3883: 0000: 
3884: 0000: \**********************************************************************************
3885: 0000: \***
3886: 0000: \***       %INCLUDE FOR ITEM RECORD FILE - FIELD DECLARATIONS
3887: 0000: \***                                     - FILE REFERENCE PARAMETERS
3888: 0000: \***
3889: 0000: \***                      FILE TYPE    : Keyed
3890: 0000: \***
3891: 0000: \***                      REFERENCE    : IRFDEC.J86
3892: 0000: \***
3893: 0000: \***     Version A               Andrew Wedgeworth            29th June 1992
3894: 0000: \***
3895: 0000: \***     Version B               Andrew Wedgeworth        14th December 1992
3896: 0000: \***     Version letter incremented to match other IRF code.
3897: 0000: \***
3898: 0000: \***     Version C             Steve Windsor          12.02.93
3899: 0000: \***     Version letter incremented to match other IRF code.
3900: 0000: \***
3901: 0000: \***     Version D             Steve Windsor          12.05.93
3902: 0000: \***     Version letter incremented to match other IRF code.
3903: 0000: \***
3904: 0000: \***     Version E           Steve Perkins       20th September 1993
3905: 0000: \***     Deals project : Handling of Converted/Unconverted records
3906: 0000: \***     ++   Anything with 'Delete' after initials should be   ++
3907: 0000: \***     ++   deleted once the IRF has been converted in all    ++
3908: 0000: \***     ++   stores.                                           ++
3909: 0000: \***
3910: 0000: \***     Version F           Mark Walker            5th January 1994
3911: 0000: \***     Version letter incremented to match other IRF code.
3912: 0000: \***
3913: 0000: \***     Version 96A         Mark Walker               22nd May 1995
3914: 0000: \***     Definition for IRF.POINTS% added.
3915: 0000: \***
3916: 0000: \***                     Stuart McConnachie           12th June 1995
3917: 0000: \***     INDICAT3% comments added for discount/loyalty flags.
3918: 0000: \***
3919: 0000: \***     Version for 96C  Andrew Wedgeworth            22nd May 1996
3920: 0000: \***     Removed IRF.FILLER$ field, as this is now redundant.
3921: 0000: \***
3922: 0000: \***     Version G     Stuart William McConnachie      11th February 2000
3923: 0000: \***     Converted IRF.INDICAT2$ to integer flag byte.
3924: 0000: \***
3925: 0000: \***     REVISION 1.6.               ROBERT COWEY.               9 JUL 2002.
3926: 0000: \***     Major changes for 2002 Deals Rewrite project.
3927: 0000: \***     Incorporated up to date record layout to assist development work
3928: 0000: \***     (placed in the IRFDEC.J86 to make it visible from ...LST files).
3929: 0000: \***     Moved various comments against variables to record layout.
3930: 0000: \***     Relisted variables in alphabetical order.
3931: 0000: \***     Deleted redundant variables associated with the old deals system ...
3932: 0000: \***     DEAL.NUM$, DEAL.SAVING$
3933: 0000: \***     Retained variables that are otherwise redundant (to be set to null X'00'
3934: 0000: \***     within file functions) ...
3935: 0000: \***     INDICAT2%, INDICAT4%, SALEQUAN$, POINTS%
3936: 0000: \***     Defined variables to hold interpreted deals data for new deals system ...
3937: 0000: \***     DEAL.NUM$(n) and LIST.ID%(n) (where 'n' represents entry 0, 1 and 2).
3938: 0000: \***     These two variables are interpretations of DEAL.DATA% which is defined
3939: 0000: \***     locally within IRFFUN.BAS to keep underlying data invisible to programs.
3940: 0000: \***
3941: 0000: \***     REVISION 1.7                ROBERT COWEY.               5 AUG 2002.
3942: 0000: \***     Further changes for 2002 Deals Rewrite project (PSBF19 related).
3943: 0000: \***     Defined NEW.IRF.DATA$ as a global variable for use with new functions
3944: 0000: \***     CONCAT.NEW.IRF.DATA$ and SPLIT.NEW.IRF.DATA$.
3945: 0000: \***
3946: 0000: \***     REVISION 1.8                ROBERT COWEY.              15 JUL 2003.
3947: 0000: \***     Usage of INDICAT0% bit-3 X'08' changed to Item Contains Alcohol.
3948: 0000: \***     No changes to this file other than description.
3949: 0000: \***     No changes to IRF file functions.
3950: 0000: \***
3951: 0000: \***     REVISION 1.9.      STUART WILLIAM MCCONNACHIE           22 OCT 2003.
3952: 0000: \***     Changes to remove limit of 3 deals per item.
3953: 0000: \***     Declaration of new variables for IRF Deal Extension file (IRFDEX).
3954: 0000: \***
3955: 0000: \***     REVISION 2.0.            ALAN CARR                       9 FEB 2006.
3956: 0000: \***     Add new IRF.INDICAT8% 1 byte, amend IRF.UNUSED$ from 3 to 2 bytes.
3957: 0000: \***
3958: 0000: \***     REVISION 2.1              TITTOO THOMAS                  01 July 2011
3959: 0000: \***     The IRF.UNUSED field is disintegrated to 2 new indicator fields
3960: 0000: \***                      IRF.INDICAT9%   1 INT
3961: 0000: \***                      IRF.INDICAT10%  1 INT
3962: 0000: \***...............................................................................
3963: 0000: 
3964: 0000: 
3965: 0000: \**********************************************************************************
3966: 0000: \***
3967: 0000: \***    IRF RECORD LAYOUT - REVISION 1.7 - CORRECT FOR 2011 CORE Stores PROJECT
3968: 0000: \***
3969: 0000: \***     1 11  UPD  BAR.CODE$   Without check digit - File KEY
3970: 0000: \***    12  1  INT  INDICAT0%
3971: 0000: \***                    X"01" - Contains statins                           ! 2.2 TT
3972: 0000: \***                    X"02" - Item not priced (giveaway)
3973: 0000: \***                    X"04" - Item not returnable
3974: 0000: \***                    X"08" - Item contains alcohol
3975: 0000: \***                    X"10" - Blocked from sale                          ! 2.2 TT
3976: 0000: \***                    X"20" - Enforced price entry
3977: 0000: \***                    X"40" - Enforced quantity entry
3978: 0000: \***                    X"80" - Movement kept
3979: 0000: \***    13  1  INT  INDICAT1%
3980: 0000: \***                    X"01" - Asprin
3981: 0000: \***                    X"02" - Paracetamol
3982: 0000: \***                    X"04" - TPLU inclusion flag
3983: 0000: \***                    X"08" - Giftcard item                              ! 2.2 TT
3984: 0000: \***                    X"10" - Withdrawn Block from sale                  ! 2.2 TT
3985: 0000: \***                    X"20" - Non-solid dose painkiller                  ! 2.2 TT
3986: 0000: \***                    X"40" - Insurance policy item                      ! 2.2 TT
3987: 0000: \***                    X"80" - Ibuprofen
3988: 0000: \***    14  2  INT  DEAL.DATA%(0)   Interpreted into sub-variables ...
3989: 0000: \***                    X'3F' - into DEAL.NUM$(0) "0000" to "9999" (2 byte UPD)
3990: 0000: \***                    X'C0' - into LIST.ID%(0) X'00' X
3991: 0000: \***                                             X'01' A
3992: 0000: \***                                             X'10' B
3993: 0000: \***                                             X'11' C                   ! 1.9 RC
3994: 0000: \***    16  1  INT  INDICAT8%                                              ! 2.0 AJC
3995: 0000: \***                    X"01" - Chlamydia NHS test kit                     ! 2.2 TT
3996: 0000: \***                    X"02" - Chlamydia open sell test kit               ! 2.2 TT
3997: 0000: \***                    X"04" - Unrestricted group code                    ! 2.2 TT
3998: 0000: \***                    X"08" - Nightingale Till prompt                    ! 2.2 TT
3999: 0000: \***                    X"10" - Contains Ephedrine                         ! 2.2 TT
4000: 0000: \***                    X"60" -  X'00' - If also Blocked From Sale Recall, ! 2.2 TT
4001: 0000: \***                                        Emergency                      ! 2.2 TT
4002: 0000: \***                             X'00' - If NOT Blocked From Sale Recall,  ! 2.2 TT
4003: 0000: \***                                        No recall                      ! 2.2 TT
4004: 0000: \***                             X'20' 100% returns                        ! 2.2 TT
4005: 0000: \***                             X'40' Withdrawn recall                    ! 2.2 TT
4006: 0000: \***                             X'60' Reverse Logistics                   ! 2.2 TT
4007: 0000: \***                    X"80" - WEEE item flag                             ! 2.0 AJC
4008: 0000: \***    17  1  INT  INDICAT9%
4009: 0000: \***                    X'3F' - Disposal special instruction (0-63)
4010: 0000: \***                    X"40" - Resaleable Indicator
4011: 0000: \***                    X"80" - Boots.com Extended Indicator
4012: 0000: \***    18  1  INT  INDICAT10%
4013: 0000: \***                    X'07' - Age restrictions
4014: 0000: \***                             X'00' - No Age restriction
4015: 0000: \***                             X'01' - Age 12 or over
4016: 0000: \***                             X'02' - Age 15 or over
4017: 0000: \***                             X'03' - Age 16 or over
4018: 0000: \***                             X'04' - Age 18 or over
4019: 0000: \***                             X'05' - Age 21 or over
4020: 0000: \***                             X'06' - Reserved
4021: 0000: \***                             X'07' - Reserved
4022: 0000: \***                    X'38' - Ethical classification
4023: 0000: \***                             X'00' - No ethical classification
4024: 0000: \***                             X'08' - Pharmacy medicine (P)
4025: 0000: \***                             X'10' - General Sale License (GSL)
4026: 0000: \***                             X'18' - Prescription Only Medicine (POM)
4027: 0000: \***                             X'20' - Reserved
4028: 0000: \***                             X'28' - Reserved
4029: 0000: \***                             X'30' - Reserved
4030: 0000: \***                             X'38' - Reserved
4031: 0000: \***                    X'C0' - Returns route
4032: 0000: \***                             X'00' - Not Returnable (Destroy)
4033: 0000: \***                             X'40' - Returns & Recovery
4034: 0000: \***                             X'80' - Direct
4035: 0000: \***                             X'C0' - Semi-centralised
4036: 0000: \***    19  5  UPD  SALEPRIC$   Current price in pence
4037: 0000: \***    24  1  INT  INDICAT5%   Guarantee duration
4038: 0000: \***                    X'3F' - Lowest 6 bits indicate duration (1-63)
4039: 0000: \***                    X'40' - Contains Pseudoephedrine                   ! 2.2 TT
4040: 0000: \***                    X'80' - Guarantee Duration Type                    ! 2.2 TT
4041: 0000: \***                              (1 = Months, 0 = Years)                  ! 2.2 TT
4042: 0000: \***    25 18  ASC  ITEMNAME$   Description used by till
4043: 0000: \***    43  3  UPD  BOOTS.CODE$ Without check digit
4044: 0000: \***    46  2  INT  DEAL.DATA%(1)   Similar structure to DEAL.DATA%(0)
4045: 0000: \***    48  2  INT  DEAL.DATA%(2)   Similar structure to DEAL.DATA%(0)
4046: 0000: \***    50  1  INT  INDICAT3%
4047: 0000: \***                    X"01" - Discountexempt (item exempt from discount)
4048: 0000: \***                    X"02" - Boots brand item
4049: 0000: \***                    X"04" - Item redeemable for loyalty
4050: 0000: \***                    X"08" - Loyalty exempt (item exempt from loyalty)
4051: 0000: \***                    X"10" - **Redundant                                ! 2.2 TT
4052: 0000: \***                    X"20" - Local Price active
4053: 0000: \***                    X"40" - Stock system item
4054: 0000: \***                    X"80" - **Redundant                                ! 2.2 TT
4055: 0000: \***
4056: 0000: \***    Record Length 50
4057: 0000: \***
4058: 0000: \***
4059: 0000: \***    IRF DEAL EXTENSION RECORD LAYOUT ! 1.9 RC
4060: 0000: \***
4061: 0000: \***     1  3  UPD  BOOTS.CODE$
4062: 0000: \***     4  2  INT  IRF.DEAL.DATA%(3)   Similar structure to DEAL.DATA%(0)
4063: 0000: \***     6  2  INT  IRF.DEAL.DATA%(4)   Similar structure to DEAL.DATA%(0)
4064: 0000: \***     8  2  INT  IRF.DEAL.DATA%(5)   Similar structure to DEAL.DATA%(0)
4065: 0000: \***    10  2  INT  IRF.DEAL.DATA%(6)   Similar structure to DEAL.DATA%(0)
4066: 0000: \***    12  2  INT  IRF.DEAL.DATA%(7)   Similar structure to DEAL.DATA%(0)
4067: 0000: \***    14  2  INT  IRF.DEAL.DATA%(8)   Similar structure to DEAL.DATA%(0)
4068: 0000: \***    16  2  INT  IRF.DEAL.DATA%(9)   Similar structure to DEAL.DATA%(0)
4069: 0000: \***
4070: 0000: \***    Record Length 17
4071: 0000: \***
4072: 0000: \**********************************************************************************
4073: 0000: 
4074: 0000: 
4075: 0000:     STRING GLOBAL            \
4076: 0000:         IRF.ALT.FILE.NAME$,  \
4077: 0000:         IRF.BAR.CODE$,       \
4078: 0000:         IRF.BOOTS.CODE$,     \
4079: 0000:         IRF.DEAL.SAVING$,    \ 2 byte - deal saving amount (0 - 99.99) ! ESP
4080: 0000:         IRF.DEPARTME$,       \ 3 byte UPD. Department number          ! ESP Delete
4081: 0000:         IRF.FILE.NAME$,      \
4082: 0000:         IRF.HOLDING.PRICE$,  \ 4 byte UPD. Current H.O. price in pence if a local
4083: 0000:                              \ price is in effect, zero otherwise.     ! ESP Delete
4084: 0000:         IRF.ITEMNAME$,       \
4085: 0000: \       IRF.MPGROUP$,        \ Removed SBH 31/1/96
4086: 0000:         IRF.RECORD$,         \                                         ! ESP Delete
4087: 0000:         IRF.SALEPRIC$,       \
4088: 0000:         IRF.SALEQUAN$,       \ Redundant (set to null within functions)    ! 1.6 RC
4089: 0000:         IRF.UNUSED$,         \                                                        ! 1.6 RC
4090: 0000:         NEW.IRF.DATA$        !                                             ! 1.7 RC
4091: 0000: 
4092: 0000:     STRING GLOBAL            \                                             ! 1.6 RC
4093: 0000:         IRF.DEAL.NUM$(1)                                                   ! 1.6 RC
4094: 0000: 
4095: 0000:     INTEGER*1 GLOBAL         \
4096: 0000:         IRF.DD.SUB%,         \ IRF.DEAL.DATA% subscript                    ! 1.6 RC
4097: 0000:         IRF.INDICAT0%,       \
4098: 0000:         IRF.INDICAT1%,       \
4099: 0000:         IRF.INDICAT2%,       \ Redundant (set to null within functions)    ! 1.6 RC
4100: 0000:         IRF.INDICAT3%,       \
4101: 0000:         IRF.INDICAT4%,       \ Redundant (set to null within functions)    ! 1.6 RC
4102: 0000:         IRF.INDICAT5%,       \                                             ! 2.0 AJC
4103: 0000:         IRF.INDICAT8%,       \                                             ! 2.0 AJC
4104: 0000:         IRF.INDICAT9%,       \                                             ! 2.2 TT
4105: 0000:         IRF.INDICAT10%                                                     ! 2.2 TT
4106: 0000: 
4107: 0000:     INTEGER*1 GLOBAL         \                                             ! 1.6 RC
4108: 0000:         IRF.LIST.ID%(1)                                                    ! 1.6 RC
4109: 0000: 
4110: 0000:     INTEGER*2 GLOBAL         \
4111: 0000:         IRF.ALT.REPORT.NUM%, \
4112: 0000:         IRF.ALT.SESS.NUM%,   \
4113: 0000:         IRF.POINTS%,         \ Redundant (set to null within functions)    ! 1.6 RC
4114: 0000:         IRF.RECL%,           \
4115: 0000:         IRF.REPORT.NUM%,     \
4116: 0000:         IRF.SESS.NUM%,       \
4117: 0000:         IRF.MAX.DEALS%       !                                             ! 1.9 SM
4118: 0000: 
4119: 0000:     STRING GLOBAL IRFDEX.FILE.NAME$                                        ! 1.9 SM
4120: 0000: 
4121: 0000:     INTEGER*2 GLOBAL IRFDEX.SESS.NUM%                                      ! 1.9 SM
4122: 0000:     INTEGER*2 GLOBAL IRFDEX.REPORT.NUM%                                    ! 1.9 SM
4123: 0000:     INTEGER*2 GLOBAL IRFDEX.RECL%                                          ! 1.9 SM
4124: 0000: 
4125: 0000: 
4126: 0000: !   INTEGER*2 GLOBAL      \ IRF.DEAL.DATA%(n) variables are defined locally  1.6 RC
4127: 0000: !       IRF.DEAL.DATA%(1) \ within IRFFUN.BAS to keep invisible to programs  1.6 RC
4128: 0000: 
4129: 0000:  %INCLUDE STKDCDEC.J86                    ! 1.8DA
4130: 0000: \******************************************************************************
4131: 0000: \******************************************************************************
4132: 0000: \***
4133: 0000: \***   $Workfile:   STKDCDEC.J86  $
4134: 0000: \***
4135: 0000: \***   $Revision:   1.0  $
4136: 0000: \***
4137: 0000: \******************************************************************************
4138: 0000: \******************************************************************************
4139: 0000: \***
4140: 0000: \***   $Log:   V:\archive\j86\stkdcdec.j8v  $
4141: 0000: \***   
4142: 0000: \***      Rev 1.0   15 Jul 1997 14:20:40   DEV45PS
4143: 0000: \***    
4144: 0000: \***   
4145: 0000: \***      Rev 1.0   09 Jul 1997 11:04:58   DEV45PS
4146: 0000: \***   Stocktake System New Files
4147: 0000: \***   
4148: 0000: \******************************************************************************
4149: 0000: \******************************************************************************\******************************************************************************
4150: 0000: \******************************************************************************
4151: 0000: \***
4152: 0000: \***         %INCLUDE FOR STOCKTAKE DUMP CODEP FIELD DECLARATIONS
4153: 0000: \***
4154: 0000: \***               FILE TYPE    : DIRECT
4155: 0000: \***
4156: 0000: \***               REFERENCE    : STKDCDEC.J86
4157: 0000: \***
4158: 0000: \***    VERSION A.              Nik Sen.               19 Jun 1997.
4159: 0000: \***    New file for stocktaking system. Holds all items counted using
4160: 0000: \***    dump codes during the stocktake.
4161: 0000: \***
4162: 0000: \*******************************************************************************
4163: 0000: \*******************************************************************************
4164: 0000: 
4165: 0000: STRING GLOBAL                                                  \
4166: 0000:        STKDC.FILE.NAME$,               \
4167: 0000:        STKDC.DUMP.CODE$,               \
4168: 0000:        STKDC.QUANTITY$,                \
4169: 0000:        STKDC.PRICE$,                   \
4170: 0000:        STKDC.LOCATION$,                \
4171: 0000:        STKDC.STOCKTAKER.NUM$
4172: 0000:         
4173: 0000: INTEGER*4 GLOBAL               \
4174: 0000:        STKDC.RECORD.NUM%
4175: 0000: 
4176: 0000: 
4177: 0000: INTEGER*2 GLOBAL                \
4178: 0000:    STKDC.REPORT.NUM%,           \
4179: 0000:    STKDC.SESS.NUM%             
4180: 0000: 
4181: 0000: 
4182: 0000: INTEGER*1 GLOBAL                \
4183: 0000:    STKDC.RECL%         
4184: 0000: 
4185: 0000: 
4186: 0000:  %INCLUDE MINLSDEC.J86                    ! 1.9BG
4187: 0000: 
4188: 0000: \*****************************************************************************
4189: 0000: \*****************************************************************************
4190: 0000: \***
4191: 0000: \***        %INCLUDE FIELD DECLARATIONS AND FILE REFERENCE PARAMETERS
4192: 0000: \***
4193: 0000: \***                   FILE TYPE:  KEYED
4194: 0000: \***
4195: 0000: \***                   REFERENCE:  MINLSDEC.J86
4196: 0000: \***
4197: 0000: \***              DESCRIPTION:  MINSITS RP - SCREEN COUNT INFORMATION
4198: 0000: \***
4199: 0000: \***
4200: 0000: \***
4201: 0000: \***      VERSION 1 : Julia Stones             8th January 1998  
4202: 0000: \***      
4203: 0000: \*****************************************************************************
4204: 0000: \*****************************************************************************
4205: 0000: 
4206: 0000: STRING GLOBAL   \
4207: 0000:    MINLS.FILE.NAME$,  \
4208: 0000:    MINLS.ITEM.CODE$,     \  4 byte UPD;  Record key
4209: 0000:    MINLS.RECOUNT.DATE$,  \  3 byte UPD;  YYMMDD      
4210: 0000:    MINLS.DISCREPANCY$,    \  3 byte UPD        
4211: 0000:    MINLS.COUNT.STATUS$     ! 1 byte ASCII 
4212: 0000: 
4213: 0000: INTEGER*2 GLOBAL  \
4214: 0000:    MINLS.RECL%,   \
4215: 0000:    MINLS.REPORT.NUM%,  \
4216: 0000:    MINLS.SESS.NUM%   !
4217: 0000: 
4218: 0000: 
4219: 0000: 
4220: 0000:  %INCLUDE NEGSCDEC.J86                    ! 1.9BG
4221: 0000: 
4222: 0000: \*****************************************************************************
4223: 0000: \*****************************************************************************
4224: 0000: \***
4225: 0000: \***        %INCLUDE FIELD DECLARATIONS AND FILE REFERENCE PARAMETERS
4226: 0000: \***
4227: 0000: \***                   FILE TYPE:  KEYED
4228: 0000: \***
4229: 0000: \***                   REFERENCE:  NEGSCDEC.J86
4230: 0000: \***
4231: 0000: \***              DESCRIPTION:  CURRENT NEGATIVE STOCK COUNT INFORMATION
4232: 0000: \***
4233: 0000: \***
4234: 0000: \***
4235: 0000: \***      VERSION 1 : Julia Stones             15th July 1999  
4236: 0000: \***      
4237: 0000: \***    REVISION 1.2.            ROBERT COWEY.                  09 SEP 2003.
4238: 0000: \***    Changes for RF trial.
4239: 0000: \***    Recompiled to prevent future automatic recompiles.
4240: 0000: \***    No changes to actual code.
4241: 0000: \***
4242: 0000: \*****************************************************************************
4243: 0000: \*****************************************************************************
4244: 0000: 
4245: 0000: STRING GLOBAL   \
4246: 0000:    NEGSC.FILE.NAME$,  \
4247: 0000:    NEGSC.KEY$,   \      !  5 bytes UPD; 1 byte Record type 
4248: 0000:                         \                 Record type 01 item record
4249: 0000:                         \                 Record type 02 total count record
4250: 0000:                         \               4 bytes item code (set to zero's if
4251: 0000:                         \                 record type 02)
4252: 0000:    NEGSC.STATUS.1$      !  1 byte ASC
4253: 0000:                         !            'B' - Discontinued but still on display
4254: 0000:                         !            'C' - Cancel outstanding orders
4255: 0000:                         !            'D' - Discontinued and no longer on display
4256: 0000:                         !            'P' - Suspended (orders to Store)
4257: 0000:                         !            'X' - Deleted
4258: 0000:                         !            ' ' - No special Status (default value)
4259: 0000:   
4260: 0000: INTEGER*2 GLOBAL  \
4261: 0000:    NEGSC.RECL%,   \
4262: 0000:    NEGSC.REPORT.NUM%,  \
4263: 0000:    NEGSC.SESS.NUM%,    \
4264: 0000:    NEGSC.ITEM.TSF%,    \
4265: 0000:    NEGSC.NUMBER.OF.DAYS%   !
4266: 0000: 
4267: 0000: 
4268: 0000: 
4269: 0000:  %INCLUDE SSPSCDEC.J86                    ! 2.0JAS
4270: 0000: \*****************************************************************************
4271: 0000: \*****************************************************************************
4272: 0000: \***
4273: 0000: \***               %INCLUDE FOR SSPSCTRL - FIELD DECLARATIONS
4274: 0000: \***                                          FILE REFERENCE PARAMETERS
4275: 0000: \***
4276: 0000: \***                      FILE TYPE    : DIRECT
4277: 0000: \***
4278: 0000: \***                      REFERENCE    : SSPSCdea.J86
4279: 0000: \***
4280: 0000: \***    Version A               Julia Stones          23 Oct 2003
4281: 0000: \***
4282: 0000: \***
4283: 0000: \*****************************************************************************
4284: 0000: \*****************************************************************************
4285: 0000: 
4286: 0000: REM \
4287: 0000: 
4288: 0000:   STRING GLOBAL           \
4289: 0000:     SSPSCTRL.FILE.NAME$
4290: 0000: 
4291: 0000:   INTEGER*2 GLOBAL        \
4292: 0000:     SSPSCTRL.REPORT.NUM%,   \
4293: 0000:     SSPSCTRL.SESS.NUM%
4294: 0000: REM \
4295: 0000: 
4296: 0000:   STRING GLOBAL           \
4297: 0000:     SSPS.BTCSK.NUM$,      \ 3 byte, file ext number (000 - 999)
4298: 0000:     SSPS.BTCSF.NUM$,      \ 3 byte, file ext number (000 - 999)
4299: 0000:     SSPS.BTCSK.FTP$,      \ 3 byte, last file ext number sent to SMARTSCRIPT
4300: 0000:     SSPS.BTCSF.FTP$,      \ 3 byte, last file ext number sent to SMARTSCRIPT
4301: 0000:     SSPS.FILLER$          ! 68 byte, spaces
4302: 0000: 
4303: 0000:   INTEGER*2 GLOBAL        \
4304: 0000:     SSPSCTRL.RECL%
4305: 0000:  %INCLUDE BTCSDEC.J86                     ! 2.0JAS
4306: 0000: \*****************************************************************************
4307: 0000: \*****************************************************************************
4308: 0000: \***
4309: 0000: \***      %INCLUDE FOR BTCS FILE - FIELD DECLARATIONS
4310: 0000: \***                               FILE REFERENCE PARAMETERS
4311: 0000: \***
4312: 0000: \***      FILE TYPE    : DIRECT
4313: 0000: \***
4314: 0000: \***      REFERENCE    : BTCSDEC
4315: 0000: \***
4316: 0000: \***      VERSION A    : Julia Stones 22/10/03
4317: 0000: \***
4318: 0000: \*****************************************************************************
4319: 0000: \*****************************************************************************
4320: 0000: 
4321: 0000:     STRING GLOBAL        BTCS.FILE.NAME$
4322: 0000: 
4323: 0000: 
4324: 0000:     INTEGER*2 GLOBAL     BTCS.SESS.NUM%,        \
4325: 0000:                          BTCS.RECL%,            \
4326: 0000:                          BTCS.REPORT.NUM%
4327: 0000: 
4328: 0000: 
4329: 0000:     INTEGER*4 GLOBAL     BTCS.REC.NUM%
4330: 0000: 
4331: 0000: 
4332: 0000:     STRING GLOBAL        BTCS.RECORD$,           \ Whole record form file:
4333: 0000:                          BTCS.RECORD.TYPE$,      \ 1 ASC Type of record:
4334: 0000:                                                  \       "H" = header
4335: 0000:                                                  \       "D" = detail
4336: 0000:                                                  \       "T" = trailer
4337: 0000:                          BTCS.STORE.NUMBER$,     \ 4 ASC 4 digit Store number
4338: 0000:                          BTCS.STKTAKE.NUM$,      \ 4 ASC 4 digit Stock take number
4339: 0000:                          BTCS.DATE$,             \ 6 ASC Date YYMMDD
4340: 0000:                          BTCS.TIME$,             \ 6 ASC Time HHMMSS
4341: 0000:                          BTCS.DISP.AREA$,        \ 1 ASC M = MDS
4342: 0000:                                                  \       D = Dispensing
4343: 0000:                          BTCS.FILLER$,           \   ASC Set to spaces
4344: 0000:                          BTCS.NUM.RECORD$,       \ 4 ASC Record sequence number starting at 0001
4345: 0000:                          BTCS.ITEM.CODE$,        \13 ASC Item Code/PIP code
4346: 0000:                          BTCS.CODE.TYPE$,        \ 1 ASC E = EAN item code
4347: 0000:                                                  \       P = PIP code
4348: 0000:                          BTCS.PACK.QTY$,         \ 6 ASC Number of packs, bottles etc
4349: 0000:                          BTCS.DIS.UNIT.QTY$,     \ 4 ASC Dispensed unit quantity
4350: 0000:                          BTCS.RECORD.COUNT$,     \ 4 ASC Amount of records in file (inc header and trailer)
4351: 0000:                          BTCS.ENDREC$            \ 2 ASC ODOA
4352: 0000: 
4353: 0000:  %INCLUDE PRINTDEC.J86                    ! 2.0JAS
4354: 0000: 
4355: 0000: REM \
4356: 0000: \*******************************************************************************
4357: 0000: \*******************************************************************************
4358: 0000: \***
4359: 0000: \***    %INCLUDE FOR PRINT FILE VARIABLE DECLARATIONS
4360: 0000: \***
4361: 0000: \***        REFERENCE   :   PRINTDE (J86)
4362: 0000: \***
4363: 0000: \***        FILE TYPE   :   Printer / Labeller
4364: 0000: \***
4365: 0000: \***    VERSION A.              ANDREW WEDGEWORTH                   09 JUL 1992.
4366: 0000: \***    Original version created by merging PRINTFLG and PRINTNUG.
4367: 0000: \***
4368: 0000: \***    VERSION B.              UNKNOWN.                            ?? ??? 1992.
4369: 0000: \***    Changes unknown.             
4370: 0000: \***
4371: 0000: \***    VERSION C.              ROBERT COWEY.                       18 NOV 1992.
4372: 0000: \***    No changes made to this file.
4373: 0000: \***
4374: 0000: \***    Version D               Andrew Wedgeworth                 24th May 1992
4375: 0000: \***    Variable added to contain condensed print record length.
4376: 0000: \***
4377: 0000: \*******************************************************************************
4378: 0000: \*******************************************************************************
4379: 0000: 
4380: 0000: 
4381: 0000:     STRING GLOBAL \
4382: 0000:         PRINT.LINE$, \
4383: 0000:         PRINT.FILE.NAME$, \
4384: 0000:         SELF.LAN.NAME$, \
4385: 0000:         SELF.NOLAN.NAME$
4386: 0000: 
4387: 0000:     INTEGER*2 GLOBAL \
4388: 0000:         PRINT.CONDENSED.RECL%, \                                       ! DAW  
4389: 0000:         PRINT.SESS.NUM%, \
4390: 0000:         PRINT.REPORT.NUM%, \
4391: 0000:         PRINT.REPORT.RECL%, \
4392: 0000:         PRINT.SELF.RECL%
4393: 0000: 
4394: 0000:  %INCLUDE SOPTSDEC.J86                    ! 2.1JAS
4395: 0000: REM \
4396: 0000: \******************************************************************************
4397: 0000: \******************************************************************************
4398: 0000: \***
4399: 0000: \***                 %INCLUDE FOR THE STORE OPTIONS FILE
4400: 0000: \***   
4401: 0000: \***                      FILE TYPE  :   Direct
4402: 0000: \***
4403: 0000: \***                      REFERENCE  :   SOPTSDEC.J86
4404: 0000: \***
4405: 0000: \***    Version A         Stuart William McConnachie      19th June 1995
4406: 0000: \***
4407: 0000: \******************************************************************************
4408: 0000: \*******************************************************************************
4409: 0000: 
4410: 0000:   STRING GLOBAL           \
4411: 0000:     SOPTS.RECORD$,        \           
4412: 0000:     SOPTS.SPACE$,         \           
4413: 0000:     SOPTS.FILE.NAME$
4414: 0000:     
4415: 0000:   INTEGER*2 GLOBAL        \
4416: 0000:     SOPTS.RECL%,          \            
4417: 0000:     SOPTS.REPORT.NUM%,    \      
4418: 0000:     SOPTS.SESS.NUM%
4419: 0000: 
4420: 0000:   INTEGER*4 GLOBAL        \
4421: 0000:     SOPTS.REC.NUM%
4422: 0000: 
4423: 0000:  %INCLUDE TSFDEC.J86                      ! 2.1JAS
4424: 0000: \*****************************************************************************
4425: 0000: \*****************************************************************************
4426: 0000: \***
4427: 0000: \***      %INCLUDE FOR TERMINAL STATUS FILE - FIELD DECLARATIONS
4428: 0000: \***                                          FILE REFERENCE PARAMETERS
4429: 0000: \***
4430: 0000: \***                      FILE TYPE    : KEYED
4431: 0000: \***
4432: 0000: \***                      REFERENCE    : TSFDEC
4433: 0000: \***
4434: 0000: \***           VERSION A : STEVEN GOULDING              13.10.92
4435: 0000: \***
4436: 0000: \***           VERSION B : STEVE WINDSOR                15.09.93
4437: 0000: \***           Updated to keep in step.
4438: 0000: \***
4439: 0000: \***           VERSION C : STUART WILLIAM MCCONNACHIE   18.03.97
4440: 0000: \***           Added extra fields in user data.
4441: 0000: \*** 
4442: 0000: \***           VERSION D : REBECCA DAKIN                22.02.99
4443: 0000: \***           Added ACSALD.CUT.OFF, as part of Cash Accounting project.
4444: 0000: \***
4445: 0000: \***           VERSION E : AMY HOGGARD                  16.10.00
4446: 0000: \***           Added TILLBAG.CUT.OFF, as part of ECO project.
4447: 0000: \***
4448: 0000: \***           VERSION F : STUART WILLIAM MCCONNACHIE   20.05.05
4449: 0000: \***           Added "new" fields as no one else can be bothered.
4450: 0000: \***           Corrected offset bug of controller ID.
4451: 0000: \***
4452: 0000: \***           VERSION G : JAMIE THORPE                 05.10.05
4453: 0000: \***           Added new INVDUE.DATE record to the store record 
4454: 0000: \***           (for Zero TSF proj.)
4455: 0000: \***           This is the date that the most recent INVDUE file
4456: 0000: \***           was created.
4457: 0000: \***
4458: 0000: \***    VERSION H               Mark Walker                      3rd Nov 2014
4459: 0000: \***    F294 PCI Phase 1
4460: 0000: \***    Includes the following changes:
4461: 0000: \***    - Removed redundant 'smartcard software level' field.
4462: 0000: \***    - Extended TSF.INDICAT2% integer field from 1 to 2 bytes.
4463: 0000: \***
4464: 0000: \*****************************************************************************
4465: 0000: \*****************************************************************************
4466: 0000: 
4467: 0000:     STRING GLOBAL               \
4468: 0000:         TSF.FILE.NAME$,         \
4469: 0000:         TSF.REC$(1),            \ One dimensional array
4470: 0000:         TSF.SECTOR.FILLER$,     \
4471: 0000:         TSF.SECTOR.INFO$
4472: 0000:         
4473: 0000:     INTEGER*1 GLOBAL            \
4474: 0000:         TSF.REC.SUB%            ! Subscript used with TSF.REC array
4475: 0000: 
4476: 0000:     INTEGER*2 GLOBAL            \
4477: 0000:         TSF.SESS.NUM%,          \
4478: 0000:         TSF.RECL%,              \
4479: 0000:         TSF.REPORT.NUM%,        \
4480: 0000:         TSF.SECTOR.NUM%
4481: 0000: 
4482: 0000:     STRING GLOBAL               \
4483: 0000:         TSF.TERM.STORE$,        \ 2 byte UPD.Terminal number or 
4484: 0000:                                 \ 9999 for store (key)
4485: 0000:         TSF.TSL.NAME$,          \ 8 bytes. Most recent old TSL file
4486: 0000:         TSF.MONITOR$,           \ 2 byte UPD last monitoring terminal
4487: 0000:         TSF.TLOGFLAG$,          \ 1 byte, EALLGHC processed flag
4488: 0000:         TSF.OPERATOR$,          \ Operator number
4489: 0000:         TSF.TRANSNUM$,          \ Most recent transaction
4490: 0000:         TSF.RCPSTATUS$,         \ Store close requested through RCF                                                             
4491: 0000:         TSF.SIGN.OFF.DELAY$,    \ 1 byte PD counter to auto sign off    \  !CSWM
4492: 0000:         TSF.USER$,              \ User data
4493: 0000:         TSF.CONTROLLER$,        \ Controller ID
4494: 0000:         TSF.INVDUE.DATE$,       \ Creation date of the INVDUE
4495: 0000:                                 \ (Updated by PSS33)                    \   !GJT
4496: 0000:         TSF.SPACE$              ! 34 bytes or 14 bytes
4497: 0000: 
4498: 0000:     INTEGER*1 GLOBAL            \
4499: 0000:         TSF.INDICAT0%,          \ Indicator byte 0
4500: 0000:         TSF.INDICAT1%,          \ Indicator byte 1
4501: 0000: \       TSF.INDICAT2%,          \ Indicator byte 2                      \   !HMW
4502: 0000:         TSF.MTSL.CUT.OFF%,      \ MTSL cut-off required flag            \  !CSWM
4503: 0000:         TSF.CUSTD.CUT.OFF%,     \ CUSTD cut-off required flag           \  !CSWM
4504: 0000:         TSF.ACSAL.CUT.OFF%,     \ ACSAL cut-off required flag               !DRD
4505: 0000:         TSF.TILLBAG.CUT.OFF%    ! TILLBAG cut-off required flag             !EAH
4506: 0000:     
4507: 0000:     INTEGER*2 GLOBAL            \
4508: 0000: \       TSF.SC.LEVEL%           ! Smartcard software level              \   !HMW
4509: 0000:         TSF.INDICAT2%           ! Indicator flags 2                         !HMW
4510: 0000: 
4511: 0000:     INTEGER*4 GLOBAL            \
4512: 0000:         TSF.GROSSPOS,           \ Gross plus
4513: 0000:         TSF.GROSSNEG,           \ Gross minus
4514: 0000:         TSF.NETCASH,            \ Net cash
4515: 0000:         TSF.NETNCASH,           \ Net non-cash
4516: 0000:         TSF.AMTLOAN,            \ Loans
4517: 0000:         TSF.AMTPICKU,           \ Withdrawals
4518: 0000:         TSF.AMTCASHC,           \ Cash count
4519: 0000:         TSF.NETCCURR,           \ Net cash currency face value
4520: 0000:         TSF.NETCCCURR           ! Net cash count currency face value
4521: 0000: 
4522: 0000:  %INCLUDE LOCALDEC.J86                    ! 2.1JAS
4523: 0000: \***********************************************************************
4524: 0000: \***********************************************************************
4525: 0000: \***
4526: 0000: \***    DESCRIPTION: Local Price File
4527: 0000: \***                 Field Definitions
4528: 0000: \***
4529: 0000: \***    FILE TYPE : Keyed
4530: 0000: \***
4531: 0000: \***********************************************************************
4532: 0000: \***
4533: 0000: \***    Version A.          Paul Flanagan                1st Jul 1993
4534: 0000: \***    Initial version.
4535: 0000: \***
4536: 0000: \***    Version B.          Clive Norris                24th Nov 1993
4537: 0000: \***    AUTH.NUM$, STOCK.FIG$ and RETRIEVAL.FLAG$ replaced filler as
4538: 0000: \***    part of the RETURNS/AUTOMATIC CREDIT CLAIMING package.
4539: 0000: \***
4540: 0000: \***    Version C.          Mick Bayliss                 6th Dec 1994
4541: 0000: \***    Added missing field.
4542: 0000: \***
4543: 0000: \***    Version D.          Mark Walker                  1st Jul 2015
4544: 0000: \***    F392 Retail Stock 5
4545: 0000: \***    Added key length field.
4546: 0000: \***
4547: 0000: \***********************************************************************
4548: 0000: \***********************************************************************
4549: 0000: 
4550: 0000:     STRING GLOBAL             \
4551: 0000:         LOCAL.AUTH.NUM$,      \ 4 bytes UPD Auth'n number
4552: 0000:                               \             from Business Centre.
4553: 0000:         LOCAL.END.DATE$,      \ 3 bytes UPD yymmdd.
4554: 0000:         LOCAL.FILE.NAME$,     \
4555: 0000:         LOCAL.H.O.PRICE$,     \ 5 byte UPD.
4556: 0000:         LOCAL.HO.CHANGE$,     \ 3 bytes UPD. Date of HO price change
4557: 0000:                               \ (this will be zero if no change since
4558: 0000:                               \ local price was initiated).
4559: 0000:         LOCAL.ITEM.CODE$,     \ 4 bytes UPD (key) Boots code 
4560: 0000:                               \                   with check digit. 
4561: 0000:         LOCAL.OPERATOR$,      \ 4 bytes UPD operator id (when set up).
4562: 0000:         LOCAL.PRICE$,         \ 5 bytes UPD.
4563: 0000:         LOCAL.REASON$,        \ 4 byte ASCII 
4564: 0000:         LOCAL.RETRIEVAL.FLAG$,\ 1 byte ASC "Y" or "N"  
4565: 0000:         LOCAL.SPACE$,         \                                            !CMJB
4566: 0000:         LOCAL.START.DATE$,    \ 3 bytes UPD yymmdd. 
4567: 0000:         LOCAL.START.TIME$     ! 2 bytes UPD hhmm.
4568: 0000:         
4569: 0000:     INTEGER*2 GLOBAL          \
4570: 0000:         LOCAL.KEYL%,          \                                             !DMW
4571: 0000:         LOCAL.RECL%,          \
4572: 0000:         LOCAL.REPORT.NUM%,    \
4573: 0000:         LOCAL.SESS.NUM%,      \
4574: 0000:         LOCAL.STOCK.FIG%      !  No. of items authorised at the price.
4575: 0000: 
4576: 0000:  %INCLUDE CCREJDEC.J86                    ! 1.2JAS
4577: 0000: REM \
4578: 0000: \******************************************************************************
4579: 0000: \******************************************************************************
4580: 0000: \***
4581: 0000: \***      %INCLUDE FOR CREDIT CLAIMING REJECT FILE FIELD DECLARATIONS
4582: 0000: \***                                          FILE REFERENCE PARAMETERS
4583: 0000: \***
4584: 0000: \***               FILE TYPE    : Sequential
4585: 0000: \***
4586: 0000: \***               REFERENCE    : CCREJDEC.J86
4587: 0000: \***
4588: 0000: \***      Version A.     Julia Stones           11th March 2004.
4589: 0000: \***
4590: 0000: \******************************************************************************
4591: 0000: \*******************************************************************************
4592: 0000: \***
4593: 0000: \***
4594: 0000: \***
4595: 0000: \******************************************************************************
4596: 0000: 
4597: 0000:   STRING GLOBAL              \
4598: 0000:     CCREJ.FILE.NAME$,        \
4599: 0000:     CCREJC.FILE.NAME$,       \
4600: 0000:     CCREJP.FILE.NAME$,       \
4601: 0000:     CCREJ.RECORD$,           \ Used to store the whole record which is unstrung
4602: 0000:                              \ into the fields below
4603: 0000:     CCREJ.ENDREC.MARKER$,    \ 2 bytes ASCII set to XODOA
4604: 0000:     CCREJ.DATE$,             \ 8 byte ASCII
4605: 0000:     CCREJ.RETURN.REASON$,    \ 2 byte ASCII
4606: 0000:     CCREJ.BC.LETTER$,        \ 1 byte ASCII
4607: 0000:     CCREJ.UOD.NUM$,          \ 14 byte ASCII
4608: 0000:     CCREJ.ITEM.BARCODE.FLAG$,\ 1 byte ASC;  "I" = Boots item code,
4609: 0000:               \                             "B" = Barcode.
4610: 0000:     CCREJ.ITEM.BARCODE$,     \ 12 byte ASCII
4611: 0000:     CCREJ.DESC$,             \ 24 byte ASCII
4612: 0000:     CCREJ.ITEM.BC$,          \ 1 byte ASCII
4613: 0000:     CCREJ.ITEM.QTY$,         \ 4 byte ASCII
4614: 0000:     CCREJ.REJECT.REASON$     ! 1 byte ASCII "1" = Item not on file
4615: 0000:                              !              "2" = Credit Claim not allowed against this
4616: 0000:                              !                    Business Centre
4617: 0000:                              !              "3" = Item does not belong to Business Centre
4618: 0000:                              !                    being claimed against
4619: 0000: 
4620: 0000: 
4621: 0000:   INTEGER*2 GLOBAL           \
4622: 0000:     CCREJ.RECL%,             \
4623: 0000:     CCREJC.RECL%,            \
4624: 0000:     CCREJP.RECL%,            \
4625: 0000:     CCREJC.SESS.NUM%,        \
4626: 0000:     CCREJP.SESS.NUM%,        \
4627: 0000:     CCREJ.SESS.NUM%,         \
4628: 0000:     CCREJC.REPORT.NUM%,      \
4629: 0000:     CCREJP.REPORT.NUM%,      \
4630: 0000:     CCREJ.REPORT.NUM%
4631: 0000: 
4632: 0000: 
4633: 0000:  %INCLUDE RBDEC.J86                       ! 2.6BG
4634: 0000: \/******************************************************************/
4635: 0000: \/*                                                                */
4636: 0000: \/* Recalls Buffer FILE GLOBAL VARIABLE DECLARATIONS               */
4637: 0000: \/*                                                                */
4638: 0000: \/* REFERENCE   : RBDEC.J86                                        */
4639: 0000: \/*                                                                */
4640: 0000: \/* VERSION A.          Brian Greenfield        11th may 2007      */
4641: 0000: \/*                                                                */
4642: 0000: \/******************************************************************/
4643: 0000: 
4644: 0000:    STRING GLOBAL                \
4645: 0000:       RB.FILE.NAME$,            \
4646: 0000:                                 \
4647: 0000:       RB.RCD$,                  \  ? bytes  (25/14/12)
4648: 0000:       RB.REC.TYPE$,             \  1 byte   (H/D/T)
4649: 0000:       RB.REFERENCE$,            \  8 bytes
4650: 0000:       RB.LABEL$,                \ 14 bytes (8 bytes label type)
4651: 0000:                                 \          (6 bytes label number)
4652: 0000:       RB.ITEM.CODE$,            \  7 bytes (with check digit)
4653: 0000:       RB.STOCK.COUNT$,          \  4 bytes (1 - 9999)
4654: 0000:       RB.ITEM.COUNT$,           \  5 bytes (1 - 99999)
4655: 0000:       RB.RECORD.COUNT$          !  4 bytes (1 - 9999 inc header and trailer)
4656: 0000: 
4657: 0000:    INTEGER*2 GLOBAL             \
4658: 0000:       RB.REPORT.NUM%,           \
4659: 0000:       RB.SESS.NUM%              !
4660: 0000: 
4661: 0000: \/******************************************************************/
4662: 0000:  %INCLUDE REWKFDEC.J86                    ! 2.6BG
4663: 0000: \/******************************************************************/
4664: 0000: \/*                                                                */
4665: 0000: \/* Recalls Work FILE GLOBAL VARIABLE DECLARATIONS                 */
4666: 0000: \/*                                                                */
4667: 0000: \/* REFERENCE   : REWKFDEC.J86                                     */
4668: 0000: \/*                                                                */
4669: 0000: \/* VERSION A.          Brian Greenfield        11th may 2007      */
4670: 0000: \/*                                                                */
4671: 0000: \/* VERSION B.          Brian Greenfield        15th April 2008    */
4672: 0000: \/*                                                                */
4673: 0000: \/* VERSION C.          Brian Greenfield        6th May 2008       */
4674: 0000: \/*                                                                */
4675: 0000: \/******************************************************************/
4676: 0000: 
4677: 0000:    STRING GLOBAL                \
4678: 0000:       REWKF.FILE.NAME$,         \
4679: 0000:                                 \
4680: 0000:       REWKF.RCD$,               \  ? bytes  (25/47/8)
4681: 0000:       REWKF.REC.TYPE$,          \  1 byte   (H/D/T)
4682: 0000:       REWKF.REFERENCE$,         \  8 bytes
4683: 0000:       REWKF.LABEL$,             \ 14 bytes (8 bytes label type)
4684: 0000:                                 \          (6 bytes label number - zero's)
4685: 0000:       REWKF.BATCH.TYPE$,        \  1 byte  (E/F/R/S/W/X/I/C) !BBG
4686: 0000:       REWKF.MRQ$,               \  2 bytes ASCII !CBG
4687: 0000:       REWKF.DUE.BY.DATE$,       \  8 bytes (YYYYMMDD) !BBG
4688: 0000:       REWKF.BARCODE$,           \ 13 bytes (with check digit)
4689: 0000:       REWKF.ITEM.CODE$,         \  7 bytes (with check digit)
4690: 0000:       REWKF.DESCRIPTION$,       \ 20 bytes (truncated from the IDF)
4691: 0000:       REWKF.TSF$,               \  4 bytes (1 - 9999 or SPACES for recall types F, S, & X)
4692: 0000:       REWKF.ITEM.COUNT$         !  5 bytes (1 - 99999)
4693: 0000:       
4694: 0000:    INTEGER*2 GLOBAL             \
4695: 0000:       REWKF.REPORT.NUM%,        \
4696: 0000:       REWKF.SESS.NUM%           !
4697: 0000: 
4698: 0000: \/******************************************************************/
4699: 0000:  %INCLUDE RECALDEC.J86                    ! 2.6BG
4700: 0000: \******************************************************************************
4701: 0000: \******************************************************************************
4702: 0000: \***
4703: 0000: \***         INCLUDE FOR RECALLS.BIN DECLARATIONS
4704: 0000: \***
4705: 0000: \***               FILE TYPE    : Keyed
4706: 0000: \***
4707: 0000: \***               REFERENCE    : RECALDEC.J86
4708: 0000: \***
4709: 0000: \***    VERSION A               BRIAN GREENFIELD                    14th May 2007
4710: 0000: \***    Initial Version
4711: 0000: \***
4712: 0000: \***    Version B               BRIAN GREENFIELD                    20th June 2007
4713: 0000: \***    Altered due to a change in the file layout.
4714: 0000: \***
4715: 0000: \*******************************************************************************
4716: 0000: \*******************************************************************************
4717: 0000: 
4718: 0000:   STRING GLOBAL                \
4719: 0000:     RECALLS.FILE.NAME$,        \
4720: 0000:                                \
4721: 0000:     RECALLS.REFERENCE$,        \ 8 bytes UPD  - Key is reference + RECALLS.CHAIN%
4722: 0000:     RECALLS.TYPE$,             \ 1 byte  ASC  - E = Emergency
4723: 0000:                                \                F = Batch Emergency
4724: 0000:                                \                G = generic items not authorised for sale
4725: 0000:                                \                R = 100% Returns
4726: 0000:                                \                S = Batch 100% Returns
4727: 0000:                                \                W = Withdrawn
4728: 0000:                                \                X = batch Withdrawn
4729: 0000:     RECALLS.DESCRIPTION$,      \ 20 bytes ASC
4730: 0000:     RECALLS.LABEL.TYPE$,       \ 8 bytes ASC
4731: 0000:     RECALLS.SUPPLY.ROUTE$,     \ 1 byte ASC
4732: 0000:     RECALLS.REASON.CODE$,      \ 1 byte ASC
4733: 0000:     RECALLS.BC$,               \ 1 byte ASC
4734: 0000:     RECALLS.ACTIVE.DATE$,      \ 8 bytes ASC  - YYYYMMDD
4735: 0000:     RECALLS.DUE.BY.DATE$,      \ 8 bytes ASC  - YYYYMMDD
4736: 0000:     RECALLS.COMPLETION.DATE$,  \ 8 bytes ASC  - YYYYMMDD
4737: 0000:     RECALLS.STATUS$,           \ 1 byte ASC   - N = Not Actioned, A = Actioned, P = Partially Actioned
4738: 0000:     RECALLS.BATCH.NUM$,        \ 30 bytes ASC
4739: 0000:     RECALLS.ITEM.COUNT$,       \ 4 bytes ASC  - Total count of items in this recall
4740: 0000:                                \
4741: 0000:                                \ The following 8 bytes are repeated for the number of items in this part
4742: 0000:                                \ of the recall chain - up to 50 items per chain.
4743: 0000:     RECALLS.ITEM.CODE$(1),     \ 4 bytes PD   - 6 digit Item Code
4744: 0000:     RECALLS.ITEM.STOCK$(1),    \ 2 bytes PD   - SPACES if not yet actioned                         !BBG
4745: 0000:     RECALLS.SESS.STOCK$(1),    \ 2 bytes PD   - 4 digit session stock count - used only by the PPC !BBG
4746: 0000:     RECALLS.ITEM.UPT.FLAG$(1), \ 1 byte ASC   - used by the PPC only - Y = actioned, N - reset, space = unactioned
4747: 0000:                                \
4748: 0000:     RECALLS.FILLER$            !
4749: 0000:     
4750: 0000:   INTEGER*1 GLOBAL             \
4751: 0000:     RECALLS.CHAIN%
4752: 0000:     
4753: 0000:   INTEGER*2 GLOBAL             \
4754: 0000:     RECALLS.RECL%,             \
4755: 0000:     RECALLS.KEYL%,             \
4756: 0000:     RECALLS.REPORT.NUM%,       \
4757: 0000:     RECALLS.SESS.NUM%,         \
4758: 0000:     RECALLS.MAX.REC.ITEMS%
4759: 0000: 
4760: 0000: 
4761: 0000:  %INCLUDE DELVIDEC.J86                    ! 2.7SH
4762: 0000: \/******************************************************************/
4763: 0000: \/*                                                                */
4764: 0000: \/* DELVINDX FILE GLOBAl VARIABLE DECLARATIONS                     */
4765: 0000: \/*                                                                */
4766: 0000: \/* REFERENCE   : DELVIDEC.J86                                     */
4767: 0000: \/*                                                                */
4768: 0000: \/* VERSION A.          Stuart Highley              14 July 2008   */
4769: 0000: \/*                                                                */
4770: 0000: \/* VERSION B.          Stuart Highley               18 Dec 2008   */
4771: 0000: \/* Make file fixed rec length.                                    */
4772: 0000: \/******************************************************************/
4773: 0000: 
4774: 0000:    STRING GLOBAL                    \
4775: 0000:       DELVINDX.FILE.NAME$,          \
4776: 0000:       DELVINDX.FILLER$,             \
4777: 0000:       DELVINDX.ASN.NUM$,            \
4778: 0000:       DELVINDX.ASN.CARTON.COUNT$,   \
4779: 0000:       DELVINDX.UOD.LICENCE$,        \
4780: 0000:       DELVINDX.UOD.DESPATCH.DATE$,  \
4781: 0000:       DELVINDX.UOD.BOL.FLAG$,       \
4782: 0000:       DELVINDX.UOD.SEQ$,            \
4783: 0000:       DELVINDX.UOD.PARENT$,         \
4784: 0000:       DELVINDX.UOD.TYPE$,           \
4785: 0000:       DELVINDX.UOD.EXP.DEL.DATE$
4786: 0000: 
4787: 0000:    INTEGER*2 GLOBAL             \
4788: 0000:       DELVINDX.REPORT.NUM%,     \
4789: 0000:       DELVINDX.SESS.NUM%
4790: 0000: 
4791: 0000: \/******************************************************************/
4792: 0000:  %INCLUDE UODOTDEC.J86                    ! 2.7SH
4793: 0000: \*******************************************************************************
4794: 0000: \***
4795: 0000: \***    UOD Outers FILE GLOBAl VARIABLE DECLARATIONS
4796: 0000: \***
4797: 0000: \***    REFERENCE   : UODOTDEC.J86
4798: 0000: \***
4799: 0000: \***    VERSION A.              Stuart Highley                  14th Jul 2008
4800: 0000: \***
4801: 0000: \***    VERSION B.              Mark Goode                      10th Dec 2008
4802: 0000: \***    Add summary record read/write functionality.
4803: 0000: \***
4804: 0000: \***    REVISION 1.8.           Robert Cowey                    14th Jan 2009
4805: 0000: \***    Changes for 10A PosUOD fixes creating SSC04.286 Rv 1.3.
4806: 0000: \***    No new variables but defined new function UODOT.REC$.
4807: 0000: \***
4808: 0000: \***    VERSION C.              Mark Walker                     18th Feb 2015
4809: 0000: \***    F391 HUMSS UOD Messaging
4810: 0000: \***    Includes the following changes:
4811: 0000: \***    - Defined UOD number field.
4812: 0000: \***    - Various coding standards related changes (uncommented).
4813: 0000: \***
4814: 0000: \*******************************************************************************
4815: 0000: 
4816: 0000:     STRING GLOBAL                                                       \
4817: 0000:         UODOT.AUDIT.OP.ID$,                                             \
4818: 0000:         UODOT.BOOKED.DATE$,                                             \
4819: 0000:         UODOT.BOOKED.TIME$,                                             \
4820: 0000:         UODOT.CHILD.LICENCE$(1),                                        \
4821: 0000:         UODOT.CHILD.TYPE$(1),                                           \
4822: 0000:         UODOT.DESPATCH.DATE$,                                           \
4823: 0000:         UODOT.DRVR.DEL.DATE$,                                           \
4824: 0000:         UODOT.DRVR.DEL.TIME$,                                           \
4825: 0000:         UODOT.DRVR.ID$,                                                 \
4826: 0000:         UODOT.EST.DEL.DATE$,                                            \
4827: 0000:         UODOT.FILE.NAME$,                                               \
4828: 0000:         UODOT.FILLER$,                                                  \
4829: 0000:         UODOT.IMMEDIATE.PARENT$,                                        \
4830: 0000:         UODOT.LEVEL$,                                                   \
4831: 0000:         UODOT.LICENCE$,                                                 \
4832: 0000:         UODOT.OPEN.FLAG$,                                               \
4833: 0000:         UODOT.REASON$,                                                  \
4834: 0000:         UODOT.STATUS$,                                                  \
4835: 0000:         UODOT.STORE.OP.ID$,                                             \
4836: 0000:         UODOT.SUMMARY.STATUS$,                                          \   !BMG
4837: 0000:         UODOT.TYPE$,                                                    \
4838: 0000:         UODOT.ULTIMATE.PARENT$,                                         \
4839: 0000:         UODOT.UOD.NUMBER$,                                              \   !CMW
4840: 0000:         UODOT.WAREHOUSE.AREA$
4841: 0000: 
4842: 0000:     INTEGER*1 GLOBAL                                                    \
4843: 0000:         UODOT.BOL,                                                      \
4844: 0000:         UODOT.SDPD
4845: 0000: 
4846: 0000:     INTEGER*2 GLOBAL                                                    \
4847: 0000:         UODOT.AUDITED,                                                  \
4848: 0000:         UODOT.AUTO,                                                     \
4849: 0000:         UODOT.BOOKED,                                                   \
4850: 0000:         UODOT.CONTROLLER,                                               \
4851: 0000:         UODOT.GIT.MISMATCH,                                             \
4852: 0000:         UODOT.KEYL%,                                                    \
4853: 0000:         UODOT.MAX.CHILDREN%,                                            \
4854: 0000:         UODOT.MC70,                                                     \
4855: 0000:         UODOT.NUM.CHILDREN%,                                            \
4856: 0000:         UODOT.NUM.ITEMS%,                                               \
4857: 0000:         UODOT.PARTIAL,                                                  \
4858: 0000:         UODOT.PDT,                                                      \
4859: 0000:         UODOT.RECL%,                                                    \
4860: 0000:         UODOT.REPORT.NUM%,                                              \
4861: 0000:         UODOT.RF,                                                       \
4862: 0000:         UODOT.SEQ%,                                                     \
4863: 0000:         UODOT.SESS.NUM%,                                                \
4864: 0000:         UODOT.STOCK.UPDATED
4865: 0000: 
4866: 0000:  %INCLUDE AFDEC.J86                       ! 2.7SH
4867: 0000: 
4868: 0000: \REM
4869: 0000: \*******************************************************************************
4870: 0000: \*******************************************************************************
4871: 0000: \***
4872: 0000: \***    %INCLUDE FOR GSA AUTHORISATION FILE VARIABLE DECLARATIONS
4873: 0000: \***
4874: 0000: \***        REFERENCE   :  AFDEC (J86)
4875: 0000: \***
4876: 0000: \***        FILE TYPE   :  Keyed
4877: 0000: \***
4878: 0000: \***    The GSA Authorisation File (EALAUTH.DAT) should not be confused with
4879: 0000: \***    the Operating System Authorisation File (ADXCSOUF.DAT).
4880: 0000: \***
4881: 0000: \***    VERSION A.              ROBERT COWEY.                       18 AUG 1992.
4882: 0000: \***    Original version created by merging AFFLDD and AFNUMD.
4883: 0000: \***
4884: 0000: \***    VERSION B.              Steve Windsor                          Nov 1992.
4885: 0000: \***    Addition of new fields for the CASTLE project.
4886: 0000: \***    Supervisor flag and operator model.
4887: 0000: \***
4888: 0000: \***    VERSION C.              ROBERT COWEY.                       03 MAR 1994.
4889: 0000: \***    Defined fields DATE.PSWD.CHANGE$, and MODEL.FLAGS.1% and ...2%.
4890: 0000: \***
4891: 0000: \***    VERSION D.             Mike Bishop                          30 JUN 2004
4892: 0000: \***    Defined field AF.STAFF.NUM$ AF.EMPLOYEE.FLAG$
4893: 0000: \***
4894: 0000: \***    VERSION E.             Alan Carr  (AJC)                      4 Oct 2004
4895: 0000: \***    Defined field AF.RECEIPT.NAME$
4896: 0000: \***
4897: 0000: \***    VERSION F.             Alan Carr  (AJC)                     31 Jan 2005
4898: 0000: \***    Defined field AF.GROUP.CODE$
4899: 0000: \***
4900: 0000: \***    REVISION 1.6.                ROBERT COWEY.                15 JUN 2009.
4901: 0000: \***    Changes for A9C POS improvements project.
4902: 0000: \***    Used up last available three bytes of EALAUTH user data by redefining 
4903: 0000: \***    remaining AF.USER$ variable as AF.BIRTH.DATE$.
4904: 0000: \***    See IBM manual "GSA Programming Guide" Appendix A-27 for file layout 
4905: 0000: \***    describing INDICAT flags (and position of original 20 bytes user data).
4906: 0000: \***
4907: 0000: \***    REVISION 1.7.                ROBERT COWEY.                22 JUN 2009.
4908: 0000: \***    Changes for A9C POS improvements project creating PSB99.286 Rv 1.8.
4909: 0000: \***    Defect 3247 - Redefined AF.BIRTH.DATE$ format as UPD-hex DDMCYY.
4910: 0000: \***    Description text change only - No code changes to this file.
4911: 0000: \***
4912: 0000: \*******************************************************************************
4913: 0000: \*******************************************************************************
4914: 0000: 
4915: 0000: 
4916: 0000:     STRING GLOBAL \
4917: 0000:         AF.BIRTH.DATE$,       \ ! 3 byte DDMCYY UPD/hex format         ! 1.7 RC
4918: 0000:                               \ ! M is month  A=Oct B=Nov C=Dec        ! 1.7 RC
4919: 0000:                               \ ! C is century  0=19xx 1=20xx          ! 1.7 RC
4920: 0000:         AF.DATE.PSWD.CHANGE$, \ ! 3 bytes UPD                          ! CRC
4921: 0000:         AF.FILE.NAME$, \
4922: 0000:         AF.FLAGS.01.12$, \      ! 15 bytes
4923: 0000:         AF.FLAGS.13.16$, \      ! 4 bytes
4924: 0000:         AF.OPERATOR.NAME$,\     ! 20 bytes
4925: 0000:         AF.OPERATOR.NO$, \      ! 4 byte UPD (key)
4926: 0000:         AF.OPTIONS.KEY$, \      ! 1 byte UPD
4927: 0000:         AF.PASSWORD$, \         ! 4 byte UPD
4928: 0000:         AF.RECEIPT.NAME$, \     ! 12 bytes                             ! AJC
4929: 0000:         AF.STAFF.NUM$, \         ! 4 byte UPD                          DMB
4930: 0000:         AF.EMPLOYEE.FLAG$, \     ! 1 byte UPD                          DMB
4931: 0000:         AF.GROUP.CODE$, \       ! 1  byte UPD                          AJC
4932: 0000: \       AF.USER$, \             ! 3  bytes                             ! 1.6 RC
4933: 0000:         AF.SUP.FLAG$, \         ! 1  byte                              BSJW
4934: 0000:         AF.OP.MODEL$            ! 3  bytes                             BSJW
4935: 0000: 
4936: 0000:     INTEGER*1 GLOBAL \
4937: 0000:         AF.INDICAT4%, \
4938: 0000:         AF.INDICAT5%, \
4939: 0000:         AF.INDICAT6%, \
4940: 0000:         AF.INDICAT7%, \
4941: 0000:         AF.INDICAT8%, \
4942: 0000:         AF.INDICAT9%, \
4943: 0000:         AF.INDICAT10%, \
4944: 0000:         AF.INDICAT11%, \
4945: 0000:         AF.INDICAT12%, \
4946: 0000:         AF.INDICAT13%, \
4947: 0000:         AF.INDICAT14%, \
4948: 0000:         AF.INDICAT15%, \
4949: 0000:         AF.INDICAT16%, \
4950: 0000:         AF.REPORT.NUM%
4951: 0000: 
4952: 0000:     INTEGER*2 GLOBAL \
4953: 0000:         AF.INDICAT1%, \
4954: 0000:         AF.INDICAT2%, \
4955: 0000:         AF.INDICAT3%, \
4956: 0000:         AF.MODEL.FLAGS.1%, \                                           ! CRC
4957: 0000:         AF.MODEL.FLAGS.2%, \                                           ! CRC
4958: 0000:         AF.RECL%, \
4959: 0000:         AF.SESS.NUM%
4960: 0000: 
4961: 0000:  %INCLUDE UBDEC.J86                       ! 2.7SH
4962: 0000: \/******************************************************************/
4963: 0000: \/*                                                                */
4964: 0000: \/* UOD Banked FILE GLOBAL VARIABLE DECLARATIONS                   */
4965: 0000: \/*                                                                */
4966: 0000: \/* REFERENCE   : UBDEC.J86                                        */
4967: 0000: \/*                                                                */
4968: 0000: \/* VERSION A.          Stuart Highley            14 August 2008   */
4969: 0000: \/                                                                 */
4970: 0000: \/* VERSION B.          Charles Skadorwa          9 October 2008   */
4971: 0000: \/*                                                                */
4972: 0000: \/* VERSION C.          Stuart Highley            16 December 2008 */
4973: 0000: \/* Look carefully below and ye shall find my change.              */
4974: 0000: \/*                                                                */
4975: 0000: \/* VERSION D.          Mark Goode                22nd December 08 */
4976: 0000: \/* Changes to the fields on the audit record                      */
4977: 0000: \/******************************************************************/
4978: 0000: 
4979: 0000:    STRING GLOBAL                \
4980: 0000:       UB.TEMP.NAME$,            \
4981: 0000:       UB.FILE.NAME$,            \
4982: 0000:       UB.REC$,                  \
4983: 0000:       UB.REC.TYPE$,             \
4984: 0000:       UB.OP.ID$,                \
4985: 0000:       UB.METHOD$,               \
4986: 0000:       UB.REPORT.RQD$,           \
4987: 0000:       UB.LICENCE$,              \
4988: 0000:       UB.DESPATCH.DATE$,        \
4989: 0000:       UB.BOOKED.DATE$,          \
4990: 0000:       UB.BOOKED.TIME$,          \
4991: 0000:       UB.BOOK.TYPE$,            \
4992: 0000:       UB.BAR.CODE$,             \
4993: 0000:       UB.QTY$,                  \
4994: 0000:       UB.DRVR.ID$,              \
4995: 0000:       UB.DRVR.CHCK.DATE$,       \
4996: 0000:       UB.DRVR.CHCK.TIME$,       \
4997: 0000:       UB.DRVR.GIT.MATCH$,       \
4998: 0000:       UB.REC.COUNT$,            \
4999: 0000:       UB.ONIGHT.DELIVERY.TYPE$, \                                !BCSk
5000: 0000:       UB.DRIVER.CHECKIN.REQD$,  \                                !BCSk
5001: 0000:       UB.DRVR.REJECTED$,        \ "Y" or "N" on batch rec,       !CSH
5002: 0000:                                 \ " " on session rec             !CSH
5003: 0000:       UB.DRVR.CONFIRM.SCAN$,    \                                !BCSk
5004: 0000:       UB.BOOKED.STATUS$                                          !DMG
5005: 0000:       
5006: 0000:    INTEGER*2 GLOBAL             \
5007: 0000:       UB.RECL%,                 \
5008: 0000:       UB.REPORT.NUM%,           \
5009: 0000:       UB.SESS.NUM%
5010: 0000: 
5011: 0000: \/******************************************************************/
5012: 0000:  
5013: 0000: \*****************************************************************************
5014: 0000: \*****************************************************************************
5015: 0000: \***                                                                       ***
5016: 0000: \***      V A R I A B L E   D E C L A R A T I O N S                        ***
5017: 0000: \***                                                                       ***
5018: 0000: \*****************************************************************************
5019: 0000: \*****************************************************************************
5020: 0000: 
5021: 0000: INTEGER*1 GLOBAL                          \
5022: 0000:         ASN.ACTIVE%,                      \ 2.5NWB
5023: 0000:         BC.CHECK%(1),                     \ FLC
5024: 0000:         ERROR.COUNT%,                     \
5025: 0000:         REC.MAX%,                         \
5026: 0000:         LDT.TRANSMIT,                     \ HDS
5027: 0000:         NESTING.LEVEL%,                   \ FLC
5028: 0000:         TRUE,                             \ HDS
5029: 0000:         FALSE,                            \ HDS
5030: 0000:         PORT.EVENT%,                      \ FLC
5031: 0000:         RE.CHAIN,                         \ DSW
5032: 0000:         WARM.START,                       \ DSW
5033: 0000:         GAP,                              \ GMJK
5034: 0000:         CCBUF.ENTRY.REQUIRED,             \ GMJK
5035: 0000:         CCBUF.RECS.PRESENT,               \ GMJK
5036: 0000:         CCREJ.RECS.PRESENT,               \ 2.2JAS
5037: 0000:         DETAIL.RECORDS.RECEIVED,          \ GMJK
5038: 0000:         END.OF.CCTMP,                     \ GMJK
5039: 0000:         END.OF.FILE,                      \ GMJK
5040: 0000:         TABLE.FULL,                       \ GMJK
5041: 0000:         REWKF.RECS.PRESENT,               \ 2.6BG
5042: 0000:         ALL.PRODUCTS                      ! 1.8DA
5043: 0000: \       ALLOW.CSR.PROCESSING              ! 1.2 !2.5NWB
5044: 0000: 
5045: 0000: INTEGER*2 GLOBAL                          \
5046: 0000:         ACTUAL.NUM.OF.UODS%,              \ FLC
5047: 0000:         BTSCNT%,                          \2.3CS
5048: 0000:         EANCNT%,                          \2.3CS
5049: 0000:         COUNTED.ITEMS%,                   \ FLC
5050: 0000: \       CSR.ITEMS.COUNT%,                 \     !2.5NWB
5051: 0000:         CSR.AUDIT.SESS.NUM%,              \ CDS
5052: 0000:         CURRENT.REPORT.NUM%,              \ DLC
5053: 0000:         EXPECTED.NUM.OF.UODS%,            \ FLC
5054: 0000:         FILE.HEADER.LISTS%,               \ FLC
5055: 0000:         FILE.TRAILER.LISTS%,              \ FLC
5056: 0000:         FIRST.TIME,                       \ CDS
5057: 0000:         ORDERS.EXPECTED%,                 \ CDS
5058: 0000:         INT.DELAY%,                       \ FLC
5059: 0000:         ITEMS.BOOKED.IN%,                 \ CDS
5060: 0000:         ITEM.COUNT%,                      \ FLC
5061: 0000:         LINES.BOOKED.IN%,                 \ CDS
5062: 0000:         LINES.ADDED%,                     \ CDS
5063: 0000:         LINE.TOTAL%,                      \ CDS
5064: 0000:         LIST.COUNT%,                      \ FLC
5065: 0000:         LIST.TRAILER.ITEMS%,              \ FLC
5066: 0000:         ONORD.COUNT%,                     \
5067: 0000:         ORDERS.FOUND%,                    \ CDS
5068: 0000:         RC%,                              \ DLC
5069: 0000:         SINGLES.ADDED%,                   \ CDS
5070: 0000:         TYPE.17.WRITTEN,                  \ CDS
5071: 0000:         UOD.NUM.ITEMS%,                   \ FLC
5072: 0000:         ACTUAL.NUM%,                      \ GMJK
5073: 0000:         ACTUAL.UOD.ITEMS%,                \ GMJK
5074: 0000:         CURR.ITEM%,                       \ GMJK
5075: 0000:         CURR.REC%,                        \ GMJK
5076: 0000:         CURR.SUBSCRIPT%,                  \ GMJK
5077: 0000:         EXPECTED.NUM%,                    \ GMJK
5078: 0000:         FILE.NUM%,                        \ GMJK
5079: 0000:         ITEM.POS%,                        \ GMJK
5080: 0000:         MAX.TABLE.SIZE%,                  \ GMJK
5081: 0000:         NUM.BARCODES%,                    \ GMJK
5082: 0000:         NUM.BC.EXTRACTED%,                \ GMJK
5083: 0000:         NUM.ITEMS%,                       \ GMJK
5084: 0000:         NUM.STATUS.O.C.X.UODS%,           \ 1.4
5085: 0000:         NUM.OF.CANCELLED.UODS%,           \ 1.4
5086: 0000:         NUM.OF.DESPATCHED.UODS%,          \ 1.4
5087: 0000:         NUM.RECORDS%,                     \ GMJK
5088: 0000:         RECORD$,                          \ GMJK
5089: 0000:         REC.NUM%,                         \ GMJK
5090: 0000:         RECS.PER.SECTOR%,                 \ GMJK
5091: 0000:         BC%,CG%,PG%,                      \ 1.8DA
5092: 0000:         SECTOR%                           ! GMJK
5093: 0000: 
5094: 0000: INTEGER*4 GLOBAL                          \
5095: 0000:         LAST.ACTIVE%,                     \
5096: 0000:         LAST.STOCKTAKE%,                  \ 1.5
5097: 0000:         TIMEOUT.VALUE%                    ! FLC
5098: 0000: 
5099: 0000: 
5100: 0000: STRING GLOBAL                             \ for modules 00, 01 , 02 , 03 and 04
5101: 0000:         ACK$,                             \ 1.5
5102: 0000:         ALL.FILES.CLOSED$,                \
5103: 0000:         APPL$,                            \ FLC
5104: 0000:         APPLICATION.NO$,                  \
5105: 0000:         BAR.CODES$(1),                    \ FLC
5106: 0000:         BCSMF.RECORD$,                    \ GMJK
5107: 0000:         BOOKING.STARTED$,                 \ CDS
5108: 0000:         BOOKING.ENDED$,                   \ CDS
5109: 0000:         CCUOD.OPEN.FLAG$,                 \ GMJK
5110: 0000:         CCLAM.OPEN.FLAG$,                 \ 1.4
5111: 0000:         CCITM.OPEN.FLAG$,                 \ GMJK
5112: 0000:         CCTRL.OPEN.FLAG$,                 \ GMJK
5113: 0000:         CCDMY.OPEN.FLAG$,                 \ GMJK
5114: 0000:         CCTMP.OPEN.FLAG$,                 \ GMJK
5115: 0000:         CCBUF.OPEN.FLAG$,                 \ GMJK
5116: 0000:         CCUPF.OPEN.FLAG$,                 \ HMJK
5117: 0000:         CCWKF.OPEN.FLAG$,                 \ GMJK
5118: 0000:         STKRC.OPEN.FLAG$,                 \ 1.8DA
5119: 0000:         XGCF.OPEN.FLAG$,                  \ 1.8DA
5120: 0000:         STKEX.OPEN.FLAG$,                 \ 1.8DA
5121: 0000:         STKIF.OPEN.FLAG$,                 \ 1.8DA
5122: 0000:         LOCCNT.OPEN.FLAG$,                \ 1.8DA
5123: 0000:         STKTF.OPEN.FLAG$,                 \ 1.8DA
5124: 0000:         STKDC.OPEN.FLAG$,                 \ 1.8DA
5125: 0000: \       CSR.LIST.ALREADY.PROCESSED.FLAG$, \ !2.5NWB
5126: 0000: \       CSR.OPEN.FLAG$,                   \ !2.5NWB
5127: 0000:         CHKBF.OPEN.FLAG$,                 \ DSW
5128: 0000:         GAPBF.OPEN.FLAG$,                 \ SDH  2.3CS !2.4BG
5129: 0000:         PLLOL.OPEN.FLAG$,                 \ 2.3CS
5130: 0000:         PLLDB.OPEN.FLAG$,                 \ 2.3CS
5131: 0000:         PLLDB.TABLE$(1),                  \ 2.3CS
5132: 0000:         EAN.TABLE$(1),                    \ 2.3CS
5133: 0000: \       CITEM.OPEN.FLAG$,                 \ !2.5NWB
5134: 0000: \       CIMF.OPEN.FLAG$,                  \ !2.5NWB
5135: 0000: \       CSRWF.OPEN.FLAG$,                 \ !2.5NWB
5136: 0000: \       CSRBF.OPEN.FLAG$,                 \ !2.5NWB
5137: 0000:         CSR.AUDIT.FILE$,                  \ CDS
5138: 0000:         CSR.AUDIT.DATA$,                  \ CDS
5139: 0000:         CSR.AUDIT.OPEN.FLAG$,             \ CDS
5140: 0000:         CURR.LIST$,                       \ FLC
5141: 0000:         CURR.TERMINAL$,                   \
5142: 0000:         CURRENT.CODE$,                    \ DLC
5143: 0000:         DATA.IN$,                         \
5144: 0000:         DATE.TODAY$,                      \ FLC
5145: 0000:         STKMQ.OPEN.FLAG$,                 \ CDS
5146: 0000:         STLDT.OPEN.FLAG$,                 \ 1.6
5147: 0000:         BCSMF.OPEN.FLAG$,                 \ CDS
5148: 0000:         IEF.OPEN.FLAG$,                   \ CDS
5149: 0000:         DATA.FILES.REQ$,                  \ GMJK
5150: 0000:         DETAIL.RECORDS.RECEIVED$,         \ FLC
5151: 0000:         DIREC.OPEN.FLAG$,                 \ CDS
5152: 0000:         DIRORD.OPEN.FLAG$,                \ CDS
5153: 0000:         DIRSUP.OPEN.FLAG$,                \ CDS
5154: 0000:         DIRWF.OPEN.FLAG$,                 \ CDS
5155: 0000:         EPSOM.OPEN.FLAG$,                 \ FLC
5156: 0000:         LDTAF.OPEN.FLAG$,                 \ GMJK
5157: 0000:         LDTCF.OPEN.FLAG$,                 \ CDS
5158: 0000:         DRSMQ.OPEN.FLAG$,                 \ CDS
5159: 0000:         FILE.OPERATION$,                  \ DLC
5160: 0000: \       FIRST.CSR.LIST.FOR.PDT$,          \ 2.5NWB
5161: 0000:         FIRST.EOT.FOR.THIS.PDT$,          \
5162: 0000:         FIRST.ITEM.TO.BE.PROCESSED$,      \
5163: 0000:         FIRST.RETURN$,                    \ FLC
5164: 0000:         FPF.OPEN.FLAG$,                   \
5165: 0000:         HOLD.FLAG$,                       \
5166: 0000:         IDF.OPEN.FLAG$,                   \
5167: 0000:         IDSOF.OPEN.FLAG$,                 \ ELC
5168: 0000:         IRF.OPEN.FLAG$,                   \ FLC
5169: 0000:         IMSTC.OPEN.FLAG$,                 \1.7BG
5170: 0000:         LAST.ACTIVE.DATE$,                \
5171: 0000:         LAST.STOCKTAKE.DATE$,             \ 1.5
5172: 0000:         LAST.MESSAGE$,                    \
5173: 0000:         LOG.ON.DATE$,                     \ GMJK
5174: 0000:         LOG.ON.TIME$,                     \ GMJK
5175: 0000:         LDTBF.HEADER.WRITTEN$,            \ ELC
5176: 0000:         LDTBF.OPEN.FLAG$,                 \ ELC
5177: 0000:         LIST.ABANDONED$,                  \
5178: 0000:         LIST.BC$,                         \ FLC
5179: 0000:         LIST.TRANSMIT$(1),                \ FLC
5180: 0000:         LSSST.OPEN.FLAG$,                 \1.7BG
5181: 0000:         MONITORED.PORT$,                  \ DLC
5182: 0000:         NUM.SECTOR$,                      \ GMJK
5183: 0000:         ONORD.OPEN.FLAG$,                 \
5184: 0000:         ONORD.DELETED$(1),                \
5185: 0000:         ORDER.LINE.TABLE$(1),             \ CDS
5186: 0000:         PCHK.OPEN.FLAG$,                  \
5187: 0000:         PDT.ACTION$,                      \ FLC
5188: 0000:         PIITM.OPEN.FLAG$,                 \ FLC
5189: 0000:         PILST.OPEN.FLAG$,                 \ FLC
5190: 0000:         PIPE.OUT$,                        \
5191: 0000:         PDTWF.OPEN.FLAG$,                 \ FLC
5192: 0000:         PK2$,                             \
5193: 0000:         PK4$,                             \
5194: 0000:         PORT.STRING$,                     \
5195: 0000:         PREV.LOGGED.STATE$,               \ ELC
5196: 0000: \       PROCESS.CSR.WORKFILE$,            \ !2.5NWB
5197: 0000:         PSS38.STATUS$,                    \ FLC
5198: 0000:         RB.OPEN.FLAG$,                    \ 2.6BG
5199: 0000:         REWKF.OPEN.FLAG$,                 \ 2.6BG
5200: 0000:         RECALLS.OPEN.FLAG$,               \ 2.6BG
5201: 0000:         DELVINDX.OPEN.FLAG$,              \ 2.7SH
5202: 0000:         AF.OPEN.FLAG$,                    \ 2.7SH
5203: 0000:         UB.OPEN.FLAG$,                    \ 2.7SH
5204: 0000:         RECEIVE.STATE$,                   \
5205: 0000:         REQ.LIST.STORE$(1),               \ FLC
5206: 0000:         REQ.LIST.DATA$(1),                \ FLC
5207: 0000:         SAVED.ORDER.NO$,                  \ CDS
5208: 0000:         SAVED.ORDER.SUFFIX$,              \ CDS
5209: 0000:         SAVED.PAGE.NO$,                   \ CDS
5210: 0000:         SAVED.STORE.NUMBER$,              \ 1.8DA
5211: 0000:         SAVED.SUPPLIER.NO$,               \ CDS
5212: 0000:         SECTOR$,                          \ GMJK
5213: 0000:         SOFTS.OPEN.FLAG$,                 \ GMJK
5214: 0000:         SOH$,                             \ 1.5
5215: 0000:         STORED.UOD.HEADER$,               \ FLC
5216: 0000:         STORE.NUMBER$,                    \ 1.5
5217: 0000:         STOCK.OPEN.FLAG$,                 \1.7BG
5218: 0000:         STX$,                             \ FLC
5219: 0000:         STKBF.OPEN.FLAG$,                 \ 1.5
5220: 0000:         SXTMP.OPEN.FLAG$,                 \ 1.5
5221: 0000:         T.DATE$,                          \ 1.5
5222: 0000:         T.TIME$,                          \ 1.5
5223: 0000:         TEMP.TIME$,                       \ GMJK
5224: 0000:         TRAILER.LIST$,                    \ FLC
5225: 0000:         UOD.NUMBER$,                      \ FLC
5226: 0000:         UOD.NUM.ITEMS$,                   \ FLC
5227: 0000:         UOD.OPEN.FLAG$,                   \ FLC
5228: 0000:         UOD.STATUS.FLAG$,                 \ FLC
5229: 0000:         UODBF.OPEN.FLAG$,                 \ FLC
5230: 0000:         UODTF.OPEN.FLAG$,                 \ FLC
5231: 0000:         UNITS.OPEN.FLAG$
5232: 0000: 
5233: 0000: STRING GLOBAL                             \ GMJK
5234: 0000:         ITEM.STORAGE$,                    \ GMJK
5235: 0000:         ITEM.DESC.STORAGE$,               \ GMJK
5236: 0000:         BARCODE.DATA$,                    \ GMJK
5237: 0000:         BARCODE.INDEX$,                   \ GMJK
5238: 0000:         BARCODE.INDEX.STORAGE$,           \ GMJK
5239: 0000:         BARCODE.STORAGE$,                 \ GMJK
5240: 0000:         ITEM.DATA$,                       \ GMJK
5241: 0000:         ITEM.DATA.DESC$,                  \ GMJK
5242: 0000:         ITEM.POS.TABLE$(1),               \ GMJK
5243: 0000:         CCUOD.TABLE$(1),                  \ GMJK
5244: 0000:         CCLAM.TABLE$(1),                  \ 1.4
5245: 0000:         DATA.FILES.REQUIRED$,             \ GMJK
5246: 0000:         FINISH.DATE$,                     \ GMJK
5247: 0000:         FINISH.TIME$,                     \ GMJK
5248: 0000:         LDT.CCUOD.UPDATE.DATE$,           \ GMJK
5249: 0000:         LDT.CCUOD.UPDATE.TIME$,           \ GMJK
5250: 0000:         LDT.DATE.TIME$,                   \ GMJK
5251: 0000:         LDT.LAST.CLAIM.NUM$,              \ GMJK
5252: 0000:         STKCF.OPEN.FLAG$,                 \ 1.8DA
5253: 0000:         STKMF.OPEN.FLAG$,                 \ 1.8DA
5254: 0000:         CONCEPT.GROUPS$(1),               \ 1.8DA
5255: 0000:         PRODUCT.GROUPS$(1),               \ 1.8DA
5256: 0000:         BUSINESS.CENTRES$(1),             \ ! 1.8DA 2.1JAS
5257: 0000:         SOPTS.OPEN.FLAG$,                 \ ! 2.1JAS
5258: 0000:         LOCAL.OPEN.FLAG$,                 \ ! 2.1JAS
5259: 0000:         TSF.OPEN.FLAG$,                   \ ! 2.1JAS 2.2JAS
5260: 0000:         CCREJ.OPEN.FLAG$,                 \ 2.2JAS
5261: 0000:         CREDIT.CLAIM.FLAG$                ! 2.2JAS
5262: 0000: 
5263: 0000: 
5264: 0000: STRING GLOBAL                             \
5265: 0000:         BATCH.SCREEN.FLAG$,               \
5266: 0000:         EXP.STATES$,                      \
5267: 0000:         MODULE.NUMBER$,                   \
5268: 0000:         OPERATOR.ID$,                     \
5269: 0000:         STATE$,                           \
5270: 0000:         TRANS.FROM$,                      \
5271: 0000:         TRANS.TO$
5272: 0000: 
5273: 0000:  STRING GLOBAL                            \
5274: 0000:         REC.CHECK$(1),                    \
5275: 0000:         V.TAB$(1)
5276: 0000: 
5277: 0000: \*****************************************************************************
5278: 0000: \*****************************************************************************
5279: 0000: \***                                                                       ***
5280: 0000: \*** E X T E R N A L   F U N C T I O N   D E C L A R A T I O N S           ***
5281: 0000: \***                                                                       ***
5282: 0000: \*****************************************************************************
5283: 0000: \*****************************************************************************
5284: 0000: 
5285: 0000: \*****************************************************************************
5286: 0000: \***   include external definitions for the following functions
5287: 0000: \***
5288: 0000: \***     ADXERROR
5289: 0000: \***     ADXSERVE
5290: 0000: \***     ADXSERCL
5291: 0000: \***     APPLICATION.LOG             01
5292: 0000: \***     READ.NEXT.IEF               11
5293: 0000: \***     SORT.TABLE                  14
5294: 0000: \***     CONV.TO.HEX                 16
5295: 0000: \***     CONV.TO.STRING              17
5296: 0000: \***     SESS.NUM.UTILITY            20
5297: 0000: \***     STKMQ
5298: 0000: \***     BCSMF
5299: 0000: \***     IDF
5300: 0000: \***     INVOK
5301: 0000: \***     PCHK
5302: 0000: \***     UOD
5303: 0000: \***     UODBF
5304: 0000: \***     UODTF
5305: 0000: \***     STKBF
5306: 0000: \***     SXTMP
5307: 0000: \***     SSPSC
5308: 0000: \***     BTCS
5309: 0000: \***     PRINT
5310: 0000: \***     SOPTS
5311: 0000: \***     LOCAL
5312: 0000: \***
5313: 0000: \*****************************************************************************
5314: 0000: 
5315: 0000:  %INCLUDE ADXERROR.J86
5316: 0000: \******************************************************************************
5317: 0000: \******************************************************************************
5318: 0000: \***                                                                        ***
5319: 0000: \***    %INCLUDE FOR FUNCTION ADXERROR (an I.B.M. system function)          ***
5320: 0000: \***                                                                        ***
5321: 0000: \***         AUTHOR        :  Stephen Kelsey                                ***
5322: 0000: \***                                                                        ***
5323: 0000: \***         DATE WRITTEN  :  21st February 1986                            ***
5324: 0000: \***                                                                        ***
5325: 0000: \***         DATE OF LAST REVISION  - 21st February 1986                    ***
5326: 0000: \***                                                                        ***
5327: 0000: \***         VERSION B     :  Stuart William McConnachie  18th March 1997   ***
5328: 0000: \***    Define size of ADXERROR return value from function.  This change    ***
5329: 0000: \***    was introduced by IBM in the 4690 Programming Guide.  Not defining  ***
5330: 0000: \***    this variable can cause Memory Protection Violations at run time.   ***
5331: 0000: \***                                                                        ***
5332: 0000: \******************************************************************************
5333: 0000: \******************************************************************************
5334: 0000: 
5335: 0000:    FUNCTION ADXERROR (TERM%,                                                  \
5336: 0000:                       MSGGRP%,                                                \
5337: 0000:                       MSGNUM%,                                                \
5338: 0000:                       SEVERITY%,                                              \
5339: 0000:                       EVENT.NUM%,                                             \
5340: 0000:                       UNIQUE$) EXTERNAL
5341: 0000: 
5342: 0000:       INTEGER*2  MSGNUM%,                                                     \
5343: 0000:                  TERM%,                                                       \
5344: 0000:                  ADXERROR                                                     !BSWM
5345: 0000: 
5346: 0000:       INTEGER*1 EVENT.NUM%,                                                   \
5347: 0000:                 MSGGRP%,                                                      \
5348: 0000:                 SEVERITY%
5349: 0000: 
5350: 0000:       STRING  UNIQUE$
5351: 0000: 
5352: 0000:    END FUNCTION
5353: 0000: 
5354: 0000:  %INCLUDE ADXSERVE.J86
5355: 0000: \******************************************************************************
5356: 0000: \******************************************************************************
5357: 0000: \***                                                                        ***
5358: 0000: \***    %INCLUDE FOR FUNCTION ADXSERVE (an I.B.M. system function)          ***
5359: 0000: \***                                                                        ***
5360: 0000: \***         AUTHOR        :  Bruce Scriver                                 ***
5361: 0000: \***                                                                        ***
5362: 0000: \***         DATE WRITTEN  :  14th March 1986                               ***
5363: 0000: \***                                                                        ***
5364: 0000: \***         DATE OF LAST REVISION  - 14th March 1986                       ***
5365: 0000: \***                                                                        ***
5366: 0000: \***                                                                        ***
5367: 0000: \******************************************************************************
5368: 0000: \******************************************************************************
5369: 0000: 
5370: 0000:    SUB ADXSERVE (RETURN.CODE%,                                                \
5371: 0000:                  ADX.FUNCTION%,                                               \
5372: 0000:                  ADX.PARM.1%,                                                 \
5373: 0000:                  ADX.PARM.2$)                                                 \
5374: 0000:    EXTERNAL
5375: 0000:   
5376: 0000:       STRING     ADX.PARM.2$
5377: 0000: 
5378: 0000:       INTEGER*2  ADX.FUNCTION%,                                               \
5379: 0000:                  ADX.PARM.1%
5380: 0000: 
5381: 0000:       INTEGER*4  RETURN.CODE%                                                 \
5382: 0000: 
5383: 0000:    END SUB     
5384: 0000: 
5385: 0000:  %INCLUDE ADXSERCL.J86                    ! DSW
5386: 0000: SUB ADXSERCL EXTERNAL
5387: 0000: END SUB
5388: 0000:  %INCLUDE PSBF01E.J86                     ! DLC
5389: 0000: REM \
5390: 0000: \*******************************************************************************
5391: 0000: \*******************************************************************************
5392: 0000: \***
5393: 0000: \***      %INCLUDE FOR EXTERNAL DEFINITION OF FUNCTION APPLICATION.LOG
5394: 0000: \***
5395: 0000: \***                      FUNCTION NUMBER   : PSBF01
5396: 0000: \***
5397: 0000: \***                    INCLUDE REFERENCE : PSBF01E.J86
5398: 0000: \*** 
5399: 0000: \***      Version B           Andrew Wedgeworth          1st July 1992
5400: 0000: \***      Three parameters which passed to the function have been removed.
5401: 0000: \***      APPLICATION.LOG has been added as a variable name (this holds the
5402: 0000: \***      return code).
5403: 0000: \***
5404: 0000: \*******************************************************************************
5405: 0000: 
5406: 0000: 
5407: 0000:    FUNCTION APPLICATION.LOG (MESSAGE.NO%,                                     \
5408: 0000:                              VAR.STRING.1$,                                   \
5409: 0000:                              VAR.STRING.2$,                                   \
5410: 0000:                              EVENT.NO%)  EXTERNAL
5411: 0000: 
5412: 0000:       INTEGER*1 EVENT.NO%
5413: 0000: 
5414: 0000:       INTEGER*2 APPLICATION.LOG,                                       \ GAW
5415: 0000:                 MESSAGE.NO%
5416: 0000: 
5417: 0000:       STRING VAR.STRING.1$,                                            \
5418: 0000:              VAR.STRING.2$
5419: 0000: 
5420: 0000:    END FUNCTION
5421: 0000: 
5422: 0000: \*******************************************************************************
5423: 0000:  %INCLUDE PSBF05E.J86                     ! 1.9BG
5424: 0000: REM\
5425: 0000: \*******************************************************************************
5426: 0000: \*******************************************************************************
5427: 0000: \***
5428: 0000: \***        INCLUDE       : CHECK.BOOTS.CODE external definition
5429: 0000: \***
5430: 0000: \***        REFERENCE     : PSBF05E.J86
5431: 0000: \***
5432: 0000: \***        Version A       Bruce Scriver                  24th February 1986  
5433: 0000: \*** 
5434: 0000: \***        Version B       Andrew Wedgeworth                  15th July 1992 
5435: 0000: \***        Redundant parameters removed, and CHECK.BOOTS.CODE defined as a 
5436: 0000: \***        variable to hold the return code.  
5437: 0000: \***
5438: 0000: \*******************************************************************************
5439: 0000: \*******************************************************************************
5440: 0000: 
5441: 0000:    FUNCTION CHECK.BOOTS.CODE (BOOTS.CODE$)                                     \
5442: 0000:    EXTERNAL
5443: 0000:    ! 3 parameters removed from here                                    ! BAW   
5444: 0000: 
5445: 0000:       STRING BOOTS.CODE$
5446: 0000:    ! 3 variables removed from here                                     ! BAW
5447: 0000:    
5448: 0000:       INTEGER*2 CHECK.BOOTS.CODE                                       ! BAW
5449: 0000:    
5450: 0000: 
5451: 0000:    END FUNCTION
5452: 0000: 
5453: 0000: !%INCLUDE PSBF06E.J86                     ! FLC
5454: 0000:  %INCLUDE PSBF11E.J86                     ! DLC
5455: 0000: REM \
5456: 0000: \*******************************************************************************
5457: 0000: \*******************************************************************************
5458: 0000: \***
5459: 0000: \***    %INCLUDE FOR EXTERNAL DEFINITION OF FUNCTION READ.NEXT.IEF
5460: 0000: \***
5461: 0000: \***
5462: 0000: \***            FUNCTION NUMBER       : PSBF11
5463: 0000: \***
5464: 0000: \***            INCLUDE REFERENCE     : PSBF11E.J86
5465: 0000: \***
5466: 0000: \***            DATE OF LAST AMENDMENT -  3rd March 1986
5467: 0000: \***
5468: 0000: \***     Version B             Andrew Wedgeworth          15th July 1992
5469: 0000: \***     Removal of redundant function parameters.  READ.NEXT.IEF defined as
5470: 0000: \***     a variable to hold the return code.
5471: 0000: \***
5472: 0000: \*******************************************************************************
5473: 0000: \*******************************************************************************
5474: 0000: 
5475: 0000: REM \
5476: 0000: \*******************************************************************************
5477: 0000: \*******************************************************************************
5478: 0000: \***
5479: 0000: \***
5480: 0000: \***            FUNCTION OVERVIEW
5481: 0000: \***            -----------------
5482: 0000: \***
5483: 0000: \***   This function finds and retreives the next bar code in an IEF chain.
5484: 0000: \***   If the code found is the last code in the chain, the function checks that
5485: 0000: \***   the number of codes in the chain is equal to the expected number.  If it
5486: 0000: \***   is not, a message is displayed and logged.  If an error occurs in reading
5487: 0000: \***   the IEF, a message is displayed and logged, and the function returns to
5488: 0000: \***   the calling program with a return code of 1.
5489: 0000: \***
5490: 0000: \***
5491: 0000: \*******************************************************************************
5492: 0000: \*******************************************************************************
5493: 0000: 
5494: 0000:    FUNCTION READ.NEXT.IEF (LAST.BAR.CODE$,                             \
5495: 0000:                            TOTAL.COUNT%,                               \
5496: 0000:                            BOOTS.CODE$)  EXTERNAL
5497: 0000:    ! 3 parameters deleted from here                                    ! BAW			   
5498: 0000: 
5499: 0000:       STRING  BOOTS.CODE$,                                             \
5500: 0000:               LAST.BAR.CODE$
5501: 0000:       ! 3 variables removed from here                                  ! BAW
5502: 0000: 
5503: 0000:       INTEGER*2 READ.NEXT.IEF,                                         \ BAW
5504: 0000:                 TOTAL.COUNT%
5505: 0000:              
5506: 0000: 
5507: 0000: 
5508: 0000:    END FUNCTION
5509: 0000: 
5510: 0000: \*******************************************************************************
5511: 0000:  %INCLUDE PSBF14E.J86                     ! DLC
5512: 0000: REM\
5513: 0000: \*******************************************************************************
5514: 0000: \*******************************************************************************
5515: 0000: \***
5516: 0000: \***        INCLUDE       : SORT.TABLE external definition
5517: 0000: \***
5518: 0000: \***        REFERENCE     : PSBF14E.J86
5519: 0000: \***
5520: 0000: \***        Version A     Bruce Scriver                   3rd March 1986   
5521: 0000: \*** 
5522: 0000: \***        Version B     Andrew Wedgeworth               17th July 1992
5523: 0000: \***        Redundant function parameters removed.  SORT.TABLE defined as a
5524: 0000: \***        variable to hold the return code.
5525: 0000: \***
5526: 0000: \*******************************************************************************
5527: 0000: \*******************************************************************************
5528: 0000: 
5529: 0000:    FUNCTION SORT.TABLE (NUMBER.OF.ENTRIES%)                                    \
5530: 0000:    EXTERNAL
5531: 0000: 
5532: 0000:       INTEGER   NUMBER.OF.ENTRIES%,                                    \ BAW
5533: 0000:                 SORT.TABLE                 
5534: 0000: 
5535: 0000:    END FUNCTION
5536: 0000: 
5537: 0000:  %INCLUDE PSBF16E.J86                     ! DLC
5538: 0000: REM\
5539: 0000: \*******************************************************************************
5540: 0000: \*******************************************************************************
5541: 0000: \***
5542: 0000: \***       %INCLUDE FOR EXTERNAL DEFINITION OF CONV.TO.HEX FUNCTION
5543: 0000: \***
5544: 0000: \***                  REFERENCE     : PSBF16E.J86
5545: 0000: \***
5546: 0000: \***       Version A            Bruce Scriver          25th February 1986
5547: 0000: \***
5548: 0000: \***       Version B           Andrew Wedgeworth            2nd July 1992
5549: 0000: \***       Removal of redundant parameters, and CONV.TO.HEX defined as a 
5550: 0000: \***       variable to hold the return code. 
5551: 0000: \***
5552: 0000: \*******************************************************************************
5553: 0000: \*******************************************************************************
5554: 0000: 
5555: 0000:    FUNCTION CONV.TO.HEX (INTEGER4%)                                            \
5556: 0000:    EXTERNAL
5557: 0000:    ! 3 parameters removed from here                                    ! BAW
5558: 0000: 
5559: 0000:    ! 3 lines deleted from here                                         ! BAW
5560: 0000:    
5561: 0000:       INTEGER*2 CONV.TO.HEX                                            ! BAW
5562: 0000: 
5563: 0000:       INTEGER*4 INTEGER4%
5564: 0000: 
5565: 0000:    END FUNCTION
5566: 0000: 
5567: 0000:  %INCLUDE PSBF17E.J86                     ! DLC
5568: 0000: REM \
5569: 0000: \*******************************************************************************
5570: 0000: \*******************************************************************************
5571: 0000: \***
5572: 0000: \***
5573: 0000: \***       %INCLUDE FOR EXTERNAL DEFINITION OF CONV.TO.STRING FUNCTION
5574: 0000: \***
5575: 0000: \***                     REFERENCE     : PSBF17E.J86
5576: 0000: \***
5577: 0000: \***       Version A            Bruce Scriver       24th February 1986           
5578: 0000: \***
5579: 0000: \***       Version B          Andrew Wedgeworth          2nd July 1992
5580: 0000: \***       Redundant parameters removed, and the function's name is 
5581: 0000: \***       is defined as a variable to hold the return code. 
5582: 0000: \***
5583: 0000: \*******************************************************************************
5584: 0000: \*******************************************************************************
5585: 0000: 
5586: 0000:    FUNCTION CONV.TO.STRING (EVENT.NUMBER%,                                     \
5587: 0000:                             INTEGER4%)                                         \
5588: 0000:    EXTERNAL
5589: 0000: ! 3 parameters removed from here                                       ! BAW
5590: 0000: 
5591: 0000: ! 3 lines deleted from here                                            ! BAW
5592: 0000: 
5593: 0000:       INTEGER*1 EVENT.NUMBER%
5594: 0000: 
5595: 0000:       INTEGER*2 CONV.TO.STRING                                         ! BAW
5596: 0000: 
5597: 0000:       INTEGER*4 INTEGER4%
5598: 0000: 
5599: 0000:    END FUNCTION
5600: 0000: 
5601: 0000:  %INCLUDE PSBF18E.J86                     ! 1.8DA
5602: 0000: REM\
5603: 0000: \*******************************************************************************
5604: 0000: \*******************************************************************************
5605: 0000: \***
5606: 0000: \***        INCLUDE       : CALC.BOOTS.CODE.CHECK.DIGIT external definition
5607: 0000: \***
5608: 0000: \***        REFERENCE     : PSBF18E.J86
5609: 0000: \***
5610: 0000: \***        Version A      Stephen Kelsey                   23rd March 1987 
5611: 0000: \***
5612: 0000: \***        Version B      Andrew Wedgeworth                  7th July 1992 
5613: 0000: \***        Removal of redundant parameters, and inclusion of function's 
5614: 0000: \***        name as a variable to hold the return code.
5615: 0000: \***
5616: 0000: \*******************************************************************************
5617: 0000: \*******************************************************************************
5618: 0000: 
5619: 0000:    FUNCTION CALC.BOOTS.CODE.CHECK.DIGIT (BOOTS.CODE.6.DIGIT$)          \ 
5620: 0000:    EXTERNAL
5621: 0000:    ! 3 parameters removed from here                                    ! BAW
5622: 0000: 
5623: 0000:    STRING BOOTS.CODE.6.DIGIT$
5624: 0000:    ! 3 variables deleted from here                                     ! BAW
5625: 0000:    
5626: 0000:    INTEGER* 2 CALC.BOOTS.CODE.CHECK.DIGIT                              ! BAW
5627: 0000:    
5628: 0000:    END FUNCTION
5629: 0000: 
5630: 0000:  %INCLUDE PSBF20E.J86                     ! DLC
5631: 0000: REM\
5632: 0000: \*******************************************************************************
5633: 0000: \*******************************************************************************
5634: 0000: \***
5635: 0000: \***       %INCLUDE FOR EXTERNAL DEFINITION OF SESS.NUM.UTILITY
5636: 0000: \***
5637: 0000: \***                  REFERENCE     : PSBF20E.J86
5638: 0000: \***
5639: 0000: \***     VERSION C            Janet Smith                13th May 1992
5640: 0000: \***     Increased PASSED.INTEGER to 2 bytes to cater for more than
5641: 0000: \***     128 files.
5642: 0000: \***
5643: 0000: \***     VERSION D.           Andrew Wedgeworth          1st July 1992
5644: 0000: \***     Removal of redundant parameters and addition of SESS.NUM.UTILITY
5645: 0000: \***     as a variable.  This new variable contains the function's return
5646: 0000: \***     code.
5647: 0000: \***
5648: 0000: \*******************************************************************************
5649: 0000: \*******************************************************************************
5650: 0000: 
5651: 0000:    FUNCTION SESS.NUM.UTILITY (FUNCTION.FLAG$,                          \
5652: 0000:                               PASSED.INTEGER%,                         \
5653: 0000:                               PASSED.STRING$)                          \
5654: 0000:    EXTERNAL
5655: 0000: 
5656: 0000:    STRING    FUNCTION.FLAG$,                                           \
5657: 0000:              PASSED.STRING$
5658: 0000:    ! 3 variables removed from here                                     ! CAW
5659: 0000: 
5660: 0000: 
5661: 0000:    INTEGER*2 SESS.NUM.UTILITY,                                         \ CAW
5662: 0000:              PASSED.INTEGER%				               ! CJAS
5663: 0000: 
5664: 0000:    END FUNCTION
5665: 0000: 
5666: 0000:  %INCLUDE PSBF21E.J86                     ! 1.9BG
5667: 0000: REM\
5668: 0000: \*******************************************************************************
5669: 0000: \*******************************************************************************
5670: 0000: \***
5671: 0000: \***        INCLUDE       : CHECK.BAR.CODE external definition
5672: 0000: \***
5673: 0000: \***        REFERENCE     : PSBF21E.J86
5674: 0000: \***
5675: 0000: \***        Version A     Bruce Scriver                  13th May 1988
5676: 0000: \***
5677: 0000: \***        Version B     Andrew Wedgeworth             21st July 1992
5678: 0000: \***        Redundant function parameters removed.  CHECK.BAR.CODE defined as
5679: 0000: \***        a variable to hold the return code.
5680: 0000: \***
5681: 0000: \*******************************************************************************
5682: 0000: \*******************************************************************************
5683: 0000: 
5684: 0000:    FUNCTION CHECK.BAR.CODE (BAR.CODE$)                                 \
5685: 0000:    EXTERNAL
5686: 0000: 
5687: 0000:    STRING    BAR.CODE$
5688: 0000: 
5689: 0000:    INTEGER*2 CHECK.BAR.CODE                                            ! BAW
5690: 0000: 
5691: 0000:    END FUNCTION
5692: 0000: 
5693: 0000: 
5694: 0000:  %INCLUDE IDFEXT.J86                      ! FLC
5695: 0000: \*******************************************************************************
5696: 0000: \***                                                                         ***
5697: 0000: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE ITEM DESCRIPTION FILE        ***
5698: 0000: \***                                                                         ***
5699: 0000: \***                       REFERENCE : IDFEXT.J86                            ***
5700: 0000: \***                                                                         ***
5701: 0000: \***      Version A           Andrew Wedgeworth         9th July 1992        ***
5702: 0000: \***
5703: 0000: \***    VERSION C.              Robert Cowey.                       25 AUG 1993.
5704: 0000: \***    No changes to this file.
5705: 0000: \***
5706: 0000: \***   VERSION D               Nik Sen                 22nd December 1994
5707: 0000: \***   WRITE.IDF.HOLD added
5708: 0000: \***
5709: 0000: \*******************************************************************************
5710: 0000: 
5711: 0000:        FUNCTION IDF.SET EXTERNAL                                      
5712: 0000:        END FUNCTION                                                   
5713: 0000: 
5714: 0000: 
5715: 0000:        FUNCTION READ.IDF EXTERNAL                                     
5716: 0000:           INTEGER*2 READ.IDF                                          
5717: 0000:        END FUNCTION                                                   
5718: 0000: 
5719: 0000: 
5720: 0000:        FUNCTION READ.IDF.LOCK EXTERNAL                                
5721: 0000:           INTEGER*2 READ.IDF.LOCK                                     
5722: 0000:        END FUNCTION                                                   
5723: 0000: 
5724: 0000:        FUNCTION WRITE.IDF EXTERNAL
5725: 0000:           INTEGER*2 WRITE.IDF
5726: 0000:        END FUNCTION	       
5727: 0000: 
5728: 0000:        FUNCTION WRITE.IDF.HOLD EXTERNAL
5729: 0000:           INTEGER*2 WRITE.IDF.HOLD
5730: 0000:        END FUNCTION
5731: 0000: 
5732: 0000:        FUNCTION WRITE.IDF.UNLOCK EXTERNAL                                  
5733: 0000:           INTEGER*2 WRITE.IDF.UNLOCK                                      
5734: 0000:        END FUNCTION                                                   
5735: 0000: !%INCLUDE IRFEXT.J86                      ! FLC TEST
5736: 0000:  %INCLUDE STKMQEXT.J86                    ! GMJK
5737: 0000: \*****************************************************************************
5738: 0000: \*****************************************************************************
5739: 0000: \***
5740: 0000: \***      EXTERNAL FUNCTION DEFINITIONS FOR STOCK MOVEMENT QUEUE FILE
5741: 0000: \***
5742: 0000: \***                      REFERENCE: STKMQEXT.J86
5743: 0000: \***
5744: 0000: \***       Version A            Les Cook                     8/9/92
5745: 0000: \***
5746: 0000: \***    VERSION F.              ROBERT COWEY.                       21 OCT 1993.
5747: 0000: \***    No changes to this file.
5748: 0000: \***
5749: 0000: \*******************************************************************************
5750: 0000: \*******************************************************************************
5751: 0000: 
5752: 0000:      FUNCTION STKMQ.SET EXTERNAL
5753: 0000:      END FUNCTION
5754: 0000:      
5755: 0000:      FUNCTION READ.STKMQ EXTERNAL
5756: 0000:         INTEGER*2 READ.STKMQ
5757: 0000:      END FUNCTION
5758: 0000:      
5759: 0000:      FUNCTION WRITE.STKMQ EXTERNAL
5760: 0000:         INTEGER*2 WRITE.STKMQ
5761: 0000:      END FUNCTION
5762: 0000:      
5763: 0000:      FUNCTION WRITE.HOLD.STKMQ EXTERNAL
5764: 0000:         INTEGER*2 WRITE.HOLD.STKMQ
5765: 0000:      END FUNCTION
5766: 0000:      
5767: 0000:      
5768: 0000:      
5769: 0000:  %INCLUDE BCSMFEXT.J86                    ! FLC
5770: 0000: \*****************************************************************************
5771: 0000: \*****************************************************************************
5772: 0000: \***
5773: 0000: \***   EXTERNAL FUNCTION DEFINITIONS FOR BUSINESS CENTRE SUPPLY METHOD FILE
5774: 0000: \***
5775: 0000: \***               REFERENCE: BCSMFFUN.BAS
5776: 0000: \***
5777: 0000: \***        Version B           Les Cook              11/1/93
5778: 0000: \***
5779: 0000: \*****************************************************************************
5780: 0000: \*****************************************************************************
5781: 0000: 
5782: 0000:     FUNCTION BCSMF.SET EXTERNAL
5783: 0000:     END FUNCTION
5784: 0000:     
5785: 0000:     FUNCTION READ.BCSMF EXTERNAL
5786: 0000:        INTEGER*2 READ.BCSMF
5787: 0000:     END FUNCTION
5788: 0000:     
5789: 0000:     FUNCTION READ.BCSMF.LOCK EXTERNAL
5790: 0000:        INTEGER*2 READ.BCSMF.LOCK
5791: 0000:     END FUNCTION
5792: 0000:     
5793: 0000:     FUNCTION WRITE.BCSMF EXTERNAL
5794: 0000:        INTEGER*2 WRITE.BCSMF
5795: 0000:     END FUNCTION
5796: 0000:     
5797: 0000:     FUNCTION WRITE.BCSMF.UNLOCK EXTERNAL
5798: 0000:        INTEGER*2 WRITE.BCSMF.UNLOCK
5799: 0000:     END FUNCTION
5800: 0000:     
5801: 0000:     
5802: 0000:  %INCLUDE INVOKEXT.J86                    ! FLC
5803: 0000: \*******************************************************************************
5804: 0000: \***                                                                         ***
5805: 0000: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE INVCE OK FILE                ***
5806: 0000: \***                                                                         ***
5807: 0000: \***                     REFERENCE : INVOKEXT.J86                            ***
5808: 0000: \***                                                                         ***
5809: 0000: \***      Version A         Andrew Wedgeworth       3rd August 1992          ***
5810: 0000: \***                                                                         ***
5811: 0000: \***      Version B         Stephen Kelsey (CTG)    9th October 1992         ***
5812: 0000: \***          Add functions READ.INVOK.LOCKED and WRITE.INVOK.UNLOCK         ***
5813: 0000: \***                                                                         ***
5814: 0000: \*******************************************************************************
5815: 0000: 
5816: 0000: 
5817: 0000:       FUNCTION INVOK.SET EXTERNAL 
5818: 0000:       END FUNCTION
5819: 0000:       
5820: 0000:       FUNCTION READ.INVOK EXTERNAL
5821: 0000:          INTEGER*2 READ.INVOK
5822: 0000:       END FUNCTION	             
5823: 0000:       
5824: 0000:       FUNCTION READ.INVOK.LOCKED EXTERNAL                              ! BSPK
5825: 0000:          INTEGER*2 READ.INVOK.LOCKED                                   ! BSPK
5826: 0000:       END FUNCTION	                                               ! BSPK
5827: 0000:       
5828: 0000:       FUNCTION WRITE.INVOK.UNLOCK EXTERNAL                             ! BSPK
5829: 0000:          INTEGER*2 WRITE.INVOK.UNLOCK                                  ! BSPK
5830: 0000:       END FUNCTION	                                               ! BSPK
5831: 0000:  %INCLUDE PCHKEXT.J86                     ! DLC
5832: 0000: \*****************************************************************************
5833: 0000: \*****************************************************************************
5834: 0000: \***
5835: 0000: \***        EXTERNAL FUNCTION DEFINITIONS FOR PCHK
5836: 0000: \***
5837: 0000: \***        REFERENCE: PCHKEXT.J86
5838: 0000: \***
5839: 0000: \*****************************************************************************
5840: 0000: \*****************************************************************************
5841: 0000: 
5842: 0000: 
5843: 0000:    FUNCTION PCHK.SET EXTERNAL
5844: 0000:    END FUNCTION
5845: 0000:    
5846: 0000:    FUNCTION READ.PCHK EXTERNAL
5847: 0000:    END FUNCTION
5848: 0000:    
5849: 0000:    FUNCTION WRITE.PCHK EXTERNAL
5850: 0000:    END FUNCTION
5851: 0000:    
5852: 0000:    
5853: 0000: \%INCLUDE CSREXT.J86                      ! DLC !2.5NWB
5854: 0000:  %INCLUDE EPSOMEXT.J86                    ! DLC
5855: 0000: \*****************************************************************************
5856: 0000: \*****************************************************************************
5857: 0000: \***
5858: 0000: \***      EXTERNAL FUNCTION DEFINITIONS FOR EPSOM
5859: 0000: \***
5860: 0000: \***      REFERENCE: EPSOMEXT.J86
5861: 0000: \***
5862: 0000: \*****************************************************************************
5863: 0000: \*****************************************************************************
5864: 0000: 
5865: 0000: 
5866: 0000:    FUNCTION EPSOM.SET EXTERNAL
5867: 0000:    END FUNCTION
5868: 0000:    
5869: 0000:  %INCLUDE UNITSEXT.J86                    ! DLC
5870: 0000: \*****************************************************************************
5871: 0000: \*****************************************************************************
5872: 0000: \*** 
5873: 0000: \***        EXTERNAL FUNCTION DEFINITIONS FOR UNITS
5874: 0000: \***
5875: 0000: \***        REFERENCE:  UNITSEXT.J86
5876: 0000: \***
5877: 0000: \*****************************************************************************
5878: 0000: \*****************************************************************************
5879: 0000: 
5880: 0000:    FUNCTION UNITS.SET EXTERNAL
5881: 0000:    END FUNCTION
5882: 0000:    
5883: 0000:    FUNCTION READ.UNITS EXTERNAL
5884: 0000:       INTEGER*2 READ.UNITS
5885: 0000:    END FUNCTION
5886: 0000:    
5887: 0000:    FUNCTION READ.UNITS.LOCK EXTERNAL
5888: 0000:       INTEGER*2 READ.UNITS.LOCK
5889: 0000:    END FUNCTION
5890: 0000:    
5891: 0000:    FUNCTION WRITE.UNITS EXTERNAL
5892: 0000:       INTEGER*2 WRITE.UNITS
5893: 0000:    END FUNCTION
5894: 0000:    
5895: 0000:    FUNCTION WRITE.UNITS.UNLOCK EXTERNAL
5896: 0000:       INTEGER*2 WRITE.UNITS.UNLOCK
5897: 0000:    END FUNCTION
5898: 0000:    
5899: 0000:    
5900: 0000:    
5901: 0000:  %INCLUDE DIRECEXT.J86                    ! DLC
5902: 0000: \*****************************************************************************
5903: 0000: \*****************************************************************************
5904: 0000: \***
5905: 0000: \***       EXTERNAL FUNCTION DEFINITIONS FOR DIREC
5906: 0000: \***
5907: 0000: \***       REFERENCE: DIRECEXT.J86
5908: 0000: \***
5909: 0000: \*****************************************************************************
5910: 0000: \*****************************************************************************
5911: 0000: 
5912: 0000:    FUNCTION DIREC.SET EXTERNAL 
5913: 0000:    END FUNCTION
5914: 0000:    
5915: 0000:    
5916: 0000:  %INCLUDE LDTBFEXT.J86                    ! ELC
5917: 0000: \*******************************************************************************
5918: 0000: \***                                                                         
5919: 0000: \***         EXTERNAL FUNCTION DEFINITIONS FOR THE LDT BUFFER FILE          
5920: 0000: \***                                                                         
5921: 0000: \***                     REFERENCE : LDTBFEXT.J86                            
5922: 0000: \***                                                                         
5923: 0000: \***          Version B     Les Cook      4th November 1992               
5924: 0000: \***                                                                         
5925: 0000: \*******************************************************************************
5926: 0000: 
5927: 0000:        FUNCTION LDTBF.SET EXTERNAL                                      
5928: 0000:        END FUNCTION                                                   
5929: 0000: 
5930: 0000: 
5931: 0000:        FUNCTION READ.LDTBF EXTERNAL                                  
5932: 0000:           INTEGER*2 READ.LDTBF                                       
5933: 0000:        END FUNCTION                                                   
5934: 0000:        
5935: 0000:        FUNCTION WRITE.LDTBF EXTERNAL
5936: 0000:           INTEGER*2 WRITE.LDTBF
5937: 0000:        END FUNCTION
5938: 0000:  %INCLUDE UODEXT.J86                      ! FLC
5939: 0000: \*****************************************************************************
5940: 0000: \*****************************************************************************
5941: 0000: \***
5942: 0000: \***     EXTERNAL FUNCTION DEFINITIONS FOR UOD DUMMY FILE
5943: 0000: \***
5944: 0000: \***     REFERENCE: UODEXT.J86
5945: 0000: \***
5946: 0000: \*****************************************************************************
5947: 0000: \*****************************************************************************
5948: 0000: 
5949: 0000:    FUNCTION UOD.SET EXTERNAL
5950: 0000:    END FUNCTION
5951: 0000:    
5952: 0000:    
5953: 0000:  %INCLUDE UODBFEXT.J86                    ! FLC
5954: 0000: \*******************************************************************************
5955: 0000: \*******************************************************************************
5956: 0000: \***
5957: 0000: \***           UOD BUFFER FILE EXTERNAL FILE PUBLIC DEFINITIONS
5958: 0000: \***
5959: 0000: \***                    REFERENCE    : UODBFEXT.BAS
5960: 0000: \***
5961: 0000: \***    Version A.         Michael Kelsall              08th February 1993
5962: 0000: \***
5963: 0000: \*******************************************************************************
5964: 0000: \*******************************************************************************
5965: 0000: 
5966: 0000:  
5967: 0000:   FUNCTION UODBF.SET EXTERNAL
5968: 0000:       INTEGER*2 UODBF.SET
5969: 0000:   END FUNCTION
5970: 0000: 
5971: 0000: 
5972: 0000:   FUNCTION READ.UODBF EXTERNAL
5973: 0000:       INTEGER*2 READ.UODBF 
5974: 0000:   END FUNCTION
5975: 0000: 
5976: 0000:   
5977: 0000:   FUNCTION WRITE.UODBF EXTERNAL
5978: 0000:       INTEGER*2 WRITE.UODBF
5979: 0000:   END FUNCTION
5980: 0000: 
5981: 0000:   
5982: 0000:   FUNCTION WRITE.HOLD.UODBF EXTERNAL
5983: 0000:       INTEGER*2 WRITE.HOLD.UODBF						
5984: 0000:   END FUNCTION								
5985: 0000: 
5986: 0000:  %INCLUDE UODTFEXT.J86                    ! FLC
5987: 0000: \*****************************************************************************
5988: 0000: \*****************************************************************************
5989: 0000: \***
5990: 0000: \***        EXTERNAL FUNCTION DEFINITIONS FOR UODTF
5991: 0000: \***
5992: 0000: \***        REFERENCE:  UODTFEXT.J86
5993: 0000: \***
5994: 0000: \***        Version A         Les Cook         22/2/1993
5995: 0000: \***
5996: 0000: \*****************************************************************************
5997: 0000: \*****************************************************************************
5998: 0000: 
5999: 0000:    FUNCTION UODTF.SET EXTERNAL
6000: 0000:    END FUNCTION
6001: 0000:    
6002: 0000:    FUNCTION READ.UODTF EXTERNAL
6003: 0000:       INTEGER*2 READ.UODTF
6004: 0000:    END FUNCTION
6005: 0000:    
6006: 0000:    FUNCTION WRITE.UODTF EXTERNAL
6007: 0000:       INTEGER*2 WRITE.UODTF
6008: 0000:    END FUNCTION
6009: 0000:    
6010: 0000:    
6011: 0000:  %INCLUDE PILSTEXT.J86                    ! FLC
6012: 0000: \*****************************************************************************
6013: 0000: \*****************************************************************************
6014: 0000: \***
6015: 0000: \***     EXTERNAL FUNCTION DEFINITIONS FOR PILST
6016: 0000: \***
6017: 0000: \***     REFERENCE: PILSTEXT.J86
6018: 0000: \***
6019: 0000: \***     9th October 1992
6020: 0000: \***
6021: 0000: \*****************************************************************************
6022: 0000: \*****************************************************************************
6023: 0000: 
6024: 0000:    FUNCTION PILST.SET EXTERNAL
6025: 0000:    END FUNCTION
6026: 0000:    
6027: 0000:    FUNCTION READ.PILST EXTERNAL
6028: 0000:       INTEGER*2 READ.PILST
6029: 0000:    END FUNCTION
6030: 0000:    
6031: 0000:    FUNCTION READ.PILST.LOCK EXTERNAL
6032: 0000:       INTEGER*2 READ.PILST.LOCK
6033: 0000:    END FUNCTION
6034: 0000:    
6035: 0000:    FUNCTION WRITE.PILST EXTERNAL
6036: 0000:       INTEGER*2 WRITE.PILST
6037: 0000:    END FUNCTION
6038: 0000:    
6039: 0000:    FUNCTION WRITE.PILST.HOLD EXTERNAL
6040: 0000:       INTEGER*2 WRITE.PILST.HOLD
6041: 0000:    END FUNCTION
6042: 0000:    
6043: 0000:    FUNCTION WRITE.PILST.UNLOCK EXTERNAL
6044: 0000:       INTEGER*2 WRITE.PILST.UNLOCK
6045: 0000:    END FUNCTION
6046: 0000:    
6047: 0000:    
6048: 0000:  %INCLUDE PIITMEXT.J86                    ! FLC
6049: 0000: \*****************************************************************************
6050: 0000: \*****************************************************************************
6051: 0000: \***
6052: 0000: \***            EXTERNAL FUNCTION DEFINITIONS FOR PIITM
6053: 0000: \***
6054: 0000: \***            REFERENCE: PIITMEXT.J86
6055: 0000: \***
6056: 0000: \***            Les Cook 9/10/1992
6057: 0000: \***
6058: 0000: \*****************************************************************************
6059: 0000: \*****************************************************************************
6060: 0000: 
6061: 0000:    FUNCTION PIITM.SET EXTERNAL
6062: 0000:    END FUNCTION
6063: 0000:    
6064: 0000:    FUNCTION READ.PIITM EXTERNAL
6065: 0000:       INTEGER*2 READ.PIITM
6066: 0000:    END FUNCTION
6067: 0000:    
6068: 0000:    FUNCTION READ.PIITM.LOCK EXTERNAL
6069: 0000:       INTEGER*2 READ.PIITM.LOCK
6070: 0000:    END FUNCTION
6071: 0000:    
6072: 0000:    FUNCTION WRITE.PIITM EXTERNAL
6073: 0000:       INTEGER*2 WRITE.PIITM
6074: 0000:    END FUNCTION
6075: 0000:    
6076: 0000:    FUNCTION WRITE.PIITM.UNLOCK EXTERNAL
6077: 0000:       INTEGER*2 WRITE.PIITM.UNLOCK
6078: 0000:    END FUNCTION
6079: 0000:    
6080: 0000:    FUNCTION WRITE.PIITM.HOLD.UNLOCK EXTERNAL
6081: 0000:       INTEGER*2 WRITE.PIITM.HOLD.UNLOCK
6082: 0000:    END FUNCTION
6083: 0000:    
6084: 0000:    FUNCTION WRITE.PIITM.HOLD EXTERNAL
6085: 0000:       INTEGER*2 WRITE.PIITM.HOLD
6086: 0000:    END FUNCTION
6087: 0000:    
6088: 0000: !%INCLUDE PDTWFEXT.J86                    ! FLC
6089: 0000: 
6090: 0000:  %INCLUDE CCUODEXT.J86                    ! GMJK
6091: 0000: 
6092: 0000: \*****************************************************************************
6093: 0000: \*****************************************************************************
6094: 0000: \***
6095: 0000: \***        %INCLUDE FOR FILE HANDLING FUNCTIONS EXTERNAL DEFINITIONS
6096: 0000: \***
6097: 0000: \***                   FILE TYPE:  KEYED
6098: 0000: \***
6099: 0000: \***                   REFERENCE:  CCUODEXT.J86
6100: 0000: \***
6101: 0000: \***	             DESCRIPTION:  RETURNS / AUTOMATIC CREDIT CLAIMING
6102: 0000: \***				   FILE OF OPEN/CLOSED UODS
6103: 0000: \***
6104: 0000: \***
6105: 0000: \***      VERSION A : Michael J. Kelsall      13th September 1993
6106: 0000: \***      
6107: 0000: \*****************************************************************************
6108: 0000: \*****************************************************************************
6109: 0000: 
6110: 0000: 
6111: 0000:   FUNCTION CCUOD.SET EXTERNAL
6112: 0000:      INTEGER*2 CCUOD.SET
6113: 0000:   END FUNCTION
6114: 0000: 
6115: 0000: 
6116: 0000:   FUNCTION READ.CCUOD EXTERNAL
6117: 0000:     INTEGER*2 READ.CCUOD
6118: 0000:   END FUNCTION
6119: 0000:   
6120: 0000: 
6121: 0000:   FUNCTION READ.CCUOD.LOCKED EXTERNAL
6122: 0000:     INTEGER*2 READ.CCUOD.LOCKED
6123: 0000:   END FUNCTION  
6124: 0000: 
6125: 0000: 
6126: 0000:   FUNCTION WRITE.HOLD.CCUOD EXTERNAL
6127: 0000:     INTEGER*2 WRITE.HOLD.CCUOD
6128: 0000:   END FUNCTION
6129: 0000: 
6130: 0000: 
6131: 0000:   FUNCTION WRITE.UNLOCK.CCUOD EXTERNAL
6132: 0000:     INTEGER*2 WRITE.UNLOCK.CCUOD
6133: 0000:   END FUNCTION
6134: 0000: 
6135: 0000: 
6136: 0000:   FUNCTION WRITE.HOLD.UNLOCK.CCUOD EXTERNAL
6137: 0000:     INTEGER*2 WRITE.HOLD.UNLOCK.CCUOD
6138: 0000:   END FUNCTION
6139: 0000:   
6140: 0000: 
6141: 0000:   FUNCTION WRITE.CCUOD EXTERNAL
6142: 0000:     INTEGER*2 WRITE.CCUOD
6143: 0000:   END FUNCTION
6144: 0000: 
6145: 0000:  %INCLUDE CCLAMEXT.J86                    ! 1.4
6146: 0000: 
6147: 0000: \*****************************************************************************
6148: 0000: \*****************************************************************************
6149: 0000: \***
6150: 0000: \***        %INCLUDE FOR FILE HANDLING FUNCTIONS EXTERNAL DEFINITIONS
6151: 0000: \***
6152: 0000: \***                   FILE TYPE:  KEYED
6153: 0000: \***
6154: 0000: \***                   REFERENCE:  CCLAMEXT.J86
6155: 0000: \***
6156: 0000: \***	             DESCRIPTION:  RETURNS / AUTOMATIC CREDIT CLAIMING
6157: 0000: \***				   FILE OF CURRENT CREDIT CLAIMS
6158: 0000: \***
6159: 0000: \***
6160: 0000: \***      VERSION A : Michael J. Kelsall      14th September 1993
6161: 0000: \***      
6162: 0000: \*****************************************************************************
6163: 0000: \*****************************************************************************
6164: 0000: 
6165: 0000: 
6166: 0000:   FUNCTION CCLAM.SET EXTERNAL
6167: 0000:      INTEGER*2 CCLAM.SET
6168: 0000:   END FUNCTION
6169: 0000: 
6170: 0000: 
6171: 0000:   FUNCTION READ.CCLAM EXTERNAL
6172: 0000:     INTEGER*2 READ.CCLAM
6173: 0000:   END FUNCTION
6174: 0000:   
6175: 0000: 
6176: 0000:   FUNCTION READ.CCLAM.LOCKED EXTERNAL
6177: 0000:     INTEGER*2 READ.CCLAM.LOCKED
6178: 0000:   END FUNCTION  
6179: 0000: 
6180: 0000: 
6181: 0000:   FUNCTION WRITE.HOLD.CCLAM EXTERNAL
6182: 0000:     INTEGER*2 WRITE.HOLD.CCLAM
6183: 0000:   END FUNCTION
6184: 0000: 
6185: 0000: 
6186: 0000:   FUNCTION WRITE.UNLOCK.CCLAM EXTERNAL
6187: 0000:     INTEGER*2 WRITE.UNLOCK.CCLAM
6188: 0000:   END FUNCTION
6189: 0000: 
6190: 0000: 
6191: 0000:   FUNCTION WRITE.HOLD.UNLOCK.CCLAM EXTERNAL
6192: 0000:     INTEGER*2 WRITE.HOLD.UNLOCK.CCLAM
6193: 0000:   END FUNCTION
6194: 0000:   
6195: 0000: 
6196: 0000:   FUNCTION WRITE.CCLAM EXTERNAL
6197: 0000:     INTEGER*2 WRITE.CCLAM
6198: 0000:   END FUNCTION
6199: 0000: 
6200: 0000:  %INCLUDE CCITMEXT.J86                    ! GMJK
6201: 0000: 
6202: 0000: \*****************************************************************************
6203: 0000: \*****************************************************************************
6204: 0000: \***
6205: 0000: \***        %INCLUDE FOR FILE HANDLING FUNCTION EXTERNAL DECLARATIONS
6206: 0000: \***
6207: 0000: \***                   FILE TYPE:  KEYED
6208: 0000: \***
6209: 0000: \***                   REFERENCE:  CCITMEXT.J86
6210: 0000: \***
6211: 0000: \***	             DESCRIPTION:  RETURNS / AUTOMATIC CREDIT CLAIMING
6212: 0000: \***				   FILE OF ITEMS PER OPEN/CLOSED UODS
6213: 0000: \***
6214: 0000: \***
6215: 0000: \***      VERSION A : Michael J. Kelsall      13th September 1993
6216: 0000: \***      
6217: 0000: \*****************************************************************************
6218: 0000: \*****************************************************************************
6219: 0000: 
6220: 0000: 
6221: 0000:   FUNCTION CCITM.SET EXTERNAL
6222: 0000:      INTEGER*2 CCITM.SET
6223: 0000:   END FUNCTION
6224: 0000: 
6225: 0000: 
6226: 0000:   FUNCTION READ.CCITM EXTERNAL
6227: 0000:     INTEGER*2 READ.CCITM
6228: 0000:   END FUNCTION
6229: 0000:   
6230: 0000: 
6231: 0000:   FUNCTION READ.CCITM.LOCKED EXTERNAL
6232: 0000:     INTEGER*2 READ.CCITM.LOCKED
6233: 0000:   END FUNCTION  
6234: 0000: 
6235: 0000: 
6236: 0000:   FUNCTION WRITE.HOLD.CCITM EXTERNAL
6237: 0000:     INTEGER*2 WRITE.HOLD.CCITM
6238: 0000:   END FUNCTION
6239: 0000: 
6240: 0000: 
6241: 0000:   FUNCTION WRITE.UNLOCK.CCITM EXTERNAL
6242: 0000:     INTEGER*2 WRITE.UNLOCK.CCITM
6243: 0000:   END FUNCTION
6244: 0000: 
6245: 0000: 
6246: 0000:   FUNCTION WRITE.HOLD.UNLOCK.CCITM EXTERNAL
6247: 0000:     INTEGER*2 WRITE.HOLD.UNLOCK.CCITM
6248: 0000:   END FUNCTION
6249: 0000: 
6250: 0000: 
6251: 0000:   FUNCTION WRITE.CCITM EXTERNAL
6252: 0000:     INTEGER*2 WRITE.CCITM
6253: 0000:   END FUNCTION
6254: 0000: 
6255: 0000:  %INCLUDE CCTRLEXT.J86                    ! GMJK
6256: 0000: 
6257: 0000: \*****************************************************************************
6258: 0000: \*****************************************************************************
6259: 0000: \***
6260: 0000: \***        %INCLUDE FOR FILE HANDLING FUNCTIONS EXTERNAL DEFINITIONS
6261: 0000: \***
6262: 0000: \***                   FILE TYPE:  DIRECT
6263: 0000: \***
6264: 0000: \***                   REFERENCE:  CCTRLEXT.J86
6265: 0000: \***
6266: 0000: \***	             DESCRIPTION:  RETURNS / AUTOMATIC CREDIT CLAIMING
6267: 0000: \***				   CREDIT CLAIMS CONTROL FILE
6268: 0000: \***
6269: 0000: \***
6270: 0000: \***      VERSION A : Michael J. Kelsall      14th September 1993
6271: 0000: \***      
6272: 0000: \*****************************************************************************
6273: 0000: \*****************************************************************************
6274: 0000: 
6275: 0000: 
6276: 0000:   FUNCTION CCTRL.SET EXTERNAL
6277: 0000:      INTEGER*2 CCTRL.SET
6278: 0000:   END FUNCTION
6279: 0000: 
6280: 0000: 
6281: 0000:   FUNCTION READ.CCTRL EXTERNAL
6282: 0000:     INTEGER*2 READ.CCTRL
6283: 0000:   END FUNCTION
6284: 0000:   
6285: 0000: 
6286: 0000:   FUNCTION READ.CCTRL.LOCKED EXTERNAL
6287: 0000:     INTEGER*2 READ.CCTRL.LOCKED
6288: 0000:   END FUNCTION  
6289: 0000: 
6290: 0000: 
6291: 0000:   FUNCTION WRITE.HOLD.CCTRL EXTERNAL
6292: 0000:     INTEGER*2 WRITE.HOLD.CCTRL
6293: 0000:   END FUNCTION
6294: 0000: 
6295: 0000: 
6296: 0000:   FUNCTION WRITE.UNLOCK.CCTRL EXTERNAL
6297: 0000:     INTEGER*2 WRITE.UNLOCK.CCTRL
6298: 0000:   END FUNCTION
6299: 0000: 
6300: 0000: 
6301: 0000:   FUNCTION WRITE.HOLD.UNLOCK.CCTRL EXTERNAL
6302: 0000:     INTEGER*2 WRITE.HOLD.UNLOCK.CCTRL
6303: 0000:   END FUNCTION
6304: 0000:   
6305: 0000: 
6306: 0000:   FUNCTION WRITE.CCTRL EXTERNAL
6307: 0000:     INTEGER*2 WRITE.CCTRL
6308: 0000:   END FUNCTION
6309: 0000: 
6310: 0000:  %INCLUDE CCTMPEXT.J86                    ! GMJK
6311: 0000: \*******************************************************************************
6312: 0000: \*******************************************************************************
6313: 0000: \***
6314: 0000: \*** RETURNS / AUTOMATIC CREDIT CLAIMING FILE EXTERNAL FILE PUBLIC DEFINITIONS
6315: 0000: \***
6316: 0000: \***                    REFERENCE    : CCTMPEXT.BAS
6317: 0000: \***
6318: 0000: \***    Version A.         Michael Kelsall              30th September 1993
6319: 0000: \***
6320: 0000: \*******************************************************************************
6321: 0000: \*******************************************************************************
6322: 0000: 
6323: 0000:  
6324: 0000:   FUNCTION CCTMP.SET EXTERNAL
6325: 0000:       INTEGER*2 CCTMP.SET
6326: 0000:   END FUNCTION
6327: 0000: 
6328: 0000: 
6329: 0000:   FUNCTION READ.CCTMP EXTERNAL
6330: 0000:       INTEGER*2 READ.CCTMP 
6331: 0000:   END FUNCTION
6332: 0000: 
6333: 0000:   
6334: 0000:   FUNCTION WRITE.CCTMP EXTERNAL
6335: 0000:       INTEGER*2 WRITE.CCTMP
6336: 0000:   END FUNCTION
6337: 0000: 
6338: 0000:   
6339: 0000:   FUNCTION WRITE.HOLD.CCTMP EXTERNAL
6340: 0000:       INTEGER*2 WRITE.HOLD.CCTMP						
6341: 0000:   END FUNCTION								
6342: 0000: 
6343: 0000:  %INCLUDE CCBUFEXT.J86                    ! GMJK
6344: 0000: \*******************************************************************************
6345: 0000: \*******************************************************************************
6346: 0000: \***
6347: 0000: \*** RETURNS / AUTOMATIC CREDIT CLAIMING FILE EXTERNAL FILE PUBLIC DEFINITIONS
6348: 0000: \***
6349: 0000: \***                    REFERENCE    : CCBUFEXT.BAS
6350: 0000: \***
6351: 0000: \***    Version A.         Michael Kelsall              30th September 1993
6352: 0000: \***
6353: 0000: \*******************************************************************************
6354: 0000: \*******************************************************************************
6355: 0000: 
6356: 0000:  
6357: 0000:   FUNCTION CCBUF.SET EXTERNAL
6358: 0000:       INTEGER*2 CCBUF.SET
6359: 0000:   END FUNCTION
6360: 0000: 
6361: 0000: 
6362: 0000:   FUNCTION READ.CCBUF EXTERNAL
6363: 0000:       INTEGER*2 READ.CCBUF 
6364: 0000:   END FUNCTION
6365: 0000: 
6366: 0000:   
6367: 0000:   FUNCTION WRITE.CCBUF EXTERNAL
6368: 0000:       INTEGER*2 WRITE.CCBUF
6369: 0000:   END FUNCTION
6370: 0000: 
6371: 0000:   
6372: 0000:   FUNCTION WRITE.HOLD.CCBUF EXTERNAL
6373: 0000:       INTEGER*2 WRITE.HOLD.CCBUF						
6374: 0000:   END FUNCTION								
6375: 0000: 
6376: 0000:  %INCLUDE CCUPFEXT.J86                    ! HMJK
6377: 0000: 
6378: 0000: \*****************************************************************************
6379: 0000: \*****************************************************************************
6380: 0000: \***
6381: 0000: \***        %INCLUDE FOR FILE HANDLING FUNCTION EXTERNAL DECLARATIONS
6382: 0000: \***
6383: 0000: \***                   FILE TYPE:  KEYED
6384: 0000: \***
6385: 0000: \***                   REFERENCE:  CCUPFEXT.J86
6386: 0000: \***
6387: 0000: \***	             DESCRIPTION:  RETURNS / AUTOMATIC CREDIT CLAIMING
6388: 0000: \***				   UOD PROCESSED FILE 
6389: 0000: \***
6390: 0000: \***      VERSION A : Michael J. Kelsall      14th March 1994
6391: 0000: \***      
6392: 0000: \*****************************************************************************
6393: 0000: \*****************************************************************************
6394: 0000: 
6395: 0000: 
6396: 0000:   FUNCTION CCUPF.SET EXTERNAL
6397: 0000:      INTEGER*2 CCUPF.SET
6398: 0000:   END FUNCTION
6399: 0000: 
6400: 0000: 
6401: 0000:   FUNCTION READ.CCUPF EXTERNAL
6402: 0000:     INTEGER*2 READ.CCUPF
6403: 0000:   END FUNCTION
6404: 0000:   
6405: 0000: 
6406: 0000:   FUNCTION READ.CCUPF.LOCKED EXTERNAL
6407: 0000:     INTEGER*2 READ.CCUPF.LOCKED
6408: 0000:   END FUNCTION  
6409: 0000: 
6410: 0000: 
6411: 0000:   FUNCTION WRITE.HOLD.CCUPF EXTERNAL
6412: 0000:     INTEGER*2 WRITE.HOLD.CCUPF
6413: 0000:   END FUNCTION
6414: 0000: 
6415: 0000: 
6416: 0000:   FUNCTION WRITE.UNLOCK.CCUPF EXTERNAL
6417: 0000:     INTEGER*2 WRITE.UNLOCK.CCUPF
6418: 0000:   END FUNCTION
6419: 0000: 
6420: 0000: 
6421: 0000:   FUNCTION WRITE.HOLD.UNLOCK.CCUPF EXTERNAL
6422: 0000:     INTEGER*2 WRITE.HOLD.UNLOCK.CCUPF
6423: 0000:   END FUNCTION
6424: 0000: 
6425: 0000: 
6426: 0000:   FUNCTION WRITE.CCUPF EXTERNAL
6427: 0000:     INTEGER*2 WRITE.CCUPF
6428: 0000:   END FUNCTION
6429: 0000: 
6430: 0000:  %INCLUDE CCWKFEXT.J86                    ! GMJK
6431: 0000: \*****************************************************************************
6432: 0000: \*****************************************************************************
6433: 0000: \***
6434: 0000: \***       EXTERNAL FUNCTION DEFINTIONS FOR CCWKF - RETURNS WORK FILE
6435: 0000: \***
6436: 0000: \***                      REFERENCE: CCWKFEXT.J86
6437: 0000: \***
6438: 0000: \***    Version A          Michael J. Kelsall            30th September 1993
6439: 0000: \***
6440: 0000: \*****************************************************************************
6441: 0000: \*****************************************************************************
6442: 0000: 
6443: 0000:    FUNCTION CCWKF.SET EXTERNAL
6444: 0000:       INTEGER*2 CCWKF.SET
6445: 0000:    END FUNCTION
6446: 0000:    
6447: 0000:    FUNCTION READ.CCWKF EXTERNAL
6448: 0000:       INTEGER*2 READ.CCWKF
6449: 0000:    END FUNCTION
6450: 0000:    
6451: 0000:    FUNCTION WRITE.CCWKF EXTERNAL
6452: 0000:       INTEGER*2 WRITE.CCWKF
6453: 0000:    END FUNCTION
6454: 0000:    
6455: 0000:  %INCLUDE CCDMYEXT.J86                    ! GMJK
6456: 0000: \*****************************************************************************
6457: 0000: \*****************************************************************************
6458: 0000: \***
6459: 0000: \***        EXTERNAL FUNCTION DEFINITIONS FOR RETURNS DUMMY FILE
6460: 0000: \***
6461: 0000: \***                      REFERENCE: CCDMYEXT.J86
6462: 0000: \***
6463: 0000: \***    Version A       Michael J. Kelsall             30th September 1993
6464: 0000: \***
6465: 0000: \*****************************************************************************
6466: 0000: \*****************************************************************************
6467: 0000: 
6468: 0000:    FUNCTION CCDMY.SET EXTERNAL
6469: 0000:       INTEGER*2 CCDMY.SET
6470: 0000:    END FUNCTION
6471: 0000:    
6472: 0000:    
6473: 0000:  %INCLUDE LDTAFEXT.J86                    ! HMJK
6474: 0000: 
6475: 0000: \*****************************************************************************
6476: 0000: \*****************************************************************************
6477: 0000: \***
6478: 0000: \***        %INCLUDE FOR FILE HANDLING FUNCTIONS EXTERNAL DEFINITIONS
6479: 0000: \***
6480: 0000: \***                   FILE TYPE:  DIRECT
6481: 0000: \***
6482: 0000: \***                   REFERENCE:  LDTAFEXT.J86
6483: 0000: \***
6484: 0000: \***	             DESCRIPTION:  LDT / PDT SUPPORT LINK AUDIT FILE
6485: 0000: \***
6486: 0000: \***
6487: 0000: \***      VERSION A        Michael J. Kelsall        30th September 1993
6488: 0000: \*** 
6489: 0000: \***      VERSION B        Michael J. Kelsall        25th March 1994
6490: 0000: \***      No change to external definitions.
6491: 0000: \***      
6492: 0000: \*****************************************************************************
6493: 0000: \*****************************************************************************
6494: 0000: 
6495: 0000: 
6496: 0000:   FUNCTION LDTAF.SET EXTERNAL
6497: 0000:      INTEGER*2 LDTAF.SET
6498: 0000:   END FUNCTION
6499: 0000: 
6500: 0000: 
6501: 0000:   FUNCTION READ.LDTAF EXTERNAL
6502: 0000:     INTEGER*2 READ.LDTAF
6503: 0000:   END FUNCTION
6504: 0000:   
6505: 0000: 
6506: 0000:   FUNCTION WRITE.HOLD.LDTAF EXTERNAL
6507: 0000:     INTEGER*2 WRITE.HOLD.LDTAF
6508: 0000:   END FUNCTION
6509: 0000: 
6510: 0000: 
6511: 0000:   FUNCTION WRITE.LDTAF EXTERNAL
6512: 0000:     INTEGER*2 WRITE.LDTAF
6513: 0000:   END FUNCTION
6514: 0000: 
6515: 0000:  %INCLUDE SOFTSEXT.J86                    ! GMJK
6516: 0000: \*******************************************************************************
6517: 0000: \***                                                                         ***
6518: 0000: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE SOFTWARE STATUS FILE         ***
6519: 0000: \***                                                                         ***
6520: 0000: \***                     REFERENCE : SOFTSEXT.J86                            ***
6521: 0000: \***                                                                         ***
6522: 0000: \***      Version A         Andrew Wedgeworth          1st July 1992         ***
6523: 0000: \***
6524: 0000: \***   Version B
6525: 0000: \***                                                                      ***
6526: 0000: \***      Version C         Steve Wright               3rd May 1996          ***
6527: 0000: \***      Synchronise with function source.                                  ***
6528: 0000: \*******************************************************************************
6529: 0000: 
6530: 0000:       FUNCTION SOFTS.SET EXTERNAL 
6531: 0000:       END FUNCTION
6532: 0000:       
6533: 0000:       FUNCTION READ.SOFTS EXTERNAL
6534: 0000:           INTEGER*2 I%, READ.SOFTS
6535: 0000:       END FUNCTION	                   
6536: 0000: 
6537: 0000:       FUNCTION WRITE.SOFTS EXTERNAL
6538: 0000:           INTEGER*2 I%, WRITE.SOFTS
6539: 0000:       END FUNCTION
6540: 0000: 
6541: 0000: 
6542: 0000:  %INCLUDE STKBFEXT.J86                    ! 1.5
6543: 0000: \******************************************************************************
6544: 0000: \******************************************************************************
6545: 0000: \***
6546: 0000: \***   $Workfile:   STKBFEXT.J86  $
6547: 0000: \***
6548: 0000: \***   $Revision:   1.0  $
6549: 0000: \***
6550: 0000: \******************************************************************************
6551: 0000: \******************************************************************************
6552: 0000: \***
6553: 0000: \***   $Log:   V:\archive\j86\stkbfext.j8v  $
6554: 0000: \***   
6555: 0000: \***      Rev 1.0   15 Jul 1997 14:20:38   DEV45PS
6556: 0000: \***    
6557: 0000: \***   
6558: 0000: \***      Rev 1.0   09 Jul 1997 11:04:54   DEV45PS
6559: 0000: \***   Stocktake System New Files
6560: 0000: \***   
6561: 0000: \******************************************************************************
6562: 0000: \******************************************************************************\*****************************************************************************
6563: 0000: \***
6564: 0000: \***           FUNCTION DEFINITIONS FOR THE STOCKTAKE BUFFER FILE
6565: 0000: \***
6566: 0000: \***           REFERENCE:   STKBFEXT.J86
6567: 0000: \***
6568: 0000: \***           VERSION A         Nik Sen         19th June 1997
6569: 0000: \***
6570: 0000: \***
6571: 0000: \*******************************************************************************
6572: 0000: \*******************************************************************************
6573: 0000: 
6574: 0000:    FUNCTION STKBF.SET EXTERNAL
6575: 0000:    END FUNCTION
6576: 0000:    
6577: 0000:    FUNCTION READ.STKBF EXTERNAL
6578: 0000:       INTEGER*2 READ.STKBF
6579: 0000:    END FUNCTION
6580: 0000:    
6581: 0000:    FUNCTION WRITE.STKBF EXTERNAL
6582: 0000:       INTEGER*2 WRITE.STKBF
6583: 0000:    END FUNCTION
6584: 0000:  
6585: 0000:  %INCLUDE SXTMPEXT.J86                    ! 1.5
6586: 0000: \*****************************************************************************
6587: 0000: \***
6588: 0000: \***           FUNCTION DEFINITIONS FOR THE TEMPORARY STOCKTAKE BUFFER FILE
6589: 0000: \***
6590: 0000: \***           REFERENCE:   STKBFEXT.J86
6591: 0000: \***
6592: 0000: \***           VERSION A         Nik Sen         30th June 1997
6593: 0000: \***
6594: 0000: \***
6595: 0000: \*******************************************************************************
6596: 0000: \*******************************************************************************
6597: 0000: 
6598: 0000:    FUNCTION SXTMP.SET EXTERNAL
6599: 0000:    END FUNCTION
6600: 0000:    
6601: 0000:    FUNCTION READ.SXTMP EXTERNAL
6602: 0000:       INTEGER*2 READ.SXTMP
6603: 0000:    END FUNCTION
6604: 0000:    
6605: 0000:    FUNCTION WRITE.SXTMP EXTERNAL
6606: 0000:       INTEGER*2 WRITE.SXTMP
6607: 0000:    END FUNCTION
6608: 0000:  
6609: 0000:  %INCLUDE STKTKEXT.J86                    ! 1.5
6610: 0000: \*****************************************************************************
6611: 0000: \*****************************************************************************
6612: 0000: \***
6613: 0000: \***      EXTERNAL FUNCTION DEFINITIONS FOR STOCKTAKE
6614: 0000: \***
6615: 0000: \***      REFERENCE: STKTKEXT.J86
6616: 0000: \***
6617: 0000: \*****************************************************************************
6618: 0000: \*****************************************************************************
6619: 0000: 
6620: 0000: 
6621: 0000:    FUNCTION STKTK.SET EXTERNAL
6622: 0000:    END FUNCTION
6623: 0000:    
6624: 0000:  %INCLUDE STLDTEXT.J86                    ! 1.6
6625: 0000: \*****************************************************************************
6626: 0000: \*****************************************************************************
6627: 0000: \***
6628: 0000: \***                   FUNCTION DEFINITIONS FOR THE STLDT
6629: 0000: \***
6630: 0000: \***           Version A           David Artiss         20th December 2000
6631: 0000: \***
6632: 0000: \*****************************************************************************
6633: 0000: \*****************************************************************************
6634: 0000: 
6635: 0000:    FUNCTION STLDT.SET EXTERNAL
6636: 0000:    END FUNCTION
6637: 0000: 
6638: 0000:   FUNCTION READ.STLDT EXTERNAL
6639: 0000:    INTEGER*2 READ.STLDT
6640: 0000:   END FUNCTION
6641: 0000: 
6642: 0000:   FUNCTION WRITE.STLDT EXTERNAL
6643: 0000:    INTEGER*2 WRITE.STLDT
6644: 0000:   END FUNCTION
6645: 0000:  %INCLUDE SXTCFEXT.J86                    ! 1.8DA
6646: 0000: \******************************************************************************
6647: 0000: \******************************************************************************
6648: 0000: \***
6649: 0000: \***   $Workfile:   SXTCFEXT.J86  $
6650: 0000: \***
6651: 0000: \***   $Revision:   1.0  $
6652: 0000: \***
6653: 0000: \******************************************************************************
6654: 0000: \******************************************************************************
6655: 0000: \***
6656: 0000: \***   $Log:   V:\archive\j86\sxtcfext.j8v  $
6657: 0000: \***   
6658: 0000: \***      Rev 1.0   15 Jul 1997 14:21:08   DEV45PS
6659: 0000: \***    
6660: 0000: \***   
6661: 0000: \***      Rev 1.0   09 Jul 1997 11:05:30   DEV45PS
6662: 0000: \***   Stocktake System New Files
6663: 0000: \***   
6664: 0000: \******************************************************************************
6665: 0000: \******************************************************************************\*****************************************************************************
6666: 0000: \*****************************************************************************
6667: 0000: \***
6668: 0000: \***                  FUNCTION DEFINITIONS FOR SXTCF
6669: 0000: \***
6670: 0000: \***                      REFERENCE    : SXTCFEXA
6671: 0000: \***
6672: 0000: \***           VERSION A : NIK SEN  3rd July 1997
6673: 0000: \***
6674: 0000: \*****************************************************************************
6675: 0000: \*****************************************************************************
6676: 0000: 
6677: 0000:    FUNCTION SXTCF.SET EXTERNAL
6678: 0000:    END FUNCTION
6679: 0000: 
6680: 0000:   FUNCTION READ.SXTCF.LOCK EXTERNAL
6681: 0000:    INTEGER*1 READ.SXTCF.LOCK
6682: 0000:   END FUNCTION
6683: 0000: 
6684: 0000:   FUNCTION WRITE.SXTCF.UNLOCK EXTERNAL
6685: 0000:    INTEGER*1 WRITE.SXTCF.UNLOCK
6686: 0000:   END FUNCTION
6687: 0000: 
6688: 0000:   FUNCTION WRITE.SXTCF.UNLOCK.HOLD EXTERNAL
6689: 0000:    INTEGER*1 WRITE.SXTCF.UNLOCK.HOLD
6690: 0000:   END FUNCTION
6691: 0000: 
6692: 0000:   FUNCTION READ.SXTCF EXTERNAL
6693: 0000:    INTEGER*1 READ.SXTCF
6694: 0000:   END FUNCTION
6695: 0000: 
6696: 0000:   FUNCTION WRITE.SXTCF         EXTERNAL
6697: 0000:    INTEGER*1 WRITE.SXTCF        
6698: 0000:   END FUNCTION
6699: 0000: 
6700: 0000:  %INCLUDE STKCFEXT.J86                    ! 1.8DA
6701: 0000: \*****************************************************************************
6702: 0000: \*****************************************************************************
6703: 0000: \***
6704: 0000: \***                  FUNCTION DEFINITIONS FOR STKCF
6705: 0000: \***
6706: 0000: \***                      REFERENCE    : STKCFEXA
6707: 0000: \***
6708: 0000: \***           VERSION A : STEVEN GOULDING  11.01.93
6709: 0000: \***
6710: 0000: \*****************************************************************************
6711: 0000: \*****************************************************************************
6712: 0000: 
6713: 0000:    FUNCTION STKCF.SET EXTERNAL
6714: 0000:    END FUNCTION
6715: 0000: 
6716: 0000:   FUNCTION READ.STKCF.LOCK EXTERNAL
6717: 0000:    INTEGER*1 READ.STKCF.LOCK
6718: 0000:   END FUNCTION
6719: 0000: 
6720: 0000:   FUNCTION WRITE.STKCF.UNLOCK EXTERNAL
6721: 0000:    INTEGER*1 WRITE.STKCF.UNLOCK
6722: 0000:   END FUNCTION
6723: 0000: 
6724: 0000:   FUNCTION WRITE.STKCF.UNLOCK.HOLD EXTERNAL
6725: 0000:    INTEGER*1 WRITE.STKCF.UNLOCK.HOLD
6726: 0000:   END FUNCTION
6727: 0000: 
6728: 0000:   FUNCTION READ.STKCF EXTERNAL
6729: 0000:    INTEGER*1 READ.STKCF
6730: 0000:   END FUNCTION
6731: 0000: 
6732: 0000:   FUNCTION WRITE.STKCF         EXTERNAL
6733: 0000:    INTEGER*1 WRITE.STKCF        
6734: 0000:   END FUNCTION
6735: 0000: 
6736: 0000:  %INCLUDE STKMFEXT.J86                    ! 1.8DA
6737: 0000: \******************************************************************************
6738: 0000: \******************************************************************************
6739: 0000: \***
6740: 0000: \***   $Workfile:   STKMFEXT.J86  $
6741: 0000: \***
6742: 0000: \***   $Revision:   1.0  $
6743: 0000: \***
6744: 0000: \******************************************************************************
6745: 0000: \******************************************************************************
6746: 0000: \***
6747: 0000: \***   $Log:   V:\archive\j86\stkmfext.j8v  $
6748: 0000: \***   
6749: 0000: \***      Rev 1.0   15 Jul 1997 14:20:56   DEV45PS
6750: 0000: \***    
6751: 0000: \***   
6752: 0000: \***      Rev 1.0   09 Jul 1997 11:05:18   DEV45PS
6753: 0000: \***   Stocktake System New Files
6754: 0000: \***   
6755: 0000: \******************************************************************************
6756: 0000: \******************************************************************************\*****************************************************************************
6757: 0000: \***
6758: 0000: \***  FUNCTION DEFINITIONS FOR THE STOCKTAKE MAINFRAME TRANSMISSION FILE
6759: 0000: \***
6760: 0000: \***           REFERENCE:   STKMFEXT.J86
6761: 0000: \***
6762: 0000: \***           VERSION A         Nik Sen         19th June 1997
6763: 0000: \***
6764: 0000: \***
6765: 0000: \*******************************************************************************
6766: 0000: \*******************************************************************************
6767: 0000: 
6768: 0000:    FUNCTION STKMF.SET EXTERNAL
6769: 0000:    END FUNCTION
6770: 0000:    
6771: 0000:    FUNCTION READ.STKMF EXTERNAL
6772: 0000:       INTEGER*2 READ.STKMF
6773: 0000:    END FUNCTION
6774: 0000:    
6775: 0000:    FUNCTION WRITE.STKMF EXTERNAL
6776: 0000:       INTEGER*2 WRITE.STKMF
6777: 0000:    END FUNCTION
6778: 0000:  
6779: 0000:  %INCLUDE STKRCEXT.J86                    ! 1.8DA
6780: 0000: \******************************************************************************
6781: 0000: \******************************************************************************
6782: 0000: \***
6783: 0000: \***   $Workfile:   STKRCEXT.J86  $
6784: 0000: \***
6785: 0000: \***   $Revision:   1.0  $
6786: 0000: \***
6787: 0000: \******************************************************************************
6788: 0000: \******************************************************************************
6789: 0000: \***
6790: 0000: \***   $Log:   V:\archive\j86\stkrcext.j8v  $
6791: 0000: \***   
6792: 0000: \***      Rev 1.0   15 Jul 1997 14:21:00   DEV45PS
6793: 0000: \***    
6794: 0000: \***   
6795: 0000: \***      Rev 1.0   09 Jul 1997 11:05:24   DEV45PS
6796: 0000: \***   Stocktake System New Files
6797: 0000: \***   
6798: 0000: \******************************************************************************
6799: 0000: \******************************************************************************\*****************************************************************************
6800: 0000: \***
6801: 0000: \***           FUNCTION DEFINITIONS FOR THE STOCKTAKE RECOUNT FILE
6802: 0000: \***
6803: 0000: \***           REFERENCE:   STKRCEXT.J86
6804: 0000: \***
6805: 0000: \***           VERSION A         Nik Sen         19th June 1997
6806: 0000: \***
6807: 0000: \***
6808: 0000: \*******************************************************************************
6809: 0000: \*******************************************************************************
6810: 0000: 
6811: 0000:    FUNCTION STKRC.SET EXTERNAL
6812: 0000:    END FUNCTION
6813: 0000:    
6814: 0000:    FUNCTION READ.STKRC EXTERNAL
6815: 0000:       INTEGER*2 READ.STKRC
6816: 0000:    END FUNCTION
6817: 0000:    
6818: 0000:    FUNCTION WRITE.STKRC EXTERNAL
6819: 0000:       INTEGER*2 WRITE.STKRC
6820: 0000:    END FUNCTION
6821: 0000:  
6822: 0000:  %INCLUDE XGCFEXT.J86                     ! 1.8DA
6823: 0000: \******************************************************************************
6824: 0000: \******************************************************************************
6825: 0000: \***
6826: 0000: \***         %INCLUDE FOR STOCKTAKE GROUP CODE FILE
6827: 0000: \***
6828: 0000: \***                  FILE TYPE    : Keyed
6829: 0000: \***
6830: 0000: \***                  REFERENCE    : XGCFEXT.J86
6831: 0000: \***
6832: 0000: \***    VERSION A               Steve Wright                        24 Aug 1999
6833: 0000: \***
6834: 0000: \*******************************************************************************
6835: 0000: \*******************************************************************************
6836: 0000: 
6837: 0000: FUNCTION XGCF.SET EXTERNAL
6838: 0000: END FUNCTION
6839: 0000: 
6840: 0000: FUNCTION READ.XGCF EXTERNAL
6841: 0000:    INTEGER*2 READ.XGCF
6842: 0000: END FUNCTION
6843: 0000: 
6844: 0000: FUNCTION READ.XGCF.LOCK EXTERNAL
6845: 0000:    INTEGER*2 READ.XGCF.LOCK
6846: 0000: END FUNCTION
6847: 0000: 
6848: 0000: FUNCTION WRITE.XGCF EXTERNAL
6849: 0000:    INTEGER*2 WRITE.XGCF
6850: 0000: END FUNCTION
6851: 0000: 
6852: 0000: FUNCTION WRITE.XGCF.HOLD EXTERNAL
6853: 0000:    INTEGER*2 WRITE.XGCF.HOLD
6854: 0000: END FUNCTION
6855: 0000: 
6856: 0000: FUNCTION WRITE.XGCF.UNLOCK EXTERNAL
6857: 0000:    INTEGER*2 WRITE.XGCF.UNLOCK
6858: 0000: END FUNCTION
6859: 0000: 
6860: 0000:  %INCLUDE STKEXEXT.J86                    ! 1.8DA
6861: 0000: \******************************************************************************
6862: 0000: \******************************************************************************
6863: 0000: \***
6864: 0000: \***   $Workfile:   STKEXEXT.J86  $
6865: 0000: \***
6866: 0000: \***   $Revision:   1.0  $
6867: 0000: \***
6868: 0000: \******************************************************************************
6869: 0000: \******************************************************************************
6870: 0000: \***
6871: 0000: \***   $Log:   V:\archive\j86\stkexext.j8v  $
6872: 0000: \***   
6873: 0000: \***      Rev 1.0   15 Jul 1997 14:20:44   DEV45PS
6874: 0000: \***    
6875: 0000: \***   
6876: 0000: \***      Rev 1.0   09 Jul 1997 11:05:06   DEV45PS
6877: 0000: \***   Stocktake System New Files
6878: 0000: \***   
6879: 0000: \******************************************************************************
6880: 0000: \******************************************************************************\*****************************************************************************
6881: 0000: \***
6882: 0000: \***           FUNCTION DEFINITIONS FOR THE STOCKTAKE EXCEPTIONS FILE
6883: 0000: \***
6884: 0000: \***           REFERENCE:   STKEXEXT.J86
6885: 0000: \***
6886: 0000: \***           VERSION A         Nik Sen         19th June 1997
6887: 0000: \***
6888: 0000: \***
6889: 0000: \*******************************************************************************
6890: 0000: \*******************************************************************************
6891: 0000: 
6892: 0000:    FUNCTION STKEX.SET EXTERNAL
6893: 0000:    END FUNCTION
6894: 0000:    
6895: 0000:    FUNCTION READ.STKEX EXTERNAL
6896: 0000:       INTEGER*2 READ.STKEX
6897: 0000:    END FUNCTION
6898: 0000:    
6899: 0000:    FUNCTION WRITE.STKEX EXTERNAL
6900: 0000:       INTEGER*2 WRITE.STKEX
6901: 0000:    END FUNCTION
6902: 0000:  
6903: 0000:  %INCLUDE STKIFEXT.J86                    ! 1.8DA
6904: 0000: \******************************************************************************
6905: 0000: \******************************************************************************
6906: 0000: \***
6907: 0000: \***   $Workfile:   STKIFEXT.J86  $
6908: 0000: \***
6909: 0000: \***   $Revision:   1.0  $
6910: 0000: \***
6911: 0000: \******************************************************************************
6912: 0000: \******************************************************************************
6913: 0000: \***
6914: 0000: \***   $Log:   V:\archive\j86\stkifext.j8v  $
6915: 0000: \***   
6916: 0000: \***      Rev 1.0   15 Jul 1997 14:20:48   DEV45PS
6917: 0000: \***    
6918: 0000: \***   
6919: 0000: \***      Rev 1.0   09 Jul 1997 11:05:12   DEV45PS
6920: 0000: \***   Stocktake System New Files
6921: 0000: \***   
6922: 0000: \******************************************************************************
6923: 0000: \******************************************************************************\*****************************************************************************
6924: 0000: \***
6925: 0000: \***           FUNCTION DEFINITIONS FOR THE STOCKTAKE ITEM FILE
6926: 0000: \***
6927: 0000: \***           REFERENCE:   STKIFEXT.J86
6928: 0000: \***
6929: 0000: \***           VERSION A         Nik Sen         19th June 1997
6930: 0000: \***
6931: 0000: \***
6932: 0000: \*******************************************************************************
6933: 0000: \*******************************************************************************
6934: 0000: 
6935: 0000:    FUNCTION STKIF.SET EXTERNAL
6936: 0000:    END FUNCTION
6937: 0000:    
6938: 0000:    FUNCTION READ.STKIF EXTERNAL
6939: 0000:       INTEGER*2 READ.STKIF
6940: 0000:    END FUNCTION
6941: 0000:    
6942: 0000:    FUNCTION WRITE.STKIF EXTERNAL
6943: 0000:       INTEGER*2 WRITE.STKIF
6944: 0000:    END FUNCTION
6945: 0000:  
6946: 0000:  %INCLUDE LOCNTEXT.J86                    ! 1.8DA
6947: 0000: \******************************************************************************
6948: 0000: \******************************************************************************
6949: 0000: \***
6950: 0000: \***   $Workfile:   LOCNTEXT.J86  $
6951: 0000: \***
6952: 0000: \***   $Revision:   1.0  $
6953: 0000: \***
6954: 0000: \******************************************************************************
6955: 0000: \******************************************************************************
6956: 0000: \***
6957: 0000: \***   $Log:   V:\archive\j86\locntext.j8v  $
6958: 0000: \***   
6959: 0000: \***      Rev 1.0   03 Feb 1998 10:07:40   DEV69PS
6960: 0000: \***    
6961: 0000: \***   
6962: 0000: \******************************************************************************
6963: 0000: \******************************************************************************
6964: 0000: \***
6965: 0000: \***           FUNCTION DEFINITIONS FOR THE STOCKTAKE LOCATION COUNT FILE
6966: 0000: \***
6967: 0000: \***           REFERENCE:   LOCNTEXT.J86
6968: 0000: \***
6969: 0000: \***           VERSION A         Johnnie Chan    6th Jan 1998
6970: 0000: \***
6971: 0000: \***
6972: 0000: \*******************************************************************************
6973: 0000: \*******************************************************************************
6974: 0000: 
6975: 0000:    FUNCTION LOCCNT.SET EXTERNAL
6976: 0000:    END FUNCTION
6977: 0000:    
6978: 0000:    FUNCTION READ.LOCCNT EXTERNAL
6979: 0000:       INTEGER*2 READ.LOCCNT
6980: 0000:    END FUNCTION
6981: 0000:    
6982: 0000:    FUNCTION WRITE.LOCCNT EXTERNAL
6983: 0000:       INTEGER*2 WRITE.LOCCNT
6984: 0000:    END FUNCTION
6985: 0000: 
6986: 0000:    FUNCTION GET.LOCCNT.RECNUM(LOC.CODE$) EXTERNAL
6987: 0000:       INTEGER*4 GET.LOCCNT.RECNUM
6988: 0000:       STRING LOC.CODE$
6989: 0000:    END FUNCTION
6990: 0000:  
6991: 0000:  %INCLUDE STKIGEXT.J86                    ! 1.8DA
6992: 0000: \*****************************************************************************
6993: 0000: \***
6994: 0000: \***           FUNCTION DEFINITIONS FOR THE STOCKTAKE ITEM GROUP FILE
6995: 0000: \***
6996: 0000: \***           REFERENCE:   STKIGEXT.J86
6997: 0000: \***
6998: 0000: \***           VERSION A         Nik Sen         17th June 1997
6999: 0000: \***
7000: 0000: \***
7001: 0000: \*******************************************************************************
7002: 0000: \*******************************************************************************
7003: 0000: 
7004: 0000:    FUNCTION STKIG.SET EXTERNAL
7005: 0000:    END FUNCTION
7006: 0000:    
7007: 0000:    FUNCTION READ.STKIG EXTERNAL
7008: 0000:       INTEGER*2 READ.STKIG
7009: 0000:    END FUNCTION
7010: 0000:    
7011: 0000:    FUNCTION WRITE.STKIG EXTERNAL
7012: 0000:       INTEGER*2 WRITE.STKIG
7013: 0000:    END FUNCTION
7014: 0000:  
7015: 0000:  %INCLUDE STKTFEXT.J86                    ! 1.8DA
7016: 0000: \******************************************************************************
7017: 0000: \******************************************************************************
7018: 0000: \***
7019: 0000: \***   $Workfile:   STKTFEXT.J86  $
7020: 0000: \***
7021: 0000: \***   $Revision:   1.1  $
7022: 0000: \***
7023: 0000: \******************************************************************************
7024: 0000: \******************************************************************************
7025: 0000: \***
7026: 0000: \***   $Log:   V:\archive\j86\stktfext.j8v  $
7027: 0000: \***   
7028: 0000: \***      Rev 1.1   15 Jul 1997 14:36:30   DEV45PS
7029: 0000: \***    
7030: 0000: \***   
7031: 0000: \***      Rev 1.0   15 Jul 1997 14:21:04   DEV45PS
7032: 0000: \***   Stocktake System New Files
7033: 0000: \***   
7034: 0000: \******************************************************************************
7035: 0000: \******************************************************************************\*****************************************************************************
7036: 0000: \***
7037: 0000: \***           FUNCTION DEFINITIONS FOR THE STOCKTAKE TOTALS FILE
7038: 0000: \***
7039: 0000: \***           REFERENCE:   STKTFEXT.J86
7040: 0000: \***
7041: 0000: \***           VERSION A         Nik Sen         15th July 1997
7042: 0000: \***
7043: 0000: \***
7044: 0000: \*******************************************************************************
7045: 0000: \*******************************************************************************
7046: 0000: 
7047: 0000:    FUNCTION STKTF.SET EXTERNAL
7048: 0000:    END FUNCTION
7049: 0000:    
7050: 0000:    FUNCTION READ.STKTF EXTERNAL
7051: 0000:       INTEGER*2 READ.STKTF
7052: 0000:    END FUNCTION
7053: 0000:    
7054: 0000:    FUNCTION WRITE.STKTF EXTERNAL
7055: 0000:       INTEGER*2 WRITE.STKTF
7056: 0000:    END FUNCTION
7057: 0000:  
7058: 0000:  %INCLUDE IRFEXT.J86                      ! 1.8DA
7059: 0000: \*********************************************************************************
7060: 0000: \***
7061: 0000: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE ITEM REFERENCE FILE
7062: 0000: \***
7063: 0000: \***                    REFERENCE : IRFEXT.J86
7064: 0000: \***
7065: 0000: \***      Version A          Andrew Wedgeworth        9th July 1992
7066: 0000: \***
7067: 0000: \***      Version B          Andrew Wedgeworth        14th December 1992
7068: 0000: \***      Version letter incremented to match other IRF code.
7069: 0000: \***
7070: 0000: \***      Version C           Steve Windsor        12.02.93
7071: 0000: \***      Added external reference to read the alternate IRF.
7072: 0000: \***
7073: 0000: \***      Version D           Steve Windsor        12.05.93
7074: 0000: \***      Added all external references that wre in the original FNS.
7075: 0000: \***
7076: 0000: \***      Version E           Steve Perkins        21.09.93
7077: 0000: \***      Deals project: Fields changed for new deals project
7078: 0000: \*** 
7079: 0000: \***      Version F           Mark Walker          5th January 1994
7080: 0000: \***      Version letter incremented to match other IRF code.           
7081: 0000: \***                                                                    
7082: 0000: \***      Version G     Stuart William McConnachie      11th February 2000
7083: 0000: \***      Converted IRF.INDICAT2$ to integer flag byte.
7084: 0000: \***
7085: 0000: \***      REVISION 1.6.               ROBERT COWEY.               9 JUL 2002.
7086: 0000: \***      Major changes to IRF layout for 2002 Deals Rewrite project.
7087: 0000: \***      No changes to this particular file for this revision.
7088: 0000: \***
7089: 0000: \***      REVISION 1.7.               ROBERT COWEY.               5 AUG 2002.
7090: 0000: \***      Further changes for 2002 Deals Rewrite project (PSBF19 related).
7091: 0000: \***      Defined new functions CONCAT.NEW.IRF.DATA$ and SPLIT.NEW.IRF.DATA$.
7092: 0000: \***
7093: 0000: \***      REVISION 1.8                ROBERT COWEY.              15 JUL 2003.
7094: 0000: \***      Usage of INDICAT0% bit-3 X'08' changed to Item Contains Alcohol.
7095: 0000: \***      No changes to this file other than description.
7096: 0000: \***      No changes to IRF file functions.
7097: 0000: \***
7098: 0000: \***      REVISION 1.9.      STUART WILLIAM MCCONNACHIE           22 OCT 2003.
7099: 0000: \***      Changes to remove limit of 3 deals per item.
7100: 0000: \***      No changes to this file.
7101: 0000: \***
7102: 0000: \***      REVISION 2.0.             ALAN CARR                      9 FEB 2006.
7103: 0000: \***      Add new IRF.INDICAT8% 1 byte, amend IRF.UNUSED$ from 3 to 2 bytes.
7104: 0000: \***      No changes to this file.
7105: 0000: \***
7106: 0000: \***..............................................................................
7107: 0000:    
7108: 0000:    FUNCTION IRF.SET EXTERNAL
7109: 0000:    END FUNCTION
7110: 0000: 
7111: 0000:   FUNCTION CONCAT.NEW.IRF.DATA$ EXTERNAL                                  ! 1.7 RC
7112: 0000:   END FUNCTION                                                            ! 1.7 RC
7113: 0000: 
7114: 0000:   FUNCTION SPLIT.NEW.IRF.DATA$ EXTERNAL                                   ! 1.7 RC
7115: 0000:   END FUNCTION                                                            ! 1.7 RC
7116: 0000:   
7117: 0000:   FUNCTION READ.IRF EXTERNAL
7118: 0000:    INTEGER*2 READ.IRF
7119: 0000:   END FUNCTION
7120: 0000: 
7121: 0000:   FUNCTION READ.IRF.ALT EXTERNAL
7122: 0000:    INTEGER*2 READ.IRF.ALT
7123: 0000:   END FUNCTION
7124: 0000: 
7125: 0000:   FUNCTION READ.IRF.LOCK EXTERNAL
7126: 0000:    INTEGER*2 READ.IRF.LOCK
7127: 0000:   END FUNCTION
7128: 0000: 
7129: 0000:   FUNCTION WRITE.IRF EXTERNAL
7130: 0000:    INTEGER*2 WRITE.IRF
7131: 0000:   END FUNCTION
7132: 0000: 
7133: 0000:   FUNCTION WRITE.IRF.UNLOCK EXTERNAL
7134: 0000:    INTEGER*2 WRITE.IRF.UNLOCK
7135: 0000:   END FUNCTION
7136: 0000: 
7137: 0000:   FUNCTION WRITE.IRF.HOLD EXTERNAL
7138: 0000:    INTEGER*2 WRITE.IRF.HOLD
7139: 0000:   END FUNCTION
7140: 0000: 
7141: 0000:   FUNCTION WRITE.IRF.HOLD.UNLOCK EXTERNAL
7142: 0000:    INTEGER*2 WRITE.IRF.HOLD.UNLOCK
7143: 0000:   END FUNCTION
7144: 0000: 
7145: 0000:   
7146: 0000:  %INCLUDE STKDCEXT.J86                    ! 1.8DA
7147: 0000: \******************************************************************************
7148: 0000: \******************************************************************************
7149: 0000: \***
7150: 0000: \***   $Workfile:   STKDCEXT.J86  $
7151: 0000: \***
7152: 0000: \***   $Revision:   1.0  $
7153: 0000: \***
7154: 0000: \******************************************************************************
7155: 0000: \******************************************************************************
7156: 0000: \***
7157: 0000: \***   $Log:   V:\archive\j86\stkdcext.j8v  $
7158: 0000: \***   
7159: 0000: \***      Rev 1.0   15 Jul 1997 14:20:40   DEV45PS
7160: 0000: \***    
7161: 0000: \***   
7162: 0000: \***      Rev 1.0   09 Jul 1997 11:05:00   DEV45PS
7163: 0000: \***   Stocktake System New Files
7164: 0000: \***   
7165: 0000: \******************************************************************************
7166: 0000: \******************************************************************************\*****************************************************************************
7167: 0000: \***
7168: 0000: \***           FUNCTION DEFINITIONS FOR THE STOCKTAKE DUMP CODE FILE
7169: 0000: \***
7170: 0000: \***           REFERENCE:   STKDCEXT.J86
7171: 0000: \***
7172: 0000: \***           VERSION A         Nik Sen         19th June 1997
7173: 0000: \***
7174: 0000: \***
7175: 0000: \*******************************************************************************
7176: 0000: \*******************************************************************************
7177: 0000: 
7178: 0000:    FUNCTION STKDC.SET EXTERNAL
7179: 0000:    END FUNCTION
7180: 0000:    
7181: 0000:    FUNCTION READ.STKDC EXTERNAL
7182: 0000:       INTEGER*2 READ.STKDC
7183: 0000:    END FUNCTION
7184: 0000:    
7185: 0000:    FUNCTION WRITE.STKDC EXTERNAL
7186: 0000:       INTEGER*2 WRITE.STKDC
7187: 0000:    END FUNCTION
7188: 0000:  
7189: 0000:  %INCLUDE IMSTCEXT.J86                    ! 1.9BG
7190: 0000: \***********************************************************************
7191: 0000: \***********************************************************************
7192: 0000: \***
7193: 0000: \***    DESCRIPTION: Item Movement & Stock File
7194: 0000: \***                 External File Function Definitions
7195: 0000: \***
7196: 0000: \***    FILE TYPE : Keyed
7197: 0000: \***
7198: 0000: \***********************************************************************
7199: 0000: \***
7200: 0000: \***    Version A.          Les Cook                     21st Aug 1992
7201: 0000: \***    Initial version.
7202: 0000: \***
7203: 0000: \***    VERSION 1.1         Julia Stones                 13th Jun 2005
7204: 0000: \***    Added new external functions for
7205: 0000: \***        MIMSTC - merged IMSTC
7206: 0000: \***        CIMSTC - Copy of IMSTC
7207: 0000: \***        BIMSTC - Backup of IMSTC
7208: 0000: \***
7209: 0000: \***    Version C.          Mark Walker                  23rd Jan 2014
7210: 0000: \***    F337 Centralised View of Stock
7211: 0000: \***    - Moved BIMST, CIMST and MIMST external function definitions
7212: 0000: \***      to separate modules.
7213: 0000: \***    - Minor formatting changes (uncommented).
7214: 0000: \***
7215: 0000: \***********************************************************************
7216: 0000: \***********************************************************************
7217: 0000: 
7218: 0000: FUNCTION IMSTC.SET EXTERNAL
7219: 0000: END FUNCTION
7220: 0000: 
7221: 0000: FUNCTION READ.IMSTC EXTERNAL
7222: 0000:     INTEGER*2 READ.IMSTC
7223: 0000: END FUNCTION
7224: 0000: 
7225: 0000: FUNCTION READ.IMSTC.LOCK EXTERNAL
7226: 0000:     INTEGER*2 READ.IMSTC.LOCK
7227: 0000: END FUNCTION
7228: 0000: 
7229: 0000: FUNCTION WRITE.IMSTC EXTERNAL
7230: 0000:    INTEGER*2 WRITE.IMSTC
7231: 0000: END FUNCTION
7232: 0000: 
7233: 0000: FUNCTION WRITE.IMSTC.UNLOCK.HOLD EXTERNAL
7234: 0000:     INTEGER*2 WRITE.IMSTC.UNLOCK.HOLD
7235: 0000: END FUNCTION
7236: 0000: 
7237: 0000: FUNCTION WRITE.IMSTC.UNLOCK EXTERNAL
7238: 0000:    INTEGER*2 WRITE.IMSTC.UNLOCK
7239: 0000: END FUNCTION
7240: 0000: 
7241: 0000: FUNCTION WRITE.IMSTC.HOLD EXTERNAL
7242: 0000:    INTEGER*2 WRITE.IMSTC.HOLD
7243: 0000: END FUNCTION
7244: 0000: 
7245: 0000:  %INCLUDE STOCKEXT.J86                    ! 1.9BG
7246: 0000: \***********************************************************************
7247: 0000: \***********************************************************************
7248: 0000: \***
7249: 0000: \***    DESCRIPTION: Stock File
7250: 0000: \***                 External File Function Definitions
7251: 0000: \***
7252: 0000: \***    FILE TYPE : Keyed
7253: 0000: \***
7254: 0000: \***********************************************************************
7255: 0000: \***
7256: 0000: \***    Version A.          Les Cook                     21st Aug 1992
7257: 0000: \***    Initial version.
7258: 0000: \***
7259: 0000: \***    Version B.          Robert Cowey                 21st Oct 1993
7260: 0000: \***    No changes to this file.
7261: 0000: \***
7262: 0000: \***    Version C.          Nik Sen                      22nd Dec 1994
7263: 0000: \***    WRITE.STOCK.HOLD added.
7264: 0000: \***
7265: 0000: \***    Version D.          Mark Walker                  23rd Jan 2014
7266: 0000: \***    F337 Centralised View of Stock
7267: 0000: \***    - Minor formatting changes (uncommented).
7268: 0000: \***
7269: 0000: \***********************************************************************
7270: 0000: \***********************************************************************
7271: 0000: 
7272: 0000: FUNCTION STOCK.SET EXTERNAL
7273: 0000: END FUNCTION
7274: 0000:    
7275: 0000: FUNCTION READ.STOCK EXTERNAL
7276: 0000:     INTEGER*2 READ.STOCK
7277: 0000: END FUNCTION
7278: 0000:    
7279: 0000: FUNCTION WRITE.STOCK EXTERNAL
7280: 0000:     INTEGER*2 WRITE.STOCK
7281: 0000: END FUNCTION
7282: 0000:    
7283: 0000: FUNCTION WRITE.STOCK.HOLD EXTERNAL
7284: 0000:     INTEGER*2 WRITE.STOCK.HOLD
7285: 0000: END FUNCTION
7286: 0000: 
7287: 0000: FUNCTION READ.STOCK.LOCK EXTERNAL
7288: 0000:     INTEGER*2 READ.STOCK.LOCK
7289: 0000: END FUNCTION
7290: 0000:    
7291: 0000: FUNCTION WRITE.STOCK.UNLOCK EXTERNAL
7292: 0000:     INTEGER*2 WRITE.STOCK.UNLOCK
7293: 0000: END FUNCTION
7294: 0000:    
7295: 0000: FUNCTION WRITE.STOCK.UNLOCK.HOLD EXTERNAL
7296: 0000:     INTEGER*2 WRITE.STOCK.UNLOCK.HOLD
7297: 0000: END FUNCTION
7298: 0000: 
7299: 0000:  %INCLUDE MINLSEXT.J86                    ! 1.9BG
7300: 0000: 
7301: 0000: \*****************************************************************************
7302: 0000: \*****************************************************************************
7303: 0000: \***
7304: 0000: \***        %INCLUDE FOR FILE HANDLING FUNCTIONS EXTERNAL DEFINITIONS
7305: 0000: \***
7306: 0000: \***                   FILE TYPE:  KEYED
7307: 0000: \***
7308: 0000: \***                   REFERENCE:  MINLSEXT.J86
7309: 0000: \***
7310: 0000: \***	             DESCRIPTION:  MINSITS RP - SCREEN COUNT INFORMATION
7311: 0000: \***
7312: 0000: \***
7313: 0000: \***
7314: 0000: \***      VERSION 1 : Julia Stones             8th January 1998   
7315: 0000: \***      
7316: 0000: \*****************************************************************************
7317: 0000: \*****************************************************************************
7318: 0000: 
7319: 0000: 
7320: 0000:   FUNCTION MINLS.SET EXTERNAL
7321: 0000:      INTEGER*2 MINLS.SET
7322: 0000:   END FUNCTION
7323: 0000: 
7324: 0000: 
7325: 0000:   FUNCTION READ.MINLS EXTERNAL
7326: 0000:     INTEGER*2 READ.MINLS
7327: 0000:   END FUNCTION
7328: 0000:   
7329: 0000: 
7330: 0000:   FUNCTION READ.MINLS.LOCKED EXTERNAL
7331: 0000:     INTEGER*2 READ.MINLS.LOCKED
7332: 0000:   END FUNCTION  
7333: 0000: 
7334: 0000: 
7335: 0000:   FUNCTION WRITE.HOLD.MINLS EXTERNAL
7336: 0000:     INTEGER*2 WRITE.HOLD.MINLS
7337: 0000:   END FUNCTION
7338: 0000: 
7339: 0000: 
7340: 0000:   FUNCTION WRITE.UNLOCK.MINLS EXTERNAL
7341: 0000:     INTEGER*2 WRITE.UNLOCK.MINLS
7342: 0000:   END FUNCTION
7343: 0000: 
7344: 0000: 
7345: 0000:   FUNCTION WRITE.HOLD.UNLOCK.MINLS EXTERNAL
7346: 0000:     INTEGER*2 WRITE.HOLD.UNLOCK.MINLS
7347: 0000:   END FUNCTION
7348: 0000:   
7349: 0000: 
7350: 0000:   FUNCTION WRITE.MINLS EXTERNAL
7351: 0000:     INTEGER*2 WRITE.MINLS
7352: 0000:   END FUNCTION
7353: 0000: 
7354: 0000:  %INCLUDE NEGSCEXT.J86                    ! 1.9BG
7355: 0000: 
7356: 0000: \*****************************************************************************
7357: 0000: \*****************************************************************************
7358: 0000: \***
7359: 0000: \***        %INCLUDE FOR FILE HANDLING FUNCTIONS EXTERNAL DEFINITIONS
7360: 0000: \***
7361: 0000: \***                   FILE TYPE:  KEYED
7362: 0000: \***
7363: 0000: \***                   REFERENCE:  NEGSCEXT.J86
7364: 0000: \***
7365: 0000: \***                 DESCRIPTION:  CURRENT NEGATIVE STOCK COUNT INFORMATION
7366: 0000: \***
7367: 0000: \***
7368: 0000: \***
7369: 0000: \***      VERSION 1 : Julia Stones             15th July 1999   
7370: 0000: \***      
7371: 0000: \***    REVISION 1.2.            ROBERT COWEY.                  09 SEP 2003.
7372: 0000: \***    Changes for RF trial.
7373: 0000: \***    Recompiled to prevent future automatic recompiles.
7374: 0000: \***    No changes to actual code.
7375: 0000: \***
7376: 0000: \*****************************************************************************
7377: 0000: \*****************************************************************************
7378: 0000: 
7379: 0000: 
7380: 0000:   FUNCTION NEGSC.SET EXTERNAL
7381: 0000:      INTEGER*2 NEGSC.SET
7382: 0000:   END FUNCTION
7383: 0000: 
7384: 0000: 
7385: 0000:   FUNCTION READ.NEGSC EXTERNAL
7386: 0000:     INTEGER*2 READ.NEGSC
7387: 0000:   END FUNCTION
7388: 0000:   
7389: 0000: 
7390: 0000:   FUNCTION READ.NEGSC.LOCKED EXTERNAL
7391: 0000:     INTEGER*2 READ.NEGSC.LOCKED
7392: 0000:   END FUNCTION  
7393: 0000: 
7394: 0000: 
7395: 0000:   FUNCTION WRITE.HOLD.NEGSC EXTERNAL
7396: 0000:     INTEGER*2 WRITE.HOLD.NEGSC
7397: 0000:   END FUNCTION
7398: 0000: 
7399: 0000: 
7400: 0000:   FUNCTION WRITE.UNLOCK.NEGSC EXTERNAL
7401: 0000:     INTEGER*2 WRITE.UNLOCK.NEGSC
7402: 0000:   END FUNCTION
7403: 0000: 
7404: 0000: 
7405: 0000:   FUNCTION WRITE.HOLD.UNLOCK.NEGSC EXTERNAL
7406: 0000:     INTEGER*2 WRITE.HOLD.UNLOCK.NEGSC
7407: 0000:   END FUNCTION
7408: 0000:   
7409: 0000: 
7410: 0000:   FUNCTION WRITE.NEGSC EXTERNAL
7411: 0000:     INTEGER*2 WRITE.NEGSC
7412: 0000:   END FUNCTION
7413: 0000: 
7414: 0000:  %INCLUDE SSPSCEXT.J86                    ! 2.0JAS
7415: 0000: \*****************************************************************************
7416: 0000: \*****************************************************************************
7417: 0000: \***
7418: 0000: \***         FUNCTION DEFINITIONS FOR SSPSCTRL
7419: 0000: \***
7420: 0000: \***                    REFERENCE : SSPSCexa.J86
7421: 0000: \***
7422: 0000: \***    Version A           Julia Stones         23.10.2003
7423: 0000: \***
7424: 0000: \*******************************************************************************
7425: 0000: \*******************************************************************************
7426: 0000: 
7427: 0000:   FUNCTION SSPSCTRL.SET EXTERNAL
7428: 0000:    INTEGER*2 SSPSCTRL.SET
7429: 0000:   END FUNCTION
7430: 0000: 
7431: 0000:   FUNCTION READ.SSPSCTRL EXTERNAL
7432: 0000:    INTEGER*2 READ.SSPSCTRL
7433: 0000:   END FUNCTION
7434: 0000: 
7435: 0000:   FUNCTION READ.SSPSCTRL.LOCKED EXTERNAL
7436: 0000:    INTEGER*2 READ.SSPSCTRL.LOCKED
7437: 0000:   END FUNCTION
7438: 0000: 
7439: 0000:   FUNCTION WRITE.SSPSCTRL EXTERNAL
7440: 0000:    INTEGER*2 WRITE.SSPSCTRL
7441: 0000:   END FUNCTION
7442: 0000: 
7443: 0000:   FUNCTION WRITE.SSPSCTRL.UNLOCK EXTERNAL
7444: 0000:    INTEGER*2 WRITE.SSPSCTRL.UNLOCK
7445: 0000:   END FUNCTION
7446: 0000: 
7447: 0000:  %INCLUDE BTCSEXT.J86                     ! 2.0JAS
7448: 0000: \*****************************************************************************
7449: 0000: \*****************************************************************************
7450: 0000: \***
7451: 0000: \***         FUNCTION DEFINITIONS FOR BTCS FILE
7452: 0000: \***
7453: 0000: \***         REFERENCE    : BTCSEXT
7454: 0000: \***
7455: 0000: \***         VERSION A    : JULIA STONES 23/10/03
7456: 0000: \***
7457: 0000: \*****************************************************************************
7458: 0000: \*****************************************************************************
7459: 0000: 
7460: 0000:     FUNCTION BTCS.SET EXTERNAL
7461: 0000:     END FUNCTION
7462: 0000: 
7463: 0000:     FUNCTION READ.BTCS EXTERNAL
7464: 0000:     INTEGER*1 READ.BTCS
7465: 0000:     END FUNCTION
7466: 0000: 
7467: 0000:     FUNCTION READ.BTCS.LOCK EXTERNAL
7468: 0000:     INTEGER*1 READ.BTCS.LOCK
7469: 0000:     END FUNCTION
7470: 0000: 
7471: 0000:     FUNCTION WRITE.BTCS EXTERNAL
7472: 0000:     INTEGER*1 WRITE.BTCS
7473: 0000:     END FUNCTION
7474: 0000: 
7475: 0000:     FUNCTION WRITE.BTCS.UNLOCK EXTERNAL
7476: 0000:     INTEGER*1 WRITE.BTCS.UNLOCK
7477: 0000:     END FUNCTION
7478: 0000: 
7479: 0000:     FUNCTION WRITE.BTCS.UNLOCK.HOLD EXTERNAL
7480: 0000:     INTEGER*1 WRITE.BTCS.UNLOCK.HOLD
7481: 0000:     END FUNCTION
7482: 0000: 
7483: 0000:  %INCLUDE PRINTEXT.J86                    ! 2.0JAS
7484: 0000: 
7485: 0000: REM \
7486: 0000: \*******************************************************************************
7487: 0000: \*******************************************************************************
7488: 0000: \***
7489: 0000: \***    %INCLUDE FOR PRINT FILE EXTERNAL FUNCTIONS
7490: 0000: \***
7491: 0000: \***        REFERENCE   :   PRINTEX (J86)
7492: 0000: \***
7493: 0000: \***        FILE TYPE   :   Printer / Labeller
7494: 0000: \***
7495: 0000: \***    VERSION A.              ANDREW WEDGEWORTH                   09 JUL 1992.
7496: 0000: \***    Original version created from PRINTEXG.
7497: 0000: \***
7498: 0000: \***    VERSION B.              UNKNOWN.                            ?? ??? 1992.
7499: 0000: \***    Changes unknown.
7500: 0000: \***
7501: 0000: \***    VERSION C.              ROBERT COWEY.                       18 NOV 1992.
7502: 0000: \***    Defined function variables for use as return codes.
7503: 0000: \***
7504: 0000: \***    Version C               Andrew Wedgeworth                 24th May 1992
7505: 0000: \***    Condensed print function added.
7506: 0000: \***
7507: 0000: \***    Version D               Stuart WIlliam McConnachie       31st July 2000.
7508: 0000: \***    Added function for PCL printing to LaserJet.
7509: 0000: \***
7510: 0000: \***    Version E               Charles Skadorwa                   4th Apr 2008.
7511: 0000: \***    Added parameter to WRITE.CONDENSED.PRINT function to
7512: 0000: \***    enable Alliance Pharmacy Brother Laser printers to print
7513: 0000: \***    in condensed mode.
7514: 0000: \***
7515: 0000: \***    Version F           Charles Skadorwa                       2nd Mar 2016.
7516: 0000: \***    It was found that certain reports would not print when stores
7517: 0000: \***    were converted to LAN attached printing.
7518: 0000: \***
7519: 0000: \***    Added new function: WRITE.PRINT.PLUS.LF based on WRITE.PRINT.
7520: 0000: \***    This adds a Line-Feed characters to every print line.
7521: 0000: \***
7522: 0000: \*******************************************************************************
7523: 0000: \*******************************************************************************
7524: 0000: 
7525: 0000: 
7526: 0000:     FUNCTION PRINT.SET EXTERNAL
7527: 0000:         INTEGER*2 PRINT.SET
7528: 0000:     END FUNCTION
7529: 0000: 
7530: 0000: 
7531: 0000:     FUNCTION WRITE.PRINT EXTERNAL
7532: 0000:        INTEGER*2 WRITE.PRINT
7533: 0000:     END FUNCTION
7534: 0000: 
7535: 0000: 
7536: 0000:     FUNCTION WRITE.PRINT.PLUS.LF EXTERNAL                               !FCS
7537: 0000:        INTEGER*2 WRITE.PRINT.PLUS.LF                                    !FCS
7538: 0000:     END FUNCTION                                                        !FCS
7539: 0000: 
7540: 0000: 
7541: 0000:     FUNCTION WRITE.CONDENSED.PRINT (AP.STORE) EXTERNAL                 ! ECSk
7542: 0000:        INTEGER*2 WRITE.CONDENSED.PRINT
7543: 0000:     END FUNCTION
7544: 0000: 
7545: 0000: 
7546: 0000:     FUNCTION WRITE.PCL.PRINT EXTERNAL                                  ! DSWM
7547: 0000:        INTEGER*2 WRITE.PCL.PRINT                                       ! DSWM
7548: 0000:     END FUNCTION                                                       ! DSWM
7549: 0000: 
7550: 0000: 
7551: 0000:     FUNCTION WRITE.LABEL EXTERNAL
7552: 0000:         INTEGER*2 WRITE.LABEL
7553: 0000:     END FUNCTION
7554: 0000: 
7555: 0000:  %INCLUDE SOPTSEXT.J86                    ! 2.1JAS
7556: 0000: \*******************************************************************************
7557: 0000: \***                                                                         ***
7558: 0000: \***      EXTERNAL FUNCTION DEFINITIONS FOR THE STORE OPTIONS FILE           ***
7559: 0000: \***                                                                         ***
7560: 0000: \***                     REFERENCE : SOPTSEXT.J86                            ***
7561: 0000: \***                                                                         ***
7562: 0000: \***      Version A      Stuart William McConnachie      19th June 1995      ***
7563: 0000: \***                                                                         ***
7564: 0000: \*******************************************************************************
7565: 0000: 
7566: 0000:       FUNCTION SOPTS.SET EXTERNAL
7567: 0000:       END FUNCTION
7568: 0000:       
7569: 0000:       FUNCTION READ.SOPTS EXTERNAL
7570: 0000:          INTEGER*2 READ.SOPTS
7571: 0000:       END FUNCTION
7572: 0000: 
7573: 0000:       FUNCTION WRITE.SOPTS EXTERNAL
7574: 0000:          INTEGER*2 WRITE.SOPTS
7575: 0000:       END FUNCTION
7576: 0000: 
7577: 0000:  %INCLUDE LOCALEXT.J86                    ! 2.1JAS
7578: 0000: \***********************************************************************
7579: 0000: \***********************************************************************
7580: 0000: \***
7581: 0000: \***    DESCRIPTION: Local Price File
7582: 0000: \***                 External File Function Definitions
7583: 0000: \***
7584: 0000: \***    FILE TYPE : Keyed
7585: 0000: \***
7586: 0000: \***********************************************************************
7587: 0000: \***
7588: 0000: \***    Version A.              Paul Flanagan            1st Jul 1993
7589: 0000: \***    Initial version.
7590: 0000: \***
7591: 0000: \***    Version B.              Clive Norris            30th Nov 1993
7592: 0000: \***    Renamed to keep the versions in line.
7593: 0000: \***
7594: 0000: \***    Version C.              Mark Walker             29th Jun 2015
7595: 0000: \***    F392 Retail Stock 5
7596: 0000: \***    Added function WRITE.LOCAL.UNLOCK.HOLD
7597: 0000: \***
7598: 0000: \***********************************************************************
7599: 0000: \***********************************************************************
7600: 0000: 
7601: 0000: FUNCTION LOCAL.SET EXTERNAL
7602: 0000: END FUNCTION
7603: 0000: 
7604: 0000: FUNCTION READ.LOCAL EXTERNAL
7605: 0000:     INTEGER*2 READ.LOCAL
7606: 0000: END FUNCTION
7607: 0000: 
7608: 0000: FUNCTION READ.LOCAL.LOCK EXTERNAL
7609: 0000:     INTEGER*2 READ.LOCAL.LOCK
7610: 0000: END FUNCTION
7611: 0000: 
7612: 0000: FUNCTION WRITE.LOCAL EXTERNAL
7613: 0000:     INTEGER*2 WRITE.LOCAL
7614: 0000: END FUNCTION
7615: 0000: 
7616: 0000: FUNCTION WRITE.LOCAL.UNLOCK EXTERNAL
7617: 0000:     INTEGER*2 WRITE.LOCAL.UNLOCK
7618: 0000: END FUNCTION
7619: 0000: 
7620: 0000: FUNCTION WRITE.LOCAL.UNLOCK.HOLD EXTERNAL                                   !CMW
7621: 0000:     INTEGER*2 WRITE.LOCAL.UNLOCK.HOLD                                       !CMW
7622: 0000: END FUNCTION                                                                !CMW
7623: 0000: 
7624: 0000:  %INCLUDE CCREJEXT.J86                    ! 2.2JAS
7625: 0000: \*******************************************************************************
7626: 0000: \*******************************************************************************
7627: 0000: \***
7628: 0000: \*** RETURNS / AUTOMATIC CREDIT CLAIMING FILE EXTERNAL FILE PUBLIC DEFINITIONS
7629: 0000: \***
7630: 0000: \***                    REFERENCE    : CCREJEXT.BAS
7631: 0000: \***
7632: 0000: \***    Version A.         Julia Stones              12th March 2004
7633: 0000: \***
7634: 0000: \*******************************************************************************
7635: 0000: \*******************************************************************************
7636: 0000: 
7637: 0000: 
7638: 0000:   FUNCTION CCREJ.SET EXTERNAL
7639: 0000:       INTEGER*2 CCREJ.SET
7640: 0000:   END FUNCTION
7641: 0000: 
7642: 0000:   FUNCTION CCREJC.SET EXTERNAL
7643: 0000:       INTEGER*2 CCREJC.SET
7644: 0000:   END FUNCTION
7645: 0000: 
7646: 0000:   FUNCTION CCREJP.SET EXTERNAL
7647: 0000:       INTEGER*2 CCREJP.SET
7648: 0000:   END FUNCTION
7649: 0000: 
7650: 0000:   FUNCTION READ.CCREJ EXTERNAL
7651: 0000:       INTEGER*2 READ.CCREJ
7652: 0000:   END FUNCTION
7653: 0000: 
7654: 0000:   FUNCTION READ.CCREJC EXTERNAL
7655: 0000:       INTEGER*2 READ.CCREJC
7656: 0000:   END FUNCTION
7657: 0000: 
7658: 0000:   FUNCTION READ.CCREJP EXTERNAL
7659: 0000:       INTEGER*2 READ.CCREJP
7660: 0000:   END FUNCTION
7661: 0000: 
7662: 0000:   FUNCTION WRITE.CCREJ EXTERNAL
7663: 0000:       INTEGER*2 WRITE.CCREJ
7664: 0000:   END FUNCTION
7665: 0000: 
7666: 0000:   FUNCTION WRITE.CCREJC EXTERNAL
7667: 0000:       INTEGER*2 WRITE.CCREJC
7668: 0000:   END FUNCTION
7669: 0000: 
7670: 0000:   FUNCTION WRITE.HOLD.CCREJ EXTERNAL
7671: 0000:       INTEGER*2 WRITE.HOLD.CCREJ
7672: 0000:   END FUNCTION
7673: 0000: 
7674: 0000:   FUNCTION WRITE.HOLD.CCREJC EXTERNAL
7675: 0000:       INTEGER*2 WRITE.HOLD.CCREJC
7676: 0000:   END FUNCTION
7677: 0000: 
7678: 0000:  %INCLUDE RBEXT.J86                       ! 2.6BG
7679: 0000: \/******************************************************************/
7680: 0000: \/*                                                                */
7681: 0000: \/* Recalls Buffer FILE EXTERNAL FUNCTION DEFNS                    */
7682: 0000: \/*                                                                */
7683: 0000: \/* REFERENCE   : RBEXT.J86                                        */
7684: 0000: \/*                                                                */
7685: 0000: \/* VERSION A.          Brian Greenield         11th May 2007      */
7686: 0000: \/*                                                                */
7687: 0000: \/******************************************************************/
7688: 0000: 
7689: 0000:    FUNCTION RB.SET EXTERNAL
7690: 0000:       INTEGER*1 RB.SET
7691: 0000:    END FUNCTION
7692: 0000: 
7693: 0000:    FUNCTION READ.RB EXTERNAL
7694: 0000:       INTEGER*2 READ.RB
7695: 0000:    END FUNCTION
7696: 0000: 
7697: 0000:    FUNCTION WRITE.RB EXTERNAL
7698: 0000:       INTEGER*2 WRITE.RB
7699: 0000:    END FUNCTION
7700: 0000: 
7701: 0000: \/******************************************************************/
7702: 0000:  %INCLUDE REWKFEXT.J86                    ! 2.6BG
7703: 0000: \/******************************************************************/
7704: 0000: \/*                                                                */
7705: 0000: \/* Recalls Work FILE EXTERNAL FUNCTION DEFNS                      */
7706: 0000: \/*                                                                */
7707: 0000: \/* REFERENCE   : REWKFEXT.J86                                     */
7708: 0000: \/*                                                                */
7709: 0000: \/* VERSION A.          Brian Greenield         11th May 2007      */
7710: 0000: \/*                                                                */
7711: 0000: \/******************************************************************/
7712: 0000: 
7713: 0000:    FUNCTION REWKF.SET EXTERNAL
7714: 0000:       INTEGER*1 REWKF.SET
7715: 0000:    END FUNCTION
7716: 0000: 
7717: 0000:    FUNCTION READ.REWKF EXTERNAL
7718: 0000:       INTEGER*2 READ.REWKF
7719: 0000:    END FUNCTION
7720: 0000: 
7721: 0000:    FUNCTION WRITE.REWKF EXTERNAL
7722: 0000:       INTEGER*2 WRITE.REWKF
7723: 0000:    END FUNCTION
7724: 0000: 
7725: 0000: \/******************************************************************/
7726: 0000:  %INCLUDE RECALEXT.J86                    ! 2.6BG
7727: 0000: \******************************************************************************
7728: 0000: \******************************************************************************
7729: 0000: \***
7730: 0000: \***                 FUNCTION DEFINITIONS FOR RECALLS.BIN
7731: 0000: \***
7732: 0000: \***                        REFERENCE: RECALFEXT.J86
7733: 0000: \***
7734: 0000: \***    VERSION A               BRIAN GREENFIELD                14th May 2007
7735: 0000: \***    Initial Version
7736: 0000: \***
7737: 0000: \***    Version B               CHARLES SKADORWA                26th June 2007
7738: 0000: \***    Added DELETE.RECALLS function.
7739: 0000: \***
7740: 0000: \*******************************************************************************
7741: 0000: \*******************************************************************************
7742: 0000: 
7743: 0000:    FUNCTION RECALLS.SET EXTERNAL
7744: 0000:       INTEGER*1 RECALLS.SET
7745: 0000:    END FUNCTION
7746: 0000:    
7747: 0000:    FUNCTION WRITE.RECALLS EXTERNAL
7748: 0000:       INTEGER*1 WRITE.RECALLS
7749: 0000:    END FUNCTION
7750: 0000:    
7751: 0000:    FUNCTION READ.RECALLS EXTERNAL
7752: 0000:       INTEGER*1 READ.RECALLS
7753: 0000:    END FUNCTION
7754: 0000:    
7755: 0000:   FUNCTION DELETE.RECALLS (KEY$) EXTERNAL
7756: 0000:       INTEGER*1 DELETE.RECALLS
7757: 0000:    END FUNCTION
7758: 0000:  %INCLUDE DELVIEXT.J86                    ! 2.7SH
7759: 0000: \/******************************************************************/
7760: 0000: \/*                                                                */
7761: 0000: \/* DELVINDX FILE EXTERNAL FUNCTION DEFNS                          */
7762: 0000: \/*                                                                */
7763: 0000: \/* REFERENCE   : DELVIEXT.J86                                     */
7764: 0000: \/*                                                                */
7765: 0000: \/* VERSION A.          Stuart Highley              14 July 2008   */
7766: 0000: \/*                                                                */
7767: 0000: \/******************************************************************/
7768: 0000: 
7769: 0000:    FUNCTION DELVINDX.SET EXTERNAL
7770: 0000:       INTEGER*1 DELVINDX.SET
7771: 0000:    END FUNCTION
7772: 0000: 
7773: 0000:    FUNCTION READ.DELVINDX EXTERNAL
7774: 0000:       INTEGER*2 READ.DELVINDX
7775: 0000:    END FUNCTION
7776: 0000: 
7777: 0000:    FUNCTION WRITE.DELVINDX EXTERNAL
7778: 0000:       INTEGER*2 WRITE.DELVINDX
7779: 0000:    END FUNCTION
7780: 0000: 
7781: 0000: \/******************************************************************/
7782: 0000:  %INCLUDE UODOTEXT.J86                    ! 2.7SH
7783: 0000: \/******************************************************************/
7784: 0000: \/*                                                                */
7785: 0000: \/* UOD Outers FILE EXTERNAL FUNCTION DEFNS                        */
7786: 0000: \/*                                                                */
7787: 0000: \/* REFERENCE   : UODOTEXT.J86                                     */
7788: 0000: \/*                                                                */
7789: 0000: \/* VERSION A.          Stuart Highley              14 July 2008   */
7790: 0000: \/*                                                                
7791: 0000: \/* REVISION 1.8.            ROBERT COWEY.            14 JAN 2009.
7792: 0000: \/* Changes for 10A PosUOD fixes creating SSC04.286 Rv 1.3.
7793: 0000: \/* Defined new function UODOT.REC$.
7794: 0000: \/*
7795: 0000: \/******************************************************************/
7796: 0000: 
7797: 0000:     FUNCTION UODOT.KEY$ EXTERNAL
7798: 0000:         STRING    UODOT.KEY$
7799: 0000:         STRING    WORK$
7800: 0000:     END FUNCTION
7801: 0000: 
7802: 0000:     FUNCTION UODOT.SET EXTERNAL
7803: 0000:         INTEGER*1 UODOT.SET
7804: 0000:     END FUNCTION
7805: 0000: 
7806: 0000:     FUNCTION READ.UODOT EXTERNAL
7807: 0000:         STRING    CHILD.LIST$
7808: 0000:         INTEGER*1 UODOT.INDICAT1%
7809: 0000:         INTEGER*2 UODOT.STATUS%
7810: 0000:         INTEGER*2 READ.UODOT
7811: 0000:         INTEGER*2 I%
7812: 0000:     END FUNCTION
7813: 0000: 
7814: 0000: 
7815: 0000:     FUNCTION READ.UODOT.ON.DESPATCH EXTERNAL
7816: 0000:         STRING TEMP$
7817: 0000:         INTEGER*2 RC%
7818: 0000:         INTEGER*2 READ.UODOT.ON.DESPATCH
7819: 0000:     END FUNCTION
7820: 0000: 
7821: 0000:     FUNCTION READ.UODOT.LOCK EXTERNAL
7822: 0000:         INTEGER*1 UODOT.INDICAT1%
7823: 0000:         INTEGER*2 UODOT.STATUS%
7824: 0000:         INTEGER*2 READ.UODOT.LOCK
7825: 0000:         INTEGER*2 I%
7826: 0000:         STRING    CHILD.LIST$
7827: 0000:     END FUNCTION
7828: 0000: 
7829: 0000:     FUNCTION WRITE.UODOT EXTERNAL
7830: 0000:         INTEGER*1 UODOT.INDICAT1%
7831: 0000:         INTEGER*2 UODOT.STATUS%
7832: 0000:         INTEGER*2 WRITE.UODOT
7833: 0000:         INTEGER*2 I%
7834: 0000:         STRING    CHILD.LIST$
7835: 0000:     END FUNCTION
7836: 0000: 
7837: 0000:     FUNCTION WRITE.UODOT.UNLOCK EXTERNAL
7838: 0000:         INTEGER*1 UODOT.INDICAT1%
7839: 0000:         INTEGER*2 UODOT.STATUS%
7840: 0000:         INTEGER*2 WRITE.UODOT.UNLOCK
7841: 0000:         INTEGER*2 I%
7842: 0000:         STRING    CHILD.LIST$
7843: 0000:     END FUNCTION
7844: 0000: 
7845: 0000: \/******************************************************************/
7846: 0000: 
7847: 0000:     FUNCTION DELETE.UODOT EXTERNAL
7848: 0000:         INTEGER*2 DELETE.UODOT
7849: 0000:     END FUNCTION
7850: 0000: 
7851: 0000: \/******************************************************************/
7852: 0000: 
7853: 0000:     FUNCTION UODOT.REC$ EXTERNAL                                      ! 1.8 RC
7854: 0000:         STRING UODOT.REC$                                             ! 1.8 RC
7855: 0000:     END FUNCTION                                                      ! 1.8 RC
7856: 0000: 
7857: 0000: 
7858: 0000:  %INCLUDE AFEXT.J86                       ! 2.7SH
7859: 0000: 
7860: 0000: \REM
7861: 0000: \*******************************************************************************
7862: 0000: \*******************************************************************************
7863: 0000: \***
7864: 0000: \***    %INCLUDE FOR GSA AUTHORISATION FILE EXTERNAL FUNCTIONS
7865: 0000: \***
7866: 0000: \***        REFERENCE   :  AFEXT (J86)
7867: 0000: \***
7868: 0000: \***        FILE TYPE   :  Keyed
7869: 0000: \***
7870: 0000: \***    The GSA Authorisation File (EALAUTH.DAT) should not be confused with
7871: 0000: \***    the Operating System Authorisation File (ADXCSOUF.DAT).
7872: 0000: \***
7873: 0000: \***    VERSION A.              ROBERT COWEY.                       18 AUG 1992.
7874: 0000: \***    Original version created from AFEXTA.
7875: 0000: \***
7876: 0000: \***    VERSION B.              Steve Windsor                       29 Dec 1992.
7877: 0000: \***    Version incremented to keep in line with other included code           
7878: 0000: \***
7879: 0000: \***    VERSION C.              ROBERT COWEY.                       03 MAR 1994.
7880: 0000: \***    No changes to this file.
7881: 0000: \***
7882: 0000: \***    REVISION 1.6.                ROBERT COWEY.                15 JUN 2009.
7883: 0000: \***    Changes for A9C POS improvements project.
7884: 0000: \***    Used up last available three bytes of EALAUTH user data by redefining 
7885: 0000: \***    remaining AF.USER$ variable as AF.BIRTH.DATE$.
7886: 0000: \***    No changes to this file.
7887: 0000: \***
7888: 0000: \***    REVISION 1.7.                ROBERT COWEY.                22 JUN 2009.
7889: 0000: \***    Changes for A9C POS improvements project creating PSB99.286 Rv 1.8.
7890: 0000: \***    Defect 3247 - Redefined AF.BIRTH.DATE$ format within AFDEC.J86.
7891: 0000: \***    Description text change only - No code changes to this file.
7892: 0000: \***
7893: 0000: \*******************************************************************************
7894: 0000: \*******************************************************************************
7895: 0000: 
7896: 0000: 
7897: 0000: FUNCTION AF.SET EXTERNAL
7898: 0000:     INTEGER*2 AF.SET
7899: 0000: END FUNCTION
7900: 0000: 
7901: 0000: 
7902: 0000: FUNCTION READ.AF EXTERNAL
7903: 0000:     INTEGER*2 READ.AF
7904: 0000: END FUNCTION
7905: 0000: 
7906: 0000: 
7907: 0000: FUNCTION READ.AF.LOCKED EXTERNAL
7908: 0000:     INTEGER*2 READ.AF.LOCKED
7909: 0000: END FUNCTION
7910: 0000: 
7911: 0000:   
7912: 0000: FUNCTION READ.AF.ABREV EXTERNAL
7913: 0000:     INTEGER*2 READ.AF.ABREV
7914: 0000: END FUNCTION
7915: 0000: 
7916: 0000: 
7917: 0000: FUNCTION READ.AF.ABREV.LOCKED EXTERNAL
7918: 0000:     INTEGER*2 READ.AF.ABREV.LOCKED
7919: 0000: END FUNCTION
7920: 0000: 
7921: 0000:   
7922: 0000: FUNCTION WRITE.AF.UNLOCK EXTERNAL
7923: 0000:     INTEGER*2 WRITE.AF.UNLOCK
7924: 0000: END FUNCTION
7925: 0000: 
7926: 0000: 
7927: 0000: FUNCTION WRITE.AF.ABREV EXTERNAL
7928: 0000:     INTEGER*2 WRITE.AF.ABREV
7929: 0000: END FUNCTION
7930: 0000: 
7931: 0000: 
7932: 0000: FUNCTION WRITE.AF.ABREV.UNLOCK EXTERNAL
7933: 0000:     INTEGER*2 WRITE.AF.ABREV.UNLOCK
7934: 0000: END FUNCTION
7935: 0000: 
7936: 0000:  %INCLUDE UBEXT.J86                       ! 2.7SH
7937: 0000: \/******************************************************************/
7938: 0000: \/*                                                                */
7939: 0000: \/* UOD Bookin FILE EXTERNAL FUNCTION DEFNS                        */
7940: 0000: \/*                                                                */
7941: 0000: \/* REFERENCE   : UBEXT.J86                                        */
7942: 0000: \/*                                                                */
7943: 0000: \/* VERSION A.          Stuart Highley            14 August 2008   */
7944: 0000: \/*                                                                */
7945: 0000: \/******************************************************************/
7946: 0000: 
7947: 0000:    FUNCTION UB.SET EXTERNAL
7948: 0000:       INTEGER*1 UB.SET
7949: 0000:    END FUNCTION
7950: 0000: 
7951: 0000:    FUNCTION READ.UB EXTERNAL
7952: 0000:       INTEGER*2 READ.UB
7953: 0000:    END FUNCTION
7954: 0000: 
7955: 0000:    FUNCTION WRITE.UB EXTERNAL
7956: 0000:       INTEGER*2 WRITE.UB
7957: 0000:    END FUNCTION
7958: 0000: 
7959: 0000: \/******************************************************************/
7960: 0000:  
7961: 0000: \*****************************************************************************
7962: 0000: \*****************************************************************************
7963: 0000: \***                                                                       ***
7964: 0000: \*** I N T E R N A L   F U N C T I O N   D E C L A R A T I O N S           ***
7965: 0000: \***                                                                       ***
7966: 0000: \***   - FN.SECONDS                                                        ***
7967: 0000: \***   - FN.Z.PACK                                                         ***
7968: 0000: \***   - FN.VALIDATE.DATA                                                  ***
7969: 0000: \***   - FN.CONV.TO.INTEGER (SIGNED)                                       ***
7970: 0000: \***                                                                       ***
7971: 0000: \*****************************************************************************
7972: 0000: \*****************************************************************************
7973: 0000: 
7974: 0000: \******************************************************************************
7975: 0000: \***
7976: 0000: \***   Function : FN.SECONDS( TIME.VALUE$ )
7977: 0000: \***
7978: 0000: \***   Purpose  : Convert passed TIME in format HHMMSS to seconds
7979: 0000: \***
7980: 0000: \***   Output   : = 4 byte integer
7981: 0000: \***
7982: 0000: \******************************************************************************
7983: 0000: 
7984: 0000:    FUNCTION FN.SECONDS( TIME.VALUE$ )
7985: 0029: 
7986: 0029:       STRING                                                                  \
7987: 0029:          TIME.VALUE$
7988: 0029:       INTEGER*4                                                               \
7989: 0029:          FN.SECONDS
7990: 0029: 
7991: 0029:       FN.SECONDS = VAL(MID$(TIME.VALUE$,1,2)) * 3600 +                        \
7992: 00fb:                    VAL(MID$(TIME.VALUE$,3,2)) * 60 +                          \
7993: 00fb:                    VAL(MID$(TIME.VALUE$,5,2))
7994: 00fb: 
7995: 00fb:    END FUNCTION
7996: 011a: 
7997: 011a: \******************************************************************************
7998: 011a: \***
7999: 011a: \***   Function : FN.Z.PACK( NUM.STRING$, LENGTH% )
8000: 011a: \***
8001: 011a: \***   Purpose  : Zero pack (to the left) NUM.STRING$ out to LENGTH%
8002: 011a: \***
8003: 011a: \******************************************************************************
8004: 011a: 
8005: 011a:    FUNCTION FN.Z.PACK(NUM.STRING$, LENGTH%)
8006: 0143: 
8007: 0143:       STRING                                                                 \
8008: 0143:          FN.Z.PACK,                                                          \
8009: 0143:          NUM.STRING$
8010: 0143:       INTEGER*2                                                              \
8011: 0143:          LENGTH%
8012: 0143: 
8013: 0143:       FN.Z.PACK = RIGHT$(STRING$(LENGTH%,"0")+NUM.STRING$,LENGTH%)
8014: 018c: 
8015: 018c:    END FUNCTION
8016: 01aa: 
8017: 01aa: \******************************************************************************
8018: 01aa: \***
8019: 01aa: \***   Function : FN.VALIDATE.DATA( RECORD$, FORMAT% )
8020: 01aa: \***
8021: 01aa: \***   Purpose  : Test received record RECORD$ is in correct format for
8022: 01aa: \***              data format FORMAT%
8023: 01aa: \***
8024: 01aa: \***   Output   : = 0 if RECORD$ does not conform to data format FORMAT%
8025: 01aa: \***              = 1 if RECORD$ does conform to data format FORMAT%
8026: 01aa: \***
8027: 01aa: \******************************************************************************
8028: 01aa: 
8029: 01aa:    FUNCTION FN.VALIDATE.DATA(RECORD$, FORMAT%)
8030: 01d3: 
8031: 01d3:       STRING                                                                  \
8032: 01d3:          CHECK$,                                                              \
8033: 01d3:          DATA$,                                                               \
8034: 01d3:          RECORD$,                                                             \
8035: 01d3:          TEST$,                                                               \
8036: 01d3:          TYPE$,                                                               \
8037: 01d3:          VALID.FLAG$
8038: 01d3:       INTEGER*1                                                               \
8039: 01d3:          FORMAT%,                                                             \
8040: 01d3:          FN.VALIDATE.DATA
8041: 01d3:       INTEGER*2                                                               \
8042: 01d3:          BYTE.PTR%,                                                           \
8043: 01d3:          CHECK.PTR%,                                                          \
8044: 01d3:          REC.LENGTH%
8045: 01d3: 
8046: 01d3:       REC.LENGTH% = LEN(RECORD$)
8047: 01eb:       IF REC.LENGTH% < 1                                                      \
8048: 0220:       OR FORMAT% < 1 OR FORMAT% > REC.MAX% THEN BEGIN                         \
8049: 0220:          FN.VALIDATE.DATA = 0
8050: 022c:          EXIT FUNCTION
8051: 0237:       ENDIF
8052: 023f: 
8053: 023f:       CHECK$ = REC.CHECK$(FORMAT%)
8054: 026a:       CHECK.PTR% = 1
8055: 0278:       BYTE.PTR% = 1
8056: 0286:       VALID.FLAG$ = "Y"
8057: 029b: 
8058: 029b:       WHILE BYTE.PTR% <= REC.LENGTH%                                          \
8059: 02a6:         AND CHECK.PTR% < LEN(CHECK$)
8060: 02a6: 
8061: 02a6:          TYPE$ = MID$(CHECK$, CHECK.PTR%, 1)
8062: 02ca:          DATA$ = MID$(CHECK$, CHECK.PTR%+1, 1)
8063: 02ef:          CHECK.PTR% = CHECK.PTR% + 2
8064: 02fc: 
8065: 02fc:          IF TYPE$ = "B" THEN BEGIN
8066: 0317:             IF MID$(RECORD$, BYTE.PTR%, 1) <> DATA$ THEN BEGIN
8067: 034d:                VALID.FLAG$ = "N"
8068: 0362:             ENDIF
8069: 036a:             BYTE.PTR% = BYTE.PTR% + 1
8070: 0376:          ENDIF
8071: 037e: 
8072: 037e:          IF TYPE$ = "N" THEN BEGIN
8073: 039c:             WHILE BYTE.PTR% <= REC.LENGTH% AND DATA$ <> CHR$(0)
8074: 03a7:                TEST$ = MID$(RECORD$, BYTE.PTR%, 1)
8075: 03c9:                IF (TEST$ < "0" OR TEST$ > "9")                               \
8076: 0484:               AND TEST$ <> "-" AND TEST$ <> "+"                              \
8077: 0484:               AND TEST$ <> "." THEN VALID.FLAG$ = "N"
8078: 0499:                BYTE.PTR% = BYTE.PTR% + 1
8079: 04a5:                DATA$ = CHR$(ASC(DATA$) - 1)
8080: 04ca:             WEND
8081: 050a:             IF BYTE.PTR% > REC.LENGTH%                                       \
8082: 0547:            AND DATA$ <> CHR$(0) THEN VALID.FLAG$ = "N"
8083: 055c:          ENDIF
8084: 0564: 
8085: 0564:          IF TYPE$ = "A" THEN BYTE.PTR% = BYTE.PTR% + ASC(DATA$)
8086: 0590: 
8087: 0590:       WEND
8088: 05c5: 
8089: 05c5:       IF CHECK.PTR% <= LEN(CHECK$) THEN VALID.FLAG$ = "N"
8090: 05ee: 
8091: 05ee:       IF VALID.FLAG$ = "Y" THEN BEGIN
8092: 0609:          FN.VALIDATE.DATA = 1
8093: 0615:          LAST.ACTIVE.DATE$ = DATE$
8094: 062d:          LAST.ACTIVE% = FN.SECONDS(TIME$)
8095: 0655:       ENDIF ELSE BEGIN
8096: 065d:          FN.VALIDATE.DATA = 0
8097: 0669:       ENDIF
8098: 0671: 
8099: 0671:    END FUNCTION
8100: 068d: 
8101: 068d: \******************************************************************************
8102: 068d: \***
8103: 068d: \***   Function : FN.CONV.TO.INTEGER( NUM.STRING$ )
8104: 068d: \***
8105: 068d: \***   Purpose  : Convert passed string to a 1, 2 or 4 byte (dependant on
8106: 068d: \***              length of passed string) signed integer.
8107: 068d: \***
8108: 068d: \***   Output   : = 1, 2 or 4 byte integer
8109: 068d: \***
8110: 068d: \******************************************************************************
8111: 068d: 
8112: 068d:    FUNCTION FN.CONV.TO.INTEGER( NUM.STRING$ )
8113: 06b6: 
8114: 06b6:       INTEGER*4                                                              \
8115: 06b6:          BYTE%,                                                              \
8116: 06b6:          BYTE.POS%,                                                          \
8117: 06b6:          BYTES%,                                                             \
8118: 06b6:          SIGN.BIT%
8119: 06b6:       REAL                                                                   \
8120: 06b6:          FN.CONV.TO.INTEGER,                                                 \
8121: 06b6:          NUMBER
8122: 06b6:       STRING                                                                 \
8123: 06b6:          NUM.STRING$
8124: 06b6: 
8125: 06b6:       BYTES% = LEN(NUM.STRING$)
8126: 06db:       NUMBER = 0
8127: 06f6:       FOR BYTE.POS% = 1 TO BYTES%
8128: 070e:          BYTE% = ASC(MID$(NUM.STRING$, BYTE.POS%, 1))
8129: 073f:          IF BYTE.POS% = BYTES% THEN BEGIN
8130: 075a:             SIGN.BIT% = BYTE% AND 80h
8131: 0773:             BYTE% = BYTE% AND (SIGN.BIT% XOR 0FFh)
8132: 079f:          ENDIF
8133: 07a7:          NUMBER = NUMBER + (100h ^ (BYTE.POS% - 1)) * BYTE%
8134: 07fd:       NEXT BYTE.POS%
8135: 082a:       IF SIGN.BIT% <> 0 THEN NUMBER = NUMBER - (80h * (100h ^ (BYTES% - 1)))
8136: 0893: 
8137: 0893:       FN.CONV.TO.INTEGER = NUMBER
8138: 08a9: 
8139: 08a9:    END FUNCTION
8140: 08c2: 
8141: 08c2: \******************************************************************************
8142: 08c2: \***
8143: 08c2: \***   Function : FN.ZERO.PL( TEXT$,
8144: 08c2: \***                          LENGTH% )
8145: 08c2: \***
8146: 08c2: \***   Purpose  : Zero pack, to the left, the passed string TEXT$ to the
8147: 08c2: \***              specified length.
8148: 08c2: \***
8149: 08c2: \******************************************************************************
8150: 08c2: 
8151: 08c2:    FUNCTION FN.ZERO.PL(TEXT$,LENGTH%)
8152: 08eb: 
8153: 08eb:       STRING    FN.ZERO.PL, TEXT$
8154: 08eb:       INTEGER*2 LENGTH%
8155: 08eb: 
8156: 08eb:       FN.ZERO.PL = RIGHT$( STRING$( LENGTH%, "0" ) + TEXT$ , LENGTH% )
8157: 0934: 
8158: 0934:    END FUNCTION
8159: 0952: 
8160: 0952: \*****************************************************************************
8161: 0952: \*****************************************************************************
8162: 0952: \***                                                                       ***
8163: 0952: \*** E N D   OF   G L O B A L   D E F N S   F O R   P S S 3 7              ***
8164: 0952: \***                                                                       ***
8165: 0952: \*****************************************************************************
8166: 0952: \*****************************************************************************
8167: 0952: 
8168: 0952:    FUNCTION ADXSTART(NAME$, PARM$, MESS$) EXTERNAL
8169: 0952:       INTEGER*2 ADXSTART
8170: 0952:       STRING    NAME$, PARM$, MESS$
8171: 0952:    END FUNCTION
8172: 0952: 
8173: 0952:    FUNCTION FN.INVERT.DATE(PARM$)
8174: 097b:       STRING FN.INVERT.DATE,PARM$
8175: 097b:       PARM$ = RIGHT$("000000"+PARM$,6)
8176: 09b0:       FN.INVERT.DATE = RIGHT$(PARM$,2)+MID$(PARM$,3,2)+LEFT$(PARM$,2)
8177: 0a06:    END FUNCTION
8178: 0a24: 
8179: 0a24:    SUB PSS3704 PUBLIC
8180: 0a48: 
8181: 0a48: REAL                                                               \
8182: 0a48:        GAP,                                                        \
8183: 0a48:        CCTMP.RECORD.COMPLETE,                                      \
8184: 0a48:        DETAIL.RECORDS.RECEIVED,                                    \
8185: 0a48:        END.OF.CCTMP,                                               \
8186: 0a48:        END.OF.FILE,                                                \
8187: 0a48:        TABLE.FULL
8188: 0a48: 
8189: 0a48: INTEGER*1                                                          \
8190: 0a48:        CURR.SESS.NUM%,                                             \
8191: 0a48:        MORE.BAR.CODES,                                             \ BMJK
8192: 0a48:        PORT.EVENT%,                                                \
8193: 0a48:        PRIMER.PRESENT,                                             \ BMJK
8194: 0a48:        SB.EVENT.NO%,                                               \
8195: 0a48:        SB.FILE.SESS.NUM%,                                          \
8196: 0a48:        FINISHED,                                                   \
8197: 0a48:        SWAPPED,                                                    \
8198: 0a48:        HEADER.EXPECTED,                                            \ 1.13DA
8199: 0a48:        GROUP.CODE,                                                 \ 1.13DA
8200: 0a48:        CURRENT.CODE,                                               \ 1.13DA
8201: 0a48:        CODE.LENGTH,                                                \ 1.13DA
8202: 0a48:        VALID.ENTRY%,                                               \ 1.16JAS
8203: 0a48:        VALID.BC,                                                   \ 1.16JAS
8204: 0a48:        VALID.DATA.PRESENT                                          ! BMJK
8205: 0a48: 
8206: 0a48: INTEGER*2                                                          \
8207: 0a48:        R%,                                                         \ 1.13DA
8208: 0a48:        IDF.NUM.BARCODES%,                                          \ BMJK
8209: 0a48:        NUM.OF.UODS.TRANSMITTED%,                                   \ 1.4
8210: 0a48:        NUM.OF.OPEN.CLOSED.UODS%,                                   \ 1.4
8211: 0a48:        INDEX%,                                                     \ BMJK
8212: 0a48:        MESSAGE.NO%,                                                \ BMJK
8213: 0a48:        NUM.SECTORS%,                                               \ BMJK
8214: 0a48:        SB.FILE.REP.NUM%,                                           \
8215: 0a48:        SB.INTEGER%,                                                \
8216: 0a48:        I%,                                                         \ 1.6
8217: 0a48:        NO.MAX.RECS%                                                ! 1.6
8218: 0a48: 
8219: 0a48: INTEGER*4                                                        \
8220: 0a48:           ADX.RET.CODE%,                                                  \
8221: 0a48:           A%,                                                        \
8222: 0a48:           B%,                                                        \
8223: 0a48:           STOCKTAKE.COUNT,                                           \ 1.5
8224: 0a48:           EXPECTED.RECORDS,                                          \ 1.5
8225: 0a48:           MAX%,                                                      \
8226: 0a48:           INPUT.SIZE%,                                               \ 1.6
8227: 0a48:           MAX.REC.SIZE%,                                             \ 1.6
8228: 0a48:           CUR.LOC.COUNTER%,                                          \ 1.13DA
8229: 0a48:           ITEM.COUNT,                                                \ 1.13DA
8230: 0a48:           BATCH.ITEMS,                                               \ 1.13DA
8231: 0a48:           QUANTITY,                                                  \ 1.13DA
8232: 0a48:           SAVED.RECORD.NUM%,                                         \ 1.13DA
8233: 0a48:           REC.LEN%,                                                  \ 1.16JAS
8234: 0a48:           COMMA.POS%,                                                \ 1.16JAS
8235: 0a48:           END.POS%,                                                  \ 1.16JAS
8236: 0a48:           ITEM.COUNT%,                                               \ 1.16JAS
8237: 0a48:           VALID.INDEX%,                                              \ 1.16JAS
8238: 0a48:           ITEM.QTY%,                                                 \ 1.17JAS
8239: 0a48:           EXTRA.ITEMS%,                                              \ 1.17JAS
8240: 0a48:           REMAINDER%                                                 ! 1.6
8241: 0a48: 
8242: 0a48: STRING                                                               \
8243: 0a48:        CCTMP.ITEM.QTY$,                                          \ BMJK
8244: 0a48:        CCTMP.NUM.ITEM.UPDATED$,                                   \ BMJK
8245: 0a48:        CCTMP.TOTAL.QTY.IN.UOD$,                                   \ BMJK
8246: 0a48:        CCUOD.DATE.TIME$,                                          \ BMJK
8247: 0a48:        CCUOD.KEY$,                                                 \ BMJK
8248: 0a48:        CCLAM.KEY$,                                                 \ 1.4
8249: 0a48:        STATUS$,                                                    \ 1.4
8250: 0a48:        CRLF$,                                                        \
8251: 0a48:        CURRENT.KEY$,                                                 \ BMJK
8252: 0a48:        BARCODE.TABLE$(1),                                          \
8253: 0a48:        BARCODE.POS.TABLE$(1),                                          \
8254: 0a48:        FILLER$,                                                 \ BMJK
8255: 0a48:        ITEM.POS.STRING$,                                          \ BMJK
8256: 0a48:        SB.ACTION$,                                                    \
8257: 0a48:        SB.ERRF$,                                                      \
8258: 0a48:        SB.ERRL$,                                                      \
8259: 0a48:        SB.ERRS$,                                                      \
8260: 0a48:        SB.MESSAGE$,                                                   \
8261: 0a48:        SB.UNIQUE$,                                                    \
8262: 0a48:        SB.STRING$,                                                    \
8263: 0a48:        SB.BOOTS.ITEM$,                                                \ 1.13DA
8264: 0a48:        SB.BOOTS.CODE$,                                                \ 1.13DA
8265: 0a48:        TEMP$,                                                    \
8266: 0a48:        TEMP.STATE$,                                                 \ BMJK
8267: 0a48:        TEMP.RECORD$,                                                   \ 1.16JAS
8268: 0a48:        UNIQUE.2$,                                                 \
8269: 0a48:        UOD.POS.STRING$,                                                \
8270: 0a48:        CUR.LOC$,                                                       \ 1.13DA
8271: 0a48:        NEW.LOC$,                                                       \ 1.13DA
8272: 0a48:        STOCKTAKER$,                                                    \ 1.13DA
8273: 0a48:        STORE$,                                                         \ 1.13DA
8274: 0a48:        CR$,                                                            \ 1.13DA
8275: 0a48:        ITEM.CODE$,                                                     \ 1.13DA
8276: 0a48:        RECORD.FORMAT$,                                                 \ 1.6
8277: 0a48:        DATA.BLOCK$,                                                    \ ! 1.6 1.16JAS
8278: 0a48:        PREV.BC$,                                                       \ 1.16JAS
8279: 0a48:        BOOTS.CODE$,                                                    \ 1.16JAS
8280: 0a48:        COMMA$,                                                         \ 1.16JAS
8281: 0a48:        LDT.RETURNS.TYPE$,                                              \ 1.16JAS
8282: 0a48:        OTHER.CLAIM.VALID.BC$,                                          \ 1.16JAS
8283: 0a48:        BLANK.LINE$,                                                    \ 1.16JAS
8284: 0a48:        FOOTER.LINE$,                                                   \ 1.16JAS
8285: 0a48:        PAGE.THROW$,                                                    \ 1.16JAS
8286: 0a48:        TEMP.TABLE$(1)                                                  ! 1.17JAS
8287: 0a48: 
8288: 0a48: \******************************************************************************
8289: 0a48: \******************************************************************************
8290: 0a48: \***                                                                        ***
8291: 0a48: \***   M A I N L I N E   C O D E                                            ***
8292: 0a48: \***                                                                        ***
8293: 0a48: \******************************************************************************
8294: 0a48: \******************************************************************************
8295: 0a48: 
8296: 0a48: \******************************************************************************
8297: 0a48: \***
8298: 0a48: \***   for any errors, pass control to ERROR.DETECTED
8299: 0a48: \***
8300: 0a48: \***   pass control to the appropriate section of code, depending upon
8301: 0a48: \***   the value of RECEIVE.STATE$
8302: 0a48: \***
8303: 0a48: \***   MODULE.EXIT:
8304: 0a48: \***     return to calling module
8305: 0a48: \***
8306: 0a48: \***   PROGRAM.EXIT:
8307: 0a48: \***     stop
8308: 0a48: \***
8309: 0a48: \******************************************************************************
8310: 0a48: 
8311: 0a48: ON ERROR GOTO ERROR.DETECTED
8312: 0a5d: 
8313: 0a5d:       IF MATCH(RECEIVE.STATE$,"ghijklmnopqr",1) > 0 THEN BEGIN         ! 1.5
8314: 0a83:          ON (ASC(RECEIVE.STATE$) - ASC("f")) GOSUB                       \
8315: 0ac8:               RECEIVED.RETURNS.FILE.ID,                            \
8316: 0ac8:               RECEIVED.RETURNS.FILE.HEADER,                            \
8317: 0ac8:               RECEIVED.RETURNS.UOD.HEADER,                            \
8318: 0ac8:               RECEIVED.RETURNS.ITEM.DETAIL,                            \
8319: 0ac8:               RECEIVED.RETURNS.UOD.TRAILER,                            \
8320: 0ac8:               RECEIVED.RETURNS.FILE.TRAILER,                            \
8321: 0ac8:               RECEIVED.RETURNS.FILE.REQUEST,                            \
8322: 0ac8:               RECEIVED.RETURNS.FILE.RECEIVED.OK,                     \
8323: 0ac8:               RECEIVED.RETURNS.EOT,                                    \ 1.5
8324: 0ac8:               RECEIVED.STOCKTAKE.HEADER,                               \ 1.5
8325: 0ac8:               RECEIVED.STOCKTAKE.DETAIL,                               \ 1.5
8326: 0ac8:               RECEIVED.STOCKTAKE.TRAILER                               ! 1.5
8327: 0ac8:         GOTO MODULE.EXIT
8328: 0ad2:       ENDIF
8329: 0ada: 
8330: 0ada: 
8331: 0ada: MODULE.EXIT:
8332: 0aea: 
8333: 0aea:    EXIT SUB
8334: 0af5: 
8335: 0af5: PROGRAM.EXIT:
8336: 0b05: 
8337: 0b05:    STOP
8338: 0b12: 
8339: 0b12: 
8340: 0b12: \******************************************************************************
8341: 0b12: \******************************************************************************
8342: 0b12: \***                                                                        ***
8343: 0b12: \***          M A I N     R E T U R N S     S U B R O U T I N E S           ***
8344: 0b12: \***                                                                        ***
8345: 0b12: \******************************************************************************
8346: 0b12: \******************************************************************************
8347: 0b12: 
8348: 0b12: \******************************************************************************
8349: 0b12: \******************************************************************************
8350: 0b12: \***                                                                        ***
8351: 0b12: \***   RECEIVED.RETURNS.FILE.ID:                                            ***
8352: 0b12: \***                                                                        ***
8353: 0b12: \***     validate file id record, return if invalid                         ***
8354: 0b12: \***                                                                        ***
8355: 0b12: \***     log details to audit file                                          ***
8356: 0b12: \***     extract records from data record                                   ***
8357: 0b12: \***                                                                        ***
8358: 0b12: \***     As part of the new credit claiming system a new flag will be       ***
8359: 0b12: \***     passed on the data record.  If the flag is set to "G" then the     ***
8360: 0b12: \***     transmission is Goods Out, if the flag is set to "O" then the      ***
8361: 0b12: \***     transmission is Credit Claiming                                    ***
8362: 0b12: \***                                                                        ***
8363: 0b12: \***     open CCTRL and read current claim number                           ***
8364: 0b12: \***     if claim number on LDT is greater than controller;                 ***
8365: 0b12: \***       update CCTRL with value from LDT                                 ***
8366: 0b12: \***       close CCTRL                                                      ***
8367: 0b12: \***                                                                        ***
8368: 0b12: \***     compare the date/time of the controller CCUOD with the date/time   ***
8369: 0b12: \***     on the LDT then;                                                   ***
8370: 0b12: \***       if the controller values = 999999999999;                         ***
8371: 0b12: \***         format a file ID reply of 999999999999 for the date/time       ***
8372: 0b12: \***       otherwise if the LDT values > controller values;                 ***
8373: 0b12: \***         format a file ID reply of 000000000000 for the date/time       ***
8374: 0b12: \***       otherwise if the controller values >= LDT values;                ***
8375: 0b12: \***         format a file ID reply of the controller values for date/time  ***
8376: 0b12: \***                                                                        ***
8377: 0b12: \***     transmission of the file ID reply to the LDT                       ***
8378: 0b12: \***                                                                        ***
8379: 0b12: \******************************************************************************
8380: 0b12: \******************************************************************************
8381: 0b12: 
8382: 0b12:     RECEIVED.RETURNS.FILE.ID:
8383: 0b22: 
8384: 0b22:       SB.MESSAGE$ = "PDT Support - RETURNS file ID received"
8385: 0b37:       GOSUB SB.BG.MESSAGE
8386: 0b49: 
8387: 0b49:       IF FN.VALIDATE.DATA(DATA.IN$, 34) = 0 THEN BEGIN
8388: 0b6b:          RECEIVE.STATE$ = "*"
8389: 0b82:          GOTO MODULE.EXIT
8390: 0b8d:       ENDIF
8391: 0b95: 
8392: 0b95:       LDT.LAST.CLAIM.NUM$ = MID$(DATA.IN$,3,8)
8393: 0bbc:       LDT.CCUOD.UPDATE.DATE$ = MID$(DATA.IN$,11,6)
8394: 0be3:       LDT.CCUOD.UPDATE.TIME$ = MID$(DATA.IN$,17,6)
8395: 0c0a:       LDT.RETURNS.TYPE$ = MID$(DATA.IN$,23,1)                          ! 1.16JAS  "G" = Goods Out
8396: 0c2f:                                                                        ! 1.16JAS  "O" = Credit Claiming
8397: 0c2f: 
8398: 0c2f:       CURR.SESS.NUM% = CCTRL.SESS.NUM%
8399: 0c41:       IF END #CCTRL.SESS.NUM% THEN OPEN.ERROR
8400: 0c5d:       OPEN CCTRL.FILE.NAME$ DIRECT RECL CCTRL.RECL% AS CCTRL.SESS.NUM%        ! BMJK
8401: 0c89:       CCTRL.OPEN.FLAG$ = "Y"
8402: 0ca0: 
8403: 0ca0:       CCTRL.REC.NUM% = 1
8404: 0cb1:       CURRENT.KEY$ = "1"
8405: 0cc6:       IF READ.CCTRL.LOCKED THEN GOTO READ.ERROR
8406: 0cda:       IF LDT.LAST.CLAIM.NUM$ > UNPACK$(CCTRL.CREDIT.CLAIM.NUM$) THEN BEGIN
8407: 0d07:         CCTRL.CREDIT.CLAIM.NUM$ = PACK$(LDT.LAST.CLAIM.NUM$)
8408: 0d2a:        CCTRL.REC.NUM% = 1
8409: 0d3b:        IF WRITE.UNLOCK.CCTRL THEN GOTO WRITE.ERROR
8410: 0d4f:       ENDIF
8411: 0d57: 
8412: 0d57:       CCTRL.OPEN.FLAG$ = "N"
8413: 0d6e:       CLOSE CCTRL.SESS.NUM%
8414: 0d82: 
8415: 0d82:       LDT.DATE.TIME$ = FN.INVERT.DATE(LDT.CCUOD.UPDATE.DATE$) +              \
8416: 0dbd:                      LDT.CCUOD.UPDATE.TIME$
8417: 0dbd: 
8418: 0dbd:       IF LEFT$(LDT.DATE.TIME$,6) = "000000" THEN BEGIN                 ! 2.0
8419: 0df2:          LDT.DATE.TIME$ = "850101" + LDT.CCUOD.UPDATE.TIME$            ! 2.0
8420: 0e17:       ENDIF                                                            ! 2.0
8421: 0e1f: 
8422: 0e1f:       IF LEFT$(LDT.DATE.TIME$,6) = "999999" THEN BEGIN                 ! 2.0
8423: 0e54:          LDT.DATE.TIME$ = "841231" + LDT.CCUOD.UPDATE.TIME$            ! 2.0
8424: 0e79:       ENDIF                                                            ! 2.0
8425: 0e81: 
8426: 0e81:       IF LEFT$(LDT.DATE.TIME$,2) < "85" THEN BEGIN                     ! 1.8
8427: 0eb6:          LDT.DATE.TIME$ = "20" + LDT.DATE.TIME$                        ! 1.8
8428: 0edd:       ENDIF ELSE BEGIN                                                 ! 1.8
8429: 0ee5:          LDT.DATE.TIME$ = "19" + LDT.DATE.TIME$                        ! 1.8
8430: 0f0a:       ENDIF                                                            ! 1.8
8431: 0f12: 
8432: 0f12:       CCUOD.DATE.TIME$ = UNPACK$(CCUOD.DATE.FILE.UPDATED$) +              \
8433: 0f51:                          UNPACK$(CCUOD.TIME.FILE.UPDATED$)
8434: 0f51: 
8435: 0f51:       IF LEFT$(CCUOD.DATE.TIME$,6) = "000000" THEN BEGIN               ! 2.0
8436: 0f83:          CCUOD.DATE.TIME$ = "850101" + UNPACK$(CCUOD.TIME.FILE.UPDATED$) ! 2.0
8437: 0fab:       ENDIF                                                            ! 2.0
8438: 0fb3: 
8439: 0fb3:       IF CCUOD.DATE.TIME$ <> STRING$(12,"9") THEN BEGIN                ! 1.8
8440: 0fdb:          IF LEFT$(CCUOD.DATE.TIME$,6) = "999999" THEN BEGIN            ! 2.0
8441: 100d:             CCUOD.DATE.TIME$ = "841231" + UNPACK$(CCUOD.TIME.FILE.UPDATED$) ! 2.0
8442: 1035:          ENDIF                                                         ! 2.0
8443: 103d:          IF LEFT$(CCUOD.DATE.TIME$,2) < "85" THEN BEGIN                ! 1.8
8444: 106f:             CCUOD.DATE.TIME$ = "20" + CCUOD.DATE.TIME$                 ! 1.8
8445: 1091:          ENDIF ELSE BEGIN                                              ! 1.8
8446: 1099:             CCUOD.DATE.TIME$ = "19" + CCUOD.DATE.TIME$                 ! 1.8
8447: 10b9:          ENDIF                                                         ! 1.8
8448: 10c1:       ENDIF                                                            ! 1.8
8449: 10c9: 
8450: 10c9:       IF CCUOD.DATE.TIME$ = STRING$(12,"9") THEN BEGIN
8451: 10ee:         LDT.CCUOD.UPDATE.DATE$ = "999999"
8452: 1105:         LDT.CCUOD.UPDATE.TIME$ = "999999"
8453: 111c:          GOSUB CREATE.EMPTY.CCUPF                                   ! BMJK
8454: 1131:       ENDIF ELSE IF LDT.DATE.TIME$ > CCUOD.DATE.TIME$ THEN BEGIN
8455: 1153:         LDT.CCUOD.UPDATE.DATE$ = "000000"
8456: 116a:         LDT.CCUOD.UPDATE.TIME$ = "000000"
8457: 1183:       ENDIF ELSE IF LDT.DATE.TIME$ <= CCUOD.DATE.TIME$ THEN BEGIN
8458: 11a5:         LDT.CCUOD.UPDATE.DATE$ =                                    \
8459: 11cc:             FN.INVERT.DATE(UNPACK$(CCUOD.DATE.FILE.UPDATED$))
8460: 11cc:         LDT.CCUOD.UPDATE.TIME$ = UNPACK$(CCUOD.TIME.FILE.UPDATED$)
8461: 11ef:       ENDIF
8462: 11f7: 
8463: 11f7:       PIPE.OUT$ = "L" +                                                 \
8464: 126e:                   "RI" +                                                \
8465: 126e:                   FN.Z.PACK(UNPACK$(CCTRL.CREDIT.CLAIM.NUM$),8) +       \
8466: 126e:                   FN.Z.PACK(LDT.CCUOD.UPDATE.DATE$,6) +                 \
8467: 126e:                   FN.Z.PACK(LDT.CCUOD.UPDATE.TIME$,6)
8468: 126e: 
8469: 126e:       GOSUB SEND.TO.PSS38
8470: 1280: 
8471: 1280:     RETURN
8472: 1290: 
8473: 1290: \******************************************************************************
8474: 1290: \******************************************************************************
8475: 1290: \***                                                                        ***
8476: 1290: \***   RECEIVED.RETURNS.FILE.HEADER:                                        ***
8477: 1290: \***                                                                        ***
8478: 1290: \***     log message to background screen to indicate record received       ***
8479: 1290: \***     validate record layout; return if invalid                          ***
8480: 1290: \***                                                                        ***
8481: 1290: \***     create CCBUF                                                       ***
8482: 1290: \***     create CCREJ                                                       ***
8483: 1290: \***                                                                        ***
8484: 1290: \***     If expected number of uods > 0                                     ***
8485: 1290: \***        If LDT.RETURNS.TYPE is "O" Credit Claiming                      ***
8486: 1290: \***           Open the Store options file                                  ***
8487: 1290: \***           Read record 105                                              ***
8488: 1290: \***           Put valid Claim Business Centres into a variable             ***
8489: 1290: \***           Close Store options file                                     ***
8490: 1290: \***        endif                                                           ***
8491: 1290: \***     endif else                                                         ***
8492: 1290: \***        if LDT.RETURNS.TYPE is "G" Goods out                            ***
8493: 1290: \***           write a type 27 stock movement record                        ***
8494: 1290: \***     endif                                                              ***
8495: 1290: \***                                                                        ***
8496: 1290: \***     record information on the LDT audit file                           ***
8497: 1290: \***                                                                        ***
8498: 1290: \***     create new CCTMP for storage                                       ***
8499: 1290: \***                                                                        ***
8500: 1290: \******************************************************************************
8501: 1290: \******************************************************************************
8502: 1290: 
8503: 1290:     RECEIVED.RETURNS.FILE.HEADER:
8504: 12a0: 
8505: 12a0:       SB.MESSAGE$ = "PDT Support - RETURNS file hdr received"
8506: 12b5:       GOSUB SB.BG.MESSAGE
8507: 12c7: 
8508: 12c7:       IF FN.VALIDATE.DATA(DATA.IN$, 35) = 0 THEN BEGIN
8509: 12e9:          RECEIVE.STATE$ = "*"
8510: 1300:          GOTO MODULE.EXIT
8511: 130b:       ENDIF
8512: 1313: 
8513: 1313:       GOSUB CREATE.CCBUF                                               !ADS
8514: 1325:       GOSUB CREATE.CCREJ                                               ! 1.18 JAS
8515: 1337:       CCBUF.RECS.PRESENT = FALSE                                       !ADS
8516: 134d:       CCREJ.RECS.PRESENT = FALSE                                       ! 1.18JAS
8517: 1363:       DETAIL.RECORDS.RECEIVED = FALSE
8518: 137e:       ACTUAL.NUM.OF.UODS% = 0
8519: 138f:       ITEM.POS% = 0                                                 !BMJK
8520: 13a0:       EXPECTED.NUM.OF.UODS% = VAL(MID$(DATA.IN$,3,4))
8521: 13cd: 
8522: 13cd:       CSR.AUDIT.DATA$ = "RETURNS File Header. " +                      \
8523: 1405:                         STR$(EXPECTED.NUM.OF.UODS%) + " UOD(s) to follow."
8524: 1405:       GOSUB LOG.TO.AUDIT.FILE
8525: 1417: 
8526: 1417:       IF EXPECTED.NUM.OF.UODS% > 0 THEN BEGIN                            !BMJK
8527: 142c:         CSR.AUDIT.DATA$ = "    UOD Number      Status   " +               \BMJK
8528: 144a:                           "Total items  Updated items "               !BMJK
8529: 144a:         GOSUB LOG.TO.AUDIT.FILE                                          !BMJK
8530: 145c:         ! Read store options record 105 to get valid claim Business centres
8531: 145c:         IF SOPTS.OPEN.FLAG$ <> "Y" THEN BEGIN                       ! 1.16JAS
8532: 147a:            CURR.SESS.NUM% = SOPTS.SESS.NUM%                         ! 1.16JAS
8533: 148c:            IF END# SOPTS.SESS.NUM% THEN OPEN.ERROR                  ! 1.16JAS
8534: 14a8:            OPEN SOPTS.FILE.NAME$ DIRECT RECL 102      \             ! 1.16JAS
8535: 14d0:               AS SOPTS.SESS.NUM% NOWRITE NODEL                      ! 1.16JAS
8536: 14d0: 
8537: 14d0:         ENDIF                                                       ! 1.16JAS
8538: 14d8: 
8539: 14d8:         SOPTS.REC.NUM% = 105                                        ! 1.16JAS
8540: 14ef: 
8541: 14ef:         RC% = READ.SOPTS                                            ! 1.16JAS
8542: 1503: 
8543: 1503:         IF RC% <> 0 THEN GOTO READ.ERROR                            ! 1.16JAS
8544: 1518: 
8545: 1518:         REC.LEN% = LEN(SOPTS.RECORD$)                               ! 1.16JAS
8546: 1542:         COMMA$   = ","                                              ! 1.16JAS
8547: 1557:         COMMA.POS% = MATCH(COMMA$, SOPTS.RECORD$, 1) +2             ! 1.16JAS
8548: 1588:         END.POS%   = MATCH(COMMA$, SOPTS.RECORD$, COMMA.POS%) -1    ! 1.16JAS
8549: 15bd:         END.POS%   = END.POS% - COMMA.POS%                          ! 1.16JAS
8550: 15d6:         OTHER.CLAIM.VALID.BC$ = MID$(SOPTS.RECORD$,COMMA.POS%,END.POS%) ! 1.16JAS
8551: 1607: 
8552: 1607:         SOPTS.OPEN.FLAG$ = "N"                                      ! 1.16JAS
8553: 161e:         CLOSE SOPTS.SESS.NUM%                                       ! 1.16JAS
8554: 1635: 
8555: 1635:       ENDIF ELSE BEGIN                                                 !BMJK
8556: 163d:         ! If Goods out and not uods to process write type 27 stock movement record
8557: 163d:         IF LDT.RETURNS.TYPE$ = "G" THEN BEGIN                          ! 1.16JAS
8558: 165b:            IF STKMQ.OPEN.FLAG$ <> "Y" THEN BEGIN                            !BMJK
8559: 1679:              IF END# STKMQ.SESS.NUM% THEN OPEN.ERROR                     !BMJK
8560: 1695:              CURR.SESS.NUM% = STKMQ.SESS.NUM%                            !BMJK
8561: 16a7:              OPEN STKMQ.FILE.NAME$ AS STKMQ.SESS.NUM% BUFFSIZE 512              \BMJK
8562: 16cf:                READONLY APPEND                                                 !BMJK
8563: 16cf:              STKMQ.OPEN.FLAG$ = "Y"                                    !BMJK
8564: 16e6:            ENDIF                                                        !BMJK
8565: 16ee:            FINISH.DATE$ = DATE$                                          !BMJK
8566: 1706:            FINISH.TIME$ = TIME$                                          !BMJK
8567: 171e:            STKMQ.RECORD$ = CHR$(34) + PACK$("27") + CHR$(59) +               \BMJK
8568: 17cd:                            PACK$(FINISH.DATE$) +                             \BMJK
8569: 17cd:                            PACK$(FINISH.TIME$) +                             \BMJK
8570: 17cd:                            CHR$(34) + CHR$(0Dh) + CHR$(0Ah)              !BMJK
8571: 17cd:            CURRENT.KEY$ = ""                                          !BMJK
8572: 17e2:            CURR.SESS.NUM% = STKMQ.SESS.NUM%                            !BMJK
8573: 17f4:            IF WRITE.STKMQ THEN GOTO WRITE.ERROR                            !BMJK
8574: 1808:            CLOSE STKMQ.SESS.NUM%                                          !BMJK
8575: 181c:            STKMQ.OPEN.FLAG$ = "N"                                          !BMJK
8576: 1833:         ENDIF                                                         ! 1.16JAS
8577: 183b:       ENDIF                                                           !BMJK
8578: 1843: 
8579: 1843:       GOSUB CREATE.CCTMP
8580: 1855: 
8581: 1855:     RETURN
8582: 1865: 
8583: 1865: \******************************************************************************
8584: 1865: \******************************************************************************
8585: 1865: \***                                                                        ***
8586: 1865: \***   RECEIVED.RETURNS.UOD.HEADER:                                         ***
8587: 1865: \***                                                                        ***
8588: 1865: \***     log message to background screen to indicate record received       ***
8589: 1865: \***     validate record layout; return if invalid                          ***
8590: 1865: \***                                                                        ***
8591: 1865: \***     record information on the CSR audit file                           ***
8592: 1865: \***                                                                        ***
8593: 1865: \***     If the LDT.RETURNS.TYPE$ = "G" Goods out then                      ***
8594: 1865: \***      if the number of updated lines contained in the UOD is zero or the***
8595: 1865: \***       UOD status is despatched and the previous status is closed then  ***
8596: 1865: \***       a UOD status change is present and a type 28 CCTMP record will be***
8597: 1865: \***       formatted otherwise format a type 26 CCTMP record                ***
8598: 1865: \***     else                                                               ***
8599: 1865: \***       for credit claim a type 25 CCTMP record is written and this is   ***
8600: 1865: \***       is also written to a temp record as well                         ***
8601: 1865: \***                                                                        ***
8602: 1865: \***                                                                        ***
8603: 1865: \******************************************************************************
8604: 1865: \******************************************************************************
8605: 1865: 
8606: 1865:     RECEIVED.RETURNS.UOD.HEADER:
8607: 1875: 
8608: 1875:       IF FN.VALIDATE.DATA(DATA.IN$,36) = 0 THEN BEGIN
8609: 1897:         RECEIVE.STATE$ = "*"
8610: 18ae:         RETURN
8611: 18be:       ENDIF
8612: 18c6: 
8613: 18c6:       CCTMP.CREDIT.CLAIM.NUM$ = PACK$(MID$(DATA.IN$,3,8))
8614: 18f2:       CCTMP.UOD.NUM$ = PACK$(MID$(DATA.IN$,11,14))
8615: 191e:       CCTMP.UOD.STATUS$ = MID$(DATA.IN$,25,1)
8616: 1945:       CCTMP.NUM.ITEMS.UPDATED% = VAL(MID$(DATA.IN$,27,4))
8617: 1972:       CCTMP.NUM.OF.ITEMS% = VAL(MID$(DATA.IN$,31,4))
8618: 199f:       CCTMP.PREVIOUS.STATUS$ = MID$(DATA.IN$,26,1)
8619: 19c6:       DIM F14.TABLE$(CCTMP.NUM.ITEMS.UPDATED%)                            ! 1.16JAS
8620: 19fa:       VALID.INDEX% = 0                                                    ! 1.16JAS
8621: 1a0f: 
8622: 1a0f:       ACTUAL.UOD.ITEMS% = 0
8623: 1a20: 
8624: 1a20:       CSR.AUDIT.DATA$ = "  " + UNPACK$(CCTMP.UOD.NUM$) +              \
8625: 1ae5:                         "      " + CCTMP.UOD.STATUS$ +                     \
8626: 1ae5:                      "         " +                                    \
8627: 1ae5:                      RIGHT$("    "+STR$(CCTMP.NUM.OF.ITEMS%),4) +        \
8628: 1ae5:                      "           " +                             \
8629: 1ae5:                      RIGHT$("    "+STR$(CCTMP.NUM.ITEMS.UPDATED%),4)
8630: 1ae5:       GOSUB LOG.TO.AUDIT.FILE
8631: 1af7: 
8632: 1af7:       !  Goods out transmission
8633: 1af7:       IF LDT.RETURNS.TYPE$ = "G" THEN BEGIN                               ! 1.16JAS
8634: 1b15:          IF (CCTMP.UOD.STATUS$ = "D" AND CCTMP.PREVIOUS.STATUS$ = "C")       \
8635: 1b92:            OR CCTMP.UOD.STATUS$ = "X" THEN BEGIN
8636: 1b92:            CCTMP.RECORD$ = CCTMP.RECORD.DELIMITER$ +                      \
8637: 1c49:                          PACK$("28") +                                   \
8638: 1c49:                         CCTMP.FIELD.DELIMITER$ +                     \
8639: 1c49:                         PACK$(DATE$) +                                   \
8640: 1c49:                         PACK$(TIME$) +                                    \
8641: 1c49:                         CCTMP.CREDIT.CLAIM.NUM$ +                     \
8642: 1c49:                            CCTMP.UOD.NUM$ +                            \
8643: 1c49:                         CCTMP.UOD.STATUS$ +                            \
8644: 1c49:                         CCTMP.RECORD.DELIMITER$ +                      \
8645: 1c49:                         CCTMP.ENDREC.MARKER$
8646: 1c49:            CCTMP.RECORD.COMPLETE = TRUE
8647: 1c64:            CURR.SESS.NUM% = CCTMP.SESS.NUM%                            ! 1.18JAS
8648: 1c76:            CURRENT.KEY$ = ""                                           ! 1.18JAS
8649: 1c8b:            IF WRITE.CCTMP THEN GOTO WRITE.ERROR                        ! 1.18JAS
8650: 1ca2: 
8651: 1ca2:          ENDIF ELSE BEGIN
8652: 1caa:            CCTMP.NUM.ITEM.UPDATED$ = MID$(DATA.IN$,27,4)
8653: 1ccf:            CCTMP.TOTAL.QTY.IN.UOD$ = MID$(DATA.IN$,31,4)
8654: 1cf4:            CCTMP.ADJ.STOCK.FIGURE$ = MID$(DATA.IN$,35,1)
8655: 1d1b:            CCTMP.DATE.UOD.OPENED$ = PACK$(FN.INVERT.DATE(MID$(DATA.IN$,36,6)))
8656: 1d4b:            CCTMP.DATE.DESPATCHED$ = PACK$(FN.INVERT.DATE(MID$(DATA.IN$,42,6)))
8657: 1d7b:            CCTMP.TIME.DESPATCHED$ = PACK$(MID$(DATA.IN$,48,6))
8658: 1da7:            CCTMP.SUPPLY.ROUTE$ = MID$(DATA.IN$,54,1)
8659: 1dce:            CCTMP.DISP.LOCATION$ = MID$(DATA.IN$,55,1)
8660: 1df5:            CCTMP.BC.LETTER$ = MID$(DATA.IN$,56,1)
8661: 1e1c:            CCTMP.RECALL.NUM$ = MID$(DATA.IN$,57,8)
8662: 1e43:            CCTMP.AUTHORISATION$ = MID$(DATA.IN$,65,15)
8663: 1e6a:            CCTMP.SUPPLIER$ = MID$(DATA.IN$,80,15)
8664: 1e91:            CCTMP.RETURN.METHOD$ = PACK$("0"+MID$(DATA.IN$,95,1))
8665: 1ec9:            CCTMP.CARRIER$ = PACK$("0"+MID$(DATA.IN$,96,1))
8666: 1f01:            CCTMP.BIRD.NUM$ = MID$(DATA.IN$,97,8)
8667: 1f28:            CCTMP.RETURN.REASON$ = PACK$(MID$(DATA.IN$,105,2))
8668: 1f54:            CCTMP.RECEIVING.STORE$ = PACK$(MID$(DATA.IN$,107,4))
8669: 1f80:            CCTMP.DESTINATION$ = PACK$("0"+MID$(DATA.IN$,111,1))
8670: 1fb8:            CCTMP.WAREHOUSE.ROUTE$ = MID$(DATA.IN$,112,1)
8671: 1fdf:            CCTMP.UOD.TYPE$ = PACK$("0"+MID$(DATA.IN$,113,1))
8672: 2017:            CCTMP.DAMAGE.REASON$ = PACK$("0"+MID$(DATA.IN$,114,1))
8673: 204f:            CCTMP.RECALL.TYPE$ = " "                                 ! 1.20BG
8674: 2066: 
8675: 2066:            CCTMP.RECORD$ = CCTMP.RECORD.DELIMITER$ +                     \
8676: 21f3:                           PACK$("26") +                                   \
8677: 21f3:                         CCTMP.FIELD.DELIMITER$ +                      \
8678: 21f3:                         PACK$(DATE$) +                                    \
8679: 21f3:                         PACK$(TIME$) +                                    \
8680: 21f3:                         CCTMP.UOD.NUM$ +                             \
8681: 21f3:                         CCTMP.UOD.STATUS$ +                             \
8682: 21f3:                         CCTMP.CREDIT.CLAIM.NUM$ +                     \
8683: 21f3:                         CCTMP.NUM.ITEM.UPDATED$ +                     \
8684: 21f3:                         CCTMP.TOTAL.QTY.IN.UOD$ +                     \
8685: 21f3:                         CCTMP.ADJ.STOCK.FIGURE$ +                     \
8686: 21f3:                         CCTMP.SUPPLY.ROUTE$ +                            \
8687: 21f3:                         CCTMP.DISP.LOCATION$ +                            \
8688: 21f3:                         CCTMP.BC.LETTER$ +                            \
8689: 21f3:                         CCTMP.RECALL.NUM$ +                            \
8690: 21f3:                         CCTMP.AUTHORISATION$ +                             \
8691: 21f3:                         CCTMP.SUPPLIER$ +                            \
8692: 21f3:                         CCTMP.RETURN.METHOD$ +                            \
8693: 21f3:                         CCTMP.CARRIER$ +                            \
8694: 21f3:                         CCTMP.BIRD.NUM$ +                            \
8695: 21f3:                         CCTMP.RETURN.REASON$ +                            \
8696: 21f3:                         CCTMP.WAREHOUSE.ROUTE$ +                     \
8697: 21f3:                         CCTMP.UOD.TYPE$ +                            \
8698: 21f3:                         CCTMP.DAMAGE.REASON$ +                            \
8699: 21f3:                         CCTMP.RECEIVING.STORE$ +                      \
8700: 21f3:                         CCTMP.DESTINATION$ +                            \
8701: 21f3:                         CCTMP.DATE.UOD.OPENED$ +                      \
8702: 21f3:                         CCTMP.DATE.DESPATCHED$ +                     \
8703: 21f3:                         CCTMP.TIME.DESPATCHED$ +                     \
8704: 21f3:                         CCTMP.RECALL.TYPE$                          ! 1.20BG
8705: 21f3:            CCTMP.RECORD.COMPLETE = FALSE
8706: 220e:          ENDIF
8707: 2219:       ENDIF ELSE BEGIN
8708: 2221:            ! Credit Claim transmission
8709: 2221:            CCTMP.TOTAL.QTY.IN.UOD$ = MID$(DATA.IN$,31,4)             ! 1.16JAS
8710: 2246:            CCTMP.ADJ.STOCK.FIGURE$ = MID$(DATA.IN$,35,1)             ! 1.16JAS
8711: 226d:            CCTMP.DATE.DESPATCHED$ = PACK$(FN.INVERT.DATE(MID$(DATA.IN$,42,6))) ! 1.16JAS
8712: 229d:            CCTMP.TIME.DESPATCHED$ = PACK$(MID$(DATA.IN$,48,6))       ! 1.16JAS
8713: 22c9:            CCTMP.RETURN.REASON$ = PACK$(MID$(DATA.IN$,105,2))        ! 1.16JAS
8714: 22f5: 
8715: 22f5:            EXTRA.ITEMS% = 0                                          ! 1.17JAS
8716: 230a: 
8717: 230a:            TEMP.RECORD$  = CCTMP.RECORD.DELIMITER$ +                     \ ! 1.16JAS
8718: 239d:                            PACK$("25")             +                     \ ! 1.16JAS
8719: 239d:                            CCTMP.FIELD.DELIMITER$  +                     \ ! 1.16JAS
8720: 239d:                            CCTMP.DATE.DESPATCHED$  +                     \ ! 1.16JAS
8721: 239d:                            CCTMP.TIME.DESPATCHED$  +                     \ ! 1.16JAS
8722: 239d:                            CCTMP.CREDIT.CLAIM.NUM$ +                     \ ! 1.16JAS
8723: 239d:                            CCTMP.TOTAL.QTY.IN.UOD$ +                     \ ! 1.16JAS
8724: 239d:                            STRING$(15, " ")        +                     \ ! 1.16JAS
8725: 239d:                            CCTMP.ADJ.STOCK.FIGURE$ +                     \ ! 1.16JAS
8726: 239d:                            CCTMP.RETURN.REASON$                            ! 1.16JAS
8727: 239d:            CCTMP.RECORD.COMPLETE = FALSE                                   ! 1.16JAS
8728: 23b8:       ENDIF                                                                ! 1.16JAS
8729: 23c0: 
8730: 23c0:     RETURN
8731: 23d0: 
8732: 23d0: \******************************************************************************
8733: 23d0: \******************************************************************************
8734: 23d0: \***                                                                        ***
8735: 23d0: \***   RECEIVED.RETURNS.ITEM.DETAIL:                                        ***
8736: 23d0: \***                                                                        ***
8737: 23d0: \***     log message to background screen to indicate record received       ***
8738: 23d0: \***     validate record layout; return if invalid                          ***
8739: 23d0: \***                                                                        ***
8740: 23d0: \***     transfer record information to the CCTMP record in memory          ***
8741: 23d0: \***     increment number of UOD item received                              ***
8742: 23d0: \***     If LDT.RETURNS.TYPE$ = "O" Credit Claim                            ***
8743: 23d0: \***        Open the IRF and IDF                                            ***
8744: 23d0: \***        Depending on Item/Barcode flag either validate Item or Barcode  ***
8745: 23d0: \***        If valid item add item to valid table                           ***
8746: 23d0: \***        else add item to reject table                                   ***
8747: 23d0: \***                                                                        ***
8748: 23d0: \******************************************************************************
8749: 23d0: \******************************************************************************
8750: 23d0: 
8751: 23d0: RECEIVED.RETURNS.ITEM.DETAIL:
8752: 23e0: 
8753: 23e0:        IF FN.VALIDATE.DATA(DATA.IN$,37) = 0 THEN BEGIN
8754: 2402:           RECEIVE.STATE$ = "*"
8755: 2419:           GOTO MODULE.EXIT
8756: 2424:        ENDIF
8757: 242c: 
8758: 242c:        IF (NOT CCTMP.RECORD.COMPLETE) THEN BEGIN
8759: 2444:           CCTMP.ITEM.UPDATED$ = MID$(DATA.IN$,3,1)
8760: 246b:           CCTMP.ITEM.BARCODE.FLAG$ = MID$(DATA.IN$,4,1)
8761: 2492:           CCTMP.ITEM.BARCODE$ = PACK$(MID$(DATA.IN$,6,12))
8762: 24be:           CCTMP.ITEM.QTY$ = MID$(DATA.IN$,18,4)
8763: 24e3: 
8764: 24e3:           CURR.SESS.NUM% = IDF.SESS.NUM%                              ! 1.16JAS
8765: 24f5:           IF IDF.OPEN.FLAG$ = "Y" THEN BEGIN                          ! 1.16JAS
8766: 2513:            IDF.OPEN.FLAG$ = "N"                                       ! 1.16JAS
8767: 252a:             CLOSE IDF.SESS.NUM%                                       ! 1.16JAS
8768: 253e:           ENDIF                                                       ! 1.16JAS
8769: 2546:           IF END #IDF.SESS.NUM% THEN OPEN.ERROR                       ! 1.16JAS
8770: 2562:           OPEN IDF.FILE.NAME$ KEYED RECL IDF.RECL% AS IDF.SESS.NUM%   ! 1.16JAS                                     ! MMJK
8771: 258e:           IDF.OPEN.FLAG$ = "Y"                                        ! 1.16JAS
8772: 25a5: 
8773: 25a5:           IF END# IRF.SESS.NUM% THEN OPEN.ERROR                       ! 1.16JAS
8774: 25c1:           CURR.SESS.NUM% = IRF.SESS.NUM%                              ! 1.16JAS
8775: 25d3:           OPEN IRF.FILE.NAME$ KEYED RECL IRF.RECL% AS IRF.SESS.NUM%   \ 1.16JAS
8776: 2600:                   NOWRITE NODEL                                       ! 1.16JAS
8777: 2600: 
8778: 2600:          IF CCTMP.ITEM.BARCODE.FLAG$ = "I" THEN BEGIN                 ! 1.16JAS
8779: 261e:             GOSUB CHECK.VALID.ITEM                                    ! 1.16JAS
8780: 2630:             IF VALID.ENTRY% THEN BEGIN                                ! 1.16JAS
8781: 263f:                GOSUB ADD.ITEM.TO.VALID.TABLE                          ! 1.16JAS
8782: 2653:             ENDIF ELSE BEGIN                                          ! 1.16JAS
8783: 265b:                GOSUB ADD.ITEM.TO.REJECT.TABLE                         ! 1.16JAS
8784: 266d:             ENDIF                                                     ! 1.16JAS
8785: 2678:          ENDIF ELSE BEGIN                                             ! 1.16JAS
8786: 2680:             GOSUB CHECK.VALID.BARCODE                                 ! 1.16JAS
8787: 2692:             IF VALID.ENTRY% THEN BEGIN                                ! 1.16JAS
8788: 26a1:                CCTMP.ITEM.BARCODE$ = PACK$(RIGHT$("0000"   +          \ 1.16JAS
8789: 26de:                                      BOOTS.CODE$,12))                 ! 1.16JAS
8790: 26de:                GOSUB ADD.ITEM.TO.VALID.TABLE                          ! 1.16JAS
8791: 26f2:             ENDIF ELSE BEGIN                                          ! 1.16JAS
8792: 26fa:                GOSUB ADD.ITEM.TO.REJECT.TABLE                         ! 1.16JAS
8793: 270c:             ENDIF                                                     ! 1.16JAS
8794: 2714:          ENDIF                                                        ! 1.16JAS
8795: 271c:          ACTUAL.UOD.ITEMS% = ACTUAL.UOD.ITEMS% + 1                    ! 1.16JAS
8796: 272b:        ENDIF
8797: 2733: 
8798: 2733: RETURN
8799: 2743: 
8800: 2743: \******************************************************************************
8801: 2743: \******************************************************************************
8802: 2743: \***                                                                        ***
8803: 2743: \***   RECEIVED.RETURNS.UOD.TRAILER:                                        ***
8804: 2743: \***                                                                        ***
8805: 2743: \***     log message to background screen to indicate record received       ***
8806: 2743: \***     validate record layout; return if invalid                          ***
8807: 2743: \***                                                                        ***
8808: 2743: \***        If no valid items to process                                    ***
8809: 2743: \***           Set CCTMP.RECORD.COMPLETE to TRUE                            ***
8810: 2743: \***        ELSE                                                            ***
8811: 2743: \***          unload active table                                           ***
8812: 2743: \***        endif                                                           ***
8813: 2743: \***        If rejected items to process                                    ***
8814: 2743: \***           print rejection report                                       ***
8815: 2743: \***        endif                                                           ***
8816: 2743: \***                                                                        ***
8817: 2743: \***     compare the number of items expected on the trailer to actual      ***
8818: 2743: \***     number received and if a discrepancy has occurred;                 ***
8819: 2743: \***       log an event 92 detailing discrepancy                            ***
8820: 2743: \***       abort transmission                                               ***
8821: 2743: \***                                                                        ***
8822: 2743: \***     write record to CCTMP and increment total UODs counter             ***
8823: 2743: \***                                                                        ***
8824: 2743: \******************************************************************************
8825: 2743: \******************************************************************************
8826: 2743: 
8827: 2743: RECEIVED.RETURNS.UOD.TRAILER:
8828: 2753: 
8829: 2753:        IF FN.VALIDATE.DATA(DATA.IN$,38) = 0 THEN BEGIN
8830: 2775:           RECEIVE.STATE$ = "*"
8831: 278c:           GOTO MODULE.EXIT
8832: 2797:        ENDIF
8833: 279f: 
8834: 279f:        ! If no items to process set record complete to true
8835: 279f:        ! else unload active table
8836: 279f:        ! If reject items to process - print rejection report
8837: 279f:        IF VALID.INDEX% = 0 THEN BEGIN                               ! 1.16JAS
8838: 27ba:           CCTMP.RECORD.COMPLETE = TRUE                              ! 1.16JAS
8839: 27d7:        ENDIF ELSE BEGIN                                             ! 1.16JAS
8840: 27df:           GOSUB UNLOAD.ACTIVE.TABLE                                 ! 1.16JAS
8841: 27f1:        ENDIF                                                        ! 1.16JAS
8842: 27f9: 
8843: 27f9:        IF (NOT CCTMP.RECORD.COMPLETE) THEN BEGIN                       ! BMJK
8844: 2811:           CCTMP.RECORD$ = CCTMP.RECORD$ +                              \ BMJK
8845: 2848:                           CCTMP.RECORD.DELIMITER$ +                    \ BMJK
8846: 2848:                           CCTMP.ENDREC.MARKER$                         ! BMJK
8847: 2848:           IF ACTUAL.UOD.ITEMS% <> CCTMP.NUM.OF.ITEMS% THEN BEGIN       ! BMJK
8848: 2863:              CURR.SESS.NUM% = CCTMP.SESS.NUM%                          ! BMJK
8849: 2875:              CURRENT.KEY$ = ""                                         ! BMJK
8850: 288a:              IF WRITE.CCTMP THEN GOTO WRITE.ERROR                      ! BMJK
8851: 289e:              FILE.NUM% = 244                                           ! BMJK
8852: 28af:              EXPECTED.NUM% = CCTMP.NUM.OF.ITEMS%                       ! BMJK
8853: 28c5:              ACTUAL.NUM% = ACTUAL.UOD.ITEMS%                           ! BMJK
8854: 28db:              GOSUB LOG.AN.EVENT.92                                     ! BMJK
8855: 28ed:              RECEIVE.STATE$ = "*"                                      ! BMJK
8856: 2904:              GOTO MODULE.EXIT                                          ! BMJK
8857: 290f:           ENDIF                                                        ! BMJK
8858: 2917:        ENDIF                                                           ! BMJK
8859: 291f: 
8860: 291f: \*** Code for assigning claim number and writing to CCBUF here now     ! BMJK
8861: 291f: \*** redundant due to changes to include CCUPF interrogation in the    ! BMJK
8862: 291f: \*** transfer of the CCTMP to the STKMQ                                ! BMJK
8863: 291f: 
8864: 291f:        IF  VALID.INDEX% > 0 THEN BEGIN                                 ! 1.18JAS
8865: 2938:              CURR.SESS.NUM% = CCTMP.SESS.NUM%
8866: 294a:              CURRENT.KEY$ = ""
8867: 295f:              IF WRITE.CCTMP THEN GOTO WRITE.ERROR
8868: 2973:        ENDIF                                                           ! 1.16JAS
8869: 297b: 
8870: 297b:        ACTUAL.NUM.OF.UODS% = ACTUAL.NUM.OF.UODS% + 1
8871: 298a: 
8872: 298a: RETURN
8873: 299a: 
8874: 299a: \******************************************************************************
8875: 299a: \******************************************************************************
8876: 299a: \***                                                                        ***
8877: 299a: \***   RECEIVED.RETURNS.FILE.TRAILER:                                       ***
8878: 299a: \***                                                                        ***
8879: 299a: \***     log message to background screen to indicate record received       ***
8880: 299a: \***     validate record layout; return if invalid                          ***
8881: 299a: \***                                                                        ***
8882: 299a: \***     compare the number of UODs received with the expected number       ***
8883: 299a: \***     received and if the figures differ;                                ***
8884: 299a: \***       log an event 92 and abort transmission                           ***
8885: 299a: \***                                                                        ***
8886: 299a: \***     Check for existence of CCUPF and STKMQ by opening them             ***
8887: 299a: \***                                                                        ***
8888: 299a: \***         extract last claim number from CCTRL                           ***
8889: 299a: \***                                                                        ***
8890: 299a: \***         create and send a File received OK record to LDT that          ***
8891: 299a: \***           contains the last issued credit claim number                 ***
8892: 299a: \***                                                                        ***
8893: 299a: \******************************************************************************
8894: 299a: \******************************************************************************
8895: 299a: 
8896: 299a: RECEIVED.RETURNS.FILE.TRAILER:
8897: 29aa: 
8898: 29aa:        SB.MESSAGE$ = "PDT Support - RETURNS file trailer received"
8899: 29bf:        GOSUB SB.BG.MESSAGE
8900: 29d1: 
8901: 29d1:        IF FN.VALIDATE.DATA(DATA.IN$,39) = 0 THEN BEGIN
8902: 29f3:           RECEIVE.STATE$ = "*"
8903: 2a0a:           GOTO MODULE.EXIT
8904: 2a15:        ENDIF
8905: 2a1d: 
8906: 2a1d:        IF ACTUAL.NUM.OF.UODS% <> EXPECTED.NUM.OF.UODS% THEN BEGIN
8907: 2a35:           FILE.NUM% = 244
8908: 2a46:           EXPECTED.NUM% = EXPECTED.NUM.OF.UODS%
8909: 2a5c:           ACTUAL.NUM% = ACTUAL.NUM.OF.UODS%
8910: 2a72:           GOSUB LOG.AN.EVENT.92
8911: 2a84:           RECEIVE.STATE$ = "*"
8912: 2a9b:           GOTO MODULE.EXIT
8913: 2aa6:        ENDIF
8914: 2aae: 
8915: 2aae: 
8916: 2aae:        CURR.SESS.NUM% = CCUPF.SESS.NUM%                                ! CNS
8917: 2ac0:        IF END #CCUPF.SESS.NUM% THEN OPEN.ERROR                         ! CNS
8918: 2adc:        OPEN CCUPF.FILE.NAME$ KEYED RECL CCUPF.RECL% AS CCUPF.SESS.NUM% ! CNS
8919: 2b08:        CCUPF.OPEN.FLAG$ = "Y"                                          ! CNS
8920: 2b1f: 
8921: 2b1f:        IF STKMQ.OPEN.FLAG$ <> "Y" THEN BEGIN                           ! CNS
8922: 2b3d:           IF END# STKMQ.SESS.NUM% THEN OPEN.ERROR                      ! CNS
8923: 2b59:           CURR.SESS.NUM% = STKMQ.SESS.NUM%                             ! CNS
8924: 2b6b:           OPEN STKMQ.FILE.NAME$ AS STKMQ.SESS.NUM% BUFFSIZE 512        \ CNS
8925: 2b93:              READONLY APPEND                                           ! CNS
8926: 2b93:           STKMQ.OPEN.FLAG$ = "Y"                                       ! CNS
8927: 2baa:        ENDIF                                                           ! CNS
8928: 2bb2: 
8929: 2bb2:        CLOSE CCUPF.SESS.NUM%                                           ! CNS
8930: 2bc6:        CCUPF.OPEN.FLAG$ = "N"                                          ! CNS
8931: 2bdd: 
8932: 2bdd:        CLOSE STKMQ.SESS.NUM%                                           ! CNS
8933: 2bf1:        STKMQ.OPEN.FLAG$ = "N"                                          ! CNS
8934: 2c08: 
8935: 2c08: 
8936: 2c08:        CURR.SESS.NUM% = CCTRL.SESS.NUM%
8937: 2c1a:        IF END #CCTRL.SESS.NUM% THEN OPEN.ERROR
8938: 2c36:        OPEN CCTRL.FILE.NAME$ DIRECT RECL CCTRL.RECL% AS CCTRL.SESS.NUM%        ! BMJK
8939: 2c62:        CCTRL.OPEN.FLAG$ = "Y"
8940: 2c79:        CCTRL.REC.NUM% = 1
8941: 2c8a:        CURRENT.KEY$ = "1"
8942: 2c9f:        IF READ.CCTRL THEN GOTO READ.ERROR
8943: 2cb3:        CCTRL.OPEN.FLAG$ = "N"
8944: 2cca:        CLOSE CCTRL.SESS.NUM%
8945: 2cde: 
8946: 2cde:        PIPE.OUT$ = "L" +                                               \
8947: 2d1d:                    "RO" +                                              \
8948: 2d1d:                    FN.Z.PACK(UNPACK$(CCTRL.CREDIT.CLAIM.NUM$),8)
8949: 2d1d:        GOSUB SEND.TO.PSS38
8950: 2d2f: 
8951: 2d2f: RETURN
8952: 2d3f: 
8953: 2d3f: \******************************************************************************
8954: 2d3f: \******************************************************************************
8955: 2d3f: \***                                                                        ***
8956: 2d3f: \***   RECEIVED.RETURNS.FILE.REQUEST:                                       ***
8957: 2d3f: \***                                                                        ***
8958: 2d3f: \***     log message to background screen to indicate record received       ***
8959: 2d3f: \***     validate record layout; return if invalid                          ***
8960: 2d3f: \***                                                                        ***
8961: 2d3f: \***     issue hold message to LDT                                          ***
8962: 2d3f: \***                                                                        ***
8963: 2d3f: \***     check file request flag on LDT record                              ***
8964: 2d3f: \***     record information on the audit file                               ***
8965: 2d3f: \***                                                                        ***
8966: 2d3f: \***     if file request is yes; then call routine to extract CCUOD keys    ***
8967: 2d3f: \***        AND CCLAM keys.                                                 ***
8968: 2d3f: \***                                                                        ***
8969: 2d3f: \***     create empty CCWKF and write header with number of UODs to CCWKF   ***
8970: 2d3f: \***                                                                        ***
8971: 2d3f: \***     if file request is yes and CCUOD contains UODs to transmit         ***
8972: 2d3f: \***        OR CCLAM contains despatched UODs to transmit:                  ***
8973: 2d3f: \***       call routine to extract all CCUOD records and write to CCWKF     ***
8974: 2d3f: \***                                                                        ***
8975: 2d3f: \***     call routine to extract all business centres and write to CCWKF    ***
8976: 2d3f: \***                                                                        ***
8977: 2d3f: \***     write file trailer record to CCWKF and close file                  ***
8978: 2d3f: \***                                                                        ***
8979: 2d3f: \***     release LDT                                                        ***
8980: 2d3f: \***     store transmission details on LDTAF                                ***
8981: 2d3f: \***     instruct PSS38 to send CCWKF to LDT                                ***
8982: 2d3f: \***                                                                        ***
8983: 2d3f: \******************************************************************************
8984: 2d3f: \******************************************************************************
8985: 2d3f: 
8986: 2d3f:     RECEIVED.RETURNS.FILE.REQUEST:
8987: 2d4f: 
8988: 2d4f:       SB.MESSAGE$ = "PDT Support - RETURNS file request received"
8989: 2d64:       GOSUB SB.BG.MESSAGE
8990: 2d76:       IF FN.VALIDATE.DATA(DATA.IN$,40) = 0 THEN BEGIN
8991: 2d98:          RECEIVE.STATE$ = "*"
8992: 2daf:          GOTO MODULE.EXIT
8993: 2dba:       ENDIF
8994: 2dc2: 
8995: 2dc2:       GOSUB HOLD.LDT
8996: 2dd4: 
8997: 2dd4:       GOSUB CREATE.CCTMP                                          !ADS
8998: 2de6: 
8999: 2de6:       DATA.FILES.REQ$ = MID$(DATA.IN$,3,1)
9000: 2e0d:       CSR.AUDIT.DATA$ = "RETURNS file request; "
9001: 2e24:       IF DATA.FILES.REQ$ = "Y" THEN CSR.AUDIT.DATA$ =                     \
9002: 2e61:         CSR.AUDIT.DATA$ + "Data file update required."                     \
9003: 2e61:       ELSE CSR.AUDIT.DATA$ =                                           \
9004: 2e86:         CSR.AUDIT.DATA$ + "Business Centre update only."
9005: 2e8e:       GOSUB LOG.TO.AUDIT.FILE
9006: 2ea0: 
9007: 2ea0:       DIM BARCODE.TABLE$(5000),BARCODE.POS.TABLE$(5000)
9008: 2eec: 
9009: 2eec:       NUM.STATUS.O.C.X.UODS% = 0                                         ! 1.4
9010: 2efd:       NUM.OF.CANCELLED.UODS% = 0                                         ! 1.4
9011: 2f0e:       NUM.OF.DESPATCHED.UODS% = 0                                        ! 1.4
9012: 2f1f:       IF DATA.FILES.REQ$ = "Y" THEN BEGIN                                ! 1.4
9013: 2f3d:          GOSUB DIRECT.EXTRACT.CCUOD.KEYS
9014: 2f4f:          GOSUB DIRECT.EXTRACT.CCLAM.KEYS                                 ! 1.4
9015: 2f61:       ENDIF                                                              ! 1.4
9016: 2f69: 
9017: 2f69:       GOSUB CREATE.CCWKF.AND.WRITE.HEADER
9018: 2f7b: 
9019: 2f7b:       IF (NUM.STATUS.O.C.X.UODS%>0 OR NUM.OF.DESPATCHED.UODS%>0) AND     \ 1.4
9020: 2fcf:          (DATA.FILES.REQ$="Y") THEN BEGIN                                ! 1.4
9021: 2fcf:          GOSUB PROCESS.UOD.RECORDS                                       ! 1.4
9022: 2fe1:       ENDIF
9023: 2fe9: 
9024: 2fe9:       GOSUB EXTRACT.ALL.BUSINESS.CENTRES
9025: 2ffb:       GOSUB WRITE.CCWKF.TRAILER.AND.CLOSE.FILE
9026: 300d: 
9027: 300d:       LDTAF.LINK.TYPE% = 9
9028: 301d:       IF MONITORED.PORT$ = "B" THEN LDTAF.LINK.TYPE% =                      \
9029: 304b:          (LDTAF.LINK.TYPE% OR 80H)
9030: 3053:       LDTAF.START.DATE$ = PACK$(LOG.ON.DATE$)
9031: 3076:       LDTAF.START.TIME$ = PACK$(LOG.ON.TIME$)
9032: 3099:       TEMP.TIME$ = TIME$                                                ! BMJK
9033: 30b1:       LDTAF.DURATION% = ( (VAL(LEFT$(TEMP.TIME$,2))*3600) +              \ BMJK
9034: 329d:                           (VAL(MID$(TEMP.TIME$,3,2))*60) +               \ BMJK
9035: 329d:                            VAL(RIGHT$(TEMP.TIME$,2)) ) -                \ BMJK
9036: 329d:                       ( (VAL(UNPACK$(LEFT$(LDTAF.START.TIME$,1)))*3600)+\ BMJK
9037: 329d:                         (VAL(UNPACK$(MID$(LDTAF.START.TIME$,2,1)))*60)+       \ BMJK
9038: 329d:                          VAL(UNPACK$(RIGHT$(LDTAF.START.TIME$,1))) )       ! BMJK
9039: 329d:       LDTAF.DATA.VOLUME.1% = 0
9040: 32b4:       LDTAF.DATA.VOLUME.2% = 0
9041: 32cb:       LDTAF.DATA.VOLUME.1% = SIZE (CCWKF.FILE.NAME$)
9042: 32f2:       GOSUB LOG.TO.LDTAF.FILE
9043: 3304: 
9044: 3304:       GOSUB RELEASE.LDT                                                 ! BMJK
9045: 3316: 
9046: 3316:       GOSUB TRANSMIT.CCWKF.VIA.PSS38
9047: 3328: 
9048: 3328:     RETURN
9049: 3338: 
9050: 3338: \******************************************************************************
9051: 3338: \******************************************************************************
9052: 3338: \***                                                                        ***
9053: 3338: \***   RECEIVED.RETURNS.FILE.RECEIVED.OK:                                   ***
9054: 3338: \***                                                                        ***
9055: 3338: \***     log message to background screen to indicate record received       ***
9056: 3338: \***     validate record layout; return if invalid                          ***
9057: 3338: \***                                                                        ***
9058: 3338: \******************************************************************************
9059: 3338: \******************************************************************************
9060: 3338: 
9061: 3338:     RECEIVED.RETURNS.FILE.RECEIVED.OK:
9062: 3348: 
9063: 3348:       SB.MESSAGE$ = "PDT Support - RETURNS file received OK"
9064: 335d:       GOSUB SB.BG.MESSAGE
9065: 336f: 
9066: 336f:       IF FN.VALIDATE.DATA(DATA.IN$,41) = 0 THEN BEGIN
9067: 3391:         RECEIVE.STATE$ = "*"
9068: 33a8:         GOTO MODULE.EXIT
9069: 33b3:       ENDIF
9070: 33bb: 
9071: 33bb:     RETURN
9072: 33cb: 
9073: 33cb: \******************************************************************************
9074: 33cb: \******************************************************************************
9075: 33cb: \***                                                                        ***
9076: 33cb: \***   RECEIVED.RETURNS.EOT:                                                ***
9077: 33cb: \***                                                                        ***
9078: 33cb: \***     log message to background screen to indicate record received       ***
9079: 33cb: \***     validate record layout; return if invalid                          ***
9080: 33cb: \***                                                                        ***
9081: 33cb: \***     If records on CCREJ adxstart PSS25                                 ***
9082: 33cb: \***                                                                        ***
9083: 33cb: \***     If records on CCBUF and transmission was from Goods out adxstart   ***
9084: 33cb: \***     PSS22                                                              ***
9085: 33cb: \***     record end of session on audit file                                ***
9086: 33cb: \***     set flags to allow PSS37 to rechain                                ***
9087: 33cb: \***                                                                        ***
9088: 33cb: \******************************************************************************
9089: 33cb: \******************************************************************************
9090: 33cb: 
9091: 33cb: RECEIVED.RETURNS.EOT:
9092: 33db: 
9093: 33db:       SB.MESSAGE$ = "PDT Support - RETURNS EOT received"
9094: 33f0:       GOSUB SB.BG.MESSAGE
9095: 3402: 
9096: 3402:       IF FN.VALIDATE.DATA(DATA.IN$,42) = 0 THEN BEGIN
9097: 3424:         RECEIVE.STATE$ = "*"
9098: 343b:         GOTO MODULE.EXIT
9099: 3446:       ENDIF
9100: 344e: 
9101: 344e:       CURR.SESS.NUM% = CCREJ.SESS.NUM%                                 ! 1.18JAS
9102: 3460:       IF CCREJ.OPEN.FLAG$ = "Y" THEN BEGIN                             ! 1.18JAS
9103: 347e:          CCREJ.OPEN.FLAG$ = "N"                                        ! 1.18JAS
9104: 3495:          CLOSE CCREJ.SESS.NUM%                                         ! 1.18JAS
9105: 34a9:       ENDIF                                                            ! 1.18JAS
9106: 34b1: 
9107: 34b1:       IF CCREJ.RECS.PRESENT AND SIZE(CCREJ.FILE.NAME$) > 0 THEN BEGIN  ! 1.18JAS
9108: 34ef:          ADX.RET.CODE% = ADXSTART("ADX_UPGM:PSS25.286",       \        ! 1.18JAS
9109: 351e:                          MONITORED.PORT$,                     \        ! 1.18JAS
9110: 351e:                        "PSS25 - Credit Claiming Rejection reporting")  ! 1.18JAS
9111: 351e:       ENDIF                                                            ! 1.18JAS
9112: 3526: 
9113: 3526: ! The following lines moved from Received Returns File Trailer routine - CNS
9114: 3526:       CURR.SESS.NUM% = CCTMP.SESS.NUM%                                 ! CNS
9115: 3538:       IF CCTMP.OPEN.FLAG$ = "Y" THEN BEGIN                             ! CNS
9116: 3556:          CCTMP.OPEN.FLAG$ = "N"                                        ! CNS
9117: 356d:          CLOSE CCTMP.SESS.NUM%                                         ! CNS
9118: 3581:       ENDIF                                                            ! CNS
9119: 3589:       IF END #CCTMP.SESS.NUM% THEN OPEN.ERROR                          ! CNS
9120: 35a5:       OPEN CCTMP.FILE.NAME$ AS CCTMP.SESS.NUM% LOCKED                  ! CNS
9121: 35cc:       CCTMP.OPEN.FLAG$ = "Y"                                           ! CNS
9122: 35e3: 
9123: 35e3:       LDTAF.DATA.VOLUME.1% = 0                                         ! CNS
9124: 35fa:       LDTAF.DATA.VOLUME.1% = SIZE (CCTMP.FILE.NAME$)                   ! CNS
9125: 3621:       IF LDTAF.DATA.VOLUME.1% <> 0 THEN BEGIN                          ! CNS
9126: 3640:          GOSUB WRITE.STKMQ.FROM.CCTMP                                  ! CNS
9127: 3652:          GOSUB CREATE.CCTMP                                            ! CNS
9128: 3664:       ENDIF                                                            ! CNS
9129: 366c: 
9130: 366c: 
9131: 366c:       LDTAF.DATA.VOLUME.2% = 0
9132: 3683:       LDTAF.DATA.VOLUME.2% = SIZE (CCBUF.FILE.NAME$)
9133: 36aa:       LDTAF.LINK.TYPE% = 8
9134: 36ba:       IF MONITORED.PORT$ = "B" THEN LDTAF.LINK.TYPE% =                      \
9135: 36e8:          (LDTAF.LINK.TYPE% OR 80H)
9136: 36f0:       LDTAF.START.DATE$ = PACK$(LOG.ON.DATE$)
9137: 3713:       LDTAF.START.TIME$ = PACK$(LOG.ON.TIME$)
9138: 3736:       TEMP.TIME$ = TIME$                                               ! BMJK
9139: 374e:       LDTAF.DURATION% = ( (VAL(LEFT$(TEMP.TIME$,2))*3600) +              \ BMJK
9140: 393a:                           (VAL(MID$(TEMP.TIME$,3,2))*60) +               \ BMJK
9141: 393a:                            VAL(RIGHT$(TEMP.TIME$,2)) ) -                \ BMJK
9142: 393a:                       ( (VAL(UNPACK$(LEFT$(LDTAF.START.TIME$,1)))*3600)+\ BMJK
9143: 393a:                         (VAL(UNPACK$(MID$(LDTAF.START.TIME$,2,1)))*60)+       \ BMJK
9144: 393a:                          VAL(UNPACK$(RIGHT$(LDTAF.START.TIME$,1))) )       ! BMJK
9145: 393a:       GOSUB LOG.TO.LDTAF.FILE
9146: 394c: 
9147: 394c:       !If records on CCBUF file and transmission was for Goods out Start PSS22 to print Advice of UOD contents report
9148: 394c:       IF CCBUF.RECS.PRESENT AND                                             \ ! 1.16JAS
9149: 397c:          LDT.RETURNS.TYPE$ = "G" THEN BEGIN                                   ! 1.16JAS
9150: 397c:          ADX.RET.CODE% = ADXSTART("ADX_UPGM:PSS22.286",                     \
9151: 39ab:                          MONITORED.PORT$,                            \
9152: 39ab:                        "PSS22 - Advice of UOD contents reporting")
9153: 39ab:       ENDIF
9154: 39b3: 
9155: 39b3:       TEMP.TIME$ = TIME$
9156: 39cb:       CSR.AUDIT.DATA$ = "RETURNS session complete at " +                \
9157: 3a3d:                          LEFT$(TEMP.TIME$,2) + ":" +                    \ BMJK
9158: 3a3d:                       MID$(TEMP.TIME$,3,2) + ":" +                   \ BMJK
9159: 3a3d:                       RIGHT$(TEMP.TIME$,2)                           ! BMJK
9160: 3a3d:       GOSUB LOG.TO.AUDIT.FILE
9161: 3a4f: 
9162: 3a4f:       IF CSR.AUDIT.OPEN.FLAG$ = "Y" THEN BEGIN
9163: 3a6d:         CLOSE CSR.AUDIT.SESS.NUM%
9164: 3a81:         CSR.AUDIT.OPEN.FLAG$ = "N"
9165: 3a98:       ENDIF
9166: 3aa0: 
9167: 3aa0:       RE.CHAIN = TRUE
9168: 3ab6:       RECEIVE.STATE$ = "?"
9169: 3acd: 
9170: 3acd: RETURN
9171: 3add: 
9172: 3add: \******************************************************************************
9173: 3add: \******************************************************************************
9174: 3add: \***                                                                        ***
9175: 3add: \***   RECEIVED.STOCKTAKE.HEADER - Added for version 1.5                    ***
9176: 3add: \***                                                                        ***
9177: 3add: \***     log message to background screen to indicate record received       ***
9178: 3add: \***     validate record layout; return if invalid                          ***
9179: 3add: \***                                                                        ***
9180: 3add: \***     Create temprorary buffer file                                      ***
9181: 3add: \***     Write header to file                                               ***
9182: 3add: \***                                                                        ***
9183: 3add: \******************************************************************************
9184: 3add: \******************************************************************************
9185: 3add: 
9186: 3add: RECEIVED.STOCKTAKE.HEADER:
9187: 3aed: 
9188: 3aed:       SB.MESSAGE$ = "PDT Support - Stocktake hdr received"
9189: 3b02:       GOSUB SB.BG.MESSAGE
9190: 3b14: 
9191: 3b14:       LAST.STOCKTAKE.DATE$ = DATE$
9192: 3b2c:       LAST.STOCKTAKE% = FN.SECONDS(TIME$)
9193: 3b52: 
9194: 3b52:       IF FN.VALIDATE.DATA(DATA.IN$,43) = 0 THEN BEGIN
9195: 3b74:         RECEIVE.STATE$ = "*"
9196: 3b8b:         GOTO MODULE.EXIT
9197: 3b96:       ENDIF
9198: 3b9e: 
9199: 3b9e:       TEMP.TIME$ = TIME$
9200: 3bb6:       CSR.AUDIT.DATA$ = "Stocktake session started at " +            \
9201: 3c28:                          LEFT$(TEMP.TIME$,2) + ":" +                 \
9202: 3c28:                       MID$(TEMP.TIME$,3,2) + ":" +                   \
9203: 3c28:                       RIGHT$(TEMP.TIME$,2)
9204: 3c28:       GOSUB LOG.TO.AUDIT.FILE
9205: 3c3a: 
9206: 3c3a:       IF SXTMP.OPEN.FLAG$ = "Y" THEN BEGIN                             ! 1.6
9207: 3c58:          CLOSE SXTMP.SESS.NUM%                                         ! 1.6
9208: 3c6c:          SXTMP.OPEN.FLAG$ = "N"                                        ! 1.6
9209: 3c83:       ENDIF
9210: 3c8b: 
9211: 3c8b:       IF STLDT.OPEN.FLAG$ = "Y" THEN BEGIN                             ! 1.11
9212: 3ca9:          CLOSE STLDT.SESS.NUM%                                         ! 1.11
9213: 3cbd:          STLDT.OPEN.FLAG$ = "N"                                        ! 1.11
9214: 3cd4:       ENDIF                                                            ! 1.11
9215: 3cdc: 
9216: 3cdc:       CURR.SESS.NUM% = SXTMP.SESS.NUM%
9217: 3cee:       IF END# SXTMP.SESS.NUM% THEN CREATE.ERROR
9218: 3d0a:       CREATE POSFILE SXTMP.FILE.NAME$                                  \ 1.6
9219: 3d30:             AS SXTMP.SESS.NUM% LOCKED MIRRORED PERUPDATE
9220: 3d30:       SXTMP.OPEN.FLAG$ = "Y"
9221: 3d47: 
9222: 3d47:       CURR.SESS.NUM% = STLDT.SESS.NUM%                                 ! 1.11
9223: 3d59:       IF END# STLDT.SESS.NUM% THEN CREATE.STLDT                        ! 1.13DA
9224: 3d75:       OPEN STLDT.FILE.NAME$ DIRECT RECL STLDT.RECL% AS STLDT.SESS.NUM% ! 1.11
9225: 3da1:       GOTO SKIP.CREATE.STLDT                                           ! 1.13DA
9226: 3dab:    CREATE.STLDT:                                                       ! 1.13DA
9227: 3dbb:       CREATE STLDT.FILE.NAME$ DIRECT RECL STLDT.RECL% AS               \ 1.13DA
9228: 3de7:              STLDT.SESS.NUM%                                           ! 1.13DA
9229: 3de7:    SKIP.CREATE.STLDT:                                                  ! 1.13DA
9230: 3df7:       STLDT.OPEN.FLAG$ = "Y"                                           ! 1.11
9231: 3e0e:       IF SIZE(STLDT.FILE.NAME$) = 0 THEN BEGIN                         ! 1.11
9232: 3e34:          STLDT.RECORD.NUM% = 1                                         ! 1.11
9233: 3e4d:       ENDIF ELSE BEGIN                                                 ! 1.11
9234: 3e55:          STLDT.RECORD.NUM% = (SIZE(STLDT.FILE.NAME$) / STLDT.RECL%) + 1! 1.11
9235: 3e91:       ENDIF                                                            ! 1.11
9236: 3e99: 
9237: 3e99:       STOCKTAKE.COUNT = 1
9238: 3eae:       EXPECTED.RECORDS = VAL(MID$(DATA.IN$,9,6))
9239: 3edf: 
9240: 3edf: RETURN
9241: 3eef: 
9242: 3eef: \******************************************************************************
9243: 3eef: \******************************************************************************
9244: 3eef: \***                                                                        ***
9245: 3eef: \***   RECEIVED.STOCKTAKE.DETAIL - Added for version 1.5                    ***
9246: 3eef: \***                                                                        ***
9247: 3eef: \***     log message to background screen to indicate record received       ***
9248: 3eef: \***     validate record layout; return if invalid                          ***
9249: 3eef: \***                                                                        ***
9250: 3eef: \***     Write record to buffer file                                        ***
9251: 3eef: \***                                                                        ***
9252: 3eef: \******************************************************************************
9253: 3eef: \******************************************************************************
9254: 3eef: 
9255: 3eef: RECEIVED.STOCKTAKE.DETAIL:
9256: 3eff: 
9257: 3eff: 
9258: 3eff:       IF FN.VALIDATE.DATA(DATA.IN$,44) = 0 THEN BEGIN
9259: 3f21:         RECEIVE.STATE$ = "*"
9260: 3f38:         GOTO MODULE.EXIT
9261: 3f43:       ENDIF
9262: 3f4b: 
9263: 3f4b:       LAST.STOCKTAKE.DATE$ = DATE$
9264: 3f63:       LAST.STOCKTAKE% = FN.SECONDS(TIME$)
9265: 3f89: 
9266: 3f89:       IF STOCKTAKE.COUNT = 1 THEN BEGIN
9267: 3fa7:         SXTMP.DATA$ = MID$(DATA.IN$,3,14) + "                " + CHR$(13) ! 1.9
9268: 3fe7:         STLDT.STORE$ = LEFT$(SXTMP.DATA$,4)                               ! 1.11
9269: 400e:         STLDT.STOCKTAKER$ = MID$(SXTMP.DATA$,5,4)                         ! 1.11
9270: 4035:         STLDT.DATE$ = MID$(SXTMP.DATA$,9,6)                               ! 1.11
9271: 405c:         STLDT.TIME$ = LEFT$(TIME$,4)                                      ! 1.11
9272: 408b:       ENDIF ELSE BEGIN
9273: 4093:         IF STOCKTAKE.COUNT = EXPECTED.RECORDS THEN BEGIN
9274: 40b1:           SXTMP.DATA$ = MID$(DATA.IN$,3,6) + "                        " + \ 1.9
9275: 40f1:                         CHR$(13)
9276: 40f1:           STLDT.LDT.SERIAL$ = CURR.TERMINAL$                              ! 1.12
9277: 410f:           RC% = WRITE.STLDT                                               ! 1.12
9278: 4123:           IF RC% <> 0 THEN GOTO WRITE.ERROR                               ! 1.12
9279: 4138:           STLDT.RECORD.NUM% = STLDT.RECORD.NUM% + 1                       ! 1.12
9280: 4154: 
9281: 4154:         ENDIF ELSE BEGIN
9282: 415c:           SXTMP.DATA$ = MID$(DATA.IN$,3,5) + MID$(DATA.IN$,8,13) +       \ 1.9
9283: 41f5:             MID$(DATA.IN$,21,6) + MID$(DATA.IN$,27,6) +                  \ 1.9
9284: 41f5:             CHR$(13)
9285: 41f5:           STLDT.COUNTS% = STLDT.COUNTS% + VAL(MID$(DATA.IN$,21,6))       ! 1.15DA
9286: 425a:           STLDT.ITEMS% = STLDT.ITEMS% + 1                                ! 1.11
9287: 4273:         ENDIF
9288: 427b:       ENDIF
9289: 4283: 
9290: 4283:       RC% = WRITE.SXTMP
9291: 4297:       IF RC% <> 0 THEN GOTO WRITE.ERROR
9292: 42ac:       STOCKTAKE.COUNT = STOCKTAKE.COUNT + 1
9293: 42c5: 
9294: 42c5: RETURN
9295: 42d5: 
9296: 42d5: \******************************************************************************
9297: 42d5: \******************************************************************************
9298: 42d5: \***                                                                        ***
9299: 42d5: \***   RECEIVED.STOCKTAKE.TRAILER - Added for version 1.5                   ***
9300: 42d5: \***                                                                        ***
9301: 42d5: \***     log message to background screen to indicate record received       ***
9302: 42d5: \***     validate record layout; return if invalid                          ***
9303: 42d5: \***                                                                        ***
9304: 42d5: \***     Write record to buffer file                                        ***
9305: 42d5: \***     Close buffer file                                                  ***
9306: 42d5: \***                                                                        ***
9307: 42d5: \***     Send acknowledgement to PDT                                        ***
9308: 42d5: \***     Copy temporary buffer file to stocktake buffer file                ***
9309: 42d5: \***                                                                        ***
9310: 42d5: \******************************************************************************
9311: 42d5: \******************************************************************************
9312: 42d5: 
9313: 42d5: RECEIVED.STOCKTAKE.TRAILER:
9314: 42e5: 
9315: 42e5:       SB.MESSAGE$ = "PDT Support - Stocktake trlr received"
9316: 42fa:       GOSUB SB.BG.MESSAGE
9317: 430c: 
9318: 430c:       IF FN.VALIDATE.DATA(DATA.IN$,45) = 0 THEN BEGIN
9319: 432e:         RECEIVE.STATE$ = "*"
9320: 4345:         GOTO MODULE.EXIT
9321: 4350:       ENDIF
9322: 4358: 
9323: 4358:       LAST.STOCKTAKE.DATE$ = DATE$
9324: 4370:       LAST.STOCKTAKE% = FN.SECONDS(TIME$)
9325: 4396: 
9326: 4396:       IF STOCKTAKE.COUNT <> EXPECTED.RECORDS + 1 THEN BEGIN
9327: 43c2:           FILE.NUM% = 244
9328: 43d3:           EXPECTED.NUM% = EXPECTED.RECORDS
9329: 43e9:           ACTUAL.NUM% = STOCKTAKE.COUNT + 1
9330: 4405:           GOSUB LOG.AN.EVENT.92
9331: 4417:           RECEIVE.STATE$ = "*"
9332: 442e:           GOTO MODULE.EXIT
9333: 4439:       ENDIF
9334: 4441: 
9335: 4441:       T.DATE$ = DATE$                                                  ! 1.6
9336: 4459:       T.TIME$ = TIME$                                                  ! 1.6
9337: 4471: 
9338: 4471:       PIPE.OUT$ = "L" +                                                \ 1.6
9339: 455e:                   SOH$ +                                               \ 1.6
9340: 455e:                   FN.Z.PACK(STORE.NUMBER$, 4) +                        \ 1.6
9341: 455e:                   FN.Z.PACK(CURR.TERMINAL$, 6) +                       \ 1.6
9342: 455e:                   APPLICATION.NO$ +                                    \ 1.6
9343: 455e:                   RIGHT$(T.DATE$,2)+MID$(T.DATE$,3,2)+LEFT$(T.DATE$,2) + \ 1.6
9344: 455e:                   LEFT$(T.TIME$,4) +                                   \ 1.6
9345: 455e:                   ACK$                                                 ! 1.6
9346: 455e: 
9347: 455e:       IF END# PIPEI.SESS.NUM% THEN WRITE.ERROR                         ! 1.6
9348: 457c:       CURR.SESS.NUM% = PIPEI.SESS.NUM%                                 ! 1.6
9349: 458e:       WRITE# PIPEI.SESS.NUM%; PIPE.OUT$                                ! 1.6
9350: 45b6: 
9351: 45b6: 
9352: 45b6:        IF STKBF.OPEN.FLAG$ = "Y" THEN BEGIN                            ! 1.6
9353: 45d4:           CLOSE STKBF.SESS.NUM%                                        ! 1.6
9354: 45e8:           STKBF.OPEN.FLAG$ = "N"                                       ! 1.6
9355: 45ff:        ENDIF                                                           ! 1.6
9356: 4607: 
9357: 4607:        IF STKMF.OPEN.FLAG$ = "Y" THEN BEGIN                            ! 1.13DA
9358: 4625:           CLOSE STKMF.SESS.NUM%                                        ! 1.13DA
9359: 4639:           STKMF.OPEN.FLAG$ = "N"                                       ! 1.13DA
9360: 4650:        ENDIF                                                           ! 1.13DA
9361: 4658: 
9362: 4658:        IF END# STKBF.SESS.NUM% THEN OPEN.ERROR
9363: 4674:        CURR.SESS.NUM% = STKBF.SESS.NUM%
9364: 4686:        OPEN STKBF.FILE.NAME$ AS STKBF.SESS.NUM% BUFFSIZE MAX.REC.SIZE% \ 1.6
9365: 46b3:           READONLY APPEND
9366: 46b3:        STKBF.OPEN.FLAG$ = "Y"
9367: 46ca: 
9368: 46ca:        IF END# LOCCNT.SESS.NUM% THEN OPEN.ERROR                         ! 1.14DA
9369: 46e6:        CURR.SESS.NUM% = LOCCNT.SESS.NUM%                                ! 1.14DA
9370: 46f8:        OPEN LOCCNT.FILE.NAME$ DIRECT RECL LOCCNT.RECL% AS               \ 1.14DA
9371: 4727:             LOCCNT.SESS.NUM% NODEL                                      ! 1.14DA
9372: 4727:        LOCCNT.OPEN.FLAG$ = "Y"                                          ! 1.14DA
9373: 473e:        LOCCNT.RECORD.NUM% = (SIZE(LOCCNT.FILE.NAME$) / LOCCNT.RECL%)    ! 1.14DA
9374: 4773: 
9375: 4773:        IF STOCKTAKING.ALTERNATIVE.STORE = TRUE THEN BEGIN               ! 1.13DA
9376: 478e: 
9377: 478e:        IF END# STKMF.SESS.NUM% THEN OPEN.ERROR                          ! 1.13DA
9378: 47aa:        CURR.SESS.NUM% = STKMF.SESS.NUM%                                 ! 1.13DA
9379: 47bc:        OPEN STKMF.FILE.NAME$ DIRECT RECL STKMF.RECL% AS                 \ 1.13DA
9380: 47eb:             STKMF.SESS.NUM% NODEL                                       ! 1.13DA
9381: 47eb:        STKMF.OPEN.FLAG$ = "Y"                                           ! 1.13DA
9382: 4802:        IF SIZE(STKMF.FILE.NAME$) = STKMF.RECL% THEN BEGIN               ! 1.13DA
9383: 4838:           STKMF.RECORD.NUM% = 1                                         ! 1.13DA
9384: 4851:        ENDIF ELSE BEGIN                                                 ! 1.13DA
9385: 4859:           STKMF.RECORD.NUM% = (SIZE(STKMF.FILE.NAME$) / STKMF.RECL%) + 1! 1.13DA
9386: 4899:        ENDIF                                                            ! 1.13DA
9387: 48a1: 
9388: 48a1: !      IF END# STKCF.SESS.NUM% THEN OPEN.ERROR                          ! 1.13DA
9389: 48a1: !      CURR.SESS.NUM% = STKCF.SESS.NUM%                                 ! 1.13DA
9390: 48a1: !      OPEN STKCF.FILE.NAME$ DIRECT RECL STKCF.RECL% AS                 \ 1.13DA
9391: 48a1: !           STKCF.SESS.NUM% NODEL                                       ! 1.13DA
9392: 48a1: !      STKCF.OPEN.FLAG$ = "Y"                                           ! 1.13DA
9393: 48a1: 
9394: 48a1:        IF END# STKRC.SESS.NUM% THEN OPEN.ERROR                          ! 1.13DA
9395: 48bd:        CURR.SESS.NUM% = STKRC.SESS.NUM%                                 ! 1.13DA
9396: 48cf:        OPEN STKRC.FILE.NAME$ DIRECT RECL STKRC.RECL% AS STKRC.SESS.NUM% \ 1.13DA
9397: 48fe:                NODEL                                                    ! 1.13DA
9398: 48fe:        STKRC.OPEN.FLAG$ = "Y"                                           ! 1.13DA
9399: 4915:        STKRC.RECORD.NUM% = (SIZE(STKRC.FILE.NAME$) / STKRC.RECL%)       ! 1.13DA
9400: 494a: 
9401: 494a:        IF END# XGCF.SESS.NUM% THEN OPEN.ERROR                           ! 1.13DA
9402: 4966:        CURR.SESS.NUM% = XGCF.SESS.NUM%                                  ! 1.13DA
9403: 4978:        OPEN XGCF.FILE.NAME$ KEYED RECL XGCF.RECL% AS XGCF.SESS.NUM%     \ 1.13DA
9404: 49a5:        UNLOCKED NOWRITE NODEL                                           ! 1.13DA
9405: 49a5:        XGCF.OPEN.FLAG$ = "Y"                                            ! 1.13DA
9406: 49bc: 
9407: 49bc:        IF END# STKEX.SESS.NUM% THEN OPEN.ERROR                          ! 1.13DA
9408: 49d8:        CURR.SESS.NUM% = STKEX.SESS.NUM%                                 ! 1.13DA
9409: 49ea:        OPEN STKEX.FILE.NAME$ DIRECT RECL STKEX.RECL% AS STKEX.SESS.NUM% \ 1.13DA
9410: 4a19:                NODEL                                                    ! 1.13DA
9411: 4a19:        STKEX.OPEN.FLAG$ = "Y"                                           ! 1.13DA
9412: 4a30:        STKEX.RECORD.NUM% = (SIZE(STKEX.FILE.NAME$) / STKEX.RECL%)       ! 1.13DA
9413: 4a65: 
9414: 4a65:        IF END# STKDC.SESS.NUM% THEN OPEN.ERROR                          ! 1.13DA
9415: 4a81:        CURR.SESS.NUM% = STKDC.SESS.NUM%                                 ! 1.13DA
9416: 4a93:        OPEN STKDC.FILE.NAME$ DIRECT RECL STKDC.RECL% AS STKDC.SESS.NUM% \ 1.13DA
9417: 4ac2:                NODEL                                                    ! 1.13DA
9418: 4ac2:        STKDC.OPEN.FLAG$ = "Y"                                           ! 1.13DA
9419: 4ad9:        STKDC.RECORD.NUM% = (SIZE(STKDC.FILE.NAME$) / STKDC.RECL%)       ! 1.13DA
9420: 4b0e: 
9421: 4b0e:        IF END# STKIF.SESS.NUM% THEN OPEN.ERROR                          ! 1.13DA
9422: 4b2a:        CURR.SESS.NUM% = STKIF.SESS.NUM%                                 ! 1.13DA
9423: 4b3c:        OPEN STKIF.FILE.NAME$ KEYED RECL STKIF.RECL% AS STKIF.SESS.NUM%  ! 1.13DA
9424: 4b6a:        STKIF.OPEN.FLAG$ = "Y"                                           ! 1.13DA
9425: 4b81: 
9426: 4b81:        IF END# STKTF.SESS.NUM% THEN OPEN.ERROR                          ! 1.13DA
9427: 4b9d:        CURR.SESS.NUM% = STKTF.SESS.NUM%                                 ! 1.13DA
9428: 4baf:        OPEN STKTF.FILE.NAME$ KEYED RECL STKTF.RECL% AS STKTF.SESS.NUM%  ! 1.13DA
9429: 4bdd:        STKTF.OPEN.FLAG$ = "Y"                                           ! 1.13DA
9430: 4bf4: 
9431: 4bf4:        IF END# IDF.SESS.NUM% THEN OPEN.ERROR                            ! 1.13DA
9432: 4c10:        CURR.SESS.NUM% = IDF.SESS.NUM%                                   ! 1.13DA
9433: 4c22:        OPEN IDF.FILE.NAME$ KEYED RECL IDF.RECL% AS IDF.SESS.NUM%        \ 1.13DA
9434: 4c4f:                NOWRITE NODEL                                            ! 1.13DA
9435: 4c4f: 
9436: 4c4f:        ENDIF
9437: 4c57: 
9438: 4c57:        IF SXTMP.OPEN.FLAG$ = "Y" THEN BEGIN                            ! 1.6
9439: 4c75:           CLOSE SXTMP.SESS.NUM%                                        ! 1.6
9440: 4c89:           SXTMP.OPEN.FLAG$ = "N"                                       ! 1.6
9441: 4ca0:        ENDIF                                                           ! 1.6
9442: 4ca8: 
9443: 4ca8:        IF STLDT.OPEN.FLAG$ = "Y" THEN BEGIN                            ! 1.11
9444: 4cc6:           CLOSE STLDT.SESS.NUM%                                        ! 1.11
9445: 4cda:           STLDT.OPEN.FLAG$ = "N"                                       ! 1.11
9446: 4cf1:        ENDIF                                                           ! 1.11
9447: 4cf9: 
9448: 4cf9:        IF END# SXTMP.SESS.NUM% THEN OPEN.ERROR                         ! 1.6
9449: 4d15:        CURR.SESS.NUM% = SXTMP.SESS.NUM%                                ! 1.6
9450: 4d27:        OPEN SXTMP.FILE.NAME$ AS SXTMP.SESS.NUM% BUFFSIZE MAX.REC.SIZE% \ 1.6
9451: 4d55:           NOWRITE NODEL                                                ! 1.6
9452: 4d55:        SXTMP.OPEN.FLAG$ = "Y"                                          ! 1.6
9453: 4d6c: 
9454: 4d6c:        MAX.REC.SIZE% = 32767                                           ! 1.6
9455: 4d81:        INPUT.SIZE% = SIZE(SXTMP.FILE.NAME$)                            ! 1.6
9456: 4da6: 
9457: 4da6:        IF INPUT.SIZE% < MAX.REC.SIZE% THEN BEGIN                       ! 1.6
9458: 4dbf:           RECORD.FORMAT$ = "C" + STR$(INPUT.SIZE%)                     ! 1.6
9459: 4de6:        ENDIF ELSE BEGIN                                                ! 1.6
9460: 4dee:           RECORD.FORMAT$ = "C" + STR$(MAX.REC.SIZE%)                   ! 1.6
9461: 4e13:        ENDIF
9462: 4e1b: 
9463: 4e1b:        NO.MAX.RECS% = 1                                                ! 1.6
9464: 4e29:        IF INPUT.SIZE% > MAX.REC.SIZE% THEN BEGIN                       ! 1.6
9465: 4e42:           REMAINDER% = MOD(INPUT.SIZE%, MAX.REC.SIZE%)                 ! 1.6
9466: 4e5b:           NO.MAX.RECS% = INPUT.SIZE% / MAX.REC.SIZE%                   ! 1.6
9467: 4e73:        ENDIF
9468: 4e7b: 
9469: 4e7b:        GOSUB PREPARE.PROCESS                                           ! 1.13DA
9470: 4e8d: 
9471: 4e8d:        IF END #STKBF.SESS.NUM% THEN WRITE.ERROR                        ! 1.6
9472: 4ea9:        IF END #SXTMP.SESS.NUM% THEN READ.ERROR                         ! 1.6
9473: 4ec5:        FOR I% = 1 TO NO.MAX.RECS%                                      ! 1.6
9474: 4ed5:           READ FORM RECORD.FORMAT$; #SXTMP.SESS.NUM%; DATA.BLOCK$      ! 1.6
9475: 4f01:           WRITE FORM RECORD.FORMAT$; #STKBF.SESS.NUM%; DATA.BLOCK$     ! 1.6
9476: 4f2c:        NEXT I%
9477: 4f44: 
9478: 4f44:        IF INPUT.SIZE% > MAX.REC.SIZE% THEN BEGIN                       ! 1.6
9479: 4f60:           REMAINDER% = MOD(INPUT.SIZE%, MAX.REC.SIZE%)                 ! 1.6
9480: 4f79:           IF REMAINDER% > 0 THEN BEGIN                                 ! 1.6
9481: 4f95:              RECORD.FORMAT$ = "C" + STR$(REMAINDER%)                   ! 1.6
9482: 4fba:              READ FORM RECORD.FORMAT$; #SXTMP.SESS.NUM%; DATA.BLOCK$   ! 1.6
9483: 4fe6:              WRITE FORM RECORD.FORMAT$; #STKBF.SESS.NUM%; DATA.BLOCK$  ! 1.6
9484: 5011:           ENDIF                                                        ! 1.6
9485: 5019:        ENDIF                                                           ! 1.6
9486: 5021: 
9487: 5021:        CLOSE STKBF.SESS.NUM%
9488: 5035:        STKBF.OPEN.FLAG$ = "N"
9489: 504c: 
9490: 504c:        IF STOCKTAKING.ALTERNATIVE.STORE = TRUE THEN BEGIN              ! 1.13DA
9491: 5064:           GOSUB READ.THRU.STKBF                                        ! 1.13DA
9492: 5076:        ENDIF                                                           ! 1.13DA
9493: 507e: 
9494: 507e:        CLOSE STKMF.SESS.NUM%                                           ! 1.13DA
9495: 5092:        STKMF.OPEN.FLAG$ = "N"                                          ! 1.13DA
9496: 50a9:        CLOSE SXTMP.SESS.NUM%
9497: 50bd:        SXTMP.OPEN.FLAG$ = "N"
9498: 50d4:        CLOSE STLDT.SESS.NUM%                                           ! 1.11
9499: 50e8:        STLDT.OPEN.FLAG$ = "N"                                          ! 1.11
9500: 50ff:        CLOSE SXTCF.SESS.NUM%                                           ! 1.13DA
9501: 5113: 
9502: 5113:        TEMP.TIME$ = TIME$
9503: 512b:        CSR.AUDIT.DATA$ = "Stocktake session completed at " +          \
9504: 519d:                          LEFT$(TEMP.TIME$,2) + ":" +                 \
9505: 519d:                       MID$(TEMP.TIME$,3,2) + ":" +                   \
9506: 519d:                       RIGHT$(TEMP.TIME$,2)
9507: 519d:        GOSUB LOG.TO.AUDIT.FILE
9508: 51af: 
9509: 51af:        RE.CHAIN = TRUE
9510: 51c5:        RECEIVE.STATE$ = "?"
9511: 51dc: 
9512: 51dc: RETURN
9513: 51ec: 
9514: 51ec: READ.THRU.STKBF:
9515: 51fc: 
9516: 51fc:        IF END# STKBF.SESS.NUM% THEN OPEN.ERROR
9517: 5218:        CURR.SESS.NUM% = STKBF.SESS.NUM%
9518: 522a:        OPEN STKBF.FILE.NAME$ AS STKBF.SESS.NUM% BUFFSIZE MAX.REC.SIZE% \ 1.6
9519: 5257:           READONLY APPEND
9520: 5257:        STKBF.OPEN.FLAG$ = "Y"
9521: 526e: 
9522: 526e:      READ.STKBF.LOOP:
9523: 527e:        RC% = READ.STKBF
9524: 5292:        IF RC% = 0 THEN BEGIN
9525: 52a4:           GOSUB PROCESS.RECORD
9526: 52b6:           GOTO READ.STKBF.LOOP
9527: 52c0:        ENDIF
9528: 52c8: 
9529: 52c8:        CLOSE STKBF.SESS.NUM%
9530: 52dc:        STKBF.OPEN.FLAG$ = "N"
9531: 52f3: 
9532: 52f3:        CURR.SESS.NUM% = STKBF.SESS.NUM%
9533: 5305:        IF END# STKBF.SESS.NUM% THEN CREATE.ERROR
9534: 5321:        CREATE POSFILE STKBF.FILE.NAME$ AS STKBF.SESS.NUM% MIRRORED PERUPDATE
9535: 5347: 
9536: 5347:        CLOSE STKBF.SESS.NUM%
9537: 535b:        STKBF.OPEN.FLAG$ = "N"
9538: 5372: 
9539: 5372: RETURN
9540: 5382: 
9541: 5382: \******************************************************************************
9542: 5382: \***
9543: 5382: \***   PREPARE.PROCESS:
9544: 5382: \***
9545: 5382: \***   Check that pointer to STKBF on SXTCF is valid.
9546: 5382: \***   Point to current record
9547: 5382: \***   Repeat
9548: 5382: \***           Lock control file
9549: 5382: \***           Read buffer file
9550: 5382: \***           Process record
9551: 5382: \***
9552: 5382: \******************************************************************************
9553: 5382: 
9554: 5382: PREPARE.PROCESS:
9555: 5392: 
9556: 5392:        GOSUB GET.MATRIX                                                  ! 1.13DA
9557: 53a4: 
9558: 53a4:        IF END# SXTCF.SESS.NUM% THEN OPEN.ERROR                           ! 1.13DA
9559: 53c0:        CURR.SESS.NUM% = SXTCF.SESS.NUM%                                  ! 1.13DA
9560: 53d2:        OPEN SXTCF.FILE.NAME$ DIRECT RECL SXTCF.RECL% AS SXTCF.SESS.NUM%  \ 1.13DA
9561: 53ff:                NODEL                                                     ! 1.13DA
9562: 53ff: 
9563: 53ff:        IF END# IRF.SESS.NUM% THEN OPEN.ERROR                             ! 1.13DA
9564: 541b:        CURR.SESS.NUM% = IRF.SESS.NUM%                                    ! 1.13DA
9565: 542d:        OPEN IRF.FILE.NAME$ KEYED RECL IRF.RECL% AS IRF.SESS.NUM%         \ 1.13DA
9566: 545a:                NOWRITE NODEL                                             ! 1.13DA
9567: 545a: 
9568: 545a:        CURR.SESS.NUM% = SXTCF.SESS.NUM%
9569: 546c:        RC% = READ.SXTCF
9570: 5481:        IF RC% <> 0 THEN GOTO READ.ERROR
9571: 5496: 
9572: 5496:        !******************************************************************!1.3
9573: 5496:        !* Initialise variable to hold currently processed location code   !1.3
9574: 5496:        !******************************************************************!1.3
9575: 5496:        CUR.LOC$ = SXTCF.CUR.LOCATION$                                     !1.3
9576: 54b2:        CUR.LOC.COUNTER% = 0                                               !1.3
9577: 54c7:        LOCCNT.RECORD.NUM% = GET.LOCCNT.RECNUM(CUR.LOC$)                   !1.3
9578: 54ee:        IF LOCCNT.RECORD.NUM% > 0 THEN BEGIN                               !1.3
9579: 550a:           RC% = READ.LOCCNT                                               !1.3
9580: 551e:           IF RC% = 0 THEN BEGIN                                           !1.3
9581: 5530:              CUR.LOC.COUNTER% = LOCCNT.LOCATION.COUNT%                    !1.3
9582: 554f:           ENDIF                                                           !1.3
9583: 5559:        ENDIF ELSE BEGIN                                                   !1.3
9584: 5561:           CUR.LOC$ = "     "                                              !1.3
9585: 5576:        ENDIF                                                              !1.3
9586: 557e: 
9587: 557e:        IF SXTCF.STKBF.POINTER% > SIZE(STKBF.FILE.NAME$) THEN BEGIN
9588: 55a5:             SB.UNIQUE$ = "0000000000000000" + STR$(SXTCF.STKBF.POINTER%)
9589: 55cd:             SB.EVENT.NO% = 58
9590: 55da:             GOSUB SB.LOG.AN.EVENT
9591: 55ec: 
9592: 55ec:             SXTCF.STKBF.POINTER% = 0
9593: 5603:        ENDIF
9594: 560b: 
9595: 560b:        RC% = WRITE.SXTCF
9596: 5620:        IF RC% <> 0 THEN GOTO WRITE.ERROR
9597: 5635: 
9598: 5635:        POINT STKBF.SESS.NUM%; SXTCF.STKBF.POINTER%
9599: 5654: 
9600: 5654:        HEADER.EXPECTED = SXTCF.HEADER.EXPECTED%
9601: 5666:        IF SXTCF.STKBF.POINTER% = 0 THEN HEADER.EXPECTED = 1
9602: 568a:        ITEM.COUNT = SXTCF.CURRENT.COUNT%
9603: 56a1:        STOCKTAKER$ = SXTCF.STOCKTAKER$
9604: 56bd:        STORE$ = "0000"
9605: 56d2: 
9606: 56d2:        CR$ = CHR$(13)
9607: 56ea: 
9608: 56ea: RETURN
9609: 56fa: 
9610: 56fa: \******************************************************************************
9611: 56fa: \***
9612: 56fa: \***   PROCESS.RECORD:
9613: 56fa: \***
9614: 56fa: \***   Check record type
9615: 56fa: \***
9616: 56fa: \******************************************************************************
9617: 56fa: 
9618: 56fa: PROCESS.RECORD:
9619: 570a: 
9620: 570a:      RC% = READ.SXTCF.LOCK
9621: 571f:      IF RC% <> 0 THEN BEGIN
9622: 5731:         CURR.SESS.NUM% = SXTCF.SESS.NUM%
9623: 5743:         GOTO READ.ERROR
9624: 574e:      ENDIF
9625: 5756: 
9626: 5756:      IF LEFT$(STKBF.DATA$,1) = "S" OR LEFT$(STKBF.DATA$,1) = "B" THEN BEGIN
9627: 57d3:        GOSUB PROCESS.ITEM
9628: 57e8:      ENDIF ELSE BEGIN
9629: 57f0:        IF LEFT$(STKBF.DATA$,4) = STORE.NUMBER$ THEN BEGIN
9630: 582c:           GOSUB PROCESS.HEADER
9631: 5840:        ENDIF ELSE BEGIN
9632: 5848:           GOSUB PROCESS.TRAILER
9633: 585a:        ENDIF
9634: 5862:      ENDIF
9635: 586a: 
9636: 586a: RETURN
9637: 587a: 
9638: 587a: \******************************************************************************
9639: 587a: \***
9640: 587a: \***   PROCESS.HEADER:
9641: 587a: \***
9642: 587a: \***   If header expected Then
9643: 587a: \***           Write record to Mainframe Transmission File
9644: 587a: \***   Else
9645: 587a: \***           Write record to Recount Audit Trail
9646: 587a: \***
9647: 587a: \***   RETURN
9648: 587a: \***
9649: 587a: \******************************************************************************
9650: 587a: PROCESS.HEADER:
9651: 588a: 
9652: 588a:        IF HEADER.EXPECTED = 1 THEN BEGIN
9653: 589c:             STKMF.DATA$ = LEFT$(STKBF.DATA$,8) + "                  " + CR$
9654: 58dd:             RC% = WRITE.STKMF
9655: 58f1:             IF RC% <> 0 THEN BEGIN
9656: 5903:                CURR.SESS.NUM% = STKMF.SESS.NUM%
9657: 5915:                GOTO WRITE.ERROR
9658: 5920:             ENDIF
9659: 5928:             STKMF.RECORD.NUM% = STKMF.RECORD.NUM% + 1
9660: 5941:             STKMF.DATA$ = MID$(STKBF.DATA$,9,6) + "                    " + CR$
9661: 5982:             RC% = WRITE.STKMF
9662: 5996:             IF RC% <> 0 THEN GOTO WRITE.ERROR
9663: 59ab:             STKMF.RECORD.NUM% = STKMF.RECORD.NUM% + 1
9664: 59c4:             STORE$ = LEFT$(STKBF.DATA$,4)
9665: 59e9:             STOCKTAKER$ = MID$(STKBF.DATA$,5,4)
9666: 5a0e:             HEADER.EXPECTED = 0
9667: 5a1b:             ITEM.COUNT = 0
9668: 5a30:             BATCH.ITEMS = 0
9669: 5a48:        ENDIF ELSE BEGIN
9670: 5a50:             STKRC.ITEM.CODE$ = PACK$("00000000000000")
9671: 5a6c:             STKRC.ITEM.DESCRIPTION$ = "Unexpected Header Record"
9672: 5a83:             STKRC.LOCATION$ = "X0000"                                  ! 1.3
9673: 5a9a:             STKRC.INITIAL.QUANTITY$ = PACK$("000000")
9674: 5ab6:             STKRC.INITIAL.STOCKTAKER$ = PACK$(MID$(STKBF.DATA$,5,4))
9675: 5ae2:             STKRC.FINAL.QUANTITY$ = PACK$("000000")
9676: 5afe:             STKRC.FINAL.STOCKTAKER$ = PACK$("0000")
9677: 5b1a:             RC% = WRITE.STKRC
9678: 5b2e:             IF RC% <> 0 THEN BEGIN
9679: 5b40:                CURR.SESS.NUM% = STKRC.SESS.NUM%
9680: 5b52:                GOTO WRITE.ERROR
9681: 5b5d:             ENDIF
9682: 5b65:             STKRC.RECORD.NUM% = STKRC.RECORD.NUM% + 1
9683: 5b7e:        ENDIF
9684: 5b86: 
9685: 5b86: 
9686: 5b86: 
9687: 5b86: 
9688: 5b86: RETURN
9689: 5b96: 
9690: 5b96: \******************************************************************************
9691: 5b96: \***
9692: 5b96: \***   PROCESS.ITEM:
9693: 5b96: \***
9694: 5b96: \***   If header expected Then
9695: 5b96: \***           Write record to Recount Audit Trail
9696: 5b96: \***   Else
9697: 5b96: \***
9698: 5b96: \***           Check for Group Code
9699: 5b96: \***           If Group Code Then
9700: 5b96: \***                   Write record to Dump Code Audit File
9701: 5b96: \***                   Write record to Mainframe Transmission File
9702: 5b96: \***           Else
9703: 5b96: \***                   If Barcode Then
9704: 5b96: \***                      Read IRF to get Boots Code
9705: 5b96: \***                      If not on IRF Then
9706: 5b96: \***                           Write record to Exceptions File
9707: 5b96: \***                           Read STKIF using Barcode and Location
9708: 5b96: \***                           If found on STKIF Then
9709: 5b96: \***                              Write record to Recount Audit Trail
9710: 5b96: \***                              Write record to STKIF
9711: 5b96: \***                              Update Mainframe Transmission File
9712: 5b96: \***                           Else
9713: 5b96: \***                              Write record to Mainframe Transmission File
9714: 5b96: \***                              Create new STKIF record
9715: 5b96: \***                   If Boots Code Then
9716: 5b96: \***                      Format Boots Code
9717: 5b96: \***                      Read STKIF using Boots Code and Location
9718: 5b96: \***                      If found on STKIF Then
9719: 5b96: \***                           Write record to Recount Audit Trail
9720: 5b96: \***                           Write record to STKIF
9721: 5b96: \***                           Update Mainframe Transmission File
9722: 5b96: \***                           Read Stocktake Totals File
9723: 5b96: \***                           Add count difference to total on file
9724: 5b96: \***                           Write record to Stocktake Totals File
9725: 5b96: \***                      Else
9726: 5b96: \***                           Read IDF using Boots Code
9727: 5b96: \***                           If item on IDF
9728: 5b96: \***                              Check for within stocktake scope
9729: 5b96: \***                              If Not in scope Then
9730: 5b96: \***                                 Write record to Exceptions File
9731: 5b96: \***                              Else
9732: 5b96: \***                                 Write record to Mainframe Transmission File
9733: 5b96: \***                                 Write record to STKIF
9734: 5b96: \***                                 Check if item is on stock system
9735: 5b96: \***                                 If item on stock Then
9736: 5b96: \***                                    Read Stocktake Totals File
9737: 5b96: \***                                    If item found Then
9738: 5b96: \***                                       Add count to total on file
9739: 5b96: \***                                       Write record to Stocktake Totals File
9740: 5b96: \***                                    Else
9741: 5b96: \***                                       Create new record on Stocktake Totals File
9742: 5b96: \***                                 Else
9743: 5b96: \***                                    Lookup item on XGCF (Group Codes File)         !1.4
9744: 5b96: \***                                    If item on XGCF                                !1.4
9745: 5b96: \***                                       (same processing as for group code)         !1.4
9746: 5b96: \***                                       Write record to Dump Code Audit File        !1.4
9747: 5b96: \***                                       Write record to Mainframe Transmission File !1.4
9748: 5b96: \***                                    Else                                           !1.4
9749: 5b96: \***                                       Write record to Exceptions File
9750: 5b96: \***                           Else
9751: 5b96: \***                              Write record to Exceptions File
9752: 5b96: \***                              Write record to Mainframe Transmission File
9753: 5b96: \***                              Write record to STKIF
9754: 5b96: \***
9755: 5b96: \***
9756: 5b96: \***   RETURN
9757: 5b96: \***
9758: 5b96: \******************************************************************************
9759: 5b96: PROCESS.ITEM:
9760: 5ba6: 
9761: 5ba6:        IF HEADER.EXPECTED = 1 THEN BEGIN
9762: 5bb8:             STKRC.ITEM.CODE$ = PACK$("0" + MID$(STKBF.DATA$,6,13))  ! 1.1 ! 1.3
9763: 5bf0:             STKRC.ITEM.DESCRIPTION$ = "Header Record Missing   "
9764: 5c07:             STKRC.LOCATION$ = LEFT$(STKBF.DATA$,5)                  ! 1.3
9765: 5c2e:             STKRC.INITIAL.QUANTITY$ = PACK$(MID$(STKBF.DATA$,19,6)) ! 1.1 ! 1.3
9766: 5c5a:             STKRC.INITIAL.STOCKTAKER$ = PACK$("0000")
9767: 5c76:             STKRC.FINAL.QUANTITY$ = PACK$("000000")
9768: 5c92:             STKRC.FINAL.STOCKTAKER$ = PACK$("0000")
9769: 5cae:             RC% = WRITE.STKRC
9770: 5cc2:             IF RC% <> 0 THEN BEGIN
9771: 5cd4:                CURR.SESS.NUM% = STKRC.SESS.NUM%
9772: 5ce6:                GOTO WRITE.ERROR
9773: 5cf1:             ENDIF
9774: 5cf9:             STKRC.RECORD.NUM% = STKRC.RECORD.NUM% + 1
9775: 5d15:        ENDIF ELSE BEGIN
9776: 5d1d:             !*************************************************************!1.3
9777: 5d1d:             !* Process a location change if it is detected.               !1.3
9778: 5d1d:             !*************************************************************!1.3
9779: 5d1d:             IF CUR.LOC$ <> LEFT$(STKBF.DATA$,5) THEN BEGIN                !1.3
9780: 5d4b:                NEW.LOC$ = LEFT$(STKBF.DATA$,5)                            !1.3
9781: 5d70:                GOSUB PROCESS.LOCATION.CHANGE                              !1.3
9782: 5d82:             ENDIF                                                         !1.3
9783: 5d8a: 
9784: 5d8a:             ITEM.COUNT = ITEM.COUNT + 1
9785: 5da3:             SXTCF.ITEM.COUNT% = SXTCF.ITEM.COUNT% + 1
9786: 5dbc: 
9787: 5dbc:             GOSUB CHECK.GROUP.CODE
9788: 5dce: 
9789: 5dce:             IF GROUP.CODE = 1 THEN BEGIN
9790: 5ddd: 
9791: 5ddd:                ! Group code
9792: 5ddd:                GOSUB PROCESS.GROUP.CODE
9793: 5df2: 
9794: 5df2:             ENDIF ELSE BEGIN
9795: 5dfa: 
9796: 5dfa:                ! Not a group code (Barcode / Boots code)
9797: 5dfa:                IF CURRENT.CODE = 0 THEN BEGIN
9798: 5e0c:                   ! Bar code
9799: 5e0c:                   IRF.BAR.CODE$ = MID$(STKBF.DATA$,6,12)               ! 1.3
9800: 5e33:                   IRF.BAR.CODE$ = PACK$(FN.ZERO.PL(IRF.BAR.CODE$,22))
9801: 5e5c:                   RC% = READ.IRF
9802: 5e70:                   IF RC% <> 0 THEN BEGIN
9803: 5e85:                      STKEX.ITEM.CODE$ = PACK$("0" + MID$(STKBF.DATA$,6,13)) ! 1.3
9804: 5ebd:                      STKEX.QUANTITY$ = PACK$(MID$(STKBF.DATA$,19,6))  ! 1.1 ! 1.3
9805: 5ee9:                      STKEX.LOCATION$ = LEFT$(STKBF.DATA$,5)            ! 1.3
9806: 5f10:                      STKEX.STOCKTAKER.NUM$ = PACK$(STOCKTAKER$)
9807: 5f30:                      STKEX.REASON.CODE$ = "I"
9808: 5f47:                      RC% = WRITE.STKEX
9809: 5f5b:                      IF RC% <> 0 THEN BEGIN
9810: 5f6d:                         CURR.SESS.NUM% = STKEX.SESS.NUM%
9811: 5f7f:                         GOTO WRITE.ERROR
9812: 5f8a:                      ENDIF
9813: 5f92:                      STKEX.RECORD.NUM% = STKEX.RECORD.NUM% + 1
9814: 5fab: 
9815: 5fab:                      STKIF.ITEM.CODE$ = PACK$("0" + MID$(STKBF.DATA$,6,13)) ! 1.3
9816: 5fe3:                      STKIF.LOCATION$ = LEFT$(STKBF.DATA$,5)            ! 1.3
9817: 600a:                      RC% = READ.STKIF
9818: 601e:                      IF RC% = 0 THEN BEGIN
9819: 6030:                         GOSUB ADD.TO.RECOUNT
9820: 6045:                      ENDIF ELSE BEGIN
9821: 604d:                         GOSUB ADD.TO.STKMF
9822: 605f:                         BATCH.ITEMS = BATCH.ITEMS + 1
9823: 6078:                         STKIF.BUSINESS.CENTRE$ = "X"
9824: 608f:                         STKIF.GROUP.SEQUENCE$ = PACK$("000000")
9825: 60ab:                         STKIF.QUANTITY$ = PACK$(MID$(STKBF.DATA$,19,6)) ! 1.1 ! 1.3
9826: 60d7:                         STKIF.DESCRIPTION$ = "UNKNOWN ITEM            "
9827: 60ee:                         STKIF.STOCKTAKER.NUM$ = PACK$(STOCKTAKER$)
9828: 610e:                         STKIF.STKMF.RECORD.NUM% = STKMF.RECORD.NUM% - 1
9829: 612b:                         RC% = WRITE.STKIF
9830: 613f:                         IF RC% <> 0 THEN BEGIN
9831: 6151:                             CURR.SESS.NUM% = STKIF.SESS.NUM%
9832: 6163:                             GOTO WRITE.ERROR
9833: 616e:                         ENDIF
9834: 6176:                      ENDIF
9835: 6180: 
9836: 6180:                   ENDIF ELSE BEGIN
9837: 6188:                      ITEM.CODE$ = UNPACK$(IRF.BOOTS.CODE$)
9838: 61a9:                      CURRENT.CODE = 1
9839: 61b6:                   ENDIF
9840: 61be:                ENDIF
9841: 61c6:                ! Could have a Boots code by here
9842: 61c6:                IF CURRENT.CODE = 1 THEN BEGIN
9843: 61d8:                   IF LEN(ITEM.CODE$) = 6 THEN BEGIN
9844: 61f3:                      SB.BOOTS.ITEM$ = ITEM.CODE$
9845: 620c:                      GOSUB SB.CALC.BOOTS.CHECK.DIGIT
9846: 621e:                      ITEM.CODE$ = SB.BOOTS.CODE$
9847: 6237:                   ENDIF
9848: 623f:                   IF LEN(ITEM.CODE$) = 7 THEN ITEM.CODE$ = "0" + ITEM.CODE$
9849: 6272:                   STKIF.ITEM.CODE$ = PACK$("000000" + ITEM.CODE$)
9850: 629e:                   STKIF.LOCATION$ = LEFT$(STKBF.DATA$,5)                ! 1.3
9851: 62c5: 
9852: 62c5:                   RC% = READ.STKIF
9853: 62d9:                   IF RC% = 0 THEN BEGIN
9854: 62ee:                      GOSUB ADD.TO.RECOUNT
9855: 6300: 
9856: 6300:                      STKTF.BOOTS.CODE$ = PACK$(ITEM.CODE$)
9857: 6320:                      RC% = READ.STKTF
9858: 6334:                      IF RC% = 0 THEN BEGIN
9859: 6349:                          QUANTITY = VAL(UNPACK$(STKTF.QUANTITY$)) +     \
9860: 63e8:                             VAL(UNPACK$(STKRC.FINAL.QUANTITY$)) -       \
9861: 63e8:                             VAL(UNPACK$(STKRC.INITIAL.QUANTITY$))
9862: 63e8:                          STKTF.QUANTITY$ = PACK$(FN.ZERO.PL(STR$(QUANTITY),6))
9863: 641e:                          RC% = WRITE.STKTF
9864: 6432:                          IF RC% <> 0 THEN BEGIN
9865: 6444:                             CURR.SESS.NUM% = STKTF.SESS.NUM%
9866: 6456:                             GOTO WRITE.ERROR
9867: 6461:                          ENDIF
9868: 6469:                      ENDIF
9869: 6474: 
9870: 6474:                   ENDIF ELSE BEGIN
9871: 647c:                      IDF.BOOTS.CODE$ = PACK$(ITEM.CODE$)
9872: 649c:                      RC% = READ.IDF
9873: 64b0: 
9874: 64b0:                      IF RC% <> 0 THEN BEGIN
9875: 64c5:                          STKEX.ITEM.CODE$ = STKIF.ITEM.CODE$
9876: 64e3:                          STKEX.QUANTITY$ = PACK$(MID$(STKBF.DATA$,19,6)) ! 1.1 ! 1.3
9877: 650f:                          STKEX.LOCATION$ = LEFT$(STKBF.DATA$,5)          ! 1.3
9878: 6536:                          STKEX.STOCKTAKER.NUM$ = PACK$(STOCKTAKER$)
9879: 6556:                          STKEX.REASON.CODE$ = "I"
9880: 656d:                          RC% = WRITE.STKEX
9881: 6581:                          IF RC% <> 0 THEN BEGIN
9882: 6593:                             CURR.SESS.NUM% = STKEX.SESS.NUM%
9883: 65a5:                             GOTO WRITE.ERROR
9884: 65b0:                          ENDIF
9885: 65b8:                          STKEX.RECORD.NUM% = STKEX.RECORD.NUM% + 1
9886: 65d1: 
9887: 65d1:                          GOSUB ADD.TO.STKMF
9888: 65e3:                          BATCH.ITEMS = BATCH.ITEMS + 1
9889: 65fc:                          STKIF.BUSINESS.CENTRE$ = "X"
9890: 6613:                          STKIF.GROUP.SEQUENCE$ = PACK$("000000")
9891: 662f:                          STKIF.QUANTITY$ = PACK$(MID$(STKBF.DATA$,19,6)) ! 1.1 ! 1.3
9892: 665b:                          STKIF.DESCRIPTION$ = "UNKNOWN ITEM            "
9893: 6672:                          STKIF.STOCKTAKER.NUM$ = PACK$(STOCKTAKER$)
9894: 6692:                          STKIF.STKMF.RECORD.NUM% = STKMF.RECORD.NUM% - 1
9895: 66af:                          RC% = WRITE.STKIF
9896: 66c3:                          IF RC% <> 0 THEN BEGIN
9897: 66d5:                             CURR.SESS.NUM% = STKIF.SESS.NUM%
9898: 66e7:                             GOTO WRITE.ERROR
9899: 66f2:                          ENDIF
9900: 66fd: 
9901: 66fd:                      ENDIF ELSE BEGIN
9902: 6705: 
9903: 6705:                         IF ALL.PRODUCTS = 1 THEN GOTO ITEM.IN.SCOPE
9904: 671a: 
9905: 671a:                         FOR R% = 1 TO BC%
9906: 672a:                           IF IDF.BSNS.CNTR$ = BUSINESS.CENTRES$(R%) THEN BEGIN
9907: 675d:                             GOTO ITEM.IN.SCOPE
9908: 6768:                           ENDIF
9909: 6770:                         NEXT R%
9910: 678c: 
9911: 678c:                         FOR R% = 1 TO CG%
9912: 679c:                           IF LEFT$(UNPACK$(IDF.PRODUCT.GRP$),2) = CONCEPT.GROUPS$(R%) \
9913: 67f6:                              THEN BEGIN
9914: 67f6:                                GOTO ITEM.IN.SCOPE
9915: 6801:                           ENDIF
9916: 6809:                         NEXT R%
9917: 6828: 
9918: 6828:                         FOR R% = 1 TO PG%
9919: 6838:                           IF UNPACK$(IDF.PRODUCT.GRP$) = PRODUCT.GROUPS$(R%) THEN BEGIN
9920: 687e:                              GOTO ITEM.IN.SCOPE
9921: 6889:                           ENDIF
9922: 6891:                         NEXT R%
9923: 68ad: 
9924: 68ad:                         ! Lookup item on XGCF                              !1.4
9925: 68ad:                         XGCF.BSNS.CNTR$ = IDF.BSNS.CNTR$                   !1.4
9926: 68cb:                         RC% = READ.XGCF                                    !1.4
9927: 68df:                         IF RC% <> 0 THEN BEGIN                             !1.4
9928: 68f1:                            ! Error occurred                                !1.4
9929: 68f1:                            CURR.SESS.NUM% = XGCF.SESS.NUM%                 !1.4
9930: 6903:                            GOSUB SB.FILE.READ.ERROR                        !1.4
9931: 6918:                         ENDIF ELSE BEGIN                                   !1.4
9932: 6920:                            ! Record on XGCF, so treat as group code        !1.4
9933: 6920:                            ITEM.CODE$ = RIGHT$(UNPACK$(XGCF.BAR.CODE$), 14)!1.4
9934: 6953:                            ! Poke group code back into STKBF record to     !1.4
9935: 6953:                            ! force it to be written to the STKMF           !1.4
9936: 6953:                            STKBF.DATA$ = LEFT$(STKBF.DATA$, 5) +           \1.4
9937: 6a13:                                          RIGHT$(ITEM.CODE$, 13) +          \1.4
9938: 6a13:                                          MID$(STKBF.DATA$, 19, 6) +        \1.4
9939: 6a13:                                          RIGHT$(UNPACK$(IRF.SALEPRIC$), 6) + \1.4
9940: 6a13:                                          RIGHT$(STKBF.DATA$,               \1.4
9941: 6a13:                                                 LEN(STKBF.DATA$)-30)       !1.4
9942: 6a13:                            GOSUB PROCESS.GROUP.CODE                        !1.4
9943: 6a25:                            GOTO ITEM.PROCESSED                             !1.4
9944: 6a30:                         ENDIF                                              !1.4
9945: 6a38: 
9946: 6a38:                         ! Not in scope, write to exception log
9947: 6a38:                         STKEX.ITEM.CODE$ = STKIF.ITEM.CODE$
9948: 6a56:                         STKEX.QUANTITY$ = PACK$(MID$(STKBF.DATA$,19,6)) ! 1.1 ! 1.3
9949: 6a82:                         STKEX.LOCATION$ = LEFT$(STKBF.DATA$,5)         ! 1.3
9950: 6aa9:                         STKEX.STOCKTAKER.NUM$ = PACK$(STOCKTAKER$)
9951: 6ac9:                         STKEX.REASON.CODE$ = "S"
9952: 6ae0:                         RC% = WRITE.STKEX
9953: 6af4:                         IF RC% <> 0 THEN BEGIN
9954: 6b06:                             CURR.SESS.NUM% = STKEX.SESS.NUM%
9955: 6b18:                             GOTO WRITE.ERROR
9956: 6b23:                         ENDIF
9957: 6b2b:                         STKEX.RECORD.NUM% = STKEX.RECORD.NUM% + 1
9958: 6b44:                         GOTO ITEM.PROCESSED
9959: 6b4f: 
9960: 6b4f: ITEM.IN.SCOPE:
9961: 6b5f: 
9962: 6b5f:                         GOSUB ADD.TO.STKMF
9963: 6b71:                         BATCH.ITEMS = BATCH.ITEMS + 1
9964: 6b8a:                         STKIF.BUSINESS.CENTRE$ = IDF.BSNS.CNTR$
9965: 6ba8:                         STKIF.GROUP.SEQUENCE$ = IDF.PRODUCT.GRP$
9966: 6bc6:                         STKIF.QUANTITY$ = PACK$(MID$(STKBF.DATA$,19,6)) ! 1.1 ! 1.3
9967: 6bf2:                         STKIF.DESCRIPTION$ = IDF.STNDRD.DESC$
9968: 6c10:                         STKIF.STOCKTAKER.NUM$ = PACK$(STOCKTAKER$)
9969: 6c30:                         STKIF.STKMF.RECORD.NUM% = STKMF.RECORD.NUM% - 1
9970: 6c4d:                         RC% = WRITE.STKIF
9971: 6c61:                             IF RC% <> 0 THEN BEGIN
9972: 6c73:                                CURR.SESS.NUM% = STKIF.SESS.NUM%
9973: 6c85:                                GOTO WRITE.ERROR
9974: 6c90:                             ENDIF
9975: 6c98:                         IF (IDF.BIT.FLAGS.2% AND 00001000b) <> 0 THEN BEGIN
9976: 6cb0: 
9977: 6cb0:                             STKTF.BOOTS.CODE$ = IDF.BOOTS.CODE$
9978: 6cce:                             RC% = READ.STKTF
9979: 6ce2:                             IF RC% = 0 THEN BEGIN
9980: 6cf7:                                QUANTITY = VAL(UNPACK$(STKTF.QUANTITY$)) +  \
9981: 6d66:                                   VAL(UNPACK$(STKIF.QUANTITY$))
9982: 6d66:                                STKTF.QUANTITY$ = PACK$(FN.ZERO.PL(STR$(QUANTITY),6))
9983: 6d9c:                                RC% = WRITE.STKTF
9984: 6db0:                                IF RC% <> 0 THEN BEGIN
9985: 6dc2:                                   CURR.SESS.NUM% = STKTF.SESS.NUM%
9986: 6dd4:                                   GOTO WRITE.ERROR
9987: 6ddf:                                ENDIF
9988: 6dea:                             ENDIF ELSE BEGIN
9989: 6df2:                                STKTF.QUANTITY$ = STKIF.QUANTITY$
9990: 6e10:                                STKTF.BUSINESS.CENTRE$ = STKIF.BUSINESS.CENTRE$
9991: 6e2e:                                STKTF.GROUP.SEQUENCE$ = STKIF.GROUP.SEQUENCE$
9992: 6e4c:                                RC% = WRITE.STKTF
9993: 6e60:                                IF RC% <> 0 THEN BEGIN
9994: 6e72:                                   CURR.SESS.NUM% = STKTF.SESS.NUM%
9995: 6e84:                                   GOTO WRITE.ERROR
9996: 6e8f:                                ENDIF
9997: 6e97:                             ENDIF
9998: 6ea2:                         ENDIF ELSE BEGIN
9999: 6eaa:                             STKEX.ITEM.CODE$ = PACK$("000000") + IDF.BOOTS.CODE$
10000: 6edf:                             STKEX.QUANTITY$ = PACK$(MID$(STKBF.DATA$,19,6)) ! 1.1 ! 1.3
10001: 6f0b:                             STKEX.LOCATION$ = LEFT$(STKBF.DATA$,5)      ! 1.3
10002: 6f32:                             STKEX.STOCKTAKER.NUM$ = PACK$(STOCKTAKER$)
10003: 6f52:                             STKEX.REASON.CODE$ = "N"
10004: 6f69:                             RC% = WRITE.STKEX
10005: 6f7d:                             IF RC% <> 0 THEN BEGIN
10006: 6f8f:                                CURR.SESS.NUM% = STKEX.SESS.NUM%
10007: 6fa1:                                GOTO WRITE.ERROR
10008: 6fac:                             ENDIF
10009: 6fb4:                             STKEX.RECORD.NUM% = STKEX.RECORD.NUM% + 1
10010: 6fcd:                         ENDIF
10011: 6fd5:                      ENDIF
10012: 6fdd:                   ENDIF
10013: 6fe5:                ENDIF
10014: 6fed:             ENDIF
10015: 6ff5: 
10016: 6ff5:        ENDIF
10017: 6ffd: 
10018: 6ffd: ITEM.PROCESSED:
10019: 700d: 
10020: 700d: RETURN
10021: 701d: 
10022: 701d: 
10023: 701d: PROCESS.GROUP.CODE:                                                        ! CSW
10024: 702d: 
10025: 702d:    ! Group code
10026: 702d:    STKDC.DUMP.CODE$ = PACK$(RIGHT$("00000000000000"+ITEM.CODE$,14))
10027: 706a:    STKDC.QUANTITY$ = PACK$(MID$(STKBF.DATA$,19,6))    ! 1.1 ! 1.3
10028: 7096:    STKDC.PRICE$ = PACK$(MID$(STKBF.DATA$,25,6))       ! 1.1 ! 1.3
10029: 70c2:    STKDC.LOCATION$ = LEFT$(STKBF.DATA$,5)             ! 1.3
10030: 70e9:    STKDC.STOCKTAKER.NUM$ = PACK$(STOCKTAKER$)
10031: 7109:    RC% = WRITE.STKDC
10032: 711d:    IF RC% <> 0 THEN BEGIN
10033: 712f:       CURR.SESS.NUM% = STKDC.SESS.NUM%
10034: 7141:       GOTO WRITE.ERROR
10035: 714c:    ENDIF
10036: 7154:    STKDC.RECORD.NUM% = STKDC.RECORD.NUM% + 1
10037: 716d: 
10038: 716d:    GOSUB ADD.TO.STKMF
10039: 717f:    BATCH.ITEMS = BATCH.ITEMS + 1
10040: 7198: 
10041: 7198: RETURN                                                                     ! CSW
10042: 71a8: 
10043: 71a8: 
10044: 71a8: \******************************************************************************
10045: 71a8: \***   ADD TO RECOUNT
10046: 71a8: \***
10047: 71a8: \***   Format data
10048: 71a8: \***   Write to STKRC
10049: 71a8: \***   Update record number
10050: 71a8: \***   Update STKIF
10051: 71a8: \***   Update STKMF
10052: 71a8: \***
10053: 71a8: \******************************************************************************
10054: 71a8: ADD.TO.RECOUNT:
10055: 71b8: 
10056: 71b8:        !******************************************************************!1.3
10057: 71b8:        !* For first time we count a location, we add recounts to current  !1.3
10058: 71b8:        !* totals.                                                         !1.3
10059: 71b8:        !******************************************************************!1.3
10060: 71b8:        IF CUR.LOC.COUNTER% = 0 THEN BEGIN
10061: 71d6:           !***************************************************************!1.3
10062: 71d6:           !* STKBF.QUANTITY = STKBF.QUANTITY + STKIF.QUANTITY.            !1.3
10063: 71d6:           !* where STKBF.QUANTITY = MID$(STKBF.DATA$,19,6)                !1.3
10064: 71d6:           !*   and STKIF.QUANTITY is a packed decimal string.             !1.3
10065: 71d6:           !***************************************************************!1.3
10066: 71d6:           STKBF.DATA$=LEFT$(STKBF.DATA$,18)   \                           !1.3
10067: 72c2:                       +                       \                           !1.3
10068: 72c2:                       RIGHT$("000000"+STR$(VAL(MID$(STKBF.DATA$,19,6)) + \!1.3
10069: 72c2:                                            VAL(UNPACK$(STKIF.QUANTITY$)) \!1.3
10070: 72c2:                                           ), 6)                          \!1.3
10071: 72c2:                       +                       \                           !1.3
10072: 72c2:                       MID$(STKBF.DATA$,25,LEN(STKBF.DATA$)-25)            !1.3
10073: 72c2:        ENDIF                                                              !1.3
10074: 72ca: 
10075: 72ca:        STKRC.LOC.CNT% = CUR.LOC.COUNTER% + 1                              !1.3
10076: 72e6:        STKRC.ITEM.CODE$ = STKIF.ITEM.CODE$
10077: 7304:        STKRC.ITEM.DESCRIPTION$ = STKIF.DESCRIPTION$
10078: 7322:        STKRC.LOCATION$ = LEFT$(STKBF.DATA$,5)                             !1.3
10079: 7349:        STKRC.INITIAL.QUANTITY$ = STKIF.QUANTITY$
10080: 7367:        STKRC.INITIAL.STOCKTAKER$ = STKIF.STOCKTAKER.NUM$
10081: 7385:        STKRC.FINAL.QUANTITY$ = PACK$(MID$(STKBF.DATA$,19,6))   ! 1.1 ! 1.3
10082: 73b1:        STKRC.FINAL.STOCKTAKER$ = PACK$(STOCKTAKER$)
10083: 73d1:        RC% = WRITE.STKRC
10084: 73e5:        IF RC% <> 0 THEN BEGIN
10085: 73f7:            CURR.SESS.NUM% = STKRC.SESS.NUM%
10086: 7409:            GOTO WRITE.ERROR
10087: 7414:        ENDIF
10088: 741c:        STKRC.RECORD.NUM% = STKRC.RECORD.NUM% + 1
10089: 7435: 
10090: 7435:        STKIF.QUANTITY$ = PACK$(MID$(STKBF.DATA$,19,6))         ! 1.1 ! 1.3
10091: 7461:        STKIF.STOCKTAKER.NUM$ = PACK$(STOCKTAKER$)
10092: 7481:        RC% = WRITE.STKIF
10093: 7495:        IF RC% <> 0 THEN BEGIN
10094: 74a7:            CURR.SESS.NUM% = STKIF.SESS.NUM%
10095: 74b9:            GOTO WRITE.ERROR
10096: 74c4:        ENDIF
10097: 74cc: 
10098: 74cc:        SAVED.RECORD.NUM% = STKMF.RECORD.NUM%
10099: 74e3:        STKMF.RECORD.NUM% = STKIF.STKMF.RECORD.NUM%
10100: 74fc:        RC% = READ.STKMF
10101: 7510:        IF RC% <> 0 THEN BEGIN
10102: 7522:            CURR.SESS.NUM% = STKMF.SESS.NUM%
10103: 7534:            GOTO READ.ERROR
10104: 753f:        ENDIF
10105: 7547: 
10106: 7547:        GOSUB ADD.TO.STKMF
10107: 7559:        STKMF.RECORD.NUM% = SAVED.RECORD.NUM%
10108: 7570: 
10109: 7570: RETURN
10110: 7580: 
10111: 7580: \******************************************************************************
10112: 7580: \***   ADD TO STKMF
10113: 7580: \***
10114: 7580: \***   Format data
10115: 7580: \***   Write to STKMF
10116: 7580: \***   Update record number
10117: 7580: \***
10118: 7580: \******************************************************************************
10119: 7580: ADD.TO.STKMF:
10120: 7590: 
10121: 7590:             STKMF.DATA$ = LEFT$(STKBF.DATA$,1) +                  \
10122: 760b:                MID$(STKBF.DATA$,6,13) +                           \ 1.3
10123: 760b:                MID$(STKBF.DATA$,19,12) +                          \ 1.1 1.3
10124: 760b:                CR$
10125: 760b:             RC% = WRITE.STKMF
10126: 761f:             IF RC% <> 0 THEN BEGIN
10127: 7631:                CURR.SESS.NUM% = STKMF.SESS.NUM%
10128: 7643:                GOTO WRITE.ERROR
10129: 764e:             ENDIF
10130: 7656:             STKMF.RECORD.NUM% = STKMF.RECORD.NUM% + 1
10131: 766f: 
10132: 766f: RETURN
10133: 767f: 
10134: 767f: \******************************************************************************
10135: 767f: \***   CHECK.GROUP.CODE:
10136: 767f: \***
10137: 767f: \***   Set code type = barcode
10138: 767f: \***   Set Item Code
10139: 767f: \***   If Boots Code Then
10140: 767f: \***      If 1st digit = 0 Then Group Code
10141: 767f: \***   Else
10142: 767f: \***      Remove leading zero's
10143: 767f: \***      If length = 13 Then
10144: 767f: \***         If 1st digit = 2 Then Group Code
10145: 767f: \***      If length = 12 Then
10146: 767f: \***         If 1st digit = 2 Then Group Code
10147: 767f: \***      If length = 8 Then
10148: 767f: \***         If 1st digit = 2 Then Group Code
10149: 767f: \***      If length = 6 Then
10150: 767f: \***         Set Group Code
10151: 767f: \***
10152: 767f: \******************************************************************************
10153: 767f: CHECK.GROUP.CODE:
10154: 768f: 
10155: 768f:        ITEM.CODE$ = MID$(STKBF.DATA$,6,13)                             ! 1.3
10156: 76b4:        CURRENT.CODE = 0
10157: 76c1:        GROUP.CODE = 0
10158: 76ce:        IF LEFT$(ITEM.CODE$,6) = "      " THEN BEGIN
10159: 7700:           ITEM.CODE$ = RIGHT$(ITEM.CODE$,7)
10160: 7720:           CURRENT.CODE = 1
10161: 772d:           IF LEFT$(ITEM.CODE$,1) = "0" THEN GROUP.CODE = 1
10162: 7767:        ENDIF ELSE BEGIN
10163: 776f:           ITEM.CODE$ = STR$(VAL(ITEM.CODE$))
10164: 7797:           CODE.LENGTH = LEN(ITEM.CODE$)
10165: 77b1:           IF CODE.LENGTH = 13 OR CODE.LENGTH = 12 OR CODE.LENGTH = 8 THEN BEGIN
10166: 77da:              IF LEFT$(ITEM.CODE$,1)="2" THEN GROUP.CODE = 1
10167: 7813:           ENDIF ELSE BEGIN
10168: 781b:              IF CODE.LENGTH = 6 THEN GROUP.CODE = 1
10169: 782f:           ENDIF
10170: 7837:        ENDIF
10171: 783f: 
10172: 783f: 
10173: 783f: RETURN
10174: 784f: 
10175: 784f: 
10176: 784f: \******************************************************************************
10177: 784f: \***
10178: 784f: \***   PROCESS.TRAILER:
10179: 784f: \***
10180: 784f: \***   If header expected Then
10181: 784f: \***           Write record to Recount Audit Trail
10182: 784f: \***   Else
10183: 784f: \***           Write record to Mainframe Transmission File
10184: 784f: \***           Check trailer item count
10185: 784f: \***           If mismatch Then
10186: 784f: \***                   Write record to Recount Audit Trail
10187: 784f: \***
10188: 784f: \***   RETURN
10189: 784f: \***
10190: 784f: \******************************************************************************
10191: 784f: PROCESS.TRAILER:
10192: 785f: 
10193: 785f:        IF HEADER.EXPECTED = 1 THEN BEGIN
10194: 7871:             STKRC.ITEM.CODE$ = PACK$("00000000000000")
10195: 788d:             STKRC.ITEM.DESCRIPTION$ = "Unexpected Trailer      "
10196: 78a4:             STKRC.LOCATION$ = "X0000"                                  ! 1.3
10197: 78bb:             STKRC.INITIAL.QUANTITY$ = PACK$("000000")
10198: 78d7:             STKRC.INITIAL.STOCKTAKER$ = PACK$("0000")
10199: 78f3:             STKRC.FINAL.QUANTITY$ = PACK$("000000")
10200: 790f:             STKRC.FINAL.STOCKTAKER$ = PACK$("0000")
10201: 792b:             RC% = WRITE.STKRC
10202: 793f:             IF RC% <> 0 THEN BEGIN
10203: 7951:                CURR.SESS.NUM% = STKRC.SESS.NUM%
10204: 7963:                GOTO WRITE.ERROR
10205: 796e:             ENDIF
10206: 7976:             STKRC.RECORD.NUM% = STKRC.RECORD.NUM% + 1
10207: 7992:        ENDIF ELSE BEGIN
10208: 799a:             !*************************************************************!1.3
10209: 799a:             !* Trailer reached, so signfy location has changed.           !1.3
10210: 799a:             !*************************************************************!1.3
10211: 799a:             NEW.LOC$ = "     "                                            !1.3
10212: 79af:             GOSUB PROCESS.LOCATION.CHANGE                                 !1.3
10213: 79c1: 
10214: 79c1:             IF ITEM.COUNT <> VAL(LEFT$(STKBF.DATA$,6)) THEN BEGIN
10215: 7a10:                STKRC.ITEM.CODE$ = PACK$("00000000000000")
10216: 7a2c:                STKRC.ITEM.DESCRIPTION$ = "Record Count Mismatch   "
10217: 7a43:                STKRC.LOCATION$ = "X0000"                               ! 1.3
10218: 7a5a:                STKRC.INITIAL.QUANTITY$ = PACK$(FN.ZERO.PL(STR$(ITEM.COUNT),6))
10219: 7a90:                STKRC.INITIAL.STOCKTAKER$ = PACK$(STOCKTAKER$)
10220: 7ab0:                STKRC.FINAL.QUANTITY$ = PACK$(LEFT$(STKBF.DATA$,6))
10221: 7adc:                STKRC.FINAL.STOCKTAKER$ = PACK$("0000")
10222: 7af8:                RC% = WRITE.STKRC
10223: 7b0c:                IF RC% <> 0 THEN BEGIN
10224: 7b1e:                   CURR.SESS.NUM% = STKRC.SESS.NUM%
10225: 7b30:                   GOTO WRITE.ERROR
10226: 7b3b:                ENDIF
10227: 7b43:                STKRC.RECORD.NUM% = STKRC.RECORD.NUM% + 1
10228: 7b5c:             ENDIF
10229: 7b64:             STKMF.DATA$ = RIGHT$("000000" + STR$(BATCH.ITEMS),6) +    \
10230: 7bc6:                "                    " + CR$
10231: 7bc6:             RC% = WRITE.STKMF
10232: 7bda:             IF RC% <> 0 THEN BEGIN
10233: 7bec:                CURR.SESS.NUM% = STKMF.SESS.NUM%
10234: 7bfe:                GOTO WRITE.ERROR
10235: 7c09:             ENDIF
10236: 7c11:             STKMF.RECORD.NUM% = STKMF.RECORD.NUM% + 1
10237: 7c2a:             HEADER.EXPECTED = 1
10238: 7c37:        ENDIF
10239: 7c3f: 
10240: 7c3f: RETURN
10241: 7c4f: 
10242: 7c4f: \*************************************************************************!1.3
10243: 7c4f: \***                                                                      !1.3
10244: 7c4f: \*** PROCESS.LOCATION.CHANGE:                                             !1.3
10245: 7c4f: \***                                                                      !1.3
10246: 7c4f: \***    increment number of times location has been counted in LOCCNT     !1.3
10247: 7c4f: \***    read in the value for the next location from LOCCNT               !1.3
10248: 7c4f: \***    set next location as current location.                            !1.3
10249: 7c4f: \***                                                                      !1.3
10250: 7c4f: \*** RETURN                                                               !1.3
10251: 7c4f: \***                                                                      !1.3
10252: 7c4f: \*************************************************************************!1.3
10253: 7c4f:                                                                           !1.3
10254: 7c4f: PROCESS.LOCATION.CHANGE:                                                  !1.3
10255: 7c5f:                                                                           !1.3
10256: 7c5f:    IF CUR.LOC$ <> "     " THEN BEGIN                                      !1.3
10257: 7c7d:       LOCCNT.RECORD.NUM% = GET.LOCCNT.RECNUM(CUR.LOC$)                    !1.3
10258: 7ca4:       RC% = READ.LOCCNT                                                   !1.3
10259: 7cb8:       IF RC% = 0 THEN BEGIN                                               !1.3
10260: 7cca:          CUR.LOC.COUNTER% = LOCCNT.LOCATION.COUNT% + 1                    !1.3
10261: 7ceb:          LOCCNT.LOCATION.COUNT% = CUR.LOC.COUNTER%                        !1.3
10262: 7d01:          RC% = WRITE.LOCCNT                                               !1.3
10263: 7d15:       ENDIF                                                               !1.3
10264: 7d1d:    ENDIF                                                                  !1.3
10265: 7d25:    CUR.LOC$ = NEW.LOC$                                                    !1.3
10266: 7d3e:    SXTCF.CUR.LOCATION$ = CUR.LOC$                                         !1.3
10267: 7d59:    LOCCNT.RECORD.NUM% = GET.LOCCNT.RECNUM(CUR.LOC$)                       !1.3
10268: 7d80:    IF LOCCNT.RECORD.NUM% > 0 THEN BEGIN                                   !1.3
10269: 7d9c:       RC% = READ.LOCCNT                                                   !1.3
10270: 7db0:       IF RC% = 0 THEN BEGIN                                               !1.3
10271: 7dc2:          CUR.LOC.COUNTER% = LOCCNT.LOCATION.COUNT%                        !1.3
10272: 7de1:       ENDIF                                                               !1.3
10273: 7de9:    ENDIF                                                                  !1.3
10274: 7df1:                                                                           !1.3
10275: 7df1: RETURN                                                                    !1.3
10276: 7e01: 
10277: 7e01: 
10278: 7e01: \******************************************************************************
10279: 7e01: \***
10280: 7e01: \***   DETERMINE.START.TYPE:
10281: 7e01: \***
10282: 7e01: \***      if the command tail is null then quit program and print a message
10283: 7e01: \***           saying "Program should not be started from command mode"
10284: 7e01: \***
10285: 7e01: \***   RETURN
10286: 7e01: \***
10287: 7e01: \******************************************************************************
10288: 7e01: 
10289: 7e01: DETERMINE.START.TYPE:
10290: 7e11: 
10291: 7e11:        IF COMMAND$ = "" THEN BEGIN
10292: 7e37:                PRINT "PSX01 should not be started from command mode."
10293: 7e48:                GOTO PROGRAM.EXIT
10294: 7e53:        ENDIF
10295: 7e5b: 
10296: 7e5b: RETURN
10297: 7e6b: 
10298: 7e6b: 
10299: 7e6b: 
10300: 7e6b: \******************************************************************************
10301: 7e6b: \******************************************************************************
10302: 7e6b: \***
10303: 7e6b: \***           G E N E R A L    R E T U R N S    R O U T I N E S
10304: 7e6b: \***
10305: 7e6b: \******************************************************************************
10306: 7e6b: \******************************************************************************
10307: 7e6b: 
10308: 7e6b: \******************************************************************************
10309: 7e6b: \***
10310: 7e6b: \***    CHECK.VALID.ITEM
10311: 7e6b: \***
10312: 7e6b: \***    This routine will check that the item code passed is valid
10313: 7e6b: \***    Check that the item code is found on the IDF
10314: 7e6b: \***    Checks that the item code is for a valid credit claim Business Centre
10315: 7e6b: \***    Check that the item code is found on the IRF
10316: 7e6b: \***    If the local price flag is set on the IRF then provided the read
10317: 7e6b: \***    of the local price file is successfull the item price will be the local
10318: 7e6b: \***    price else it will take the IRF.SALEPRICE
10319: 7e6b: \***    If the item is not found on the IDF, IRF or has an invalid credit claim BC then
10320: 7e6b: \***    the valid entry variable will be set to false
10321: 7e6b: \***
10322: 7e6b: \*****************************************************************************
10323: 7e6b: 
10324: 7e6b:    CHECK.VALID.ITEM:                                                     ! 1.16JAS
10325: 7e7b: 
10326: 7e7b:    VALID.ENTRY% = TRUE                                                  ! 1.16JAS
10327: 7e8d:    VALID.BC = FALSE                                                     ! 1.16JAS
10328: 7e9f: 
10329: 7e9f:    !Check item is a valid code
10330: 7e9f:    BOOTS.CODE$ = MID$(DATA.IN$, 11,7)                                   ! 1.16JAS
10331: 7ec4:    RC% = CHECK.BOOTS.CODE(BOOTS.CODE$)                                  ! 1.16JAS
10332: 7ee3:    IF F05.VALID.CODE$ = "Y" THEN BEGIN                                  ! 1.16JAS
10333: 7f04:       IDF.BOOTS.CODE$ = PACK$(RIGHT$("00000000" + BOOTS.CODE$,8))      ! 1.16JAS
10334: 7f41:       CURR.SESS.NUM% = IDF.SESS.NUM%                                    ! 1.16JAS
10335: 7f53:       RC% = READ.IDF                                                    ! 1.16JAS
10336: 7f67:       IF RC% <> 0 THEN BEGIN                                            ! 1.16JAS
10337: 7f7c:         IDF.BOOTS.CODE$ = PACK$(RIGHT$("00000000" + BOOTS.CODE$,8))    ! 1.16JAS
10338: 7fb9:         CCTMP.ITEM.PRICE$ = PACK$("000000")                             ! 1.16JAS
10339: 7fd5:         IDF.STNDRD.DESC$ = "+++ ITEM NOT ON FILE +++"                   ! 1.16JAS
10340: 7fec:         IDF.BSNS.CNTR$ = " "                                            ! 1.16JAS
10341: 8006: !JAS        VALID.ENTRY% = FALSE                                            ! 1.16JAS
10342: 8006: !JAS        CCREJ.REJECT.REASON$ = "3"                                      ! 1.18JAS
10343: 8006:       ENDIF ELSE BEGIN                                                  ! 1.16JAS
10344: 800e:         GOSUB CHECK.BUSINESS.CENTRE                                     ! 1.16JAS
10345: 8020:         IF VALID.BC THEN BEGIN                                          ! 1.16JAS
10346: 8032:             IRF.BAR.CODE$ = PACK$("0000000000") + IDF.FIRST.BAR.CODE$   ! 1.16JAS
10347: 8067:             CURR.SESS.NUM% = IRF.SESS.NUM%                              ! 1.16JAS
10348: 8079:             RC% = READ.IRF                                              ! 1.16JAS
10349: 808d:             IF RC% <> 0 THEN BEGIN                                      ! 1.16JAS
10350: 809f:                CCTMP.ITEM.PRICE$ = PACK$("000000")                      ! 1.16JAS
10351: 80bb:                IDF.STNDRD.DESC$ = "+++ ITEM NOT ON FILE +++"            ! 1.16JAS
10352: 80d2:                IDF.BSNS.CNTR$ = " "                                     ! 1.16JAS
10353: 80ec: !JAS               VALID.ENTRY% = FALSE                                     ! 1.16JAS
10354: 80ec: !JAS               CCREJ.REJECT.REASON$ = "3"                               ! 1.18JAS
10355: 80ec:             ENDIF ELSE BEGIN                                            ! 1.16JAS
10356: 80f4:                ! If local price item then try reading local file - if read not successfull
10357: 80f4:                ! then set item price to IRF.SALEPRICE
10358: 80f4:                IF (IRF.INDICAT3% AND 00100000B) = 00100000B THEN BEGIN  ! 1.16JAS
10359: 810c:                   GOSUB OPEN.LOCAL                                      ! 1.16JAS
10360: 811e:                   LOCAL.ITEM.CODE$ = IDF.BOOTS.CODE$                    ! 1.16JAS
10361: 813c:                   CURR.SESS.NUM% = LOCAL.SESS.NUM%                      ! 1.16JAS
10362: 814e:                   RC% = READ.LOCAL                                      ! 1.16JAS
10363: 8162:                   GOSUB CLOSE.LOCAL                                     ! 1.16JAS
10364: 8174:                   IF RC% = 0 THEN BEGIN                                 ! 1.16JAS
10365: 8186:                      CCTMP.ITEM.PRICE$ = RIGHT$(PACK$("000000") + LOCAL.H.O.PRICE$,3) ! 1.16JAS
10366: 81d3:                   ENDIF ELSE BEGIN                                      ! 1.16JAS
10367: 81db:                      CCTMP.ITEM.PRICE$ = RIGHT$(PACK$("000000") + IRF.SALEPRIC$,3)    ! 1.16JAS
10368: 8226:                   ENDIF                                                 ! 1.16JAS
10369: 8230:                ENDIF ELSE BEGIN                                         ! 1.16JAS
10370: 8238:                   CCTMP.ITEM.PRICE$ = RIGHT$(PACK$("000000") + IRF.SALEPRIC$,3)! 1.16JAS
10371: 8283:                ENDIF                                                    ! 1.16JAS
10372: 828b:             ENDIF                                                       ! 1.16JAS
10373: 8295:         ENDIF ELSE BEGIN                                                ! 1.16JAS
10374: 829d:             VALID.ENTRY% = FALSE                                        ! 1.16JAS
10375: 82af:         ENDIF                                                           ! 1.16JAS
10376: 82b7:       ENDIF                                                             ! 1.16JAS
10377: 82c1:    ENDIF ELSE BEGIN                                                     ! 1.16JAS
10378: 82c9:       IDF.STNDRD.DESC$ = "+++ ITEM NOT ON FILE +++"                     ! 1.16JAS
10379: 82e0:       IDF.BSNS.CNTR$ = " "                                              ! 1.16JAS
10380: 82f7: !JAS      VALID.ENTRY% = FALSE                                              ! 1.16JAS
10381: 82f7: !JAS      CCREJ.REJECT.REASON$ = "3"                                        ! 1.18JAS
10382: 82f7:    ENDIF                                                                ! 1.16JAS
10383: 82ff: 
10384: 82ff:    RETURN                                                               ! 1.16JAS
10385: 830f: 
10386: 830f: \******************************************************************************
10387: 830f: \***
10388: 830f: \***    CHECK.VALID.BARCODE
10389: 830f: \***
10390: 830f: \***    This routine will check that the bar code passed is valid
10391: 830f: \***    Check that the item code is found on the IRF
10392: 830f: \***    Using the IRF.BOOTS.CODE calculate the check digit
10393: 830f: \***    Using the IRF.BOOTS.CODE + check digit, check that the item code is found on the IDF
10394: 830f: \***    Checks that the item code is for a valid credit claim Business Centre
10395: 830f: \***    If the local price flag is set on the IRF then provided the read
10396: 830f: \***    of the local price file is successfull the item price will be the local
10397: 830f: \***    price else it will take the IRF.SALEPRICE
10398: 830f: \***    If the item is not found on the IDF, IRF or has an invalid credit claim BC then
10399: 830f: \***    the valid entry variable will be set to false
10400: 830f: \***
10401: 830f: \*****************************************************************************
10402: 830f: 
10403: 830f:    CHECK.VALID.BARCODE:                                                 ! 1.16JAS
10404: 831f: 
10405: 831f:    VALID.ENTRY% = TRUE                                                  ! 1.16JAS
10406: 8331:    VALID.BC     = FALSE                                                 ! 1.16JAS
10407: 8343: 
10408: 8343:    BOOTS.CODE$  = MID$(DATA.IN$, 6, 12)                                 ! 1.16JAS
10409: 8368: 
10410: 8368:    IRF.BAR.CODE$ = PACK$(RIGHT$(STRING$(22,"0") +         \             ! 1.16JAS
10411: 83b7:                                   BOOTS.CODE$, 22))                     ! 1.16JAS
10412: 83b7: 
10413: 83b7:    CURR.SESS.NUM% = IRF.SESS.NUM%                                       ! 1.16JAS
10414: 83c9:    RC% = READ.IRF                                                       ! 1.16JAS
10415: 83dd:    IF RC% <> 0 THEN BEGIN                                               ! 1.16JAS
10416: 83f2:        CCTMP.ITEM.PRICE$ = PACK$("000000")                              ! 1.16JAS
10417: 840e:        IDF.STNDRD.DESC$ = "+++ ITEM NOT ON FILE +++"                    ! 1.16JAS
10418: 8425:        IDF.BSNS.CNTR$ = " "                                             ! 1.16JAS
10419: 843c:        BOOTS.CODE$ = RIGHT$("00" + BOOTS.CODE$,8)                       ! 1.16JAS
10420: 8475: !JAS       VALID.ENTRY% = FALSE                                             ! 1.16JAS
10421: 8475: !JAS       CCREJ.REJECT.REASON$ = "3"                                       ! 1.18JAS
10422: 8475: 
10423: 8475:    ENDIF ELSE BEGIN                                                     ! 1.16JAS
10424: 847d:       BOOTS.CODE$ = UNPACK$(IRF.BOOTS.CODE$)                            ! 1.16JAS
10425: 849e:       RC% = CALC.BOOTS.CODE.CHECK.DIGIT(BOOTS.CODE$)                    ! 1.16JAS
10426: 84bd:       IF RC% <> 0 THEN GOTO PROGRAM.EXIT                                ! 1.16JAS
10427: 84d2:       IDF.BOOTS.CODE$ = PACK$(RIGHT$("00000000" +             \         ! 1.16JAS
10428: 851a:                                        BOOTS.CODE$ +          \         ! 1.16JAS
10429: 851a:                                        F18.CHECK.DIGIT$, 8))            ! 1.16JAS
10430: 851a:       BOOTS.CODE$ = UNPACK$(IDF.BOOTS.CODE$)                            ! 1.16JAS
10431: 853b:       CCTMP.ITEM.BARCODE.FLAG$ = "I"                                    ! 1.16JAS
10432: 8552:       CURR.SESS.NUM% = IDF.SESS.NUM%                                    ! 1.16JAS
10433: 8564:       RC% = READ.IDF                                                    ! 1.16JAS
10434: 8578:       IF RC% <> 0 THEN BEGIN                                            ! 1.16JAS
10435: 858d:          IDF.STNDRD.DESC$ = IRF.ITEMNAME$                               ! 1.16JAS
10436: 85ab:          IDF.BSNS.CNTR$ = " "                                           ! 1.16JAS
10437: 85c2:          CCTMP.ITEM.PRICE$ = RIGHT$(PACK$("000000") + IRF.SALEPRIC$,3)  ! 1.16JAS
10438: 8610: !         VALID.ENTRY% = FALSE                                           ! 1.16JAS
10439: 8610: !         CCREJ.REJECT.REASON$ = "3"                                     ! 1.18JAS
10440: 8610:       ENDIF ELSE BEGIN                                                  ! 1.16JAS
10441: 8618:         GOSUB CHECK.BUSINESS.CENTRE                                     ! 1.16JAS
10442: 862a:         IF VALID.BC THEN BEGIN                                          ! 1.16JAS
10443: 863c:            ! If local price item then try reading local file - if read not successfull
10444: 863c:            ! then set item price to IRF.SALEPRICE
10445: 863c:            IF (IRF.INDICAT3% AND 00100000B) = 00100000B THEN BEGIN      ! 1.16JAS
10446: 8654:               GOSUB OPEN.LOCAL                                          ! 1.16JAS
10447: 8666:               LOCAL.ITEM.CODE$ = IDF.BOOTS.CODE$                        ! 1.16JAS
10448: 8684:               CURR.SESS.NUM% = LOCAL.SESS.NUM%                          ! 1.16JAS
10449: 8696:               RC% = READ.LOCAL                                          ! 1.16JAS
10450: 86aa:               GOSUB CLOSE.LOCAL                                         ! 1.16JAS
10451: 86bc:               IF RC% = 0 THEN BEGIN                                     ! 1.16JAS
10452: 86ce:                  CCTMP.ITEM.PRICE$ = RIGHT$(PACK$("000000") + LOCAL.H.O.PRICE$,3) ! 1.16JAS
10453: 871b:               ENDIF ELSE BEGIN                                          ! 1.16JAS
10454: 8723:                  CCTMP.ITEM.PRICE$ = RIGHT$(PACK$("000000") + IRF.SALEPRIC$,3) ! 1.16JAS
10455: 876e:               ENDIF                                                     ! 1.16JAS
10456: 8778:            ENDIF ELSE BEGIN                                             ! 1.16JAS
10457: 8780:               CCTMP.ITEM.PRICE$ = RIGHT$(PACK$("000000") + IRF.SALEPRIC$,3) ! 1.16JAS
10458: 87cb:            ENDIF                                                        ! 1.16JAS
10459: 87d5:         ENDIF ELSE BEGIN                                                ! 1.16JAS
10460: 87dd:            VALID.ENTRY% = FALSE                                         ! 1.16JAS
10461: 87ef:         ENDIF                                                           ! 1.16JAS
10462: 87f7:       ENDIF                                                             ! 1.16JAS
10463: 87ff:    ENDIF                                                                ! 1.16JAS
10464: 8807: 
10465: 8807:    RETURN                                                               ! 1.16JAS
10466: 8817: 
10467: 8817: \******************************************************************************
10468: 8817: \***
10469: 8817: \***    ADD.ITEM.TO.REJECT.TABLE
10470: 8817: \***
10471: 8817: \***    Item has been rejected - either the business centre the item is in is not
10472: 8817: \***    allowed in credit claiming or the item code does not exist on both the
10473: 8817: \***    IRF and IDF (Items not on file has been commented out as these items
10474: 8817: \***    currently need to be passed through to credit claiming)
10475: 8817: \***    The following item information is added to the CCREJ file to be reported on
10476: 8817: \***    later in the program
10477: 8817: \***    The Item Barcode flag (either I = item code, B = Barcode)
10478: 8817: \***    The Item or Barcode
10479: 8817: \***    The Standard description (will be set to Item not on file - if not on IDF/IRF)
10480: 8817: \***    The Business Centre (will be set to blank if not on IDF/IRF)
10481: 8817: \***    The item qty claimed
10482: 8817: \***    Add record to rejection file for item being rejected from claim.
10483: 8817: \***
10484: 8817: \*****************************************************************************
10485: 8817: 
10486: 8817:    ADD.ITEM.TO.REJECT.TABLE:                                            ! 1.16JAS
10487: 8827: 
10488: 8827:   ! Add record to Credit Claim Rejection file
10489: 8827: 
10490: 8827:   CCREJ.RECORD$ = ""                                                    ! 1.18JAS
10491: 883e: 
10492: 883e:    IF LEFT$(DATE$,2) < "85" THEN BEGIN                                  ! 1.18JAS
10493: 8878:       CCREJ.RECORD$ = "20" + DATE$                                      ! 1.18JAS
10494: 8899:    ENDIF ELSE BEGIN                                                     ! 1.18JAS
10495: 88a1:       CCREJ.RECORD$ = "19" + DATE$                                      ! 1.18JAS
10496: 88c0:    ENDIF                                                                ! 1.18JAS
10497: 88c8: 
10498: 88c8:   ! If Other Credit Claiming transmission set claim business centre to item business centre
10499: 88c8: 
10500: 88c8:    IF LDT.RETURNS.TYPE$ NE "G" THEN BEGIN                               ! 1.18JAS
10501: 88e3:       CCTMP.BC.LETTER$ = IDF.BSNS.CNTR$                                 ! 1.18JAS
10502: 8901:    ENDIF                                                                ! 1.18JAS
10503: 8909: 
10504: 8909:    CCREJ.RECORD$ = CCREJ.RECORD$                 +         \            ! 1.18JAS
10505: 89ba:                    UNPACK$(CCTMP.RETURN.REASON$) +         \            ! 1.18JAS
10506: 89ba:                    CCTMP.BC.LETTER$              +         \            ! 1.18JAS
10507: 89ba:                    UNPACK$(CCTMP.UOD.NUM$)       +         \            ! 1.18JAS
10508: 89ba:                    CCTMP.ITEM.BARCODE.FLAG$      +         \            ! 1.18JAS
10509: 89ba:                    UNPACK$(CCTMP.ITEM.BARCODE$)  +         \            ! 1.18JAS
10510: 89ba:                    IDF.STNDRD.DESC$              +         \            ! 1.18JAS
10511: 89ba:                    IDF.BSNS.CNTR$                +         \            ! 1.18JAS
10512: 89ba:                    CCTMP.ITEM.QTY$               +         \            ! 1.18JAS
10513: 89ba:                    CCREJ.REJECT.REASON$                                 ! 1.18JAS
10514: 89ba: 
10515: 89ba:    CCREJ.RECORD$ = CCREJ.RECORD$ + CCREJ.ENDREC.MARKER$                 ! 1.18JAS
10516: 89e6: 
10517: 89e6:    IF CCREJ.OPEN.FLAG$ <> "Y" THEN BEGIN                                ! 1.18JAS
10518: 8a04:      IF END# CCREJ.SESS.NUM% THEN OPEN.ERROR                            ! 1.18JAS
10519: 8a20:      CURR.SESS.NUM% = CCREJ.SESS.NUM%                                   ! 1.18JAS
10520: 8a32:      OPEN CCREJ.FILE.NAME$ AS CCREJ.SESS.NUM% BUFFSIZE 512              \ 1.18JAS
10521: 8a5a:        READONLY APPEND                                                  ! 1.18JAS
10522: 8a5a:      CCREJ.OPEN.FLAG$ = "Y"                                             ! 1.18JAS
10523: 8a71:    ENDIF                                                                ! 1.18JAS
10524: 8a79: 
10525: 8a79:    CURR.SESS.NUM% = CCREJ.SESS.NUM%                                     ! 1.18JAS
10526: 8a8b:    IF WRITE.CCREJ THEN GOTO WRITE.ERROR                                 ! 1.18JAS
10527: 8a9f: 
10528: 8a9f:    CCREJ.RECS.PRESENT = TRUE                                            ! 1.18JAS
10529: 8ab5: 
10530: 8ab5:    RETURN                                                               ! 1.16JAS
10531: 8ac5: 
10532: 8ac5: \******************************************************************************
10533: 8ac5: \***
10534: 8ac5: \***   ADD.ITEM.TO.VALID.TABLE
10535: 8ac5: \***
10536: 8ac5: \***   Item qty is set to 1
10537: 8ac5: \***   The value of item qty * item price is checked
10538: 8ac5: \***   Set the item qty to equal the CCTMP.ITEM.QTY value
10539: 8ac5: \***   If the value is > £9,999.99 then if the item is the first item in the claim
10540: 8ac5: \***   the F14 table needs to be resized (number of items in claim + EXTRA.ITEMS)
10541: 8ac5: \***   If there were already entries in the F14.TABLE then size the temp table to
10542: 8ac5: \***   the number of records already held in the f14 table.  Load the F14 table into
10543: 8ac5: \***   the temp table.  Resize F14.TABLE to the number of items in the claim + EXTRA.ITEMS
10544: 8ac5: \***   Load the resized F14 table with data from the temp table.
10545: 8ac5: \***   For the item qty value add the entries to the F14.TABLE
10546: 8ac5: \***   Valid items are added to this table to be added to the STKMQ file later in the processing
10547: 8ac5: \***   If other credit claim transaction then a type 25 STKMQ record will be written later in
10548: 8ac5: \***   the processing, if Goods out transaction then a type 26 STKMQ record will be written
10549: 8ac5: \***   later in the processing
10550: 8ac5: \***   The following data is added to the table for each item from Other Credit Claim transmission
10551: 8ac5: \***   The items business centre
10552: 8ac5: \***   The item/barcode flag (I = item code, B = barcode)
10553: 8ac5: \***   The item/barcode
10554: 8ac5: \***   The item qty claimed
10555: 8ac5: \***   The item price
10556: 8ac5: \***   The following data is added to the table for each item from Goods Out transmission
10557: 8ac5: \***   The items business centre
10558: 8ac5: \***   The item/barcode flag (I = item code, B = barcode)
10559: 8ac5: \***   The item/barcode
10560: 8ac5: \***   The item qty claimed
10561: 8ac5: \***   The item updated
10562: 8ac5: \***
10563: 8ac5: \******************************************************************************
10564: 8ac5: 
10565: 8ac5:    ADD.ITEM.TO.VALID.TABLE:                                             ! 1.16JAS
10566: 8ad5: 
10567: 8ad5:    ITEM.QTY% = 1                                                        ! 1.17JAS
10568: 8aea: 
10569: 8aea:    IF CCTMP.ITEM.PRICE$ <> PACK$("000000") THEN BEGIN                        ! 1.18JAS
10570: 8b13:       IF (VAL(CCTMP.ITEM.QTY$) * VAL(UNPACK$(CCTMP.ITEM.PRICE$))) > 999999 THEN BEGIN   ! 1.17JAS
10571: 8b7a:          ITEM.QTY% = VAL(CCTMP.ITEM.QTY$)                                      ! 1.17JAS
10572: 8b9c:          EXTRA.ITEMS% = EXTRA.ITEMS% + (ITEM.QTY% - 1)                         ! 1.17JAS
10573: 8bc9:          CCTMP.ITEM.QTY$ = "0001"                                              ! 1.17JAS
10574: 8bde:          IF VALID.INDEX% > 0 THEN BEGIN                                        ! 1.17JAS
10575: 8bfa:             DIM TEMP.TABLE$(VALID.INDEX%)                                      ! 1.17JAS
10576: 8c29:             FOR I% = 1 TO VALID.INDEX%                                         ! 1.17JAS
10577: 8c39:               TEMP.TABLE$(I%) = F14.TABLE$(I%)                                ! 1.17JAS
10578: 8c70:             NEXT I%                                                            ! 1.17JAS
10579: 8c8c:             DIM F14.TABLE$(CCTMP.NUM.ITEMS.UPDATED% + (EXTRA.ITEMS%))          ! 1.17JAS
10580: 8ccd:             FOR I% = 1 TO VALID.INDEX%                                         ! 1.17JAS
10581: 8cdd:                F14.TABLE$(I%) = TEMP.TABLE$(I%)                                ! 1.17JAS
10582: 8d14:             NEXT I%                                                            ! 1.17JAS
10583: 8d32:          ENDIF ELSE BEGIN                                                      ! 1.17JAS
10584: 8d3a:             DIM F14.TABLE$(CCTMP.NUM.ITEMS.UPDATED% + (EXTRA.ITEMS%))          ! 1.17JAS
10585: 8d7b:          ENDIF                                                                 ! 1.17JAS
10586: 8d83:       ENDIF
10587: 8d8b:    ENDIF                                                                   ! 1.18JAS
10588: 8d93: 
10589: 8d93:    IF LDT.RETURNS.TYPE$ NE "G" THEN BEGIN                                  ! 1.18JAS
10590: 8db1:       FOR I% = 1 TO ITEM.QTY%                                              ! 1.17JAS
10591: 8dc2: 
10592: 8dc2:          VALID.INDEX% = VALID.INDEX% + 1                                   ! 1.16JAS
10593: 8ddb:          F14.TABLE$(VALID.INDEX%) = IDF.BSNS.CNTR$           +             \ 1.16JAS
10594: 8e37:                                     CCTMP.ITEM.BARCODE.FLAG$ +             \ 1.16JAS
10595: 8e37:                                     CCTMP.ITEM.BARCODE$      +             \ 1.16JAS
10596: 8e37:                                     CCTMP.ITEM.QTY$          +             \ 1.16JAS
10597: 8e37:                                     CCTMP.ITEM.PRICE$                      ! 1.16JAS
10598: 8e37: 
10599: 8e37:       NEXT I%                                                              ! 1.17JAS
10600: 8e59:    ENDIF ELSE BEGIN                                                        ! 1.18JAS
10601: 8e61:       FOR I% = 1 TO ITEM.QTY%                                              ! 1.18JAS
10602: 8e72: 
10603: 8e72:          VALID.INDEX% = VALID.INDEX% + 1                                   ! 1.18JAS
10604: 8e8b:          F14.TABLE$(VALID.INDEX%) = IDF.BSNS.CNTR$           +             \ 1.18JAS
10605: 8ee7:                                     CCTMP.ITEM.BARCODE.FLAG$ +             \ 1.18JAS
10606: 8ee7:                                     CCTMP.ITEM.BARCODE$      +             \ 1.18JAS
10607: 8ee7:                                     CCTMP.ITEM.QTY$          +             \ 1.18JAS
10608: 8ee7:                                     CCTMP.ITEM.UPDATED$                    ! 1.18JAS
10609: 8ee7: 
10610: 8ee7:       NEXT I%                                                              ! 1.18JAS
10611: 8f06: 
10612: 8f06:    ENDIF                                                                   ! 1.18JAS
10613: 8f0e: 
10614: 8f0e:    RETURN                                                                  ! 1.16JAS
10615: 8f1e: 
10616: 8f1e: \******************************************************************************
10617: 8f1e: \***
10618: 8f1e: \***    CHECK.BUSINESS.CENTRE
10619: 8f1e: \***
10620: 8f1e: \***    A list of valid Business Centres allowed for Credit claiming is held
10621: 8f1e: \***    on the EALSOPTS file (record 105)
10622: 8f1e: \***    The file was read earlier in the program and the business centres loaded
10623: 8f1e: \***    into the variable OTHER.CLAIM.VALID.BC
10624: 8f1e: \***    The items business centre is matched against the business centres contained
10625: 8f1e: \***    in the OTHER.CLAIM.VALID.BC variable
10626: 8f1e: \***    If a match is found that the VALID.BC is set to TRUE
10627: 8f1e: \***    If a match is not found then the reject reason is set to 2 (invalid
10628: 8f1e: \***    business centre)
10629: 8f1e: \***
10630: 8f1e: \*****************************************************************************
10631: 8f1e: 
10632: 8f1e:    CHECK.BUSINESS.CENTRE:                                               ! 1.16JAS
10633: 8f2e: 
10634: 8f2e:    IF MATCH(IDF.BSNS.CNTR$,OTHER.CLAIM.VALID.BC$,1) > 0 THEN BEGIN      ! 1.16JAS
10635: 8f58:       IF LDT.RETURNS.TYPE$ = "G" AND CREDIT.CLAIM.FLAG$ = "YY" THEN BEGIN  ! 1.18JAS
10636: 8fa5:          IF IDF.BSNS.CNTR$ = CCTMP.BC.LETTER$ THEN BEGIN                ! 1.18JAS
10637: 8fca:             VALID.BC = TRUE                                             ! 1.18JAS
10638: 8fde:          ENDIF ELSE BEGIN                                               ! 1.18JAS
10639: 8fe6:             CCREJ.REJECT.REASON$ = "2"                                  ! 1.18JAS
10640: 8ffd:          ENDIF                                                          ! 1.18JAS
10641: 9007:       ENDIF ELSE BEGIN                                                  ! 1.18JAS
10642: 900f:          VALID.BC = TRUE                                                ! 1.16JAS
10643: 9021:       ENDIF                                                             ! 1.18JAS
10644: 902b:    ENDIF ELSE BEGIN                                                     ! 1.16JAS 1.18JAS
10645: 9033:       CCREJ.REJECT.REASON$ = "1"                                        ! 1.18JAS
10646: 904a:    ENDIF                                                                ! 1.18JAS
10647: 9052: 
10648: 9052: 
10649: 9052: 
10650: 9052:    RETURN                                                               ! 1.16JAS
10651: 9062: 
10652: 9062: \******************************************************************************
10653: 9062: \***
10654: 9062: \***    UNLOAD.ACTIVE.TABLE
10655: 9062: \***
10656: 9062: \***    When writing out to the CCTMP file
10657: 9062: \***    If the transmission was from Other Credit Claiming need to split the claims
10658: 9062: \***    for the same reason but different business centres into separate claims.
10659: 9062: \***    This part of the code will create a type 25 transaction for each
10660: 9062: \***    different business centre.
10661: 9062: \***
10662: 9062: \***    The table contain valid items is sorted into business centre order.
10663: 9062: \***    Where the current business centre does not match the previous business
10664: 9062: \***    centre and the previous business centre was not set to ? (this would
10665: 9062: \***    indicate the first time in this processing) then using the data held
10666: 9062: \***    in the TEMP.RECORD (which contains the claim global data) write this out
10667: 9062: \***    as the start of the next type 25 record)
10668: 9062: \***    If the previous Business centre was not set to space then write out the
10669: 9062: \***    end of record data to the CCTMP.RECORD before adding the next TEMP data
10670: 9062: \***    to complete a type 25 transaction
10671: 9062: \***
10672: 9062: \***    Where the transmission was from Goods out then the data from the table
10673: 9062: \***    will be unloaded and a type 26 transaction created.
10674: 9062: \***    The number of items will be rewritten to the num.item.updated field and
10675: 9062: \***    total.qty.in.uod (this could have changed from the value passed by the
10676: 9062: \***    pdt due to the removal of rejected items or where the value of the item
10677: 9062: \***    * item prices exceeded £9,999.99 and the item had to be split into individual
10678: 9062: \***    items.
10679: 9062: \***
10680: 9062: \*****************************************************************************
10681: 9062: 
10682: 9062:    UNLOAD.ACTIVE.TABLE:                                                 ! 1.16JAS
10683: 9072: 
10684: 9072:    IF LDT.RETURNS.TYPE$ NE "G" THEN BEGIN                               ! 1.18JAS
10685: 9090: 
10686: 9090:       RC% EQ SORT.TABLE(VALID.INDEX%)                                   ! 1.16JAS
10687: 90ae: 
10688: 90ae:       PREV.BC$ = "?"                                                    ! 1.16JAS 1.18JAS
10689: 90c3:       ITEM.COUNT% = 0                                                   ! 1.16JAS
10690: 90d8: 
10691: 90d8:       FOR I% = 1 TO VALID.INDEX%                                        ! 1.16JAS
10692: 90e9:          IF PREV.BC$ NE LEFT$(F14.TABLE$(I%),1) THEN BEGIN              ! 1.16JAS
10693: 9128:             IF PREV.BC$ NE "?" THEN BEGIN                               ! 1.16JAS 1.18JAS
10694: 9146:                CCTMP.RECORD$ = LEFT$(CCTMP.RECORD$, 13)    +            \ 1.16JAS
10695: 91e0:                                RIGHT$("0000" + STR$(ITEM.COUNT%),4) +      \ 1.16JAS
10696: 91e0:                                RIGHT$(CCTMP.RECORD$,(LEN(CCTMP.RECORD$)-17)) ! 1.16JAS
10697: 91e0:                ITEM.COUNT% = 0                                          ! 1.16JAS
10698: 91f5:                CCTMP.RECORD$ = CCTMP.RECORD$ +                          \ 1.16JAS
10699: 922c:                                CCTMP.RECORD.DELIMITER$ +                \ 1.16JAS
10700: 922c:                                CCTMP.ENDREC.MARKER$                     ! 1.16JAS
10701: 922c:             CURR.SESS.NUM% = CCTMP.SESS.NUM%                            ! 1.16JAS
10702: 923e:             CURRENT.KEY$ = ""                                           ! 1.16JAS
10703: 9253:             IF WRITE.CCTMP THEN GOTO WRITE.ERROR                        ! 1.16JAS
10704: 9267:             CCTMP.RECORD$ = ""                                          ! 1.16JAS
10705: 927e:             ENDIF                                                       ! 1.16JAS
10706: 9286:             CCTMP.RECORD$ = LEFT$(TEMP.RECORD$,13)   +                  \ 1.16JAS
10707: 9317:                             RIGHT$("0000" + STR$(ITEM.COUNT%),4) +      \ 1.16JAS
10708: 9317:                             RIGHT$(TEMP.RECORD$,(LEN(TEMP.RECORD$)-17)) ! 1.16JAS
10709: 9317:          ENDIF                                                          ! 1.16JAS
10710: 931f:          ITEM.COUNT% = ITEM.COUNT% + 1                                  ! 1.16JAS
10711: 9338:          CCTMP.RECORD$ = CCTMP.RECORD$ +                                \ 1.16JAS
10712: 9379:                          RIGHT$(F14.TABLE$(I%),14)                      ! 1.16JAS
10713: 9379:          PREV.BC$ = LEFT$(F14.TABLE$(I%),1)                             ! 1.16JAS
10714: 93ac:       NEXT I%                                                           ! 1.16JAS
10715: 93cb: 
10716: 93cb:       CCTMP.RECORD$ = LEFT$(CCTMP.RECORD$, 13)    +                     \ 1.16JAS
10717: 9468:                       RIGHT$("0000" + STR$(ITEM.COUNT%),4) +            \ 1.16JAS
10718: 9468:                       RIGHT$(CCTMP.RECORD$,(LEN(CCTMP.RECORD$)-17))     ! 1.16JAS
10719: 9468: 
10720: 9468:    ENDIF ELSE BEGIN                                                     ! 1.18JAS
10721: 9470: 
10722: 9470:       ITEM.COUNT% = 0                                                   ! 1.18JAS
10723: 9485: 
10724: 9485:       FOR I% = 1 TO VALID.INDEX%                                        ! 1.18JAS
10725: 9495:          ITEM.COUNT% = ITEM.COUNT% + 1                                  ! 1.18JAS
10726: 94ae:          CCTMP.RECORD$ = CCTMP.RECORD$ +                                \ 1.18JAS
10727: 94ef:                          RIGHT$(F14.TABLE$(I%),12)                      ! 1.18JAS
10728: 94ef:       NEXT I%                                                           ! 1.18JAS
10729: 950b: 
10730: 950b:       CCTMP.RECORD$ = LEFT$(CCTMP.RECORD$, 21)    +                     \ 1.18JAS
10731: 95e5:                       RIGHT$("0000" + STR$(ITEM.COUNT%),4) +            \ 1.18JAS
10732: 95e5:                       RIGHT$("0000" + STR$(ITEM.COUNT%),4) +            \ 1.18JAS
10733: 95e5:                       RIGHT$(CCTMP.RECORD$,(LEN(CCTMP.RECORD$)-29))     ! 1.18JAS
10734: 95e5: 
10735: 95e5:    ENDIF                                                                ! 1.18JAS
10736: 95ed: 
10737: 95ed:    RETURN                                                               ! 1.16JAS
10738: 95fd: 
10739: 95fd: \/*****************************************************************************
10740: 95fd: \/****
10741: 95fd: \/****              OPEN.LOCAL
10742: 95fd: \/****
10743: 95fd: \/*****************************************************************************
10744: 95fd: 
10745: 95fd: OPEN.LOCAL:                                                          !1.16JAS
10746: 960d: 
10747: 960d:      CURR.SESS.NUM% = LOCAL.SESS.NUM%                                !1.16JAS
10748: 961f:      IF END #LOCAL.SESS.NUM% THEN OPEN.ERROR                         !1.16JAS
10749: 963b:      OPEN LOCAL.FILE.NAME$ KEYED RECL LOCAL.RECL% AS LOCAL.SESS.NUM% \1.16JAS
10750: 9668:           NOWRITE  NODEL                                             !1.16JAS
10751: 9668:      LOCAL.OPEN.FLAG$ = "Y"                                          !1.16JAS
10752: 967f: 
10753: 967f: RETURN                                                               !1.16JAS
10754: 968f: 
10755: 968f: \/*****************************************************************************
10756: 968f: \/****
10757: 968f: \/****              CLOSE.LOCAL
10758: 968f: \/****
10759: 968f: \/*****************************************************************************
10760: 968f: 
10761: 968f: CLOSE.LOCAL:                                                         !1.16JAS
10762: 969f: 
10763: 969f:      IF LOCAL.OPEN.FLAG$ = "Y" THEN BEGIN                            !1.16JAS
10764: 96bd: 
10765: 96bd:        CLOSE LOCAL.SESS.NUM%                                         !1.16JAS
10766: 96d1:        LOCAL.OPEN.FLAG$ = "N"                                        !1.16JAS
10767: 96e8:      ENDIF                                                           !1.16JAS
10768: 96f0: 
10769: 96f0: RETURN                                                               !1.16JAS
10770: 9700: 
10771: 9700: \******************************************************************************
10772: 9700: \***
10773: 9700: \***    CREATE.EMPTY.CCUPF:
10774: 9700: \***
10775: 9700: \***      close CCUPF if already open
10776: 9700: \***      create CCUPF as KEYED file
10777: 9700: \***
10778: 9700: \******************************************************************************
10779: 9700: 
10780: 9700:    CREATE.EMPTY.CCUPF:                                                 ! BMJK
10781: 9710:                                                                ! BMJK
10782: 9710:       CURR.SESS.NUM% = CCUPF.SESS.NUM%                                      ! BMJK
10783: 9722:       IF CCUPF.OPEN.FLAG$ = "Y" THEN BEGIN                                  ! BMJK
10784: 9740:          CCUPF.OPEN.FLAG$ = "N"                                             ! BMJK
10785: 9757:          CLOSE CCUPF.SESS.NUM%                                           ! BMJK
10786: 976b:       ENDIF                                                             ! BMJK
10787: 9773:                                                                ! BMJK
10788: 9773:       IF END #CCUPF.SESS.NUM% THEN CREATE.ERROR                            ! BMJK
10789: 978f:       CREATE POSFILE CCUPF.FILE.NAME$ KEYED 7,,,500 RECL CCUPF.RECL%       \ BMJK
10790: 97c6:         AS CCUPF.SESS.NUM% MIRRORED ATCLOSE                            ! BMJK
10791: 97c6:       CLOSE CCUPF.SESS.NUM%                                          ! BMJK
10792: 97da:                                                                ! BMJK
10793: 97da:    RETURN                                                        ! BMJK
10794: 97ea: 
10795: 97ea: \******************************************************************************
10796: 97ea: \***
10797: 97ea: \***    CREATE.CCBUF:
10798: 97ea: \***
10799: 97ea: \***       close CCBUF if already open
10800: 97ea: \***       create CCBUF as sequential readonly
10801: 97ea: \***
10802: 97ea: \******************************************************************************
10803: 97ea: 
10804: 97ea:    CREATE.CCBUF:
10805: 97fa: 
10806: 97fa:       CURR.SESS.NUM% = CCBUF.SESS.NUM%
10807: 980c: 
10808: 980c:       IF CCBUF.OPEN.FLAG$ = "Y" THEN BEGIN
10809: 982a:          CLOSE CCBUF.SESS.NUM%
10810: 983e:          CCBUF.OPEN.FLAG$ = "N"
10811: 9855:       ENDIF
10812: 985d: 
10813: 985d:       IF END #CCBUF.SESS.NUM% THEN CREATE.ERROR
10814: 9879:       CREATE POSFILE CCBUF.FILE.NAME$ AS CCBUF.SESS.NUM%               \
10815: 98a0:              BUFFSIZE 512 READONLY MIRRORED ATCLOSE
10816: 98a0:       CCBUF.OPEN.FLAG$ = "Y"
10817: 98b7: 
10818: 98b7:    RETURN
10819: 98c7: 
10820: 98c7: \******************************************************************************
10821: 98c7: \***
10822: 98c7: \***    CREATE.CCREJ:
10823: 98c7: \***
10824: 98c7: \***       close CCREJ if already open
10825: 98c7: \***       create CCREJ as sequential readonly
10826: 98c7: \***
10827: 98c7: \******************************************************************************
10828: 98c7: 
10829: 98c7:    CREATE.CCREJ:                                                        ! 1.18JAS
10830: 98d7: 
10831: 98d7:       CURR.SESS.NUM% = CCREJ.SESS.NUM%                                  ! 1.18JAS
10832: 98e9: 
10833: 98e9:       IF CCREJ.OPEN.FLAG$ = "Y" THEN BEGIN                              ! 1.18JAS
10834: 9907:          CLOSE CCREJ.SESS.NUM%                                          ! 1.18JAS
10835: 991b:          CCREJ.OPEN.FLAG$ = "N"                                         ! 1.18JAS
10836: 9932:       ENDIF                                                             ! 1.18JAS
10837: 993a: 
10838: 993a:       IF END #CCREJ.SESS.NUM% THEN CREATE.ERROR                         ! 1.18JAS
10839: 9956:       CREATE POSFILE CCREJ.FILE.NAME$ AS CCREJ.SESS.NUM%               \! 1.18JAS
10840: 997d:              BUFFSIZE 512 READONLY MIRRORED ATCLOSE                     ! 1.18JAS
10841: 997d:       CCREJ.OPEN.FLAG$ = "Y"                                            ! 1.18JAS
10842: 9994: 
10843: 9994:    RETURN                                                               ! 1.18JAS
10844: 99a4: 
10845: 99a4: \******************************************************************************
10846: 99a4: \***
10847: 99a4: \***    CREATE.CCTMP:
10848: 99a4: \***
10849: 99a4: \***       close CCTMP if already open
10850: 99a4: \***       create CCTMP as sequential readonly
10851: 99a4: \***
10852: 99a4: \******************************************************************************
10853: 99a4: 
10854: 99a4:    CREATE.CCTMP:
10855: 99b4: 
10856: 99b4:       CURR.SESS.NUM% = CCTMP.SESS.NUM%
10857: 99c6: 
10858: 99c6:       IF CCTMP.OPEN.FLAG$ = "Y" THEN BEGIN
10859: 99e4:          CLOSE CCTMP.SESS.NUM%
10860: 99f8:          CCTMP.OPEN.FLAG$ = "N"
10861: 9a0f:       ENDIF
10862: 9a17: 
10863: 9a17:       IF END #CCTMP.SESS.NUM% THEN CREATE.ERROR
10864: 9a33:       CREATE POSFILE CCTMP.FILE.NAME$ AS CCTMP.SESS.NUM%               \
10865: 9a5a:              BUFFSIZE 512 READONLY MIRRORED ATCLOSE
10866: 9a5a:       CCTMP.OPEN.FLAG$ = "Y"
10867: 9a71: 
10868: 9a71:    RETURN
10869: 9a81: 
10870: 9a81: ! ASSIGN.NEXT.CREDIT.CLAIM.NUMBER moved to after CCTMP to STKMQ transfer !BMJK
10871: 9a81: ! CHECK.FOR.WRITE.TO.CCBUF moved to after CCTMP to STKMQ transfer        !BMJK
10872: 9a81: 
10873: 9a81: \******************************************************************************
10874: 9a81: \******************************************************************************
10875: 9a81: \***                                                                        ***
10876: 9a81: \***   WRITE.STKMQ.FROM.CCTMP:                                              ***
10877: 9a81: \***                                                                        ***
10878: 9a81: \***      Transfer all records from CCTMP to STKMQ, after first checking    ***
10879: 9a81: \***        the UOD on the CCUPF for any updates since the data was         ***
10880: 9a81: \***        downloaded into the LDT; (And it goes something like this;)     ***
10881: 9a81: \***      open the STKMQ and CCUPF files for access                         ***
10882: 9a81: \***      set flag to initially suppress type 27 txn production             ***
10883: 9a81: \***      perform loop to sequentially read all records in the CCTMP        ***
10884: 9a81: \***        attempt to read CCTMP, if read failed then set flag otherwise;  ***
10885: 9a81: \***        prepare STKMQ record by adding CR+LF to CCTMP record            ***
10886: 9a81: \***        extract UOD num and status depending if type 25, 26 or 28 record***
10887: 9a81: \***        if primer is present then change UOD number to zeros plus time  ***
10888: 9a81: \***          of DESPATCH to prevent re-processing - CNS                    ***
10889: 9a81: \***        attempt to read UOD from CCUPF file;                            ***
10890: 9a81: \***          if read failed then;                                          ***
10891: 9a81: \***            if status <> O then;                                        ***
10892: 9a81: \***              if transaction type is 25 or 26 assign next claim num     ***
10893: 9a81: \***              perform writes to STKMQ + CCUPF                           ***
10894: 9a81: \***            otherwise; write to STKMQ without hold or unlock and        ***
10895: 9a81: \***              if UOD was TA primer then write to CCUPF                  ***
10896: 9a81: \***          otherwise if read was successful;                             ***
10897: 9a81: \***            check for valid new status for STKMQ record (ie can only    ***
10898: 9a81: \***              be C->D ) and if valid and type 26 record; convert to     ***
10899: 9a81: \***              type 28 to despatch the UOD but lose the item level data  ***
10900: 9a81: \***            if valid status change then; write STKMQ and write          ***
10901: 9a81: \***              unlock CCUPF to update status change                      ***
10902: 9a81: \***            otherwise if invalid status change then write CCUPF unlock  ***
10903: 9a81: \***              to release record previously locked  - Phew!              ***
10904: 9a81: \***         if during any of the stages above a record is actually written ***
10905: 9a81: \***           to the STKMQ and it was a goods out transmission , then the  ***
10906: 9a81: \***           type 27 requirement flag should be changed                   ***
10907: 9a81: \***                                                                        ***
10908: 9a81: \***      If required then write an end of session record to the STKMQ      ***
10909: 9a81: \***                                                                        ***
10910: 9a81: \******************************************************************************
10911: 9a81: \******************************************************************************
10912: 9a81: 
10913: 9a81: WRITE.STKMQ.FROM.CCTMP:
10914: 9a91: 
10915: 9a91:        CURR.SESS.NUM% = CCUPF.SESS.NUM%                                ! BMJK
10916: 9aa3:        IF END #CCUPF.SESS.NUM% THEN OPEN.ERROR                         ! BMJK
10917: 9abf:        OPEN CCUPF.FILE.NAME$ KEYED RECL CCUPF.RECL% AS CCUPF.SESS.NUM% ! BMJK
10918: 9aeb:        CCUPF.OPEN.FLAG$ = "Y"                                          ! BMJK
10919: 9b02: 
10920: 9b02:        IF STKMQ.OPEN.FLAG$ <> "Y" THEN BEGIN                           ! BMJK
10921: 9b20:           IF END# STKMQ.SESS.NUM% THEN OPEN.ERROR                      ! BMJK
10922: 9b3c:           CURR.SESS.NUM% = STKMQ.SESS.NUM%                             ! BMJK
10923: 9b4e:           OPEN STKMQ.FILE.NAME$ AS STKMQ.SESS.NUM% BUFFSIZE 512        \ BMJK
10924: 9b76:              READONLY APPEND                                           ! BMJK
10925: 9b76:           STKMQ.OPEN.FLAG$ = "Y"                                       ! BMJK
10926: 9b8d:        ENDIF                                                           ! BMJK
10927: 9b95: 
10928: 9b95:        END.OF.CCTMP = FALSE                                            ! BMJK
10929: 9bb0:        VALID.DATA.PRESENT = FALSE                                      ! BMJK
10930: 9bc2: 
10931: 9bc2:        WHILE (NOT END.OF.CCTMP)                                        ! BMJK
10932: 9bcd: 
10933: 9bcd:           CURR.SESS.NUM% = CCTMP.SESS.NUM%                             ! BMJK
10934: 9bdf:           IF READ.CCTMP THEN END.OF.CCTMP = TRUE ELSE BEGIN            ! BMJK
10935: 9c06: 
10936: 9c06:              STKMQ.RECORD$ = CCTMP.RECORD$ + CCTMP.ENDREC.MARKER$      ! BMJK
10937: 9c32: 
10938: 9c32:              IF CCTMP.TRANS.TYPE$ = "26" THEN BEGIN                    ! BMJK
10939: 9c50:                 CCUPF.UOD.NUM$ = MID$(CCTMP.RECORD$,10,7)              ! BMJK
10940: 9c77:                 CCTMP.UOD.STATUS$ = MID$(CCTMP.RECORD$,17,1)           ! BMJK
10941: 9ca1:              ENDIF ELSE BEGIN                                          ! BMJK
10942: 9ca9:                 IF CCTMP.TRANS.TYPE$ = "28" THEN BEGIN                 ! 1.16JAS
10943: 9cc7:                    CCUPF.UOD.NUM$ = MID$(CCTMP.RECORD$,14,7)           ! BMJK
10944: 9cee:                    CCTMP.UOD.STATUS$ = MID$(CCTMP.RECORD$,21,1)        ! BMJK
10945: 9d17:                 ENDIF ELSE BEGIN                                       ! BMJK ! 1.16JAS
10946: 9d1f:                    CCUPF.UOD.NUM$ = PACK$("00000000000000")            ! 1.16JAS
10947: 9d3b:                    CCTMP.UOD.STATUS$ = "D"                             ! 1.16JAS
10948: 9d52:                 ENDIF                                                  ! 1.16JAS
10949: 9d5a:              ENDIF                                                     ! 1.16JAS
10950: 9d62: 
10951: 9d62:              PRIMER.PRESENT = FALSE                                    ! BMJK
10952: 9d74:              IF MID$(CCUPF.UOD.NUM$,3,3) = PACK$("000000") THEN BEGIN  ! BMJK
10953: 9db1:                 PRIMER.PRESENT = TRUE                                  ! BMJK
10954: 9dc3:                 IF LDT.RETURNS.TYPE$ = "G" THEN BEGIN                  ! 1.16JAS
10955: 9de1:                    TEMP$ = MID$(CCTMP.RECORD$,95,3)                       ! CNS
10956: 9e06:                    IF TEMP$ = PACK$("000000") THEN TEMP$ = PACK$("999999") ! CNS
10957: 9e3b:                    CCUPF.UOD.NUM$ = PACK$(STRING$(8,"0")) + TEMP$         ! CNS
10958: 9e81:                 ENDIF ELSE BEGIN                                       ! 1.16JAS
10959: 9e89:                    CCUPF.UOD.NUM$ = PACK$(STRING$(8,"0")) + PACK$("999999") ! 1.16JAS
10960: 9ece:                 ENDIF                                                       ! 1.16JAS
10961: 9ed6:              ENDIF                                                     ! BMJK
10962: 9ede: 
10963: 9ede:              CURR.SESS.NUM% = CCUPF.SESS.NUM%                          ! BMJK
10964: 9ef0:              IF READ.CCUPF.LOCKED THEN BEGIN                           ! BMJK
10965: 9f04:                 IF CCTMP.UOD.STATUS$ <> "O" THEN BEGIN                 ! BMJK
10966: 9f25:                    IF CCTMP.TRANS.TYPE$ = "26" OR                      \ 1.16JAS
10967: 9f77:                       CCTMP.TRANS.TYPE$ = "25" THEN                    \ BMJK ! 1.16JAS
10968: 9f77:                       GOSUB ASSIGN.NEXT.CREDIT.CLAIM.NUMBER            ! BMJK
10969: 9f89:                    CCUPF.CURRENT.STATUS$ = CCTMP.UOD.STATUS$           ! BMJK
10970: 9fa7:                    IF PRIMER.PRESENT = FALSE THEN BEGIN                ! CNS
10971: 9fbc:                       CURR.SESS.NUM% = CCUPF.SESS.NUM%                 ! BMJK
10972: 9fce:                       IF WRITE.CCUPF THEN GOTO WRITE.ERROR             ! BMJK
10973: 9fe2:                    ENDIF                                               ! CNS
10974: 9fea:                    CURR.SESS.NUM% = STKMQ.SESS.NUM%                    ! BMJK
10975: 9ffc:                    IF WRITE.STKMQ THEN GOTO WRITE.ERROR                ! BMJK
10976: a010:                    VALID.DATA.PRESENT = TRUE                           ! BMJK
10977: a022:                    GOSUB CHECK.FOR.WRITE.TO.CCBUF                      ! BMJK
10978: a036:                 ENDIF ELSE BEGIN                                       ! BMJK
10979: a03e: ! 4 lines removed from here - CNS
10980: a03e:                    CURR.SESS.NUM% = STKMQ.SESS.NUM%                    ! BMJK
10981: a050:                    IF WRITE.STKMQ THEN GOTO WRITE.ERROR                ! BMJK
10982: a064:                    VALID.DATA.PRESENT = TRUE                           ! BMJK
10983: a076:                 ENDIF                                                  ! BMJK
10984: a081:              ENDIF ELSE BEGIN                                          ! BMJK
10985: a089:                 IF ( CCUPF.CURRENT.STATUS$="C" AND                     \ BMJK
10986: a0de:                    CCTMP.UOD.STATUS$="D" ) THEN BEGIN                  ! BMJK
10987: a0de:                    IF CCTMP.TRANS.TYPE$ = "26" THEN                    \ BMJK
10988: a0ff:                       STKMQ.RECORD$ = CCTMP.RECORD.DELIMITER$ +        \ BMJK
10989: a1a7:                                       PACK$("28") +                    \ BMJK
10990: a1a7:                                       MID$(CCTMP.RECORD$,3,7) +        \ BMJK
10991: a1a7:                                       MID$(CCTMP.RECORD$,18,4) +       \ BMJK
10992: a1a7:                                       MID$(CCTMP.RECORD$,10,8) +       \ BMJK
10993: a1a7:                                       CCTMP.RECORD.DELIMITER$ +        \ BMJK
10994: a1a7:                                       CCTMP.ENDREC.MARKER$             ! BMJK
10995: a1af:                    CURR.SESS.NUM% = STKMQ.SESS.NUM%                    ! BMJK
10996: a1c1:                    IF WRITE.STKMQ THEN GOTO WRITE.ERROR                ! BMJK
10997: a1d5:                    CURR.SESS.NUM% = CCUPF.SESS.NUM%                    ! BMJK
10998: a1e7:                    CCUPF.CURRENT.STATUS$ = CCTMP.UOD.STATUS$           ! BMJK
10999: a205:                    IF WRITE.UNLOCK.CCUPF THEN GOTO WRITE.ERROR         ! BMJK
11000: a219:                    VALID.DATA.PRESENT = TRUE                           ! BMJK
11001: a22d:                 ENDIF ELSE BEGIN                                       ! BMJK
11002: a235:                    IF WRITE.UNLOCK.CCUPF THEN GOTO WRITE.ERROR         ! BMJK
11003: a249:                 ENDIF                                                  ! BMJK
11004: a251:              ENDIF                                                     ! BMJK
11005: a259:           ENDIF                                                        ! BMJK
11006: a261: 
11007: a261:        WEND
11008: a279: 
11009: a279:       ! If VALID data and Goods out transmission
11010: a279: 
11011: a279:        IF VALID.DATA.PRESENT AND                                       \ ! 1.16JAS
11012: a2a9:           LDT.RETURNS.TYPE$ = "G" THEN BEGIN                           ! BMJK 1.16JAS
11013: a2a9:           GOSUB UPDATE.CCUOD.WITH.LDT.NUMBER                           ! BMJK
11014: a2bb:              FINISH.DATE$ = DATE$
11015: a2d3:              FINISH.TIME$ = TIME$
11016: a2eb:              STKMQ.RECORD$ = CHR$(34) + PACK$("27") + CHR$(59) +          \
11017: a39a:                              PACK$(FINISH.DATE$) +                        \
11018: a39a:                              PACK$(FINISH.TIME$) +                        \
11019: a39a:                              CHR$(34) + CHR$(0Dh) + CHR$(0Ah)
11020: a39a:              CURRENT.KEY$ = ""
11021: a3af:              CURR.SESS.NUM% = STKMQ.SESS.NUM%
11022: a3c1:              IF WRITE.STKMQ THEN GOTO WRITE.ERROR
11023: a3d5:        ENDIF                                                           ! BMJK
11024: a3dd: 
11025: a3dd:        CLOSE STKMQ.SESS.NUM%
11026: a3f1:        STKMQ.OPEN.FLAG$ = "N"
11027: a408: 
11028: a408:        CLOSE CCUPF.SESS.NUM%                                           ! BMJK
11029: a41c:        CCUPF.OPEN.FLAG$ = "N"                                          ! BMJK
11030: a433: 
11031: a433:   RETURN
11032: a443: 
11033: a443: \******************************************************************************
11034: a443: \***
11035: a443: \***   ASSIGN.NEXT.CREDIT.CLAIM.NUMBER:
11036: a443: \***
11037: a443: \***     open CCTRL as DIRECT
11038: a443: \***     read record from file
11039: a443: \***     increment record and update record in file
11040: a443: \***     check for claim number exceeding 9999999; if so set to 00000001
11041: a443: \***     close CCTRL
11042: a443: \***
11043: a443: \***     If Goods out transmission insert new claim number into existing
11044: a443: \***        CCTMP type 26 record
11045: a443: \***     If credit claim transmission insert new claim number into existing
11046: a443: \***        CCTMP type 25 record
11047: a443: \***
11048: a443: \******************************************************************************
11049: a443: 
11050: a443: ASSIGN.NEXT.CREDIT.CLAIM.NUMBER:
11051: a453: 
11052: a453:        CURR.SESS.NUM% = CCTRL.SESS.NUM%
11053: a465:        IF END #CCTRL.SESS.NUM% THEN OPEN.ERROR
11054: a481:        OPEN CCTRL.FILE.NAME$ DIRECT RECL CCTRL.RECL% AS CCTRL.SESS.NUM%
11055: a4ad:        CCTRL.OPEN.FLAG$ = "Y"
11056: a4c4:        CCTRL.REC.NUM% = 1
11057: a4d5:        CURRENT.KEY$ = "1"
11058: a4ea:        IF READ.CCTRL.LOCKED THEN GOTO READ.ERROR
11059: a4fe:        CCTRL.CREDIT.CLAIM.NUM$ = PACK$(RIGHT$(STRING$(8,"0") +         \
11060: a595:                                  STR$(VAL(UNPACK$(                     \
11061: a595:                                  CCTRL.CREDIT.CLAIM.NUM$))+1),8))
11062: a595:        IF (VAL(UNPACK$(CCTRL.CREDIT.CLAIM.NUM$))>9999999) OR           \
11063: a63c:           (VAL(UNPACK$(CCTRL.CREDIT.CLAIM.NUM$))=0) THEN               \
11064: a63c:              CCTRL.CREDIT.CLAIM.NUM$ = PACK$("00000001")
11065: a658: 
11066: a658:        CCTRL.REC.NUM% = 1
11067: a669:        IF WRITE.UNLOCK.CCTRL THEN GOTO WRITE.ERROR
11068: a67d:        CCTRL.OPEN.FLAG$ = "N"
11069: a694:        CLOSE CCTRL.SESS.NUM%
11070: a6a8: 
11071: a6a8:        ! Goods out transmission
11072: a6a8:        IF LDT.RETURNS.TYPE$ = "G" THEN BEGIN                              ! 1.16JAS
11073: a6c3:           STKMQ.RECORD$ = LEFT$(STKMQ.RECORD$,17) +                       \ BMJK
11074: a72a:                          CCTRL.CREDIT.CLAIM.NUM$ +                        \ BMJK
11075: a72a:                          RIGHT$(STKMQ.RECORD$,(LEN(STKMQ.RECORD$)-21))    ! BMJK
11076: a72a:        ENDIF ELSE BEGIN                                                   ! 1.16JAS
11077: a732:           ! Credit Claim transmission
11078: a732:           STKMQ.RECORD$ = LEFT$(STKMQ.RECORD$, 9) +                       \ 1.16JAS
11079: a797:                          CCTRL.CREDIT.CLAIM.NUM$ +                        \ 1.16JAS
11080: a797:                          RIGHT$(STKMQ.RECORD$,(LEN(STKMQ.RECORD$)-13))    ! 1.16JAS
11081: a797:        ENDIF                                                              ! 1.16JAS
11082: a79f: 
11083: a79f: RETURN
11084: a7af: 
11085: a7af: \******************************************************************************
11086: a7af: \***
11087: a7af: \***   CHECK.FOR.WRITE.TO.CCBUF:
11088: a7af: \***
11089: a7af: \***      If Goods out transmission
11090: a7af: \***      check for requirement using UOD number structure, if required then
11091: a7af: \***        append record to the CCBUF
11092: a7af: \***
11093: a7af: \******************************************************************************
11094: a7af: 
11095: a7af: CHECK.FOR.WRITE.TO.CCBUF:
11096: a7bf: 
11097: a7bf:     ! Goods out transmission
11098: a7bf:     IF LDT.RETURNS.TYPE$ = "G" THEN BEGIN                              ! 1.16JAS
11099: a7dd:        IF MID$(CCUPF.UOD.NUM$,3,2) <> PACK$("0006") AND                \ BMJK
11100: a86b:           MID$(CCUPF.UOD.NUM$,3,2) <> PACK$("0083") AND                \ BMJK
11101: a86b:           (NOT PRIMER.PRESENT) THEN BEGIN                              ! BMJK
11102: a86b: 
11103: a86b:           CCBUF.RECS.PRESENT = TRUE                                    ! BMJK
11104: a881:           CCBUF.RECORD$ = STKMQ.RECORD$                                ! BMJK
11105: a89f:           CURRENT.KEY$ = ""                                            ! BMJK
11106: a8b4:           CURR.SESS.NUM% = CCBUF.SESS.NUM%                             ! BMJK
11107: a8c6:           IF WRITE.CCBUF THEN GOTO WRITE.ERROR                         ! BMJK
11108: a8da: 
11109: a8da:        ENDIF                                                           ! BMJK
11110: a8e2:     ENDIF                                                              ! 1.16JAS
11111: a8ea: 
11112: a8ea: RETURN
11113: a8fa: 
11114: a8fa: \******************************************************************************
11115: a8fa: \***
11116: a8fa: \***   UPDATE.CCUOD.WITH.LDT.NUMBER:
11117: a8fa: \***
11118: a8fa: \***     close CCUOD if currently open
11119: a8fa: \***     open CCUOD as keyed
11120: a8fa: \***     read header record from file as LOCKED
11121: a8fa: \***     store current LDT number in file
11122: a8fa: \***     update record in file and release
11123: a8fa: \***     close CCUOD
11124: a8fa: \***
11125: a8fa: \******************************************************************************
11126: a8fa: 
11127: a8fa: UPDATE.CCUOD.WITH.LDT.NUMBER:
11128: a90a: 
11129: a90a:        IF CCUOD.OPEN.FLAG$="Y" THEN BEGIN
11130: a928:           CCUOD.OPEN.FLAG$ = "N"
11131: a93f:           CLOSE CCUOD.SESS.NUM%
11132: a953:        ENDIF
11133: a95b:        CURR.SESS.NUM% = CCUOD.SESS.NUM%
11134: a96d:        IF END #CCUOD.SESS.NUM% THEN OPEN.ERROR
11135: a989:        OPEN CCUOD.FILE.NAME$ KEYED RECL CCUOD.RECL% AS CCUOD.SESS.NUM%                                        ! MMJK
11136: a9b5:        CCUOD.OPEN.FLAG$ = "Y"
11137: a9cc:        CCUOD.UOD.NUM$ = PACK$(STRING$(7,"??"))
11138: a9ef:        CURRENT.KEY$ = UNPACK$(CCUOD.UOD.NUM$)
11139: aa10:        IF READ.CCUOD.LOCKED THEN GOTO READ.ERROR
11140: aa24:        CCUOD.LDT.NUM$ = PACK$(CURR.TERMINAL$)
11141: aa47:        IF WRITE.UNLOCK.CCUOD THEN GOTO WRITE.ERROR
11142: aa5b:        CCUOD.OPEN.FLAG$ = "N"
11143: aa72:        CLOSE CCUOD.SESS.NUM%
11144: aa86: 
11145: aa86: RETURN
11146: aa96: 
11147: aa96: \******************************************************************************
11148: aa96: \***
11149: aa96: \***   DIRECT.EXTRACT.CCUOD.KEYS:
11150: aa96: \***
11151: aa96: \***     close CCUOD if already open
11152: aa96: \***     open CCUOD for direct access
11153: aa96: \***     process each sector extracting any open,closed or cancelled UODs
11154: aa96: \***       store all extracts in a table
11155: aa96: \***       KEEP A SEPARATE COUNT OF CANCELLED UODS       1.4
11156: aa96: \***     complete loop
11157: aa96: \***     close file
11158: aa96: \***
11159: aa96: \******************************************************************************
11160: aa96: 
11161: aa96:     DIRECT.EXTRACT.CCUOD.KEYS:
11162: aaa6: 
11163: aaa6:       MAX.TABLE.SIZE% = 200
11164: aab7:       DIM CCUOD.TABLE$(MAX.TABLE.SIZE%)
11165: aaeb:       RECS.PER.SECTOR% = (508/CCUOD.RECL%)
11166: ab0b:       SECTOR% = 2
11167: ab1c:       NUM.STATUS.O.C.X.UODS% = 0                                          !1.4
11168: ab2d:       NUM.OF.CANCELLED.UODS% = 0                                          !1.4
11169: ab3e:       TABLE.FULL = FALSE
11170: ab59:       END.OF.FILE = FALSE
11171: ab74: 
11172: ab74:       CURR.SESS.NUM% = CCUOD.SESS.NUM%
11173: ab86:       IF CCUOD.OPEN.FLAG$ = "Y" THEN BEGIN
11174: aba4:         CCUOD.OPEN.FLAG$ = "N"
11175: abbb:        CLOSE CCUOD.SESS.NUM%
11176: abcf:       ENDIF
11177: abd7:       IF END #CCUOD.SESS.NUM% THEN OPEN.ERROR
11178: abf3:       OPEN CCUOD.FILE.NAME$ DIRECT RECL 512 AS CCUOD.SESS.NUM%
11179: ac1b:       CCUOD.OPEN.FLAG$ = "Y"
11180: ac32: 
11181: ac32:       WHILE (NOT END.OF.FILE) AND (NOT TABLE.FULL)
11182: ac3d:         IF END #CCUOD.SESS.NUM% THEN END.OF.CCUOD.DIRECT
11183: ac59:         READ FORM "C4,C508";#CCUOD.SESS.NUM%,SECTOR%;FILLER$,SECTOR$
11184: ac9b:        IF LEFT$(SECTOR$,7)<>PACK$(STRING$(14,"0")) THEN BEGIN
11185: acdf:          INDEX% = 1
11186: aced:          WHILE (INDEX%<(RECS.PER.SECTOR%*CCUOD.RECL%)) AND (NOT TABLE.FULL)
11187: acf8:            CCUOD.KEY$ = MID$(SECTOR$,INDEX%,7)
11188: ad1f:            CCUOD.STATUS$ = MID$(SECTOR$,INDEX%+7,1)
11189: ad4b:            IF CCUOD.KEY$ = PACK$(STRING$(14,"0")) THEN INDEX% = 508       \
11190: ad7e:             ELSE IF (CCUOD.STATUS$ = "O" OR CCUOD.STATUS$ = "C" OR        \
11191: ae2f:                      CCUOD.STATUS$ = "X")                             \
11192: ae2f:                 AND CCUOD.KEY$ <> PACK$(STRING$(14,"?")) THEN BEGIN
11193: ae2f:                   IF CCUOD.STATUS$ = "X" THEN BEGIN                       ! 1.4
11194: ae4d:                      NUM.OF.CANCELLED.UODS% = NUM.OF.CANCELLED.UODS% + 1 ! 1.4
11195: ae5c:                   ENDIF                                                   ! 1.4
11196: ae64:                   NUM.STATUS.O.C.X.UODS% = NUM.STATUS.O.C.X.UODS% + 1     ! 1.4
11197: ae73:                   IF NUM.STATUS.O.C.X.UODS%>MAX.TABLE.SIZE% THEN TABLE.FULL=TRUE \1.4
11198: aea0:                  ELSE CCUOD.TABLE$(NUM.STATUS.O.C.X.UODS%) = CCUOD.KEY$          !1.4
11199: aecc:                 ENDIF
11200: aed4:            INDEX% = INDEX% + CCUOD.RECL%
11201: aee7:          WEND
11202: af53:        ENDIF
11203: af5b:        SECTOR% = SECTOR% + 1
11204: af6a:         END.OF.CCUOD.DIRECT.RETURN:
11205: af7a:       WEND
11206: afe2: 
11207: afe2:       CCUOD.OPEN.FLAG$ = "N"
11208: aff9:       CLOSE CCUOD.SESS.NUM%
11209: b00d: 
11210: b00d:       IF TABLE.FULL THEN BEGIN
11211: b022:        SB.UNIQUE$ = "CCUOD KEYS"
11212: b037:         GOSUB LOG.TABLE.FULL.ERROR
11213: b049:       ENDIF
11214: b051: 
11215: b051:     RETURN
11216: b061: 
11217: b061: 
11218: b061:     END.OF.CCUOD.DIRECT:
11219: b071: 
11220: b071: 
11221: b071:        END.OF.FILE = TRUE
11222: b08c: 
11223: b08c:        GOTO END.OF.CCUOD.DIRECT.RETURN
11224: b097: 
11225: b097: 
11226: b097: \******************************************************************************
11227: b097: \***
11228: b097: \***   DIRECT.EXTRACT.CCLAM.KEYS:     !1.4
11229: b097: \***
11230: b097: \***     close CCLAM if already open
11231: b097: \***     open CCLAM for direct access
11232: b097: \***     process each sector extracting any despatched UODs (not including
11233: b097: \***       primer UODs) and store extracts in a table.
11234: b097: \***     complete loop
11235: b097: \***     close file
11236: b097: \***
11237: b097: \******************************************************************************
11238: b097: 
11239: b097:     DIRECT.EXTRACT.CCLAM.KEYS:
11240: b0a7: 
11241: b0a7:       MAX.TABLE.SIZE% = 1600                   ! Was 400                          1.19CS
11242: b0b8:                                                ! CCLAM is keyed & holds 2000
11243: b0b8:                                                ! records. Max table size needs
11244: b0b8:                                                ! to be 20% less ie. 1600 to 
11245: b0b8:                                                ! prevent performance errors.
11246: b0b8:       DIM CCLAM.TABLE$(MAX.TABLE.SIZE%)
11247: b0ec:       RECS.PER.SECTOR% = (508/CCLAM.RECL%)
11248: b10c:       SECTOR% = 2
11249: b11d:       NUM.OF.DESPATCHED.UODS% = 0
11250: b12e:       TABLE.FULL = FALSE
11251: b149:       END.OF.FILE = FALSE
11252: b164: 
11253: b164:       CURR.SESS.NUM% = CCLAM.SESS.NUM%
11254: b176:       IF CCLAM.OPEN.FLAG$ = "Y" THEN BEGIN
11255: b194:         CCLAM.OPEN.FLAG$ = "N"
11256: b1ab:        CLOSE CCLAM.SESS.NUM%
11257: b1bf:       ENDIF
11258: b1c7:       IF END #CCLAM.SESS.NUM% THEN OPEN.ERROR
11259: b1e3:       OPEN CCLAM.FILE.NAME$ DIRECT RECL 512 AS CCLAM.SESS.NUM%
11260: b20b:       CCLAM.OPEN.FLAG$ = "Y"
11261: b222: 
11262: b222:       WHILE (NOT END.OF.FILE) AND (NOT TABLE.FULL)
11263: b22d:         IF END #CCLAM.SESS.NUM% THEN END.OF.CCLAM.DIRECT
11264: b249:         READ FORM "C4,C508";#CCLAM.SESS.NUM%,SECTOR%;FILLER$,SECTOR$
11265: b28b:        IF LEFT$(SECTOR$,4)<>PACK$(STRING$(8,"0")) THEN BEGIN
11266: b2cf:          INDEX% = 1
11267: b2dd:          WHILE (INDEX%<(RECS.PER.SECTOR%*CCLAM.RECL%)) AND (NOT TABLE.FULL)
11268: b2e8:            CCLAM.KEY$ = MID$(SECTOR$,INDEX%,4)
11269: b30f:            IF CCLAM.KEY$ = PACK$(STRING$(8,"0")) THEN BEGIN
11270: b339:               INDEX% = 508
11271: b34a:            ENDIF ELSE BEGIN
11272: b352:               IF (CCLAM.KEY$ <> PACK$(STRING$(8,"?"))) THEN BEGIN
11273: b37f:                  ! Do not include primer UODs (starting with 10 zeroes)
11274: b37f:                  IF MID$(SECTOR$,INDEX%+4,5) <> PACK$("0000000000") THEN BEGIN
11275: b3c1:                     NUM.OF.DESPATCHED.UODS% = NUM.OF.DESPATCHED.UODS% + 1
11276: b3d0:                     IF NUM.OF.DESPATCHED.UODS% > MAX.TABLE.SIZE% THEN BEGIN
11277: b3e8:                        TABLE.FULL=TRUE
11278: b405:                     ENDIF ELSE BEGIN
11279: b40d:                           CCLAM.TABLE$(NUM.OF.DESPATCHED.UODS%) = CCLAM.KEY$
11280: b439:                     ENDIF
11281: b441:                  ENDIF
11282: b449:               ENDIF
11283: b451:            ENDIF
11284: b459:            INDEX% = INDEX% + CCLAM.RECL%
11285: b46c:          WEND
11286: b4d8:        ENDIF
11287: b4e0:        SECTOR% = SECTOR% + 1
11288: b4ef:         END.OF.CCLAM.DIRECT.RETURN:
11289: b4ff:       WEND
11290: b567: 
11291: b567:       CCLAM.OPEN.FLAG$ = "N"
11292: b57e:       CLOSE CCLAM.SESS.NUM%
11293: b592: 
11294: b592:       IF TABLE.FULL THEN BEGIN
11295: b5a7:        SB.UNIQUE$ = "CCLAM KEYS"
11296: b5bc:         GOSUB LOG.TABLE.FULL.ERROR
11297: b5ce:       ENDIF
11298: b5d6: 
11299: b5d6:     RETURN
11300: b5e6: 
11301: b5e6: 
11302: b5e6:     END.OF.CCLAM.DIRECT:
11303: b5f6: 
11304: b5f6:        END.OF.FILE = TRUE
11305: b611: 
11306: b611:        GOTO END.OF.CCLAM.DIRECT.RETURN
11307: b61c: 
11308: b61c: \******************************************************************************
11309: b61c: \***
11310: b61c: \***    CREATE.CCWKF.AND.WRITE.HEADER
11311: b61c: \***
11312: b61c: \***       close CCWKF if already open
11313: b61c: \***       create CCWKF as sequential readonly
11314: b61c: \***
11315: b61c: \***       clear item storage variable for extracted items
11316: b61c: \***
11317: b61c: \***       format CCWKF header record and write to CCWKF
11318: b61c: \***
11319: b61c: \***       Only send down the number of open/closed UODs not the number  1.4
11320: b61c: \***       of cancelled/despatched UODs.                                 1.4
11321: b61c: \***
11322: b61c: \***       initialise item and barcode storage tables
11323: b61c: \***
11324: b61c: \******************************************************************************
11325: b61c: 
11326: b61c:    CREATE.CCWKF.AND.WRITE.HEADER:
11327: b62c: 
11328: b62c:       CURR.SESS.NUM% = CCWKF.SESS.NUM%
11329: b63e:       IF CCWKF.OPEN.FLAG$ = "Y" THEN BEGIN
11330: b65c:         CCWKF.OPEN.FLAG$ = "N"
11331: b673:          CLOSE CCWKF.SESS.NUM%
11332: b687:       ENDIF
11333: b68f: 
11334: b68f:       IF END #CCWKF.SESS.NUM% THEN CREATE.ERROR
11335: b6ab:       CREATE POSFILE CCWKF.FILE.NAME$ AS CCWKF.SESS.NUM%               \
11336: b6d2:              BUFFSIZE 512 READONLY MIRRORED ATCLOSE
11337: b6d2:       CCWKF.OPEN.FLAG$ = "Y"
11338: b6e9: 
11339: b6e9:       CRLF$ = CHR$(0DH) + CHR$(0AH)
11340: b716:       ITEM.STORAGE$ = ""
11341: b72d:       ITEM.DESC.STORAGE$ = ""
11342: b744:       BARCODE.STORAGE$ = ""
11343: b75b:       BARCODE.INDEX.STORAGE$ = ""
11344: b772:       NUM.ITEMS% = 0
11345: b783:       NUM.BARCODES% = 0
11346: b794: 
11347: b794:       NUM.OF.OPEN.CLOSED.UODS% = NUM.STATUS.O.C.X.UODS% -             \ 1.4
11348: b7ad:                                  NUM.OF.CANCELLED.UODS%               ! 1.4
11349: b7ad: 
11350: b7ad:       CCWKF.RECORD$ = "RE" + RIGHT$("0000"+STR$(NUM.OF.OPEN.CLOSED.UODS%),4) !1.4
11351: b7fa: 
11352: b7fa:       CURRENT.KEY$ = ""
11353: b80f:       IF WRITE.CCWKF THEN GOTO WRITE.ERROR
11354: b823: 
11355: b823:    RETURN
11356: b833: 
11357: b833: \******************************************************************************
11358: b833: \***
11359: b833: \***    PROCESS.UOD.RECORDS:  !1.4 title changed
11360: b833: \***
11361: b833: \***      open keyed files for use in routine
11362: b833: \***
11363: b833: \***      initialise table pointer
11364: b833: \***      perform loop to process contents of CCUOD table
11365: b833: \***        read record from CCUOD
11366: b833: \***        call routine to write UOD header record to CCWKF
11367: b833: \***        perform loop to extract all relevent items from CCITM
11368: b833: \***          create key and attempt to read item from CCITM
11369: b833: \***          if item code is present then call routine to process item code
11370: b833: \***           and store in string to be added to CCWKF later
11371: b833: \***          increment item counter
11372: b833: \***        complete loop to process all items
11373: b833: \***      complete loop to process CCUOD table
11374: b833: \***
11375: b833: \***
11376: b833: \***      close CCUOD and CCITM                                         1.4
11377: b833: \***
11378: b833: \***      loop through CCLAM table and extract claims for writing to    1.4
11379: b833: \***      CCWKF.                                                        1.4
11380: b833: \***
11381: b833: \***
11382: b833: \***      close CCLAM                                                   1.4
11383: b833: \***
11384: b833: \***      call routine to write items to CCWKF
11385: b833: \***      call routine to sort and write any barcodes to CCWKF
11386: b833: \***
11387: b833: \***      call routine to format and write UOD trailer to CCWKF
11388: b833: \***
11389: b833: \******************************************************************************
11390: b833: 
11391: b833:      PROCESS.UOD.RECORDS:                                               !1.4
11392: b843: 
11393: b843:        CURR.SESS.NUM% = CCUOD.SESS.NUM%
11394: b855:        IF CCUOD.OPEN.FLAG$ = "Y" THEN BEGIN
11395: b873:         CCUOD.OPEN.FLAG$ = "N"
11396: b88a:          CLOSE CCUOD.SESS.NUM%
11397: b89e:        ENDIF
11398: b8a6:        IF END #CCUOD.SESS.NUM% THEN OPEN.ERROR
11399: b8c2:        OPEN CCUOD.FILE.NAME$ KEYED RECL CCUOD.RECL% AS CCUOD.SESS.NUM%                                        ! MMJK
11400: b8ee:        CCUOD.OPEN.FLAG$ = "Y"
11401: b905: 
11402: b905:        CURR.SESS.NUM% = CCITM.SESS.NUM%
11403: b917:        IF CCITM.OPEN.FLAG$ = "Y" THEN BEGIN
11404: b935:         CCITM.OPEN.FLAG$ = "N"
11405: b94c:          CLOSE CCITM.SESS.NUM%
11406: b960:        ENDIF
11407: b968:        IF END #CCITM.SESS.NUM% THEN OPEN.ERROR
11408: b984:        OPEN CCITM.FILE.NAME$ KEYED RECL CCITM.RECL% AS CCITM.SESS.NUM%                                        ! MMJK
11409: b9b0:        CCITM.OPEN.FLAG$ = "Y"
11410: b9c7: 
11411: b9c7:        CURR.SESS.NUM% = IDF.SESS.NUM%
11412: b9d9:        IF IDF.OPEN.FLAG$ = "Y" THEN BEGIN
11413: b9f7:         IDF.OPEN.FLAG$ = "N"
11414: ba0e:          CLOSE IDF.SESS.NUM%
11415: ba22:        ENDIF
11416: ba2a:        IF END #IDF.SESS.NUM% THEN OPEN.ERROR
11417: ba46:        OPEN IDF.FILE.NAME$ KEYED RECL IDF.RECL% AS IDF.SESS.NUM%                                        ! MMJK
11418: ba72:        IDF.OPEN.FLAG$ = "Y"
11419: ba89: 
11420: ba89:        CURR.SESS.NUM% = IEF.SESS.NUM%
11421: ba9b:        IF IEF.OPEN.FLAG$ = "Y" THEN BEGIN
11422: bab9:         IEF.OPEN.FLAG$ = "N"
11423: bad0:          CLOSE IEF.SESS.NUM%
11424: bae4:        ENDIF
11425: baec:        IF END #IEF.SESS.NUM% THEN OPEN.ERROR
11426: bb08:        OPEN IEF.FILE.NAME$ KEYED RECL IEF.RECL% AS IEF.SESS.NUM%                                        ! MMJK
11427: bb34:        IEF.OPEN.FLAG$ = "Y"
11428: bb4b:        CURR.SUBSCRIPT% = 1
11429: bb5c:        NUM.BARCODES% = 0
11430: bb6d:        WHILE CURR.SUBSCRIPT% <= NUM.STATUS.O.C.X.UODS%              ! 1.4
11431: bb78:          CCUOD.UOD.NUM$ = CCUOD.TABLE$(CURR.SUBSCRIPT%)
11432: bba7:         CURR.SESS.NUM% = CCUOD.SESS.NUM%
11433: bbb9:         CURRENT.KEY$ = UNPACK$(CCUOD.UOD.NUM$)
11434: bbda:          IF READ.CCUOD THEN BEGIN
11435: bbeb:           RE.CHAIN = TRUE
11436: bc01:           RECEIVE.STATE$ = "?"
11437: bc18:           GOTO READ.ERROR
11438: bc23:         ENDIF
11439: bc2b:          GOSUB WRITE.CCWKF.OPEN.CLOSED.HEADER                         ! 1.4
11440: bc3d:          IF CCUOD.NUM.OF.ITEMS%>0 THEN BEGIN
11441: bc52:            CURR.ITEM% = 1
11442: bc63:           WHILE CURR.ITEM% <= CCUOD.NUM.OF.ITEMS%
11443: bc6e:             CCITM.KEY$ = CCUOD.UOD.NUM$ +                             \
11444: bcb4:                          PACK$(FN.Z.PACK(STR$(CURR.ITEM%),4))
11445: bcb4:             CURR.SESS.NUM% = CCITM.SESS.NUM%
11446: bcc6:             CURRENT.KEY$ = UNPACK$(CCUOD.UOD.NUM$)
11447: bce7:              IF READ.CCITM <> 1 THEN GOSUB PROCESS.CCITM.RECORD        \
11448: bd05:               ELSE BEGIN
11449: bd0d:                 RE.CHAIN = TRUE
11450: bd23:                RECEIVE.STATE$ = "?"
11451: bd3a:                GOTO READ.ERROR
11452: bd45:               ENDIF
11453: bd4d:              CURR.ITEM% = CURR.ITEM% + 1
11454: bd5c:           WEND
11455: bd77:         ENDIF
11456: bd7f:          CURR.SUBSCRIPT% = CURR.SUBSCRIPT% + 1
11457: bd8e:        WEND
11458: bda9: 
11459: bda9:       IF CCUOD.OPEN.FLAG$ = "Y" THEN BEGIN                            ! 1.4
11460: bdc7:          CCUOD.OPEN.FLAG$ = "N"                                       ! 1.4
11461: bdde:          CLOSE CCUOD.SESS.NUM%                                        ! 1.4
11462: bdf2:       ENDIF                                                           ! 1.4
11463: bdfa: 
11464: bdfa:       IF CCITM.OPEN.FLAG$ = "Y" THEN BEGIN                            ! 1.4
11465: be18:          CCITM.OPEN.FLAG$ = "N"                                       ! 1.4
11466: be2f:          CLOSE CCITM.SESS.NUM%                                        ! 1.4
11467: be43:       ENDIF                                                           ! 1.4
11468: be4b: 
11469: be4b:       CURR.SUBSCRIPT% = 1                                             ! 1.4
11470: be5c:       CURR.SESS.NUM% = CCLAM.SESS.NUM%                                ! 1.4
11471: be6e:       IF CCLAM.OPEN.FLAG$ = "Y" THEN BEGIN                            ! 1.4
11472: be8c:          CCLAM.OPEN.FLAG$ = "N"                                       ! 1.4
11473: bea3:          CLOSE CCLAM.SESS.NUM%                                        ! 1.4
11474: beb7:       ENDIF                                                           ! 1.4
11475: bebf:       IF END #CCLAM.SESS.NUM% THEN OPEN.ERROR                         ! 1.4
11476: bedb:       OPEN CCLAM.FILE.NAME$ KEYED RECL CCLAM.RECL% AS CCLAM.SESS.NUM% ! 1.4                                       ! MMJK
11477: bf07:       CCLAM.OPEN.FLAG$ = "Y"                                          ! 1.4
11478: bf1e:       WHILE CURR.SUBSCRIPT% <= NUM.OF.DESPATCHED.UODS%                ! 1.4
11479: bf29:             CCLAM.CREDIT.CLAIM.NUM$ = CCLAM.TABLE$(CURR.SUBSCRIPT%)   ! 1.4
11480: bf58:             CURRENT.KEY$ = UNPACK$(CCLAM.CREDIT.CLAIM.NUM$)           ! 1.4
11481: bf79:             IF READ.CCLAM THEN BEGIN                                  ! 1.4
11482: bf8a:                RE.CHAIN = TRUE                                        ! 1.4
11483: bfa0:                RECEIVE.STATE$ = "?"                                   ! 1.4
11484: bfb7:                GOTO READ.ERROR                                        ! 1.4
11485: bfc2:             ENDIF                                                     ! 1.4
11486: bfca:             GOSUB WRITE.CCWKF.DESPATCHED.HEADER                       ! 1.4
11487: bfdc:             CURR.SUBSCRIPT% = CURR.SUBSCRIPT% + 1                     ! 1.4
11488: bfeb:       WEND                                                            ! 1.4
11489: c006: 
11490: c006:       IF CCLAM.OPEN.FLAG$ = "Y" THEN BEGIN                            ! 1.4
11491: c024:          CCLAM.OPEN.FLAG$ = "N"                                       ! 1.4
11492: c03b:          CLOSE CCLAM.SESS.NUM%                                        ! 1.4
11493: c04f:       ENDIF                                                           ! 1.4
11494: c057: 
11495: c057: 
11496: c057:       GOSUB PROCESS.ITEM.STORAGE
11497: c069:       GOSUB PROCESS.BARCODE.TABLE
11498: c07b: 
11499: c07b:       IDF.OPEN.FLAG$ = "N"
11500: c092:       CLOSE IDF.SESS.NUM%
11501: c0a6:       IEF.OPEN.FLAG$ = "N"
11502: c0bd:       CLOSE IEF.SESS.NUM%
11503: c0d1: 
11504: c0d1:     RETURN
11505: c0e1: 
11506: c0e1: \******************************************************************************
11507: c0e1: \***
11508: c0e1: \***   WRITE.CCWKF.OPEN.CLOSED.HEADER:  !1.4 title changed
11509: c0e1: \***
11510: c0e1: \***      prepare the UOD header to be written to the CCWKF
11511: c0e1: \***      write record and trap errors
11512: c0e1: \***
11513: c0e1: \******************************************************************************
11514: c0e1: 
11515: c0e1:     WRITE.CCWKF.OPEN.CLOSED.HEADER:                                     !1.4
11516: c0f1: 
11517: c0f1:       CCWKF.RECORD$ = "RH" +                                            \
11518: c305:                      UNPACK$(CCUOD.CREDIT.CLAIM.NUM$) +               \
11519: c305:                      UNPACK$(CCUOD.UOD.NUM$) +                      \
11520: c305:                     CCUOD.STATUS$ +                                   \
11521: c305:                       FN.Z.PACK(STR$(CCUOD.NUM.OF.ITEMS%),4) +               \
11522: c305:                     FN.INVERT.DATE(UNPACK$(CCUOD.DATE.UOD.OPENED$)) + \
11523: c305:                     CCUOD.SUPPLY.ROUTE$ +                            \
11524: c305:                     CCUOD.DISP.LOCATION$ +                             \
11525: c305:                     CCUOD.BC.LETTER$ +                            \
11526: c305:                     CCUOD.RECALL.NUM$ +                             \
11527: c305:                     CCUOD.AUTHORISATION$ +                            \
11528: c305:                     CCUOD.SUPPLIER$ +                             \
11529: c305:                     RIGHT$(UNPACK$(CCUOD.METHOD.OF.RETURN$),1) +       \
11530: c305:                     RIGHT$(UNPACK$(CCUOD.CARRIER$),1) +               \
11531: c305:                     CCUOD.BIRD.NUM$ +                             \
11532: c305:                     UNPACK$(CCUOD.REASON.NUM$) +                      \
11533: c305:                     UNPACK$(CCUOD.RECEIVING.STORE$) +               \
11534: c305:                     RIGHT$(UNPACK$(CCUOD.DESTINATION$),1) +               \
11535: c305:                     CCUOD.WAREHOUSE.ROUTE$ +                             \
11536: c305:                     RIGHT$(UNPACK$(CCUOD.UOD.TYPE$),1) +               \
11537: c305:                     RIGHT$(UNPACK$(CCUOD.DAMAGE.REASON$),1)
11538: c305: 
11539: c305:       CURR.SESS.NUM% = CCWKF.SESS.NUM%
11540: c317:       CURRENT.KEY$ = ""
11541: c32c:       IF WRITE.CCWKF THEN GOTO WRITE.ERROR
11542: c340: 
11543: c340:     RETURN
11544: c350: 
11545: c350: 
11546: c350: \******************************************************************************
11547: c350: \***
11548: c350: \***   WRITE.CCWKF.DESPATCHED.HEADER:  !1.4 NEW SUBROUTINE
11549: c350: \***
11550: c350: \***      prepare the UOD header to be written to the CCWKF
11551: c350: \***      write record and trap errors
11552: c350: \***
11553: c350: \******************************************************************************
11554: c350: 
11555: c350:     WRITE.CCWKF.DESPATCHED.HEADER:
11556: c360: 
11557: c360:       IF CCLAM.CANC.MARKER$ = "Y" THEN BEGIN
11558: c37e:          STATUS$ = "X"
11559: c395:       ENDIF ELSE BEGIN
11560: c39d:             STATUS$ = "D"
11561: c3b2:       ENDIF
11562: c3ba: 
11563: c3ba:       CCWKF.RECORD$ = "RH" +                                            \
11564: c5cb:                     UNPACK$(CCLAM.CREDIT.CLAIM.NUM$) +               \
11565: c5cb:                     UNPACK$(CCLAM.UOD.NUM$) +                      \
11566: c5cb:                     STATUS$ +                                   \
11567: c5cb:                     FN.Z.PACK(STR$(CCLAM.NUM.OF.ITEMS%),4) +               \
11568: c5cb:                     FN.INVERT.DATE(UNPACK$(CCLAM.DATE.OF.CLAIM$)) + \
11569: c5cb:                     CCLAM.SUPPLY.ROUTE$ +                            \
11570: c5cb:                     CCLAM.DISP.LOCATION$ +                             \
11571: c5cb:                     CCLAM.BC.LETTER$ +                            \
11572: c5cb:                     CCLAM.RECALL.NUM$ +                             \
11573: c5cb:                     CCLAM.AUTHORISATION$ +                            \
11574: c5cb:                     CCLAM.SUPPLIER$ +                             \
11575: c5cb:                     RIGHT$(UNPACK$(CCLAM.METHOD.OF.RETURN$),1) +       \
11576: c5cb:                     RIGHT$(UNPACK$(CCLAM.CARRIER$),1) +               \
11577: c5cb:                     CCLAM.BIRD.NUM$ +                             \
11578: c5cb:                     UNPACK$(CCLAM.REASON.NUM$) +                      \
11579: c5cb:                     UNPACK$(CCLAM.RECEIVING.STORE$) +               \
11580: c5cb:                     RIGHT$(UNPACK$(CCLAM.DESTINATION$),1) +               \
11581: c5cb:                     CCLAM.WAREHOUSE.ROUTE$ +                             \
11582: c5cb:                     RIGHT$(UNPACK$(CCLAM.UOD.TYPE$),1) +               \
11583: c5cb:                     RIGHT$(UNPACK$(CCLAM.DAMAGE.REASON$),1)
11584: c5cb: 
11585: c5cb:       CURR.SESS.NUM% = CCWKF.SESS.NUM%
11586: c5dd:       CURRENT.KEY$ = ""
11587: c5f2:       IF WRITE.CCWKF THEN GOTO WRITE.ERROR
11588: c606: 
11589: c606:     RETURN
11590: c616: 
11591: c616: \******************************************************************************
11592: c616: \***
11593: c616: \***   PROCESS.CCITM.RECORD:
11594: c616: \***
11595: c616: \***     check item record for item code present as opposed to barcode;
11596: c616: \***       set up key and attempt to read record from IDF for description
11597: c616: \***       if read was successful;
11598: c616: \***         store description for later use
11599: c616: \***         if item code is not parent of family then attempt to read IDF
11600: c616: \***           using parent code
11601: c616: \***         if first code was parent or new parent record was retrieved then;
11602: c616: \***           store IDF barcodes in table with reference to items position
11603: c616: \***           if codes are present in IEF (>3 codes) then;
11604: c616: \***             call READ.NEXT.IEF to read next barcode
11605: c616: \***             if read was successful; store barcodes in table
11606: c616: \***           complete loop
11607: c616: \***
11608: c616: \***      create item detail record and move to item storage area
11609: c616: \***
11610: c616: \******************************************************************************
11611: c616: 
11612: c616:     PROCESS.CCITM.RECORD:
11613: c626: 
11614: c626:        ITEM.POS% = ITEM.POS% + 1
11615: c635:        UOD.POS.STRING$ = FN.Z.PACK(STR$(CURR.SUBSCRIPT%),3)
11616: c666:        ITEM.POS.STRING$ = FN.Z.PACK(STR$(ITEM.POS%),4)
11617: c697:        IDF.STNDRD.DESC$ = "* ITEM NOT ON FILE *    "
11618: c6ae: 
11619: c6ae:        IF CCITM.BOOTS.BAR.CODE.FLAG$ = "I" THEN BEGIN                  ! BMJK
11620: c6cf:          IDF.NO.OF.BAR.CODES$ = PACK$("00")
11621: c6eb:          IDF.BOOTS.CODE$ = RIGHT$(CCITM.BOOTS.BAR.CODE$,4)
11622: c710:          CURR.SESS.NUM% = IDF.SESS.NUM%
11623: c722:          CURRENT.KEY$ = IDF.BOOTS.CODE$
11624: c73e:          IF (NOT READ.IDF) THEN BEGIN                                   ! BMJK
11625: c752:           IF CCUOD.STATUS$ = "O" THEN BEGIN                            ! BMJK
11626: c773:              IDF.NUM.BARCODES% = VAL(UNPACK$(IDF.NO.OF.BAR.CODES$))
11627: c798:             BARCODE.DATA$ = "0" + UNPACK$(IDF.FIRST.BAR.CODE$)
11628: c7c2:             BARCODE.INDEX$ = UOD.POS.STRING$ + ITEM.POS.STRING$
11629: c7e8:               GOSUB ADD.TO.BARCODE.STORAGE
11630: c7fa:             IF IDF.NUM.BARCODES% > 1 THEN BEGIN
11631: c809:               BARCODE.DATA$ = "0" + UNPACK$(IDF.SECOND.BAR.CODE$)
11632: c833:               BARCODE.INDEX$ = UOD.POS.STRING$ + ITEM.POS.STRING$
11633: c859:               GOSUB ADD.TO.BARCODE.STORAGE
11634: c86b:             ENDIF
11635: c873:              IF IDF.NUM.BARCODES% > 2 THEN BEGIN
11636: c885:               F11.CURRENT.COUNT% = 1
11637: c896:               F11.NEXT.BAR.CODE$ = IDF.SECOND.BAR.CODE$
11638: c8b4:               MORE.BAR.CODES = TRUE
11639: c8c6:               CURR.SESS.NUM% = IEF.SESS.NUM%
11640: c8d8:               WHILE MORE.BAR.CODES
11641: c8e3:                 RC% = READ.NEXT.IEF(F11.NEXT.BAR.CODE$,                     \
11642: c931:                                          NUM.BARCODES%,                       \
11643: c931:                                   RIGHT$(UNPACK$(IDF.BOOTS.CODE$),7))
11644: c931:                 IF UNPACK$(F11.NEXT.BAR.CODE$) = STRING$(12,"0")            \
11645: c987:                   OR RC% <> 0 THEN MORE.BAR.CODES = FALSE              \
11646: c99b:                 ELSE BEGIN
11647: c9a3:                   BARCODE.DATA$ = "0" + UNPACK$(F11.NEXT.BAR.CODE$)
11648: c9cd:                    BARCODE.INDEX$ = UOD.POS.STRING$ + ITEM.POS.STRING$
11649: c9f3:                   GOSUB ADD.TO.BARCODE.STORAGE
11650: ca05:                 ENDIF
11651: ca0d:               WEND
11652: ca1f:              ENDIF
11653: ca27:            ENDIF
11654: ca31:          ENDIF ELSE IDF.STNDRD.DESC$ = "* ITEM NOT ON FILE *    "             ! BMJK
11655: ca48:        ENDIF
11656: ca50: 
11657: ca50:        CCITM.BOOTS.BAR.CODE$ = RIGHT$(UNPACK$(CCITM.BOOTS.BAR.CODE$),13)
11658: ca85:        ITEM.DATA$ = CCITM.BOOTS.BAR.CODE.FLAG$ +                      \
11659: cad1:                   CCITM.BOOTS.BAR.CODE$ +                            \
11660: cad1:                   FN.Z.PACK(STR$(CCITM.QTY%),4)                       ! BMJK
11661: cad1:        ITEM.DATA.DESC$ = IDF.STNDRD.DESC$ +                            \
11662: cafa:                            UOD.POS.STRING$
11663: cafa:        GOSUB ADD.TO.ITEM.STORAGE
11664: cb0c: 
11665: cb0c:     RETURN
11666: cb1c: 
11667: cb1c: \******************************************************************************
11668: cb1c: \***
11669: cb1c: \***   ADD.TO.BARCODE.STORAGE:
11670: cb1c: \***
11671: cb1c: \***     increment barcode counter
11672: cb1c: \***     add data onto end of current storage string
11673: cb1c: \***     check for overflow of barcode storage, abort program if found
11674: cb1c: \***
11675: cb1c: \******************************************************************************
11676: cb1c: 
11677: cb1c:     ADD.TO.BARCODE.STORAGE:
11678: cb2c: 
11679: cb2c:        NUM.BARCODES% = NUM.BARCODES% + 1
11680: cb3b:        IF NUM.BARCODES%>5000 THEN BEGIN
11681: cb4e:         SB.UNIQUE$ = "BC STORAGE"
11682: cb63:         GOSUB LOG.TABLE.FULL.ERROR
11683: cb75:        ENDIF
11684: cb7d:        BARCODE.TABLE$(NUM.BARCODES%) = BARCODE.DATA$
11685: cba9:        BARCODE.POS.TABLE$(NUM.BARCODES%) = BARCODE.INDEX$
11686: cbd5: 
11687: cbd5:     RETURN
11688: cbe5: 
11689: cbe5: \******************************************************************************
11690: cbe5: \***
11691: cbe5: \***   ADD.TO.ITEM.STORAGE:
11692: cbe5: \***
11693: cbe5: \***     increment item counter
11694: cbe5: \***     add data onto end of current storage string
11695: cbe5: \***     check for overflow of current storage string, increment storage if req
11696: cbe5: \***     check for overflow of all storage areas, abort program if found
11697: cbe5: \***
11698: cbe5: \******************************************************************************
11699: cbe5: 
11700: cbe5:     ADD.TO.ITEM.STORAGE:
11701: cbf5: 
11702: cbf5:        NUM.ITEMS% = NUM.ITEMS% + 1
11703: cc04:        ITEM.STORAGE$ = ITEM.STORAGE$ + ITEM.DATA$
11704: cc30:        ITEM.DESC.STORAGE$ = ITEM.DESC.STORAGE$ + ITEM.DATA.DESC$
11705: cc5c:        IF NUM.ITEMS% > 2400 THEN BEGIN
11706: cc6f:         SB.UNIQUE$ = "IT STORAGE"
11707: cc84:         GOSUB LOG.TABLE.FULL.ERROR
11708: cc96:        ENDIF
11709: cc9e: 
11710: cc9e:     RETURN
11711: ccae: 
11712: ccae: \******************************************************************************
11713: ccae: \***
11714: ccae: \***   PROCESS.ITEM.STORAGE:
11715: ccae: \***
11716: ccae: \***     process storage area sequentially, writing each record to the CCWKF
11717: ccae: \***
11718: ccae: \******************************************************************************
11719: ccae: 
11720: ccae:     PROCESS.ITEM.STORAGE:
11721: ccbe: 
11722: ccbe:       IF NUM.ITEMS%>0 THEN BEGIN
11723: ccd3:         ITEM.POS% = 1
11724: cce4:         WHILE ITEM.POS%<=NUM.ITEMS%
11725: ccef:           CCWKF.RECORD$ = "RD" +                                    \BMJK
11726: cd5a:                          MID$(ITEM.STORAGE$,1+((ITEM.POS%-1)*18),18) +       \BMJK
11727: cd5a:                           MID$(ITEM.DESC.STORAGE$,1+((ITEM.POS%-1)*27),27)!BMJK
11728: cd5a:           CURRENT.KEY$ = ""
11729: cd6f:          CURR.SESS.NUM% = CCWKF.SESS.NUM%
11730: cd81:           IF WRITE.CCWKF THEN GOTO WRITE.ERROR
11731: cd95:          ITEM.POS% = ITEM.POS% + 1
11732: cda4:        WEND
11733: cdbf:       ENDIF
11734: cdc7: 
11735: cdc7:     RETURN
11736: cdd7: 
11737: cdd7: \******************************************************************************
11738: cdd7: \***
11739: cdd7: \***   PROCESS.BARCODE.TABLE:
11740: cdd7: \***
11741: cdd7: \***     if >1 entry sort contents into numerical order
11742: cdd7: \***     process table sequentially, writing each record to the CCWKF
11743: cdd7: \***
11744: cdd7: \******************************************************************************
11745: cdd7: 
11746: cdd7:     PROCESS.BARCODE.TABLE:
11747: cde7: 
11748: cde7:        IF NUM.BARCODES%>0 THEN BEGIN
11749: cdf9:          IF NUM.BARCODES%>1 THEN GOSUB SORT.BARCODE.TABLES
11750: ce15:         GOSUB WRITE.BARCODES.TO.CCWKF
11751: ce27:        ENDIF
11752: ce2f: 
11753: ce2f:     RETURN
11754: ce3f: 
11755: ce3f: \******************************************************************************
11756: ce3f: \***
11757: ce3f: \***   SORT.BARCODE.TABLES:
11758: ce3f: \***
11759: ce3f: \***      sort bar code table and corresponding item position table
11760: ce3f: \***      into ascending order using COMBSORT.
11761: ce3f: \***
11762: ce3f: \******************************************************************************
11763: ce3f: 
11764: ce3f:     SORT.BARCODE.TABLES:
11765: ce4f: 
11766: ce4f:        MAX% = NUM.BARCODES%
11767: ce6a:        FINISHED = FALSE
11768: ce7c: 
11769: ce7c:        GAP = MAX%
11770: ce97:        WHILE NOT FINISHED
11771: cea2:          GAP = INT(GAP / 1.3)
11772: cecf:          IF GAP = 0 THEN GAP = 1
11773: cf06:          IF GAP = 9 OR GAP = 10 THEN GAP = 11
11774: cf7b:          SWAPPED = FALSE
11775: cf8d:          FOR A%=1 TO (MAX% - GAP)
11776: cfa5:            B% = A% + GAP
11777: cfdc:            IF (BARCODE.TABLE$(A%)+BARCODE.POS.TABLE$(A%)) >               \ BMJK
11778: d073:              (BARCODE.TABLE$(B%)+BARCODE.POS.TABLE$(B%)) THEN BEGIN    ! BMJK
11779: d073:              TEMP$ = BARCODE.TABLE$(A%)
11780: d09e:             BARCODE.TABLE$(A%) = BARCODE.TABLE$(B%)
11781: d0da:              BARCODE.TABLE$(B%) = TEMP$
11782: d104:              TEMP$ = BARCODE.POS.TABLE$(A%)
11783: d12f:             BARCODE.POS.TABLE$(A%) = BARCODE.POS.TABLE$(B%)
11784: d16b:              BARCODE.POS.TABLE$(B%) = TEMP$
11785: d195:              SWAPPED = TRUE
11786: d1a7:           ENDIF
11787: d1af:          NEXT A%
11788: d1f9:          IF (NOT SWAPPED) AND GAP = 1 THEN FINISHED = TRUE
11789: d23d:        WEND
11790: d24f: 
11791: d24f:     RETURN
11792: d25f: 
11793: d25f: \******************************************************************************
11794: d25f: \***
11795: d25f: \***   WRITE.BARCODES.TO.CCWKF:
11796: d25f: \***
11797: d25f: \***     perform loop to process contents of barcode holding table
11798: d25f: \***       format CCWKF record and write to file
11799: d25f: \***     complete loop
11800: d25f: \***
11801: d25f: \******************************************************************************
11802: d25f: 
11803: d25f:     WRITE.BARCODES.TO.CCWKF:
11804: d26f: 
11805: d26f:       CURR.REC% = 1
11806: d280:       WHILE CURR.REC% <= NUM.BARCODES%
11807: d28b:         CCWKF.RECORD$ = "RB" +                                          \
11808: d2d7:                           BARCODE.TABLE$(CURR.REC%) +                      \
11809: d2d7:                      BARCODE.POS.TABLE$(CURR.REC%)
11810: d2d7:         CURRENT.KEY$ = ""
11811: d2ec:         CURR.SESS.NUM% = CCWKF.SESS.NUM%
11812: d2fe:         IF WRITE.CCWKF THEN GOTO WRITE.ERROR
11813: d312:         CURR.REC% = CURR.REC% + 1
11814: d321:       WEND
11815: d33c: 
11816: d33c:     RETURN
11817: d34c: 
11818: d34c: \******************************************************************************
11819: d34c: \***
11820: d34c: \***   EXTRACT.ALL.BUSINESS.CENTRES:
11821: d34c: \***
11822: d34c: \***     open BCSMF as direct
11823: d34c: \***     perform loop to read records out of file sequentially
11824: d34c: \***       if record is present that is not null or spaces for BC then;
11825: d34c: \***         format and write record to CCWKF
11826: d34c: \***     complete loop
11827: d34c: \***     close file
11828: d34c: \***
11829: d34c: \******************************************************************************
11830: d34c: 
11831: d34c:     EXTRACT.ALL.BUSINESS.CENTRES:
11832: d35c: 
11833: d35c:       IF BCSMF.OPEN.FLAG$ = "Y"THEN BEGIN
11834: d37a:         BCSMF.OPEN.FLAG$ = "N"
11835: d391:        CLOSE BCSMF.SESS.NUM%
11836: d3a5:       ENDIF
11837: d3ad: 
11838: d3ad:       CURRENT.KEY$ = ""
11839: d3c2:       CURR.SESS.NUM% = BCSMF.SESS.NUM%
11840: d3d4:       IF END #BCSMF.SESS.NUM% THEN OPEN.ERROR
11841: d3f0:       OPEN BCSMF.FILE.NAME$ RECL 512 AS BCSMF.SESS.NUM%       NOWRITE NODEL
11842: d419:       BCSMF.OPEN.FLAG$ = "Y"
11843: d430: 
11844: d430:       NUM.SECTORS% = SIZE(BCSMF.FILE.NAME$)/512
11845: d458:       NUM.RECORDS% = 508 / 33
11846: d469:       NUM.BC.EXTRACTED% = 0
11847: d47a: 
11848: d47a:       SECTOR% = 2
11849: d48b:       WHILE SECTOR%<=NUM.SECTORS%
11850: d496:         READ FORM "T5,C508";#BCSMF.SESS.NUM%,SECTOR%;SECTOR$
11851: d4cf:         REC.NUM% = 1
11852: d4e0:        WHILE (REC.NUM%<=NUM.RECORDS%)
11853: d4eb:           BCSMF.RECORD$ = LEFT$(SECTOR$,33)
11854: d512:           SECTOR$ = RIGHT$(SECTOR$,LEN(SECTOR$)-33)
11855: d54a:           IF LEFT$(BCSMF.RECORD$,1)=PACK$("00") THEN                      \
11856: d584:            REC.NUM%=NUM.RECORDS%                                   \
11857: d59d:          ELSE IF (LEFT$(BCSMF.RECORD$,1)<>" ") AND                      \
11858: d61a:                  (MID$(BCSMF.RECORD$,29,1)<>"Y") THEN                      \
11859: d61a:            GOSUB WRITE.BC.RECORD.TO.CCWKF
11860: d62c:          REC.NUM% = REC.NUM% + 1
11861: d63b:         WEND
11862: d656:       SECTOR% = SECTOR% + 1
11863: d665:       WEND
11864: d67d: 
11865: d67d:       BCSMF.OPEN.FLAG$ = "N"
11866: d694:       CLOSE BCSMF.SESS.NUM%
11867: d6a8: 
11868: d6a8:     RETURN
11869: d6b8: 
11870: d6b8: \******************************************************************************
11871: d6b8: \***
11872: d6b8: \***   WRITE.BC.RECORD.TO.CCWKF:
11873: d6b8: \***
11874: d6b8: \***     format record for writing to CCWKF
11875: d6b8: \***     attempt to write record to file
11876: d6b8: \***
11877: d6b8: \******************************************************************************
11878: d6b8: 
11879: d6b8:      WRITE.BC.RECORD.TO.CCWKF:
11880: d6c8: 
11881: d6c8:        CCWKF.RECORD$ = "BC" +                                           \
11882: d6f6:                      LEFT$(BCSMF.RECORD$,15)
11883: d6f6:        CURRENT.KEY$ = ""
11884: d70b:        CURR.SESS.NUM% = CCWKF.SESS.NUM%
11885: d71d:        IF WRITE.CCWKF THEN GOTO WRITE.ERROR
11886: d731:        NUM.BC.EXTRACTED% = NUM.BC.EXTRACTED% + 1
11887: d740: 
11888: d740:      RETURN
11889: d750: 
11890: d750: \******************************************************************************
11891: d750: \***
11892: d750: \***   WRITE.CCWKF.TRAILER.AND.CLOSE.FILE:
11893: d750: \***
11894: d750: \***     close CCTRL file if already open
11895: d750: \***     open CCTRL and extract current credit claiming number
11896: d750: \***     close CCTRL after use
11897: d750: \***
11898: d750: \***     format CCWKF record and write to file
11899: d750: \***
11900: d750: \***     issue close to CCWKF
11901: d750: \***
11902: d750: \******************************************************************************
11903: d750: 
11904: d750:     WRITE.CCWKF.TRAILER.AND.CLOSE.FILE:
11905: d760: 
11906: d760:       IF CCTRL.OPEN.FLAG$ = "Y" THEN BEGIN
11907: d77e:         CCTRL.OPEN.FLAG$ = "N"
11908: d795:        CLOSE CCTRL.SESS.NUM%
11909: d7a9:       ENDIF
11910: d7b1: 
11911: d7b1:       CURRENT.KEY$ = ""
11912: d7c6:       CURR.SESS.NUM% = CCTRL.SESS.NUM%
11913: d7d8:       IF END #CCTRL.SESS.NUM% THEN OPEN.ERROR
11914: d7f4:       OPEN CCTRL.FILE.NAME$ DIRECT RECL CCTRL.RECL% AS CCTRL.SESS.NUM% !BMJK
11915: d820:       CCTRL.OPEN.FLAG$ = "Y"
11916: d837:       CCTRL.REC.NUM% = 1
11917: d848:       CURRENT.KEY$ = "1"
11918: d85d:       IF READ.CCTRL THEN GOTO READ.ERROR
11919: d871: 
11920: d871:       CCTRL.OPEN.FLAG$ = "N"
11921: d888:       CLOSE CCTRL.SESS.NUM%
11922: d89c: 
11923: d89c:       NUM.OF.UODS.TRANSMITTED% = NUM.STATUS.O.C.X.UODS% +               \1.4
11924: d8b5:                                  NUM.OF.DESPATCHED.UODS%                !1.4
11925: d8b5:       CCWKF.RECORD$ = "RR" +                                            \
11926: d987:                     FN.Z.PACK(STR$(NUM.OF.UODS.TRANSMITTED%),3) +       \1.4
11927: d987:                     FN.Z.PACK(STR$(NUM.ITEMS%),4) +                     \
11928: d987:                     FN.Z.PACK(STR$(NUM.BARCODES%),4) +                  \
11929: d987:                        FN.Z.PACK(STR$(NUM.BC.EXTRACTED%),2) +                      \
11930: d987:                     UNPACK$(CCTRL.CREDIT.CLAIM.NUM$)
11931: d987:       CURRENT.KEY$ = ""
11932: d99c:       CURR.SESS.NUM% = CCWKF.SESS.NUM%
11933: d9ae:       IF WRITE.CCWKF THEN GOTO WRITE.ERROR
11934: d9c2: 
11935: d9c2:       CCWKF.OPEN.FLAG$ = "N"
11936: d9d9:       CLOSE CCWKF.SESS.NUM%
11937: d9ed: 
11938: d9ed:     RETURN
11939: d9fd: 
11940: d9fd: \******************************************************************************
11941: d9fd: \***
11942: d9fd: \***   TRANSMIT.CCWKF.VIA.PSS38:
11943: d9fd: \***
11944: d9fd: \***     set PIPE.OUT$ to "R" to instruct PSS38 to send the CCWKF to the LDT
11945: d9fd: \***     call routine to transmit the pipe
11946: d9fd: \***
11947: d9fd: \******************************************************************************
11948: d9fd: 
11949: d9fd:     TRANSMIT.CCWKF.VIA.PSS38:
11950: da0d: 
11951: da0d:       PIPE.OUT$ = "R"
11952: da24:       GOSUB SEND.TO.PSS38
11953: da36: 
11954: da36:     RETURN
11955: da46: 
11956: da46: \******************************************************************************
11957: da46: \***
11958: da46: \***   LOG.AN.EVENT.92:
11959: da46: \***
11960: da46: \***     prepare unique data with file number and exp/act records
11961: da46: \***
11962: da46: \******************************************************************************
11963: da46: 
11964: da46:     LOG.AN.EVENT.92:
11965: da56: 
11966: da56:         SB.EVENT.NO% = 92
11967: da63:        SB.UNIQUE$ = CHR$(SHIFT(FILE.NUM%,8)) +                          \
11968: db71:                     CHR$(SHIFT(FILE.NUM%,0)) +                         \
11969: db71:                    PACK$(RIGHT$(STRING$(8,"0")+STR$(EXPECTED.NUM%),8))+\
11970: db71:                    PACK$(RIGHT$(STRING$(8,"0")+STR$(ACTUAL.NUM%),8))
11971: db71:        SB.MESSAGE$ = ""
11972: db86:        GOSUB SB.LOG.AN.EVENT
11973: db98: 
11974: db98:     RETURN
11975: dba8: 
11976: dba8: \******************************************************************************
11977: dba8: \***
11978: dba8: \***   LOG.TO.AUDIT.FILE
11979: dba8: \***
11980: dba8: \***   RETURN
11981: dba8: \***
11982: dba8: \******************************************************************************
11983: dba8: 
11984: dba8:    LOG.TO.AUDIT.FILE:
11985: dbb8: 
11986: dbb8:       IF CSR.AUDIT.OPEN.FLAG$ = "N" THEN BEGIN
11987: dbd6:          IF END #CSR.AUDIT.SESS.NUM% THEN AUDIT.FAIL
11988: dbf2:          OPEN CSR.AUDIT.FILE$ AS CSR.AUDIT.SESS.NUM% APPEND
11989: dc19:          CSR.AUDIT.OPEN.FLAG$ = "Y"
11990: dc30:       ENDIF
11991: dc38: 
11992: dc38:       CSR.AUDIT.DATA$ = "[PORT " + MONITORED.PORT$ + "] " +              \BMJK
11993: dc6c:                         CSR.AUDIT.DATA$                                   !BMJK
11994: dc6c:       PRINT USING "&"; #CSR.AUDIT.SESS.NUM%;CSR.AUDIT.DATA$
11995: dc9b: 
11996: dc9b:    AUDIT.FAIL:
11997: dcab: 
11998: dcab:    RETURN
11999: dcbb: 
12000: dcbb: \******************************************************************************
12001: dcbb: \***
12002: dcbb: \***   LOG.TO.LDTAF.FILE
12003: dcbb: \***
12004: dcbb: \******************************************************************************
12005: dcbb: 
12006: dcbb:    LOG.TO.LDTAF.FILE:
12007: dccb: 
12008: dccb:         CURRENT.KEY$ = ""
12009: dce0:        CURR.SESS.NUM% = LDTAF.SESS.NUM%
12010: dcf2:         IF LDTAF.OPEN.FLAG$ <> "Y" THEN BEGIN
12011: dd10:            IF END #LDTAF.SESS.NUM% THEN CREATE.LDTAF.FILE
12012: dd2c:            OPEN LDTAF.FILE.NAME$ AS LDTAF.SESS.NUM% APPEND
12013: dd53:            LDTAF.OPEN.FLAG$ = "Y"
12014: dd6a:         ENDIF
12015: dd72:         IF LDTAF.LINK.TYPE% <> 0 THEN                                    \
12016: dd84:          IF WRITE.LDTAF THEN GOTO WRITE.ERROR
12017: dd98:        LDTAF.OPEN.FLAG$ = "N"
12018: ddaf:        CLOSE LDTAF.SESS.NUM%
12019: ddc3: 
12020: ddc3:    RETURN
12021: ddd3: 
12022: ddd3:    CREATE.LDTAF.FILE:
12023: dde3: 
12024: dde3:        IF END #LDTAF.SESS.NUM% THEN CREATE.ERROR
12025: ddff:         CREATE POSFILE LDTAF.FILE.NAME$ AS LDTAF.SESS.NUM%               \
12026: de25:           MIRRORED ATCLOSE
12027: de25:         LDTAF.OPEN.FLAG$ = "Y"
12028: de3c:         IF LDTAF.LINK.TYPE% <> 0 THEN                                    \
12029: de4e:          IF WRITE.LDTAF THEN GOTO WRITE.ERROR
12030: de62:         LDTAF.OPEN.FLAG$ = "N"
12031: de79:        CLOSE LDTAF.SESS.NUM%
12032: de8d: 
12033: de8d:    RETURN
12034: de9d: 
12035: de9d: \******************************************************************************
12036: de9d: \***
12037: de9d: \***   LOG.TABLE.FULL.ERROR:
12038: de9d: \***
12039: de9d: \***     prepare unique data with failing table description
12040: de9d: \***
12041: de9d: \******************************************************************************
12042: de9d: 
12043: de9d:     LOG.TABLE.FULL.ERROR:
12044: dead: 
12045: dead:         SB.EVENT.NO% = 126
12046: deba:        SB.MESSAGE$ = ""
12047: decf:        GOSUB SB.LOG.AN.EVENT
12048: dee1:         RECEIVE.STATE$ = "*"
12049: def8:        GOTO MODULE.EXIT
12050: df03: 
12051: df03:     RETURN
12052: df13: 
12053: df13: \******************************************************************************
12054: df13: \******************************************************************************
12055: df13: \***
12056: df13: \***              L D T    H A N D L I N G    R O U T I N E S
12057: df13: \***
12058: df13: \******************************************************************************
12059: df13: \******************************************************************************
12060: df13: 
12061: df13: \******************************************************************************
12062: df13: \***
12063: df13: \***   SEND.TO.PSS38:
12064: df13: \***
12065: df13: \***      transmit data to PSS38 (data contained in PIPE.OUT$)
12066: df13: \***
12067: df13: \******************************************************************************
12068: df13: 
12069: df13:    SEND.TO.PSS38:
12070: df23: 
12071: df23:       IF END# PIPEI.SESS.NUM% THEN WRITE.ERROR
12072: df41:       CURR.SESS.NUM% = PIPEI.SESS.NUM%
12073: df53:       WRITE# PIPEI.SESS.NUM%; PIPE.OUT$
12074: df7b: 
12075: df7b:    RETURN
12076: df8b: 
12077: df8b: \******************************************************************************
12078: df8b: \***
12079: df8b: \***   HOLD.LDT:
12080: df8b: \***
12081: df8b: \***      send a hold LDT command to PSS38
12082: df8b: \***
12083: df8b: \******************************************************************************
12084: df8b: 
12085: df8b:    HOLD.LDT:
12086: df9b: 
12087: df9b:       PIPE.OUT$ = "HY"
12088: dfb2:       GOSUB SEND.TO.PSS38
12089: dfc4:       HOLD.FLAG$ = "Y"
12090: dfdb: 
12091: dfdb:    RETURN
12092: dfeb: 
12093: dfeb: \******************************************************************************
12094: dfeb: \***
12095: dfeb: \***   RELEASE.LDT:
12096: dfeb: \***
12097: dfeb: \***      send a release LDT command to PSS38
12098: dfeb: \***
12099: dfeb: \******************************************************************************
12100: dfeb: 
12101: dfeb:    RELEASE.LDT:
12102: dffb: 
12103: dffb:       PIPE.OUT$ = "HN"
12104: e012:       GOSUB SEND.TO.PSS38
12105: e024:       HOLD.FLAG$ = "N"
12106: e03b: 
12107: e03b:    RETURN
12108: e04b: 
12109: e04b: \****************************************************************************
12110: e04b: \***
12111: e04b: \***   GET MATRIX
12112: e04b: \***
12113: e04b: \***   Open STKIG file
12114: e04b: \***   While Not EOF
12115: e04b: \***      Read STKIG record
12116: e04b: \***      If 'ALL   ' Then
12117: e04b: \***         Set All Products flag
12118: e04b: \***      Else
12119: e04b: \***         If 'X     ' Then
12120: e04b: \***            Store record in Business Centre array
12121: e04b: \***         Else
12122: e04b: \***            If 'XX    ' Then
12123: e04b: \***               Store record in Concept Group array
12124: e04b: \***            Else
12125: e04b: \***               If 'XXXXXX' Then
12126: e04b: \***                  Store record in Product Group array
12127: e04b: \***
12128: e04b: \***   Close STKIG file
12129: e04b: \***
12130: e04b: \****************************************************************************
12131: e04b: 
12132: e04b: GET.MATRIX:
12133: e05b: 
12134: e05b:        IF END# STKIG.SESS.NUM% THEN OPEN.ERROR
12135: e077:        CURR.SESS.NUM% = STKIG.SESS.NUM%
12136: e089:        OPEN STKIG.FILE.NAME$ DIRECT RECL STKIG.RECL% AS STKIG.SESS.NUM% \
12137: e0b8:                NODEL
12138: e0b8: 
12139: e0b8:        STKIG.RECORD.NUM% = 1
12140: e0cf:        BC% = 1
12141: e0e0:        CG% = 1
12142: e0f1:        PG% = 1
12143: e102:        ALL.PRODUCTS = 0
12144: e112:        STKIG.DATA$ = ""
12145: e129: 
12146: e129:        WHILE 1 = 1
12147: e134: 
12148: e134:            RC% = READ.STKIG
12149: e148:            IF RC% <> 0 THEN GOTO END.MATRIX
12150: e15d: 
12151: e15d:            IF STKIG.DATA$ = "ALL   " THEN BEGIN
12152: e17b:               ALL.PRODUCTS = 1
12153: e18b:               GOTO END.MATRIX
12154: e199:            ENDIF ELSE BEGIN
12155: e1a1:               IF RIGHT$(STKIG.DATA$,5) = "     " THEN BEGIN
12156: e1d4:                  BUSINESS.CENTRES$(BC%) = LEFT$(STKIG.DATA$,1)
12157: e20c:                  BC% = BC% + 1
12158: e21e:               ENDIF ELSE BEGIN
12159: e226:                  IF RIGHT$(STKIG.DATA$,4) = "    " THEN BEGIN
12160: e259:                     CONCEPT.GROUPS$(CG%) = LEFT$(STKIG.DATA$,2)
12161: e291:                     CG% = CG% + 1
12162: e2a2:                  ENDIF ELSE BEGIN
12163: e2aa:                     PRODUCT.GROUPS$(PG%) = STKIG.DATA$
12164: e2d9:                     PG% = PG% + 1
12165: e2e8:                  ENDIF
12166: e2f0:               ENDIF
12167: e2f8:            ENDIF
12168: e300: 
12169: e300: 
12170: e300:            STKIG.RECORD.NUM% = STKIG.RECORD.NUM% + 1
12171: e319: 
12172: e319:        WEND
12173: e324: 
12174: e324: END.MATRIX:
12175: e334: 
12176: e334:        CLOSE STKIG.SESS.NUM%
12177: e348: 
12178: e348: RETURN
12179: e358: 
12180: e358: \******************************************************************************
12181: e358: \******************************************************************************
12182: e358: \***                                                                        ***
12183: e358: \***                                                                        ***
12184: e358: \***   L O W   L E V E L   S U B R O U T I N E S                            ***
12185: e358: \***                                                                        ***
12186: e358: \***                                                                        ***
12187: e358: \***   - SB.FILE.UTILS                                                      ***
12188: e358: \***   - SB.BG.MESSAGE                                                      ***
12189: e358: \***   - SB.LOG.AN.EVENT                                                    ***
12190: e358: \***   - SB.FORMAT.ERROR.DATA                                               ***
12191: e358: \***   - SB.FILE.OPEN.ERROR                                                 ***
12192: e358: \***   - SB.FILE.READ.ERROR                                                 ***
12193: e358: \***   - SB.FILE.WRITE.ERROR                                                ***
12194: e358: \***                                                                        ***
12195: e358: \******************************************************************************
12196: e358: \******************************************************************************
12197: e358: 
12198: e358: \******************************************************************************
12199: e358: \***
12200: e358: \***   Subroutine : SB.FILE.UTILS
12201: e358: \***
12202: e358: \***   Purpose    : Allocate / report / de-allocate a file session number
12203: e358: \***
12204: e358: \***   Parameters : 2 or 3 (depending on action)
12205: e358: \***
12206: e358: \***      SB.ACTION$  = "O" for allocate file session number
12207: e358: \***                    "R" for report file session number
12208: e358: \***                    "C" for de-allocate file session number
12209: e358: \***      SB.INTEGER% = file reporting number for action "O" or
12210: e358: \***                  = file session number for actions "R" or "C"
12211: e358: \***
12212: e358: \***      SB.STRING$  = logical file name for action "O" or
12213: e358: \***                    null ("") for actions "R" and "C"
12214: e358: \***
12215: e358: \***   Output     : 1 or 2 (depending on action)
12216: e358: \***      SB.FILE.SESS.NUM% = file session number for action "O" or
12217: e358: \***                          undefined for action "C"
12218: e358: \***      or
12219: e358: \***      SB.FILE.REP.NUM%  = file reporting number for action "R" or
12220: e358: \***                          undefined for action "C"
12221: e358: \***
12222: e358: \***   Error action : log event 48 and end program
12223: e358: \***
12224: e358: \******************************************************************************
12225: e358: 
12226: e358:    SB.FILE.UTILS:
12227: e368: 
12228: e368:       RC% = SESS.NUM.UTILITY(SB.ACTION$,                            \
12229: e393:                           SB.INTEGER%,                            \
12230: e393:                           SB.STRING$ )
12231: e393: 
12232: e393:       IF RC% <> 0 THEN BEGIN
12233: e3a5:          SB.EVENT.NO% = 48
12234: e3b2:         SB.UNIQUE$ = FN.Z.PACK(STR$(F20.INTEGER.FILE.NO%), 10)
12235: e3e3:         SB.MESSAGE$ = "SESSION NUMBER ALLOCATION ROUTINE FAILED"
12236: e3f8:         GOSUB SB.LOG.AN.EVENT
12237: e40a:         GOTO PROGRAM.EXIT
12238: e415:       ENDIF
12239: e41d: 
12240: e41d:       IF SB.ACTION$ = "O" THEN                                          \
12241: e438:          SB.FILE.SESS.NUM% = F20.INTEGER.FILE.NO%
12242: e44a:       IF SB.ACTION$ = "R" THEN                                          \
12243: e465:          SB.FILE.REP.NUM% = F20.INTEGER.FILE.NO%
12244: e477: 
12245: e477:    RETURN
12246: e487: 
12247: e487: 
12248: e487: \******************************************************************************
12249: e487: \***
12250: e487: \***   Subroutine : SB.BG.MESSAGE
12251: e487: \***
12252: e487: \***   Purpose    : Display a message to the background screen
12253: e487: \***
12254: e487: \***   Parameters : 1
12255: e487: \***
12256: e487: \***      SB.MESSAGE$ = message to be displayed (message will be truncated to
12257: e487: \***                    46 characters if the message is longer than 46 chars)
12258: e487: \***                    Minus the port letter.
12259: e487: \***
12260: e487: \***   Output     : 1
12261: e487: \***      SB.MESSAGE$ = null
12262: e487: \***
12263: e487: \***   Error action : log an event 23 and end program
12264: e487: \***
12265: e487: \******************************************************************************
12266: e487: 
12267: e487:    SB.BG.MESSAGE:
12268: e497: 
12269: e497:       IF SB.MESSAGE$ = LAST.MESSAGE$ THEN RETURN
12270: e4c1:       LAST.MESSAGE$ = SB.MESSAGE$
12271: e4dc: 
12272: e4dc:       SB.MESSAGE$ = MONITORED.PORT$ + ": " + SB.MESSAGE$
12273: e507:       SB.MESSAGE$ = LEFT$(SB.MESSAGE$ + STRING$(46, " "), 46)
12274: e551:       CALL ADXSERVE( ADX.RET.CODE%, 26, 0, SB.MESSAGE$)
12275: e589: 
12276: e589:       IF ADX.RET.CODE% <> 0 THEN BEGIN
12277: e5a4:          SB.EVENT.NO% = 23
12278: e5b1:         SB.UNIQUE$ = FN.Z.PACK(STR$(ADX.RET.CODE%),5) + "04   "
12279: e5f2:         SB.MESSAGE$ = ""
12280: e607:         GOSUB SB.LOG.AN.EVENT
12281: e619:       ENDIF
12282: e621: 
12283: e621:       SB.MESSAGE$ = ""
12284: e636: 
12285: e636:    RETURN
12286: e646: 
12287: e646: 
12288: e646: \******************************************************************************
12289: e646: \***
12290: e646: \***   Subroutine : SB.LOG.AN.EVENT
12291: e646: \***
12292: e646: \***   Purpose    : General routine to log an event using passed data. If
12293: e646: \***                program has been started manually for a re-run then also
12294: e646: \***                display a message on the background screen.
12295: e646: \***                The event will be preceded by one indicating the port
12296: e646: \***                being monitored by the program in error.
12297: e646: \***
12298: e646: \***   Parameters : 2
12299: e646: \***
12300: e646: \***      SB.EVENT.NO% = number of event to be logged
12301: e646: \***      SB.UNIQUE$   = 10 byte block of data unique to event
12302: e646: \***
12303: e646: \***   Output     : none
12304: e646: \***
12305: e646: \***   Error action : none
12306: e646: \***
12307: e646: \******************************************************************************
12308: e646: 
12309: e646:    SB.LOG.AN.EVENT:
12310: e656: 
12311: e656:       MESSAGE.NO% = 0
12312: e664:       UNIQUE.2$ = ""
12313: e679: 
12314: e679:       PORT.STRING$ = "PORT : " + MONITORED.PORT$ + "  "
12315: e6a2:       PORT.EVENT% = 75
12316: e6af: 
12317: e6af:       RC% = APPLICATION.LOG(MESSAGE.NO%,                            \
12318: e6e2:                          PORT.STRING$,                                   \
12319: e6e2:                          UNIQUE.2$,                                   \
12320: e6e2:                          PORT.EVENT% )
12321: e6e2: 
12322: e6e2:       RC% = APPLICATION.LOG(MESSAGE.NO%,                            \
12323: e712:                          SB.UNIQUE$,                                   \
12324: e712:                          UNIQUE.2$,                                   \
12325: e712:                          SB.EVENT.NO% )
12326: e712: 
12327: e712:    RETURN
12328: e722: 
12329: e722: 
12330: e722: \******************************************************************************
12331: e722: \***
12332: e722: \***   Subroutine : SB.FORMAT.ERROR.DATA
12333: e722: \***
12334: e722: \***   Purpose    : General routine to format the common error reporting
12335: e722: \***                data
12336: e722: \***
12337: e722: \***   Parameters : 0
12338: e722: \***
12339: e722: \***   Output     :
12340: e722: \***      SB.ERRS$   = ERRN converted to a 4 byte string
12341: e722: \***      SB.ERRL$   = ERRL zero packed up to 6 bytes
12342: e722: \***      SB.ERRF$   = ERRF converted to a reporting number (1 byte)
12343: e722: \***
12344: e722: \***   Error action : if hex conversion or string conversion fails then the
12345: e722: \***                  program ends
12346: e722: \***
12347: e722: \******************************************************************************
12348: e722: 
12349: e722:    SB.FORMAT.ERROR.DATA:
12350: e732: 
12351: e732:       RC% = CONV.TO.HEX( ERRN )
12352: e752:       IF RC% <> 0 THEN                                                 \
12353: e764:          GOTO PROGRAM.EXIT
12354: e76f: 
12355: e76f:       RC% = CONV.TO.STRING(0,                                          \
12356: e793:                         ERRN )
12357: e793:       IF RC% <> 0 THEN                                                 \
12358: e7a5:          GOTO PROGRAM.EXIT
12359: e7b0:       SB.ERRS$ = F17.RETURNED.STRING$
12360: e7cc: 
12361: e7cc:       SB.ERRL$ = FN.Z.PACK(STR$(ERRL), 6)
12362: e7fb:       SB.ACTION$ = "R" : SB.INTEGER% = ERRF% : SB.STRING$ = ""
12363: e825:       GOSUB SB.FILE.UTILS
12364: e837:       SB.ERRF$ = CHR$(SHIFT(SB.FILE.REP.NUM%,8)) +                      \
12365: e880:                  CHR$(SHIFT(SB.FILE.REP.NUM%,0))
12366: e880: 
12367: e880:    RETURN
12368: e890: 
12369: e890: 
12370: e890: \******************************************************************************
12371: e890: \***
12372: e890: \***   Subroutine : SB.FILE.OPEN.ERROR
12373: e890: \***
12374: e890: \***   Purpose    : Log an event 6 with unique data indicating an error has
12375: e890: \***                occurred whilst attempting to open a file.
12376: e890: \***
12377: e890: \***   Parameters : 1
12378: e890: \***
12379: e890: \***      CURR.SESS.NUM% = file session number of the file that caused the
12380: e890: \***                       error, this is used to look-up the file reporting
12381: e890: \***                       number that is logged in the event's unique data.
12382: e890: \***
12383: e890: \***   Output     : none
12384: e890: \***
12385: e890: \***   Error action : none
12386: e890: \***
12387: e890: \******************************************************************************
12388: e890: 
12389: e890:    SB.FILE.OPEN.ERROR:
12390: e8a0: 
12391: e8a0:       SB.ACTION$ = "R"
12392: e8b5:       SB.INTEGER% = CURR.SESS.NUM%
12393: e8c4:       SB.STRING$ = ""
12394: e8d9:       GOSUB SB.FILE.UTILS
12395: e8eb:       SB.EVENT.NO% = 106
12396: e8f8:       SB.UNIQUE$ = "O" + CHR$(SHIFT(SB.FILE.REP.NUM%,8)) +            \
12397: e960:                         CHR$(SHIFT(SB.FILE.REP.NUM%,0)) +            \
12398: e960:                              PACK$(STRING$(14,"0"))
12399: e960:       GOSUB SB.LOG.AN.EVENT
12400: e972: 
12401: e972:    RETURN
12402: e982: 
12403: e982: 
12404: e982: \******************************************************************************
12405: e982: \***
12406: e982: \***   Subroutine : SB.FILE.READ.ERROR
12407: e982: \***
12408: e982: \***   Purpose    : Log an event 6 with unique data indicating an error has
12409: e982: \***                occurred whilst attempting to read a file.
12410: e982: \***
12411: e982: \***   Parameters : 2
12412: e982: \***
12413: e982: \***      CURR.SESS.NUM%  = file session number of the file that caused the
12414: e982: \***                        error, this is used to look-up the file reporting
12415: e982: \***                        number that is logged in the event's unique data.
12416: e982: \***      CURRENT.KEY$    = value of key used to try to read from file.
12417: e982: \***
12418: e982: \***   Output     : none
12419: e982: \***
12420: e982: \***   Error action : none
12421: e982: \***
12422: e982: \******************************************************************************
12423: e982: 
12424: e982:   SB.FILE.READ.ERROR:
12425: e992: 
12426: e992:       SB.ACTION$ = "R"
12427: e9a7:       SB.INTEGER% = CURR.SESS.NUM%
12428: e9b6:       SB.STRING$ = ""
12429: e9cb:       GOSUB SB.FILE.UTILS
12430: e9dd:       SB.EVENT.NO% = 106
12431: e9ea:       SB.UNIQUE$ = "R" + CHR$(SHIFT(SB.FILE.REP.NUM%,8)) +            \
12432: ea55:                         CHR$(SHIFT(SB.FILE.REP.NUM%,0)) +            \
12433: ea55:                         PACK$(FN.Z.PACK(CURRENT.KEY$,14))
12434: ea55:       GOSUB SB.LOG.AN.EVENT
12435: ea67: 
12436: ea67:    RETURN
12437: ea77: 
12438: ea77: \******************************************************************************
12439: ea77: \***
12440: ea77: \***   Subroutine : SB.FILE.WRITE.ERROR
12441: ea77: \***
12442: ea77: \***   Purpose    : Log an event 6 with unique data indicating an error has
12443: ea77: \***                occurred whilst attempting to write a file.
12444: ea77: \***
12445: ea77: \***   Parameters : 2
12446: ea77: \***
12447: ea77: \***      CURR.SESS.NUM%  = file session number of the file that caused the
12448: ea77: \***                        error, this is used to look-up the file reporting
12449: ea77: \***                        number that is logged in the event's unique data.
12450: ea77: \***    CURRENT.KEY$    = value of key used to try to write to file.
12451: ea77: \***
12452: ea77: \***   Output     : none
12453: ea77: \***
12454: ea77: \***   Error action : none
12455: ea77: \***
12456: ea77: \******************************************************************************
12457: ea77: 
12458: ea77:    SB.FILE.WRITE.ERROR:
12459: ea87: 
12460: ea87:       SB.ACTION$ = "R"
12461: ea9c:       SB.INTEGER% = CURR.SESS.NUM%
12462: eaab:       SB.STRING$ = ""
12463: eac0:       GOSUB SB.FILE.UTILS
12464: ead2:       SB.EVENT.NO% = 106
12465: eadf:       SB.UNIQUE$ = "W" + CHR$(SHIFT(SB.FILE.REP.NUM%,8)) +            \
12466: eb4a:                         CHR$(SHIFT(SB.FILE.REP.NUM%,0)) +            \
12467: eb4a:                         PACK$(FN.Z.PACK(CURRENT.KEY$,14))
12468: eb4a:       GOSUB SB.LOG.AN.EVENT
12469: eb5c: 
12470: eb5c:    RETURN
12471: eb6c: 
12472: eb6c: \******************************************************************************
12473: eb6c: \***
12474: eb6c: \***   Subroutine : SB.FILE.CREATE.ERROR
12475: eb6c: \***
12476: eb6c: \***   Purpose    : Log an event 6 with unique data indicating an error has
12477: eb6c: \***                occurred whilst attempting to create a file.
12478: eb6c: \***
12479: eb6c: \***   Parameters : 2
12480: eb6c: \***
12481: eb6c: \***      CURR.SESS.NUM%  = file session number of the file that caused the
12482: eb6c: \***                        error, this is used to look-up the file reporting
12483: eb6c: \***                        number that is logged in the event's unique data.
12484: eb6c: \***
12485: eb6c: \***   Output     : none
12486: eb6c: \***
12487: eb6c: \***   Error action : none
12488: eb6c: \***
12489: eb6c: \******************************************************************************
12490: eb6c: 
12491: eb6c:    SB.FILE.CREATE.ERROR:
12492: eb7c: 
12493: eb7c:       SB.ACTION$ = "R"
12494: eb91:       SB.INTEGER% = CURR.SESS.NUM%
12495: eba0:       SB.STRING$ = ""
12496: ebb5:       GOSUB SB.FILE.UTILS
12497: ebc7:       SB.EVENT.NO% = 106
12498: ebd4:       SB.UNIQUE$ = "C" + CHR$(SHIFT(SB.FILE.REP.NUM%,8)) +            \
12499: ec3c:                          CHR$(SHIFT(SB.FILE.REP.NUM%,0)) +             \
12500: ec3c:                       PACK$(STRING$(14,"0"))
12501: ec3c:       GOSUB SB.LOG.AN.EVENT
12502: ec4e: 
12503: ec4e:    RETURN
12504: ec5e: 
12505: ec5e: \******************************************************************************
12506: ec5e: \***
12507: ec5e: \***   Subroutine : SB.CALC.BOOTS.CHECK.DIGIT
12508: ec5e: \***
12509: ec5e: \***   Purpose    : calculate boots check digit from a six byte string
12510: ec5e: \***                containing a boots code
12511: ec5e: \***
12512: ec5e: \***   Parameters : 1
12513: ec5e: \***      SB.BOOTS.ITEM$ = 6 character boots code (cccccc)
12514: ec5e: \***
12515: ec5e: \***   Output     : 1
12516: ec5e: \***      SB.BOOTS.CODE$      = 7 character boots code (ccccccc)
12517: ec5e: \***
12518: ec5e: \***   Error action : end program if called function fails
12519: ec5e: \***
12520: ec5e: \******************************************************************************
12521: ec5e: 
12522: ec5e: SB.CALC.BOOTS.CHECK.DIGIT:
12523: ec6e: 
12524: ec6e:       RC% = CALC.BOOTS.CODE.CHECK.DIGIT(SB.BOOTS.ITEM$)
12525: ec8d:       IF RC% <> 0 THEN GOTO PROGRAM.EXIT
12526: eca2: 
12527: eca2:       SB.BOOTS.CODE$ = SB.BOOTS.ITEM$ + F18.CHECK.DIGIT$
12528: ecc9: 
12529: ecc9: RETURN
12530: ecd9: 
12531: ecd9: \******************************************************************************
12532: ecd9: \******************************************************************************
12533: ecd9: \***                                                                        ***
12534: ecd9: \***                                                                        ***
12535: ecd9: \***   E R R O R   H A N D L I N G                                          ***
12536: ecd9: \***                                                                        ***
12537: ecd9: \***                                                                        ***
12538: ecd9: \******************************************************************************
12539: ecd9: \******************************************************************************
12540: ecd9: 
12541: ecd9: \******************************************************************************
12542: ecd9: \***
12543: ecd9: \***   OPEN.ERROR:
12544: ecd9: \***
12545: ecd9: \***      log an event 6 (open error)
12546: ecd9: \***      set RECEIVE.STATE$ to "*"
12547: ecd9: \***
12548: ecd9: \***      if the source of the error is known then return to one of the
12549: ecd9: \***      specified return points so the program does not end
12550: ecd9: \***
12551: ecd9: \***   GOTO MODULE.EXIT (no return is possible)
12552: ecd9: \***
12553: ecd9: \******************************************************************************
12554: ecd9: 
12555: ecd9:    OPEN.ERROR:
12556: ece9: 
12557: ece9:       TEMP.STATE$ = RECEIVE.STATE$
12558: ed05:       GOSUB SB.FILE.OPEN.ERROR
12559: ed17:       IF RECEIVE.STATE$ <> "?" THEN RECEIVE.STATE$ = "*"
12560: ed44: 
12561: ed44:       GOTO MODULE.EXIT
12562: ed4f: 
12563: ed4f: 
12564: ed4f: \******************************************************************************
12565: ed4f: \***
12566: ed4f: \***   READ.ERROR:
12567: ed4f: \***
12568: ed4f: \***      log an event 6 (read error)
12569: ed4f: \***      set RECEIVE.STATE$ to "*"
12570: ed4f: \***
12571: ed4f: \***   GOTO MODULE.EXIT (no return is possible)
12572: ed4f: \***
12573: ed4f: \******************************************************************************
12574: ed4f: 
12575: ed4f:    READ.ERROR:
12576: ed5f: 
12577: ed5f:       TEMP.STATE$ = RECEIVE.STATE$
12578: ed7b:       GOSUB SB.FILE.READ.ERROR
12579: ed8d:       IF RECEIVE.STATE$ <> "?" THEN RECEIVE.STATE$ = "*"
12580: edba: 
12581: edba:       GOTO MODULE.EXIT
12582: edc5: 
12583: edc5: 
12584: edc5: \******************************************************************************
12585: edc5: \***
12586: edc5: \***   WRITE.ERROR:
12587: edc5: \***
12588: edc5: \***      log an event 6 (write error)
12589: edc5: \***      set RECEIVE.STATE$ to "*"
12590: edc5: \***
12591: edc5: \***      if the source of the error is known then return to one of the
12592: edc5: \***      specified return points so the program does not end
12593: edc5: \***
12594: edc5: \***   GOTO MODULE.EXIT (no return is possible)
12595: edc5: \***
12596: edc5: \******************************************************************************
12597: edc5: 
12598: edc5:    WRITE.ERROR:
12599: edd5: 
12600: edd5:       TEMP.STATE$ = RECEIVE.STATE$
12601: edf1:       GOSUB SB.FILE.WRITE.ERROR
12602: ee03:       IF RECEIVE.STATE$ <> "?" THEN RECEIVE.STATE$ = "*"
12603: ee30: 
12604: ee30:    GOTO MODULE.EXIT
12605: ee3b: 
12606: ee3b: 
12607: ee3b: \******************************************************************************
12608: ee3b: \***
12609: ee3b: \***   CREATE.ERROR:
12610: ee3b: \***
12611: ee3b: \***      log an event 6 (create error)
12612: ee3b: \***      set RECEIVE.STATE$ to "*"
12613: ee3b: \***
12614: ee3b: \***      if the source of the error is known then return to one of the
12615: ee3b: \***      specified return points so the program does not end
12616: ee3b: \***
12617: ee3b: \***   GOTO MODULE.EXIT (no return is possible)
12618: ee3b: \***
12619: ee3b: \******************************************************************************
12620: ee3b: 
12621: ee3b:    CREATE.ERROR:
12622: ee4b: 
12623: ee4b:       TEMP.STATE$ = RECEIVE.STATE$
12624: ee67:       GOSUB SB.FILE.CREATE.ERROR
12625: ee79:       IF RECEIVE.STATE$ <> "?" THEN RECEIVE.STATE$ = "*"
12626: eea6: 
12627: eea6:    GOTO MODULE.EXIT
12628: eeb1: 
12629: eeb1: 
12630: eeb1: \******************************************************************************
12631: eeb1: \***
12632: eeb1: \***   ERROR.DETECTED:
12633: eeb1: \***
12634: eeb1: \***      if an error has occurred after a 'fatal' error then quit program
12635: eeb1: \***      if SIZE error has occurred (00000052h) and is not against the BCSF
12636: eeb1: \***       then resume with next command
12637: eeb1: \***
12638: eeb1: \***      increment ERROR.COUNT%
12639: eeb1: \***      NOTE : all returns from error detected should decrement the
12640: eeb1: \***             variable ERROR.COUNT% and exit using the RESUME command
12641: eeb1: \***      if ERROR.COUNT% > 1 then end program (error within error detected)
12642: eeb1: \***
12643: eeb1: \***      set-up common error reporting information
12644: eeb1: \***
12645: eeb1: \***      if an access conflict occurs on a session then retry
12646: eeb1: \***
12647: eeb1: \***      if error is out of memory then log an event, using ADXERROR and
12648: eeb1: \***      quit program
12649: eeb1: \***
12650: eeb1: \***      log an event 1
12651: eeb1: \***
12652: eeb1: \***   resume MODULE.EXIT
12653: eeb1: \***
12654: eeb1: \******************************************************************************
12655: eeb1: 
12656: eeb1: ERROR.DETECTED:
12657: eec1: 
12658: eec1:    IF ERR = "CU" OR ERR = "DF" THEN RESUME
12659: ef2f:    IF (ERRN = 00000052h) AND (ERRF%<>BCSMF.SESS.NUM%) THEN RESUME
12660: ef7d: 
12661: ef7d:    ERROR.COUNT% = ERROR.COUNT% + 1
12662: ef8c:    IF ERROR.COUNT% > 1 THEN RESUME PROGRAM.EXIT
12663: efad: 
12664: efad:    GOSUB SB.FORMAT.ERROR.DATA
12665: efbf: 
12666: efbf:    IF (ERRN AND 0000FFFFh) = 400Ch THEN BEGIN
12667: eff9:       ERROR.COUNT% = ERROR.COUNT% - 1
12668: f008:       RESUME RETRY
12669: f01f:    ENDIF
12670: f027: 
12671: f027:    IF ERR = "OM" THEN BEGIN
12672: f050:       SB.UNIQUE$ = SB.ERRS$ + SB.ERRF$ +                             \
12673: f0b0:                    PACK$(RIGHT$(STRING$(8,"0")+SB.ERRL$,8))
12674: f0b0:       CALL ADXERROR(0, 74, 0, 3, 101, SB.UNIQUE$ )
12675: f0d8:       ERROR.COUNT% = ERROR.COUNT% - 1
12676: f0e7:       RESUME PROGRAM.EXIT
12677: f0fe:    ENDIF
12678: f106: 
12679: f106:    SB.EVENT.NO% = 101
12680: f113:    SB.UNIQUE$ = SB.ERRS$ + SB.ERRF$ +                                    \
12681: f173:                 PACK$(RIGHT$(STRING$(8,"0")+SB.ERRL$,8))
12682: f173:    GOSUB SB.LOG.AN.EVENT
12683: f185: 
12684: f185:    ERROR.COUNT% = ERROR.COUNT% - 1
12685: f194:    RECEIVE.STATE$ = "*"
12686: f1ab:    RESUME MODULE.EXIT
12687: f1c2: 
12688: f1c2: END SUB
12689: f1d6: End of Compilation
